{"before": "/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.dx.dex;\n\n/**\n * Constants that show up in and are otherwise related to {@code .dex}\n * files, and helper methods for same.\n */\npublic final class DexFormat {\n    private DexFormat() {}\n\n    /**\n     * API level to target in order to produce the most modern file\n     * format\n     */\n    \n\n    /** API level to target in order to suppress extended opcode usage */\n    public static final int API_NO_EXTENDED_OPCODES = 13;\n\n    /**\n     * file name of the primary {@code .dex} file inside an\n     * application or library {@code .jar} file\n     */\n    public static final String DEX_IN_JAR_NAME = \"classes.dex\";\n\n    /** common prefix for all dex file \"magic numbers\" */\n    public static final String MAGIC_PREFIX = \"dex\\n\";\n\n    /** common suffix for all dex file \"magic numbers\" */\n    public static final String MAGIC_SUFFIX = \"\\0\";\n\n    /** dex file version number for the current format variant */\n    public static final String VERSION_CURRENT = \"036\";\n\n    /** dex file version number for API level 13 and earlier */\n    public static final String VERSION_FOR_API_13 = \"035\";\n\n    /**\n     * value used to indicate endianness of file contents\n     */\n    public static final int ENDIAN_TAG = 0x12345678;\n\n    /**\n     * Returns the API level corresponding to the given magic number,\n     * or {@code -1} if the given array is not a well-formed dex file\n     * magic number.\n     */\n    public static int magicToApi(byte[] magic) {\n        if (magic.length != 8) {\n            return -1;\n        }\n\n        if ((magic[0] != 'd') || (magic[1] != 'e') || (magic[2] != 'x') || (magic[3] != '\\n') ||\n                (magic[7] != '\\0')) {\n            return -1;\n        }\n\n        String version = \"\" + ((char) magic[4]) + ((char) magic[5]) +((char) magic[6]);\n\n        if (version.equals(VERSION_CURRENT)) {\n            return 14;\n        } else if (version.equals(VERSION_FOR_API_13)) {\n            return 13;\n        }\n\n        return -1;\n    }\n\n    /**\n     * Returns the magic number corresponding to the given target API level.\n     */\n    public static String apiToMagic(int targetApiLevel) {\n        String version;\n\n        if (targetApiLevel >= 14) {\n            version = VERSION_CURRENT;\n        } else {\n            version = VERSION_FOR_API_13;\n        }\n\n        return MAGIC_PREFIX + version + MAGIC_SUFFIX;\n    }\n}\n", "after": "/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.dx.dex;\n\n/**\n * Constants that show up in and are otherwise related to {@code .dex}\n * files, and helper methods for same.\n */\npublic final class DexFormat {\n    private DexFormat() {}\n\n    /**\n     * API level to target in order to produce the most modern file\n     * format\n     */\n    public static final int API_CURRENT = 14;\n\n    /** API level to target in order to suppress extended opcode usage */\n    public static final int API_NO_EXTENDED_OPCODES = 13;\n\n    /**\n     * file name of the primary {@code .dex} file inside an\n     * application or library {@code .jar} file\n     */\n    public static final String DEX_IN_JAR_NAME = \"classes.dex\";\n\n    /** common prefix for all dex file \"magic numbers\" */\n    public static final String MAGIC_PREFIX = \"dex\\n\";\n\n    /** common suffix for all dex file \"magic numbers\" */\n    public static final String MAGIC_SUFFIX = \"\\0\";\n\n    /** dex file version number for the current format variant */\n    public static final String VERSION_CURRENT = \"036\";\n\n    /** dex file version number for API level 13 and earlier */\n    public static final String VERSION_FOR_API_13 = \"035\";\n\n    /**\n     * value used to indicate endianness of file contents\n     */\n    public static final int ENDIAN_TAG = 0x12345678;\n\n    /**\n     * Returns the API level corresponding to the given magic number,\n     * or {@code -1} if the given array is not a well-formed dex file\n     * magic number.\n     */\n    public static int magicToApi(byte[] magic) {\n        if (magic.length != 8) {\n            return -1;\n        }\n\n        if ((magic[0] != 'd') || (magic[1] != 'e') || (magic[2] != 'x') || (magic[3] != '\\n') ||\n                (magic[7] != '\\0')) {\n            return -1;\n        }\n\n        String version = \"\" + ((char) magic[4]) + ((char) magic[5]) +((char) magic[6]);\n\n        if (version.equals(VERSION_CURRENT)) {\n            return API_CURRENT;\n        } else if (version.equals(VERSION_FOR_API_13)) {\n            return 13;\n        }\n\n        return -1;\n    }\n\n    /**\n     * Returns the magic number corresponding to the given target API level.\n     */\n    public static String apiToMagic(int targetApiLevel) {\n        String version;\n\n        if (targetApiLevel >= API_CURRENT) {\n            version = VERSION_CURRENT;\n        } else {\n            version = VERSION_FOR_API_13;\n        }\n\n        return MAGIC_PREFIX + version + MAGIC_SUFFIX;\n    }\n}\n"}
{"before": "/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.dx.cf.direct;\n\nimport com.android.dx.cf.attrib.AttSourceFile;\nimport com.android.dx.cf.cst.ConstantPoolParser;\nimport com.android.dx.cf.iface.Attribute;\nimport com.android.dx.cf.iface.AttributeList;\nimport com.android.dx.cf.iface.ClassFile;\nimport com.android.dx.cf.iface.FieldList;\nimport com.android.dx.cf.iface.MethodList;\nimport com.android.dx.cf.iface.ParseException;\nimport com.android.dx.cf.iface.ParseObserver;\nimport com.android.dx.cf.iface.StdAttributeList;\nimport com.android.dx.rop.code.AccessFlags;\nimport com.android.dx.rop.cst.ConstantPool;\nimport com.android.dx.rop.cst.CstString;\nimport com.android.dx.rop.cst.CstType;\nimport com.android.dx.rop.cst.StdConstantPool;\nimport com.android.dx.rop.type.StdTypeList;\nimport com.android.dx.rop.type.Type;\nimport com.android.dx.rop.type.TypeList;\nimport com.android.dx.util.ByteArray;\nimport com.android.dx.util.Hex;\n\n/**\n * Class file with info taken from a {@code byte[]} or slice thereof.\n */\npublic class DirectClassFile implements ClassFile {\n    /** the expected value of the ClassFile.magic field */\n    \n\n    /**\n     * minimum {@code .class} file major version\n     *\n     * See http://en.wikipedia.org/wiki/Java_class_file for an up-to-date\n     * list of version numbers. Currently known (taken from that table) are:\n     *\n     *     J2SE 7.0 = 51 (0x33 hex),\n     *     J2SE 6.0 = 50 (0x32 hex),\n     *     J2SE 5.0 = 49 (0x31 hex),\n     *     JDK 1.4 = 48 (0x30 hex),\n     *     JDK 1.3 = 47 (0x2F hex),\n     *     JDK 1.2 = 46 (0x2E hex),\n     *     JDK 1.1 = 45 (0x2D hex).\n     *\n     * Valid ranges are typically of the form\n     * \"A.0 through B.C inclusive\" where A <= B and C >= 0,\n     * which is why we don't have a CLASS_FILE_MIN_MINOR_VERSION.\n     */\n    private static final int CLASS_FILE_MIN_MAJOR_VERSION = 45;\n\n    /**\n     * maximum {@code .class} file major version\n     *\n     * Note: if you change this, please change \"java.class.version\" in System.java.\n     */\n    private static final int CLASS_FILE_MAX_MAJOR_VERSION = 51;\n\n    /** maximum {@code .class} file minor version */\n    private static final int CLASS_FILE_MAX_MINOR_VERSION = 0;\n\n    /**\n     * {@code non-null;} the file path for the class, excluding any base directory\n     * specification\n     */\n    private final String filePath;\n\n    /** {@code non-null;} the bytes of the file */\n    private final ByteArray bytes;\n\n    /**\n     * whether to be strict about parsing; if\n     * {@code false}, this avoids doing checks that only exist\n     * for purposes of verification (such as magic number matching and\n     * path-package consistency checking)\n     */\n    private final boolean strictParse;\n\n    /**\n     * {@code null-ok;} the constant pool; only ever {@code null}\n     * before the constant pool is successfully parsed\n     */\n    private StdConstantPool pool;\n\n    /**\n     * the class file field {@code access_flags}; will be {@code -1}\n     * before the file is successfully parsed\n     */\n    private int accessFlags;\n\n    /**\n     * {@code null-ok;} the class file field {@code this_class},\n     * interpreted as a type constant; only ever {@code null}\n     * before the file is successfully parsed\n     */\n    private CstType thisClass;\n\n    /**\n     * {@code null-ok;} the class file field {@code super_class}, interpreted\n     * as a type constant if non-zero\n     */\n    private CstType superClass;\n\n    /**\n     * {@code null-ok;} the class file field {@code interfaces}; only\n     * ever {@code null} before the file is successfully\n     * parsed\n     */\n    private TypeList interfaces;\n\n    /**\n     * {@code null-ok;} the class file field {@code fields}; only ever\n     * {@code null} before the file is successfully parsed\n     */\n    private FieldList fields;\n\n    /**\n     * {@code null-ok;} the class file field {@code methods}; only ever\n     * {@code null} before the file is successfully parsed\n     */\n    private MethodList methods;\n\n    /**\n     * {@code null-ok;} the class file field {@code attributes}; only\n     * ever {@code null} before the file is successfully\n     * parsed\n     */\n    private StdAttributeList attributes;\n\n    /** {@code null-ok;} attribute factory, if any */\n    private AttributeFactory attributeFactory;\n\n    /** {@code null-ok;} parse observer, if any */\n    private ParseObserver observer;\n\n    /**\n     * Returns the string form of an object or {@code \"(none)\"}\n     * (rather than {@code \"null\"}) for {@code null}.\n     *\n     * @param obj {@code null-ok;} the object to stringify\n     * @return {@code non-null;} the appropriate string form\n     */\n    public static String stringOrNone(Object obj) {\n        if (obj == null) {\n            return \"(none)\";\n        }\n\n        return obj.toString();\n    }\n\n    /**\n     * Constructs an instance.\n     *\n     * @param bytes {@code non-null;} the bytes of the file\n     * @param filePath {@code non-null;} the file path for the class,\n     * excluding any base directory specification\n     * @param strictParse whether to be strict about parsing; if\n     * {@code false}, this avoids doing checks that only exist\n     * for purposes of verification (such as magic number matching and\n     * path-package consistency checking)\n     */\n    public DirectClassFile(ByteArray bytes, String filePath,\n                           boolean strictParse) {\n        if (bytes == null) {\n            throw new NullPointerException(\"bytes == null\");\n        }\n\n        if (filePath == null) {\n            throw new NullPointerException(\"filePath == null\");\n        }\n\n        this.filePath = filePath;\n        this.bytes = bytes;\n        this.strictParse = strictParse;\n        this.accessFlags = -1;\n    }\n\n    /**\n     * Constructs an instance.\n     *\n     * @param bytes {@code non-null;} the bytes of the file\n     * @param filePath {@code non-null;} the file path for the class,\n     * excluding any base directory specification\n     * @param strictParse whether to be strict about parsing; if\n     * {@code false}, this avoids doing checks that only exist\n     * for purposes of verification (such as magic number matching and\n     * path-package consistency checking)\n     */\n    public DirectClassFile(byte[] bytes, String filePath,\n                           boolean strictParse) {\n        this(new ByteArray(bytes), filePath, strictParse);\n    }\n\n    /**\n     * Sets the parse observer for this instance.\n     *\n     * @param observer {@code null-ok;} the observer\n     */\n    public void setObserver(ParseObserver observer) {\n        this.observer = observer;\n    }\n\n    /**\n     * Sets the attribute factory to use.\n     *\n     * @param attributeFactory {@code non-null;} the attribute factory\n     */\n    public void setAttributeFactory(AttributeFactory attributeFactory) {\n        if (attributeFactory == null) {\n            throw new NullPointerException(\"attributeFactory == null\");\n        }\n\n        this.attributeFactory = attributeFactory;\n    }\n\n    /**\n     * Gets the path where this class file is located.\n     *\n     * @return {@code non-null;} the filePath\n     */\n    public String getFilePath() {\n      return filePath;\n    }\n\n    /**\n     * Gets the {@link ByteArray} that this instance's data comes from.\n     *\n     * @return {@code non-null;} the bytes\n     */\n    public ByteArray getBytes() {\n        return bytes;\n    }\n\n    /** {@inheritDoc} */\n    public int getMagic() {\n        parseToInterfacesIfNecessary();\n        return getMagic0();\n    }\n\n    /** {@inheritDoc} */\n    public int getMinorVersion() {\n        parseToInterfacesIfNecessary();\n        return getMinorVersion0();\n    }\n\n    /** {@inheritDoc} */\n    public int getMajorVersion() {\n        parseToInterfacesIfNecessary();\n        return getMajorVersion0();\n    }\n\n    /** {@inheritDoc} */\n    public int getAccessFlags() {\n        parseToInterfacesIfNecessary();\n        return accessFlags;\n    }\n\n    /** {@inheritDoc} */\n    public CstType getThisClass() {\n        parseToInterfacesIfNecessary();\n        return thisClass;\n    }\n\n    /** {@inheritDoc} */\n    public CstType getSuperclass() {\n        parseToInterfacesIfNecessary();\n        return superClass;\n    }\n\n    /** {@inheritDoc} */\n    public ConstantPool getConstantPool() {\n        parseToInterfacesIfNecessary();\n        return pool;\n    }\n\n    /** {@inheritDoc} */\n    public TypeList getInterfaces() {\n        parseToInterfacesIfNecessary();\n        return interfaces;\n    }\n\n    /** {@inheritDoc} */\n    public FieldList getFields() {\n        parseToEndIfNecessary();\n        return fields;\n    }\n\n    /** {@inheritDoc} */\n    public MethodList getMethods() {\n        parseToEndIfNecessary();\n        return methods;\n    }\n\n    /** {@inheritDoc} */\n    public AttributeList getAttributes() {\n        parseToEndIfNecessary();\n        return attributes;\n    }\n\n    /** {@inheritDoc} */\n    public CstString getSourceFile() {\n        AttributeList attribs = getAttributes();\n        Attribute attSf = attribs.findFirst(AttSourceFile.ATTRIBUTE_NAME);\n\n        if (attSf instanceof AttSourceFile) {\n            return ((AttSourceFile) attSf).getSourceFile();\n        }\n\n        return null;\n    }\n\n    /**\n     * Constructs and returns an instance of {@link TypeList} whose\n     * data comes from the bytes of this instance, interpreted as a\n     * list of constant pool indices for classes, which are in turn\n     * translated to type constants. Instance construction will fail\n     * if any of the (alleged) indices turn out not to refer to\n     * constant pool entries of type {@code Class}.\n     *\n     * @param offset offset into {@link #bytes} for the start of the\n     * data\n     * @param size number of elements in the list (not number of bytes)\n     * @return {@code non-null;} an appropriately-constructed class list\n     */\n    public TypeList makeTypeList(int offset, int size) {\n        if (size == 0) {\n            return StdTypeList.EMPTY;\n        }\n\n        if (pool == null) {\n            throw new IllegalStateException(\"pool not yet initialized\");\n        }\n\n        return new DcfTypeList(bytes, offset, size, pool, observer);\n    }\n\n    /**\n     * Gets the class file field {@code magic}, but without doing any\n     * checks or parsing first.\n     *\n     * @return the magic value\n     */\n    public int getMagic0() {\n        return bytes.getInt(0);\n    }\n\n    /**\n     * Gets the class file field {@code minor_version}, but\n     * without doing any checks or parsing first.\n     *\n     * @return the minor version\n     */\n    public int getMinorVersion0() {\n        return bytes.getUnsignedShort(4);\n    }\n\n    /**\n     * Gets the class file field {@code major_version}, but\n     * without doing any checks or parsing first.\n     *\n     * @return the major version\n     */\n    public int getMajorVersion0() {\n        return bytes.getUnsignedShort(6);\n    }\n\n    /**\n     * Runs {@link #parse} if it has not yet been run to cover up to\n     * the interfaces list.\n     */\n    private void parseToInterfacesIfNecessary() {\n        if (accessFlags == -1) {\n            parse();\n        }\n    }\n\n    /**\n     * Runs {@link #parse} if it has not yet been run successfully.\n     */\n    private void parseToEndIfNecessary() {\n        if (attributes == null) {\n            parse();\n        }\n    }\n\n    /**\n     * Does the parsing, handing exceptions.\n     */\n    private void parse() {\n        try {\n            parse0();\n        } catch (ParseException ex) {\n            ex.addContext(\"...while parsing \" + filePath);\n            throw ex;\n        } catch (RuntimeException ex) {\n            ParseException pe = new ParseException(ex);\n            pe.addContext(\"...while parsing \" + filePath);\n            throw pe;\n        }\n    }\n\n    /**\n     * Sees if the .class file header magic has the good value.\n     *\n     * @param magic the value of a classfile \"magic\" field\n     * @return true if the magic is valid\n     */\n    private boolean isGoodMagic(int magic) {\n        return magic == 0xcafebabe;\n    }\n\n    /**\n     * Sees if the .class file header version are within\n     * range.\n     *\n     * @param minorVersion the value of a classfile \"minor_version\" field\n     * @param majorVersion the value of a classfile \"major_version\" field\n     * @return true if the parameters are valid and within range\n     */\n    private boolean isGoodVersion(int minorVersion, int majorVersion) {\n        /* Valid version ranges are typically of the form\n         * \"A.0 through B.C inclusive\" where A <= B and C >= 0,\n         * which is why we don't have a CLASS_FILE_MIN_MINOR_VERSION.\n         */\n        if (minorVersion >= 0) {\n            /* Check against max first to handle the case where\n             * MIN_MAJOR == MAX_MAJOR.\n             */\n            if (majorVersion == CLASS_FILE_MAX_MAJOR_VERSION) {\n                if (minorVersion <= CLASS_FILE_MAX_MINOR_VERSION) {\n                    return true;\n                }\n            } else if (majorVersion < CLASS_FILE_MAX_MAJOR_VERSION &&\n                       majorVersion >= CLASS_FILE_MIN_MAJOR_VERSION) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Does the actual parsing.\n     */\n    private void parse0() {\n        if (bytes.size() < 10) {\n            throw new ParseException(\"severely truncated class file\");\n        }\n\n        if (observer != null) {\n            observer.parsed(bytes, 0, 0, \"begin classfile\");\n            observer.parsed(bytes, 0, 4, \"magic: \" + Hex.u4(getMagic0()));\n            observer.parsed(bytes, 4, 2,\n                            \"minor_version: \" + Hex.u2(getMinorVersion0()));\n            observer.parsed(bytes, 6, 2,\n                            \"major_version: \" + Hex.u2(getMajorVersion0()));\n        }\n\n        if (strictParse) {\n            /* Make sure that this looks like a valid class file with a\n             * version that we can handle.\n             */\n            if (!isGoodMagic(getMagic0())) {\n                throw new ParseException(\"bad class file magic (\" + Hex.u4(getMagic0()) + \")\");\n            }\n\n            if (!isGoodVersion(getMinorVersion0(), getMajorVersion0())) {\n                throw new ParseException(\"unsupported class file version \" +\n                                         getMajorVersion0() + \".\" +\n                                         getMinorVersion0());\n            }\n        }\n\n        ConstantPoolParser cpParser = new ConstantPoolParser(bytes);\n        cpParser.setObserver(observer);\n        pool = cpParser.getPool();\n        pool.setImmutable();\n\n        int at = cpParser.getEndOffset();\n        int accessFlags = bytes.getUnsignedShort(at); // u2 access_flags;\n        int cpi = bytes.getUnsignedShort(at + 2); // u2 this_class;\n        thisClass = (CstType) pool.get(cpi);\n        cpi = bytes.getUnsignedShort(at + 4); // u2 super_class;\n        superClass = (CstType) pool.get0Ok(cpi);\n        int count = bytes.getUnsignedShort(at + 6); // u2 interfaces_count\n\n        if (observer != null) {\n            observer.parsed(bytes, at, 2,\n                            \"access_flags: \" +\n                            AccessFlags.classString(accessFlags));\n            observer.parsed(bytes, at + 2, 2, \"this_class: \" + thisClass);\n            observer.parsed(bytes, at + 4, 2, \"super_class: \" +\n                            stringOrNone(superClass));\n            observer.parsed(bytes, at + 6, 2,\n                            \"interfaces_count: \" + Hex.u2(count));\n            if (count != 0) {\n                observer.parsed(bytes, at + 8, 0, \"interfaces:\");\n            }\n        }\n\n        at += 8;\n        interfaces = makeTypeList(at, count);\n        at += count * 2;\n\n        if (strictParse) {\n            /*\n             * Make sure that the file/jar path matches the declared\n             * package/class name.\n             */\n            String thisClassName = thisClass.getClassType().getClassName();\n            if (!(filePath.endsWith(\".class\") &&\n                  filePath.startsWith(thisClassName) &&\n                  (filePath.length() == (thisClassName.length() + 6)))) {\n                throw new ParseException(\"class name (\" + thisClassName +\n                                         \") does not match path (\" +\n                                         filePath + \")\");\n            }\n        }\n\n        /*\n         * Only set the instance variable accessFlags here, since\n         * that's what signals a successful parse of the first part of\n         * the file (through the interfaces list).\n         */\n        this.accessFlags = accessFlags;\n\n        FieldListParser flParser =\n            new FieldListParser(this, thisClass, at, attributeFactory);\n        flParser.setObserver(observer);\n        fields = flParser.getList();\n        at = flParser.getEndOffset();\n\n        MethodListParser mlParser =\n            new MethodListParser(this, thisClass, at, attributeFactory);\n        mlParser.setObserver(observer);\n        methods = mlParser.getList();\n        at = mlParser.getEndOffset();\n\n        AttributeListParser alParser =\n            new AttributeListParser(this, AttributeFactory.CTX_CLASS, at,\n                                    attributeFactory);\n        alParser.setObserver(observer);\n        attributes = alParser.getList();\n        attributes.setImmutable();\n        at = alParser.getEndOffset();\n\n        if (at != bytes.size()) {\n            throw new ParseException(\"extra bytes at end of class file, \" +\n                                     \"at offset \" + Hex.u4(at));\n        }\n\n        if (observer != null) {\n            observer.parsed(bytes, at, 0, \"end classfile\");\n        }\n    }\n\n    /**\n     * Implementation of {@link TypeList} whose data comes directly\n     * from the bytes of an instance of this (outer) class,\n     * interpreted as a list of constant pool indices for classes\n     * which are in turn returned as type constants. Instance\n     * construction will fail if any of the (alleged) indices turn out\n     * not to refer to constant pool entries of type\n     * {@code Class}.\n     */\n    private static class DcfTypeList implements TypeList {\n        /** {@code non-null;} array containing the data */\n        private final ByteArray bytes;\n\n        /** number of elements in the list (not number of bytes) */\n        private final int size;\n\n        /** {@code non-null;} the constant pool */\n        private final StdConstantPool pool;\n\n        /**\n         * Constructs an instance.\n         *\n         * @param bytes {@code non-null;} original classfile's bytes\n         * @param offset offset into {@link #bytes} for the start of the\n         * data\n         * @param size number of elements in the list (not number of bytes)\n         * @param pool {@code non-null;} the constant pool to use\n         * @param observer {@code null-ok;} parse observer to use, if any\n         */\n        public DcfTypeList(ByteArray bytes, int offset, int size,\n                StdConstantPool pool, ParseObserver observer) {\n            if (size < 0) {\n                throw new IllegalArgumentException(\"size < 0\");\n            }\n\n            bytes = bytes.slice(offset, offset + size * 2);\n            this.bytes = bytes;\n            this.size = size;\n            this.pool = pool;\n\n            for (int i = 0; i < size; i++) {\n                offset = i * 2;\n                int idx = bytes.getUnsignedShort(offset);\n                CstType type;\n                try {\n                    type = (CstType) pool.get(idx);\n                } catch (ClassCastException ex) {\n                    // Translate the exception.\n                    throw new RuntimeException(\"bogus class cpi\", ex);\n                }\n                if (observer != null) {\n                    observer.parsed(bytes, offset, 2, \"  \" + type);\n                }\n            }\n        }\n\n        /** {@inheritDoc} */\n        public boolean isMutable() {\n            return false;\n        }\n\n        /** {@inheritDoc} */\n        public int size() {\n            return size;\n        }\n\n        /** {@inheritDoc} */\n        public int getWordCount() {\n            // It is the same as size because all elements are classes.\n            return size;\n        }\n\n        /** {@inheritDoc} */\n        public Type getType(int n) {\n            int idx = bytes.getUnsignedShort(n * 2);\n            return ((CstType) pool.get(idx)).getClassType();\n        }\n\n        /** {@inheritDoc} */\n        public TypeList withAddedType(Type type) {\n            throw new UnsupportedOperationException(\"unsupported\");\n        }\n    }\n}\n", "after": "/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.dx.cf.direct;\n\nimport com.android.dx.cf.attrib.AttSourceFile;\nimport com.android.dx.cf.cst.ConstantPoolParser;\nimport com.android.dx.cf.iface.Attribute;\nimport com.android.dx.cf.iface.AttributeList;\nimport com.android.dx.cf.iface.ClassFile;\nimport com.android.dx.cf.iface.FieldList;\nimport com.android.dx.cf.iface.MethodList;\nimport com.android.dx.cf.iface.ParseException;\nimport com.android.dx.cf.iface.ParseObserver;\nimport com.android.dx.cf.iface.StdAttributeList;\nimport com.android.dx.rop.code.AccessFlags;\nimport com.android.dx.rop.cst.ConstantPool;\nimport com.android.dx.rop.cst.CstString;\nimport com.android.dx.rop.cst.CstType;\nimport com.android.dx.rop.cst.StdConstantPool;\nimport com.android.dx.rop.type.StdTypeList;\nimport com.android.dx.rop.type.Type;\nimport com.android.dx.rop.type.TypeList;\nimport com.android.dx.util.ByteArray;\nimport com.android.dx.util.Hex;\n\n/**\n * Class file with info taken from a {@code byte[]} or slice thereof.\n */\npublic class DirectClassFile implements ClassFile {\n    /** the expected value of the ClassFile.magic field */\n    private static final int CLASS_FILE_MAGIC = 0xcafebabe;\n\n    /**\n     * minimum {@code .class} file major version\n     *\n     * See http://en.wikipedia.org/wiki/Java_class_file for an up-to-date\n     * list of version numbers. Currently known (taken from that table) are:\n     *\n     *     J2SE 7.0 = 51 (0x33 hex),\n     *     J2SE 6.0 = 50 (0x32 hex),\n     *     J2SE 5.0 = 49 (0x31 hex),\n     *     JDK 1.4 = 48 (0x30 hex),\n     *     JDK 1.3 = 47 (0x2F hex),\n     *     JDK 1.2 = 46 (0x2E hex),\n     *     JDK 1.1 = 45 (0x2D hex).\n     *\n     * Valid ranges are typically of the form\n     * \"A.0 through B.C inclusive\" where A <= B and C >= 0,\n     * which is why we don't have a CLASS_FILE_MIN_MINOR_VERSION.\n     */\n    private static final int CLASS_FILE_MIN_MAJOR_VERSION = 45;\n\n    /**\n     * maximum {@code .class} file major version\n     *\n     * Note: if you change this, please change \"java.class.version\" in System.java.\n     */\n    private static final int CLASS_FILE_MAX_MAJOR_VERSION = 51;\n\n    /** maximum {@code .class} file minor version */\n    private static final int CLASS_FILE_MAX_MINOR_VERSION = 0;\n\n    /**\n     * {@code non-null;} the file path for the class, excluding any base directory\n     * specification\n     */\n    private final String filePath;\n\n    /** {@code non-null;} the bytes of the file */\n    private final ByteArray bytes;\n\n    /**\n     * whether to be strict about parsing; if\n     * {@code false}, this avoids doing checks that only exist\n     * for purposes of verification (such as magic number matching and\n     * path-package consistency checking)\n     */\n    private final boolean strictParse;\n\n    /**\n     * {@code null-ok;} the constant pool; only ever {@code null}\n     * before the constant pool is successfully parsed\n     */\n    private StdConstantPool pool;\n\n    /**\n     * the class file field {@code access_flags}; will be {@code -1}\n     * before the file is successfully parsed\n     */\n    private int accessFlags;\n\n    /**\n     * {@code null-ok;} the class file field {@code this_class},\n     * interpreted as a type constant; only ever {@code null}\n     * before the file is successfully parsed\n     */\n    private CstType thisClass;\n\n    /**\n     * {@code null-ok;} the class file field {@code super_class}, interpreted\n     * as a type constant if non-zero\n     */\n    private CstType superClass;\n\n    /**\n     * {@code null-ok;} the class file field {@code interfaces}; only\n     * ever {@code null} before the file is successfully\n     * parsed\n     */\n    private TypeList interfaces;\n\n    /**\n     * {@code null-ok;} the class file field {@code fields}; only ever\n     * {@code null} before the file is successfully parsed\n     */\n    private FieldList fields;\n\n    /**\n     * {@code null-ok;} the class file field {@code methods}; only ever\n     * {@code null} before the file is successfully parsed\n     */\n    private MethodList methods;\n\n    /**\n     * {@code null-ok;} the class file field {@code attributes}; only\n     * ever {@code null} before the file is successfully\n     * parsed\n     */\n    private StdAttributeList attributes;\n\n    /** {@code null-ok;} attribute factory, if any */\n    private AttributeFactory attributeFactory;\n\n    /** {@code null-ok;} parse observer, if any */\n    private ParseObserver observer;\n\n    /**\n     * Returns the string form of an object or {@code \"(none)\"}\n     * (rather than {@code \"null\"}) for {@code null}.\n     *\n     * @param obj {@code null-ok;} the object to stringify\n     * @return {@code non-null;} the appropriate string form\n     */\n    public static String stringOrNone(Object obj) {\n        if (obj == null) {\n            return \"(none)\";\n        }\n\n        return obj.toString();\n    }\n\n    /**\n     * Constructs an instance.\n     *\n     * @param bytes {@code non-null;} the bytes of the file\n     * @param filePath {@code non-null;} the file path for the class,\n     * excluding any base directory specification\n     * @param strictParse whether to be strict about parsing; if\n     * {@code false}, this avoids doing checks that only exist\n     * for purposes of verification (such as magic number matching and\n     * path-package consistency checking)\n     */\n    public DirectClassFile(ByteArray bytes, String filePath,\n                           boolean strictParse) {\n        if (bytes == null) {\n            throw new NullPointerException(\"bytes == null\");\n        }\n\n        if (filePath == null) {\n            throw new NullPointerException(\"filePath == null\");\n        }\n\n        this.filePath = filePath;\n        this.bytes = bytes;\n        this.strictParse = strictParse;\n        this.accessFlags = -1;\n    }\n\n    /**\n     * Constructs an instance.\n     *\n     * @param bytes {@code non-null;} the bytes of the file\n     * @param filePath {@code non-null;} the file path for the class,\n     * excluding any base directory specification\n     * @param strictParse whether to be strict about parsing; if\n     * {@code false}, this avoids doing checks that only exist\n     * for purposes of verification (such as magic number matching and\n     * path-package consistency checking)\n     */\n    public DirectClassFile(byte[] bytes, String filePath,\n                           boolean strictParse) {\n        this(new ByteArray(bytes), filePath, strictParse);\n    }\n\n    /**\n     * Sets the parse observer for this instance.\n     *\n     * @param observer {@code null-ok;} the observer\n     */\n    public void setObserver(ParseObserver observer) {\n        this.observer = observer;\n    }\n\n    /**\n     * Sets the attribute factory to use.\n     *\n     * @param attributeFactory {@code non-null;} the attribute factory\n     */\n    public void setAttributeFactory(AttributeFactory attributeFactory) {\n        if (attributeFactory == null) {\n            throw new NullPointerException(\"attributeFactory == null\");\n        }\n\n        this.attributeFactory = attributeFactory;\n    }\n\n    /**\n     * Gets the path where this class file is located.\n     *\n     * @return {@code non-null;} the filePath\n     */\n    public String getFilePath() {\n      return filePath;\n    }\n\n    /**\n     * Gets the {@link ByteArray} that this instance's data comes from.\n     *\n     * @return {@code non-null;} the bytes\n     */\n    public ByteArray getBytes() {\n        return bytes;\n    }\n\n    /** {@inheritDoc} */\n    public int getMagic() {\n        parseToInterfacesIfNecessary();\n        return getMagic0();\n    }\n\n    /** {@inheritDoc} */\n    public int getMinorVersion() {\n        parseToInterfacesIfNecessary();\n        return getMinorVersion0();\n    }\n\n    /** {@inheritDoc} */\n    public int getMajorVersion() {\n        parseToInterfacesIfNecessary();\n        return getMajorVersion0();\n    }\n\n    /** {@inheritDoc} */\n    public int getAccessFlags() {\n        parseToInterfacesIfNecessary();\n        return accessFlags;\n    }\n\n    /** {@inheritDoc} */\n    public CstType getThisClass() {\n        parseToInterfacesIfNecessary();\n        return thisClass;\n    }\n\n    /** {@inheritDoc} */\n    public CstType getSuperclass() {\n        parseToInterfacesIfNecessary();\n        return superClass;\n    }\n\n    /** {@inheritDoc} */\n    public ConstantPool getConstantPool() {\n        parseToInterfacesIfNecessary();\n        return pool;\n    }\n\n    /** {@inheritDoc} */\n    public TypeList getInterfaces() {\n        parseToInterfacesIfNecessary();\n        return interfaces;\n    }\n\n    /** {@inheritDoc} */\n    public FieldList getFields() {\n        parseToEndIfNecessary();\n        return fields;\n    }\n\n    /** {@inheritDoc} */\n    public MethodList getMethods() {\n        parseToEndIfNecessary();\n        return methods;\n    }\n\n    /** {@inheritDoc} */\n    public AttributeList getAttributes() {\n        parseToEndIfNecessary();\n        return attributes;\n    }\n\n    /** {@inheritDoc} */\n    public CstString getSourceFile() {\n        AttributeList attribs = getAttributes();\n        Attribute attSf = attribs.findFirst(AttSourceFile.ATTRIBUTE_NAME);\n\n        if (attSf instanceof AttSourceFile) {\n            return ((AttSourceFile) attSf).getSourceFile();\n        }\n\n        return null;\n    }\n\n    /**\n     * Constructs and returns an instance of {@link TypeList} whose\n     * data comes from the bytes of this instance, interpreted as a\n     * list of constant pool indices for classes, which are in turn\n     * translated to type constants. Instance construction will fail\n     * if any of the (alleged) indices turn out not to refer to\n     * constant pool entries of type {@code Class}.\n     *\n     * @param offset offset into {@link #bytes} for the start of the\n     * data\n     * @param size number of elements in the list (not number of bytes)\n     * @return {@code non-null;} an appropriately-constructed class list\n     */\n    public TypeList makeTypeList(int offset, int size) {\n        if (size == 0) {\n            return StdTypeList.EMPTY;\n        }\n\n        if (pool == null) {\n            throw new IllegalStateException(\"pool not yet initialized\");\n        }\n\n        return new DcfTypeList(bytes, offset, size, pool, observer);\n    }\n\n    /**\n     * Gets the class file field {@code magic}, but without doing any\n     * checks or parsing first.\n     *\n     * @return the magic value\n     */\n    public int getMagic0() {\n        return bytes.getInt(0);\n    }\n\n    /**\n     * Gets the class file field {@code minor_version}, but\n     * without doing any checks or parsing first.\n     *\n     * @return the minor version\n     */\n    public int getMinorVersion0() {\n        return bytes.getUnsignedShort(4);\n    }\n\n    /**\n     * Gets the class file field {@code major_version}, but\n     * without doing any checks or parsing first.\n     *\n     * @return the major version\n     */\n    public int getMajorVersion0() {\n        return bytes.getUnsignedShort(6);\n    }\n\n    /**\n     * Runs {@link #parse} if it has not yet been run to cover up to\n     * the interfaces list.\n     */\n    private void parseToInterfacesIfNecessary() {\n        if (accessFlags == -1) {\n            parse();\n        }\n    }\n\n    /**\n     * Runs {@link #parse} if it has not yet been run successfully.\n     */\n    private void parseToEndIfNecessary() {\n        if (attributes == null) {\n            parse();\n        }\n    }\n\n    /**\n     * Does the parsing, handing exceptions.\n     */\n    private void parse() {\n        try {\n            parse0();\n        } catch (ParseException ex) {\n            ex.addContext(\"...while parsing \" + filePath);\n            throw ex;\n        } catch (RuntimeException ex) {\n            ParseException pe = new ParseException(ex);\n            pe.addContext(\"...while parsing \" + filePath);\n            throw pe;\n        }\n    }\n\n    /**\n     * Sees if the .class file header magic has the good value.\n     *\n     * @param magic the value of a classfile \"magic\" field\n     * @return true if the magic is valid\n     */\n    private boolean isGoodMagic(int magic) {\n        return magic == CLASS_FILE_MAGIC;\n    }\n\n    /**\n     * Sees if the .class file header version are within\n     * range.\n     *\n     * @param minorVersion the value of a classfile \"minor_version\" field\n     * @param majorVersion the value of a classfile \"major_version\" field\n     * @return true if the parameters are valid and within range\n     */\n    private boolean isGoodVersion(int minorVersion, int majorVersion) {\n        /* Valid version ranges are typically of the form\n         * \"A.0 through B.C inclusive\" where A <= B and C >= 0,\n         * which is why we don't have a CLASS_FILE_MIN_MINOR_VERSION.\n         */\n        if (minorVersion >= 0) {\n            /* Check against max first to handle the case where\n             * MIN_MAJOR == MAX_MAJOR.\n             */\n            if (majorVersion == CLASS_FILE_MAX_MAJOR_VERSION) {\n                if (minorVersion <= CLASS_FILE_MAX_MINOR_VERSION) {\n                    return true;\n                }\n            } else if (majorVersion < CLASS_FILE_MAX_MAJOR_VERSION &&\n                       majorVersion >= CLASS_FILE_MIN_MAJOR_VERSION) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Does the actual parsing.\n     */\n    private void parse0() {\n        if (bytes.size() < 10) {\n            throw new ParseException(\"severely truncated class file\");\n        }\n\n        if (observer != null) {\n            observer.parsed(bytes, 0, 0, \"begin classfile\");\n            observer.parsed(bytes, 0, 4, \"magic: \" + Hex.u4(getMagic0()));\n            observer.parsed(bytes, 4, 2,\n                            \"minor_version: \" + Hex.u2(getMinorVersion0()));\n            observer.parsed(bytes, 6, 2,\n                            \"major_version: \" + Hex.u2(getMajorVersion0()));\n        }\n\n        if (strictParse) {\n            /* Make sure that this looks like a valid class file with a\n             * version that we can handle.\n             */\n            if (!isGoodMagic(getMagic0())) {\n                throw new ParseException(\"bad class file magic (\" + Hex.u4(getMagic0()) + \")\");\n            }\n\n            if (!isGoodVersion(getMinorVersion0(), getMajorVersion0())) {\n                throw new ParseException(\"unsupported class file version \" +\n                                         getMajorVersion0() + \".\" +\n                                         getMinorVersion0());\n            }\n        }\n\n        ConstantPoolParser cpParser = new ConstantPoolParser(bytes);\n        cpParser.setObserver(observer);\n        pool = cpParser.getPool();\n        pool.setImmutable();\n\n        int at = cpParser.getEndOffset();\n        int accessFlags = bytes.getUnsignedShort(at); // u2 access_flags;\n        int cpi = bytes.getUnsignedShort(at + 2); // u2 this_class;\n        thisClass = (CstType) pool.get(cpi);\n        cpi = bytes.getUnsignedShort(at + 4); // u2 super_class;\n        superClass = (CstType) pool.get0Ok(cpi);\n        int count = bytes.getUnsignedShort(at + 6); // u2 interfaces_count\n\n        if (observer != null) {\n            observer.parsed(bytes, at, 2,\n                            \"access_flags: \" +\n                            AccessFlags.classString(accessFlags));\n            observer.parsed(bytes, at + 2, 2, \"this_class: \" + thisClass);\n            observer.parsed(bytes, at + 4, 2, \"super_class: \" +\n                            stringOrNone(superClass));\n            observer.parsed(bytes, at + 6, 2,\n                            \"interfaces_count: \" + Hex.u2(count));\n            if (count != 0) {\n                observer.parsed(bytes, at + 8, 0, \"interfaces:\");\n            }\n        }\n\n        at += 8;\n        interfaces = makeTypeList(at, count);\n        at += count * 2;\n\n        if (strictParse) {\n            /*\n             * Make sure that the file/jar path matches the declared\n             * package/class name.\n             */\n            String thisClassName = thisClass.getClassType().getClassName();\n            if (!(filePath.endsWith(\".class\") &&\n                  filePath.startsWith(thisClassName) &&\n                  (filePath.length() == (thisClassName.length() + 6)))) {\n                throw new ParseException(\"class name (\" + thisClassName +\n                                         \") does not match path (\" +\n                                         filePath + \")\");\n            }\n        }\n\n        /*\n         * Only set the instance variable accessFlags here, since\n         * that's what signals a successful parse of the first part of\n         * the file (through the interfaces list).\n         */\n        this.accessFlags = accessFlags;\n\n        FieldListParser flParser =\n            new FieldListParser(this, thisClass, at, attributeFactory);\n        flParser.setObserver(observer);\n        fields = flParser.getList();\n        at = flParser.getEndOffset();\n\n        MethodListParser mlParser =\n            new MethodListParser(this, thisClass, at, attributeFactory);\n        mlParser.setObserver(observer);\n        methods = mlParser.getList();\n        at = mlParser.getEndOffset();\n\n        AttributeListParser alParser =\n            new AttributeListParser(this, AttributeFactory.CTX_CLASS, at,\n                                    attributeFactory);\n        alParser.setObserver(observer);\n        attributes = alParser.getList();\n        attributes.setImmutable();\n        at = alParser.getEndOffset();\n\n        if (at != bytes.size()) {\n            throw new ParseException(\"extra bytes at end of class file, \" +\n                                     \"at offset \" + Hex.u4(at));\n        }\n\n        if (observer != null) {\n            observer.parsed(bytes, at, 0, \"end classfile\");\n        }\n    }\n\n    /**\n     * Implementation of {@link TypeList} whose data comes directly\n     * from the bytes of an instance of this (outer) class,\n     * interpreted as a list of constant pool indices for classes\n     * which are in turn returned as type constants. Instance\n     * construction will fail if any of the (alleged) indices turn out\n     * not to refer to constant pool entries of type\n     * {@code Class}.\n     */\n    private static class DcfTypeList implements TypeList {\n        /** {@code non-null;} array containing the data */\n        private final ByteArray bytes;\n\n        /** number of elements in the list (not number of bytes) */\n        private final int size;\n\n        /** {@code non-null;} the constant pool */\n        private final StdConstantPool pool;\n\n        /**\n         * Constructs an instance.\n         *\n         * @param bytes {@code non-null;} original classfile's bytes\n         * @param offset offset into {@link #bytes} for the start of the\n         * data\n         * @param size number of elements in the list (not number of bytes)\n         * @param pool {@code non-null;} the constant pool to use\n         * @param observer {@code null-ok;} parse observer to use, if any\n         */\n        public DcfTypeList(ByteArray bytes, int offset, int size,\n                StdConstantPool pool, ParseObserver observer) {\n            if (size < 0) {\n                throw new IllegalArgumentException(\"size < 0\");\n            }\n\n            bytes = bytes.slice(offset, offset + size * 2);\n            this.bytes = bytes;\n            this.size = size;\n            this.pool = pool;\n\n            for (int i = 0; i < size; i++) {\n                offset = i * 2;\n                int idx = bytes.getUnsignedShort(offset);\n                CstType type;\n                try {\n                    type = (CstType) pool.get(idx);\n                } catch (ClassCastException ex) {\n                    // Translate the exception.\n                    throw new RuntimeException(\"bogus class cpi\", ex);\n                }\n                if (observer != null) {\n                    observer.parsed(bytes, offset, 2, \"  \" + type);\n                }\n            }\n        }\n\n        /** {@inheritDoc} */\n        public boolean isMutable() {\n            return false;\n        }\n\n        /** {@inheritDoc} */\n        public int size() {\n            return size;\n        }\n\n        /** {@inheritDoc} */\n        public int getWordCount() {\n            // It is the same as size because all elements are classes.\n            return size;\n        }\n\n        /** {@inheritDoc} */\n        public Type getType(int n) {\n            int idx = bytes.getUnsignedShort(n * 2);\n            return ((CstType) pool.get(idx)).getClassType();\n        }\n\n        /** {@inheritDoc} */\n        public TypeList withAddedType(Type type) {\n            throw new UnsupportedOperationException(\"unsupported\");\n        }\n    }\n}\n"}
{"before": "/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.dx.dex;\n\n/**\n * Constants that show up in and are otherwise related to {@code .dex}\n * files, and helper methods for same.\n */\npublic final class DexFormat {\n    private DexFormat() {}\n\n    /**\n     * API level to target in order to produce the most modern file\n     * format\n     */\n    \n\n    /** API level to target in order to suppress extended opcode usage */\n    public static final int API_NO_EXTENDED_OPCODES = 13;\n\n    /**\n     * file name of the primary {@code .dex} file inside an\n     * application or library {@code .jar} file\n     */\n    public static final String DEX_IN_JAR_NAME = \"classes.dex\";\n\n    /** common prefix for all dex file \"magic numbers\" */\n    public static final String MAGIC_PREFIX = \"dex\\n\";\n\n    /** common suffix for all dex file \"magic numbers\" */\n    public static final String MAGIC_SUFFIX = \"\\0\";\n\n    /** dex file version number for the current format variant */\n    public static final String VERSION_CURRENT = \"036\";\n\n    /** dex file version number for API level 13 and earlier */\n    public static final String VERSION_FOR_API_13 = \"035\";\n\n    /**\n     * value used to indicate endianness of file contents\n     */\n    public static final int ENDIAN_TAG = 0x12345678;\n\n    /**\n     * Returns the API level corresponding to the given magic number,\n     * or {@code -1} if the given array is not a well-formed dex file\n     * magic number.\n     */\n    public static int magicToApi(byte[] magic) {\n        if (magic.length != 8) {\n            return -1;\n        }\n\n        if ((magic[0] != 'd') || (magic[1] != 'e') || (magic[2] != 'x') || (magic[3] != '\\n') ||\n                (magic[7] != '\\0')) {\n            return -1;\n        }\n\n        String version = \"\" + ((char) magic[4]) + ((char) magic[5]) +((char) magic[6]);\n\n        if (version.equals(VERSION_CURRENT)) {\n            return 14;\n        } else if (version.equals(VERSION_FOR_API_13)) {\n            return 13;\n        }\n\n        return -1;\n    }\n\n    /**\n     * Returns the magic number corresponding to the given target API level.\n     */\n    public static String apiToMagic(int targetApiLevel) {\n        String version;\n\n        if (targetApiLevel >= 14) {\n            version = VERSION_CURRENT;\n        } else {\n            version = VERSION_FOR_API_13;\n        }\n\n        return MAGIC_PREFIX + version + MAGIC_SUFFIX;\n    }\n}\n", "after": "/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.dx.dex;\n\n/**\n * Constants that show up in and are otherwise related to {@code .dex}\n * files, and helper methods for same.\n */\npublic final class DexFormat {\n    private DexFormat() {}\n\n    /**\n     * API level to target in order to produce the most modern file\n     * format\n     */\n    public static final int API_CURRENT = 14;\n\n    /** API level to target in order to suppress extended opcode usage */\n    public static final int API_NO_EXTENDED_OPCODES = 13;\n\n    /**\n     * file name of the primary {@code .dex} file inside an\n     * application or library {@code .jar} file\n     */\n    public static final String DEX_IN_JAR_NAME = \"classes.dex\";\n\n    /** common prefix for all dex file \"magic numbers\" */\n    public static final String MAGIC_PREFIX = \"dex\\n\";\n\n    /** common suffix for all dex file \"magic numbers\" */\n    public static final String MAGIC_SUFFIX = \"\\0\";\n\n    /** dex file version number for the current format variant */\n    public static final String VERSION_CURRENT = \"036\";\n\n    /** dex file version number for API level 13 and earlier */\n    public static final String VERSION_FOR_API_13 = \"035\";\n\n    /**\n     * value used to indicate endianness of file contents\n     */\n    public static final int ENDIAN_TAG = 0x12345678;\n\n    /**\n     * Returns the API level corresponding to the given magic number,\n     * or {@code -1} if the given array is not a well-formed dex file\n     * magic number.\n     */\n    public static int magicToApi(byte[] magic) {\n        if (magic.length != 8) {\n            return -1;\n        }\n\n        if ((magic[0] != 'd') || (magic[1] != 'e') || (magic[2] != 'x') || (magic[3] != '\\n') ||\n                (magic[7] != '\\0')) {\n            return -1;\n        }\n\n        String version = \"\" + ((char) magic[4]) + ((char) magic[5]) +((char) magic[6]);\n\n        if (version.equals(VERSION_CURRENT)) {\n            return API_CURRENT;\n        } else if (version.equals(VERSION_FOR_API_13)) {\n            return 13;\n        }\n\n        return -1;\n    }\n\n    /**\n     * Returns the magic number corresponding to the given target API level.\n     */\n    public static String apiToMagic(int targetApiLevel) {\n        String version;\n\n        if (targetApiLevel >= API_CURRENT) {\n            version = VERSION_CURRENT;\n        } else {\n            version = VERSION_FOR_API_13;\n        }\n\n        return MAGIC_PREFIX + version + MAGIC_SUFFIX;\n    }\n}\n"}
{"before": "/*\n * Copyright (C) 2015 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License\n */\n\npackage com.android.contacts.editor;\n\nimport com.android.contacts.R;\nimport com.android.contacts.common.ContactPhotoManager;\nimport com.android.contacts.common.model.ValuesDelta;\nimport com.android.contacts.common.model.account.AccountType;\n\nimport android.app.Fragment;\nimport android.content.Context;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Parcel;\nimport android.os.Parcelable;\nimport android.provider.ContactsContract;\nimport android.util.DisplayMetrics;\nimport android.view.Display;\nimport android.view.LayoutInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.accessibility.AccessibilityEvent;\nimport android.widget.AdapterView;\nimport android.widget.BaseAdapter;\nimport android.widget.GridView;\nimport android.widget.ImageView;\n\nimport java.util.ArrayList;\n\n/**\n * Displays {@link Photo}s in a grid and calls back the host when one is clicked.\n */\npublic class CompactPhotoSelectionFragment extends Fragment {\n\n    private static final String STATE_PHOTOS = \"photos\";\n    private static final String STATE_PHOTO_MODE = \"photoMode\";\n    \n    private final int VIEW_TYPE_ALL_PHOTOS = 1;\n    private final int VIEW_TYPE_IMAGE = 2;\n\n    /**\n     * Callbacks hosts this Fragment.\n     */\n    public interface Listener {\n\n        /**\n         * Invoked when the user wants to change their photo.\n         */\n        void onPhotoSelected(Photo photo);\n    }\n\n    /**\n     * Holds a photo {@link ValuesDelta} and {@link AccountType} information to draw\n     * an account type icon over it.\n     */\n    public static final class Photo implements Parcelable {\n\n        public static final Creator<Photo> CREATOR = new Creator<Photo>() {\n\n            public Photo createFromParcel(Parcel in) {\n                return new Photo(in);\n            }\n\n            public Photo[] newArray(int size) {\n                return new Photo[size];\n            }\n        };\n\n        public Photo() {\n        }\n\n        private Photo(Parcel source) {\n            readFromParcel(source);\n        }\n\n        // From AccountType, everything we need to display the account type icon\n        public int titleRes;\n        public int iconRes;\n        public String syncAdapterPackageName;\n\n        public String contentDescription;\n        public String contentDescriptionChecked; // Talkback announcement when the photo is checked\n\n        public ValuesDelta valuesDelta;\n\n        /**\n         * Whether the photo is being displayed for the aggregate contact.\n         * This may be because it is marked super primary or it is the one quick contacts picked\n         * randomly to display because none is marked super primary.\n         */\n        public boolean primary;\n\n        /**\n         * Pointer back to the KindSectionDataList this photo came from.\n         * See {@link CompactRawContactsEditorView#getPhotos}\n         * See {@link CompactRawContactsEditorView#setPrimaryPhoto}\n         */\n        public int kindSectionDataListIndex = -1;\n        public int valuesDeltaListIndex = -1;\n\n        /** Newly taken or selected photo that has not yet been saved to CP2. */\n        public Uri updatedPhotoUri;\n\n        public long photoId;\n\n        @Override\n        public int describeContents() {\n            return 0;\n        }\n\n        @Override\n        public void writeToParcel(Parcel dest, int flags) {\n            dest.writeInt(titleRes);\n            dest.writeInt(iconRes);\n            dest.writeString(syncAdapterPackageName);\n            dest.writeParcelable(valuesDelta, flags);\n            dest.writeInt(primary ? 1 : 0);\n            dest.writeInt(kindSectionDataListIndex);\n            dest.writeInt(valuesDeltaListIndex);\n            dest.writeParcelable(updatedPhotoUri, flags);\n            dest.writeLong(photoId);\n        }\n\n        private void readFromParcel(Parcel source) {\n            final ClassLoader classLoader = getClass().getClassLoader();\n            titleRes = source.readInt();\n            iconRes = source.readInt();\n            syncAdapterPackageName = source.readString();\n            valuesDelta = source.readParcelable(classLoader);\n            primary = source.readInt() == 1;\n            kindSectionDataListIndex = source.readInt();\n            valuesDeltaListIndex = source.readInt();\n            updatedPhotoUri = source.readParcelable(classLoader);\n            photoId = source.readLong();\n        }\n    }\n\n    private final class PhotoAdapter extends BaseAdapter {\n\n        private final Context mContext;\n        private final LayoutInflater mLayoutInflater;\n\n        public PhotoAdapter() {\n            mContext = getContext();\n            mLayoutInflater = LayoutInflater.from(mContext);\n        }\n\n        @Override\n        public int getCount() {\n            return mPhotos == null ? 2 : mPhotos.size() + 2;\n        }\n\n        @Override\n        public Object getItem(int index) {\n            return mPhotos == null ? null : mPhotos.get(index);\n        }\n\n        @Override\n        public long getItemId(int index) {\n            return index;\n        }\n\n        @Override\n        public int getItemViewType(int index) {\n            if (index == 0) {\n                return 0;\n            } else if (index == 1) {\n                return VIEW_TYPE_ALL_PHOTOS;\n            } else {\n                return VIEW_TYPE_IMAGE;\n            }\n        }\n\n        @Override\n        public View getView(int position, View convertView, ViewGroup parent) {\n            if (mPhotos == null) return null;\n\n            // when position is 0 or 1, we should make sure account_type *is not* in convertView\n            // before reusing it.\n            if (getItemViewType(position) == 0){\n                if (convertView == null || convertView.findViewById(R.id.account_type) != null) {\n                    return mLayoutInflater.inflate(R.layout.take_a_photo_button, /* root =*/ null);\n                }\n                return convertView;\n            }\n\n            if (getItemViewType(position) == 1) {\n                if (convertView == null || convertView.findViewById(R.id.account_type) != null) {\n                    return mLayoutInflater.inflate(R.layout.all_photos_button, /* root =*/ null);\n                }\n                return convertView;\n            }\n\n            // when position greater than 1, we should make sure account_type *is* in convertView\n            // before reusing it.\n            position -= 2;\n\n            final View photoItemView;\n            if (convertView == null || convertView.findViewById(R.id.account_type) == null) {\n                photoItemView = mLayoutInflater.inflate(\n                        R.layout.compact_photo_selection_item, /* root =*/ null);\n            } else {\n                photoItemView = convertView;\n            }\n\n            final Photo photo = mPhotos.get(position);\n\n            // Bind the photo\n            final ImageView imageView = (ImageView) photoItemView.findViewById(R.id.image);\n            if (photo.updatedPhotoUri != null) {\n                EditorUiUtils.loadPhoto(ContactPhotoManager.getInstance(mContext),\n                        imageView, photo.updatedPhotoUri);\n            } else {\n                final Long photoFileId = EditorUiUtils.getPhotoFileId(photo.valuesDelta);\n                if (photoFileId != null) {\n                    final Uri photoUri = ContactsContract.DisplayPhoto.CONTENT_URI.buildUpon()\n                            .appendPath(photoFileId.toString()).build();\n                    EditorUiUtils.loadPhoto(ContactPhotoManager.getInstance(mContext),\n                            imageView, photoUri);\n                } else {\n                    imageView.setImageBitmap(EditorUiUtils.getPhotoBitmap(photo.valuesDelta));\n                }\n            }\n\n            // Add the account type icon\n            final ImageView accountTypeImageView = (ImageView)\n                    photoItemView.findViewById(R.id.account_type);\n            accountTypeImageView.setImageDrawable(AccountType.getDisplayIcon(\n                    mContext, photo.titleRes, photo.iconRes, photo.syncAdapterPackageName));\n\n            // Display a check icon over the primary photo\n            final ImageView checkImageView = (ImageView) photoItemView.findViewById(R.id.check);\n            checkImageView.setVisibility(photo.primary ? View.VISIBLE : View.GONE);\n\n            photoItemView.setContentDescription(photo.contentDescription);\n\n            return photoItemView;\n        }\n    }\n\n    private ArrayList<Photo> mPhotos;\n    private int mPhotoMode;\n    private Listener mListener;\n    private GridView mGridView;\n\n    public void setListener(Listener listener) {\n        mListener = listener;\n    }\n\n    public void setPhotos(ArrayList<Photo> photos, int photoMode) {\n        mPhotos = photos;\n        mPhotoMode = photoMode;\n        mGridView.setAccessibilityDelegate(new View.AccessibilityDelegate() {});\n    }\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        if (savedInstanceState != null) {\n            mPhotos = savedInstanceState.getParcelableArrayList(STATE_PHOTOS);\n            mPhotoMode = savedInstanceState.getInt(STATE_PHOTO_MODE, 0);\n        }\n    }\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedState) {\n        setHasOptionsMenu(true);\n\n        final PhotoAdapter photoAdapter = new PhotoAdapter();\n\n        final View view = inflater.inflate(R.layout.compact_photo_selection_fragment,\n                container, false);\n        mGridView = (GridView) view.findViewById(R.id.grid_view);\n        mGridView.setAdapter(photoAdapter);\n        mGridView.setOnItemClickListener(new AdapterView.OnItemClickListener() {\n            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {\n                final PhotoSourceDialogFragment.Listener listener =\n                        (PhotoSourceDialogFragment.Listener) getActivity();\n                if (position == 0) {\n                    listener.onTakePhotoChosen();\n                } else if (position == 1) {\n                    listener.onPickFromGalleryChosen();\n                } else {\n                    // Call the host back so it can set the new photo as primary\n                    final Photo photo = (Photo) photoAdapter.getItem(position - 2);\n                    if (mListener != null) {\n                        mListener.onPhotoSelected(photo);\n                    }\n                    handleAccessibility(photo, position);\n                }\n            }\n        });\n\n        final Display display = getActivity().getWindowManager().getDefaultDisplay();\n        final DisplayMetrics outMetrics = new DisplayMetrics ();\n        display.getRealMetrics(outMetrics); // real metrics include the navigation Bar\n\n        final float numColumns = outMetrics.widthPixels /\n                getResources().getDimension(R.dimen.photo_picker_item_ideal_width);\n        mGridView.setNumColumns(Math.round(numColumns));\n\n        return view;\n    }\n\n    private void handleAccessibility(Photo photo, int position) {\n        // Use custom AccessibilityDelegate when closing this fragment to suppress event.\n        mGridView.setAccessibilityDelegate(new View.AccessibilityDelegate() {\n            @Override\n            public boolean onRequestSendAccessibilityEvent(\n                    ViewGroup host, View child,AccessibilityEvent event) {\n                if (event.getEventType() == AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED) {\n                    return false;\n                }\n                return super.onRequestSendAccessibilityEvent(host, child, event);\n            }\n        });\n        final ViewGroup clickedView = (ViewGroup) mGridView.getChildAt(position);\n        clickedView.announceForAccessibility(photo.contentDescriptionChecked);\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        outState.putParcelableArrayList(STATE_PHOTOS, mPhotos);\n        outState.putInt(STATE_PHOTO_MODE, mPhotoMode);\n        super.onSaveInstanceState(outState);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case android.R.id.home:\n                getActivity().onBackPressed();\n                return true;\n            default:\n                return super.onOptionsItemSelected(item);\n        }\n    }\n\n    @Override\n    public Context getContext() {\n        return getActivity();\n    }\n}", "after": "/*\n * Copyright (C) 2015 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License\n */\n\npackage com.android.contacts.editor;\n\nimport com.android.contacts.R;\nimport com.android.contacts.common.ContactPhotoManager;\nimport com.android.contacts.common.model.ValuesDelta;\nimport com.android.contacts.common.model.account.AccountType;\n\nimport android.app.Fragment;\nimport android.content.Context;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Parcel;\nimport android.os.Parcelable;\nimport android.provider.ContactsContract;\nimport android.util.DisplayMetrics;\nimport android.view.Display;\nimport android.view.LayoutInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.view.accessibility.AccessibilityEvent;\nimport android.widget.AdapterView;\nimport android.widget.BaseAdapter;\nimport android.widget.GridView;\nimport android.widget.ImageView;\n\nimport java.util.ArrayList;\n\n/**\n * Displays {@link Photo}s in a grid and calls back the host when one is clicked.\n */\npublic class CompactPhotoSelectionFragment extends Fragment {\n\n    private static final String STATE_PHOTOS = \"photos\";\n    private static final String STATE_PHOTO_MODE = \"photoMode\";\n    private final int VIEW_TYPE_TAKE_PHOTO = 0;\n    private final int VIEW_TYPE_ALL_PHOTOS = 1;\n    private final int VIEW_TYPE_IMAGE = 2;\n\n    /**\n     * Callbacks hosts this Fragment.\n     */\n    public interface Listener {\n\n        /**\n         * Invoked when the user wants to change their photo.\n         */\n        void onPhotoSelected(Photo photo);\n    }\n\n    /**\n     * Holds a photo {@link ValuesDelta} and {@link AccountType} information to draw\n     * an account type icon over it.\n     */\n    public static final class Photo implements Parcelable {\n\n        public static final Creator<Photo> CREATOR = new Creator<Photo>() {\n\n            public Photo createFromParcel(Parcel in) {\n                return new Photo(in);\n            }\n\n            public Photo[] newArray(int size) {\n                return new Photo[size];\n            }\n        };\n\n        public Photo() {\n        }\n\n        private Photo(Parcel source) {\n            readFromParcel(source);\n        }\n\n        // From AccountType, everything we need to display the account type icon\n        public int titleRes;\n        public int iconRes;\n        public String syncAdapterPackageName;\n\n        public String contentDescription;\n        public String contentDescriptionChecked; // Talkback announcement when the photo is checked\n\n        public ValuesDelta valuesDelta;\n\n        /**\n         * Whether the photo is being displayed for the aggregate contact.\n         * This may be because it is marked super primary or it is the one quick contacts picked\n         * randomly to display because none is marked super primary.\n         */\n        public boolean primary;\n\n        /**\n         * Pointer back to the KindSectionDataList this photo came from.\n         * See {@link CompactRawContactsEditorView#getPhotos}\n         * See {@link CompactRawContactsEditorView#setPrimaryPhoto}\n         */\n        public int kindSectionDataListIndex = -1;\n        public int valuesDeltaListIndex = -1;\n\n        /** Newly taken or selected photo that has not yet been saved to CP2. */\n        public Uri updatedPhotoUri;\n\n        public long photoId;\n\n        @Override\n        public int describeContents() {\n            return 0;\n        }\n\n        @Override\n        public void writeToParcel(Parcel dest, int flags) {\n            dest.writeInt(titleRes);\n            dest.writeInt(iconRes);\n            dest.writeString(syncAdapterPackageName);\n            dest.writeParcelable(valuesDelta, flags);\n            dest.writeInt(primary ? 1 : 0);\n            dest.writeInt(kindSectionDataListIndex);\n            dest.writeInt(valuesDeltaListIndex);\n            dest.writeParcelable(updatedPhotoUri, flags);\n            dest.writeLong(photoId);\n        }\n\n        private void readFromParcel(Parcel source) {\n            final ClassLoader classLoader = getClass().getClassLoader();\n            titleRes = source.readInt();\n            iconRes = source.readInt();\n            syncAdapterPackageName = source.readString();\n            valuesDelta = source.readParcelable(classLoader);\n            primary = source.readInt() == 1;\n            kindSectionDataListIndex = source.readInt();\n            valuesDeltaListIndex = source.readInt();\n            updatedPhotoUri = source.readParcelable(classLoader);\n            photoId = source.readLong();\n        }\n    }\n\n    private final class PhotoAdapter extends BaseAdapter {\n\n        private final Context mContext;\n        private final LayoutInflater mLayoutInflater;\n\n        public PhotoAdapter() {\n            mContext = getContext();\n            mLayoutInflater = LayoutInflater.from(mContext);\n        }\n\n        @Override\n        public int getCount() {\n            return mPhotos == null ? 2 : mPhotos.size() + 2;\n        }\n\n        @Override\n        public Object getItem(int index) {\n            return mPhotos == null ? null : mPhotos.get(index);\n        }\n\n        @Override\n        public long getItemId(int index) {\n            return index;\n        }\n\n        @Override\n        public int getItemViewType(int index) {\n            if (index == 0) {\n                return VIEW_TYPE_TAKE_PHOTO;\n            } else if (index == 1) {\n                return VIEW_TYPE_ALL_PHOTOS;\n            } else {\n                return VIEW_TYPE_IMAGE;\n            }\n        }\n\n        @Override\n        public View getView(int position, View convertView, ViewGroup parent) {\n            if (mPhotos == null) return null;\n\n            // when position is 0 or 1, we should make sure account_type *is not* in convertView\n            // before reusing it.\n            if (getItemViewType(position) == 0){\n                if (convertView == null || convertView.findViewById(R.id.account_type) != null) {\n                    return mLayoutInflater.inflate(R.layout.take_a_photo_button, /* root =*/ null);\n                }\n                return convertView;\n            }\n\n            if (getItemViewType(position) == 1) {\n                if (convertView == null || convertView.findViewById(R.id.account_type) != null) {\n                    return mLayoutInflater.inflate(R.layout.all_photos_button, /* root =*/ null);\n                }\n                return convertView;\n            }\n\n            // when position greater than 1, we should make sure account_type *is* in convertView\n            // before reusing it.\n            position -= 2;\n\n            final View photoItemView;\n            if (convertView == null || convertView.findViewById(R.id.account_type) == null) {\n                photoItemView = mLayoutInflater.inflate(\n                        R.layout.compact_photo_selection_item, /* root =*/ null);\n            } else {\n                photoItemView = convertView;\n            }\n\n            final Photo photo = mPhotos.get(position);\n\n            // Bind the photo\n            final ImageView imageView = (ImageView) photoItemView.findViewById(R.id.image);\n            if (photo.updatedPhotoUri != null) {\n                EditorUiUtils.loadPhoto(ContactPhotoManager.getInstance(mContext),\n                        imageView, photo.updatedPhotoUri);\n            } else {\n                final Long photoFileId = EditorUiUtils.getPhotoFileId(photo.valuesDelta);\n                if (photoFileId != null) {\n                    final Uri photoUri = ContactsContract.DisplayPhoto.CONTENT_URI.buildUpon()\n                            .appendPath(photoFileId.toString()).build();\n                    EditorUiUtils.loadPhoto(ContactPhotoManager.getInstance(mContext),\n                            imageView, photoUri);\n                } else {\n                    imageView.setImageBitmap(EditorUiUtils.getPhotoBitmap(photo.valuesDelta));\n                }\n            }\n\n            // Add the account type icon\n            final ImageView accountTypeImageView = (ImageView)\n                    photoItemView.findViewById(R.id.account_type);\n            accountTypeImageView.setImageDrawable(AccountType.getDisplayIcon(\n                    mContext, photo.titleRes, photo.iconRes, photo.syncAdapterPackageName));\n\n            // Display a check icon over the primary photo\n            final ImageView checkImageView = (ImageView) photoItemView.findViewById(R.id.check);\n            checkImageView.setVisibility(photo.primary ? View.VISIBLE : View.GONE);\n\n            photoItemView.setContentDescription(photo.contentDescription);\n\n            return photoItemView;\n        }\n    }\n\n    private ArrayList<Photo> mPhotos;\n    private int mPhotoMode;\n    private Listener mListener;\n    private GridView mGridView;\n\n    public void setListener(Listener listener) {\n        mListener = listener;\n    }\n\n    public void setPhotos(ArrayList<Photo> photos, int photoMode) {\n        mPhotos = photos;\n        mPhotoMode = photoMode;\n        mGridView.setAccessibilityDelegate(new View.AccessibilityDelegate() {});\n    }\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        if (savedInstanceState != null) {\n            mPhotos = savedInstanceState.getParcelableArrayList(STATE_PHOTOS);\n            mPhotoMode = savedInstanceState.getInt(STATE_PHOTO_MODE, 0);\n        }\n    }\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedState) {\n        setHasOptionsMenu(true);\n\n        final PhotoAdapter photoAdapter = new PhotoAdapter();\n\n        final View view = inflater.inflate(R.layout.compact_photo_selection_fragment,\n                container, false);\n        mGridView = (GridView) view.findViewById(R.id.grid_view);\n        mGridView.setAdapter(photoAdapter);\n        mGridView.setOnItemClickListener(new AdapterView.OnItemClickListener() {\n            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {\n                final PhotoSourceDialogFragment.Listener listener =\n                        (PhotoSourceDialogFragment.Listener) getActivity();\n                if (position == 0) {\n                    listener.onTakePhotoChosen();\n                } else if (position == 1) {\n                    listener.onPickFromGalleryChosen();\n                } else {\n                    // Call the host back so it can set the new photo as primary\n                    final Photo photo = (Photo) photoAdapter.getItem(position - 2);\n                    if (mListener != null) {\n                        mListener.onPhotoSelected(photo);\n                    }\n                    handleAccessibility(photo, position);\n                }\n            }\n        });\n\n        final Display display = getActivity().getWindowManager().getDefaultDisplay();\n        final DisplayMetrics outMetrics = new DisplayMetrics ();\n        display.getRealMetrics(outMetrics); // real metrics include the navigation Bar\n\n        final float numColumns = outMetrics.widthPixels /\n                getResources().getDimension(R.dimen.photo_picker_item_ideal_width);\n        mGridView.setNumColumns(Math.round(numColumns));\n\n        return view;\n    }\n\n    private void handleAccessibility(Photo photo, int position) {\n        // Use custom AccessibilityDelegate when closing this fragment to suppress event.\n        mGridView.setAccessibilityDelegate(new View.AccessibilityDelegate() {\n            @Override\n            public boolean onRequestSendAccessibilityEvent(\n                    ViewGroup host, View child,AccessibilityEvent event) {\n                if (event.getEventType() == AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED) {\n                    return false;\n                }\n                return super.onRequestSendAccessibilityEvent(host, child, event);\n            }\n        });\n        final ViewGroup clickedView = (ViewGroup) mGridView.getChildAt(position);\n        clickedView.announceForAccessibility(photo.contentDescriptionChecked);\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        outState.putParcelableArrayList(STATE_PHOTOS, mPhotos);\n        outState.putInt(STATE_PHOTO_MODE, mPhotoMode);\n        super.onSaveInstanceState(outState);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case android.R.id.home:\n                getActivity().onBackPressed();\n                return true;\n            default:\n                return super.onOptionsItemSelected(item);\n        }\n    }\n\n    @Override\n    public Context getContext() {\n        return getActivity();\n    }\n}"}
{"before": "/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.camera;\n\nimport com.android.camera.gallery.IImage;\nimport com.android.camera.gallery.IImageList;\n\nimport android.graphics.Bitmap;\nimport android.os.Handler;\nimport android.util.Log;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\n\nimport static com.android.camera.Util.Assert;\n\n/**\n * A dedicated decoding thread used by ImageGallery.\n */\npublic class ImageLoader {\n    @SuppressWarnings(\"unused\")\n    private static final String TAG = \"ImageLoader\";\n\n    // Queue of work to do in the worker thread. The work is done in order.\n    private final ArrayList<WorkItem> mQueue = new ArrayList<WorkItem>();\n\n    // the worker thread and a done flag so we know when to exit\n    private boolean mDone;\n    private Thread mDecodeThread;\n\n    // Thumbnail checking will be done when there is no getBitmap requests\n    // need to be processed.\n    private ThumbnailChecker mThumbnailChecker;\n\n    /**\n     * Notify interface of how many thumbnails are processed.\n     */\n    public interface ThumbCheckCallback {\n        public boolean checking(int current, int count);\n        public void done();\n    }\n\n    public interface LoadedCallback {\n        public void run(Bitmap result);\n    }\n\n    public void getBitmap(IImage image,\n                          LoadedCallback imageLoadedRunnable,\n                          int tag) {\n        if (mDecodeThread == null) {\n            start();\n        }\n        synchronized (mQueue) {\n            WorkItem w = new WorkItem(image, imageLoadedRunnable, tag);\n            mQueue.add(w);\n            mQueue.notifyAll();\n        }\n    }\n\n    public boolean cancel(final IImage image) {\n        synchronized (mQueue) {\n            int index = findItem(image);\n            if (index >= 0) {\n                mQueue.remove(index);\n                return true;\n            } else {\n                return false;\n            }\n        }\n    }\n\n    // The caller should hold mQueue lock.\n    private int findItem(IImage image) {\n        for (int i = 0; i < mQueue.size(); i++) {\n            if (mQueue.get(i).mImage == image) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    // Clear the queue. Returns an array of tags that were in the queue.\n    public int[] clearQueue() {\n        synchronized (mQueue) {\n            int n = mQueue.size();\n            int[] tags = new int[n];\n            for (int i = 0; i < n; i++) {\n                tags[i] = mQueue.get(i).mTag;\n            }\n            mQueue.clear();\n            return tags;\n        }\n    }\n\n    private static class WorkItem {\n        IImage mImage;\n        LoadedCallback mOnLoadedRunnable;\n        int mTag;\n\n        WorkItem(IImage image, LoadedCallback onLoadedRunnable, int tag) {\n            mImage = image;\n            mOnLoadedRunnable = onLoadedRunnable;\n            mTag = tag;\n        }\n    }\n\n    public ImageLoader(Handler handler) {\n        mThumbnailChecker = new ThumbnailChecker();\n        start();\n    }\n\n    private class WorkerThread implements Runnable {\n\n        // 1000000000 is the time we wait before we start checking thumbnail.\n        // This gives the thumbnail generation work priority because there\n        // may be a short period of time when the queue is empty while\n        // ImageBlockManager is calculating what to load next.\n        \n        private long mLastWorkTime = System.nanoTime();\n\n        // Pick off items on the queue, one by one, and compute their bitmap.\n        // Place the resulting bitmap in the cache, then call back by executing\n        // the given runnable so things can get updated appropriately.\n        public void run() {\n            while (true) {\n                WorkItem workItem = null;\n                synchronized (mQueue) {\n                    if (mDone) {\n                        break;\n                    }\n                    if (!mQueue.isEmpty()) {\n                        workItem = mQueue.remove(0);\n                    } else {\n                        if (!mThumbnailChecker.hasMoreThumbnailsToCheck()) {\n                            try {\n                                mQueue.wait();\n                            } catch (InterruptedException ex) {\n                                // ignore the exception\n                            }\n                            continue;\n                        } else {\n                            // Calculate the time we need to be idle before we\n                            // start checking thumbnail.\n                            long t = 1000000000 -\n                                    (System.nanoTime() - mLastWorkTime);\n                            t = t / 1000000;  // convert to milliseconds.\n                            if (t > 0) {\n                                try {\n                                    mQueue.wait(t);\n                                } catch (InterruptedException ex) {\n                                    // ignore the exception\n                                }\n                                continue;\n                            }\n                        }\n                    }\n                }\n\n                // This holds if and only if the above\n                // hasMoreThumbnailsToCheck() returns true. (We put the call\n                // here because we want to release the lock on mQueue.\n                if (workItem == null) {\n                    mThumbnailChecker.checkNextThumbnail();\n                    continue;\n                }\n\n                final Bitmap b = workItem.mImage.miniThumbBitmap();\n\n                if (workItem.mOnLoadedRunnable != null) {\n                    workItem.mOnLoadedRunnable.run(b);\n                }\n\n                mLastWorkTime = System.nanoTime();\n            }\n        }\n    }\n\n    private void start() {\n        if (mDecodeThread != null) {\n            return;\n        }\n\n        mDone = false;\n        Thread t = new Thread(new WorkerThread());\n        t.setName(\"image-loader\");\n        mDecodeThread = t;\n        t.start();\n    }\n\n    public void stop() {\n        synchronized (mQueue) {\n            mDone = true;\n            mQueue.notifyAll();\n        }\n        if (mDecodeThread != null) {\n            try {\n                Thread t = mDecodeThread;\n                BitmapManager.instance().cancelThreadDecoding(t);\n                t.join();\n                mDecodeThread = null;\n            } catch (InterruptedException ex) {\n                // so now what?\n            }\n        }\n        stopCheckingThumbnails();\n    }\n\n    // Passthrough to ThumbnailChecker.\n    public void startCheckingThumbnails(IImageList imageList,\n            ThumbCheckCallback cb) {\n        mThumbnailChecker.startCheckingThumbnails(imageList, cb);\n        // Kick WorkerThread to start working.\n        synchronized (mQueue) {\n            mQueue.notifyAll();\n        }\n    }\n\n    public void stopCheckingThumbnails() {\n        mThumbnailChecker.stopCheckingThumbnails();\n    }\n}\n\n// This is part of ImageLoader which is responsible for checking thumbnails.\n//\n// The methods of ThumbnailChecker need to be synchronized because the data\n// will also be accessed by the WorkerThread. The methods of ThumbnailChecker\n// is only called by ImageLoader.\nclass ThumbnailChecker {\n    private static final String TAG = \"ThumbnailChecker\";\n\n    private IImageList mImageListToCheck;  // The image list we will check.\n    private int mTotalToCheck;  // total number of thumbnails to check.\n    private int mNextToCheck;  // next thumbnail to check,\n                               // -1 if no further checking is needed.\n    private ImageLoader.ThumbCheckCallback mThumbCheckCallback;\n\n    ThumbnailChecker() {\n        mNextToCheck = -1;\n    }\n\n    // Both imageList and cb must be non-null.\n    synchronized void startCheckingThumbnails(IImageList imageList,\n            ImageLoader.ThumbCheckCallback cb) {\n        Assert(imageList != null);\n        Assert(cb != null);\n        mImageListToCheck = imageList;\n        mTotalToCheck = imageList.getCount();\n        mNextToCheck = 0;\n        mThumbCheckCallback = cb;\n\n        if (!ImageManager.hasStorage()) {\n            Log.v(TAG, \"bailing from the image checker -- no storage\");\n            stopCheckingThumbnails();\n        }\n    }\n\n    synchronized void stopCheckingThumbnails() {\n        if (mThumbCheckCallback == null) return;  // already stopped.\n        mThumbCheckCallback.done();\n        mImageListToCheck = null;\n        mTotalToCheck = 0;\n        mNextToCheck = -1;\n        mThumbCheckCallback = null;\n    }\n\n    synchronized boolean hasMoreThumbnailsToCheck() {\n        return mNextToCheck != -1;\n    }\n\n    synchronized void checkNextThumbnail() {\n        if (mNextToCheck == -1) {\n            return;\n        }\n\n        if (mNextToCheck >= mTotalToCheck) {\n            stopCheckingThumbnails();\n            return;\n        }\n\n        try {\n            mImageListToCheck.checkThumbnail(mNextToCheck);\n        } catch (IOException ex) {\n            Log.e(TAG, \"Failed to check thumbnail...\"\n                    + \" was the sd card removed? - \" + ex.getMessage());\n            stopCheckingThumbnails();\n            return;\n        }\n\n        if (!mThumbCheckCallback.checking(mNextToCheck, mTotalToCheck)) {\n            stopCheckingThumbnails();\n            return;\n        }\n\n        mNextToCheck++;\n    }\n}\n", "after": "/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.camera;\n\nimport com.android.camera.gallery.IImage;\nimport com.android.camera.gallery.IImageList;\n\nimport android.graphics.Bitmap;\nimport android.os.Handler;\nimport android.util.Log;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\n\nimport static com.android.camera.Util.Assert;\n\n/**\n * A dedicated decoding thread used by ImageGallery.\n */\npublic class ImageLoader {\n    @SuppressWarnings(\"unused\")\n    private static final String TAG = \"ImageLoader\";\n\n    // Queue of work to do in the worker thread. The work is done in order.\n    private final ArrayList<WorkItem> mQueue = new ArrayList<WorkItem>();\n\n    // the worker thread and a done flag so we know when to exit\n    private boolean mDone;\n    private Thread mDecodeThread;\n\n    // Thumbnail checking will be done when there is no getBitmap requests\n    // need to be processed.\n    private ThumbnailChecker mThumbnailChecker;\n\n    /**\n     * Notify interface of how many thumbnails are processed.\n     */\n    public interface ThumbCheckCallback {\n        public boolean checking(int current, int count);\n        public void done();\n    }\n\n    public interface LoadedCallback {\n        public void run(Bitmap result);\n    }\n\n    public void getBitmap(IImage image,\n                          LoadedCallback imageLoadedRunnable,\n                          int tag) {\n        if (mDecodeThread == null) {\n            start();\n        }\n        synchronized (mQueue) {\n            WorkItem w = new WorkItem(image, imageLoadedRunnable, tag);\n            mQueue.add(w);\n            mQueue.notifyAll();\n        }\n    }\n\n    public boolean cancel(final IImage image) {\n        synchronized (mQueue) {\n            int index = findItem(image);\n            if (index >= 0) {\n                mQueue.remove(index);\n                return true;\n            } else {\n                return false;\n            }\n        }\n    }\n\n    // The caller should hold mQueue lock.\n    private int findItem(IImage image) {\n        for (int i = 0; i < mQueue.size(); i++) {\n            if (mQueue.get(i).mImage == image) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    // Clear the queue. Returns an array of tags that were in the queue.\n    public int[] clearQueue() {\n        synchronized (mQueue) {\n            int n = mQueue.size();\n            int[] tags = new int[n];\n            for (int i = 0; i < n; i++) {\n                tags[i] = mQueue.get(i).mTag;\n            }\n            mQueue.clear();\n            return tags;\n        }\n    }\n\n    private static class WorkItem {\n        IImage mImage;\n        LoadedCallback mOnLoadedRunnable;\n        int mTag;\n\n        WorkItem(IImage image, LoadedCallback onLoadedRunnable, int tag) {\n            mImage = image;\n            mOnLoadedRunnable = onLoadedRunnable;\n            mTag = tag;\n        }\n    }\n\n    public ImageLoader(Handler handler) {\n        mThumbnailChecker = new ThumbnailChecker();\n        start();\n    }\n\n    private class WorkerThread implements Runnable {\n\n        // IDLE_TIME is the time we wait before we start checking thumbnail.\n        // This gives the thumbnail generation work priority because there\n        // may be a short period of time when the queue is empty while\n        // ImageBlockManager is calculating what to load next.\n        private static final long IDLE_TIME = 1000000000;  // in nanoseconds.\n        private long mLastWorkTime = System.nanoTime();\n\n        // Pick off items on the queue, one by one, and compute their bitmap.\n        // Place the resulting bitmap in the cache, then call back by executing\n        // the given runnable so things can get updated appropriately.\n        public void run() {\n            while (true) {\n                WorkItem workItem = null;\n                synchronized (mQueue) {\n                    if (mDone) {\n                        break;\n                    }\n                    if (!mQueue.isEmpty()) {\n                        workItem = mQueue.remove(0);\n                    } else {\n                        if (!mThumbnailChecker.hasMoreThumbnailsToCheck()) {\n                            try {\n                                mQueue.wait();\n                            } catch (InterruptedException ex) {\n                                // ignore the exception\n                            }\n                            continue;\n                        } else {\n                            // Calculate the time we need to be idle before we\n                            // start checking thumbnail.\n                            long t = IDLE_TIME -\n                                    (System.nanoTime() - mLastWorkTime);\n                            t = t / 1000000;  // convert to milliseconds.\n                            if (t > 0) {\n                                try {\n                                    mQueue.wait(t);\n                                } catch (InterruptedException ex) {\n                                    // ignore the exception\n                                }\n                                continue;\n                            }\n                        }\n                    }\n                }\n\n                // This holds if and only if the above\n                // hasMoreThumbnailsToCheck() returns true. (We put the call\n                // here because we want to release the lock on mQueue.\n                if (workItem == null) {\n                    mThumbnailChecker.checkNextThumbnail();\n                    continue;\n                }\n\n                final Bitmap b = workItem.mImage.miniThumbBitmap();\n\n                if (workItem.mOnLoadedRunnable != null) {\n                    workItem.mOnLoadedRunnable.run(b);\n                }\n\n                mLastWorkTime = System.nanoTime();\n            }\n        }\n    }\n\n    private void start() {\n        if (mDecodeThread != null) {\n            return;\n        }\n\n        mDone = false;\n        Thread t = new Thread(new WorkerThread());\n        t.setName(\"image-loader\");\n        mDecodeThread = t;\n        t.start();\n    }\n\n    public void stop() {\n        synchronized (mQueue) {\n            mDone = true;\n            mQueue.notifyAll();\n        }\n        if (mDecodeThread != null) {\n            try {\n                Thread t = mDecodeThread;\n                BitmapManager.instance().cancelThreadDecoding(t);\n                t.join();\n                mDecodeThread = null;\n            } catch (InterruptedException ex) {\n                // so now what?\n            }\n        }\n        stopCheckingThumbnails();\n    }\n\n    // Passthrough to ThumbnailChecker.\n    public void startCheckingThumbnails(IImageList imageList,\n            ThumbCheckCallback cb) {\n        mThumbnailChecker.startCheckingThumbnails(imageList, cb);\n        // Kick WorkerThread to start working.\n        synchronized (mQueue) {\n            mQueue.notifyAll();\n        }\n    }\n\n    public void stopCheckingThumbnails() {\n        mThumbnailChecker.stopCheckingThumbnails();\n    }\n}\n\n// This is part of ImageLoader which is responsible for checking thumbnails.\n//\n// The methods of ThumbnailChecker need to be synchronized because the data\n// will also be accessed by the WorkerThread. The methods of ThumbnailChecker\n// is only called by ImageLoader.\nclass ThumbnailChecker {\n    private static final String TAG = \"ThumbnailChecker\";\n\n    private IImageList mImageListToCheck;  // The image list we will check.\n    private int mTotalToCheck;  // total number of thumbnails to check.\n    private int mNextToCheck;  // next thumbnail to check,\n                               // -1 if no further checking is needed.\n    private ImageLoader.ThumbCheckCallback mThumbCheckCallback;\n\n    ThumbnailChecker() {\n        mNextToCheck = -1;\n    }\n\n    // Both imageList and cb must be non-null.\n    synchronized void startCheckingThumbnails(IImageList imageList,\n            ImageLoader.ThumbCheckCallback cb) {\n        Assert(imageList != null);\n        Assert(cb != null);\n        mImageListToCheck = imageList;\n        mTotalToCheck = imageList.getCount();\n        mNextToCheck = 0;\n        mThumbCheckCallback = cb;\n\n        if (!ImageManager.hasStorage()) {\n            Log.v(TAG, \"bailing from the image checker -- no storage\");\n            stopCheckingThumbnails();\n        }\n    }\n\n    synchronized void stopCheckingThumbnails() {\n        if (mThumbCheckCallback == null) return;  // already stopped.\n        mThumbCheckCallback.done();\n        mImageListToCheck = null;\n        mTotalToCheck = 0;\n        mNextToCheck = -1;\n        mThumbCheckCallback = null;\n    }\n\n    synchronized boolean hasMoreThumbnailsToCheck() {\n        return mNextToCheck != -1;\n    }\n\n    synchronized void checkNextThumbnail() {\n        if (mNextToCheck == -1) {\n            return;\n        }\n\n        if (mNextToCheck >= mTotalToCheck) {\n            stopCheckingThumbnails();\n            return;\n        }\n\n        try {\n            mImageListToCheck.checkThumbnail(mNextToCheck);\n        } catch (IOException ex) {\n            Log.e(TAG, \"Failed to check thumbnail...\"\n                    + \" was the sd card removed? - \" + ex.getMessage());\n            stopCheckingThumbnails();\n            return;\n        }\n\n        if (!mThumbCheckCallback.checking(mNextToCheck, mTotalToCheck)) {\n            stopCheckingThumbnails();\n            return;\n        }\n\n        mNextToCheck++;\n    }\n}\n"}
{"before": "/*\n * Copyright (C) 2009 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.camera.gallery;\n\nimport com.android.camera.BitmapManager;\nimport com.android.camera.Util;\n\nimport android.content.ContentResolver;\nimport android.content.ContentValues;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.net.Uri;\nimport android.os.ParcelFileDescriptor;\nimport android.provider.MediaStore.Images.ImageColumns;\nimport android.util.Log;\n\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\n/**\n * Represents a particular image and provides access to the underlying bitmap\n * and two thumbnail bitmaps as well as other information such as the id, and\n * the path to the actual image data.\n */\npublic abstract class BaseImage implements IImage {\n    private static final String TAG = \"BaseImage\";\n    \n\n    private static final byte [] sMiniThumbData =\n            new byte[MiniThumbFile.BYTES_PER_MINTHUMB];\n\n    protected ContentResolver mContentResolver;\n\n\n    // Database field\n    protected Uri mUri;\n    protected long mId;\n    protected String mDataPath;\n    protected long mMiniThumbMagic;\n    protected final int mIndex;\n    protected String mMimeType;\n    private final long mDateTaken;\n    private String mTitle;\n    private final String mDisplayName;\n\n    protected BaseImageList mContainer;\n\n    private int mWidth = -1;\n    private int mHeight = -1;\n\n    protected BaseImage(BaseImageList container, ContentResolver cr,\n            long id, int index, Uri uri, String dataPath, long miniThumbMagic,\n            String mimeType, long dateTaken, String title, String displayName) {\n        mContainer = container;\n        mContentResolver = cr;\n        mId = id;\n        mIndex = index;\n        mUri = uri;\n        mDataPath = dataPath;\n        mMiniThumbMagic = miniThumbMagic;\n        mMimeType = mimeType;\n        mDateTaken = dateTaken;\n        mTitle = title;\n        mDisplayName = displayName;\n    }\n\n    protected abstract Bitmap.CompressFormat compressionType();\n\n    private class CompressImageToFile extends BaseCancelable<Boolean> {\n        private ThreadSafeOutputStream mOutputStream = null;\n\n        private final Bitmap mBitmap;\n        private final Uri mDestinationUri;\n        private final byte[] mJpegData;\n\n        public CompressImageToFile(Bitmap bitmap, byte[] jpegData, Uri uri) {\n            mBitmap = bitmap;\n            mDestinationUri = uri;\n            mJpegData = jpegData;\n        }\n\n        @Override\n        public boolean requestCancel() {\n            if (super.requestCancel()) {\n                if (mOutputStream != null) {\n                    mOutputStream.close();\n                }\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        public Boolean execute() {\n            try {\n                OutputStream delegate =\n                        mContentResolver.openOutputStream(mDestinationUri);\n                synchronized (this) {\n                    mOutputStream = new ThreadSafeOutputStream(delegate);\n                }\n                if (mBitmap != null) {\n                    mBitmap.compress(compressionType(), 75, mOutputStream);\n                } else {\n                    mOutputStream.write(mJpegData);\n                }\n                return true;\n            } catch (FileNotFoundException ex) {\n                return false;\n            } catch (IOException ex) {\n                return false;\n            } finally {\n                Util.closeSilently(mOutputStream);\n            }\n        }\n    }\n\n    /**\n     * Take a given bitmap and compress it to a file as described\n     * by the Uri parameter.\n     *\n     * @param bitmap    the bitmap to be compressed/stored\n     * @param uri       where to store the bitmap\n     * @return          true if we succeeded\n     */\n    protected Cancelable<Boolean> compressImageToFile(\n            Bitmap bitmap, byte [] jpegData, Uri uri) {\n        return new CompressImageToFile(bitmap, jpegData, uri);\n    }\n\n    public String getDataPath() {\n        return mDataPath;\n    }\n\n    @Override\n    public boolean equals(Object other) {\n        if (other == null || !(other instanceof Image)) return false;\n        return mUri.equals(((Image) other).mUri);\n    }\n\n    @Override\n    public int hashCode() {\n        return mUri.hashCode();\n    }\n\n    public Bitmap fullSizeBitmap(int targetWidthHeight) {\n        return fullSizeBitmap(targetWidthHeight, true);\n    }\n\n    protected Bitmap fullSizeBitmap(\n            int targetWidthHeight, boolean rotateAsNeeded) {\n        Uri url = mContainer.contentUri(mId);\n        if (url == null) return null;\n\n        Bitmap b = Util.makeBitmap(targetWidthHeight, url, mContentResolver);\n        if (b != null && rotateAsNeeded) {\n            b = Util.rotate(b, getDegreesRotated());\n        }\n        return b;\n    }\n\n    private class LoadBitmapCancelable extends BaseCancelable<Bitmap> {\n        private final ParcelFileDescriptor mPFD;\n        private final BitmapFactory.Options mOptions =\n                new BitmapFactory.Options();\n        private final int mTargetWidthHeight;\n\n        public LoadBitmapCancelable(\n                ParcelFileDescriptor pfdInput, int targetWidthHeight) {\n            mPFD = pfdInput;\n            mTargetWidthHeight = targetWidthHeight;\n        }\n\n        @Override\n        public boolean requestCancel() {\n            if (super.requestCancel()) {\n                mOptions.requestCancelDecode();\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        protected Bitmap execute() {\n            try {\n                Bitmap b = Util.makeBitmap(mTargetWidthHeight, mUri,\n                        mContentResolver, mPFD, mOptions);\n                if (b != null) {\n                    b = Util.rotate(b, getDegreesRotated());\n                }\n                return b;\n            } catch (RuntimeException ex) {\n                return null;\n            } catch (Error e) {\n                return null;\n            }\n        }\n    }\n\n    public Cancelable<Bitmap> fullSizeBitmapCancelable(\n            int targetWidthHeight) {\n        try {\n            ParcelFileDescriptor pfdInput = mContentResolver\n                    .openFileDescriptor(mUri, \"r\");\n            return new LoadBitmapCancelable(pfdInput, targetWidthHeight);\n        } catch (FileNotFoundException ex) {\n            return null;\n        } catch (UnsupportedOperationException ex) {\n            return null;\n        }\n    }\n\n    public InputStream fullSizeImageData() {\n        try {\n            InputStream input = mContentResolver.openInputStream(mUri);\n            return input;\n        } catch (IOException ex) {\n            return null;\n        }\n    }\n\n    public long fullSizeImageId() {\n        return mId;\n    }\n\n    public Uri fullSizeImageUri() {\n        return mUri;\n    }\n\n    public IImageList getContainer() {\n        return mContainer;\n    }\n\n    public long getDateTaken() {\n        return mDateTaken;\n    }\n\n    protected int getDegreesRotated() {\n        return 0;\n    }\n\n    public String getMimeType() {\n        return mMimeType;\n    }\n\n    public String getTitle() {\n        return mTitle;\n    }\n\n    public String getDisplayName() {\n        return mDisplayName;\n    }\n\n    private void setupDimension() {\n        ParcelFileDescriptor input = null;\n        try {\n            input = mContentResolver.openFileDescriptor(mUri, \"r\");\n            BitmapFactory.Options options = new BitmapFactory.Options();\n            options.inJustDecodeBounds = true;\n            BitmapManager.instance().decodeFileDescriptor(\n                    input.getFileDescriptor(), options);\n            mWidth = options.outWidth;\n            mHeight = options.outHeight;\n        } catch (FileNotFoundException ex) {\n            mWidth = 0;\n            mHeight = 0;\n        } finally {\n            Util.closeSilently(input);\n        }\n    }\n\n    public int getWidth() {\n        if (mWidth == -1) setupDimension();\n        return mWidth;\n    }\n\n    public int getHeight() {\n        if (mHeight == -1) setupDimension();\n        return mHeight;\n    }\n\n    public Bitmap miniThumbBitmap() {\n        try {\n            long id = mId;\n\n            synchronized (sMiniThumbData) {\n                byte [] data = null;\n                \n                // Try to get it from the file.\n                if (mMiniThumbMagic != 0) {\n                    data = mContainer.getMiniThumbFromFile(id, sMiniThumbData,\n                            mMiniThumbMagic);\n                }\n\n                // If it does not exist, try to create the thumbnail\n                if (data == null) {\n                    byte[][] createdThumbData = new byte[1][];\n                    try {\n                        ((BaseImageList) getContainer())\n                                .checkThumbnail(this, createdThumbData);\n                    } catch (IOException ex) {\n                        // Typically IOException because the sd card is full.\n                        // But createdThumbData may have been filled in, so\n                        // continue on.\n                    }\n                    data = createdThumbData[0];\n                }\n\n                if (data == null) {\n                    // Unable to get mini-thumb.\n                }\n\n                if (data != null) {\n                    Bitmap b = BitmapFactory.decodeByteArray(data, 0,\n                            data.length);\n                    if (b == null) {\n                        Log.v(TAG, \"couldn't decode byte array, \"\n                                + \"length was \" + data.length);\n                    }\n                    return b;\n                }\n            }\n            return null;\n        } catch (Throwable ex) {\n            Log.e(TAG, \"miniThumbBitmap got exception\", ex);\n            return null;\n        }\n    }\n\n    protected void onRemove() {\n    }\n\n    protected void saveMiniThumb(Bitmap source) throws IOException {\n        mContainer.saveMiniThumbToFile(source, fullSizeImageId(), 0);\n    }\n\n    public void setTitle(String name) {\n        if (mTitle.equals(name)) return;\n        mTitle = name;\n        ContentValues values = new ContentValues();\n        values.put(ImageColumns.TITLE, name);\n        mContentResolver.update(mUri, values, null, null);\n    }\n\n    public Uri thumbUri() {\n        // The value for the query parameter cannot be null :-(,\n        // so using a dummy \"1\"\n        return mUri.buildUpon().appendQueryParameter(\"thumb\", \"1\").build();\n    }\n\n    @Override\n    public String toString() {\n        return mUri.toString();\n    }\n}\n", "after": "/*\n * Copyright (C) 2009 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.camera.gallery;\n\nimport com.android.camera.BitmapManager;\nimport com.android.camera.Util;\n\nimport android.content.ContentResolver;\nimport android.content.ContentValues;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.net.Uri;\nimport android.os.ParcelFileDescriptor;\nimport android.provider.MediaStore.Images.ImageColumns;\nimport android.util.Log;\n\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\n/**\n * Represents a particular image and provides access to the underlying bitmap\n * and two thumbnail bitmaps as well as other information such as the id, and\n * the path to the actual image data.\n */\npublic abstract class BaseImage implements IImage {\n    private static final String TAG = \"BaseImage\";\n    private static final int UNKNOWN_LENGTH = -1;\n\n    private static final byte [] sMiniThumbData =\n            new byte[MiniThumbFile.BYTES_PER_MINTHUMB];\n\n    protected ContentResolver mContentResolver;\n\n\n    // Database field\n    protected Uri mUri;\n    protected long mId;\n    protected String mDataPath;\n    protected long mMiniThumbMagic;\n    protected final int mIndex;\n    protected String mMimeType;\n    private final long mDateTaken;\n    private String mTitle;\n    private final String mDisplayName;\n\n    protected BaseImageList mContainer;\n\n    private int mWidth = UNKNOWN_LENGTH;\n    private int mHeight = UNKNOWN_LENGTH;\n\n    protected BaseImage(BaseImageList container, ContentResolver cr,\n            long id, int index, Uri uri, String dataPath, long miniThumbMagic,\n            String mimeType, long dateTaken, String title, String displayName) {\n        mContainer = container;\n        mContentResolver = cr;\n        mId = id;\n        mIndex = index;\n        mUri = uri;\n        mDataPath = dataPath;\n        mMiniThumbMagic = miniThumbMagic;\n        mMimeType = mimeType;\n        mDateTaken = dateTaken;\n        mTitle = title;\n        mDisplayName = displayName;\n    }\n\n    protected abstract Bitmap.CompressFormat compressionType();\n\n    private class CompressImageToFile extends BaseCancelable<Boolean> {\n        private ThreadSafeOutputStream mOutputStream = null;\n\n        private final Bitmap mBitmap;\n        private final Uri mDestinationUri;\n        private final byte[] mJpegData;\n\n        public CompressImageToFile(Bitmap bitmap, byte[] jpegData, Uri uri) {\n            mBitmap = bitmap;\n            mDestinationUri = uri;\n            mJpegData = jpegData;\n        }\n\n        @Override\n        public boolean requestCancel() {\n            if (super.requestCancel()) {\n                if (mOutputStream != null) {\n                    mOutputStream.close();\n                }\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        public Boolean execute() {\n            try {\n                OutputStream delegate =\n                        mContentResolver.openOutputStream(mDestinationUri);\n                synchronized (this) {\n                    mOutputStream = new ThreadSafeOutputStream(delegate);\n                }\n                if (mBitmap != null) {\n                    mBitmap.compress(compressionType(), 75, mOutputStream);\n                } else {\n                    mOutputStream.write(mJpegData);\n                }\n                return true;\n            } catch (FileNotFoundException ex) {\n                return false;\n            } catch (IOException ex) {\n                return false;\n            } finally {\n                Util.closeSilently(mOutputStream);\n            }\n        }\n    }\n\n    /**\n     * Take a given bitmap and compress it to a file as described\n     * by the Uri parameter.\n     *\n     * @param bitmap    the bitmap to be compressed/stored\n     * @param uri       where to store the bitmap\n     * @return          true if we succeeded\n     */\n    protected Cancelable<Boolean> compressImageToFile(\n            Bitmap bitmap, byte [] jpegData, Uri uri) {\n        return new CompressImageToFile(bitmap, jpegData, uri);\n    }\n\n    public String getDataPath() {\n        return mDataPath;\n    }\n\n    @Override\n    public boolean equals(Object other) {\n        if (other == null || !(other instanceof Image)) return false;\n        return mUri.equals(((Image) other).mUri);\n    }\n\n    @Override\n    public int hashCode() {\n        return mUri.hashCode();\n    }\n\n    public Bitmap fullSizeBitmap(int targetWidthHeight) {\n        return fullSizeBitmap(targetWidthHeight, true);\n    }\n\n    protected Bitmap fullSizeBitmap(\n            int targetWidthHeight, boolean rotateAsNeeded) {\n        Uri url = mContainer.contentUri(mId);\n        if (url == null) return null;\n\n        Bitmap b = Util.makeBitmap(targetWidthHeight, url, mContentResolver);\n        if (b != null && rotateAsNeeded) {\n            b = Util.rotate(b, getDegreesRotated());\n        }\n        return b;\n    }\n\n    private class LoadBitmapCancelable extends BaseCancelable<Bitmap> {\n        private final ParcelFileDescriptor mPFD;\n        private final BitmapFactory.Options mOptions =\n                new BitmapFactory.Options();\n        private final int mTargetWidthHeight;\n\n        public LoadBitmapCancelable(\n                ParcelFileDescriptor pfdInput, int targetWidthHeight) {\n            mPFD = pfdInput;\n            mTargetWidthHeight = targetWidthHeight;\n        }\n\n        @Override\n        public boolean requestCancel() {\n            if (super.requestCancel()) {\n                mOptions.requestCancelDecode();\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        protected Bitmap execute() {\n            try {\n                Bitmap b = Util.makeBitmap(mTargetWidthHeight, mUri,\n                        mContentResolver, mPFD, mOptions);\n                if (b != null) {\n                    b = Util.rotate(b, getDegreesRotated());\n                }\n                return b;\n            } catch (RuntimeException ex) {\n                return null;\n            } catch (Error e) {\n                return null;\n            }\n        }\n    }\n\n    public Cancelable<Bitmap> fullSizeBitmapCancelable(\n            int targetWidthHeight) {\n        try {\n            ParcelFileDescriptor pfdInput = mContentResolver\n                    .openFileDescriptor(mUri, \"r\");\n            return new LoadBitmapCancelable(pfdInput, targetWidthHeight);\n        } catch (FileNotFoundException ex) {\n            return null;\n        } catch (UnsupportedOperationException ex) {\n            return null;\n        }\n    }\n\n    public InputStream fullSizeImageData() {\n        try {\n            InputStream input = mContentResolver.openInputStream(mUri);\n            return input;\n        } catch (IOException ex) {\n            return null;\n        }\n    }\n\n    public long fullSizeImageId() {\n        return mId;\n    }\n\n    public Uri fullSizeImageUri() {\n        return mUri;\n    }\n\n    public IImageList getContainer() {\n        return mContainer;\n    }\n\n    public long getDateTaken() {\n        return mDateTaken;\n    }\n\n    protected int getDegreesRotated() {\n        return 0;\n    }\n\n    public String getMimeType() {\n        return mMimeType;\n    }\n\n    public String getTitle() {\n        return mTitle;\n    }\n\n    public String getDisplayName() {\n        return mDisplayName;\n    }\n\n    private void setupDimension() {\n        ParcelFileDescriptor input = null;\n        try {\n            input = mContentResolver.openFileDescriptor(mUri, \"r\");\n            BitmapFactory.Options options = new BitmapFactory.Options();\n            options.inJustDecodeBounds = true;\n            BitmapManager.instance().decodeFileDescriptor(\n                    input.getFileDescriptor(), options);\n            mWidth = options.outWidth;\n            mHeight = options.outHeight;\n        } catch (FileNotFoundException ex) {\n            mWidth = 0;\n            mHeight = 0;\n        } finally {\n            Util.closeSilently(input);\n        }\n    }\n\n    public int getWidth() {\n        if (mWidth == UNKNOWN_LENGTH) setupDimension();\n        return mWidth;\n    }\n\n    public int getHeight() {\n        if (mHeight == UNKNOWN_LENGTH) setupDimension();\n        return mHeight;\n    }\n\n    public Bitmap miniThumbBitmap() {\n        try {\n            long id = mId;\n\n            synchronized (sMiniThumbData) {\n                byte [] data = null;\n                \n                // Try to get it from the file.\n                if (mMiniThumbMagic != 0) {\n                    data = mContainer.getMiniThumbFromFile(id, sMiniThumbData,\n                            mMiniThumbMagic);\n                }\n\n                // If it does not exist, try to create the thumbnail\n                if (data == null) {\n                    byte[][] createdThumbData = new byte[1][];\n                    try {\n                        ((BaseImageList) getContainer())\n                                .checkThumbnail(this, createdThumbData);\n                    } catch (IOException ex) {\n                        // Typically IOException because the sd card is full.\n                        // But createdThumbData may have been filled in, so\n                        // continue on.\n                    }\n                    data = createdThumbData[0];\n                }\n\n                if (data == null) {\n                    // Unable to get mini-thumb.\n                }\n\n                if (data != null) {\n                    Bitmap b = BitmapFactory.decodeByteArray(data, 0,\n                            data.length);\n                    if (b == null) {\n                        Log.v(TAG, \"couldn't decode byte array, \"\n                                + \"length was \" + data.length);\n                    }\n                    return b;\n                }\n            }\n            return null;\n        } catch (Throwable ex) {\n            Log.e(TAG, \"miniThumbBitmap got exception\", ex);\n            return null;\n        }\n    }\n\n    protected void onRemove() {\n    }\n\n    protected void saveMiniThumb(Bitmap source) throws IOException {\n        mContainer.saveMiniThumbToFile(source, fullSizeImageId(), 0);\n    }\n\n    public void setTitle(String name) {\n        if (mTitle.equals(name)) return;\n        mTitle = name;\n        ContentValues values = new ContentValues();\n        values.put(ImageColumns.TITLE, name);\n        mContentResolver.update(mUri, values, null, null);\n    }\n\n    public Uri thumbUri() {\n        // The value for the query parameter cannot be null :-(,\n        // so using a dummy \"1\"\n        return mUri.buildUpon().appendQueryParameter(\"thumb\", \"1\").build();\n    }\n\n    @Override\n    public String toString() {\n        return mUri.toString();\n    }\n}\n"}
{"before": "/*\n * Copyright (C) 2009 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.camera.gallery;\n\nimport com.android.camera.ImageManager;\nimport com.android.camera.Util;\n\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.media.ExifInterface;\nimport android.net.Uri;\nimport android.os.Parcel;\nimport android.provider.BaseColumns;\nimport android.provider.MediaStore.Images.ImageColumns;\nimport android.provider.MediaStore.Images.Thumbnails;\nimport android.util.Log;\n\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.Random;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * A collection of <code>BaseImage</code>s.\n */\npublic abstract class BaseImageList implements IImageList {\n    private static final String TAG = \"BaseImageList\";\n    \n    private final LruCache<Integer, BaseImage> mCache =\n            new LruCache<Integer, BaseImage>(512);\n\n    protected ContentResolver mContentResolver;\n    protected int mSort;\n\n    protected Uri mBaseUri;\n    protected Cursor mCursor;\n    protected String mBucketId;\n    protected MiniThumbFile mMiniThumbFile;\n    protected Uri mThumbUri;\n    protected boolean mCursorDeactivated = false;\n\n    public BaseImageList(Uri uri, int sort, String bucketId) {\n        mSort = sort;\n        mBaseUri = uri;\n        mBucketId = bucketId;\n        mMiniThumbFile = new MiniThumbFile(uri);\n    }\n\n    protected BaseImageList(Parcel in) {\n        mSort = in.readInt();\n        mBaseUri = (Uri) in.readParcelable(null);\n        mBucketId = in.readString();\n        mMiniThumbFile = new MiniThumbFile(mBaseUri);\n    }\n\n    public void writeToParcel(Parcel out, int flags) {\n        out.writeInt(mSort);\n        out.writeParcelable(mBaseUri, flags);\n        out.writeString(mBucketId);\n    }\n\n    public void open(ContentResolver resolver) {\n        mContentResolver = resolver;\n        mCursor = createCursor();\n\n        // If the media provider is killed, we will fail to get the cursor.\n        // This is a workaround to wait a bit and retry in the hope that the\n        // new instance of media provider will be created soon enough.\n        if (mCursor == null) {\n            for (int i = 0; i < 10; i++) {\n                Log.w(TAG, \"createCursor failed, retry...\");\n                try {\n                    Thread.sleep(300);\n                } catch (InterruptedException ex) {\n                    // ignore.\n                }\n                mCursor = createCursor();\n                if (mCursor != null) break;\n            }\n        }\n\n        // TODO: We need to clear the cache because we may \"reopen\" the image\n        // list. After we implement the image list state, we can remove this\n        // kind of usage.\n        mCache.clear();\n    }\n\n    // TODO: merge close() and deactivate()\n    public void close() {\n        mContentResolver = null;\n        if (mCursor != null) {\n            mCursor.close();\n            mCursor = null;\n        }\n    }\n\n    public int describeContents() {\n        return 0;\n    }\n\n    /**\n     * Store a given thumbnail in the database.\n     */\n    protected Bitmap storeThumbnail(Bitmap thumb, long imageId) {\n        if (thumb == null) return null;\n        try {\n            Uri uri = getThumbnailUri(imageId, thumb.getWidth(),\n                    thumb.getHeight());\n            if (uri == null) {\n                return thumb;\n            }\n            OutputStream thumbOut = mContentResolver.openOutputStream(uri);\n            thumb.compress(Bitmap.CompressFormat.JPEG, 60, thumbOut);\n            thumbOut.close();\n            return thumb;\n        } catch (Exception ex) {\n            Log.e(TAG, \"Unable to store thumbnail\", ex);\n            return thumb;\n        }\n    }\n\n    /**\n     * Store a JPEG thumbnail from the EXIF header in the database.\n     */\n    protected boolean storeThumbnail(\n            byte[] jpegThumbnail, long imageId, int width, int height) {\n        if (jpegThumbnail == null) return false;\n\n        Uri uri = getThumbnailUri(imageId, width, height);\n        if (uri == null) {\n            return false;\n        }\n        try {\n            OutputStream thumbOut = mContentResolver.openOutputStream(uri);\n            thumbOut.write(jpegThumbnail);\n            thumbOut.close();\n            return true;\n        } catch (FileNotFoundException ex) {\n            return false;\n        } catch (IOException ex) {\n            return false;\n        }\n    }\n\n    private static final String[] THUMB_PROJECTION = new String[] {\n        BaseColumns._ID\n    };\n\n    private Uri getThumbnailUri(long imageId, int width, int height) {\n\n        // we do not store thumbnails for DRM'd images\n        if (mThumbUri == null) {\n            return null;\n        }\n\n        Cursor c = mContentResolver.query(mThumbUri, THUMB_PROJECTION,\n                Thumbnails.IMAGE_ID + \"=?\",\n                new String[]{String.valueOf(imageId)}, null);\n        try {\n            if (c.moveToNext()) {\n                return ContentUris.withAppendedId(mThumbUri, c.getLong(0));\n            }\n        } finally {\n            c.close();\n        }\n        ContentValues values = new ContentValues(4);\n        values.put(Thumbnails.KIND, Thumbnails.MINI_KIND);\n        values.put(Thumbnails.IMAGE_ID, imageId);\n        values.put(Thumbnails.HEIGHT, height);\n        values.put(Thumbnails.WIDTH, width);\n        try {\n            return mContentResolver.insert(mThumbUri, values);\n        } catch (Exception ex) {\n            return null;\n        }\n    }\n\n    private static final Random sRandom =\n            new Random(System.currentTimeMillis());\n\n    // If the photo has an EXIF thumbnail and it's big enough, extract it and\n    // save that JPEG as the large thumbnail without re-encoding it. We still\n    // have to decompress it though, in order to generate the minithumb.\n    private Bitmap createThumbnailFromEXIF(String filePath, long id) {\n        if (filePath == null) return null;\n\n        byte [] thumbData = ExifInterface.getExifThumbnail(filePath);\n        if (thumbData == null) return null;\n\n        // Sniff the size of the EXIF thumbnail before decoding it. Photos\n        // from the device will pass, but images that are side loaded from\n        // other cameras may not.\n        BitmapFactory.Options options = new BitmapFactory.Options();\n        options.inJustDecodeBounds = true;\n        BitmapFactory.decodeByteArray(thumbData, 0, thumbData.length, options);\n        int width = options.outWidth;\n        int height = options.outHeight;\n        if (width >= IImage.THUMBNAIL_TARGET_SIZE\n                && height >= IImage.THUMBNAIL_TARGET_SIZE) {\n            \n            // We do not check the return value of storeThumbnail because\n            // we should return the mini thumb even if the storing fails.\n            storeThumbnail(thumbData, id, width, height);\n\n            // this is used for *encoding* the minithumb, so\n            // we don't want to dither or convert to 565 here.\n            //\n            // Decode with a scaling factor\n            // to match MINI_THUMB_TARGET_SIZE closely\n            // which will produce much better scaling quality\n            // and is significantly faster.\n            options.inSampleSize =\n                    Util.computeSampleSize(options,\n                    IImage.MINI_THUMB_TARGET_SIZE);\n            options.inDither = false;\n            options.inPreferredConfig = Bitmap.Config.ARGB_8888;\n            options.inJustDecodeBounds = false;\n            return BitmapFactory.decodeByteArray(\n                    thumbData, 0, thumbData.length, options);\n        }\n        return null;\n    }\n\n    // The fallback case is to decode the original photo to thumbnail size,\n    // then encode it as a JPEG. We return the thumbnail Bitmap in order to\n    // create the minithumb from it.\n    private Bitmap createThumbnailFromUri(Uri uri, long id) {\n        Bitmap bitmap = Util.makeBitmap(IImage.THUMBNAIL_TARGET_SIZE, uri,\n                mContentResolver);\n        if (bitmap != null) {\n            storeThumbnail(bitmap, id);\n        } else {\n            bitmap = Util.makeBitmap(IImage.MINI_THUMB_TARGET_SIZE, uri,\n                mContentResolver);\n        }\n        return bitmap;\n    }\n\n    public void checkThumbnail(int index) throws IOException {\n        checkThumbnail((BaseImage) getImageAt(index), null);\n    }\n\n    /**\n     * Checks to see if a mini thumbnail exists in the cache. If not, tries to\n     * create it and add it to the cache.\n     * @param createdThumbnailData if this parameter is non-null, and a new\n     *         mini-thumbnail bitmap is created, the new bitmap's data will be\n     *         stored in createdThumbnailData[0]. Note that if the sdcard is\n     *         full, it's possible that createdThumbnailData[0] will be set\n     *         even if the method throws an IOException. This is actually\n     *         useful, because it allows the caller to use the created\n     *         thumbnail even if the sdcard is full.\n     * @throws IOException\n     */\n    public void checkThumbnail(BaseImage existingImage,\n            byte[][] createdThumbnailData) throws IOException {\n        long magic, id;\n\n        magic = existingImage.mMiniThumbMagic;\n        id = existingImage.fullSizeImageId();\n\n        if (magic != 0) {\n            long fileMagic = mMiniThumbFile.getMagic(id);\n            if (fileMagic == magic) {\n                return;\n            }\n        }\n\n        // If we can't retrieve the thumbnail, first check if there is one\n        // embedded in the EXIF data. If not, or it's not big enough,\n        // decompress the full size image.\n        Bitmap bitmap = null;\n        String filePath = existingImage.getDataPath();\n\n        if (filePath != null) {\n            boolean isVideo = ImageManager.isVideo(existingImage);\n            if (isVideo) {\n                bitmap = Util.createVideoThumbnail(filePath);\n            } else {\n                bitmap = createThumbnailFromEXIF(filePath, id);\n                if (bitmap == null) {\n                    bitmap = createThumbnailFromUri(\n                            ContentUris.withAppendedId(mBaseUri, id), id);\n                }\n            }\n            int degrees = existingImage.getDegreesRotated();\n            if (degrees != 0) {\n                bitmap = Util.rotate(bitmap, degrees);\n            }\n        }\n\n        // make a new magic number since things are out of sync\n        do {\n            magic = sRandom.nextLong();\n        } while (magic == 0);\n\n        if (bitmap != null) {\n            byte [] data = Util.miniThumbData(bitmap);\n            if (createdThumbnailData != null) {\n                createdThumbnailData[0] = data;\n            }\n\n            // This could throw IOException.\n            saveMiniThumbToFile(data, id, magic);\n        }\n\n        ContentValues values = new ContentValues();\n        values.put(ImageColumns.MINI_THUMB_MAGIC, magic);\n        mContentResolver.update(\n                existingImage.fullSizeImageUri(), values, null, null);\n        existingImage.mMiniThumbMagic = magic;\n    }\n\n    // TODO: Change public to protected\n    public Uri contentUri(long id) {\n\n        // TODO: avoid using exception for most cases\n        try {\n            // does our uri already have an id (single image query)?\n            // if so just return it\n            long existingId = ContentUris.parseId(mBaseUri);\n            if (existingId != id) Log.e(TAG, \"id mismatch\");\n            return mBaseUri;\n        } catch (NumberFormatException ex) {\n            // otherwise tack on the id\n            return ContentUris.withAppendedId(mBaseUri, id);\n        }\n    }\n\n    public void deactivate() {\n        try {\n            invalidateCursor();\n        } catch (IllegalStateException e) {\n            // IllegalStateException may be thrown if the cursor is stale.\n            Log.e(TAG, \"Caught exception while deactivating cursor.\", e);\n        }\n        mMiniThumbFile.deactivate();\n    }\n\n    public int getCount() {\n        Cursor cursor = getCursor();\n        synchronized (cursor) {\n            return cursor.getCount();\n        }\n    }\n\n    public boolean isEmpty() {\n        return getCount() == 0;\n    }\n\n    private Cursor getCursor() {\n        synchronized (mCursor) {\n            if (mCursorDeactivated) {\n                mCursor.requery();\n                mCursorDeactivated = false;\n            }\n            return mCursor;\n        }\n    }\n\n    public IImage getImageAt(int i) {\n        BaseImage result = mCache.get(i);\n        if (result == null) {\n            Cursor cursor = getCursor();\n            synchronized (cursor) {\n                result = cursor.moveToPosition(i)\n                        ? loadImageFromCursor(cursor)\n                        : null;\n                mCache.put(i, result);\n            }\n        }\n        return result;\n    }\n\n    byte [] getMiniThumbFromFile(long id, byte [] data, long magicCheck) {\n        return mMiniThumbFile.getMiniThumbFromFile(id, data, magicCheck);\n    }\n\n    void saveMiniThumbToFile(Bitmap bitmap, long id, long magic)\n            throws IOException {\n        mMiniThumbFile.saveMiniThumbToFile(bitmap, id, magic);\n    }\n\n    void saveMiniThumbToFile(byte[] data, long id, long magic)\n            throws IOException {\n        mMiniThumbFile.saveMiniThumbToFile(data, id, magic);\n    }\n\n    public boolean removeImage(IImage image) {\n        // TODO: need to delete the thumbnails as well\n        if (mContentResolver.delete(image.fullSizeImageUri(), null, null) > 0) {\n            ((BaseImage) image).onRemove();\n            invalidateCursor();\n            invalidateCache();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public boolean removeImageAt(int i) {\n        // TODO: need to delete the thumbnails as well\n        return removeImage(getImageAt(i));\n    }\n\n    protected abstract Cursor createCursor();\n\n    protected abstract BaseImage loadImageFromCursor(Cursor cursor);\n\n    protected abstract long getImageId(Cursor cursor);\n\n    protected void invalidateCursor() {\n        mCursor.deactivate();\n        mCursorDeactivated = true;\n    }\n\n    protected void invalidateCache() {\n        mCache.clear();\n    }\n\n    private static final Pattern sPathWithId = Pattern.compile(\"(.*)/\\\\d+\");\n\n    private static String getPathWithoutId(Uri uri) {\n        String path = uri.getPath();\n        Matcher matcher = sPathWithId.matcher(path);\n        return matcher.matches() ? matcher.group(1) : path;\n    }\n\n    private boolean isChildImageUri(Uri uri) {\n        // Sometimes, the URI of an image contains a query string with key\n        // \"bucketId\" inorder to restore the image list. However, the query\n        // string is not part of the mBaseUri. So, we check only other parts\n        // of the two Uri to see if they are the same.\n        Uri base = mBaseUri;\n        return Util.equals(base.getScheme(), uri.getScheme())\n                && Util.equals(base.getHost(), uri.getHost())\n                && Util.equals(base.getAuthority(), uri.getAuthority())\n                && Util.equals(base.getPath(), getPathWithoutId(uri));\n    }\n\n    public IImage getImageForUri(Uri uri) {\n        if (!isChildImageUri(uri)) return null;\n        // Find the id of the input URI.\n        long matchId;\n        try {\n            matchId = ContentUris.parseId(uri);\n        } catch (NumberFormatException ex) {\n            Log.i(TAG, \"fail to get id in: \" + uri, ex);\n            return null;\n        }\n        // TODO: design a better method to get URI of specified ID\n        Cursor cursor = getCursor();\n        synchronized (cursor) {\n            cursor.moveToPosition(-1); // before first\n            for (int i = 0; cursor.moveToNext(); ++i) {\n                if (getImageId(cursor) == matchId) {\n                    BaseImage image = mCache.get(i);\n                    if (image == null) {\n                        image = loadImageFromCursor(cursor);\n                        mCache.put(i, image);\n                    }\n                    return image;\n                }\n            }\n            return null;\n        }\n    }\n\n    public int getImageIndex(IImage image) {\n        return ((BaseImage) image).mIndex;\n    }\n}\n", "after": "/*\n * Copyright (C) 2009 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.camera.gallery;\n\nimport com.android.camera.ImageManager;\nimport com.android.camera.Util;\n\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.database.Cursor;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.media.ExifInterface;\nimport android.net.Uri;\nimport android.os.Parcel;\nimport android.provider.BaseColumns;\nimport android.provider.MediaStore.Images.ImageColumns;\nimport android.provider.MediaStore.Images.Thumbnails;\nimport android.util.Log;\n\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.Random;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * A collection of <code>BaseImage</code>s.\n */\npublic abstract class BaseImageList implements IImageList {\n    private static final String TAG = \"BaseImageList\";\n    private static final int CACHE_CAPACITY = 512;\n    private final LruCache<Integer, BaseImage> mCache =\n            new LruCache<Integer, BaseImage>(CACHE_CAPACITY);\n\n    protected ContentResolver mContentResolver;\n    protected int mSort;\n\n    protected Uri mBaseUri;\n    protected Cursor mCursor;\n    protected String mBucketId;\n    protected MiniThumbFile mMiniThumbFile;\n    protected Uri mThumbUri;\n    protected boolean mCursorDeactivated = false;\n\n    public BaseImageList(Uri uri, int sort, String bucketId) {\n        mSort = sort;\n        mBaseUri = uri;\n        mBucketId = bucketId;\n        mMiniThumbFile = new MiniThumbFile(uri);\n    }\n\n    protected BaseImageList(Parcel in) {\n        mSort = in.readInt();\n        mBaseUri = (Uri) in.readParcelable(null);\n        mBucketId = in.readString();\n        mMiniThumbFile = new MiniThumbFile(mBaseUri);\n    }\n\n    public void writeToParcel(Parcel out, int flags) {\n        out.writeInt(mSort);\n        out.writeParcelable(mBaseUri, flags);\n        out.writeString(mBucketId);\n    }\n\n    public void open(ContentResolver resolver) {\n        mContentResolver = resolver;\n        mCursor = createCursor();\n\n        // If the media provider is killed, we will fail to get the cursor.\n        // This is a workaround to wait a bit and retry in the hope that the\n        // new instance of media provider will be created soon enough.\n        if (mCursor == null) {\n            for (int i = 0; i < 10; i++) {\n                Log.w(TAG, \"createCursor failed, retry...\");\n                try {\n                    Thread.sleep(300);\n                } catch (InterruptedException ex) {\n                    // ignore.\n                }\n                mCursor = createCursor();\n                if (mCursor != null) break;\n            }\n        }\n\n        // TODO: We need to clear the cache because we may \"reopen\" the image\n        // list. After we implement the image list state, we can remove this\n        // kind of usage.\n        mCache.clear();\n    }\n\n    // TODO: merge close() and deactivate()\n    public void close() {\n        mContentResolver = null;\n        if (mCursor != null) {\n            mCursor.close();\n            mCursor = null;\n        }\n    }\n\n    public int describeContents() {\n        return 0;\n    }\n\n    /**\n     * Store a given thumbnail in the database.\n     */\n    protected Bitmap storeThumbnail(Bitmap thumb, long imageId) {\n        if (thumb == null) return null;\n        try {\n            Uri uri = getThumbnailUri(imageId, thumb.getWidth(),\n                    thumb.getHeight());\n            if (uri == null) {\n                return thumb;\n            }\n            OutputStream thumbOut = mContentResolver.openOutputStream(uri);\n            thumb.compress(Bitmap.CompressFormat.JPEG, 60, thumbOut);\n            thumbOut.close();\n            return thumb;\n        } catch (Exception ex) {\n            Log.e(TAG, \"Unable to store thumbnail\", ex);\n            return thumb;\n        }\n    }\n\n    /**\n     * Store a JPEG thumbnail from the EXIF header in the database.\n     */\n    protected boolean storeThumbnail(\n            byte[] jpegThumbnail, long imageId, int width, int height) {\n        if (jpegThumbnail == null) return false;\n\n        Uri uri = getThumbnailUri(imageId, width, height);\n        if (uri == null) {\n            return false;\n        }\n        try {\n            OutputStream thumbOut = mContentResolver.openOutputStream(uri);\n            thumbOut.write(jpegThumbnail);\n            thumbOut.close();\n            return true;\n        } catch (FileNotFoundException ex) {\n            return false;\n        } catch (IOException ex) {\n            return false;\n        }\n    }\n\n    private static final String[] THUMB_PROJECTION = new String[] {\n        BaseColumns._ID\n    };\n\n    private Uri getThumbnailUri(long imageId, int width, int height) {\n\n        // we do not store thumbnails for DRM'd images\n        if (mThumbUri == null) {\n            return null;\n        }\n\n        Cursor c = mContentResolver.query(mThumbUri, THUMB_PROJECTION,\n                Thumbnails.IMAGE_ID + \"=?\",\n                new String[]{String.valueOf(imageId)}, null);\n        try {\n            if (c.moveToNext()) {\n                return ContentUris.withAppendedId(mThumbUri, c.getLong(0));\n            }\n        } finally {\n            c.close();\n        }\n        ContentValues values = new ContentValues(4);\n        values.put(Thumbnails.KIND, Thumbnails.MINI_KIND);\n        values.put(Thumbnails.IMAGE_ID, imageId);\n        values.put(Thumbnails.HEIGHT, height);\n        values.put(Thumbnails.WIDTH, width);\n        try {\n            return mContentResolver.insert(mThumbUri, values);\n        } catch (Exception ex) {\n            return null;\n        }\n    }\n\n    private static final Random sRandom =\n            new Random(System.currentTimeMillis());\n\n    // If the photo has an EXIF thumbnail and it's big enough, extract it and\n    // save that JPEG as the large thumbnail without re-encoding it. We still\n    // have to decompress it though, in order to generate the minithumb.\n    private Bitmap createThumbnailFromEXIF(String filePath, long id) {\n        if (filePath == null) return null;\n\n        byte [] thumbData = ExifInterface.getExifThumbnail(filePath);\n        if (thumbData == null) return null;\n\n        // Sniff the size of the EXIF thumbnail before decoding it. Photos\n        // from the device will pass, but images that are side loaded from\n        // other cameras may not.\n        BitmapFactory.Options options = new BitmapFactory.Options();\n        options.inJustDecodeBounds = true;\n        BitmapFactory.decodeByteArray(thumbData, 0, thumbData.length, options);\n        int width = options.outWidth;\n        int height = options.outHeight;\n        if (width >= IImage.THUMBNAIL_TARGET_SIZE\n                && height >= IImage.THUMBNAIL_TARGET_SIZE) {\n            \n            // We do not check the return value of storeThumbnail because\n            // we should return the mini thumb even if the storing fails.\n            storeThumbnail(thumbData, id, width, height);\n\n            // this is used for *encoding* the minithumb, so\n            // we don't want to dither or convert to 565 here.\n            //\n            // Decode with a scaling factor\n            // to match MINI_THUMB_TARGET_SIZE closely\n            // which will produce much better scaling quality\n            // and is significantly faster.\n            options.inSampleSize =\n                    Util.computeSampleSize(options,\n                    IImage.MINI_THUMB_TARGET_SIZE);\n            options.inDither = false;\n            options.inPreferredConfig = Bitmap.Config.ARGB_8888;\n            options.inJustDecodeBounds = false;\n            return BitmapFactory.decodeByteArray(\n                    thumbData, 0, thumbData.length, options);\n        }\n        return null;\n    }\n\n    // The fallback case is to decode the original photo to thumbnail size,\n    // then encode it as a JPEG. We return the thumbnail Bitmap in order to\n    // create the minithumb from it.\n    private Bitmap createThumbnailFromUri(Uri uri, long id) {\n        Bitmap bitmap = Util.makeBitmap(IImage.THUMBNAIL_TARGET_SIZE, uri,\n                mContentResolver);\n        if (bitmap != null) {\n            storeThumbnail(bitmap, id);\n        } else {\n            bitmap = Util.makeBitmap(IImage.MINI_THUMB_TARGET_SIZE, uri,\n                mContentResolver);\n        }\n        return bitmap;\n    }\n\n    public void checkThumbnail(int index) throws IOException {\n        checkThumbnail((BaseImage) getImageAt(index), null);\n    }\n\n    /**\n     * Checks to see if a mini thumbnail exists in the cache. If not, tries to\n     * create it and add it to the cache.\n     * @param createdThumbnailData if this parameter is non-null, and a new\n     *         mini-thumbnail bitmap is created, the new bitmap's data will be\n     *         stored in createdThumbnailData[0]. Note that if the sdcard is\n     *         full, it's possible that createdThumbnailData[0] will be set\n     *         even if the method throws an IOException. This is actually\n     *         useful, because it allows the caller to use the created\n     *         thumbnail even if the sdcard is full.\n     * @throws IOException\n     */\n    public void checkThumbnail(BaseImage existingImage,\n            byte[][] createdThumbnailData) throws IOException {\n        long magic, id;\n\n        magic = existingImage.mMiniThumbMagic;\n        id = existingImage.fullSizeImageId();\n\n        if (magic != 0) {\n            long fileMagic = mMiniThumbFile.getMagic(id);\n            if (fileMagic == magic) {\n                return;\n            }\n        }\n\n        // If we can't retrieve the thumbnail, first check if there is one\n        // embedded in the EXIF data. If not, or it's not big enough,\n        // decompress the full size image.\n        Bitmap bitmap = null;\n        String filePath = existingImage.getDataPath();\n\n        if (filePath != null) {\n            boolean isVideo = ImageManager.isVideo(existingImage);\n            if (isVideo) {\n                bitmap = Util.createVideoThumbnail(filePath);\n            } else {\n                bitmap = createThumbnailFromEXIF(filePath, id);\n                if (bitmap == null) {\n                    bitmap = createThumbnailFromUri(\n                            ContentUris.withAppendedId(mBaseUri, id), id);\n                }\n            }\n            int degrees = existingImage.getDegreesRotated();\n            if (degrees != 0) {\n                bitmap = Util.rotate(bitmap, degrees);\n            }\n        }\n\n        // make a new magic number since things are out of sync\n        do {\n            magic = sRandom.nextLong();\n        } while (magic == 0);\n\n        if (bitmap != null) {\n            byte [] data = Util.miniThumbData(bitmap);\n            if (createdThumbnailData != null) {\n                createdThumbnailData[0] = data;\n            }\n\n            // This could throw IOException.\n            saveMiniThumbToFile(data, id, magic);\n        }\n\n        ContentValues values = new ContentValues();\n        values.put(ImageColumns.MINI_THUMB_MAGIC, magic);\n        mContentResolver.update(\n                existingImage.fullSizeImageUri(), values, null, null);\n        existingImage.mMiniThumbMagic = magic;\n    }\n\n    // TODO: Change public to protected\n    public Uri contentUri(long id) {\n\n        // TODO: avoid using exception for most cases\n        try {\n            // does our uri already have an id (single image query)?\n            // if so just return it\n            long existingId = ContentUris.parseId(mBaseUri);\n            if (existingId != id) Log.e(TAG, \"id mismatch\");\n            return mBaseUri;\n        } catch (NumberFormatException ex) {\n            // otherwise tack on the id\n            return ContentUris.withAppendedId(mBaseUri, id);\n        }\n    }\n\n    public void deactivate() {\n        try {\n            invalidateCursor();\n        } catch (IllegalStateException e) {\n            // IllegalStateException may be thrown if the cursor is stale.\n            Log.e(TAG, \"Caught exception while deactivating cursor.\", e);\n        }\n        mMiniThumbFile.deactivate();\n    }\n\n    public int getCount() {\n        Cursor cursor = getCursor();\n        synchronized (cursor) {\n            return cursor.getCount();\n        }\n    }\n\n    public boolean isEmpty() {\n        return getCount() == 0;\n    }\n\n    private Cursor getCursor() {\n        synchronized (mCursor) {\n            if (mCursorDeactivated) {\n                mCursor.requery();\n                mCursorDeactivated = false;\n            }\n            return mCursor;\n        }\n    }\n\n    public IImage getImageAt(int i) {\n        BaseImage result = mCache.get(i);\n        if (result == null) {\n            Cursor cursor = getCursor();\n            synchronized (cursor) {\n                result = cursor.moveToPosition(i)\n                        ? loadImageFromCursor(cursor)\n                        : null;\n                mCache.put(i, result);\n            }\n        }\n        return result;\n    }\n\n    byte [] getMiniThumbFromFile(long id, byte [] data, long magicCheck) {\n        return mMiniThumbFile.getMiniThumbFromFile(id, data, magicCheck);\n    }\n\n    void saveMiniThumbToFile(Bitmap bitmap, long id, long magic)\n            throws IOException {\n        mMiniThumbFile.saveMiniThumbToFile(bitmap, id, magic);\n    }\n\n    void saveMiniThumbToFile(byte[] data, long id, long magic)\n            throws IOException {\n        mMiniThumbFile.saveMiniThumbToFile(data, id, magic);\n    }\n\n    public boolean removeImage(IImage image) {\n        // TODO: need to delete the thumbnails as well\n        if (mContentResolver.delete(image.fullSizeImageUri(), null, null) > 0) {\n            ((BaseImage) image).onRemove();\n            invalidateCursor();\n            invalidateCache();\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public boolean removeImageAt(int i) {\n        // TODO: need to delete the thumbnails as well\n        return removeImage(getImageAt(i));\n    }\n\n    protected abstract Cursor createCursor();\n\n    protected abstract BaseImage loadImageFromCursor(Cursor cursor);\n\n    protected abstract long getImageId(Cursor cursor);\n\n    protected void invalidateCursor() {\n        mCursor.deactivate();\n        mCursorDeactivated = true;\n    }\n\n    protected void invalidateCache() {\n        mCache.clear();\n    }\n\n    private static final Pattern sPathWithId = Pattern.compile(\"(.*)/\\\\d+\");\n\n    private static String getPathWithoutId(Uri uri) {\n        String path = uri.getPath();\n        Matcher matcher = sPathWithId.matcher(path);\n        return matcher.matches() ? matcher.group(1) : path;\n    }\n\n    private boolean isChildImageUri(Uri uri) {\n        // Sometimes, the URI of an image contains a query string with key\n        // \"bucketId\" inorder to restore the image list. However, the query\n        // string is not part of the mBaseUri. So, we check only other parts\n        // of the two Uri to see if they are the same.\n        Uri base = mBaseUri;\n        return Util.equals(base.getScheme(), uri.getScheme())\n                && Util.equals(base.getHost(), uri.getHost())\n                && Util.equals(base.getAuthority(), uri.getAuthority())\n                && Util.equals(base.getPath(), getPathWithoutId(uri));\n    }\n\n    public IImage getImageForUri(Uri uri) {\n        if (!isChildImageUri(uri)) return null;\n        // Find the id of the input URI.\n        long matchId;\n        try {\n            matchId = ContentUris.parseId(uri);\n        } catch (NumberFormatException ex) {\n            Log.i(TAG, \"fail to get id in: \" + uri, ex);\n            return null;\n        }\n        // TODO: design a better method to get URI of specified ID\n        Cursor cursor = getCursor();\n        synchronized (cursor) {\n            cursor.moveToPosition(-1); // before first\n            for (int i = 0; cursor.moveToNext(); ++i) {\n                if (getImageId(cursor) == matchId) {\n                    BaseImage image = mCache.get(i);\n                    if (image == null) {\n                        image = loadImageFromCursor(cursor);\n                        mCache.put(i, image);\n                    }\n                    return image;\n                }\n            }\n            return null;\n        }\n    }\n\n    public int getImageIndex(IImage image) {\n        return ((BaseImage) image).mIndex;\n    }\n}\n"}
{"before": "/*\n * Copyright (C) 2009 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.camera.gallery;\n\nimport com.android.camera.Util;\n\nimport android.graphics.Bitmap;\nimport android.net.Uri;\nimport android.os.Environment;\nimport android.util.Log;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\n\n// This class handles the mini-thumb file. A mini-thumb file consists\n// of blocks, indexed by id. Each block has BYTES_PER_MINTHUMB bytes in the\n// following format:\n//\n// 1 byte status (0 = empty, 1 = mini-thumb available)\n// 8 bytes magic (a magic number to match what's in the database)\n// 4 bytes data length (LEN)\n// LEN bytes jpeg data\n// (the remaining bytes are unused)\n//\nclass MiniThumbFile {\n    private static final String TAG = \"MiniThumbFile\";\n    \n    public static final int BYTES_PER_MINTHUMB = 10000;\n    private static final int HEADER_SIZE = 1 + 8 + 4;\n    private Uri mUri;\n    private RandomAccessFile mMiniThumbFile;\n\n    private String randomAccessFilePath(int version) {\n        String directoryName =\n                Environment.getExternalStorageDirectory().toString()\n                + \"/DCIM/.thumbnails\";\n        return directoryName + \"/.thumbdata\" + version + \"-\" + mUri.hashCode();\n    }\n\n    private void removeOldFile() {\n        String oldPath = randomAccessFilePath(3 - 1);\n        File oldFile = new File(oldPath);\n        if (oldFile.exists()) {\n            try {\n                oldFile.delete();\n            } catch (SecurityException ex) {\n                // ignore\n            }\n        }\n    }\n\n    private RandomAccessFile miniThumbDataFile() {\n        if (mMiniThumbFile == null) {\n            removeOldFile();\n            String path = randomAccessFilePath(3);\n            File directory = new File(path).getParentFile();\n            if (!directory.isDirectory()) {\n                if (!directory.mkdirs()) {\n                    Log.e(TAG, \"Unable to create .thumbnails directory \"\n                            + directory.toString());\n                }\n            }\n            File f = new File(path);\n            try {\n                mMiniThumbFile = new RandomAccessFile(f, \"rw\");\n            } catch (IOException ex) {\n                // Open as read-only so we can at least read the existing\n                // thumbnails.\n                try {\n                    mMiniThumbFile = new RandomAccessFile(f, \"r\");\n                } catch (IOException ex2) {\n                    // ignore exception\n                }\n            }\n        }\n        return mMiniThumbFile;\n    }\n\n    public MiniThumbFile(Uri uri) {\n        mUri = uri;\n    }\n\n    public void deactivate() {\n        if (mMiniThumbFile != null) {\n            try {\n                mMiniThumbFile.close();\n                mMiniThumbFile = null;\n            } catch (IOException ex) {\n                // ignore exception\n            }\n        }\n    }\n\n    // Get the magic number for the specified id in the mini-thumb file.\n    // Returns 0 if the magic is not available.\n    public long getMagic(long id) {\n        // check the mini thumb file for the right data.  Right is\n        // defined as having the right magic number at the offset\n        // reserved for this \"id\".\n        RandomAccessFile r = miniThumbDataFile();\n        if (r != null) {\n            synchronized (r) {\n                long pos = id * BYTES_PER_MINTHUMB;\n                try {\n                    // check that we can read the following 9 bytes\n                    // (1 for the \"status\" and 8 for the long)\n                    if (r.length() >= pos + 1 + 8) {\n                        r.seek(pos);\n                        if (r.readByte() == 1) {\n                            long fileMagic = r.readLong();\n                            return fileMagic;\n                        }\n                    }\n                } catch (IOException ex) {\n                    Log.v(TAG, \"Got exception checking file magic: \", ex);\n                }\n            }\n        }\n        return 0;\n    }\n\n    public void saveMiniThumbToFile(Bitmap bitmap, long id, long magic)\n            throws IOException {\n        byte[] data = Util.miniThumbData(bitmap);\n        saveMiniThumbToFile(data, id, magic);\n    }\n\n    public void saveMiniThumbToFile(byte[] data, long id, long magic)\n            throws IOException {\n        RandomAccessFile r = miniThumbDataFile();\n        if (r == null) return;\n\n        long pos = id * BYTES_PER_MINTHUMB;\n        synchronized (r) {\n            try {\n                if (data != null) {\n                    if (data.length > BYTES_PER_MINTHUMB - HEADER_SIZE) {\n                        // not enough space to store it.\n                        return;\n                    }\n                    r.seek(pos);\n                    r.writeByte(0);     // we have no data in this slot\n\n                    // if magic is 0 then leave it alone\n                    if (magic == 0) {\n                        r.skipBytes(8);\n                    } else {\n                        r.writeLong(magic);\n                    }\n                    r.writeInt(data.length);\n                    r.write(data);\n                    r.seek(pos);\n                    r.writeByte(1);  // we have data in this slot\n                }\n            } catch (IOException ex) {\n                Log.e(TAG, \"couldn't save mini thumbnail data for \"\n                        + id + \"; \", ex);\n                throw ex;\n            }\n        }\n    }\n\n    byte [] getMiniThumbFromFile(long id, byte [] data, long magicCheck) {\n        RandomAccessFile r = miniThumbDataFile();\n        if (r == null) return null;\n\n        long pos = id * BYTES_PER_MINTHUMB;\n        synchronized (r) {\n            try {\n                r.seek(pos);\n                if (r.readByte() == 1) {\n                    long magic = r.readLong();\n                    if (magic != magicCheck) {\n                        return null;\n                    }\n                    int length = r.readInt();\n                    int got = r.read(data, 0, length);\n                    if (got != length) return null;\n                    return data;\n                } else {\n                    return null;\n                }\n            } catch (IOException ex) {\n                return null;\n            }\n        }\n    }\n}\n", "after": "/*\n * Copyright (C) 2009 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.camera.gallery;\n\nimport com.android.camera.Util;\n\nimport android.graphics.Bitmap;\nimport android.net.Uri;\nimport android.os.Environment;\nimport android.util.Log;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\n\n// This class handles the mini-thumb file. A mini-thumb file consists\n// of blocks, indexed by id. Each block has BYTES_PER_MINTHUMB bytes in the\n// following format:\n//\n// 1 byte status (0 = empty, 1 = mini-thumb available)\n// 8 bytes magic (a magic number to match what's in the database)\n// 4 bytes data length (LEN)\n// LEN bytes jpeg data\n// (the remaining bytes are unused)\n//\nclass MiniThumbFile {\n    private static final String TAG = \"MiniThumbFile\";\n    private static final int MINI_THUMB_DATA_FILE_VERSION = 3;\n    public static final int BYTES_PER_MINTHUMB = 10000;\n    private static final int HEADER_SIZE = 1 + 8 + 4;\n    private Uri mUri;\n    private RandomAccessFile mMiniThumbFile;\n\n    private String randomAccessFilePath(int version) {\n        String directoryName =\n                Environment.getExternalStorageDirectory().toString()\n                + \"/DCIM/.thumbnails\";\n        return directoryName + \"/.thumbdata\" + version + \"-\" + mUri.hashCode();\n    }\n\n    private void removeOldFile() {\n        String oldPath = randomAccessFilePath(MINI_THUMB_DATA_FILE_VERSION - 1);\n        File oldFile = new File(oldPath);\n        if (oldFile.exists()) {\n            try {\n                oldFile.delete();\n            } catch (SecurityException ex) {\n                // ignore\n            }\n        }\n    }\n\n    private RandomAccessFile miniThumbDataFile() {\n        if (mMiniThumbFile == null) {\n            removeOldFile();\n            String path = randomAccessFilePath(MINI_THUMB_DATA_FILE_VERSION);\n            File directory = new File(path).getParentFile();\n            if (!directory.isDirectory()) {\n                if (!directory.mkdirs()) {\n                    Log.e(TAG, \"Unable to create .thumbnails directory \"\n                            + directory.toString());\n                }\n            }\n            File f = new File(path);\n            try {\n                mMiniThumbFile = new RandomAccessFile(f, \"rw\");\n            } catch (IOException ex) {\n                // Open as read-only so we can at least read the existing\n                // thumbnails.\n                try {\n                    mMiniThumbFile = new RandomAccessFile(f, \"r\");\n                } catch (IOException ex2) {\n                    // ignore exception\n                }\n            }\n        }\n        return mMiniThumbFile;\n    }\n\n    public MiniThumbFile(Uri uri) {\n        mUri = uri;\n    }\n\n    public void deactivate() {\n        if (mMiniThumbFile != null) {\n            try {\n                mMiniThumbFile.close();\n                mMiniThumbFile = null;\n            } catch (IOException ex) {\n                // ignore exception\n            }\n        }\n    }\n\n    // Get the magic number for the specified id in the mini-thumb file.\n    // Returns 0 if the magic is not available.\n    public long getMagic(long id) {\n        // check the mini thumb file for the right data.  Right is\n        // defined as having the right magic number at the offset\n        // reserved for this \"id\".\n        RandomAccessFile r = miniThumbDataFile();\n        if (r != null) {\n            synchronized (r) {\n                long pos = id * BYTES_PER_MINTHUMB;\n                try {\n                    // check that we can read the following 9 bytes\n                    // (1 for the \"status\" and 8 for the long)\n                    if (r.length() >= pos + 1 + 8) {\n                        r.seek(pos);\n                        if (r.readByte() == 1) {\n                            long fileMagic = r.readLong();\n                            return fileMagic;\n                        }\n                    }\n                } catch (IOException ex) {\n                    Log.v(TAG, \"Got exception checking file magic: \", ex);\n                }\n            }\n        }\n        return 0;\n    }\n\n    public void saveMiniThumbToFile(Bitmap bitmap, long id, long magic)\n            throws IOException {\n        byte[] data = Util.miniThumbData(bitmap);\n        saveMiniThumbToFile(data, id, magic);\n    }\n\n    public void saveMiniThumbToFile(byte[] data, long id, long magic)\n            throws IOException {\n        RandomAccessFile r = miniThumbDataFile();\n        if (r == null) return;\n\n        long pos = id * BYTES_PER_MINTHUMB;\n        synchronized (r) {\n            try {\n                if (data != null) {\n                    if (data.length > BYTES_PER_MINTHUMB - HEADER_SIZE) {\n                        // not enough space to store it.\n                        return;\n                    }\n                    r.seek(pos);\n                    r.writeByte(0);     // we have no data in this slot\n\n                    // if magic is 0 then leave it alone\n                    if (magic == 0) {\n                        r.skipBytes(8);\n                    } else {\n                        r.writeLong(magic);\n                    }\n                    r.writeInt(data.length);\n                    r.write(data);\n                    r.seek(pos);\n                    r.writeByte(1);  // we have data in this slot\n                }\n            } catch (IOException ex) {\n                Log.e(TAG, \"couldn't save mini thumbnail data for \"\n                        + id + \"; \", ex);\n                throw ex;\n            }\n        }\n    }\n\n    byte [] getMiniThumbFromFile(long id, byte [] data, long magicCheck) {\n        RandomAccessFile r = miniThumbDataFile();\n        if (r == null) return null;\n\n        long pos = id * BYTES_PER_MINTHUMB;\n        synchronized (r) {\n            try {\n                r.seek(pos);\n                if (r.readByte() == 1) {\n                    long magic = r.readLong();\n                    if (magic != magicCheck) {\n                        return null;\n                    }\n                    int length = r.readInt();\n                    int got = r.read(data, 0, length);\n                    if (got != length) return null;\n                    return data;\n                } else {\n                    return null;\n                }\n            } catch (IOException ex) {\n                return null;\n            }\n        }\n    }\n}\n"}
{"before": "/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.server.persistence;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.ByteBuffer;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.zip.Adler32;\nimport java.util.zip.CheckedInputStream;\nimport java.util.zip.CheckedOutputStream;\n\nimport org.apache.jute.BinaryInputArchive;\nimport org.apache.jute.BinaryOutputArchive;\nimport org.apache.jute.InputArchive;\nimport org.apache.jute.OutputArchive;\nimport org.apache.log4j.Logger;\nimport org.apache.zookeeper.server.DataTree;\nimport org.apache.zookeeper.server.util.SerializeUtils;\n\n/**\n * This class implements the snapshot interface.\n * it is responsible for storing, serializing\n * and deserializing the right snapshot.\n * and provides access to the snapshots.\n */\npublic class FileSnap implements SnapShot {\n    File snapDir;\n    \n    private static final long dbId=-1;\n    private static final Logger LOG = Logger.getLogger(FileSnap.class);\n    public final static int SNAP_MAGIC\n        = ByteBuffer.wrap(\"ZKSN\".getBytes()).getInt();\n    public FileSnap(File snapDir) {\n        this.snapDir = snapDir;\n    }\n\n    /**\n     * deserialize a data tree from the most recent snapshot\n     * @return the zxid of the snapshot\n     */\n    public long deserialize(DataTree dt, Map<Long, Integer> sessions)\n            throws IOException {\n        File snap = findMostRecentSnapshot();\n        if (snap == null) {\n            return -1L;\n        }\n        LOG.info(\"Reading snapshot \" + snap);\n        InputStream snapIS = new BufferedInputStream(new FileInputStream(snap));\n        CheckedInputStream crcIn = new CheckedInputStream(snapIS, new Adler32());\n        InputArchive ia=BinaryInputArchive.getArchive(crcIn);\n        deserialize(dt,sessions, ia);\n        long checkSum = crcIn.getChecksum().getValue();\n        long val = ia.readLong(\"val\");\n        if (val != checkSum) {\n            throw new IOException(\"CRC corruption in snapshot :  \" + snap);\n        }\n        snapIS.close();\n        crcIn.close();\n        dt.lastProcessedZxid = Util.getZxidFromName(snap.getName(), \"snapshot\");\n        return dt.lastProcessedZxid;\n    }\n\n    /**\n     * deserialize the datatree from an inputarchive\n     * @param dt the datatree to be serialized into\n     * @param sessions the sessions to be filled up\n     * @param ia the input archive to restore from\n     * @throws IOException\n     */\n    protected void deserialize(DataTree dt, Map<Long, Integer> sessions,\n            InputArchive ia) throws IOException {\n        FileHeader header = new FileHeader();\n        header.deserialize(ia, \"fileheader\");\n        if (header.getMagic() != SNAP_MAGIC) {\n            throw new IOException(\"mismatching magic headers \"\n                    + header.getMagic() + \n                    \" !=  \" + FileSnap.SNAP_MAGIC);\n        }\n        SerializeUtils.deserializeSnapshot(dt,ia,sessions);\n    }\n\n    /**\n     * find the most recent snapshot in the database.\n     * @return the file containing the most recent snapshot\n     */\n    public File findMostRecentSnapshot() throws IOException {\n        List<File> files = Util.sortDataDir(snapDir.listFiles(), \"snapshot\", false);\n        for (File f : files) {\n            if(Util.isValidSnapshot(f))\n                return f;\n        }\n        return null;\n    }\n\n    /**\n     * serialize the datatree and sessions\n     * @param dt the datatree to be serialized\n     * @param sessions the sessions to be serialized\n     * @param oa the output archive to serialize into\n     * @param header the header of this snapshot\n     * @throws IOException\n     */\n    protected void serialize(DataTree dt,Map<Long, Integer> sessions,\n            OutputArchive oa, FileHeader header) throws IOException {\n        // this is really a programmatic error and not something that can\n        // happen at runtime\n        if(header==null)\n            throw new IllegalStateException(\n                    \"Snapshot's not open for writing: uninitialized header\");\n        header.serialize(oa, \"fileheader\");\n        SerializeUtils.serializeSnapshot(dt,oa,sessions);\n    }\n\n    /**\n     * serialize the datatree and session into the file snapshot\n     * @param dt the datatree to be serialized\n     * @param sessions the sessions to be serialized\n     * @param snapShot the file to store snapshot into\n     */\n    public void serialize(DataTree dt, Map<Long, Integer> sessions, File snapShot)\n            throws IOException {\n        OutputStream sessOS = new BufferedOutputStream(new FileOutputStream(snapShot));\n        CheckedOutputStream crcOut = new CheckedOutputStream(sessOS, new Adler32());\n        //CheckedOutputStream cout = new CheckedOutputStream()\n        OutputArchive oa = BinaryOutputArchive.getArchive(crcOut);\n        FileHeader header = new FileHeader(SNAP_MAGIC, 2, dbId);\n        serialize(dt,sessions,oa, header);\n        long val = crcOut.getChecksum().getValue();\n        oa.writeLong(val, \"val\");\n        oa.writeString(\"/\", \"path\");\n        sessOS.flush();\n        crcOut.close();\n        sessOS.close();\n    }\n\n }", "after": "/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.server.persistence;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.ByteBuffer;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.zip.Adler32;\nimport java.util.zip.CheckedInputStream;\nimport java.util.zip.CheckedOutputStream;\n\nimport org.apache.jute.BinaryInputArchive;\nimport org.apache.jute.BinaryOutputArchive;\nimport org.apache.jute.InputArchive;\nimport org.apache.jute.OutputArchive;\nimport org.apache.log4j.Logger;\nimport org.apache.zookeeper.server.DataTree;\nimport org.apache.zookeeper.server.util.SerializeUtils;\n\n/**\n * This class implements the snapshot interface.\n * it is responsible for storing, serializing\n * and deserializing the right snapshot.\n * and provides access to the snapshots.\n */\npublic class FileSnap implements SnapShot {\n    File snapDir;\n    private static final int VERSION=2;\n    private static final long dbId=-1;\n    private static final Logger LOG = Logger.getLogger(FileSnap.class);\n    public final static int SNAP_MAGIC\n        = ByteBuffer.wrap(\"ZKSN\".getBytes()).getInt();\n    public FileSnap(File snapDir) {\n        this.snapDir = snapDir;\n    }\n\n    /**\n     * deserialize a data tree from the most recent snapshot\n     * @return the zxid of the snapshot\n     */\n    public long deserialize(DataTree dt, Map<Long, Integer> sessions)\n            throws IOException {\n        File snap = findMostRecentSnapshot();\n        if (snap == null) {\n            return -1L;\n        }\n        LOG.info(\"Reading snapshot \" + snap);\n        InputStream snapIS = new BufferedInputStream(new FileInputStream(snap));\n        CheckedInputStream crcIn = new CheckedInputStream(snapIS, new Adler32());\n        InputArchive ia=BinaryInputArchive.getArchive(crcIn);\n        deserialize(dt,sessions, ia);\n        long checkSum = crcIn.getChecksum().getValue();\n        long val = ia.readLong(\"val\");\n        if (val != checkSum) {\n            throw new IOException(\"CRC corruption in snapshot :  \" + snap);\n        }\n        snapIS.close();\n        crcIn.close();\n        dt.lastProcessedZxid = Util.getZxidFromName(snap.getName(), \"snapshot\");\n        return dt.lastProcessedZxid;\n    }\n\n    /**\n     * deserialize the datatree from an inputarchive\n     * @param dt the datatree to be serialized into\n     * @param sessions the sessions to be filled up\n     * @param ia the input archive to restore from\n     * @throws IOException\n     */\n    protected void deserialize(DataTree dt, Map<Long, Integer> sessions,\n            InputArchive ia) throws IOException {\n        FileHeader header = new FileHeader();\n        header.deserialize(ia, \"fileheader\");\n        if (header.getMagic() != SNAP_MAGIC) {\n            throw new IOException(\"mismatching magic headers \"\n                    + header.getMagic() + \n                    \" !=  \" + FileSnap.SNAP_MAGIC);\n        }\n        SerializeUtils.deserializeSnapshot(dt,ia,sessions);\n    }\n\n    /**\n     * find the most recent snapshot in the database.\n     * @return the file containing the most recent snapshot\n     */\n    public File findMostRecentSnapshot() throws IOException {\n        List<File> files = Util.sortDataDir(snapDir.listFiles(), \"snapshot\", false);\n        for (File f : files) {\n            if(Util.isValidSnapshot(f))\n                return f;\n        }\n        return null;\n    }\n\n    /**\n     * serialize the datatree and sessions\n     * @param dt the datatree to be serialized\n     * @param sessions the sessions to be serialized\n     * @param oa the output archive to serialize into\n     * @param header the header of this snapshot\n     * @throws IOException\n     */\n    protected void serialize(DataTree dt,Map<Long, Integer> sessions,\n            OutputArchive oa, FileHeader header) throws IOException {\n        // this is really a programmatic error and not something that can\n        // happen at runtime\n        if(header==null)\n            throw new IllegalStateException(\n                    \"Snapshot's not open for writing: uninitialized header\");\n        header.serialize(oa, \"fileheader\");\n        SerializeUtils.serializeSnapshot(dt,oa,sessions);\n    }\n\n    /**\n     * serialize the datatree and session into the file snapshot\n     * @param dt the datatree to be serialized\n     * @param sessions the sessions to be serialized\n     * @param snapShot the file to store snapshot into\n     */\n    public void serialize(DataTree dt, Map<Long, Integer> sessions, File snapShot)\n            throws IOException {\n        OutputStream sessOS = new BufferedOutputStream(new FileOutputStream(snapShot));\n        CheckedOutputStream crcOut = new CheckedOutputStream(sessOS, new Adler32());\n        //CheckedOutputStream cout = new CheckedOutputStream()\n        OutputArchive oa = BinaryOutputArchive.getArchive(crcOut);\n        FileHeader header = new FileHeader(SNAP_MAGIC, VERSION, dbId);\n        serialize(dt,sessions,oa, header);\n        long val = crcOut.getChecksum().getValue();\n        oa.writeLong(val, \"val\");\n        oa.writeString(\"/\", \"path\");\n        sessOS.flush();\n        crcOut.close();\n        sessOS.close();\n    }\n\n }"}
{"before": "/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.server.persistence;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.ByteBuffer;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.zip.Adler32;\nimport java.util.zip.CheckedInputStream;\nimport java.util.zip.CheckedOutputStream;\n\nimport org.apache.jute.BinaryInputArchive;\nimport org.apache.jute.BinaryOutputArchive;\nimport org.apache.jute.InputArchive;\nimport org.apache.jute.OutputArchive;\nimport org.apache.log4j.Logger;\nimport org.apache.zookeeper.server.DataTree;\nimport org.apache.zookeeper.server.util.SerializeUtils;\n\n/**\n * This class implements the snapshot interface.\n * it is responsible for storing, serializing\n * and deserializing the right snapshot.\n * and provides access to the snapshots.\n */\npublic class FileSnap implements SnapShot {\n    File snapDir;\n    \n    private static final long dbId=-1;\n    private static final Logger LOG = Logger.getLogger(FileSnap.class);\n    public final static int SNAP_MAGIC\n        = ByteBuffer.wrap(\"ZKSN\".getBytes()).getInt();\n    public FileSnap(File snapDir) {\n        this.snapDir = snapDir;\n    }\n\n    /**\n     * deserialize a data tree from the most recent snapshot\n     * @return the zxid of the snapshot\n     */\n    public long deserialize(DataTree dt, Map<Long, Integer> sessions)\n            throws IOException {\n        File snap = findMostRecentSnapshot();\n        if (snap == null) {\n            return -1L;\n        }\n        LOG.info(\"Reading snapshot \" + snap);\n        InputStream snapIS = new BufferedInputStream(new FileInputStream(snap));\n        CheckedInputStream crcIn = new CheckedInputStream(snapIS, new Adler32());\n        InputArchive ia=BinaryInputArchive.getArchive(crcIn);\n        deserialize(dt,sessions, ia);\n        long checkSum = crcIn.getChecksum().getValue();\n        long val = ia.readLong(\"val\");\n        if (val != checkSum) {\n            throw new IOException(\"CRC corruption in snapshot :  \" + snap);\n        }\n        snapIS.close();\n        crcIn.close();\n        dt.lastProcessedZxid = Util.getZxidFromName(snap.getName(), \"snapshot\");\n        return dt.lastProcessedZxid;\n    }\n\n    /**\n     * deserialize the datatree from an inputarchive\n     * @param dt the datatree to be serialized into\n     * @param sessions the sessions to be filled up\n     * @param ia the input archive to restore from\n     * @throws IOException\n     */\n    protected void deserialize(DataTree dt, Map<Long, Integer> sessions,\n            InputArchive ia) throws IOException {\n        FileHeader header = new FileHeader();\n        header.deserialize(ia, \"fileheader\");\n        SerializeUtils.deserializeSnapshot(dt,ia,sessions);\n    }\n\n    /**\n     * find the most recent snapshot in the database.\n     * @return the file containing the most recent snapshot\n     */\n    public File findMostRecentSnapshot() throws IOException {\n        List<File> files = Util.sortDataDir(snapDir.listFiles(), \"snapshot\", false);\n        for (File f : files) {\n            if(Util.isValidSnapshot(f))\n                return f;\n        }\n        return null;\n    }\n\n    /**\n     * serialize the datatree and sessions\n     * @param dt the datatree to be serialized\n     * @param sessions the sessions to be serialized\n     * @param oa the output archive to serialize into\n     * @param header the header of this snapshot\n     * @throws IOException\n     */\n    protected void serialize(DataTree dt,Map<Long, Integer> sessions,\n            OutputArchive oa, FileHeader header) throws IOException {\n        // this is really a programmatic error and not something that can\n        // happen at runtime\n        if(header==null)\n            throw new IllegalStateException(\n                    \"Snapshot's not open for writing: uninitialized header\");\n        header.serialize(oa, \"fileheader\");\n        SerializeUtils.serializeSnapshot(dt,oa,sessions);\n    }\n\n    /**\n     * serialize the datatree and session into the file snapshot\n     * @param dt the datatree to be serialized\n     * @param sessions the sessions to be serialized\n     * @param snapShot the file to store snapshot into\n     */\n    public void serialize(DataTree dt, Map<Long, Integer> sessions, File snapShot)\n            throws IOException {\n        OutputStream sessOS = new BufferedOutputStream(new FileOutputStream(snapShot));\n        CheckedOutputStream crcOut = new CheckedOutputStream(sessOS, new Adler32());\n        //CheckedOutputStream cout = new CheckedOutputStream()\n        OutputArchive oa = BinaryOutputArchive.getArchive(crcOut);\n        FileHeader header = new FileHeader(SNAP_MAGIC, 2, dbId);\n        serialize(dt,sessions,oa, header);\n        long val = crcOut.getChecksum().getValue();\n        oa.writeLong(val, \"val\");\n        oa.writeString(\"/\", \"path\");\n        sessOS.flush();\n        crcOut.close();\n        sessOS.close();\n    }\n\n }", "after": "/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.server.persistence;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.ByteBuffer;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.zip.Adler32;\nimport java.util.zip.CheckedInputStream;\nimport java.util.zip.CheckedOutputStream;\n\nimport org.apache.jute.BinaryInputArchive;\nimport org.apache.jute.BinaryOutputArchive;\nimport org.apache.jute.InputArchive;\nimport org.apache.jute.OutputArchive;\nimport org.apache.log4j.Logger;\nimport org.apache.zookeeper.server.DataTree;\nimport org.apache.zookeeper.server.util.SerializeUtils;\n\n/**\n * This class implements the snapshot interface.\n * it is responsible for storing, serializing\n * and deserializing the right snapshot.\n * and provides access to the snapshots.\n */\npublic class FileSnap implements SnapShot {\n    File snapDir;\n    private static final int VERSION=2;\n    private static final long dbId=-1;\n    private static final Logger LOG = Logger.getLogger(FileSnap.class);\n    public final static int SNAP_MAGIC\n        = ByteBuffer.wrap(\"ZKSN\".getBytes()).getInt();\n    public FileSnap(File snapDir) {\n        this.snapDir = snapDir;\n    }\n\n    /**\n     * deserialize a data tree from the most recent snapshot\n     * @return the zxid of the snapshot\n     */\n    public long deserialize(DataTree dt, Map<Long, Integer> sessions)\n            throws IOException {\n        File snap = findMostRecentSnapshot();\n        if (snap == null) {\n            return -1L;\n        }\n        LOG.info(\"Reading snapshot \" + snap);\n        InputStream snapIS = new BufferedInputStream(new FileInputStream(snap));\n        CheckedInputStream crcIn = new CheckedInputStream(snapIS, new Adler32());\n        InputArchive ia=BinaryInputArchive.getArchive(crcIn);\n        deserialize(dt,sessions, ia);\n        long checkSum = crcIn.getChecksum().getValue();\n        long val = ia.readLong(\"val\");\n        if (val != checkSum) {\n            throw new IOException(\"CRC corruption in snapshot :  \" + snap);\n        }\n        snapIS.close();\n        crcIn.close();\n        dt.lastProcessedZxid = Util.getZxidFromName(snap.getName(), \"snapshot\");\n        return dt.lastProcessedZxid;\n    }\n\n    /**\n     * deserialize the datatree from an inputarchive\n     * @param dt the datatree to be serialized into\n     * @param sessions the sessions to be filled up\n     * @param ia the input archive to restore from\n     * @throws IOException\n     */\n    protected void deserialize(DataTree dt, Map<Long, Integer> sessions,\n            InputArchive ia) throws IOException {\n        FileHeader header = new FileHeader();\n        header.deserialize(ia, \"fileheader\");\n        SerializeUtils.deserializeSnapshot(dt,ia,sessions);\n    }\n\n    /**\n     * find the most recent snapshot in the database.\n     * @return the file containing the most recent snapshot\n     */\n    public File findMostRecentSnapshot() throws IOException {\n        List<File> files = Util.sortDataDir(snapDir.listFiles(), \"snapshot\", false);\n        for (File f : files) {\n            if(Util.isValidSnapshot(f))\n                return f;\n        }\n        return null;\n    }\n\n    /**\n     * serialize the datatree and sessions\n     * @param dt the datatree to be serialized\n     * @param sessions the sessions to be serialized\n     * @param oa the output archive to serialize into\n     * @param header the header of this snapshot\n     * @throws IOException\n     */\n    protected void serialize(DataTree dt,Map<Long, Integer> sessions,\n            OutputArchive oa, FileHeader header) throws IOException {\n        // this is really a programmatic error and not something that can\n        // happen at runtime\n        if(header==null)\n            throw new IllegalStateException(\n                    \"Snapshot's not open for writing: uninitialized header\");\n        header.serialize(oa, \"fileheader\");\n        SerializeUtils.serializeSnapshot(dt,oa,sessions);\n    }\n\n    /**\n     * serialize the datatree and session into the file snapshot\n     * @param dt the datatree to be serialized\n     * @param sessions the sessions to be serialized\n     * @param snapShot the file to store snapshot into\n     */\n    public void serialize(DataTree dt, Map<Long, Integer> sessions, File snapShot)\n            throws IOException {\n        OutputStream sessOS = new BufferedOutputStream(new FileOutputStream(snapShot));\n        CheckedOutputStream crcOut = new CheckedOutputStream(sessOS, new Adler32());\n        //CheckedOutputStream cout = new CheckedOutputStream()\n        OutputArchive oa = BinaryOutputArchive.getArchive(crcOut);\n        FileHeader header = new FileHeader(SNAP_MAGIC, VERSION, dbId);\n        serialize(dt,sessions,oa, header);\n        long val = crcOut.getChecksum().getValue();\n        oa.writeLong(val, \"val\");\n        oa.writeString(\"/\", \"path\");\n        sessOS.flush();\n        crcOut.close();\n        sessOS.close();\n    }\n\n }"}
