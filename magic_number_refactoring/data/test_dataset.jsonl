{"magic_number_smell": "            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > 50 ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;", "refactored_code": "    private static final int INET_CONDITION_THRESHOLD = 50;\n            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;"}
{"magic_number_smell": "        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+5*1000) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }", "refactored_code": "    private static final long MIN_TIME_BETWEEN_GCS = 5*1000;\n        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+MIN_TIME_BETWEEN_GCS) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }"}
{"magic_number_smell": "\t\t\treturn getInt(\"rate\");\n\t\t}\n\n\t\treturn 5;\n\t}\n\n\t/**", "refactored_code": "\tprivate static final int DEFAULT_ATTACK_RATE = 5;\n\t\t\treturn getInt(\"rate\");\n\t\t}\n\n\t\treturn DEFAULT_ATTACK_RATE;\n\t}\n\n\t/**"}
{"magic_number_smell": "    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);"}
{"magic_number_smell": "\n                        // track and wait for the wire Component\n                        String filterString = \"(\" + ConfigurationService.KURA_SERVICE_PID + \"=\" + temporaryName + \")\";\n                        ServiceUtil.waitForService(filterString, 60, TimeUnit.SECONDS);\n\n                        conf = cs.getComponentConfiguration(temporaryName);\n                        comp = createMetatypeOnlyGwtComponentConfiguration(conf);", "refactored_code": "    private static final int SERVICE_WAIT_TIMEOUT = 60;\n\n                        // track and wait for the wire Component\n                        String filterString = \"(\" + ConfigurationService.KURA_SERVICE_PID + \"=\" + temporaryName + \")\";\n                        ServiceUtil.waitForService(filterString, SERVICE_WAIT_TIMEOUT, TimeUnit.SECONDS);\n\n                        conf = cs.getComponentConfiguration(temporaryName);\n                        comp = createMetatypeOnlyGwtComponentConfiguration(conf);"}
{"magic_number_smell": "        Sort sortByMetadataChangeDate = SortUtils.createSort(Sort.Direction.DESC, Metadata_.dataInfo, MetadataDataInfo_.changeDate);\n        int currentPage = 0;\n        Page<Pair<Integer, ISODate>> results = metadataUtils.findAllIdsAndChangeDates(\n            PageRequest.of(currentPage, 50000, sortByMetadataChangeDate));\n\n        // index all metadata in DBMS if needed\n        while (results.getNumberOfElements() > 0) {", "refactored_code": "    private static final int METADATA_BATCH_PAGE_SIZE = 50000;\n        Sort sortByMetadataChangeDate = SortUtils.createSort(Sort.Direction.DESC, Metadata_.dataInfo, MetadataDataInfo_.changeDate);\n        int currentPage = 0;\n        Page<Pair<Integer, ISODate>> results = metadataUtils.findAllIdsAndChangeDates(\n            PageRequest.of(currentPage, METADATA_BATCH_PAGE_SIZE, sortByMetadataChangeDate));\n\n        // index all metadata in DBMS if needed\n        while (results.getNumberOfElements() > 0) {"}
{"magic_number_smell": "          final double estimatedCardinality = union.getEstimate();\n          final long estimatedNumShards;\n          if (estimatedCardinality <= 0) {\n            estimatedNumShards = 7L;\n            LOG.warn(\"Estimated cardinality for union of estimates is zero or less: %.2f, setting num shards to %d\",\n                     estimatedCardinality, estimatedNumShards\n            );", "refactored_code": "  private static final long DEFAULT_NUM_SHARDS_WHEN_ESTIMATE_GOES_NEGATIVE = 7L;\n          final double estimatedCardinality = union.getEstimate();\n          final long estimatedNumShards;\n          if (estimatedCardinality <= 0) {\n            estimatedNumShards = DEFAULT_NUM_SHARDS_WHEN_ESTIMATE_GOES_NEGATIVE;\n            LOG.warn(\"Estimated cardinality for union of estimates is zero or less: %.2f, setting num shards to %d\",\n                     estimatedCardinality, estimatedNumShards\n            );"}
{"magic_number_smell": "  public void onResourceReady(Resource<R> resource, DataSource dataSource) {\n    this.resource = resource;\n    this.dataSource = dataSource;\n    MAIN_THREAD_HANDLER.obtainMessage(1, this).sendToTarget();\n  }\n\n  @Override", "refactored_code": "  private static final int MSG_COMPLETE = 1;\n  public void onResourceReady(Resource<R> resource, DataSource dataSource) {\n    this.resource = resource;\n    this.dataSource = dataSource;\n    MAIN_THREAD_HANDLER.obtainMessage(MSG_COMPLETE, this).sendToTarget();\n  }\n\n  @Override"}
{"magic_number_smell": "            dataString += \" %s/%s\";\n        }\n        int fieldLength = getNumberOfDigits(totalTests);\n        appendText(format(dataString + \"\\n\", timestamp, formatLong(opsSum, 14),\n                formatLong(opsDelta, 14), formatDouble(opsPerSecDelta, 14),\n                formatLong(numberOfTests, 14 - fieldLength), formatLong(totalTests, fieldLength)), file);\n    }", "refactored_code": "    private static final int NUMBER_FORMAT_LENGTH = 14;\n            dataString += \" %s/%s\";\n        }\n        int fieldLength = getNumberOfDigits(totalTests);\n        appendText(format(dataString + \"\\n\", timestamp, formatLong(opsSum, NUMBER_FORMAT_LENGTH),\n                formatLong(opsDelta, NUMBER_FORMAT_LENGTH), formatDouble(opsPerSecDelta, NUMBER_FORMAT_LENGTH),\n                formatLong(numberOfTests, NUMBER_FORMAT_LENGTH - fieldLength), formatLong(totalTests, fieldLength)), file);\n    }"}
{"magic_number_smell": "        if (this.currEntry != null && this.currEntry.isGNULongNameEntry()) {\n            // read in the name\n            StringBuffer longName = new StringBuffer();\n            byte[] buf = new byte[256];\n            int length = 0;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));", "refactored_code": "    private static final int SMALL_BUFFER_SIZE = 256;\n        if (this.currEntry != null && this.currEntry.isGNULongNameEntry()) {\n            // read in the name\n            StringBuffer longName = new StringBuffer();\n            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n            int length = 0;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));"}
{"magic_number_smell": "\n\t/**\n\t * Convenient way to encode faces that may be null.\n\t * Null is returned as {@link #6}. \n\t * Use {@link #faceFromIndex(int)} to retrieve encoded face.\n\t */\n\tpublic static int toFaceIndex(Direction face) {", "refactored_code": "\tpublic static final int NULL_FACE_ID = 6;\n\n\t/**\n\t * Convenient way to encode faces that may be null.\n\t * Null is returned as {@link #NULL_FACE_ID}. \n\t * Use {@link #faceFromIndex(int)} to retrieve encoded face.\n\t */\n\tpublic static int toFaceIndex(Direction face) {"}
{"magic_number_smell": "    /**\n     * Offset within the log meta data where the active term id is stored.\n     */\n    public static final int LOG_META_DATA_SECTION_INDEX = 3 * 2;\n\n    /**\n     * Offset within the log meta data where the active term id is stored.", "refactored_code": "    public static final int PARTITION_COUNT = 3;\n    /**\n     * Offset within the log meta data where the active term id is stored.\n     */\n    public static final int LOG_META_DATA_SECTION_INDEX = PARTITION_COUNT * 2;\n\n    /**\n     * Offset within the log meta data where the active term id is stored."}
{"magic_number_smell": "\t\tWebcam.setDriver(new DummyDriver());\n\n\t\tfinal Webcam w = Webcam.getDefault();\n\t\tfinal WebcamPanel p = new WebcamPanel(w, new Dimension(256, height), false);\n\n\t\tw.open();\n\t\tp.repaint();", "refactored_code": "\tprivate final int width = 256;\n\t\tWebcam.setDriver(new DummyDriver());\n\n\t\tfinal Webcam w = Webcam.getDefault();\n\t\tfinal WebcamPanel p = new WebcamPanel(w, new Dimension(width, height), false);\n\n\t\tw.open();\n\t\tp.repaint();"}
{"magic_number_smell": "     * @return true if the magic is valid\n     */\n    private boolean isGoodMagic(int magic) {\n        return magic == 0xcafebabe;\n    }\n\n    /**", "refactored_code": "    private static final int CLASS_FILE_MAGIC = 0xcafebabe;\n     * @return true if the magic is valid\n     */\n    private boolean isGoodMagic(int magic) {\n        return magic == CLASS_FILE_MAGIC;\n    }\n\n    /**"}
{"magic_number_smell": "        GT_Multiblock_Tooltip_Builder tt = new GT_Multiblock_Tooltip_Builder();\n        tt.addInfo(\"Transcending Dimensional Boundaries.\")\n                .addInfo(\"Takes \" + EnumChatFormatting.RED\n                        + GT_Utility.formatNumbers(3600d * 8d * 20d / (3600 * 20)) + EnumChatFormatting.GRAY\n                        + \" hours of continuous run time to fully breach dimensional\")\n                .addInfo(\"boundaries and achieve maximum efficiency. This reduces fuel\")\n                .addInfo(\"consumption by up to \" + EnumChatFormatting.RED", "refactored_code": "    private static final double max_efficiency_time_in_ticks = 3600d * 8d * 20d;\n        GT_Multiblock_Tooltip_Builder tt = new GT_Multiblock_Tooltip_Builder();\n        tt.addInfo(\"Transcending Dimensional Boundaries.\")\n                .addInfo(\"Takes \" + EnumChatFormatting.RED\n                        + GT_Utility.formatNumbers(max_efficiency_time_in_ticks / (3600 * 20)) + EnumChatFormatting.GRAY\n                        + \" hours of continuous run time to fully breach dimensional\")\n                .addInfo(\"boundaries and achieve maximum efficiency. This reduces fuel\")\n                .addInfo(\"consumption by up to \" + EnumChatFormatting.RED"}
{"magic_number_smell": "  // an application-wide executor to run concurrent blaze builds remotely\n  private static final ListeningExecutorService remoteBuildExecutor =\n      MoreExecutors.listeningDecorator(\n          AppExecutorUtil.createBoundedApplicationPoolExecutor(\"FetchExecutor\", 8));\n\n  // a per-project executor to run single-threaded sync phases\n  private final ListeningExecutorService singleThreadedExecutor;", "refactored_code": "  private static final int MAX_BUILD_TASKS = 8;\n  // an application-wide executor to run concurrent blaze builds remotely\n  private static final ListeningExecutorService remoteBuildExecutor =\n      MoreExecutors.listeningDecorator(\n          AppExecutorUtil.createBoundedApplicationPoolExecutor(\"FetchExecutor\", MAX_BUILD_TASKS));\n\n  // a per-project executor to run single-threaded sync phases\n  private final ListeningExecutorService singleThreadedExecutor;"}
{"magic_number_smell": "    private final ScheduledExecutorService scheduledExecutorService;\n\n    public JsonRpc2_0Neow3j(Neow3jService neow3jService) {\n        this(neow3jService, 15 * 1000, Async.defaultExecutorService());\n    }\n\n    public JsonRpc2_0Neow3j(", "refactored_code": "    public static final int DEFAULT_BLOCK_TIME = 15 * 1000;\n    private final ScheduledExecutorService scheduledExecutorService;\n\n    public JsonRpc2_0Neow3j(Neow3jService neow3jService) {\n        this(neow3jService, DEFAULT_BLOCK_TIME, Async.defaultExecutorService());\n    }\n\n    public JsonRpc2_0Neow3j("}
{"magic_number_smell": "    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #-1}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode", "refactored_code": "    public static final int INFINITE = -1;\n    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #INFINITE}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode"}
{"magic_number_smell": "    RecordEventsReadableSpanImpl span = createTestSpan(Kind.INTERNAL);\n    spanDoWork(span, null);\n    Span spanProto = span.toSpanProto();\n    long timeInNanos = (startTime.getSeconds() + 1) * TimeUnit.SECONDS.toNanos(1);\n    TimedEvent timedEvent = TimedEvent.create(timeInNanos, event);\n    verifySpanProto(\n        spanProto,", "refactored_code": "  private static final long NANOS_PER_SECOND = TimeUnit.SECONDS.toNanos(1);\n    RecordEventsReadableSpanImpl span = createTestSpan(Kind.INTERNAL);\n    spanDoWork(span, null);\n    Span spanProto = span.toSpanProto();\n    long timeInNanos = (startTime.getSeconds() + 1) * NANOS_PER_SECOND;\n    TimedEvent timedEvent = TimedEvent.create(timeInNanos, event);\n    verifySpanProto(\n        spanProto,"}
{"magic_number_smell": "    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #-1}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode", "refactored_code": "    public static final int INFINITE = -1;\n    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #INFINITE}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode"}
{"magic_number_smell": "        long startTime = System.currentTimeMillis();\n\n        // only track progress for files larger than 100kb in verbose mode\n        boolean trackProgress = getVerbose() && filesize > 102400;\n        // since filesize keeps on decreasing we have to store the\n        // initial filesize\n        long initFilesize = filesize;", "refactored_code": "    private static final int HUNDRED_KILOBYTES = 102400;\n        long startTime = System.currentTimeMillis();\n\n        // only track progress for files larger than 100kb in verbose mode\n        boolean trackProgress = getVerbose() && filesize > HUNDRED_KILOBYTES;\n        // since filesize keeps on decreasing we have to store the\n        // initial filesize\n        long initFilesize = filesize;"}
{"magic_number_smell": "    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #-1}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode", "refactored_code": "    public static final int INFINITE = -1;\n    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #INFINITE}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode"}
{"magic_number_smell": "        assertEquals(statistics1.getMin(), statistics2.getMin());\n        assertEquals(statistics1.getMax(), statistics2.getMax());\n        assertEquals(statistics1.getFirst(), statistics2.getFirst());\n        assertEquals(statistics1.getSum(), statistics2.getSum(), 0.0001d);\n        assertEquals(statistics1.getLast(), statistics2.getLast());\n      }\n    }", "refactored_code": "  private static final double maxError = 0.0001d;\n        assertEquals(statistics1.getMin(), statistics2.getMin());\n        assertEquals(statistics1.getMax(), statistics2.getMax());\n        assertEquals(statistics1.getFirst(), statistics2.getFirst());\n        assertEquals(statistics1.getSum(), statistics2.getSum(), maxError);\n        assertEquals(statistics1.getLast(), statistics2.getLast());\n      }\n    }"}
{"magic_number_smell": "\n    @Override\n    public boolean handleMessage(Message message) {\n      if (message.what == 1) {\n        Resource<?> resource = (Resource<?>) message.obj;\n        resource.recycle();\n        return true;", "refactored_code": "    public static final int RECYCLE_RESOURCE = 1;\n\n    @Override\n    public boolean handleMessage(Message message) {\n      if (message.what == RECYCLE_RESOURCE) {\n        Resource<?> resource = (Resource<?>) message.obj;\n        resource.recycle();\n        return true;"}
{"magic_number_smell": "        if (isP2P) {\r\n            return this.progress_max;\r\n        } else {\r\n            return (int) (this.100);\r\n        }\r\n    }\r\n\r", "refactored_code": "    protected final long fileSize = 100;\r\n        if (isP2P) {\r\n            return this.progress_max;\r\n        } else {\r\n            return (int) (this.fileSize);\r\n        }\r\n    }\r\n\r"}
{"magic_number_smell": "    /**\n     * Offset within the log meta data where the active term id is stored.\n     */\n    public static final int LOG_META_DATA_SECTION_INDEX = 3 * 2;\n\n    /**\n     * Offset within the log meta data where the active term id is stored.", "refactored_code": "    public static final int PARTITION_COUNT = 3;\n    /**\n     * Offset within the log meta data where the active term id is stored.\n     */\n    public static final int LOG_META_DATA_SECTION_INDEX = PARTITION_COUNT * 2;\n\n    /**\n     * Offset within the log meta data where the active term id is stored."}
{"magic_number_smell": "     */\n    public static String shortenPath(File file) {\n        String path = removeCWD(file);\n        if (path.length() < 12 * 2) {\n            return path;\n        }\n        return path.substring(0, 12)", "refactored_code": "    private static final int SHORTENED_PATH_LENGTH = 12;\n     */\n    public static String shortenPath(File file) {\n        String path = removeCWD(file);\n        if (path.length() < SHORTENED_PATH_LENGTH * 2) {\n            return path;\n        }\n        return path.substring(0, SHORTENED_PATH_LENGTH)"}
{"magic_number_smell": "\n\t\t\tInterest i = null;\n\n\t\t\twhile (_sentInterests.size() + inOrderSegments.size() + outOfOrderSegments.size() + 0 < SystemConfiguration.PIPELINE_SIZE && !doneAdvancing) {\n\t\t\t\tif (Log.isLoggable(Log.FAC_PIPELINE, Level.INFO))\n\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: _sentInterests.size() = {0} inOrderSegments.size() = {1} outOfOrderSegments.size()  = {2} 0 = {3} total = {4}\", _sentInterests.size(), inOrderSegments.size(), outOfOrderSegments.size(), 0, (_sentInterests.size() + inOrderSegments.size() + outOfOrderSegments.size() + 0) );\n", "refactored_code": "\tprivate final int processingDefer = 0;\n\n\t\t\tInterest i = null;\n\n\t\t\twhile (_sentInterests.size() + inOrderSegments.size() + outOfOrderSegments.size() + processingDefer < SystemConfiguration.PIPELINE_SIZE && !doneAdvancing) {\n\t\t\t\tif (Log.isLoggable(Log.FAC_PIPELINE, Level.INFO))\n\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: _sentInterests.size() = {0} inOrderSegments.size() = {1} outOfOrderSegments.size()  = {2} processingDefer = {3} total = {4}\", _sentInterests.size(), inOrderSegments.size(), outOfOrderSegments.size(), processingDefer, (_sentInterests.size() + inOrderSegments.size() + outOfOrderSegments.size() + processingDefer) );\n"}
{"magic_number_smell": "            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + AlarmManager.INTERVAL_HOUR;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {", "refactored_code": "    private static final long BACKUP_INTERVAL = AlarmManager.INTERVAL_HOUR;\n            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + BACKUP_INTERVAL;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {"}
{"magic_number_smell": "            @Override\n            public boolean hasNext()\n            {\n                return position < groupByHash.getGroupCount();\n            }\n\n            @Override", "refactored_code": "            private final int totalPositions = groupByHash.getGroupCount();\n            @Override\n            public boolean hasNext()\n            {\n                return position < totalPositions;\n            }\n\n            @Override"}
{"magic_number_smell": "\n    @Override\n    public int hashCode() {\n        return isEmpty() ? Objects.hash(new LinkedList<>()) : Objects.hash(headers);\n    }\n\n    @Override", "refactored_code": "    private static final int EMPTY_HASH = Objects.hash(new LinkedList<>());\n\n    @Override\n    public int hashCode() {\n        return isEmpty() ? EMPTY_HASH : Objects.hash(headers);\n    }\n\n    @Override"}
{"magic_number_smell": "    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);"}
{"magic_number_smell": "            forwardRequestExecutor.shutdown();\n            startAndStopExecutor.shutdown();\n\n            if (!forwardRequestExecutor.awaitTermination(TimeUnit.SECONDS.toMillis(10), TimeUnit.MILLISECONDS))\n                forwardRequestExecutor.shutdownNow();\n            if (!startAndStopExecutor.awaitTermination(START_AND_STOP_SHUTDOWN_TIMEOUT_MS, TimeUnit.MILLISECONDS))\n                startAndStopExecutor.shutdownNow();", "refactored_code": "    private static final long FORWARD_REQUEST_SHUTDOWN_TIMEOUT_MS = TimeUnit.SECONDS.toMillis(10);\n            forwardRequestExecutor.shutdown();\n            startAndStopExecutor.shutdown();\n\n            if (!forwardRequestExecutor.awaitTermination(FORWARD_REQUEST_SHUTDOWN_TIMEOUT_MS, TimeUnit.MILLISECONDS))\n                forwardRequestExecutor.shutdownNow();\n            if (!startAndStopExecutor.awaitTermination(START_AND_STOP_SHUTDOWN_TIMEOUT_MS, TimeUnit.MILLISECONDS))\n                startAndStopExecutor.shutdownNow();"}
{"magic_number_smell": "  private static final int DEPARTURE_TIME = 8 * 60 * 60;\n  private static final int ACCESS_DURATION = 10 * 60;\n  private static final int ALIGHT_TIME = DEPARTURE_TIME + ACCESS_DURATION;\n  private static final TestAccessEgress WALK = TestAccessEgress.walk(100, ACCESS_DURATION);\n  private static final int COST = WALK.generalizedCost();\n\n  private final AccessStopArrival<RaptorTripSchedule> subject = new AccessStopArrival<>(", "refactored_code": "  private static final int ALIGHT_STOP = 100;\n  private static final int DEPARTURE_TIME = 8 * 60 * 60;\n  private static final int ACCESS_DURATION = 10 * 60;\n  private static final int ALIGHT_TIME = DEPARTURE_TIME + ACCESS_DURATION;\n  private static final TestAccessEgress WALK = TestAccessEgress.walk(ALIGHT_STOP, ACCESS_DURATION);\n  private static final int COST = WALK.generalizedCost();\n\n  private final AccessStopArrival<RaptorTripSchedule> subject = new AccessStopArrival<>("}
{"magic_number_smell": "\n            BasicInvocation inv = new BasicTargetInvocation(\n                    basicInvocation.nodeEngine, basicInvocation.serviceName, isStillExecuting,\n                    target, 0, 0, 5000, null, null, true);\n            Future f = inv.invoke();\n            basicInvocation.logger.warning(\"Asking if operation execution has been started: \" + toString());\n            executing = (Boolean) basicInvocation.nodeEngine.toObject(f.get(GET_TIME, TimeUnit.MILLISECONDS));", "refactored_code": "    private static final long CALL_TIMEOUT = 5000;\n\n            BasicInvocation inv = new BasicTargetInvocation(\n                    basicInvocation.nodeEngine, basicInvocation.serviceName, isStillExecuting,\n                    target, 0, 0, CALL_TIMEOUT, null, null, true);\n            Future f = inv.invoke();\n            basicInvocation.logger.warning(\"Asking if operation execution has been started: \" + toString());\n            executing = (Boolean) basicInvocation.nodeEngine.toObject(f.get(GET_TIME, TimeUnit.MILLISECONDS));"}
{"magic_number_smell": "                         KubernetesGCPServiceAccountSecretManager serviceAccountSecretManager,\n                         Debug debug, String styxEnvironment) {\n    this(client, stateManager, stats, serviceAccountSecretManager, debug, styxEnvironment,\n        60, DEFAULT_POD_DELETION_DELAY_SECONDS, DEFAULT_TIME,\n        Executors.newSingleThreadScheduledExecutor(THREAD_FACTORY));\n  }\n", "refactored_code": "  private static final int DEFAULT_POLL_PODS_INTERVAL_SECONDS = 60;\n                         KubernetesGCPServiceAccountSecretManager serviceAccountSecretManager,\n                         Debug debug, String styxEnvironment) {\n    this(client, stateManager, stats, serviceAccountSecretManager, debug, styxEnvironment,\n        DEFAULT_POLL_PODS_INTERVAL_SECONDS, DEFAULT_POD_DELETION_DELAY_SECONDS, DEFAULT_TIME,\n        Executors.newSingleThreadScheduledExecutor(THREAD_FACTORY));\n  }\n"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "        // 1. write the leading byte first\n        out.write(leading);\n\n        // the flags (e.g. 1, LOW_PRIO)\n        out.write(flags);\n\n        // 3. src_addr", "refactored_code": "    public static final byte OOB       = 1;\n        // 1. write the leading byte first\n        out.write(leading);\n\n        // the flags (e.g. OOB, LOW_PRIO)\n        out.write(flags);\n\n        // 3. src_addr"}
{"magic_number_smell": "        emitSPIRVCapabilities(module);\n        emitImportOpenCL(asm, module);\n        emitOpenCLAddressingMode(module);\n        emitOpSourceForOpenCL(module, SPIRV_HEADER_VALUES.300000);\n\n        boolean isParallel = crb.isParallel();\n        // Generate this only if the kernel is parallel (it uses the get_global_id)", "refactored_code": "        public static final int SPIRV_VERSION_FOR_OPENCL = 300000;\n        emitSPIRVCapabilities(module);\n        emitImportOpenCL(asm, module);\n        emitOpenCLAddressingMode(module);\n        emitOpSourceForOpenCL(module, SPIRV_HEADER_VALUES.SPIRV_VERSION_FOR_OPENCL);\n\n        boolean isParallel = crb.isParallel();\n        // Generate this only if the kernel is parallel (it uses the get_global_id)"}
{"magic_number_smell": "\t}\n\n\t/** Fills pixels that are within the ROI bounding rectangle and part of\n\t*\tthe mask (i.e. pixels that have a value=0xFF000000 in the mask array).\n\t*\tUse ip.getMask() to acquire the mask.\n\t*\tThrows and IllegalArgumentException if the mask is null or\n\t*\tthe size of the mask is not the same as the size of the ROI.", "refactored_code": "\tpublic static final int BLACK = 0xFF000000;\n\t}\n\n\t/** Fills pixels that are within the ROI bounding rectangle and part of\n\t*\tthe mask (i.e. pixels that have a value=BLACK in the mask array).\n\t*\tUse ip.getMask() to acquire the mask.\n\t*\tThrows and IllegalArgumentException if the mask is null or\n\t*\tthe size of the mask is not the same as the size of the ROI."}
{"magic_number_smell": "        int bytes = meta.getInt();\n        int magic = meta.getInt();\n\n        if (magic != TarWriter.INDEX_MAGIC) {\n            return null; // magic byte mismatch\n        }\n", "refactored_code": "    private static final int INDEX_MAGIC = TarWriter.INDEX_MAGIC;\n        int bytes = meta.getInt();\n        int magic = meta.getInt();\n\n        if (magic != INDEX_MAGIC) {\n            return null; // magic byte mismatch\n        }\n"}
{"magic_number_smell": "    private static final String TAG = \"BaseImageList\";\n    private static final int 512 = 512;\n    private final LruCache<Integer, BaseImage> mCache =\n            new LruCache<Integer, BaseImage>(512);\n\n    protected ContentResolver mContentResolver;\n    protected int mSort;", "refactored_code": "    private static final int CACHE_CAPACITY = 512;\n    private static final String TAG = \"BaseImageList\";\n    private static final int CACHE_CAPACITY = 512;\n    private final LruCache<Integer, BaseImage> mCache =\n            new LruCache<Integer, BaseImage>(CACHE_CAPACITY);\n\n    protected ContentResolver mContentResolver;\n    protected int mSort;"}
{"magic_number_smell": "    // scheduling parameters\n    private int maxActiveTapes = 1;\n    private int minTapeRecallPercentage = 80;\n    private long minNumberOfRequestsForTapeSelection = -1;\n    private long minJobWaitingTime = MINUTES.toMillis(2);\n    private long maxJobWaitingTime = HOURS.toMillis(1);\n    private long tapeinfolessJobWaitingTime = MINUTES.toMillis(10);", "refactored_code": "    public static final long NO_VALUE = -1;\n    // scheduling parameters\n    private int maxActiveTapes = 1;\n    private int minTapeRecallPercentage = 80;\n    private long minNumberOfRequestsForTapeSelection = NO_VALUE;\n    private long minJobWaitingTime = MINUTES.toMillis(2);\n    private long maxJobWaitingTime = HOURS.toMillis(1);\n    private long tapeinfolessJobWaitingTime = MINUTES.toMillis(10);"}
{"magic_number_smell": "\n               if (dataOkay)\n               {\n                  for (int k = 0; k < 128; k++)\n                  {\n                     float rangeScaled = range[k] / 1000.0F;\n                     if (rangeScaled > 30.0)", "refactored_code": "   public static final int OUSTER_NUMBER_ROWS = 128;\n\n               if (dataOkay)\n               {\n                  for (int k = 0; k < OUSTER_NUMBER_ROWS; k++)\n                  {\n                     float rangeScaled = range[k] / 1000.0F;\n                     if (rangeScaled > 30.0)"}
{"magic_number_smell": "\n        final int numProcessors = Runtime.getRuntime().availableProcessors();\n        final GambleGambleThread[] threads = new GambleGambleThread[numProcessors];\n        final int workPerProcessor = 400_000 / numProcessors;\n        int i = 0;\n        while (i < threads.length) {\n            (threads[i] = new GambleGambleThread(masterSeed + (i++), workPerProcessor))", "refactored_code": "    private static final int N = 400_000;\n\n        final int numProcessors = Runtime.getRuntime().availableProcessors();\n        final GambleGambleThread[] threads = new GambleGambleThread[numProcessors];\n        final int workPerProcessor = N / numProcessors;\n        int i = 0;\n        while (i < threads.length) {\n            (threads[i] = new GambleGambleThread(masterSeed + (i++), workPerProcessor))"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "\t\tList<CandidateElement> candidateElements = new ArrayList<CandidateElement>();\n\t\tint maxValues = getMaxNumberOfValues(eventableCondition.getLinkedInputFields());\n\n\t\tif (maxValues == 0) {\n\t\t\tLOGGER.warn(\"No input values found for element: \"\n\t\t\t        + DomUtils.getElementString(sourceElement));\n\t\t\treturn candidateElements;", "refactored_code": "\tprivate static final int EMPTY = 0;\n\t\tList<CandidateElement> candidateElements = new ArrayList<CandidateElement>();\n\t\tint maxValues = getMaxNumberOfValues(eventableCondition.getLinkedInputFields());\n\n\t\tif (maxValues == EMPTY) {\n\t\t\tLOGGER.warn(\"No input values found for element: \"\n\t\t\t        + DomUtils.getElementString(sourceElement));\n\t\t\treturn candidateElements;"}
{"magic_number_smell": "        connection.start();\n        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\n        System.out.printf(\"Waiting up to %s milliseconds to receive %s messages\\n\", 15000L, MESSAGE_COUNT);\n        try {\n            // Create a producer for the queue\n            Queue destination = session.createQueue(QUEUE);", "refactored_code": "    private static final long MESSAGE_TIMEOUT_MILLIS = 15000L;\n        connection.start();\n        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\n        System.out.printf(\"Waiting up to %s milliseconds to receive %s messages\\n\", MESSAGE_TIMEOUT_MILLIS, MESSAGE_COUNT);\n        try {\n            // Create a producer for the queue\n            Queue destination = session.createQueue(QUEUE);"}
{"magic_number_smell": "        @Override\n        public int getItemViewType(int index) {\n            if (index == 0) {\n                return 0;\n            } else if (index == 1) {\n                return VIEW_TYPE_ALL_PHOTOS;\n            } else {", "refactored_code": "    private final int VIEW_TYPE_TAKE_PHOTO = 0;\n        @Override\n        public int getItemViewType(int index) {\n            if (index == 0) {\n                return VIEW_TYPE_TAKE_PHOTO;\n            } else if (index == 1) {\n                return VIEW_TYPE_ALL_PHOTOS;\n            } else {"}
{"magic_number_smell": "    /**\n     * set up the decoding table.\n     */\n    private static final byte[] DECODING_TABLE = new byte[128];\n\n    static {\n        // initialize the decoding table", "refactored_code": "    private static final int DECODING_TABLE_SIZE = 128;\n    /**\n     * set up the decoding table.\n     */\n    private static final byte[] DECODING_TABLE = new byte[DECODING_TABLE_SIZE];\n\n    static {\n        // initialize the decoding table"}
{"magic_number_smell": "        deselectAll.addActionListener(new SelectionButton(false));\n        deselectAllDuplicates.addActionListener(e -> {\n            for (int i = 0; i < glTable.getRowCount(); i++) {\n                if (glTable.getValueAt(i, 1) != null) {\n                    glTable.setValueAt(false, i, 0);\n                }\n            }", "refactored_code": "    private static final int DUPL_COL = 1;\n        deselectAll.addActionListener(new SelectionButton(false));\n        deselectAllDuplicates.addActionListener(e -> {\n            for (int i = 0; i < glTable.getRowCount(); i++) {\n                if (glTable.getValueAt(i, DUPL_COL) != null) {\n                    glTable.setValueAt(false, i, 0);\n                }\n            }"}
{"magic_number_smell": "\n   @Override\n   protected void createCacheManagers() throws Throwable {\n      createHotRodServers(2, getCacheConfiguration());\n   }\n\n   private org.infinispan.configuration.cache.ConfigurationBuilder getCacheConfiguration() {", "refactored_code": "   private static final int NUM_SERVERS = 2;\n\n   @Override\n   protected void createCacheManagers() throws Throwable {\n      createHotRodServers(NUM_SERVERS, getCacheConfiguration());\n   }\n\n   private org.infinispan.configuration.cache.ConfigurationBuilder getCacheConfiguration() {"}
{"magic_number_smell": "                this.hiddenNotifications.put(subtype, xpstrid, val);\n            }\n        } catch (SQLException sqe) {\n            if (Integer.parseInt(SurveyMain.getNewVersion()) >= 42) {\n                SurveyLog.logException(sqe, \"Getting hidden notifications for uid#\" + userId + \" in \" + localeId, null);\n                throw new InternalError(\"Error getting hidden notifications: \" + sqe.getMessage());\n            }", "refactored_code": "    private final int FIRST_DB_VERSION = 42;\n                this.hiddenNotifications.put(subtype, xpstrid, val);\n            }\n        } catch (SQLException sqe) {\n            if (Integer.parseInt(SurveyMain.getNewVersion()) >= FIRST_DB_VERSION) {\n                SurveyLog.logException(sqe, \"Getting hidden notifications for uid#\" + userId + \" in \" + localeId, null);\n                throw new InternalError(\"Error getting hidden notifications: \" + sqe.getMessage());\n            }"}
{"magic_number_smell": "        String version = \"\" + ((char) magic[4]) + ((char) magic[5]) +((char) magic[6]);\n\n        if (version.equals(VERSION_CURRENT)) {\n            return 14;\n        } else if (version.equals(VERSION_FOR_API_13)) {\n            return 13;\n        }", "refactored_code": "    public static final int API_CURRENT = 14;\n        String version = \"\" + ((char) magic[4]) + ((char) magic[5]) +((char) magic[6]);\n\n        if (version.equals(VERSION_CURRENT)) {\n            return API_CURRENT;\n        } else if (version.equals(VERSION_FOR_API_13)) {\n            return 13;\n        }"}
{"magic_number_smell": "     * @throws IOException on IO error\n     */\n    static void crossStreams(final InputStream in, final OutputStream out) throws IOException {\n        final byte[] buffer = new byte[0x20000];\n        int len;\n        while ((len = in.read(buffer)) != -1) {\n            out.write(buffer, 0, len);", "refactored_code": "    private static final int bufferSize = 0x20000; // ~130K.\n     * @throws IOException on IO error\n     */\n    static void crossStreams(final InputStream in, final OutputStream out) throws IOException {\n        final byte[] buffer = new byte[bufferSize];\n        int len;\n        while ((len = in.read(buffer)) != -1) {\n            out.write(buffer, 0, len);"}
{"magic_number_smell": "        Collection<String> sqlHints = Splitter.on(SQL_HINT_SPLIT).trimResults().splitToList(comment.substring(startIndex, endIndex).trim());\n        for (String each : sqlHints) {\n            List<String> hintValues = Splitter.on(SQL_HINT_VALUE_SPLIT).trimResults().splitToList(each);\n            if (2 == hintValues.size()) {\n                result.put(hintValues.get(0), hintValues.get(1));\n            }\n        }", "refactored_code": "    private static final int SQL_HINT_VALUE_SIZE = 2;\n        Collection<String> sqlHints = Splitter.on(SQL_HINT_SPLIT).trimResults().splitToList(comment.substring(startIndex, endIndex).trim());\n        for (String each : sqlHints) {\n            List<String> hintValues = Splitter.on(SQL_HINT_VALUE_SPLIT).trimResults().splitToList(each);\n            if (SQL_HINT_VALUE_SIZE == hintValues.size()) {\n                result.put(hintValues.get(0), hintValues.get(1));\n            }\n        }"}
{"magic_number_smell": "        }\n\n        long getDefaultDisplayDelayTimeout() {\n            return 10000;\n        }\n    }\n", "refactored_code": "    private static final long WAIT_FOR_DEFAULT_DISPLAY_TIMEOUT = 10000;\n        }\n\n        long getDefaultDisplayDelayTimeout() {\n            return WAIT_FOR_DEFAULT_DISPLAY_TIMEOUT;\n        }\n    }\n"}
{"magic_number_smell": "     * @return array of column indices; -1 if the column with that id is not in cursor\n     */\n    public int[] Gen_columnIndices(android.database.Cursor cursor) {\n        int[] result=new int[82];\n        result[0] = cursor.getColumnIndex(GEN_FIELD__ID);\n        // Make compatible with database generated by older version of plugin with uppercase column name\n        if (result[0] == -1) {", "refactored_code": "    public static final int GEN_COUNT = 82;\n     * @return array of column indices; -1 if the column with that id is not in cursor\n     */\n    public int[] Gen_columnIndices(android.database.Cursor cursor) {\n        int[] result=new int[GEN_COUNT];\n        result[0] = cursor.getColumnIndex(GEN_FIELD__ID);\n        // Make compatible with database generated by older version of plugin with uppercase column name\n        if (result[0] == -1) {"}
{"magic_number_smell": "\n    public RequestContainerV5()\n    {\n        this(60000);\n    }\n\n    @Override", "refactored_code": "    private static final int DEFAULT_TICKER_INTERVAL = 60000;\n\n    public RequestContainerV5()\n    {\n        this(DEFAULT_TICKER_INTERVAL);\n    }\n\n    @Override"}
{"magic_number_smell": "\t\t} else if (element.hasAttribute(\"alt\")) {\n\t\t\tret = element.getAttribute(\"alt\");\n\t\t}\n\t\tif (ret.length() > 50) {\n\t\t\treturn ret.substring(0, 50);\n\t\t} else {\n\t\t\treturn ret;", "refactored_code": "\tprivate static final int TEXT_CUTOFF = 50;\n\t\t} else if (element.hasAttribute(\"alt\")) {\n\t\t\tret = element.getAttribute(\"alt\");\n\t\t}\n\t\tif (ret.length() > TEXT_CUTOFF) {\n\t\t\treturn ret.substring(0, TEXT_CUTOFF);\n\t\t} else {\n\t\t\treturn ret;"}
{"magic_number_smell": "     * @param charset the character set name to use\n     */\n    public CharSequenceInputStream(final CharSequence s, final Charset charset) {\n        this(s, charset, 2048);\n    }\n\n    /**", "refactored_code": "    private static final int BUFFER_SIZE = 2048;\n     * @param charset the character set name to use\n     */\n    public CharSequenceInputStream(final CharSequence s, final Charset charset) {\n        this(s, charset, BUFFER_SIZE);\n    }\n\n    /**"}
{"magic_number_smell": "          throw new ParserException(\"X-TIMESTAMP-MAP doesn't contain media timestamp: \" + line);\n        } else {\n          mediaTimestampUs = (Long.parseLong(timestampMatcher.group().substring(7)) * 1000)\n              / 90 + mediaTimestampOffsetUs;\n        }\n        mediaTimestampUs = getAdjustedStartTime(mediaTimestampUs);\n      }", "refactored_code": "  private static final long SAMPLING_RATE = 90;\n          throw new ParserException(\"X-TIMESTAMP-MAP doesn't contain media timestamp: \" + line);\n        } else {\n          mediaTimestampUs = (Long.parseLong(timestampMatcher.group().substring(7)) * 1000)\n              / SAMPLING_RATE + mediaTimestampOffsetUs;\n        }\n        mediaTimestampUs = getAdjustedStartTime(mediaTimestampUs);\n      }"}
{"magic_number_smell": "            public void onResponse(Integer ndx) {\n                if (!getActive()) return;\n\n                if (ndx >= 75) {\n                    // last channel is not in first page so grab a set where it will be in the middle\n                    ndx = ndx - (75 / 2);\n                } else {", "refactored_code": "    private static final int PAGE_SIZE = 75;\n            public void onResponse(Integer ndx) {\n                if (!getActive()) return;\n\n                if (ndx >= PAGE_SIZE) {\n                    // last channel is not in first page so grab a set where it will be in the middle\n                    ndx = ndx - (PAGE_SIZE / 2);\n                } else {"}
{"magic_number_smell": "        String version = \"\" + ((char) magic[4]) + ((char) magic[5]) +((char) magic[6]);\n\n        if (version.equals(VERSION_CURRENT)) {\n            return 14;\n        } else if (version.equals(VERSION_FOR_API_13)) {\n            return 13;\n        }", "refactored_code": "    public static final int API_CURRENT = 14;\n        String version = \"\" + ((char) magic[4]) + ((char) magic[5]) +((char) magic[6]);\n\n        if (version.equals(VERSION_CURRENT)) {\n            return API_CURRENT;\n        } else if (version.equals(VERSION_FOR_API_13)) {\n            return 13;\n        }"}
{"magic_number_smell": "        RedisInstanceInfo info = context.instance().getRedisInstanceInfo();\n\n        MetricData data = new MetricData(TYPE, info.getDcId(), info.getClusterId(), info.getShardId());\n        data.setValue((double) (context.getResult() / 1000));\n        data.setTimestampMilli(context.getRecvTimeMilli());\n        data.setHostPort(info.getHostPort());\n        return data;", "refactored_code": "    private static final int THOUSAND = 1000;\n        RedisInstanceInfo info = context.instance().getRedisInstanceInfo();\n\n        MetricData data = new MetricData(TYPE, info.getDcId(), info.getClusterId(), info.getShardId());\n        data.setValue((double) (context.getResult() / THOUSAND));\n        data.setTimestampMilli(context.getRecvTimeMilli());\n        data.setHostPort(info.getHostPort());\n        return data;"}
{"magic_number_smell": "public class ManagedLedgerFactoryConfig {\n    private static final long 1024 * 1024 = 1024 * 1024;\n\n    private long maxCacheSize = 128 * 1024 * 1024;\n\n    /**\n     * The cache eviction watermark is the percentage of the cache size to reach when removing entries from the cache.", "refactored_code": "    private static final long MB = 1024 * 1024;\npublic class ManagedLedgerFactoryConfig {\n    private static final long MB = 1024 * 1024;\n\n    private long maxCacheSize = 128 * MB;\n\n    /**\n     * The cache eviction watermark is the percentage of the cache size to reach when removing entries from the cache."}
{"magic_number_smell": "      if (commandLineArgs.containsKey(CommandLineIntepreter.OPTION_ADMINPORT)) {\n         return Integer.parseInt(commandLineArgs.get(CommandLineIntepreter.OPTION_ADMINPORT));\n      }\n      return 8889;\n   }\n}", "refactored_code": "   public static final int DEFAULT_ADMIN_PORT = 8889;\n      if (commandLineArgs.containsKey(CommandLineIntepreter.OPTION_ADMINPORT)) {\n         return Integer.parseInt(commandLineArgs.get(CommandLineIntepreter.OPTION_ADMINPORT));\n      }\n      return DEFAULT_ADMIN_PORT;\n   }\n}"}
{"magic_number_smell": "\t\tsuper((SegmentationProfile.isSegment(baseName) ? SegmentationProfile.segmentRoot(baseName) : baseName),\n\t\t\t  locator, publisher, type, keys, segmenter);\n\n\t\t_buffers = new byte[128][];\n\t\t// Always make the first one; it simplifies error handling later and only is superfluous if we\n\t\t// attempt to write an empty stream, which is rare.\n\t\t_buffers[0] = new byte[_segmenter.getBlockSize()];", "refactored_code": "\tpublic static final int BLOCK_BUF_COUNT = 128;\t// Must be at least 2\n\t\tsuper((SegmentationProfile.isSegment(baseName) ? SegmentationProfile.segmentRoot(baseName) : baseName),\n\t\t\t  locator, publisher, type, keys, segmenter);\n\n\t\t_buffers = new byte[BLOCK_BUF_COUNT][];\n\t\t// Always make the first one; it simplifies error handling later and only is superfluous if we\n\t\t// attempt to write an empty stream, which is rare.\n\t\t_buffers[0] = new byte[_segmenter.getBlockSize()];"}
{"magic_number_smell": "                    continue;\n                log.debug(\"{} About to send \" + toSend.size() + \" records to Kafka\", this);\n                if (!sendRecords())\n                    stopRequestedLatch.await(100, TimeUnit.MILLISECONDS);\n            }\n        } catch (InterruptedException e) {\n            // Ignore and allow to exit.", "refactored_code": "    private static final long SEND_FAILED_BACKOFF_MS = 100;\n                    continue;\n                log.debug(\"{} About to send \" + toSend.size() + \" records to Kafka\", this);\n                if (!sendRecords())\n                    stopRequestedLatch.await(SEND_FAILED_BACKOFF_MS, TimeUnit.MILLISECONDS);\n            }\n        } catch (InterruptedException e) {\n            // Ignore and allow to exit."}
{"magic_number_smell": "  public boolean create(String storeName) throws IOException {\n    String path = formPath(storeName);\n\n    return propStore.exists(path, 0) || propStore.create(path, ArrayUtils.EMPTY_BYTE_ARRAY,\n        AccessOption.PERSISTENT);\n  }\n", "refactored_code": "  private static final int DEFAULT_OPTION = 0;\n  public boolean create(String storeName) throws IOException {\n    String path = formPath(storeName);\n\n    return propStore.exists(path, DEFAULT_OPTION) || propStore.create(path, ArrayUtils.EMPTY_BYTE_ARRAY,\n        AccessOption.PERSISTENT);\n  }\n"}
{"magic_number_smell": "    private static final long 1L = 1L;\n\n    public static class BaseDirectory implements Serializable {\n        private static final long 1L = 1L;\n        private BaseDirValueContext context;\n        private String name;\n", "refactored_code": "    private static final long serialVersionUID = 1L;\n    private static final long serialVersionUID = 1L;\n\n    public static class BaseDirectory implements Serializable {\n        private static final long serialVersionUID = 1L;\n        private BaseDirValueContext context;\n        private String name;\n"}
{"magic_number_smell": "\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != 0x414E4554) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n", "refactored_code": "    private static final int FILE_MAGIC = 0x414E4554;\n\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != FILE_MAGIC) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n"}
{"magic_number_smell": "      } else {\n        sqliteConnection.open(false);\n      }\n      sqliteConnection.setBusyTimeout(SQLiteAccessMethod.1000);\n    } catch (final SQLiteException e) {\n      LOGGER.error(e.getMessage(), e);\n      throw new DbException(e);", "refactored_code": "  private static final long DEFAULT_BUSY_TIMEOUT = 1000;\n      } else {\n        sqliteConnection.open(false);\n      }\n      sqliteConnection.setBusyTimeout(SQLiteAccessMethod.DEFAULT_BUSY_TIMEOUT);\n    } catch (final SQLiteException e) {\n      LOGGER.error(e.getMessage(), e);\n      throw new DbException(e);"}
{"magic_number_smell": "            buffer[index++] = (byte) (0xFF & VERSION_2_MAGIC_NUMBER);\n        } else {\n            // Magic number for version 1.\n            buffer[index++] = (byte) (0xFF & (0x78B1 >> 8));\n            buffer[index++] = (byte) (0xFF & 0x78B1);\n        }\n        // Dictionary version.", "refactored_code": "    private static final int VERSION_1_MAGIC_NUMBER = 0x78B1;\n            buffer[index++] = (byte) (0xFF & VERSION_2_MAGIC_NUMBER);\n        } else {\n            // Magic number for version 1.\n            buffer[index++] = (byte) (0xFF & (VERSION_1_MAGIC_NUMBER >> 8));\n            buffer[index++] = (byte) (0xFF & VERSION_1_MAGIC_NUMBER);\n        }\n        // Dictionary version."}
{"magic_number_smell": "            return STRING_BLANK;\n        }\n        if (isRetryTopic(originalResource)) {\n            return originalResource.substring(MixAll.RETRY_GROUP_TOPIC_PREFIX.length());\n        }\n\n        if (isDLQTopic(originalResource)) {", "refactored_code": "    public static final int RETRY_PREFIX_LENGTH = MixAll.RETRY_GROUP_TOPIC_PREFIX.length();\n            return STRING_BLANK;\n        }\n        if (isRetryTopic(originalResource)) {\n            return originalResource.substring(RETRY_PREFIX_LENGTH);\n        }\n\n        if (isDLQTopic(originalResource)) {"}
{"magic_number_smell": "\t}\n\t\n\tprivate Ref<ACell> write(AArrayBlob key, int keyOffset, Ref<ACell> value, long indexPosition) throws IOException {\n\t\tif (keyOffset>=32) {\n\t\t\tthrow new Error(\"Offset exceeded for key: \"+key);\n\t\t}\n\t\t", "refactored_code": "\tprivate static final int KEY_SIZE=32;\n\t}\n\t\n\tprivate Ref<ACell> write(AArrayBlob key, int keyOffset, Ref<ACell> value, long indexPosition) throws IOException {\n\t\tif (keyOffset>=KEY_SIZE) {\n\t\t\tthrow new Error(\"Offset exceeded for key: \"+key);\n\t\t}\n\t\t"}
{"magic_number_smell": "\t{\n\t\tfor (int i = 0; i < 2048; ++i)\n\t\t{\n\t\t\tSINE[i] = (int) (65536.0D * Math.sin((double) i * Math.PI / 1024d));\n\t\t\tCOSINE[i] = (int) (65536.0D * Math.cos((double) i * Math.PI / 1024d));\n\t\t}\n\t}", "refactored_code": "\tprivate static final double UNIT = Math.PI / 1024d; // How much of the circle each unit of SINE/COSINE is\n\t{\n\t\tfor (int i = 0; i < 2048; ++i)\n\t\t{\n\t\t\tSINE[i] = (int) (65536.0D * Math.sin((double) i * UNIT));\n\t\t\tCOSINE[i] = (int) (65536.0D * Math.cos((double) i * UNIT));\n\t\t}\n\t}"}
{"magic_number_smell": "    if (currentVrrpGroup == null) {\n      currentVrrpGroup = new VrrpGroup(group);\n      currentVrrpGroup.setPreempt(DEFAULT_VRRP_PREEMPT);\n      currentVrrpGroup.setPriority(100);\n      _currentInterface.getVrrpGroups().put(group, currentVrrpGroup);\n    }\n    _currentVrrpGroup = currentVrrpGroup;", "refactored_code": "  private static final int DEFAULT_VRRP_PRIORITY = 100;\n    if (currentVrrpGroup == null) {\n      currentVrrpGroup = new VrrpGroup(group);\n      currentVrrpGroup.setPreempt(DEFAULT_VRRP_PREEMPT);\n      currentVrrpGroup.setPriority(DEFAULT_VRRP_PRIORITY);\n      _currentInterface.getVrrpGroups().put(group, currentVrrpGroup);\n    }\n    _currentVrrpGroup = currentVrrpGroup;"}
{"magic_number_smell": "public class HistogramWindow extends ImageWindow implements Measurements, ActionListener, \n\tClipboardOwner, ImageListener, RoiListener, Runnable {\n\tprivate static final double Prefs.getGuiScale() = Prefs.getGuiScale();\n\tstatic final int HIST_WIDTH = (int)(Prefs.getGuiScale()*256);\n\tstatic final int HIST_HEIGHT = (int)(Prefs.getGuiScale()*128);\n\tstatic final int XMARGIN = (int)(20*Prefs.getGuiScale());\n\tstatic final int YMARGIN = (int)(10*Prefs.getGuiScale());", "refactored_code": "\tprivate static final double SCALE = Prefs.getGuiScale();\npublic class HistogramWindow extends ImageWindow implements Measurements, ActionListener, \n\tClipboardOwner, ImageListener, RoiListener, Runnable {\n\tprivate static final double SCALE = Prefs.getGuiScale();\n\tstatic final int HIST_WIDTH = (int)(SCALE*256);\n\tstatic final int HIST_HEIGHT = (int)(SCALE*128);\n\tstatic final int XMARGIN = (int)(20*SCALE);\n\tstatic final int YMARGIN = (int)(10*SCALE);"}
{"magic_number_smell": "    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);"}
{"magic_number_smell": "\t\t\t\t\t( mailPart.name != null ? mailPart.name + \", \" : \"\" ) +\r\n\t\t\t\t\t( mailPart.type != null ? '(' + mailPart.type + ')' : _(\"unknown\") ) );\r\n\t\t\t\r\n\t\t\tif( level == 0 && mailPart.13 == null ) {\r\n\t\t\t\t/*\r\n\t\t\t\t * not a MIME mail, so simply print it literally\r\n\t\t\t\t */\r", "refactored_code": "\tprivate static final int version = 13;\r\n\t\t\t\t\t( mailPart.name != null ? mailPart.name + \", \" : \"\" ) +\r\n\t\t\t\t\t( mailPart.type != null ? '(' + mailPart.type + ')' : _(\"unknown\") ) );\r\n\t\t\t\r\n\t\t\tif( level == 0 && mailPart.version == null ) {\r\n\t\t\t\t/*\r\n\t\t\t\t * not a MIME mail, so simply print it literally\r\n\t\t\t\t */\r"}
{"magic_number_smell": "\n  @Test\n  public void testKeyPut() throws Exception {\n    for (int i = 0; i < 500000; i++) {\n      sbTree.put(i, new ORecordId(i % 32000, i));\n    }\n", "refactored_code": "  private static final int KEYS_COUNT = 500000;\n\n  @Test\n  public void testKeyPut() throws Exception {\n    for (int i = 0; i < KEYS_COUNT; i++) {\n      sbTree.put(i, new ORecordId(i % 32000, i));\n    }\n"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "     */\n    public OptionalRandomizer(final Randomizer<T> delegate, final int optionalPercent) {\n        this.delegate = delegate;\n        this.optionalPercent = optionalPercent > 100 ? 100 : optionalPercent < 0 ? 0 : optionalPercent;\n    }\n\n    @Override", "refactored_code": "    private static final int MAX_PERCENT = 100;\n     */\n    public OptionalRandomizer(final Randomizer<T> delegate, final int optionalPercent) {\n        this.delegate = delegate;\n        this.optionalPercent = optionalPercent > MAX_PERCENT ? MAX_PERCENT : optionalPercent < 0 ? 0 : optionalPercent;\n    }\n\n    @Override"}
{"magic_number_smell": "\t\tJScrollPane scrollPane = new JScrollPane(list, ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS, ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n\t\tadd(\"Center\", scrollPane);\n\t\tpanel = new Panel();\n\t\tint nButtons = 11;\n\t\tpanel.setLayout(new GridLayout(nButtons, 1, 5, 0));\n\t\taddButton(\"Add [t]\");\n\t\taddButton(\"Update\");", "refactored_code": "\tprivate static final int BUTTONS = 11;\n\t\tJScrollPane scrollPane = new JScrollPane(list, ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS, ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n\t\tadd(\"Center\", scrollPane);\n\t\tpanel = new Panel();\n\t\tint nButtons = BUTTONS;\n\t\tpanel.setLayout(new GridLayout(nButtons, 1, 5, 0));\n\t\taddButton(\"Add [t]\");\n\t\taddButton(\"Update\");"}
{"magic_number_smell": "                && b.size() > SPARSITY_SIZE_THRESHOLD\n                && a.sparsity2() > SPARSITY2_THRESHOLD\n                && b.sparsity2() > SPARSITY2_THRESHOLD\n                && (a.nVariables > 4 || (a.sparsity() > 0.2 && b.sparsity() > 0.2));\n    }\n\n    @SuppressWarnings(\"unchecked\")", "refactored_code": "    private static final double SPARSITY_THRESHOLD_NVARS_4 = 0.2;\n                && b.size() > SPARSITY_SIZE_THRESHOLD\n                && a.sparsity2() > SPARSITY2_THRESHOLD\n                && b.sparsity2() > SPARSITY2_THRESHOLD\n                && (a.nVariables > 4 || (a.sparsity() > SPARSITY_THRESHOLD_NVARS_4 && b.sparsity() > SPARSITY_THRESHOLD_NVARS_4));\n    }\n\n    @SuppressWarnings(\"unchecked\")"}
{"magic_number_smell": "\n\t\t\tInterest i = null;\n\n\t\t\twhile (_sentInterests.size() + inOrderSegments.size() + outOfOrderSegments.size() + 0 < SystemConfiguration.PIPELINE_SIZE && !doneAdvancing) {\n\t\t\t\tif (Log.isLoggable(Log.FAC_PIPELINE, Level.INFO))\n\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: _sentInterests.size() = {0} inOrderSegments.size() = {1} outOfOrderSegments.size()  = {2} 0 = {3} total = {4}\", _sentInterests.size(), inOrderSegments.size(), outOfOrderSegments.size(), 0, (_sentInterests.size() + inOrderSegments.size() + outOfOrderSegments.size() + 0) );\n", "refactored_code": "\tprivate final int processingDefer = 0;\n\n\t\t\tInterest i = null;\n\n\t\t\twhile (_sentInterests.size() + inOrderSegments.size() + outOfOrderSegments.size() + processingDefer < SystemConfiguration.PIPELINE_SIZE && !doneAdvancing) {\n\t\t\t\tif (Log.isLoggable(Log.FAC_PIPELINE, Level.INFO))\n\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: _sentInterests.size() = {0} inOrderSegments.size() = {1} outOfOrderSegments.size()  = {2} processingDefer = {3} total = {4}\", _sentInterests.size(), inOrderSegments.size(), outOfOrderSegments.size(), processingDefer, (_sentInterests.size() + inOrderSegments.size() + outOfOrderSegments.size() + processingDefer) );\n"}
{"magic_number_smell": "    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);"}
{"magic_number_smell": "            }\n\n        } catch (Exception ex) {\n            os = -1;\n        }\n        OS = os;\n        DF = dfPath;", "refactored_code": "    private static final int INIT_PROBLEM = -1;\n            }\n\n        } catch (Exception ex) {\n            os = INIT_PROBLEM;\n        }\n        OS = os;\n        DF = dfPath;"}
{"magic_number_smell": "     * @param directory File working directory (may be null)\n     */\n    public SystemCommand(File directory, Map<String, String> env) {\n        this(directory, 0L, 100, env, null, null, null);\n    }\n\n    /**", "refactored_code": "    protected static final int POLL_INTERVAL = 100;\n     * @param directory File working directory (may be null)\n     */\n    public SystemCommand(File directory, Map<String, String> env) {\n        this(directory, 0L, POLL_INTERVAL, env, null, null, null);\n    }\n\n    /**"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "        Thread cancellerThread = null;\n\n        try {\n            monitor.beginTask(mainTaskName, 1000);\n\n            ProcessBuilder builder = new ProcessBuilder(command);\n            builder.redirectErrorStream(false);", "refactored_code": "    private static final int PROGRESS_DURATION = 1000;\n        Thread cancellerThread = null;\n\n        try {\n            monitor.beginTask(mainTaskName, PROGRESS_DURATION);\n\n            ProcessBuilder builder = new ProcessBuilder(command);\n            builder.redirectErrorStream(false);"}
{"magic_number_smell": "\n\tpublic void add(ContentObject co) {\n\t\t_currentQueueSize++;\n\t\tif (!_throttled && _currentQueueSize > 2000) {\n\t\t\t_throttled = true;\n\t\t\t_server.setThrottle(true);\n\t\t}", "refactored_code": "\tpublic static final int THROTTLE_TOP = 2000;\n\n\tpublic void add(ContentObject co) {\n\t\t_currentQueueSize++;\n\t\tif (!_throttled && _currentQueueSize > THROTTLE_TOP) {\n\t\t\t_throttled = true;\n\t\t\t_server.setThrottle(true);\n\t\t}"}
{"magic_number_smell": "        systemErr = new SystemLogHolder(LoggingConstants.SYSTEM_ERR, System.err);\n\n        Timer earlyMessageTraceKiller_Timer = new Timer();\n        earlyMessageTraceKiller_Timer.schedule(new EarlyMessageTraceCleaner(), 5 * 60000); // 5 minutes wait time\n    }\n\n    /**", "refactored_code": "    private static final int MINUTE = 60000;\n        systemErr = new SystemLogHolder(LoggingConstants.SYSTEM_ERR, System.err);\n\n        Timer earlyMessageTraceKiller_Timer = new Timer();\n        earlyMessageTraceKiller_Timer.schedule(new EarlyMessageTraceCleaner(), 5 * MINUTE); // 5 minutes wait time\n    }\n\n    /**"}
{"magic_number_smell": "                        } else {\n                            // Calculate the time we need to be idle before we\n                            // start checking thumbnail.\n                            long t = 1000000000 -\n                                    (System.nanoTime() - mLastWorkTime);\n                            t = t / 1000000;  // convert to milliseconds.\n                            if (t > 0) {", "refactored_code": "        private static final long IDLE_TIME = 1000000000;  // in nanoseconds.\n                        } else {\n                            // Calculate the time we need to be idle before we\n                            // start checking thumbnail.\n                            long t = IDLE_TIME -\n                                    (System.nanoTime() - mLastWorkTime);\n                            t = t / 1000000;  // convert to milliseconds.\n                            if (t > 0) {"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "\n    g2.setColor(gridColor);\n\n    for (int i = 0; i < height; i += 10) {\n      g2.drawLine(0, i, width, i);\n    }\n", "refactored_code": "  private static final int GRID_SIZE = 10;\n\n    g2.setColor(gridColor);\n\n    for (int i = 0; i < height; i += GRID_SIZE) {\n      g2.drawLine(0, i, width, i);\n    }\n"}
{"magic_number_smell": "            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > 50 ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;", "refactored_code": "    private static final int INET_CONDITION_THRESHOLD = 50;\n            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;"}
{"magic_number_smell": "\n\t\t\tif (lowRange != DLNAMediaInfo.ENDFILE_POS && !HEAD.equals(method)) {\n\t\t\t\t// Send the response body to the client in chunks.\n\t\t\t\tChannelFuture chunkWriteFuture = event.getChannel().write(new ChunkedStream(inputStream, 8 * 1024));\n\n\t\t\t\t// Add a listener to clean up after sending the entire response body.\n\t\t\t\tfinal InputStream finalInputStream = inputStream;", "refactored_code": "\tprivate static final int BUFFER_SIZE = 8 * 1024;\n\n\t\t\tif (lowRange != DLNAMediaInfo.ENDFILE_POS && !HEAD.equals(method)) {\n\t\t\t\t// Send the response body to the client in chunks.\n\t\t\t\tChannelFuture chunkWriteFuture = event.getChannel().write(new ChunkedStream(inputStream, BUFFER_SIZE));\n\n\t\t\t\t// Add a listener to clean up after sending the entire response body.\n\t\t\t\tfinal InputStream finalInputStream = inputStream;"}
{"magic_number_smell": "        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+5*1000) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }", "refactored_code": "    private static final long MIN_TIME_BETWEEN_GCS = 5*1000;\n        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+MIN_TIME_BETWEEN_GCS) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }"}
{"magic_number_smell": "    private GetResult getHalfMsg(MessageQueue messageQueue, long offset) {\n        GetResult getResult = new GetResult();\n\n        PullResult result = pullHalfMsg(messageQueue, offset, 1);\n        getResult.setPullResult(result);\n        List<MessageExt> messageExts = result.getMsgFoundList();\n        if (messageExts == null) {", "refactored_code": "    private static final int PULL_MSG_RETRY_NUMBER = 1;\n    private GetResult getHalfMsg(MessageQueue messageQueue, long offset) {\n        GetResult getResult = new GetResult();\n\n        PullResult result = pullHalfMsg(messageQueue, offset, PULL_MSG_RETRY_NUMBER);\n        getResult.setPullResult(result);\n        List<MessageExt> messageExts = result.getMsgFoundList();\n        if (messageExts == null) {"}
{"magic_number_smell": "            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > 50 ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;", "refactored_code": "    private static final int INET_CONDITION_THRESHOLD = 50;\n            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;"}
{"magic_number_smell": "        boolean capped = getSpecification()\n            .getBoolean(GameOptions.BELL_ACCUMULATION_CAPPED);\n        if (capped && sonsOfLiberty >= 100) {\n            liberty = 200 * getUnitCount();\n        }\n    }\n", "refactored_code": "    public static final int LIBERTY_PER_REBEL = 200;\n        boolean capped = getSpecification()\n            .getBoolean(GameOptions.BELL_ACCUMULATION_CAPPED);\n        if (capped && sonsOfLiberty >= 100) {\n            liberty = LIBERTY_PER_REBEL * getUnitCount();\n        }\n    }\n"}
{"magic_number_smell": "    if (v) {\n      setExpireAfterWrite(ExpiryTimeValues.ETERNAL);\n    } else {\n      setExpireAfterWrite(Long.MAX_VALUE - 1);\n    }\n  }\n", "refactored_code": "  public static final long EXPIRY_NOT_ETERNAL = Long.MAX_VALUE - 1;\n    if (v) {\n      setExpireAfterWrite(ExpiryTimeValues.ETERNAL);\n    } else {\n      setExpireAfterWrite(EXPIRY_NOT_ETERNAL);\n    }\n  }\n"}
{"magic_number_smell": "    public static final Setting<TimeValue> CACHE_TTL_SETTING = Setting.timeSetting(\"cache.ttl\", DEFAULT_TTL, Setting.Property.NodeScope);\n\n    private static final int 100_000 = 100_000; //100k users\n    public static final Setting<Integer> CACHE_MAX_USERS_SETTING = Setting.intSetting(\"cache.max_users\", 100_000,\n            Setting.Property.NodeScope);\n\n    private final Cache<String, UserWithHash> cache;", "refactored_code": "    private static final int DEFAULT_MAX_USERS = 100_000; //100k users\n    public static final Setting<TimeValue> CACHE_TTL_SETTING = Setting.timeSetting(\"cache.ttl\", DEFAULT_TTL, Setting.Property.NodeScope);\n\n    private static final int DEFAULT_MAX_USERS = 100_000; //100k users\n    public static final Setting<Integer> CACHE_MAX_USERS_SETTING = Setting.intSetting(\"cache.max_users\", DEFAULT_MAX_USERS,\n            Setting.Property.NodeScope);\n\n    private final Cache<String, UserWithHash> cache;"}
{"magic_number_smell": "\t\t\t\t/*\n\t\t\t\t * \n\t\t\t\t */\n\t\t\t\t((TinyTablesPreproConfiguration) config).setTriplesBatchSize(4096);\n\n\t\t\t\t((TinyTablesPreproConfiguration) config).setTriplesFile(new File(\n\t\t\t\t\t\t\"triples_\" + playerId));", "refactored_code": "\tprivate static final int TRIPLES_BATCH_SIZE = 4096;\n\t\t\t\t/*\n\t\t\t\t * \n\t\t\t\t */\n\t\t\t\t((TinyTablesPreproConfiguration) config).setTriplesBatchSize(TRIPLES_BATCH_SIZE);\n\n\t\t\t\t((TinyTablesPreproConfiguration) config).setTriplesFile(new File(\n\t\t\t\t\t\t\"triples_\" + playerId));"}
{"magic_number_smell": "\tpublic static Mac _AESKeyMac;\n\tpublic static String _AESKeyAlgorithm = MAC_ALGORITHM;\n\t\n\tprotected static DERInteger _version = new DERInteger(1);\n\t\n\tprotected byte[] _id = null;\n\tprotected KeyStore.Entry _ourEntry = null;", "refactored_code": "\tpublic static final int VERSION = 1;\n\tpublic static Mac _AESKeyMac;\n\tpublic static String _AESKeyAlgorithm = MAC_ALGORITHM;\n\t\n\tprotected static DERInteger _version = new DERInteger(VERSION);\n\t\n\tprotected byte[] _id = null;\n\tprotected KeyStore.Entry _ourEntry = null;"}
{"magic_number_smell": "\t\tint options = getInt(ijProps, OPTIONS);\n\t\tif (options==-1)\n\t\t\treturn true;\n\t\treturn (options&1<<22)!=0;\n\t}\n\t\n\tprotected static int getInt(Properties props, String key) {", "refactored_code": "\tprivate static final int RUN_SOCKET_LISTENER=1<<22;\n\t\tint options = getInt(ijProps, OPTIONS);\n\t\tif (options==-1)\n\t\t\treturn true;\n\t\treturn (options&RUN_SOCKET_LISTENER)!=0;\n\t}\n\t\n\tprotected static int getInt(Properties props, String key) {"}
{"magic_number_smell": "        if (getCollection().add(item)) {\n            return item.getItemId();\n        }\n        return -1;\n    }\n\n    public void addBackup(long itemId, Data value) {", "refactored_code": "    public static final int INVALID_ITEM_ID = -1;\n        if (getCollection().add(item)) {\n            return item.getItemId();\n        }\n        return INVALID_ITEM_ID;\n    }\n\n    public void addBackup(long itemId, Data value) {"}
{"magic_number_smell": "\t\t\t\tsynchronized (_opencloseLock) {\n\t\t\t\t\t_opencloseLock.wait(_downDelay);\n\t\t\t\t\tif (! _ncConnected) {\n\t\t\t\t\t\tif (_downDelay < 3500)\n\t\t\t\t\t\t\t_downDelay = _downDelay * 2 + 1;\n\t\t\t\t\t\topen();\n\t\t\t\t\t}", "refactored_code": "\tpublic static final int HEARTBEAT_PERIOD = 3500;\n\t\t\t\tsynchronized (_opencloseLock) {\n\t\t\t\t\t_opencloseLock.wait(_downDelay);\n\t\t\t\t\tif (! _ncConnected) {\n\t\t\t\t\t\tif (_downDelay < HEARTBEAT_PERIOD)\n\t\t\t\t\t\t\t_downDelay = _downDelay * 2 + 1;\n\t\t\t\t\t\topen();\n\t\t\t\t\t}"}
{"magic_number_smell": "        final Map<Integer, CIString> results = Maps.newHashMap();\n        final Map<String, Object> params = Maps.newHashMap();\n\n        for (List<Integer> partition : Lists.partition(objectIds, 10_000)) {\n            params.put(\"objectids\", partition);\n            namedParameterJdbcTemplate.query(\n                \"SELECT object_id, status FROM status WHERE object_id IN (:objectids)\",", "refactored_code": "    private static final int QUERY_PARTITION = 10_000;\n        final Map<Integer, CIString> results = Maps.newHashMap();\n        final Map<String, Object> params = Maps.newHashMap();\n\n        for (List<Integer> partition : Lists.partition(objectIds, QUERY_PARTITION)) {\n            params.put(\"objectids\", partition);\n            namedParameterJdbcTemplate.query(\n                \"SELECT object_id, status FROM status WHERE object_id IN (:objectids)\","}
{"magic_number_smell": "        byte[] extensionBytes = ArrayConverter.concatenate(extension.getExtensionType().getValue(), ArrayConverter\n                .intToBytes(extension.getExtensionLength().getValue(), ExtensionByteLength.EXTENSIONS), ArrayConverter\n                .intToBytes(extension.getSignatureAndHashAlgorithmsLength().getValue(),\n                        2), extension.getSignatureAndHashAlgorithms().getValue());\n\n        extension.setExtensionBytes(extensionBytes);\n    }", "refactored_code": "    public static final int SIGNATURE_AND_HASH_ALGORITHMS_LENGTH = 2;\n        byte[] extensionBytes = ArrayConverter.concatenate(extension.getExtensionType().getValue(), ArrayConverter\n                .intToBytes(extension.getExtensionLength().getValue(), ExtensionByteLength.EXTENSIONS), ArrayConverter\n                .intToBytes(extension.getSignatureAndHashAlgorithmsLength().getValue(),\n                        SIGNATURE_AND_HASH_ALGORITHMS_LENGTH), extension.getSignatureAndHashAlgorithms().getValue());\n\n        extension.setExtensionBytes(extensionBytes);\n    }"}
{"magic_number_smell": "    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #-1}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode", "refactored_code": "    public static final int INFINITE = -1;\n    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #INFINITE}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode"}
{"magic_number_smell": "    public AdapterResponse<Feed> getFeed(GetFeedRequest getFeedRequest) {\n        AdapterResponse<Feed> response;\n\n        int pageSize = 25;\n        final String pageSizeString = getFeedRequest.getPageSize();\n\n        if (StringUtils.isNotBlank(pageSizeString)) {", "refactored_code": "    private static final int PAGE_SIZE = 25;\n    public AdapterResponse<Feed> getFeed(GetFeedRequest getFeedRequest) {\n        AdapterResponse<Feed> response;\n\n        int pageSize = PAGE_SIZE;\n        final String pageSizeString = getFeedRequest.getPageSize();\n\n        if (StringUtils.isNotBlank(pageSizeString)) {"}
{"magic_number_smell": "            long nextConsecutiveId = -1L;\n\n            // TODO is there a better way to set the initial size, e.g. dss.setCount\n            HugeLongLongMap setIdToConsecutiveId = new HugeLongLongMap(BitUtil.ceilDiv(dss.size(), 10L), tracker);\n            this.communities = HugeLongArray.newArray(dss.size(), tracker);\n\n            for (int nodeId = 0; nodeId < dss.size(); nodeId++) {", "refactored_code": "        private static final long MAPPING_SIZE_QUOTIENT = 10L;\n            long nextConsecutiveId = -1L;\n\n            // TODO is there a better way to set the initial size, e.g. dss.setCount\n            HugeLongLongMap setIdToConsecutiveId = new HugeLongLongMap(BitUtil.ceilDiv(dss.size(), MAPPING_SIZE_QUOTIENT), tracker);\n            this.communities = HugeLongArray.newArray(dss.size(), tracker);\n\n            for (int nodeId = 0; nodeId < dss.size(); nodeId++) {"}
{"magic_number_smell": "\n    public SftpFileNameParser()\n    {\n        super(22);\n    }\n\n    public static FileNameParser getInstance()", "refactored_code": "    private static final int DEFAULT_PORT = 22;\n\n    public SftpFileNameParser()\n    {\n        super(DEFAULT_PORT);\n    }\n\n    public static FileNameParser getInstance()"}
{"magic_number_smell": "\t}\n\n\tprivate static class LowerCaseLetterDocument extends PlainDocument {\n\t\tprivate static final long 4436228792112530975L = -5123268875802709841L;\n\n\t\t@Override\n\t\tpublic void insertString(final int offs, final String str, final AttributeSet a)", "refactored_code": "\tprivate static final long serialVersionUID = 4436228792112530975L;\n\t}\n\n\tprivate static class LowerCaseLetterDocument extends PlainDocument {\n\t\tprivate static final long serialVersionUID = -5123268875802709841L;\n\n\t\t@Override\n\t\tpublic void insertString(final int offs, final String str, final AttributeSet a)"}
{"magic_number_smell": "   @After\r\n   public void closeSCS()\r\n   {\r\n      ThreadTools.sleep(2000);\r\n      scs.closeAndDispose();\r\n      scs = null;\r\n   }\r", "refactored_code": "   private static final long CLOSING_SLEEP_TIME = 2000;\r\n   @After\r\n   public void closeSCS()\r\n   {\r\n      ThreadTools.sleep(CLOSING_SLEEP_TIME);\r\n      scs.closeAndDispose();\r\n      scs = null;\r\n   }\r"}
{"magic_number_smell": "        public BugInfoBuilder setExpression(final String expression) {\n            if (expression == null) {\n                bugInfo.expression = \"\";\n            } else if (expression.length() > 200) {\n                bugInfo.expression = expression.substring(0, 200);\n            } else {\n                bugInfo.expression = expression;", "refactored_code": "        private static final int MAX_LENGTH = 200;\n        public BugInfoBuilder setExpression(final String expression) {\n            if (expression == null) {\n                bugInfo.expression = \"\";\n            } else if (expression.length() > MAX_LENGTH) {\n                bugInfo.expression = expression.substring(0, MAX_LENGTH);\n            } else {\n                bugInfo.expression = expression;"}
{"magic_number_smell": "        buffer.order(ByteOrder.LITTLE_ENDIAN);\n        buffer.putShort((short) GZIPInputStream.GZIP_MAGIC);\n        buffer.put((byte) Deflater.DEFLATED); // compression method (8: deflate)\n        buffer.put((byte) ((filename != null ? 1 << 3 : 0) | (comment != null ? FCOMMENT : 0))); // flags\n        buffer.putInt((int) (parameters.getModificationTime() / 1000));\n        \n        // extra flags", "refactored_code": "    private static final int FNAME = 1 << 3;\n        buffer.order(ByteOrder.LITTLE_ENDIAN);\n        buffer.putShort((short) GZIPInputStream.GZIP_MAGIC);\n        buffer.put((byte) Deflater.DEFLATED); // compression method (8: deflate)\n        buffer.put((byte) ((filename != null ? FNAME : 0) | (comment != null ? FCOMMENT : 0))); // flags\n        buffer.putInt((int) (parameters.getModificationTime() / 1000));\n        \n        // extra flags"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "        connection.start();\n        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\n        System.out.printf(\"Waiting up to %s milliseconds to receive %s messages\\n\", 15000L, MESSAGE_COUNT);\n        try {\n            // Create a producer for the queue\n            Queue destination = session.createQueue(QUEUE);", "refactored_code": "    private static final long MESSAGE_TIMEOUT_MILLIS = 15000L;\n        connection.start();\n        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\n        System.out.printf(\"Waiting up to %s milliseconds to receive %s messages\\n\", MESSAGE_TIMEOUT_MILLIS, MESSAGE_COUNT);\n        try {\n            // Create a producer for the queue\n            Queue destination = session.createQueue(QUEUE);"}
{"magic_number_smell": "\t\tRunnable defer = () -> {\n\t\t\tlong start = startTime;\n\t\t\ttry {\n\t\t\t\tThread.sleep(4000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tLOGGER.error(\"stopPlaying sleep interrupted\", e);\n\t\t\t}", "refactored_code": "\tprivate static final int STOP_PLAYING_DELAY = 4000;\n\t\tRunnable defer = () -> {\n\t\t\tlong start = startTime;\n\t\t\ttry {\n\t\t\t\tThread.sleep(STOP_PLAYING_DELAY);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tLOGGER.error(\"stopPlaying sleep interrupted\", e);\n\t\t\t}"}
{"magic_number_smell": "\n    private void serializeFooter(final ParquetMetadata footer, final OutputStream os) throws IOException {\n        final long footerIndex = writeChannel.position();\n        org.apache.parquet.format.FileMetaData parquetMetadata = metadataConverter.toParquetMetadata(1, footer);\n        writeFileMetaData(parquetMetadata, os);\n        BytesUtils.writeIntLittleEndian(os, (int) (writeChannel.position() - footerIndex));\n        os.write(ParquetFileReader.MAGIC);", "refactored_code": "    private static final int VERSION = 1;\n\n    private void serializeFooter(final ParquetMetadata footer, final OutputStream os) throws IOException {\n        final long footerIndex = writeChannel.position();\n        org.apache.parquet.format.FileMetaData parquetMetadata = metadataConverter.toParquetMetadata(VERSION, footer);\n        writeFileMetaData(parquetMetadata, os);\n        BytesUtils.writeIntLittleEndian(os, (int) (writeChannel.position() - footerIndex));\n        os.write(ParquetFileReader.MAGIC);"}
{"magic_number_smell": "        long totalLength = le.getAttrs().getSize();\n\n        SftpProgressMonitor monitor = null;\n        boolean trackProgress = getVerbose() && totalLength > 102400;\n        if (trackProgress) {\n            monitor = getProgressMonitor();\n        }", "refactored_code": "    private static final int HUNDRED_KILOBYTES = 102400;\n        long totalLength = le.getAttrs().getSize();\n\n        SftpProgressMonitor monitor = null;\n        boolean trackProgress = getVerbose() && totalLength > HUNDRED_KILOBYTES;\n        if (trackProgress) {\n            monitor = getProgressMonitor();\n        }"}
{"magic_number_smell": "  @Implementation\n  protected static final void setThreadPriority(int tid, int priority) {\n    checkArgument(\n        priority >= -20 && priority <= THREAD_PRIORITY_LOWEST,\n        \"priority %s out of range [%s, %s]. It is recommended to use a Process.THREAD_PRIORITY_*\"\n            + \" constant.\",\n        priority,", "refactored_code": "  private static final int THREAD_PRIORITY_HIGHEST = -20;\n  @Implementation\n  protected static final void setThreadPriority(int tid, int priority) {\n    checkArgument(\n        priority >= THREAD_PRIORITY_HIGHEST && priority <= THREAD_PRIORITY_LOWEST,\n        \"priority %s out of range [%s, %s]. It is recommended to use a Process.THREAD_PRIORITY_*\"\n            + \" constant.\",\n        priority,"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "        // 1. write the leading byte first\n        out.write(leading);\n\n        // the flags (e.g. 1, LOW_PRIO)\n        out.write(flags);\n\n        // 3. src_addr", "refactored_code": "    public static final byte OOB       = 1;\n        // 1. write the leading byte first\n        out.write(leading);\n\n        // the flags (e.g. OOB, LOW_PRIO)\n        out.write(flags);\n\n        // 3. src_addr"}
{"magic_number_smell": "        builder.addGroupBegin().addRuleCollection(getAggregationRules()).addGroupEnd().addMatchOrder(HepMatchOrder.BOTTOM_UP);\n        builder.addGroupBegin().addRuleCollection(getCalcRules()).addGroupEnd().addMatchOrder(HepMatchOrder.BOTTOM_UP);\n        builder.addGroupBegin().addRuleCollection(getSubQueryRules()).addGroupEnd().addMatchOrder(HepMatchOrder.BOTTOM_UP);\n        builder.addMatchLimit(1024);\n        return new HepPlanner(builder.build());\n    }\n    ", "refactored_code": "    private static final int DEFAULT_MATCH_LIMIT = 1024;\n        builder.addGroupBegin().addRuleCollection(getAggregationRules()).addGroupEnd().addMatchOrder(HepMatchOrder.BOTTOM_UP);\n        builder.addGroupBegin().addRuleCollection(getCalcRules()).addGroupEnd().addMatchOrder(HepMatchOrder.BOTTOM_UP);\n        builder.addGroupBegin().addRuleCollection(getSubQueryRules()).addGroupEnd().addMatchOrder(HepMatchOrder.BOTTOM_UP);\n        builder.addMatchLimit(DEFAULT_MATCH_LIMIT);\n        return new HepPlanner(builder.build());\n    }\n    "}
{"magic_number_smell": "\tprotected int _byteScale = SegmentationProfile.DEFAULT_SCALE;\n\tprotected SegmentNumberType _sequenceType = SegmentNumberType.SEGMENT_FIXED_INCREMENT;\n\n\tprotected ArrayList<ContentObject> _blocks = new ArrayList<ContentObject>(128 + 1);\n\n\tprotected CCNHandle _handle;\n", "refactored_code": "\tpublic static final int HOLD_COUNT = 128;\n\tprotected int _byteScale = SegmentationProfile.DEFAULT_SCALE;\n\tprotected SegmentNumberType _sequenceType = SegmentNumberType.SEGMENT_FIXED_INCREMENT;\n\n\tprotected ArrayList<ContentObject> _blocks = new ArrayList<ContentObject>(HOLD_COUNT + 1);\n\n\tprotected CCNHandle _handle;\n"}
{"magic_number_smell": "  /** Immutable data for the current leg. */\n  private MyLeg leg;\n\n  private int fromTime = -999_999_999;\n  private int toTime = -999_999_999;\n\n  private PathBuilderLeg<T> prev = null;", "refactored_code": "  private static final int NOT_SET = -999_999_999;\n  /** Immutable data for the current leg. */\n  private MyLeg leg;\n\n  private int fromTime = NOT_SET;\n  private int toTime = NOT_SET;\n\n  private PathBuilderLeg<T> prev = null;"}
{"magic_number_smell": "\n\n  public static byte[] readHeader(InputStream inputStream) throws DataParserException {\n    byte[] headerBytes = new byte[2];\n    try {\n      IOUtils.read(inputStream, headerBytes);\n    } catch (IOException e) {", "refactored_code": "  public static final int NUMBER_HEADER_BYTES = 2;\n\n\n  public static byte[] readHeader(InputStream inputStream) throws DataParserException {\n    byte[] headerBytes = new byte[NUMBER_HEADER_BYTES];\n    try {\n      IOUtils.read(inputStream, headerBytes);\n    } catch (IOException e) {"}
{"magic_number_smell": "\n\t/**\n\t * GetLatestVersion attempt timeout.\n\t * TODO  This timeout is set to 1000 to work around the problem\n\t * in ccnd where some interests take >300ms (and sometimes longer, have seen periodic delays >800ms)\n\t * when that bug is found and fixed, this can be reduced back to the SHORT_TIMEOUT.\n\t * long attemptTimeout = SystemConfiguration.SHORT_TIMEOUT;", "refactored_code": "\tpublic static final long MEDIUM_TIMEOUT = 1000;\n\n\t/**\n\t * GetLatestVersion attempt timeout.\n\t * TODO  This timeout is set to MEDIUM_TIMEOUT to work around the problem\n\t * in ccnd where some interests take >300ms (and sometimes longer, have seen periodic delays >800ms)\n\t * when that bug is found and fixed, this can be reduced back to the SHORT_TIMEOUT.\n\t * long attemptTimeout = SystemConfiguration.SHORT_TIMEOUT;"}
{"magic_number_smell": "        final long initialDelayMs = 0;\n        final boolean isDaemon = true;\n        Timer timer = new Timer(\"EventDispatchThreadHangMonitor\", isDaemon);\n        timer.schedule(new HangChecker(), initialDelayMs, 100);\n    }\n    \n    private class HangChecker extends TimerTask {", "refactored_code": "    private static final long CHECK_INTERVAL_MS = 100;\n        final long initialDelayMs = 0;\n        final boolean isDaemon = true;\n        Timer timer = new Timer(\"EventDispatchThreadHangMonitor\", isDaemon);\n        timer.schedule(new HangChecker(), initialDelayMs, CHECK_INTERVAL_MS);\n    }\n    \n    private class HangChecker extends TimerTask {"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    private long pos = 0;\n\n    /** the marked position */\n    private long mark = -1;\n\n    /** flag if close shoud be propagated */\n    private boolean propagateClose = true;", "refactored_code": "    private static final int EOF = -1;\n    private long pos = 0;\n\n    /** the marked position */\n    private long mark = EOF;\n\n    /** flag if close shoud be propagated */\n    private boolean propagateClose = true;"}
{"magic_number_smell": "\t * @throws IOException\r\n\t */\r\n\tpublic void writeHeader() throws IOException {\r\n\t\tout.writeByte(0x01);\r\n\t\tout.writeChar(MAGIC_NUMBER);\r\n\t\tout.writeChar(FORMAT_VERSION);\r\n\t}\r", "refactored_code": "\tpublic static final byte BLOCK_HEADER = 0x01;\r\n\t * @throws IOException\r\n\t */\r\n\tpublic void writeHeader() throws IOException {\r\n\t\tout.writeByte(BLOCK_HEADER);\r\n\t\tout.writeChar(MAGIC_NUMBER);\r\n\t\tout.writeChar(FORMAT_VERSION);\r\n\t}\r"}
{"magic_number_smell": "                         KubernetesGCPServiceAccountSecretManager serviceAccountSecretManager,\n                         Debug debug, String styxEnvironment) {\n    this(client, stateManager, stats, serviceAccountSecretManager, debug, styxEnvironment,\n        60, DEFAULT_POD_DELETION_DELAY_SECONDS, DEFAULT_TIME,\n        Executors.newSingleThreadScheduledExecutor(THREAD_FACTORY));\n  }\n", "refactored_code": "  private static final int DEFAULT_POLL_PODS_INTERVAL_SECONDS = 60;\n                         KubernetesGCPServiceAccountSecretManager serviceAccountSecretManager,\n                         Debug debug, String styxEnvironment) {\n    this(client, stateManager, stats, serviceAccountSecretManager, debug, styxEnvironment,\n        DEFAULT_POLL_PODS_INTERVAL_SECONDS, DEFAULT_POD_DELETION_DELAY_SECONDS, DEFAULT_TIME,\n        Executors.newSingleThreadScheduledExecutor(THREAD_FACTORY));\n  }\n"}
{"magic_number_smell": "        sGPSColor = getResources().getColor(R.color.gps_track);\n\n        mFirstLocationFix = true;\n        int zoomLevel = 13;\n        GeoPoint lastLoc = null;\n        if (savedInstanceState != null) {\n            mFirstLocationFix = false;", "refactored_code": "    private static final int DEFAULT_ZOOM = 13;\n        sGPSColor = getResources().getColor(R.color.gps_track);\n\n        mFirstLocationFix = true;\n        int zoomLevel = DEFAULT_ZOOM;\n        GeoPoint lastLoc = null;\n        if (savedInstanceState != null) {\n            mFirstLocationFix = false;"}
{"magic_number_smell": "   * Default values is defined in the default constructor.\n   */\n  private SearchParams() {\n    earliestDepartureTime = -9_999_999;\n    latestArrivalTime = -9_999_999;\n    searchWindowInSeconds = NOT_SET;\n    preferLateArrival = false;", "refactored_code": "  public static final int TIME_NOT_SET = -9_999_999;\n   * Default values is defined in the default constructor.\n   */\n  private SearchParams() {\n    earliestDepartureTime = TIME_NOT_SET;\n    latestArrivalTime = TIME_NOT_SET;\n    searchWindowInSeconds = NOT_SET;\n    preferLateArrival = false;"}
