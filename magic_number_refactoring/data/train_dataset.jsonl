{"magic_number_smell": "            buffer[index++] = (byte) (0xFF & VERSION_2_MAGIC_NUMBER);\n        } else {\n            // Magic number for version 1.\n            buffer[index++] = (byte) (0xFF & (0x78B1 >> 8));\n            buffer[index++] = (byte) (0xFF & 0x78B1);\n        }\n        // Dictionary version.", "refactored_code": "    private static final int VERSION_1_MAGIC_NUMBER = 0x78B1;\n            buffer[index++] = (byte) (0xFF & VERSION_2_MAGIC_NUMBER);\n        } else {\n            // Magic number for version 1.\n            buffer[index++] = (byte) (0xFF & (VERSION_1_MAGIC_NUMBER >> 8));\n            buffer[index++] = (byte) (0xFF & VERSION_1_MAGIC_NUMBER);\n        }\n        // Dictionary version."}
{"magic_number_smell": "\tprotected static final int 1 = 1;\n\t\n\tpublic DetailedFormatter() {\n\t\t_args[1] = new Date();\n\t}\n\t\n\tprotected Date getDate() { return (Date)_args[1]; }", "refactored_code": "\tprotected static final int DATE_INDEX = 1;\n\tprotected static final int DATE_INDEX = 1;\n\t\n\tpublic DetailedFormatter() {\n\t\t_args[DATE_INDEX] = new Date();\n\t}\n\t\n\tprotected Date getDate() { return (Date)_args[DATE_INDEX]; }"}
{"magic_number_smell": "     * and accumulates it into an unmodifiable list.\n     */\n    public static <T, R> List<R> map(Iterable<? extends T> from, Function<? super T, ? extends R> f) {\n        return map(from.iterator(), -1, f);\n    }\n\n    /**", "refactored_code": "    private static final int UNKNOWN_SIZE = -1;\n     * and accumulates it into an unmodifiable list.\n     */\n    public static <T, R> List<R> map(Iterable<? extends T> from, Function<? super T, ? extends R> f) {\n        return map(from.iterator(), UNKNOWN_SIZE, f);\n    }\n\n    /**"}
{"magic_number_smell": "\t\tString element_lower = element.toLowerCase();\n\t\tString openElement = \"<\" + element_lower;\n\t\tString closeElement = \"</\" + element_lower;\n\t\twhile (i < 10000) {\n\t\t\tif (dom_lower.indexOf(openElement, position) == -1 && dom_lower.indexOf(closeElement, position) == -1) {\n\t\t\t\treturn -1;\n\t\t\t}", "refactored_code": "\tprivate static final int MAX_SEARCH_LOOPS = 10000;\n\t\tString element_lower = element.toLowerCase();\n\t\tString openElement = \"<\" + element_lower;\n\t\tString closeElement = \"</\" + element_lower;\n\t\twhile (i < MAX_SEARCH_LOOPS) {\n\t\t\tif (dom_lower.indexOf(openElement, position) == -1 && dom_lower.indexOf(closeElement, position) == -1) {\n\t\t\t\treturn -1;\n\t\t\t}"}
{"magic_number_smell": "        final List<Analog> measurements = new ArrayList<>();\n\n        final String eanCode = values[0];\n        for (int index = 1; index < CURRENT_START_INDEX; index++) {\n            final String description = eanCode + \":voltage_L\" + index;\n            measurements.add(this.createAnalog(description, Float.valueOf(values[index]), UnitSymbol.V));\n        }", "refactored_code": "    private static final int VOLTAGE_START_INDEX = 1;\n        final List<Analog> measurements = new ArrayList<>();\n\n        final String eanCode = values[0];\n        for (int index = VOLTAGE_START_INDEX; index < CURRENT_START_INDEX; index++) {\n            final String description = eanCode + \":voltage_L\" + index;\n            measurements.add(this.createAnalog(description, Float.valueOf(values[index]), UnitSymbol.V));\n        }"}
{"magic_number_smell": "\r\n\t\tBlockFile.pageSeek(bf.file, levelPage);\r\n\t\tlong magic = bf.file.readLong();\r\n\t\tif (magic != 0x42534c6576656c73l)\r\n\t\t\tthrow new IOException(\"Bad SkipLevels magic number 0x\" + Long.toHexString(magic) + \" on page \" + levelPage);\r\n\r\n\t\tbsl.levelHash.put(new Integer(this.levelPage), this);\r", "refactored_code": "\tprivate static final long MAGIC = 0x42534c6576656c73l;  // \"BSLevels\"\r\n\r\n\t\tBlockFile.pageSeek(bf.file, levelPage);\r\n\t\tlong magic = bf.file.readLong();\r\n\t\tif (magic != MAGIC)\r\n\t\t\tthrow new IOException(\"Bad SkipLevels magic number 0x\" + Long.toHexString(magic) + \" on page \" + levelPage);\r\n\r\n\t\tbsl.levelHash.put(new Integer(this.levelPage), this);\r"}
{"magic_number_smell": "      float posY = ImGui.getWindowPosY() + ImGuiTools.TAB_BAR_HEIGHT;\n      sizeX = ImGui.getWindowSizeX();\n      sizeY = ImGui.getWindowSizeY() - ImGuiTools.TAB_BAR_HEIGHT;\n      float renderSizeX = sizeX * 2;\n      float renderSizeY = sizeY * 2;\n\n      inputCalculator.compute();", "refactored_code": "   public static final int ANTI_ALIASING = 2;\n      float posY = ImGui.getWindowPosY() + ImGuiTools.TAB_BAR_HEIGHT;\n      sizeX = ImGui.getWindowSizeX();\n      sizeY = ImGui.getWindowSizeY() - ImGuiTools.TAB_BAR_HEIGHT;\n      float renderSizeX = sizeX * ANTI_ALIASING;\n      float renderSizeY = sizeY * ANTI_ALIASING;\n\n      inputCalculator.compute();"}
{"magic_number_smell": "\n    public static final String ETCD3_NOTIFY_MAXTHREADS_KEYS = \"etcd3.notify.maxthreads\";\n\n    public static final int DEFAULT_ETCD3_NOTIFY_THREADS = Math.min(Runtime.getRuntime().availableProcessors() + 1, 32);\n\n    public static final String DEFAULT_ETCD3_NOTIFY_QUEUES_KEY = \"etcd3.notify.queues\";\n", "refactored_code": "    public static final int DEFAULT_IO_THREADS = Math.min(Runtime.getRuntime().availableProcessors() + 1, 32);\n\n    public static final String ETCD3_NOTIFY_MAXTHREADS_KEYS = \"etcd3.notify.maxthreads\";\n\n    public static final int DEFAULT_ETCD3_NOTIFY_THREADS = DEFAULT_IO_THREADS;\n\n    public static final String DEFAULT_ETCD3_NOTIFY_QUEUES_KEY = \"etcd3.notify.queues\";\n"}
{"magic_number_smell": "    /** Returns a string representation of this instance. */\n    public String toString() {\n\treturn \"DataServiceHeader[\" +\n\t    \"version:\" + 1 + \".\" + minorVersion +\n\t    \", appName:\\\"\" + appName + \"\\\"]\";\n    }\n", "refactored_code": "    private static final long serialVersionUID = 1;\n    /** Returns a string representation of this instance. */\n    public String toString() {\n\treturn \"DataServiceHeader[\" +\n\t    \"version:\" + serialVersionUID + \".\" + minorVersion +\n\t    \", appName:\\\"\" + appName + \"\\\"]\";\n    }\n"}
{"magic_number_smell": "            final String token = frames.nextToken();\n            // Determine if the line starts with <whitespace>at\n            final int at = token.indexOf(\"at\");\n            if (at != -1 && token.substring(0, at).trim().isEmpty()) {\n                traceStarted = true;\n                list.add(token);\n            } else if (traceStarted) {", "refactored_code": "    private static final int NOT_FOUND = -1;\n            final String token = frames.nextToken();\n            // Determine if the line starts with <whitespace>at\n            final int at = token.indexOf(\"at\");\n            if (at != NOT_FOUND && token.substring(0, at).trim().isEmpty()) {\n                traceStarted = true;\n                list.add(token);\n            } else if (traceStarted) {"}
{"magic_number_smell": "        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+5*1000) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }", "refactored_code": "    private static final long MIN_TIME_BETWEEN_GCS = 5*1000;\n        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+MIN_TIME_BETWEEN_GCS) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }"}
{"magic_number_smell": "    @Override\n    public void validate(final PreparedUpdate update, final UpdateContext updateContext) {\n        Ipv6Resource ipv6Resource = Ipv6Resource.parse(update.getUpdatedObject().getKey());\n        if (ipv6Resource.getPrefixLength() > 64) {\n            updateContext.addMessage(update, UpdateMessages.prefixTooSmall(64));\n        }\n    }", "refactored_code": "    private static final int MINIMUM_PREFIX_LENGTH = 64;\n    @Override\n    public void validate(final PreparedUpdate update, final UpdateContext updateContext) {\n        Ipv6Resource ipv6Resource = Ipv6Resource.parse(update.getUpdatedObject().getKey());\n        if (ipv6Resource.getPrefixLength() > MINIMUM_PREFIX_LENGTH) {\n            updateContext.addMessage(update, UpdateMessages.prefixTooSmall(MINIMUM_PREFIX_LENGTH));\n        }\n    }"}
{"magic_number_smell": "\n    static public final String BASE_CRYPTO = Crypto.XMR.getSymbol();\n    static public final int 12 = 12;\n    static public final long ONE_XMR = Math.round(Math.pow(10, Helper.12));\n\n    static public final boolean SHOW_EXCHANGERATES = true;\n    static public final boolean ALLOW_SHIFT = true;", "refactored_code": "    static public final int XMR_DECIMALS = 12;\n\n    static public final String BASE_CRYPTO = Crypto.XMR.getSymbol();\n    static public final int XMR_DECIMALS = 12;\n    static public final long ONE_XMR = Math.round(Math.pow(10, Helper.XMR_DECIMALS));\n\n    static public final boolean SHOW_EXCHANGERATES = true;\n    static public final boolean ALLOW_SHIFT = true;"}
{"magic_number_smell": "            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + AlarmManager.INTERVAL_HOUR;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {", "refactored_code": "    private static final long BACKUP_INTERVAL = AlarmManager.INTERVAL_HOUR;\n            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + BACKUP_INTERVAL;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {"}
{"magic_number_smell": "\t\tAssert.assertFalse(gotInterest);\n\t\tgetHandle.cancelInterest(interest1, tl);\n\t\tgetHandle.expressInterest(interest2, tl);\n\t\tAssert.assertTrue(\"Couldn't get semaphore\", filterSema.tryAcquire(8000, TimeUnit.MILLISECONDS));\n\t\tgetHandle.checkError(TEST_TIMEOUT);\n\t\tAssert.assertTrue(gotInterest);\n\t\tgetHandle.cancelInterest(interest2, tl);", "refactored_code": "\tprotected static final int WAIT_MILLIS = 8000;\n\t\tAssert.assertFalse(gotInterest);\n\t\tgetHandle.cancelInterest(interest1, tl);\n\t\tgetHandle.expressInterest(interest2, tl);\n\t\tAssert.assertTrue(\"Couldn't get semaphore\", filterSema.tryAcquire(WAIT_MILLIS, TimeUnit.MILLISECONDS));\n\t\tgetHandle.checkError(TEST_TIMEOUT);\n\t\tAssert.assertTrue(gotInterest);\n\t\tgetHandle.cancelInterest(interest2, tl);"}
{"magic_number_smell": "        // TODO We limit the notification of config changes to a specific path level, for example\n        //  /dubbo/config/service/configurators, other config changes not in this level will not get notified,\n        //  say /dubbo/config/dubbo.properties\n        if (path.split(\"/\").length >= 5) {\n            String key = pathToKey(path);\n            ConfigChangeType changeType;\n            switch (eventType) {", "refactored_code": "    private static final int MIN_PATH_DEPTH = 5;\n        // TODO We limit the notification of config changes to a specific path level, for example\n        //  /dubbo/config/service/configurators, other config changes not in this level will not get notified,\n        //  say /dubbo/config/dubbo.properties\n        if (path.split(\"/\").length >= MIN_PATH_DEPTH) {\n            String key = pathToKey(path);\n            ConfigChangeType changeType;\n            switch (eventType) {"}
{"magic_number_smell": "  private boolean drawFrameOrFallback(Canvas canvas, int frameNumber, @FrameType int frameType) {\n    CloseableReference<Bitmap> bitmapReference = null;\n    boolean drawn = false;\n    int nextFrameType = -1;\n\n    try {\n      switch (frameType) {", "refactored_code": "  public static final int FRAME_TYPE_UNKNOWN = -1;\n  private boolean drawFrameOrFallback(Canvas canvas, int frameNumber, @FrameType int frameType) {\n    CloseableReference<Bitmap> bitmapReference = null;\n    boolean drawn = false;\n    int nextFrameType = FRAME_TYPE_UNKNOWN;\n\n    try {\n      switch (frameType) {"}
{"magic_number_smell": "        int offset = 0;\n        int readed;\n\n        while (offset < size && (readed = input.read(data, offset, size - offset)) != -1) {\n            offset += readed;\n        }\n", "refactored_code": "    private static final int EOF = -1;\n        int offset = 0;\n        int readed;\n\n        while (offset < size && (readed = input.read(data, offset, size - offset)) != EOF) {\n            offset += readed;\n        }\n"}
{"magic_number_smell": "        boolean reallyMultiCore = coreSize >= CORE_SIZE_CHECK;\n        int concurrencyLevel = reallyMultiCore ? coreSize * CORE_SIZE_FACTOR : CONCURRENCY_LEVEL;\n        this.executingCalls =\n                new ConcurrentHashMap<RemoteCallKey, RemoteCallKey>(1000, LOAD_FACTOR, concurrencyLevel);\n        this.invocations = new ConcurrentHashMap<Long, BasicInvocation>(1000, LOAD_FACTOR, concurrencyLevel);\n        this.scheduler = new BasicOperationScheduler(node, executionService, new BasicOperationProcessorImpl());\n    }", "refactored_code": "    private static final int INITIAL_CAPACITY = 1000;\n        boolean reallyMultiCore = coreSize >= CORE_SIZE_CHECK;\n        int concurrencyLevel = reallyMultiCore ? coreSize * CORE_SIZE_FACTOR : CONCURRENCY_LEVEL;\n        this.executingCalls =\n                new ConcurrentHashMap<RemoteCallKey, RemoteCallKey>(INITIAL_CAPACITY, LOAD_FACTOR, concurrencyLevel);\n        this.invocations = new ConcurrentHashMap<Long, BasicInvocation>(INITIAL_CAPACITY, LOAD_FACTOR, concurrencyLevel);\n        this.scheduler = new BasicOperationScheduler(node, executionService, new BasicOperationProcessorImpl());\n    }"}
{"magic_number_smell": "                    });\n                }\n                break;\n            case 1:\n                Long startTime = (Long) msg.obj;\n                if (startTime != null) {\n                    pausedPostion = startTime;", "refactored_code": "    public static final int START = 1;\n                    });\n                }\n                break;\n            case START:\n                Long startTime = (Long) msg.obj;\n                if (startTime != null) {\n                    pausedPostion = startTime;"}
{"magic_number_smell": "    private final GridMenuItemStyle mStyle;\n    private Array<T> mItems;\n    private final Array<FocusIndicator> mFocusIndicators = new Array<>();\n    private int mSelectedIndex = -1;\n    private int mCurrentIndex = 0;\n    private ItemRenderer<T> mRenderer;\n    private SelectionListener<T> mSelectionListener;", "refactored_code": "    public static final int INVALID_INDEX = -1;\n    private final GridMenuItemStyle mStyle;\n    private Array<T> mItems;\n    private final Array<FocusIndicator> mFocusIndicators = new Array<>();\n    private int mSelectedIndex = INVALID_INDEX;\n    private int mCurrentIndex = 0;\n    private ItemRenderer<T> mRenderer;\n    private SelectionListener<T> mSelectionListener;"}
{"magic_number_smell": "    {\n        if (nowNs >= clockUpdateDeadlineNs)\n        {\n            clockUpdateDeadlineNs = nowNs + TimeUnit.MILLISECONDS.toNanos(1);\n            cachedNanoClock.update(nowNs);\n            cachedEpochClock.update(epochClock.time());\n        }", "refactored_code": "    private static final long CLOCK_UPDATE_DURATION_NS = TimeUnit.MILLISECONDS.toNanos(1);\n    {\n        if (nowNs >= clockUpdateDeadlineNs)\n        {\n            clockUpdateDeadlineNs = nowNs + CLOCK_UPDATE_DURATION_NS;\n            cachedNanoClock.update(nowNs);\n            cachedEpochClock.update(epochClock.time());\n        }"}
{"magic_number_smell": "        //Constants used in AbstractCard for scale formatting\n        private static final float 300.0F * Settings.scale = 300.0F * Settings.scale;\n        //Multipliers are slightly fudged to be more forgiving to longer names\n        private static final float TITLE_BOX_WIDTH = 300.0F * Settings.scale * 0.7F; //Was 0.6F\n        private static final float TITLE_BOX_WIDTH_NO_COST = 300.0F * Settings.scale * 0.8F; //Was 0.7F\n        private static final GlyphLayout gl = new GlyphLayout();\n", "refactored_code": "        private static final float IMG_WIDTH = 300.0F * Settings.scale;\n        //Constants used in AbstractCard for scale formatting\n        private static final float IMG_WIDTH = 300.0F * Settings.scale;\n        //Multipliers are slightly fudged to be more forgiving to longer names\n        private static final float TITLE_BOX_WIDTH = IMG_WIDTH * 0.7F; //Was 0.6F\n        private static final float TITLE_BOX_WIDTH_NO_COST = IMG_WIDTH * 0.8F; //Was 0.7F\n        private static final GlyphLayout gl = new GlyphLayout();\n"}
{"magic_number_smell": "        if (inputStream instanceof DataInputStream) {\n            this.dataInputStream = (DataInputStream) inputStream;\n        } else {\n            this.dataInputStream = new DataInputStream(new BufferedInputStream(inputStream, 8192));\n        }\n    }\n", "refactored_code": "    private static final int BUFSIZE = 8192;\n        if (inputStream instanceof DataInputStream) {\n            this.dataInputStream = (DataInputStream) inputStream;\n        } else {\n            this.dataInputStream = new DataInputStream(new BufferedInputStream(inputStream, BUFSIZE));\n        }\n    }\n"}
{"magic_number_smell": "      isDone.set(false);\n      planId.set(FootstepPlanningRequestPacket.NO_PLAN_ID);\n\n      for (int i = 0; i < 1; i++)\n      {\n         PathPlanningStage pathPlanningStage = createNewPathPlanningStage();\n         registry.addChild(pathPlanningStage.getYoVariableRegistry());", "refactored_code": "   private static final int initialNumberOfPathStages = 1;\n      isDone.set(false);\n      planId.set(FootstepPlanningRequestPacket.NO_PLAN_ID);\n\n      for (int i = 0; i < initialNumberOfPathStages; i++)\n      {\n         PathPlanningStage pathPlanningStage = createNewPathPlanningStage();\n         registry.addChild(pathPlanningStage.getYoVariableRegistry());"}
{"magic_number_smell": "    @Override\n    public void tick() {\n        if (gameOver > 0) {\n            if (++gameOver > 15) {\n                chips.clear();\n                gameOver = 0;\n            } else return;", "refactored_code": "    public static final int TIMEOUT_TICKS = 15;\n    @Override\n    public void tick() {\n        if (gameOver > 0) {\n            if (++gameOver > TIMEOUT_TICKS) {\n                chips.clear();\n                gameOver = 0;\n            } else return;"}
{"magic_number_smell": "    {\n        int format = 0;\n\n        byte[] magic = new byte[8];\n\n        // If this is not an HDF5 file, then the magic number is at\n        // position 0; If it is an HDF5 file, then we need to search", "refactored_code": "    static private final int MAGIC_NUMBER_LEN = 8;\n    {\n        int format = 0;\n\n        byte[] magic = new byte[MAGIC_NUMBER_LEN];\n\n        // If this is not an HDF5 file, then the magic number is at\n        // position 0; If it is an HDF5 file, then we need to search"}
{"magic_number_smell": "      double headingToObstacle = BodyPathPlannerTools.calculateHeading(headingToClosestObstacle);\n      double distanceToObstacle = headingToClosestObstacle.length() + parameters.getObstacleExtrusionDistance();\n\n      if (distanceToObstacle > parameters.getPreferredObstacleExtrusionDistance() - 5e-2)\n         return nominalHeading;\n\n//      double rotationForAvoidance = computeRotationForAvoidanceUsingBox(distanceToObstacle, parameters.getObstacleExtrusionDistance());", "refactored_code": "   private static final double epsilon = 5e-2;\n      double headingToObstacle = BodyPathPlannerTools.calculateHeading(headingToClosestObstacle);\n      double distanceToObstacle = headingToClosestObstacle.length() + parameters.getObstacleExtrusionDistance();\n\n      if (distanceToObstacle > parameters.getPreferredObstacleExtrusionDistance() - epsilon)\n         return nominalHeading;\n\n//      double rotationForAvoidance = computeRotationForAvoidanceUsingBox(distanceToObstacle, parameters.getObstacleExtrusionDistance());"}
{"magic_number_smell": "\n  public static synchronized void reset() {\n    for (final Entry<Integer, boolean[]> each : CLASS_HITS.entrySet()) {\n      if (each.getValue()[0]) { //Probe 0 gets covered by any method that runs\n        Arrays.fill(each.getValue(), false);\n      }\n    }", "refactored_code": "  private static final int                     CLASS_HIT_INDEX   = 0;\n\n  public static synchronized void reset() {\n    for (final Entry<Integer, boolean[]> each : CLASS_HITS.entrySet()) {\n      if (each.getValue()[CLASS_HIT_INDEX]) { //Probe 0 gets covered by any method that runs\n        Arrays.fill(each.getValue(), false);\n      }\n    }"}
{"magic_number_smell": "        long totalLength = 0;\n\n        // only track progress for files larger than 100kb in verbose mode\n        boolean trackProgress = getVerbose() && filesize > 102400;\n        // since filesize keeps on decreasing we have to store the\n        // initial filesize\n        long initFilesize = filesize;", "refactored_code": "    private static final int HUNDRED_KILOBYTES = 102400;\n        long totalLength = 0;\n\n        // only track progress for files larger than 100kb in verbose mode\n        boolean trackProgress = getVerbose() && filesize > HUNDRED_KILOBYTES;\n        // since filesize keeps on decreasing we have to store the\n        // initial filesize\n        long initFilesize = filesize;"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "         nodeShift.set(nodeShiftToAvoidObstacles);\n      }\n\n      if (nodeShift.length() > 0.01)\n      {\n         nextPointInWorld2D.add(nodeShift);\n         nodeLocationToPack.set(nextPointInWorld2D, findHeightOfPoint(nextPointInWorld2D, bothRegions));", "refactored_code": "   private static final double minDistanceToMove = 0.01;\n         nodeShift.set(nodeShiftToAvoidObstacles);\n      }\n\n      if (nodeShift.length() > minDistanceToMove)\n      {\n         nextPointInWorld2D.add(nodeShift);\n         nodeLocationToPack.set(nextPointInWorld2D, findHeightOfPoint(nextPointInWorld2D, bothRegions));"}
{"magic_number_smell": "\n\n    public DPXReader(SeekableByteChannel ch) throws IOException {\n        this.readBuf = allocate(2048 + 1024);\n        initialRead(ch);\n        this.magic = readBuf.getInt();\n", "refactored_code": "    private static final int READ_BUFFER_SIZE = 2048 + 1024;\n\n\n    public DPXReader(SeekableByteChannel ch) throws IOException {\n        this.readBuf = allocate(READ_BUFFER_SIZE);\n        initialRead(ch);\n        this.magic = readBuf.getInt();\n"}
{"magic_number_smell": "            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > 50 ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;", "refactored_code": "    private static final int INET_CONDITION_THRESHOLD = 50;\n            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;"}
{"magic_number_smell": "    public void sizeOfListShouldBeTwo() {\n        assertThat(list)\n                .overridingErrorMessage(\"Expected size of list to be: %d but was: %d\",\n                        2,\n                        list.size()\n                )\n                .hasSize(2);", "refactored_code": "    private static final int EXPECTED_SIZE = 2;\n    public void sizeOfListShouldBeTwo() {\n        assertThat(list)\n                .overridingErrorMessage(\"Expected size of list to be: %d but was: %d\",\n                        EXPECTED_SIZE,\n                        list.size()\n                )\n                .hasSize(EXPECTED_SIZE);"}
{"magic_number_smell": "            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + AlarmManager.INTERVAL_HOUR;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {", "refactored_code": "    private static final long BACKUP_INTERVAL = AlarmManager.INTERVAL_HOUR;\n            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + BACKUP_INTERVAL;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {"}
{"magic_number_smell": "        this.messageTransferQueue = Collections\r\n            .synchronizedList(new LinkedList<MessageTransfer>());\r\n\r\n        this.executor = Executors.newFixedThreadPool(10);\r\n\r\n        this.connection = connection;\r\n        this.chatmanager = connection.getChatManager();\r", "refactored_code": "    public static final int MAX_PARALLEL_SENDS = 10;\r\n        this.messageTransferQueue = Collections\r\n            .synchronizedList(new LinkedList<MessageTransfer>());\r\n\r\n        this.executor = Executors.newFixedThreadPool(MAX_PARALLEL_SENDS);\r\n\r\n        this.connection = connection;\r\n        this.chatmanager = connection.getChatManager();\r"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "        emitSPIRVCapabilities(module);\n        emitImportOpenCL(asm, module);\n        emitOpenCLAddressingMode(module);\n        emitOpSourceForOpenCL(module, SPIRV_HEADER_VALUES.300000);\n\n        boolean isParallel = crb.isParallel();\n        // Generate this only if the kernel is parallel (it uses the get_global_id)", "refactored_code": "        public static final int SPIRV_VERSION_FOR_OPENCL = 300000;\n        emitSPIRVCapabilities(module);\n        emitImportOpenCL(asm, module);\n        emitOpenCLAddressingMode(module);\n        emitOpSourceForOpenCL(module, SPIRV_HEADER_VALUES.SPIRV_VERSION_FOR_OPENCL);\n\n        boolean isParallel = crb.isParallel();\n        // Generate this only if the kernel is parallel (it uses the get_global_id)"}
{"magic_number_smell": "            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > 50 ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;", "refactored_code": "    private static final int INET_CONDITION_THRESHOLD = 50;\n            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;"}
{"magic_number_smell": "        StringBuilder result = buffer.get();\n        if (result == null) {\n            final int currentPatternLength = messagePattern == null ? 0 : messagePattern.length();\n            result = new StringBuilder(Math.min(512, currentPatternLength * 2));\n            buffer.set(result);\n        }\n        result.setLength(0);", "refactored_code": "    private static final int MIN_BUILDER_SIZE = 512;\n        StringBuilder result = buffer.get();\n        if (result == null) {\n            final int currentPatternLength = messagePattern == null ? 0 : messagePattern.length();\n            result = new StringBuilder(Math.min(MIN_BUILDER_SIZE, currentPatternLength * 2));\n            buffer.set(result);\n        }\n        result.setLength(0);"}
{"magic_number_smell": "\n    private Paint paint;\n    private int viewWidth;\n    private int textSize = 20;\n    private int textColorNormal = TEXT_COLOR_NORMAL;\n    private int textColorFocus = TEXT_COLOR_FOCUS;\n    private int lineColor = LINE_COLOR;", "refactored_code": "    public static final int TEXT_SIZE = 20;\n\n    private Paint paint;\n    private int viewWidth;\n    private int textSize = TEXT_SIZE;\n    private int textColorNormal = TEXT_COLOR_NORMAL;\n    private int textColorFocus = TEXT_COLOR_FOCUS;\n    private int lineColor = LINE_COLOR;"}
{"magic_number_smell": "\t}\n\n\tpublic void testMultipleIncludesError() throws IOException {\n\t\trunParserTest(GCC_ERROR_STREAM1, GCC_ERROR_STREAM1_ERRORS, 1, GCC_ERROR_STREAM1_FILENAMES, null,\n\t\t\t\tnew String[]{GCC_ERROR_PARSER_ID});\n\t}\n", "refactored_code": "\tpublic static final int GCC_ERROR_STREAM1_WARNINGS = 1;\n\t}\n\n\tpublic void testMultipleIncludesError() throws IOException {\n\t\trunParserTest(GCC_ERROR_STREAM1, GCC_ERROR_STREAM1_ERRORS, GCC_ERROR_STREAM1_WARNINGS, GCC_ERROR_STREAM1_FILENAMES, null,\n\t\t\t\tnew String[]{GCC_ERROR_PARSER_ID});\n\t}\n"}
{"magic_number_smell": "\t\tint stackSize = imp.getStackSize();\n\t\tif (stackSize>1) {\n\t\t\tString macroOptions = Macro.getOptions();\n\t\t\tif (imp.isComposite() && ((CompositeImage)imp).getMode()==IJ.1, COLOR=2, GRAYSCALE=3) {\n\t\t\t\tif (macroOptions==null || !macroOptions.contains(\"slice\"))\n\t\t\t\t\treturn flags | PlugInFilter.DOES_STACKS;\n\t\t\t}", "refactored_code": "\tpublic static final int COMPOSITE=1, COLOR=2, GRAYSCALE=3;\n\t\tint stackSize = imp.getStackSize();\n\t\tif (stackSize>1) {\n\t\t\tString macroOptions = Macro.getOptions();\n\t\t\tif (imp.isComposite() && ((CompositeImage)imp).getMode()==IJ.COMPOSITE) {\n\t\t\t\tif (macroOptions==null || !macroOptions.contains(\"slice\"))\n\t\t\t\t\treturn flags | PlugInFilter.DOES_STACKS;\n\t\t\t}"}
{"magic_number_smell": "  public void toProtoAttributes() {\n    Attributes expected =\n        Attributes.newBuilder()\n            .setDroppedAttributesCount(1)\n            .putAttributeMap(\n                ATTRIBUTE_KEY_1,\n                io.opentelemetry.proto.trace.v1.AttributeValue.newBuilder()", "refactored_code": "  private static final int DROPPED_ATTRIBUTES_COUNT = 1;\n  public void toProtoAttributes() {\n    Attributes expected =\n        Attributes.newBuilder()\n            .setDroppedAttributesCount(DROPPED_ATTRIBUTES_COUNT)\n            .putAttributeMap(\n                ATTRIBUTE_KEY_1,\n                io.opentelemetry.proto.trace.v1.AttributeValue.newBuilder()"}
{"magic_number_smell": "      yPoly.setQuadratic(0.0, 1.0, bodyStartPose.getY(), Math.sin(yaw) * 0.2, bodyGoalPose.getY());\n      zPoly.setQuadratic(0.0, 1.0, bodyStartPose.getZ(), 0.0, bodyGoalPose.getZ());\n      yawPoly.setQuadratic(0.0, 1.0, bodyStartPose.getYaw(), 0.0, bodyGoalPose.getYaw());\n      for (int i = 0; i < 5; i++)\n      {\n         double percent = i / (double) (5 - 1);\n         xPoly.compute(percent);", "refactored_code": "   private static final int numberOfPoints = 5;\n      yPoly.setQuadratic(0.0, 1.0, bodyStartPose.getY(), Math.sin(yaw) * 0.2, bodyGoalPose.getY());\n      zPoly.setQuadratic(0.0, 1.0, bodyStartPose.getZ(), 0.0, bodyGoalPose.getZ());\n      yawPoly.setQuadratic(0.0, 1.0, bodyStartPose.getYaw(), 0.0, bodyGoalPose.getYaw());\n      for (int i = 0; i < numberOfPoints; i++)\n      {\n         double percent = i / (double) (numberOfPoints - 1);\n         xPoly.compute(percent);"}
{"magic_number_smell": "        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+5*1000) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }", "refactored_code": "    private static final long MIN_TIME_BETWEEN_GCS = 5*1000;\n        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+MIN_TIME_BETWEEN_GCS) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }"}
{"magic_number_smell": "        builder = new ConfigurationBuilder();\n        builder.addServer()\n                .host(SERVER_HOST)\n                .port(11222);\n    }\n\n    @After", "refactored_code": "    private final int HOTROD_PORT = 11222;\n        builder = new ConfigurationBuilder();\n        builder.addServer()\n                .host(SERVER_HOST)\n                .port(HOTROD_PORT);\n    }\n\n    @After"}
{"magic_number_smell": "        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+5*1000) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }", "refactored_code": "    private static final long MIN_TIME_BETWEEN_GCS = 5*1000;\n        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+MIN_TIME_BETWEEN_GCS) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }"}
{"magic_number_smell": "        if (readerIdleTime <= 0) {\n            readerIdleTimeNanos = 0;\n        } else {\n            readerIdleTimeNanos = Math.max(unit.toNanos(readerIdleTime), TimeUnit.MILLISECONDS.toNanos(1));\n        }\n        if (writerIdleTime <= 0) {\n            writerIdleTimeNanos = 0;", "refactored_code": "    private static final long MIN_TIMEOUT_NANOS = TimeUnit.MILLISECONDS.toNanos(1);\n        if (readerIdleTime <= 0) {\n            readerIdleTimeNanos = 0;\n        } else {\n            readerIdleTimeNanos = Math.max(unit.toNanos(readerIdleTime), MIN_TIMEOUT_NANOS);\n        }\n        if (writerIdleTime <= 0) {\n            writerIdleTimeNanos = 0;"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);"}
{"magic_number_smell": "\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != 0x414E4554) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n", "refactored_code": "    private static final int FILE_MAGIC = 0x414E4554;\n\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != FILE_MAGIC) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n"}
{"magic_number_smell": "    // A queue for storing peer bonded events.\n    final ArrayBlockingQueue<PeerBondedEvent> queue = new ArrayBlockingQueue<>(10);\n    agent.observePeerBondedEvents(queue::add);\n    assertThatCode(() -> agent.start(26422).get(5, TimeUnit.SECONDS))\n        .doesNotThrowAnyException();\n\n    // Wait until we've received 5 events.", "refactored_code": "  private static final int BROADCAST_TCP_PORT = 26422;\n    // A queue for storing peer bonded events.\n    final ArrayBlockingQueue<PeerBondedEvent> queue = new ArrayBlockingQueue<>(10);\n    agent.observePeerBondedEvents(queue::add);\n    assertThatCode(() -> agent.start(BROADCAST_TCP_PORT).get(5, TimeUnit.SECONDS))\n        .doesNotThrowAnyException();\n\n    // Wait until we've received 5 events."}
{"magic_number_smell": "        long totalLength = filesize;\n\n        // only track progress for files larger than 100kb in verbose mode\n        boolean trackProgress = getVerbose() && filesize > 102400;\n\n        SftpProgressMonitor monitor = null;\n        if (trackProgress) {", "refactored_code": "    private static final int HUNDRED_KILOBYTES = 102400;\n        long totalLength = filesize;\n\n        // only track progress for files larger than 100kb in verbose mode\n        boolean trackProgress = getVerbose() && filesize > HUNDRED_KILOBYTES;\n\n        SftpProgressMonitor monitor = null;\n        if (trackProgress) {"}
{"magic_number_smell": "    private Callback<WorkbenchFx, Node> navigationDrawerFactory = workbench -> {\n      NavigationDrawer navigationDrawer = new NavigationDrawer(workbench);\n      StackPane.setAlignment(navigationDrawer, Pos.TOP_LEFT);\n      navigationDrawer.maxWidthProperty().bind(workbench.widthProperty().multiply(.333));\n      return navigationDrawer;\n    };\n", "refactored_code": "    private final double widthPercentage = .333;\n    private Callback<WorkbenchFx, Node> navigationDrawerFactory = workbench -> {\n      NavigationDrawer navigationDrawer = new NavigationDrawer(workbench);\n      StackPane.setAlignment(navigationDrawer, Pos.TOP_LEFT);\n      navigationDrawer.maxWidthProperty().bind(workbench.widthProperty().multiply(widthPercentage));\n      return navigationDrawer;\n    };\n"}
{"magic_number_smell": "    if (x == 0 && y == 0 && w == 1 && h == 1) {\n      return buf;\n    }\n    else if (getSizeX() <= 8192 && getSizeY() <= 8192) {\n      int ifdIndex = getIFDIndex(getSeries(), no);\n      in = new RandomAccessInputStream(currentId);\n      tiffParser = new TiffParser(in);", "refactored_code": "  private static final int MAX_SIZE = 8192;\n    if (x == 0 && y == 0 && w == 1 && h == 1) {\n      return buf;\n    }\n    else if (getSizeX() <= MAX_SIZE && getSizeY() <= MAX_SIZE) {\n      int ifdIndex = getIFDIndex(getSeries(), no);\n      in = new RandomAccessInputStream(currentId);\n      tiffParser = new TiffParser(in);"}
{"magic_number_smell": "     * @param charset the character set name to use\n     */\n    public CharSequenceInputStream(final CharSequence s, final Charset charset) {\n        this(s, charset, 2048);\n    }\n\n    /**", "refactored_code": "    private static final int BUFFER_SIZE = 2048;\n     * @param charset the character set name to use\n     */\n    public CharSequenceInputStream(final CharSequence s, final Charset charset) {\n        this(s, charset, BUFFER_SIZE);\n    }\n\n    /**"}
{"magic_number_smell": "\tprotected static final String [] _tagToStringMap = new String[]{\n\t\tnull, null, null, null, null, null, null, null, null, null, null,\n\t\tnull, null,\n\t\t\"13\", \"Name\", \"Component\", \"Certificate\", \"Collection\", \"CompleteName\",\n\t\t\"Content\", \"SignedInfo\", \"ContentDigest\", \"ContentHash\", null, \"Count\", \"Header\",\n\t\t\"Interest\", \"Key\", \"KeyLocator\", \"KeyName\", \"Length\", \"Link\", \"LinkAuthenticator\",\n\t\t\"NameComponentCount\", \"ExtOpt\", null, \"RootDigest\", \"Signature\", \"Start\", \"Timestamp\", \"Type\",", "refactored_code": "\tpublic static final int Any = 13;\n\tprotected static final String [] _tagToStringMap = new String[]{\n\t\tnull, null, null, null, null, null, null, null, null, null, null,\n\t\tnull, null,\n\t\t\"Any\", \"Name\", \"Component\", \"Certificate\", \"Collection\", \"CompleteName\",\n\t\t\"Content\", \"SignedInfo\", \"ContentDigest\", \"ContentHash\", null, \"Count\", \"Header\",\n\t\t\"Interest\", \"Key\", \"KeyLocator\", \"KeyName\", \"Length\", \"Link\", \"LinkAuthenticator\",\n\t\t\"NameComponentCount\", \"ExtOpt\", null, \"RootDigest\", \"Signature\", \"Start\", \"Timestamp\", \"Type\","}
{"magic_number_smell": "public final class BinaryXMLDecoder extends GenericXMLDecoder implements XMLDecoder {\n\n\tpublic final int 512 = 512;\t// Default max we can go back for a resync\n\tprotected int _resyncLimit = 512;\n\tprotected boolean _resyncable = false;\n\n\tpublic BinaryXMLDecoder() {", "refactored_code": "\tpublic final int RESYNC_LIMIT = 512;\t// Default max we can go back for a resync\npublic final class BinaryXMLDecoder extends GenericXMLDecoder implements XMLDecoder {\n\n\tpublic final int RESYNC_LIMIT = 512;\t// Default max we can go back for a resync\n\tprotected int _resyncLimit = RESYNC_LIMIT;\n\tprotected boolean _resyncable = false;\n\n\tpublic BinaryXMLDecoder() {"}
{"magic_number_smell": "    }\n\n    private void removeOldFile() {\n        String oldPath = randomAccessFilePath(3 - 1);\n        File oldFile = new File(oldPath);\n        if (oldFile.exists()) {\n            try {", "refactored_code": "    private static final int MINI_THUMB_DATA_FILE_VERSION = 3;\n    }\n\n    private void removeOldFile() {\n        String oldPath = randomAccessFilePath(MINI_THUMB_DATA_FILE_VERSION - 1);\n        File oldFile = new File(oldPath);\n        if (oldFile.exists()) {\n            try {"}
{"magic_number_smell": "          logger.info(\"Rescheduling {} URLs from previous crawl.\", numPreviouslyInProcessPages);\n          scheduledPages -= numPreviouslyInProcessPages;\n\n          List<WebURL> urls = inProcessPages.get(100);\n          while (!urls.isEmpty()) {\n            scheduleAll(urls);\n            inProcessPages.delete(urls.size());", "refactored_code": "  private static final int MAX_IN_PROCESS_PAGES = 100;\n          logger.info(\"Rescheduling {} URLs from previous crawl.\", numPreviouslyInProcessPages);\n          scheduledPages -= numPreviouslyInProcessPages;\n\n          List<WebURL> urls = inProcessPages.get(MAX_IN_PROCESS_PAGES);\n          while (!urls.isEmpty()) {\n            scheduleAll(urls);\n            inProcessPages.delete(urls.size());"}
{"magic_number_smell": "\t\tRunnable defer = () -> {\n\t\t\tlong start = startTime;\n\t\t\ttry {\n\t\t\t\tThread.sleep(4000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tLOGGER.error(\"stopPlaying sleep interrupted\", e);\n\t\t\t}", "refactored_code": "\tprivate static final int STOP_PLAYING_DELAY = 4000;\n\t\tRunnable defer = () -> {\n\t\t\tlong start = startTime;\n\t\t\ttry {\n\t\t\t\tThread.sleep(STOP_PLAYING_DELAY);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tLOGGER.error(\"stopPlaying sleep interrupted\", e);\n\t\t\t}"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "\t\t\t\t}\n\t\t\t}\n\t\t\tif ( list.isEmpty() && haslatest)\n\t\t\t\tlist.add( new Version(999999999,0,0));\n\t\t\treturn new SortedList<Version>(list);\n\t\t}\n\t\treturn SortedList.empty();", "refactored_code": "\tpublic static final int\tMAX_MAJOR\t= 999999999;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( list.isEmpty() && haslatest)\n\t\t\t\tlist.add( new Version(MAX_MAJOR,0,0));\n\t\t\treturn new SortedList<Version>(list);\n\t\t}\n\t\treturn SortedList.empty();"}
{"magic_number_smell": "        @Override\n        public int getItemViewType(int index) {\n            if (index == 0) {\n                return 0;\n            } else if (index == 1) {\n                return VIEW_TYPE_ALL_PHOTOS;\n            } else {", "refactored_code": "    private final int VIEW_TYPE_TAKE_PHOTO = 0;\n        @Override\n        public int getItemViewType(int index) {\n            if (index == 0) {\n                return VIEW_TYPE_TAKE_PHOTO;\n            } else if (index == 1) {\n                return VIEW_TYPE_ALL_PHOTOS;\n            } else {"}
{"magic_number_smell": "        OrderByToken orderByToken = orderByTokenGenerator.generateSQLToken(selectStatementContext);\n        assertThat(orderByToken.getColumnLabels().get(0), is(TEST_COLUMN_ORDER_BY_ITEM_SEGMENT_COLUMN_LABEL));\n        assertThat(orderByToken.getColumnLabels().get(1), is(TEST_EXPRESSION_ORDER_BY_ITEM_SEGMENT_COLUMN_LABEL));\n        assertThat(orderByToken.getColumnLabels().get(2), is(String.valueOf(5)));\n        assertThat(orderByToken.getOrderDirections().get(0), is(orderDirection));\n    }\n", "refactored_code": "    private static final int TEST_OTHER_CLASS_ORDER_BY_ITEM_INDEX = 5;\n        OrderByToken orderByToken = orderByTokenGenerator.generateSQLToken(selectStatementContext);\n        assertThat(orderByToken.getColumnLabels().get(0), is(TEST_COLUMN_ORDER_BY_ITEM_SEGMENT_COLUMN_LABEL));\n        assertThat(orderByToken.getColumnLabels().get(1), is(TEST_EXPRESSION_ORDER_BY_ITEM_SEGMENT_COLUMN_LABEL));\n        assertThat(orderByToken.getColumnLabels().get(2), is(String.valueOf(TEST_OTHER_CLASS_ORDER_BY_ITEM_INDEX)));\n        assertThat(orderByToken.getOrderDirections().get(0), is(orderDirection));\n    }\n"}
{"magic_number_smell": "    final Bytes32 keccak256 = host.keccak256();\n    final MutableBytesValue template = MutableBytesValue.create(keccak256.size());\n    byte msb = keccak256.get(0);\n    msb ^= -128;\n    template.set(0, msb);\n\n    for (int i = 0; i < n; i++) {", "refactored_code": "  private static final byte MOST_SIGNFICANT_BIT_MASK = -128;\n    final Bytes32 keccak256 = host.keccak256();\n    final MutableBytesValue template = MutableBytesValue.create(keccak256.size());\n    byte msb = keccak256.get(0);\n    msb ^= MOST_SIGNFICANT_BIT_MASK;\n    template.set(0, msb);\n\n    for (int i = 0; i < n; i++) {"}
{"magic_number_smell": "    /**\n     * Timeout value for nodes to accept client connection requests.\n     */\n    private int connectionTimeout = 5000;\n\n    /**\n     * While client is trying to connect initially to one of the members in the {@link ClientNetworkConfig#addressList},", "refactored_code": "    private static final int CONNECTION_TIMEOUT = 5000;\n    /**\n     * Timeout value for nodes to accept client connection requests.\n     */\n    private int connectionTimeout = CONNECTION_TIMEOUT;\n\n    /**\n     * While client is trying to connect initially to one of the members in the {@link ClientNetworkConfig#addressList},"}
{"magic_number_smell": "\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != 0x414E4554) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n", "refactored_code": "    private static final int FILE_MAGIC = 0x414E4554;\n\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != FILE_MAGIC) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n"}
{"magic_number_smell": "        long sum = 0;\n\n        for (int i = 0; i < buf.length; ++i) {\n            sum += 255 & buf[i];\n        }\n\n        return sum;", "refactored_code": "    private static final int BYTE_MASK = 255;\n        long sum = 0;\n\n        for (int i = 0; i < buf.length; ++i) {\n            sum += BYTE_MASK & buf[i];\n        }\n\n        return sum;"}
{"magic_number_smell": "        }\n        final byte[] data = item.data();\n        final int len = data.length;\n        if(len > 0 && (data[0] & 0x80) != 0) {\n            return isInt\n                    ? (Object) BizarroIntegers.getInt(data, 0, len)\n                    : (Object) BizarroIntegers.getLong(data, 0, len);", "refactored_code": "    private static final int SIGN_BIT_MASK = 0x80;\n        }\n        final byte[] data = item.data();\n        final int len = data.length;\n        if(len > 0 && (data[0] & SIGN_BIT_MASK) != 0) {\n            return isInt\n                    ? (Object) BizarroIntegers.getInt(data, 0, len)\n                    : (Object) BizarroIntegers.getLong(data, 0, len);"}
{"magic_number_smell": "\n  private boolean mayFillRequest(int requestedSize, Integer actualSize) {\n    return actualSize != null\n        && (isNoMoreThanHalfFull() || actualSize <= (8 * requestedSize));\n  }\n\n  private boolean isNoMoreThanHalfFull() {", "refactored_code": "  private static final int MAX_OVER_SIZE_MULTIPLE = 8;\n\n  private boolean mayFillRequest(int requestedSize, Integer actualSize) {\n    return actualSize != null\n        && (isNoMoreThanHalfFull() || actualSize <= (MAX_OVER_SIZE_MULTIPLE * requestedSize));\n  }\n\n  private boolean isNoMoreThanHalfFull() {"}
{"magic_number_smell": "            throw new SubMerchantOnboardingInvalidSmsVerificationCode(\"SMS verification code can not be empty or null\");\n        }\n\n        if (StringUtils.length(verificationCode) != 6) {\n            throw new SubMerchantOnboardingInvalidSmsVerificationCode(\n                    String.format(\"SMS verification code should be %d characters long\", 6)\n            );", "refactored_code": "    private static final int VERIFICATION_CODE_LENGTH = 6;\n            throw new SubMerchantOnboardingInvalidSmsVerificationCode(\"SMS verification code can not be empty or null\");\n        }\n\n        if (StringUtils.length(verificationCode) != VERIFICATION_CODE_LENGTH) {\n            throw new SubMerchantOnboardingInvalidSmsVerificationCode(\n                    String.format(\"SMS verification code should be %d characters long\", VERIFICATION_CODE_LENGTH)\n            );"}
{"magic_number_smell": "    @Override\n    public void awaitShutdown() {\n        try {\n            shutdownLatch.await(3, TimeUnit.SECONDS);\n        } catch (InterruptedException ignored) {\n            EmptyStatement.ignore(ignored);\n        }", "refactored_code": "    private static final int SHUTDOWN_TIMEOUT_SECONDS = 3;\n    @Override\n    public void awaitShutdown() {\n        try {\n            shutdownLatch.await(SHUTDOWN_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n        } catch (InterruptedException ignored) {\n            EmptyStatement.ignore(ignored);\n        }"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "        assertThat(transfer.getAssetHash(), is(\"0x\" + NEO_HASH));\n        assertThat(transfer.getTransferAddress(), is(TX_RECIPIENT_1));\n        assertThat(transfer.getAmount(), is(TX_AMOUNT_NEO));\n        assertThat(transfer.getBlockIndex(), is(2L));\n        assertThat(transfer.getTransferNotifyIndex(), is(1L));\n\n        assertNotNull(nep17TransferWrapper.getReceived());", "refactored_code": "    private static final long TX_BLOCK_IDX = 2L;\n        assertThat(transfer.getAssetHash(), is(\"0x\" + NEO_HASH));\n        assertThat(transfer.getTransferAddress(), is(TX_RECIPIENT_1));\n        assertThat(transfer.getAmount(), is(TX_AMOUNT_NEO));\n        assertThat(transfer.getBlockIndex(), is(TX_BLOCK_IDX));\n        assertThat(transfer.getTransferNotifyIndex(), is(1L));\n\n        assertNotNull(nep17TransferWrapper.getReceived());"}
{"magic_number_smell": "        output.write(MAGIC_NUMBER);\n\n        // Actually copy the file\n        final byte[] buffer = new byte[1024];\n        for (int readBytes = input.read(buffer); readBytes >= 0; readBytes = input.read(buffer))\n            output.write(buffer, 0, readBytes);\n        input.close();", "refactored_code": "    private static final int FILE_READ_BUFFER_SIZE = 1024;\n        output.write(MAGIC_NUMBER);\n\n        // Actually copy the file\n        final byte[] buffer = new byte[FILE_READ_BUFFER_SIZE];\n        for (int readBytes = input.read(buffer); readBytes >= 0; readBytes = input.read(buffer))\n            output.write(buffer, 0, readBytes);\n        input.close();"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "\t\tif ( index >= 0 && index < allocatedSize )\n\t\t{\n\t\t\tupdateAccess( dataAccess, index );\n\t\t\tfinal boolean isFree = dataAccess.getInt( 0 ) == -2;\n\t\t\tif ( ! isFree )\n\t\t\t{\n\t\t\t\tdataAccess.putIndex( -2, 0 );", "refactored_code": "\tpublic static final int FREE_ELEMENT_MAGIC_NUMBER = -2;\n\t\tif ( index >= 0 && index < allocatedSize )\n\t\t{\n\t\t\tupdateAccess( dataAccess, index );\n\t\t\tfinal boolean isFree = dataAccess.getInt( 0 ) == FREE_ELEMENT_MAGIC_NUMBER;\n\t\t\tif ( ! isFree )\n\t\t\t{\n\t\t\t\tdataAccess.putIndex( FREE_ELEMENT_MAGIC_NUMBER, 0 );"}
{"magic_number_smell": "            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > 50 ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;", "refactored_code": "    private static final int INET_CONDITION_THRESHOLD = 50;\n            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;"}
{"magic_number_smell": "//         ThreadTools.scheduleSingleExecution(\"SafetyStop\", guiRecorder::stop, 1200.0);\n      }\n\n      primary3DPanel = new RDX3DPanel(VIEW_3D_WINDOW_NAME, 2, true);\n      primary3DPanel.setBackgroundShade((float) view3DBackgroundShade.get());\n   }\n", "refactored_code": "   public static final int ANTI_ALIASING = 2;\n//         ThreadTools.scheduleSingleExecution(\"SafetyStop\", guiRecorder::stop, 1200.0);\n      }\n\n      primary3DPanel = new RDX3DPanel(VIEW_3D_WINDOW_NAME, ANTI_ALIASING, true);\n      primary3DPanel.setBackgroundShade((float) view3DBackgroundShade.get());\n   }\n"}
{"magic_number_smell": "        String version = \"\" + ((char) magic[4]) + ((char) magic[5]) +((char) magic[6]);\n\n        if (version.equals(VERSION_CURRENT)) {\n            return 14;\n        } else if (version.equals(VERSION_FOR_API_13)) {\n            return 13;\n        }", "refactored_code": "    public static final int API_CURRENT = 14;\n        String version = \"\" + ((char) magic[4]) + ((char) magic[5]) +((char) magic[6]);\n\n        if (version.equals(VERSION_CURRENT)) {\n            return API_CURRENT;\n        } else if (version.equals(VERSION_FOR_API_13)) {\n            return 13;\n        }"}
{"magic_number_smell": "     * @return the updated path\n     */\n    public static String separatorsToUnix(final String path) {\n        if (path == null || path.indexOf(WINDOWS_SEPARATOR) == -1) {\n            return path;\n        }\n        return path.replace(WINDOWS_SEPARATOR, UNIX_SEPARATOR);", "refactored_code": "    private static final int NOT_FOUND = -1;\n     * @return the updated path\n     */\n    public static String separatorsToUnix(final String path) {\n        if (path == null || path.indexOf(WINDOWS_SEPARATOR) == NOT_FOUND) {\n            return path;\n        }\n        return path.replace(WINDOWS_SEPARATOR, UNIX_SEPARATOR);"}
{"magic_number_smell": "    }\n\n    private void removeOldFile() {\n        String oldPath = randomAccessFilePath(3 - 1);\n        File oldFile = new File(oldPath);\n        if (oldFile.exists()) {\n            try {", "refactored_code": "    private static final int MINI_THUMB_DATA_FILE_VERSION = 3;\n    }\n\n    private void removeOldFile() {\n        String oldPath = randomAccessFilePath(MINI_THUMB_DATA_FILE_VERSION - 1);\n        File oldFile = new File(oldPath);\n        if (oldFile.exists()) {\n            try {"}
{"magic_number_smell": "    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);"}
{"magic_number_smell": "  private final LruCache<ModelKey<A>, B> cache;\n\n  public ModelCache() {\n    this(250);\n  }\n\n  public ModelCache(int size) {", "refactored_code": "  private static final int DEFAULT_SIZE = 250;\n  private final LruCache<ModelKey<A>, B> cache;\n\n  public ModelCache() {\n    this(DEFAULT_SIZE);\n  }\n\n  public ModelCache(int size) {"}
{"magic_number_smell": "    if (x == 0 && y == 0 && w == 1 && h == 1) {\n      return buf;\n    }\n    else if (getSizeX() <= 8192 && getSizeY() <= 8192) {\n      int ifdIndex = getIFDIndex(getSeries(), no);\n      in = new RandomAccessInputStream(currentId);\n      tiffParser = new TiffParser(in);", "refactored_code": "  private static final int MAX_SIZE = 8192;\n    if (x == 0 && y == 0 && w == 1 && h == 1) {\n      return buf;\n    }\n    else if (getSizeX() <= MAX_SIZE && getSizeY() <= MAX_SIZE) {\n      int ifdIndex = getIFDIndex(getSeries(), no);\n      in = new RandomAccessInputStream(currentId);\n      tiffParser = new TiffParser(in);"}
{"magic_number_smell": "        plc.retryLimit(1);\n\n        try (var client = getClient(plc)) {\n            for (int i = 0; i < 100; i++) {\n                assertEquals(\"t\", client.tables().tables().get(0).name());\n            }\n", "refactored_code": "    private static final int ITER = 100;\n        plc.retryLimit(1);\n\n        try (var client = getClient(plc)) {\n            for (int i = 0; i < ITER; i++) {\n                assertEquals(\"t\", client.tables().tables().get(0).name());\n            }\n"}
{"magic_number_smell": "            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > 50 ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;", "refactored_code": "    private static final int INET_CONDITION_THRESHOLD = 50;\n            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "        StatisticsHandler statsHandler = new StatisticsHandler();\n        statsHandler.setHandler(handlers);\n        jettyServer.setHandler(statsHandler);\n        jettyServer.setStopTimeout(60 * 1000);\n        jettyServer.setStopAtShutdown(true);\n\n        try {", "refactored_code": "    private static final long GRACEFUL_SHUTDOWN_TIMEOUT_MS = 60 * 1000;\n        StatisticsHandler statsHandler = new StatisticsHandler();\n        statsHandler.setHandler(handlers);\n        jettyServer.setHandler(statsHandler);\n        jettyServer.setStopTimeout(GRACEFUL_SHUTDOWN_TIMEOUT_MS);\n        jettyServer.setStopAtShutdown(true);\n\n        try {"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    }\n\n    public HttpRequestExecutor() {\n        this(3000);\n    }\n\n    /**", "refactored_code": "    public static final int DEFAULT_WAIT_FOR_CONTINUE = 3000;\n    }\n\n    public HttpRequestExecutor() {\n        this(DEFAULT_WAIT_FOR_CONTINUE);\n    }\n\n    /**"}
{"magic_number_smell": "\n      public Controller(YoGraphicsListRegistry graphicsListRegistry)\n      {\n         for (int i = 0; i < 5; i++)\n         {\n            YoFramePoint3D yoPoint = new YoFramePoint3D(\"Position\" + i, ReferenceFrame.getWorldFrame(), registry);\n            YoGraphicPosition position = new YoGraphicPosition(\"Position\" + i, yoPoint, 0.02, YoAppearance.Blue());", "refactored_code": "      private static final int numberOfPoints = 5;\n\n      public Controller(YoGraphicsListRegistry graphicsListRegistry)\n      {\n         for (int i = 0; i < numberOfPoints; i++)\n         {\n            YoFramePoint3D yoPoint = new YoFramePoint3D(\"Position\" + i, ReferenceFrame.getWorldFrame(), registry);\n            YoGraphicPosition position = new YoGraphicPosition(\"Position\" + i, yoPoint, 0.02, YoAppearance.Blue());"}
{"magic_number_smell": "\n\t\t\tAdvancedFloatStatistics stats = AdvancedFloatStatistics.of(allDimsPerRecordArray);\n\t\t\t// throwing out all values with more than 80% NAN\n\t\t\tif (stats.getNaNs() < stats.getN() * 0.8) {\n\t\t\t\tallDimVar.add(new Pair<Float, Integer>(stats.getMedianAbsoluteDeviation(), dimID));\n\t\t\t}\n\t\t}", "refactored_code": "\tprivate static final double NAN_THRESHOLD = 0.8;\n\n\t\t\tAdvancedFloatStatistics stats = AdvancedFloatStatistics.of(allDimsPerRecordArray);\n\t\t\t// throwing out all values with more than 80% NAN\n\t\t\tif (stats.getNaNs() < stats.getN() * NAN_THRESHOLD) {\n\t\t\t\tallDimVar.add(new Pair<Float, Integer>(stats.getMedianAbsoluteDeviation(), dimID));\n\t\t\t}\n\t\t}"}
{"magic_number_smell": "     * @return true if the magic is valid\n     */\n    private boolean isGoodMagic(int magic) {\n        return magic == 0xcafebabe;\n    }\n\n    /**", "refactored_code": "    private static final int CLASS_FILE_MAGIC = 0xcafebabe;\n     * @return true if the magic is valid\n     */\n    private boolean isGoodMagic(int magic) {\n        return magic == CLASS_FILE_MAGIC;\n    }\n\n    /**"}
{"magic_number_smell": "        if (rv <= 0) {\n            // We have had an error. It can simply be that we have reached\n            // the timeout (very unlikely, as we have set it to MAX_INTEGER)\n            if (rv != -120001) {\n                // It's not a timeout being exceeded. Throw the error\n                throwException(rv);\n            }", "refactored_code": "    private static final int APR_TIMEUP_ERROR = -120001;\n        if (rv <= 0) {\n            // We have had an error. It can simply be that we have reached\n            // the timeout (very unlikely, as we have set it to MAX_INTEGER)\n            if (rv != APR_TIMEUP_ERROR) {\n                // It's not a timeout being exceeded. Throw the error\n                throwException(rv);\n            }"}
{"magic_number_smell": "\t{\n\t\tfor (int i = 0; i < 2048; ++i)\n\t\t{\n\t\t\tSINE[i] = (int) (65536.0D * Math.sin((double) i * Math.PI / 1024d));\n\t\t\tCOSINE[i] = (int) (65536.0D * Math.cos((double) i * Math.PI / 1024d));\n\t\t}\n\t}", "refactored_code": "\tprivate static final double UNIT = Math.PI / 1024d; // How much of the circle each unit of SINE/COSINE is\n\t{\n\t\tfor (int i = 0; i < 2048; ++i)\n\t\t{\n\t\t\tSINE[i] = (int) (65536.0D * Math.sin((double) i * UNIT));\n\t\t\tCOSINE[i] = (int) (65536.0D * Math.cos((double) i * UNIT));\n\t\t}\n\t}"}
{"magic_number_smell": "\n                // where\n                //     shipdate <= '1998-09-02'\n                if (shipDate <= DateTimeUtils.parseDate(\"1998-09-02\")) {\n                    //     returnflag,\n                    //     linestatus\n                    //     quantity", "refactored_code": "        private static final int MAX_SHIP_DATE = DateTimeUtils.parseDate(\"1998-09-02\");\n\n                // where\n                //     shipdate <= '1998-09-02'\n                if (shipDate <= MAX_SHIP_DATE) {\n                    //     returnflag,\n                    //     linestatus\n                    //     quantity"}
{"magic_number_smell": "\n  /**\n   * the amount of bytes that a stack pointer is allowed\n   * to differ from the stack limit beyond {@link #256}.\n   * <p>\n   * This was set based on the historic values so it's probably\n   * safe to change this if you have appropriate test cases.", "refactored_code": "  private static final int BIG_FRAME_MINIMUM_SIZE = 256;\n\n  /**\n   * the amount of bytes that a stack pointer is allowed\n   * to differ from the stack limit beyond {@link #BIG_FRAME_MINIMUM_SIZE}.\n   * <p>\n   * This was set based on the historic values so it's probably\n   * safe to change this if you have appropriate test cases."}
{"magic_number_smell": "   * @param location to be processed\n   */\n  private void queueLocationUpdateTask(Location location) {\n    thread.queueTask(1001, NewLocationModel.create(location, mapboxNavigation));\n  }\n\n  /**", "refactored_code": "  private static final int MSG_LOCATION_UPDATED = 1001;\n   * @param location to be processed\n   */\n  private void queueLocationUpdateTask(Location location) {\n    thread.queueTask(MSG_LOCATION_UPDATED, NewLocationModel.create(location, mapboxNavigation));\n  }\n\n  /**"}
{"magic_number_smell": "\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != 0x414E4554) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n", "refactored_code": "    private static final int FILE_MAGIC = 0x414E4554;\n\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != FILE_MAGIC) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n"}
{"magic_number_smell": "        output.write(MAGIC_NUMBER);\n\n        // Actually copy the file\n        final byte[] buffer = new byte[1024];\n        for (int readBytes = input.read(buffer); readBytes >= 0; readBytes = input.read(buffer))\n            output.write(buffer, 0, readBytes);\n        input.close();", "refactored_code": "    private static final int FILE_READ_BUFFER_SIZE = 1024;\n        output.write(MAGIC_NUMBER);\n\n        // Actually copy the file\n        final byte[] buffer = new byte[FILE_READ_BUFFER_SIZE];\n        for (int readBytes = input.read(buffer); readBytes >= 0; readBytes = input.read(buffer))\n            output.write(buffer, 0, readBytes);\n        input.close();"}
{"magic_number_smell": "            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + AlarmManager.INTERVAL_HOUR;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {", "refactored_code": "    private static final long BACKUP_INTERVAL = AlarmManager.INTERVAL_HOUR;\n            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + BACKUP_INTERVAL;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {"}
{"magic_number_smell": "\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != 0x414E4554) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n", "refactored_code": "    private static final int FILE_MAGIC = 0x414E4554;\n\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != FILE_MAGIC) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n"}
{"magic_number_smell": "\n            double range = upperLimit - lowerLimit;\n\n            if (range > 2.0 * Math.toRadians(5.0))\n            {\n               double safeLowerBound = lowerLimit + Math.toRadians(5.0);\n               double safeUpperBound = upperLimit - Math.toRadians(5.0);", "refactored_code": "   private final double HARDSTOP_RESTRICTION_ANGLE = Math.toRadians(5.0);\n\n            double range = upperLimit - lowerLimit;\n\n            if (range > 2.0 * HARDSTOP_RESTRICTION_ANGLE)\n            {\n               double safeLowerBound = lowerLimit + HARDSTOP_RESTRICTION_ANGLE;\n               double safeUpperBound = upperLimit - HARDSTOP_RESTRICTION_ANGLE;"}
{"magic_number_smell": "\n        int minor = stream.readUnsignedShort();\n        int major = stream.readUnsignedShort();\n        if (major < 51 || major > MAJOR_VERSION_JAVA9) {\n            throw new UnsupportedClassVersionError(\"Unsupported class file version: \" + major + \".\" + minor);\n        }\n", "refactored_code": "    private static final int MAJOR_VERSION_JAVA7 = 51;\n\n        int minor = stream.readUnsignedShort();\n        int major = stream.readUnsignedShort();\n        if (major < MAJOR_VERSION_JAVA7 || major > MAJOR_VERSION_JAVA9) {\n            throw new UnsupportedClassVersionError(\"Unsupported class file version: \" + major + \".\" + minor);\n        }\n"}
{"magic_number_smell": "\r\n\tpublic static void init(BlockFile bf, int page, int spanSize) throws IOException {\r\n\t\tBlockFile.pageSeek(bf.file, page);\r\n\t\tbf.file.writeInt(0x5370616e);\r\n\t\tbf.file.writeInt(0);\r\n\t\tbf.file.writeInt(0);\r\n\t\tbf.file.writeInt(0);\r", "refactored_code": "\tprotected static final int MAGIC = 0x5370616e;  // \"Span\"\r\n\r\n\tpublic static void init(BlockFile bf, int page, int spanSize) throws IOException {\r\n\t\tBlockFile.pageSeek(bf.file, page);\r\n\t\tbf.file.writeInt(MAGIC);\r\n\t\tbf.file.writeInt(0);\r\n\t\tbf.file.writeInt(0);\r\n\t\tbf.file.writeInt(0);\r"}
{"magic_number_smell": "                deltaProgressDown.addDelta(50, 55, -1);\n            }\n            if (progressDown >= 50) {\n                sendNetworkGuiUpdate(IDS.allocId(\"DOWN\"));\n                invDownOut.setStackInSlot(0, invDownIn.getStackInSlot(0));\n                invDownIn.setStackInSlot(0, StackUtil.EMPTY);\n                progressDown = -1;", "refactored_code": "    public static final int NET_DOWN = IDS.allocId(\"DOWN\");\n                deltaProgressDown.addDelta(50, 55, -1);\n            }\n            if (progressDown >= 50) {\n                sendNetworkGuiUpdate(NET_DOWN);\n                invDownOut.setStackInSlot(0, invDownIn.getStackInSlot(0));\n                invDownIn.setStackInSlot(0, StackUtil.EMPTY);\n                progressDown = -1;"}
{"magic_number_smell": "                else\n                    nUnchangedInterpolations = 0;\n\n                if (nUnchangedInterpolations >= 5 || bBasePrime.compareTo(bound2) > 0)\n                    return candidate;\n\n                previousBase = candidate;", "refactored_code": "    private static final int N_UNCHANGED_INTERPOLATIONS = 5;\n                else\n                    nUnchangedInterpolations = 0;\n\n                if (nUnchangedInterpolations >= N_UNCHANGED_INTERPOLATIONS || bBasePrime.compareTo(bound2) > 0)\n                    return candidate;\n\n                previousBase = candidate;"}
{"magic_number_smell": "        while (System.currentTimeMillis() - START_TIME < MAX_TIME_PER_CHOICE) {\r\n\t\t\tpruneScore = createPruneScore();\r\n\t\t\tprocessingLeft = 1;\r\n\t\t\tstartWorker(firstChoice,mainPhases,120,INITIAL_MAX_GAMES);\r\n\t\t\twaitUntilProcessed();\r\n            if (mainPhases >= MAX_MAIN_PHASES || \r\n                firstChoice.aiScore.getScore() > ArtificialScoringSystem.WIN_GAME_SCORE / 2) {\r", "refactored_code": "\tprivate static final int INITIAL_MAX_DEPTH=120;\r\n        while (System.currentTimeMillis() - START_TIME < MAX_TIME_PER_CHOICE) {\r\n\t\t\tpruneScore = createPruneScore();\r\n\t\t\tprocessingLeft = 1;\r\n\t\t\tstartWorker(firstChoice,mainPhases,INITIAL_MAX_DEPTH,INITIAL_MAX_GAMES);\r\n\t\t\twaitUntilProcessed();\r\n            if (mainPhases >= MAX_MAIN_PHASES || \r\n                firstChoice.aiScore.getScore() > ArtificialScoringSystem.WIN_GAME_SCORE / 2) {\r"}
{"magic_number_smell": "        mediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);\n        int rotation = activity.getWindowManager().getDefaultDisplay().getRotation();\n        switch (sensorOrientation) {\n            case 90:\n                mediaRecorder.setOrientationHint(DEFAULT_ORIENTATIONS.get(rotation));\n                break;\n            case SENSOR_ORIENTATION_INVERSE_DEGREES:", "refactored_code": "    private static final int SENSOR_ORIENTATION_DEFAULT_DEGREES = 90;\n        mediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);\n        int rotation = activity.getWindowManager().getDefaultDisplay().getRotation();\n        switch (sensorOrientation) {\n            case SENSOR_ORIENTATION_DEFAULT_DEGREES:\n                mediaRecorder.setOrientationHint(DEFAULT_ORIENTATIONS.get(rotation));\n                break;\n            case SENSOR_ORIENTATION_INVERSE_DEGREES:"}
{"magic_number_smell": "            Log.v(TAG, \"Will create table \" + creator.getTableName());\n            createStatements.put(creator.getTableName(), creator);\n            getWritableDatabase().needUpgrade(++dbVersion);\n            onUpgrade(getWritableDatabase(), 0, 99);\n        }\n    }\n", "refactored_code": "    private static final int ALWAYS_UPGRADE = 99;\n            Log.v(TAG, \"Will create table \" + creator.getTableName());\n            createStatements.put(creator.getTableName(), creator);\n            getWritableDatabase().needUpgrade(++dbVersion);\n            onUpgrade(getWritableDatabase(), 0, ALWAYS_UPGRADE);\n        }\n    }\n"}
{"magic_number_smell": "      float posY = ImGui.getWindowPosY() + ImGuiTools.TAB_BAR_HEIGHT;\n      sizeX = ImGui.getWindowSizeX();\n      sizeY = ImGui.getWindowSizeY() - ImGuiTools.TAB_BAR_HEIGHT;\n      float renderSizeX = sizeX * 2;\n      float renderSizeY = sizeY * 2;\n\n      inputCalculator.compute();", "refactored_code": "   public static final int ANTI_ALIASING = 2;\n      float posY = ImGui.getWindowPosY() + ImGuiTools.TAB_BAR_HEIGHT;\n      sizeX = ImGui.getWindowSizeX();\n      sizeY = ImGui.getWindowSizeY() - ImGuiTools.TAB_BAR_HEIGHT;\n      float renderSizeX = sizeX * ANTI_ALIASING;\n      float renderSizeY = sizeY * ANTI_ALIASING;\n\n      inputCalculator.compute();"}
{"magic_number_smell": "        case PRIMITIVE_LONG:\n        case PRIMITIVE_SHORT:\n        case PRIMITIVE_BOOLEAN:\n        case 's':\n            return new SimpleElementValue(type, input.readUnsignedShort(), cpool);\n\n        case ENUM_CONSTANT:", "refactored_code": "    public static final byte STRING = 's';\n        case PRIMITIVE_LONG:\n        case PRIMITIVE_SHORT:\n        case PRIMITIVE_BOOLEAN:\n        case STRING:\n            return new SimpleElementValue(type, input.readUnsignedShort(), cpool);\n\n        case ENUM_CONSTANT:"}
{"magic_number_smell": "            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > 50 ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;", "refactored_code": "    private static final int INET_CONDITION_THRESHOLD = 50;\n            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;"}
{"magic_number_smell": "    @Test\n    public void testAutoEmbeddedTimer() throws OrekitException {\n    \tdateDetector = new DateDetector(maxCheck, threshold, iniDate.shiftedBy(-dt)) {\n            private static final long 3583432139818469589L = 1L;\n\t\t\tpublic int eventOccurred(SpacecraftState s, boolean increasing) throws OrekitException {\n\t\t\t\tAbsoluteDate nextDate = s.getDate().shiftedBy(-dt);\n\t\t\t\tthis.addEventDate(nextDate);", "refactored_code": "\t\t\tprivate static final long serialVersionUID = 3583432139818469589L;\n    @Test\n    public void testAutoEmbeddedTimer() throws OrekitException {\n    \tdateDetector = new DateDetector(maxCheck, threshold, iniDate.shiftedBy(-dt)) {\n            private static final long serialVersionUID = 1L;\n\t\t\tpublic int eventOccurred(SpacecraftState s, boolean increasing) throws OrekitException {\n\t\t\t\tAbsoluteDate nextDate = s.getDate().shiftedBy(-dt);\n\t\t\t\tthis.addEventDate(nextDate);"}
{"magic_number_smell": "                }\n                if (hasLine) {\n                    // hex string\n                    int dataSize = lineStr.length() == 0 ? 0 : Integer.parseInt(lineStr, 16);\n                    if (dataSize == 0) {\n                        return true;\n                    }", "refactored_code": "    private static final int RADIX = 16;\n                }\n                if (hasLine) {\n                    // hex string\n                    int dataSize = lineStr.length() == 0 ? 0 : Integer.parseInt(lineStr, RADIX);\n                    if (dataSize == 0) {\n                        return true;\n                    }"}
{"magic_number_smell": "  private boolean shouldIncreaseIndex;\n\n  NavigationRouteProcessor() {\n    indices = NavigationIndices.create(0, FIRST_STEP_INDEX);\n  }\n\n  @Override", "refactored_code": "  private static final int FIRST_LEG_INDEX = 0;\n  private boolean shouldIncreaseIndex;\n\n  NavigationRouteProcessor() {\n    indices = NavigationIndices.create(FIRST_LEG_INDEX, FIRST_STEP_INDEX);\n  }\n\n  @Override"}
{"magic_number_smell": "\n\t\tCollection<TopicPartition> tps;\n\t\tif (partitions == null || partitions.length == 0) {\n\t\t\tMap<String, List<PartitionInfo>> parts = consumer.listTopics(Duration.ofSeconds(10));\n\t\t\ttps = parts.entrySet()\n\t\t\t\t\t.stream()\n\t\t\t\t\t.filter(entry -> entry.getKey().equals(topic))", "refactored_code": "\tprivate static final int TEN = 10;\n\n\t\tCollection<TopicPartition> tps;\n\t\tif (partitions == null || partitions.length == 0) {\n\t\t\tMap<String, List<PartitionInfo>> parts = consumer.listTopics(Duration.ofSeconds(TEN));\n\t\t\ttps = parts.entrySet()\n\t\t\t\t\t.stream()\n\t\t\t\t\t.filter(entry -> entry.getKey().equals(topic))"}
{"magic_number_smell": "    public static final long fnv1a_64_magic_prime = 0x100000001b3L;\n\n    public static long fnv1a_64_extract(String key){\n        long hashCode = 0xcbf29ce484222325L;\n        for(int i = 0; i < key.length(); ++i){\n            char ch = key.charAt(i);\n            if(ch == '_' || ch == '-'){", "refactored_code": "    public static final long fnv1a_64_magic_hashcode = 0xcbf29ce484222325L;\n    public static final long fnv1a_64_magic_prime = 0x100000001b3L;\n\n    public static long fnv1a_64_extract(String key){\n        long hashCode = fnv1a_64_magic_hashcode;\n        for(int i = 0; i < key.length(); ++i){\n            char ch = key.charAt(i);\n            if(ch == '_' || ch == '-'){"}
{"magic_number_smell": "    public void test1()\n    {\n        Calendar cal = Calendar.getInstance();\n        cal.set(2011, 0, 7, i12, i30);\n        Date start = cal.getTime();\n\n        cal.set(2011, 0, i14);", "refactored_code": "    private final int i2011 = 2011;\n    public void test1()\n    {\n        Calendar cal = Calendar.getInstance();\n        cal.set(i2011, 0, 7, i12, i30);\n        Date start = cal.getTime();\n\n        cal.set(i2011, 0, i14);"}
{"magic_number_smell": "    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);"}
{"magic_number_smell": "\n\t\t\tCheckResult checkResult;\n\t\t\ttry {\n\t\t\t\tbufferedStream.mark(5 * 1024 * 1024);\n\t\t\t\tcheckResult = provider.checkStream(name, new ProtectedStream(bufferedStream));\n\t\t\t}\n\t\t\tfinally {", "refactored_code": "\tprivate static final int\t\t\t\t\t\t\t\t\tREAD_AHEAD_MAX\t\t\t\t\t= 5 * 1024 * 1024;\n\n\t\t\tCheckResult checkResult;\n\t\t\ttry {\n\t\t\t\tbufferedStream.mark(READ_AHEAD_MAX);\n\t\t\t\tcheckResult = provider.checkStream(name, new ProtectedStream(bufferedStream));\n\t\t\t}\n\t\t\tfinally {"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "        if (getCollection().add(item)) {\n            return item.getItemId();\n        }\n        return -1;\n    }\n\n    public void addBackup(long itemId, Data value) {", "refactored_code": "    public static final int INVALID_ITEM_ID = -1;\n        if (getCollection().add(item)) {\n            return item.getItemId();\n        }\n        return INVALID_ITEM_ID;\n    }\n\n    public void addBackup(long itemId, Data value) {"}
{"magic_number_smell": "\tthrows DatabaseException\n    {\n\tlong timeout = 1000L * PropertiesUtil.getLongProperty(\n\t    properties, TXN_TIMEOUT_PROPERTY, 1000);\n\tboolean flushToDisk = PropertiesUtil.getBooleanProperty(\n\t    properties, FLUSH_TO_DISK_PROPERTY, false);\n        EnvironmentConfig config = new EnvironmentConfig();", "refactored_code": "    private static final long DEFAULT_TXN_TIMEOUT = 1000;\n\tthrows DatabaseException\n    {\n\tlong timeout = 1000L * PropertiesUtil.getLongProperty(\n\t    properties, TXN_TIMEOUT_PROPERTY, DEFAULT_TXN_TIMEOUT);\n\tboolean flushToDisk = PropertiesUtil.getBooleanProperty(\n\t    properties, FLUSH_TO_DISK_PROPERTY, false);\n        EnvironmentConfig config = new EnvironmentConfig();"}
{"magic_number_smell": "\t\t\t\t\t\tAutomaticIndexingSynchronizationStrategyNames.READ_SYNC )\n\t\t\t\t.setup( Book.class );\n\n\t\tprepareBooks( entityManagerFactory, 8 );\n\t}\n\n\t@Test", "refactored_code": "\tprivate static final int NUMBER_OF_BOOKS = 8;\n\t\t\t\t\t\tAutomaticIndexingSynchronizationStrategyNames.READ_SYNC )\n\t\t\t\t.setup( Book.class );\n\n\t\tprepareBooks( entityManagerFactory, NUMBER_OF_BOOKS );\n\t}\n\n\t@Test"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "\t\t\n    \t//update Window menu\n    \tint nItems = window.getItemCount();\n    \tint start = 6 + windowMenuItems2;\n    \tint index = start + WindowManager.getCurrentIndex();\n    \ttry {  // workaround for Linux/Java 5.0/bug\n\t\t\tfor (int i=start; i<nItems; i++) {", "refactored_code": "\tpublic static final int WINDOW_MENU_ITEMS = 6; // fixed items at top of Window menu\n\t\t\n    \t//update Window menu\n    \tint nItems = window.getItemCount();\n    \tint start = WINDOW_MENU_ITEMS + windowMenuItems2;\n    \tint index = start + WindowManager.getCurrentIndex();\n    \ttry {  // workaround for Linux/Java 5.0/bug\n\t\t\tfor (int i=start; i<nItems; i++) {"}
{"magic_number_smell": "\tprivate long mouseDownTime;\n\tprivate Graphics g;\n\tprivate static Toolbar instance;\n\tprivate int mpPrevious = 0;\n\tprivate String[] names = new String[MAX_TOOLS];\n\tprivate String[] icons = new String[MAX_TOOLS];\n\tprivate PlugInTool[] tools = new PlugInTool[MAX_TOOLS];", "refactored_code": "\tpublic static final int RECTANGLE = 0;\n\tprivate long mouseDownTime;\n\tprivate Graphics g;\n\tprivate static Toolbar instance;\n\tprivate int mpPrevious = RECTANGLE;\n\tprivate String[] names = new String[MAX_TOOLS];\n\tprivate String[] icons = new String[MAX_TOOLS];\n\tprivate PlugInTool[] tools = new PlugInTool[MAX_TOOLS];"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "\n    public boolean equals(Object object) {\n\treturn object instanceof DummyManagedObject &&\n\t    nextId.getAndIncrement() == ((DummyManagedObject) object).nextId.getAndIncrement();\n    }\n\n    public int hashCode() {", "refactored_code": "    private final int id = nextId.getAndIncrement();\n\n    public boolean equals(Object object) {\n\treturn object instanceof DummyManagedObject &&\n\t    id == ((DummyManagedObject) object).id;\n    }\n\n    public int hashCode() {"}
{"magic_number_smell": "    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);"}
{"magic_number_smell": "    zkClient = new ZkClient(zkServer.connectString(), 30000, 30000, ZKStringSerializer$.MODULE$);\n    // setup Broker\n    port = TestUtils.choosePort();\n    Properties props = TestUtils.createBrokerConfig(0, port);\n    kafkaServer = TestUtils.createServer(new KafkaConfig(props), new MockTime());\n    // create topic\n    AdminUtils.createTopic(zkClient, TOPIC1, PARTITIONS, REPLICATION_FACTOR, new Properties());", "refactored_code": "  private static final int BROKER_ID = 0;\n    zkClient = new ZkClient(zkServer.connectString(), 30000, 30000, ZKStringSerializer$.MODULE$);\n    // setup Broker\n    port = TestUtils.choosePort();\n    Properties props = TestUtils.createBrokerConfig(BROKER_ID, port);\n    kafkaServer = TestUtils.createServer(new KafkaConfig(props), new MockTime());\n    // create topic\n    AdminUtils.createTopic(zkClient, TOPIC1, PARTITIONS, REPLICATION_FACTOR, new Properties());"}
{"magic_number_smell": "    {\n        int format = 0;\n\n        byte[] magic = new byte[8];\n\n        // If this is not an HDF5 file, then the magic number is at\n        // position 0; If it is an HDF5 file, then we need to search", "refactored_code": "    static private final int MAGIC_NUMBER_LEN = 8;\n    {\n        int format = 0;\n\n        byte[] magic = new byte[MAGIC_NUMBER_LEN];\n\n        // If this is not an HDF5 file, then the magic number is at\n        // position 0; If it is an HDF5 file, then we need to search"}
{"magic_number_smell": "     */\n    public static String shortenPath(File file) {\n        String path = removeCWD(file);\n        if (path.length() < 12 * 2) {\n            return path;\n        }\n        return path.substring(0, 12)", "refactored_code": "    private static final int SHORTENED_PATH_LENGTH = 12;\n     */\n    public static String shortenPath(File file) {\n        String path = removeCWD(file);\n        if (path.length() < SHORTENED_PATH_LENGTH * 2) {\n            return path;\n        }\n        return path.substring(0, SHORTENED_PATH_LENGTH)"}
{"magic_number_smell": "    private static final\n    @MonthInt\n    int MONTH = 10;\n    private static final Date ANY_DATE = Date.on(5, MONTH, 1990);\n\n    @Test\n    public void whenAddingADayOfMonth_thenIncreaseNormally() {", "refactored_code": "    private static final int DAY = 5;\n    private static final\n    @MonthInt\n    int MONTH = 10;\n    private static final Date ANY_DATE = Date.on(DAY, MONTH, 1990);\n\n    @Test\n    public void whenAddingADayOfMonth_thenIncreaseNormally() {"}
{"magic_number_smell": "    private int usedCount;\n    private final int[] indices = new int[256];\n    private transient Object[] varargs;\n    private transient Object[] params = new Object[10];\n    private transient Throwable throwable;\n\n    /**", "refactored_code": "    private static final int MAX_PARMS = 10;\n    private int usedCount;\n    private final int[] indices = new int[256];\n    private transient Object[] varargs;\n    private transient Object[] params = new Object[MAX_PARMS];\n    private transient Throwable throwable;\n\n    /**"}
{"magic_number_smell": "\tprivate String title;\n\tprivate\tString url;\n\tprivate FileInfo fileInfo;\n\tprivate int imageType = 0;\n\tprivate boolean typeSet;\n\tprivate ImageStack stack;\n\tprivate static int currentID = -1;", "refactored_code": "\tpublic static final int GRAY8 = 0;\n\tprivate String title;\n\tprivate\tString url;\n\tprivate FileInfo fileInfo;\n\tprivate int imageType = GRAY8;\n\tprivate boolean typeSet;\n\tprivate ImageStack stack;\n\tprivate static int currentID = -1;"}
{"magic_number_smell": "     */\n    @Override\n    public int hashCode() {\n        int hash = 3;\n        hash = MAGIC_HASH_MULTIPLIER * hash + ObjectUtils.hashCode(StringUtils.lowerCase(this.name));\n        hash = MAGIC_HASH_MULTIPLIER * hash + ObjectUtils.hashCode(StringUtils.lowerCase(this.source));\n        hash = MAGIC_HASH_MULTIPLIER * hash + ObjectUtils.hashCode(StringUtils.lowerCase(this.value));", "refactored_code": "    private static final int MAGIC_HASH_INIT_VALUE = 3;\n     */\n    @Override\n    public int hashCode() {\n        int hash = MAGIC_HASH_INIT_VALUE;\n        hash = MAGIC_HASH_MULTIPLIER * hash + ObjectUtils.hashCode(StringUtils.lowerCase(this.name));\n        hash = MAGIC_HASH_MULTIPLIER * hash + ObjectUtils.hashCode(StringUtils.lowerCase(this.source));\n        hash = MAGIC_HASH_MULTIPLIER * hash + ObjectUtils.hashCode(StringUtils.lowerCase(this.value));"}
{"magic_number_smell": "        this.pageSize = pageSize;\n        this.allocator = allocator;\n        dlEncoder = column.getMaxDefinitionLevel() == 0 ? null : new RunLengthBitPackingHybridEncoder(\n                getWidthFromMaxInt(column.getMaxDefinitionLevel()), 64, pageSize, allocator);\n        rlEncoder = column.getMaxRepetitionLevel() == 0 ? null : new RunLengthBitPackingHybridEncoder(\n                getWidthFromMaxInt(column.getMaxRepetitionLevel()), 64, pageSize, allocator);\n        this.owner = owner;", "refactored_code": "    private static final int MIN_SLAB_SIZE = 64;\n        this.pageSize = pageSize;\n        this.allocator = allocator;\n        dlEncoder = column.getMaxDefinitionLevel() == 0 ? null : new RunLengthBitPackingHybridEncoder(\n                getWidthFromMaxInt(column.getMaxDefinitionLevel()), MIN_SLAB_SIZE, pageSize, allocator);\n        rlEncoder = column.getMaxRepetitionLevel() == 0 ? null : new RunLengthBitPackingHybridEncoder(\n                getWidthFromMaxInt(column.getMaxRepetitionLevel()), MIN_SLAB_SIZE, pageSize, allocator);\n        this.owner = owner;"}
{"magic_number_smell": "  }\n\n  public void appendOutput(String s) {\n    if (getSize() > 20) {\n      try { Thread.sleep(500); } catch (InterruptedException e) { }\n    }\n    if (getSize() > 20) {", "refactored_code": "  private static final int OUTPUT_QUEUE_SIZE = 20;\n  }\n\n  public void appendOutput(String s) {\n    if (getSize() > OUTPUT_QUEUE_SIZE) {\n      try { Thread.sleep(500); } catch (InterruptedException e) { }\n    }\n    if (getSize() > OUTPUT_QUEUE_SIZE) {"}
{"magic_number_smell": "  /** Returns the name of the given codec. */\n  public static String getCodecName(int codec) {\n    switch (codec) {\n      case 1:\n        return \"Uncompressed\";\n      case CCITT_1D:\n        return \"CCITT Group 3 1-Dimensional Modified Huffman\";", "refactored_code": "  public static final int UNCOMPRESSED = 1;\n  /** Returns the name of the given codec. */\n  public static String getCodecName(int codec) {\n    switch (codec) {\n      case UNCOMPRESSED:\n        return \"Uncompressed\";\n      case CCITT_1D:\n        return \"CCITT Group 3 1-Dimensional Modified Huffman\";"}
{"magic_number_smell": "    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);"}
{"magic_number_smell": "\tprivate final long length;\n\n\tpublic ArArchiveEntry(String name, long length) {\n\t\tthis(name, length, 0, 0, 33188, System.currentTimeMillis());\n\t}\n\t\n\tpublic ArArchiveEntry(String name, long length, int userId, int groupId, int mode, long lastModified) {", "refactored_code": "    private static final int DEFAULT_MODE = 33188; // = (octal) 0100644 \n\tprivate final long length;\n\n\tpublic ArArchiveEntry(String name, long length) {\n\t\tthis(name, length, 0, 0, DEFAULT_MODE, System.currentTimeMillis());\n\t}\n\t\n\tpublic ArArchiveEntry(String name, long length, int userId, int groupId, int mode, long lastModified) {"}
{"magic_number_smell": "\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != 0x414E4554) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n", "refactored_code": "    private static final int FILE_MAGIC = 0x414E4554;\n\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != FILE_MAGIC) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n"}
{"magic_number_smell": "    private static final String TEMPORARY_DIRECTORY_STRING = System\n            .getProperty(PROPERTY_LOCAL_TEMPORARY_DIRECTORY);\n    private static final int 5 = 5;\n    private static final Retry RETRY = new Retry(5, Duration.ONE_SECOND)\n            .withQuadratic(true);\n\n    private final String namespace;", "refactored_code": "    private static final int RETRY_NUMBER = 5;\n    private static final String TEMPORARY_DIRECTORY_STRING = System\n            .getProperty(PROPERTY_LOCAL_TEMPORARY_DIRECTORY);\n    private static final int RETRY_NUMBER = 5;\n    private static final Retry RETRY = new Retry(RETRY_NUMBER, Duration.ONE_SECOND)\n            .withQuadratic(true);\n\n    private final String namespace;"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);"}
{"magic_number_smell": "  @NotNull\n  private Set<VirtualFile> scanForRootsInsideDir(@NotNull final VirtualFile dir, final int depth) {\n    final Set<VirtualFile> roots = new HashSet<VirtualFile>();\n    if (depth > 2) {\n      // performance optimization via limitation: don't scan deep though the whole VFS, 2 levels under a content root is enough\n      return roots;\n    }", "refactored_code": "  private static final int MAXIMUM_SCAN_DEPTH = 2;\n  @NotNull\n  private Set<VirtualFile> scanForRootsInsideDir(@NotNull final VirtualFile dir, final int depth) {\n    final Set<VirtualFile> roots = new HashSet<VirtualFile>();\n    if (depth > MAXIMUM_SCAN_DEPTH) {\n      // performance optimization via limitation: don't scan deep though the whole VFS, 2 levels under a content root is enough\n      return roots;\n    }"}
{"magic_number_smell": "        }\n\n        long getDefaultDisplayDelayTimeout() {\n            return 10000;\n        }\n    }\n", "refactored_code": "    private static final long WAIT_FOR_DEFAULT_DISPLAY_TIMEOUT = 10000;\n        }\n\n        long getDefaultDisplayDelayTimeout() {\n            return WAIT_FOR_DEFAULT_DISPLAY_TIMEOUT;\n        }\n    }\n"}
{"magic_number_smell": "\t */\n\tpublic static synchronized ContentKeys generateRandomKeys() throws NoSuchAlgorithmException, NoSuchPaddingException {\n\t\tbyte [] key = new byte[DEFAULT_KEY_LENGTH];\n\t\tbyte [] iv = new byte[8];\n\t\t// do we want additional whitening?\n\t\tSecureRandom random = ContentKeys.getRandom();\n\t\trandom.nextBytes(key);", "refactored_code": "\tpublic static final int IV_MASTER_LENGTH = 8; // bytes\n\t */\n\tpublic static synchronized ContentKeys generateRandomKeys() throws NoSuchAlgorithmException, NoSuchPaddingException {\n\t\tbyte [] key = new byte[DEFAULT_KEY_LENGTH];\n\t\tbyte [] iv = new byte[IV_MASTER_LENGTH];\n\t\t// do we want additional whitening?\n\t\tSecureRandom random = ContentKeys.getRandom();\n\t\trandom.nextBytes(key);"}
{"magic_number_smell": "    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);"}
{"magic_number_smell": "        LOGGER.info(\"Collection \" + collectionName + \" is stored in partition \" + partitionId);\n\n        // scale up\n        LOGGER.info(\"Scaling up to \" + (4 + 1) + \" members...\");\n        for (int backupCount = 1; backupCount <= 4; backupCount++) {\n            factory.newHazelcastInstance(config);\n            waitAllForSafeState(factory.getAllHazelcastInstances());", "refactored_code": "    protected static final int BACKUP_COUNT = 4;\n        LOGGER.info(\"Collection \" + collectionName + \" is stored in partition \" + partitionId);\n\n        // scale up\n        LOGGER.info(\"Scaling up to \" + (BACKUP_COUNT + 1) + \" members...\");\n        for (int backupCount = 1; backupCount <= BACKUP_COUNT; backupCount++) {\n            factory.newHazelcastInstance(config);\n            waitAllForSafeState(factory.getAllHazelcastInstances());"}
{"magic_number_smell": "\n    private void serializeFooter(final ParquetMetadata footer, final OutputStream os) throws IOException {\n        final long footerIndex = writeChannel.position();\n        org.apache.parquet.format.FileMetaData parquetMetadata = metadataConverter.toParquetMetadata(1, footer);\n        writeFileMetaData(parquetMetadata, os);\n        BytesUtils.writeIntLittleEndian(os, (int) (writeChannel.position() - footerIndex));\n        os.write(ParquetFileReader.MAGIC);", "refactored_code": "    private static final int VERSION = 1;\n\n    private void serializeFooter(final ParquetMetadata footer, final OutputStream os) throws IOException {\n        final long footerIndex = writeChannel.position();\n        org.apache.parquet.format.FileMetaData parquetMetadata = metadataConverter.toParquetMetadata(VERSION, footer);\n        writeFileMetaData(parquetMetadata, os);\n        BytesUtils.writeIntLittleEndian(os, (int) (writeChannel.position() - footerIndex));\n        os.write(ParquetFileReader.MAGIC);"}
{"magic_number_smell": "   //   private final double maximumHeightAboveGround = 0.925;\n\n   //   // USE THESE FOR VRC Atlas Model TASK 2 UNTIL WALKING WORKS BETTER WITH OTHERS.\n   //   private double 0.785 = 0.68;\n   //   private double nominalHeightAboveGround = 0.76;\n   //   private double maximumHeightAboveGround = 0.82;\n", "refactored_code": "   //   private final double minimumHeightAboveGround = 0.785;\n   //   private final double maximumHeightAboveGround = 0.925;\n\n   //   // USE THESE FOR VRC Atlas Model TASK 2 UNTIL WALKING WORKS BETTER WITH OTHERS.\n   //   private double minimumHeightAboveGround = 0.68;\n   //   private double nominalHeightAboveGround = 0.76;\n   //   private double maximumHeightAboveGround = 0.82;\n"}
{"magic_number_smell": "  @Override\n  public void prepareForTransitWith() {\n    this.onTripIndex = UNBOUNDED_TRIP_INDEX;\n    this.onTripBoardTime = -1;\n    this.onTripBoardStop = -1;\n    this.onTrip = null;\n    this.onTripTimeShift = -1;", "refactored_code": "  private static final int NOT_SET = -1;\n  @Override\n  public void prepareForTransitWith() {\n    this.onTripIndex = UNBOUNDED_TRIP_INDEX;\n    this.onTripBoardTime = NOT_SET;\n    this.onTripBoardStop = NOT_SET;\n    this.onTrip = null;\n    this.onTripTimeShift = NOT_SET;"}
{"magic_number_smell": "\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != 0x414E4554) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n", "refactored_code": "    private static final int FILE_MAGIC = 0x414E4554;\n\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != FILE_MAGIC) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n"}
{"magic_number_smell": "    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);"}
{"magic_number_smell": "    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);"}
{"magic_number_smell": "\n  /**\n   * the amount of bytes that a stack pointer is allowed\n   * to differ from the stack limit beyond {@link #256}.\n   * <p>\n   * This was set based on the historic values so it's probably\n   * safe to change this if you have appropriate test cases.", "refactored_code": "  private static final int BIG_FRAME_MINIMUM_SIZE = 256;\n\n  /**\n   * the amount of bytes that a stack pointer is allowed\n   * to differ from the stack limit beyond {@link #BIG_FRAME_MINIMUM_SIZE}.\n   * <p>\n   * This was set based on the historic values so it's probably\n   * safe to change this if you have appropriate test cases."}
{"magic_number_smell": "            if (currentStudent.section.equals(previousStudent.section)) {\n                studentsCount++;\n            } else {\n                if (studentsCount > 100) {\n                    invalidSectionList.add(previousStudent.section);\n                }\n                studentsCount = 1;", "refactored_code": "    private static final int SECTION_SIZE_LIMIT = 100;\n            if (currentStudent.section.equals(previousStudent.section)) {\n                studentsCount++;\n            } else {\n                if (studentsCount > SECTION_SIZE_LIMIT) {\n                    invalidSectionList.add(previousStudent.section);\n                }\n                studentsCount = 1;"}
{"magic_number_smell": "\n        batchCount++;\n\n        if (batchCount >= 1000) {\n          pipeline.exec();\n          pipeline.multi();\n          batchCount = 0;", "refactored_code": "      private static final int DEFAULT_BATCH_SIZE = 1000;\n\n        batchCount++;\n\n        if (batchCount >= DEFAULT_BATCH_SIZE) {\n          pipeline.exec();\n          pipeline.multi();\n          batchCount = 0;"}
{"magic_number_smell": "    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);"}
{"magic_number_smell": "                }\n                if (hasLine) {\n                    // hex string\n                    int dataSize = lineStr.length() == 0 ? 0 : Integer.parseInt(lineStr, 16);\n                    if (dataSize == 0) {\n                        return true;\n                    }", "refactored_code": "    private static final int RADIX = 16;\n                }\n                if (hasLine) {\n                    // hex string\n                    int dataSize = lineStr.length() == 0 ? 0 : Integer.parseInt(lineStr, RADIX);\n                    if (dataSize == 0) {\n                        return true;\n                    }"}
{"magic_number_smell": "\r\n\tpublic static void init(BlockFile bf, int page, int spanSize) throws IOException {\r\n\t\tBlockFile.pageSeek(bf.file, page);\r\n\t\tbf.file.writeInt(0x5370616e);\r\n\t\tbf.file.writeInt(0);\r\n\t\tbf.file.writeInt(0);\r\n\t\tbf.file.writeInt(0);\r", "refactored_code": "\tprotected static final int MAGIC = 0x5370616e;  // \"Span\"\r\n\r\n\tpublic static void init(BlockFile bf, int page, int spanSize) throws IOException {\r\n\t\tBlockFile.pageSeek(bf.file, page);\r\n\t\tbf.file.writeInt(MAGIC);\r\n\t\tbf.file.writeInt(0);\r\n\t\tbf.file.writeInt(0);\r\n\t\tbf.file.writeInt(0);\r"}
{"magic_number_smell": "            return;\n        }\n        \n        this.isPanelsCollapsed = bundle.responses.size() > 500;\n        \n        switch (viewType) {\n            case RECIPIENT_GIVER_QUESTION:", "refactored_code": "    private static final int RESPONSE_LIMIT_FOR_COLLAPSING_PANEL = 500;\n            return;\n        }\n        \n        this.isPanelsCollapsed = bundle.responses.size() > RESPONSE_LIMIT_FOR_COLLAPSING_PANEL;\n        \n        switch (viewType) {\n            case RECIPIENT_GIVER_QUESTION:"}
{"magic_number_smell": "                    // this is a hex pair we need to convert back to a single byte.\n                    byte c1 = DECODING_TABLE[b1];\n                    byte c2 = DECODING_TABLE[b2];\n                    out.write((c1 << Byte.SIZE / 2) | c2);\n                    // 3 bytes in, one byte out\n                    bytesWritten++;\n                }", "refactored_code": "    private static final int UPPER_NIBBLE_SHIFT = Byte.SIZE / 2;\n                    // this is a hex pair we need to convert back to a single byte.\n                    byte c1 = DECODING_TABLE[b1];\n                    byte c2 = DECODING_TABLE[b2];\n                    out.write((c1 << UPPER_NIBBLE_SHIFT) | c2);\n                    // 3 bytes in, one byte out\n                    bytesWritten++;\n                }"}
{"magic_number_smell": "\tprivate static int size = 18;\n\tprivate Font font;\n\tprivate static boolean antialiasedText = true; // global flag used by text tool\n\tprivate static int globalJustification = 0, CENTER=1, RIGHT=2;\n\tprivate static Color defaultFillColor;\n\tprivate int justification = 0, CENTER=1, RIGHT=2;\n\tprivate double previousMag;", "refactored_code": "\tpublic static final int LEFT=0, CENTER=1, RIGHT=2;\n\tprivate static int size = 18;\n\tprivate Font font;\n\tprivate static boolean antialiasedText = true; // global flag used by text tool\n\tprivate static int globalJustification = LEFT;\n\tprivate static Color defaultFillColor;\n\tprivate int justification = LEFT;\n\tprivate double previousMag;"}
{"magic_number_smell": "        private static final int TRUE = 1;\n        private static final AtomicIntegerFieldUpdater<LastSendFutureWrapper> THROW_ONCE_UPDATER =\n                AtomicIntegerFieldUpdater.newUpdater(LastSendFutureWrapper.class, \"throwOnce\");\n        private volatile int throwOnce = 0;\n\n        private LastSendFutureWrapper(CompletableFuture<MessageId> lastSendFuture) {\n            this.lastSendFuture = lastSendFuture;", "refactored_code": "        private static final int FALSE = 0;\n        private static final int TRUE = 1;\n        private static final AtomicIntegerFieldUpdater<LastSendFutureWrapper> THROW_ONCE_UPDATER =\n                AtomicIntegerFieldUpdater.newUpdater(LastSendFutureWrapper.class, \"throwOnce\");\n        private volatile int throwOnce = FALSE;\n\n        private LastSendFutureWrapper(CompletableFuture<MessageId> lastSendFuture) {\n            this.lastSendFuture = lastSendFuture;"}
{"magic_number_smell": "\t\t\t\tPreparedStatement ps = cntx.prepareStatement(update + column);\r\n\t\t\t\tps.executeUpdate();\r\n\t\t\t} catch (SQLException ee) {\r\n\t\t\t\tif (ee.getErrorCode() != 1060)\r\n\t\t\t\t\tTownyMessaging.sendErrorMsg(\"Error updating table \" + tableType.tableName() + \":\" + ee.getMessage());\r\n\t\t\t}\r\n\t\t}\r", "refactored_code": "\tprivate static final int MYSQL_DUPLICATE_COLUMN_ERR = 1060;\r\n\t\t\t\tPreparedStatement ps = cntx.prepareStatement(update + column);\r\n\t\t\t\tps.executeUpdate();\r\n\t\t\t} catch (SQLException ee) {\r\n\t\t\t\tif (ee.getErrorCode() != MYSQL_DUPLICATE_COLUMN_ERR)\r\n\t\t\t\t\tTownyMessaging.sendErrorMsg(\"Error updating table \" + tableType.tableName() + \":\" + ee.getMessage());\r\n\t\t\t}\r\n\t\t}\r"}
{"magic_number_smell": "        if (response instanceof NormalResponse && op instanceof BackupAwareOperation) {\n            final NormalResponse resp = (NormalResponse) response;\n            if (resp.getBackupCount() > 0) {\n                waitForBackups(resp.getBackupCount(), 5, TimeUnit.SECONDS, resp);\n                return;\n            }\n        }", "refactored_code": "    public static final long TIMEOUT = 5;\n        if (response instanceof NormalResponse && op instanceof BackupAwareOperation) {\n            final NormalResponse resp = (NormalResponse) response;\n            if (resp.getBackupCount() > 0) {\n                waitForBackups(resp.getBackupCount(), TIMEOUT, TimeUnit.SECONDS, resp);\n                return;\n            }\n        }"}
{"magic_number_smell": "  public int maximize(Formula objective) {\n    int id = idGenerator.getFreshId();\n    objectiveMap = objectiveMap.putAndCopy(id, objectiveMap.size());\n    long objectiveId = msat_make_maximize(curEnv, getMsatTerm(objective), 0, 0);\n    msat_assert_objective(curEnv, objectiveId);\n    return id;\n  }", "refactored_code": "  private static final int ERROR_TERM = 0;\n  public int maximize(Formula objective) {\n    int id = idGenerator.getFreshId();\n    objectiveMap = objectiveMap.putAndCopy(id, objectiveMap.size());\n    long objectiveId = msat_make_maximize(curEnv, getMsatTerm(objective), ERROR_TERM, ERROR_TERM);\n    msat_assert_objective(curEnv, objectiveId);\n    return id;\n  }"}
{"magic_number_smell": "        }\n\n        long getDefaultDisplayDelayTimeout() {\n            return 10000;\n        }\n    }\n", "refactored_code": "    private static final long WAIT_FOR_DEFAULT_DISPLAY_TIMEOUT = 10000;\n        }\n\n        long getDefaultDisplayDelayTimeout() {\n            return WAIT_FOR_DEFAULT_DISPLAY_TIMEOUT;\n        }\n    }\n"}
{"magic_number_smell": "    List<String> lines = new ArrayList<>(fetch);\n    while (((System.currentTimeMillis() - start) < maxWaitTimeMillis) && (logLinesQueue.size() < fetch)) {\n      try {\n        Thread.sleep(100);\n      } catch (InterruptedException ex) {\n        break;\n      }", "refactored_code": "  private static final int SLEEP_TIME_WAITING_FOR_BATCH_SIZE_MS = 100;\n    List<String> lines = new ArrayList<>(fetch);\n    while (((System.currentTimeMillis() - start) < maxWaitTimeMillis) && (logLinesQueue.size() < fetch)) {\n      try {\n        Thread.sleep(SLEEP_TIME_WAITING_FOR_BATCH_SIZE_MS);\n      } catch (InterruptedException ex) {\n        break;\n      }"}
{"magic_number_smell": "\n    @Override\n    public void run() {\n        if (basePanel.getSelectedEntries().size() >= 10) {\n            String[] options = new String[]{Localization.lang(\"Look up full text documents\"), Localization.lang(\"Cancel\")};\n            int answer = JOptionPane.showOptionDialog(basePanel.frame(),\n                    Localization.lang(", "refactored_code": "    private static final int warningLimit = 10; // The minimum number of selected entries to ask the user for confirmation\n\n    @Override\n    public void run() {\n        if (basePanel.getSelectedEntries().size() >= warningLimit) {\n            String[] options = new String[]{Localization.lang(\"Look up full text documents\"), Localization.lang(\"Cancel\")};\n            int answer = JOptionPane.showOptionDialog(basePanel.frame(),\n                    Localization.lang("}
{"magic_number_smell": "                }\n\n                // Look at the uses of tiles surrounding the settlement.\n                int alarmRadius = settlement.getRadius() + 2;\n                int alarm = 0;\n                for (Tile tile: settlement.getTile()\n                         .getSurroundingTiles(alarmRadius)) {", "refactored_code": "    public static final int ALARM_RADIUS = 2;\n                }\n\n                // Look at the uses of tiles surrounding the settlement.\n                int alarmRadius = settlement.getRadius() + ALARM_RADIUS;\n                int alarm = 0;\n                for (Tile tile: settlement.getTile()\n                         .getSurroundingTiles(alarmRadius)) {"}
{"magic_number_smell": "            }\n\n            // Dump needs a bigger buffer to check the signature;\n            final byte[] dumpsig = new byte[32];\n            in.mark(dumpsig.length);\n            signatureLength = IOUtils.readFully(in, dumpsig);\n            in.reset();", "refactored_code": "    private static final int DUMP_SIGNATURE_SIZE = 32;\n            }\n\n            // Dump needs a bigger buffer to check the signature;\n            final byte[] dumpsig = new byte[DUMP_SIGNATURE_SIZE];\n            in.mark(dumpsig.length);\n            signatureLength = IOUtils.readFully(in, dumpsig);\n            in.reset();"}
{"magic_number_smell": "            }\n\n            // Tar needs an even bigger buffer to check the signature; read the first block\n            final byte[] tarheader = new byte[512];\n            in.mark(tarheader.length);\n            signatureLength = IOUtils.readFully(in, tarheader);\n            in.reset();", "refactored_code": "    private static final int TAR_HEADER_SIZE = 512;\n            }\n\n            // Tar needs an even bigger buffer to check the signature; read the first block\n            final byte[] tarheader = new byte[TAR_HEADER_SIZE];\n            in.mark(tarheader.length);\n            signatureLength = IOUtils.readFully(in, tarheader);\n            in.reset();"}
{"magic_number_smell": "\n  private final Action showGameAction =\n      new AbstractAction(\"Show current game\") {\n        private static final long 7640069668264418976L = -7551760679570164254L;\n\n        {\n          setEnabled(false);", "refactored_code": "  private static final long serialVersionUID = 7640069668264418976L;\n\n  private final Action showGameAction =\n      new AbstractAction(\"Show current game\") {\n        private static final long serialVersionUID = -7551760679570164254L;\n\n        {\n          setEnabled(false);"}
{"magic_number_smell": "\n                        // track and wait for the wire Component\n                        String filterString = \"(\" + ConfigurationService.KURA_SERVICE_PID + \"=\" + temporaryName + \")\";\n                        ServiceUtil.waitForService(filterString, 60, TimeUnit.SECONDS);\n\n                        conf = cs.getComponentConfiguration(temporaryName);\n                        comp = createMetatypeOnlyGwtComponentConfiguration(conf);", "refactored_code": "    private static final int SERVICE_WAIT_TIMEOUT = 60;\n\n                        // track and wait for the wire Component\n                        String filterString = \"(\" + ConfigurationService.KURA_SERVICE_PID + \"=\" + temporaryName + \")\";\n                        ServiceUtil.waitForService(filterString, SERVICE_WAIT_TIMEOUT, TimeUnit.SECONDS);\n\n                        conf = cs.getComponentConfiguration(temporaryName);\n                        comp = createMetatypeOnlyGwtComponentConfiguration(conf);"}
{"magic_number_smell": "                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**", "refactored_code": "    private static final int NOT_FOUND = -1;\n                return i;\n            }\n        }\n        return NOT_FOUND;\n    }\n\n    /**"}
{"magic_number_smell": "\n    private int getType(String tok) {\n        if (tok.startsWith(\"string\")) { //$NON-NLS-1$\n            return 1;\n        } else if (tok.startsWith(\"belong\")) { //$NON-NLS-1$\n            return BELONG_TYPE;\n        } else if (tok.equals(\"short\")) { //$NON-NLS-1$", "refactored_code": "    public static final int STRING_TYPE = 1;\n\n    private int getType(String tok) {\n        if (tok.startsWith(\"string\")) { //$NON-NLS-1$\n            return STRING_TYPE;\n        } else if (tok.startsWith(\"belong\")) { //$NON-NLS-1$\n            return BELONG_TYPE;\n        } else if (tok.equals(\"short\")) { //$NON-NLS-1$"}
{"magic_number_smell": "            boolean hashAggregation = operatorType.equalsIgnoreCase(\"hash\");\n\n            RowPagesBuilder pagesBuilder = RowPagesBuilder.rowPagesBuilder(hashAggregation, ImmutableList.of(0), VARCHAR, BIGINT);\n            for (int i = 0; i < 140; i++) {\n                BlockBuilder blockBuilder = VARCHAR.createBlockBuilder(null, ROWS_PER_PAGE);\n                for (int j = 0; j < groupsPerPage; j++) {\n                    String groupKey = format(\"%s\", i * groupsPerPage + j);", "refactored_code": "        public static final int TOTAL_PAGES = 140;\n            boolean hashAggregation = operatorType.equalsIgnoreCase(\"hash\");\n\n            RowPagesBuilder pagesBuilder = RowPagesBuilder.rowPagesBuilder(hashAggregation, ImmutableList.of(0), VARCHAR, BIGINT);\n            for (int i = 0; i < TOTAL_PAGES; i++) {\n                BlockBuilder blockBuilder = VARCHAR.createBlockBuilder(null, ROWS_PER_PAGE);\n                for (int j = 0; j < groupsPerPage; j++) {\n                    String groupKey = format(\"%s\", i * groupsPerPage + j);"}
{"magic_number_smell": "\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != 0x414E4554) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n", "refactored_code": "    private static final int FILE_MAGIC = 0x414E4554;\n\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != FILE_MAGIC) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n"}
{"magic_number_smell": "    private final TupleType inputTypes;\n    private final TupleType outputTypes;\n\n    private final byte[] selector = new byte[4];\n    private final String hashAlgorithm;\n\n    private final String stateMutability;", "refactored_code": "    public static final int SELECTOR_LEN = 4;\n    private final TupleType inputTypes;\n    private final TupleType outputTypes;\n\n    private final byte[] selector = new byte[SELECTOR_LEN];\n    private final String hashAlgorithm;\n\n    private final String stateMutability;"}
{"magic_number_smell": "                        } else {\n                            // Calculate the time we need to be idle before we\n                            // start checking thumbnail.\n                            long t = 1000000000 -\n                                    (System.nanoTime() - mLastWorkTime);\n                            t = t / 1000000;  // convert to milliseconds.\n                            if (t > 0) {", "refactored_code": "        private static final long IDLE_TIME = 1000000000;  // in nanoseconds.\n                        } else {\n                            // Calculate the time we need to be idle before we\n                            // start checking thumbnail.\n                            long t = IDLE_TIME -\n                                    (System.nanoTime() - mLastWorkTime);\n                            t = t / 1000000;  // convert to milliseconds.\n                            if (t > 0) {"}
{"magic_number_smell": "                DanmakuTimer timer, boolean fromCachingTask) {\n            boolean filtered = danmaku != null && mFilterTypes.contains(danmaku.getType());\n            if (filtered) {\n                danmaku.mFilterParam |= 0x00000001;\n            }\n        }\n", "refactored_code": "    public static final int FILTER_TYPE_TYPE = 0x00000001;\n                DanmakuTimer timer, boolean fromCachingTask) {\n            boolean filtered = danmaku != null && mFilterTypes.contains(danmaku.getType());\n            if (filtered) {\n                danmaku.mFilterParam |= FILTER_TYPE_TYPE;\n            }\n        }\n"}
{"magic_number_smell": "            final int len1 = bom1.length();\n            final int len2 = bom2.length();\n            if (len1 > len2) {\n                return -1;\n            }\n            if (len2 > len1) {\n                return 1;", "refactored_code": "    private static final int EOF = -1;\n            final int len1 = bom1.length();\n            final int len2 = bom2.length();\n            if (len1 > len2) {\n                return EOF;\n            }\n            if (len2 > len1) {\n                return 1;"}
{"magic_number_smell": "                return null;\n            }\n\n            if (currentNode.length() == 2) {\n                // Decode the key\n                byte[] k = unpackToNibbles(currentNode.get(0).asBytes());\n                Object v = currentNode.get(1).asObj();", "refactored_code": "    private static final byte PAIR_SIZE = 2;\n                return null;\n            }\n\n            if (currentNode.length() == PAIR_SIZE) {\n                // Decode the key\n                byte[] k = unpackToNibbles(currentNode.get(0).asBytes());\n                Object v = currentNode.get(1).asObj();"}
{"magic_number_smell": "     */\n    private void updateLeaderboards() {\n        // Only update FFS leaderboards every 10 minutes.. this puts a lot of strain on the server (depending on the size of the database) and should not be done frequently\n        if (System.currentTimeMillis() < lastUpdate + 600000L) {\n            return;\n        }\n", "refactored_code": "    private final long UPDATE_WAIT_TIME = 600000L; // 10 minutes\n     */\n    private void updateLeaderboards() {\n        // Only update FFS leaderboards every 10 minutes.. this puts a lot of strain on the server (depending on the size of the database) and should not be done frequently\n        if (System.currentTimeMillis() < lastUpdate + UPDATE_WAIT_TIME) {\n            return;\n        }\n"}
{"magic_number_smell": "     * Note that this method may change the value of top_prot or bottom_prot.\n     * @param prot The protocol to be inserted. Before insertion, a sanity check will ensure that none\n     *             of the existing protocols have the same name as the new protocol.\n     * @param position Where to place the protocol with respect to the neighbor_prot (1, BELOW)\n     * @param neighbor_prot The name of the neighbor protocol. An exception will be thrown if this name\n     *                      is not found\n     * @exception Exception Will be thrown when the new protocol cannot be created, or inserted.", "refactored_code": "    public static final int         ABOVE=1; // used by insertProtocol()\n     * Note that this method may change the value of top_prot or bottom_prot.\n     * @param prot The protocol to be inserted. Before insertion, a sanity check will ensure that none\n     *             of the existing protocols have the same name as the new protocol.\n     * @param position Where to place the protocol with respect to the neighbor_prot (ABOVE, BELOW)\n     * @param neighbor_prot The name of the neighbor protocol. An exception will be thrown if this name\n     *                      is not found\n     * @exception Exception Will be thrown when the new protocol cannot be created, or inserted."}
{"magic_number_smell": "    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);"}
{"magic_number_smell": "    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);"}
{"magic_number_smell": "    {\n        if (finished.get())\n        {\n            return -1;\n        }\n\n        final int ch = super.read();", "refactored_code": "    private static final int EOF_CHAR = -1;\n    {\n        if (finished.get())\n        {\n            return EOF_CHAR;\n        }\n\n        final int ch = super.read();"}
{"magic_number_smell": "            forceValidityCheck(removes);\n            removes.clear();\n            try {\n\t\tThread.sleep(3 * 1000);\n\t    } catch (InterruptedException ignore) {\n                LOG.error(\"InterruptedException!!!\", ignore);\n            }", "refactored_code": "    private static final int SLEEP_SECONDS = 3;\n            forceValidityCheck(removes);\n            removes.clear();\n            try {\n\t\tThread.sleep(SLEEP_SECONDS * 1000);\n\t    } catch (InterruptedException ignore) {\n                LOG.error(\"InterruptedException!!!\", ignore);\n            }"}
{"magic_number_smell": "        }\n        if (field.isAnnotationPresent(javax.validation.constraints.Future.class)) {\n            Calendar calendar = Calendar.getInstance();\n            calendar.add(Calendar.YEAR, 10);\n            object = new DateRangeRandomizer(new Date(), calendar.getTime()).getRandomValue();\n        }\n        if (field.isAnnotationPresent(javax.validation.constraints.Past.class)) {", "refactored_code": "    private static final int DEFAULT_DATE_RANGE = 10;\n        }\n        if (field.isAnnotationPresent(javax.validation.constraints.Future.class)) {\n            Calendar calendar = Calendar.getInstance();\n            calendar.add(Calendar.YEAR, DEFAULT_DATE_RANGE);\n            object = new DateRangeRandomizer(new Date(), calendar.getTime()).getRandomValue();\n        }\n        if (field.isAnnotationPresent(javax.validation.constraints.Past.class)) {"}
{"magic_number_smell": "    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);"}
{"magic_number_smell": "\t/* File format (TIFF, GIF_OR_JPG, BMP, etc.). Used by the File/Revert command */\n\tpublic int fileFormat;\n\t\n\t/* File type (0, GRAY_16_UNSIGNED, RGB, etc.) */\n\tpublic int fileType;\t\n\tpublic String fileName;\n\tpublic String directory;", "refactored_code": "\tpublic static final int GRAY8 = 0;\n\t/* File format (TIFF, GIF_OR_JPG, BMP, etc.). Used by the File/Revert command */\n\tpublic int fileFormat;\n\t\n\t/* File type (GRAY8, GRAY_16_UNSIGNED, RGB, etc.) */\n\tpublic int fileType;\t\n\tpublic String fileName;\n\tpublic String directory;"}
{"magic_number_smell": "        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+5*1000) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }", "refactored_code": "    private static final long MIN_TIME_BETWEEN_GCS = 5*1000;\n        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+MIN_TIME_BETWEEN_GCS) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }"}
{"magic_number_smell": "    @Summary(index = 0)\n    private int id;\n\n    @Column(name = \"UUID\", length = 36)\n    // db type is CHAR, this string will thus always be of this length\n    private String uuid;\n", "refactored_code": "    private static final int UUID_LENGTH = 36;\n    @Summary(index = 0)\n    private int id;\n\n    @Column(name = \"UUID\", length = UUID_LENGTH)\n    // db type is CHAR, this string will thus always be of this length\n    private String uuid;\n"}
{"magic_number_smell": "    final AtomicLong destroyedCount = new AtomicLong(0);\n    final AtomicLong destroyedByEvictorCount = new AtomicLong(0);\n    final AtomicLong destroyedByBorrowValidationCount = new AtomicLong(0);\n    private final StatsStore activeTimes = new StatsStore(100);\n    private final StatsStore idleTimes = new StatsStore(100);\n    private final StatsStore waitTimes = new StatsStore(100);\n    private final AtomicLong maxBorrowWaitTimeMillis = new AtomicLong(0L);", "refactored_code": "    public static final int MEAN_TIMING_STATS_CACHE_SIZE = 100;\n    final AtomicLong destroyedCount = new AtomicLong(0);\n    final AtomicLong destroyedByEvictorCount = new AtomicLong(0);\n    final AtomicLong destroyedByBorrowValidationCount = new AtomicLong(0);\n    private final StatsStore activeTimes = new StatsStore(MEAN_TIMING_STATS_CACHE_SIZE);\n    private final StatsStore idleTimes = new StatsStore(MEAN_TIMING_STATS_CACHE_SIZE);\n    private final StatsStore waitTimes = new StatsStore(MEAN_TIMING_STATS_CACHE_SIZE);\n    private final AtomicLong maxBorrowWaitTimeMillis = new AtomicLong(0L);"}
{"magic_number_smell": "    .withProfile(PROFILE)\n    .withOptimizations(OPTIMIZATIONS)\n    .withTimeLimit(TIME_LIMIT)\n    .withRelaxGeneralizedCostAtDestination(1.2)\n    .build();\n\n  @Test", "refactored_code": "  private static final double RELAX_GENERALIZED_COST_AT_DESTINATION = 1.2;\n    .withProfile(PROFILE)\n    .withOptimizations(OPTIMIZATIONS)\n    .withTimeLimit(TIME_LIMIT)\n    .withRelaxGeneralizedCostAtDestination(RELAX_GENERALIZED_COST_AT_DESTINATION)\n    .build();\n\n  @Test"}
{"magic_number_smell": "\n\t@Override\n\tpublic int getVersion() {\n\t\treturn 0;\n\t}\n\n\t@Override", "refactored_code": "\tpublic static final int VERSION = 0;\n\n\t@Override\n\tpublic int getVersion() {\n\t\treturn VERSION;\n\t}\n\n\t@Override"}
{"magic_number_smell": "    };\n    private final ArrayListComboBoxModel modelStudy = new ArrayListComboBoxModel() {\n\n        private static final long 1826724555734323483L = 2272386715266884376L;\n\n        @Override\n        public void addElement(Object anObject) {", "refactored_code": "        private static final long serialVersionUID = 1826724555734323483L;\n    };\n    private final ArrayListComboBoxModel modelStudy = new ArrayListComboBoxModel() {\n\n        private static final long serialVersionUID = 2272386715266884376L;\n\n        @Override\n        public void addElement(Object anObject) {"}
{"magic_number_smell": "\n            // get start day running hours\n            String startDayStr = DATE_FORMAT.format(startTime);\n            long endOfTheDay = DATE_FORMAT.parse(startDayStr).getTime() + TimeUnit.HOURS.toMillis(24) - 1;\n            runningHours = TimeUnit.MILLISECONDS.toHours(endOfTheDay - startTime.getTime());\n            CloudbreakUsage startDayUsage = getCloudbreakUsage(prototype, runningHours, startTime);\n            dailyStackUsageMap.put(DATE_FORMAT.format(startTime), startDayUsage);", "refactored_code": "    private static final int HOURS_IN_DAY = 24;\n\n            // get start day running hours\n            String startDayStr = DATE_FORMAT.format(startTime);\n            long endOfTheDay = DATE_FORMAT.parse(startDayStr).getTime() + TimeUnit.HOURS.toMillis(HOURS_IN_DAY) - 1;\n            runningHours = TimeUnit.MILLISECONDS.toHours(endOfTheDay - startTime.getTime());\n            CloudbreakUsage startDayUsage = getCloudbreakUsage(prototype, runningHours, startTime);\n            dailyStackUsageMap.put(DATE_FORMAT.format(startTime), startDayUsage);"}
{"magic_number_smell": "\t\n\tpublic static String defaultSymmetricKeystoreType() { return DEFAULT_SYMMETRIC_KEYSTORE_TYPE; }\n\t\n\tpublic static int defaultKeyLength() { return 1024; }\n\n\tpublic static Component defaultKeyNamespaceMarker() { return DEFAULT_KEY_NAMESPACE_MARKER; }\n}", "refactored_code": "\tprotected static final int DEFAULT_KEY_LENGTH = 1024;\n\t\n\tpublic static String defaultSymmetricKeystoreType() { return DEFAULT_SYMMETRIC_KEYSTORE_TYPE; }\n\t\n\tpublic static int defaultKeyLength() { return DEFAULT_KEY_LENGTH; }\n\n\tpublic static Component defaultKeyNamespaceMarker() { return DEFAULT_KEY_NAMESPACE_MARKER; }\n}"}
{"magic_number_smell": "        assertThat(transfer.getAssetHash(), is(\"0x\" + NEO_HASH));\n        assertThat(transfer.getTransferAddress(), is(TX_RECIPIENT_1));\n        assertThat(transfer.getAmount(), is(TX_AMOUNT_NEO));\n        assertThat(transfer.getBlockIndex(), is(2L));\n        assertThat(transfer.getTransferNotifyIndex(), is(1L));\n\n        assertNotNull(nep17TransferWrapper.getReceived());", "refactored_code": "    private static final long TX_BLOCK_IDX = 2L;\n        assertThat(transfer.getAssetHash(), is(\"0x\" + NEO_HASH));\n        assertThat(transfer.getTransferAddress(), is(TX_RECIPIENT_1));\n        assertThat(transfer.getAmount(), is(TX_AMOUNT_NEO));\n        assertThat(transfer.getBlockIndex(), is(TX_BLOCK_IDX));\n        assertThat(transfer.getTransferNotifyIndex(), is(1L));\n\n        assertNotNull(nep17TransferWrapper.getReceived());"}
{"magic_number_smell": "                    maxPartialMemory,\n                    spillEnabled,\n                    unspillMemoryLimit,\n                    DataSize.succinctBytes((long) (unspillMemoryLimit.toBytes() * 0.9)),\n                    spillerFactory,\n                    joinCompiler);\n        }", "refactored_code": "    private static final double MERGE_WITH_MEMORY_RATIO = 0.9;\n                    maxPartialMemory,\n                    spillEnabled,\n                    unspillMemoryLimit,\n                    DataSize.succinctBytes((long) (unspillMemoryLimit.toBytes() * MERGE_WITH_MEMORY_RATIO)),\n                    spillerFactory,\n                    joinCompiler);\n        }"}
{"magic_number_smell": "    private static StringBuilder getThreadLocalStringBuilder() {\n        StringBuilder buffer = threadLocalStringBuilder.get();\n        if (buffer == null) {\n            buffer = new StringBuilder(255);\n            threadLocalStringBuilder.set(buffer);\n        }\n        buffer.setLength(0);", "refactored_code": "    private static final int DEFAULT_STRING_BUILDER_SIZE = 255;\n    private static StringBuilder getThreadLocalStringBuilder() {\n        StringBuilder buffer = threadLocalStringBuilder.get();\n        if (buffer == null) {\n            buffer = new StringBuilder(DEFAULT_STRING_BUILDER_SIZE);\n            threadLocalStringBuilder.set(buffer);\n        }\n        buffer.setLength(0);"}
{"magic_number_smell": "        CheckedOutputStream crcOut = new CheckedOutputStream(sessOS, new Adler32());\n        //CheckedOutputStream cout = new CheckedOutputStream()\n        OutputArchive oa = BinaryOutputArchive.getArchive(crcOut);\n        FileHeader header = new FileHeader(SNAP_MAGIC, 2, dbId);\n        serialize(dt,sessions,oa, header);\n        long val = crcOut.getChecksum().getValue();\n        oa.writeLong(val, \"val\");", "refactored_code": "    private static final int VERSION=2;\n        CheckedOutputStream crcOut = new CheckedOutputStream(sessOS, new Adler32());\n        //CheckedOutputStream cout = new CheckedOutputStream()\n        OutputArchive oa = BinaryOutputArchive.getArchive(crcOut);\n        FileHeader header = new FileHeader(SNAP_MAGIC, VERSION, dbId);\n        serialize(dt,sessions,oa, header);\n        long val = crcOut.getChecksum().getValue();\n        oa.writeLong(val, \"val\");"}
{"magic_number_smell": "\n    private static class Special implements Serializable {\n        /** default serial version id */\n        private static final long 1L = 1L;\n        private Special() { }\n\n        public static final Special NULL_VALUE = new Special() {", "refactored_code": "    private static final long serialVersionUID = 1L;\n\n    private static class Special implements Serializable {\n        /** default serial version id */\n        private static final long serialVersionUID = 1L;\n        private Special() { }\n\n        public static final Special NULL_VALUE = new Special() {"}
{"magic_number_smell": "            if (!isLocalServerRunning()) {\n                startLocalServer();\n            }\n        }, 0, 30, TimeUnit.SECONDS);\n    }\n\n    private void startLocalServer() {", "refactored_code": "    private static final int MONITOR_PERIOD = 30;\n            if (!isLocalServerRunning()) {\n                startLocalServer();\n            }\n        }, 0, MONITOR_PERIOD, TimeUnit.SECONDS);\n    }\n\n    private void startLocalServer() {"}
{"magic_number_smell": "    }\n\n    private long getNewCtime() {\n        return System.currentTimeMillis() - 20;\n    }\n\n    private long getExpiredCtime() {", "refactored_code": "    private static final long TIME_SAFETY_MARGIN = 20;\n    }\n\n    private long getNewCtime() {\n        return System.currentTimeMillis() - TIME_SAFETY_MARGIN;\n    }\n\n    private long getExpiredCtime() {"}
{"magic_number_smell": "\n        for (PixelOffset px : pixels) {\n            float d = getDepth(px.offset);\n            if (d != -1) {\n\n//                Vec3D pKinect = calibIR.pixelToWorld(px.x, px.y, d);\n//                depthData.depthPoints[px.offset] = pKinect;", "refactored_code": "    protected static final float INVALID_DEPTH = -1;\n\n        for (PixelOffset px : pixels) {\n            float d = getDepth(px.offset);\n            if (d != INVALID_DEPTH) {\n\n//                Vec3D pKinect = calibIR.pixelToWorld(px.x, px.y, d);\n//                depthData.depthPoints[px.offset] = pKinect;"}
{"magic_number_smell": "\t@Test\n\tpublic void testWaitConditionNoIndexOutOfBounceAfterTwoTries() {\n\t\tWaitCondition wc = new WaitCondition(\"tmp\", WAIT_TIME_LONG, new TimeoutExpectedCondition());\n\t\tAssert.assertEquals(\"Wait timed out\", 0, wc.testAndWait(browser));\n\t}\n\n\t@Test", "refactored_code": "\tprivate static final int WAIT_TIMEOUT = 0;\n\t@Test\n\tpublic void testWaitConditionNoIndexOutOfBounceAfterTwoTries() {\n\t\tWaitCondition wc = new WaitCondition(\"tmp\", WAIT_TIME_LONG, new TimeoutExpectedCondition());\n\t\tAssert.assertEquals(\"Wait timed out\", WAIT_TIMEOUT, wc.testAndWait(browser));\n\t}\n\n\t@Test"}
{"magic_number_smell": "                setId(maxItemId + ID_PROMOTION_OFFSET);\n                itemMap.clear();\n            } else {\n                itemSet = new HashSet<CollectionItem>(1000);\n            }\n            itemMap = null;\n        }", "refactored_code": "    private static final int INITIAL_CAPACITY = 1000;\n                setId(maxItemId + ID_PROMOTION_OFFSET);\n                itemMap.clear();\n            } else {\n                itemSet = new HashSet<CollectionItem>(INITIAL_CAPACITY);\n            }\n            itemMap = null;\n        }"}
{"magic_number_smell": "          float cp1Radius = longSegment ? innerRadius : outerRadius;\n          float cp2Radius = longSegment ? outerRadius : innerRadius;\n\n          float cp1x = cp1Radius * cp1Roundedness * .47829f * cp1Dx;\n          float cp1y = cp1Radius * cp1Roundedness * .47829f * cp1Dy;\n          float cp2x = cp2Radius * cp2Roundedness * .47829f * cp2Dx;\n          float cp2y = cp2Radius * cp2Roundedness * .47829f * cp2Dy;", "refactored_code": "    private static final float POLYSTAR_MAGIC_NUMBER = .47829f;\n          float cp1Radius = longSegment ? innerRadius : outerRadius;\n          float cp2Radius = longSegment ? outerRadius : innerRadius;\n\n          float cp1x = cp1Radius * cp1Roundedness * POLYSTAR_MAGIC_NUMBER * cp1Dx;\n          float cp1y = cp1Radius * cp1Roundedness * POLYSTAR_MAGIC_NUMBER * cp1Dy;\n          float cp2x = cp2Radius * cp2Roundedness * POLYSTAR_MAGIC_NUMBER * cp2Dx;\n          float cp2y = cp2Radius * cp2Roundedness * POLYSTAR_MAGIC_NUMBER * cp2Dy;"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "        Path paramFile = modelPath.resolve(String.format(\"%s-%04d.params\", modelName, epoch));\n        try (DataOutputStream dos = new DataOutputStream(Files.newOutputStream(paramFile))) {\n            dos.writeBytes(\"DJL@\");\n            dos.writeInt(1);\n            dos.writeUTF(modelName);\n            dos.writeUTF(dataType.name());\n            inputData = block.describeInput();", "refactored_code": "    private static final int MODEL_VERSION = 1;\n        Path paramFile = modelPath.resolve(String.format(\"%s-%04d.params\", modelName, epoch));\n        try (DataOutputStream dos = new DataOutputStream(Files.newOutputStream(paramFile))) {\n            dos.writeBytes(\"DJL@\");\n            dos.writeInt(MODEL_VERSION);\n            dos.writeUTF(modelName);\n            dos.writeUTF(dataType.name());\n            inputData = block.describeInput();"}
{"magic_number_smell": "    // true if more defragged ids can be read from file\n    private boolean haveMore = true;\n    // marks where this sessions released ids will be written\n    private long readBlocksTo = 9;\n    // used to calculate number of ids actually in use\n    private long defraggedIdCount = -1;\n", "refactored_code": "    private static final int HEADER_SIZE = 9;\n    // true if more defragged ids can be read from file\n    private boolean haveMore = true;\n    // marks where this sessions released ids will be written\n    private long readBlocksTo = HEADER_SIZE;\n    // used to calculate number of ids actually in use\n    private long defraggedIdCount = -1;\n"}
{"magic_number_smell": "        if (response instanceof NormalResponse && op instanceof BackupAwareOperation) {\n            final NormalResponse resp = (NormalResponse) response;\n            if (resp.getBackupCount() > 0) {\n                waitForBackups(resp.getBackupCount(), 5, TimeUnit.SECONDS, resp);\n                return;\n            }\n        }", "refactored_code": "    public static final long TIMEOUT = 5;\n        if (response instanceof NormalResponse && op instanceof BackupAwareOperation) {\n            final NormalResponse resp = (NormalResponse) response;\n            if (resp.getBackupCount() > 0) {\n                waitForBackups(resp.getBackupCount(), TIMEOUT, TimeUnit.SECONDS, resp);\n                return;\n            }\n        }"}
{"magic_number_smell": "\tprivate static final long MAGIC = MAGIC_BASE | (MAJOR << 8) | MINOR;\r\n\tprivate long magicBytes = MAGIC;\r\n\tpublic static final int MAGIC_CONT = 0x434f4e54;   // \"CONT\"\r\n\tprivate long fileLen = 1024 * 2;\r\n\tprivate int freeListStart = 0;\r\n\tprivate int mounted = 0;\r\n\tpublic int spanSize = 16;\r", "refactored_code": "\tpublic static final long PAGESIZE = 1024;\r\n\tprivate static final long MAGIC = MAGIC_BASE | (MAJOR << 8) | MINOR;\r\n\tprivate long magicBytes = MAGIC;\r\n\tpublic static final int MAGIC_CONT = 0x434f4e54;   // \"CONT\"\r\n\tprivate long fileLen = PAGESIZE * 2;\r\n\tprivate int freeListStart = 0;\r\n\tprivate int mounted = 0;\r\n\tpublic int spanSize = 16;\r"}
{"magic_number_smell": "     * Returns the amount of gold that this player has.\n     *\n     * @return The amount of gold that this player has.  May return\n     *     Integer.MIN_VALUE for players whose gold is not accounted.\n     */\n    public int getGold() {\n        return gold;", "refactored_code": "    public static final int GOLD_NOT_ACCOUNTED = Integer.MIN_VALUE;\n     * Returns the amount of gold that this player has.\n     *\n     * @return The amount of gold that this player has.  May return\n     *     GOLD_NOT_ACCOUNTED for players whose gold is not accounted.\n     */\n    public int getGold() {\n        return gold;"}
{"magic_number_smell": "            {\n                try\n                {\n                    thread.join(1000);\n\n                    if (!thread.isAlive() || done)\n                    {", "refactored_code": "    private static final int TIMEOUT_MS = 1000;\n            {\n                try\n                {\n                    thread.join(TIMEOUT_MS);\n\n                    if (!thread.isAlive() || done)\n                    {"}
{"magic_number_smell": "\n        // Move back to America:\n        Unit carrier = getUnit();\n        if (!carrier.getOwner().checkGold(600)\n            || transportList.size() > 0) {\n            moveUnitToAmerica();\n        }", "refactored_code": "    private static final int MINIMUM_GOLD_TO_STAY_IN_EUROPE = 600;\n\n        // Move back to America:\n        Unit carrier = getUnit();\n        if (!carrier.getOwner().checkGold(MINIMUM_GOLD_TO_STAY_IN_EUROPE)\n            || transportList.size() > 0) {\n            moveUnitToAmerica();\n        }"}
{"magic_number_smell": "        byte[] tempBytes = getX509Certificate()\n                .getExtensionValue(SUBJECT_KEY_IDENTIFIER_EXTENSION);\n\n        if (tempBytes.length > 20) {\n            this.subjectKeyIdentifier = truncatePrefixBytes(tempBytes);\n        } else {\n            this.subjectKeyIdentifier =", "refactored_code": "    private static final int CA_BYTE_SIZE = 20;\n        byte[] tempBytes = getX509Certificate()\n                .getExtensionValue(SUBJECT_KEY_IDENTIFIER_EXTENSION);\n\n        if (tempBytes.length > CA_BYTE_SIZE) {\n            this.subjectKeyIdentifier = truncatePrefixBytes(tempBytes);\n        } else {\n            this.subjectKeyIdentifier ="}
{"magic_number_smell": "\n    static public final String BASE_CRYPTO = Crypto.XMR.getSymbol();\n    static public final int 12 = 12;\n    static public final long ONE_XMR = Math.round(Math.pow(10, Helper.12));\n\n    static public final boolean SHOW_EXCHANGERATES = true;\n    static public final boolean ALLOW_SHIFT = true;", "refactored_code": "    static public final int XMR_DECIMALS = 12;\n\n    static public final String BASE_CRYPTO = Crypto.XMR.getSymbol();\n    static public final int XMR_DECIMALS = 12;\n    static public final long ONE_XMR = Math.round(Math.pow(10, Helper.XMR_DECIMALS));\n\n    static public final boolean SHOW_EXCHANGERATES = true;\n    static public final boolean ALLOW_SHIFT = true;"}
{"magic_number_smell": "        }\n\n        long getDefaultDisplayDelayTimeout() {\n            return 10000;\n        }\n    }\n", "refactored_code": "    private static final long WAIT_FOR_DEFAULT_DISPLAY_TIMEOUT = 10000;\n        }\n\n        long getDefaultDisplayDelayTimeout() {\n            return WAIT_FOR_DEFAULT_DISPLAY_TIMEOUT;\n        }\n    }\n"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "\tpublic byte [] root() { \n\t\tif ((null == _tree) || (_tree.length == 0))\n\t\t\treturn new byte[0];\n\t\treturn get(1);\n\t} \n\t\n\t/**", "refactored_code": "\tprotected static final int ROOT_NODE = 1;\n\tpublic byte [] root() { \n\t\tif ((null == _tree) || (_tree.length == 0))\n\t\t\treturn new byte[0];\n\t\treturn get(ROOT_NODE);\n\t} \n\t\n\t/**"}
{"magic_number_smell": "        // For testing:\n        Collect instance = Collect.getInstance();\n        if (instance == null) {\n            return Collect.21;\n        }\n\n        return Integer.parseInt(String.valueOf(GeneralSharedPreferences.getInstance().get(KEY_FONT_SIZE)));", "refactored_code": "    public static final int DEFAULT_FONTSIZE_INT = 21;\n        // For testing:\n        Collect instance = Collect.getInstance();\n        if (instance == null) {\n            return Collect.DEFAULT_FONTSIZE_INT;\n        }\n\n        return Integer.parseInt(String.valueOf(GeneralSharedPreferences.getInstance().get(KEY_FONT_SIZE)));"}
{"magic_number_smell": "    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #-1}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode", "refactored_code": "    public static final int INFINITE = -1;\n    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #INFINITE}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode"}
{"magic_number_smell": "    }\n\n    private static final int BiomeGenBase.getBiomeGenArray().length = BiomeGenBase.getBiomeGenArray().length;\n    private static BiomeInfo[] biomeList = new BiomeInfo[BiomeGenBase.getBiomeGenArray().length];\n    @SuppressWarnings(\"unchecked\")\n    private static ArrayList<BiomeGenBase>[] typeInfoList = new ArrayList[Type.values().length];\n", "refactored_code": "    private static final int BIOME_LIST_SIZE = BiomeGenBase.getBiomeGenArray().length;\n    }\n\n    private static final int BIOME_LIST_SIZE = BiomeGenBase.getBiomeGenArray().length;\n    private static BiomeInfo[] biomeList = new BiomeInfo[BIOME_LIST_SIZE];\n    @SuppressWarnings(\"unchecked\")\n    private static ArrayList<BiomeGenBase>[] typeInfoList = new ArrayList[Type.values().length];\n"}
{"magic_number_smell": "        CheckedOutputStream crcOut = new CheckedOutputStream(sessOS, new Adler32());\n        //CheckedOutputStream cout = new CheckedOutputStream()\n        OutputArchive oa = BinaryOutputArchive.getArchive(crcOut);\n        FileHeader header = new FileHeader(SNAP_MAGIC, 2, dbId);\n        serialize(dt,sessions,oa, header);\n        long val = crcOut.getChecksum().getValue();\n        oa.writeLong(val, \"val\");", "refactored_code": "    private static final int VERSION=2;\n        CheckedOutputStream crcOut = new CheckedOutputStream(sessOS, new Adler32());\n        //CheckedOutputStream cout = new CheckedOutputStream()\n        OutputArchive oa = BinaryOutputArchive.getArchive(crcOut);\n        FileHeader header = new FileHeader(SNAP_MAGIC, VERSION, dbId);\n        serialize(dt,sessions,oa, header);\n        long val = crcOut.getChecksum().getValue();\n        oa.writeLong(val, \"val\");"}
{"magic_number_smell": "\t\t\t\t\t\t\"ca_compromise\", \"extra_space\", \"affiliation_changed\",\n\t\t\t\t\t\t\"superseded\", \"cessation_of_operation\", \"certificate_hold\",\n\t\t\t\t\t\t\"remove_from_crl\"};\n\tpublic static final int REASON_CODES[] = {0, REASON_KEY_COMPROMISE,\n\t\t\tREASON_CA_COMPROMISE, REASON_AFFILIATION_CHANGED, REASON_SUPERSEDED,\n\t\t\tREASON_CESSATION_OF_OPERATION, REASON_CERTIFICATE_HOLD, REASON_REMOVE_FROM_CRL\n\t\t\t};", "refactored_code": "\tpublic static final int REASON_UNSPECIFIED \t\t= 0;\n\t\t\t\t\t\t\"ca_compromise\", \"extra_space\", \"affiliation_changed\",\n\t\t\t\t\t\t\"superseded\", \"cessation_of_operation\", \"certificate_hold\",\n\t\t\t\t\t\t\"remove_from_crl\"};\n\tpublic static final int REASON_CODES[] = {REASON_UNSPECIFIED, REASON_KEY_COMPROMISE,\n\t\t\tREASON_CA_COMPROMISE, REASON_AFFILIATION_CHANGED, REASON_SUPERSEDED,\n\t\t\tREASON_CESSATION_OF_OPERATION, REASON_CERTIFICATE_HOLD, REASON_REMOVE_FROM_CRL\n\t\t\t};"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "        Intent intent = new Intent(context, MainActivity.class);\n\n        PendingIntent pendingIntent = PendingIntent.getActivity(context,\n                8959, intent, PendingIntent.FLAG_UPDATE_CURRENT);\n\n        Notification.Builder builder = new Notification.Builder(context)\n                .setContentTitle(String.format(getString(R.string.notification_title), trainerLevel))", "refactored_code": "    private static final int NOTIFICATION_REQ_CODE = 8959;\n        Intent intent = new Intent(context, MainActivity.class);\n\n        PendingIntent pendingIntent = PendingIntent.getActivity(context,\n                NOTIFICATION_REQ_CODE, intent, PendingIntent.FLAG_UPDATE_CURRENT);\n\n        Notification.Builder builder = new Notification.Builder(context)\n                .setContentTitle(String.format(getString(R.string.notification_title), trainerLevel))"}
{"magic_number_smell": "            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + AlarmManager.INTERVAL_HOUR;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {", "refactored_code": "    private static final long BACKUP_INTERVAL = AlarmManager.INTERVAL_HOUR;\n            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + BACKUP_INTERVAL;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {"}
{"magic_number_smell": "\n    public HollowProducer(Publisher publisher,\n                          Announcer announcer) {\n        this(new HollowFilesystemBlobStager(), publisher, announcer, Collections.<Validator>emptyList(), Collections.<HollowProducerListener>emptyList(), Collections.<HollowValidationListener>emptyList(), new VersionMinterWithCounter(), null, 0, 16L * 1024L * 1024L, null, new DummyBlobStorageCleaner(), new BasicSingleProducerEnforcer());\n    }\n\n    public HollowProducer(Publisher publisher,", "refactored_code": "    private static final long DEFAULT_TARGET_MAX_TYPE_SHARD_SIZE = 16L * 1024L * 1024L;\n\n    public HollowProducer(Publisher publisher,\n                          Announcer announcer) {\n        this(new HollowFilesystemBlobStager(), publisher, announcer, Collections.<Validator>emptyList(), Collections.<HollowProducerListener>emptyList(), Collections.<HollowValidationListener>emptyList(), new VersionMinterWithCounter(), null, 0, DEFAULT_TARGET_MAX_TYPE_SHARD_SIZE, null, new DummyBlobStorageCleaner(), new BasicSingleProducerEnforcer());\n    }\n\n    public HollowProducer(Publisher publisher,"}
{"magic_number_smell": "    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);"}
{"magic_number_smell": "    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #-1}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode", "refactored_code": "    public static final int INFINITE = -1;\n    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #INFINITE}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode"}
{"magic_number_smell": "            settlement.changeMissionary(unit);\n            settlement.setConvertProgress(0);\n            List<FreeColGameObject> modifiedSettlements\n                = settlement.modifyAlarm(serverPlayer, -100);\n            modifiedSettlements.remove(settlement);\n            if (!modifiedSettlements.isEmpty()) {\n                cs.add(See.only(serverPlayer), modifiedSettlements);", "refactored_code": "    public static final int ALARM_NEW_MISSIONARY = -100;\n            settlement.changeMissionary(unit);\n            settlement.setConvertProgress(0);\n            List<FreeColGameObject> modifiedSettlements\n                = settlement.modifyAlarm(serverPlayer, ALARM_NEW_MISSIONARY);\n            modifiedSettlements.remove(settlement);\n            if (!modifiedSettlements.isEmpty()) {\n                cs.add(See.only(serverPlayer), modifiedSettlements);"}
{"magic_number_smell": "    // Fills the specified point on the bitmap with the currently selected fill color.\n    // int x, int y: The starting coords for the fill\n    public boolean floodFill(int x, int y, Window parent) {\n        final Rectangle largestPossibleFloodArea = new Rectangle(x - 46340 / 2, y - 46340 / 2, 46340, 46340);\n        final Rectangle fillBounds = fillMethod.getBounds();\n        if (! largestPossibleFloodArea.contains(fillBounds)) {\n            boundsTooLarge = true;", "refactored_code": "    private static final int MAX_INT_SQUARE_SIDE = 46340; // sqrt(Integer.MAX_VALUE)\n    // Fills the specified point on the bitmap with the currently selected fill color.\n    // int x, int y: The starting coords for the fill\n    public boolean floodFill(int x, int y, Window parent) {\n        final Rectangle largestPossibleFloodArea = new Rectangle(x - MAX_INT_SQUARE_SIDE / 2, y - MAX_INT_SQUARE_SIDE / 2, MAX_INT_SQUARE_SIDE, MAX_INT_SQUARE_SIDE);\n        final Rectangle fillBounds = fillMethod.getBounds();\n        if (! largestPossibleFloodArea.contains(fillBounds)) {\n            boundsTooLarge = true;"}
{"magic_number_smell": "\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != 0x414E4554) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n", "refactored_code": "    private static final int FILE_MAGIC = 0x414E4554;\n\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != FILE_MAGIC) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n"}
{"magic_number_smell": "                    }\r\n                }\r\n            }\r\n        }, 0, 1000);\r\n    }\r\n\r\n    /**\r", "refactored_code": "    protected static final int MILLIS_UPDATE = 1000;\r\n                    }\r\n                }\r\n            }\r\n        }, 0, MILLIS_UPDATE);\r\n    }\r\n\r\n    /**\r"}
{"magic_number_smell": "    public static final Setting<TimeValue> CACHE_TTL_SETTING = Setting.timeSetting(\"cache.ttl\", DEFAULT_TTL, Setting.Property.NodeScope);\n\n    private static final int 100_000 = 100_000; //100k users\n    public static final Setting<Integer> CACHE_MAX_USERS_SETTING = Setting.intSetting(\"cache.max_users\", 100_000,\n            Setting.Property.NodeScope);\n\n    private final Cache<String, UserWithHash> cache;", "refactored_code": "    private static final int DEFAULT_MAX_USERS = 100_000; //100k users\n    public static final Setting<TimeValue> CACHE_TTL_SETTING = Setting.timeSetting(\"cache.ttl\", DEFAULT_TTL, Setting.Property.NodeScope);\n\n    private static final int DEFAULT_MAX_USERS = 100_000; //100k users\n    public static final Setting<Integer> CACHE_MAX_USERS_SETTING = Setting.intSetting(\"cache.max_users\", DEFAULT_MAX_USERS,\n            Setting.Property.NodeScope);\n\n    private final Cache<String, UserWithHash> cache;"}
{"magic_number_smell": "    @Test(dataProvider = \"hashEnabledAndMemoryLimitForMergeValues\")\n    public void testHashBuilderResize(boolean hashEnabled, boolean spillEnabled, long memoryLimitForMerge, long memoryLimitForMergeWithMemory)\n    {\n        BlockBuilder builder = VARCHAR.createBlockBuilder(null, 1, 64 * 1024);\n        VARCHAR.writeSlice(builder, Slices.allocate(200_000)); // this must be larger than 64 * 1024, 64K\n        builder.build();\n", "refactored_code": "    private static final int MAX_BLOCK_SIZE_IN_BYTES = 64 * 1024;\n    @Test(dataProvider = \"hashEnabledAndMemoryLimitForMergeValues\")\n    public void testHashBuilderResize(boolean hashEnabled, boolean spillEnabled, long memoryLimitForMerge, long memoryLimitForMergeWithMemory)\n    {\n        BlockBuilder builder = VARCHAR.createBlockBuilder(null, 1, MAX_BLOCK_SIZE_IN_BYTES);\n        VARCHAR.writeSlice(builder, Slices.allocate(200_000)); // this must be larger than MAX_BLOCK_SIZE_IN_BYTES, 64K\n        builder.build();\n"}
{"magic_number_smell": "     * @param listener the TailerListener to use.\n     */\n    public Tailer(File file, TailerListener listener) {\n        this(file, listener, 1000);\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_DELAY_MILLIS = 1000;\n     * @param listener the TailerListener to use.\n     */\n    public Tailer(File file, TailerListener listener) {\n        this(file, listener, DEFAULT_DELAY_MILLIS);\n    }\n\n    /**"}
{"magic_number_smell": "            if (!isValid(tag.trim())) {\n                throw new IllegalArgumentException(\"invalid tag : \" + tag);\n            }\n            if (tag.length() > 16) {\n                throw new IllegalArgumentException(\"too long tag, over 16\");\n            }\n        }", "refactored_code": "    private static final int TAG_MAX_LEN = 16;\n            if (!isValid(tag.trim())) {\n                throw new IllegalArgumentException(\"invalid tag : \" + tag);\n            }\n            if (tag.length() > TAG_MAX_LEN) {\n                throw new IllegalArgumentException(\"too long tag, over 16\");\n            }\n        }"}
{"magic_number_smell": "\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != 0x414E4554) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n", "refactored_code": "    private static final int FILE_MAGIC = 0x414E4554;\n\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != FILE_MAGIC) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n"}
{"magic_number_smell": "\n\tprotected static class DaemonListenerClass extends UnicastRemoteObject implements DaemonListener {\n\n\t\tprivate static final long -4969812722104756329L = -9217344397211709762L;\n\t\tprotected WorkerThread _daemonThread;\n\n\t\tpublic DaemonListenerClass(WorkerThread daemonThread) throws RemoteException {", "refactored_code": "\t\tprivate static final long serialVersionUID = -4969812722104756329L;\n\n\tprotected static class DaemonListenerClass extends UnicastRemoteObject implements DaemonListener {\n\n\t\tprivate static final long serialVersionUID = -9217344397211709762L;\n\t\tprotected WorkerThread _daemonThread;\n\n\t\tpublic DaemonListenerClass(WorkerThread daemonThread) throws RemoteException {"}
{"magic_number_smell": "public class AdaptiveSchedulerTest extends TestLogger {\n\n    private static final int 4 = 4;\n    private static final JobVertex JOB_VERTEX = createNoOpVertex(\"v1\", 4);\n\n    @ClassRule\n    public static final TestExecutorResource<ScheduledExecutorService> EXECUTOR_RESOURCE =", "refactored_code": "    private static final int PARALLELISM = 4;\npublic class AdaptiveSchedulerTest extends TestLogger {\n\n    private static final int PARALLELISM = 4;\n    private static final JobVertex JOB_VERTEX = createNoOpVertex(\"v1\", PARALLELISM);\n\n    @ClassRule\n    public static final TestExecutorResource<ScheduledExecutorService> EXECUTOR_RESOURCE ="}
{"magic_number_smell": "        given(commitPointer.getSha()).willReturn(\"sha1\");\n        GhprbTestUtil.setupGhprbTriggerDescriptor(null);\n        project.addProperty(new GithubProjectProperty(\"https://github.com/user/dropwizard\"));\n        given(ghPullRequest.getId()).willReturn(1);\n        given(ghPullRequest.getNumber()).willReturn(1);\n        given(ghRepository.getPullRequest(1)).willReturn(ghPullRequest);\n        Ghprb ghprb = spy(trigger.createGhprb(project));", "refactored_code": "    private final int prId = 1;\n        given(commitPointer.getSha()).willReturn(\"sha1\");\n        GhprbTestUtil.setupGhprbTriggerDescriptor(null);\n        project.addProperty(new GithubProjectProperty(\"https://github.com/user/dropwizard\"));\n        given(ghPullRequest.getId()).willReturn(prId);\n        given(ghPullRequest.getNumber()).willReturn(prId);\n        given(ghRepository.getPullRequest(prId)).willReturn(ghPullRequest);\n        Ghprb ghprb = spy(trigger.createGhprb(project));"}
{"magic_number_smell": "\t\n\tpublic static String defaultSymmetricKeystoreType() { return DEFAULT_SYMMETRIC_KEYSTORE_TYPE; }\n\t\n\tpublic static int defaultKeyLength() { return 1024; }\n\n\tpublic static Component defaultKeyNamespaceMarker() { return DEFAULT_KEY_NAMESPACE_MARKER; }\n}", "refactored_code": "\tprotected static final int DEFAULT_KEY_LENGTH = 1024;\n\t\n\tpublic static String defaultSymmetricKeystoreType() { return DEFAULT_SYMMETRIC_KEYSTORE_TYPE; }\n\t\n\tpublic static int defaultKeyLength() { return DEFAULT_KEY_LENGTH; }\n\n\tpublic static Component defaultKeyNamespaceMarker() { return DEFAULT_KEY_NAMESPACE_MARKER; }\n}"}
{"magic_number_smell": "            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + AlarmManager.INTERVAL_HOUR;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {", "refactored_code": "    private static final long BACKUP_INTERVAL = AlarmManager.INTERVAL_HOUR;\n            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + BACKUP_INTERVAL;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {"}
{"magic_number_smell": "    }\n\n    static class Counter implements ManagedObject, Serializable {\n\tprivate static final long 1 = 1;\n\tprivate int count;\n\tCounter() { }\n\tint next() { return ++count; }", "refactored_code": "\tprivate static final long serialVersionUID = 1;\n    }\n\n    static class Counter implements ManagedObject, Serializable {\n\tprivate static final long serialVersionUID = 1;\n\tprivate int count;\n\tCounter() { }\n\tint next() { return ++count; }"}
{"magic_number_smell": "\t@Test\n\tpublic void randomValuesAreUnique() {\n\t\tSet<String> set = new HashSet<>();\n\t\tfor (int i = 0; i < 1000; i++) {\n\t\t\tassertThat(set.add(generator.getRandomString(LENGTH_MEDIUM)), is(true));\n\t\t}\n\t}", "refactored_code": "\tprivate static final int NUM_RAND_CHECKS = 1000;\n\t@Test\n\tpublic void randomValuesAreUnique() {\n\t\tSet<String> set = new HashSet<>();\n\t\tfor (int i = 0; i < NUM_RAND_CHECKS; i++) {\n\t\t\tassertThat(set.add(generator.getRandomString(LENGTH_MEDIUM)), is(true));\n\t\t}\n\t}"}
{"magic_number_smell": "                               FramesFactory.getEME2000(), AbsoluteDate.J2000_EPOCH, 3.986004415e14);\n        KeplerianPropagator propagator = new KeplerianPropagator(orbit);\n        propagator.setMasterMode(new OrekitStepHandler() {\n            private static final long 5918362126173997016L = 8183822352839222377L;\n            public void handleStep(OrekitStepInterpolator interpolator,\n                                   boolean isLast) throws PropagationException {\n                if (isLast) {", "refactored_code": "            private static final long serialVersionUID = 5918362126173997016L;\n                               FramesFactory.getEME2000(), AbsoluteDate.J2000_EPOCH, 3.986004415e14);\n        KeplerianPropagator propagator = new KeplerianPropagator(orbit);\n        propagator.setMasterMode(new OrekitStepHandler() {\n            private static final long serialVersionUID = 8183822352839222377L;\n            public void handleStep(OrekitStepInterpolator interpolator,\n                                   boolean isLast) throws PropagationException {\n                if (isLast) {"}
{"magic_number_smell": "\n        case R.id.action_settings:\n            Intent prefs = new Intent(getBaseContext(), PreferencesActivity.class);\n            startActivityForResult(prefs, 1);\n            return true;\n\n        case R.id.action_swap:", "refactored_code": "    public static final int REQUEST_PREFS = 1;\n\n        case R.id.action_settings:\n            Intent prefs = new Intent(getBaseContext(), PreferencesActivity.class);\n            startActivityForResult(prefs, REQUEST_PREFS);\n            return true;\n\n        case R.id.action_swap:"}
{"magic_number_smell": "\n        // Prepare the loaders. Either re-connect with an existing ones,\n        // or start new ones.\n        getSupportLoaderManager().initLoader(0, null, this);\n\n        mNfcHelper = new NfcHelper(this, mProviderHelper);\n        mNfcHelper.initNfc(mDataUri);", "refactored_code": "    private static final int LOADER_ID_UNIFIED = 0;\n\n        // Prepare the loaders. Either re-connect with an existing ones,\n        // or start new ones.\n        getSupportLoaderManager().initLoader(LOADER_ID_UNIFIED, null, this);\n\n        mNfcHelper = new NfcHelper(this, mProviderHelper);\n        mNfcHelper.initNfc(mDataUri);"}
{"magic_number_smell": "  private @Nullable Component mRoot;\n\n  @GuardedBy(\"this\")\n  private int mExternalRootVersion = -1;\n\n  @GuardedBy(\"this\")\n  private int mNextResolveVersion;", "refactored_code": "  public static final int INVALID_LAYOUT_VERSION = -1;\n  private @Nullable Component mRoot;\n\n  @GuardedBy(\"this\")\n  private int mExternalRootVersion = INVALID_LAYOUT_VERSION;\n\n  @GuardedBy(\"this\")\n  private int mNextResolveVersion;"}
{"magic_number_smell": "     * Note that this method may change the value of top_prot or bottom_prot.\n     * @param prot The protocol to be inserted. Before insertion, a sanity check will ensure that none\n     *             of the existing protocols have the same name as the new protocol.\n     * @param position Where to place the protocol with respect to the neighbor_prot (1, BELOW)\n     * @param neighbor_prot The name of the neighbor protocol. An exception will be thrown if this name\n     *                      is not found\n     * @exception Exception Will be thrown when the new protocol cannot be created, or inserted.", "refactored_code": "    public static final int         ABOVE=1; // used by insertProtocol()\n     * Note that this method may change the value of top_prot or bottom_prot.\n     * @param prot The protocol to be inserted. Before insertion, a sanity check will ensure that none\n     *             of the existing protocols have the same name as the new protocol.\n     * @param position Where to place the protocol with respect to the neighbor_prot (ABOVE, BELOW)\n     * @param neighbor_prot The name of the neighbor protocol. An exception will be thrown if this name\n     *                      is not found\n     * @exception Exception Will be thrown when the new protocol cannot be created, or inserted."}
{"magic_number_smell": "\n    private void addReceivedMessage(ByteArrayWrapper message) {\n        if (message != null) {\n            if (this.receivedMessages.size() >= 5000) {\n                this.receivedMessages.clear();\n            }\n            this.receivedMessages.add(message);", "refactored_code": "    public static final int MAX_NUMBER_OF_MESSAGES_CACHED = 5000;\n\n    private void addReceivedMessage(ByteArrayWrapper message) {\n        if (message != null) {\n            if (this.receivedMessages.size() >= MAX_NUMBER_OF_MESSAGES_CACHED) {\n                this.receivedMessages.clear();\n            }\n            this.receivedMessages.add(message);"}
{"magic_number_smell": "                setId(maxItemId + ID_PROMOTION_OFFSET);\n                itemMap.clear();\n            } else {\n                itemSet = new HashSet<CollectionItem>(1000);\n            }\n            itemMap = null;\n        }", "refactored_code": "    private static final int INITIAL_CAPACITY = 1000;\n                setId(maxItemId + ID_PROMOTION_OFFSET);\n                itemMap.clear();\n            } else {\n                itemSet = new HashSet<CollectionItem>(INITIAL_CAPACITY);\n            }\n            itemMap = null;\n        }"}
{"magic_number_smell": "        this.configuration = new FrameConfiguration(frameType);\n        this.position = new Position(configuration.getX(), configuration.getY());\n        this.setLocation(position.getX(), position.getY());\n        this.dimension = new Dimension(Math.max(configuration.getWidth(), 450),\n                Math.max(configuration.getHeight(), MIN_HEIGHT));\n        this.setSize(dimension.width, dimension.height);\n    }", "refactored_code": "    private static final int MIN_WIDTH = 450;\n        this.configuration = new FrameConfiguration(frameType);\n        this.position = new Position(configuration.getX(), configuration.getY());\n        this.setLocation(position.getX(), position.getY());\n        this.dimension = new Dimension(Math.max(configuration.getWidth(), MIN_WIDTH),\n                Math.max(configuration.getHeight(), MIN_HEIGHT));\n        this.setSize(dimension.width, dimension.height);\n    }"}
{"magic_number_smell": "    */\r\n   static class RangeProperties implements Serializable\r\n   {\r\n      private static final long 6730844584074229969L = 5627339191207625169L;\r\n      \r\n      QName qname;\r\n      String lower;\r", "refactored_code": "   private static final long serialVersionUID = 6730844584074229969L;\r\n    */\r\n   static class RangeProperties implements Serializable\r\n   {\r\n      private static final long serialVersionUID = 5627339191207625169L;\r\n      \r\n      QName qname;\r\n      String lower;\r"}
{"magic_number_smell": "  public Single<Optional<java.io.File>> getDriveFileAsJavaFile(String fileId, java.io.File downloadLocationFile) {\n    try (InputStream is = driveService.files().get(fileId).setFields(\"*\").executeMediaAsInputStream()) {\n      try (FileOutputStream fileOutputStream = new FileOutputStream(downloadLocationFile)) {\n        byte[] buffer = new byte[8192];\n        int read;\n        while ((read = is.read(buffer)) != -1) {\n          fileOutputStream.write(buffer, 0, read);", "refactored_code": "  private static final int BYTE_BUFFER_SIZE = 8192;\n  public Single<Optional<java.io.File>> getDriveFileAsJavaFile(String fileId, java.io.File downloadLocationFile) {\n    try (InputStream is = driveService.files().get(fileId).setFields(\"*\").executeMediaAsInputStream()) {\n      try (FileOutputStream fileOutputStream = new FileOutputStream(downloadLocationFile)) {\n        byte[] buffer = new byte[BYTE_BUFFER_SIZE];\n        int read;\n        while ((read = is.read(buffer)) != -1) {\n          fileOutputStream.write(buffer, 0, read);"}
{"magic_number_smell": "\n    private static byte addressVersion = DEFAULT_ADDRESS_VERSION;\n    private Long networkMagic = null;\n    private int blockInterval = 15 * 1000;\n    private long maxValidUntilBlockIncrement = MAX_VALID_UNTIL_BLOCK_INCREMENT_BASE / blockInterval;\n    private int pollingInterval = 15 * 1000;\n    private ScheduledExecutorService scheduledExecutorService = Async.defaultExecutorService();", "refactored_code": "    public static final int DEFAULT_BLOCK_TIME = 15 * 1000;\n\n    private static byte addressVersion = DEFAULT_ADDRESS_VERSION;\n    private Long networkMagic = null;\n    private int blockInterval = DEFAULT_BLOCK_TIME;\n    private long maxValidUntilBlockIncrement = MAX_VALID_UNTIL_BLOCK_INCREMENT_BASE / blockInterval;\n    private int pollingInterval = DEFAULT_BLOCK_TIME;\n    private ScheduledExecutorService scheduledExecutorService = Async.defaultExecutorService();"}
{"magic_number_smell": "\t\tfinal boolean vibrate = preferences.getBoolean(\"vibrate_on_notification\", true);\n\n\t\tif (notifications.size() == 0) {\n\t\t\tnotificationManager.cancel(0x2342);\n\t\t} else {\n\t\t\tif (notify) {\n\t\t\t\tthis.markLastNotification();", "refactored_code": "\tpublic static final int NOTIFICATION_ID = 0x2342;\n\t\tfinal boolean vibrate = preferences.getBoolean(\"vibrate_on_notification\", true);\n\n\t\tif (notifications.size() == 0) {\n\t\t\tnotificationManager.cancel(NOTIFICATION_ID);\n\t\t} else {\n\t\t\tif (notify) {\n\t\t\t\tthis.markLastNotification();"}
{"magic_number_smell": "    int secs = (int)(micros / 1000000);\n    int usec = (int)(micros % 1000000);\n    int capLen = packet.length;\n    byte[] ret = new byte[4*Integer.BYTES + packet.length];\n    int offset = 0;\n    {\n      byte[] b = Bytes.toBytes(swapBytes?ByteOrderConverter.swap(secs):secs);", "refactored_code": "  public static final int PACKET_HEADER_SIZE = 4*Integer.BYTES;\n    int secs = (int)(micros / 1000000);\n    int usec = (int)(micros % 1000000);\n    int capLen = packet.length;\n    byte[] ret = new byte[PACKET_HEADER_SIZE + packet.length];\n    int offset = 0;\n    {\n      byte[] b = Bytes.toBytes(swapBytes?ByteOrderConverter.swap(secs):secs);"}
{"magic_number_smell": "         {\n            Point2DReadOnly target = listOfObserverPoints.get(j);\n\n            if (observer.distance(target) > 0.01)\n            {\n               boolean targetIsVisible = isPointVisibleForStaticMaps(clusters, observer, target);\n", "refactored_code": "   private static final double MAGIC_NUMBER = 0.01;\n         {\n            Point2DReadOnly target = listOfObserverPoints.get(j);\n\n            if (observer.distance(target) > MAGIC_NUMBER)\n            {\n               boolean targetIsVisible = isPointVisibleForStaticMaps(clusters, observer, target);\n"}
{"magic_number_smell": "                final int num = 4_000_000 + (int) Math.pow(3.7, len);\n                for (int j = 0; j < num; j++) {\n                    for (int i = 1; i < lim; i++) {\n                        temp[i] = ALPHABET[r.nextInt(ALPHABET.length)];\n                    }\n                    String sig = new String(temp);\n                    try {", "refactored_code": "    private static final int ALPHABET_LEN = ALPHABET.length;\n                final int num = 4_000_000 + (int) Math.pow(3.7, len);\n                for (int j = 0; j < num; j++) {\n                    for (int i = 1; i < lim; i++) {\n                        temp[i] = ALPHABET[r.nextInt(ALPHABET_LEN)];\n                    }\n                    String sig = new String(temp);\n                    try {"}
{"magic_number_smell": "\t\t\t\t}\n\t\t\t}\n\t\t\tif ( list.isEmpty() && haslatest)\n\t\t\t\tlist.add( new Version(999999999,0,0));\n\t\t\treturn new SortedList<Version>(list);\n\t\t}\n\t\treturn SortedList.empty();", "refactored_code": "\tpublic static final int\tMAX_MAJOR\t= 999999999;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( list.isEmpty() && haslatest)\n\t\t\t\tlist.add( new Version(MAX_MAJOR,0,0));\n\t\t\treturn new SortedList<Version>(list);\n\t\t}\n\t\treturn SortedList.empty();"}
{"magic_number_smell": "            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + AlarmManager.INTERVAL_HOUR;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {", "refactored_code": "    private static final long BACKUP_INTERVAL = AlarmManager.INTERVAL_HOUR;\n            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + BACKUP_INTERVAL;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {"}
{"magic_number_smell": "          logger.info(\"Rescheduling {} URLs from previous crawl.\", numPreviouslyInProcessPages);\n          scheduledPages -= numPreviouslyInProcessPages;\n\n          List<WebURL> urls = inProcessPages.get(100);\n          while (!urls.isEmpty()) {\n            scheduleAll(urls);\n            inProcessPages.delete(urls.size());", "refactored_code": "  private static final int IN_PROCESS_RESCHEDULE_BATCH_SIZE = 100;\n          logger.info(\"Rescheduling {} URLs from previous crawl.\", numPreviouslyInProcessPages);\n          scheduledPages -= numPreviouslyInProcessPages;\n\n          List<WebURL> urls = inProcessPages.get(IN_PROCESS_RESCHEDULE_BATCH_SIZE);\n          while (!urls.isEmpty()) {\n            scheduleAll(urls);\n            inProcessPages.delete(urls.size());"}
{"magic_number_smell": "\t\tfinal boolean vibrate = preferences.getBoolean(\"vibrate_on_notification\", true);\n\n\t\tif (notifications.size() == 0) {\n\t\t\tnotificationManager.cancel(0x2342);\n\t\t} else {\n\t\t\tif (notify) {\n\t\t\t\tthis.markLastNotification();", "refactored_code": "\tpublic static final int NOTIFICATION_ID = 0x2342;\n\t\tfinal boolean vibrate = preferences.getBoolean(\"vibrate_on_notification\", true);\n\n\t\tif (notifications.size() == 0) {\n\t\t\tnotificationManager.cancel(NOTIFICATION_ID);\n\t\t} else {\n\t\t\tif (notify) {\n\t\t\t\tthis.markLastNotification();"}
{"magic_number_smell": "\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != 0x414E4554) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n", "refactored_code": "    private static final int FILE_MAGIC = 0x414E4554;\n\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != FILE_MAGIC) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n"}
{"magic_number_smell": "\t}\n\n\tprivate int ipNumberPart() {\n\t\treturn baseProducer.randomInt(0xFF);\n\t}\n\n}", "refactored_code": "\tprivate static final int MAX = 0xFF;\n\t}\n\n\tprivate int ipNumberPart() {\n\t\treturn baseProducer.randomInt(MAX);\n\t}\n\n}"}
{"magic_number_smell": "                setId(lastItem.getItemId() + ID_PROMOTION_OFFSET);\n                itemMap.clear();\n            } else {\n                itemList = new ArrayList<CollectionItem>(1000);\n            }\n            itemMap = null;\n        }", "refactored_code": "    private static final int INITIAL_CAPACITY = 1000;\n                setId(lastItem.getItemId() + ID_PROMOTION_OFFSET);\n                itemMap.clear();\n            } else {\n                itemList = new ArrayList<CollectionItem>(INITIAL_CAPACITY);\n            }\n            itemMap = null;\n        }"}
{"magic_number_smell": "     */\n    public static String shortenPath(File file) {\n        String path = removeCWD(file);\n        if (path.length() < 12 * 2) {\n            return path;\n        }\n        return path.substring(0, 12)", "refactored_code": "    private static final int SHORTENED_PATH_LENGTH = 12;\n     */\n    public static String shortenPath(File file) {\n        String path = removeCWD(file);\n        if (path.length() < SHORTENED_PATH_LENGTH * 2) {\n            return path;\n        }\n        return path.substring(0, SHORTENED_PATH_LENGTH)"}
{"magic_number_smell": "\t\tDataOutputSerializer dos = new DataOutputSerializer(32);\n\n\t\tkeySerializer.serialize(key, dos);\n\t\tdos.writeByte(42);\n\t\tnamespaceSerializer.serialize(namespace, dos);\n\n\t\treturn dos.getCopyOfBuffer();", "refactored_code": "\tprivate static final int MAGIC_NUMBER = 42;\n\t\tDataOutputSerializer dos = new DataOutputSerializer(32);\n\n\t\tkeySerializer.serialize(key, dos);\n\t\tdos.writeByte(MAGIC_NUMBER);\n\t\tnamespaceSerializer.serialize(namespace, dos);\n\n\t\treturn dos.getCopyOfBuffer();"}
{"magic_number_smell": "            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + AlarmManager.INTERVAL_HOUR;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {", "refactored_code": "    private static final long BACKUP_INTERVAL = AlarmManager.INTERVAL_HOUR;\n            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + BACKUP_INTERVAL;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {"}
{"magic_number_smell": "                start = ratio;\n            }\n\n            endPosition = ratio.position() + 1000 - 1;\n        }\n\n        if (start != null) {", "refactored_code": "    private static final int SEGMENT_SIZE = 1000;\n                start = ratio;\n            }\n\n            endPosition = ratio.position() + SEGMENT_SIZE - 1;\n        }\n\n        if (start != null) {"}
{"magic_number_smell": "            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > 50 ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;", "refactored_code": "    private static final int INET_CONDITION_THRESHOLD = 50;\n            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;"}
{"magic_number_smell": "\n    public static int Gb( double giga )\n    {\n        return (int) giga * 1024 * 1024 * 1024;\n    }\n\n    public static int Mb( double mega )", "refactored_code": "    private static final int KILOBYTE_UNIT = 1024;\n\n    public static int Gb( double giga )\n    {\n        return (int) giga * KILOBYTE_UNIT * KILOBYTE_UNIT * KILOBYTE_UNIT;\n    }\n\n    public static int Mb( double mega )"}
{"magic_number_smell": "\n        @Override\n        public List<Pos2d> getItemInputPositions(int itemInputCount) {\n            return UIHelper.getGridPositions(itemInputCount, 16, yOrigin, 3);\n        }\n\n        @Override", "refactored_code": "        private static final int xDirMaxCount = 3;\n\n        @Override\n        public List<Pos2d> getItemInputPositions(int itemInputCount) {\n            return UIHelper.getGridPositions(itemInputCount, 16, yOrigin, xDirMaxCount);\n        }\n\n        @Override"}
{"magic_number_smell": "  }\n\n  public RecyclerBinder(ComponentContext c) {\n    this(c, 4f, new LinearLayoutInfo(c, VERTICAL, false), null, false, false);\n  }\n\n  public RecyclerBinder(ComponentContext c, LayoutInfo layoutInfo) {", "refactored_code": "  public static final float DEFAULT_RANGE_RATIO = 4f;\n  }\n\n  public RecyclerBinder(ComponentContext c) {\n    this(c, DEFAULT_RANGE_RATIO, new LinearLayoutInfo(c, VERTICAL, false), null, false, false);\n  }\n\n  public RecyclerBinder(ComponentContext c, LayoutInfo layoutInfo) {"}
{"magic_number_smell": "\t\t// header\r\n\t\tByteBuffer buffer = ByteBuffer.allocate(SIZEOF_INT + SIZEOF_INT + SIZEOF_INT);\r\n\r\n\t\tbuffer.putInt(0xC0DEDEA1);\r\n\t\tbuffer.putInt(currentVersion);\r\n\t\tbuffer.putInt(length);\r\n\t\ttarget.write(buffer.array());\r", "refactored_code": "\tprivate final int byteOrder = 0xC0DEDEA1;\r\n\t\t// header\r\n\t\tByteBuffer buffer = ByteBuffer.allocate(SIZEOF_INT + SIZEOF_INT + SIZEOF_INT);\r\n\r\n\t\tbuffer.putInt(byteOrder);\r\n\t\tbuffer.putInt(currentVersion);\r\n\t\tbuffer.putInt(length);\r\n\t\ttarget.write(buffer.array());\r"}
{"magic_number_smell": "        glfwSetScrollCallback(context.getWindowHandle(), scrollCallback = new GLFWScrollCallback() {\n            @Override\n            public void invoke(final long window, final double xOffset, final double yOffset) {\n                onWheelScroll(window, xOffset, yOffset * 120);\n            }\n        });\n", "refactored_code": "    private static final int WHEEL_SCALE = 120;\n        glfwSetScrollCallback(context.getWindowHandle(), scrollCallback = new GLFWScrollCallback() {\n            @Override\n            public void invoke(final long window, final double xOffset, final double yOffset) {\n                onWheelScroll(window, xOffset, yOffset * WHEEL_SCALE);\n            }\n        });\n"}
{"magic_number_smell": "    Filter orFilter = FilterFactory.or(andFilter, TimeFilter.eq(1000L));\n\n    long startTime = System.currentTimeMillis();\n    for (long i = 0; i < 10000000; i++) {\n      orFilter.satisfy(i, i + 0.1);\n    }\n    long endTime = System.currentTimeMillis();", "refactored_code": "  private static final long EFFICIENCY_TEST_COUNT = 10000000;\n    Filter orFilter = FilterFactory.or(andFilter, TimeFilter.eq(1000L));\n\n    long startTime = System.currentTimeMillis();\n    for (long i = 0; i < EFFICIENCY_TEST_COUNT; i++) {\n      orFilter.satisfy(i, i + 0.1);\n    }\n    long endTime = System.currentTimeMillis();"}
{"magic_number_smell": "\t\t\t\tattrib.type = Attribute.ELF_TYPE_CORE;\n\t\t\t\tbreak;\n            case Elf.ELFhdr.ET_EXEC:\n                attrib.type = Attribute.1;\n                break;\n            case Elf.ELFhdr.ET_REL:\n                attrib.type = Attribute.ELF_TYPE_OBJ;", "refactored_code": "\t\tpublic static final int ELF_TYPE_EXE   = 1;\n\t\t\t\tattrib.type = Attribute.ELF_TYPE_CORE;\n\t\t\t\tbreak;\n            case Elf.ELFhdr.ET_EXEC:\n                attrib.type = Attribute.ELF_TYPE_EXE;\n                break;\n            case Elf.ELFhdr.ET_REL:\n                attrib.type = Attribute.ELF_TYPE_OBJ;"}
{"magic_number_smell": "            }\n            if (event.getSource() == pt.getSelectionModel() && pt.getRowSelectionAllowed()) {\n                final int selectedRows = pt.getSelectedRowCount();\n                if (selectedRows >= 2) {\n                    PokemonGoMainWindow.window.setTitle(selectedRows + \" Pok\u00e9mon selected\");\n                } else {\n                    PokemonGoMainWindow.window.refreshTitle();", "refactored_code": "    private static final int WHEN_TO_SHOW_SELECTION_TITLE = 2;\n            }\n            if (event.getSource() == pt.getSelectionModel() && pt.getRowSelectionAllowed()) {\n                final int selectedRows = pt.getSelectedRowCount();\n                if (selectedRows >= WHEN_TO_SHOW_SELECTION_TITLE) {\n                    PokemonGoMainWindow.window.setTitle(selectedRows + \" Pok\u00e9mon selected\");\n                } else {\n                    PokemonGoMainWindow.window.refreshTitle();"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "     */\n    private static Integer fetchDruidResponseTimeOut(String timeOutSysProp) {\n        try {\n            return SYSTEM_CONFIG.getIntProperty(timeOutSysProp, Math.toIntExact(TimeUnit.MINUTES.toMillis(10)));\n        } catch (SystemConfigException e) {\n            LOG.error(e.getMessage(), e);\n            throw new RuntimeException(e.getMessage(), e);", "refactored_code": "    private static final int DRUID_REQUEST_TIMEOUT_DEFAULT = Math.toIntExact(TimeUnit.MINUTES.toMillis(10));\n     */\n    private static Integer fetchDruidResponseTimeOut(String timeOutSysProp) {\n        try {\n            return SYSTEM_CONFIG.getIntProperty(timeOutSysProp, DRUID_REQUEST_TIMEOUT_DEFAULT);\n        } catch (SystemConfigException e) {\n            LOG.error(e.getMessage(), e);\n            throw new RuntimeException(e.getMessage(), e);"}
{"magic_number_smell": "            {\n                weekdayCount++;\n            }\n            startMs += 86400000;\n        }\n        return weekdayCount;\n    }", "refactored_code": "    public static final long MS_IN_DAY = 86400000;\n            {\n                weekdayCount++;\n            }\n            startMs += MS_IN_DAY;\n        }\n        return weekdayCount;\n    }"}
{"magic_number_smell": "\tpublic static final int DEBUG = 256;\n\n\tprivate static final String IJ_X=\"ij.x\",IJ_Y=\"ij.y\";\n\tprivate static int port = 57294;\n\tprivate static String[] arguments;\n\t\n\tprivate Toolbar toolbar;", "refactored_code": "\tpublic static final int DEFAULT_PORT = 57294;\n\tpublic static final int DEBUG = 256;\n\n\tprivate static final String IJ_X=\"ij.x\",IJ_Y=\"ij.y\";\n\tprivate static int port = DEFAULT_PORT;\n\tprivate static String[] arguments;\n\t\n\tprivate Toolbar toolbar;"}
{"magic_number_smell": "\n    private Paint paint;\n    private int viewWidth;\n    private int textSize = 20;\n    private int textColorNormal = TEXT_COLOR_NORMAL;\n    private int textColorFocus = TEXT_COLOR_FOCUS;\n    private int lineColor = LINE_COLOR;", "refactored_code": "    public static final int TEXT_SIZE = 20;\n\n    private Paint paint;\n    private int viewWidth;\n    private int textSize = TEXT_SIZE;\n    private int textColorNormal = TEXT_COLOR_NORMAL;\n    private int textColorFocus = TEXT_COLOR_FOCUS;\n    private int lineColor = LINE_COLOR;"}
{"magic_number_smell": "\tprivate static final BlendMode[] BLEND_MODES = BlendMode.values();\n\n\tprivate static final int MathHelper.smallestEncompassingPowerOfTwo(BlendMode.values().length) - 1 = MathHelper.smallestEncompassingPowerOfTwo(BlendMode.values().length) - 1;\n\tprivate static final int COLOR_DISABLE_FLAG = MathHelper.smallestEncompassingPowerOfTwo(BlendMode.values().length) - 1 + 1;\n\tprivate static final int EMISSIVE_FLAG = COLOR_DISABLE_FLAG << 1;\n\tprivate static final int DIFFUSE_FLAG = EMISSIVE_FLAG << 1;\n\tprivate static final int AO_FLAG = DIFFUSE_FLAG << 1;", "refactored_code": "\tprivate static final int BLEND_MODE_MASK = MathHelper.smallestEncompassingPowerOfTwo(BlendMode.values().length) - 1;\n\tprivate static final BlendMode[] BLEND_MODES = BlendMode.values();\n\n\tprivate static final int BLEND_MODE_MASK = MathHelper.smallestEncompassingPowerOfTwo(BlendMode.values().length) - 1;\n\tprivate static final int COLOR_DISABLE_FLAG = BLEND_MODE_MASK + 1;\n\tprivate static final int EMISSIVE_FLAG = COLOR_DISABLE_FLAG << 1;\n\tprivate static final int DIFFUSE_FLAG = EMISSIVE_FLAG << 1;\n\tprivate static final int AO_FLAG = DIFFUSE_FLAG << 1;"}
{"magic_number_smell": "\t\tsuper(width, height, cm);\n\t\tpath = IJ.addSeparator(path);\n\t\tthis.path = path;\n\t\tnames = new String[100];\n\t\tlabels = new String[100];\n\t}\n", "refactored_code": "\tprivate static final int INITIAL_SIZE = 100;\n\t\tsuper(width, height, cm);\n\t\tpath = IJ.addSeparator(path);\n\t\tthis.path = path;\n\t\tnames = new String[INITIAL_SIZE];\n\t\tlabels = new String[INITIAL_SIZE];\n\t}\n"}
{"magic_number_smell": "\t\tif (null != startName)\n\t\t\t_doCallbacks = false;\n\t\t_decoder = new BinaryXMLDecoder();\n\t\t_decoder.setInitialBufferSize(756);\n\t}\n\t\n\t/**", "refactored_code": "\tpublic static final int DECODER_SIZE = 756;\n\t\tif (null != startName)\n\t\t\t_doCallbacks = false;\n\t\t_decoder = new BinaryXMLDecoder();\n\t\t_decoder.setInitialBufferSize(DECODER_SIZE);\n\t}\n\t\n\t/**"}
{"magic_number_smell": "            out.write((b2 << MASK_4BITS) | (b3 >> MASK_2BITS));\n            out.write((b3 << MASK_6BITS) | b4);\n\n            outLen += 3;\n        }\n\n        if (data[end - MASK_2BITS] == PADDING) {", "refactored_code": "    private static final int BYTES_PER_UNENCODED_BLOCK = 3;\n            out.write((b2 << MASK_4BITS) | (b3 >> MASK_2BITS));\n            out.write((b3 << MASK_6BITS) | b4);\n\n            outLen += BYTES_PER_UNENCODED_BLOCK;\n        }\n\n        if (data[end - MASK_2BITS] == PADDING) {"}
{"magic_number_smell": "\t */\n\tpublic void startEarthTimer() {\n\t\t// Set up earth time text update\n\t\ttimeLabeltimer = new Timeline(new KeyFrame(Duration.millis(SettlementWindow.TIME_DELAY), ae -> updateTimeLabels()));\n\t\t// Note: Infinite Timeline might result in a memory leak if not stopped\n\t\t// properly.\n\t\t// All the objects with animated properties would not be garbage collected.", "refactored_code": "\tprivate static final int TIME_DELAY = SettlementWindow.TIME_DELAY;\n\t */\n\tpublic void startEarthTimer() {\n\t\t// Set up earth time text update\n\t\ttimeLabeltimer = new Timeline(new KeyFrame(Duration.millis(TIME_DELAY), ae -> updateTimeLabels()));\n\t\t// Note: Infinite Timeline might result in a memory leak if not stopped\n\t\t// properly.\n\t\t// All the objects with animated properties would not be garbage collected."}
{"magic_number_smell": "\n                // where\n                //     shipdate <= '1998-09-02'\n                if (shipDate <= DateTimeUtils.parseDate(\"1998-09-02\")) {\n                    //     returnflag,\n                    //     linestatus\n                    //     quantity", "refactored_code": "        private static final int MAX_SHIP_DATE = DateTimeUtils.parseDate(\"1998-09-02\");\n\n                // where\n                //     shipdate <= '1998-09-02'\n                if (shipDate <= MAX_SHIP_DATE) {\n                    //     returnflag,\n                    //     linestatus\n                    //     quantity"}
{"magic_number_smell": "\t * into a combined string or regex.\n\t */\n\tpublic static class SortedHeaderMap extends TreeMap<String, String> {\n\t\tprivate static final long -3998102753945339020L = -5090333053981045429L;\n\t\tString headers = null;\n\n\t\tpublic SortedHeaderMap() {", "refactored_code": "\t\t\t\t\tprivate static final long serialVersionUID = -3998102753945339020L;\n\t * into a combined string or regex.\n\t */\n\tpublic static class SortedHeaderMap extends TreeMap<String, String> {\n\t\tprivate static final long serialVersionUID = -5090333053981045429L;\n\t\tString headers = null;\n\n\t\tpublic SortedHeaderMap() {"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "\n            outputStream.finish();\n            long takeTime = System.currentTimeMillis() - start;\n            if (takeTime > 50) {\n                LOGGER.info(\"Compressing takes {}ms\", takeTime);\n            }\n            return byteArrayOutputStream.toByteArray();", "refactored_code": "    private static final long MINIMUM_TAKE_TIME_MILLISECOND = 50;\n\n            outputStream.finish();\n            long takeTime = System.currentTimeMillis() - start;\n            if (takeTime > MINIMUM_TAKE_TIME_MILLISECOND) {\n                LOGGER.info(\"Compressing takes {}ms\", takeTime);\n            }\n            return byteArrayOutputStream.toByteArray();"}
{"magic_number_smell": "    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #-1}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode", "refactored_code": "    public static final int INFINITE = -1;\n    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #INFINITE}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode"}
{"magic_number_smell": "        String version = \"\" + ((char) magic[4]) + ((char) magic[5]) +((char) magic[6]);\n\n        if (version.equals(VERSION_CURRENT)) {\n            return 14;\n        } else if (version.equals(VERSION_FOR_API_13)) {\n            return 13;\n        }", "refactored_code": "    public static final int API_CURRENT = 14;\n        String version = \"\" + ((char) magic[4]) + ((char) magic[5]) +((char) magic[6]);\n\n        if (version.equals(VERSION_CURRENT)) {\n            return API_CURRENT;\n        } else if (version.equals(VERSION_FOR_API_13)) {\n            return 13;\n        }"}
{"magic_number_smell": "                        updateMetaServer();\n                    } catch (NoRouteToServerException e) {}\n                }\n            }, 60000, 60000);\n    }\n\n    /**", "refactored_code": "    private static final int META_SERVER_UPDATE_INTERVAL = 60000;\n                        updateMetaServer();\n                    } catch (NoRouteToServerException e) {}\n                }\n            }, META_SERVER_UPDATE_INTERVAL, META_SERVER_UPDATE_INTERVAL);\n    }\n\n    /**"}
{"magic_number_smell": "\n\t/**\n\t * GetLatestVersion attempt timeout.\n\t * TODO  This timeout is set to 1000 to work around the problem\n\t * in ccnd where some interests take >300ms (and sometimes longer, have seen periodic delays >800ms)\n\t * when that bug is found and fixed, this can be reduced back to the SHORT_TIMEOUT.\n\t * long attemptTimeout = SystemConfiguration.SHORT_TIMEOUT;", "refactored_code": "\tpublic static final long MEDIUM_TIMEOUT = 1000;\n\n\t/**\n\t * GetLatestVersion attempt timeout.\n\t * TODO  This timeout is set to MEDIUM_TIMEOUT to work around the problem\n\t * in ccnd where some interests take >300ms (and sometimes longer, have seen periodic delays >800ms)\n\t * when that bug is found and fixed, this can be reduced back to the SHORT_TIMEOUT.\n\t * long attemptTimeout = SystemConfiguration.SHORT_TIMEOUT;"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "  /** Returns the name of the given codec. */\n  public static String getCodecName(int codec) {\n    switch (codec) {\n      case 1:\n        return \"Uncompressed\";\n      case CCITT_1D:\n        return \"CCITT Group 3 1-Dimensional Modified Huffman\";", "refactored_code": "  public static final int UNCOMPRESSED = 1;\n  /** Returns the name of the given codec. */\n  public static String getCodecName(int codec) {\n    switch (codec) {\n      case UNCOMPRESSED:\n        return \"Uncompressed\";\n      case CCITT_1D:\n        return \"CCITT Group 3 1-Dimensional Modified Huffman\";"}
{"magic_number_smell": "        if (minCapacity > cache.length) {\n            int oldCapacity = cache.length;\n            BigDecimal oldCache[] = cache;\n            int newCapacity = oldCapacity + 5;\n            if (newCapacity < minCapacity) {\n                newCapacity = minCapacity;\n            }", "refactored_code": "    public static final int CAPACITY_BUMP_SIZE = 5;\n        if (minCapacity > cache.length) {\n            int oldCapacity = cache.length;\n            BigDecimal oldCache[] = cache;\n            int newCapacity = oldCapacity + CAPACITY_BUMP_SIZE;\n            if (newCapacity < minCapacity) {\n                newCapacity = minCapacity;\n            }"}
{"magic_number_smell": "\r\n\t\tBlockFile.pageSeek(bf.file, skipPage);\r\n\t\tlong magic = bf.file.readLong();\r\n\t\tif (magic != 0x536b69704c697374l)\r\n\t\t\tthrow new IOException(\"Bad SkipList magic number 0x\" + Long.toHexString(magic) + \" on page \" + skipPage);\r\n\t\tfirstSpanPage = bf.file.readUnsignedInt();\r\n\t\tfirstLevelPage = bf.file.readUnsignedInt();\r", "refactored_code": "\tprivate static final long MAGIC = 0x536b69704c697374l;  // \"SkipList\"\r\n\r\n\t\tBlockFile.pageSeek(bf.file, skipPage);\r\n\t\tlong magic = bf.file.readLong();\r\n\t\tif (magic != MAGIC)\r\n\t\t\tthrow new IOException(\"Bad SkipList magic number 0x\" + Long.toHexString(magic) + \" on page \" + skipPage);\r\n\t\tfirstSpanPage = bf.file.readUnsignedInt();\r\n\t\tfirstLevelPage = bf.file.readUnsignedInt();\r"}
{"magic_number_smell": "     */\n    @SuppressWarnings(\"unused\")\n    public static int gsPasswordDeadline() {\n        return 90;\n    }\n    \n    /**", "refactored_code": "    private static final int DEFAULT_PASSWORD_DEADLINE = 90;\n     */\n    @SuppressWarnings(\"unused\")\n    public static int gsPasswordDeadline() {\n        return DEFAULT_PASSWORD_DEADLINE;\n    }\n    \n    /**"}
{"magic_number_smell": "        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+5*1000) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }", "refactored_code": "    private static final long MIN_TIME_BETWEEN_GCS = 5*1000;\n        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+MIN_TIME_BETWEEN_GCS) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }"}
{"magic_number_smell": "  }\n\n  private void serializeFooter(RedelmMetaData footer, OutputStream os) throws IOException {\n    parquet.format.FileMetaData parquetMetadata = new ParquetMetadataConverter().toParquetMetadata(1, footer);\n    metadataConverter.writeFileMetaData(parquetMetadata, os);\n  }\n", "refactored_code": "  public static final int CURRENT_VERSION = 1;\n  }\n\n  private void serializeFooter(RedelmMetaData footer, OutputStream os) throws IOException {\n    parquet.format.FileMetaData parquetMetadata = new ParquetMetadataConverter().toParquetMetadata(CURRENT_VERSION, footer);\n    metadataConverter.writeFileMetaData(parquetMetadata, os);\n  }\n"}
{"magic_number_smell": "\tpublic static Mac _AESKeyMac;\n\tpublic static String _AESKeyAlgorithm = MAC_ALGORITHM;\n\t\n\tprotected static DERInteger _version = new DERInteger(1);\n\t\n\tprotected byte[] _id = null;\n\tprotected KeyStore.Entry _ourEntry = null;", "refactored_code": "\tpublic static final int VERSION = 1;\n\tpublic static Mac _AESKeyMac;\n\tpublic static String _AESKeyAlgorithm = MAC_ALGORITHM;\n\t\n\tprotected static DERInteger _version = new DERInteger(VERSION);\n\t\n\tprotected byte[] _id = null;\n\tprotected KeyStore.Entry _ourEntry = null;"}
{"magic_number_smell": "    if (metersPerSecond < 10.0) {\n      return DoubleUtils.roundTo1Decimal(metersPerSecond);\n    }\n    if (metersPerSecond > 340.0) {\n      throw new IllegalArgumentException(\n        \"Are you flying in supersonic speed: \" + metersPerSecond + \" m/s\"\n      );", "refactored_code": "  private static final double ONE_MACH = 340.0;\n    if (metersPerSecond < 10.0) {\n      return DoubleUtils.roundTo1Decimal(metersPerSecond);\n    }\n    if (metersPerSecond > ONE_MACH) {\n      throw new IllegalArgumentException(\n        \"Are you flying in supersonic speed: \" + metersPerSecond + \" m/s\"\n      );"}
{"magic_number_smell": "      }\n    }\n\n    int count = 20;\n    if (StringUtils.isNotEmpty(countString)) {\n      try {\n        count = Integer.parseInt(countString);", "refactored_code": "  private static final int DEFAULT_LIMIT = 20;\n      }\n    }\n\n    int count = DEFAULT_LIMIT;\n    if (StringUtils.isNotEmpty(countString)) {\n      try {\n        count = Integer.parseInt(countString);"}
{"magic_number_smell": "                    maxPartialMemory,\n                    spillEnabled,\n                    unspillMemoryLimit,\n                    DataSize.succinctBytes((long) (unspillMemoryLimit.toBytes() * 0.9)),\n                    spillerFactory,\n                    joinCompiler);\n        }", "refactored_code": "    private static final double MERGE_WITH_MEMORY_RATIO = 0.9;\n                    maxPartialMemory,\n                    spillEnabled,\n                    unspillMemoryLimit,\n                    DataSize.succinctBytes((long) (unspillMemoryLimit.toBytes() * MERGE_WITH_MEMORY_RATIO)),\n                    spillerFactory,\n                    joinCompiler);\n        }"}
{"magic_number_smell": "    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);"}
{"magic_number_smell": "    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);"}
{"magic_number_smell": "      timeSpentInFootstepPlanner = new YoDouble(\"timeSpentInFootstepPlanner\", registry);\n      yoResult = new YoEnum<>(\"planningResult\", registry, FootstepPlanningResult.class);\n\n      timeout.set(5.0);\n      visualizing = graphicsListRegistry != null;\n      if (visualizing)\n      {", "refactored_code": "   private static final double defaultTimeout = 5.0;\n      timeSpentInFootstepPlanner = new YoDouble(\"timeSpentInFootstepPlanner\", registry);\n      yoResult = new YoEnum<>(\"planningResult\", registry, FootstepPlanningResult.class);\n\n      timeout.set(defaultTimeout);\n      visualizing = graphicsListRegistry != null;\n      if (visualizing)\n      {"}
{"magic_number_smell": "            int minor, int access_flags, ConstantPool constant_pool, int[] interfaces,\n            Field[] fields, Method[] methods, Attribute[] attributes) {\n        this(class_name_index, superclass_name_index, file_name, major, minor, access_flags,\n                constant_pool, interfaces, fields, methods, attributes, 1);\n    }\n\n", "refactored_code": "    public static final byte HEAP = 1;\n            int minor, int access_flags, ConstantPool constant_pool, int[] interfaces,\n            Field[] fields, Method[] methods, Attribute[] attributes) {\n        this(class_name_index, superclass_name_index, file_name, major, minor, access_flags,\n                constant_pool, interfaces, fields, methods, attributes, HEAP);\n    }\n\n"}
{"magic_number_smell": "            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + AlarmManager.INTERVAL_HOUR;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {", "refactored_code": "    private static final long BACKUP_INTERVAL = AlarmManager.INTERVAL_HOUR;\n            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + BACKUP_INTERVAL;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {"}
{"magic_number_smell": "     * (<code>CRLFCRLF</code>).\n     */\n    protected static final byte[] HEADER_SEPARATOR = {\n            0x0D, LF, 0x0D, LF };\n\n\n    /**", "refactored_code": "    public static final byte CR = 0x0D;\n     * (<code>CRLFCRLF</code>).\n     */\n    protected static final byte[] HEADER_SEPARATOR = {\n            CR, LF, CR, LF };\n\n\n    /**"}
{"magic_number_smell": "    private JPanel changingPanel;\n    private JPanel manuPanel;\n    private JPanel autoPanel;\n    private int maxXPos = -10;\n    private int maxPort;\n    private int portCnt;\n    private int anonCnt;", "refactored_code": "    private static final int X_OFFSET = 10;\n    private JPanel changingPanel;\n    private JPanel manuPanel;\n    private JPanel autoPanel;\n    private int maxXPos = -X_OFFSET;\n    private int maxPort;\n    private int portCnt;\n    private int anonCnt;"}
{"magic_number_smell": "        assertEquals(1, failureFlowFiles.size());\n        validateFlowFiles(failureFlowFiles);\n        // We expect the same number of records to come out no matter the granularity\n        assertEquals(1053, validateFlowFiles(failureFlowFiles));\n\n        // Whole file fails if there is a failure parsing\n        List<MockFlowFile> successFlowFiles = testRunner.getFlowFilesForRelationship(ParseEvtx.REL_SUCCESS);", "refactored_code": "    public static final int EXPECTED_SUCCESSFUL_EVENT_COUNT = 1053;\n        assertEquals(1, failureFlowFiles.size());\n        validateFlowFiles(failureFlowFiles);\n        // We expect the same number of records to come out no matter the granularity\n        assertEquals(EXPECTED_SUCCESSFUL_EVENT_COUNT, validateFlowFiles(failureFlowFiles));\n\n        // Whole file fails if there is a failure parsing\n        List<MockFlowFile> successFlowFiles = testRunner.getFlowFilesForRelationship(ParseEvtx.REL_SUCCESS);"}
{"magic_number_smell": "\tprotected Feeling feeling = Feeling.UNDEFINED;\n\n\tpublic int entrance;\n\tpublic int compassTarget = -1;\t// Where compass should point\n\n\tprivate HashMap<Integer, Integer> exitMap = new HashMap<>();\n", "refactored_code": "\tprivate static final int INVALID_CELL = -1;\n\tprotected Feeling feeling = Feeling.UNDEFINED;\n\n\tpublic int entrance;\n\tpublic int compassTarget = INVALID_CELL;\t// Where compass should point\n\n\tprivate HashMap<Integer, Integer> exitMap = new HashMap<>();\n"}
{"magic_number_smell": "                            .setCancelable(true)\n                            .setPositiveButton(R.string.permission_dialog_setting, new DialogInterface.OnClickListener() {\n                                public void onClick(DialogInterface dialog, int id) {\n                                    IntentUtils.intentOpenSettings(activity, 39528);\n                                }\n                            })\n                            .setNegativeButton(R.string.permission_dialog_not_now, new DialogInterface.OnClickListener() {", "refactored_code": "    private static final int REQUEST_SETTINGS = 39528;\n                            .setCancelable(true)\n                            .setPositiveButton(R.string.permission_dialog_setting, new DialogInterface.OnClickListener() {\n                                public void onClick(DialogInterface dialog, int id) {\n                                    IntentUtils.intentOpenSettings(activity, REQUEST_SETTINGS);\n                                }\n                            })\n                            .setNegativeButton(R.string.permission_dialog_not_now, new DialogInterface.OnClickListener() {"}
{"magic_number_smell": "    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #-1}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode", "refactored_code": "    public static final int INFINITE = -1;\n    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #INFINITE}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode"}
{"magic_number_smell": "                public Integer call() {\n                    eventsMonitor.updateEvents();\n                    eventPreferences.markEventsAsInitialised();\n                    return 5;\n                }\n            })\n                    .subscribe();", "refactored_code": "    private static final int A_NUMBER = 5;\n                public Integer call() {\n                    eventsMonitor.updateEvents();\n                    eventPreferences.markEventsAsInitialised();\n                    return A_NUMBER;\n                }\n            })\n                    .subscribe();"}
{"magic_number_smell": "     */\n    public void write(int b) throws IOException {\n        byte[] buff = new byte[1];\n        buff[0] = (byte) (b & 0xFF);\n        write(buff, 0, 1);\n    }\n", "refactored_code": "    private static final int BYTE_MASK = 0xFF;\n     */\n    public void write(int b) throws IOException {\n        byte[] buff = new byte[1];\n        buff[0] = (byte) (b & BYTE_MASK);\n        write(buff, 0, 1);\n    }\n"}
{"magic_number_smell": "\n        int minor = stream.readUnsignedShort();\n        int major = stream.readUnsignedShort();\n        if (major < 51 || major > MAJOR_VERSION_JAVA9) {\n            throw new UnsupportedClassVersionError(\"Unsupported class file version: \" + major + \".\" + minor);\n        }\n", "refactored_code": "    private static final int MAJOR_VERSION_JAVA7 = 51;\n\n        int minor = stream.readUnsignedShort();\n        int major = stream.readUnsignedShort();\n        if (major < MAJOR_VERSION_JAVA7 || major > MAJOR_VERSION_JAVA9) {\n            throw new UnsupportedClassVersionError(\"Unsupported class file version: \" + major + \".\" + minor);\n        }\n"}
{"magic_number_smell": "\tprotected long _timeout = SystemConfiguration.FC_TIMEOUT;\n\tprotected long _timeoutToUse = SystemConfiguration.FC_TIMEOUT;\n\n\tprotected int _capacity = CCNSegmenter.HOLD_COUNT + 1;\n\n\t// Value used to determine whether the buffer is draining in waitForPutDrain\n\tprotected long _nOut = 0;", "refactored_code": "\tprotected static final int DEFAULT_CAPACITY = CCNSegmenter.HOLD_COUNT + 1;\n\tprotected long _timeout = SystemConfiguration.FC_TIMEOUT;\n\tprotected long _timeoutToUse = SystemConfiguration.FC_TIMEOUT;\n\n\tprotected int _capacity = DEFAULT_CAPACITY;\n\n\t// Value used to determine whether the buffer is draining in waitForPutDrain\n\tprotected long _nOut = 0;"}
{"magic_number_smell": "\tString getName(int tag) {\n\t\tString name;\n\t\tswitch (tag) {\n\t\t\tcase 254: name=\"NewSubfileType\"; break;\n\t\t\tcase IMAGE_WIDTH: name=\"ImageWidth\"; break;\n\t\t\tcase IMAGE_LENGTH: name=\"ImageLength\"; break;\n\t\t\tcase STRIP_OFFSETS: name=\"StripOffsets\"; break;", "refactored_code": "\tpublic static final int NEW_SUBFILE_TYPE = 254;\n\tString getName(int tag) {\n\t\tString name;\n\t\tswitch (tag) {\n\t\t\tcase NEW_SUBFILE_TYPE: name=\"NewSubfileType\"; break;\n\t\t\tcase IMAGE_WIDTH: name=\"ImageWidth\"; break;\n\t\t\tcase IMAGE_LENGTH: name=\"ImageLength\"; break;\n\t\t\tcase STRIP_OFFSETS: name=\"StripOffsets\"; break;"}
{"magic_number_smell": "    private static final String BASE56_DECODE = \"23456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz\";\n    private static final int 56 = 56;\n    private static final int CHARS_PER_LINE = 19;\n    private static final BigInteger BASE = BigInteger.valueOf(56);\n\n    public static byte[] combine(byte[] a, byte b) {\n        return combine(a, new byte[] {b});", "refactored_code": "    private static final int BASE_INT = 56;\n    private static final String BASE56_DECODE = \"23456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz\";\n    private static final int BASE_INT = 56;\n    private static final int CHARS_PER_LINE = 19;\n    private static final BigInteger BASE = BigInteger.valueOf(BASE_INT);\n\n    public static byte[] combine(byte[] a, byte b) {\n        return combine(a, new byte[] {b});"}
{"magic_number_smell": "        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+5*1000) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }", "refactored_code": "    private static final long MIN_TIME_BETWEEN_GCS = 5*1000;\n        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+MIN_TIME_BETWEEN_GCS) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }"}
{"magic_number_smell": "                    copyTextPaint,\n                    copyWidthForDropCap,\n                    Layout.Alignment.ALIGN_NORMAL,\n                    1.0f,\n                    lineSpacingExtra,\n                    true\n            );", "refactored_code": "    private static final float SPACING_MULTIPLIER = 1.0f;\n                    copyTextPaint,\n                    copyWidthForDropCap,\n                    Layout.Alignment.ALIGN_NORMAL,\n                    SPACING_MULTIPLIER,\n                    lineSpacingExtra,\n                    true\n            );"}
{"magic_number_smell": "            case TYPE_MC:\n                squishVanillaUncompressed(nbt, new DataOutputStream(stream));\n                return;\n            case NbtSquishConstants.VANILLA_COMPRESSED:\n                squishVanilla(nbt, stream);\n                return;\n            case TYPE_BC_1:", "refactored_code": "    private static final int TYPE_MC_GZIP = NbtSquishConstants.VANILLA_COMPRESSED;\n            case TYPE_MC:\n                squishVanillaUncompressed(nbt, new DataOutputStream(stream));\n                return;\n            case TYPE_MC_GZIP:\n                squishVanilla(nbt, stream);\n                return;\n            case TYPE_BC_1:"}
{"magic_number_smell": "            return;\n        }\n        \n        this.isPanelsCollapsed = bundle.responses.size() > 500;\n        \n        switch (viewType) {\n            case RECIPIENT_GIVER_QUESTION:", "refactored_code": "    private static final int RESPONSE_LIMIT_FOR_COLLAPSING_PANEL = 500;\n            return;\n        }\n        \n        this.isPanelsCollapsed = bundle.responses.size() > RESPONSE_LIMIT_FOR_COLLAPSING_PANEL;\n        \n        switch (viewType) {\n            case RECIPIENT_GIVER_QUESTION:"}
{"magic_number_smell": "\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != 0x414E4554) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n", "refactored_code": "    private static final int FILE_MAGIC = 0x414E4554;\n\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != FILE_MAGIC) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n"}
{"magic_number_smell": "    static {\n        // Initialise as all invalid characters\n        for (int i = 0; i < DECODING_TABLE.length; i++) {\n            DECODING_TABLE[i] = -1;\n        }\n        // set up valid characters\n        for (int i = 0; i < ENCODING_TABLE.length; i++) {", "refactored_code": "    private static final int INVALID_BYTE = -1; // must be outside range 0-63\n    static {\n        // Initialise as all invalid characters\n        for (int i = 0; i < DECODING_TABLE.length; i++) {\n            DECODING_TABLE[i] = INVALID_BYTE;\n        }\n        // set up valid characters\n        for (int i = 0; i < ENCODING_TABLE.length; i++) {"}
{"magic_number_smell": "\t\t\t\t\t\t.color(0.5F, 0.5F, 0.5F, 1F)\n\t\t\t\t\t\t.endVertex();\n\t\t\t\tbuffer.pos(width, 24F, 0F)\n\t\t\t\t\t\t.tex(width / 32.0F, 0.75F)\n\t\t\t\t\t\t.color(0.5F, 0.5F, 0.5F, 1F)\n\t\t\t\t\t\t.endVertex();\n\t\t\t\tbuffer.pos(width, 8F, 0F)", "refactored_code": "\tprivate static final float backgroundScale = 32.0F;\n\t\t\t\t\t\t.color(0.5F, 0.5F, 0.5F, 1F)\n\t\t\t\t\t\t.endVertex();\n\t\t\t\tbuffer.pos(width, 24F, 0F)\n\t\t\t\t\t\t.tex(width / backgroundScale, 0.75F)\n\t\t\t\t\t\t.color(0.5F, 0.5F, 0.5F, 1F)\n\t\t\t\t\t\t.endVertex();\n\t\t\t\tbuffer.pos(width, 8F, 0F)"}
{"magic_number_smell": "            canvas.showColonyPanel((Colony) unit.getTile().getSettlement());\n        } else if (unit.getMovesLeft() <= 0) {\t\n            //Perform a short pause on an active unit's last move, if the option is enabled.\n            if (freeColClient.getClientOptions().getBoolean(ClientOptions.300)) {\n                canvas.paintImmediately(canvas.getBounds());\n                try {\n                    //300 is an instance variable located at the top of this class.", "refactored_code": "    private final short UNIT_LAST_MOVE_DELAY = 300;\n            canvas.showColonyPanel((Colony) unit.getTile().getSettlement());\n        } else if (unit.getMovesLeft() <= 0) {\t\n            //Perform a short pause on an active unit's last move, if the option is enabled.\n            if (freeColClient.getClientOptions().getBoolean(ClientOptions.UNIT_LAST_MOVE_DELAY)) {\n                canvas.paintImmediately(canvas.getBounds());\n                try {\n                    //UNIT_LAST_MOVE_DELAY is an instance variable located at the top of this class."}
{"magic_number_smell": "            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + AlarmManager.INTERVAL_HOUR;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {", "refactored_code": "    private static final long BACKUP_INTERVAL = AlarmManager.INTERVAL_HOUR;\n            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + BACKUP_INTERVAL;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {"}
{"magic_number_smell": "        inflater.inflate(R.menu.menu_sort_albums, menu);\n        inflater.inflate(R.menu.menu_view_as, menu);\n\n        menu.addSubMenu(0, 100, 0, R.string.menu_grid_size);\n        SubMenu subMenu = menu.findItem(100).getSubMenu();\n\n        int[] spanCountArray = getResources().getIntArray(R.array.span_count);", "refactored_code": "    private static final int MENU_GRID_SIZE = 100;\n        inflater.inflate(R.menu.menu_sort_albums, menu);\n        inflater.inflate(R.menu.menu_view_as, menu);\n\n        menu.addSubMenu(0, MENU_GRID_SIZE, 0, R.string.menu_grid_size);\n        SubMenu subMenu = menu.findItem(MENU_GRID_SIZE).getSubMenu();\n\n        int[] spanCountArray = getResources().getIntArray(R.array.span_count);"}
{"magic_number_smell": "    private final ScheduledExecutorService scheduledExecutorService;\n\n    public JsonRpc2_0Neow3j(Neow3jService neow3jService) {\n        this(neow3jService, 15 * 1000, Async.defaultExecutorService());\n    }\n\n    public JsonRpc2_0Neow3j(", "refactored_code": "    public static final int DEFAULT_BLOCK_TIME = 15 * 1000;\n    private final ScheduledExecutorService scheduledExecutorService;\n\n    public JsonRpc2_0Neow3j(Neow3jService neow3jService) {\n        this(neow3jService, DEFAULT_BLOCK_TIME, Async.defaultExecutorService());\n    }\n\n    public JsonRpc2_0Neow3j("}
{"magic_number_smell": "            final StructureConstant structorDefinition = (StructureConstant) arrayConstant.getElement(i);\n            final Symbol prioritySymbol = structorDefinition.getElement(0);\n            final Integer priority = LLVMSymbolReadResolver.evaluateIntegerConstant(prioritySymbol);\n            structors.add(new Pair<>(priority != null ? priority : 65535, functionCall));\n        }\n\n        return structors.stream().sorted(priorityComparator).map(Pair::getSecond).toArray(LLVMExpressionNode[]::new);", "refactored_code": "    private static final int LEAST_CONSTRUCTOR_PRIORITY = 65535;\n            final StructureConstant structorDefinition = (StructureConstant) arrayConstant.getElement(i);\n            final Symbol prioritySymbol = structorDefinition.getElement(0);\n            final Integer priority = LLVMSymbolReadResolver.evaluateIntegerConstant(prioritySymbol);\n            structors.add(new Pair<>(priority != null ? priority : LEAST_CONSTRUCTOR_PRIORITY, functionCall));\n        }\n\n        return structors.stream().sorted(priorityComparator).map(Pair::getSecond).toArray(LLVMExpressionNode[]::new);"}
{"magic_number_smell": "                    // this is a hex pair we need to convert back to a single byte.\n                    byte c1 = DECODING_TABLE[b1];\n                    byte c2 = DECODING_TABLE[b2];\n                    out.write((c1 << 4) | c2);\n                    // 3 bytes in, one byte out\n                    bytesWritten++;\n                }", "refactored_code": "    private static final int OUT_SHIFT = 4;\n                    // this is a hex pair we need to convert back to a single byte.\n                    byte c1 = DECODING_TABLE[b1];\n                    byte c2 = DECODING_TABLE[b2];\n                    out.write((c1 << OUT_SHIFT) | c2);\n                    // 3 bytes in, one byte out\n                    bytesWritten++;\n                }"}
{"magic_number_smell": "    \n    @SuppressWarnings(\"unchecked\")\n    public void afterConstruct() {\n        NotifyCenter.registerToPublisher(ValueChangeEvent.class, 16384);\n        listenOldRaftClose();\n    }\n    ", "refactored_code": "    protected final int queueMaxSize = 16384;\n    \n    @SuppressWarnings(\"unchecked\")\n    public void afterConstruct() {\n        NotifyCenter.registerToPublisher(ValueChangeEvent.class, queueMaxSize);\n        listenOldRaftClose();\n    }\n    "}
{"magic_number_smell": "    while (DecompositionType.DECOMPOSABLE == canExposeExpression(expression)) {\n      exposeExpression(expression);\n      i++;\n      if (i > 1000) {\n        throw new IllegalStateException(\n            \"DecomposeExpression depth exceeded on:\\n\" + expression.toStringTree());\n      }", "refactored_code": "  private static final int MAX_ITERATIONS = 1000;\n    while (DecompositionType.DECOMPOSABLE == canExposeExpression(expression)) {\n      exposeExpression(expression);\n      i++;\n      if (i > MAX_ITERATIONS) {\n        throw new IllegalStateException(\n            \"DecomposeExpression depth exceeded on:\\n\" + expression.toStringTree());\n      }"}
{"magic_number_smell": "            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + AlarmManager.INTERVAL_HOUR;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {", "refactored_code": "    private static final long BACKUP_INTERVAL = AlarmManager.INTERVAL_HOUR;\n            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + BACKUP_INTERVAL;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {"}
{"magic_number_smell": "\n  public static synchronized void reset() {\n    for (final Entry<Integer, boolean[]> each : CLASS_HITS.entrySet()) {\n      if (each.getValue()[0]) { //Probe 0 gets covered by any method that runs\n        Arrays.fill(each.getValue(), false);\n      }\n    }", "refactored_code": "  private static final int                     CLASS_HIT_INDEX   = 0;\n\n  public static synchronized void reset() {\n    for (final Entry<Integer, boolean[]> each : CLASS_HITS.entrySet()) {\n      if (each.getValue()[CLASS_HIT_INDEX]) { //Probe 0 gets covered by any method that runs\n        Arrays.fill(each.getValue(), false);\n      }\n    }"}
{"magic_number_smell": "\n            BasicInvocation inv = new BasicTargetInvocation(\n                    basicInvocation.nodeEngine, basicInvocation.serviceName, isStillExecuting,\n                    target, 0, 0, 5000, null, null, true);\n            Future f = inv.invoke();\n            basicInvocation.logger.warning(\"Asking if operation execution has been started: \" + toString());\n            executing = (Boolean) basicInvocation.nodeEngine.toObject(f.get(GET_TIME, TimeUnit.MILLISECONDS));", "refactored_code": "    private static final long CALL_TIMEOUT = 5000;\n\n            BasicInvocation inv = new BasicTargetInvocation(\n                    basicInvocation.nodeEngine, basicInvocation.serviceName, isStillExecuting,\n                    target, 0, 0, CALL_TIMEOUT, null, null, true);\n            Future f = inv.invoke();\n            basicInvocation.logger.warning(\"Asking if operation execution has been started: \" + toString());\n            executing = (Boolean) basicInvocation.nodeEngine.toObject(f.get(GET_TIME, TimeUnit.MILLISECONDS));"}
{"magic_number_smell": "\tprivate static final BasicStroke twoPixelsWide = new BasicStroke(2);\n\tprivate static final BasicStroke threePixelsWide = new BasicStroke(3);\n\tprivate static final BasicStroke fivePixelsWide = new BasicStroke(5);\n\tprivate static int defaultType = 0, CROSS=1, CROSSHAIR=1, DOT=2, CIRCLE=3;\n\tprivate static int defaultSize = SMALL;\n\tprivate static Font font;\n\tprivate static Color defaultCrossColor = Color.white;", "refactored_code": "\tpublic static final int HYBRID=0, CROSS=1, CROSSHAIR=1, DOT=2, CIRCLE=3;\n\tprivate static final BasicStroke twoPixelsWide = new BasicStroke(2);\n\tprivate static final BasicStroke threePixelsWide = new BasicStroke(3);\n\tprivate static final BasicStroke fivePixelsWide = new BasicStroke(5);\n\tprivate static int defaultType = HYBRID;\n\tprivate static int defaultSize = SMALL;\n\tprivate static Font font;\n\tprivate static Color defaultCrossColor = Color.white;"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    public void whenNoBodyIsReturned() {\n        HttpResponse<JsonNode> i = Unirest.get(MockServer.NOBODY).asJson();\n\n        assertEquals(200, i.getStatus());\n        assertEquals(\"{}\", i.getBody().toString());\n    }\n", "refactored_code": "    private final int HTTP_STATUS_OK = 200;\n    public void whenNoBodyIsReturned() {\n        HttpResponse<JsonNode> i = Unirest.get(MockServer.NOBODY).asJson();\n\n        assertEquals(HTTP_STATUS_OK, i.getStatus());\n        assertEquals(\"{}\", i.getBody().toString());\n    }\n"}
{"magic_number_smell": "            throw new IllegalArgumentException(\"Mark is not supported.\");\n        }\n\n        final byte[] signature = new byte[12];\n        in.mark(signature.length);\n        try {\n            int signatureLength = IOUtils.readFully(in, signature);", "refactored_code": "    private static final int SIGNATURE_SIZE = 12;\n            throw new IllegalArgumentException(\"Mark is not supported.\");\n        }\n\n        final byte[] signature = new byte[SIGNATURE_SIZE];\n        in.mark(signature.length);\n        try {\n            int signatureLength = IOUtils.readFully(in, signature);"}
{"magic_number_smell": "    }\n    public byte[] getId() {\n\treturn new byte[] {\n\t    (byte) (nextId++ >>> 56), (byte) (nextId++ >>> 48), (byte) (nextId++ >>> 40),\n\t    (byte) (nextId++ >>> 32), (byte) (nextId++ >>> 24), (byte) (nextId++ >>> 16),\n\t    (byte) (nextId++ >>> 8), (byte) nextId++ };\n    }", "refactored_code": "    private final long id = nextId++;\n    }\n    public byte[] getId() {\n\treturn new byte[] {\n\t    (byte) (id >>> 56), (byte) (id >>> 48), (byte) (id >>> 40),\n\t    (byte) (id >>> 32), (byte) (id >>> 24), (byte) (id >>> 16),\n\t    (byte) (id >>> 8), (byte) id };\n    }"}
{"magic_number_smell": "\t\t// increase the timeout, as otherwise the player often\n\t\t// would use their stake because of reacting too slow.\n\t\t\n\t\tramon.setPlayerChatTimeout(180); \n\n\t\tramon.add(ConversationStates.ATTENDING, \"play\", null,\n\t\t\t\tConversationStates.ATTENDING,", "refactored_code": "\tprivate static final int ONE_MINUTE = 180;\n\t\t// increase the timeout, as otherwise the player often\n\t\t// would use their stake because of reacting too slow.\n\t\t\n\t\tramon.setPlayerChatTimeout(ONE_MINUTE); \n\n\t\tramon.add(ConversationStates.ATTENDING, \"play\", null,\n\t\t\t\tConversationStates.ATTENDING,"}
{"magic_number_smell": "        boolean createNew = false;\n\n        try {\n            if (this.lockTopicConfigTable.tryLock(3000, TimeUnit.MILLISECONDS)) {\n                try {\n                    topicConfig = this.topicConfigTable.get(topic);\n                    if (topicConfig != null)", "refactored_code": "    private static final long LOCK_TIMEOUT_MILLIS = 3000;\n        boolean createNew = false;\n\n        try {\n            if (this.lockTopicConfigTable.tryLock(LOCK_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)) {\n                try {\n                    topicConfig = this.topicConfigTable.get(topic);\n                    if (topicConfig != null)"}
{"magic_number_smell": "            throw new IllegalStateException(e);\n        }\n        int realLength = SHA_256.getDigestLength();\n        if (realLength != 32) {\n            // Just in case\n            throw new IllegalStateException(\"Digest length of sha-256 is meant to be 32, but returned \" + realLength);\n        }", "refactored_code": "    public static final int DIGEST_LENGTH = 32;\n            throw new IllegalStateException(e);\n        }\n        int realLength = SHA_256.getDigestLength();\n        if (realLength != DIGEST_LENGTH) {\n            // Just in case\n            throw new IllegalStateException(\"Digest length of sha-256 is meant to be 32, but returned \" + realLength);\n        }"}
{"magic_number_smell": "\n    public Location findPlaceToStand(Location playerLoc, boolean goUp)\n    {\n        int 0.2;\n        if (goUp)\n        {\n            0.2 = 1;", "refactored_code": "    private final double                     step                   = 0.2;\n\n    public Location findPlaceToStand(Location playerLoc, boolean goUp)\n    {\n        int step;\n        if (goUp)\n        {\n            step = 1;"}
{"magic_number_smell": "                    notificationManager.notify(NOTIFY_ID_UPDATING, notificationBuilder.build());\n                    Toast.makeText(context, text, Toast.LENGTH_LONG).show();\n                    break;\n                case 0:\n                    break;\n                case STATUS_COMPLETE_AND_SAME:\n                    text = context.getString(R.string.repos_unchanged);", "refactored_code": "    public static final int STATUS_COMPLETE_WITH_CHANGES = 0;\n                    notificationManager.notify(NOTIFY_ID_UPDATING, notificationBuilder.build());\n                    Toast.makeText(context, text, Toast.LENGTH_LONG).show();\n                    break;\n                case STATUS_COMPLETE_WITH_CHANGES:\n                    break;\n                case STATUS_COMPLETE_AND_SAME:\n                    text = context.getString(R.string.repos_unchanged);"}
{"magic_number_smell": "        PerfRecorder recorderSetRealValue = new PerfRecorder(\"setRealValue\");\n\n        // WHEN\n        for (int i = 0; i < 10_000; i++) {\n            long tsStart = System.nanoTime();\n\n            PrismContainerValue<AssignmentType> newValue = assignmentContainer.createNewValue();", "refactored_code": "    private static final int ITERATIONS = 10_000;\n        PerfRecorder recorderSetRealValue = new PerfRecorder(\"setRealValue\");\n\n        // WHEN\n        for (int i = 0; i < ITERATIONS; i++) {\n            long tsStart = System.nanoTime();\n\n            PrismContainerValue<AssignmentType> newValue = assignmentContainer.createNewValue();"}
{"magic_number_smell": "                props.put(\"batch-size\", Integer.toString(batchSize));\r\n            }\r\n            if (retries > 1) {\r\n                if (retries > 3) {\r\n                    retries = 3;\r\n                }\r\n                props.put(\"max-attempts\", Integer.toString(retries * agents.length));\r", "refactored_code": "    private static final int MAX_RECONNECTS = 3;\r\n                props.put(\"batch-size\", Integer.toString(batchSize));\r\n            }\r\n            if (retries > 1) {\r\n                if (retries > MAX_RECONNECTS) {\r\n                    retries = MAX_RECONNECTS;\r\n                }\r\n                props.put(\"max-attempts\", Integer.toString(retries * agents.length));\r"}
{"magic_number_smell": "\n    public IntHashMap()\n    {\n        this( 101, DEFAULT_LOAD_FACTOR );\n    }\n\n    /*", "refactored_code": "    private static final int DEFAULT_INITIAL_CAPACITY = 101;\n\n    public IntHashMap()\n    {\n        this( DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR );\n    }\n\n    /*"}
{"magic_number_smell": "                    ArtilleryAttackAction aaa = (ArtilleryAttackAction) actualFireInfo.buildWeaponAttackAction();\n                    HelperAmmo ammo = findAmmo(shooter, actualFireInfo.getWeapon(), actualFireInfo.getAmmo());\n\n                    if (ammo.equipmentNum > -1) {\n                        //This can happen if princess is towing ammo trailers, which she really shouldn't be doing...\n                        aaa.setAmmoId(ammo.equipmentNum);\n                        aaa.setAmmoMunitionType(ammo.munitionType);", "refactored_code": "    private static final int NO_AMMO = -1;\n                    ArtilleryAttackAction aaa = (ArtilleryAttackAction) actualFireInfo.buildWeaponAttackAction();\n                    HelperAmmo ammo = findAmmo(shooter, actualFireInfo.getWeapon(), actualFireInfo.getAmmo());\n\n                    if (ammo.equipmentNum > NO_AMMO) {\n                        //This can happen if princess is towing ammo trailers, which she really shouldn't be doing...\n                        aaa.setAmmoId(ammo.equipmentNum);\n                        aaa.setAmmoMunitionType(ammo.munitionType);"}
{"magic_number_smell": "\tprivate Color currentColor;\t\t\t\t\t\t// for next objects added\n\tprivate Color currentColor2;\t\t\t\t\t// 2nd color for next object added (e.g. line for CONNECTED_CIRCLES)\n\tfloat currentLineWidth;\n\tprivate int currentJustification = ImageProcessor.LEFT_JUSTIFY, CENTER=ImageProcessor.CENTER_JUSTIFY, RIGHT=ImageProcessor.RIGHT_JUSTIFY;\n\tprivate boolean ignoreForce2Grid;               // after explicit setting of range (limits), ignore 'FORCE2GRID' flags\n\t//private boolean snapToMinorGrid;  \t\t\t// snap to grid when zooming to selection\n\tprivate static double SEPARATED_BAR_WIDTH=0.5;  // for plots with separate bars (e.g. categories), fraction of space, 0.1-1.0", "refactored_code": "\tpublic static final int LEFT=ImageProcessor.LEFT_JUSTIFY, CENTER=ImageProcessor.CENTER_JUSTIFY, RIGHT=ImageProcessor.RIGHT_JUSTIFY;\n\tprivate Color currentColor;\t\t\t\t\t\t// for next objects added\n\tprivate Color currentColor2;\t\t\t\t\t// 2nd color for next object added (e.g. line for CONNECTED_CIRCLES)\n\tfloat currentLineWidth;\n\tprivate int currentJustification = LEFT;\n\tprivate boolean ignoreForce2Grid;               // after explicit setting of range (limits), ignore 'FORCE2GRID' flags\n\t//private boolean snapToMinorGrid;  \t\t\t// snap to grid when zooming to selection\n\tprivate static double SEPARATED_BAR_WIDTH=0.5;  // for plots with separate bars (e.g. categories), fraction of space, 0.1-1.0"}
{"magic_number_smell": "    /**\n     * Timeout value for nodes to accept client connection requests.\n     */\n    private int connectionTimeout = 5000;\n\n    /**\n     * While client is trying to connect initially to one of the members in the {@link ClientNetworkConfig#addressList},", "refactored_code": "    private static final int CONNECTION_TIMEOUT = 5000;\n    /**\n     * Timeout value for nodes to accept client connection requests.\n     */\n    private int connectionTimeout = CONNECTION_TIMEOUT;\n\n    /**\n     * While client is trying to connect initially to one of the members in the {@link ClientNetworkConfig#addressList},"}
{"magic_number_smell": "\r\n\t\tBlockFile.pageSeek(bf.file, skipPage);\r\n\t\tlong magic = bf.file.readLong();\r\n\t\tif (magic != 0x536b69704c697374l)\r\n\t\t\tthrow new IOException(\"Bad SkipList magic number 0x\" + Long.toHexString(magic) + \" on page \" + skipPage);\r\n\t\tfirstSpanPage = bf.file.readUnsignedInt();\r\n\t\tfirstLevelPage = bf.file.readUnsignedInt();\r", "refactored_code": "\tprivate static final long MAGIC = 0x536b69704c697374l;  // \"SkipList\"\r\n\r\n\t\tBlockFile.pageSeek(bf.file, skipPage);\r\n\t\tlong magic = bf.file.readLong();\r\n\t\tif (magic != MAGIC)\r\n\t\t\tthrow new IOException(\"Bad SkipList magic number 0x\" + Long.toHexString(magic) + \" on page \" + skipPage);\r\n\t\tfirstSpanPage = bf.file.readUnsignedInt();\r\n\t\tfirstLevelPage = bf.file.readUnsignedInt();\r"}
{"magic_number_smell": "        //Constants used in AbstractCard for scale formatting\n        private static final float 300.0F * Settings.scale = 300.0F * Settings.scale;\n        //Multipliers are slightly fudged to be more forgiving to longer names\n        private static final float TITLE_BOX_WIDTH = 300.0F * Settings.scale * 0.7F; //Was 0.6F\n        private static final float TITLE_BOX_WIDTH_NO_COST = 300.0F * Settings.scale * 0.8F; //Was 0.7F\n        private static final GlyphLayout gl = new GlyphLayout();\n", "refactored_code": "        private static final float IMG_WIDTH = 300.0F * Settings.scale;\n        //Constants used in AbstractCard for scale formatting\n        private static final float IMG_WIDTH = 300.0F * Settings.scale;\n        //Multipliers are slightly fudged to be more forgiving to longer names\n        private static final float TITLE_BOX_WIDTH = IMG_WIDTH * 0.7F; //Was 0.6F\n        private static final float TITLE_BOX_WIDTH_NO_COST = IMG_WIDTH * 0.8F; //Was 0.7F\n        private static final GlyphLayout gl = new GlyphLayout();\n"}
{"magic_number_smell": "    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);"}
{"magic_number_smell": "            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > 50 ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;", "refactored_code": "    private static final int INET_CONDITION_THRESHOLD = 50;\n            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "\tpublic static final int 0, CTZ=1, ZCT=2, ZTC=3, TCZ=4, TZC=5=0, CTZ=1, ZCT=2, ZTC=3, TCZ=4, TZC=5;\n\tstatic final int C=0, Z=1, T=2;\n\tstatic final String[] orders = {\"xyczt(default)\", \"xyctz\", \"xyzct\", \"xyztc\", \"xytcz\", \"xytzc\"};\n\tstatic int ordering = 0, CTZ=1, ZCT=2, ZTC=3, TCZ=4, TZC=5;\n\tstatic boolean splitRGB = true;\n\n\tpublic void run(String arg) {", "refactored_code": "\tpublic static final int CZT=0, CTZ=1, ZCT=2, ZTC=3, TCZ=4, TZC=5;\n\tpublic static final int CZT=0, CTZ=1, ZCT=2, ZTC=3, TCZ=4, TZC=5;\n\tstatic final int C=0, Z=1, T=2;\n\tstatic final String[] orders = {\"xyczt(default)\", \"xyctz\", \"xyzct\", \"xyztc\", \"xytcz\", \"xytzc\"};\n\tstatic int ordering = CZT;\n\tstatic boolean splitRGB = true;\n\n\tpublic void run(String arg) {"}
{"magic_number_smell": "\t\t\t\t// period is in seconds\n//\t\t\t\tdouble period = timeCache / currentTR * MarsClock.SECONDS_PER_MILLISOL;\n\n\t\t\t\tif (count > 4) {\n//\t\t\t\t\tint speed = getCurrentSpeed();\n//\t\t\t\t\tif (speed == 0)\n//\t\t\t\t\t\tspeed = 1;", "refactored_code": "\tprivate static final int FACTOR = 4;\n\t\t\t\t// period is in seconds\n//\t\t\t\tdouble period = timeCache / currentTR * MarsClock.SECONDS_PER_MILLISOL;\n\n\t\t\t\tif (count > FACTOR) {\n//\t\t\t\t\tint speed = getCurrentSpeed();\n//\t\t\t\t\tif (speed == 0)\n//\t\t\t\t\t\tspeed = 1;"}
{"magic_number_smell": "        this.mbean = new ManagedLedgerFactoryMBeanImpl(this);\n        this.entryCacheManager = new EntryCacheManager(this);\n        this.statsTask = scheduledExecutor.scheduleAtFixedRate(this::refreshStats,\n                0, 60, TimeUnit.SECONDS);\n        this.flushCursorsTask = scheduledExecutor.scheduleAtFixedRate(this::flushCursors,\n                config.getCursorPositionFlushSeconds(), config.getCursorPositionFlushSeconds(), TimeUnit.SECONDS);\n", "refactored_code": "    public static final int StatsPeriodSeconds = 60;\n        this.mbean = new ManagedLedgerFactoryMBeanImpl(this);\n        this.entryCacheManager = new EntryCacheManager(this);\n        this.statsTask = scheduledExecutor.scheduleAtFixedRate(this::refreshStats,\n                0, StatsPeriodSeconds, TimeUnit.SECONDS);\n        this.flushCursorsTask = scheduledExecutor.scheduleAtFixedRate(this::flushCursors,\n                config.getCursorPositionFlushSeconds(), config.getCursorPositionFlushSeconds(), TimeUnit.SECONDS);\n"}
{"magic_number_smell": "        int concurrency,\n        AllocationTracker tracker\n    ) {\n        var componentSizeBuilder = HugeSparseLongArray.GrowingBuilder.create(0L, tracker);\n\n        if (concurrency == 1) {\n            // For one thread, we can just iterate through the node space", "refactored_code": "    private static final long EMPTY_COMMUNITY = 0L;\n        int concurrency,\n        AllocationTracker tracker\n    ) {\n        var componentSizeBuilder = HugeSparseLongArray.GrowingBuilder.create(EMPTY_COMMUNITY, tracker);\n\n        if (concurrency == 1) {\n            // For one thread, we can just iterate through the node space"}
{"magic_number_smell": "     * is returned.\n     */\n    public static <T> boolean anyMatch(Iterator<? extends T> iterator, Predicate<? super T> pred) {\n        return matches(iterator, pred, 0);\n    }\n\n    /**", "refactored_code": "    private static final int MATCH_ANY = 0;\n     * is returned.\n     */\n    public static <T> boolean anyMatch(Iterator<? extends T> iterator, Predicate<? super T> pred) {\n        return matches(iterator, pred, MATCH_ANY);\n    }\n\n    /**"}
{"magic_number_smell": "        for (String each : selectStatementContext.getTablesContext().getTableNames()) {\n            ShardingSphereTable table = schema.getTable(each);\n            ShardingSpherePreconditions.checkState(null != table, () -> new NoSuchTableException(each));\n            // TODO replace 0 with actual version in ShardingSphereTable\n            result.getTableMetaDataVersions().put(table.getName(), 0);\n        }\n        return result;", "refactored_code": "    private static final int DEFAULT_METADATA_VERSION = 0;\n        for (String each : selectStatementContext.getTablesContext().getTableNames()) {\n            ShardingSphereTable table = schema.getTable(each);\n            ShardingSpherePreconditions.checkState(null != table, () -> new NoSuchTableException(each));\n            // TODO replace DEFAULT_METADATA_VERSION with actual version in ShardingSphereTable\n            result.getTableMetaDataVersions().put(table.getName(), DEFAULT_METADATA_VERSION);\n        }\n        return result;"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "\t\tp.setActive(true);\n\t\tIIdType id = ourClient.create().resource(p).execute().getId().toUnqualifiedVersionless();\n\n\t\tfor (int i = 1; i < 77; i++) {\n\t\t\tObservation obs = new Observation();\n\t\t\tobs.setId(\"A\" + StringUtils.leftPad(Integer.toString(i), 2, '0'));\n\t\t\tobs.setSubject(new Reference(id));", "refactored_code": "\tpublic static final int LARGE_NUMBER = 77;\n\t\tp.setActive(true);\n\t\tIIdType id = ourClient.create().resource(p).execute().getId().toUnqualifiedVersionless();\n\n\t\tfor (int i = 1; i < LARGE_NUMBER; i++) {\n\t\t\tObservation obs = new Observation();\n\t\t\tobs.setId(\"A\" + StringUtils.leftPad(Integer.toString(i), 2, '0'));\n\t\t\tobs.setSubject(new Reference(id));"}
{"magic_number_smell": "        }\n\n        long getDefaultDisplayDelayTimeout() {\n            return 10000;\n        }\n    }\n", "refactored_code": "    private static final long WAIT_FOR_DEFAULT_DISPLAY_TIMEOUT = 10000;\n        }\n\n        long getDefaultDisplayDelayTimeout() {\n            return WAIT_FOR_DEFAULT_DISPLAY_TIMEOUT;\n        }\n    }\n"}
{"magic_number_smell": "\t\t\tLog.d(\"Server\",\"getCapabilities using \" + capabilitiesURL.toString());\n\t\t\tcon = (HttpURLConnection) capabilitiesURL.openConnection();\n\t\t\t//--Start: header not yet send\n\t\t\tcon.setReadTimeout(45 * 1000);\n\t\t\tcon.setConnectTimeout(45 * 1000);\n\t\t\tcon.setRequestProperty(\"User-Agent\", Application.userAgent);\n", "refactored_code": "\tprivate static final int TIMEOUT = 45 * 1000;\n\t\t\tLog.d(\"Server\",\"getCapabilities using \" + capabilitiesURL.toString());\n\t\t\tcon = (HttpURLConnection) capabilitiesURL.openConnection();\n\t\t\t//--Start: header not yet send\n\t\t\tcon.setReadTimeout(TIMEOUT);\n\t\t\tcon.setConnectTimeout(TIMEOUT);\n\t\t\tcon.setRequestProperty(\"User-Agent\", Application.userAgent);\n"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+5*1000) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }", "refactored_code": "    private static final long MIN_TIME_BETWEEN_GCS = 5*1000;\n        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+MIN_TIME_BETWEEN_GCS) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }"}
{"magic_number_smell": "\t\tadd(title);\n\n\t\tbuttonX = left;\n\t\tbuttonY = bottom - 24;\n\n\t\tbtnNewGame = new GameButton(TXT_NEW) {\n\t\t\t@Override", "refactored_code": "\tprivate static final float BUTTON_HEIGHT = 24;\n\t\tadd(title);\n\n\t\tbuttonX = left;\n\t\tbuttonY = bottom - BUTTON_HEIGHT;\n\n\t\tbtnNewGame = new GameButton(TXT_NEW) {\n\t\t\t@Override"}
{"magic_number_smell": "            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + AlarmManager.INTERVAL_HOUR;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {", "refactored_code": "    private static final long BACKUP_INTERVAL = AlarmManager.INTERVAL_HOUR;\n            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + BACKUP_INTERVAL;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {"}
{"magic_number_smell": "        ? null\n        : Units.reluctance(\n          builder.relaxGeneralizedCostAtDestination,\n          1.0,\n          MAX_RELAX_COST_AT_DESTINATION\n        );\n  }", "refactored_code": "  private static final double MIN_RELAX_COST_AT_DESTINATION = 1.0;\n        ? null\n        : Units.reluctance(\n          builder.relaxGeneralizedCostAtDestination,\n          MIN_RELAX_COST_AT_DESTINATION,\n          MAX_RELAX_COST_AT_DESTINATION\n        );\n  }"}
{"magic_number_smell": "\t\t\t\t\tint[] termStringOffsets = new int[n];\n\t\t\t\t\twhile (currentTerm < n) {\n\t\t\t\t\t\tint firstTermInBlock = currentTerm;\n\t\t\t\t\t\tint blockSize = (int)Math.min(bytesLeftToWrite, Integer.MAX_VALUE - 100);\n\n\t\t\t\t\t\t// Calculate byte offsets for all the terms and fill data array\n\t\t\t\t\t\tint currentOffset = 0;", "refactored_code": "\tprivate static final int APPROX_MAX_ARRAY_SIZE = Integer.MAX_VALUE - 100;\n\t\t\t\t\tint[] termStringOffsets = new int[n];\n\t\t\t\t\twhile (currentTerm < n) {\n\t\t\t\t\t\tint firstTermInBlock = currentTerm;\n\t\t\t\t\t\tint blockSize = (int)Math.min(bytesLeftToWrite, APPROX_MAX_ARRAY_SIZE);\n\n\t\t\t\t\t\t// Calculate byte offsets for all the terms and fill data array\n\t\t\t\t\t\tint currentOffset = 0;"}
{"magic_number_smell": "\t\t\t\t\t\tfileCreate(\"payableBytecode\").path(ContractResources.PAYABLE_CONTRACT_BYTECODE_PATH),\n\t\t\t\t\t\tcontractCreate(\"payableContract\").bytecode(\"payableBytecode\").adminKey(THRESHOLD)\n\t\t\t\t).when(\n\t\t\t\t\t\tcontractCall(\"payableContract\", ContractResources.DEPOSIT_ABI, 1000)\n\t\t\t\t\t\t\t\t.via(\"payTxn\").sending(1000)\n\t\t\t\t).then(\n\t\t\t\t\t\tgetTxnRecord(\"payTxn\")", "refactored_code": "\tprivate static final long depositAmount = 1000;\n\t\t\t\t\t\tfileCreate(\"payableBytecode\").path(ContractResources.PAYABLE_CONTRACT_BYTECODE_PATH),\n\t\t\t\t\t\tcontractCreate(\"payableContract\").bytecode(\"payableBytecode\").adminKey(THRESHOLD)\n\t\t\t\t).when(\n\t\t\t\t\t\tcontractCall(\"payableContract\", ContractResources.DEPOSIT_ABI, depositAmount)\n\t\t\t\t\t\t\t\t.via(\"payTxn\").sending(depositAmount)\n\t\t\t\t).then(\n\t\t\t\t\t\tgetTxnRecord(\"payTxn\")"}
{"magic_number_smell": "    private static class LocalWrapperException extends RuntimeException {\n\n        /** Serializable UID. */\n        private static final long 4489391420715269318L = 2734331164409224983L;\n\n        /** Wrapped exception. */\n        private final OrekitException wrappedException;", "refactored_code": "    private static final long serialVersionUID = 4489391420715269318L;\n    private static class LocalWrapperException extends RuntimeException {\n\n        /** Serializable UID. */\n        private static final long serialVersionUID = 2734331164409224983L;\n\n        /** Wrapped exception. */\n        private final OrekitException wrappedException;"}
{"magic_number_smell": "            } else {\r\n                // Set minimum size and adjust after all components have\r\n                // (supposedly) been drawn completely.\r\n                DOM.setStyleAttribute(base, styleAttribute, 50 + \"px\");\r\n                DeferredCommand.addCommand(new Command() {\r\n                    public void execute() {\r\n                        final Element p = DOM.getParent(getElement());\r", "refactored_code": "    private static final int MIN_SIZE = 50;\r\n            } else {\r\n                // Set minimum size and adjust after all components have\r\n                // (supposedly) been drawn completely.\r\n                DOM.setStyleAttribute(base, styleAttribute, MIN_SIZE + \"px\");\r\n                DeferredCommand.addCommand(new Command() {\r\n                    public void execute() {\r\n                        final Element p = DOM.getParent(getElement());\r"}
{"magic_number_smell": "                    .build();\n            metadataByteBuf = PulsarByteBufAllocator.DEFAULT.buffer(\n                    mlInfoMetadata.getSerializedSize() + 6, mlInfoMetadata.getSerializedSize() + 6);\n            metadataByteBuf.writeShort(0x4778);\n            metadataByteBuf.writeInt(mlInfoMetadata.getSerializedSize());\n            metadataByteBuf.writeBytes(mlInfoMetadata.toByteArray());\n", "refactored_code": "    private static final int MAGIC_MANAGED_LEDGER_INFO_METADATA = 0x4778; // 0100 0111 0111 1000\n                    .build();\n            metadataByteBuf = PulsarByteBufAllocator.DEFAULT.buffer(\n                    mlInfoMetadata.getSerializedSize() + 6, mlInfoMetadata.getSerializedSize() + 6);\n            metadataByteBuf.writeShort(MAGIC_MANAGED_LEDGER_INFO_METADATA);\n            metadataByteBuf.writeInt(mlInfoMetadata.getSerializedSize());\n            metadataByteBuf.writeBytes(mlInfoMetadata.toByteArray());\n"}
{"magic_number_smell": "        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+5*1000) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }", "refactored_code": "    private static final long MIN_TIME_BETWEEN_GCS = 5*1000;\n        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+MIN_TIME_BETWEEN_GCS) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }"}
{"magic_number_smell": "        throw new MPCException(\"Retriever got interrupted\", e1);\n      } catch (ClientProtocolException e) {\n        logger.warn(\"Retriever could not reach client. Exception message: \" + e.getMessage()\n            + \". Waiting for a \" + 1000 + \"ms before trying again.\");\n        try {\n          Thread.sleep(1000);\n          semaphore.release();", "refactored_code": "  private static final int waitTimeInMs = 1000;\n        throw new MPCException(\"Retriever got interrupted\", e1);\n      } catch (ClientProtocolException e) {\n        logger.warn(\"Retriever could not reach client. Exception message: \" + e.getMessage()\n            + \". Waiting for a \" + waitTimeInMs + \"ms before trying again.\");\n        try {\n          Thread.sleep(waitTimeInMs);\n          semaphore.release();"}
{"magic_number_smell": "    @Override\n    public String probeContentType(Path path) throws IOException {\n        long magicWord = readMagicWord(path);\n        if (magicWord == 0xdec04342L || magicWord == WRAPPER_MAGIC_WORD) {\n            return Sulong.LLVM_BITCODE_MIME_TYPE;\n        } else if (magicWord == ELF_MAGIC_WORD) {\n            return Sulong.LLVM_ELF_SHARED_MIME_TYPE;", "refactored_code": "    private static final long BC_MAGIC_WORD = 0xdec04342L; // 'BC' c0de\n    @Override\n    public String probeContentType(Path path) throws IOException {\n        long magicWord = readMagicWord(path);\n        if (magicWord == BC_MAGIC_WORD || magicWord == WRAPPER_MAGIC_WORD) {\n            return Sulong.LLVM_BITCODE_MIME_TYPE;\n        } else if (magicWord == ELF_MAGIC_WORD) {\n            return Sulong.LLVM_ELF_SHARED_MIME_TYPE;"}
{"magic_number_smell": "     * @since 1.1\n     */\n    public ZipShort getLocalFileDataLength() {\n        return new ZipShort(4         // CRC\n                          + 2         // Mode\n                          + 4         // SizDev\n                          + 2         // UID", "refactored_code": "    private static final int      WORD = 4;\n     * @since 1.1\n     */\n    public ZipShort getLocalFileDataLength() {\n        return new ZipShort(WORD         // CRC\n                          + 2         // Mode\n                          + WORD         // SizDev\n                          + 2         // UID"}
{"magic_number_smell": "    long waitTimeInMs = TimeUnit.MILLISECONDS.convert(timeout, unit);\n    while (! isTerminated() && \n           Clock.accurateTime() - startTime < waitTimeInMs) {\n      Thread.sleep(100);\n    }\n    \n    return isTerminated();", "refactored_code": "  private static final int AWAIT_TERMINATION_POLL_INTERVAL_IN_MS = 100;\n    long waitTimeInMs = TimeUnit.MILLISECONDS.convert(timeout, unit);\n    while (! isTerminated() && \n           Clock.accurateTime() - startTime < waitTimeInMs) {\n      Thread.sleep(AWAIT_TERMINATION_POLL_INTERVAL_IN_MS);\n    }\n    \n    return isTerminated();"}
{"magic_number_smell": "    // Though the tile provider can only provide up to 13, this overlay will display higher.\n    @Override\n    public int getMaximumZoomLevel() {\n        return 20;\n    }\n\n    @Override", "refactored_code": "    public static final int MAX_ZOOM_LEVEL_OF_MAP = 20;\n    // Though the tile provider can only provide up to 13, this overlay will display higher.\n    @Override\n    public int getMaximumZoomLevel() {\n        return MAX_ZOOM_LEVEL_OF_MAP;\n    }\n\n    @Override"}
{"magic_number_smell": "                final boolean isPrimaryKeyQuery = queryAttributeName.equals(primaryKeyPropertyName);\n                final QueryRequest queryRequest = new QueryRequest().withTableName(tableName)\n                        .withKeyConditions(conditions).withExclusiveStartKey(lastEvaluatedKey);\n                queryRequest.setLimit(500);\n                if (!isPrimaryKeyQuery) {\n                    queryRequest.withIndexName(queryAttributeName + \"_idx\");\n                }", "refactored_code": "    public static final int BATCH_SIZE = 500;\n                final boolean isPrimaryKeyQuery = queryAttributeName.equals(primaryKeyPropertyName);\n                final QueryRequest queryRequest = new QueryRequest().withTableName(tableName)\n                        .withKeyConditions(conditions).withExclusiveStartKey(lastEvaluatedKey);\n                queryRequest.setLimit(BATCH_SIZE);\n                if (!isPrimaryKeyQuery) {\n                    queryRequest.withIndexName(queryAttributeName + \"_idx\");\n                }"}
{"magic_number_smell": "            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > 50 ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;", "refactored_code": "    private static final int INET_CONDITION_THRESHOLD = 50;\n            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;"}
{"magic_number_smell": "            boolean hashAggregation = operatorType.equalsIgnoreCase(\"hash\");\n\n            RowPagesBuilder pagesBuilder = RowPagesBuilder.rowPagesBuilder(hashAggregation, ImmutableList.of(0), VARCHAR, BIGINT);\n            for (int i = 0; i < 140; i++) {\n                BlockBuilder blockBuilder = VARCHAR.createBlockBuilder(null, ROWS_PER_PAGE);\n                for (int j = 0; j < groupsPerPage; j++) {\n                    String groupKey = format(\"%s\", i * groupsPerPage + j);", "refactored_code": "        public static final int TOTAL_PAGES = 140;\n            boolean hashAggregation = operatorType.equalsIgnoreCase(\"hash\");\n\n            RowPagesBuilder pagesBuilder = RowPagesBuilder.rowPagesBuilder(hashAggregation, ImmutableList.of(0), VARCHAR, BIGINT);\n            for (int i = 0; i < TOTAL_PAGES; i++) {\n                BlockBuilder blockBuilder = VARCHAR.createBlockBuilder(null, ROWS_PER_PAGE);\n                for (int j = 0; j < groupsPerPage; j++) {\n                    String groupKey = format(\"%s\", i * groupsPerPage + j);"}
{"magic_number_smell": "        //Some known certs have an incorrect \"unused bits\" value, which causes problems on newer versions of BouncyCastle.\n        if(FIXSIG.contains(cert.getSubjectDN().getName())) {\n            byte[] encoded = cert.getEncoded();\n            encoded[encoded.length - 257] = 0;  // Fix the \"unused bits\" field (should always be 0).\n            cert = (X509Certificate) CertificateFactory.getInstance(\"X.509\", BC_PROVIDER).generateCertificate(new ByteArrayInputStream(encoded));\n        }\n        return cert;", "refactored_code": "    private static final int UNUSED_BITS_BYTE_INDEX_FROM_END = 257;\n        //Some known certs have an incorrect \"unused bits\" value, which causes problems on newer versions of BouncyCastle.\n        if(FIXSIG.contains(cert.getSubjectDN().getName())) {\n            byte[] encoded = cert.getEncoded();\n            encoded[encoded.length - UNUSED_BITS_BYTE_INDEX_FROM_END] = 0;  // Fix the \"unused bits\" field (should always be 0).\n            cert = (X509Certificate) CertificateFactory.getInstance(\"X.509\", BC_PROVIDER).generateCertificate(new ByteArrayInputStream(encoded));\n        }\n        return cert;"}
{"magic_number_smell": "    paramLabel = MANDATORY_INTEGER_FORMAT_HELP,\n    description = \"Maximum p2p peer connections that can be established (default: ${DEFAULT-VALUE})\"\n  )\n  private final Integer maxPeers = 25;\n\n  @Option(\n    names = {\"--max-trailing-peers\"},", "refactored_code": "  private static final int DEFAULT_MAX_PEERS = 25;\n    paramLabel = MANDATORY_INTEGER_FORMAT_HELP,\n    description = \"Maximum p2p peer connections that can be established (default: ${DEFAULT-VALUE})\"\n  )\n  private final Integer maxPeers = DEFAULT_MAX_PEERS;\n\n  @Option(\n    names = {\"--max-trailing-peers\"},"}
{"magic_number_smell": "    }\n\n    public long getBootTimestamp() {\n        return System.currentTimeMillis();\n    }\n\n    public ScheduledExecutorService getScheduledExecutorService() {", "refactored_code": "    private final long bootTimestamp = System.currentTimeMillis();\n    }\n\n    public long getBootTimestamp() {\n        return bootTimestamp;\n    }\n\n    public ScheduledExecutorService getScheduledExecutorService() {"}
{"magic_number_smell": "    }\n\n    protected boolean isJarFile(File file) throws IOException {\n        return checkMagic(file, 0x504B0304);\n    }\n\n}", "refactored_code": "    private static final int ZIP_MAGIC = 0x504B0304;\n    }\n\n    protected boolean isJarFile(File file) throws IOException {\n        return checkMagic(file, ZIP_MAGIC);\n    }\n\n}"}
{"magic_number_smell": "            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > 50 ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;", "refactored_code": "    private static final int INET_CONDITION_THRESHOLD = 50;\n            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "\t\t\t{\n\t\t\t\tfor(int j=0; j<dbmSize(); j++)\n\t\t\t\t{\n\t\t\t\t\tif(getDbmEntry(i, k) != Integer.MAX_VALUE && getDbmEntry(k, j) != Integer.MAX_VALUE\n\t\t\t\t\t\t\t&& getDbmEntry(i, j) > getDbmEntry(i, k) + getDbmEntry(k, j))\n\t\t\t\t\t{\n\t\t\t\t\t\tsetDbmEntry(i, j, getDbmEntry(i, k) + getDbmEntry(k, j));", "refactored_code": "\tpublic static final int INFINITY = Integer.MAX_VALUE;\n\t\t\t{\n\t\t\t\tfor(int j=0; j<dbmSize(); j++)\n\t\t\t\t{\n\t\t\t\t\tif(getDbmEntry(i, k) != INFINITY && getDbmEntry(k, j) != INFINITY\n\t\t\t\t\t\t\t&& getDbmEntry(i, j) > getDbmEntry(i, k) + getDbmEntry(k, j))\n\t\t\t\t\t{\n\t\t\t\t\t\tsetDbmEntry(i, j, getDbmEntry(i, k) + getDbmEntry(k, j));"}
{"magic_number_smell": "            assert (variant.end() != null);\n\n            long length = Math.abs(endPosition - variant.start().position());\n            return length >= 1000;\n        }\n\n        return true;", "refactored_code": "    private static final double MIN_LENGTH = 1000;\n            assert (variant.end() != null);\n\n            long length = Math.abs(endPosition - variant.start().position());\n            return length >= MIN_LENGTH;\n        }\n\n        return true;"}
{"magic_number_smell": "     * During a close operation, this is the time at which we will time out all pending operations\n     * and force the RPC thread to exit. If the admin client is not closing, this will be 0.\n     */\n    private final AtomicLong hardShutdownTimeMs = new AtomicLong(-1);\n\n    /**\n     * A factory which creates TimeoutProcessors for the RPC thread.", "refactored_code": "    private static final long INVALID_SHUTDOWN_TIME = -1;\n     * During a close operation, this is the time at which we will time out all pending operations\n     * and force the RPC thread to exit. If the admin client is not closing, this will be 0.\n     */\n    private final AtomicLong hardShutdownTimeMs = new AtomicLong(INVALID_SHUTDOWN_TIME);\n\n    /**\n     * A factory which creates TimeoutProcessors for the RPC thread."}
{"magic_number_smell": "     * Creates a new instance of the Operation class.\n     */\n    public Operation() {\n        this.sequenceNumber = Long.MIN_VALUE;\n    }\n\n    /**", "refactored_code": "    public static final long NO_SEQUENCE_NUMBER = Long.MIN_VALUE;\n     * Creates a new instance of the Operation class.\n     */\n    public Operation() {\n        this.sequenceNumber = NO_SEQUENCE_NUMBER;\n    }\n\n    /**"}
{"magic_number_smell": "\n  @Test\n  public void setThreadPriorityOneArgument_setsCurrentThreadPriority_highestPriority() {\n    android.os.Process.setThreadPriority(-20);\n\n    assertThat(android.os.Process.getThreadPriority(android.os.Process.myTid()))\n        .isEqualTo(-20);", "refactored_code": "  private static final int THREAD_PRIORITY_HIGHEST = -20;\n\n  @Test\n  public void setThreadPriorityOneArgument_setsCurrentThreadPriority_highestPriority() {\n    android.os.Process.setThreadPriority(THREAD_PRIORITY_HIGHEST);\n\n    assertThat(android.os.Process.getThreadPriority(android.os.Process.myTid()))\n        .isEqualTo(THREAD_PRIORITY_HIGHEST);"}
{"magic_number_smell": "     */\n    public static final int DEFAULT_POOL_EXHAUST_ACTION = WHEN_EXHAUSTED_RUN;\n\n    private int maxThreadsActive = 8;\n    private int maxThreadsIdle = DEFAULT_MAX_THREADS_IDLE;\n    private int maxBufferSize = DEFAULT_MAX_BUFFER_SIZE;\n    private long threadTTL = DEFAULT_MAX_THREAD_TTL;", "refactored_code": "    public static final int DEFAULT_MAX_THREADS_ACTIVE = 8;\n     */\n    public static final int DEFAULT_POOL_EXHAUST_ACTION = WHEN_EXHAUSTED_RUN;\n\n    private int maxThreadsActive = DEFAULT_MAX_THREADS_ACTIVE;\n    private int maxThreadsIdle = DEFAULT_MAX_THREADS_IDLE;\n    private int maxBufferSize = DEFAULT_MAX_BUFFER_SIZE;\n    private long threadTTL = DEFAULT_MAX_THREAD_TTL;"}
{"magic_number_smell": "        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+5*1000) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }", "refactored_code": "    private static final long MIN_TIME_BETWEEN_GCS = 5*1000;\n        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+MIN_TIME_BETWEEN_GCS) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }"}
{"magic_number_smell": "            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > 50 ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;", "refactored_code": "    private static final int INET_CONDITION_THRESHOLD = 50;\n            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;"}
{"magic_number_smell": "\t\t\t}\n\n\t\t\tif (from_me == 0 && delivery_status == ChatConstants.DS_NEW) {\n\t\t\t\tmarkAsReadDelayed(_id, 2000);\n\t\t\t}\n\n\t\t\tString from = jid;", "refactored_code": "\tprivate static final int DELAY_NEWMSG = 2000;\n\t\t\t}\n\n\t\t\tif (from_me == 0 && delivery_status == ChatConstants.DS_NEW) {\n\t\t\t\tmarkAsReadDelayed(_id, DELAY_NEWMSG);\n\t\t\t}\n\n\t\t\tString from = jid;"}
{"magic_number_smell": "            }\n        }\n        if (bgColor.getAlpha() > 0) {\n            int scaledArc = round(UIManager.getInt(\"TabControlIcon.arc\") * 2 * scaling);\n            g.setColor(bgColor);\n            g.fillRoundRect(0, 0, width, height, scaledArc, scaledArc);\n        }", "refactored_code": "    private static final int arc = UIManager.getInt(\"TabControlIcon.arc\"); // NOI18N\n            }\n        }\n        if (bgColor.getAlpha() > 0) {\n            int scaledArc = round(arc * 2 * scaling);\n            g.setColor(bgColor);\n            g.fillRoundRect(0, 0, width, height, scaledArc, scaledArc);\n        }"}
{"magic_number_smell": "                    if (font != null)\n                    {\n                        int x = (res.getScaledWidth() - font.getStringWidth(name)) / 2;\n                        font.func_175063_a(name, x, y, 0xFFFFFF | (opacity << 24));\n                    }\n                    else\n                    {", "refactored_code": "    private static final int WHITE = 0xFFFFFF;\n                    if (font != null)\n                    {\n                        int x = (res.getScaledWidth() - font.getStringWidth(name)) / 2;\n                        font.func_175063_a(name, x, y, WHITE | (opacity << 24));\n                    }\n                    else\n                    {"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "      return new InterRegionConnectionFilter()\n      {\n         private final double getMaxInterRegionConnectionLength() = getMaxInterRegionConnectionLength();\n         private final double maxLengthSquared = MathTools.square(getMaxInterRegionConnectionLength());\n         private final double maxDeltaHeight = getTooHighToStepDistance();\n\n         @Override", "refactored_code": "         private final double maxLength = getMaxInterRegionConnectionLength();\n      return new InterRegionConnectionFilter()\n      {\n         private final double maxLength = getMaxInterRegionConnectionLength();\n         private final double maxLengthSquared = MathTools.square(maxLength);\n         private final double maxDeltaHeight = getTooHighToStepDistance();\n\n         @Override"}
{"magic_number_smell": "\t\t\t{\n\t\t\t\tfor(int j=0; j<dbmSize(); j++)\n\t\t\t\t{\n\t\t\t\t\tif(getDbmEntry(i, k) != Integer.MAX_VALUE && getDbmEntry(k, j) != Integer.MAX_VALUE\n\t\t\t\t\t\t\t&& getDbmEntry(i, j) > getDbmEntry(i, k) + getDbmEntry(k, j))\n\t\t\t\t\t{\n\t\t\t\t\t\tsetDbmEntry(i, j, getDbmEntry(i, k) + getDbmEntry(k, j));", "refactored_code": "\tpublic static final int INFINITY = Integer.MAX_VALUE;\n\t\t\t{\n\t\t\t\tfor(int j=0; j<dbmSize(); j++)\n\t\t\t\t{\n\t\t\t\t\tif(getDbmEntry(i, k) != INFINITY && getDbmEntry(k, j) != INFINITY\n\t\t\t\t\t\t\t&& getDbmEntry(i, j) > getDbmEntry(i, k) + getDbmEntry(k, j))\n\t\t\t\t\t{\n\t\t\t\t\t\tsetDbmEntry(i, j, getDbmEntry(i, k) + getDbmEntry(k, j));"}
{"magic_number_smell": "\n        public int getRecordSize()\n        {\n            return 1;\n        }\n\n        public String getTypeAndVersionDescriptor()", "refactored_code": "        private static final int RECORD_SIZE = 1;\n\n        public int getRecordSize()\n        {\n            return RECORD_SIZE;\n        }\n\n        public String getTypeAndVersionDescriptor()"}
{"magic_number_smell": "    final WebSocketConfiguration config = new WebSocketConfiguration();\n    config.setEnabled(false);\n    config.setHost(DEFAULT_WEBSOCKET_HOST);\n    config.setPort(8546);\n    config.setRpcApis(DEFAULT_WEBSOCKET_APIS);\n    config.setRefreshDelay(DEFAULT_WEBSOCKET_REFRESH_DELAY);\n    return config;", "refactored_code": "  public static final int DEFAULT_WEBSOCKET_PORT = 8546;\n    final WebSocketConfiguration config = new WebSocketConfiguration();\n    config.setEnabled(false);\n    config.setHost(DEFAULT_WEBSOCKET_HOST);\n    config.setPort(DEFAULT_WEBSOCKET_PORT);\n    config.setRpcApis(DEFAULT_WEBSOCKET_APIS);\n    config.setRefreshDelay(DEFAULT_WEBSOCKET_REFRESH_DELAY);\n    return config;"}
{"magic_number_smell": "                            public void onClick(View view) {\n                                ActivityCompat.requestPermissions(BrowserActivity.this,\n                                        new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},\n                                        1);\n                            }\n                        })\n                        .show();", "refactored_code": "    public static final int REQUEST_PERMISSIONS_WRITE_EXTERNAL_STORAGE = 1;\n                            public void onClick(View view) {\n                                ActivityCompat.requestPermissions(BrowserActivity.this,\n                                        new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},\n                                        REQUEST_PERMISSIONS_WRITE_EXTERNAL_STORAGE);\n                            }\n                        })\n                        .show();"}
{"magic_number_smell": "//         ThreadTools.scheduleSingleExecution(\"SafetyStop\", guiRecorder::stop, 1200.0);\n      }\n\n      primary3DPanel = new RDX3DPanel(VIEW_3D_WINDOW_NAME, 2, true);\n      primary3DPanel.setBackgroundShade((float) view3DBackgroundShade.get());\n   }\n", "refactored_code": "   public static final int ANTI_ALIASING = 2;\n//         ThreadTools.scheduleSingleExecution(\"SafetyStop\", guiRecorder::stop, 1200.0);\n      }\n\n      primary3DPanel = new RDX3DPanel(VIEW_3D_WINDOW_NAME, ANTI_ALIASING, true);\n      primary3DPanel.setBackgroundShade((float) view3DBackgroundShade.get());\n   }\n"}
{"magic_number_smell": "    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);"}
{"magic_number_smell": "    public ChunkHeader next() throws MalformedChunkException, IOException {\n        if (count <= chunkCount) {\n            long currentOffset = this.currentOffset;\n            this.currentOffset += 65536;\n            BinaryReader binaryReader = new BinaryReader(inputStream, 65536);\n            try {\n                return new ChunkHeader(binaryReader, log, currentOffset, count++);", "refactored_code": "    public static final int CHUNK_SIZE = 65536;\n    public ChunkHeader next() throws MalformedChunkException, IOException {\n        if (count <= chunkCount) {\n            long currentOffset = this.currentOffset;\n            this.currentOffset += CHUNK_SIZE;\n            BinaryReader binaryReader = new BinaryReader(inputStream, CHUNK_SIZE);\n            try {\n                return new ChunkHeader(binaryReader, log, currentOffset, count++);"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "\t\t\tscaleY = 0.0f;\n\t\t}\n\n\t\tint scaleXComp = Math.round(scaleX * 10000.0f);\n\t\tint scaleYComp = Math.round(scaleY * 10000.0f);\n\n\t\tint oldScaleXComp = Math.round(oldScales.x * 10000.0f);", "refactored_code": "\tpublic static final float SCALE_FACTOR_ACCURACY = 10000.0f;\n\t\t\tscaleY = 0.0f;\n\t\t}\n\n\t\tint scaleXComp = Math.round(scaleX * SCALE_FACTOR_ACCURACY);\n\t\tint scaleYComp = Math.round(scaleY * SCALE_FACTOR_ACCURACY);\n\n\t\tint oldScaleXComp = Math.round(oldScales.x * SCALE_FACTOR_ACCURACY);"}
{"magic_number_smell": "\n  private final Action selectUnitsAction =\n      new AbstractAction(\"Select Units\") {\n        private static final long -2672163347536778594L = 4745335350716395600L;\n\n        @Override\n        public void actionPerformed(final ActionEvent event) {", "refactored_code": "  private static final long serialVersionUID = -2672163347536778594L;\n\n  private final Action selectUnitsAction =\n      new AbstractAction(\"Select Units\") {\n        private static final long serialVersionUID = 4745335350716395600L;\n\n        @Override\n        public void actionPerformed(final ActionEvent event) {"}
{"magic_number_smell": "                if (\"\".equalsIgnoreCase(pw)) {\n                    startActivity(new Intent(this, AdminPreferencesActivity.class));\n                } else {\n                    showDialog(1);\n                }\n                return true;\n        }", "refactored_code": "    private static final int PASSWORD_DIALOG = 1;\n                if (\"\".equalsIgnoreCase(pw)) {\n                    startActivity(new Intent(this, AdminPreferencesActivity.class));\n                } else {\n                    showDialog(PASSWORD_DIALOG);\n                }\n                return true;\n        }"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "\n    public int getPriority()\n    {\n        return 0;\n    }\n\n    public boolean match( MappingFilter filter, AnyHolder value ) throws UnsupportedFilterableData", "refactored_code": "    public static final int DEFAULT_PRIORITY = 0;\n\n    public int getPriority()\n    {\n        return DEFAULT_PRIORITY;\n    }\n\n    public boolean match( MappingFilter filter, AnyHolder value ) throws UnsupportedFilterableData"}
{"magic_number_smell": "            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > 50 ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;", "refactored_code": "    private static final int INET_CONDITION_THRESHOLD = 50;\n            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;"}
{"magic_number_smell": "        this.bitstream = bitstream;\n        this.parser = listener;\n        this.block = Block.ROOT;\n        this.idSize = 2;\n        this.offset = 0;\n    }\n", "refactored_code": "    private static final int DEFAULT_ID_SIZE = 2;\n        this.bitstream = bitstream;\n        this.parser = listener;\n        this.block = Block.ROOT;\n        this.idSize = DEFAULT_ID_SIZE;\n        this.offset = 0;\n    }\n"}
{"magic_number_smell": "    public WebhookCallback(List<String> remoteEndpoints) {\n        this.remoteEndpoints = remoteEndpoints;\n        requestConfig = RequestConfig.custom()\n            .setConnectTimeout(1000)\n            .setConnectionRequestTimeout(HTTP_CONNECTION_REQUEST_TIMEOUT)\n            .setSocketTimeout(HTTP_SOCKET_TIMEOUT).build();\n    }", "refactored_code": "    private static final int HTTP_CONNECT_TIMEOUT = 1000;\n    public WebhookCallback(List<String> remoteEndpoints) {\n        this.remoteEndpoints = remoteEndpoints;\n        requestConfig = RequestConfig.custom()\n            .setConnectTimeout(HTTP_CONNECT_TIMEOUT)\n            .setConnectionRequestTimeout(HTTP_CONNECTION_REQUEST_TIMEOUT)\n            .setSocketTimeout(HTTP_SOCKET_TIMEOUT).build();\n    }"}
{"magic_number_smell": "    public void testPost() throws Exception {\n        SparkTestUtil.UrlResponse response = testUtil.doMethod(\"POST\", \"/hello\", BODY_CONTENT);\n        LOGGER.info(response.body);\n        Assert.assertEquals(200, response.status);\n        Assert.assertTrue(response.body.contains(BODY_CONTENT));\n\n        Assert.assertEquals(BODY_CONTENT, beforeBody);", "refactored_code": "    private final int HTTP_OK = 200;\n    public void testPost() throws Exception {\n        SparkTestUtil.UrlResponse response = testUtil.doMethod(\"POST\", \"/hello\", BODY_CONTENT);\n        LOGGER.info(response.body);\n        Assert.assertEquals(HTTP_OK, response.status);\n        Assert.assertTrue(response.body.contains(BODY_CONTENT));\n\n        Assert.assertEquals(BODY_CONTENT, beforeBody);"}
{"magic_number_smell": "//         ThreadTools.scheduleSingleExecution(\"SafetyStop\", guiRecorder::stop, 1200.0);\n      }\n\n      primary3DPanel = new RDX3DPanel(VIEW_3D_WINDOW_NAME, 2, true);\n      primary3DPanel.setBackgroundShade((float) view3DBackgroundShade.get());\n   }\n", "refactored_code": "   public static final int ANTI_ALIASING = 2;\n//         ThreadTools.scheduleSingleExecution(\"SafetyStop\", guiRecorder::stop, 1200.0);\n      }\n\n      primary3DPanel = new RDX3DPanel(VIEW_3D_WINDOW_NAME, ANTI_ALIASING, true);\n      primary3DPanel.setBackgroundShade((float) view3DBackgroundShade.get());\n   }\n"}
{"magic_number_smell": "  }\n\n  private boolean isLCDActive() {\n    return mmu.readByte(0xFF40) != 0;\n  }\n\n  private TileColor getTileColor(int x, int y) {", "refactored_code": "  private static final int LCD_GPU_CONTROL_ADDRESS = 0xFF40;\n  }\n\n  private boolean isLCDActive() {\n    return mmu.readByte(LCD_GPU_CONTROL_ADDRESS) != 0;\n  }\n\n  private TileColor getTileColor(int x, int y) {"}
{"magic_number_smell": "    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);"}
{"magic_number_smell": "\t\t\to = (DERTaggedObject)e.nextElement();\n\t\t\t\n\t\t\tswitch (o.getTagNo()) {\n\t\t\t\tcase 0:\n\t\t\t\t\tthis._keyIdentifier = ASN1OctetString.getInstance(o);\n\t\t\t\t\tbreak;\n\t\t\t\tcase tag_IssuerName:", "refactored_code": "\tpublic static final int tag_KeyIdentifier \t\t\t= 0;\n\t\t\to = (DERTaggedObject)e.nextElement();\n\t\t\t\n\t\t\tswitch (o.getTagNo()) {\n\t\t\t\tcase tag_KeyIdentifier:\n\t\t\t\t\tthis._keyIdentifier = ASN1OctetString.getInstance(o);\n\t\t\t\t\tbreak;\n\t\t\t\tcase tag_IssuerName:"}
{"magic_number_smell": "     * @throws IOException If an I/O error occurs\n     */\n    public MemoryMappedFileInputStream(final Path file) throws IOException {\n        this(file, 256 * 1024);\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_BUFFER_SIZE = 256 * 1024;\n     * @throws IOException If an I/O error occurs\n     */\n    public MemoryMappedFileInputStream(final Path file) throws IOException {\n        this(file, DEFAULT_BUFFER_SIZE);\n    }\n\n    /**"}
{"magic_number_smell": "\tprivate static final long MAGIC = MAGIC_BASE | (MAJOR << 8) | MINOR;\r\n\tprivate long magicBytes = MAGIC;\r\n\tpublic static final int MAGIC_CONT = 0x434f4e54;   // \"CONT\"\r\n\tprivate long fileLen = 1024 * 2;\r\n\tprivate int freeListStart = 0;\r\n\tprivate int mounted = 0;\r\n\tpublic int spanSize = 16;\r", "refactored_code": "\tpublic static final long PAGESIZE = 1024;\r\n\tprivate static final long MAGIC = MAGIC_BASE | (MAJOR << 8) | MINOR;\r\n\tprivate long magicBytes = MAGIC;\r\n\tpublic static final int MAGIC_CONT = 0x434f4e54;   // \"CONT\"\r\n\tprivate long fileLen = PAGESIZE * 2;\r\n\tprivate int freeListStart = 0;\r\n\tprivate int mounted = 0;\r\n\tpublic int spanSize = 16;\r"}
{"magic_number_smell": "        return new ConfigDef()\n                .define(NAME_CONFIG, Type.STRING, ConfigDef.NO_DEFAULT_VALUE, nonEmptyStringWithoutControlChars(), Importance.HIGH, NAME_DOC, COMMON_GROUP, ++orderInGroup, Width.MEDIUM, NAME_DISPLAY)\n                .define(CONNECTOR_CLASS_CONFIG, Type.STRING, Importance.HIGH, CONNECTOR_CLASS_DOC, COMMON_GROUP, ++orderInGroup, Width.LONG, CONNECTOR_CLASS_DISPLAY)\n                .define(TASKS_MAX_CONFIG, Type.INT, 1, atLeast(TASKS_MIN_CONFIG), Importance.HIGH, TASKS_MAX_DOC, COMMON_GROUP, ++orderInGroup, Width.SHORT, TASK_MAX_DISPLAY)\n                .define(KEY_CONVERTER_CLASS_CONFIG, Type.CLASS, null, Importance.LOW, KEY_CONVERTER_CLASS_DOC, COMMON_GROUP, ++orderInGroup, Width.SHORT, KEY_CONVERTER_CLASS_DISPLAY)\n                .define(VALUE_CONVERTER_CLASS_CONFIG, Type.CLASS, null, Importance.LOW, VALUE_CONVERTER_CLASS_DOC, COMMON_GROUP, ++orderInGroup, Width.SHORT, VALUE_CONVERTER_CLASS_DISPLAY)\n                .define(HEADER_CONVERTER_CLASS_CONFIG, Type.CLASS, HEADER_CONVERTER_CLASS_DEFAULT, Importance.LOW, HEADER_CONVERTER_CLASS_DOC, COMMON_GROUP, ++orderInGroup, Width.SHORT, HEADER_CONVERTER_CLASS_DISPLAY)", "refactored_code": "    public static final int TASKS_MAX_DEFAULT = 1;\n        return new ConfigDef()\n                .define(NAME_CONFIG, Type.STRING, ConfigDef.NO_DEFAULT_VALUE, nonEmptyStringWithoutControlChars(), Importance.HIGH, NAME_DOC, COMMON_GROUP, ++orderInGroup, Width.MEDIUM, NAME_DISPLAY)\n                .define(CONNECTOR_CLASS_CONFIG, Type.STRING, Importance.HIGH, CONNECTOR_CLASS_DOC, COMMON_GROUP, ++orderInGroup, Width.LONG, CONNECTOR_CLASS_DISPLAY)\n                .define(TASKS_MAX_CONFIG, Type.INT, TASKS_MAX_DEFAULT, atLeast(TASKS_MIN_CONFIG), Importance.HIGH, TASKS_MAX_DOC, COMMON_GROUP, ++orderInGroup, Width.SHORT, TASK_MAX_DISPLAY)\n                .define(KEY_CONVERTER_CLASS_CONFIG, Type.CLASS, null, Importance.LOW, KEY_CONVERTER_CLASS_DOC, COMMON_GROUP, ++orderInGroup, Width.SHORT, KEY_CONVERTER_CLASS_DISPLAY)\n                .define(VALUE_CONVERTER_CLASS_CONFIG, Type.CLASS, null, Importance.LOW, VALUE_CONVERTER_CLASS_DOC, COMMON_GROUP, ++orderInGroup, Width.SHORT, VALUE_CONVERTER_CLASS_DISPLAY)\n                .define(HEADER_CONVERTER_CLASS_CONFIG, Type.CLASS, HEADER_CONVERTER_CLASS_DEFAULT, Importance.LOW, HEADER_CONVERTER_CLASS_DOC, COMMON_GROUP, ++orderInGroup, Width.SHORT, HEADER_CONVERTER_CLASS_DISPLAY)"}
{"magic_number_smell": "     * @param charset the character set name to use\n     */\n    public CharSequenceInputStream(final CharSequence s, final Charset charset) {\n        this(s, charset, 2048);\n    }\n\n    /**", "refactored_code": "    private static final int BUFFER_SIZE = 2048;\n     * @param charset the character set name to use\n     */\n    public CharSequenceInputStream(final CharSequence s, final Charset charset) {\n        this(s, charset, BUFFER_SIZE);\n    }\n\n    /**"}
{"magic_number_smell": "    zkClient = new ZkClient(zkServer.connectString(), 30000, 30000, ZKStringSerializer$.MODULE$);\n    // setup Broker\n    port = TestUtils.choosePort();\n    Properties props = TestUtils.createBrokerConfig(0, port);\n    kafkaServer = TestUtils.createServer(new KafkaConfig(props), new MockTime());\n    // create topic\n    AdminUtils.createTopic(zkClient, TOPIC1, PARTITIONS, REPLICATION_FACTOR, new Properties());", "refactored_code": "  private static final int BROKER_ID = 0;\n    zkClient = new ZkClient(zkServer.connectString(), 30000, 30000, ZKStringSerializer$.MODULE$);\n    // setup Broker\n    port = TestUtils.choosePort();\n    Properties props = TestUtils.createBrokerConfig(BROKER_ID, port);\n    kafkaServer = TestUtils.createServer(new KafkaConfig(props), new MockTime());\n    // create topic\n    AdminUtils.createTopic(zkClient, TOPIC1, PARTITIONS, REPLICATION_FACTOR, new Properties());"}
{"magic_number_smell": "\n\n    public DPXReader(SeekableByteChannel ch) throws IOException {\n        this.readBuf = allocate(2048 + 1024);\n        initialRead(ch);\n        this.magic = readBuf.getInt();\n", "refactored_code": "    private static final int READ_BUFFER_SIZE = 2048 + 1024;\n\n\n    public DPXReader(SeekableByteChannel ch) throws IOException {\n        this.readBuf = allocate(READ_BUFFER_SIZE);\n        initialRead(ch);\n        this.magic = readBuf.getInt();\n"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "  private final ZXPolyModule[] modules;\n  private volatile int currentVideoMode = VIDEOMODE_RESERVED2;\n\n  private Dimension size = new Dimension(512, SCREEN_HEIGHT);\n  private volatile float zoom = 1.0f;\n  private volatile int portFEw = 0;\n", "refactored_code": "  public static final int SCREEN_WIDTH = 512;\n  private final ZXPolyModule[] modules;\n  private volatile int currentVideoMode = VIDEOMODE_RESERVED2;\n\n  private Dimension size = new Dimension(SCREEN_WIDTH, SCREEN_HEIGHT);\n  private volatile float zoom = 1.0f;\n  private volatile int portFEw = 0;\n"}
{"magic_number_smell": "  // Visible for testing.\n  static class DecodeJobFactory {\n    private final DecodeJob.DiskCacheProvider diskCacheProvider;\n    private final Pools.Pool<DecodeJob<?>> pool = FactoryPools.simple(150,\n        new FactoryPools.Factory<DecodeJob<?>>() {\n          @Override\n          public DecodeJob<?> create() {", "refactored_code": "  private static final int JOB_POOL_SIZE = 150;\n  // Visible for testing.\n  static class DecodeJobFactory {\n    private final DecodeJob.DiskCacheProvider diskCacheProvider;\n    private final Pools.Pool<DecodeJob<?>> pool = FactoryPools.simple(JOB_POOL_SIZE,\n        new FactoryPools.Factory<DecodeJob<?>>() {\n          @Override\n          public DecodeJob<?> create() {"}
{"magic_number_smell": "        inflater.inflate(R.menu.menu_sort_artists, menu);\n        inflater.inflate(R.menu.menu_view_as, menu);\n\n        menu.addSubMenu(0, 100, 0, R.string.menu_grid_size);\n        SubMenu subMenu = menu.findItem(100).getSubMenu();\n\n        int[] spanCountArray = getResources().getIntArray(R.array.span_count);", "refactored_code": "    private static final int MENU_GRID_SIZE = 100;\n        inflater.inflate(R.menu.menu_sort_artists, menu);\n        inflater.inflate(R.menu.menu_view_as, menu);\n\n        menu.addSubMenu(0, MENU_GRID_SIZE, 0, R.string.menu_grid_size);\n        SubMenu subMenu = menu.findItem(MENU_GRID_SIZE).getSubMenu();\n\n        int[] spanCountArray = getResources().getIntArray(R.array.span_count);"}
{"magic_number_smell": "  }\n\n  private static class BombardComponent extends JPanel {\n    private static final long 5304208569738042592L = -2388895995673156507L;\n    private final JList<Object> list;\n\n    BombardComponent(", "refactored_code": "  private static final long serialVersionUID = 5304208569738042592L;\n  }\n\n  private static class BombardComponent extends JPanel {\n    private static final long serialVersionUID = -2388895995673156507L;\n    private final JList<Object> list;\n\n    BombardComponent("}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "        }\n\n        long getDefaultDisplayDelayTimeout() {\n            return 10000;\n        }\n    }\n", "refactored_code": "    private static final long WAIT_FOR_DEFAULT_DISPLAY_TIMEOUT = 10000;\n        }\n\n        long getDefaultDisplayDelayTimeout() {\n            return WAIT_FOR_DEFAULT_DISPLAY_TIMEOUT;\n        }\n    }\n"}
{"magic_number_smell": "    in.seek(96);\n    in.order(true);\n\n    boolean little = in.readShort() == -16224;\n    in.order(little);\n    in.seek(0);\n", "refactored_code": "  private static final short LITTLE_ENDIAN = -16224;\n    in.seek(96);\n    in.order(true);\n\n    boolean little = in.readShort() == LITTLE_ENDIAN;\n    in.order(little);\n    in.seek(0);\n"}
{"magic_number_smell": "     * @throws IOException on IO error\n     */\n    static void crossStreams(final InputStream in, final OutputStream out) throws IOException {\n        final byte[] buffer = new byte[0x20000];\n        int len;\n        while ((len = in.read(buffer)) != -1) {\n            out.write(buffer, 0, len);", "refactored_code": "    private static final int bufferSize = 0x20000; // ~130K.\n     * @throws IOException on IO error\n     */\n    static void crossStreams(final InputStream in, final OutputStream out) throws IOException {\n        final byte[] buffer = new byte[bufferSize];\n        int len;\n        while ((len = in.read(buffer)) != -1) {\n            out.write(buffer, 0, len);"}
{"magic_number_smell": "            throw new MQClientException(\"the specified group is blank\", null);\n        }\n\n        if (group.length() > 255) {\n            throw new MQClientException(\"the specified group is longer than group max length 255.\", null);\n        }\n", "refactored_code": "    public static final int CHARACTER_MAX_LENGTH = 255;\n            throw new MQClientException(\"the specified group is blank\", null);\n        }\n\n        if (group.length() > CHARACTER_MAX_LENGTH) {\n            throw new MQClientException(\"the specified group is longer than group max length 255.\", null);\n        }\n"}
{"magic_number_smell": "\t\tint y  = 60;\n\t\tadd(text[0], width-20, y, font, TextRoi.RIGHT, overlay);\n\t\tint xcenter = 410;\n\t\tfont = new Font(\"SansSerif\", Font.PLAIN, 20, LARGE_FONT=45);\n\t\ty += 45;\n\t\tadd(text[1], xcenter, y, font, TextRoi.CENTER, overlay);\n\t\ty += 27;", "refactored_code": "\t\tprivate static final int SMALL_FONT=20, LARGE_FONT=45;\n\t\tint y  = 60;\n\t\tadd(text[0], width-20, y, font, TextRoi.RIGHT, overlay);\n\t\tint xcenter = 410;\n\t\tfont = new Font(\"SansSerif\", Font.PLAIN, SMALL_FONT);\n\t\ty += 45;\n\t\tadd(text[1], xcenter, y, font, TextRoi.CENTER, overlay);\n\t\ty += 27;"}
{"magic_number_smell": "            throw new IllegalArgumentException();\n        if (USE_MODULAR_ALGORITHM &&\n                (isGradedOrder(monomialOrder) || isHomogeneousIdeal(generators))\n                && (tryModular && factory.nVariables <= 3))\n            return ModularGB(generators, monomialOrder, hilbertSeries);\n        if (isGradedOrder(monomialOrder))\n            return F4GB(generators, monomialOrder, hilbertSeries);", "refactored_code": "    private static final int MODULAR_ALGORITHM_MAX_N_VARIABLES = 3;\n            throw new IllegalArgumentException();\n        if (USE_MODULAR_ALGORITHM &&\n                (isGradedOrder(monomialOrder) || isHomogeneousIdeal(generators))\n                && (tryModular && factory.nVariables <= MODULAR_ALGORITHM_MAX_N_VARIABLES))\n            return ModularGB(generators, monomialOrder, hilbertSeries);\n        if (isGradedOrder(monomialOrder))\n            return F4GB(generators, monomialOrder, hilbertSeries);"}
{"magic_number_smell": "    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);"}
{"magic_number_smell": "            }\n            Thread.sleep(timeInMillis);\n            sum += timeInMillis;\n            timeInMillis = Math.min(1000L, timeInMillis * 2);\n        }\n        timeInMillis = maxTimeInMillis - sum;\n        Thread.sleep(Math.max(timeInMillis, 0));", "refactored_code": "    private static final long AWAIT_BUSY_THRESHOLD = 1000L;\n            }\n            Thread.sleep(timeInMillis);\n            sum += timeInMillis;\n            timeInMillis = Math.min(AWAIT_BUSY_THRESHOLD, timeInMillis * 2);\n        }\n        timeInMillis = maxTimeInMillis - sum;\n        Thread.sleep(Math.max(timeInMillis, 0));"}
{"magic_number_smell": "    private static final String TAG = \"BaseImageList\";\n    private static final int 512 = 512;\n    private final LruCache<Integer, BaseImage> mCache =\n            new LruCache<Integer, BaseImage>(512);\n\n    protected ContentResolver mContentResolver;\n    protected int mSort;", "refactored_code": "    private static final int CACHE_CAPACITY = 512;\n    private static final String TAG = \"BaseImageList\";\n    private static final int CACHE_CAPACITY = 512;\n    private final LruCache<Integer, BaseImage> mCache =\n            new LruCache<Integer, BaseImage>(CACHE_CAPACITY);\n\n    protected ContentResolver mContentResolver;\n    protected int mSort;"}
{"magic_number_smell": "\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != 0x414E4554) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n", "refactored_code": "    private static final int FILE_MAGIC = 0x414E4554;\n\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != FILE_MAGIC) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n"}
{"magic_number_smell": "\tprotected FileOutputStream _tapStreamOut = null;\n\tprotected FileOutputStream _tapStreamIn = null;\n\tprotected long _lastHeartbeat = 0;\n\tprotected int _port = 9695;\n\tprotected String _host = DEFAULT_AGENT_HOST;\n\tprotected NetworkProtocol _protocol = SystemConfiguration.AGENT_PROTOCOL;\n", "refactored_code": "\tpublic static final int DEFAULT_AGENT_PORT = 9695; // ccnx registered port\n\tprotected FileOutputStream _tapStreamOut = null;\n\tprotected FileOutputStream _tapStreamIn = null;\n\tprotected long _lastHeartbeat = 0;\n\tprotected int _port = DEFAULT_AGENT_PORT;\n\tprotected String _host = DEFAULT_AGENT_HOST;\n\tprotected NetworkProtocol _protocol = SystemConfiguration.AGENT_PROTOCOL;\n"}
{"magic_number_smell": "        \n        // VERIFY VERSION\n        int version = data[4] & 0xFF;\n        if (version != 0x9B && version != VERSION_2_0_0)\n            return PARSE_FAILED;\n                \n        // PATCH BANK AND NAME", "refactored_code": "    public static final int VERSION_1_5_5 = 0x9B;\n        \n        // VERIFY VERSION\n        int version = data[4] & 0xFF;\n        if (version != VERSION_1_5_5 && version != VERSION_2_0_0)\n            return PARSE_FAILED;\n                \n        // PATCH BANK AND NAME"}
{"magic_number_smell": "  private static final int 100 = 100;\n\n  private static int safePageSize(final int pageSize) {\n    return 0 < pageSize && pageSize <= 100 ? pageSize : 100;\n  }\n\n  public void allOpenPrev(final String pos, final int pageSize,", "refactored_code": "  private static final int MAX_PER_PAGE = 100;\n  private static final int MAX_PER_PAGE = 100;\n\n  private static int safePageSize(final int pageSize) {\n    return 0 < pageSize && pageSize <= MAX_PER_PAGE ? pageSize : MAX_PER_PAGE;\n  }\n\n  public void allOpenPrev(final String pos, final int pageSize,"}
{"magic_number_smell": "        boolean reallyMultiCore = coreSize >= CORE_SIZE_CHECK;\n        int concurrencyLevel = reallyMultiCore ? coreSize * CORE_SIZE_FACTOR : CONCURRENCY_LEVEL;\n        this.executingCalls =\n                new ConcurrentHashMap<RemoteCallKey, RemoteCallKey>(1000, LOAD_FACTOR, concurrencyLevel);\n        this.invocations = new ConcurrentHashMap<Long, BasicInvocation>(1000, LOAD_FACTOR, concurrencyLevel);\n        this.scheduler = new BasicOperationScheduler(node, executionService, new BasicOperationProcessorImpl());\n    }", "refactored_code": "    private static final int INITIAL_CAPACITY = 1000;\n        boolean reallyMultiCore = coreSize >= CORE_SIZE_CHECK;\n        int concurrencyLevel = reallyMultiCore ? coreSize * CORE_SIZE_FACTOR : CONCURRENCY_LEVEL;\n        this.executingCalls =\n                new ConcurrentHashMap<RemoteCallKey, RemoteCallKey>(INITIAL_CAPACITY, LOAD_FACTOR, concurrencyLevel);\n        this.invocations = new ConcurrentHashMap<Long, BasicInvocation>(INITIAL_CAPACITY, LOAD_FACTOR, concurrencyLevel);\n        this.scheduler = new BasicOperationScheduler(node, executionService, new BasicOperationProcessorImpl());\n    }"}
{"magic_number_smell": "        // TODO We limit the notification of config changes to a specific path level, for example\n        //  /dubbo/config/service/configurators, other config changes not in this level will not get notified,\n        //  say /dubbo/config/dubbo.properties\n        if (path.split(\"/\").length >= 5) {\n            String key = pathToKey(path);\n            ConfigChangeType changeType;\n            switch (eventType) {", "refactored_code": "    private static final int MIN_PATH_DEPTH = 5;\n        // TODO We limit the notification of config changes to a specific path level, for example\n        //  /dubbo/config/service/configurators, other config changes not in this level will not get notified,\n        //  say /dubbo/config/dubbo.properties\n        if (path.split(\"/\").length >= MIN_PATH_DEPTH) {\n            String key = pathToKey(path);\n            ConfigChangeType changeType;\n            switch (eventType) {"}
{"magic_number_smell": "\t * @return true means would write log\n\t */\n\tpublic static boolean isLoggable(Level level) {\n\t\tif (level.intValue() <\t_fac_value[FAC_DEFAULT]\t || _fac_value[FAC_DEFAULT] == Level.OFF.intValue()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;", "refactored_code": "\tprotected static final int offValue = Level.OFF.intValue();\n\t * @return true means would write log\n\t */\n\tpublic static boolean isLoggable(Level level) {\n\t\tif (level.intValue() <\t_fac_value[FAC_DEFAULT]\t || _fac_value[FAC_DEFAULT] == offValue) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;"}
{"magic_number_smell": "        }\n\n        long getDefaultDisplayDelayTimeout() {\n            return 10000;\n        }\n    }\n", "refactored_code": "    private static final long WAIT_FOR_DEFAULT_DISPLAY_TIMEOUT = 10000;\n        }\n\n        long getDefaultDisplayDelayTimeout() {\n            return WAIT_FOR_DEFAULT_DISPLAY_TIMEOUT;\n        }\n    }\n"}
{"magic_number_smell": "     * @param cs array of given constants, new ones will be appended\n     */\n    public ConstantPoolGen(Constant[] cs) {\n        StringBuilder sb = new StringBuilder(256);\n\n        size = Math.max(256, cs.length + 64);\n        constants = new Constant[size];", "refactored_code": "    private static final int DEFAULT_BUFFER_SIZE = 256;\n     * @param cs array of given constants, new ones will be appended\n     */\n    public ConstantPoolGen(Constant[] cs) {\n        StringBuilder sb = new StringBuilder(DEFAULT_BUFFER_SIZE);\n\n        size = Math.max(DEFAULT_BUFFER_SIZE, cs.length + 64);\n        constants = new Constant[size];"}
{"magic_number_smell": "    public int hashCode()\n    {\n        int result = eventType.hashCode();\n        result = 31 * result + listener.hashCode();\n        return result;\n    }\n", "refactored_code": "    private static final int HASH_FACTOR = 31;\n    public int hashCode()\n    {\n        int result = eventType.hashCode();\n        result = HASH_FACTOR * result + listener.hashCode();\n        return result;\n    }\n"}
{"magic_number_smell": "    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "                extraMetaData.put(SPECIAL_TYPE_NAME_PREFIX + colName, DBARRAY_SPECIAL_TYPE);\n            }\n        }\n        return new ParquetFileWriter(path, new LocalFSChannelProvider(), 1 << 20,\n                new HeapByteBufferAllocator(), mappedSchema.getParquetSchema(), codecName, extraMetaData);\n    }\n", "refactored_code": "    private static final int PAGE_SIZE = 1 << 20;\n                extraMetaData.put(SPECIAL_TYPE_NAME_PREFIX + colName, DBARRAY_SPECIAL_TYPE);\n            }\n        }\n        return new ParquetFileWriter(path, new LocalFSChannelProvider(), PAGE_SIZE,\n                new HeapByteBufferAllocator(), mappedSchema.getParquetSchema(), codecName, extraMetaData);\n    }\n"}
{"magic_number_smell": "\n    static {\n        Calendar calendar = Calendar.getInstance();\n        calendar.add(Calendar.YEAR, 10);\n        Date inTenYears = calendar.getTime();\n        calendar = Calendar.getInstance();\n        calendar.add(Calendar.YEAR, -10);", "refactored_code": "    private static final int DEFAULT_DATE_RANGE = 10;\n\n    static {\n        Calendar calendar = Calendar.getInstance();\n        calendar.add(Calendar.YEAR, DEFAULT_DATE_RANGE);\n        Date inTenYears = calendar.getTime();\n        calendar = Calendar.getInstance();\n        calendar.add(Calendar.YEAR, -DEFAULT_DATE_RANGE);"}
{"magic_number_smell": "\r\n\t\tBlockFile.pageSeek(bf.file, levelPage);\r\n\t\tlong magic = bf.file.readLong();\r\n\t\tif (magic != 0x42534c6576656c73l)\r\n\t\t\tthrow new IOException(\"Bad SkipLevels magic number 0x\" + Long.toHexString(magic) + \" on page \" + levelPage);\r\n\r\n\t\tbsl.levelHash.put(new Integer(this.levelPage), this);\r", "refactored_code": "\tprivate static final long MAGIC = 0x42534c6576656c73l;  // \"BSLevels\"\r\n\r\n\t\tBlockFile.pageSeek(bf.file, levelPage);\r\n\t\tlong magic = bf.file.readLong();\r\n\t\tif (magic != MAGIC)\r\n\t\t\tthrow new IOException(\"Bad SkipLevels magic number 0x\" + Long.toHexString(magic) + \" on page \" + levelPage);\r\n\r\n\t\tbsl.levelHash.put(new Integer(this.levelPage), this);\r"}
{"magic_number_smell": "    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);"}
{"magic_number_smell": "        // Config for Append-Only test\n        INPUTS = new ArrayList<>();\n        for (int segmentCount : SEGMENT_COUNTS) {\n            int appendCount = 10000 / segmentCount;\n            for (int appendSize : APPEND_SIZES) {\n                for (int burstSize : BURST_SIZES) {\n                    INPUTS.add(new TestInput(segmentCount, appendCount, appendSize, burstSize));", "refactored_code": "    private static final int APPEND_COUNT = 10000;\n        // Config for Append-Only test\n        INPUTS = new ArrayList<>();\n        for (int segmentCount : SEGMENT_COUNTS) {\n            int appendCount = APPEND_COUNT / segmentCount;\n            for (int appendSize : APPEND_SIZES) {\n                for (int burstSize : BURST_SIZES) {\n                    INPUTS.add(new TestInput(segmentCount, appendCount, appendSize, burstSize));"}
{"magic_number_smell": "    public static final Setting<TimeValue> CACHE_TTL_SETTING = Setting.timeSetting(\"cache.ttl\", DEFAULT_TTL, Setting.Property.NodeScope);\n\n    private static final int 100_000 = 100_000; //100k users\n    public static final Setting<Integer> CACHE_MAX_USERS_SETTING = Setting.intSetting(\"cache.max_users\", 100_000,\n            Setting.Property.NodeScope);\n\n    private final Cache<String, UserWithHash> cache;", "refactored_code": "    private static final int DEFAULT_MAX_USERS = 100_000; //100k users\n    public static final Setting<TimeValue> CACHE_TTL_SETTING = Setting.timeSetting(\"cache.ttl\", DEFAULT_TTL, Setting.Property.NodeScope);\n\n    private static final int DEFAULT_MAX_USERS = 100_000; //100k users\n    public static final Setting<Integer> CACHE_MAX_USERS_SETTING = Setting.intSetting(\"cache.max_users\", DEFAULT_MAX_USERS,\n            Setting.Property.NodeScope);\n\n    private final Cache<String, UserWithHash> cache;"}
{"magic_number_smell": "     */\n    public static String shortenPath(File file) {\n        String path = removeCWD(file);\n        if (path.length() < 12 * 2) {\n            return path;\n        }\n        return path.substring(0, 12)", "refactored_code": "    private static final int SHORTENED_PATH_LENGTH = 12;\n     */\n    public static String shortenPath(File file) {\n        String path = removeCWD(file);\n        if (path.length() < SHORTENED_PATH_LENGTH * 2) {\n            return path;\n        }\n        return path.substring(0, SHORTENED_PATH_LENGTH)"}
{"magic_number_smell": "        if (fragment == null) {\n            ConfirmationDialog confirm = ConfirmationDialog.newInstance(\n                    R.string.dlg_delete_all_favorites,\n                    19126);\n            confirm.show(fm, ConfirmationDialog.TAG);\n        }\n    }", "refactored_code": "    public static final int DELETE_ALL_FAVORITES_REQUEST_CODE = 19126;\n        if (fragment == null) {\n            ConfirmationDialog confirm = ConfirmationDialog.newInstance(\n                    R.string.dlg_delete_all_favorites,\n                    DELETE_ALL_FAVORITES_REQUEST_CODE);\n            confirm.show(fm, ConfirmationDialog.TAG);\n        }\n    }"}
{"magic_number_smell": "\n  private final TransactionValidator transactionValidator = mock(TransactionValidator.class);\n  private MutableBlockchain blockchain;\n  private final PendingTransactions transactions = new PendingTransactions(5);\n  private final Transaction transaction1 = createTransaction(1);\n  private final Transaction transaction2 = createTransaction(2);\n  private TransactionPool transactionPool;", "refactored_code": "  private static final int MAX_TRANSACTIONS = 5;\n\n  private final TransactionValidator transactionValidator = mock(TransactionValidator.class);\n  private MutableBlockchain blockchain;\n  private final PendingTransactions transactions = new PendingTransactions(MAX_TRANSACTIONS);\n  private final Transaction transaction1 = createTransaction(1);\n  private final Transaction transaction2 = createTransaction(2);\n  private TransactionPool transactionPool;"}
{"magic_number_smell": "    public static boolean preValidate(String path) throws CTFException {\n        String metadataPath = path + Utils.SEPARATOR + METADATA_FILENAME;\n        File metadataFile = new File(metadataPath);\n        if (metadataFile.exists() && metadataFile.length() > 8) {\n            if (CTFTrace.startsWithMagicNumber(metadataFile, Utils.TSDL_MAGIC) != null) {\n                return true;\n            }", "refactored_code": "    private static final int PREVALIDATION_SIZE = 8;\n    public static boolean preValidate(String path) throws CTFException {\n        String metadataPath = path + Utils.SEPARATOR + METADATA_FILENAME;\n        File metadataFile = new File(metadataPath);\n        if (metadataFile.exists() && metadataFile.length() > PREVALIDATION_SIZE) {\n            if (CTFTrace.startsWithMagicNumber(metadataFile, Utils.TSDL_MAGIC) != null) {\n                return true;\n            }"}
{"magic_number_smell": "    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);"}
{"magic_number_smell": "\n        long recommendedHeartbeatInterval = serverIdleTimeoutMs / 3;\n\n        if (recommendedHeartbeatInterval < 500) {\n            recommendedHeartbeatInterval = 500;\n        }\n", "refactored_code": "    private static final long MIN_RECOMMENDED_HEARTBEAT_INTERVAL = 500;\n\n        long recommendedHeartbeatInterval = serverIdleTimeoutMs / 3;\n\n        if (recommendedHeartbeatInterval < MIN_RECOMMENDED_HEARTBEAT_INTERVAL) {\n            recommendedHeartbeatInterval = MIN_RECOMMENDED_HEARTBEAT_INTERVAL;\n        }\n"}
{"magic_number_smell": "\n\t/**\n\t * Convenient way to encode faces that may be null.\n\t * Null is returned as {@link #6}. \n\t * Use {@link #faceFromIndex(int)} to retrieve encoded face.\n\t */\n\tpublic static int toFaceIndex(Direction face) {", "refactored_code": "\tpublic static final int NULL_FACE_ID = 6;\n\n\t/**\n\t * Convenient way to encode faces that may be null.\n\t * Null is returned as {@link #NULL_FACE_ID}. \n\t * Use {@link #faceFromIndex(int)} to retrieve encoded face.\n\t */\n\tpublic static int toFaceIndex(Direction face) {"}
{"magic_number_smell": "    GeoPoint defCentre = CycleMapDefaults.centre();\n    int lat = pref(PREFS_APP_CENTRE_LAT, (int)(defCentre.getLatitude() * 1E6));\n    int lon = pref(PREFS_APP_CENTRE_LON, (int)(defCentre.getLongitude() * 1E6));\n    int zoom = pref(PREFS_APP_ZOOM_LEVEL, 14);\n    Log.d(TAG, \"onResume: Loading lat/lon=\" + lat + \"/\" + lon + \", zoom=\" + zoom);\n    final GeoPoint centre = new GeoPoint(lat / 1e6, lon / 1e6);\n    getScroller().abortAnimation();", "refactored_code": "  public static final int DEFAULT_ZOOM_LEVEL = 14;\n    GeoPoint defCentre = CycleMapDefaults.centre();\n    int lat = pref(PREFS_APP_CENTRE_LAT, (int)(defCentre.getLatitude() * 1E6));\n    int lon = pref(PREFS_APP_CENTRE_LON, (int)(defCentre.getLongitude() * 1E6));\n    int zoom = pref(PREFS_APP_ZOOM_LEVEL, DEFAULT_ZOOM_LEVEL);\n    Log.d(TAG, \"onResume: Loading lat/lon=\" + lat + \"/\" + lon + \", zoom=\" + zoom);\n    final GeoPoint centre = new GeoPoint(lat / 1e6, lon / 1e6);\n    getScroller().abortAnimation();"}
{"magic_number_smell": "\t\t\tbreak;\n\t\t\tcase ROTATION_STYLE_ALL_AROUND : direction = realRotation;\n\t\t\tbreak;\n\t\t\tcase 0 : direction =\n\t\t\t\t\tisFlipped() ? -DEGREE_UI_OFFSET : DEGREE_UI_OFFSET;\n\t\t}\n\t\treturn direction;", "refactored_code": "\tpublic static final int ROTATION_STYLE_LEFT_RIGHT_ONLY = 0;\n\t\t\tbreak;\n\t\t\tcase ROTATION_STYLE_ALL_AROUND : direction = realRotation;\n\t\t\tbreak;\n\t\t\tcase ROTATION_STYLE_LEFT_RIGHT_ONLY : direction =\n\t\t\t\t\tisFlipped() ? -DEGREE_UI_OFFSET : DEGREE_UI_OFFSET;\n\t\t}\n\t\treturn direction;"}
{"magic_number_smell": "\t\t\t}\n\n\t\t\tif (!from_me && delivery_status == ChatConstants.DS_NEW) {\n\t\t\t\tmarkAsReadDelayed(_id, 2000);\n\t\t\t}\n\n\t\t\tString from = jid;", "refactored_code": "\tprivate static final int DELAY_NEWMSG = 2000;\n\t\t\t}\n\n\t\t\tif (!from_me && delivery_status == ChatConstants.DS_NEW) {\n\t\t\t\tmarkAsReadDelayed(_id, DELAY_NEWMSG);\n\t\t\t}\n\n\t\t\tString from = jid;"}
{"magic_number_smell": "        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+5*1000) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }", "refactored_code": "    private static final long MIN_TIME_BETWEEN_GCS = 5*1000;\n        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+MIN_TIME_BETWEEN_GCS) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }"}
{"magic_number_smell": "          throw new ParserException(\"X-TIMESTAMP-MAP doesn't contain media timestamp: \" + line);\n        } else {\n          mediaTimestampUs = (Long.parseLong(timestampMatcher.group().substring(7)) * 1000)\n              / 90 + mediaTimestampOffsetUs;\n        }\n        mediaTimestampUs = getAdjustedStartTime(mediaTimestampUs);\n      }", "refactored_code": "  private static final long SAMPLING_RATE = 90;\n          throw new ParserException(\"X-TIMESTAMP-MAP doesn't contain media timestamp: \" + line);\n        } else {\n          mediaTimestampUs = (Long.parseLong(timestampMatcher.group().substring(7)) * 1000)\n              / SAMPLING_RATE + mediaTimestampOffsetUs;\n        }\n        mediaTimestampUs = getAdjustedStartTime(mediaTimestampUs);\n      }"}
{"magic_number_smell": "\n    @Getter\n    private static NounListNameGenerator instance = new NounListNameGenerator();\n    private List<String> nouns = new ArrayList<>(6801);\n\n    @SneakyThrows\n    private NounListNameGenerator() {", "refactored_code": "    private static final int NOUN_LIST_LENGTH = 6801;\n\n    @Getter\n    private static NounListNameGenerator instance = new NounListNameGenerator();\n    private List<String> nouns = new ArrayList<>(NOUN_LIST_LENGTH);\n\n    @SneakyThrows\n    private NounListNameGenerator() {"}
{"magic_number_smell": "\t\tthis.tasksToCommitTo = checkNotNull(tasksToCommitTo);\n\t\tthis.pendingCheckpoints = new LinkedHashMap<Long, PendingCheckpoint>();\n\t\tthis.completedCheckpointStore = checkNotNull(completedCheckpointStore);\n\t\tthis.recentPendingCheckpoints = new ArrayDeque<Long>(16);\n\t\tthis.userClassLoader = userClassLoader;\n\n\t\t// Started with the periodic scheduler", "refactored_code": "\tprivate static final int NUM_GHOST_CHECKPOINT_IDS = 16;\n\t\tthis.tasksToCommitTo = checkNotNull(tasksToCommitTo);\n\t\tthis.pendingCheckpoints = new LinkedHashMap<Long, PendingCheckpoint>();\n\t\tthis.completedCheckpointStore = checkNotNull(completedCheckpointStore);\n\t\tthis.recentPendingCheckpoints = new ArrayDeque<Long>(NUM_GHOST_CHECKPOINT_IDS);\n\t\tthis.userClassLoader = userClassLoader;\n\n\t\t// Started with the periodic scheduler"}
{"magic_number_smell": "      transport.writeByte(CLIENT_INTELLIGENCE_HASH_DISTRIBUTION_AWARE);\n      transport.writeVInt(topologyId.get());\n      //todo change once TX support is added\n      transport.writeByte(0);\n      if (log.isTraceEnabled()) {\n         log.tracef(\"wrote header for message %d. Operation code: %#04x. Flags: %#x\",\n                    messageId, operationCode, flagInt);", "refactored_code": "   private static final byte NO_TX = 0;\n      transport.writeByte(CLIENT_INTELLIGENCE_HASH_DISTRIBUTION_AWARE);\n      transport.writeVInt(topologyId.get());\n      //todo change once TX support is added\n      transport.writeByte(NO_TX);\n      if (log.isTraceEnabled()) {\n         log.tracef(\"wrote header for message %d. Operation code: %#04x. Flags: %#x\",\n                    messageId, operationCode, flagInt);"}
{"magic_number_smell": "        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+5*1000) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }", "refactored_code": "    private static final long MIN_TIME_BETWEEN_GCS = 5*1000;\n        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+MIN_TIME_BETWEEN_GCS) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }"}
{"magic_number_smell": "    paramLabel = MANDATORY_INTEGER_FORMAT_HELP,\n    description = \"Maximum p2p peer connections that can be established (default: ${DEFAULT-VALUE})\"\n  )\n  private final Integer maxPeers = 25;\n\n  @Option(\n    names = {\"--max-trailing-peers\"},", "refactored_code": "  private static final int DEFAULT_MAX_PEERS = 25;\n    paramLabel = MANDATORY_INTEGER_FORMAT_HELP,\n    description = \"Maximum p2p peer connections that can be established (default: ${DEFAULT-VALUE})\"\n  )\n  private final Integer maxPeers = DEFAULT_MAX_PEERS;\n\n  @Option(\n    names = {\"--max-trailing-peers\"},"}
{"magic_number_smell": "            return;\n        }\n        final Rectangle r = getVisibleRect();\n        final boolean scrollUp = (cursor.y - r.y) < GroupsTree.10;\n        final boolean scrollDown = ((r.y + r.height) - cursor.y) < GroupsTree.10;\n        final boolean scrollLeft = (cursor.x - r.x) < GroupsTree.10;\n        final boolean scrollRight = ((r.x + r.width) - cursor.x) < GroupsTree.10;", "refactored_code": "    private static final int DRAG_SCROLL_ACTIVATION_MARGIN = 10;\n            return;\n        }\n        final Rectangle r = getVisibleRect();\n        final boolean scrollUp = (cursor.y - r.y) < GroupsTree.DRAG_SCROLL_ACTIVATION_MARGIN;\n        final boolean scrollDown = ((r.y + r.height) - cursor.y) < GroupsTree.DRAG_SCROLL_ACTIVATION_MARGIN;\n        final boolean scrollLeft = (cursor.x - r.x) < GroupsTree.DRAG_SCROLL_ACTIVATION_MARGIN;\n        final boolean scrollRight = ((r.x + r.width) - cursor.x) < GroupsTree.DRAG_SCROLL_ACTIVATION_MARGIN;"}
{"magic_number_smell": "     * When running sychonously, return events can be received over transports that\n     * support ack or replyTo This property determines how long to wait for a receive\n     */\n    private int synchronousEventTimeout = 10000;\n\n    /**\n     * The default transaction timeout value used if no specific transaction time out", "refactored_code": "    public static final int DEFAULT_TIMEOUT = 10000;\n     * When running sychonously, return events can be received over transports that\n     * support ack or replyTo This property determines how long to wait for a receive\n     */\n    private int synchronousEventTimeout = DEFAULT_TIMEOUT;\n\n    /**\n     * The default transaction timeout value used if no specific transaction time out"}
{"magic_number_smell": "\n    protected BaseImageList mContainer;\n\n    private int mWidth = -1;\n    private int mHeight = -1;\n\n    protected BaseImage(BaseImageList container, ContentResolver cr,", "refactored_code": "    private static final int UNKNOWN_LENGTH = -1;\n\n    protected BaseImageList mContainer;\n\n    private int mWidth = UNKNOWN_LENGTH;\n    private int mHeight = UNKNOWN_LENGTH;\n\n    protected BaseImage(BaseImageList container, ContentResolver cr,"}
{"magic_number_smell": "        }\n\n        long getDefaultDisplayDelayTimeout() {\n            return 10000;\n        }\n    }\n", "refactored_code": "    private static final long WAIT_FOR_DEFAULT_DISPLAY_TIMEOUT = 10000;\n        }\n\n        long getDefaultDisplayDelayTimeout() {\n            return WAIT_FOR_DEFAULT_DISPLAY_TIMEOUT;\n        }\n    }\n"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "            } else {\r\n                // Set minimum size and adjust after all components have\r\n                // (supposedly) been drawn completely.\r\n                DOM.setStyleAttribute(base, styleAttribute, 50 + \"px\");\r\n                DeferredCommand.addCommand(new Command() {\r\n                    public void execute() {\r\n                        final Element p = DOM.getParent(getElement());\r", "refactored_code": "    private static final int MIN_SIZE = 50;\r\n            } else {\r\n                // Set minimum size and adjust after all components have\r\n                // (supposedly) been drawn completely.\r\n                DOM.setStyleAttribute(base, styleAttribute, MIN_SIZE + \"px\");\r\n                DeferredCommand.addCommand(new Command() {\r\n                    public void execute() {\r\n                        final Element p = DOM.getParent(getElement());\r"}
{"magic_number_smell": "    in.seek(96);\n    in.order(true);\n\n    boolean little = in.readShort() == -16224;\n    in.order(little);\n    in.seek(0);\n", "refactored_code": "  private static final short LITTLE_ENDIAN = -16224;\n    in.seek(96);\n    in.order(true);\n\n    boolean little = in.readShort() == LITTLE_ENDIAN;\n    in.order(little);\n    in.seek(0);\n"}
{"magic_number_smell": "    public void getMethodPathValid() throws Exception {\n        ServiceResponse<Void> response = client.getMethodPathValid(unencodedPath);\n        // Will throw ServiceException if not 200.\n        //Assert.assertEquals(200, response.getResponse().code());\n    }\n\n    @Ignore(\"wait for this release -- https://github.com/square/retrofit/commit/2ea70568bd057fa9235ae5183cebbde1659af84d\")", "refactored_code": "    private static final int OK_STATUS_CODE = 200;\n    public void getMethodPathValid() throws Exception {\n        ServiceResponse<Void> response = client.getMethodPathValid(unencodedPath);\n        // Will throw ServiceException if not 200.\n        //Assert.assertEquals(OK_STATUS_CODE, response.getResponse().code());\n    }\n\n    @Ignore(\"wait for this release -- https://github.com/square/retrofit/commit/2ea70568bd057fa9235ae5183cebbde1659af84d\")"}
{"magic_number_smell": "\t}\n\t\n\tprivate Ref<ACell> write(AArrayBlob key, int keyOffset, Ref<ACell> value, long indexPosition) throws IOException {\n\t\tif (keyOffset>=32) {\n\t\t\tthrow new Error(\"Offset exceeded for key: \"+key);\n\t\t}\n\t\t", "refactored_code": "\tprivate static final int KEY_SIZE=32;\n\t}\n\t\n\tprivate Ref<ACell> write(AArrayBlob key, int keyOffset, Ref<ACell> value, long indexPosition) throws IOException {\n\t\tif (keyOffset>=KEY_SIZE) {\n\t\t\tthrow new Error(\"Offset exceeded for key: \"+key);\n\t\t}\n\t\t"}
{"magic_number_smell": "        showButton.setActionCommand(SHOW);\n        showButton.addActionListener(this);\n\n        add(Utility.getDefaultTextArea(message, 40), \"wrap 20\");\n        add(okButton, \"split 2, tag ok\");\n        add(showButton);\n    }", "refactored_code": "    private static final int columnWidth = 40;\n        showButton.setActionCommand(SHOW);\n        showButton.addActionListener(this);\n\n        add(Utility.getDefaultTextArea(message, columnWidth), \"wrap 20\");\n        add(okButton, \"split 2, tag ok\");\n        add(showButton);\n    }"}
{"magic_number_smell": "    server.start();\n\n    System.setProperty(client + \".niws.client.MaxAutoRetries\", \"0\");\n    System.setProperty(client + \".niws.client.MaxAutoRetriesNextServer\", \"\" + 1);\n    System.setProperty(client + \".niws.client.OkToRetryOnAllOperations\", \"true\");\n    System.setProperty(client + \".niws.client.NIWSServerListClassName\",\n        \"com.netflix.loadbalancer.ConfigurationBasedServerList\");", "refactored_code": "  private static final int retries = 1; // TODO: it seems to be ignoring retry property\n    server.start();\n\n    System.setProperty(client + \".niws.client.MaxAutoRetries\", \"0\");\n    System.setProperty(client + \".niws.client.MaxAutoRetriesNextServer\", \"\" + retries);\n    System.setProperty(client + \".niws.client.OkToRetryOnAllOperations\", \"true\");\n    System.setProperty(client + \".niws.client.NIWSServerListClassName\",\n        \"com.netflix.loadbalancer.ConfigurationBasedServerList\");"}
{"magic_number_smell": "\n        public BabyGiantSteps(Poly poly) {\n            int n = poly.degree();\n            l = (int) Math.ceil(Math.pow(1.0 * n, 0.5));\n            m = (int) Math.ceil(1.0 * n / 2 / l);\n\n            invMod = UnivariateDivision.fastDivisionPreConditioning(poly);", "refactored_code": "    private static final double SHOUP_BETA = 0.5;\n\n        public BabyGiantSteps(Poly poly) {\n            int n = poly.degree();\n            l = (int) Math.ceil(Math.pow(1.0 * n, SHOUP_BETA));\n            m = (int) Math.ceil(1.0 * n / 2 / l);\n\n            invMod = UnivariateDivision.fastDivisionPreConditioning(poly);"}
{"magic_number_smell": "            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + AlarmManager.INTERVAL_HOUR;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {", "refactored_code": "    private static final long BACKUP_INTERVAL = AlarmManager.INTERVAL_HOUR;\n            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + BACKUP_INTERVAL;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {"}
{"magic_number_smell": "    try {\n      this.id = id;\n      this.files = files;\n      this.chunkSize = 64 * 1024 * 1024 / pageSize;\n\n      this.pageSize = pageSize;\n      this.writeAheadLog = writeAheadLog;", "refactored_code": "  private static final int CHUNK_SIZE = 64 * 1024 * 1024;\n    try {\n      this.id = id;\n      this.files = files;\n      this.chunkSize = CHUNK_SIZE / pageSize;\n\n      this.pageSize = pageSize;\n      this.writeAheadLog = writeAheadLog;"}
{"magic_number_smell": "\n    final DiscoveryTestSocket discoveryTestSocket;\n    try {\n      discoveryTestSocket = result.get(5, TimeUnit.SECONDS);\n    } catch (final Exception ex) {\n      throw new AssertionError(\"Could not initialize test peer\", ex);\n    }", "refactored_code": "  private static final int TEST_SOCKET_START_TIMEOUT_SECS = 5;\n\n    final DiscoveryTestSocket discoveryTestSocket;\n    try {\n      discoveryTestSocket = result.get(TEST_SOCKET_START_TIMEOUT_SECS, TimeUnit.SECONDS);\n    } catch (final Exception ex) {\n      throw new AssertionError(\"Could not initialize test peer\", ex);\n    }"}
{"magic_number_smell": "\tprivate static final BlendMode[] BLEND_MODES = BlendMode.values();\n\n\tprivate static final int MathHelper.smallestEncompassingPowerOfTwo(BlendMode.values().length) - 1 = MathHelper.smallestEncompassingPowerOfTwo(BlendMode.values().length) - 1;\n\tprivate static final int COLOR_DISABLE_FLAG = MathHelper.smallestEncompassingPowerOfTwo(BlendMode.values().length) - 1 + 1;\n\tprivate static final int EMISSIVE_FLAG = COLOR_DISABLE_FLAG << 1;\n\tprivate static final int DIFFUSE_FLAG = EMISSIVE_FLAG << 1;\n\tprivate static final int AO_FLAG = DIFFUSE_FLAG << 1;", "refactored_code": "\tprivate static final int BLEND_MODE_MASK = MathHelper.smallestEncompassingPowerOfTwo(BlendMode.values().length) - 1;\n\tprivate static final BlendMode[] BLEND_MODES = BlendMode.values();\n\n\tprivate static final int BLEND_MODE_MASK = MathHelper.smallestEncompassingPowerOfTwo(BlendMode.values().length) - 1;\n\tprivate static final int COLOR_DISABLE_FLAG = BLEND_MODE_MASK + 1;\n\tprivate static final int EMISSIVE_FLAG = COLOR_DISABLE_FLAG << 1;\n\tprivate static final int DIFFUSE_FLAG = EMISSIVE_FLAG << 1;\n\tprivate static final int AO_FLAG = DIFFUSE_FLAG << 1;"}
{"magic_number_smell": "                setId(lastItem.getItemId() + ID_PROMOTION_OFFSET);\n                itemMap.clear();\n            } else {\n                itemList = new ArrayList<CollectionItem>(1000);\n            }\n            itemMap = null;\n        }", "refactored_code": "    private static final int INITIAL_CAPACITY = 1000;\n                setId(lastItem.getItemId() + ID_PROMOTION_OFFSET);\n                itemMap.clear();\n            } else {\n                itemList = new ArrayList<CollectionItem>(INITIAL_CAPACITY);\n            }\n            itemMap = null;\n        }"}
{"magic_number_smell": "            }\n\n            boolean result = false;\n            for (int i = 0; i < 10 && !result; i++) {\n                result = CommitLog.this.mappedFileQueue.commit(0);\n                CommitLog.log.info(this.getServiceName() + \" service shutdown, retry \" + (i + 1) + \" times \" + (result ? \"OK\" : \"Not OK\"));\n            }", "refactored_code": "        protected static final int RETRY_TIMES_OVER = 10;\n            }\n\n            boolean result = false;\n            for (int i = 0; i < RETRY_TIMES_OVER && !result; i++) {\n                result = CommitLog.this.mappedFileQueue.commit(0);\n                CommitLog.log.info(this.getServiceName() + \" service shutdown, retry \" + (i + 1) + \" times \" + (result ? \"OK\" : \"Not OK\"));\n            }"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "\tprotected FileOutputStream _tapStreamOut = null;\n\tprotected FileOutputStream _tapStreamIn = null;\n\tprotected long _lastHeartbeat = 0;\n\tprotected int _port = 9695;\n\tprotected String _host = DEFAULT_AGENT_HOST;\n\tprotected NetworkProtocol _protocol = SystemConfiguration.AGENT_PROTOCOL;\n", "refactored_code": "\tpublic static final int DEFAULT_AGENT_PORT = 9695; // ccnx registered port\n\tprotected FileOutputStream _tapStreamOut = null;\n\tprotected FileOutputStream _tapStreamIn = null;\n\tprotected long _lastHeartbeat = 0;\n\tprotected int _port = DEFAULT_AGENT_PORT;\n\tprotected String _host = DEFAULT_AGENT_HOST;\n\tprotected NetworkProtocol _protocol = SystemConfiguration.AGENT_PROTOCOL;\n"}
{"magic_number_smell": "            return false;\n        }\n\n        if (topic.length() > 127) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(\"The specified topic is longer than topic max length.\");\n            return false;", "refactored_code": "    private static final int TOPIC_MAX_LENGTH = 127;\n            return false;\n        }\n\n        if (topic.length() > TOPIC_MAX_LENGTH) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(\"The specified topic is longer than topic max length.\");\n            return false;"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "        }\n\n        final int release = Integer.parseInt(System.getProperty(\"java.version\").substring(6));\n        if (release < 60) {\n            JOptionPane.showMessageDialog(null, ResourceUtils.getString(\"Message.JFX\"),\n                    ResourceUtils.getString(\"Title.Error\"), JOptionPane.ERROR_MESSAGE);\n            return;", "refactored_code": "    private static final int JAVA_RELEASE = 60;\n        }\n\n        final int release = Integer.parseInt(System.getProperty(\"java.version\").substring(6));\n        if (release < JAVA_RELEASE) {\n            JOptionPane.showMessageDialog(null, ResourceUtils.getString(\"Message.JFX\"),\n                    ResourceUtils.getString(\"Title.Error\"), JOptionPane.ERROR_MESSAGE);\n            return;"}
{"magic_number_smell": "    /**\n     * <p>Finds the index of the given object in the array.</p>\n     *\n     * <p>This method returns {@link #-1} (<code>-1</code>) for a <code>null</code> input array.</p>\n     * \n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param objectToFind  the object to find, may be <code>null</code>", "refactored_code": "    public static final int INDEX_NOT_FOUND = -1;\n    /**\n     * <p>Finds the index of the given object in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     * \n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param objectToFind  the object to find, may be <code>null</code>"}
{"magic_number_smell": "            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + AlarmManager.INTERVAL_HOUR;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {", "refactored_code": "    private static final long BACKUP_INTERVAL = AlarmManager.INTERVAL_HOUR;\n            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + BACKUP_INTERVAL;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);"}
{"magic_number_smell": "\n                // If there wasn't a key string in config, make one\n                if (material == null) {\n                    material = new byte[128];\n                    new SecureRandom().nextBytes(material);\n                }\n                // Hash the key string given in config", "refactored_code": "    private static final int MIN_KEY_BYTES = 128;\n\n                // If there wasn't a key string in config, make one\n                if (material == null) {\n                    material = new byte[MIN_KEY_BYTES];\n                    new SecureRandom().nextBytes(material);\n                }\n                // Hash the key string given in config"}
{"magic_number_smell": "        LOGGER.info(\"Collection \" + collectionName + \" is stored in partition \" + partitionId);\n\n        // scale up\n        LOGGER.info(\"Scaling up to \" + (4 + 1) + \" members...\");\n        for (int backupCount = 1; backupCount <= 4; backupCount++) {\n            factory.newHazelcastInstance(config);\n            waitAllForSafeState(factory.getAllHazelcastInstances());", "refactored_code": "    protected static final int BACKUP_COUNT = 4;\n        LOGGER.info(\"Collection \" + collectionName + \" is stored in partition \" + partitionId);\n\n        // scale up\n        LOGGER.info(\"Scaling up to \" + (BACKUP_COUNT + 1) + \" members...\");\n        for (int backupCount = 1; backupCount <= BACKUP_COUNT; backupCount++) {\n            factory.newHazelcastInstance(config);\n            waitAllForSafeState(factory.getAllHazelcastInstances());"}
{"magic_number_smell": "        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+5*1000) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }", "refactored_code": "    private static final long MIN_TIME_BETWEEN_GCS = 5*1000;\n        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+MIN_TIME_BETWEEN_GCS) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }"}
{"magic_number_smell": "\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != 0x414E4554) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n", "refactored_code": "    private static final int FILE_MAGIC = 0x414E4554;\n\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != FILE_MAGIC) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n"}
{"magic_number_smell": "          throws Exception {\n    // CHECKSTYLE:ON\n    if (count < 1)\n      count = 20;\n\n    WorkflowQuery q = new WorkflowQuery();\n    q.withCount(count);", "refactored_code": "  private static final int DEFAULT_LIMIT = 20;\n          throws Exception {\n    // CHECKSTYLE:ON\n    if (count < 1)\n      count = DEFAULT_LIMIT;\n\n    WorkflowQuery q = new WorkflowQuery();\n    q.withCount(count);"}
{"magic_number_smell": "        String footer = '\\n' + importFormatsList + outFormatsList + \"\\nPlease report issues at https://github.com/JabRef/jabref/issues.\";\n\n        HelpFormatter formatter = new HelpFormatter();\n        formatter.printHelp(100, \"jabref [OPTIONS] [BIBTEX_FILE]\\n\\nOptions:\", header, getOptions(), footer, true);\n    }\n\n    private String getVersionInfo() {", "refactored_code": "    private static final int WIDTH = 100; // Number of characters per line\n        String footer = '\\n' + importFormatsList + outFormatsList + \"\\nPlease report issues at https://github.com/JabRef/jabref/issues.\";\n\n        HelpFormatter formatter = new HelpFormatter();\n        formatter.printHelp(WIDTH, \"jabref [OPTIONS] [BIBTEX_FILE]\\n\\nOptions:\", header, getOptions(), footer, true);\n    }\n\n    private String getVersionInfo() {"}
{"magic_number_smell": "                    copyTextPaint,\n                    copyWidthForDropCap,\n                    Layout.Alignment.ALIGN_NORMAL,\n                    1.0f,\n                    lineSpacingExtra,\n                    true\n            );", "refactored_code": "    private static final float SPACING_MULTIPLIER = 1.0f;\n                    copyTextPaint,\n                    copyWidthForDropCap,\n                    Layout.Alignment.ALIGN_NORMAL,\n                    SPACING_MULTIPLIER,\n                    lineSpacingExtra,\n                    true\n            );"}
{"magic_number_smell": "            @Override\n            public boolean hasNext()\n            {\n                return position < groupByHash.getGroupCount();\n            }\n\n            @Override", "refactored_code": "            private final int totalPositions = groupByHash.getGroupCount();\n            @Override\n            public boolean hasNext()\n            {\n                return position < totalPositions;\n            }\n\n            @Override"}
{"magic_number_smell": " ActionListener, AdjustmentListener, FocusListener, ItemListener, Runnable{\n\n\tprivate static final int 0, RGB=1, LAB=2, YUV=3=0, RGB=1, LAB=2, YUV=3;\n\tprivate static final String[] colorSpaces = {\"0, RGB=1, LAB=2, YUV=3\", \"RGB\", \"Lab\", \"YUV\"};\n\tprivate boolean flag = false;\n\tprivate int colorSpace = 0, RGB=1, LAB=2, YUV=3;\n\tprivate Thread thread;", "refactored_code": "\tprivate static final int HSB=0, RGB=1, LAB=2, YUV=3;\n ActionListener, AdjustmentListener, FocusListener, ItemListener, Runnable{\n\n\tprivate static final int HSB=0, RGB=1, LAB=2, YUV=3;\n\tprivate static final String[] colorSpaces = {\"HSB\", \"RGB\", \"Lab\", \"YUV\"};\n\tprivate boolean flag = false;\n\tprivate int colorSpace = HSB;\n\tprivate Thread thread;"}
{"magic_number_smell": "    @Test(dataProvider = \"hashEnabledAndMemoryLimitForMergeValues\")\n    public void testHashBuilderResize(boolean hashEnabled, boolean spillEnabled, long memoryLimitForMerge, long memoryLimitForMergeWithMemory)\n    {\n        BlockBuilder builder = VARCHAR.createBlockBuilder(null, 1, 64 * 1024);\n        VARCHAR.writeSlice(builder, Slices.allocate(200_000)); // this must be larger than 64 * 1024, 64K\n        builder.build();\n", "refactored_code": "    private static final int MAX_BLOCK_SIZE_IN_BYTES = 64 * 1024;\n    @Test(dataProvider = \"hashEnabledAndMemoryLimitForMergeValues\")\n    public void testHashBuilderResize(boolean hashEnabled, boolean spillEnabled, long memoryLimitForMerge, long memoryLimitForMergeWithMemory)\n    {\n        BlockBuilder builder = VARCHAR.createBlockBuilder(null, 1, MAX_BLOCK_SIZE_IN_BYTES);\n        VARCHAR.writeSlice(builder, Slices.allocate(200_000)); // this must be larger than MAX_BLOCK_SIZE_IN_BYTES, 64K\n        builder.build();\n"}
{"magic_number_smell": "        if (effect == null || dur == -1 || amp == -1) {\n            return null;\n        } else {\n            return new PotionEffect(effect, dur * 20, amp);\n        }\n    }\n    ", "refactored_code": "    private static final int TICKS_PER_SECOND = 20;\n        if (effect == null || dur == -1 || amp == -1) {\n            return null;\n        } else {\n            return new PotionEffect(effect, dur * TICKS_PER_SECOND, amp);\n        }\n    }\n    "}
{"magic_number_smell": "     */\n    public static final int STEP_INITIAL_LOADING = 9;\n\n    @SwapStep private int step = 1;\n\n    /**\n     * Current screen that the swap process is up to.", "refactored_code": "    public static final int STEP_INTRO           = 1;\n     */\n    public static final int STEP_INITIAL_LOADING = 9;\n\n    @SwapStep private int step = STEP_INTRO;\n\n    /**\n     * Current screen that the swap process is up to."}
{"magic_number_smell": "        if (parts.length == 2) {\n            if (parts[1].matches(\"\\\\d{1,3}\")) { // Need to eliminate signs\n                int bits = Integer.parseInt(parts[1]); // cannot fail because of RE check\n                if (bits < 0 || bits > 128) {\n                    return false; // out of range\n                }\n            } else {", "refactored_code": "    private static final int MAX_BYTE = 128;\n        if (parts.length == 2) {\n            if (parts[1].matches(\"\\\\d{1,3}\")) { // Need to eliminate signs\n                int bits = Integer.parseInt(parts[1]); // cannot fail because of RE check\n                if (bits < 0 || bits > MAX_BYTE) {\n                    return false; // out of range\n                }\n            } else {"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    /**\n     * Offset within the log meta data where the active term id is stored.\n     */\n    public static final int LOG_META_DATA_SECTION_INDEX = 3 * 2;\n\n    /**\n     * Offset within the log meta data where the active term id is stored.", "refactored_code": "    public static final int PARTITION_COUNT = 3;\n    /**\n     * Offset within the log meta data where the active term id is stored.\n     */\n    public static final int LOG_META_DATA_SECTION_INDEX = PARTITION_COUNT * 2;\n\n    /**\n     * Offset within the log meta data where the active term id is stored."}
{"magic_number_smell": "                }\r\n            }\r\n        }\r\n        RetryTimerTask retryTimerTask = new RetryTimerTask(loadbalance, invocation, invokers, lastInvoker, retries, 5);\r\n        try {\r\n            failTimer.newTimeout(retryTimerTask, 5, TimeUnit.SECONDS);\r\n        } catch (Throwable e) {\r", "refactored_code": "    private static final long RETRY_FAILED_PERIOD = 5;\r\n                }\r\n            }\r\n        }\r\n        RetryTimerTask retryTimerTask = new RetryTimerTask(loadbalance, invocation, invokers, lastInvoker, retries, RETRY_FAILED_PERIOD);\r\n        try {\r\n            failTimer.newTimeout(retryTimerTask, RETRY_FAILED_PERIOD, TimeUnit.SECONDS);\r\n        } catch (Throwable e) {\r"}
{"magic_number_smell": "    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #-1}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode", "refactored_code": "    public static final int INFINITE = -1;\n    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #INFINITE}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode"}
{"magic_number_smell": "\t\t\t\t\t\tt = position;\n\t\t\t\t}\n\t\t\t\tif (((c==0||c==channel) && (z==0||z==slice) && (t==0||t==frame)) || roiManagerShowAllMode)\n\t\t\t\t\tdrawRoi(g, roi, drawLabels?i+100000:-1);\n\t\t\t} else {\n\t\t\t\tint position =  stackSize>1?roi.getPosition():0;\n\t\t\t\tif (position==0 && stackSize>1)", "refactored_code": "    private static final int LIST_OFFSET = 100000;\n\t\t\t\t\t\tt = position;\n\t\t\t\t}\n\t\t\t\tif (((c==0||c==channel) && (z==0||z==slice) && (t==0||t==frame)) || roiManagerShowAllMode)\n\t\t\t\t\tdrawRoi(g, roi, drawLabels?i+LIST_OFFSET:-1);\n\t\t\t} else {\n\t\t\t\tint position =  stackSize>1?roi.getPosition():0;\n\t\t\t\tif (position==0 && stackSize>1)"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "        } else if (stripChars.length() == 0) {\n            return str;\n        } else {\n            while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != -1)) {\n                start++;\n            }\n        }", "refactored_code": "    public static final int INDEX_NOT_FOUND = -1;\n        } else if (stripChars.length() == 0) {\n            return str;\n        } else {\n            while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) {\n                start++;\n            }\n        }"}
{"magic_number_smell": "\n    protected BaseImageList mContainer;\n\n    private int mWidth = -1;\n    private int mHeight = -1;\n\n    protected BaseImage(BaseImageList container, ContentResolver cr,", "refactored_code": "    private static final int UNKNOWN_LENGTH = -1;\n\n    protected BaseImageList mContainer;\n\n    private int mWidth = UNKNOWN_LENGTH;\n    private int mHeight = UNKNOWN_LENGTH;\n\n    protected BaseImage(BaseImageList container, ContentResolver cr,"}
{"magic_number_smell": "  @Override\n  public void prepareForTransitWith() {\n    this.onTripIndex = UNBOUNDED_TRIP_INDEX;\n    this.onTripBoardTime = -1;\n    this.onTripBoardStop = -1;\n    this.onTrip = null;\n  }", "refactored_code": "  private static final int NOT_SET = -1;\n  @Override\n  public void prepareForTransitWith() {\n    this.onTripIndex = UNBOUNDED_TRIP_INDEX;\n    this.onTripBoardTime = NOT_SET;\n    this.onTripBoardStop = NOT_SET;\n    this.onTrip = null;\n  }"}
{"magic_number_smell": "\n        //initialise date randomizer to generate dates in [now - 10 years, now + 10 years]\n        Calendar calendar = Calendar.getInstance();\n        calendar.add(Calendar.YEAR, 10);\n        Date inTenYears = calendar.getTime();\n        calendar = Calendar.getInstance();\n        calendar.add(Calendar.YEAR, -10);", "refactored_code": "    private static final int DEFAULT_DATE_RANGE = 10;\n\n        //initialise date randomizer to generate dates in [now - 10 years, now + 10 years]\n        Calendar calendar = Calendar.getInstance();\n        calendar.add(Calendar.YEAR, DEFAULT_DATE_RANGE);\n        Date inTenYears = calendar.getTime();\n        calendar = Calendar.getInstance();\n        calendar.add(Calendar.YEAR, -DEFAULT_DATE_RANGE);"}
{"magic_number_smell": "                            }\r\n                        }\r\n                    }\r\n                }, 1200, 1200);\r\n                if (verbose)\r\n                {\r\n                    getLogger().log(Level.INFO, \"Scheduled the XRay checker.\");\r", "refactored_code": "    private static final long XRAY_TIME = 1200;\r\n                            }\r\n                        }\r\n                    }\r\n                }, XRAY_TIME, XRAY_TIME);\r\n                if (verbose)\r\n                {\r\n                    getLogger().log(Level.INFO, \"Scheduled the XRay checker.\");\r"}
{"magic_number_smell": "    public AdapterResponse<Feed> getFeed(GetFeedRequest getFeedRequest) {\n        AdapterResponse<Feed> response;\n\n        int pageSize = 25;\n        final String pageSizeString = getFeedRequest.getPageSize();\n\n        if (StringUtils.isNotBlank(pageSizeString)) {", "refactored_code": "    private static final int PAGE_SIZE = 25;\n    public AdapterResponse<Feed> getFeed(GetFeedRequest getFeedRequest) {\n        AdapterResponse<Feed> response;\n\n        int pageSize = PAGE_SIZE;\n        final String pageSizeString = getFeedRequest.getPageSize();\n\n        if (StringUtils.isNotBlank(pageSizeString)) {"}
