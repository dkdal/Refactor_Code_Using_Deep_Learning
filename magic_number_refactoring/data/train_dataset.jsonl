{"magic_number_smell": "\n  private static final int 10000 = 10000;\n\n  private final int numEntities;\n\n  private final Component[] renderComponents = new RenderComponent[10000];\n\n  public RenderComponentManager(int numEntities) {\n    this.numEntities = numEntities;\n  }\n", "refactored_code": "  private static final int MAX_ENTITIES = 10000;\n\n  private static final int MAX_ENTITIES = 10000;\n\n  private final int numEntities;\n\n  private final Component[] renderComponents = new RenderComponent[MAX_ENTITIES];\n\n  public RenderComponentManager(int numEntities) {\n    this.numEntities = numEntities;\n  }\n"}
{"magic_number_smell": "  private static final int FAILED = 2;\n  private static final int COMPLETED = 3;\n\n  private final Object lock;\n\n  private volatile int state = 1;\n  private T value;\n  private Exception exception;\n\n  PromiseSupport() {\n    this.lock = new Object();", "refactored_code": "  private static final int RUNNING = 1;\n  private static final int FAILED = 2;\n  private static final int COMPLETED = 3;\n\n  private final Object lock;\n\n  private volatile int state = RUNNING;\n  private T value;\n  private Exception exception;\n\n  PromiseSupport() {\n    this.lock = new Object();"}
{"magic_number_smell": "    private static String withOutRetryAndDLQ(String originalResource) {\n        if (StringUtils.isEmpty(originalResource)) {\n            return STRING_BLANK;\n        }\n        if (isRetryTopic(originalResource)) {\n            return originalResource.substring(MixAll.RETRY_GROUP_TOPIC_PREFIX.length());\n        }\n\n        if (isDLQTopic(originalResource)) {\n            return originalResource.substring(DLQ_PREFIX_LENGTH);\n        }", "refactored_code": "    public static final int RETRY_PREFIX_LENGTH = MixAll.RETRY_GROUP_TOPIC_PREFIX.length();\n    private static String withOutRetryAndDLQ(String originalResource) {\n        if (StringUtils.isEmpty(originalResource)) {\n            return STRING_BLANK;\n        }\n        if (isRetryTopic(originalResource)) {\n            return originalResource.substring(RETRY_PREFIX_LENGTH);\n        }\n\n        if (isDLQTopic(originalResource)) {\n            return originalResource.substring(DLQ_PREFIX_LENGTH);\n        }"}
{"magic_number_smell": "            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(\"The specified topic contains illegal characters, allowing only \" + VALID_PATTERN_STR);\n            return false;\n        }\n\n        if (topic.length() > 127) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(\"The specified topic is longer than topic max length.\");\n            return false;\n        }\n", "refactored_code": "    private static final int TOPIC_MAX_LENGTH = 127;\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(\"The specified topic contains illegal characters, allowing only \" + VALID_PATTERN_STR);\n            return false;\n        }\n\n        if (topic.length() > TOPIC_MAX_LENGTH) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(\"The specified topic is longer than topic max length.\");\n            return false;\n        }\n"}
{"magic_number_smell": "   * Cache Store.\n   * @param dataBaseManager {@link DbManager}\n   */\n  public CacheStore(final DbManager dataBaseManager) {\n    this.dbManager = dataBaseManager;\n    initCapacity(3);\n  }\n\n  /**\n   * Init cache capacity.\n   * @param capacity int", "refactored_code": "  private static final int CAPACITY = 3;\n   * Cache Store.\n   * @param dataBaseManager {@link DbManager}\n   */\n  public CacheStore(final DbManager dataBaseManager) {\n    this.dbManager = dataBaseManager;\n    initCapacity(CAPACITY);\n  }\n\n  /**\n   * Init cache capacity.\n   * @param capacity int"}
{"magic_number_smell": "    public MQAdminImpl getMQAdminImpl() {\n        return mQAdminImpl;\n    }\n\n    public long getBootTimestamp() {\n        return System.currentTimeMillis();\n    }\n\n    public ScheduledExecutorService getScheduledExecutorService() {\n        return scheduledExecutorService;\n    }", "refactored_code": "    private final long bootTimestamp = System.currentTimeMillis();\n    public MQAdminImpl getMQAdminImpl() {\n        return mQAdminImpl;\n    }\n\n    public long getBootTimestamp() {\n        return bootTimestamp;\n    }\n\n    public ScheduledExecutorService getScheduledExecutorService() {\n        return scheduledExecutorService;\n    }"}
{"magic_number_smell": "    public static void checkGroup(String group) throws MQClientException {\n        if (UtilAll.isBlank(group)) {\n            throw new MQClientException(\"the specified group is blank\", null);\n        }\n\n        if (group.length() > 255) {\n            throw new MQClientException(\"the specified group is longer than group max length 255.\", null);\n        }\n\n        if (!regularExpressionMatcher(group, PATTERN)) {\n            throw new MQClientException(String.format(", "refactored_code": "    public static final int CHARACTER_MAX_LENGTH = 255;\n    public static void checkGroup(String group) throws MQClientException {\n        if (UtilAll.isBlank(group)) {\n            throw new MQClientException(\"the specified group is blank\", null);\n        }\n\n        if (group.length() > CHARACTER_MAX_LENGTH) {\n            throw new MQClientException(\"the specified group is longer than group max length 255.\", null);\n        }\n\n        if (!regularExpressionMatcher(group, PATTERN)) {\n            throw new MQClientException(String.format("}
{"magic_number_smell": "  }\n\n  @BeforeEach\n  void init() {\n    System.setProperty(\"mongo-host\", TEST_HOST);\n    System.setProperty(\"mongo-port\", String.valueOf(27017));\n    mongoDatabase.drop();\n    mongoBank = new MongoBank(mongoDatabase.getName(), TEST_ACCOUNTS_COLLECTION);\n  }\n\n  @AfterAll", "refactored_code": "  private static final int TEST_PORT = 27017;\n  }\n\n  @BeforeEach\n  void init() {\n    System.setProperty(\"mongo-host\", TEST_HOST);\n    System.setProperty(\"mongo-port\", String.valueOf(TEST_PORT));\n    mongoDatabase.drop();\n    mongoBank = new MongoBank(mongoDatabase.getName(), TEST_ACCOUNTS_COLLECTION);\n  }\n\n  @AfterAll"}
{"magic_number_smell": "        Matcher timestampMatcher = MEDIA_TIMESTAMP.matcher(line);\n        if (!timestampMatcher.find()) {\n          throw new ParserException(\"X-TIMESTAMP-MAP doesn't contain media timestamp: \" + line);\n        } else {\n          mediaTimestampUs = (Long.parseLong(timestampMatcher.group().substring(7)) * 1000)\n              / 90 + mediaTimestampOffsetUs;\n        }\n        mediaTimestampUs = getAdjustedStartTime(mediaTimestampUs);\n      }\n    }\n", "refactored_code": "  private static final long SAMPLING_RATE = 90;\n        Matcher timestampMatcher = MEDIA_TIMESTAMP.matcher(line);\n        if (!timestampMatcher.find()) {\n          throw new ParserException(\"X-TIMESTAMP-MAP doesn't contain media timestamp: \" + line);\n        } else {\n          mediaTimestampUs = (Long.parseLong(timestampMatcher.group().substring(7)) * 1000)\n              / SAMPLING_RATE + mediaTimestampOffsetUs;\n        }\n        mediaTimestampUs = getAdjustedStartTime(mediaTimestampUs);\n      }\n    }\n"}
{"magic_number_smell": "\n  private long safeCall(int value) {\n    var retries = 0;\n    var result = FAILURE.getRemoteServiceStatusValue();\n\n    for (int i = 0; i < 3; i++) {\n      if (retries >= 3) {\n        return FAILURE.getRemoteServiceStatusValue();\n      }\n\n      if ((result = checkLatency(value)) == FAILURE.getRemoteServiceStatusValue()) {", "refactored_code": "  private static final int RETRIES = 3;\n\n  private long safeCall(int value) {\n    var retries = 0;\n    var result = FAILURE.getRemoteServiceStatusValue();\n\n    for (int i = 0; i < RETRIES; i++) {\n      if (retries >= RETRIES) {\n        return FAILURE.getRemoteServiceStatusValue();\n      }\n\n      if ((result = checkLatency(value)) == FAILURE.getRemoteServiceStatusValue()) {"}
{"magic_number_smell": "                    CommitLog.log.error(this.getServiceName() + \" service has exception. \", e);\n                }\n            }\n\n            boolean result = false;\n            for (int i = 0; i < 10 && !result; i++) {\n                result = CommitLog.this.mappedFileQueue.commit(0);\n                CommitLog.log.info(this.getServiceName() + \" service shutdown, retry \" + (i + 1) + \" times \" + (result ? \"OK\" : \"Not OK\"));\n            }\n            CommitLog.log.info(this.getServiceName() + \" service end\");\n        }", "refactored_code": "        protected static final int RETRY_TIMES_OVER = 10;\n                    CommitLog.log.error(this.getServiceName() + \" service has exception. \", e);\n                }\n            }\n\n            boolean result = false;\n            for (int i = 0; i < RETRY_TIMES_OVER && !result; i++) {\n                result = CommitLog.this.mappedFileQueue.commit(0);\n                CommitLog.log.info(this.getServiceName() + \" service shutdown, retry \" + (i + 1) + \" times \" + (result ? \"OK\" : \"Not OK\"));\n            }\n            CommitLog.log.info(this.getServiceName() + \" service end\");\n        }"}
{"magic_number_smell": "\n    private static final TimeValue DEFAULT_TTL = TimeValue.timeValueMinutes(20);\n    public static final Setting<TimeValue> CACHE_TTL_SETTING = Setting.timeSetting(\"cache.ttl\", DEFAULT_TTL, Setting.Property.NodeScope);\n\n    private static final int 100_000 = 100_000; //100k users\n    public static final Setting<Integer> CACHE_MAX_USERS_SETTING = Setting.intSetting(\"cache.max_users\", 100_000,\n            Setting.Property.NodeScope);\n\n    private final Cache<String, UserWithHash> cache;\n    final Hasher hasher;\n", "refactored_code": "    private static final int DEFAULT_MAX_USERS = 100_000; //100k users\n\n    private static final TimeValue DEFAULT_TTL = TimeValue.timeValueMinutes(20);\n    public static final Setting<TimeValue> CACHE_TTL_SETTING = Setting.timeSetting(\"cache.ttl\", DEFAULT_TTL, Setting.Property.NodeScope);\n\n    private static final int DEFAULT_MAX_USERS = 100_000; //100k users\n    public static final Setting<Integer> CACHE_MAX_USERS_SETTING = Setting.intSetting(\"cache.max_users\", DEFAULT_MAX_USERS,\n            Setting.Property.NodeScope);\n\n    private final Cache<String, UserWithHash> cache;\n    final Hasher hasher;\n"}
{"magic_number_smell": "        new PaymentDetailsErrorException());\n    var ss = new ShippingService(new ShippingDatabase());\n    var ms = new MessagingService(new MessagingDatabase(), new DatabaseUnavailableException());\n    var eh = new EmployeeHandle(new EmployeeDatabase());\n    var qdb = new QueueDatabase(new DatabaseUnavailableException());\n    var c = new Commander(eh, ps, ss, ms, qdb, 3, retryDuration,\n        queueTime, queueTaskTime, paymentTime, messageTime, employeeTime);\n    var user = new User(\"Jim\", \"ABCD\");\n    var order = new Order(user, \"book\", 10f);\n    c.placeOrder(order);\n  }", "refactored_code": "  private final int numOfRetries = 3;\n        new PaymentDetailsErrorException());\n    var ss = new ShippingService(new ShippingDatabase());\n    var ms = new MessagingService(new MessagingDatabase(), new DatabaseUnavailableException());\n    var eh = new EmployeeHandle(new EmployeeDatabase());\n    var qdb = new QueueDatabase(new DatabaseUnavailableException());\n    var c = new Commander(eh, ps, ss, ms, qdb, numOfRetries, retryDuration,\n        queueTime, queueTaskTime, paymentTime, messageTime, employeeTime);\n    var user = new User(\"Jim\", \"ABCD\");\n    var order = new Order(user, \"book\", 10f);\n    c.placeOrder(order);\n  }"}
{"magic_number_smell": "        new DatabaseUnavailableException(), new DatabaseUnavailableException(),\n        new DatabaseUnavailableException(), new DatabaseUnavailableException(),\n        new DatabaseUnavailableException());\n    var eh = new EmployeeHandle(new EmployeeDatabase());\n    var qdb = new QueueDatabase();\n    var c = new Commander(eh, ps, ss, ms, qdb, 3, retryDuration,\n        queueTime, queueTaskTime, paymentTime, messageTime, employeeTime);\n    var user = new User(\"Jim\", \"ABCD\");\n    var order = new Order(user, \"book\", 10f);\n    c.placeOrder(order);\n  }", "refactored_code": "  private final int numOfRetries = 3;\n        new DatabaseUnavailableException(), new DatabaseUnavailableException(),\n        new DatabaseUnavailableException(), new DatabaseUnavailableException(),\n        new DatabaseUnavailableException());\n    var eh = new EmployeeHandle(new EmployeeDatabase());\n    var qdb = new QueueDatabase();\n    var c = new Commander(eh, ps, ss, ms, qdb, numOfRetries, retryDuration,\n        queueTime, queueTaskTime, paymentTime, messageTime, employeeTime);\n    var user = new User(\"Jim\", \"ABCD\");\n    var order = new Order(user, \"book\", 10f);\n    c.placeOrder(order);\n  }"}
{"magic_number_smell": "            if (breakSupplier.getAsBoolean()) {\n                return true;\n            }\n            Thread.sleep(timeInMillis);\n            sum += timeInMillis;\n            timeInMillis = Math.min(1000L, timeInMillis * 2);\n        }\n        timeInMillis = maxTimeInMillis - sum;\n        Thread.sleep(Math.max(timeInMillis, 0));\n        return breakSupplier.getAsBoolean();\n    }", "refactored_code": "    private static final long AWAIT_BUSY_THRESHOLD = 1000L;\n            if (breakSupplier.getAsBoolean()) {\n                return true;\n            }\n            Thread.sleep(timeInMillis);\n            sum += timeInMillis;\n            timeInMillis = Math.min(AWAIT_BUSY_THRESHOLD, timeInMillis * 2);\n        }\n        timeInMillis = maxTimeInMillis - sum;\n        Thread.sleep(Math.max(timeInMillis, 0));\n        return breakSupplier.getAsBoolean();\n    }"}
{"magic_number_smell": "   * wrapped in a {@link DefaultCircuitBreaker} implementation with failure threshold of 1 failure\n   * and retry time period of 2 seconds.\n   */\n  @BeforeEach\n  void setupCircuitBreakers() {\n    var delayedService = new DelayedRemoteService(System.nanoTime(), 4);\n    //Set the circuit Breaker parameters\n    delayedServiceCircuitBreaker = new DefaultCircuitBreaker(delayedService, 3000,\n        FAILURE_THRESHOLD,\n        RETRY_PERIOD * 1000 * 1000 * 1000);\n", "refactored_code": "  private static final int STARTUP_DELAY = 4;\n   * wrapped in a {@link DefaultCircuitBreaker} implementation with failure threshold of 1 failure\n   * and retry time period of 2 seconds.\n   */\n  @BeforeEach\n  void setupCircuitBreakers() {\n    var delayedService = new DelayedRemoteService(System.nanoTime(), STARTUP_DELAY);\n    //Set the circuit Breaker parameters\n    delayedServiceCircuitBreaker = new DefaultCircuitBreaker(delayedService, 3000,\n        FAILURE_THRESHOLD,\n        RETRY_PERIOD * 1000 * 1000 * 1000);\n"}
{"magic_number_smell": "            if (breakSupplier.getAsBoolean()) {\n                return true;\n            }\n            Thread.sleep(timeInMillis);\n            sum += timeInMillis;\n            timeInMillis = Math.min(1000L, timeInMillis * 2);\n        }\n        timeInMillis = maxTimeInMillis - sum;\n        Thread.sleep(Math.max(timeInMillis, 0));\n        return breakSupplier.getAsBoolean();\n    }", "refactored_code": "    private static final long AWAIT_BUSY_THRESHOLD = 1000L;\n            if (breakSupplier.getAsBoolean()) {\n                return true;\n            }\n            Thread.sleep(timeInMillis);\n            sum += timeInMillis;\n            timeInMillis = Math.min(AWAIT_BUSY_THRESHOLD, timeInMillis * 2);\n        }\n        timeInMillis = maxTimeInMillis - sum;\n        Thread.sleep(Math.max(timeInMillis, 0));\n        return breakSupplier.getAsBoolean();\n    }"}
{"magic_number_smell": "        final String remoteAddress, final int clientDefaultTopicQueueNums, final int topicSysFlag) {\n        TopicConfig topicConfig = null;\n        boolean createNew = false;\n\n        try {\n            if (this.lockTopicConfigTable.tryLock(3000, TimeUnit.MILLISECONDS)) {\n                try {\n                    topicConfig = this.topicConfigTable.get(topic);\n                    if (topicConfig != null)\n                        return topicConfig;\n", "refactored_code": "    private static final long LOCK_TIMEOUT_MILLIS = 3000;\n        final String remoteAddress, final int clientDefaultTopicQueueNums, final int topicSysFlag) {\n        TopicConfig topicConfig = null;\n        boolean createNew = false;\n\n        try {\n            if (this.lockTopicConfigTable.tryLock(LOCK_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)) {\n                try {\n                    topicConfig = this.topicConfigTable.get(topic);\n                    if (topicConfig != null)\n                        return topicConfig;\n"}
{"magic_number_smell": "   * @param gameObject the gameObject instance\n   * @param e          key event instance\n   */\n  @Override\n  public void update(GameObject gameObject, int e) {\n    gameObject.updateVelocity(2);\n    LOGGER.info(gameObject.getName() + \" has moved right.\");\n  }\n}\n", "refactored_code": "  private static final int WALK_ACCELERATION = 2;\n   * @param gameObject the gameObject instance\n   * @param e          key event instance\n   */\n  @Override\n  public void update(GameObject gameObject, int e) {\n    gameObject.updateVelocity(WALK_ACCELERATION);\n    LOGGER.info(gameObject.getName() + \" has moved right.\");\n  }\n}\n"}
{"magic_number_smell": "    eventProcessor.reset();\n\n    LOGGER.info(\"Creating the accounts............\");\n\n    eventProcessor.process(new AccountCreateEvent(\n        0, new Date().getTime(), 1, \"Daenerys Targaryen\"));\n\n    eventProcessor.process(new AccountCreateEvent(\n        1, new Date().getTime(), ACCOUNT_OF_JON, \"Jon Snow\"));\n\n    LOGGER.info(\"Do some money operations............\");", "refactored_code": "  public static final int ACCOUNT_OF_DAENERYS = 1;\n    eventProcessor.reset();\n\n    LOGGER.info(\"Creating the accounts............\");\n\n    eventProcessor.process(new AccountCreateEvent(\n        0, new Date().getTime(), ACCOUNT_OF_DAENERYS, \"Daenerys Targaryen\"));\n\n    eventProcessor.process(new AccountCreateEvent(\n        1, new Date().getTime(), ACCOUNT_OF_JON, \"Jon Snow\"));\n\n    LOGGER.info(\"Do some money operations............\");"}
{"magic_number_smell": "\t\t\tTypeSerializer<N> namespaceSerializer) throws IOException {\n\n\t\tDataOutputSerializer dos = new DataOutputSerializer(32);\n\n\t\tkeySerializer.serialize(key, dos);\n\t\tdos.writeByte(42);\n\t\tnamespaceSerializer.serialize(namespace, dos);\n\n\t\treturn dos.getCopyOfBuffer();\n\t}\n", "refactored_code": "\tprivate static final int MAGIC_NUMBER = 42;\n\t\t\tTypeSerializer<N> namespaceSerializer) throws IOException {\n\n\t\tDataOutputSerializer dos = new DataOutputSerializer(32);\n\n\t\tkeySerializer.serialize(key, dos);\n\t\tdos.writeByte(MAGIC_NUMBER);\n\t\tnamespaceSerializer.serialize(namespace, dos);\n\n\t\treturn dos.getCopyOfBuffer();\n\t}\n"}
{"magic_number_smell": "  private static final int 5 = 5;\n\n  @Test\n  void testConsume() throws Exception {\n    final var queue = spy(new ItemQueue());\n    for (var id = 0; id < 5; id++) {\n      queue.put(new Item(\"producer\", id));\n    }\n\n    reset(queue); // Don't count the preparation above as interactions with the queue\n    final var consumer = new Consumer(\"consumer\", queue);", "refactored_code": "  private static final int ITEM_COUNT = 5;\n  private static final int ITEM_COUNT = 5;\n\n  @Test\n  void testConsume() throws Exception {\n    final var queue = spy(new ItemQueue());\n    for (var id = 0; id < ITEM_COUNT; id++) {\n      queue.put(new Item(\"producer\", id));\n    }\n\n    reset(queue); // Don't count the preparation above as interactions with the queue\n    final var consumer = new Consumer(\"consumer\", queue);"}
{"magic_number_smell": "        final String remoteAddress, final int clientDefaultTopicQueueNums, final int topicSysFlag) {\n        TopicConfig topicConfig = null;\n        boolean createNew = false;\n\n        try {\n            if (this.lockTopicConfigTable.tryLock(3000, TimeUnit.MILLISECONDS)) {\n                try {\n                    topicConfig = this.topicConfigTable.get(topic);\n                    if (topicConfig != null)\n                        return topicConfig;\n", "refactored_code": "    private static final long LOCK_TIMEOUT_MILLIS = 3000;\n        final String remoteAddress, final int clientDefaultTopicQueueNums, final int topicSysFlag) {\n        TopicConfig topicConfig = null;\n        boolean createNew = false;\n\n        try {\n            if (this.lockTopicConfigTable.tryLock(LOCK_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)) {\n                try {\n                    topicConfig = this.topicConfigTable.get(topic);\n                    if (topicConfig != null)\n                        return topicConfig;\n"}
{"magic_number_smell": "    var ps = new PaymentService(new PaymentDatabase());\n    var ss = new ShippingService(new ShippingDatabase(), new ItemUnavailableException());\n    var ms = new MessagingService(new MessagingDatabase());\n    var eh = new EmployeeHandle(new EmployeeDatabase());\n    var qdb = new QueueDatabase();\n    var c = new Commander(eh, ps, ss, ms, qdb, 3, retryDuration,\n        queueTime, queueTaskTime, paymentTime, messageTime, employeeTime);\n    var user = new User(\"Jim\", \"ABCD\");\n    var order = new Order(user, \"book\", 10f);\n    c.placeOrder(order);\n  }", "refactored_code": "  private final int numOfRetries = 3;\n    var ps = new PaymentService(new PaymentDatabase());\n    var ss = new ShippingService(new ShippingDatabase(), new ItemUnavailableException());\n    var ms = new MessagingService(new MessagingDatabase());\n    var eh = new EmployeeHandle(new EmployeeDatabase());\n    var qdb = new QueueDatabase();\n    var c = new Commander(eh, ps, ss, ms, qdb, numOfRetries, retryDuration,\n        queueTime, queueTaskTime, paymentTime, messageTime, employeeTime);\n    var user = new User(\"Jim\", \"ABCD\");\n    var order = new Order(user, \"book\", 10f);\n    c.placeOrder(order);\n  }"}
{"magic_number_smell": "                    CommitLog.log.error(this.getServiceName() + \" service has exception. \", e);\n                }\n            }\n\n            boolean result = false;\n            for (int i = 0; i < 10 && !result; i++) {\n                result = CommitLog.this.mappedFileQueue.commit(0);\n                CommitLog.log.info(this.getServiceName() + \" service shutdown, retry \" + (i + 1) + \" times \" + (result ? \"OK\" : \"Not OK\"));\n            }\n            CommitLog.log.info(this.getServiceName() + \" service end\");\n        }", "refactored_code": "        protected static final int RETRY_TIMES_OVER = 10;\n                    CommitLog.log.error(this.getServiceName() + \" service has exception. \", e);\n                }\n            }\n\n            boolean result = false;\n            for (int i = 0; i < RETRY_TIMES_OVER && !result; i++) {\n                result = CommitLog.this.mappedFileQueue.commit(0);\n                CommitLog.log.info(this.getServiceName() + \" service shutdown, retry \" + (i + 1) + \" times \" + (result ? \"OK\" : \"Not OK\"));\n            }\n            CommitLog.log.info(this.getServiceName() + \" service end\");\n        }"}
{"magic_number_smell": "                outputStream.write(buffer);\n            }\n\n            outputStream.finish();\n            long takeTime = System.currentTimeMillis() - start;\n            if (takeTime > 50) {\n                LOGGER.info(\"Compressing takes {}ms\", takeTime);\n            }\n            return byteArrayOutputStream.toByteArray();\n        } catch (IOException e) {\n            LOGGER.error(\"Failed to compress RegisterBrokerBody object\", e);", "refactored_code": "    private static final long MINIMUM_TAKE_TIME_MILLISECOND = 50;\n                outputStream.write(buffer);\n            }\n\n            outputStream.finish();\n            long takeTime = System.currentTimeMillis() - start;\n            if (takeTime > MINIMUM_TAKE_TIME_MILLISECOND) {\n                LOGGER.info(\"Compressing takes {}ms\", takeTime);\n            }\n            return byteArrayOutputStream.toByteArray();\n        } catch (IOException e) {\n            LOGGER.error(\"Failed to compress RegisterBrokerBody object\", e);"}
{"magic_number_smell": "\t\tthis.tasksToTrigger = checkNotNull(tasksToTrigger);\n\t\tthis.tasksToWaitFor = checkNotNull(tasksToWaitFor);\n\t\tthis.tasksToCommitTo = checkNotNull(tasksToCommitTo);\n\t\tthis.pendingCheckpoints = new LinkedHashMap<Long, PendingCheckpoint>();\n\t\tthis.completedCheckpointStore = checkNotNull(completedCheckpointStore);\n\t\tthis.recentPendingCheckpoints = new ArrayDeque<Long>(16);\n\t\tthis.userClassLoader = userClassLoader;\n\n\t\t// Started with the periodic scheduler\n\t\tthis.checkpointIdCounter = checkNotNull(checkpointIDCounter);\n", "refactored_code": "\tprivate static final int NUM_GHOST_CHECKPOINT_IDS = 16;\n\t\tthis.tasksToTrigger = checkNotNull(tasksToTrigger);\n\t\tthis.tasksToWaitFor = checkNotNull(tasksToWaitFor);\n\t\tthis.tasksToCommitTo = checkNotNull(tasksToCommitTo);\n\t\tthis.pendingCheckpoints = new LinkedHashMap<Long, PendingCheckpoint>();\n\t\tthis.completedCheckpointStore = checkNotNull(completedCheckpointStore);\n\t\tthis.recentPendingCheckpoints = new ArrayDeque<Long>(NUM_GHOST_CHECKPOINT_IDS);\n\t\tthis.userClassLoader = userClassLoader;\n\n\t\t// Started with the periodic scheduler\n\t\tthis.checkpointIdCounter = checkNotNull(checkpointIDCounter);\n"}
{"magic_number_smell": "\n    private static final TimeValue DEFAULT_TTL = TimeValue.timeValueMinutes(20);\n    public static final Setting<TimeValue> CACHE_TTL_SETTING = Setting.timeSetting(\"cache.ttl\", DEFAULT_TTL, Setting.Property.NodeScope);\n\n    private static final int 100_000 = 100_000; //100k users\n    public static final Setting<Integer> CACHE_MAX_USERS_SETTING = Setting.intSetting(\"cache.max_users\", 100_000,\n            Setting.Property.NodeScope);\n\n    private final Cache<String, UserWithHash> cache;\n    final Hasher hasher;\n", "refactored_code": "    private static final int DEFAULT_MAX_USERS = 100_000; //100k users\n\n    private static final TimeValue DEFAULT_TTL = TimeValue.timeValueMinutes(20);\n    public static final Setting<TimeValue> CACHE_TTL_SETTING = Setting.timeSetting(\"cache.ttl\", DEFAULT_TTL, Setting.Property.NodeScope);\n\n    private static final int DEFAULT_MAX_USERS = 100_000; //100k users\n    public static final Setting<Integer> CACHE_MAX_USERS_SETTING = Setting.intSetting(\"cache.max_users\", DEFAULT_MAX_USERS,\n            Setting.Property.NodeScope);\n\n    private final Cache<String, UserWithHash> cache;\n    final Hasher hasher;\n"}
{"magic_number_smell": "  /**\n   * Remote function takes a value and multiplies it by 10 taking a random amount of time. Will\n   * sometimes return -1. This imitates connectivity issues a client might have to account for.\n   *\n   * @param value integer value to be multiplied.\n   * @return if waitTime is less than {@link RemoteService#200}, it returns value * 10,\n   *     otherwise {@link RemoteServiceStatus#FAILURE}.\n   */\n  @Override\n  public long doRemoteFunction(int value) {\n", "refactored_code": "  private static final int THRESHOLD = 200;\n  /**\n   * Remote function takes a value and multiplies it by 10 taking a random amount of time. Will\n   * sometimes return -1. This imitates connectivity issues a client might have to account for.\n   *\n   * @param value integer value to be multiplied.\n   * @return if waitTime is less than {@link RemoteService#THRESHOLD}, it returns value * 10,\n   *     otherwise {@link RemoteServiceStatus#FAILURE}.\n   */\n  @Override\n  public long doRemoteFunction(int value) {\n"}
{"magic_number_smell": "    }\n\n    private GetResult getHalfMsg(MessageQueue messageQueue, long offset) {\n        GetResult getResult = new GetResult();\n\n        PullResult result = pullHalfMsg(messageQueue, offset, 1);\n        getResult.setPullResult(result);\n        List<MessageExt> messageExts = result.getMsgFoundList();\n        if (messageExts == null) {\n            return getResult;\n        }", "refactored_code": "    private static final int PULL_MSG_RETRY_NUMBER = 1;\n    }\n\n    private GetResult getHalfMsg(MessageQueue messageQueue, long offset) {\n        GetResult getResult = new GetResult();\n\n        PullResult result = pullHalfMsg(messageQueue, offset, PULL_MSG_RETRY_NUMBER);\n        getResult.setPullResult(result);\n        List<MessageExt> messageExts = result.getMsgFoundList();\n        if (messageExts == null) {\n            return getResult;\n        }"}
{"magic_number_smell": "  public static void main(final String[] args) {\n    // create model, view and controller\n\n    // initialize calculator view, output and variable = 0\n    var view = new CalculatorView(new CalculatorViewModel());\n    var variable1 = 10.0;\n\n    // calculator variable = 10.0 -> 10.0\n    view.setVariable(variable1);\n\n    // add calculator variable to output -> calculator output = 10.0", "refactored_code": "  private static final double RANDOM_VARIABLE = 10.0;\n  public static void main(final String[] args) {\n    // create model, view and controller\n\n    // initialize calculator view, output and variable = 0\n    var view = new CalculatorView(new CalculatorViewModel());\n    var variable1 = RANDOM_VARIABLE;\n\n    // calculator variable = RANDOM_VARIABLE -> 10.0\n    view.setVariable(variable1);\n\n    // add calculator variable to output -> calculator output = 10.0"}
{"magic_number_smell": "                outputStream.write(buffer);\n            }\n\n            outputStream.finish();\n            long takeTime = System.currentTimeMillis() - start;\n            if (takeTime > 50) {\n                LOGGER.info(\"Compressing takes {}ms\", takeTime);\n            }\n            return byteArrayOutputStream.toByteArray();\n        } catch (IOException e) {\n            LOGGER.error(\"Failed to compress RegisterBrokerBody object\", e);", "refactored_code": "    private static final long MINIMUM_TAKE_TIME_MILLISECOND = 50;\n                outputStream.write(buffer);\n            }\n\n            outputStream.finish();\n            long takeTime = System.currentTimeMillis() - start;\n            if (takeTime > MINIMUM_TAKE_TIME_MILLISECOND) {\n                LOGGER.info(\"Compressing takes {}ms\", takeTime);\n            }\n            return byteArrayOutputStream.toByteArray();\n        } catch (IOException e) {\n            LOGGER.error(\"Failed to compress RegisterBrokerBody object\", e);"}
{"magic_number_smell": "    return price.minus(calculateDiscount());\n  }\n\n  private Money calculateDiscount() {\n    if (ChronoUnit.DAYS.between(LocalDate.now(), expirationDate)\n            < 4) {\n\n      return price.multipliedBy(DISCOUNT_RATE, RoundingMode.DOWN);\n    }\n\n    return Money.zero(USD);", "refactored_code": "  private static final int DAYS_UNTIL_EXPIRATION_WHEN_DISCOUNT_ACTIVE = 4;\n    return price.minus(calculateDiscount());\n  }\n\n  private Money calculateDiscount() {\n    if (ChronoUnit.DAYS.between(LocalDate.now(), expirationDate)\n            < DAYS_UNTIL_EXPIRATION_WHEN_DISCOUNT_ACTIVE) {\n\n      return price.multipliedBy(DISCOUNT_RATE, RoundingMode.DOWN);\n    }\n\n    return Money.zero(USD);"}
{"magic_number_smell": "  @Test\n  void shouldConstructPart() {\n    var partProperties = Map.of(\n        Property.TYPE.toString(), TEST_PART_TYPE,\n        Property.MODEL.toString(), TEST_PART_MODEL,\n        Property.PRICE.toString(), (Object) 0L\n    );\n    var part = new Part(partProperties);\n    assertEquals(TEST_PART_TYPE, part.getType().orElseThrow());\n    assertEquals(TEST_PART_MODEL, part.getModel().orElseThrow());\n    assertEquals(0L, part.getPrice().orElseThrow());", "refactored_code": "  private static final long TEST_PART_PRICE = 0L;\n  @Test\n  void shouldConstructPart() {\n    var partProperties = Map.of(\n        Property.TYPE.toString(), TEST_PART_TYPE,\n        Property.MODEL.toString(), TEST_PART_MODEL,\n        Property.PRICE.toString(), (Object) TEST_PART_PRICE\n    );\n    var part = new Part(partProperties);\n    assertEquals(TEST_PART_TYPE, part.getType().orElseThrow());\n    assertEquals(TEST_PART_MODEL, part.getModel().orElseThrow());\n    assertEquals(TEST_PART_PRICE, part.getPrice().orElseThrow());"}
{"magic_number_smell": "\n  public static final double 60 = 60;\n\n  @Override\n  public double calculate(double amount) {\n    return amount * 60 / 100.0;\n  }\n\n}\n", "refactored_code": "  public static final double TAX_PERCENTAGE = 60;\n\n  public static final double TAX_PERCENTAGE = 60;\n\n  @Override\n  public double calculate(double amount) {\n    return amount * TAX_PERCENTAGE / 100.0;\n  }\n\n}\n"}
{"magic_number_smell": "  private final BookRepository bookRepository = new BookRepository();\n\n  @BeforeEach\n  void setUp() throws BookDuplicateException {\n    var book = new Book();\n    book.setId(1);\n    bookRepository.add(book);\n  }\n\n  @Test\n  void testDefaultVersionRemainsZeroAfterAdd() throws BookNotFoundException {", "refactored_code": "  private final long bookId = 1;\n  private final BookRepository bookRepository = new BookRepository();\n\n  @BeforeEach\n  void setUp() throws BookDuplicateException {\n    var book = new Book();\n    book.setId(bookId);\n    bookRepository.add(book);\n  }\n\n  @Test\n  void testDefaultVersionRemainsZeroAfterAdd() throws BookNotFoundException {"}
{"magic_number_smell": "\n  private static final int 10000 = 10000;\n\n  private final int numEntities;\n\n  private final Component[] physicsComponents = new PhysicsComponent[10000];\n\n  public PhysicsComponentManager(int numEntities) {\n    this.numEntities = numEntities;\n  }\n", "refactored_code": "  private static final int MAX_ENTITIES = 10000;\n\n  private static final int MAX_ENTITIES = 10000;\n\n  private final int numEntities;\n\n  private final Component[] physicsComponents = new PhysicsComponent[MAX_ENTITIES];\n\n  public PhysicsComponentManager(int numEntities) {\n    this.numEntities = numEntities;\n  }\n"}
{"magic_number_smell": "        new DatabaseUnavailableException());\n    var qdb =\n        new QueueDatabase(new DatabaseUnavailableException(), new DatabaseUnavailableException(),\n            new DatabaseUnavailableException(), new DatabaseUnavailableException(),\n            new DatabaseUnavailableException(), new DatabaseUnavailableException());\n    var c = new Commander(eh, ps, ss, ms, qdb, 3, retryDuration,\n        queueTime, queueTaskTime, paymentTime, messageTime, employeeTime);\n    var user = new User(\"Jim\", \"ABCD\");\n    var order = new Order(user, \"book\", 10f);\n    c.placeOrder(order);\n  }", "refactored_code": "  private final int numOfRetries = 3;\n        new DatabaseUnavailableException());\n    var qdb =\n        new QueueDatabase(new DatabaseUnavailableException(), new DatabaseUnavailableException(),\n            new DatabaseUnavailableException(), new DatabaseUnavailableException(),\n            new DatabaseUnavailableException(), new DatabaseUnavailableException());\n    var c = new Commander(eh, ps, ss, ms, qdb, numOfRetries, retryDuration,\n        queueTime, queueTaskTime, paymentTime, messageTime, employeeTime);\n    var user = new User(\"Jim\", \"ABCD\");\n    var order = new Order(user, \"book\", 10f);\n    c.placeOrder(order);\n  }"}
{"magic_number_smell": "   */\n  @Override\n  public void update(GameObject gameObject, int e) {\n    switch (e) {\n      case KeyEvent.KEY_LOCATION_LEFT -> {\n        gameObject.updateVelocity(-1);\n        LOGGER.info(gameObject.getName() + \" has moved left.\");\n      }\n      case KeyEvent.KEY_LOCATION_RIGHT -> {\n        gameObject.updateVelocity(1);\n        LOGGER.info(gameObject.getName() + \" has moved right.\");", "refactored_code": "  private static final int WALK_ACCELERATION = 1;\n   */\n  @Override\n  public void update(GameObject gameObject, int e) {\n    switch (e) {\n      case KeyEvent.KEY_LOCATION_LEFT -> {\n        gameObject.updateVelocity(-WALK_ACCELERATION);\n        LOGGER.info(gameObject.getName() + \" has moved left.\");\n      }\n      case KeyEvent.KEY_LOCATION_RIGHT -> {\n        gameObject.updateVelocity(WALK_ACCELERATION);\n        LOGGER.info(gameObject.getName() + \" has moved right.\");"}
{"magic_number_smell": "    var eh = new EmployeeHandle(new EmployeeDatabase());\n    var qdb =\n        new QueueDatabase(new DatabaseUnavailableException(), new DatabaseUnavailableException(),\n            new DatabaseUnavailableException(), new DatabaseUnavailableException(),\n            new DatabaseUnavailableException(), new DatabaseUnavailableException());\n    var c = new Commander(eh, ps, ss, ms, qdb, 3, retryDuration,\n        queueTime, queueTaskTime, paymentTime, messageTime, employeeTime);\n    var user = new User(\"Jim\", \"ABCD\");\n    var order = new Order(user, \"book\", 10f);\n    c.placeOrder(order);\n  }", "refactored_code": "  private final int numOfRetries = 3;\n    var eh = new EmployeeHandle(new EmployeeDatabase());\n    var qdb =\n        new QueueDatabase(new DatabaseUnavailableException(), new DatabaseUnavailableException(),\n            new DatabaseUnavailableException(), new DatabaseUnavailableException(),\n            new DatabaseUnavailableException(), new DatabaseUnavailableException());\n    var c = new Commander(eh, ps, ss, ms, qdb, numOfRetries, retryDuration,\n        queueTime, queueTaskTime, paymentTime, messageTime, employeeTime);\n    var user = new User(\"Jim\", \"ABCD\");\n    var order = new Order(user, \"book\", 10f);\n    c.placeOrder(order);\n  }"}
{"magic_number_smell": "\n  @Override\n  public void update() {\n    if (patrollingLeft) {\n      position -= 1;\n      if (position == 0) {\n        patrollingLeft = false;\n      }\n    } else {\n      position += 1;\n      if (position == PATROLLING_RIGHT_BOUNDING) {", "refactored_code": "  private static final int PATROLLING_LEFT_BOUNDING = 0;\n\n  @Override\n  public void update() {\n    if (patrollingLeft) {\n      position -= 1;\n      if (position == PATROLLING_LEFT_BOUNDING) {\n        patrollingLeft = false;\n      }\n    } else {\n      position += 1;\n      if (position == PATROLLING_RIGHT_BOUNDING) {"}
{"magic_number_smell": "public class LoopInitializer {\n\t\n\tpublic static final int 1 = 1;\n\t\n\tpublic int getLoopInitializationPoint() {\n\t\treturn LoopInitializer.1;\n\t}\n}\n", "refactored_code": "\tpublic static final int LOOP_INIT_VALUE = 1;\npublic class LoopInitializer {\n\t\n\tpublic static final int LOOP_INIT_VALUE = 1;\n\t\n\tpublic int getLoopInitializationPoint() {\n\t\treturn LoopInitializer.LOOP_INIT_VALUE;\n\t}\n}\n"}
{"magic_number_smell": "   *\n   * @param args command line args\n   */\n  public static void main(String[] args) throws InterruptedException {\n    var bank = new Bank(ACCOUNT_NUM, BASE_AMOUNT);\n    var latch = new CountDownLatch(5);\n    var executorService = Executors.newFixedThreadPool(5);\n\n    for (int i = 0; i < 5; i++) {\n      executorService.execute(() -> runner(bank, latch));\n    }", "refactored_code": "  private static final int NUMBER_OF_THREADS = 5;\n   *\n   * @param args command line args\n   */\n  public static void main(String[] args) throws InterruptedException {\n    var bank = new Bank(ACCOUNT_NUM, BASE_AMOUNT);\n    var latch = new CountDownLatch(NUMBER_OF_THREADS);\n    var executorService = Executors.newFixedThreadPool(NUMBER_OF_THREADS);\n\n    for (int i = 0; i < NUMBER_OF_THREADS; i++) {\n      executorService.execute(() -> runner(bank, latch));\n    }"}
{"magic_number_smell": "    public static void checkGroup(String group) throws MQClientException {\n        if (UtilAll.isBlank(group)) {\n            throw new MQClientException(\"the specified group is blank\", null);\n        }\n\n        if (group.length() > 255) {\n            throw new MQClientException(\"the specified group is longer than group max length 255.\", null);\n        }\n\n        if (!regularExpressionMatcher(group, PATTERN)) {\n            throw new MQClientException(String.format(", "refactored_code": "    public static final int CHARACTER_MAX_LENGTH = 255;\n    public static void checkGroup(String group) throws MQClientException {\n        if (UtilAll.isBlank(group)) {\n            throw new MQClientException(\"the specified group is blank\", null);\n        }\n\n        if (group.length() > CHARACTER_MAX_LENGTH) {\n            throw new MQClientException(\"the specified group is longer than group max length 255.\", null);\n        }\n\n        if (!regularExpressionMatcher(group, PATTERN)) {\n            throw new MQClientException(String.format("}
{"magic_number_smell": "    // Timeout for the API request.\n    // Used to break the calls made to remote resource if it exceeds the limit\n    this.timeout = timeout;\n    this.retryTimePeriod = retryTimePeriod;\n    //An absurd amount of time in future which basically indicates the last failure never happened\n    this.lastFailureTime = System.nanoTime() + 1_000_000_000_000L;\n    this.failureCount = 0;\n  }\n\n  // Reset everything to defaults\n  @Override", "refactored_code": "  private final long futureTime = 1_000_000_000_000L;\n    // Timeout for the API request.\n    // Used to break the calls made to remote resource if it exceeds the limit\n    this.timeout = timeout;\n    this.retryTimePeriod = retryTimePeriod;\n    //An absurd amount of time in future which basically indicates the last failure never happened\n    this.lastFailureTime = System.nanoTime() + futureTime;\n    this.failureCount = 0;\n  }\n\n  // Reset everything to defaults\n  @Override"}
{"magic_number_smell": "\n    try {\n      LOGGER.info(\"Start frame-based game loop:\");\n      var frameBasedGameLoop = new FrameBasedGameLoop();\n      frameBasedGameLoop.run();\n      Thread.sleep(2000);\n      frameBasedGameLoop.stop();\n      LOGGER.info(\"Stop frame-based game loop.\");\n\n      LOGGER.info(\"Start variable-step game loop:\");\n      var variableStepGameLoop = new VariableStepGameLoop();", "refactored_code": "  private static final int GAME_LOOP_DURATION_TIME = 2000;\n\n    try {\n      LOGGER.info(\"Start frame-based game loop:\");\n      var frameBasedGameLoop = new FrameBasedGameLoop();\n      frameBasedGameLoop.run();\n      Thread.sleep(GAME_LOOP_DURATION_TIME);\n      frameBasedGameLoop.stop();\n      LOGGER.info(\"Stop frame-based game loop.\");\n\n      LOGGER.info(\"Start variable-step game loop:\");\n      var variableStepGameLoop = new VariableStepGameLoop();"}
{"magic_number_smell": "  @Test\n  void testAddItem() throws Exception {\n    assertTimeout(ofMillis(10000), () -> {\n      // Create a new inventory with a limit of 1000 items and put some load on the add method\n      final var inventory = new Inventory(INVENTORY_SIZE);\n      final var executorService = Executors.newFixedThreadPool(8);\n      IntStream.range(0, 8).<Runnable>mapToObj(i -> () -> {\n        while (inventory.addItem(new Item())) ;\n      }).forEach(executorService::execute);\n\n      // Wait until all threads have finished", "refactored_code": "  private static final int THREAD_COUNT = 8;\n  @Test\n  void testAddItem() throws Exception {\n    assertTimeout(ofMillis(10000), () -> {\n      // Create a new inventory with a limit of 1000 items and put some load on the add method\n      final var inventory = new Inventory(INVENTORY_SIZE);\n      final var executorService = Executors.newFixedThreadPool(THREAD_COUNT);\n      IntStream.range(0, THREAD_COUNT).<Runnable>mapToObj(i -> () -> {\n        while (inventory.addItem(new Item())) ;\n      }).forEach(executorService::execute);\n\n      // Wait until all threads have finished"}
{"magic_number_smell": "        var qdb = new QueueDatabase\n                (new DatabaseUnavailableException(), new DatabaseUnavailableException(),\n                        new DatabaseUnavailableException(), new DatabaseUnavailableException(),\n                        new DatabaseUnavailableException(), new DatabaseUnavailableException());\n        return new Commander(employeeHandle, paymentService, shippingService,\n                messagingService, qdb, 1, retryDuration,\n                queueTime, queueTaskTime, paymentTime, messageTime, employeeTime);\n    }\n\n    private Commander buildCommanderObjectVanilla() {\n        PaymentService paymentService = new PaymentService", "refactored_code": "    private final int numOfRetries = 1;\n        var qdb = new QueueDatabase\n                (new DatabaseUnavailableException(), new DatabaseUnavailableException(),\n                        new DatabaseUnavailableException(), new DatabaseUnavailableException(),\n                        new DatabaseUnavailableException(), new DatabaseUnavailableException());\n        return new Commander(employeeHandle, paymentService, shippingService,\n                messagingService, qdb, numOfRetries, retryDuration,\n                queueTime, queueTaskTime, paymentTime, messageTime, employeeTime);\n    }\n\n    private Commander buildCommanderObjectVanilla() {\n        PaymentService paymentService = new PaymentService"}
{"magic_number_smell": "\n  public static final double 20 = 20;\n\n  @Override\n  public double calculate(double amount) {\n    return amount * 20 / 100.0;\n  }\n\n}\n", "refactored_code": "  public static final double TAX_PERCENTAGE = 20;\n\n  public static final double TAX_PERCENTAGE = 20;\n\n  @Override\n  public double calculate(double amount) {\n    return amount * TAX_PERCENTAGE / 100.0;\n  }\n\n}\n"}
{"magic_number_smell": "public class FrameBuffer implements Buffer {\n\n  public static final int 10 = 10;\n  public static final int HEIGHT = 8;\n\n  private final Pixel[] pixels = new Pixel[10 * HEIGHT];\n\n  public FrameBuffer() {\n    clearAll();\n  }\n", "refactored_code": "  public static final int WIDTH = 10;\npublic class FrameBuffer implements Buffer {\n\n  public static final int WIDTH = 10;\n  public static final int HEIGHT = 8;\n\n  private final Pixel[] pixels = new Pixel[WIDTH * HEIGHT];\n\n  public FrameBuffer() {\n    clearAll();\n  }\n"}
{"magic_number_smell": "public class LoopInitializer {\n\t\n\tpublic static final int 1 = 1;\n\t\n\tpublic int getLoopInitializationPoint() {\n\t\treturn LoopInitializer.1;\n\t}\n}\n", "refactored_code": "\tpublic static final int LOOP_INIT_VALUE = 1;\npublic class LoopInitializer {\n\t\n\tpublic static final int LOOP_INIT_VALUE = 1;\n\t\n\tpublic int getLoopInitializationPoint() {\n\t\treturn LoopInitializer.LOOP_INIT_VALUE;\n\t}\n}\n"}
{"magic_number_smell": "  @Test\n  void testIdGeneration() throws Exception {\n    assertTimeout(ofMillis(10000), () -> {\n      final var service = Executors.newFixedThreadPool(THREAD_COUNT);\n\n      final var tasks = IntStream.range(0, 128 * 1024)\n          .<Callable<Integer>>mapToObj(i -> () -> factory.apply(1).getId())\n          .collect(Collectors.toCollection(ArrayList::new));\n\n      final var ids = service.invokeAll(tasks)\n          .stream()", "refactored_code": "  private static final int TASK_COUNT = 128 * 1024;\n  @Test\n  void testIdGeneration() throws Exception {\n    assertTimeout(ofMillis(10000), () -> {\n      final var service = Executors.newFixedThreadPool(THREAD_COUNT);\n\n      final var tasks = IntStream.range(0, TASK_COUNT)\n          .<Callable<Integer>>mapToObj(i -> () -> factory.apply(1).getId())\n          .collect(Collectors.toCollection(ArrayList::new));\n\n      final var ids = service.invokeAll(tasks)\n          .stream()"}
{"magic_number_smell": "public class EventManager implements ThreadCompleteListener {\n\n  public static final int 1000 = 1000;\n  // Just don't wanna have too many running events. :)\n  public static final int MIN_ID = 1;\n  public static final int MAX_ID = 1000;\n  public static final int MAX_EVENT_TIME = 1800; // in seconds / 30 minutes.\n  private int currentlyRunningSyncEvent = -1;\n  private final SecureRandom rand;\n  private final Map<Integer, AsyncEvent> eventPool;\n", "refactored_code": "  public static final int MAX_RUNNING_EVENTS = 1000;\npublic class EventManager implements ThreadCompleteListener {\n\n  public static final int MAX_RUNNING_EVENTS = 1000;\n  // Just don't wanna have too many running events. :)\n  public static final int MIN_ID = 1;\n  public static final int MAX_ID = MAX_RUNNING_EVENTS;\n  public static final int MAX_EVENT_TIME = 1800; // in seconds / 30 minutes.\n  private int currentlyRunningSyncEvent = -1;\n  private final SecureRandom rand;\n  private final Map<Integer, AsyncEvent> eventPool;\n"}
{"magic_number_smell": "  void setUp() {\n    MockitoAnnotations.openMocks(this);\n    healthIndicator =\n        new DatabaseTransactionHealthIndicator(\n            healthCheckRepository, asynchronousHealthChecker, retryTemplate);\n    healthIndicator.setTimeoutInSeconds(4);\n  }\n\n  /**\n   * Test case for the `health()` method when the database transaction succeeds.\n   *", "refactored_code": "  private final long timeoutInSeconds = 4;\n  void setUp() {\n    MockitoAnnotations.openMocks(this);\n    healthIndicator =\n        new DatabaseTransactionHealthIndicator(\n            healthCheckRepository, asynchronousHealthChecker, retryTemplate);\n    healthIndicator.setTimeoutInSeconds(timeoutInSeconds);\n  }\n\n  /**\n   * Test case for the `health()` method when the database transaction succeeds.\n   *"}
{"magic_number_smell": "      // Initiates an orderly shutdown.\n      LOGGER.info(\"Initiating shutdown.\"\n          + \" Executor will shutdown only after all the Threads are completed.\");\n      executor.shutdown();\n\n      // Wait for 15 seconds for all the threads to complete \n      // their tasks and then shut down the executor and then exit. \n      if (!executor.awaitTermination(15, TimeUnit.SECONDS)) {\n        LOGGER.info(\"Executor was shut down and Exiting.\");\n        executor.shutdownNow();\n      }", "refactored_code": "  private static final int SHUTDOWN_TIME = 15;\n      // Initiates an orderly shutdown.\n      LOGGER.info(\"Initiating shutdown.\"\n          + \" Executor will shutdown only after all the Threads are completed.\");\n      executor.shutdown();\n\n      // Wait for SHUTDOWN_TIME seconds for all the threads to complete \n      // their tasks and then shut down the executor and then exit. \n      if (!executor.awaitTermination(SHUTDOWN_TIME, TimeUnit.SECONDS)) {\n        LOGGER.info(\"Executor was shut down and Exiting.\");\n        executor.shutdownNow();\n      }"}
{"magic_number_smell": "  \n  @Override\n  public void run() {\n    List<ActiveCreature> creatures = new ArrayList<>();\n    try {\n      for (int i = 0; i < 3; i++) {\n        creatures.add(new Orc(Orc.class.getSimpleName() + i));\n        creatures.get(i).eat();\n        creatures.get(i).roam();\n      }\n      Thread.sleep(1000);", "refactored_code": "  private static final int NUM_CREATURES = 3;\n  \n  @Override\n  public void run() {\n    List<ActiveCreature> creatures = new ArrayList<>();\n    try {\n      for (int i = 0; i < NUM_CREATURES; i++) {\n        creatures.add(new Orc(Orc.class.getSimpleName() + i));\n        creatures.get(i).eat();\n        creatures.get(i).roam();\n      }\n      Thread.sleep(1000);"}
{"magic_number_smell": "    private static String withOutRetryAndDLQ(String originalResource) {\n        if (StringUtils.isEmpty(originalResource)) {\n            return STRING_BLANK;\n        }\n        if (isRetryTopic(originalResource)) {\n            return originalResource.substring(MixAll.RETRY_GROUP_TOPIC_PREFIX.length());\n        }\n\n        if (isDLQTopic(originalResource)) {\n            return originalResource.substring(DLQ_PREFIX_LENGTH);\n        }", "refactored_code": "    public static final int RETRY_PREFIX_LENGTH = MixAll.RETRY_GROUP_TOPIC_PREFIX.length();\n    private static String withOutRetryAndDLQ(String originalResource) {\n        if (StringUtils.isEmpty(originalResource)) {\n            return STRING_BLANK;\n        }\n        if (isRetryTopic(originalResource)) {\n            return originalResource.substring(RETRY_PREFIX_LENGTH);\n        }\n\n        if (isDLQTopic(originalResource)) {\n            return originalResource.substring(DLQ_PREFIX_LENGTH);\n        }"}
{"magic_number_smell": "\t\t\tTypeSerializer<N> namespaceSerializer) throws IOException {\n\n\t\tDataOutputSerializer dos = new DataOutputSerializer(32);\n\n\t\tkeySerializer.serialize(key, dos);\n\t\tdos.writeByte(42);\n\t\tnamespaceSerializer.serialize(namespace, dos);\n\n\t\treturn dos.getCopyOfBuffer();\n\t}\n", "refactored_code": "\tprivate static final int MAGIC_NUMBER = 42;\n\t\t\tTypeSerializer<N> namespaceSerializer) throws IOException {\n\n\t\tDataOutputSerializer dos = new DataOutputSerializer(32);\n\n\t\tkeySerializer.serialize(key, dos);\n\t\tdos.writeByte(MAGIC_NUMBER);\n\t\tnamespaceSerializer.serialize(namespace, dos);\n\n\t\treturn dos.getCopyOfBuffer();\n\t}\n"}
{"magic_number_smell": "public class Application {\n\n  private static final int 5 = 5;\n\n  /**\n   * Start game loop with each component have 5 instance.\n   */\n  public static void main(String[] args) {\n    LOGGER.info(\"Start Game Application using Data-Locality pattern\");\n    var gameEntity = new GameEntity(5);\n    gameEntity.start();", "refactored_code": "  private static final int NUM_ENTITIES = 5;\npublic class Application {\n\n  private static final int NUM_ENTITIES = 5;\n\n  /**\n   * Start game loop with each component have NUM_ENTITIES instance.\n   */\n  public static void main(String[] args) {\n    LOGGER.info(\"Start Game Application using Data-Locality pattern\");\n    var gameEntity = new GameEntity(NUM_ENTITIES);\n    gameEntity.start();"}
{"magic_number_smell": "\t\tthis.tasksToTrigger = checkNotNull(tasksToTrigger);\n\t\tthis.tasksToWaitFor = checkNotNull(tasksToWaitFor);\n\t\tthis.tasksToCommitTo = checkNotNull(tasksToCommitTo);\n\t\tthis.pendingCheckpoints = new LinkedHashMap<Long, PendingCheckpoint>();\n\t\tthis.completedCheckpointStore = checkNotNull(completedCheckpointStore);\n\t\tthis.recentPendingCheckpoints = new ArrayDeque<Long>(16);\n\t\tthis.userClassLoader = userClassLoader;\n\n\t\t// Started with the periodic scheduler\n\t\tthis.checkpointIdCounter = checkNotNull(checkpointIDCounter);\n", "refactored_code": "\tprivate static final int NUM_GHOST_CHECKPOINT_IDS = 16;\n\t\tthis.tasksToTrigger = checkNotNull(tasksToTrigger);\n\t\tthis.tasksToWaitFor = checkNotNull(tasksToWaitFor);\n\t\tthis.tasksToCommitTo = checkNotNull(tasksToCommitTo);\n\t\tthis.pendingCheckpoints = new LinkedHashMap<Long, PendingCheckpoint>();\n\t\tthis.completedCheckpointStore = checkNotNull(completedCheckpointStore);\n\t\tthis.recentPendingCheckpoints = new ArrayDeque<Long>(NUM_GHOST_CHECKPOINT_IDS);\n\t\tthis.userClassLoader = userClassLoader;\n\n\t\t// Started with the periodic scheduler\n\t\tthis.checkpointIdCounter = checkNotNull(checkpointIDCounter);\n"}
{"magic_number_smell": "\n    protected abstract void checkCounters(JobExecutionResult result);\n\n    protected static int getNumBuffers(int parallelism, int numShuffles) {\n        // p + 1 buffer on output side + input side including recovery (=local channels count fully)\n        int buffersPerSubtask = parallelism + 1 + 2 * 1 * parallelism;\n        return buffersPerSubtask * parallelism * numShuffles;\n    }\n\n    /** A source that generates longs in a fixed number of splits. */\n    protected static class LongSource", "refactored_code": "    protected static final int BUFFER_PER_CHANNEL = 1;\n\n    protected abstract void checkCounters(JobExecutionResult result);\n\n    protected static int getNumBuffers(int parallelism, int numShuffles) {\n        // p + 1 buffer on output side + input side including recovery (=local channels count fully)\n        int buffersPerSubtask = parallelism + 1 + 2 * BUFFER_PER_CHANNEL * parallelism;\n        return buffersPerSubtask * parallelism * numShuffles;\n    }\n\n    /** A source that generates longs in a fixed number of splits. */\n    protected static class LongSource"}
{"magic_number_smell": "        Matcher timestampMatcher = MEDIA_TIMESTAMP.matcher(line);\n        if (!timestampMatcher.find()) {\n          throw new ParserException(\"X-TIMESTAMP-MAP doesn't contain media timestamp: \" + line);\n        } else {\n          mediaTimestampUs = (Long.parseLong(timestampMatcher.group().substring(7)) * 1000)\n              / 90 + mediaTimestampOffsetUs;\n        }\n        mediaTimestampUs = getAdjustedStartTime(mediaTimestampUs);\n      }\n    }\n", "refactored_code": "  private static final long SAMPLING_RATE = 90;\n        Matcher timestampMatcher = MEDIA_TIMESTAMP.matcher(line);\n        if (!timestampMatcher.find()) {\n          throw new ParserException(\"X-TIMESTAMP-MAP doesn't contain media timestamp: \" + line);\n        } else {\n          mediaTimestampUs = (Long.parseLong(timestampMatcher.group().substring(7)) * 1000)\n              / SAMPLING_RATE + mediaTimestampOffsetUs;\n        }\n        mediaTimestampUs = getAdjustedStartTime(mediaTimestampUs);\n      }\n    }\n"}
{"magic_number_smell": "public class PotatoPeelingTask extends Task {\n\n  private static final int 200 = 200;\n\n  public PotatoPeelingTask(int numPotatoes) {\n    super(numPotatoes * 200);\n  }\n\n  @Override\n  public String toString() {\n    return String.format(\"%s %s\", this.getClass().getSimpleName(), super.toString());", "refactored_code": "  private static final int TIME_PER_POTATO = 200;\npublic class PotatoPeelingTask extends Task {\n\n  private static final int TIME_PER_POTATO = 200;\n\n  public PotatoPeelingTask(int numPotatoes) {\n    super(numPotatoes * TIME_PER_POTATO);\n  }\n\n  @Override\n  public String toString() {\n    return String.format(\"%s %s\", this.getClass().getSimpleName(), super.toString());"}
{"magic_number_smell": "    this.tower = tower;\n  }\n\n  @Override\n  public void enter(Wizard wizard) {\n    if (numWizards < 3) {\n      tower.enter(wizard);\n      numWizards++;\n    } else {\n      LOGGER.info(\"{} is not allowed to enter!\", wizard);\n    }", "refactored_code": "  private static final int NUM_WIZARDS_ALLOWED = 3;\n    this.tower = tower;\n  }\n\n  @Override\n  public void enter(Wizard wizard) {\n    if (numWizards < NUM_WIZARDS_ALLOWED) {\n      tower.enter(wizard);\n      numWizards++;\n    } else {\n      LOGGER.info(\"{} is not allowed to enter!\", wizard);\n    }"}
{"magic_number_smell": "\n    protected abstract void checkCounters(JobExecutionResult result);\n\n    protected static int getNumBuffers(int parallelism, int numShuffles) {\n        // p + 1 buffer on output side + input side including recovery (=local channels count fully)\n        int buffersPerSubtask = parallelism + 1 + 2 * 1 * parallelism;\n        return buffersPerSubtask * parallelism * numShuffles;\n    }\n\n    /** A source that generates longs in a fixed number of splits. */\n    protected static class LongSource", "refactored_code": "    protected static final int BUFFER_PER_CHANNEL = 1;\n\n    protected abstract void checkCounters(JobExecutionResult result);\n\n    protected static int getNumBuffers(int parallelism, int numShuffles) {\n        // p + 1 buffer on output side + input side including recovery (=local channels count fully)\n        int buffersPerSubtask = parallelism + 1 + 2 * BUFFER_PER_CHANNEL * parallelism;\n        return buffersPerSubtask * parallelism * numShuffles;\n    }\n\n    /** A source that generates longs in a fixed number of splits. */\n    protected static class LongSource"}
{"magic_number_smell": "\n  private int tailIndex;\n\n  private volatile Thread updateThread = null;\n\n  private final PlayMessage[] pendingAudio = new PlayMessage[16];\n\n  // Visible only for testing purposes\n  Audio() {\n\n  }", "refactored_code": "  private static final int MAX_PENDING = 16;\n\n  private int tailIndex;\n\n  private volatile Thread updateThread = null;\n\n  private final PlayMessage[] pendingAudio = new PlayMessage[MAX_PENDING];\n\n  // Visible only for testing purposes\n  Audio() {\n\n  }"}
{"magic_number_smell": "  private static final int BASE_AMOUNT = 1000;\n  private static Bank bank;\n\n  @BeforeAll\n  public static void Setup() {\n    bank = new Bank(4, BASE_AMOUNT);\n  }\n\n  @AfterAll\n  public static void TearDown() {\n    bank = null;", "refactored_code": "  private static final int ACCOUNT_NUM = 4;\n  private static final int BASE_AMOUNT = 1000;\n  private static Bank bank;\n\n  @BeforeAll\n  public static void Setup() {\n    bank = new Bank(ACCOUNT_NUM, BASE_AMOUNT);\n  }\n\n  @AfterAll\n  public static void TearDown() {\n    bank = null;"}
{"magic_number_smell": "public class LoopInitializer {\n\t\n\tpublic static final int 1 = 1;\n\t\n\tpublic int getLoopInitializationPoint() {\n\t\treturn LoopInitializer.1;\n\t}\n}\n", "refactored_code": "\tpublic static final int LOOP_INIT_VALUE = 1;\npublic class LoopInitializer {\n\t\n\tpublic static final int LOOP_INIT_VALUE = 1;\n\t\n\tpublic int getLoopInitializationPoint() {\n\t\treturn LoopInitializer.LOOP_INIT_VALUE;\n\t}\n}\n"}
{"magic_number_smell": "  private static final String FIRSTNAME = \"Winston\";\n  private static final String LASTNAME = \"Churchill\";\n\n  @BeforeEach\n  void setUp() {\n    customer = new Customer(1, FIRSTNAME, LASTNAME);\n  }\n\n  @Test\n  void getAndSetId() {\n    final var newId = 2;", "refactored_code": "  private static final int ID = 1;\n  private static final String FIRSTNAME = \"Winston\";\n  private static final String LASTNAME = \"Churchill\";\n\n  @BeforeEach\n  void setUp() {\n    customer = new Customer(ID, FIRSTNAME, LASTNAME);\n  }\n\n  @Test\n  void getAndSetId() {\n    final var newId = 2;"}
