{"magic_number_smell": "                    if (level == 1) {\n                        returnCode = GET_CHAR_LEN_TOP_ALT_VARLEN;\n                    } else {\n                        returnCode = -1;\n                    }\n                } else {\n                    len = tlen;", "refactored_code": "    private static final int GET_CHAR_LEN_VARLEN            = -1;\n                    if (level == 1) {\n                        returnCode = GET_CHAR_LEN_TOP_ALT_VARLEN;\n                    } else {\n                        returnCode = GET_CHAR_LEN_VARLEN;\n                    }\n                } else {\n                    len = tlen;"}
{"magic_number_smell": "    private static final int 8 = 8;\n    private void entryRepeatRange(int id, int lower, int upper) {\n        if (regex.repeatRangeLo == null) {\n            regex.repeatRangeLo = new int[8];\n            regex.repeatRangeHi = new int[8];\n        } else if (id >= regex.repeatRangeLo.length){\n            int[]tmp = new int[regex.repeatRangeLo.length + 8];", "refactored_code": "    private static final int REPEAT_RANGE_ALLOC = 8;\n    private static final int REPEAT_RANGE_ALLOC = 8;\n    private void entryRepeatRange(int id, int lower, int upper) {\n        if (regex.repeatRangeLo == null) {\n            regex.repeatRangeLo = new int[REPEAT_RANGE_ALLOC];\n            regex.repeatRangeHi = new int[REPEAT_RANGE_ALLOC];\n        } else if (id >= regex.repeatRangeLo.length){\n            int[]tmp = new int[regex.repeatRangeLo.length + REPEAT_RANGE_ALLOC];"}
{"magic_number_smell": "        return -1;\n    }\n    public static boolean bsAt(int stats, int n) {\n        return (n < 4 * 8 ? stats & (1 << n) : (stats & 1)) != 0;\n    }\n    public static int bsOnAt(int stats, int n) {\n        if (n < 4 * 8) {", "refactored_code": "    public static final int BIT_STATUS_BITS_NUM = 4 * 8;\n        return -1;\n    }\n    public static boolean bsAt(int stats, int n) {\n        return (n < BIT_STATUS_BITS_NUM ? stats & (1 << n) : (stats & 1)) != 0;\n    }\n    public static int bsOnAt(int stats, int n) {\n        if (n < BIT_STATUS_BITS_NUM) {"}
{"magic_number_smell": "            Thread.interrupted();\n            throw new InterruptedException();\n        }\n        interruptCheckEvery = Math.min(interruptCheckEvery << 1, 256 << 7);\n    }\n\n    private boolean opEnd() {", "refactored_code": "    private static final int MAX_INTERRUPT_CHECK_EVERY = 256 << 7; // 32768\n            Thread.interrupted();\n            throw new InterruptedException();\n        }\n        interruptCheckEvery = Math.min(interruptCheckEvery << 1, MAX_INTERRUPT_CHECK_EVERY);\n    }\n\n    private boolean opEnd() {"}
{"magic_number_smell": "    private int used;\n\n    public CodeRangeBuffer() {\n        p = new int[5];\n        writeCodePoint(0, 0);\n    }\n", "refactored_code": "    private static final int INIT_MULTI_BYTE_RANGE_SIZE = 5;\n    private int used;\n\n    public CodeRangeBuffer() {\n        p = new int[INIT_MULTI_BYTE_RANGE_SIZE];\n        writeCodePoint(0, 0);\n    }\n"}
{"magic_number_smell": "\n        if (Config.DEBUG_SEARCH) debugSearch(str, end, start, range);\n\n        if (start > end || start < str) return -1;\n\n        /* anchor optimize: resume search range */\n        if (regex.anchor != 0 && str < end) {", "refactored_code": "    public static final int FAILED = -1;\n\n        if (Config.DEBUG_SEARCH) debugSearch(str, end, start, range);\n\n        if (start > end || start < str) return FAILED;\n\n        /* anchor optimize: resume search range */\n        if (regex.anchor != 0 && str < end) {"}
{"magic_number_smell": "    int compare(OptMapInfo m) {\n        if (m.value <= 0) return -1;\n\n        int ve = 20 * length * (ignoreCase > 0 ? 1 : 2);\n        int vm = 20 * 5 * 2 / m.value;\n\n        return mmd.compareDistanceValue(m.mmd, ve, vm);", "refactored_code": "    private static final int COMP_EM_BASE   = 20;\n    int compare(OptMapInfo m) {\n        if (m.value <= 0) return -1;\n\n        int ve = COMP_EM_BASE * length * (ignoreCase > 0 ? 1 : 2);\n        int vm = COMP_EM_BASE * 5 * 2 / m.value;\n\n        return mmd.compareDistanceValue(m.mmd, ve, vm);"}
{"magic_number_smell": "\n    public static final int MAXBIT               = (1 << 19); /* limit */\n\n    public static final int DEFAULT              = 0;\n\n    public static String toString(int option) {\n        String options = \"\";", "refactored_code": "    public static final int NONE                 = 0;\n\n    public static final int MAXBIT               = (1 << 19); /* limit */\n\n    public static final int DEFAULT              = NONE;\n\n    public static String toString(int option) {\n        String options = \"\";"}
{"magic_number_smell": "            return;\n        }\n\n        int v1 = 1<<15 / value;\n        int v2 = 1<<15 /alt.value;\n\n        if (mmd.compareDistanceValue(alt.mmd, v1, v2) > 0) copy(alt);", "refactored_code": "    private static final int z = 1<<15; /* 32768: something big value */\n            return;\n        }\n\n        int v1 = z / value;\n        int v2 = z /alt.value;\n\n        if (mmd.compareDistanceValue(alt.mmd, v1, v2) > 0) copy(alt);"}
{"magic_number_smell": "        } else {\n            not = false;\n        }\n        if (enc.strLength(bytes, p, stop) >= 4 + 3) { // else goto not_posix_bracket\n            boolean asciiRange = isAsciiRange(env.option) && !isPosixBracketAllRange(env.option);\n\n            for (int i=0; i<PosixBracket.PBSNamesLower.length; i++) {", "refactored_code": "    private static final int POSIX_BRACKET_NAME_MIN_LEN            = 4;\n        } else {\n            not = false;\n        }\n        if (enc.strLength(bytes, p, stop) >= POSIX_BRACKET_NAME_MIN_LEN + 3) { // else goto not_posix_bracket\n            boolean asciiRange = isAsciiRange(env.option) && !isPosixBracketAllRange(env.option);\n\n            for (int i=0; i<PosixBracket.PBSNamesLower.length; i++) {"}
{"magic_number_smell": "            if (enc.isDigit(c)) {\n                int onum = num;\n                num = num * 10 + Encoding.digitVal(c);\n                if (((onum ^ num) & 1 << 31) != 0) return -1;\n            } else {\n                unfetch();\n                break;", "refactored_code": "    private static final int INT_SIGN_BIT = 1 << 31;\n            if (enc.isDigit(c)) {\n                int onum = num;\n                num = num * 10 + Encoding.digitVal(c);\n                if (((onum ^ num) & INT_SIGN_BIT) != 0) return -1;\n            } else {\n                unfetch();\n                break;"}
{"magic_number_smell": "                int targetEnd = regex.exactEnd;\n\n                if (regex.intMapBackward == null) {\n                    if (s_ - range_ < 100) {\n                        return SLOW_BACKWARD.search(matcher, text, textP, adjustText, textEnd, textStart, s_, range_); // goto exact_method;\n                    }\n                    setBmBackwardSkip(regex, target, targetP, targetEnd);", "refactored_code": "        private static final int BM_BACKWARD_SEARCH_LENGTH_THRESHOLD = 100;\n                int targetEnd = regex.exactEnd;\n\n                if (regex.intMapBackward == null) {\n                    if (s_ - range_ < BM_BACKWARD_SEARCH_LENGTH_THRESHOLD) {\n                        return SLOW_BACKWARD.search(matcher, text, textP, adjustText, textEnd, textStart, s_, range_); // goto exact_method;\n                    }\n                    setBmBackwardSkip(regex, target, targetP, targetEnd);"}
{"magic_number_smell": "        if (stack != null) pushEnsured(ALT, regex.codeLength - 1); /* bottom stack */\n        if (repeatStk != null) {\n            for (int i = (Config.USE_SUBEXP_CALL ? 0 : 1); i <= regex.numMem; i++) {\n                repeatStk[i + memStartStk] = repeatStk[i + memEndStk] = -1;\n            }\n        }\n    }", "refactored_code": "    protected static final int INVALID_INDEX = -1;\n        if (stack != null) pushEnsured(ALT, regex.codeLength - 1); /* bottom stack */\n        if (repeatStk != null) {\n            for (int i = (Config.USE_SUBEXP_CALL ? 0 : 1); i <= regex.numMem; i++) {\n                repeatStk[i + memStartStk] = repeatStk[i + memEndStk] = INVALID_INDEX;\n            }\n        }\n    }"}
{"magic_number_smell": "    }\n\n    public void setNot() {\n        flags |= 1 << 0;\n    }\n\n    public void clearNot() {", "refactored_code": "    private static final int FLAG_NCCLASS_NOT = 1 << 0;\n    }\n\n    public void setNot() {\n        flags |= FLAG_NCCLASS_NOT;\n    }\n\n    public void clearNot() {"}
{"magic_number_smell": "        case A:\n            setTarget(other.target);\n            lower = 0;\n            upper = -1;\n            greedy = true;\n            break;\n", "refactored_code": "    public static final int REPEAT_INFINITE = -1;\n        case A:\n            setTarget(other.target);\n            lower = 0;\n            upper = REPEAT_INFINITE;\n            greedy = true;\n            break;\n"}
{"magic_number_smell": "    private void ensure(int ahead) {\n        int len = (end - p) + ahead;\n        if (len >= bytes.length) {\n            byte[]tmp = new byte[len + 16];\n            System.arraycopy(bytes, p, tmp, 0, end - p);\n            bytes = tmp;\n        }", "refactored_code": "    private static final int NODE_STR_MARGIN = 16;\n    private void ensure(int ahead) {\n        int len = (end - p) + ahead;\n        if (len >= bytes.length) {\n            byte[]tmp = new byte[len + NODE_STR_MARGIN];\n            System.arraycopy(bytes, p, tmp, 0, end - p);\n            bytes = tmp;\n        }"}
{"magic_number_smell": "\n    int numTokens = tokenizer.countTokens ();\n    if (\n    \t\tnumTokens < BlastWebSiteHitTableComparisonData.12 ||\n    \t\tnumTokens > BlastWebSiteHitTableComparisonData.MAX_NUM_FIELDS) {\n      \n      final String message = \"while reading \" + ", "refactored_code": "  public static final int MIN_NUM_FIELDS = 12;\n\n    int numTokens = tokenizer.countTokens ();\n    if (\n    \t\tnumTokens < BlastWebSiteHitTableComparisonData.MIN_NUM_FIELDS ||\n    \t\tnumTokens > BlastWebSiteHitTableComparisonData.MAX_NUM_FIELDS) {\n      \n      final String message = \"while reading \" + "}
{"magic_number_smell": "  private boolean duplicate; \n  \n  /**\n   *  This is the type of this event (eg 1, FEATURE_ADDED, etc),\n   *  as passed to the constructor\n   **/\n  private int type;", "refactored_code": "  public static final int FEATURE_DELETED = 1;\n  private boolean duplicate; \n  \n  /**\n   *  This is the type of this event (eg FEATURE_DELETED, FEATURE_ADDED, etc),\n   *  as passed to the constructor\n   **/\n  private int type;"}
{"magic_number_smell": "  private Entry entry;\n\n  /**\n   *  This is the type of this event (eg ENTRY_ADDED, 1, etc), as\n   *  passed to the constructor\n   **/\n  private int type;", "refactored_code": "  public static final int ENTRY_DELETED = 1;\n  private Entry entry;\n\n  /**\n   *  This is the type of this event (eg ENTRY_ADDED, ENTRY_DELETED, etc), as\n   *  passed to the constructor\n   **/\n  private int type;"}
{"magic_number_smell": "  private Feature feature;\n\n  /**\n   *  This is the type of this event (eg 1, QUALIFIER_CHANGED,\n   *  etc), as passed to the constructor\n   **/\n  private int type;", "refactored_code": "  public static final int LOCATION_CHANGED = 1;\n  private Feature feature;\n\n  /**\n   *  This is the type of this event (eg LOCATION_CHANGED, QUALIFIER_CHANGED,\n   *  etc), as passed to the constructor\n   **/\n  private int type;"}
{"magic_number_smell": "  class CvRenderer extends JLabel implements ListCellRenderer\n  {\n    /** */\n    private static final long 1L = 1L;\n\n    public CvRenderer() \n    {", "refactored_code": "  private static final long serialVersionUID = 1L;\n  class CvRenderer extends JLabel implements ListCellRenderer\n  {\n    /** */\n    private static final long serialVersionUID = 1L;\n\n    public CvRenderer() \n    {"}
{"magic_number_smell": "  /** delete statement */\n  public static final int DELETE = 3;\n  \n  /** type of statement <i>e.g.</i> 1, INSERT, DELETE, ... */\n  protected int type;\n  /** feature unique name */\n  protected String old_uniquename;", "refactored_code": "  public static final int UPDATE = 1;\n  /** delete statement */\n  public static final int DELETE = 3;\n  \n  /** type of statement <i>e.g.</i> UPDATE, INSERT, DELETE, ... */\n  protected int type;\n  /** feature unique name */\n  protected String old_uniquename;"}
{"magic_number_smell": "  class ColorRenderer extends JLabel\n                       implements TableCellRenderer \n  {\n    private static final long 1L = 1L;\n    Border unselectedBorder = null;\n    Border selectedBorder = null;\n    boolean isBordered = true;", "refactored_code": "  private static final long serialVersionUID = 1L;\n  class ColorRenderer extends JLabel\n                       implements TableCellRenderer \n  {\n    private static final long serialVersionUID = 1L;\n    Border unselectedBorder = null;\n    Border selectedBorder = null;\n    boolean isBordered = true;"}
{"magic_number_smell": "    removeItem(item);\n    insertItemAt(item, 0);\n    setSelectedItem(item);\n    if(getItemCount() > 30)\n      removeItemAt(getItemCount()-1);\n\n    order.add(item);", "refactored_code": "  public static final int MAX_MEM_LEN = 30;\n    removeItem(item);\n    insertItemAt(item, 0);\n    setSelectedItem(item);\n    if(getItemCount() > MAX_MEM_LEN)\n      removeItemAt(getItemCount()-1);\n\n    order.add(item);"}
{"magic_number_smell": "  public class ColorChooserShades extends JPanel\n                              implements javax.swing.event.ChangeListener\n  {\n    private static final long 1L = 1L;\n    private JPanel bannerPanel = new JPanel(new BorderLayout());\n    private JColorChooser tcc;\n    private Color definedColour[] = new Color[NUMBER_OF_SHADES];", "refactored_code": "  private static final long serialVersionUID = 1L;\n  public class ColorChooserShades extends JPanel\n                              implements javax.swing.event.ChangeListener\n  {\n    private static final long serialVersionUID = 1L;\n    private JPanel bannerPanel = new JPanel(new BorderLayout());\n    private JColorChooser tcc;\n    private Color definedColour[] = new Color[NUMBER_OF_SHADES];"}
{"magic_number_smell": "  class CommitButton extends JButton\n        implements FeatureChangeListener, SequenceChangeListener, EntryChangeListener\n  {\n    private static final long 1L = 1L;\n    private Color DEFAULT_FOREGROUND;\n    private CommitFrame commitFrame;\n    private final ChadoTransactionManager ctm;", "refactored_code": "  private static final long serialVersionUID = 1L;\n  class CommitButton extends JButton\n        implements FeatureChangeListener, SequenceChangeListener, EntryChangeListener\n  {\n    private static final long serialVersionUID = 1L;\n    private Color DEFAULT_FOREGROUND;\n    private CommitFrame commitFrame;\n    private final ChadoTransactionManager ctm;"}
{"magic_number_smell": "            ((IndexFastaStream)entry.getEMBLEntry().getSequence()).getContigs();\n\n        indexFastaCombo = new SequenceComboBox(contigs){\n          private static final long 1L = 1L;\n          public void update(IndexReferenceEvent event)\n          {\n            IndexFastaStream is = (IndexFastaStream)entry.getEMBLEntry().getSequence();", "refactored_code": "  private static final long serialVersionUID = 1L;\n            ((IndexFastaStream)entry.getEMBLEntry().getSequence()).getContigs();\n\n        indexFastaCombo = new SequenceComboBox(contigs){\n          private static final long serialVersionUID = 1L;\n          public void update(IndexReferenceEvent event)\n          {\n            IndexFastaStream is = (IndexFastaStream)entry.getEMBLEntry().getSequence();"}
{"magic_number_smell": "    }\n\n    scrollbar.setValues (1, getSize ().width,\n                         1, scroll_max + 100);\n\n    scrollbar.setBlockIncrement (getSize ().width);\n  }", "refactored_code": "  private final int SCROLL_BAR_SIZE = 100;\n    }\n\n    scrollbar.setValues (1, getSize ().width,\n                         1, scroll_max + SCROLL_BAR_SIZE);\n\n    scrollbar.setBlockIncrement (getSize ().width);\n  }"}
{"magic_number_smell": "    textPane = new JTextPane()\n    {\n      /** */\n      private static final long 1L = 1L;\n\n      public boolean getScrollableTracksViewportWidth()\n      {", "refactored_code": "  private static final long serialVersionUID = 1L;\n    textPane = new JTextPane()\n    {\n      /** */\n      private static final long serialVersionUID = 1L;\n\n      public boolean getScrollableTracksViewportWidth()\n      {"}
{"magic_number_smell": " */\nclass SelectionSubMenu extends JMenu\n{\n  private static final long 1L = 1L;\n  private String parentMenuStr;\n  public SelectionSubMenu(SelectionMenu parentMenu, String str)\n  {", "refactored_code": "  private static final long serialVersionUID = 1L;\n */\nclass SelectionSubMenu extends JMenu\n{\n  private static final long serialVersionUID = 1L;\n  private String parentMenuStr;\n  public SelectionSubMenu(SelectionMenu parentMenu, String str)\n  {"}
{"magic_number_smell": "    return new JPanel() \n    {\n      /** */\n      private static final long 1L = 1L;\n\n      public void update(Graphics g) \n      {", "refactored_code": "  private static final long serialVersionUID = 1L;\n    return new JPanel() \n    {\n      /** */\n      private static final long serialVersionUID = 1L;\n\n      public void update(Graphics g) \n      {"}
{"magic_number_smell": "\nclass QualifierPanel extends JPanel\n{\n  private static final long 1L = 1L;\n  private Hashtable<JCheckBox, Vector<JCheckBox>> qualifierCheckBoxes = new Hashtable<JCheckBox, Vector<JCheckBox>>();\n  private Feature feature;\n  protected int nrows = 0;", "refactored_code": "  private static final long serialVersionUID = 1L;\n\nclass QualifierPanel extends JPanel\n{\n  private static final long serialVersionUID = 1L;\n  private Hashtable<JCheckBox, Vector<JCheckBox>> qualifierCheckBoxes = new Hashtable<JCheckBox, Vector<JCheckBox>>();\n  private Feature feature;\n  protected int nrows = 0;"}
{"magic_number_smell": "\n    \n    combo = new SequenceComboBox(seqNames){\n      private static final long 1L = 1L;\n      public void update(IndexReferenceEvent event)\n      {\n        laststart = -1;", "refactored_code": "  private static final long serialVersionUID = 1L;\n\n    \n    combo = new SequenceComboBox(seqNames){\n      private static final long serialVersionUID = 1L;\n      public void update(IndexReferenceEvent event)\n      {\n        laststart = -1;"}
{"magic_number_smell": "  \n  protected static int[] FLAGS =\n  {\n    0x1,\n    PROPER_PAIR_FLAG,\n    READ_UNMAPPED_FLAG,\n    MATE_UNMAPPED_FLAG,", "refactored_code": "  protected static final int READ_PAIRED_FLAG = 0x1;\n  \n  protected static int[] FLAGS =\n  {\n    READ_PAIRED_FLAG,\n    PROPER_PAIR_FLAG,\n    READ_UNMAPPED_FLAG,\n    MATE_UNMAPPED_FLAG,"}
{"magic_number_smell": " */\nclass DatabaseLoginPrompt extends JPanel implements ILoginPrompt\n{\n  private static final long 1L = 1L;\n  private JPasswordField pfield;\n  private JTextField server;\n  private JTextField port;", "refactored_code": "  private static final long serialVersionUID = 1L;\n */\nclass DatabaseLoginPrompt extends JPanel implements ILoginPrompt\n{\n  private static final long serialVersionUID = 1L;\n  private JPasswordField pfield;\n  private JTextField server;\n  private JTextField port;"}
{"magic_number_smell": "    tree.setSelectionModel(new DefaultTreeSelectionModel() \n    { \n      /***/\n      private static final long 1L = 1L;\n\n      // Extend the implementation of the constructor, as if: \n      /* public this() */", "refactored_code": "  private static final long serialVersionUID = 1L;\n    tree.setSelectionModel(new DefaultTreeSelectionModel() \n    { \n      /***/\n      private static final long serialVersionUID = 1L;\n\n      // Extend the implementation of the constructor, as if: \n      /* public this() */"}
{"magic_number_smell": "    tree.setSelectionModel(new DefaultTreeSelectionModel() \n    { \n      /** */\n      private static final long 1L = 1L;\n\n      // Extend the implementation of the constructor, as if: \n      /* public this() */", "refactored_code": "  private static final long serialVersionUID = 1L;\n    tree.setSelectionModel(new DefaultTreeSelectionModel() \n    { \n      /** */\n      private static final long serialVersionUID = 1L;\n\n      // Extend the implementation of the constructor, as if: \n      /* public this() */"}
{"magic_number_smell": "  \n  class ComboBoxRenderer extends JLabel implements ListCellRenderer \n  {\n    private static final long 1L = 1L;\n    private JSeparator separator;\n\n    public ComboBoxRenderer() ", "refactored_code": "  private static final long serialVersionUID = 1L;\n  \n  class ComboBoxRenderer extends JLabel implements ListCellRenderer \n  {\n    private static final long serialVersionUID = 1L;\n    private JSeparator separator;\n\n    public ComboBoxRenderer() "}
{"magic_number_smell": "  protected class ButtonEditor extends DefaultCellEditor \n  {\n   /** */\n   private static final long 1L = 1L;\n   protected JButton buttRemove;\n   private boolean   isPushed;\n   private int selectedRow;", "refactored_code": "    private static final long serialVersionUID = 1L;\n  protected class ButtonEditor extends DefaultCellEditor \n  {\n   /** */\n   private static final long serialVersionUID = 1L;\n   protected JButton buttRemove;\n   private boolean   isPushed;\n   private int selectedRow;"}
{"magic_number_smell": "\n    try\n    {\n      for(i = beg>>13; i < idx.get(tid).n && offset[i] == 0; ++i);\n      min_off = (i == idx.get(tid).n)? offset[idx.get(tid).n-1] : offset[i];\n    }\n    catch(ArrayIndexOutOfBoundsException e)", "refactored_code": "  public static final int TAD_LIDX_SHIFT = 13; // linear index shift\n\n    try\n    {\n      for(i = beg>>TAD_LIDX_SHIFT; i < idx.get(tid).n && offset[i] == 0; ++i);\n      min_off = (i == idx.get(tid).n)? offset[idx.get(tid).n-1] : offset[i];\n    }\n    catch(ArrayIndexOutOfBoundsException e)"}
{"magic_number_smell": "    }\n    \n    combo = new SequenceComboBox(vcfReaders[0].getSeqNames()){\n      private static final long 1L = 1L;\n      public void update(IndexReferenceEvent event)\n      {\n        if(combo.getSelectedItem().equals(\"Combine References\"))", "refactored_code": "  private static final long serialVersionUID = 1L;\n    }\n    \n    combo = new SequenceComboBox(vcfReaders[0].getSeqNames()){\n      private static final long serialVersionUID = 1L;\n      public void update(IndexReferenceEvent event)\n      {\n        if(combo.getSelectedItem().equals(\"Combine References\"))"}
{"magic_number_smell": "\t\tlong startOffset = ((start - 1) / basesPerLine) * bytesPerLine + (start - 1) % basesPerLine;\n\n\t\t// Allocate a 128K buffer for reading in sequence data.\n\t\tByteBuffer channelBuffer = ByteBuffer.allocate(1024 * 100);\n\n\t\twhile (targetBuffer.position() < length) {\n\t\t\t// If the bufferOffset is currently within the eol characters in the", "refactored_code": "\tprivate static final int BUFFER_SIZE = 1024 * 100;\n\t\tlong startOffset = ((start - 1) / basesPerLine) * bytesPerLine + (start - 1) % basesPerLine;\n\n\t\t// Allocate a 128K buffer for reading in sequence data.\n\t\tByteBuffer channelBuffer = ByteBuffer.allocate(BUFFER_SIZE);\n\n\t\twhile (targetBuffer.position() < length) {\n\t\t\t// If the bufferOffset is currently within the eol characters in the"}
{"magic_number_smell": "\n\t\t\t\tif (confirmMD5(md5, data)) {\n\t\t\t\t\t// sanitize, Internet is a wild place:\n\t\t\t\t\tif (Utils.isValidSequence(data, 1000))\n\t\t\t\t\t\treturn data;\n\t\t\t\t\telse {\n\t\t\t\t\t\t// reject, it looks like garbage", "refactored_code": "\tprivate static final int REF_BASES_TO_CHECK_FOR_SANITY = 1000;\n\n\t\t\t\tif (confirmMD5(md5, data)) {\n\t\t\t\t\t// sanitize, Internet is a wild place:\n\t\t\t\t\tif (Utils.isValidSequence(data, REF_BASES_TO_CHECK_FOR_SANITY))\n\t\t\t\t\t\treturn data;\n\t\t\t\t\telse {\n\t\t\t\t\t\t// reject, it looks like garbage"}
{"magic_number_smell": "  public class ActiveJSplitPane extends JSplitPane\n  {\n    /** */\n    private static final long 1L = 1L;\n    private JLabel tabLabel;\n    private Color bg;\n", "refactored_code": "  private static final long serialVersionUID = 1L;\n  public class ActiveJSplitPane extends JSplitPane\n  {\n    /** */\n    private static final long serialVersionUID = 1L;\n    private JLabel tabLabel;\n    private Color bg;\n"}
{"magic_number_smell": "    ruler = new JPanel()\n    {\n      /** */\n      private static final long 1L = 1L;\n\n      public void paintComponent(Graphics g)\n      {", "refactored_code": "  private static final long serialVersionUID = 1L;\n    ruler = new JPanel()\n    {\n      /** */\n      private static final long serialVersionUID = 1L;\n\n      public void paintComponent(Graphics g)\n      {"}
{"magic_number_smell": "\n  public long getNumericID()\n  {\n    return id_counter++;\n  }\n\n  public Feature copy()", "refactored_code": "  private final long      id = id_counter++;\n\n  public long getNumericID()\n  {\n    return id;\n  }\n\n  public Feature copy()"}
{"magic_number_smell": "  /**\n   *  See comment above.\n   **/\n  private final Vector rbtree_buckets = new Vector (10);\n\n  /**\n   *  The Comparator that was passed to the constructor.", "refactored_code": "  private final int BUCKET_COUNT = 10;\n  /**\n   *  See comment above.\n   **/\n  private final Vector rbtree_buckets = new Vector (BUCKET_COUNT);\n\n  /**\n   *  The Comparator that was passed to the constructor."}
{"magic_number_smell": "    final String translation_string =\n      translation.toString ().substring (start, end + 1);\n\n    final float [] scores = new float [28];\n\n    float max_score = -1.0F;\n", "refactored_code": "  private static final int WINDOW_SIZE = 28;\n    final String translation_string =\n      translation.toString ().substring (start, end + 1);\n\n    final float [] scores = new float [WINDOW_SIZE];\n\n    float max_score = -1.0F;\n"}
{"magic_number_smell": "\n    stop_codon_cache = null;\n\n    forward_strand = new Strand(this, 1);\n    reverse_strand = new Strand(this, REVERSE);\n\n    for(int i = 0 ; i < listener_hash_map_array.length ; ++i) ", "refactored_code": "  static public final int FORWARD = 1;\n\n    stop_codon_cache = null;\n\n    forward_strand = new Strand(this, FORWARD);\n    reverse_strand = new Strand(this, REVERSE);\n\n    for(int i = 0 ; i < listener_hash_map_array.length ; ++i) "}
{"magic_number_smell": "   *  Return a String containing the bases of this strand.\n   **/\n  public String getStrandBases () {\n    if (getDirection () == Bases.FORWARD) {\n      return bases.toString ();\n    } else {\n      return Bases.reverseComplement (bases.toString ());", "refactored_code": "  static public final int FORWARD = Bases.FORWARD;\n   *  Return a String containing the bases of this strand.\n   **/\n  public String getStrandBases () {\n    if (getDirection () == FORWARD) {\n      return bases.toString ();\n    } else {\n      return Bases.reverseComplement (bases.toString ());"}
{"magic_number_smell": "     * @return complete url\n     */\n    public String getCompleteURL() {\n        return getURLWithFixes(1 | SCHEME\n                | DATABASE_NAME | QUERY_PARAMS);\n    }\n", "refactored_code": "    public static final int PROTOCOL = 1;\n     * @return complete url\n     */\n    public String getCompleteURL() {\n        return getURLWithFixes(PROTOCOL | SCHEME\n                | DATABASE_NAME | QUERY_PARAMS);\n    }\n"}
{"magic_number_smell": "\t{\n\t\tMockitoAnnotations.initMocks(this);\n\t\t\n\t\trange = new Range (70, END_POS);\n\t\tbases = new Bases( new EmblStreamSequence(SEQUENCE) );\n\t\tfwdStrand = bases.getForwardStrand();\n\t}", "refactored_code": "\tprivate static final int START_POS = 70;\n\t{\n\t\tMockitoAnnotations.initMocks(this);\n\t\t\n\t\trange = new Range (START_POS, END_POS);\n\t\tbases = new Bases( new EmblStreamSequence(SEQUENCE) );\n\t\tfwdStrand = bases.getForwardStrand();\n\t}"}
{"magic_number_smell": "\t\t// Then\n\t\t\n\t\tassertNotNull( result );\n\t\tassertEquals( 4, result.size() );\n\t\t\n\t\t// When\n\t\t", "refactored_code": "\tprivate static final int NUM_EMBL_HDRS_FOR_TESTS = 4;\n\t\t// Then\n\t\t\n\t\tassertNotNull( result );\n\t\tassertEquals( NUM_EMBL_HDRS_FOR_TESTS, result.size() );\n\t\t\n\t\t// When\n\t\t"}
{"magic_number_smell": "\t    // Then\n\t\t\n\t\tassertTrue(entry instanceof IndexedGFFDocumentEntry);\n\t\tassertEquals( 2238, artGffEntry.getFeatureCount() );\n\t\tassertNull( artGffEntry.getHeaderText() ); // Method not implemented for GFF\n\n\t\t", "refactored_code": "\tprivate final int NUM_INDEXED_GFF_FEATURES = 2238;\n\t    // Then\n\t\t\n\t\tassertTrue(entry instanceof IndexedGFFDocumentEntry);\n\t\tassertEquals( NUM_INDEXED_GFF_FEATURES, artGffEntry.getFeatureCount() );\n\t\tassertNull( artGffEntry.getHeaderText() ); // Method not implemented for GFF\n\n\t\t"}
{"magic_number_smell": "\t\tassertNotNull(\"Reverse strand is not null check\", bases.getReverseStrand());\n\t\tassertEquals(\"Reverse strand has correct direction identifier\", Strand.REVERSE, bases.getReverseStrand().getDirection());\n\t\t\n\t\tassertEquals(\"Check sequence length\", TEST_SEQUENCE.length(), bases.getLength());\n\t\tassertEquals(\"Check sequence letters\", TEST_SEQUENCE, bases.toString());\n\t}\n\t", "refactored_code": "\tprivate static final int SEQLEN = TEST_SEQUENCE.length();\n\t\tassertNotNull(\"Reverse strand is not null check\", bases.getReverseStrand());\n\t\tassertEquals(\"Reverse strand has correct direction identifier\", Strand.REVERSE, bases.getReverseStrand().getDirection());\n\t\t\n\t\tassertEquals(\"Check sequence length\", SEQLEN, bases.getLength());\n\t\tassertEquals(\"Check sequence letters\", TEST_SEQUENCE, bases.toString());\n\t}\n\t"}
{"magic_number_smell": "\t\t// When\n\n\t\twhen(feature.getStrand()).thenReturn(fwdStrand);\n\t\twhen(feature.getLocation()).thenReturn(new Location(new Range(10, FEATURE_END_POS)));\n\t\twhen(feature.isForwardFeature()).thenReturn(true);\n\t\t\n\t\tString bases = fwdStrand.getStrandBases();", "refactored_code": "\tprivate static final int FEATURE_START_POS = 10;\n\t\t// When\n\n\t\twhen(feature.getStrand()).thenReturn(fwdStrand);\n\t\twhen(feature.getLocation()).thenReturn(new Location(new Range(FEATURE_START_POS, FEATURE_END_POS)));\n\t\twhen(feature.isForwardFeature()).thenReturn(true);\n\t\t\n\t\tString bases = fwdStrand.getStrandBases();"}
{"magic_number_smell": "        sb.append(System.getProperty(\"line.separator\"));\n        sb.append(\"                this.lowerBound = lowerBound;\");\n        sb.append(System.getProperty(\"line.separator\"));\n        sb.append(\"                this.upperBound = -1;\");\n        sb.append(System.getProperty(\"line.separator\"));\n        sb.append(\"        }\");\n        sb.append(System.getProperty(\"line.separator\"));", "refactored_code": "        sb.append(\"        private final int INF = -1;\");\n        sb.append(System.getProperty(\"line.separator\"));\n        sb.append(\"                this.lowerBound = lowerBound;\");\n        sb.append(System.getProperty(\"line.separator\"));\n        sb.append(\"                this.upperBound = INF;\");\n        sb.append(System.getProperty(\"line.separator\"));\n        sb.append(\"        }\");\n        sb.append(System.getProperty(\"line.separator\"));"}
{"magic_number_smell": "        sb.append(System.getProperty(\"line.separator\"));\n        sb.append(\"        this.lowerBound = lowerBound;\");\n        sb.append(System.getProperty(\"line.separator\"));\n        sb.append(\"        this.upperBound = -1;\");\n        sb.append(System.getProperty(\"line.separator\"));\n        sb.append(\"    }\");\n        sb.append(System.getProperty(\"line.separator\"));", "refactored_code": "        sb.append(\"    private final int INF = -1;\");\n        sb.append(System.getProperty(\"line.separator\"));\n        sb.append(\"        this.lowerBound = lowerBound;\");\n        sb.append(System.getProperty(\"line.separator\"));\n        sb.append(\"        this.upperBound = INF;\");\n        sb.append(System.getProperty(\"line.separator\"));\n        sb.append(\"    }\");\n        sb.append(System.getProperty(\"line.separator\"));"}
{"magic_number_smell": "        sb.append(System.getProperty(\"line.separator\"));\n        sb.append(\"        this.lowerBound = lowerBound;\");\n        sb.append(System.getProperty(\"line.separator\"));\n        sb.append(\"        this.upperBound = -1;\");\n        sb.append(System.getProperty(\"line.separator\"));\n        sb.append(\"    }\");\n        sb.append(System.getProperty(\"line.separator\"));", "refactored_code": "        sb.append(\"    private final int INF = -1;\");\n        sb.append(System.getProperty(\"line.separator\"));\n        sb.append(\"        this.lowerBound = lowerBound;\");\n        sb.append(System.getProperty(\"line.separator\"));\n        sb.append(\"        this.upperBound = INF;\");\n        sb.append(System.getProperty(\"line.separator\"));\n        sb.append(\"    }\");\n        sb.append(System.getProperty(\"line.separator\"));"}
{"magic_number_smell": "    int julLevelValue = record.getLevel().intValue();\n    int slf4jLevel;\n\n    if (julLevelValue <= Level.FINEST.intValue()) {\n      slf4jLevel = LocationAwareLogger.TRACE_INT;\n    } else if (julLevelValue <= DEBUG_LEVEL_THRESHOLD) {\n      slf4jLevel = LocationAwareLogger.DEBUG_INT;", "refactored_code": "  private static final int TRACE_LEVEL_THRESHOLD = Level.FINEST.intValue();\n    int julLevelValue = record.getLevel().intValue();\n    int slf4jLevel;\n\n    if (julLevelValue <= TRACE_LEVEL_THRESHOLD) {\n      slf4jLevel = LocationAwareLogger.TRACE_INT;\n    } else if (julLevelValue <= DEBUG_LEVEL_THRESHOLD) {\n      slf4jLevel = LocationAwareLogger.DEBUG_INT;"}
{"magic_number_smell": "    * informational events than the <code>DEBUG</code level.\n   *  @since 1.2.12\n    */\n  public static final Level TRACE = new Level(5000, \"TRACE\", 7);\n\n\n  /**", "refactored_code": "  public static final int TRACE_INT = 5000;\n    * informational events than the <code>DEBUG</code level.\n   *  @since 1.2.12\n    */\n  public static final Level TRACE = new Level(TRACE_INT, \"TRACE\", 7);\n\n\n  /**"}
{"magic_number_smell": "                beginTracking();\n                doExecute();\n\n                result &= addedLatch.await(5000, TimeUnit.MILLISECONDS);\n                result &= removedLatch.await(5000, TimeUnit.MILLISECONDS);\n            } finally {\n                endTracking();", "refactored_code": "        private static final long DEFAULT_TIMEOUT = 5000;\n                beginTracking();\n                doExecute();\n\n                result &= addedLatch.await(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS);\n                result &= removedLatch.await(DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS);\n            } finally {\n                endTracking();"}
{"magic_number_smell": "\t          null);\n\t      \n\t      tracker.open();\n\t      final Object hw = tracker.waitForService(10000);\n\t      tracker.close();\n\t\n\t      if (hw != null) {", "refactored_code": "  public static final long DEFAULT_TIMEOUT = 10000;\n\t          null);\n\t      \n\t      tracker.open();\n\t      final Object hw = tracker.waitForService(DEFAULT_TIMEOUT);\n\t      tracker.close();\n\t\n\t      if (hw != null) {"}
{"magic_number_smell": "  \n  public int getCost()\n  {\n    return 0;\n  }\n\n  public BundleSuggestion suggestBundleToUse(DeploymentContent content)", "refactored_code": "  private static final int REPOSITORY_COST = 0;\n  \n  public int getCost()\n  {\n    return REPOSITORY_COST;\n  }\n\n  public BundleSuggestion suggestBundleToUse(DeploymentContent content)"}
{"magic_number_smell": "      tracker.open();\n      // add tracker to the list of trackers we close at tear down\n      srs.add(tracker);\n      Object x = tracker.waitForService(60000);\n      if (x == null) {\n        throw new RuntimeException(\"Gave up waiting for service \" + flt);\n      }", "refactored_code": "  public static final long DEFAULT_TIMEOUT = 60000; \n      tracker.open();\n      // add tracker to the list of trackers we close at tear down\n      srs.add(tracker);\n      Object x = tracker.waitForService(DEFAULT_TIMEOUT);\n      if (x == null) {\n        throw new RuntimeException(\"Gave up waiting for service \" + flt);\n      }"}
{"magic_number_smell": "\t * <p>\n\t * The type values are:\n\t * <ul>\n\t * <li>{@link #1}</li>\n\t * <li>{@link #CREATED}</li>\n\t * <li>{@link #DESTROYING}</li>\n\t * <li>{@link #DESTROYED}</li>", "refactored_code": "\tpublic static final int\tCREATING\t\t= 1;\n\t * <p>\n\t * The type values are:\n\t * <ul>\n\t * <li>{@link #CREATING}</li>\n\t * <li>{@link #CREATED}</li>\n\t * <li>{@link #DESTROYING}</li>\n\t * <li>{@link #DESTROYED}</li>"}
{"magic_number_smell": "    private final Map<ServiceRegistration, T> registrations;\n\n    public BaseManagedServiceFactory(BundleContext context, String name) {\n        this(context, name, 30000);\n    }\n\n    public BaseManagedServiceFactory(BundleContext context, String name, long timeoutBeforeInterrupt) {", "refactored_code": "    public static final long DEFAULT_TIMEOUT_BEFORE_INTERRUPT = 30000;\n    private final Map<ServiceRegistration, T> registrations;\n\n    public BaseManagedServiceFactory(BundleContext context, String name) {\n        this(context, name, DEFAULT_TIMEOUT_BEFORE_INTERRUPT);\n    }\n\n    public BaseManagedServiceFactory(BundleContext context, String name, long timeoutBeforeInterrupt) {"}
{"magic_number_smell": "    }\n\n    public static <T> T getOsgiService(BundleContext bundleContext, Class<T> type) {\n        return getOsgiService(bundleContext, type, null, 30000);\n    }\n\n    public static <T> T getOsgiService(BundleContext bundleContext, Class<T> type, String filter) {", "refactored_code": "    public static final long DEFAULT_TIMEOUT = 30000;\n    }\n\n    public static <T> T getOsgiService(BundleContext bundleContext, Class<T> type) {\n        return getOsgiService(bundleContext, type, null, DEFAULT_TIMEOUT);\n    }\n\n    public static <T> T getOsgiService(BundleContext bundleContext, Class<T> type, String filter) {"}
{"magic_number_smell": "    }\n\n    private long getDefaultTimeout() {\n        long timeout = 5 * 60 * 1000;\n        try {\n            timeout = Long.getLong(DEFAULT_TIMEOUT_PROPERTY, 5 * 60 * 1000);\n            if (timeout != 5 * 60 * 1000) {", "refactored_code": "    private static final long DEFAULT_TIMEOUT = 5 * 60 * 1000;\n    }\n\n    private long getDefaultTimeout() {\n        long timeout = DEFAULT_TIMEOUT;\n        try {\n            timeout = Long.getLong(DEFAULT_TIMEOUT_PROPERTY, DEFAULT_TIMEOUT);\n            if (timeout != DEFAULT_TIMEOUT) {"}
{"magic_number_smell": "        handlers = new NamespaceHandlerRegistryImpl(trackingContext);\n        executors = new ScheduledExecutorServiceWrapper(ctx, \"Blueprint Extender\", new ScheduledExecutorServiceFactory() {\n            public ScheduledExecutorService create(String name) {\n                int extenderThreads = 3;\n                try {\n                    extenderThreads = Integer.getInteger(EXTENDER_THREADS_PROPERTY, 3);\n                    if (extenderThreads != 3) {", "refactored_code": "    private static final int DEFAULT_NUMBER_OF_THREADS = 3;\n        handlers = new NamespaceHandlerRegistryImpl(trackingContext);\n        executors = new ScheduledExecutorServiceWrapper(ctx, \"Blueprint Extender\", new ScheduledExecutorServiceFactory() {\n            public ScheduledExecutorService create(String name) {\n                int extenderThreads = DEFAULT_NUMBER_OF_THREADS;\n                try {\n                    extenderThreads = Integer.getInteger(EXTENDER_THREADS_PROPERTY, DEFAULT_NUMBER_OF_THREADS);\n                    if (extenderThreads != DEFAULT_NUMBER_OF_THREADS) {"}
{"magic_number_smell": "            Type needed = parameterTypes[i];\n            long sc;\n            if (arg.type == null || needed == arg.type) {\n                sc = 1L;\n            } else if (allowCast && ClassUtil.getClass(needed).isAssignableFrom(ClassUtil.getClass(arg.type))) {\n                sc = COST_CAST;\n            } else {", "refactored_code": "    private static final long COST_ASSIGN  =       1L;\n            Type needed = parameterTypes[i];\n            long sc;\n            if (arg.type == null || needed == arg.type) {\n                sc = COST_ASSIGN;\n            } else if (allowCast && ClassUtil.getClass(needed).isAssignableFrom(ClassUtil.getClass(arg.type))) {\n                sc = COST_CAST;\n            } else {"}
{"magic_number_smell": "        metadata.setAvailability(CARDINALITY_0_1.equals(element.getAttribute(CARDINALITY_ATTRIBUTE))\n                ? ReferenceMetadata.AVAILABILITY_OPTIONAL\n                : ReferenceMetadata.AVAILABILITY_MANDATORY);\n        metadata.setTimeout(getLong(element.getAttribute(TIMEOUT_ATTRIBUTE), 300000));\n        metadata.setInterface(element.getAttribute(INTERFACE_ATTRIBUTE));\n        metadata.setFilter(element.getAttribute(FILTER_ATTRIBUTE));\n        String[] dependsOn = StringUtils.tokenizeToStringArray(element.getAttribute(DEPENDS_ON_ATTRIBUTE), \",; \");", "refactored_code": "    public static final int DEFAULT_TIMEOUT = 300000;\n        metadata.setAvailability(CARDINALITY_0_1.equals(element.getAttribute(CARDINALITY_ATTRIBUTE))\n                ? ReferenceMetadata.AVAILABILITY_OPTIONAL\n                : ReferenceMetadata.AVAILABILITY_MANDATORY);\n        metadata.setTimeout(getLong(element.getAttribute(TIMEOUT_ATTRIBUTE), DEFAULT_TIMEOUT));\n        metadata.setInterface(element.getAttribute(INTERFACE_ATTRIBUTE));\n        metadata.setFilter(element.getAttribute(FILTER_ATTRIBUTE));\n        String[] dependsOn = StringUtils.tokenizeToStringArray(element.getAttribute(DEPENDS_ON_ATTRIBUTE), \",; \");"}
{"magic_number_smell": "\n    @Test\n    public void testReferenceListenerDeadlock() throws Exception {\n        for (int i=0; i < 10; i++) {\n            Bundle b = context().getBundleByName(\"sample\" + i);\n            b.start();\n        }", "refactored_code": "    private static final int TOTAL_REF_TEST_BUNDLES = 10;\n\n    @Test\n    public void testReferenceListenerDeadlock() throws Exception {\n        for (int i=0; i < TOTAL_REF_TEST_BUNDLES; i++) {\n            Bundle b = context().getBundleByName(\"sample\" + i);\n            b.start();\n        }"}
{"magic_number_smell": "  public Object addingBundle(Bundle bundle, BundleEvent event) {\n    \n    if(mightContainEJBs(bundle)) {\n      if((bundle.getState() & Bundle.STARTING | Bundle.ACTIVE) != 0) {\n        startEJBs(bundle);\n      }\n      return bundle;", "refactored_code": "  private static final int STARTABLE = Bundle.STARTING | Bundle.ACTIVE;\n  public Object addingBundle(Bundle bundle, BundleEvent event) {\n    \n    if(mightContainEJBs(bundle)) {\n      if((bundle.getState() & STARTABLE) != 0) {\n        startEJBs(bundle);\n      }\n      return bundle;"}
{"magic_number_smell": "        URL url = new URL(contextPath);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n\n        conn.setConnectTimeout(10000);\n        conn.connect();\n\n        return conn;", "refactored_code": "    private static final int CONNECTION_TIMEOUT = 10000;\n        URL url = new URL(contextPath);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n\n        conn.setConnectTimeout(CONNECTION_TIMEOUT);\n        conn.connect();\n\n        return conn;"}
{"magic_number_smell": "    if (weavingJavaVersion == -1 ) {\n      //In order to avoid an inconsistent stack error the version of the woven byte code needs to match\n      //the level of byte codes in the original class\n      switch(new BigDecimal(System.getProperty(\"java.class.version\")).intValue()) {\n        case Opcodes.V21:\n          LOGGER.debug(\"Weaving to Java 21\");\n          weavingJavaVersion = Opcodes.V21;", "refactored_code": "  public static final int JAVA_CLASS_VERSION = new BigDecimal(System.getProperty(\"java.class.version\")).intValue();\n    if (weavingJavaVersion == -1 ) {\n      //In order to avoid an inconsistent stack error the version of the woven byte code needs to match\n      //the level of byte codes in the original class\n      switch(JAVA_CLASS_VERSION) {\n        case Opcodes.V21:\n          LOGGER.debug(\"Weaving to Java 21\");\n          weavingJavaVersion = Opcodes.V21;"}
{"magic_number_smell": "\tpublic static String[] jpaLayerNames = {\"OpenJPA\", \"Hibernate\"};\n\tpublic static final int 0 = 0;\n\tpublic static final int HIBERNATE = 1;\n\tpublic static int jpaLayer = 0;\n\n\tpublic static String[] orderProcessingModeNames =\n\t\t{ \"Synchronous\", \"Asynchronous_2-Phase\" };", "refactored_code": "\tpublic static final int OPENJPA = 0;\n\tpublic static String[] jpaLayerNames = {\"OpenJPA\", \"Hibernate\"};\n\tpublic static final int OPENJPA = 0;\n\tpublic static final int HIBERNATE = 1;\n\tpublic static int jpaLayer = OPENJPA;\n\n\tpublic static String[] orderProcessingModeNames =\n\t\t{ \"Synchronous\", \"Asynchronous_2-Phase\" };"}
{"magic_number_smell": "\t\tURL url = new URL(contextPath);\n\t\tHttpURLConnection conn = (HttpURLConnection) url.openConnection();\n\n\t\tconn.setConnectTimeout(30000);\n\t\tconn.connect();\n\n\t\treturn conn;", "refactored_code": "\tprivate static final int CONNECTION_TIMEOUT = 30000;\n\t\tURL url = new URL(contextPath);\n\t\tHttpURLConnection conn = (HttpURLConnection) url.openConnection();\n\n\t\tconn.setConnectTimeout(CONNECTION_TIMEOUT);\n\t\tconn.connect();\n\n\t\treturn conn;"}
{"magic_number_smell": "    URL url = new URL(contextPath);\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n\n    conn.setConnectTimeout(30000);\n    conn.connect();\n\n    return conn;", "refactored_code": "    private static final int CONNECTION_TIMEOUT = 30000;\n    URL url = new URL(contextPath);\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n\n    conn.setConnectTimeout(CONNECTION_TIMEOUT);\n    conn.connect();\n\n    return conn;"}
{"magic_number_smell": "    System.out.println(\"AccountAccessServiceImpl.openLineOfCreditAccount(\" + name + \",\" + assets\n        + \",\" + liabilities + \") riskThreshold = \" + _riskThreshold);\n    double risk = _creditCheckService.risk(name, assets, liabilities);\n    int accountNumber = -1;\n    if (risk < _riskThreshold)\n      accountNumber = _lineOfCreditAccountService.open(name);\n    System.out.println(\"AccountAccessServiceImpl.openLineOfCreditAccount(\" + name + \",\" + assets", "refactored_code": "  private static final int NO_ACCOUNT = -1; \n    System.out.println(\"AccountAccessServiceImpl.openLineOfCreditAccount(\" + name + \",\" + assets\n        + \",\" + liabilities + \") riskThreshold = \" + _riskThreshold);\n    double risk = _creditCheckService.risk(name, assets, liabilities);\n    int accountNumber = NO_ACCOUNT;\n    if (risk < _riskThreshold)\n      accountNumber = _lineOfCreditAccountService.open(name);\n    System.out.println(\"AccountAccessServiceImpl.openLineOfCreditAccount(\" + name + \",\" + assets"}
{"magic_number_smell": "\t}\n\t\n\tprivate static final int Constants.CHEQUING_ACCOUNT_BASE = Constants.CHEQUING_ACCOUNT_BASE;\n\tprivate static int nextAccount_ = Constants.CHEQUING_ACCOUNT_BASE;\n\tprivate static AccountRecord[] _accounts = new AccountRecord[10];\n\n\t@Override", "refactored_code": "\tprivate static final int BASE = Constants.CHEQUING_ACCOUNT_BASE;\n\t}\n\t\n\tprivate static final int BASE = Constants.CHEQUING_ACCOUNT_BASE;\n\tprivate static int nextAccount_ = BASE;\n\tprivate static AccountRecord[] _accounts = new AccountRecord[10];\n\n\t@Override"}
{"magic_number_smell": "  public double risk(String name, int assets, int liabilities) {\n    int equity = assets - liabilities;\n    double risk = 1.0;\n    if (equity <= -10000)\n      risk = 1.0;\n    else if (equity >= MAX)\n      risk = 0.0;", "refactored_code": "  private static final int MIN = -10000;\n  public double risk(String name, int assets, int liabilities) {\n    int equity = assets - liabilities;\n    double risk = 1.0;\n    if (equity <= MIN)\n      risk = 1.0;\n    else if (equity >= MAX)\n      risk = 0.0;"}
{"magic_number_smell": "  }\n  \n  private static final int Constants.LINEOFCREDIT_ACCOUNT_BASE = Constants.LINEOFCREDIT_ACCOUNT_BASE;\n  private static int nextAccount_ = Constants.LINEOFCREDIT_ACCOUNT_BASE;\n  private static AccountRecord[] _accounts = new AccountRecord[10];\n\n  @Override", "refactored_code": "  private static final int BASE = Constants.LINEOFCREDIT_ACCOUNT_BASE;\n  }\n  \n  private static final int BASE = Constants.LINEOFCREDIT_ACCOUNT_BASE;\n  private static int nextAccount_ = BASE;\n  private static AccountRecord[] _accounts = new AccountRecord[10];\n\n  @Override"}
{"magic_number_smell": "    BundleDescriptor(String symbolicName, Version version) {\n        this.symbolicName = symbolicName;\n        this.version = version;\n        this.bundleID = -1;\n        this.filter = null;\n    }\n", "refactored_code": "    public static final int BUNDLE_ID_UNSPECIFIED = -1;\n    BundleDescriptor(String symbolicName, Version version) {\n        this.symbolicName = symbolicName;\n        this.version = version;\n        this.bundleID = BUNDLE_ID_UNSPECIFIED;\n        this.filter = null;\n    }\n"}
{"magic_number_smell": "\n            switch (action)\n            {\n                case 0:\n                    return AccessController.getContext();\n                case ADD_EXTENSION_URL_ACTION:\n                    Method addURL =", "refactored_code": "        public static final int INITIALIZE_CONTEXT_ACTION = 0;\n\n            switch (action)\n            {\n                case INITIALIZE_CONTEXT_ACTION:\n                    return AccessController.getContext();\n                case ADD_EXTENSION_URL_ACTION:\n                    Method addURL ="}
{"magic_number_smell": "            case APPROX:\n                s = \"(\" + m_name + \"~=\" + toEncodedString(m_value) + \")\";\n                break;\n            case 0:\n                s = \"(*)\";\n                break;\n        }", "refactored_code": "    public static final int MATCH_ALL = 0;\n            case APPROX:\n                s = \"(\" + m_name + \"~=\" + toEncodedString(m_value) + \")\";\n                break;\n            case MATCH_ALL:\n                s = \"(*)\";\n                break;\n        }"}
{"magic_number_smell": "\n        Hashtable configuration = new Hashtable();\n        token = 0;\n        while ( nextToken( pr ) == 'N' )\n        {\n            String key = tokenValue;\n", "refactored_code": "    protected static final int TOKEN_NAME = 'N';\n\n        Hashtable configuration = new Hashtable();\n        token = 0;\n        while ( nextToken( pr ) == TOKEN_NAME )\n        {\n            String key = tokenValue;\n"}
{"magic_number_smell": "\t}\n\t\n\tpublic void addRequirements(Collection<? extends Requirement> requirements) throws BundleException, InvalidSyntaxException {\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tRegionDigraph copy = copyDigraph();\n\t\t\tRegion tail = copyTail(copy);\n\t\t\tRegion head = copyHead(copy);", "refactored_code": "\tpublic static final int MAX_ATTEMPTS_DEFAULT = 10;\n\t}\n\t\n\tpublic void addRequirements(Collection<? extends Requirement> requirements) throws BundleException, InvalidSyntaxException {\n\t\tfor (int i = 0; i < MAX_ATTEMPTS_DEFAULT; i++) {\n\t\t\tRegionDigraph copy = copyDigraph();\n\t\t\tRegion tail = copyTail(copy);\n\t\t\tRegion head = copyHead(copy);"}
{"magic_number_smell": "    }\n    \n    protected static void copy(InputStream is, OutputStream os) throws IOException {\n        byte[] bytes = new byte[2048];\n        int read;\n        while ((read = is.read(bytes)) != -1) {\n            os.write(bytes, 0, read);", "refactored_code": "    protected static final int ARRAY_SIZE_BYTES = 2048;\n    }\n    \n    protected static void copy(InputStream is, OutputStream os) throws IOException {\n        byte[] bytes = new byte[ARRAY_SIZE_BYTES];\n        int read;\n        while ((read = is.read(bytes)) != -1) {\n            os.write(bytes, 0, read);"}
{"magic_number_smell": "    }\n    \n    private Collection<Callable<Subsystem>> createInstallFeatureCallables() {\n        Collection<Callable<Subsystem>> callables = new ArrayList<Callable<Subsystem>>(50);\n        for (int i = 0; i < 50; i++) {\n            final int count = i;\n            callables.add(new Callable<Subsystem>() {", "refactored_code": "    private static final int FEATURE_COUNT = 50;\n    }\n    \n    private Collection<Callable<Subsystem>> createInstallFeatureCallables() {\n        Collection<Callable<Subsystem>> callables = new ArrayList<Callable<Subsystem>>(FEATURE_COUNT);\n        for (int i = 0; i < FEATURE_COUNT; i++) {\n            final int count = i;\n            callables.add(new Callable<Subsystem>() {"}
{"magic_number_smell": "\t\n\tprivate synchronized boolean commit0() throws BundleException {\n\t\tsynchronized (scope) {\n\t\t\tif (scope.getLastUpdate() > idGenerator.nextId())\n\t\t\t\treturn false;\n\t\t\tscope.setUpdating(true);\n\t\t\tsynchronized (bundles) {", "refactored_code": "\tprivate final long id = idGenerator.nextId();\n\t\n\tprivate synchronized boolean commit0() throws BundleException {\n\t\tsynchronized (scope) {\n\t\t\tif (scope.getLastUpdate() > id)\n\t\t\t\treturn false;\n\t\t\tscope.setUpdating(true);\n\t\t\tsynchronized (bundles) {"}
{"magic_number_smell": "\n\n    public <T> T getService(Class<T> type) {\n        return getService(type, null, 15000);\n    }\n\n    public <T> T getService(Class<T> type, long timeout) {", "refactored_code": "    public static final long DEFAULT_TIMEOUT = 15000;\n\n\n    public <T> T getService(Class<T> type) {\n        return getService(type, null, DEFAULT_TIMEOUT);\n    }\n\n    public <T> T getService(Class<T> type, long timeout) {"}
{"magic_number_smell": "    }\n\n    private static void assertAllowedModifier(Method m) {\n        if ((m.getModifiers() & Modifier.PRIVATE | Modifier.STATIC) != 0) {\n            throw new IllegalArgumentException(\"Transaction annotation is not allowed on private or static method \" + m);\n        }\n    }", "refactored_code": "    private static final int BANNED_MODIFIERS = Modifier.PRIVATE | Modifier.STATIC;\n    }\n\n    private static void assertAllowedModifier(Method m) {\n        if ((m.getModifiers() & BANNED_MODIFIERS) != 0) {\n            throw new IllegalArgumentException(\"Transaction annotation is not allowed on private or static method \" + m);\n        }\n    }"}
{"magic_number_smell": "            }\n        }\n\n        if (expiryTimeout > 0 && System.currentTimeMillis() > lastUsed + expiryTimeout) {\n            hasExpired = true;\n            if (referenceCount == 0) {\n                close();", "refactored_code": "    private final long firstUsed = lastUsed;\n            }\n        }\n\n        if (expiryTimeout > 0 && System.currentTimeMillis() > firstUsed + expiryTimeout) {\n            hasExpired = true;\n            if (referenceCount == 0) {\n                close();"}
{"magic_number_smell": "        this.properties = properties;\n        this.bundleContext = bundleContext;\n        // Transaction timeout\n        int transactionTimeout = getInt(this.properties, TRANSACTION_TIMEOUT, 600);\n        if (transactionTimeout <= 0) {\n            throw new ConfigurationException(TRANSACTION_TIMEOUT, \"The transaction timeout property must be greater than zero.\");\n        }", "refactored_code": "    public static final int DEFAULT_TRANSACTION_TIMEOUT = 600; // 600 seconds -> 10 minutes\n        this.properties = properties;\n        this.bundleContext = bundleContext;\n        // Transaction timeout\n        int transactionTimeout = getInt(this.properties, TRANSACTION_TIMEOUT, DEFAULT_TRANSACTION_TIMEOUT);\n        if (transactionTimeout <= 0) {\n            throw new ConfigurationException(TRANSACTION_TIMEOUT, \"The transaction timeout property must be greater than zero.\");\n        }"}
{"magic_number_smell": "public class XidFactoryImpl implements XidFactory {\n    private final byte[] baseId = new byte[Xid.MAXGTRIDSIZE];\n    private final long System.currentTimeMillis() = System.currentTimeMillis();\n    private long count = System.currentTimeMillis();\n\n    public XidFactoryImpl(byte[] tmId) {\n        System.arraycopy(tmId, 0, baseId, 8, tmId.length);", "refactored_code": "    private final long start = System.currentTimeMillis();\npublic class XidFactoryImpl implements XidFactory {\n    private final byte[] baseId = new byte[Xid.MAXGTRIDSIZE];\n    private final long start = System.currentTimeMillis();\n    private long count = start;\n\n    public XidFactoryImpl(byte[] tmId) {\n        System.arraycopy(tmId, 0, baseId, 8, tmId.length);"}
{"magic_number_smell": "  /** The size by which to grow our array */\n  private static final int 0x4000 = 0x4000;\n  /** The bytes that have been read so far */\n  private byte[] bytes = new byte[0x4000];\n  /** Index of the next empty entry in the array */\n  private int pos = 0;\n  /** The input stream that actually holds the data */", "refactored_code": "  private static final int bufferGrowthSize = 0x4000;\n  /** The size by which to grow our array */\n  private static final int bufferGrowthSize = 0x4000;\n  /** The bytes that have been read so far */\n  private byte[] bytes = new byte[bufferGrowthSize];\n  /** Index of the next empty entry in the array */\n  private int pos = 0;\n  /** The input stream that actually holds the data */"}
{"magic_number_smell": "   * List of Name/Value\n   */\n  public static class NameValueList extends ArrayList<NameValuePair> implements NameValueCollection, List<NameValuePair> {\n\tprivate static final long -6446338858542599141L = 1808636823825029983L;\n\n\tpublic void addToCollection(String n, Map<String,String> v){\n      this.add(new NameValuePair(n,v));", "refactored_code": "\tprivate static final long serialVersionUID = -6446338858542599141L;\n   * List of Name/Value\n   */\n  public static class NameValueList extends ArrayList<NameValuePair> implements NameValueCollection, List<NameValuePair> {\n\tprivate static final long serialVersionUID = 1808636823825029983L;\n\n\tpublic void addToCollection(String n, Map<String,String> v){\n      this.add(new NameValuePair(n,v));"}
{"magic_number_smell": "    public void test_jdk_chap13_4_14_2() {\n        ClassWriter cw = new ClassWriter(0);\n        cw.visit(V1_5, ACC_PUBLIC, \"pkg/Test\", null, \"versioning/java/files/TestA\", null);\n        cw.visitMethod(ACC_PUBLIC + 0, \"getCooLen\", \"(Ljava/lang/String;)I\", null, null).visitEnd();\n        cw.visitEnd();\n        byte[] oldBytes = cw.toByteArray();\n", "refactored_code": "    private static final int ACC_ABASTRACT = 0;\n    public void test_jdk_chap13_4_14_2() {\n        ClassWriter cw = new ClassWriter(0);\n        cw.visit(V1_5, ACC_PUBLIC, \"pkg/Test\", null, \"versioning/java/files/TestA\", null);\n        cw.visitMethod(ACC_PUBLIC + ACC_ABASTRACT, \"getCooLen\", \"(Ljava/lang/String;)I\", null, null).visitEnd();\n        cw.visitEnd();\n        byte[] oldBytes = cw.toByteArray();\n"}
{"magic_number_smell": "    private File outputDir;\n\n    public CachedOutputStream() {\n        this(64 * 1024, null);\n    }\n\n    public CachedOutputStream(long threshold, File outputDir) {", "refactored_code": "    private static final int DEFAULT_THRESHOLD = 64 * 1024;\n    private File outputDir;\n\n    public CachedOutputStream() {\n        this(DEFAULT_THRESHOLD, null);\n    }\n\n    public CachedOutputStream(long threshold, File outputDir) {"}
{"magic_number_smell": "\tpublic Visualization() {\n\t\tsuper();\n\t\tthis.frame = new JFrame(\"We are making progress here\"); //$NON-NLS-1$\n\t\tthis.progress = new JProgressBar(0, 600);\n\t}\n\n\tprivate void buildUI() {", "refactored_code": "\tprivate static final int PREFERRED_WIDTH = 600;\n\tpublic Visualization() {\n\t\tsuper();\n\t\tthis.frame = new JFrame(\"We are making progress here\"); //$NON-NLS-1$\n\t\tthis.progress = new JProgressBar(0, PREFERRED_WIDTH);\n\t}\n\n\tprivate void buildUI() {"}
{"magic_number_smell": "    }\n\n    public static Percent createFromFactor(double factor) {\n        return new Percent(factor * Percent.100.0d);\n    }\n\n    public static Percent createFromFactor(int part, int whole) {", "refactored_code": "    public static final double PERCENTAGE_FACTOR = 100.0d;\n    }\n\n    public static Percent createFromFactor(double factor) {\n        return new Percent(factor * Percent.PERCENTAGE_FACTOR);\n    }\n\n    public static Percent createFromFactor(int part, int whole) {"}
{"magic_number_smell": "\t\t *            NULL to use system-level default.\n\t\t */\n\t\tpublic UnicodeReader(InputStream in, String defaultEnc) {\n\t\t\tinternalIn = new PushbackInputStream(in, 4);\n\t\t\tthis.defaultEnc = defaultEnc;\n\t\t}\n", "refactored_code": "\t\tprivate static final int BOM_SIZE = 4;\n\t\t *            NULL to use system-level default.\n\t\t */\n\t\tpublic UnicodeReader(InputStream in, String defaultEnc) {\n\t\t\tinternalIn = new PushbackInputStream(in, BOM_SIZE);\n\t\t\tthis.defaultEnc = defaultEnc;\n\t\t}\n"}
{"magic_number_smell": "\t\t{\n\t\t\tthrow new IllegalArgumentException(\"id must not be null!\");\n\t\t}\n\t\tif(id.length()< 2)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"id must have at least \"+2+\" characters!\");\n\t\t}", "refactored_code": "\tprivate static final int HASH_DIRECTORY_NAME_LENGTH = 2;\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"id must not be null!\");\n\t\t}\n\t\tif(id.length()< HASH_DIRECTORY_NAME_LENGTH)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"id must have at least \"+HASH_DIRECTORY_NAME_LENGTH+\" characters!\");\n\t\t}"}
{"magic_number_smell": "\n\tpublic BlockingCircularBuffer(int bufferSize)\n\t{\n\t\tthis(bufferSize, 500);\n\t}\n\n\tpublic int getCongestionDelay()", "refactored_code": "\tprivate static final int DEFAULT_CONGESTION_DELAY = 500;\n\n\tpublic BlockingCircularBuffer(int bufferSize)\n\t{\n\t\tthis(bufferSize, DEFAULT_CONGESTION_DELAY);\n\t}\n\n\tpublic int getCongestionDelay()"}
{"magic_number_smell": "\tpublic void setUp()\n\t\tthrows Exception\n\t{\n\t\tinstance = new OverwritingCircularBuffer<>(5);\n\t}\n\n\t@Test", "refactored_code": "\tprivate static final int TEST_BUFFER_SIZE = 5;\n\tpublic void setUp()\n\t\tthrows Exception\n\t{\n\t\tinstance = new OverwritingCircularBuffer<>(TEST_BUFFER_SIZE);\n\t}\n\n\t@Test"}
{"magic_number_smell": "\t\t\t\t\t}\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tThread.sleep(500);\n\t\t\t\t\t}\n\t\t\t\t\tcatch(InterruptedException e)\n\t\t\t\t\t{", "refactored_code": "\t\tprivate static final int UPDATE_INTERVAL = 500;\n\t\t\t\t\t}\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tThread.sleep(UPDATE_INTERVAL);\n\t\t\t\t\t}\n\t\t\t\t\tcatch(InterruptedException e)\n\t\t\t\t\t{"}
{"magic_number_smell": "\t\t\t\tfor(E element : elements)\n\t\t\t\t{\n\t\t\t\t\toffsets[index] = offset;\n\t\t\t\t\toffset = offset + internalWriteElement(dataFile, offset, element, codec) + 4;\n\t\t\t\t\tindex++;\n\t\t\t\t}\n", "refactored_code": "\tpublic static final long DATA_LENGTH_SIZE = 4;\n\t\t\t\tfor(E element : elements)\n\t\t\t\t{\n\t\t\t\t\toffsets[index] = offset;\n\t\t\t\t\toffset = offset + internalWriteElement(dataFile, offset, element, codec) + DATA_LENGTH_SIZE;\n\t\t\t\t\tindex++;\n\t\t\t\t}\n"}
{"magic_number_smell": "\t\t\t{\n\t\t\t\traf.seek(0);\n\t\t\t\tint codecMagic = raf.readInt();\n\t\t\t\tif(codecMagic == 0x0B501E7E)\n\t\t\t\t{\n\t\t\t\t\treturn raf.readInt();\n\t\t\t\t}", "refactored_code": "\tpublic static final int CODEC_FILE_HEADER_MAGIC_VALUE = 0x0B501E7E;\n\t\t\t{\n\t\t\t\traf.seek(0);\n\t\t\t\tint codecMagic = raf.readInt();\n\t\t\t\tif(codecMagic == CODEC_FILE_HEADER_MAGIC_VALUE)\n\t\t\t\t{\n\t\t\t\t\treturn raf.readInt();\n\t\t\t\t}"}
{"magic_number_smell": "\tpublic void setOffset(RandomAccessFile indexFile, long index, long offset)\n\t\tthrows IOException\n\t{\n\t\tlong offsetOffset = 8 * index;\n\t\tlong fileLength = indexFile.length();\n\t\tif(fileLength < offsetOffset)\n\t\t{", "refactored_code": "\tpublic static final long DATA_OFFSET_SIZE = 8;\n\tpublic void setOffset(RandomAccessFile indexFile, long index, long offset)\n\t\tthrows IOException\n\t{\n\t\tlong offsetOffset = DATA_OFFSET_SIZE * index;\n\t\tlong fileLength = indexFile.length();\n\t\tif(fileLength < offsetOffset)\n\t\t{"}
{"magic_number_smell": "\t\t\t\tfor(E element : elements)\n\t\t\t\t{\n\t\t\t\t\toffsets[index] = offset;\n\t\t\t\t\toffset = offset + internalWriteElement(dataFile, offset, elementsCount + index, element, codec) + 4 + INDEX_SIZE;\n\t\t\t\t\tindex++;\n\t\t\t\t}\n", "refactored_code": "\tpublic static final long DATA_LENGTH_SIZE = 4;\n\t\t\t\tfor(E element : elements)\n\t\t\t\t{\n\t\t\t\t\toffsets[index] = offset;\n\t\t\t\t\toffset = offset + internalWriteElement(dataFile, offset, elementsCount + index, element, codec) + DATA_LENGTH_SIZE + INDEX_SIZE;\n\t\t\t\t\tindex++;\n\t\t\t\t}\n"}
{"magic_number_smell": "      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:de.huxhorn.sulky.codec.filebuffer.MapEntry)\n      MapEntryOrBuilder {\n  private static final long 0L = 0L;\n    // Use MapEntry.newBuilder() to construct.\n    private MapEntry(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);", "refactored_code": "  private static final long serialVersionUID = 0L;\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:de.huxhorn.sulky.codec.filebuffer.MapEntry)\n      MapEntryOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use MapEntry.newBuilder() to construct.\n    private MapEntry(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);"}
{"magic_number_smell": "\tpublic static boolean isValidXMLCharacter(int codePoint)\n\t{\n\t\treturn codePoint == '\\t' || codePoint == '\\r' || codePoint == '\\n' ||\n\t\t\t\t(codePoint >= 0x000020 && codePoint <= XML_CHAR_RANGE_A_END) ||\n\t\t\t\t(codePoint >= XML_CHAR_RANGE_B_START && codePoint <= XML_CHAR_RANGE_B_END) ||\n\t\t\t\t(codePoint >= XML_CHAR_RANGE_C_START && codePoint <= XML_CHAR_RANGE_C_END);\n\t}", "refactored_code": "\tprivate static final int XML_CHAR_RANGE_A_START = 0x000020;\n\tpublic static boolean isValidXMLCharacter(int codePoint)\n\t{\n\t\treturn codePoint == '\\t' || codePoint == '\\r' || codePoint == '\\n' ||\n\t\t\t\t(codePoint >= XML_CHAR_RANGE_A_START && codePoint <= XML_CHAR_RANGE_A_END) ||\n\t\t\t\t(codePoint >= XML_CHAR_RANGE_B_START && codePoint <= XML_CHAR_RANGE_B_END) ||\n\t\t\t\t(codePoint >= XML_CHAR_RANGE_C_START && codePoint <= XML_CHAR_RANGE_C_END);\n\t}"}
{"magic_number_smell": "\tpublic void normal()\n\t\t\tthrows IOException\n\t{\n\t\tJUnitTools.copyResourceToFile(\"/Foo.groovy\", fooFile, System.currentTimeMillis() - 60_000);\n\n\t\tGroovyInstance instance = new GroovyInstance();\n\t\tinstance.setGroovyFileName(fooFile.getAbsolutePath());", "refactored_code": "\tprivate static final long ONE_MINUTE = 60_000;\n\tpublic void normal()\n\t\t\tthrows IOException\n\t{\n\t\tJUnitTools.copyResourceToFile(\"/Foo.groovy\", fooFile, System.currentTimeMillis() - ONE_MINUTE);\n\n\t\tGroovyInstance instance = new GroovyInstance();\n\t\tinstance.setGroovyFileName(fooFile.getAbsolutePath());"}
{"magic_number_smell": "\t\t\t// correct +/-hhmm to +/-hh:mm\n\t\t\tString hh = matcher.group(1);\n\t\t\tString mm = matcher.group(2);\n\t\t\tdateTime = dateTime.substring(0, dateTime.length() - 5) + hh + \":\" + mm;\n\t\t}\n\t\tTemporalAccessor temporal = ISO_DATE_TIME_PARSER.parse(dateTime);\n\t\tlong seconds = temporal.getLong(ChronoField.INSTANT_SECONDS);", "refactored_code": "\tprivate static final int TIMEZONE_DATE_FORMAT_LENGTH = 5;\n\t\t\t// correct +/-hhmm to +/-hh:mm\n\t\t\tString hh = matcher.group(1);\n\t\t\tString mm = matcher.group(2);\n\t\t\tdateTime = dateTime.substring(0, dateTime.length() - TIMEZONE_DATE_FORMAT_LENGTH) + hh + \":\" + mm;\n\t\t}\n\t\tTemporalAccessor temporal = ISO_DATE_TIME_PARSER.parse(dateTime);\n\t\tlong seconds = temporal.getLong(ChronoField.INSTANT_SECONDS);"}
{"magic_number_smell": "\tpublic static class TableColumnLayoutInfo\n\t\timplements Serializable\n\t{\n\t\tprivate static final long 367475030324866809L = 8018128012962924414L;\n\n\t\tprivate String columnName;\n\t\tprivate int width;", "refactored_code": "\tprivate static final long serialVersionUID = 367475030324866809L;\n\tpublic static class TableColumnLayoutInfo\n\t\timplements Serializable\n\t{\n\t\tprivate static final long serialVersionUID = 8018128012962924414L;\n\n\t\tprivate String columnName;\n\t\tprivate int width;"}
{"magic_number_smell": "\t\t}\n\n\t\tthis.mixColor = mixColor;\n\t\tif(mixValue < 0.0f)\n\t\t{\n\t\t\tmixValue = 0.0f;\n\t\t}", "refactored_code": "    private static final float MIN_MIX_VALUE = 0.0f;\n\t\t}\n\n\t\tthis.mixColor = mixColor;\n\t\tif(mixValue < MIN_MIX_VALUE)\n\t\t{\n\t\t\tmixValue = MIN_MIX_VALUE;\n\t\t}"}
{"magic_number_smell": "\t\t\t\t\t\t\trunnable.run();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tThread.sleep(200);\n\t\t\t\t}\n\t\t\t\tcatch(InterruptedException e)\n\t\t\t\t{", "refactored_code": "\t\tprivate static final long POLL_INTERVAL = 200;\n\t\t\t\t\t\t\trunnable.run();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tThread.sleep(POLL_INTERVAL);\n\t\t\t\t}\n\t\t\t\tcatch(InterruptedException e)\n\t\t\t\t{"}
{"magic_number_smell": "\t{\n\t\tfor(int i = count-1; i >= 0; i--)\n\t\t{\n\t\t\tint index = (int)((value >>> (i * MASK_BITS)) & 0x1F);\n\t\t\tbuilder.append(ENCODING_CHARS[index]);\n\t\t}\n\t}", "refactored_code": "\tprivate static final int MASK = 0x1F;\n\t{\n\t\tfor(int i = count-1; i >= 0; i--)\n\t\t{\n\t\t\tint index = (int)((value >>> (i * MASK_BITS)) & MASK);\n\t\t\tbuilder.append(ENCODING_CHARS[index]);\n\t\t}\n\t}"}
{"magic_number_smell": "\n\t\tDataInputStream dis = new DataInputStream(is);\n\t\tint magic = dis.readInt();\n\t\tif(0xCAFEBABE != magic)\n\t\t{\n\t\t\t//if(logger.isDebugEnabled()) logger.debug(\"Wrong magic number for class in {}. Ignoring.\", classFileName);\n\t\t\tdis.close();", "refactored_code": "\tprivate static final int MAGIC_NUMBER_CLASS = 0xCAFEBABE;\n\n\t\tDataInputStream dis = new DataInputStream(is);\n\t\tint magic = dis.readInt();\n\t\tif(MAGIC_NUMBER_CLASS != magic)\n\t\t{\n\t\t\t//if(logger.isDebugEnabled()) logger.debug(\"Wrong magic number for class in {}. Ignoring.\", classFileName);\n\t\t\tdis.close();"}
{"magic_number_smell": "\t@SuppressWarnings(\"PMD.CloseResource\")\n\tpublic static void main(String[] args)\n\t{\n\t\tstatusCode = 0;\n\t\tString propertiesName = System.getProperty(PROPERTIES_NAME_PROPERTY, PROPERTIES_NAME);\n\n\t\tInputStream input = Main.class.getResourceAsStream(propertiesName);", "refactored_code": "\tpublic static final int NO_ERROR_STATUS_CODE = 0;\n\t@SuppressWarnings(\"PMD.CloseResource\")\n\tpublic static void main(String[] args)\n\t{\n\t\tstatusCode = NO_ERROR_STATUS_CODE;\n\t\tString propertiesName = System.getProperty(PROPERTIES_NAME_PROPERTY, PROPERTIES_NAME);\n\n\t\tInputStream input = Main.class.getResourceAsStream(propertiesName);"}
{"magic_number_smell": "\t\t\n\t\ttry {\n\t\t\tint byteCount = 0;\n\t\t\tbyte[] buffer = new byte[4096];\n\t\t\tint bytesRead = -1;\n\t\t\twhile ((bytesRead = in.read(buffer)) != -1) {\n\t\t\t\tout.write(buffer, 0, bytesRead);", "refactored_code": "\tpublic static final int BUFFER_SIZE = 4096;\n\t\t\n\t\ttry {\n\t\t\tint byteCount = 0;\n\t\t\tbyte[] buffer = new byte[BUFFER_SIZE];\n\t\t\tint bytesRead = -1;\n\t\t\twhile ((bytesRead = in.read(buffer)) != -1) {\n\t\t\t\tout.write(buffer, 0, bytesRead);"}
{"magic_number_smell": "\t\t\n\t\ttry {\n\t\t\tint byteCount = 0;\n\t\t\tbyte[] buffer = new byte[4096];\n\t\t\tint bytesRead = -1;\n\t\t\twhile ((bytesRead = in.read(buffer)) != -1) {\n\t\t\t\tout.write(buffer, 0, bytesRead);", "refactored_code": "\tpublic static final int BUFFER_SIZE = 4096;\n\t\t\n\t\ttry {\n\t\t\tint byteCount = 0;\n\t\t\tbyte[] buffer = new byte[BUFFER_SIZE];\n\t\t\tint bytesRead = -1;\n\t\t\twhile ((bytesRead = in.read(buffer)) != -1) {\n\t\t\t\tout.write(buffer, 0, bytesRead);"}
{"magic_number_smell": "\t\t\n\t\tthis.defaultEncoding = defaultEncoding;\n\n\t\tbyte buffer[] = new byte[4];\n\t\tPushbackInputStream pushbackStream = new PushbackInputStream(in, 4);\n\t\tint read = pushbackStream.read(buffer, 0, 4);\n", "refactored_code": "\tprivate static final int MAX_BOM_SIZE = 4;\n\t\t\n\t\tthis.defaultEncoding = defaultEncoding;\n\n\t\tbyte buffer[] = new byte[MAX_BOM_SIZE];\n\t\tPushbackInputStream pushbackStream = new PushbackInputStream(in, MAX_BOM_SIZE);\n\t\tint read = pushbackStream.read(buffer, 0, MAX_BOM_SIZE);\n"}
{"magic_number_smell": "\n\tprivate boolean xhtml = true;\n\n\tprivate int state = 0;\n\n\tprivate TagWriter parent;\n", "refactored_code": "\tprivate static final int STATE_CLOSED = 0;\n\n\tprivate boolean xhtml = true;\n\n\tprivate int state = STATE_CLOSED;\n\n\tprivate TagWriter parent;\n"}
{"magic_number_smell": "    /**\n     * Returns the time in milliseconds that has to be elapsed since the last\n     * up-to-date check before another check is performed. Implementors may \n     * return {@link #-1L} to indicate that the content should be \n     * cached eternally.\n     */\n    public long getTimeToLive();", "refactored_code": "\tpublic static final long CACHE_ETERNALLY = -1L;\n    /**\n     * Returns the time in milliseconds that has to be elapsed since the last\n     * up-to-date check before another check is performed. Implementors may \n     * return {@link #CACHE_ETERNALLY} to indicate that the content should be \n     * cached eternally.\n     */\n    public long getTimeToLive();"}
{"magic_number_smell": "\t\t\tif (file != null) {\n\t\t\t\treturn file.lastModified();\n\t\t\t}\n\t\t\treturn System.currentTimeMillis();\n\t\t}\n\t\t\n\t\tpublic ModelAndView handleRequest(HttpServletRequest request,", "refactored_code": "\t\tprivate static final long STARTUP_TIME = System.currentTimeMillis();\n\t\t\tif (file != null) {\n\t\t\t\treturn file.lastModified();\n\t\t\t}\n\t\t\treturn STARTUP_TIME;\n\t\t}\n\t\t\n\t\tpublic ModelAndView handleRequest(HttpServletRequest request,"}
{"magic_number_smell": "\t */\n\tpublic static void setFarFutureExpiresHeader(HttpServletResponse response) {\n\t\tresponse.setDateHeader(EXPIRES_HEADER, System.currentTimeMillis() + \n\t\t\t\t307584000000L);\n\t}\n\n\t/**", "refactored_code": "\tprivate static final long FAR_FUTURE = 307584000000L;\n\t */\n\tpublic static void setFarFutureExpiresHeader(HttpServletResponse response) {\n\t\tresponse.setDateHeader(EXPIRES_HEADER, System.currentTimeMillis() + \n\t\t\t\tFAR_FUTURE);\n\t}\n\n\t/**"}
{"magic_number_smell": "\t}\n\t\n\tprotected int getValidationMode() {\n\t\treturn 0;\n\t}\n\t\n\tprotected EntityResolver getEntityResolver() {", "refactored_code": "\tprotected static final int VALIDATION_MODE_NONE = 0;\n\t}\n\t\n\tprotected int getValidationMode() {\n\t\treturn VALIDATION_MODE_NONE;\n\t}\n\t\n\tprotected EntityResolver getEntityResolver() {"}
{"magic_number_smell": "        final String selector = args.length == 2 ? args[1] : null;\n\n        // fetch the specified URL and parse to a HTML DOM\n        Document doc = Jsoup.connect(url).userAgent(userAgent).5 * 1000(5 * 1000).get();\n\n        HtmlToPlainText formatter = new HtmlToPlainText();\n", "refactored_code": "    private static final int timeout = 5 * 1000;\n        final String selector = args.length == 2 ? args[1] : null;\n\n        // fetch the specified URL and parse to a HTML DOM\n        Document doc = Jsoup.connect(url).userAgent(userAgent).timeout(timeout).get();\n\n        HtmlToPlainText formatter = new HtmlToPlainText();\n"}
{"magic_number_smell": "        // read the start of the stream and look for a BOM or meta charset\n        InputStream wrappedInputStream = ControllableInputStream.wrap(input, DefaultBufferSize, 0);\n        wrappedInputStream.mark(DefaultBufferSize);\n        ByteBuffer firstBytes = readToByteBuffer(wrappedInputStream, 1024 * 5 - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n        boolean fullyRead = (wrappedInputStream.read() == -1);\n        wrappedInputStream.reset();\n", "refactored_code": "    private static final int firstReadBufferSize = 1024 * 5;\n        // read the start of the stream and look for a BOM or meta charset\n        InputStream wrappedInputStream = ControllableInputStream.wrap(input, DefaultBufferSize, 0);\n        wrappedInputStream.mark(DefaultBufferSize);\n        ByteBuffer firstBytes = readToByteBuffer(wrappedInputStream, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n        boolean fullyRead = (wrappedInputStream.read() == -1);\n        wrappedInputStream.reset();\n"}
{"magic_number_smell": "\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != 307) {\n                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                        req.data().clear();\n                        req.requestBody(null);", "refactored_code": "    private static final int HTTP_TEMP_REDIR = 307; // http/1.1 temporary redirect, not in Java's set.\n\n                // redirect if there's a location header (from 3xx, or 201 etc)\n                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                    if (status != HTTP_TEMP_REDIR) {\n                        req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                        req.data().clear();\n                        req.requestBody(null);"}
{"magic_number_smell": "\n    // the number of instance fields is kept as low as possible giving an object size of 24 bytes\n    private int size = 0; // number of slots used (not total capacity, which is keys.length)\n    String[] keys = new String[3];\n    Object[] vals = new Object[3]; // Genericish: all non-internal attribute values must be Strings and are cast on access.\n    // todo - make keys iterable without creating Attribute objects\n", "refactored_code": "    private static final int InitialCapacity = 3; // sampling found mean count when attrs present = 1.49; 1.08 overall. 2.6:1 don't have any attrs.\n\n    // the number of instance fields is kept as low as possible giving an object size of 24 bytes\n    private int size = 0; // number of slots used (not total capacity, which is keys.length)\n    String[] keys = new String[InitialCapacity];\n    Object[] vals = new Object[InitialCapacity]; // Genericish: all non-internal attribute values must be Strings and are cast on access.\n    // todo - make keys iterable without creating Attribute objects\n"}
{"magic_number_smell": "\n        int codepointForName(final String name) {\n            int index = Arrays.binarySearch(nameKeys, name);\n            return index >= 0 ? codeVals[index] : -1;\n        }\n\n        String nameForCodepoint(final int codepoint) {", "refactored_code": "    private static final int empty = -1;\n\n        int codepointForName(final String name) {\n            int index = Arrays.binarySearch(nameKeys, name);\n            return index >= 0 ? codeVals[index] : empty;\n        }\n\n        String nameForCodepoint(final int codepoint) {"}
{"magic_number_smell": "     */\n    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        // limit (no cache):\n        if (count > 12)\n            return new String(charBuf, start, count);\n        if (count < 1)\n            return \"\";", "refactored_code": "    private static final int maxStringCacheLen = 12;\n     */\n    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n        // limit (no cache):\n        if (count > maxStringCacheLen)\n            return new String(charBuf, start, count);\n        if (count < 1)\n            return \"\";"}
{"magic_number_smell": "    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, @Nullable String[] extraTypes) {\n        // https://html.spec.whatwg.org/multipage/parsing.html#has-an-element-in-the-specific-scope\n        final int bottom = stack.size() -1;\n        final int top = bottom > 100 ? bottom - 100 : 0;\n        // don't walk too far up the tree\n\n        for (int pos = bottom; pos >= top; pos--) {", "refactored_code": "    public static final int MaxScopeSearchDepth = 100; // prevents the parser bogging down in exceptionally broken pages\n    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, @Nullable String[] extraTypes) {\n        // https://html.spec.whatwg.org/multipage/parsing.html#has-an-element-in-the-specific-scope\n        final int bottom = stack.size() -1;\n        final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;\n        // don't walk too far up the tree\n\n        for (int pos = bottom; pos >= top; pos--) {"}
{"magic_number_smell": "    }\n    \n    public static ParseErrorList tracking(int maxSize) {\n        return new ParseErrorList(16, maxSize);\n    }\n\n    @Override", "refactored_code": "    private static final int INITIAL_CAPACITY = 16;\n    }\n    \n    public static ParseErrorList tracking(int maxSize) {\n        return new ParseErrorList(INITIAL_CAPACITY, maxSize);\n    }\n\n    @Override"}
{"magic_number_smell": "            if (attributes == null)\n                attributes = new Attributes();\n\n            if (hasAttrName && attributes.size() < 512) {\n                // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here\n                String name = attrNameSb.length() > 0 ? attrNameSb.toString() : attrName;\n                name = name.trim();", "refactored_code": "        private static final int MaxAttributes = 512;\n            if (attributes == null)\n                attributes = new Attributes();\n\n            if (hasAttrName && attributes.size() < MaxAttributes) {\n                // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here\n                String name = attrNameSb.length() > 0 ? attrNameSb.toString() : attrName;\n                name = name.trim();"}
{"magic_number_smell": "    @Nullable private String lastStartCloseSeq; // \"</\" + lastStartTag, so we can quickly check for that in RCData\n\n    private static final int -1 = -1;\n    private int markupStartPos, charStartPos = -1; // reader pos at the start of markup / characters. updated on state transition\n\n    Tokeniser(TreeBuilder treeBuilder) {\n        tagPending = startPending  = new Token.StartTag(treeBuilder);", "refactored_code": "    private static final int Unset = -1;\n    @Nullable private String lastStartCloseSeq; // \"</\" + lastStartTag, so we can quickly check for that in RCData\n\n    private static final int Unset = -1;\n    private int markupStartPos, charStartPos = Unset; // reader pos at the start of markup / characters. updated on state transition\n\n    Tokeniser(TreeBuilder treeBuilder) {\n        tagPending = startPending  = new Token.StartTag(treeBuilder);"}
{"magic_number_smell": "public class AuthenticationHandlerTest {\n    public static final int AuthenticationHandler.MaxAttempts = AuthenticationHandler.AuthenticationHandler.MaxAttempts;\n\n    // tests are in ConnectionTest, ProxyTest. This class just makes the AuthenticationHandler.MaxAttempts visible for test.\n}\n", "refactored_code": "    public static final int MaxAttempts = AuthenticationHandler.MaxAttempts;\npublic class AuthenticationHandlerTest {\n    public static final int MaxAttempts = AuthenticationHandler.MaxAttempts;\n\n    // tests are in ConnectionTest, ProxyTest. This class just makes the MaxAttempts visible for test.\n}\n"}
{"magic_number_smell": "\n    @Override\n    protected void doIt(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {\n        int intCode = HttpServletResponse.SC_OK;\n        String code = req.getHeader(CodeParam);\n        if (code != null)\n            intCode = Integer.parseInt(code);", "refactored_code": "    private static final int DefaultCode = HttpServletResponse.SC_OK;\n\n    @Override\n    protected void doIt(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {\n        int intCode = DefaultCode;\n        String code = req.getHeader(CodeParam);\n        if (code != null)\n            intCode = Integer.parseInt(code);"}
{"magic_number_smell": "        if (location == null)\n            location = \"\";\n\n        int intCode = HttpServletResponse.SC_MOVED_TEMPORARILY;\n        String code = req.getParameter(CodeParam);\n        if (code != null)\n            intCode = Integer.parseInt(code);", "refactored_code": "    private static final int DefaultCode = HttpServletResponse.SC_MOVED_TEMPORARILY;\n        if (location == null)\n            location = \"\";\n\n        int intCode = DefaultCode;\n        String code = req.getParameter(CodeParam);\n        if (code != null)\n            intCode = Integer.parseInt(code);"}
{"magic_number_smell": "                log(\"Remote connection lost\");\n                break;\n            }\n            if (pause(2000)) break;\n\n            if (maxTime > 0 && System.currentTimeMillis() > startTime + maxTime) {\n                w.println(\"<h1>outatime</h1>\");", "refactored_code": "    private static final int SleepTime = 2000;\n                log(\"Remote connection lost\");\n                break;\n            }\n            if (pause(SleepTime)) break;\n\n            if (maxTime > 0 && System.currentTimeMillis() > startTime + maxTime) {\n                w.println(\"<h1>outatime</h1>\");"}
{"magic_number_smell": "\t\tArrayList<Activity> activitiesOpened = getAllOpenedActivities();\n\t\t// Finish all opened activities\n\t\tfor (int i = activitiesOpened.size()-1; i >= 0; i--) {\n\t\t\tsleeper.sleep(100);\n\t\t\tfinishActivity(activitiesOpened.get(i));\n\t\t}\n\t\tactivitiesOpened = null;", "refactored_code": "\tprivate final int MINISLEEP = 100;\n\t\tArrayList<Activity> activitiesOpened = getAllOpenedActivities();\n\t\t// Finish all opened activities\n\t\tfor (int i = activitiesOpened.size()-1; i >= 0; i--) {\n\t\t\tsleeper.sleep(MINISLEEP);\n\t\t\tfinishActivity(activitiesOpened.get(i));\n\t\t}\n\t\tactivitiesOpened = null;"}
{"magic_number_smell": "\t\t\t}catch(SecurityException e){\n\t\t\t\tex = e;\n\t\t\t\tdialogUtils.hideSoftKeyboard(null, false, true);\n\t\t\t\tsleeper.sleep(300);\n\t\t\t\tretry++;\n\t\t\t\tView identicalView = viewFetcher.getIdenticalView(view);\n\t\t\t\tif(identicalView != null){", "refactored_code": "\tprivate final int MINI_WAIT = 300;\n\t\t\t}catch(SecurityException e){\n\t\t\t\tex = e;\n\t\t\t\tdialogUtils.hideSoftKeyboard(null, false, true);\n\t\t\t\tsleeper.sleep(MINI_WAIT);\n\t\t\t\tretry++;\n\t\t\t\tView identicalView = viewFetcher.getIdenticalView(view);\n\t\t\t\tif(identicalView != null){"}
{"magic_number_smell": "\t\t\tif(!isDialogOpen()){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tsleeper.sleep(200);\n\t\t}\n\t\treturn false;\n\t}", "refactored_code": "\tprivate final int MINISLEEP = 200;\n\t\t\tif(!isDialogOpen()){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tsleeper.sleep(MINISLEEP);\n\t\t}\n\t\treturn false;\n\t}"}
{"magic_number_smell": "\t\tint viewId = targetContext.getResources().getIdentifier(id, \"id\", packageName);\n\n\t\tif(viewId != 0){\n\t\t\tviewToReturn = getView(viewId, index, 1000); \n\t\t}\n\t\t\n\t\tif(viewToReturn == null){", "refactored_code": "\tprivate final int TIMEOUT = 1000;\n\t\tint viewId = targetContext.getResources().getIdentifier(id, \"id\", packageName);\n\n\t\tif(viewId != 0){\n\t\t\tviewToReturn = getView(viewId, index, TIMEOUT); \n\t\t}\n\t\t\n\t\tif(viewToReturn == null){"}
{"magic_number_smell": "\t\t}\n\t\tfor (double i = 0; i < Math.PI; i += incrementFactor)\n\t\t{\n\t\t\teventTime += 10;\n\t\t\tpointerCoords[0].x += Math.cos(i);\n\t\t\tpointerCoords[0].y += Math.sin(i);\n\t\t\tpointerCoords[1].x += Math.cos(i + Math.PI);", "refactored_code": "\tprivate static final int EVENT_TIME_INTERVAL_MS = 10;\n\t\t}\n\t\tfor (double i = 0; i < Math.PI; i += incrementFactor)\n\t\t{\n\t\t\teventTime += EVENT_TIME_INTERVAL_MS;\n\t\t\tpointerCoords[0].x += Math.cos(i);\n\t\t\tpointerCoords[0].y += Math.sin(i);\n\t\t\tpointerCoords[1].x += Math.cos(i + Math.PI);"}
{"magic_number_smell": "\t\t\t\tinstrumentation.runOnMainSync(runnable);\n\n\t\t\ttry {\n\t\t\t\tscreenshotMutex.wait(TimeUnit.SECONDS.toMillis(2));\n\t\t\t} catch (InterruptedException ignored) {\n\t\t\t}\n\t\t}", "refactored_code": "\tprivate static final long TIMEOUT_SCREENSHOT_MUTEX = TimeUnit.SECONDS.toMillis(2);\n\t\t\t\tinstrumentation.runOnMainSync(runnable);\n\n\t\t\ttry {\n\t\t\t\tscreenshotMutex.wait(TIMEOUT_SCREENSHOT_MUTEX);\n\t\t\t} catch (InterruptedException ignored) {\n\t\t\t}\n\t\t}"}
{"magic_number_smell": "\t\theight--;\n\t\tint scrollTo = -1;\n\n\t\tif (direction == 0) {\n\t\t\tscrollTo = height;\n\t\t}\n", "refactored_code": "\tpublic static final int DOWN = 0;\n\t\theight--;\n\t\tint scrollTo = -1;\n\n\t\tif (direction == DOWN) {\n\t\t\tscrollTo = height;\n\t\t}\n"}
{"magic_number_smell": "\t */\n\n\tpublic boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int expectedMinimumNumberOfMatches, boolean scroll, boolean onlyVisible) {\n\t\tfinal long endTime = SystemClock.uptimeMillis() + 5000;\n\n\t\tTextView foundAnyMatchingView = null;\n", "refactored_code": "\tprivate final int TIMEOUT = 5000;\n\t */\n\n\tpublic boolean searchWithTimeoutFor(Class<? extends TextView> viewClass, String regex, int expectedMinimumNumberOfMatches, boolean scroll, boolean onlyVisible) {\n\t\tfinal long endTime = SystemClock.uptimeMillis() + TIMEOUT;\n\n\t\tTextView foundAnyMatchingView = null;\n"}
{"magic_number_smell": "\n\n\t/**\n\t * Sets the status of a given SlidingDrawer. Examples are Solo.0 and Solo.OPENED.\n\t *\n\t * @param slidingDrawer the {@link SlidingDrawer}\n\t * @param status the status that the {@link SlidingDrawer} should be set to", "refactored_code": "\tprivate final int CLOSED = 0;\n\n\n\t/**\n\t * Sets the status of a given SlidingDrawer. Examples are Solo.CLOSED and Solo.OPENED.\n\t *\n\t * @param slidingDrawer the {@link SlidingDrawer}\n\t * @param status the status that the {@link SlidingDrawer} should be set to"}
{"magic_number_smell": "                2, pointerProperties, pointerCoords, 0, 0, 1, 1, 0, 0, 0, 0);\n        _instrument.sendPointerSync(event);\n\n        int numMoves = 1000 / EVENT_TIME_INTERVAL_MS;\n\n        float stepX1 = (endX1 - startX1) / numMoves;\n        float stepY1 = (endY1 - startY1) / numMoves;", "refactored_code": "    public static final int GESTURE_DURATION_MS = 1000;\n                2, pointerProperties, pointerCoords, 0, 0, 1, 1, 0, 0, 0, 0);\n        _instrument.sendPointerSync(event);\n\n        int numMoves = GESTURE_DURATION_MS / EVENT_TIME_INTERVAL_MS;\n\n        float stepX1 = (endX1 - startX1) / numMoves;\n        float stepY1 = (endY1 - startY1) / numMoves;"}
{"magic_number_smell": "                                     0, 0, 0, 0 );\n         _instrument.sendPointerSync(event);\n\n         int numMoves = 1000 / EVENT_TIME_INTERVAL_MS;\n\n         float stepX1 = (endX1 - startX1) / numMoves;\n         float stepY1 = (endY1 - startY1) / numMoves;", "refactored_code": "\tpublic static final int GESTURE_DURATION_MS = 1000;\n                                     0, 0, 0, 0 );\n         _instrument.sendPointerSync(event);\n\n         int numMoves = GESTURE_DURATION_MS / EVENT_TIME_INTERVAL_MS;\n\n         float stepX1 = (endX1 - startX1) / numMoves;\n         float stepY1 = (endY1 - startY1) / numMoves;"}
{"magic_number_smell": "                }\n                break;\n            }\n            case 2: {\n                if (resultCode == RESULT_OK && data != null) {\n                    if (ACTION_ADD_ACCOUNT.equals(data.getAction())) {\n                        handleAccountManagerAuth(data);", "refactored_code": "    private static final int REQUEST_PICK_ACCOUNT = 2;\n                }\n                break;\n            }\n            case REQUEST_PICK_ACCOUNT: {\n                if (resultCode == RESULT_OK && data != null) {\n                    if (ACTION_ADD_ACCOUNT.equals(data.getAction())) {\n                        handleAccountManagerAuth(data);"}
{"magic_number_smell": "    private final Drawable idle, done, error, syncing;\n\n    private static final int R.drawable.ic_done = R.drawable.ic_done;\n    private static final int idleDrawable = R.drawable.ic_done;\n    private static final int errorDrawable = R.drawable.ic_syncing_problem;\n    private static final int syncingDrawable = R.drawable.ic_syncing;\n", "refactored_code": "    private static final int doneDrawable = R.drawable.ic_done;\n    private final Drawable idle, done, error, syncing;\n\n    private static final int doneDrawable = R.drawable.ic_done;\n    private static final int idleDrawable = doneDrawable;\n    private static final int errorDrawable = R.drawable.ic_syncing_problem;\n    private static final int syncingDrawable = R.drawable.ic_syncing;\n"}
{"magic_number_smell": "\n        int visibility = getWindow().getDecorView().getSystemUiVisibility();\n        if (themeId == R.style.SMSBackupPlusTheme_Light) {\n            visibility |= 16;\n        } else {\n            visibility &= ~(16);\n        }", "refactored_code": "    private static final int SYSTEM_UI_FLAG_LIGHT_NAVIGATION_BAR = 16;\n\n        int visibility = getWindow().getDecorView().getSystemUiVisibility();\n        if (themeId == R.style.SMSBackupPlusTheme_Light) {\n            visibility |= SYSTEM_UI_FLAG_LIGHT_NAVIGATION_BAR;\n        } else {\n            visibility &= ~(SYSTEM_UI_FLAG_LIGHT_NAVIGATION_BAR);\n        }"}
{"magic_number_smell": "\n        if (isFinishing()) return;\n\n        if (requestCode == 0) {\n            if (allGranted(grantResults)) {\n                checkAccounts();\n            } else {", "refactored_code": "    private static final int REQUEST_GET_ACCOUNTS = 0;\n\n        if (isFinishing()) return;\n\n        if (requestCode == REQUEST_GET_ACCOUNTS) {\n            if (allGranted(grantResults)) {\n                checkAccounts();\n            } else {"}
{"magic_number_smell": "        @Override\n        public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\n            super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n            if (requestCode == 0 && allGranted(grantResults)) {\n                callLogPreference.setChecked(true);\n                App.post(new AutoBackupSettingsChangedEvent());\n            }", "refactored_code": "        private static final int REQUEST_CALL_LOG_PERMISSIONS = 0;\n        @Override\n        public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\n            super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n            if (requestCode == REQUEST_CALL_LOG_PERMISSIONS && allGranted(grantResults)) {\n                callLogPreference.setChecked(true);\n                App.post(new AutoBackupSettingsChangedEvent());\n            }"}
{"magic_number_smell": "            final PackageInfo info = packageManager.getPackageInfo(COM_GOOGLE_ANDROID_GMS, GET_SIGNATURES);\n            // TODO: check signatures\n\n            if (info.versionCode < 9256030) {\n                Log.w(TAG, \"Google Play Services out of date: \"+ info.versionCode);\n                return false;\n            } else {", "refactored_code": "    private static final int MIN_GMS_VERSION = 9256030; // 9256030  9.2.56 (030-124593566)\n            final PackageInfo info = packageManager.getPackageInfo(COM_GOOGLE_ANDROID_GMS, GET_SIGNATURES);\n            // TODO: check signatures\n\n            if (info.versionCode < MIN_GMS_VERSION) {\n                Log.w(TAG, \"Google Play Services out of date: \"+ info.versionCode);\n                return false;\n            } else {"}
{"magic_number_smell": "\n    // simple LRU cache\n    private final Map<String, PersonRecord> personCache =\n            new LinkedHashMap<String, PersonRecord>(500 + 1, .75F, true) {\n                @Override\n                public boolean removeEldestEntry(Map.Entry<String, PersonRecord> eldest) {\n                    return size() > 500;", "refactored_code": "    private static final int MAX_PEOPLE_CACHE_SIZE = 500;\n\n    // simple LRU cache\n    private final Map<String, PersonRecord> personCache =\n            new LinkedHashMap<String, PersonRecord>(MAX_PEOPLE_CACHE_SIZE + 1, .75F, true) {\n                @Override\n                public boolean removeEldestEntry(Map.Entry<String, PersonRecord> eldest) {\n                    return size() > MAX_PEOPLE_CACHE_SIZE;"}
{"magic_number_smell": "            cancelAll();\n            return null;\n        } else if (preferences.isUseOldScheduler()) {\n            return schedule(60, REGULAR, false);\n        } else {\n            // everything else should be persistent by GCM\n            return null;", "refactored_code": "    private static final int BOOT_BACKUP_DELAY = 60;\n            cancelAll();\n            return null;\n        } else if (preferences.isUseOldScheduler()) {\n            return schedule(BOOT_BACKUP_DELAY, REGULAR, false);\n        } else {\n            // everything else should be persistent by GCM\n            return null;"}
{"magic_number_smell": "                .setContentText(state.getNotificationLabel(getResources()))\n                .setContentIntent(getPendingIntent(null))\n                .build();\n        startForeground(1, notification);\n    }\n\n    private void scheduleNextBackup(BackupState state) {", "refactored_code": "    private static final int BACKUP_ID = 1;\n                .setContentText(state.getNotificationLabel(getResources()))\n                .setContentIntent(getPendingIntent(null))\n                .build();\n        startForeground(BACKUP_ID, notification);\n    }\n\n    private void scheduleNextBackup(BackupState state) {"}
{"magic_number_smell": "                    .setContentIntent(getPendingIntent(null))\n                    .build();\n\n            startForeground(2, notification);\n        } else {\n            Log.d(TAG, \"stopping service, state\"+ this.state);\n            stopForeground(true);", "refactored_code": "    private static final int RESTORE_ID = 2;\n                    .setContentIntent(getPendingIntent(null))\n                    .build();\n\n            startForeground(RESTORE_ID, notification);\n        } else {\n            Log.d(TAG, \"stopping service, state\"+ this.state);\n            stopForeground(true);"}
{"magic_number_smell": "    }\n\n    private void rotate(final File logFile) {\n        if (logFile.length() < 32 * 1024) return;\n        if (LOCAL_LOGV) Log.v(TAG, \"rotating logfile \" + logFile);\n\n        try {", "refactored_code": "    private static final int MAX_SIZE = 32 * 1024;\n    }\n\n    private void rotate(final File logFile) {\n        if (logFile.length() < MAX_SIZE) return;\n        if (LOCAL_LOGV) Log.v(TAG, \"rotating logfile \" + logFile);\n\n        try {"}
{"magic_number_smell": "\n    @SuppressWarnings(\"serial\")\n    private Map<String, Long> threadIdCache =\n            new LinkedHashMap<String, Long>(500 + 1, .75F, true) {\n                @Override\n                public boolean removeEldestEntry(Map.Entry<String, Long> eldest) {\n                    return size() > 500;", "refactored_code": "    private static final int MAX_THREAD_CACHE_SIZE = 500;\n\n    @SuppressWarnings(\"serial\")\n    private Map<String, Long> threadIdCache =\n            new LinkedHashMap<String, Long>(MAX_THREAD_CACHE_SIZE + 1, .75F, true) {\n                @Override\n                public boolean removeEldestEntry(Map.Entry<String, Long> eldest) {\n                    return size() > MAX_THREAD_CACHE_SIZE;"}
{"magic_number_smell": "  public static void copy(InputStream in, OutputStream out)\n    throws IOException\n  {\n    byte[] buffer = new byte[1024 * 4];\n    int n = 0;\n    while (-1 != (n = in.read(buffer))) {\n      out.write(buffer, 0, n);", "refactored_code": "  private static final int DEFAULT_BUFFER_SIZE = 1024 * 4;\n  public static void copy(InputStream in, OutputStream out)\n    throws IOException\n  {\n    byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];\n    int n = 0;\n    while (-1 != (n = in.read(buffer))) {\n      out.write(buffer, 0, n);"}
{"magic_number_smell": "    }\n    menu = menu.replaceAll(\"\\n\", StringUtils.EMPTY);\n    menu = menu.replaceAll(\"<.*?>\", StringUtils.EMPTY);\n    return StringUtils.abbreviate(menu, 74);\n  }\n\n  /**", "refactored_code": "  private static final int MAX_SHORT_DESCRIPTION_LENGTH = 74;\n    }\n    menu = menu.replaceAll(\"\\n\", StringUtils.EMPTY);\n    menu = menu.replaceAll(\"<.*?>\", StringUtils.EMPTY);\n    return StringUtils.abbreviate(menu, MAX_SHORT_DESCRIPTION_LENGTH);\n  }\n\n  /**"}
{"magic_number_smell": "    }\n\n    for (MethodWrapper root : roots) {\n      if (root.getLevel() > 3 || root.isRecursive()) {\n        continue;\n      }\n      results.add(formatRoot(root, comparator, callees));", "refactored_code": "  private static final int MAX_CALL_DEPTH = 3;\n    }\n\n    for (MethodWrapper root : roots) {\n      if (root.getLevel() > MAX_CALL_DEPTH || root.isRecursive()) {\n        continue;\n      }\n      results.add(formatRoot(root, comparator, callees));"}
{"magic_number_smell": "\n        IField getter = methods.indexOf(GETTER) != -1 ? field : null;\n        IField setter = methods.indexOf(SETTER) != -1 ? field : null;\n        int methodType = getter != null ? 0 : TYPE_SET;\n        // edge case to prevent insert setter before getter if getter already\n        // exists.\n        if (getter != null && setter != null &&", "refactored_code": "  private static final int TYPE_GET = 0;\n\n        IField getter = methods.indexOf(GETTER) != -1 ? field : null;\n        IField setter = methods.indexOf(SETTER) != -1 ? field : null;\n        int methodType = getter != null ? TYPE_GET : TYPE_SET;\n        // edge case to prevent insert setter before getter if getter already\n        // exists.\n        if (getter != null && setter != null &&"}
{"magic_number_smell": "  public static CompilationUnit getCompilationUnit(\n      ICompilationUnit src, boolean recordModifications)\n  {\n    ASTParser parser = ASTParser.newParser(AST.JLS16);\n    parser.setSource(src);\n    CompilationUnit cu = (CompilationUnit)parser.createAST(null);\n    if(recordModifications){", "refactored_code": "  private static final int JLS_LATEST = AST.JLS16;\n  public static CompilationUnit getCompilationUnit(\n      ICompilationUnit src, boolean recordModifications)\n  {\n    ASTParser parser = ASTParser.newParser(JLS_LATEST);\n    parser.setSource(src);\n    CompilationUnit cu = (CompilationUnit)parser.createAST(null);\n    if(recordModifications){"}
{"magic_number_smell": "\t\ttry {\n\t\t\tPackageInfo pi = getPackageManager().getPackageInfo(\n\t\t\t\t\tmApgPackageName, 0);\n\t\t\tif (pi.versionCode >= 16) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tToast.makeText(this, R.string.error_apg_version_not_supported,", "refactored_code": "    private static final int mMinRequiredVersion = 16;\n\t\ttry {\n\t\t\tPackageInfo pi = getPackageManager().getPackageInfo(\n\t\t\t\t\tmApgPackageName, 0);\n\t\t\tif (pi.versionCode >= mMinRequiredVersion) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tToast.makeText(this, R.string.error_apg_version_not_supported,"}
{"magic_number_smell": "\tprivate SQLiteStatement addTimestampsStatement;\n\n\tprivate OrgDatabase(Context context) {\n\t\tsuper(context, DATABASE_NAME, null, 5);\n\n\t\torgdataInsertStatement = getWritableDatabase()\n\t\t\t\t.compileStatement(\"INSERT INTO \" + Tables.ORGDATA+ \" (\"", "refactored_code": "\tprivate static final int DATABASE_VERSION = 5;\n\tprivate SQLiteStatement addTimestampsStatement;\n\n\tprivate OrgDatabase(Context context) {\n\t\tsuper(context, DATABASE_NAME, null, DATABASE_VERSION);\n\n\t\torgdataInsertStatement = getWritableDatabase()\n\t\t\t\t.compileStatement(\"INSERT INTO \" + Tables.ORGDATA+ \" (\""}
{"magic_number_smell": "\t\tif (schedule.find()) {\n\t\t\ttry {\n\t\t\t\tif (schedule.group(BEGIN_TIME) == null) { // event is an entire day event\n\t\t\t\t\tthis.beginTime = dateformatter.parse(schedule.group(1)).getTime();\n\n\t\t\t\t\tthis.endTime = this.beginTime + DateUtils.DAY_IN_MILLIS;\n\t\t\t\t\tthis.allDay = 1;", "refactored_code": "\tprivate static final int DATE = 1;\n\t\tif (schedule.find()) {\n\t\t\ttry {\n\t\t\t\tif (schedule.group(BEGIN_TIME) == null) { // event is an entire day event\n\t\t\t\t\tthis.beginTime = dateformatter.parse(schedule.group(DATE)).getTime();\n\n\t\t\t\t\tthis.endTime = this.beginTime + DateUtils.DAY_IN_MILLIS;\n\t\t\t\t\tthis.allDay = 1;"}
{"magic_number_smell": "\t\tMatcher matcher = pattern.matcher(line);\n\t\tmatcher.region(numberOfStars + 1, line.length());\n\t\tif (matcher.find()) {\n\t\t\tif (matcher.group(1) != null)\n\t\t\t\tnode.todo = matcher.group(1);\n\n\t\t\tnode.name = matcher.group(NAME_GROUP);", "refactored_code": "\tprivate static final int TODO_GROUP = 1;\n\t\tMatcher matcher = pattern.matcher(line);\n\t\tmatcher.region(numberOfStars + 1, line.length());\n\t\tif (matcher.find()) {\n\t\t\tif (matcher.group(TODO_GROUP) != null)\n\t\t\t\tnode.todo = matcher.group(TODO_GROUP);\n\n\t\t\tnode.name = matcher.group(NAME_GROUP);"}
{"magic_number_smell": "\n    private static UriMatcher buildUriMatcher() {\n        final UriMatcher uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n        uriMatcher.addURI(AUTHORITY, Tables.100, 100);\n        uriMatcher.addURI(AUTHORITY, Tables.100 + \"/*\", ORGDATA_ID);\n        uriMatcher.addURI(AUTHORITY, Tables.100 + \"/*/parent\", ORGDATA_PARENT);\n        uriMatcher.addURI(AUTHORITY, Tables.100 + \"/*/children\", ORGDATA_CHILDREN);", "refactored_code": "    private static final int ORGDATA = 100;\n\n    private static UriMatcher buildUriMatcher() {\n        final UriMatcher uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n        uriMatcher.addURI(AUTHORITY, Tables.ORGDATA, ORGDATA);\n        uriMatcher.addURI(AUTHORITY, Tables.ORGDATA + \"/*\", ORGDATA_ID);\n        uriMatcher.addURI(AUTHORITY, Tables.ORGDATA + \"/*/parent\", ORGDATA_PARENT);\n        uriMatcher.addURI(AUTHORITY, Tables.ORGDATA + \"/*/children\", ORGDATA_CHILDREN);"}
{"magic_number_smell": "\tprivate static final String LOGIN_HOST = \"login.ubuntu.com\";\n\tprivate static final int 443 = 443;\n\tprivate static final String LOGIN_URL = \"https://\" + LOGIN_HOST + \":\"\n\t\t\t+ 443 + \"/api/1.0/authentications\"\n\t\t\t+ \"?ws.op=authenticate&token_name=\";\n    private static final String FILES_BASE = \"https://files.one.ubuntu.com\";\n    private static final String FILES_URL = \"https://one.ubuntu.com/api/file_storage/v1\";", "refactored_code": "\tprivate static final int LOGIN_PORT = 443;\n\tprivate static final String LOGIN_HOST = \"login.ubuntu.com\";\n\tprivate static final int LOGIN_PORT = 443;\n\tprivate static final String LOGIN_URL = \"https://\" + LOGIN_HOST + \":\"\n\t\t\t+ LOGIN_PORT + \"/api/1.0/authentications\"\n\t\t\t+ \"?ws.op=authenticate&token_name=\";\n    private static final String FILES_BASE = \"https://files.one.ubuntu.com\";\n    private static final String FILES_URL = \"https://one.ubuntu.com/api/file_storage/v1\";"}
{"magic_number_smell": "\t\t} catch (NumberFormatException e) {\n\t\t}\n\t\t\n\t\treturn 14;\n\t}\n\n\tpublic static int getLevelOfRecursion() {", "refactored_code": "\tprivate static final int DEFAULT_FONTSIZE = 14;\n\t\t} catch (NumberFormatException e) {\n\t\t}\n\t\t\n\t\treturn DEFAULT_FONTSIZE;\n\t}\n\n\tpublic static int getLevelOfRecursion() {"}
{"magic_number_smell": "\t    \t}\n\t    }\n\t    \n\t    return -1;\n\t}\n\t\n}", "refactored_code": "\tpublic static final int HASHES_EQUAL = -1;\n\t    \t}\n\t    }\n\t    \n\t    return HASHES_EQUAL;\n\t}\n\t\n}"}
{"magic_number_smell": "\t\t\t}\n\t\t\t\n\t\t\ttry {\n\t\t\t\tsleep(5000);\n\t\t\t}\n\t\t\tcatch (InterruptedException e) {\n\t\t\t\t", "refactored_code": "\tprivate static final long SCAN_DELAY = 5000;\n\t\t\t}\n\t\t\t\n\t\t\ttry {\n\t\t\t\tsleep(SCAN_DELAY);\n\t\t\t}\n\t\t\tcatch (InterruptedException e) {\n\t\t\t\t"}
{"magic_number_smell": "\t * @generated\n\t * @ordered\n\t */\n\tprotected int ringIn = 0;\n\n\t/**\n\t * This is true if the Ring In attribute has been set.", "refactored_code": "\tprotected static final int RING_IN_EDEFAULT = 0;\n\t * @generated\n\t * @ordered\n\t */\n\tprotected int ringIn = RING_IN_EDEFAULT;\n\n\t/**\n\t * This is true if the Ring In attribute has been set."}
{"magic_number_smell": "\t * @generated\n\t * @ordered\n\t */\n\tprotected int line = 0;\n\n\t/**\n\t * This is true if the Line attribute has been set.", "refactored_code": "\tprotected static final int LINE_EDEFAULT = 0;\n\t * @generated\n\t * @ordered\n\t */\n\tprotected int line = LINE_EDEFAULT;\n\n\t/**\n\t * This is true if the Line attribute has been set."}
{"magic_number_smell": "\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        menu.add(0, ActivityDiscovery.0, 0, R.string.scan_single_title).setIcon(\n                android.R.drawable.ic_menu_mylocation);\n        menu.add(0, ActivityDiscovery.MENU_EXPORT, 0, R.string.preferences_export).setIcon(\n                android.R.drawable.ic_menu_save);", "refactored_code": "    public static final int MENU_SCAN_SINGLE = 0;\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        menu.add(0, ActivityDiscovery.MENU_SCAN_SINGLE, 0, R.string.scan_single_title).setIcon(\n                android.R.drawable.ic_menu_mylocation);\n        menu.add(0, ActivityDiscovery.MENU_EXPORT, 0, R.string.preferences_export).setIcon(\n                android.R.drawable.ic_menu_save);"}
{"magic_number_smell": "                    }\n                }\n                progress_current++;\n                setProgress(progress_current * 10000 / nb_port);\n            }\n        }\n", "refactored_code": "    private static final int PROGRESS_MAX = 10000;\n                    }\n                }\n                progress_current++;\n                setProgress(progress_current * PROGRESS_MAX / nb_port);\n            }\n        }\n"}
{"magic_number_smell": "                connectSocket(ina, j);\n            }\n            while (select && selector.keys().size() > 0) {\n                if (selector.select(300) > 0) {\n                    synchronized (selector.selectedKeys()) {\n                        Iterator<SelectionKey> iterator = selector.selectedKeys().iterator();\n                        while (iterator.hasNext()) {", "refactored_code": "    private static final int TIMEOUT_SELECT = 300;\n                connectSocket(ina, j);\n            }\n            while (select && selector.keys().size() > 0) {\n                if (selector.select(TIMEOUT_SELECT) > 0) {\n                    synchronized (selector.selectedKeys()) {\n                        Iterator<SelectionKey> iterator = selector.selectedKeys().iterator();\n                        while (iterator.hasNext()) {"}
{"magic_number_smell": "            try {\n                InetAddress h = InetAddress.getByName(addr);\n                // Rate control check\n                if (doRateControl && mRateControl.indicator != null && hosts_done % 5 == 0) {\n                    mRateControl.adaptRate();\n                }\n                // Arp Check #1", "refactored_code": "    private final int mRateMult = 5; // Number of alive hosts between Rate\n            try {\n                InetAddress h = InetAddress.getByName(addr);\n                // Rate control check\n                if (doRateControl && mRateControl.indicator != null && hosts_done % mRateMult == 0) {\n                    mRateControl.adaptRate();\n                }\n                // Arp Check #1"}
{"magic_number_smell": "            Socket s = new Socket();\n            s.bind(null);\n            s.connect(new InetSocketAddress(host, port), timeout);\n            BufferedReader in = new BufferedReader(new InputStreamReader(s.getInputStream()), 8 * 1024);\n            while ((banner = in.readLine()) != null) {\n                break;\n            }", "refactored_code": "    private static final int BUF = 8 * 1024;\n            Socket s = new Socket();\n            s.bind(null);\n            s.connect(new InetSocketAddress(host, port), timeout);\n            BufferedReader in = new BufferedReader(new InputStreamReader(s.getInputStream()), BUF);\n            while ((banner = in.readLine()) != null) {\n                break;\n            }"}
{"magic_number_smell": "                Matcher matcher;\n                Pattern ptrn = Pattern.compile(ptn);\n                Process p = Runtime.getRuntime().exec(path + cmd);\n                BufferedReader r = new BufferedReader(new InputStreamReader(p.getInputStream()), 8 * 1024);\n                while ((line = r.readLine()) != null) {\n                    matcher = ptrn.matcher(line);\n                    if (matcher.matches()) {", "refactored_code": "    private static final int BUF = 8 * 1024;\n                Matcher matcher;\n                Pattern ptrn = Pattern.compile(ptn);\n                Process p = Runtime.getRuntime().exec(path + cmd);\n                BufferedReader r = new BufferedReader(new InputStreamReader(p.getInputStream()), BUF);\n                while ((line = r.readLine()) != null) {\n                    matcher = ptrn.matcher(line);\n                    if (matcher.matches()) {"}
{"magic_number_smell": "        } catch (Exception e) {\n            Log.e(TAG, \"Can't use native ping: \" + e.getMessage());\n            try {\n                if (InetAddress.getByName(host).isReachable(1000)) {\n                    Log.i(TAG, \"Using Java ICMP request instead ...\");\n                }\n            } catch (Exception e1) {", "refactored_code": "    private static final int TIMEOUT = 1000;\n        } catch (Exception e) {\n            Log.e(TAG, \"Can't use native ping: \" + e.getMessage());\n            try {\n                if (InetAddress.getByName(host).isReachable(TIMEOUT)) {\n                    Log.i(TAG, \"Using Java ICMP request instead ...\");\n                }\n            } catch (Exception e1) {"}
{"magic_number_smell": "        Matcher matcher;\n        try {\n            final Process proc = Runtime.getRuntime().exec(CMD + host);\n            reader = new BufferedReader(new InputStreamReader(proc.getInputStream()), 512);\n            while ((line = reader.readLine()) != null) {\n                matcher = mPattern.matcher(line);\n                if (matcher.matches()) {", "refactored_code": "    private static final int BUF = 512;\n        Matcher matcher;\n        try {\n            final Process proc = Runtime.getRuntime().exec(CMD + host);\n            reader = new BufferedReader(new InputStreamReader(proc.getInputStream()), BUF);\n            while ((line = reader.readLine()) != null) {\n                matcher = mPattern.matcher(line);\n                if (matcher.matches()) {"}
{"magic_number_smell": "        Socket s = new Socket();\n        try {\n            s.bind(null);\n            s.connect(new InetSocketAddress(host, PORT), 250);\n            OutputStream out = s.getOutputStream();\n            for (int b : buff) {\n                out.write(b);", "refactored_code": "    private final int TIMEOUT = 250;\n        Socket s = new Socket();\n        try {\n            s.bind(null);\n            s.connect(new InetSocketAddress(host, PORT), TIMEOUT);\n            OutputStream out = s.getOutputStream();\n            for (int b : buff) {\n                out.write(b);"}
{"magic_number_smell": "    public void setAccessible(AccessibleObject accessibleObject, boolean flag) {\n        boolean operationComplete = false;\n\n        if (UNSAFE_INSTANCE != null && UNSAFE_PUT_BOOLEAN_METHOD != null && determineAccessibleObjectOverrideFieldOffset() != -1) {\n            try {\n                UNSAFE_PUT_BOOLEAN_METHOD.invoke(UNSAFE_INSTANCE, accessibleObject, determineAccessibleObjectOverrideFieldOffset(), flag);\n                operationComplete = true;", "refactored_code": "    private static final long ACCESSIBLE_OBJECT_OVERRIDE_FIELD_OFFSET = determineAccessibleObjectOverrideFieldOffset();\n    public void setAccessible(AccessibleObject accessibleObject, boolean flag) {\n        boolean operationComplete = false;\n\n        if (UNSAFE_INSTANCE != null && UNSAFE_PUT_BOOLEAN_METHOD != null && ACCESSIBLE_OBJECT_OVERRIDE_FIELD_OFFSET != -1) {\n            try {\n                UNSAFE_PUT_BOOLEAN_METHOD.invoke(UNSAFE_INSTANCE, accessibleObject, ACCESSIBLE_OBJECT_OVERRIDE_FIELD_OFFSET, flag);\n                operationComplete = true;"}
{"magic_number_smell": "            private int index = 0;\n\n            public boolean hasMoreElements() {\n                return index < Array.getLength(target);\n            }\n\n            public Object nextElement() {", "refactored_code": "            private final int count = Array.getLength(target);\n            private int index = 0;\n\n            public boolean hasMoreElements() {\n                return index < count;\n            }\n\n            public Object nextElement() {"}
{"magic_number_smell": "    public static final int LAST = 2;\n    public static final int ALL = 3;\n\n    public static final DynamicSubscript first = new DynamicSubscript(0);\n    public static final DynamicSubscript mid = new DynamicSubscript(MID);\n    public static final DynamicSubscript last = new DynamicSubscript(LAST);\n    public static final DynamicSubscript all = new DynamicSubscript(ALL);", "refactored_code": "    public static final int FIRST = 0;\n    public static final int LAST = 2;\n    public static final int ALL = 3;\n\n    public static final DynamicSubscript first = new DynamicSubscript(FIRST);\n    public static final DynamicSubscript mid = new DynamicSubscript(MID);\n    public static final DynamicSubscript last = new DynamicSubscript(LAST);\n    public static final DynamicSubscript all = new DynamicSubscript(ALL);"}
{"magic_number_smell": "            public Object nextElement() {\n                if (next >= finish)\n                    throw new NoSuchElementException();\n                return OgnlOps.newInteger(OgnlOps.getNumericType(target), next++);\n            }\n        };\n    }", "refactored_code": "            private final int type = OgnlOps.getNumericType(target);\n            public Object nextElement() {\n                if (next >= finish)\n                    throw new NoSuchElementException();\n                return OgnlOps.newInteger(type, next++);\n            }\n        };\n    }"}
{"magic_number_smell": "        if ((pad = HEX_PADDING.get(l)) == null) {\n            StringBuilder pb = new StringBuilder();\n\n            for (int i = hex.length(); i < 8; i++) {\n                pb.append('0');\n            }\n            pad = new String(pb);", "refactored_code": "    private static final int HEX_LENGTH = 8;\n        if ((pad = HEX_PADDING.get(l)) == null) {\n            StringBuilder pb = new StringBuilder();\n\n            for (int i = hex.length(); i < HEX_LENGTH; i++) {\n                pb.append('0');\n            }\n            pad = new String(pb);"}
{"magic_number_smell": "\t\tPublic static methods\n\t  ===================================================================*/\n    public static int getStaticInt() {\n        return 23;\n    }\n\n    /*===================================================================", "refactored_code": "    public static final int STATIC_INT = 23;\n\t\tPublic static methods\n\t  ===================================================================*/\n    public static int getStaticInt() {\n        return STATIC_INT;\n    }\n\n    /*==================================================================="}
{"magic_number_smell": "\n\t@Override\n\tpublic void updateDrawState(TextPaint tp) {\n\t\ttp.setTextSize(tp.getTextSize() * 0.3f);\n\t}\n\n\t@Override", "refactored_code": "\tprivate static final float PROPORTION = 0.3f;\n\n\t@Override\n\tpublic void updateDrawState(TextPaint tp) {\n\t\ttp.setTextSize(tp.getTextSize() * PROPORTION);\n\t}\n\n\t@Override"}
{"magic_number_smell": "\n\tpublic QuoteSpan(int color, DisplayMetrics metrics) {\n\t\tthis.color = color;\n\t\tthis.width = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, 2f, metrics);\n\t\tthis.paddingLeft = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, PADDING_LEFT_SP, metrics);\n\t\tthis.paddingRight = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, PADDING_RIGHT_SP, metrics);\n\t}", "refactored_code": "\tprivate static final float WIDTH_SP = 2f;\n\n\tpublic QuoteSpan(int color, DisplayMetrics metrics) {\n\t\tthis.color = color;\n\t\tthis.width = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, WIDTH_SP, metrics);\n\t\tthis.paddingLeft = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, PADDING_LEFT_SP, metrics);\n\t\tthis.paddingRight = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, PADDING_RIGHT_SP, metrics);\n\t}"}
{"magic_number_smell": "\n\t\t\tbyte[] bytes = null;\n            try {\n                if ((flags & 1) != 0) {\n                    publishProgress(R.string.upload_compress);\n                    bytes = FileHelper.shrinkPicture(ctx, path, fileUploadSizeLimit);\n                }", "refactored_code": "    public static final int F_RESIZE = 1;\n\n\t\t\tbyte[] bytes = null;\n            try {\n                if ((flags & F_RESIZE) != 0) {\n                    publishProgress(R.string.upload_compress);\n                    bytes = FileHelper.shrinkPicture(ctx, path, fileUploadSizeLimit);\n                }"}
{"magic_number_smell": "\t\tswitch (menu_id) {\n\t\tcase R.id.roster_contextmenu_take_image: return REQUEST_CAMERA;\n\t\tcase R.id.roster_contextmenu_send_image: return REQUEST_IMAGE;\n\t\tcase R.id.roster_contextmenu_send_file: return 1;\n\t\tdefault: throw new IllegalStateException(\"Unknown menu ID!\");\n\t\t}\n\t}", "refactored_code": "\tprivate static final int REQUEST_FILE = 1;\n\t\tswitch (menu_id) {\n\t\tcase R.id.roster_contextmenu_take_image: return REQUEST_CAMERA;\n\t\tcase R.id.roster_contextmenu_send_image: return REQUEST_IMAGE;\n\t\tcase R.id.roster_contextmenu_send_file: return REQUEST_FILE;\n\t\tdefault: throw new IllegalStateException(\"Unknown menu ID!\");\n\t\t}\n\t}"}
{"magic_number_smell": "\tprivate static final int ARCHIVE = 3;\n\n\tstatic {\n\t\tURI_MATCHER.addURI(AUTHORITY, \"chats\", 1);\n\t\tURI_MATCHER.addURI(AUTHORITY, \"chats/#\", MESSAGE_ID);\n\t\tURI_MATCHER.addURI(AUTHORITY, \"archive\", ARCHIVE);\n\t}", "refactored_code": "\tprivate static final int MESSAGES = 1;\n\tprivate static final int ARCHIVE = 3;\n\n\tstatic {\n\t\tURI_MATCHER.addURI(AUTHORITY, \"chats\", MESSAGES);\n\t\tURI_MATCHER.addURI(AUTHORITY, \"chats/#\", MESSAGE_ID);\n\t\tURI_MATCHER.addURI(AUTHORITY, \"archive\", ARCHIVE);\n\t}"}
{"magic_number_smell": "\t\n\n\tstatic {\n\t\tURI_MATCHER.addURI(AUTHORITY, \"roster\", 1);\n\t\tURI_MATCHER.addURI(AUTHORITY, \"roster/#\", CONTACT_ID);\n\t\tURI_MATCHER.addURI(AUTHORITY, \"groups\", GROUPS);\n\t\tURI_MATCHER.addURI(AUTHORITY, \"groups/*\", GROUP_MEMBERS);", "refactored_code": "\tprivate static final int CONTACTS = 1;\n\t\n\n\tstatic {\n\t\tURI_MATCHER.addURI(AUTHORITY, \"roster\", CONTACTS);\n\t\tURI_MATCHER.addURI(AUTHORITY, \"roster/#\", CONTACT_ID);\n\t\tURI_MATCHER.addURI(AUTHORITY, \"groups\", GROUPS);\n\t\tURI_MATCHER.addURI(AUTHORITY, \"groups/*\", GROUP_MEMBERS);"}
{"magic_number_smell": "\t\treturn code;\n\t}\n\tpublic String createInvitationCode() {\n\t\treturn createInvitationCode(14*24*3600);\n\t}\n\t\n\tpublic void whitelistInvitationJID(String jid) {", "refactored_code": "\tprivate static final long DEFAULT_INVITATION_TIME = 14*24*3600; // two weeks in seconds\n\t\treturn code;\n\t}\n\tpublic String createInvitationCode() {\n\t\treturn createInvitationCode(DEFAULT_INVITATION_TIME);\n\t}\n\t\n\tpublic void whitelistInvitationJID(String jid) {"}
{"magic_number_smell": "\t\tXMPPConnection c = YaximApplication.getInstance().getSmackable().getConnection();\n\t\ttry {\n\t\t\tswitch (mode) {\n\t\t\t\tcase 0:\n\t\t\t\t\tloadBookmarksOrThrow(c);\n\t\t\t\t\tbreak;\n\t\t\t\tcase MODE_DOMAIN:", "refactored_code": "\tpublic static final int MODE_BOOKMARKS = 0;\n\t\tXMPPConnection c = YaximApplication.getInstance().getSmackable().getConnection();\n\t\ttry {\n\t\t\tswitch (mode) {\n\t\t\t\tcase MODE_BOOKMARKS:\n\t\t\t\t\tloadBookmarksOrThrow(c);\n\t\t\t\t\tbreak;\n\t\t\t\tcase MODE_DOMAIN:"}
{"magic_number_smell": "\t\t\tString messageSummary = msg_string;\n\t\t\tif (newline >= 0)\n\t\t\t\tlimit = newline;\n\t\t\tif (limit > 45 || nd.lastMessage.length() > 45)\n\t\t\t\tlimit = 45;\n\t\t\tif (limit > 0)\n\t\t\t\tmessageSummary = msg_string.substring(0, limit) + \"\u00e2\u20ac\u00a6\";", "refactored_code": "\tprivate static final int MAX_TICKER_MSG_LEN = 45;\n\t\t\tString messageSummary = msg_string;\n\t\t\tif (newline >= 0)\n\t\t\t\tlimit = newline;\n\t\t\tif (limit > MAX_TICKER_MSG_LEN || nd.lastMessage.length() > MAX_TICKER_MSG_LEN)\n\t\t\t\tlimit = MAX_TICKER_MSG_LEN;\n\t\t\tif (limit > 0)\n\t\t\t\tmessageSummary = msg_string.substring(0, limit) + \"\u00e2\u20ac\u00a6\";"}
{"magic_number_smell": "\n\n\tpublic static final int 250 = 250;\n\tprivate CircularArray lastIDs = new CircularArray<Long>(250);\n\tlong lastPong = -1;\n\n\tMUCController(XMPPConnection c, String jid) {", "refactored_code": "\tpublic static final int LOOKUP_SIZE = 250;\n\n\n\tpublic static final int LOOKUP_SIZE = 250;\n\tprivate CircularArray lastIDs = new CircularArray<Long>(LOOKUP_SIZE);\n\tlong lastPong = -1;\n\n\tMUCController(XMPPConnection c, String jid) {"}
{"magic_number_smell": "\tprivate static final int 5 = 5;\n\tprivate static final int RECONNECT_MAXIMUM = 10*60;\n\tprivate static final String RECONNECT_ALARM = \"org.yaxim.androidclient.RECONNECT_ALARM\";\n\tprivate int mReconnectTimeout = 5;\n\tprivate String mReconnectInfo = \"\";\n\tprivate Intent mAlarmIntent = new Intent(RECONNECT_ALARM);\n\tprivate PendingIntent mPAlarmIntent;", "refactored_code": "\tprivate static final int RECONNECT_AFTER = 5;\n\tprivate static final int RECONNECT_AFTER = 5;\n\tprivate static final int RECONNECT_MAXIMUM = 10*60;\n\tprivate static final String RECONNECT_ALARM = \"org.yaxim.androidclient.RECONNECT_ALARM\";\n\tprivate int mReconnectTimeout = RECONNECT_AFTER;\n\tprivate String mReconnectInfo = \"\";\n\tprivate Intent mAlarmIntent = new Intent(RECONNECT_ALARM);\n\tprivate PendingIntent mPAlarmIntent;"}
{"magic_number_smell": "\t\t\tif (!opts.outMimeType.contains(\"jpeg\") || opts.outHeight < 0 || opts.outWidth < 0)\n\t\t\t\treturn null;\n\t\t\tint current_size = (opts.outWidth > opts.outHeight)? opts.outWidth : opts.outHeight;\n\t\t\tint factor = (int)Math.ceil((double)current_size/ 1920);\n\t\t\tis.close();\n\t\t\tint rotation = getExifRotation(ctx, path);\n\t\t\tByteArrayOutputStream baos;", "refactored_code": "\tprivate static final int IMAGE_SIZE = 1920;\n\t\t\tif (!opts.outMimeType.contains(\"jpeg\") || opts.outHeight < 0 || opts.outWidth < 0)\n\t\t\t\treturn null;\n\t\t\tint current_size = (opts.outWidth > opts.outHeight)? opts.outWidth : opts.outHeight;\n\t\t\tint factor = (int)Math.ceil((double)current_size/ IMAGE_SIZE);\n\t\t\tis.close();\n\t\t\tint rotation = getExifRotation(ctx, path);\n\t\t\tByteArrayOutputStream baos;"}
{"magic_number_smell": "\tpublic static String securePassword() {\n\t\tSecureRandom r = new SecureRandom();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0 ; i < 12; i++)\n\t\t\tsb.append(PASSWORD_CHARS.charAt(r.nextInt(PASSWORD_CHARS.length() - 1)));\n\t\treturn sb.toString();\n\t}", "refactored_code": "\tprivate static final int PASSWORD_LENGTH = 12;\n\tpublic static String securePassword() {\n\t\tSecureRandom r = new SecureRandom();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0 ; i < PASSWORD_LENGTH; i++)\n\t\t\tsb.append(PASSWORD_CHARS.charAt(r.nextInt(PASSWORD_CHARS.length() - 1)));\n\t\treturn sb.toString();\n\t}"}
{"magic_number_smell": "\t\tfinal int BUFFSIZE = 1024;\n\n\t\tLog.i(\"CarCast\", \"Processing URL: \" + url);\n\t\tURLConnection connection = connectToHttpURL(url, 10);\n\t\tString charset = getCharset(connection.getContentType());\n\t\tSAXParser sp = saxParserFactory.newSAXParser();\n", "refactored_code": "\tpublic static final int MAX_REDIRECTS = 10;\n\t\tfinal int BUFFSIZE = 1024;\n\n\t\tLog.i(\"CarCast\", \"Processing URL: \" + url);\n\t\tURLConnection connection = connectToHttpURL(url, MAX_REDIRECTS);\n\t\tString charset = getCharset(connection.getContentType());\n\t\tSAXParser sp = saxParserFactory.newSAXParser();\n"}
{"magic_number_smell": "\t\t\t\n\t\t\tLog.i(\"CarCast\", localName + \" \" + atts.getValue(\"url\") + \"; priority=\" + priority);\n\t\t\ttry {\n\t\t\t\tif (max != -2 && (max == UNLIMITED || max > 0)) {\n\t\t\t\t\tif (max > 0)\n\t\t\t\t\t\tmax--;\n\t\t\t\t\tif (feedName == null) {", "refactored_code": "\tprivate static final int STOP = -2;\n\t\t\t\n\t\t\tLog.i(\"CarCast\", localName + \" \" + atts.getValue(\"url\") + \"; priority=\" + priority);\n\t\t\ttry {\n\t\t\t\tif (max != STOP && (max == UNLIMITED || max > 0)) {\n\t\t\t\t\tif (max > 0)\n\t\t\t\t\t\tmax--;\n\t\t\t\t\tif (feedName == null) {"}
{"magic_number_smell": "//            }\n//        };\n//\t\t\n//        long endTime = System.currentTimeMillis() + TIMEOUT_DURATION_MS;\n//        \n//        while (true) {\n//        \t// Retry messages until mp isn't null or it's time to give up", "refactored_code": "\tprivate final static String AMP_TAG = \"AocateAndroidMediaPlayer\";\n//            }\n//        };\n//\t\t\n//        long endTime = System.currentTimeMillis() + TIMEOUT_DURATION_MS;\n//        \n//        while (true) {\n//        \t// Retry messages until mp isn't null or it's time to give up"}
{"magic_number_smell": "    }\n\n    @Benchmark\n    @OperationsPerInvocation(1024 * BLOCK_LENGTH)\n    public void run() {\n        run(grouping, op, blockType, 1024);\n    }", "refactored_code": "    private static final int OP_COUNT = 1024;\n    }\n\n    @Benchmark\n    @OperationsPerInvocation(OP_COUNT * BLOCK_LENGTH)\n    public void run() {\n        run(grouping, op, blockType, OP_COUNT);\n    }"}
{"magic_number_smell": "    static {\n        // Smoke test all the expected values and force loading subclasses more like prod\n        int totalPositions = 10;\n        long[] actualCheckSums = new long[1024];\n\n        for (String paramString : RELEVANT_TYPE_BLOCK_COMBINATIONS) {\n            String[] params = paramString.split(\"/\");", "refactored_code": "    public static final int NUM_BLOCKS_PER_ITERATION = 1024;\n    static {\n        // Smoke test all the expected values and force loading subclasses more like prod\n        int totalPositions = 10;\n        long[] actualCheckSums = new long[NUM_BLOCKS_PER_ITERATION];\n\n        for (String paramString : RELEVANT_TYPE_BLOCK_COMBINATIONS) {\n            String[] params = paramString.split(\"/\");"}
{"magic_number_smell": "        switch (operation) {\n            case \"abs\" -> {\n                LongVector v = actual.<LongBlock>getBlock(1).asVector();\n                for (int i = 0; i < 8 * 1024; i++) {\n                    if (v.getLong(i) != i * 100_000) {\n                        throw new AssertionError(\"[\" + operation + \"] expected [\" + (i * 100_000) + \"] but was [\" + v.getLong(i) + \"]\");\n                    }", "refactored_code": "    private static final int BLOCK_LENGTH = 8 * 1024;\n        switch (operation) {\n            case \"abs\" -> {\n                LongVector v = actual.<LongBlock>getBlock(1).asVector();\n                for (int i = 0; i < BLOCK_LENGTH; i++) {\n                    if (v.getLong(i) != i * 100_000) {\n                        throw new AssertionError(\"[\" + operation + \"] expected [\" + (i * 100_000) + \"] but was [\" + v.getLong(i) + \"]\");\n                    }"}
{"magic_number_smell": "    private static Block block(String data) {\n        return switch (data) {\n            case LONGS -> {\n                var builder = blockFactory.newLongBlockBuilder(8 * 1024);\n                for (int i = 0; i < 8 * 1024; i++) {\n                    builder.appendLong(i);\n                }", "refactored_code": "    private static final int BLOCK_LENGTH = 8 * 1024;\n    private static Block block(String data) {\n        return switch (data) {\n            case LONGS -> {\n                var builder = blockFactory.newLongBlockBuilder(BLOCK_LENGTH);\n                for (int i = 0; i < BLOCK_LENGTH; i++) {\n                    builder.appendLong(i);\n                }"}
{"magic_number_smell": "@Fork(1)\npublic class ValuesSourceReaderBenchmark {\n    private static final int 16 * 1024 = 16 * 1024;\n    private static final int INDEX_SIZE = 10 * 16 * 1024;\n    private static final int COMMIT_INTERVAL = 500;\n    private static final BigArrays BIG_ARRAYS = BigArrays.NON_RECYCLING_INSTANCE;\n    private static final BlockFactory blockFactory = BlockFactory.getInstance(", "refactored_code": "    private static final int BLOCK_LENGTH = 16 * 1024;\n@Fork(1)\npublic class ValuesSourceReaderBenchmark {\n    private static final int BLOCK_LENGTH = 16 * 1024;\n    private static final int INDEX_SIZE = 10 * BLOCK_LENGTH;\n    private static final int COMMIT_INTERVAL = 500;\n    private static final BigArrays BIG_ARRAYS = BigArrays.NON_RECYCLING_INSTANCE;\n    private static final BlockFactory blockFactory = BlockFactory.getInstance("}
{"magic_number_smell": "\n    @Setup(Level.Iteration)\n    public void setupIteration() throws IOException {\n        decode.setupIteration(bitsPerValue, new ConstantIntegerSupplier(17, bitsPerValue, BLOCK_SIZE));\n    }\n\n    @Benchmark", "refactored_code": "    private static final int SEED = 17;\n\n    @Setup(Level.Iteration)\n    public void setupIteration() throws IOException {\n        decode.setupIteration(bitsPerValue, new ConstantIntegerSupplier(SEED, bitsPerValue, BLOCK_SIZE));\n    }\n\n    @Benchmark"}
{"magic_number_smell": "\n    @Setup(Level.Iteration)\n    public void setupIteration() throws IOException {\n        decode.setupIteration(bitsPerValue, new DecreasingIntegerSupplier(17, bitsPerValue, BLOCK_SIZE));\n    }\n\n    @Benchmark", "refactored_code": "    private static final int SEED = 17;\n\n    @Setup(Level.Iteration)\n    public void setupIteration() throws IOException {\n        decode.setupIteration(bitsPerValue, new DecreasingIntegerSupplier(SEED, bitsPerValue, BLOCK_SIZE));\n    }\n\n    @Benchmark"}
{"magic_number_smell": "\n    @Setup(Level.Iteration)\n    public void setupIteration() throws IOException {\n        decode.setupIteration(bitsPerValue, new IncreasingIntegerSupplier(17, bitsPerValue, BLOCK_SIZE));\n    }\n\n    @Benchmark", "refactored_code": "    private static final int SEED = 17;\n\n    @Setup(Level.Iteration)\n    public void setupIteration() throws IOException {\n        decode.setupIteration(bitsPerValue, new IncreasingIntegerSupplier(SEED, bitsPerValue, BLOCK_SIZE));\n    }\n\n    @Benchmark"}
{"magic_number_smell": "\n    @Setup(Level.Iteration)\n    public void setupIteration() throws IOException {\n        decode.setupIteration(bitsPerValue, new NonSortedIntegerSupplier(17, bitsPerValue, BLOCK_SIZE));\n    }\n\n    @Benchmark", "refactored_code": "    private static final int SEED = 17;\n\n    @Setup(Level.Iteration)\n    public void setupIteration() throws IOException {\n        decode.setupIteration(bitsPerValue, new NonSortedIntegerSupplier(SEED, bitsPerValue, BLOCK_SIZE));\n    }\n\n    @Benchmark"}
{"magic_number_smell": "\n    @Setup(Level.Iteration)\n    public void setupIteration() throws IOException {\n        encode.setupIteration(bitsPerValue, new ConstantIntegerSupplier(17, bitsPerValue, BLOCK_SIZE));\n    }\n\n    @Benchmark", "refactored_code": "    private static final int SEED = 17;\n\n    @Setup(Level.Iteration)\n    public void setupIteration() throws IOException {\n        encode.setupIteration(bitsPerValue, new ConstantIntegerSupplier(SEED, bitsPerValue, BLOCK_SIZE));\n    }\n\n    @Benchmark"}
{"magic_number_smell": "\n    @Setup(Level.Iteration)\n    public void setupIteration() throws IOException {\n        encode.setupIteration(bitsPerValue, new DecreasingIntegerSupplier(17, bitsPerValue, BLOCK_SIZE));\n    }\n\n    @Benchmark", "refactored_code": "    private static final int SEED = 17;\n\n    @Setup(Level.Iteration)\n    public void setupIteration() throws IOException {\n        encode.setupIteration(bitsPerValue, new DecreasingIntegerSupplier(SEED, bitsPerValue, BLOCK_SIZE));\n    }\n\n    @Benchmark"}
{"magic_number_smell": "\n    @Setup(Level.Iteration)\n    public void setupIteration() throws IOException {\n        encode.setupIteration(bitsPerValue, new IncreasingIntegerSupplier(17, bitsPerValue, BLOCK_SIZE));\n    }\n\n    @Benchmark", "refactored_code": "    private static final int SEED = 17;\n\n    @Setup(Level.Iteration)\n    public void setupIteration() throws IOException {\n        encode.setupIteration(bitsPerValue, new IncreasingIntegerSupplier(SEED, bitsPerValue, BLOCK_SIZE));\n    }\n\n    @Benchmark"}
{"magic_number_smell": "\n    @Setup(Level.Iteration)\n    public void setupIteration() throws IOException {\n        encode.setupIteration(bitsPerValue, new NonSortedIntegerSupplier(17, bitsPerValue, BLOCK_SIZE));\n    }\n\n    @Benchmark", "refactored_code": "    private static final int SEED = 17;\n\n    @Setup(Level.Iteration)\n    public void setupIteration() throws IOException {\n        encode.setupIteration(bitsPerValue, new NonSortedIntegerSupplier(SEED, bitsPerValue, BLOCK_SIZE));\n    }\n\n    @Benchmark"}
{"magic_number_smell": "    public void setup() throws IOException {\n        // pre: set up MapperService and SearchExecutionContext\n        List<String> fields = new ArrayList<>();\n        for (int i = 0; i < 1000; i++) {\n            fields.add(String.format(\"\"\"\n                \"field%d\":{\"type\":\"long\"}\"\"\", i));\n        }", "refactored_code": "    private static final int NUMBER_OF_MAPPING_FIELDS = 1000;\n    public void setup() throws IOException {\n        // pre: set up MapperService and SearchExecutionContext\n        List<String> fields = new ArrayList<>();\n        for (int i = 0; i < NUMBER_OF_MAPPING_FIELDS; i++) {\n            fields.add(String.format(\"\"\"\n                \"field%d\":{\"type\":\"long\"}\"\"\", i));\n        }"}
{"magic_number_smell": "    @Benchmark\n    public void singleBucketIntoSingleImmutableMonmorphicInvocation(Blackhole bh) {\n        try (LongKeyedBucketOrds.FromSingle ords = new LongKeyedBucketOrds.FromSingle(bigArrays)) {\n            for (long i = 0; i < 1_000_000; i++) {\n                ords.add(0, i % DISTINCT_VALUES);\n            }\n            if (ords.size() != DISTINCT_VALUES) {", "refactored_code": "    private static final long LIMIT = 1_000_000;\n    @Benchmark\n    public void singleBucketIntoSingleImmutableMonmorphicInvocation(Blackhole bh) {\n        try (LongKeyedBucketOrds.FromSingle ords = new LongKeyedBucketOrds.FromSingle(bigArrays)) {\n            for (long i = 0; i < LIMIT; i++) {\n                ords.add(0, i % DISTINCT_VALUES);\n            }\n            if (ords.size() != DISTINCT_VALUES) {"}
{"magic_number_smell": "@State(Scope.Thread)\npublic class SortBench {\n    private final int 100000 = 100000;\n    private final double[] values = new double[100000];\n\n    @Param({ \"0\", \"1\", \"-1\" })\n    public int sortDirection;", "refactored_code": "    private final int size = 100000;\n@State(Scope.Thread)\npublic class SortBench {\n    private final int size = 100000;\n    private final double[] values = new double[size];\n\n    @Param({ \"0\", \"1\", \"-1\" })\n    public int sortDirection;"}
{"magic_number_smell": "        writeUnicastHostsFiles();\n\n        LOGGER.info(\"Starting to wait for cluster to form\");\n        waitForConditions(waitConditions, System.currentTimeMillis(), 40, CLUSTER_UP_TIMEOUT_UNIT, this);\n    }\n\n    @Override", "refactored_code": "    private static final int CLUSTER_UP_TIMEOUT = 40;\n        writeUnicastHostsFiles();\n\n        LOGGER.info(\"Starting to wait for cluster to form\");\n        waitForConditions(waitConditions, System.currentTimeMillis(), CLUSTER_UP_TIMEOUT, CLUSTER_UP_TIMEOUT_UNIT, this);\n    }\n\n    @Override"}
{"magic_number_smell": "                if (processHandle.isAlive() == false) {\n                    return;\n                }\n                LOGGER.info(\"process did not terminate after {} {}, stopping it forcefully\", 20, ES_DESTROY_TIMEOUT_UNIT);\n                processHandle.destroyForcibly();\n            }\n", "refactored_code": "    private static final int ES_DESTROY_TIMEOUT = 20;\n                if (processHandle.isAlive() == false) {\n                    return;\n                }\n                LOGGER.info(\"process did not terminate after {} {}, stopping it forcefully\", ES_DESTROY_TIMEOUT, ES_DESTROY_TIMEOUT_UNIT);\n                processHandle.destroyForcibly();\n            }\n"}
{"magic_number_smell": "                OutputStream os = t.getResponseBody();\n                os.write(response.getBytes());\n                os.close();\n                instance.stop(3);\n                instance = null;\n            } catch (Exception e) {\n                e.printStackTrace();", "refactored_code": "        private static final int STOP_TIME = 3;\n                OutputStream os = t.getResponseBody();\n                os.write(response.getBytes());\n                os.close();\n                instance.stop(STOP_TIME);\n                instance = null;\n            } catch (Exception e) {\n                e.printStackTrace();"}
{"magic_number_smell": "    private static final int 4096 = 4096;\n\n    /** The buffer of bytes sent to the stream */\n    private byte[] buffer = new byte[4096];\n\n    /** Offset of the start of unwritten data in the buffer */\n    private int start = 0;", "refactored_code": "    private static final int DEFAULT_BUFFER_LENGTH = 4096;\n    private static final int DEFAULT_BUFFER_LENGTH = 4096;\n\n    /** The buffer of bytes sent to the stream */\n    private byte[] buffer = new byte[DEFAULT_BUFFER_LENGTH];\n\n    /** Offset of the start of unwritten data in the buffer */\n    private int start = 0;"}
{"magic_number_smell": "            }\n            spec.setIgnoreExitValue(true);\n        });\n        if (OS.current().equals(OS.LINUX) && result.getExitValue() == 137) {\n            throw new IllegalStateException(\"Third party audit was killed buy SIGKILL, could be a victim of the Linux OOM killer\");\n        }\n        final String forbiddenApisOutput;", "refactored_code": "    private static final int SIG_KILL_EXIT_VALUE = 137;\n            }\n            spec.setIgnoreExitValue(true);\n        });\n        if (OS.current().equals(OS.LINUX) && result.getExitValue() == SIG_KILL_EXIT_VALUE) {\n            throw new IllegalStateException(\"Third party audit was killed buy SIGKILL, could be a victim of the Linux OOM killer\");\n        }\n        final String forbiddenApisOutput;"}
{"magic_number_smell": "    private static final Path RELATIVE_REST_XPACK = Path.of(\"x-pack/plugin\");\n    private static final Path RELATIVE_REST_PROJECT_RESOURCES = Path.of(\"src/yamlRestTest/resources\");\n    private static final int Version.fromString(VersionProperties.getVersions().get(\"elasticsearch\")).getMajor() - 1 = Version.fromString(VersionProperties.getVersions().get(\"elasticsearch\")).getMajor() - 1;\n    private static final String SOURCE_SET_NAME = \"yamlRestTestV\" + Version.fromString(VersionProperties.getVersions().get(\"elasticsearch\")).getMajor() - 1 + \"Compat\";\n    private ProjectLayout projectLayout;\n    private FileOperations fileOperations;\n", "refactored_code": "    private static final int COMPATIBLE_VERSION = Version.fromString(VersionProperties.getVersions().get(\"elasticsearch\")).getMajor() - 1;\n    private static final Path RELATIVE_REST_XPACK = Path.of(\"x-pack/plugin\");\n    private static final Path RELATIVE_REST_PROJECT_RESOURCES = Path.of(\"src/yamlRestTest/resources\");\n    private static final int COMPATIBLE_VERSION = Version.fromString(VersionProperties.getVersions().get(\"elasticsearch\")).getMajor() - 1;\n    private static final String SOURCE_SET_NAME = \"yamlRestTestV\" + COMPATIBLE_VERSION + \"Compat\";\n    private ProjectLayout projectLayout;\n    private FileOperations fileOperations;\n"}
{"magic_number_smell": "    private ReservedPortRangeFactory portRangeFactory = new DefaultReservedPortRangeFactory();\n\n    protected Pair<Integer, Integer> getNextPortRange(int rangeNumber) {\n        int startPort = 10300 + (rangeNumber * DEFAULT_RANGE_SIZE);\n        int endPort = startPort + DEFAULT_RANGE_SIZE - 1;\n        if (endPort > MAX_PRIVATE_PORT) {\n            throw new IllegalStateException(", "refactored_code": "    public static final int MIN_PRIVATE_PORT = 10300;\n    private ReservedPortRangeFactory portRangeFactory = new DefaultReservedPortRangeFactory();\n\n    protected Pair<Integer, Integer> getNextPortRange(int rangeNumber) {\n        int startPort = MIN_PRIVATE_PORT + (rangeNumber * DEFAULT_RANGE_SIZE);\n        int endPort = startPort + DEFAULT_RANGE_SIZE - 1;\n        if (endPort > MAX_PRIVATE_PORT) {\n            throw new IllegalStateException("}
{"magic_number_smell": "                    // GC between trials to reduce the likelihood of a GC occurring in the middle of a trial.\n                    runGc();\n                    BenchmarkRunner benchmark = new BenchmarkRunner(\n                        10_000,\n                        10_000,\n                        new SearchBenchmarkTask(\n                            searchRequestExecutor(client, indexName),", "refactored_code": "    private static final int SEARCH_BENCHMARK_ITERATIONS = 10_000;\n                    // GC between trials to reduce the likelihood of a GC occurring in the middle of a trial.\n                    runGc();\n                    BenchmarkRunner benchmark = new BenchmarkRunner(\n                        SEARCH_BENCHMARK_ITERATIONS,\n                        SEARCH_BENCHMARK_ITERATIONS,\n                        new SearchBenchmarkTask(\n                            searchRequestExecutor(client, indexName),"}
{"magic_number_smell": "     */\n    DeadHostState(Supplier<Long> timeSupplier) {\n        this.failedAttempts = 1;\n        this.deadUntilNanos = timeSupplier.get() + TimeUnit.MINUTES.toNanos(1);\n        this.timeSupplier = timeSupplier;\n    }\n", "refactored_code": "    private static final long MIN_CONNECTION_TIMEOUT_NANOS = TimeUnit.MINUTES.toNanos(1);\n     */\n    DeadHostState(Supplier<Long> timeSupplier) {\n        this.failedAttempts = 1;\n        this.deadUntilNanos = timeSupplier.get() + MIN_CONNECTION_TIMEOUT_NANOS;\n        this.timeSupplier = timeSupplier;\n    }\n"}
{"magic_number_smell": "    private CloseableHttpAsyncClient createHttpClient() {\n        // default timeouts are all infinite\n        RequestConfig.Builder requestConfigBuilder = RequestConfig.custom()\n            .setConnectTimeout(1000)\n            .setSocketTimeout(DEFAULT_SOCKET_TIMEOUT_MILLIS);\n        if (requestConfigCallback != null) {\n            requestConfigBuilder = requestConfigCallback.customizeRequestConfig(requestConfigBuilder);", "refactored_code": "    public static final int DEFAULT_CONNECT_TIMEOUT_MILLIS = 1000;\n    private CloseableHttpAsyncClient createHttpClient() {\n        // default timeouts are all infinite\n        RequestConfig.Builder requestConfigBuilder = RequestConfig.custom()\n            .setConnectTimeout(DEFAULT_CONNECT_TIMEOUT_MILLIS)\n            .setSocketTimeout(DEFAULT_SOCKET_TIMEOUT_MILLIS);\n        if (requestConfigCallback != null) {\n            requestConfigBuilder = requestConfigCallback.customizeRequestConfig(requestConfigBuilder);"}
{"magic_number_smell": "        } catch (IllegalArgumentException e) {\n            assertEquals(\"bufferLimit must be greater than 0\", e.getMessage());\n        }\n        int bufferLimit = randomIntBetween(1, 50 * 1024 * 1024 - 100);\n        HeapBufferedAsyncResponseConsumer consumer = new HeapBufferedAsyncResponseConsumer(bufferLimit);\n        bufferLimitTest(consumer, bufferLimit);\n    }", "refactored_code": "    private static final int MAX_TEST_BUFFER_SIZE = 50 * 1024 * 1024;\n        } catch (IllegalArgumentException e) {\n            assertEquals(\"bufferLimit must be greater than 0\", e.getMessage());\n        }\n        int bufferLimit = randomIntBetween(1, MAX_TEST_BUFFER_SIZE - 100);\n        HeapBufferedAsyncResponseConsumer consumer = new HeapBufferedAsyncResponseConsumer(bufferLimit);\n        bufferLimitTest(consumer, bufferLimit);\n    }"}
{"magic_number_smell": "\n    /**\n     * Creates a new instance of the Elasticsearch sniffer. It will use the provided {@link RestClient} to fetch the hosts,\n     * through the nodes info api, the default sniff request timeout value {@link #TimeUnit.SECONDS.toMillis(1)} and http\n     * as the scheme for all the hosts.\n     * @param restClient client used to fetch the hosts from elasticsearch through nodes info api. Usually the same instance\n     *                   that is also provided to {@link Sniffer#builder(RestClient)}, so that the hosts are set to the same", "refactored_code": "    public static final long DEFAULT_SNIFF_REQUEST_TIMEOUT = TimeUnit.SECONDS.toMillis(1);\n\n    /**\n     * Creates a new instance of the Elasticsearch sniffer. It will use the provided {@link RestClient} to fetch the hosts,\n     * through the nodes info api, the default sniff request timeout value {@link #DEFAULT_SNIFF_REQUEST_TIMEOUT} and http\n     * as the scheme for all the hosts.\n     * @param restClient client used to fetch the hosts from elasticsearch through nodes info api. Usually the same instance\n     *                   that is also provided to {@link Sniffer#builder(RestClient)}, so that the hosts are set to the same"}
{"magic_number_smell": "    public static final long DEFAULT_SNIFF_AFTER_FAILURE_DELAY = TimeUnit.MINUTES.toMillis(1);\n\n    private final RestClient restClient;\n    private long sniffIntervalMillis = TimeUnit.MINUTES.toMillis(5);\n    private long sniffAfterFailureDelayMillis = DEFAULT_SNIFF_AFTER_FAILURE_DELAY;\n    private NodesSniffer nodesSniffer;\n", "refactored_code": "    public static final long DEFAULT_SNIFF_INTERVAL = TimeUnit.MINUTES.toMillis(5);\n    public static final long DEFAULT_SNIFF_AFTER_FAILURE_DELAY = TimeUnit.MINUTES.toMillis(1);\n\n    private final RestClient restClient;\n    private long sniffIntervalMillis = DEFAULT_SNIFF_INTERVAL;\n    private long sniffAfterFailureDelayMillis = DEFAULT_SNIFF_AFTER_FAILURE_DELAY;\n    private NodesSniffer nodesSniffer;\n"}
{"magic_number_smell": "        @Override\n        public void onProgress(int percent) {\n            if (enabled) {\n                int currentPosition = percent * 50 / 100;\n                StringBuilder sb = new StringBuilder(\"\\r[\");\n                sb.append(String.join(\"=\", Collections.nCopies(currentPosition, \"\")));\n                if (currentPosition > 0 && percent < 100) {", "refactored_code": "        private static final int WIDTH = 50;\n        @Override\n        public void onProgress(int percent) {\n            if (enabled) {\n                int currentPosition = percent * WIDTH / 100;\n                StringBuilder sb = new StringBuilder(\"\\r[\");\n                sb.append(String.join(\"=\", Collections.nCopies(currentPosition, \"\")));\n                if (currentPosition > 0 && percent < 100) {"}
{"magic_number_smell": " */\npublic final class MachineDependentHeap {\n    private static final long 1024L * 1024L * 1024L = 1024L * 1024L * 1024L; // 1GB\n    private static final long MAX_HEAP_SIZE = 1024L * 1024L * 1024L * 31; // 31GB\n    private static final long MIN_HEAP_SIZE = 1024 * 1024 * 128; // 128MB\n    private static final int DEFAULT_HEAP_SIZE_MB = 1024;\n    private static final String ELASTICSEARCH_YML = \"elasticsearch.yml\";", "refactored_code": "    private static final long GB = 1024L * 1024L * 1024L; // 1GB\n */\npublic final class MachineDependentHeap {\n    private static final long GB = 1024L * 1024L * 1024L; // 1GB\n    private static final long MAX_HEAP_SIZE = GB * 31; // 31GB\n    private static final long MIN_HEAP_SIZE = 1024 * 1024 * 128; // 128MB\n    private static final int DEFAULT_HEAP_SIZE_MB = 1024;\n    private static final String ELASTICSEARCH_YML = \"elasticsearch.yml\";"}
{"magic_number_smell": "\n    public void testNoOptions() {\n        final SystemMemoryInfo memoryInfo = new OverridableSystemMemoryInfo(List.of(), fallbackSystemMemoryInfo());\n        assertThat(memoryInfo.availableSystemMemory(), is(-1L));\n    }\n\n    public void testNoOverrides() {", "refactored_code": "    private static final long FALLBACK = -1L;\n\n    public void testNoOptions() {\n        final SystemMemoryInfo memoryInfo = new OverridableSystemMemoryInfo(List.of(), fallbackSystemMemoryInfo());\n        assertThat(memoryInfo.availableSystemMemory(), is(FALLBACK));\n    }\n\n    public void testNoOverrides() {"}
{"magic_number_smell": "            // JDK >= 22 returns a console even if the terminal is redirected unless using -Djdk.console=java.base\n            // https://bugs.openjdk.org/browse/JDK-8308591\n            Console console = System.console();\n            if (console != null && Runtime.version().feature() >= 22) {\n                try {\n                    // verify the console is a terminal using isTerminal() on JDK >= 22\n                    // TODO: Remove reflection once Java 22 sources are supported, e.g. using a MRJAR", "refactored_code": "        private static final int JDK_VERSION_WITH_IS_TERMINAL = 22;\n            // JDK >= 22 returns a console even if the terminal is redirected unless using -Djdk.console=java.base\n            // https://bugs.openjdk.org/browse/JDK-8308591\n            Console console = System.console();\n            if (console != null && Runtime.version().feature() >= JDK_VERSION_WITH_IS_TERMINAL) {\n                try {\n                    // verify the console is a terminal using isTerminal() on JDK >= 22\n                    // TODO: Remove reflection once Java 22 sources are supported, e.g. using a MRJAR"}
{"magic_number_smell": "            double onePlusXSqInv4 = onePlusXSqInv2 * onePlusXSqInv2;\n            atanTab[i] = StrictMath.atan(x);\n            atanDer1DivF1Tab[i] = onePlusXSqInv;\n            atanDer2DivF2Tab[i] = (-2 * x * onePlusXSqInv2) * 1 / 2.0;\n            atanDer3DivF3Tab[i] = ((-2 + 6 * x * x) * onePlusXSqInv3) * ONE_DIV_F3;\n            atanDer4DivF4Tab[i] = ((24 * x * (1 - x * x)) * onePlusXSqInv4) * ONE_DIV_F4;\n        }", "refactored_code": "    private static final double ONE_DIV_F2 = 1 / 2.0;\n            double onePlusXSqInv4 = onePlusXSqInv2 * onePlusXSqInv2;\n            atanTab[i] = StrictMath.atan(x);\n            atanDer1DivF1Tab[i] = onePlusXSqInv;\n            atanDer2DivF2Tab[i] = (-2 * x * onePlusXSqInv2) * ONE_DIV_F2;\n            atanDer3DivF3Tab[i] = ((-2 + 6 * x * x) * onePlusXSqInv3) * ONE_DIV_F3;\n            atanDer4DivF4Tab[i] = ((24 * x * (1 - x * x)) * onePlusXSqInv4) * ONE_DIV_F4;\n        }"}
{"magic_number_smell": "    }\n\n    public static long nsecToMSec(long ns) {\n        return ns / TimeUnit.NANOSECONDS.convert(1, TimeUnit.MILLISECONDS);\n    }\n\n    @Override", "refactored_code": "    public static final long NSEC_PER_MSEC = TimeUnit.NANOSECONDS.convert(1, TimeUnit.MILLISECONDS);\n    }\n\n    public static long nsecToMSec(long ns) {\n        return ns / NSEC_PER_MSEC;\n    }\n\n    @Override"}
{"magic_number_smell": "    private static final int RUNTIME_VERSION_FEATURE = Runtime.version().feature();\n\n    static {\n        assert RUNTIME_VERSION_FEATURE >= 8;\n    }\n\n    private static final String MRJAR_VERSION_PREFIX = \"META-INF/versions/\";", "refactored_code": "    private static final int BASE_VERSION_FEATURE = 8; // lowest supported release version\n    private static final int RUNTIME_VERSION_FEATURE = Runtime.version().feature();\n\n    static {\n        assert RUNTIME_VERSION_FEATURE >= BASE_VERSION_FEATURE;\n    }\n\n    private static final String MRJAR_VERSION_PREFIX = \"META-INF/versions/\";"}
{"magic_number_smell": "    }\n\n    private static Optional<ModuleDescriptor> getModuleInfoVersioned(Path rootPath) throws IOException {\n        for (int v = RUNTIME_VERSION_FEATURE; v >= 8; v--) {\n            Path mi = rootPath.resolve(\"META-INF\").resolve(\"versions\").resolve(Integer.toString(v)).resolve(MODULE_INFO);\n            if (Files.exists(mi)) {\n                return Optional.of(readModuleInfo(mi, rootPath));", "refactored_code": "    private static final int BASE_VERSION_FEATURE = 8; // lowest supported release version\n    }\n\n    private static Optional<ModuleDescriptor> getModuleInfoVersioned(Path rootPath) throws IOException {\n        for (int v = RUNTIME_VERSION_FEATURE; v >= BASE_VERSION_FEATURE; v--) {\n            Path mi = rootPath.resolve(\"META-INF\").resolve(\"versions\").resolve(Integer.toString(v)).resolve(MODULE_INFO);\n            if (Files.exists(mi)) {\n                return Optional.of(readModuleInfo(mi, rootPath));"}
{"magic_number_smell": "     * validates longitude value is within standard +/-180 coordinate bounds\n     */\n    protected void checkLongitude(double longitude) {\n        if (Double.isNaN(longitude) || longitude < -180.0D || longitude > MAX_LON_INCL) {\n            throw new IllegalArgumentException(\n                \"invalid longitude \" + longitude + \"; must be between \" + -180.0D + \" and \" + MAX_LON_INCL\n            );", "refactored_code": "    private static final double MIN_LON_INCL = -180.0D;\n     * validates longitude value is within standard +/-180 coordinate bounds\n     */\n    protected void checkLongitude(double longitude) {\n        if (Double.isNaN(longitude) || longitude < MIN_LON_INCL || longitude > MAX_LON_INCL) {\n            throw new IllegalArgumentException(\n                \"invalid longitude \" + longitude + \"; must be between \" + MIN_LON_INCL + \" and \" + MAX_LON_INCL\n            );"}
{"magic_number_smell": "    private static final double LON_SCALE = (0x1L << (BITS - 1)) / 360.0D;\n    private static final double LON_DECODE = 360.0D / (0x1L << BITS);\n\n    private static final short MORTON_OFFSET = (BITS << 1) - (12 * 5);\n    /** Bit encoded representation of the latitude of north pole */\n    private static final long MAX_LAT_BITS = (0x1L << (12 * 5 / 2)) - 1;\n", "refactored_code": "    public static final int PRECISION = 12;\n    private static final double LON_SCALE = (0x1L << (BITS - 1)) / 360.0D;\n    private static final double LON_DECODE = 360.0D / (0x1L << BITS);\n\n    private static final short MORTON_OFFSET = (BITS << 1) - (PRECISION * 5);\n    /** Bit encoded representation of the latitude of north pole */\n    private static final long MAX_LAT_BITS = (0x1L << (PRECISION * 5 / 2)) - 1;\n"}
{"magic_number_smell": "\n        @Override\n        protected void checkLongitude(double longitude) {\n            if (Double.isNaN(longitude) || longitude < -1D || longitude > MAX_LON_INCL) {\n                throw new IllegalArgumentException(\n                    \"invalid longitude \" + longitude + \"; must be between \" + -1D + \" and \" + MAX_LON_INCL\n                );", "refactored_code": "        private static final double MIN_LON_INCL = -1D;\n\n        @Override\n        protected void checkLongitude(double longitude) {\n            if (Double.isNaN(longitude) || longitude < MIN_LON_INCL || longitude > MAX_LON_INCL) {\n                throw new IllegalArgumentException(\n                    \"invalid longitude \" + longitude + \"; must be between \" + MIN_LON_INCL + \" and \" + MAX_LON_INCL\n                );"}
{"magic_number_smell": "                assertThat(\"Point \" + point + \" should have unit length\", point.length(), closeTo(1.0, 1e-15));\n            }\n        }\n        assertThat(\"Should be between all three axes\", from(45, 45), samePoint(0.5, 0.5, sin(toRadians(45))));\n        assertThat(\"Should be between all three axes\", from(-45, -135), samePoint(-0.5, -0.5, -sin(toRadians(45))));\n        assertThat(\"XY should be between x and y axes\", from(0, 45), samePoint(sin(toRadians(45)), sin(toRadians(45)), 0));\n        assertThat(\"YZ should be between y and z axes\", from(45, 90), samePoint(0, sin(toRadians(45)), sin(toRadians(45))));", "refactored_code": "    private static final double sin45 = sin(toRadians(45));\n                assertThat(\"Point \" + point + \" should have unit length\", point.length(), closeTo(1.0, 1e-15));\n            }\n        }\n        assertThat(\"Should be between all three axes\", from(45, 45), samePoint(0.5, 0.5, sin45));\n        assertThat(\"Should be between all three axes\", from(-45, -135), samePoint(-0.5, -0.5, -sin45));\n        assertThat(\"XY should be between x and y axes\", from(0, 45), samePoint(sin45, sin45, 0));\n        assertThat(\"YZ should be between y and z axes\", from(45, 90), samePoint(0, sin45, sin45));"}
{"magic_number_smell": "     */\n    String toRegex(PatternBank patternBank, String grokPattern) {\n        StringBuilder res = new StringBuilder();\n        for (int i = 0; i < 100_000; i++) {\n            byte[] grokPatternBytes = grokPattern.getBytes(StandardCharsets.UTF_8);\n            Matcher matcher = GROK_PATTERN_REGEX.matcher(grokPatternBytes);\n", "refactored_code": "    private static final int MAX_TO_REGEX_ITERATIONS = 100_000; // sanity limit\n     */\n    String toRegex(PatternBank patternBank, String grokPattern) {\n        StringBuilder res = new StringBuilder();\n        for (int i = 0; i < MAX_TO_REGEX_ITERATIONS; i++) {\n            byte[] grokPatternBytes = grokPattern.getBytes(StandardCharsets.UTF_8);\n            Matcher matcher = GROK_PATTERN_REGEX.matcher(grokPatternBytes);\n"}
{"magic_number_smell": "    /** How many points it holds */\n    private int numVertext;\n    /** The actual points */\n    private final LatLng[] points = new LatLng[10];\n\n    CellBoundary() {}\n", "refactored_code": "    private static final int MAX_CELL_BNDRY_VERTS = 10;\n    /** How many points it holds */\n    private int numVertext;\n    /** The actual points */\n    private final LatLng[] points = new LatLng[MAX_CELL_BNDRY_VERTS];\n\n    CellBoundary() {}\n"}
{"magic_number_smell": "     * the origin face's coordinate system, or -1 if not adjacent.\n     */\n    private static final int[][] adjacentFaceDir = new int[][] {\n        { 0, KI, -1, -1, 1, JK, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },  // face 0\n        { 1, 0, KI, -1, -1, -1, JK, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },  // face 1\n        { -1, 1, 0, KI, -1, -1, -1, JK, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },  // face 2\n        { -1, -1, 1, 0, KI, -1, -1, -1, JK, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },  // face 3", "refactored_code": "    private static final int IJ = 1;\n     * the origin face's coordinate system, or -1 if not adjacent.\n     */\n    private static final int[][] adjacentFaceDir = new int[][] {\n        { 0, KI, -1, -1, IJ, JK, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },  // face 0\n        { IJ, 0, KI, -1, -1, -1, JK, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },  // face 1\n        { -1, IJ, 0, KI, -1, -1, -1, JK, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },  // face 2\n        { -1, -1, IJ, 0, KI, -1, -1, -1, JK, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },  // face 3"}
{"magic_number_smell": "        index &= (SIN_COS_TABS_SIZE - 2); // index % (SIN_COS_TABS_SIZE-1)\n        double indexCos = cosTab[index];\n        double indexSin = sinTab[index];\n        return indexCos + delta * (-indexSin + delta * (-indexCos * 1 / 2.0 + delta * (indexSin * ONE_DIV_F3 + delta * indexCos\n            * ONE_DIV_F4)));\n    }\n", "refactored_code": "    private static final double ONE_DIV_F2 = 1 / 2.0;\n        index &= (SIN_COS_TABS_SIZE - 2); // index % (SIN_COS_TABS_SIZE-1)\n        double indexCos = cosTab[index];\n        double indexSin = sinTab[index];\n        return indexCos + delta * (-indexSin + delta * (-indexCos * ONE_DIV_F2 + delta * (indexSin * ONE_DIV_F3 + delta * indexCos\n            * ONE_DIV_F4)));\n    }\n"}
{"magic_number_smell": "        { 1, 7, 6, 9, 0, 3, 2 },                          // base cell 1\n        { 2, 6, 10, 11, 0, 1, 5 },                        // base cell 2\n        { 3, 13, 1, 7, 4, 12, 0 },                        // base cell 3\n        { 4, 127, 15, 8, 3, 0, 12 },        // base cell 4 (pentagon)\n        { 5, 2, 18, 10, 8, 0, 16 },                       // base cell 5\n        { 6, 14, 11, 17, 1, 9, 2 },                       // base cell 6\n        { 7, 21, 9, 19, 3, 13, 1 },                       // base cell 7", "refactored_code": "    private static final int INVALID_BASE_CELL = 127;\n        { 1, 7, 6, 9, 0, 3, 2 },                          // base cell 1\n        { 2, 6, 10, 11, 0, 1, 5 },                        // base cell 2\n        { 3, 13, 1, 7, 4, 12, 0 },                        // base cell 3\n        { 4, INVALID_BASE_CELL, 15, 8, 3, 0, 12 },        // base cell 4 (pentagon)\n        { 5, 2, 18, 10, 8, 0, 16 },                       // base cell 5\n        { 6, 14, 11, 17, 1, 9, 2 },                       // base cell 6\n        { 7, 21, 9, 19, 3, 13, 1 },                       // base cell 7"}
{"magic_number_smell": "    }\n\n    boolean isNumericallyIdentical(LatLng latLng) {\n        return Math.abs(this.lat - latLng.lat) < Math.PI * 1.0e-12 && Math.abs(this.lon - latLng.lon) < Math.PI * 1.0e-12;\n    }\n\n    @Override", "refactored_code": "    private static final double MINIMUM_ANGULAR_RESOLUTION = Math.PI * 1.0e-12; // taken from lucene's spatial3d\n    }\n\n    boolean isNumericallyIdentical(LatLng latLng) {\n        return Math.abs(this.lat - latLng.lat) < MINIMUM_ANGULAR_RESOLUTION && Math.abs(this.lon - latLng.lon) < MINIMUM_ANGULAR_RESOLUTION;\n    }\n\n    @Override"}
{"magic_number_smell": "        a2 = Math.abs(y);\n\n        // first do a reverse conversion\n        x2 = a2 / Constants.M_SQRT3_2;\n        x1 = a1 + x2 / 2.0;\n\n        // check if we have the center of a hex", "refactored_code": "    private static final double M_SIN60 = Constants.M_SQRT3_2;\n        a2 = Math.abs(y);\n\n        // first do a reverse conversion\n        x2 = a2 / M_SIN60;\n        x1 = a1 + x2 / 2.0;\n\n        // check if we have the center of a hex"}
{"magic_number_smell": "    static int maxCompressedLength(int length) {\n        if (length < 0) {\n            throw new IllegalArgumentException(\"length must be >= 0, got \" + length);\n        } else if (length >= 0x7E000000) {\n            throw new IllegalArgumentException(\"length must be < \" + 0x7E000000);\n        }\n        return length + length / 255 + 16;", "refactored_code": "    private static final int MAX_INPUT_SIZE = 0x7E000000;\n    static int maxCompressedLength(int length) {\n        if (length < 0) {\n            throw new IllegalArgumentException(\"length must be >= 0, got \" + length);\n        } else if (length >= MAX_INPUT_SIZE) {\n            throw new IllegalArgumentException(\"length must be < \" + MAX_INPUT_SIZE);\n        }\n        return length + length / 255 + 16;"}
{"magic_number_smell": "\n    @Override\n    public NativeFileHandle open(String path) throws IOException {\n        int fd = functions.open(path, 1, constants.O_CREAT);\n        if (fd < 0) {\n            throw newIOException(String.format(Locale.ROOT, \"Could not open file [%s] for preallocation\", path));\n        }", "refactored_code": "    private static final int O_WRONLY = 1;\n\n    @Override\n    public NativeFileHandle open(String path) throws IOException {\n        int fd = functions.open(path, O_WRONLY, constants.O_CREAT);\n        if (fd < 0) {\n            throw newIOException(String.format(Locale.ROOT, \"Could not open file [%s] for preallocation\", path));\n        }"}
{"magic_number_smell": "        }\n\n        public boolean isConstructed() {\n            return (tag & DerParser.0x20) == DerParser.0x20;\n        }\n\n        /**", "refactored_code": "    private static final int CONSTRUCTED = 0x20;\n        }\n\n        public boolean isConstructed() {\n            return (tag & DerParser.CONSTRUCTED) == DerParser.CONSTRUCTED;\n        }\n\n        /**"}
{"magic_number_smell": "        assertThat(certificate.getSubjectAlternativeNames(), iterableWithSize(2));\n        assertThat(\n            certificate.getSubjectAlternativeNames(),\n            containsInAnyOrder(Arrays.asList(DNS_NAME, \"localhost\"), Arrays.asList(7, \"127.0.0.1\"))\n        );\n\n        for (int i = 0; i < caDN.length; i++) {", "refactored_code": "    private static final int IP_NAME = 7;\n        assertThat(certificate.getSubjectAlternativeNames(), iterableWithSize(2));\n        assertThat(\n            certificate.getSubjectAlternativeNames(),\n            containsInAnyOrder(Arrays.asList(DNS_NAME, \"localhost\"), Arrays.asList(IP_NAME, \"127.0.0.1\"))\n        );\n\n        for (int i = 0; i < caDN.length; i++) {"}
{"magic_number_smell": "            assertThat(certificate.getSubjectAlternativeNames(), iterableWithSize(2));\n            assertThat(\n                certificate.getSubjectAlternativeNames(),\n                containsInAnyOrder(Arrays.asList(DNS_NAME, \"localhost\"), Arrays.asList(7, \"127.0.0.1\"))\n            );\n        }\n", "refactored_code": "    private static final int IP_NAME = 7;\n            assertThat(certificate.getSubjectAlternativeNames(), iterableWithSize(2));\n            assertThat(\n                certificate.getSubjectAlternativeNames(),\n                containsInAnyOrder(Arrays.asList(DNS_NAME, \"localhost\"), Arrays.asList(IP_NAME, \"127.0.0.1\"))\n            );\n        }\n"}
{"magic_number_smell": "\n    IntAVLTree(int initialCapacity) {\n        nodeAllocator = new NodeAllocator();\n        root = 0;\n        parent = new int[initialCapacity];\n        left = new int[initialCapacity];\n        right = new int[initialCapacity];", "refactored_code": "    protected static final int NIL = 0;\n\n    IntAVLTree(int initialCapacity) {\n        nodeAllocator = new NodeAllocator();\n        root = NIL;\n        parent = new int[initialCapacity];\n        left = new int[initialCapacity];\n        right = new int[initialCapacity];"}
{"magic_number_smell": "        mergingDigest = TDigest.createMergingDigest(COMPRESSION);\n        sortingDigest = TDigest.createSortingDigest();\n        hybridDigest = TDigest.createHybridDigest(COMPRESSION);\n        samples = new double[1_000_000];\n\n        for (int i = 0; i < 1_000_000; i++) {\n            samples[i] = sampleGenerator.get();", "refactored_code": "    private static final int SAMPLE_COUNT = 1_000_000;\n        mergingDigest = TDigest.createMergingDigest(COMPRESSION);\n        sortingDigest = TDigest.createSortingDigest();\n        hybridDigest = TDigest.createHybridDigest(COMPRESSION);\n        samples = new double[SAMPLE_COUNT];\n\n        for (int i = 0; i < SAMPLE_COUNT; i++) {\n            samples[i] = sampleGenerator.get();"}
{"magic_number_smell": "     */\n    @Deprecated\n    public static XContentType xContentType(CharSequence content) {\n        int length = content.length() < 20 ? content.length() : 20;\n        if (length == 0) {\n            return null;\n        }", "refactored_code": "    public static final int GUESS_HEADER_LENGTH = 20;\n     */\n    @Deprecated\n    public static XContentType xContentType(CharSequence content) {\n        int length = content.length() < GUESS_HEADER_LENGTH ? content.length() : GUESS_HEADER_LENGTH;\n        if (length == 0) {\n            return null;\n        }"}
{"magic_number_smell": "    }\n\n    public TimeSeriesAggregationBuilder(String name) {\n        this(name, true, MultiBucketConsumerService.DEFAULT_MAX_BUCKETS);\n    }\n\n    public TimeSeriesAggregationBuilder(String name, Boolean keyed) {", "refactored_code": "    private static final int DEFAULT_SIZE = MultiBucketConsumerService.DEFAULT_MAX_BUCKETS;\n    }\n\n    public TimeSeriesAggregationBuilder(String name) {\n        this(name, true, DEFAULT_SIZE);\n    }\n\n    public TimeSeriesAggregationBuilder(String name, Boolean keyed) {"}
{"magic_number_smell": "\npublic abstract class BaseMatrixStatsTestCase extends ESTestCase {\n    protected final int atLeast(10000) = atLeast(10000);\n    protected final ArrayList<Double> fieldA = new ArrayList<>(atLeast(10000));\n    protected final ArrayList<Double> fieldB = new ArrayList<>(atLeast(10000));\n    protected final MultiPassStats actualStats = new MultiPassStats(fieldAKey, fieldBKey);\n    protected static final String fieldAKey = \"fieldA\";", "refactored_code": "    protected final int numObs = atLeast(10000);\n\npublic abstract class BaseMatrixStatsTestCase extends ESTestCase {\n    protected final int numObs = atLeast(10000);\n    protected final ArrayList<Double> fieldA = new ArrayList<>(numObs);\n    protected final ArrayList<Double> fieldB = new ArrayList<>(numObs);\n    protected final MultiPassStats actualStats = new MultiPassStats(fieldAKey, fieldBKey);\n    protected static final String fieldAKey = \"fieldA\";"}
{"magic_number_smell": "\n    static int parseSide(String side) {\n        return switch (side) {\n            case \"front\" -> 1;\n            case \"back\" -> SIDE_BACK;\n            default -> throw new IllegalArgumentException(\"invalid side: \" + side);\n        };", "refactored_code": "    public static final int SIDE_FRONT = 1;\n\n    static int parseSide(String side) {\n        return switch (side) {\n            case \"front\" -> SIDE_FRONT;\n            case \"back\" -> SIDE_BACK;\n            default -> throw new IllegalArgumentException(\"invalid side: \" + side);\n        };"}
{"magic_number_smell": "    private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);\n    private final OffsetAttribute offsetAtt = addAttribute(OffsetAttribute.class);\n\n    private final CharacterUtils.CharacterBuffer ioBuffer = CharacterUtils.newCharacterBuffer(4096);\n\n    @Override\n    public final boolean incrementToken() throws IOException {", "refactored_code": "    private static final int IO_BUFFER_SIZE = 4096;\n    private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);\n    private final OffsetAttribute offsetAtt = addAttribute(OffsetAttribute.class);\n\n    private final CharacterUtils.CharacterBuffer ioBuffer = CharacterUtils.newCharacterBuffer(IO_BUFFER_SIZE);\n\n    @Override\n    public final boolean incrementToken() throws IOException {"}
{"magic_number_smell": "            ElasticsearchException.generateThrowableXContent(builder, EMPTY_PARAMS, e);\n            return builder;\n        });\n        String newError = Strings.substring(exceptionToString, 0, 1000);\n        ErrorEntry existingError = indexNameToError.get(indexName);\n        long recordedTimestamp = nowSupplier.getAsLong();\n        if (existingError == null) {", "refactored_code": "    public static final int MAX_ERROR_MESSAGE_LENGTH = 1000;\n            ElasticsearchException.generateThrowableXContent(builder, EMPTY_PARAMS, e);\n            return builder;\n        });\n        String newError = Strings.substring(exceptionToString, 0, MAX_ERROR_MESSAGE_LENGTH);\n        ErrorEntry existingError = indexNameToError.get(indexName);\n        long recordedTimestamp = nowSupplier.getAsLong();\n        if (existingError == null) {"}
{"magic_number_smell": "\n    public static final Setting<Integer> DATA_STREAM_MERGE_POLICY_TARGET_FACTOR_SETTING = Setting.intSetting(\n        \"data_streams.lifecycle.target.merge.policy.merge_factor\",\n        16,\n        2,\n        Setting.Property.Dynamic,\n        Setting.Property.NodeScope", "refactored_code": "    public static final int TARGET_MERGE_FACTOR_VALUE = 16;\n\n    public static final Setting<Integer> DATA_STREAM_MERGE_POLICY_TARGET_FACTOR_SETTING = Setting.intSetting(\n        \"data_streams.lifecycle.target.merge.policy.merge_factor\",\n        TARGET_MERGE_FACTOR_VALUE,\n        2,\n        Setting.Property.Dynamic,\n        Setting.Property.NodeScope"}
{"magic_number_smell": "            String resourceName = readOptionalStringProperty(TYPE, processorTag, config, \"resource_name\");\n            String targetField = readStringProperty(TYPE, processorTag, config, \"target_field\", \"attachment\");\n            List<String> propertyNames = readOptionalList(TYPE, processorTag, config, \"properties\");\n            int indexedChars = readIntProperty(TYPE, processorTag, config, \"indexed_chars\", 100000);\n            boolean ignoreMissing = readBooleanProperty(TYPE, processorTag, config, \"ignore_missing\", false);\n            String indexedCharsField = readOptionalStringProperty(TYPE, processorTag, config, \"indexed_chars_field\");\n            @UpdateForV9 // update the [remove_binary] default to be 'true' assuming enough time has passed. Deprecated in September 2022.", "refactored_code": "    private static final int NUMBER_OF_CHARS_INDEXED = 100000;\n            String resourceName = readOptionalStringProperty(TYPE, processorTag, config, \"resource_name\");\n            String targetField = readStringProperty(TYPE, processorTag, config, \"target_field\", \"attachment\");\n            List<String> propertyNames = readOptionalList(TYPE, processorTag, config, \"properties\");\n            int indexedChars = readIntProperty(TYPE, processorTag, config, \"indexed_chars\", NUMBER_OF_CHARS_INDEXED);\n            boolean ignoreMissing = readBooleanProperty(TYPE, processorTag, config, \"ignore_missing\", false);\n            String indexedCharsField = readOptionalStringProperty(TYPE, processorTag, config, \"indexed_chars_field\");\n            @UpdateForV9 // update the [remove_binary] default to be 'true' assuming enough time has passed. Deprecated in September 2022."}
{"magic_number_smell": "        assertThat(results.size(), equalTo(1));\n        assertThat(results.get(0), instanceOf(SimulateDocumentVerboseResult.class));\n        SimulateDocumentVerboseResult result = (SimulateDocumentVerboseResult) results.get(0);\n        assertThat(result.getProcessorResults().size(), equalTo(randomIntBetween(2, 50)));\n        List<SimulateProcessorResult> simulateProcessorResults = result.getProcessorResults();\n        SimulateProcessorResult lastResult = simulateProcessorResults.get(simulateProcessorResults.size() - 1);\n        IngestDocument resultDoc = lastResult.getIngestDocument();", "refactored_code": "    private final int manyPipelinesCount = randomIntBetween(2, 50);\n        assertThat(results.size(), equalTo(1));\n        assertThat(results.get(0), instanceOf(SimulateDocumentVerboseResult.class));\n        SimulateDocumentVerboseResult result = (SimulateDocumentVerboseResult) results.get(0);\n        assertThat(result.getProcessorResults().size(), equalTo(manyPipelinesCount));\n        List<SimulateProcessorResult> simulateProcessorResults = result.getProcessorResults();\n        SimulateProcessorResult lastResult = simulateProcessorResults.get(simulateProcessorResults.size() - 1);\n        IngestDocument resultDoc = lastResult.getIngestDocument();"}
{"magic_number_smell": "                return null;\n            }\n            s = s.toLowerCase(Locale.ROOT);\n            s = s.substring(0, Math.min(s.length(), 100));\n            return disallowedInDataset.matcher(s).replaceAll(REPLACEMENT);\n        }\n", "refactored_code": "        private static final int MAX_LENGTH = 100;\n                return null;\n            }\n            s = s.toLowerCase(Locale.ROOT);\n            s = s.substring(0, Math.min(s.length(), MAX_LENGTH));\n            return disallowedInDataset.matcher(s).replaceAll(REPLACEMENT);\n        }\n"}
{"magic_number_smell": "                .startObject(SINGLE_MAPPING_NAME)\n                .startObject(\"_meta\")\n                .field(\"version\", LEGACY_VERSION_FIELD_VALUE)\n                .field(SystemIndexDescriptor.VERSION_META_KEY, 1)\n                .endObject()\n                .field(\"dynamic\", \"strict\")\n                .startObject(\"properties\")", "refactored_code": "    private static final int GEOIP_INDEX_MAPPINGS_VERSION = 1;\n                .startObject(SINGLE_MAPPING_NAME)\n                .startObject(\"_meta\")\n                .field(\"version\", LEGACY_VERSION_FIELD_VALUE)\n                .field(SystemIndexDescriptor.VERSION_META_KEY, GEOIP_INDEX_MAPPINGS_VERSION)\n                .endObject()\n                .field(\"dynamic\", \"strict\")\n                .startObject(\"properties\")"}
{"magic_number_smell": "\n        @Override\n        public String toString() {\n            return List.of(1, publicField, getPrivateMethod(), getPublicMethod()).toString();\n        }\n    }\n", "refactored_code": "        private final int privateField = 1;\n\n        @Override\n        public String toString() {\n            return List.of(privateField, publicField, getPrivateMethod(), getPublicMethod()).toString();\n        }\n    }\n"}
{"magic_number_smell": "         */\n        private MethodHandle lookup(int flavorValue, String nameValue, Class<?> receiver) throws Throwable {\n            return switch (flavorValue) {\n                case 0 -> Def.lookupMethod(\n                    painlessLookup,\n                    functions,\n                    constants,", "refactored_code": "    public static final int METHOD_CALL = 0;\n         */\n        private MethodHandle lookup(int flavorValue, String nameValue, Class<?> receiver) throws Throwable {\n            return switch (flavorValue) {\n                case METHOD_CALL -> Def.lookupMethod(\n                    painlessLookup,\n                    functions,\n                    constants,"}
{"magic_number_smell": "        }\n\n        // truncate to our limit\n        limit = Math.min(limit, 256);\n        fileName.append(scriptName, 0, limit);\n\n        // if we truncated, make it obvious", "refactored_code": "    private static final int MAX_NAME_LENGTH = 256;\n        }\n\n        // truncate to our limit\n        limit = Math.min(limit, MAX_NAME_LENGTH);\n        fileName.append(scriptName, 0, limit);\n\n        // if we truncated, make it obvious"}
{"magic_number_smell": "\n    // Regular Expression Pattern augmentations with limit factor injected\n    public static String[] split(Pattern receiver, int limitFactor, CharSequence input) {\n        if (limitFactor == 0) {\n            return receiver.split(input);\n        }\n        return receiver.split(new LimitedCharSequence(input, receiver, limitFactor));", "refactored_code": "    public static final int UNLIMITED_PATTERN_FACTOR = 0;\n\n    // Regular Expression Pattern augmentations with limit factor injected\n    public static String[] split(Pattern receiver, int limitFactor, CharSequence input) {\n        if (limitFactor == UNLIMITED_PATTERN_FACTOR) {\n            return receiver.split(input);\n        }\n        return receiver.split(new LimitedCharSequence(input, receiver, limitFactor));"}
{"magic_number_smell": "            + counter.count\n            + \"], \"\n            + \"wrapped: [\"\n            + snippet(64)\n            + \"]\";\n    }\n", "refactored_code": "    public static final int MAX_STR_LENGTH = 64;\n            + counter.count\n            + \"], \"\n            + \"wrapped: [\"\n            + snippet(MAX_STR_LENGTH)\n            + \"]\";\n    }\n"}
{"magic_number_smell": "        public static int defaultTreeLevel(String tree) {\n            return switch (tree) {\n                case PrefixTrees.GEOHASH -> GEOHASH_TREE_LEVELS;\n                case PrefixTrees.LEGACY_QUADTREE, PrefixTrees.QUADTREE -> GeoUtils.quadTreeLevelsForPrecision(PRECISION);\n                default -> throw new IllegalArgumentException(\"Unknown prefix type [\" + tree + \"]\");\n            };\n        }", "refactored_code": "        public static final int QUADTREE_LEVELS = GeoUtils.quadTreeLevelsForPrecision(PRECISION);\n        public static int defaultTreeLevel(String tree) {\n            return switch (tree) {\n                case PrefixTrees.GEOHASH -> GEOHASH_TREE_LEVELS;\n                case PrefixTrees.LEGACY_QUADTREE, PrefixTrees.QUADTREE -> QUADTREE_LEVELS;\n                default -> throw new IllegalArgumentException(\"Unknown prefix type [\" + tree + \"]\");\n            };\n        }"}
{"magic_number_smell": "     * Test that creates new shape from a random test shape and checks both for equality\n     */\n    public void testFromXContent() throws IOException {\n        for (int runs = 0; runs < 20; runs++) {\n            SB testShape = createTestShapeBuilder();\n            XContentBuilder contentBuilder = XContentFactory.contentBuilder(randomFrom(XContentType.values()));\n            if (randomBoolean()) {", "refactored_code": "    private static final int NUMBER_OF_TESTBUILDERS = 20;\n     * Test that creates new shape from a random test shape and checks both for equality\n     */\n    public void testFromXContent() throws IOException {\n        for (int runs = 0; runs < NUMBER_OF_TESTBUILDERS; runs++) {\n            SB testShape = createTestShapeBuilder();\n            XContentBuilder contentBuilder = XContentFactory.contentBuilder(randomFrom(XContentType.values()));\n            if (randomBoolean()) {"}
{"magic_number_smell": "    }\n\n    private static double xDivisible(double v) {\n        return xDivisible(v, 2);\n    }\n\n    protected static Rectangle xMakeNormRect(double minX, double maxX, double minY, double maxY) {", "refactored_code": "    protected static final double xDIVISIBLE = 2;\n    }\n\n    private static double xDivisible(double v) {\n        return xDivisible(v, xDIVISIBLE);\n    }\n\n    protected static Rectangle xMakeNormRect(double minX, double maxX, double minY, double maxY) {"}
{"magic_number_smell": "            m -> builder(m).maxShingleSize.get(),\n            Defaults.MAX_SHINGLE_SIZE\n        ).addValidator(v -> {\n            if (v < 2 || v > MAX_SHINGLE_SIZE_UPPER_BOUND) {\n                throw new MapperParsingException(\n                    \"[max_shingle_size] must be at least [\"\n                        + 2", "refactored_code": "    private static final int MAX_SHINGLE_SIZE_LOWER_BOUND = 2;\n            m -> builder(m).maxShingleSize.get(),\n            Defaults.MAX_SHINGLE_SIZE\n        ).addValidator(v -> {\n            if (v < MAX_SHINGLE_SIZE_LOWER_BOUND || v > MAX_SHINGLE_SIZE_UPPER_BOUND) {\n                throw new MapperParsingException(\n                    \"[max_shingle_size] must be at least [\"\n                        + MAX_SHINGLE_SIZE_LOWER_BOUND"}
{"magic_number_smell": "        }\n\n        private double round(double d) {\n            long encoded = Math.round(d * randomDoubleBetween(0, Double.MAX_VALUE, false));\n            double decoded = encoded / randomDoubleBetween(0, Double.MAX_VALUE, false);\n            long reencoded = Math.round(decoded * randomDoubleBetween(0, Double.MAX_VALUE, false));\n            if (encoded != reencoded) {", "refactored_code": "        private final double scalingFactor = randomDoubleBetween(0, Double.MAX_VALUE, false);\n        }\n\n        private double round(double d) {\n            long encoded = Math.round(d * scalingFactor);\n            double decoded = encoded / scalingFactor;\n            long reencoded = Math.round(decoded * scalingFactor);\n            if (encoded != reencoded) {"}
{"magic_number_smell": "    private final ScoreMode scoreMode;\n    private InnerHitBuilder innerHitBuilder;\n    private int minChildren = DEFAULT_MIN_CHILDREN;\n    private int maxChildren = Integer.MAX_VALUE;\n    private boolean ignoreUnmapped = DEFAULT_IGNORE_UNMAPPED;\n\n    public HasChildQueryBuilder(String type, QueryBuilder query, ScoreMode scoreMode) {", "refactored_code": "    public static final int DEFAULT_MAX_CHILDREN = Integer.MAX_VALUE;\n    private final ScoreMode scoreMode;\n    private InnerHitBuilder innerHitBuilder;\n    private int minChildren = DEFAULT_MIN_CHILDREN;\n    private int maxChildren = DEFAULT_MAX_CHILDREN;\n    private boolean ignoreUnmapped = DEFAULT_IGNORE_UNMAPPED;\n\n    public HasChildQueryBuilder(String type, QueryBuilder query, ScoreMode scoreMode) {"}
{"magic_number_smell": "    private static final FieldType TYPE;\n    static {\n        TYPE = new FieldType();\n        TYPE.setDimensions(2, InetAddressPoint.BYTES);\n        TYPE.freeze();\n    }\n", "refactored_code": "    public static final int BYTES = InetAddressPoint.BYTES;\n    private static final FieldType TYPE;\n    static {\n        TYPE = new FieldType();\n        TYPE.setDimensions(2, BYTES);\n        TYPE.freeze();\n    }\n"}
{"magic_number_smell": "\n                @Override\n                public float matchCost() {\n                    return 1000;\n                }\n            };\n        }", "refactored_code": "    private static final float MATCH_COST = 1000;\n\n                @Override\n                public float matchCost() {\n                    return MATCH_COST;\n                }\n            };\n        }"}
{"magic_number_smell": "                    if (id.equals(\"1\") || id.equals(\"6\")) {\n                        assertFalse(hit.getRating().isPresent());\n                    } else {\n                        assertEquals(1, hit.getRating().getAsInt());\n                    }\n                }\n            }", "refactored_code": "    private static final int RELEVANT_RATING_1 = 1;\n                    if (id.equals(\"1\") || id.equals(\"6\")) {\n                        assertFalse(hit.getRating().isPresent());\n                    } else {\n                        assertEquals(RELEVANT_RATING_1, hit.getRating().getAsInt());\n                    }\n                }\n            }"}
{"magic_number_smell": "    private static final double LOG2 = Math.log(2.0);\n\n    public DiscountedCumulativeGain() {\n        this(false, null, 10);\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_K = 10;\n    private static final double LOG2 = Math.log(2.0);\n\n    public DiscountedCumulativeGain() {\n        this(false, null, DEFAULT_K);\n    }\n\n    /**"}
{"magic_number_smell": "     * @param maxRelevance the highest expected relevance in the data\n     */\n    public ExpectedReciprocalRank(int maxRelevance) {\n        this(maxRelevance, null, 10);\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_K = 10;\n     * @param maxRelevance the highest expected relevance in the data\n     */\n    public ExpectedReciprocalRank(int maxRelevance) {\n        this(maxRelevance, null, DEFAULT_K);\n    }\n\n    /**"}
{"magic_number_smell": "    private final int relevantRatingThreshhold;\n\n    public MeanReciprocalRank() {\n        this(1, DEFAULT_K);\n    }\n\n    MeanReciprocalRank(StreamInput in) throws IOException {", "refactored_code": "    private static final int DEFAULT_RATING_THRESHOLD = 1;\n    private final int relevantRatingThreshhold;\n\n    public MeanReciprocalRank() {\n        this(DEFAULT_RATING_THRESHOLD, DEFAULT_K);\n    }\n\n    MeanReciprocalRank(StreamInput in) throws IOException {"}
{"magic_number_smell": "    }\n\n    public PrecisionAtK(boolean ignoreUnlabeled) {\n        this(1, ignoreUnlabeled, DEFAULT_K);\n    }\n\n    public PrecisionAtK() {", "refactored_code": "    private static final int DEFAULT_RELEVANT_RATING_THRESHOLD = 1;\n    }\n\n    public PrecisionAtK(boolean ignoreUnlabeled) {\n        this(DEFAULT_RELEVANT_RATING_THRESHOLD, ignoreUnlabeled, DEFAULT_K);\n    }\n\n    public PrecisionAtK() {"}
{"magic_number_smell": "    }\n\n    public RecallAtK() {\n        this(1, DEFAULT_K);\n    }\n\n    RecallAtK(StreamInput in) throws IOException {", "refactored_code": "    private static final int DEFAULT_RELEVANT_RATING_THRESHOLD = 1;\n    }\n\n    public RecallAtK() {\n        this(DEFAULT_RELEVANT_RATING_THRESHOLD, DEFAULT_K);\n    }\n\n    RecallAtK(StreamInput in) throws IOException {"}
{"magic_number_smell": "            hits[i].shard(new SearchShardTarget(\"testnode\", new ShardId(\"index\", \"uuid\", 0), null));\n        }\n        DiscountedCumulativeGain dcg = new DiscountedCumulativeGain();\n        assertEquals(EXPECTED_DCG, dcg.evaluate(\"id\", hits, rated).metricScore(), 10E-14);\n\n        /**\n         * Check with normalization: to get the maximal possible dcg, sort documents by", "refactored_code": "    private static final double DELTA = 10E-14;\n            hits[i].shard(new SearchShardTarget(\"testnode\", new ShardId(\"index\", \"uuid\", 0), null));\n        }\n        DiscountedCumulativeGain dcg = new DiscountedCumulativeGain();\n        assertEquals(EXPECTED_DCG, dcg.evaluate(\"id\", hits, rated).metricScore(), DELTA);\n\n        /**\n         * Check with normalization: to get the maximal possible dcg, sort documents by"}
{"magic_number_smell": "        Integer[] relevanceRatings = new Integer[] { 3, 2, 0, 1 };\n        SearchHit[] hits = createSearchHits(rated, relevanceRatings);\n        ExpectedReciprocalRank err = new ExpectedReciprocalRank(3, 0, 3);\n        assertEquals(0.8984375, err.evaluate(\"id\", hits, rated).metricScore(), 10E-14);\n        // take 4th rank into window\n        err = new ExpectedReciprocalRank(3, 0, 4);\n        assertEquals(0.8984375 + 0.00244140625, err.evaluate(\"id\", hits, rated).metricScore(), 10E-14);", "refactored_code": "    private static final double DELTA = 10E-14;\n        Integer[] relevanceRatings = new Integer[] { 3, 2, 0, 1 };\n        SearchHit[] hits = createSearchHits(rated, relevanceRatings);\n        ExpectedReciprocalRank err = new ExpectedReciprocalRank(3, 0, 3);\n        assertEquals(0.8984375, err.evaluate(\"id\", hits, rated).metricScore(), DELTA);\n        // take 4th rank into window\n        err = new ExpectedReciprocalRank(3, 0, 4);\n        assertEquals(0.8984375 + 0.00244140625, err.evaluate(\"id\", hits, rated).metricScore(), DELTA);"}
{"magic_number_smell": "            if (i == relevantAt) {\n                ratedDocs.add(new RatedDocument(\"test\", Integer.toString(i), RELEVANT_RATING_1));\n            } else {\n                ratedDocs.add(new RatedDocument(\"test\", Integer.toString(i), 0));\n            }\n        }\n", "refactored_code": "    private static final int IRRELEVANT_RATING_0 = 0;\n            if (i == relevantAt) {\n                ratedDocs.add(new RatedDocument(\"test\", Integer.toString(i), RELEVANT_RATING_1));\n            } else {\n                ratedDocs.add(new RatedDocument(\"test\", Integer.toString(i), IRRELEVANT_RATING_0));\n            }\n        }\n"}
{"magic_number_smell": "        rated.add(createRatedDoc(\"test\", \"1\", RELEVANT_RATING));\n        rated.add(createRatedDoc(\"test\", \"2\", RELEVANT_RATING));\n        rated.add(createRatedDoc(\"test\", \"3\", RELEVANT_RATING));\n        rated.add(createRatedDoc(\"test\", \"4\", 0));\n        EvalQueryQuality evaluated = (new PrecisionAtK()).evaluate(\"id\", toSearchHits(rated, \"test\"), rated);\n        assertEquals((double) 4 / 5, evaluated.metricScore(), 0.00001);\n        assertEquals(4, ((PrecisionAtK.Detail) evaluated.getMetricDetails()).getRelevantRetrieved());", "refactored_code": "    private static final int IRRELEVANT_RATING = 0;\n        rated.add(createRatedDoc(\"test\", \"1\", RELEVANT_RATING));\n        rated.add(createRatedDoc(\"test\", \"2\", RELEVANT_RATING));\n        rated.add(createRatedDoc(\"test\", \"3\", RELEVANT_RATING));\n        rated.add(createRatedDoc(\"test\", \"4\", IRRELEVANT_RATING));\n        EvalQueryQuality evaluated = (new PrecisionAtK()).evaluate(\"id\", toSearchHits(rated, \"test\"), rated);\n        assertEquals((double) 4 / 5, evaluated.metricScore(), 0.00001);\n        assertEquals(4, ((PrecisionAtK.Detail) evaluated.getMetricDetails()).getRelevantRetrieved());"}
{"magic_number_smell": "        rated.add(createRatedDoc(\"test\", \"1\", RELEVANT_RATING));\n        rated.add(createRatedDoc(\"test\", \"2\", RELEVANT_RATING));\n        rated.add(createRatedDoc(\"test\", \"3\", RELEVANT_RATING));\n        rated.add(createRatedDoc(\"test\", \"4\", 0));\n\n        EvalQueryQuality evaluated = (new RecallAtK()).evaluate(\"id\", toSearchHits(rated, \"test\"), rated);\n        assertEquals((double) 4 / 4, evaluated.metricScore(), 0.00001);", "refactored_code": "    private static final int IRRELEVANT_RATING = 0;\n        rated.add(createRatedDoc(\"test\", \"1\", RELEVANT_RATING));\n        rated.add(createRatedDoc(\"test\", \"2\", RELEVANT_RATING));\n        rated.add(createRatedDoc(\"test\", \"3\", RELEVANT_RATING));\n        rated.add(createRatedDoc(\"test\", \"4\", IRRELEVANT_RATING));\n\n        EvalQueryQuality evaluated = (new RecallAtK()).evaluate(\"id\", toSearchHits(rated, \"test\"), rated);\n        assertEquals((double) 4 / 4, evaluated.metricScore(), 0.00001);"}
{"magic_number_smell": "    @Before\n    public void setupTestIndex() throws IOException {\n        StringBuilder bulk = new StringBuilder();\n        for (int i = 0; i < between(150, 2000); i++) {\n            bulk.append(\"{\\\"index\\\":{}}\\n\");\n            bulk.append(\"{\\\"test\\\":\\\"test\\\"}\\n\");\n        }", "refactored_code": "    private final int count = between(150, 2000);\n    @Before\n    public void setupTestIndex() throws IOException {\n        StringBuilder bulk = new StringBuilder();\n        for (int i = 0; i < count; i++) {\n            bulk.append(\"{\\\"index\\\":{}}\\n\");\n            bulk.append(\"{\\\"test\\\":\\\"test\\\"}\\n\");\n        }"}
{"magic_number_smell": "                createIndex.setJsonEntity(\"{\\\"settings\\\":{\\\"number_of_shards\\\": 1}}\");\n                oldEs.performRequest(createIndex);\n\n                for (int i = 0; i < 5; i++) {\n                    Request doc = new Request(\"PUT\", \"/test/doc/testdoc\" + i);\n                    doc.addParameter(\"refresh\", \"true\");\n                    doc.setJsonEntity(\"{\\\"test\\\":\\\"test\\\"}\");", "refactored_code": "    private static final int DOCS = 5;\n                createIndex.setJsonEntity(\"{\\\"settings\\\":{\\\"number_of_shards\\\": 1}}\");\n                oldEs.performRequest(createIndex);\n\n                for (int i = 0; i < DOCS; i++) {\n                    Request doc = new Request(\"PUT\", \"/test/doc/testdoc\" + i);\n                    doc.addParameter(\"refresh\", \"true\");\n                    doc.setJsonEntity(\"{\\\"test\\\":\\\"test\\\"}\");"}
{"magic_number_smell": "    public void testExternalVersioningCreatesWhenAbsentAndSetsVersion() throws Exception {\n        setupSourceAbsent();\n        assertThat(reindexExternal(), matcher().created(1));\n        assertDest(\"source\", 4);\n    }\n\n    public void testExternalVersioningUpdatesOnOlderAndSetsVersion() throws Exception {", "refactored_code": "    private static final int SOURCE_VERSION = 4;\n    public void testExternalVersioningCreatesWhenAbsentAndSetsVersion() throws Exception {\n        setupSourceAbsent();\n        assertThat(reindexExternal(), matcher().created(1));\n        assertDest(\"source\", SOURCE_VERSION);\n    }\n\n    public void testExternalVersioningUpdatesOnOlderAndSetsVersion() throws Exception {"}
{"magic_number_smell": "        testCase(\n            ReindexAction.NAME,\n            client -> new ReindexRequestBuilder(client).source(\"source\").destination(\"dest\"),\n            matcher().created(20)\n        );\n    }\n", "refactored_code": "    private static final int DOC_COUNT = 20;\n        testCase(\n            ReindexAction.NAME,\n            client -> new ReindexRequestBuilder(client).source(\"source\").destination(\"dest\"),\n            matcher().created(DOC_COUNT)\n        );\n    }\n"}
{"magic_number_smell": "        updater.start();\n\n        try {\n            for (int i = 0; i < 50; i++) {\n                GetResponse get = client().prepareGet(\"test\", \"test\").get();\n                assertEquals(value.get(), get.getSource().get(\"test\"));\n                value.set(randomSimpleString(random()));", "refactored_code": "    private static final int MAX_MUTATIONS = 50;\n        updater.start();\n\n        try {\n            for (int i = 0; i < MAX_MUTATIONS; i++) {\n                GetResponse get = client().prepareGet(\"test\", \"test\").get();\n                assertEquals(value.get(), get.getSource().get(\"test\"));\n                value.set(randomSimpleString(random()));"}
{"magic_number_smell": "    }\n\n    public long getReadChunkSize() {\n        return new ByteSizeValue(32, ByteSizeUnit.MB).getBytes();\n    }\n\n    @Override", "refactored_code": "    private static final long DEFAULT_READ_CHUNK_SIZE = new ByteSizeValue(32, ByteSizeUnit.MB).getBytes();\n    }\n\n    public long getReadChunkSize() {\n        return DEFAULT_READ_CHUNK_SIZE;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    static final Setting<Integer> MAX_OPEN_CONNECTIONS = Setting.intSetting(\n        \"repository.azure.http_client.max_open_connections\",\n        50,\n        1,\n        Setting.Property.NodeScope\n    );", "refactored_code": "    private static final int DEFAULT_MAX_CONNECTIONS = 50;\n\n    static final Setting<Integer> MAX_OPEN_CONNECTIONS = Setting.intSetting(\n        \"repository.azure.http_client.max_open_connections\",\n        DEFAULT_MAX_CONNECTIONS,\n        1,\n        Setting.Property.NodeScope\n    );"}
{"magic_number_smell": "     * The maximum size of a Block Blob.\n     * See https://docs.microsoft.com/en-us/rest/api/storageservices/understanding-block-blobs--append-blobs--and-page-blobs\n     */\n    public static final long MAX_BLOB_SIZE = 50000 * DEFAULT_BLOCK_SIZE.getBytes();\n\n    /**\n     * Maximum allowed blob size in Azure blob store.", "refactored_code": "    public static final long MAX_BLOCK_NUMBER = 50000;\n     * The maximum size of a Block Blob.\n     * See https://docs.microsoft.com/en-us/rest/api/storageservices/understanding-block-blobs--append-blobs--and-page-blobs\n     */\n    public static final long MAX_BLOB_SIZE = MAX_BLOCK_NUMBER * DEFAULT_BLOCK_SIZE.getBytes();\n\n    /**\n     * Maximum allowed blob size in Azure blob store."}
{"magic_number_smell": "    public static final AffixSetting<Integer> MAX_RETRIES_SETTING = Setting.affixKeySetting(\n        AZURE_CLIENT_PREFIX_KEY,\n        \"max_retries\",\n        (key) -> Setting.intSetting(key, 3, Setting.Property.NodeScope),\n        () -> ACCOUNT_SETTING\n    );\n    /**", "refactored_code": "    public static final int DEFAULT_MAX_RETRIES = 3;\n    public static final AffixSetting<Integer> MAX_RETRIES_SETTING = Setting.affixKeySetting(\n        AZURE_CLIENT_PREFIX_KEY,\n        \"max_retries\",\n        (key) -> Setting.intSetting(key, DEFAULT_MAX_RETRIES, Setting.Property.NodeScope),\n        () -> ACCOUNT_SETTING\n    );\n    /**"}
{"magic_number_smell": "    protected static Tuple<Long, Long> getRanges(HttpExchange exchange) {\n        final String rangeHeader = exchange.getRequestHeaders().getFirst(\"X-ms-range\");\n        if (rangeHeader == null) {\n            return Tuple.tuple(0L, Long.MAX_VALUE - 1L);\n        }\n\n        final Matcher matcher = RANGE_PATTERN.matcher(rangeHeader);", "refactored_code": "    protected static final long MAX_RANGE_VAL = Long.MAX_VALUE - 1L;\n    protected static Tuple<Long, Long> getRanges(HttpExchange exchange) {\n        final String rangeHeader = exchange.getRequestHeaders().getFirst(\"X-ms-range\");\n        if (rangeHeader == null) {\n            return Tuple.tuple(0L, MAX_RANGE_VAL);\n        }\n\n        final Matcher matcher = RANGE_PATTERN.matcher(rangeHeader);"}
{"magic_number_smell": "                        }\n                    });\n                    pendingDeletesInBatch++;\n                    if (pendingDeletesInBatch % 1000 == 0) {\n                        batch.submit();\n                        batch = client().batch();\n                        pendingDeletesInBatch = 0;", "refactored_code": "    public static final int MAX_DELETES_PER_BATCH = 1000;\n                        }\n                    });\n                    pendingDeletesInBatch++;\n                    if (pendingDeletesInBatch % MAX_DELETES_PER_BATCH == 0) {\n                        batch.submit();\n                        batch = client().batch();\n                        pendingDeletesInBatch = 0;"}
{"magic_number_smell": "            SocketAccess.doPrivilegedVoid(() -> {\n                blobNames.forEachRemaining(key -> {\n                    partition.add(key);\n                    if (partition.size() == 1000) {\n                        deletePartition(purpose, clientReference, partition, aex);\n                        partition.clear();\n                    }", "refactored_code": "    private static final int MAX_BULK_DELETES = 1000;\n            SocketAccess.doPrivilegedVoid(() -> {\n                blobNames.forEachRemaining(key -> {\n                    partition.add(key);\n                    if (partition.size() == MAX_BULK_DELETES) {\n                        deletePartition(purpose, clientReference, partition, aex);\n                        partition.clear();\n                    }"}
{"magic_number_smell": "\n    private void accumulateFailure(Exception e) {\n        if (failures == null) {\n            failures = new ArrayList<>(10);\n        }\n        if (failures.size() < 10) {\n            failures.add(e);", "refactored_code": "    public static final int MAX_SUPPRESSED_EXCEPTIONS = 10;\n\n    private void accumulateFailure(Exception e) {\n        if (failures == null) {\n            failures = new ArrayList<>(MAX_SUPPRESSED_EXCEPTIONS);\n        }\n        if (failures.size() < MAX_SUPPRESSED_EXCEPTIONS) {\n            failures.add(e);"}
{"magic_number_smell": "\n    private static void handleInvalidResponse(CloseableHttpResponse response) {\n        int statusCode = response.getStatusLine().getStatusCode();\n        String errorBody = parseBodyAsString(response, 1024);\n        throw new URLHttpClientException(statusCode, createErrorMessage(statusCode, errorBody));\n    }\n", "refactored_code": "    public static final int MAX_ERROR_MESSAGE_BODY_SIZE = 1024;\n\n    private static void handleInvalidResponse(CloseableHttpResponse response) {\n        int statusCode = response.getStatusLine().getStatusCode();\n        String errorBody = parseBodyAsString(response, MAX_ERROR_MESSAGE_BODY_SIZE);\n        throw new URLHttpClientException(statusCode, createErrorMessage(statusCode, errorBody));\n    }\n"}
{"magic_number_smell": "\n    static final Setting<Integer> HTTP_MAX_RETRIES_SETTING = Setting.intSetting(\n        \"http_max_retries\",\n        URLHttpClientSettings.5,\n        0,\n        Integer.MAX_VALUE\n    );", "refactored_code": "    public static final int DEFAULT_MAX_RETRIES = 5;\n\n    static final Setting<Integer> HTTP_MAX_RETRIES_SETTING = Setting.intSetting(\n        \"http_max_retries\",\n        URLHttpClientSettings.DEFAULT_MAX_RETRIES,\n        0,\n        Integer.MAX_VALUE\n    );"}
{"magic_number_smell": "    protected Settings nodeSettings(int nodeOrdinal, Settings otherSettings) {\n        return Settings.builder()\n            .put(super.nodeSettings(nodeOrdinal, otherSettings))\n            .put(SETTING_PIPELINING_MAX_EVENTS.getKey(), 10)\n            .build();\n    }\n", "refactored_code": "    private static final int MAX_PIPELINE_EVENTS = 10;\n    protected Settings nodeSettings(int nodeOrdinal, Settings otherSettings) {\n        return Settings.builder()\n            .put(super.nodeSettings(nodeOrdinal, otherSettings))\n            .put(SETTING_PIPELINING_MAX_EVENTS.getKey(), MAX_PIPELINE_EVENTS)\n            .build();\n    }\n"}
{"magic_number_smell": "    @Override\n    protected Settings nodeSettings(int nodeOrdinal, Settings otherSettings) {\n        if (randomPort == -1) {\n            randomPort = randomIntBetween(49152, 65535 - Constants.WINDOWS ? 300 : 10);\n            randomPortRange = Strings.format(\"%s-%s\", randomPort, randomPort + Constants.WINDOWS ? 300 : 10);\n        }\n        Settings.Builder builder = Settings.builder()", "refactored_code": "    private static final int NUMBER_OF_CLIENT_PORTS = Constants.WINDOWS ? 300 : 10;\n    @Override\n    protected Settings nodeSettings(int nodeOrdinal, Settings otherSettings) {\n        if (randomPort == -1) {\n            randomPort = randomIntBetween(49152, 65535 - NUMBER_OF_CLIENT_PORTS);\n            randomPortRange = Strings.format(\"%s-%s\", randomPort, randomPort + NUMBER_OF_CLIENT_PORTS);\n        }\n        Settings.Builder builder = Settings.builder()"}
{"magic_number_smell": "        assert Transports.assertTransportThread();\n        if (ctx.channel().isWritable() && currentWrite == null && queuedWrites.isEmpty()) {\n            // nothing is queued for writing and the channel is writable, just pass the write down the pipeline directly\n            if (buf.readableBytes() > 1 << 18) {\n                writeInSlices(ctx, promise, buf);\n            } else {\n                ctx.write(buf, promise);", "refactored_code": "    public static final int MAX_BYTES_PER_WRITE = 1 << 18;\n        assert Transports.assertTransportThread();\n        if (ctx.channel().isWritable() && currentWrite == null && queuedWrites.isEmpty()) {\n            // nothing is queued for writing and the channel is writable, just pass the write down the pipeline directly\n            if (buf.readableBytes() > MAX_BYTES_PER_WRITE) {\n                writeInSlices(ctx, promise, buf);\n            } else {\n                ctx.write(buf, promise);"}
{"magic_number_smell": "    }\n\n    public void testToChannelBufferWithSlice() throws IOException {\n        BytesReference ref = getRandomizedBytesReference(randomIntBetween(1, 3 * PageCacheRecycler.BYTE_PAGE_SIZE));\n        int sliceOffset = randomIntBetween(0, ref.length());\n        int sliceLength = randomIntBetween(ref.length() - sliceOffset, ref.length() - sliceOffset);\n        BytesReference slice = ref.slice(sliceOffset, sliceLength);", "refactored_code": "    private static final int PAGE_SIZE = PageCacheRecycler.BYTE_PAGE_SIZE;\n    }\n\n    public void testToChannelBufferWithSlice() throws IOException {\n        BytesReference ref = getRandomizedBytesReference(randomIntBetween(1, 3 * PAGE_SIZE));\n        int sliceOffset = randomIntBetween(0, ref.length());\n        int sliceLength = randomIntBetween(ref.length() - sliceOffset, ref.length() - sliceOffset);\n        BytesReference slice = ref.slice(sliceOffset, sliceLength);"}
{"magic_number_smell": "        }\n\n        Integer replicationFactor = repositorySettings.getAsInt(\"replication_factor\", null);\n        if (replicationFactor != null && replicationFactor < 1) {\n            throw new RepositoryException(\n                metadata.name(),\n                \"Value of replication_factor [{}] must be >= {}\",", "refactored_code": "    private static final int MIN_REPLICATION_FACTOR = 1;\n        }\n\n        Integer replicationFactor = repositorySettings.getAsInt(\"replication_factor\", null);\n        if (replicationFactor != null && replicationFactor < MIN_REPLICATION_FACTOR) {\n            throw new RepositoryException(\n                metadata.name(),\n                \"Value of replication_factor [{}] must be >= {}\","}
{"magic_number_smell": "            caCert = getCaCert(installation);\n        }\n\n        while (started == false && timeElapsed < TimeUnit.MINUTES.toMillis(3)) {\n            if (System.currentTimeMillis() - lastRequest > requestInterval) {\n                try {\n", "refactored_code": "    private static final long waitTime = TimeUnit.MINUTES.toMillis(3);\n            caCert = getCaCert(installation);\n        }\n\n        while (started == false && timeElapsed < waitTime) {\n            if (System.currentTimeMillis() - lastRequest > requestInterval) {\n                try {\n"}
{"magic_number_smell": "        do {\n            try {\n                // Give the container enough time for security auto-configuration or a chance to crash out\n                Thread.sleep(1000);\n\n                // Set COLUMNS so that `ps` doesn't truncate its output\n                psOutput = dockerShell.run(\"bash -c 'COLUMNS=2000 ps ax'\").stdout();", "refactored_code": "    public static final int STARTUP_SLEEP_INTERVAL_MILLISECONDS = 1000;\n        do {\n            try {\n                // Give the container enough time for security auto-configuration or a chance to crash out\n                Thread.sleep(STARTUP_SLEEP_INTERVAL_MILLISECONDS);\n\n                // Set COLUMNS so that `ps` doesn't truncate its output\n                psOutput = dockerShell.run(\"bash -c 'COLUMNS=2000 ps ax'\").stdout();"}
{"magic_number_smell": "    }\n\n    private void start() throws Exception {\n        final String command = \"docker run -t --detach --rm -p \" + 1080 + \":\" + 1080 + \" mockserver/mockserver:latest\";\n        this.containerId = this.shell.run(command).stdout().trim();\n\n        // It's a Java app, so give it a chance to wake up. I'd add a healthcheck to the above command,", "refactored_code": "    private static final int CONTAINER_PORT = 1080; // default for image\n    }\n\n    private void start() throws Exception {\n        final String command = \"docker run -t --detach --rm -p \" + CONTAINER_PORT + \":\" + CONTAINER_PORT + \" mockserver/mockserver:latest\";\n        this.containerId = this.shell.run(command).stdout().trim();\n\n        // It's a Java app, so give it a chance to wake up. I'd add a healthcheck to the above command,"}
{"magic_number_smell": "    private static final ElasticsearchCluster cluster = ElasticsearchCluster.local()\n        .distribution(DistributionType.DEFAULT)\n        .version(getOldClusterTestVersion())\n        .nodes(3)\n        .setting(\"path.repo\", new Supplier<>() {\n            @Override\n            @SuppressForbidden(reason = \"TemporaryFolder only has io.File methods, not nio.File\")", "refactored_code": "    private static final int NODE_NUM = 3;\n    private static final ElasticsearchCluster cluster = ElasticsearchCluster.local()\n        .distribution(DistributionType.DEFAULT)\n        .version(getOldClusterTestVersion())\n        .nodes(NODE_NUM)\n        .setting(\"path.repo\", new Supplier<>() {\n            @Override\n            @SuppressForbidden(reason = \"TemporaryFolder only has io.File methods, not nio.File\")"}
{"magic_number_smell": "            (List<SnapshotInfo>) args[0],\n            (Map<String, ElasticsearchException>) args[1],\n            (String) args[2],\n            args[3] == null ? -1 : (int) args[3],\n            args[4] == null ? -1 : (int) args[4]\n        )\n    );", "refactored_code": "    private static final int UNKNOWN_COUNT = -1;\n            (List<SnapshotInfo>) args[0],\n            (Map<String, ElasticsearchException>) args[1],\n            (String) args[2],\n            args[3] == null ? UNKNOWN_COUNT : (int) args[3],\n            args[4] == null ? UNKNOWN_COUNT : (int) args[4]\n        )\n    );"}
{"magic_number_smell": "    protected Settings nodeSettings(int nodeOrdinal, Settings otherSettings) {\n        return Settings.builder()\n            .put(super.nodeSettings(nodeOrdinal, otherSettings))\n            .put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(), new ByteSizeValue(10, ByteSizeUnit.KB).getBytes() * 2 + \"b\")\n            .put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(), new ByteSizeValue(10, ByteSizeUnit.KB).getBytes() * 2 + \"b\")\n            .put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_DISK_FLOOD_STAGE_WATERMARK_SETTING.getKey(), new ByteSizeValue(10, ByteSizeUnit.KB).getBytes() + \"b\")\n            .put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_REROUTE_INTERVAL_SETTING.getKey(), \"0ms\")", "refactored_code": "    private static final long FLOOD_STAGE_BYTES = new ByteSizeValue(10, ByteSizeUnit.KB).getBytes();\n    protected Settings nodeSettings(int nodeOrdinal, Settings otherSettings) {\n        return Settings.builder()\n            .put(super.nodeSettings(nodeOrdinal, otherSettings))\n            .put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(), FLOOD_STAGE_BYTES * 2 + \"b\")\n            .put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(), FLOOD_STAGE_BYTES * 2 + \"b\")\n            .put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_DISK_FLOOD_STAGE_WATERMARK_SETTING.getKey(), FLOOD_STAGE_BYTES + \"b\")\n            .put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_REROUTE_INTERVAL_SETTING.getKey(), \"0ms\")"}
{"magic_number_smell": "    protected Settings nodeSettings(int nodeOrdinal, Settings otherSettings) {\n        return Settings.builder()\n            .put(super.nodeSettings(nodeOrdinal, otherSettings))\n            .put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(), new ByteSizeValue(10, ByteSizeUnit.KB).getBytes() + \"b\")\n            .put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(), new ByteSizeValue(10, ByteSizeUnit.KB).getBytes() + \"b\")\n            .put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_DISK_FLOOD_STAGE_WATERMARK_SETTING.getKey(), \"0b\")\n            .put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_REROUTE_INTERVAL_SETTING.getKey(), \"0ms\")", "refactored_code": "    private static final long WATERMARK_BYTES = new ByteSizeValue(10, ByteSizeUnit.KB).getBytes();\n    protected Settings nodeSettings(int nodeOrdinal, Settings otherSettings) {\n        return Settings.builder()\n            .put(super.nodeSettings(nodeOrdinal, otherSettings))\n            .put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(), WATERMARK_BYTES + \"b\")\n            .put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(), WATERMARK_BYTES + \"b\")\n            .put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_DISK_FLOOD_STAGE_WATERMARK_SETTING.getKey(), \"0b\")\n            .put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_REROUTE_INTERVAL_SETTING.getKey(), \"0ms\")"}
{"magic_number_smell": "\n    @Override\n    public MappingsVersion getMappingsVersion() {\n        return useNewMappings.get() ? new MappingsVersion(1, 0) : new MappingsVersion(OLD_MAPPINGS_VERSION, 0);\n    }\n\n    public static String getOldMappings() {", "refactored_code": "    private static final int NEW_MAPPINGS_VERSION = 1;\n\n    @Override\n    public MappingsVersion getMappingsVersion() {\n        return useNewMappings.get() ? new MappingsVersion(NEW_MAPPINGS_VERSION, 0) : new MappingsVersion(OLD_MAPPINGS_VERSION, 0);\n    }\n\n    public static String getOldMappings() {"}
{"magic_number_smell": "        DiscoveryNode relocationSource = initialState.getNodes()\n            .getDataNodes()\n            .get(initialState.getRoutingTable().shardRoutingTable(\"test\", 0).primaryShard().currentNodeId());\n        for (int i = 0; i < 15; i++) {\n            DiscoveryNode relocationTarget = randomFrom(dataNodes);\n            while (relocationTarget.equals(relocationSource)) {\n                relocationTarget = randomFrom(dataNodes);", "refactored_code": "    private static final int RELOCATION_COUNT = 15;\n        DiscoveryNode relocationSource = initialState.getNodes()\n            .getDataNodes()\n            .get(initialState.getRoutingTable().shardRoutingTable(\"test\", 0).primaryShard().currentNodeId());\n        for (int i = 0; i < RELOCATION_COUNT; i++) {\n            DiscoveryNode relocationTarget = randomFrom(dataNodes);\n            while (relocationTarget.equals(relocationSource)) {\n                relocationTarget = randomFrom(dataNodes);"}
{"magic_number_smell": "        ensureGreen();\n\n        logger.info(\"--> indexing sample data\");\n        final int numDocs = between(500, MAX_DOC_COUNT);\n        final IndexRequestBuilder[] docs = new IndexRequestBuilder[numDocs];\n\n        for (int i = 0; i < numDocs; i++) {", "refactored_code": "    private static final int MIN_DOC_COUNT = 500;\n        ensureGreen();\n\n        logger.info(\"--> indexing sample data\");\n        final int numDocs = between(MIN_DOC_COUNT, MAX_DOC_COUNT);\n        final IndexRequestBuilder[] docs = new IndexRequestBuilder[numDocs];\n\n        for (int i = 0; i < numDocs; i++) {"}
{"magic_number_smell": "        createIndex(indexName);\n\n        long nbDocs = 0;\n        try (BackgroundIndexer indexer = new BackgroundIndexer(indexName, client(), 25_000)) {\n            indexer.setFailureAssertion(t -> assertException(t, indexName));\n\n            waitForDocs(randomIntBetween(10, 50), indexer);", "refactored_code": "    private static final int MAX_DOCS = 25_000;\n        createIndex(indexName);\n\n        long nbDocs = 0;\n        try (BackgroundIndexer indexer = new BackgroundIndexer(indexName, client(), MAX_DOCS)) {\n            indexer.setFailureAssertion(t -> assertException(t, indexName));\n\n            waitForDocs(randomIntBetween(10, 50), indexer);"}
{"magic_number_smell": "        for (int i = 0; i < numDocs; i++) {\n            String id = Integer.toString(i);\n            assertThat(bulkResponse.getItems()[i].getId(), equalTo(id));\n            if (i == 3) {\n                UpdateResponse dropped = bulkResponse.getItems()[i].getResponse();\n                assertThat(dropped.getId(), equalTo(id));\n                assertThat(dropped.getResult(), equalTo(DocWriteResponse.Result.NOOP));", "refactored_code": "    private static final int DROPPED = 3;\n        for (int i = 0; i < numDocs; i++) {\n            String id = Integer.toString(i);\n            assertThat(bulkResponse.getItems()[i].getId(), equalTo(id));\n            if (i == DROPPED) {\n                UpdateResponse dropped = bulkResponse.getItems()[i].getResponse();\n                assertThat(dropped.getId(), equalTo(id));\n                assertThat(dropped.getResult(), equalTo(DocWriteResponse.Result.NOOP));"}
{"magic_number_smell": "    protected Settings nodeSettings(int nodeOrdinal, Settings otherSettings) {\n        return Settings.builder()\n            .put(super.nodeSettings(nodeOrdinal, otherSettings))\n            .put(ScriptService.64.getKey(), 64)\n            .build();\n    }\n", "refactored_code": "    private static final int SCRIPT_MAX_SIZE_IN_BYTES = 64;\n    protected Settings nodeSettings(int nodeOrdinal, Settings otherSettings) {\n        return Settings.builder()\n            .put(super.nodeSettings(nodeOrdinal, otherSettings))\n            .put(ScriptService.SCRIPT_MAX_SIZE_IN_BYTES.getKey(), SCRIPT_MAX_SIZE_IN_BYTES)\n            .build();\n    }\n"}
{"magic_number_smell": "    @Override\n    public void setupSuiteScopeCluster() throws Exception {\n        assertAcked(\n            prepareCreate(\"test\").setSettings(indexSettings(1, 0))\n                .setMapping(\"author\", \"type=keyword\", \"name\", \"type=keyword\", \"genre\", \"type=keyword\", \"price\", \"type=float\")\n        );\n        createIndex(\"idx_unmapped\");", "refactored_code": "    private static final int NUM_SHARDS = 1;\n    @Override\n    public void setupSuiteScopeCluster() throws Exception {\n        assertAcked(\n            prepareCreate(\"test\").setSettings(indexSettings(NUM_SHARDS, 0))\n                .setMapping(\"author\", \"type=keyword\", \"name\", \"type=keyword\", \"genre\", \"type=keyword\", \"price\", \"type=float\")\n        );\n        createIndex(\"idx_unmapped\");"}
{"magic_number_smell": "    public void setupSuiteScopeCluster() throws Exception {\n        createIndex(\"idx\");\n        List<IndexRequestBuilder> builders = new ArrayList<>();\n        for (int i = 0; i < 5; i++) {\n            builders.add(\n                prepareIndex(\"idx\").setSource(\n                    jsonBuilder().startObject()", "refactored_code": "    private static final int NUM_DOCS = 5; // TODO: randomize the size?\n    public void setupSuiteScopeCluster() throws Exception {\n        createIndex(\"idx\");\n        List<IndexRequestBuilder> builders = new ArrayList<>();\n        for (int i = 0; i < NUM_DOCS; i++) {\n            builders.add(\n                prepareIndex(\"idx\").setSource(\n                    jsonBuilder().startObject()"}
{"magic_number_smell": "    @Override\n    public void setupSuiteScopeCluster() throws Exception {\n        createIndex(\"idx\", \"high_card_idx\");\n        IndexRequestBuilder[] lowCardBuilders = new IndexRequestBuilder[5];\n        for (int i = 0; i < lowCardBuilders.length; i++) {\n            lowCardBuilders[i] = prepareIndex(\"idx\").setSource(\n                jsonBuilder().startObject()", "refactored_code": "    private static final int NUM_DOCS = 5; // TODO randomize the size?\n    @Override\n    public void setupSuiteScopeCluster() throws Exception {\n        createIndex(\"idx\", \"high_card_idx\");\n        IndexRequestBuilder[] lowCardBuilders = new IndexRequestBuilder[NUM_DOCS];\n        for (int i = 0; i < lowCardBuilders.length; i++) {\n            lowCardBuilders[i] = prepareIndex(\"idx\").setSource(\n                jsonBuilder().startObject()"}
{"magic_number_smell": "        assertResponse(\n            prepareSearch(\"idx\").setPreference(\"shard:0\")\n                .addAggregation(\n                    new RandomSamplerAggregationBuilder(\"sampler\").setProbability(0.25)\n                        .setSeed(0)\n                        .subAggregation(avg(\"mean_monotonic\").field(MONOTONIC_VALUE))\n                        .subAggregation(avg(\"mean_numeric\").field(NUMERIC_VALUE))", "refactored_code": "    private static final double PROBABILITY = 0.25;\n        assertResponse(\n            prepareSearch(\"idx\").setPreference(\"shard:0\")\n                .addAggregation(\n                    new RandomSamplerAggregationBuilder(\"sampler\").setProbability(PROBABILITY)\n                        .setSeed(0)\n                        .subAggregation(avg(\"mean_monotonic\").field(MONOTONIC_VALUE))\n                        .subAggregation(avg(\"mean_numeric\").field(NUMERIC_VALUE))"}
{"magic_number_smell": "    @Override\n    public void setupSuiteScopeCluster() throws Exception {\n        assertAcked(\n            prepareCreate(\"test\").setSettings(indexSettings(2, 0))\n                .setMapping(\"author\", \"type=keyword\", \"name\", \"type=text\", \"genre\", \"type=keyword\", \"price\", \"type=float\")\n        );\n        createIndex(\"idx_unmapped\");", "refactored_code": "    public static final int NUM_SHARDS = 2;\n    @Override\n    public void setupSuiteScopeCluster() throws Exception {\n        assertAcked(\n            prepareCreate(\"test\").setSettings(indexSettings(NUM_SHARDS, 0))\n                .setMapping(\"author\", \"type=keyword\", \"name\", \"type=text\", \"genre\", \"type=keyword\", \"price\", \"type=float\")\n        );\n        createIndex(\"idx_unmapped\");"}
{"magic_number_smell": "    private static final int -1000000 = -1000000;\n    private static final int MAX_SAMPLE_VALUE = 1000000;\n    private static final int NUMBER_OF_DOCS = 1000;\n    private static final Supplier<Long> sampleSupplier = () -> randomLongBetween(-1000000, MAX_SAMPLE_VALUE);\n\n    private static long[] singleValueSample;\n    private static long[] multiValueSample;", "refactored_code": "    private static final int MIN_SAMPLE_VALUE = -1000000;\n    private static final int MIN_SAMPLE_VALUE = -1000000;\n    private static final int MAX_SAMPLE_VALUE = 1000000;\n    private static final int NUMBER_OF_DOCS = 1000;\n    private static final Supplier<Long> sampleSupplier = () -> randomLongBetween(MIN_SAMPLE_VALUE, MAX_SAMPLE_VALUE);\n\n    private static long[] singleValueSample;\n    private static long[] multiValueSample;"}
{"magic_number_smell": "                jsonBuilder().startObject()\n                    .field(\"name\", \"TestPosition\")\n                    .startObject(\"location\")\n                    .field(\"lat\", 32.798)\n                    .field(\"lon\", src_lon)\n                    .endObject()\n                    .endObject()", "refactored_code": "    private static final double src_lat = 32.798;\n                jsonBuilder().startObject()\n                    .field(\"name\", \"TestPosition\")\n                    .startObject(\"location\")\n                    .field(\"lat\", src_lat)\n                    .field(\"lon\", src_lon)\n                    .endObject()\n                    .endObject()"}
{"magic_number_smell": "                    .startObject(\"properties\")\n                    .startObject(vectorField)\n                    .field(\"type\", \"dense_vector\")\n                    .field(\"dims\", 3)\n                    .field(\"index\", true)\n                    .field(\"similarity\", \"cosine\")\n                    .endObject()", "refactored_code": "    private static final int KNN_DIM = 3;\n                    .startObject(\"properties\")\n                    .startObject(vectorField)\n                    .field(\"type\", \"dense_vector\")\n                    .field(\"dims\", KNN_DIM)\n                    .field(\"index\", true)\n                    .field(\"similarity\", \"cosine\")\n                    .endObject()"}
{"magic_number_smell": "            types[i] = randomInt(6);\n        }\n        List<List<Object>> documents = new ArrayList<>();\n        for (int i = 0; i < 100; i++) {\n            List<Object> values = new ArrayList<>();\n            for (int type : types) {\n                switch (type) {", "refactored_code": "    private static final int NUM_DOCS = 100;\n            types[i] = randomInt(6);\n        }\n        List<List<Object>> documents = new ArrayList<>();\n        for (int i = 0; i < NUM_DOCS; i++) {\n            List<Object> values = new ArrayList<>();\n            for (int type : types) {\n                switch (type) {"}
{"magic_number_smell": "\n    private static void writeException(Throwable throwable, StreamOutput output, int nestedLevel, Runnable nestedExceptionLimitCallback)\n        throws IOException {\n        if (nestedLevel > 100) {\n            nestedExceptionLimitCallback.run();\n            writeException(new IllegalStateException(\"too many nested exceptions\"), output);\n            return;", "refactored_code": "    private static final int MAX_NESTED_EXCEPTION_LEVEL = 100;\n\n    private static void writeException(Throwable throwable, StreamOutput output, int nestedLevel, Runnable nestedExceptionLimitCallback)\n        throws IOException {\n        if (nestedLevel > MAX_NESTED_EXCEPTION_LEVEL) {\n            nestedExceptionLimitCallback.run();\n            writeException(new IllegalStateException(\"too many nested exceptions\"), output);\n            return;"}
{"magic_number_smell": "     */\n\n    public static final int 0 = 0;\n    public static final Version V_EMPTY = new Version(0);\n    public static final Version V_7_0_0 = new Version(7_00_00_99);\n    public static final Version V_7_0_1 = new Version(7_00_01_99);\n    public static final Version V_7_1_0 = new Version(7_01_00_99);", "refactored_code": "    public static final int V_EMPTY_ID = 0;\n     */\n\n    public static final int V_EMPTY_ID = 0;\n    public static final Version V_EMPTY = new Version(V_EMPTY_ID);\n    public static final Version V_7_0_0 = new Version(7_00_00_99);\n    public static final Version V_7_0_1 = new Version(7_00_01_99);\n    public static final Version V_7_1_0 = new Version(7_01_00_99);"}
{"magic_number_smell": "    public static final int -1 = -1;\n\n    /**\n     * Number of snapshots to fetch information for or {@link #-1} for fetching all snapshots matching the request.\n     */\n    private int size = -1;\n", "refactored_code": "    public static final int NO_LIMIT = -1;\n    public static final int NO_LIMIT = -1;\n\n    /**\n     * Number of snapshots to fetch information for or {@link #NO_LIMIT} for fetching all snapshots matching the request.\n     */\n    private int size = NO_LIMIT;\n"}
{"magic_number_smell": "        public static final boolean FLUSH = true;\n    }\n\n    private int maxNumSegments = Defaults.-1;\n    private boolean onlyExpungeDeletes = Defaults.ONLY_EXPUNGE_DELETES;\n    private boolean flush = Defaults.FLUSH;\n    /**", "refactored_code": "        public static final int MAX_NUM_SEGMENTS = -1;\n        public static final boolean FLUSH = true;\n    }\n\n    private int maxNumSegments = Defaults.MAX_NUM_SEGMENTS;\n    private boolean onlyExpungeDeletes = Defaults.ONLY_EXPUNGE_DELETES;\n    private boolean flush = Defaults.FLUSH;\n    /**"}
{"magic_number_smell": "    public static final int -1 = -1;\n\n    static final ConstructingObjectParser<QueryExplanation, Void> PARSER = new ConstructingObjectParser<>(\"query_explanation\", true, a -> {\n        int shard = -1;\n        if (a[1] != null) {\n            shard = (int) a[1];\n        }", "refactored_code": "    public static final int RANDOM_SHARD = -1;\n    public static final int RANDOM_SHARD = -1;\n\n    static final ConstructingObjectParser<QueryExplanation, Void> PARSER = new ConstructingObjectParser<>(\"query_explanation\", true, a -> {\n        int shard = RANDOM_SHARD;\n        if (a[1] != null) {\n            shard = (int) a[1];\n        }"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        return RamUsageEstimator.shallowSizeOfInstance(BulkItemRequest.class) + request.ramBytesUsed();\n    }\n}\n", "refactored_code": "    private static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(BulkItemRequest.class);\n\n    @Override\n    public long ramBytesUsed() {\n        return SHALLOW_SIZE + request.ramBytesUsed();\n    }\n}\n"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        return RamUsageEstimator.shallowSizeOfInstance(BulkRequest.class) + requests.stream().mapToLong(Accountable::ramBytesUsed).sum();\n    }\n\n    public Set<String> getIndices() {", "refactored_code": "    private static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(BulkRequest.class);\n\n    @Override\n    public long ramBytesUsed() {\n        return SHALLOW_SIZE + requests.stream().mapToLong(Accountable::ramBytesUsed).sum();\n    }\n\n    public Set<String> getIndices() {"}
{"magic_number_smell": "    }\n\n    public BulkResponse(BulkItemResponse[] responses, long tookInMillis) {\n        this(responses, tookInMillis, -1L);\n    }\n\n    public BulkResponse(BulkItemResponse[] responses, long tookInMillis, long ingestTookInMillis) {", "refactored_code": "    public static final long NO_INGEST_TOOK = -1L;\n    }\n\n    public BulkResponse(BulkItemResponse[] responses, long tookInMillis) {\n        this(responses, tookInMillis, NO_INGEST_TOOK);\n    }\n\n    public BulkResponse(BulkItemResponse[] responses, long tookInMillis, long ingestTookInMillis) {"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        long sum = RamUsageEstimator.shallowSizeOfInstance(BulkShardRequest.class);\n        for (BulkItemRequest item : items) {\n            sum += item.ramBytesUsed();\n        }", "refactored_code": "    private static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(BulkShardRequest.class);\n\n    @Override\n    public long ramBytesUsed() {\n        long sum = SHALLOW_SIZE;\n        for (BulkItemRequest item : items) {\n            sum += item.ramBytesUsed();\n        }"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        return RamUsageEstimator.shallowSizeOfInstance(DeleteRequest.class) + RamUsageEstimator.sizeOf(id);\n    }\n}\n", "refactored_code": "    private static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(DeleteRequest.class);\n\n    @Override\n    public long ramBytesUsed() {\n        return SHALLOW_SIZE + RamUsageEstimator.sizeOf(id);\n    }\n}\n"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        return RamUsageEstimator.shallowSizeOfInstance(IndexRequest.class) + RamUsageEstimator.sizeOf(id) + (source == null ? 0 : source.length());\n    }\n\n    @Override", "refactored_code": "    private static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(IndexRequest.class);\n\n    @Override\n    public long ramBytesUsed() {\n        return SHALLOW_SIZE + RamUsageEstimator.sizeOf(id) + (source == null ? 0 : source.length());\n    }\n\n    @Override"}
{"magic_number_smell": "    public final ShardSearchRequest buildShardSearchRequest(SearchShardIterator shardIt, int shardIndex) {\n        AliasFilter filter = aliasFilter.get(shardIt.shardId().getIndex().getUUID());\n        assert filter != null;\n        float indexBoost = concreteIndexBoosts.getOrDefault(shardIt.shardId().getIndex().getUUID(), 1.0f);\n        ShardSearchRequest shardRequest = new ShardSearchRequest(\n            shardIt.getOriginalIndices(),\n            request,", "refactored_code": "    private static final float DEFAULT_INDEX_BOOST = 1.0f;\n    public final ShardSearchRequest buildShardSearchRequest(SearchShardIterator shardIt, int shardIndex) {\n        AliasFilter filter = aliasFilter.get(shardIt.shardId().getIndex().getUUID());\n        assert filter != null;\n        float indexBoost = concreteIndexBoosts.getOrDefault(shardIt.shardId().getIndex().getUUID(), DEFAULT_INDEX_BOOST);\n        ShardSearchRequest shardRequest = new ShardSearchRequest(\n            shardIt.getOriginalIndices(),\n            request,"}
{"magic_number_smell": "    public CanMatchNodeRequest.Shard buildShardLevelRequest(SearchShardIterator shardIt) {\n        AliasFilter filter = aliasFilter.get(shardIt.shardId().getIndex().getUUID());\n        assert filter != null;\n        float indexBoost = concreteIndexBoosts.getOrDefault(shardIt.shardId().getIndex().getUUID(), 1.0f);\n        int shardRequestIndex = shardItIndexMap.get(shardIt);\n        return new CanMatchNodeRequest.Shard(\n            shardIt.getOriginalIndices().indices(),", "refactored_code": "    private static final float DEFAULT_INDEX_BOOST = 1.0f;\n    public CanMatchNodeRequest.Shard buildShardLevelRequest(SearchShardIterator shardIt) {\n        AliasFilter filter = aliasFilter.get(shardIt.shardId().getIndex().getUUID());\n        assert filter != null;\n        float indexBoost = concreteIndexBoosts.getOrDefault(shardIt.shardId().getIndex().getUUID(), DEFAULT_INDEX_BOOST);\n        int shardRequestIndex = shardItIndexMap.get(shardIt);\n        return new CanMatchNodeRequest.Shard(\n            shardIt.getOriginalIndices().indices(),"}
{"magic_number_smell": "    private static final int -2 = -2;\n    private static final int ALL_ACTIVE_SHARDS = -1;\n\n    public static final ActiveShardCount DEFAULT = new ActiveShardCount(-2);\n    public static final ActiveShardCount ALL = new ActiveShardCount(ALL_ACTIVE_SHARDS);\n    public static final ActiveShardCount NONE = new ActiveShardCount(0);\n    public static final ActiveShardCount ONE = new ActiveShardCount(1);", "refactored_code": "    private static final int ACTIVE_SHARD_COUNT_DEFAULT = -2;\n    private static final int ACTIVE_SHARD_COUNT_DEFAULT = -2;\n    private static final int ALL_ACTIVE_SHARDS = -1;\n\n    public static final ActiveShardCount DEFAULT = new ActiveShardCount(ACTIVE_SHARD_COUNT_DEFAULT);\n    public static final ActiveShardCount ALL = new ActiveShardCount(ALL_ACTIVE_SHARDS);\n    public static final ActiveShardCount NONE = new ActiveShardCount(0);\n    public static final ActiveShardCount ONE = new ActiveShardCount(1);"}
{"magic_number_smell": "\n        private void addException(Exception e) {\n            if (caughtExceptions != null) {\n                if (caughtExceptions.size() == 4) {\n                    caughtExceptions.removeLast();\n                }\n            } else {", "refactored_code": "        private static final int MAX_EXCEPTIONS = 4;\n\n        private void addException(Exception e) {\n            if (caughtExceptions != null) {\n                if (caughtExceptions.size() == MAX_EXCEPTIONS) {\n                    caughtExceptions.removeLast();\n                }\n            } else {"}
{"magic_number_smell": "            validationException = validatePositiveInt(\"from\", from, validationException);\n            validationException = validatePositiveInt(\"size\", size, validationException);\n\n            if (from + size > 10_000) {\n                validationException = addValidationError(\n                    \"Too many results to retrieve. [from] + [size] must be less than or equal to \" + 10_000,\n                    validationException", "refactored_code": "        private static final int MAX_SYNONYMS_RESULTS = 10_000;\n            validationException = validatePositiveInt(\"from\", from, validationException);\n            validationException = validatePositiveInt(\"size\", size, validationException);\n\n            if (from + size > MAX_SYNONYMS_RESULTS) {\n                validationException = addValidationError(\n                    \"Too many results to retrieve. [from] + [size] must be less than or equal to \" + MAX_SYNONYMS_RESULTS,\n                    validationException"}
{"magic_number_smell": "    public static final int DEFAULT_MIN_WORD_LENGTH = 0;\n    public static final int DEFAULT_MAX_WORD_LENGTH = 0;\n\n    private int maxNumTerms = 25;\n    private int minTermFreq = DEFAULT_MIN_TERM_FREQ;\n    private int maxTermFreq = DEFAULT_MAX_TERM_FREQ;\n    private int minDocFreq = DEFAULT_MIN_DOC_FREQ;", "refactored_code": "    public static final int DEFAULT_MAX_QUERY_TERMS = 25;\n    public static final int DEFAULT_MIN_WORD_LENGTH = 0;\n    public static final int DEFAULT_MAX_WORD_LENGTH = 0;\n\n    private int maxNumTerms = DEFAULT_MAX_QUERY_TERMS;\n    private int minTermFreq = DEFAULT_MIN_TERM_FREQ;\n    private int maxTermFreq = DEFAULT_MAX_TERM_FREQ;\n    private int minDocFreq = DEFAULT_MIN_DOC_FREQ;"}
{"magic_number_smell": "        // termVectors field\n        BytesStreamOutput header = new BytesStreamOutput();\n        header.writeString(HEADER);\n        header.writeInt(-1);\n        header.writeBoolean(getTermStatistics);\n        header.writeBoolean(getFieldStatistics);\n        header.writeBoolean(scores);", "refactored_code": "    private static final int CURRENT_VERSION = -1;\n        // termVectors field\n        BytesStreamOutput header = new BytesStreamOutput();\n        header.writeString(HEADER);\n        header.writeInt(CURRENT_VERSION);\n        header.writeBoolean(getTermStatistics);\n        header.writeBoolean(getFieldStatistics);\n        header.writeBoolean(scores);"}
{"magic_number_smell": "        if (upsertRequest != null) {\n            childRequestBytes += upsertRequest.ramBytesUsed();\n        }\n        return RamUsageEstimator.shallowSizeOfInstance(UpdateRequest.class) + RamUsageEstimator.sizeOf(id) + childRequestBytes;\n    }\n}\n", "refactored_code": "    private static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(UpdateRequest.class);\n        if (upsertRequest != null) {\n            childRequestBytes += upsertRequest.ramBytesUsed();\n        }\n        return SHALLOW_SIZE + RamUsageEstimator.sizeOf(id) + childRequestBytes;\n    }\n}\n"}
{"magic_number_smell": "\n        @Override\n        public BootstrapCheckResult check(BootstrapContext context) {\n            if (getMaxNumberOfThreads() != -1 && getMaxNumberOfThreads() < 1 << 12) {\n                final String message = String.format(\n                    Locale.ROOT,\n                    \"max number of threads [%d] for user [%s] is too low, increase to at least [%d]\",", "refactored_code": "        private static final long MAX_NUMBER_OF_THREADS_THRESHOLD = 1 << 12;\n\n        @Override\n        public BootstrapCheckResult check(BootstrapContext context) {\n            if (getMaxNumberOfThreads() != -1 && getMaxNumberOfThreads() < MAX_NUMBER_OF_THREADS_THRESHOLD) {\n                final String message = String.format(\n                    Locale.ROOT,\n                    \"max number of threads [%d] for user [%s] is too low, increase to at least [%d]\","}
{"magic_number_smell": "    private final Task task;\n    private final long computationTimeMillis;\n    private final long publicationStartTimeMillis;\n    private volatile long publicationContextConstructionElapsedMillis = -1L;\n    private volatile long publicationCommitElapsedMillis = -1L;\n    private volatile long publicationCompletionElapsedMillis = -1L;\n    private volatile long masterApplyElapsedMillis = -1L;", "refactored_code": "    private static final long NOT_SET = -1L;\n    private final Task task;\n    private final long computationTimeMillis;\n    private final long publicationStartTimeMillis;\n    private volatile long publicationContextConstructionElapsedMillis = NOT_SET;\n    private volatile long publicationCommitElapsedMillis = NOT_SET;\n    private volatile long publicationCompletionElapsedMillis = NOT_SET;\n    private volatile long masterApplyElapsedMillis = NOT_SET;"}
{"magic_number_smell": "\n        @Override\n        public long getRemovalAgeMillis(long currentTimeMillis) {\n            return -1L;\n        }\n    };\n", "refactored_code": "    private static final long NOT_REMOVED = -1L;\n\n        @Override\n        public long getRemovalAgeMillis(long currentTimeMillis) {\n            return NOT_REMOVED;\n        }\n    };\n"}
{"magic_number_smell": "            long oldestRelevantHistoryTime = now - maxHistoryAge.getMillis();\n            List<TimeAndMaster> newMasterHistory = new ArrayList<>();\n            int sizeAfterAddingNewMaster = masterHistory.size() + 1;\n            int startIndex = Math.max(0, sizeAfterAddingNewMaster - 50);\n            for (int i = startIndex; i < masterHistory.size(); i++) {\n                TimeAndMaster timeAndMaster = masterHistory.get(i);\n                final long currentMasterEndTime;", "refactored_code": "    public static final int MAX_HISTORY_SIZE = 50;\n            long oldestRelevantHistoryTime = now - maxHistoryAge.getMillis();\n            List<TimeAndMaster> newMasterHistory = new ArrayList<>();\n            int sizeAfterAddingNewMaster = masterHistory.size() + 1;\n            int startIndex = Math.max(0, sizeAfterAddingNewMaster - MAX_HISTORY_SIZE);\n            for (int i = startIndex; i < masterHistory.size(); i++) {\n                TimeAndMaster timeAndMaster = masterHistory.get(i);\n                final long currentMasterEndTime;"}
{"magic_number_smell": "public class NoMasterBlockService {\n    public static final int 2 = 2;\n    public static final ClusterBlock NO_MASTER_BLOCK_WRITES = new ClusterBlock(\n        2,\n        \"no master\",\n        true,\n        false,", "refactored_code": "    public static final int NO_MASTER_BLOCK_ID = 2;\npublic class NoMasterBlockService {\n    public static final int NO_MASTER_BLOCK_ID = 2;\n    public static final ClusterBlock NO_MASTER_BLOCK_WRITES = new ClusterBlock(\n        NO_MASTER_BLOCK_ID,\n        \"no master\",\n        true,\n        false,"}
{"magic_number_smell": "            }\n\n            public Round {\n                if (config.getFixedInterval().estimateMillis() < TimeValue.timeValueMinutes(5).getMillis()) {\n                    throw new IllegalArgumentException(\n                        \"A downsampling round must have a fixed interval of at least five minutes but found: \" + config.getFixedInterval()\n                    );", "refactored_code": "        public static final long FIVE_MINUTES_MILLIS = TimeValue.timeValueMinutes(5).getMillis();\n            }\n\n            public Round {\n                if (config.getFixedInterval().estimateMillis() < FIVE_MINUTES_MILLIS) {\n                    throw new IllegalArgumentException(\n                        \"A downsampling round must have a fixed interval of at least five minutes but found: \" + config.getFixedInterval()\n                    );"}
{"magic_number_smell": "         * Add a deleted index to the list of tombstones in the cluster state.\n         */\n        public Builder addTombstone(final Index index) {\n            tombstones.add(new Tombstone(index, System.currentTimeMillis()));\n            return this;\n        }\n", "refactored_code": "        private final long currentTime = System.currentTimeMillis();\n         * Add a deleted index to the list of tombstones in the cluster state.\n         */\n        public Builder addTombstone(final Index index) {\n            tombstones.add(new Tombstone(index, currentTime));\n            return this;\n        }\n"}
{"magic_number_smell": "        assertShardInBounds(shardId);\n\n        long uptime = shardUptimeInMillis[shardId];\n        return uptime != -1 ? OptionalLong.of(uptime) : OptionalLong.empty();\n    }\n\n    // Visible for testing", "refactored_code": "    private static final long UNKNOWN_UPTIME = -1;\n        assertShardInBounds(shardId);\n\n        long uptime = shardUptimeInMillis[shardId];\n        return uptime != UNKNOWN_UPTIME ? OptionalLong.of(uptime) : OptionalLong.empty();\n    }\n\n    // Visible for testing"}
{"magic_number_smell": "    }\n\n    private static long generation(Object[] manifestFields) {\n        return requireNonNullElseDefault((Long) manifestFields[2], -1L);\n    }\n\n    @SuppressWarnings(\"unchecked\")", "refactored_code": "    private static final long MISSING_GLOBAL_GENERATION = -1L;\n    }\n\n    private static long generation(Object[] manifestFields) {\n        return requireNonNullElseDefault((Long) manifestFields[2], MISSING_GLOBAL_GENERATION);\n    }\n\n    @SuppressWarnings(\"unchecked\")"}
{"magic_number_smell": "            throw exceptionCtor.apply(index, \"must not start with '_', '-', or '+'\");\n        }\n        int byteCount = index.getBytes(StandardCharsets.UTF_8).length;\n        if (byteCount > 255) {\n            throw exceptionCtor.apply(index, \"index name is too long, (\" + byteCount + \" > \" + 255 + \")\");\n        }\n        if (index.equals(\".\") || index.equals(\"..\")) {", "refactored_code": "    public static final int MAX_INDEX_NAME_BYTES = 255;\n            throw exceptionCtor.apply(index, \"must not start with '_', '-', or '+'\");\n        }\n        int byteCount = index.getBytes(StandardCharsets.UTF_8).length;\n        if (byteCount > MAX_INDEX_NAME_BYTES) {\n            throw exceptionCtor.apply(index, \"index name is too long, (\" + byteCount + \" > \" + MAX_INDEX_NAME_BYTES + \")\");\n        }\n        if (index.equals(\".\") || index.equals(\"..\")) {"}
{"magic_number_smell": "            final Set<ClusterBlock> clusterBlocks = currentState.blocks().indices().get(index.getName());\n            if (clusterBlocks != null) {\n                for (ClusterBlock clusterBlock : clusterBlocks) {\n                    if (clusterBlock.id() == 4) {\n                        // Reuse the existing index closed block\n                        indexBlock = clusterBlock;\n                        break;", "refactored_code": "    public static final int INDEX_CLOSED_BLOCK_ID = 4;\n            final Set<ClusterBlock> clusterBlocks = currentState.blocks().indices().get(index.getName());\n            if (clusterBlocks != null) {\n                for (ClusterBlock clusterBlock : clusterBlocks) {\n                    if (clusterBlock.id() == INDEX_CLOSED_BLOCK_ID) {\n                        // Reuse the existing index closed block\n                        indexBlock = clusterBlock;\n                        break;"}
{"magic_number_smell": "            unassignedInfo,\n            RelocationFailureInfo.NO_FAILURES,\n            null,\n            -1,\n            role\n        );\n    }", "refactored_code": "    public static final long UNAVAILABLE_EXPECTED_SHARD_SIZE = -1;\n            unassignedInfo,\n            RelocationFailureInfo.NO_FAILURES,\n            null,\n            UNAVAILABLE_EXPECTED_SHARD_SIZE,\n            role\n        );\n    }"}
{"magic_number_smell": "    public static final String NAME = \"throttling\";\n    public static final Setting<Integer> CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_RECOVERIES_SETTING = new Setting<>(\n        \"cluster.routing.allocation.node_concurrent_recoveries\",\n        Integer.toString(2),\n        (s) -> Setting.parseInt(s, 0, \"cluster.routing.allocation.node_concurrent_recoveries\"),\n        Property.Dynamic,\n        Property.NodeScope", "refactored_code": "    public static final int DEFAULT_CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_RECOVERIES = 2;\n    public static final String NAME = \"throttling\";\n    public static final Setting<Integer> CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_RECOVERIES_SETTING = new Setting<>(\n        \"cluster.routing.allocation.node_concurrent_recoveries\",\n        Integer.toString(DEFAULT_CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_RECOVERIES),\n        (s) -> Setting.parseInt(s, 0, \"cluster.routing.allocation.node_concurrent_recoveries\"),\n        Property.Dynamic,\n        Property.NodeScope"}
{"magic_number_smell": "     */\n    public static String generateValidIndexName(String prefix, String indexName) {\n        String randomUUID = generateValidIndexSuffix(UUIDs::randomBase64UUID);\n        randomUUID = randomUUID.substring(0, Math.min(randomUUID.length(), 4));\n        return prefix + randomUUID + \"-\" + indexName;\n    }\n", "refactored_code": "    public static final int MAX_GENERATED_UUID_LENGTH = 4;\n     */\n    public static String generateValidIndexName(String prefix, String indexName) {\n        String randomUUID = generateValidIndexSuffix(UUIDs::randomBase64UUID);\n        randomUUID = randomUUID.substring(0, Math.min(randomUUID.length(), MAX_GENERATED_UUID_LENGTH));\n        return prefix + randomUUID + \"-\" + indexName;\n    }\n"}
{"magic_number_smell": "    /**\n     * Collect transitions from the provided rules for the provided date range\n     * into a list we can reason about. If we'd collect more than\n     * {@link #5000} rules we'll abort, returning {@code null}\n     * signaling that {@link LocalTimeOffset} is probably not the implementation\n     * to use in this case.\n     * <p>", "refactored_code": "    private static final int MAX_TRANSITIONS = 5000;\n    /**\n     * Collect transitions from the provided rules for the provided date range\n     * into a list we can reason about. If we'd collect more than\n     * {@link #MAX_TRANSITIONS} rules we'll abort, returning {@code null}\n     * signaling that {@link LocalTimeOffset} is probably not the implementation\n     * to use in this case.\n     * <p>"}
{"magic_number_smell": "\n    public ParsingException(XContentLocation contentLocation, String msg, Throwable cause, Object... args) {\n        super(msg, cause, args);\n        int lineNumber = -1;\n        int columnNumber = -1;\n        if (contentLocation != null) {\n            lineNumber = contentLocation.lineNumber();", "refactored_code": "    protected static final int UNKNOWN_POSITION = -1;\n\n    public ParsingException(XContentLocation contentLocation, String msg, Throwable cause, Object... args) {\n        super(msg, cause, args);\n        int lineNumber = UNKNOWN_POSITION;\n        int columnNumber = UNKNOWN_POSITION;\n        if (contentLocation != null) {\n            lineNumber = contentLocation.lineNumber();"}
{"magic_number_smell": "            }\n\n            @Override\n            long TimeUnit.DAYS.toMillis(7)() {\n                return TimeUnit.DAYS.toMillis(7);\n            }\n        },", "refactored_code": "            private final long extraLocalOffsetLookup = TimeUnit.DAYS.toMillis(7);\n            }\n\n            @Override\n            long extraLocalOffsetLookup() {\n                return extraLocalOffsetLookup;\n            }\n        },"}
{"magic_number_smell": "    public static final int 2 * Long.BYTES = 2 * Long.BYTES;\n\n    public static void ensureValidRegisterContent(BytesReference bytesReference) {\n        if (bytesReference.length() > 2 * Long.BYTES) {\n            final var message = \"invalid register content with length [\" + bytesReference.length() + \"]\";\n            assert false : message;\n            throw new IllegalStateException(message);", "refactored_code": "    public static final int MAX_REGISTER_CONTENT_LENGTH = 2 * Long.BYTES;\n    public static final int MAX_REGISTER_CONTENT_LENGTH = 2 * Long.BYTES;\n\n    public static void ensureValidRegisterContent(BytesReference bytesReference) {\n        if (bytesReference.length() > MAX_REGISTER_CONTENT_LENGTH) {\n            final var message = \"invalid register content with length [\" + bytesReference.length() + \"]\";\n            assert false : message;\n            throw new IllegalStateException(message);"}
{"magic_number_smell": "\n    @Override\n    public long getLimit() {\n        return -1;\n    }\n\n    @Override", "refactored_code": "    public static final int LIMIT = -1;\n\n    @Override\n    public long getLimit() {\n        return LIMIT;\n    }\n\n    @Override"}
{"magic_number_smell": "        // we calculate the initial fragment size here to ensure that if this reference is a slice we are still page aligned\n        // across the entire iteration. The first page is smaller if our offset != 0 then we start in the middle of the page\n        // otherwise we iterate full pages until we reach the last chunk which also might end within a page.\n        final int initialFragmentSize = offset != 0 ? PageCacheRecycler.BYTE_PAGE_SIZE - (offset % PageCacheRecycler.BYTE_PAGE_SIZE) : PageCacheRecycler.BYTE_PAGE_SIZE;\n        return new BytesRefIterator() {\n            int position = 0;\n            int nextFragmentSize = Math.min(length, initialFragmentSize);", "refactored_code": "    private static final int PAGE_SIZE = PageCacheRecycler.BYTE_PAGE_SIZE;\n        // we calculate the initial fragment size here to ensure that if this reference is a slice we are still page aligned\n        // across the entire iteration. The first page is smaller if our offset != 0 then we start in the middle of the page\n        // otherwise we iterate full pages until we reach the last chunk which also might end within a page.\n        final int initialFragmentSize = offset != 0 ? PAGE_SIZE - (offset % PAGE_SIZE) : PAGE_SIZE;\n        return new BytesRefIterator() {\n            int position = 0;\n            int nextFragmentSize = Math.min(length, initialFragmentSize);"}
{"magic_number_smell": "\n    public static final int 256 = 256;\n    @SuppressWarnings(\"unchecked\")\n    private final CacheSegment[] segments = (CacheSegment[]) Array.newInstance(CacheSegment.class, 256);\n\n    {\n        for (int i = 0; i < segments.length; i++) {", "refactored_code": "    public static final int NUMBER_OF_SEGMENTS = 256;\n\n    public static final int NUMBER_OF_SEGMENTS = 256;\n    @SuppressWarnings(\"unchecked\")\n    private final CacheSegment[] segments = (CacheSegment[]) Array.newInstance(CacheSegment.class, NUMBER_OF_SEGMENTS);\n\n    {\n        for (int i = 0; i < segments.length; i++) {"}
{"magic_number_smell": "                    StandardWatchEventKinds.ENTRY_DELETE\n                );\n            } catch (IOException e) {\n                if (retryCount == 5 - 1) {\n                    throw e;\n                }\n                Thread.sleep(retryDelayMillis(retryCount));", "refactored_code": "    private static final int REGISTER_RETRY_COUNT = 5;\n                    StandardWatchEventKinds.ENTRY_DELETE\n                );\n            } catch (IOException e) {\n                if (retryCount == REGISTER_RETRY_COUNT - 1) {\n                    throw e;\n                }\n                Thread.sleep(retryDelayMillis(retryCount));"}
{"magic_number_smell": "            if (logger.isTraceEnabled()) {\n                logger.trace(\"executing native method __xstat() returned {} with error code [{}] for file [{}]\", stats, rc, path);\n            }\n            return OptionalLong.of(stats.st_blocks * 512L);\n        } catch (LastErrorException e) {\n            logger.warn(\n                () -> format(", "refactored_code": "    private static final long ST_BLOCKS_UNIT = 512L;\n            if (logger.isTraceEnabled()) {\n                logger.trace(\"executing native method __xstat() returned {} with error code [{}] for file [{}]\", stats, rc, path);\n            }\n            return OptionalLong.of(stats.st_blocks * ST_BLOCKS_UNIT);\n        } catch (LastErrorException e) {\n            logger.warn(\n                () -> format("}
{"magic_number_smell": "        final IntByReference lpFileSizeHigh = new IntByReference();\n\n        final int lpFileSizeLow = GetCompressedFileSizeW(fileName, lpFileSizeHigh);\n        if (lpFileSizeLow == -1) {\n            final int err = Native.getLastError();\n            if (err != NO_ERROR) {\n                logger.warn(\"error [{}] when executing native method GetCompressedFileSizeW for file [{}]\", err, path);", "refactored_code": "    private static final int INVALID_FILE_SIZE = -1;\n        final IntByReference lpFileSizeHigh = new IntByReference();\n\n        final int lpFileSizeLow = GetCompressedFileSizeW(fileName, lpFileSizeHigh);\n        if (lpFileSizeLow == INVALID_FILE_SIZE) {\n            final int err = Native.getLastError();\n            if (err != NO_ERROR) {\n                logger.warn(\"error [{}] when executing native method GetCompressedFileSizeW for file [{}]\", err, path);"}
{"magic_number_smell": "                    // Found intersection, all previous segments are now part of the linestring\n                    double[] partLons = Arrays.copyOfRange(lons, offset, i + 1);\n                    double[] partLats = Arrays.copyOfRange(lats, offset, i + 1);\n                    lons[i - 1] = partLons[partLons.length - 1] = (direction > 0 ? 180 : -180) - shift;\n                    lats[i - 1] = partLats[partLats.length - 1] = lats[i - 1] + (lats[i] - lats[i - 1]) * t;\n                    performShift(shift, partLons);\n                    offset = i - 1;", "refactored_code": "    private static final double DATELINE = 180;\n                    // Found intersection, all previous segments are now part of the linestring\n                    double[] partLons = Arrays.copyOfRange(lons, offset, i + 1);\n                    double[] partLats = Arrays.copyOfRange(lats, offset, i + 1);\n                    lons[i - 1] = partLons[partLons.length - 1] = (direction > 0 ? DATELINE : -DATELINE) - shift;\n                    lats[i - 1] = partLats[partLats.length - 1] = lats[i - 1] + (lats[i] - lats[i - 1]) * t;\n                    performShift(shift, partLons);\n                    offset = i - 1;"}
{"magic_number_smell": "        final double rng = maxX - minX;\n        // we need to decompose tif the range is greater than a hemisphere (180 degrees)\n        // but not spanning 2 hemispheres (translation would result in a collapsed poly)\n        return rng > 180 && rng != 2 * 180;\n    }\n\n    public static void decomposeMultiPolygon(MultiPolygon multiPolygon, boolean orientation, List<Polygon> collector) {", "refactored_code": "    private static final double DATELINE = 180;\n        final double rng = maxX - minX;\n        // we need to decompose tif the range is greater than a hemisphere (180 degrees)\n        // but not spanning 2 hemispheres (translation would result in a collapsed poly)\n        return rng > DATELINE && rng != 2 * DATELINE;\n    }\n\n    public static void decomposeMultiPolygon(MultiPolygon multiPolygon, boolean orientation, List<Polygon> collector) {"}
{"magic_number_smell": "\n    /** Returns true if latitude is actually a valid latitude value.*/\n    public static boolean isValidLatitude(double latitude) {\n        if (Double.isNaN(latitude) || Double.isInfinite(latitude) || latitude < GeoUtils.MIN_LAT || latitude > GeoUtils.90.0) {\n            return false;\n        }\n        return true;", "refactored_code": "    public static final double MAX_LAT = 90.0;\n\n    /** Returns true if latitude is actually a valid latitude value.*/\n    public static boolean isValidLatitude(double latitude) {\n        if (Double.isNaN(latitude) || Double.isInfinite(latitude) || latitude < GeoUtils.MIN_LAT || latitude > GeoUtils.MAX_LAT) {\n            return false;\n        }\n        return true;"}
{"magic_number_smell": "        if (numPoints == 0) {\n            return EMPTY;\n        }\n        commands[0] = encodeCommand(1, numPoints);\n        try {\n            return writeCommands(commands, 1, pos);\n        } catch (IOException ioe) {", "refactored_code": "    private static final int MOVETO = 1;\n        if (numPoints == 0) {\n            return EMPTY;\n        }\n        commands[0] = encodeCommand(MOVETO, numPoints);\n        try {\n            return writeCommands(commands, 1, pos);\n        } catch (IOException ioe) {"}
{"magic_number_smell": "        if (x < 0 || y < 0 || x >= tiles || y >= tiles) {\n            throw new IllegalArgumentException(String.format(Locale.ROOT, \"Zoom/X/Y combination is not valid: %d/%d/%d\", z, x, y));\n        }\n        final int extent = matcher.group(4) == null ? 4096 : Integer.parseInt(matcher.group(4).substring(1));\n        if (extent <= 0) {\n            throw new IllegalArgumentException(String.format(Locale.ROOT, \"Extent is not valid: %d is not > 0\", extent));\n        }", "refactored_code": "    public static final int DEFAULT_EXTENT = 4096;\n        if (x < 0 || y < 0 || x >= tiles || y >= tiles) {\n            throw new IllegalArgumentException(String.format(Locale.ROOT, \"Zoom/X/Y combination is not valid: %d/%d/%d\", z, x, y));\n        }\n        final int extent = matcher.group(4) == null ? DEFAULT_EXTENT : Integer.parseInt(matcher.group(4).substring(1));\n        if (extent <= 0) {\n            throw new IllegalArgumentException(String.format(Locale.ROOT, \"Extent is not valid: %d is not > 0\", extent));\n        }"}
{"magic_number_smell": "public class SphericalMercatorUtils {\n\n    public static final double 20037508.34 = 20037508.34;\n    private static final double MERCATOR_FACTOR = 20037508.34 / 180.0;\n    // tangent lower limit. Below this limit the transformation result is -Infinity\n    private static final double TAN_LOWER_LIMIT = Math.tan(Math.nextUp(0.0));\n", "refactored_code": "    public static final double MERCATOR_BOUNDS = 20037508.34;\npublic class SphericalMercatorUtils {\n\n    public static final double MERCATOR_BOUNDS = 20037508.34;\n    private static final double MERCATOR_FACTOR = MERCATOR_BOUNDS / 180.0;\n    // tangent lower limit. Below this limit the transformation result is -Infinity\n    private static final double TAN_LOWER_LIMIT = Math.tan(Math.nextUp(0.0));\n"}
{"magic_number_smell": "     * that will fit in the destination byte buffer.\n     */\n    public static int readFromFileChannel(FileChannel channel, long channelPosition, ByteBuffer dest) throws IOException {\n        if (dest.isDirect() || (dest.remaining() < 16384)) {\n            return readSingleChunk(channel, channelPosition, dest);\n        } else {\n            int bytesRead = 0;", "refactored_code": "    private static final int READ_CHUNK_SIZE = 16384;\n     * that will fit in the destination byte buffer.\n     */\n    public static int readFromFileChannel(FileChannel channel, long channelPosition, ByteBuffer dest) throws IOException {\n        if (dest.isDirect() || (dest.remaining() < READ_CHUNK_SIZE)) {\n            return readSingleChunk(channel, channelPosition, dest);\n        } else {\n            int bytesRead = 0;"}
{"magic_number_smell": "\n    private static int doCopy(Reader in, Writer out) throws IOException {\n        int byteCount = 0;\n        char[] buffer = new char[1024 * 8];\n        int bytesRead;\n        while ((bytesRead = in.read(buffer)) != -1) {\n            out.write(buffer, 0, bytesRead);", "refactored_code": "    public static final int BUFFER_SIZE = 1024 * 8;\n\n    private static int doCopy(Reader in, Writer out) throws IOException {\n        int byteCount = 0;\n        char[] buffer = new char[BUFFER_SIZE];\n        int bytesRead;\n        while ((bytesRead = in.read(buffer)) != -1) {\n            out.write(buffer, 0, bytesRead);"}
{"magic_number_smell": "    private static final ThreadLocal<byte[]> stringReadBuffer = ThreadLocal.withInitial(() -> new byte[1024]);\n\n    // Thread-local buffer for smaller strings\n    private static final ThreadLocal<char[]> smallSpare = ThreadLocal.withInitial(() -> new char[1024]);\n\n    // Larger buffer used for long strings that can't fit into the thread-local buffer\n    // We don't use a CharsRefBuilder since we exactly know the size of the character array up front", "refactored_code": "    private static final int SMALL_STRING_LIMIT = 1024;\n    private static final ThreadLocal<byte[]> stringReadBuffer = ThreadLocal.withInitial(() -> new byte[1024]);\n\n    // Thread-local buffer for smaller strings\n    private static final ThreadLocal<char[]> smallSpare = ThreadLocal.withInitial(() -> new char[SMALL_STRING_LIMIT]);\n\n    // Larger buffer used for long strings that can't fit into the thread-local buffer\n    // We don't use a CharsRefBuilder since we exactly know the size of the character array up front"}
{"magic_number_smell": "     * Writes a boolean.\n     */\n    public void writeBoolean(boolean b) throws IOException {\n        writeByte(b ? ONE : 0);\n    }\n\n    public void writeOptionalBoolean(@Nullable Boolean b) throws IOException {", "refactored_code": "    private static final byte ZERO = 0;\n     * Writes a boolean.\n     */\n    public void writeBoolean(boolean b) throws IOException {\n        writeByte(b ? ONE : ZERO);\n    }\n\n    public void writeOptionalBoolean(@Nullable Boolean b) throws IOException {"}
{"magic_number_smell": "            current = text;\n            return true;\n        } else {\n            currentDocFreq = -1;\n            currentTotalTermFreq = -1;\n            current = null;\n            return false;", "refactored_code": "    protected static final int NOT_FOUND = -1;\n            current = text;\n            return true;\n        } else {\n            currentDocFreq = NOT_FOUND;\n            currentTotalTermFreq = NOT_FOUND;\n            current = null;\n            return false;"}
{"magic_number_smell": "        this.needDocFreqs = needDocFreq;\n        this.needTotalTermFreqs = needTotalTermFreq;\n        if (needDocFreq) {\n            termDocFreqs = bigArrays.newIntArray(512, false);\n        } else {\n            termDocFreqs = null;\n        }", "refactored_code": "    private static final int INITIAL_NUM_TERM_FREQS_CACHED = 512;\n        this.needDocFreqs = needDocFreq;\n        this.needTotalTermFreqs = needTotalTermFreq;\n        if (needDocFreq) {\n            termDocFreqs = bigArrays.newIntArray(INITIAL_NUM_TERM_FREQS_CACHED, false);\n        } else {\n            termDocFreqs = null;\n        }"}
{"magic_number_smell": "                /**\n                 * The maximum number of tokens to parse in each example doc field that is not stored with TermVector support\n                 */\n                if (tokenCount > 5000) {\n                    break;\n                }\n                if (isNoiseWord(word)) {", "refactored_code": "    public static final int DEFAULT_MAX_NUM_TOKENS_PARSED = 5000;\n                /**\n                 * The maximum number of tokens to parse in each example doc field that is not stored with TermVector support\n                 */\n                if (tokenCount > DEFAULT_MAX_NUM_TOKENS_PARSED) {\n                    break;\n                }\n                if (isNoiseWord(word)) {"}
{"magic_number_smell": "     * @param function The {@link ScoreFunction} to apply.\n     */\n    public FunctionScoreQuery(Query subQuery, ScoreFunction function) {\n        this(subQuery, function, CombineFunction.MULTIPLY, null, Float.MAX_VALUE);\n    }\n\n    /**", "refactored_code": "    public static final float DEFAULT_MAX_BOOST = Float.MAX_VALUE;\n     * @param function The {@link ScoreFunction} to apply.\n     */\n    public FunctionScoreQuery(Query subQuery, ScoreFunction function) {\n        this(subQuery, function, CombineFunction.MULTIPLY, null, DEFAULT_MAX_BOOST);\n    }\n\n    /**"}
{"magic_number_smell": "\n    public static final int getBucketUpperBounds().length + 1 = getBucketUpperBounds().length + 1;\n\n    private static final long LAST_BUCKET_LOWER_BOUND = getBucketUpperBounds()[getBucketUpperBounds().length + 1 - 2];\n\n    private final LongAdder[] buckets;\n", "refactored_code": "    public static final int BUCKET_COUNT = getBucketUpperBounds().length + 1;\n\n    public static final int BUCKET_COUNT = getBucketUpperBounds().length + 1;\n\n    private static final long LAST_BUCKET_LOWER_BOUND = getBucketUpperBounds()[BUCKET_COUNT - 2];\n\n    private final LongAdder[] buckets;\n"}
{"magic_number_smell": "                pFlags |= Pattern.LITERAL;\n            } else if (\"COMMENTS\".equals(s)) {\n                pFlags |= Pattern.COMMENTS;\n            } else if ((\"UNICODE_CHAR_CLASS\".equals(s)) || (\"0x100\".equals(s))) {\n                pFlags |= 0x100;\n            } else {\n                throw new IllegalArgumentException(\"Unknown regex flag [\" + s + \"]\");", "refactored_code": "    public static final int UNICODE_CHARACTER_CLASS = 0x100; // supported in JAVA7\n                pFlags |= Pattern.LITERAL;\n            } else if (\"COMMENTS\".equals(s)) {\n                pFlags |= Pattern.COMMENTS;\n            } else if ((\"UNICODE_CHAR_CLASS\".equals(s)) || (\"UNICODE_CHARACTER_CLASS\".equals(s))) {\n                pFlags |= UNICODE_CHARACTER_CLASS;\n            } else {\n                throw new IllegalArgumentException(\"Unknown regex flag [\" + s + \"]\");"}
{"magic_number_smell": "        try (ChecksumIndexInput input = directory.openChecksumInput(KEYSTORE_FILENAME, IOContext.READONCE)) {\n            final int formatVersion;\n            try {\n                formatVersion = CodecUtil.checkHeader(input, KEYSTORE_FILENAME, 3, CURRENT_VERSION);\n            } catch (IndexFormatTooOldException e) {\n                throw new IllegalStateException(\n                    \"The Elasticsearch keystore [\"", "refactored_code": "    private static final int MIN_FORMAT_VERSION = 3;\n        try (ChecksumIndexInput input = directory.openChecksumInput(KEYSTORE_FILENAME, IOContext.READONCE)) {\n            final int formatVersion;\n            try {\n                formatVersion = CodecUtil.checkHeader(input, KEYSTORE_FILENAME, MIN_FORMAT_VERSION, CURRENT_VERSION);\n            } catch (IndexFormatTooOldException e) {\n                throw new IllegalStateException(\n                    \"The Elasticsearch keystore [\""}
{"magic_number_smell": "            }\n        }\n\n        return (year * 365L + (leapYears - 719527)) * MILLIS_PER_DAY; // millis per day\n    }\n\n    static boolean isLeapYear(final int year) {", "refactored_code": "    private static final int DAYS_0000_TO_1970 = 719527;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * MILLIS_PER_DAY; // millis per day\n    }\n\n    static boolean isLeapYear(final int year) {"}
{"magic_number_smell": "    private static final EpochField NEGATIVE_SIGN_FIELD = new EpochField(\n        ChronoUnit.FOREVER,\n        ChronoUnit.FOREVER,\n        ValueRange.of(-1, -1)\n    ) {\n        @Override\n        public boolean isSupportedBy(TemporalAccessor temporal) {", "refactored_code": "    private static final long NEGATIVE_SIGN_PLACEHOLDER = -1;\n    private static final EpochField NEGATIVE_SIGN_FIELD = new EpochField(\n        ChronoUnit.FOREVER,\n        ChronoUnit.FOREVER,\n        ValueRange.of(NEGATIVE_SIGN_PLACEHOLDER, NEGATIVE_SIGN_PLACEHOLDER)\n    ) {\n        @Override\n        public boolean isSupportedBy(TemporalAccessor temporal) {"}
{"magic_number_smell": "    private final double count;\n\n    private Processors(double count) {\n        // Avoid rounding up to 1E-5 when 0 processors are used\n        if (count == 0.0) {\n            this.count = count;\n        } else {", "refactored_code": "    private static final double MIN_REPRESENTABLE_PROCESSORS = 1E-5;\n    private final double count;\n\n    private Processors(double count) {\n        // Avoid rounding up to MIN_REPRESENTABLE_PROCESSORS when 0 processors are used\n        if (count == 0.0) {\n            this.count = count;\n        } else {"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        return RamUsageEstimator.shallowSizeOfInstance(BitArray.class) + RamUsageEstimator.sizeOf(bits);\n    }\n\n    @Override", "refactored_code": "    private static final long BASE_RAM_BYTES_USED = RamUsageEstimator.shallowSizeOfInstance(BitArray.class);\n\n    @Override\n    public long ramBytesUsed() {\n        return BASE_RAM_BYTES_USED + RamUsageEstimator.sizeOf(bits);\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        return RamUsageEstimator.shallowSizeOfInstance(BytesRefArray.class) + bigArraysRamBytesUsed();\n    }\n\n    /**", "refactored_code": "    private static final long BASE_RAM_BYTES_USED = RamUsageEstimator.shallowSizeOfInstance(BytesRefArray.class);\n\n    @Override\n    public long ramBytesUsed() {\n        return BASE_RAM_BYTES_USED + bigArraysRamBytesUsed();\n    }\n\n    /**"}
{"magic_number_smell": "    }\n\n    private static double log2(double x) {\n        return Math.log(x) / Math.log(2);\n    }\n\n    public long getSizeInBytes() {", "refactored_code": "    private static final double LN_2 = Math.log(2);\n    }\n\n    private static double log2(double x) {\n        return Math.log(x) / LN_2;\n    }\n\n    public long getSizeInBytes() {"}
{"magic_number_smell": "\n    /** Page size in bytes: 16KB */\n    public static final int 1 << 14 = 1 << 14;\n    public static final int OBJECT_PAGE_SIZE = 1 << 14 / RamUsageEstimator.NUM_BYTES_OBJECT_REF;\n    public static final int LONG_PAGE_SIZE = 1 << 14 / Long.BYTES;\n    public static final int INT_PAGE_SIZE = 1 << 14 / Integer.BYTES;\n    public static final int FLOAT_PAGE_SIZE = 1 << 14 / Float.BYTES;", "refactored_code": "    public static final int PAGE_SIZE_IN_BYTES = 1 << 14;\n\n    /** Page size in bytes: 16KB */\n    public static final int PAGE_SIZE_IN_BYTES = 1 << 14;\n    public static final int OBJECT_PAGE_SIZE = PAGE_SIZE_IN_BYTES / RamUsageEstimator.NUM_BYTES_OBJECT_REF;\n    public static final int LONG_PAGE_SIZE = PAGE_SIZE_IN_BYTES / Long.BYTES;\n    public static final int INT_PAGE_SIZE = PAGE_SIZE_IN_BYTES / Integer.BYTES;\n    public static final int FLOAT_PAGE_SIZE = PAGE_SIZE_IN_BYTES / Float.BYTES;"}
{"magic_number_smell": "         * If we return the size of the buffer that we've sliced\n         * we're likely to double count things.\n         */\n        return RamUsageEstimator.shallowSizeOfInstance(ReleasableByteArray.class);\n    }\n\n    @Override", "refactored_code": "    private static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(ReleasableByteArray.class);\n         * If we return the size of the buffer that we've sliced\n         * we're likely to double count things.\n         */\n        return SHALLOW_SIZE;\n    }\n\n    @Override"}
{"magic_number_smell": "         * If we return the size of the buffer that we've sliced\n         * we're likely to double count things.\n         */\n        return RamUsageEstimator.shallowSizeOfInstance(ReleasableDoubleArray.class);\n    }\n\n    @Override", "refactored_code": "    private static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(ReleasableDoubleArray.class);\n         * If we return the size of the buffer that we've sliced\n         * we're likely to double count things.\n         */\n        return SHALLOW_SIZE;\n    }\n\n    @Override"}
{"magic_number_smell": "         * If we return the size of the buffer that we've sliced\n         * we're likely to double count things.\n         */\n        return RamUsageEstimator.shallowSizeOfInstance(ReleasableIntArray.class);\n    }\n\n    @Override", "refactored_code": "    private static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(ReleasableIntArray.class);\n         * If we return the size of the buffer that we've sliced\n         * we're likely to double count things.\n         */\n        return SHALLOW_SIZE;\n    }\n\n    @Override"}
{"magic_number_smell": "         * If we return the size of the buffer that we've sliced\n         * we're likely to double count things.\n         */\n        return RamUsageEstimator.shallowSizeOfInstance(ReleasableLongArray.class);\n    }\n\n    @Override", "refactored_code": "    private static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(ReleasableLongArray.class);\n         * If we return the size of the buffer that we've sliced\n         * we're likely to double count things.\n         */\n        return SHALLOW_SIZE;\n    }\n\n    @Override"}
{"magic_number_smell": "\n        // We have to ensure that, in the worst case, two full sets can be converted into\n        // one cuckoo filter without overflowing. This keeps merging logic simpler\n        if (threshold * 2 > 1000000) {\n            throw new IllegalArgumentException(\"[threshold] must be smaller than [\" + (1000000 / 2) + \"]\");\n        }\n        if (fpp < 0) {", "refactored_code": "    private static final int FILTER_CAPACITY = 1000000;\n\n        // We have to ensure that, in the worst case, two full sets can be converted into\n        // one cuckoo filter without overflowing. This keeps merging logic simpler\n        if (threshold * 2 > FILTER_CAPACITY) {\n            throw new IllegalArgumentException(\"[threshold] must be smaller than [\" + (FILTER_CAPACITY / 2) + \"]\");\n        }\n        if (fpp < 0) {"}
{"magic_number_smell": "            return res;\n        }\n        final String interned = string.intern();\n        if (map.size() > 1000) {\n            map.clear();\n        }\n        map.put(interned, interned);", "refactored_code": "    private static final int MAX_SIZE = 1000;\n            return res;\n        }\n        final String interned = string.intern();\n        if (map.size() > MAX_SIZE) {\n            map.clear();\n        }\n        map.put(interned, interned);"}
{"magic_number_smell": "     */\n    public static final Setting<Processors> NODE_PROCESSORS_SETTING = new Setting<>(\n        \"node.processors\",\n        Double.toString(Runtime.getRuntime().availableProcessors()),\n        textValue -> {\n            double numberOfProcessors = Double.parseDouble(textValue);\n            if (Double.isNaN(numberOfProcessors) || Double.isInfinite(numberOfProcessors)) {", "refactored_code": "    private static final int MAX_NUM_PROCESSORS = Runtime.getRuntime().availableProcessors();\n     */\n    public static final Setting<Processors> NODE_PROCESSORS_SETTING = new Setting<>(\n        \"node.processors\",\n        Double.toString(MAX_NUM_PROCESSORS),\n        textValue -> {\n            double numberOfProcessors = Double.parseDouble(textValue);\n            if (Double.isNaN(numberOfProcessors) || Double.isInfinite(numberOfProcessors)) {"}
{"magic_number_smell": "        } else {\n            Automaton includeA = Regex.simpleMatchToAutomaton(includes);\n            includeA = makeMatchDotsInFieldNames(includeA);\n            include = new CharacterRunAutomaton(includeA, 50_000);\n        }\n\n        Automaton excludeA;", "refactored_code": "    private static final int MAX_DETERMINIZED_STATES = 50_000;\n        } else {\n            Automaton includeA = Regex.simpleMatchToAutomaton(includes);\n            includeA = makeMatchDotsInFieldNames(includeA);\n            include = new CharacterRunAutomaton(includeA, MAX_DETERMINIZED_STATES);\n        }\n\n        Automaton excludeA;"}
{"magic_number_smell": "            try (IndexInput indexInput = dir.openInput(file.getFileName().toString(), IOContext.DEFAULT)) {\n                // We checksum the entire file before we even go and parse it. If it's corrupted we barf right here.\n                CodecUtil.checksumEntireFile(indexInput);\n                final int format = CodecUtil.checkHeader(indexInput, STATE_FILE_CODEC, 1, CURRENT_VERSION);\n                final XContentType xContentType;\n                if (format < LE_VERSION) {\n                    xContentType = XContentType.values()[Integer.reverseBytes(indexInput.readInt())];", "refactored_code": "    private static final int MIN_COMPATIBLE_STATE_FILE_VERSION = 1;\n            try (IndexInput indexInput = dir.openInput(file.getFileName().toString(), IOContext.DEFAULT)) {\n                // We checksum the entire file before we even go and parse it. If it's corrupted we barf right here.\n                CodecUtil.checksumEntireFile(indexInput);\n                final int format = CodecUtil.checkHeader(indexInput, STATE_FILE_CODEC, MIN_COMPATIBLE_STATE_FILE_VERSION, CURRENT_VERSION);\n                final XContentType xContentType;\n                if (format < LE_VERSION) {\n                    xContentType = XContentType.values()[Integer.reverseBytes(indexInput.readInt())];"}
{"magic_number_smell": "                        }\n\n                        final int pageIndex = document.getField(PAGE_FIELD_NAME).numericValue().intValue();\n                        final boolean isLastPage = document.getField(LAST_PAGE_FIELD_NAME).numericValue().intValue() == 1;\n\n                        if (pageIndex == 0 && isLastPage) {\n                            // common case: metadata fits in a single page", "refactored_code": "    public static final int IS_LAST_PAGE = 1;\n                        }\n\n                        final int pageIndex = document.getField(PAGE_FIELD_NAME).numericValue().intValue();\n                        final boolean isLastPage = document.getField(LAST_PAGE_FIELD_NAME).numericValue().intValue() == IS_LAST_PAGE;\n\n                        if (pageIndex == 0 && isLastPage) {\n                            // common case: metadata fits in a single page"}
{"magic_number_smell": "\n    private static final int getBucketUpperBounds().length + 1 = getBucketUpperBounds().length + 1;\n\n    private static final int LAST_BUCKET_LOWER_BOUND = getBucketUpperBounds()[getBucketUpperBounds().length + 1 - 2];\n\n    private record StatsTracker(LongAdder count, LongAdder totalSize, AtomicLongArray histogram) {\n        StatsTracker {", "refactored_code": "    private static final int BUCKET_COUNT = getBucketUpperBounds().length + 1;\n\n    private static final int BUCKET_COUNT = getBucketUpperBounds().length + 1;\n\n    private static final int LAST_BUCKET_LOWER_BOUND = getBucketUpperBounds()[BUCKET_COUNT - 2];\n\n    private record StatsTracker(LongAdder count, LongAdder totalSize, AtomicLongArray histogram) {\n        StatsTracker {"}
{"magic_number_smell": "                builder.field(Fields.CLIENT_OPAQUE_ID, opaqueId);\n            }\n            builder.field(Fields.CLIENT_OPENED_TIME_MILLIS, openedTimeMillis);\n            if (closedTimeMillis != -1L) {\n                builder.field(Fields.CLIENT_CLOSED_TIME_MILLIS, closedTimeMillis);\n            }\n            builder.field(Fields.CLIENT_LAST_REQUEST_TIME_MILLIS, lastRequestTimeMillis);", "refactored_code": "        public static final long NOT_CLOSED = -1L;\n                builder.field(Fields.CLIENT_OPAQUE_ID, opaqueId);\n            }\n            builder.field(Fields.CLIENT_OPENED_TIME_MILLIS, openedTimeMillis);\n            if (closedTimeMillis != NOT_CLOSED) {\n                builder.field(Fields.CLIENT_CLOSED_TIME_MILLIS, closedTimeMillis);\n            }\n            builder.field(Fields.CLIENT_LAST_REQUEST_TIME_MILLIS, lastRequestTimeMillis);"}
{"magic_number_smell": "\n    public static final Setting<Double> INDEX_MERGE_POLICY_EXPUNGE_DELETES_ALLOWED_SETTING = Setting.doubleSetting(\n        \"index.merge.policy.expunge_deletes_allowed\",\n        10d,\n        0.0d,\n        Property.Dynamic,\n        Property.IndexScope,", "refactored_code": "    public static final double DEFAULT_EXPUNGE_DELETES_ALLOWED = 10d;\n\n    public static final Setting<Double> INDEX_MERGE_POLICY_EXPUNGE_DELETES_ALLOWED_SETTING = Setting.doubleSetting(\n        \"index.merge.policy.expunge_deletes_allowed\",\n        DEFAULT_EXPUNGE_DELETES_ALLOWED,\n        0.0d,\n        Property.Dynamic,\n        Property.IndexScope,"}
{"magic_number_smell": "    static final class StatsHolder {\n        final MeanMetric shardBulkMetric = new MeanMetric();\n        final CounterMetric totalSizeInBytes = new CounterMetric();\n        ExponentiallyWeightedMovingAverage timeInMillis = new ExponentiallyWeightedMovingAverage(0.1, 0.0);\n        ExponentiallyWeightedMovingAverage sizeInBytes = new ExponentiallyWeightedMovingAverage(0.1, 0.0);\n\n        BulkStats stats() {", "refactored_code": "    private static final double ALPHA = 0.1;\n    static final class StatsHolder {\n        final MeanMetric shardBulkMetric = new MeanMetric();\n        final CounterMetric totalSizeInBytes = new CounterMetric();\n        ExponentiallyWeightedMovingAverage timeInMillis = new ExponentiallyWeightedMovingAverage(ALPHA, 0.0);\n        ExponentiallyWeightedMovingAverage sizeInBytes = new ExponentiallyWeightedMovingAverage(ALPHA, 0.0);\n\n        BulkStats stats() {"}
{"magic_number_smell": "\n    public static final int 128 = 128;\n    private static final int BLOCK_SIZE_LOG2 = 7;\n    private final long[] tmp = new long[128 / 2];\n\n    private static long expandMask32(long mask32) {\n        return mask32 | (mask32 << 32);", "refactored_code": "    public static final int BLOCK_SIZE = 128;\n\n    public static final int BLOCK_SIZE = 128;\n    private static final int BLOCK_SIZE_LOG2 = 7;\n    private final long[] tmp = new long[BLOCK_SIZE / 2];\n\n    private static long expandMask32(long mask32) {\n        return mask32 | (mask32 << 32);"}
{"magic_number_smell": "            throw new IllegalStateException(\"maxDocs must be greater than or equal to 1, got \" + maxDocs);\n        }\n        // 10% saturation (i.e., 10 bits for each term)\n        long numBits = maxDocs * (long) 10;\n        // Round to the next multiple of 8 since we can only store whole bytes\n        numBits = ((numBits - 1) | 0x07L) + 1;\n        if (numBits > Integer.MAX_VALUE) {", "refactored_code": "    private static final int BITS_PER_ENTRY = 10;\n            throw new IllegalStateException(\"maxDocs must be greater than or equal to 1, got \" + maxDocs);\n        }\n        // 10% saturation (i.e., 10 bits for each term)\n        long numBits = maxDocs * (long) BITS_PER_ENTRY;\n        // Round to the next multiple of 8 since we can only store whole bytes\n        numBits = ((numBits - 1) | 0x07L) + 1;\n        if (numBits > Integer.MAX_VALUE) {"}
{"magic_number_smell": "\n        /**\n         * file offset for the start of the skip list, relative to docStartFP, if there are more than\n         * {@link ForUtil#ForUtil.BLOCK_SIZE} docs; otherwise -1\n         */\n        public long skipOffset;\n", "refactored_code": "    public static final int BLOCK_SIZE = ForUtil.BLOCK_SIZE;\n\n        /**\n         * file offset for the start of the skip list, relative to docStartFP, if there are more than\n         * {@link ForUtil#BLOCK_SIZE} docs; otherwise -1\n         */\n        public long skipOffset;\n"}
{"magic_number_smell": "    private final ForUtil forUtil;\n    // buffer for reading exception data; each exception uses two bytes (pos + high-order bits of the\n    // exception)\n    private final byte[] exceptionBuff = new byte[7 * 2];\n\n    PForUtil(ForUtil forUtil) {\n        assert ForUtil.BLOCK_SIZE <= 256 : \"blocksize must fit in one byte. got \" + ForUtil.BLOCK_SIZE;", "refactored_code": "    private static final int MAX_EXCEPTIONS = 7;\n    private final ForUtil forUtil;\n    // buffer for reading exception data; each exception uses two bytes (pos + high-order bits of the\n    // exception)\n    private final byte[] exceptionBuff = new byte[MAX_EXCEPTIONS * 2];\n\n    PForUtil(ForUtil forUtil) {\n        assert ForUtil.BLOCK_SIZE <= 256 : \"blocksize must fit in one byte. got \" + ForUtil.BLOCK_SIZE;"}
{"magic_number_smell": "\n    public static int roundBits(int bitsPerValue) {\n        if (bitsPerValue > 24 && bitsPerValue <= 32) {\n            return 4 * Byte.SIZE;\n        } else if (bitsPerValue > 32 && bitsPerValue <= BITS_IN_FIVE_BYTES) {\n            return BITS_IN_FIVE_BYTES;\n        } else if (bitsPerValue > BITS_IN_FIVE_BYTES && bitsPerValue <= BITS_IN_SIX_BYTES) {", "refactored_code": "    private static final int BITS_IN_FOUR_BYTES = 4 * Byte.SIZE;\n\n    public static int roundBits(int bitsPerValue) {\n        if (bitsPerValue > 24 && bitsPerValue <= 32) {\n            return BITS_IN_FOUR_BYTES;\n        } else if (bitsPerValue > 32 && bitsPerValue <= BITS_IN_FIVE_BYTES) {\n            return BITS_IN_FIVE_BYTES;\n        } else if (bitsPerValue > BITS_IN_FIVE_BYTES && bitsPerValue <= BITS_IN_SIX_BYTES) {"}
{"magic_number_smell": "\n    static final int NUMERIC_BLOCK_SHIFT = 7;\n    public static final int 1 << NUMERIC_BLOCK_SHIFT = 1 << NUMERIC_BLOCK_SHIFT;\n    static final int NUMERIC_BLOCK_MASK = 1 << NUMERIC_BLOCK_SHIFT - 1;\n    static final int DIRECT_MONOTONIC_BLOCK_SHIFT = 16;\n    static final String CODEC_NAME = \"ES87TSDB\";\n    static final String DATA_CODEC = \"ES87TSDBDocValuesData\";", "refactored_code": "    public static final int NUMERIC_BLOCK_SIZE = 1 << NUMERIC_BLOCK_SHIFT;\n\n    static final int NUMERIC_BLOCK_SHIFT = 7;\n    public static final int NUMERIC_BLOCK_SIZE = 1 << NUMERIC_BLOCK_SHIFT;\n    static final int NUMERIC_BLOCK_MASK = NUMERIC_BLOCK_SIZE - 1;\n    static final int DIRECT_MONOTONIC_BLOCK_SHIFT = 16;\n    static final String CODEC_NAME = \"ES87TSDB\";\n    static final String DATA_CODEC = \"ES87TSDBDocValuesData\";"}
{"magic_number_smell": "\n                    @Override\n                    public int advance(int target) throws IOException {\n                        if (target >= ES87TSDBDocValuesProducer.this.maxDoc) {\n                            return doc = NO_MORE_DOCS;\n                        }\n                        return doc = target;", "refactored_code": "                    private final int maxDoc = ES87TSDBDocValuesProducer.this.maxDoc;\n\n                    @Override\n                    public int advance(int target) throws IOException {\n                        if (target >= maxDoc) {\n                            return doc = NO_MORE_DOCS;\n                        }\n                        return doc = target;"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        return RamUsageEstimator.shallowSizeOfInstance(DeleteVersionValue.class);\n    }\n\n    @Override", "refactored_code": "    private static final long BASE_RAM_BYTES_USED = RamUsageEstimator.shallowSizeOfInstance(DeleteVersionValue.class);\n\n    @Override\n    public long ramBytesUsed() {\n        return BASE_RAM_BYTES_USED;\n    }\n\n    @Override"}
{"magic_number_smell": "     */\n    @Deprecated\n    public void addSegmentGenerationListener(long minGeneration, ActionListener<Long> listener) {\n        addPrimaryTermAndGenerationListener(-1L, minGeneration, listener);\n    }\n\n    /**", "refactored_code": "    public static final long UNKNOWN_PRIMARY_TERM = -1L;\n     */\n    @Deprecated\n    public void addSegmentGenerationListener(long minGeneration, ActionListener<Long> listener) {\n        addPrimaryTermAndGenerationListener(UNKNOWN_PRIMARY_TERM, minGeneration, listener);\n    }\n\n    /**"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        return RamUsageEstimator.shallowSizeOfInstance(IndexVersionValue.class) + RamUsageEstimator.shallowSizeOf(translogLocation);\n    }\n\n    @Override", "refactored_code": "    private static final long RAM_BYTES_USED = RamUsageEstimator.shallowSizeOfInstance(IndexVersionValue.class);\n\n    @Override\n    public long ramBytesUsed() {\n        return RAM_BYTES_USED + RamUsageEstimator.shallowSizeOf(translogLocation);\n    }\n\n    @Override"}
{"magic_number_smell": "        for (int i = 0; i < size; i++) {\n            String field = in.readString();\n            byte type = in.readByte();\n            if (type == 0) {\n                Boolean missingFirst = in.readOptionalBoolean();\n                boolean max = in.readBoolean();\n                boolean reverse = in.readBoolean();", "refactored_code": "    private static final byte SORT_STRING_SET = 0;\n        for (int i = 0; i < size; i++) {\n            String field = in.readString();\n            byte type = in.readByte();\n            if (type == SORT_STRING_SET) {\n                Boolean missingFirst = in.readOptionalBoolean();\n                boolean max = in.readBoolean();\n                boolean reverse = in.readBoolean();"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        return RamUsageEstimator.shallowSizeOfInstance(VersionValue.class);\n    }\n\n    @Override", "refactored_code": "    private static final long BASE_RAM_BYTES_USED = RamUsageEstimator.shallowSizeOfInstance(VersionValue.class);\n\n    @Override\n    public long ramBytesUsed() {\n        return BASE_RAM_BYTES_USED;\n    }\n\n    @Override"}
{"magic_number_smell": "            flush();\n        } else {\n            this.flushBuffer += estimator.bytesPerValue(term);\n            if (this.flushBuffer >= 1024 * 1024 * 5) {\n                flush();\n            }\n        }", "refactored_code": "    private static final long FLUSH_BUFFER_SIZE = 1024 * 1024 * 5;\n            flush();\n        } else {\n            this.flushBuffer += estimator.bytesPerValue(term);\n            if (this.flushBuffer >= FLUSH_BUFFER_SIZE) {\n                flush();\n            }\n        }"}
{"magic_number_smell": "        // Compute the worst-case number of bits per value for offsets in the worst case, eg. if no docs have a value at the\n        // beginning of the block and all docs have one at the end of the block\n        final float avgValuesPerDoc = (float) numDocsWithValue / maxDoc;\n        final int maxDelta = (int) Math.ceil(1024 * (1 - avgValuesPerDoc) * avgValuesPerDoc);\n        int bitsPerOffset = PackedInts.bitsRequired(maxDelta) + 1; // +1 because of the sign\n        bitsPerOffset = PackedInts.fastestFormatAndBits(maxDoc, bitsPerOffset, acceptableOverheadRatio).bitsPerValue;\n", "refactored_code": "    private static final int OFFSETS_PAGE_SIZE = 1024;\n        // Compute the worst-case number of bits per value for offsets in the worst case, eg. if no docs have a value at the\n        // beginning of the block and all docs have one at the end of the block\n        final float avgValuesPerDoc = (float) numDocsWithValue / maxDoc;\n        final int maxDelta = (int) Math.ceil(OFFSETS_PAGE_SIZE * (1 - avgValuesPerDoc) * avgValuesPerDoc);\n        int bitsPerOffset = PackedInts.bitsRequired(maxDelta) + 1; // +1 because of the sign\n        bitsPerOffset = PackedInts.fastestFormatAndBits(maxDoc, bitsPerOffset, acceptableOverheadRatio).bitsPerValue;\n"}
{"magic_number_smell": "    }\n\n    public OrdinalsBuilder(int maxDoc) {\n        this(maxDoc, PackedInts.FAST);\n    }\n\n    /**", "refactored_code": "    public static final float DEFAULT_ACCEPTABLE_OVERHEAD_RATIO = PackedInts.FAST;\n    }\n\n    public OrdinalsBuilder(int maxDoc) {\n        this(maxDoc, DEFAULT_ACCEPTABLE_OVERHEAD_RATIO);\n    }\n\n    /**"}
{"magic_number_smell": "            \"max_input_length\",\n            true,\n            m -> builder(m).maxInputLength.get(),\n            Defaults.50\n        ).addDeprecatedName(\"max_input_len\").addValidator(Builder::validateInputLength).alwaysSerialize();\n        private final Parameter<Map<String, String>> meta = Parameter.metaParam();\n", "refactored_code": "        public static final int DEFAULT_MAX_INPUT_LENGTH = 50;\n            \"max_input_length\",\n            true,\n            m -> builder(m).maxInputLength.get(),\n            Defaults.DEFAULT_MAX_INPUT_LENGTH\n        ).addDeprecatedName(\"max_input_len\").addValidator(Builder::validateInputLength).alwaysSerialize();\n        private final Parameter<Map<String, String>> meta = Parameter.metaParam();\n"}
{"magic_number_smell": "                throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] doesn't support formats.\");\n            }\n\n            return new SourceValueFetcher(name(), context, 1) {\n                @Override\n                protected Object parseSourceValue(Object value) {\n                    if (\"\".equals(value)) {", "refactored_code": "        public static final int DEFAULT_VALUE = 1;\n                throw new IllegalArgumentException(\"Field [\" + name() + \"] of type [\" + typeName() + \"] doesn't support formats.\");\n            }\n\n            return new SourceValueFetcher(name(), context, DEFAULT_VALUE) {\n                @Override\n                protected Object parseSourceValue(Object value) {\n                    if (\"\".equals(value)) {"}
{"magic_number_smell": "            \"ignore_above\",\n            true,\n            m -> toType(m).fieldType().ignoreAbove(),\n            Defaults.Integer.MAX_VALUE\n        );\n\n        private final Parameter<String> indexOptions = TextParams.keywordIndexOptions(m -> toType(m).indexOptions);", "refactored_code": "        public static final int IGNORE_ABOVE = Integer.MAX_VALUE;\n            \"ignore_above\",\n            true,\n            m -> toType(m).fieldType().ignoreAbove(),\n            Defaults.IGNORE_ABOVE\n        );\n\n        private final Parameter<String> indexOptions = TextParams.keywordIndexOptions(m -> toType(m).indexOptions);"}
{"magic_number_smell": "            MapperBuilderContext context,\n            int level\n        ) {\n            if (level >= 20) {\n                logger.warn(\"Exceeded maximum nesting level for searching for pass-through object fields within object fields.\");\n                return;\n            }", "refactored_code": "    private static final int MAX_NESTING_LEVEL_FOR_PASS_THROUGH_OBJECTS = 20;\n            MapperBuilderContext context,\n            int level\n        ) {\n            if (level >= MAX_NESTING_LEVEL_FOR_PASS_THROUGH_OBJECTS) {\n                logger.warn(\"Exceeded maximum nesting level for searching for pass-through object fields within object fields.\");\n                return;\n            }"}
{"magic_number_smell": "    }\n\n    private static final FielddataFrequencyFilter DEFAULT_FILTER = new FielddataFrequencyFilter(\n        Defaults.0,\n        Defaults.FIELDDATA_MAX_FREQUENCY,\n        Defaults.FIELDDATA_MIN_SEGMENT_SIZE\n    );", "refactored_code": "        public static final double FIELDDATA_MIN_FREQUENCY = 0;\n    }\n\n    private static final FielddataFrequencyFilter DEFAULT_FILTER = new FielddataFrequencyFilter(\n        Defaults.FIELDDATA_MIN_FREQUENCY,\n        Defaults.FIELDDATA_MAX_FREQUENCY,\n        Defaults.FIELDDATA_MIN_SEGMENT_SIZE\n    );"}
{"magic_number_smell": "                        dimensionValueBytesRef.bytes,\n                        dimensionValueBytesRef.offset,\n                        dimensionValueBytesRef.length,\n                        0\n                    ),\n                    tsidHash,\n                    tsidHashIndex", "refactored_code": "        private static final int SEED = 0;\n                        dimensionValueBytesRef.bytes,\n                        dimensionValueBytesRef.offset,\n                        dimensionValueBytesRef.length,\n                        SEED\n                    ),\n                    tsidHash,\n                    tsidHashIndex"}
{"magic_number_smell": "\n    public static String createId(int routingHash, BytesRef tsid, long timestamp) {\n        Hash128 hash = new Hash128();\n        MurmurHash3.hash128(tsid.bytes, tsid.offset, tsid.length, 0, hash);\n\n        byte[] bytes = new byte[20];\n        ByteUtils.writeIntLE(routingHash, bytes, 0);", "refactored_code": "    private static final long SEED = 0;\n\n    public static String createId(int routingHash, BytesRef tsid, long timestamp) {\n        Hash128 hash = new Hash128();\n        MurmurHash3.hash128(tsid.bytes, tsid.offset, tsid.length, SEED, hash);\n\n        byte[] bytes = new byte[20];\n        ByteUtils.writeIntLE(routingHash, bytes, 0);"}
{"magic_number_smell": "            \"depth_limit\",\n            true,\n            m -> builder(m).depthLimit.get(),\n            Defaults.20\n        ).addValidator(v -> {\n            if (v < 0) {\n                throw new IllegalArgumentException(\"[depth_limit] must be positive, got [\" + v + \"]\");", "refactored_code": "        public static final int DEPTH_LIMIT = 20;\n            \"depth_limit\",\n            true,\n            m -> builder(m).depthLimit.get(),\n            Defaults.DEPTH_LIMIT\n        ).addValidator(v -> {\n            if (v < 0) {\n                throw new IllegalArgumentException(\"[depth_limit] must be positive, got [\" + v + \"]\");"}
{"magic_number_smell": "    static BytesRef extractKey(BytesRef keyedValue) {\n        int length;\n        for (length = 0; length < keyedValue.length; length++) {\n            if (keyedValue.bytes[keyedValue.offset + length] == '\u0000') {\n                break;\n            }\n        }", "refactored_code": "    private static final byte SEPARATOR_BYTE = '\\0';\n    static BytesRef extractKey(BytesRef keyedValue) {\n        int length;\n        for (length = 0; length < keyedValue.length; length++) {\n            if (keyedValue.bytes[keyedValue.offset + length] == SEPARATOR_BYTE) {\n                break;\n            }\n        }"}
{"magic_number_smell": "    private static final float 1e-4f = 1e-4f;\n\n    static boolean isNotUnitVector(float magnitude) {\n        return Math.abs(magnitude - 1.0f) > 1e-4f;\n    }\n\n    public static final IndexVersion MAGNITUDE_STORED_INDEX_VERSION = IndexVersions.V_7_5_0;", "refactored_code": "    private static final float EPS = 1e-4f;\n    private static final float EPS = 1e-4f;\n\n    static boolean isNotUnitVector(float magnitude) {\n        return Math.abs(magnitude - 1.0f) > EPS;\n    }\n\n    public static final IndexVersion MAGNITUDE_STORED_INDEX_VERSION = IndexVersions.V_7_5_0;"}
{"magic_number_smell": "\n    public static int denseVectorLength(IndexVersion indexVersion, BytesRef vectorBR) {\n        return indexVersion.onOrAfter(MAGNITUDE_STORED_INDEX_VERSION)\n            ? (vectorBR.length - 4) / 4\n            : vectorBR.length / 4;\n    }\n", "refactored_code": "    public static final byte INT_BYTES = 4;\n\n    public static int denseVectorLength(IndexVersion indexVersion, BytesRef vectorBR) {\n        return indexVersion.onOrAfter(MAGNITUDE_STORED_INDEX_VERSION)\n            ? (vectorBR.length - INT_BYTES) / INT_BYTES\n            : vectorBR.length / INT_BYTES;\n    }\n"}
{"magic_number_smell": "    private static int maxNestedDepth = INDICES_MAX_NESTED_DEPTH_SETTING.getDefault(Settings.EMPTY);\n\n    protected String queryName;\n    protected float boost = 1.0f;\n\n    protected AbstractQueryBuilder() {\n", "refactored_code": "    public static final float DEFAULT_BOOST = 1.0f;\n    private static int maxNestedDepth = INDICES_MAX_NESTED_DEPTH_SETTING.getDefault(Settings.EMPTY);\n\n    protected String queryName;\n    protected float boost = DEFAULT_BOOST;\n\n    protected AbstractQueryBuilder() {\n"}
{"magic_number_smell": "\n    private final List<QueryBuilder> queries = new ArrayList<>();\n\n    private float tieBreaker = 0.0f;\n\n    public DisMaxQueryBuilder() {}\n", "refactored_code": "    public static final float DEFAULT_TIE_BREAKER = 0.0f;\n\n    private final List<QueryBuilder> queries = new ArrayList<>();\n\n    private float tieBreaker = DEFAULT_TIE_BREAKER;\n\n    public DisMaxQueryBuilder() {}\n"}
{"magic_number_smell": "    private String name;\n    private boolean ignoreUnmapped = DEFAULT_IGNORE_UNAMPPED;\n\n    private int from = 0;\n    private int size = DEFAULT_SIZE;\n    private boolean explain = DEFAULT_EXPLAIN;\n    private boolean version = DEFAULT_VERSION;", "refactored_code": "    private static final int DEFAULT_FROM = 0;\n    private String name;\n    private boolean ignoreUnmapped = DEFAULT_IGNORE_UNAMPPED;\n\n    private int from = DEFAULT_FROM;\n    private int size = DEFAULT_SIZE;\n    private boolean explain = DEFAULT_EXPLAIN;\n    private boolean version = DEFAULT_VERSION;"}
{"magic_number_smell": "    private Item[] unlikeItems = new Item[0];\n\n    // term selection parameters\n    private int maxQueryTerms = XMoreLikeThis.DEFAULT_MAX_QUERY_TERMS;\n    private int minTermFreq = DEFAULT_MIN_TERM_FREQ;\n    private int minDocFreq = DEFAULT_MIN_DOC_FREQ;\n    private int maxDocFreq = DEFAULT_MAX_DOC_FREQ;", "refactored_code": "    public static final int DEFAULT_MAX_QUERY_TERMS = XMoreLikeThis.DEFAULT_MAX_QUERY_TERMS;\n    private Item[] unlikeItems = new Item[0];\n\n    // term selection parameters\n    private int maxQueryTerms = DEFAULT_MAX_QUERY_TERMS;\n    private int minTermFreq = DEFAULT_MIN_TERM_FREQ;\n    private int minDocFreq = DEFAULT_MIN_DOC_FREQ;\n    private int maxDocFreq = DEFAULT_MAX_DOC_FREQ;"}
{"magic_number_smell": "    private Type type = DEFAULT_TYPE;\n    private Operator operator = DEFAULT_OPERATOR;\n    private String analyzer;\n    private int slop = MatchQueryParser.DEFAULT_PHRASE_SLOP;\n    private Fuzziness fuzziness;\n    private int prefixLength = DEFAULT_PREFIX_LENGTH;\n    private int maxExpansions = DEFAULT_MAX_EXPANSIONS;", "refactored_code": "    public static final int DEFAULT_PHRASE_SLOP = MatchQueryParser.DEFAULT_PHRASE_SLOP;\n    private Type type = DEFAULT_TYPE;\n    private Operator operator = DEFAULT_OPERATOR;\n    private String analyzer;\n    private int slop = DEFAULT_PHRASE_SLOP;\n    private Fuzziness fuzziness;\n    private int prefixLength = DEFAULT_PREFIX_LENGTH;\n    private int maxExpansions = DEFAULT_MAX_EXPANSIONS;"}
{"magic_number_smell": "    private ZoneId timeZone;\n\n    /** To limit effort spent determinizing regexp queries. */\n    private int maxDeterminizedStates = Operations.DEFAULT_DETERMINIZE_WORK_LIMIT;\n\n    private boolean autoGenerateSynonymsPhraseQuery = true;\n", "refactored_code": "    public static final int DEFAULT_MAX_DETERMINED_STATES = Operations.DEFAULT_DETERMINIZE_WORK_LIMIT;\n    private ZoneId timeZone;\n\n    /** To limit effort spent determinizing regexp queries. */\n    private int maxDeterminizedStates = DEFAULT_MAX_DETERMINED_STATES;\n\n    private boolean autoGenerateSynonymsPhraseQuery = true;\n"}
{"magic_number_smell": "\n    private final String value;\n\n    private int syntaxFlagsValue = RegexpFlag.ALL.value();\n    private boolean caseInsensitive = DEFAULT_CASE_INSENSITIVITY;\n\n    private int maxDeterminizedStates = DEFAULT_MAX_DETERMINIZED_STATES;", "refactored_code": "    public static final int DEFAULT_FLAGS_VALUE = RegexpFlag.ALL.value();\n\n    private final String value;\n\n    private int syntaxFlagsValue = DEFAULT_FLAGS_VALUE;\n    private boolean caseInsensitive = DEFAULT_CASE_INSENSITIVITY;\n\n    private int maxDeterminizedStates = DEFAULT_MAX_DETERMINIZED_STATES;"}
{"magic_number_smell": "    /** If result is a boolean query, minimumShouldMatch parameter to apply. Ignored otherwise. */\n    private String minimumShouldMatch;\n    /** Any search flags to be used, ALL by default. */\n    private int flags = SimpleQueryStringFlag.ALL.value;\n    /** Whether or not the lenient flag has been set or not */\n    private boolean lenientSet = false;\n", "refactored_code": "    public static final int DEFAULT_FLAGS = SimpleQueryStringFlag.ALL.value;\n    /** If result is a boolean query, minimumShouldMatch parameter to apply. Ignored otherwise. */\n    private String minimumShouldMatch;\n    /** Any search flags to be used, ALL by default. */\n    private int flags = DEFAULT_FLAGS;\n    /** Whether or not the lenient flag has been set or not */\n    private boolean lenientSet = false;\n"}
{"magic_number_smell": "\n    private final SpanQueryBuilder exclude;\n\n    private int pre = 0;\n\n    private int post = DEFAULT_POST;\n", "refactored_code": "    public static final int DEFAULT_PRE = 0;\n\n    private final SpanQueryBuilder exclude;\n\n    private int pre = DEFAULT_PRE;\n\n    private int post = DEFAULT_POST;\n"}
{"magic_number_smell": "     * Convenience constructor that converts its parameters into json to parse on the data nodes.\n     */\n    protected DecayFunctionBuilder(String fieldName, Object origin, Object scale, Object offset) {\n        this(fieldName, origin, scale, offset, 0.5);\n    }\n\n    /**", "refactored_code": "    public static final double DEFAULT_DECAY = 0.5;\n     * Convenience constructor that converts its parameters into json to parse on the data nodes.\n     */\n    protected DecayFunctionBuilder(String fieldName, Object origin, Object scale, Object offset) {\n        this(fieldName, origin, scale, offset, DEFAULT_DECAY);\n    }\n\n    /**"}
{"magic_number_smell": "    public static final float 1 = 1;\n\n    private final String field;\n    private float factor = 1;\n    private Double missing;\n    private FieldValueFactorFunction.Modifier modifier = DEFAULT_MODIFIER;\n", "refactored_code": "    public static final float DEFAULT_FACTOR = 1;\n    public static final float DEFAULT_FACTOR = 1;\n\n    private final String field;\n    private float factor = DEFAULT_FACTOR;\n    private Double missing;\n    private FieldValueFactorFunction.Modifier modifier = DEFAULT_MODIFIER;\n"}
{"magic_number_smell": "     * Maximum number of processed documents. Defaults to -1 meaning process all\n     * documents.\n     */\n    private int maxDocs = -1;\n\n    /**\n     * Should version conflicts cause aborts? Defaults to true.", "refactored_code": "    public static final int MAX_DOCS_ALL_MATCHES = -1;\n     * Maximum number of processed documents. Defaults to -1 meaning process all\n     * documents.\n     */\n    private int maxDocs = MAX_DOCS_ALL_MATCHES;\n\n    /**\n     * Should version conflicts cause aborts? Defaults to true."}
{"magic_number_smell": "\n    protected boolean enablePositionIncrements = true;\n\n    protected int phraseSlop = 0;\n\n    protected Fuzziness fuzziness = null;\n", "refactored_code": "    public static final int DEFAULT_PHRASE_SLOP = 0;\n\n    protected boolean enablePositionIncrements = true;\n\n    protected int phraseSlop = DEFAULT_PHRASE_SLOP;\n\n    protected Fuzziness fuzziness = null;\n"}
{"magic_number_smell": "\n        AddOrRenewRequest(final ShardId shardId, final String id, final long retainingSequenceNumber, final String source) {\n            super(shardId, id);\n            if (retainingSequenceNumber < 0 && retainingSequenceNumber != -1) {\n                throw new IllegalArgumentException(\"retaining sequence number [\" + retainingSequenceNumber + \"] out of range\");\n            }\n            this.retainingSequenceNumber = retainingSequenceNumber;", "refactored_code": "    public static final long RETAIN_ALL = -1;\n\n        AddOrRenewRequest(final ShardId shardId, final String id, final long retainingSequenceNumber, final String source) {\n            super(shardId, id);\n            if (retainingSequenceNumber < 0 && retainingSequenceNumber != RETAIN_ALL) {\n                throw new IllegalArgumentException(\"retaining sequence number [\" + retainingSequenceNumber + \"] out of range\");\n            }\n            this.retainingSequenceNumber = retainingSequenceNumber;"}
{"magic_number_smell": "    /**\n     * Compute the minimum of the given current minimum sequence number and the specified sequence number, accounting for the fact that the\n     * current minimum sequence number could be {@link SequenceNumbers#NO_OPS_PERFORMED} or\n     * {@link SequenceNumbers#-2L}. When the current minimum sequence number is not\n     * {@link SequenceNumbers#NO_OPS_PERFORMED} nor {@link SequenceNumbers#-2L}, the specified sequence number\n     * must not be {@link SequenceNumbers#-2L}.\n     *", "refactored_code": "    public static final long UNASSIGNED_SEQ_NO = -2L;\n    /**\n     * Compute the minimum of the given current minimum sequence number and the specified sequence number, accounting for the fact that the\n     * current minimum sequence number could be {@link SequenceNumbers#NO_OPS_PERFORMED} or\n     * {@link SequenceNumbers#UNASSIGNED_SEQ_NO}. When the current minimum sequence number is not\n     * {@link SequenceNumbers#NO_OPS_PERFORMED} nor {@link SequenceNumbers#UNASSIGNED_SEQ_NO}, the specified sequence number\n     * must not be {@link SequenceNumbers#UNASSIGNED_SEQ_NO}.\n     *"}
{"magic_number_smell": "    public static final int -1 = -1;\n\n    /**\n     * Obtain the active operation count, or {@link IndexShard#-1} if all permits are held (even if there are\n     * outstanding operations in flight).\n     *\n     * @return the active operation count, or {@link IndexShard#-1} when all permits are held.", "refactored_code": "    public static final int OPERATIONS_BLOCKED = -1;\n    public static final int OPERATIONS_BLOCKED = -1;\n\n    /**\n     * Obtain the active operation count, or {@link IndexShard#OPERATIONS_BLOCKED} if all permits are held (even if there are\n     * outstanding operations in flight).\n     *\n     * @return the active operation count, or {@link IndexShard#OPERATIONS_BLOCKED} when all permits are held."}
{"magic_number_smell": "        if (in.getTransportVersion().onOrAfter(RESERVED_BYTES_VERSION)) {\n            reservedSizeInBytes = in.readZLong();\n        } else {\n            reservedSizeInBytes = -1L;\n        }\n    }\n", "refactored_code": "    public static final long UNKNOWN_RESERVED_BYTES = -1L;\n        if (in.getTransportVersion().onOrAfter(RESERVED_BYTES_VERSION)) {\n            reservedSizeInBytes = in.readZLong();\n        } else {\n            reservedSizeInBytes = UNKNOWN_RESERVED_BYTES;\n        }\n    }\n"}
{"magic_number_smell": "    private final StoreFileMetadata metadata;\n    private long writtenBytes;\n    private final long checksumPosition;\n    private final ByteBuffer computedChecksum = ByteBuffer.allocate(8); // computed from the bytes written before checksum\n    private final ByteBuffer footerChecksum = ByteBuffer.allocate(8); // accumulates the bytes written to the checksum\n\n    VerifyingIndexOutput(StoreFileMetadata metadata, IndexOutput out) throws IOException {", "refactored_code": "    private static final int CHECKSUM_LENGTH = 8;\n    private final StoreFileMetadata metadata;\n    private long writtenBytes;\n    private final long checksumPosition;\n    private final ByteBuffer computedChecksum = ByteBuffer.allocate(CHECKSUM_LENGTH); // computed from the bytes written before checksum\n    private final ByteBuffer footerChecksum = ByteBuffer.allocate(CHECKSUM_LENGTH); // accumulates the bytes written to the checksum\n\n    VerifyingIndexOutput(StoreFileMetadata metadata, IndexOutput out) throws IOException {"}
{"magic_number_smell": "            throw new IllegalArgumentException(\"numBytes must be >= 0, got \" + numBytes);\n        }\n        if (skipBuffer == null) {\n            skipBuffer = new byte[1024];\n        }\n        assert skipBuffer.length == 1024;\n        long skipped = 0;", "refactored_code": "    private static final int SKIP_BUFFER_SIZE = 1024;\n            throw new IllegalArgumentException(\"numBytes must be >= 0, got \" + numBytes);\n        }\n        if (skipBuffer == null) {\n            skipBuffer = new byte[SKIP_BUFFER_SIZE];\n        }\n        assert skipBuffer.length == SKIP_BUFFER_SIZE;\n        long skipped = 0;"}
{"magic_number_smell": "            try (IndexInput indexInput = dir.openInput(path.getFileName().toString(), IOContext.DEFAULT)) {\n                // We checksum the entire file before we even go and parse it. If it's corrupted we barf right here.\n                CodecUtil.checksumEntireFile(indexInput);\n                final int fileVersion = CodecUtil.checkHeader(indexInput, CHECKPOINT_CODEC, 3, CURRENT_VERSION);\n                assert fileVersion == 3 || fileVersion == CURRENT_VERSION;\n                assert indexInput.length() == V4_FILE_SIZE : indexInput.length();\n                if (fileVersion == CURRENT_VERSION) {", "refactored_code": "    private static final int VERSION_LUCENE_8 = 3;      // int values written in BE format\n            try (IndexInput indexInput = dir.openInput(path.getFileName().toString(), IOContext.DEFAULT)) {\n                // We checksum the entire file before we even go and parse it. If it's corrupted we barf right here.\n                CodecUtil.checksumEntireFile(indexInput);\n                final int fileVersion = CodecUtil.checkHeader(indexInput, CHECKPOINT_CODEC, VERSION_LUCENE_8, CURRENT_VERSION);\n                assert fileVersion == VERSION_LUCENE_8 || fileVersion == CURRENT_VERSION;\n                assert indexInput.length() == V4_FILE_SIZE : indexInput.length();\n                if (fileVersion == CURRENT_VERSION) {"}
{"magic_number_smell": "            globalCheckpointSupplier.getAsLong(),\n            persistedSequenceNumberConsumer\n        );\n        assert writer.sizeInBytes() == TranslogHeader.headerSizeInBytes(UUIDs.randomBase64UUID())\n            : \"Mismatch translog header size; \"\n                + \"empty translog size [\"\n                + writer.sizeInBytes()", "refactored_code": "    public static final int DEFAULT_HEADER_SIZE_IN_BYTES = TranslogHeader.headerSizeInBytes(UUIDs.randomBase64UUID());\n            globalCheckpointSupplier.getAsLong(),\n            persistedSequenceNumberConsumer\n        );\n        assert writer.sizeInBytes() == DEFAULT_HEADER_SIZE_IN_BYTES\n            : \"Mismatch translog header size; \"\n                + \"empty translog size [\"\n                + writer.sizeInBytes()"}
{"magic_number_smell": "    public static final String TRANSLOG_CODEC = \"translog\";\n\n    public static final int 3 = 3; // with: checksums, checkpoints and primary term\n    public static final int CURRENT_VERSION = 3;\n\n    private final String translogUUID;\n    private final long primaryTerm;", "refactored_code": "    public static final int VERSION_PRIMARY_TERM = 3; // with: checksums, checkpoints and primary term\n    public static final String TRANSLOG_CODEC = \"translog\";\n\n    public static final int VERSION_PRIMARY_TERM = 3; // with: checksums, checkpoints and primary term\n    public static final int CURRENT_VERSION = VERSION_PRIMARY_TERM;\n\n    private final String translogUUID;\n    private final long primaryTerm;"}
{"magic_number_smell": "\n        @Override\n        public long ramBytesUsed() {\n            return RamUsageEstimator.shallowSizeOfInstance(Key.class) + entity.ramBytesUsed() + value.length();\n        }\n\n        @Override", "refactored_code": "        private static final long BASE_RAM_BYTES_USED = RamUsageEstimator.shallowSizeOfInstance(Key.class);\n\n        @Override\n        public long ramBytesUsed() {\n            return BASE_RAM_BYTES_USED + entity.ramBytesUsed() + value.length();\n        }\n\n        @Override"}
{"magic_number_smell": "        public long ramBytesUsed() {\n            // No need to take the IndexShard into account since it is shared\n            // across many entities\n            return RamUsageEstimator.shallowSizeOfInstance(IndexShardCacheEntity.class);\n        }\n    }\n", "refactored_code": "        private static final long BASE_RAM_BYTES_USED = RamUsageEstimator.shallowSizeOfInstance(IndexShardCacheEntity.class);\n        public long ramBytesUsed() {\n            // No need to take the IndexShard into account since it is shared\n            // across many entities\n            return BASE_RAM_BYTES_USED;\n        }\n    }\n"}
{"magic_number_smell": "        public static final int -1 = -1;\n\n        private int recovered;\n        private int total = -1;\n        private int totalOnStart = -1;\n        private int totalLocal = -1;\n", "refactored_code": "        public static final int UNKNOWN = -1;\n        public static final int UNKNOWN = -1;\n\n        private int recovered;\n        private int total = UNKNOWN;\n        private int totalOnStart = UNKNOWN;\n        private int totalLocal = UNKNOWN;\n"}
{"magic_number_smell": "            return;\n        }\n\n        if (executedPipelines.size() >= Integer.parseInt(System.getProperty(\"es.ingest.max_pipelines\", \"100\"))) {\n            handler.accept(\n                null,\n                new GraphStructureException(\"Too many nested pipelines. Cannot have more than \" + Integer.parseInt(System.getProperty(\"es.ingest.max_pipelines\", \"100\")) + \" nested pipelines\")", "refactored_code": "    public static final int MAX_PIPELINES = Integer.parseInt(System.getProperty(\"es.ingest.max_pipelines\", \"100\"));\n            return;\n        }\n\n        if (executedPipelines.size() >= MAX_PIPELINES) {\n            handler.accept(\n                null,\n                new GraphStructureException(\"Too many nested pipelines. Cannot have more than \" + MAX_PIPELINES + \" nested pipelines\")"}
{"magic_number_smell": "    public static final int MAX_HIT_COUNT = 255;\n    private final TreeNode root;\n    private boolean sequenceBufferFilled = false;\n    private final byte[] sequenceBuffer = new byte[6];\n    private int nextFreePos = 0;\n\n    // ==Performance info", "refactored_code": "    public static final int TREE_DEPTH = 6;\n    public static final int MAX_HIT_COUNT = 255;\n    private final TreeNode root;\n    private boolean sequenceBufferFilled = false;\n    private final byte[] sequenceBuffer = new byte[TREE_DEPTH];\n    private int nextFreePos = 0;\n\n    // ==Performance info"}
{"magic_number_smell": "        final int posRight;\n        byte type = input.readByte();\n        switch (type) {\n            case 0 -> {\n                negLeft = Integer.MAX_VALUE;\n                negRight = Integer.MIN_VALUE;\n                posLeft = Integer.MAX_VALUE;", "refactored_code": "    private static final byte NONE_SET = 0;\n        final int posRight;\n        byte type = input.readByte();\n        switch (type) {\n            case NONE_SET -> {\n                negLeft = Integer.MAX_VALUE;\n                negRight = Integer.MIN_VALUE;\n                posLeft = Integer.MAX_VALUE;"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        return RamUsageEstimator.shallowSizeOfInstance(MatchAllBitSet.class);\n    }\n\n    @Override", "refactored_code": "    private static final long RAM_BYTES_USED = RamUsageEstimator.shallowSizeOfInstance(MatchAllBitSet.class);\n\n    @Override\n    public long ramBytesUsed() {\n        return RAM_BYTES_USED;\n    }\n\n    @Override"}
{"magic_number_smell": "                continue;\n            }\n            long cpuTime = threadBean.getThreadCpuTime(threadIds[i]);\n            if (cpuTime == -1L) {\n                continue;\n            }\n            long allocatedBytes = type == ReportType.MEM ? sunThreadInfo.getThreadAllocatedBytes(threadIds[i]) : 0;", "refactored_code": "    private static final long INVALID_TIMING = -1L;\n                continue;\n            }\n            long cpuTime = threadBean.getThreadCpuTime(threadIds[i]);\n            if (cpuTime == INVALID_TIMING) {\n                continue;\n            }\n            long allocatedBytes = type == ReportType.MEM ? sunThreadInfo.getThreadAllocatedBytes(threadIds[i]) : 0;"}
{"magic_number_smell": "    public void addNodeStatistics(String nodeId, int queueSize, long responseTimeNanos, long avgServiceTimeNanos) {\n        nodeIdToStats.compute(nodeId, (id, ns) -> {\n            if (ns == null) {\n                ExponentiallyWeightedMovingAverage queueEWMA = new ExponentiallyWeightedMovingAverage(0.3, queueSize);\n                ExponentiallyWeightedMovingAverage responseEWMA = new ExponentiallyWeightedMovingAverage(0.3, responseTimeNanos);\n                return new NodeStatistics(nodeId, queueEWMA, responseEWMA, avgServiceTimeNanos);\n            } else {", "refactored_code": "    public static final double ALPHA = 0.3;\n    public void addNodeStatistics(String nodeId, int queueSize, long responseTimeNanos, long avgServiceTimeNanos) {\n        nodeIdToStats.compute(nodeId, (id, ns) -> {\n            if (ns == null) {\n                ExponentiallyWeightedMovingAverage queueEWMA = new ExponentiallyWeightedMovingAverage(ALPHA, queueSize);\n                ExponentiallyWeightedMovingAverage responseEWMA = new ExponentiallyWeightedMovingAverage(ALPHA, responseTimeNanos);\n                return new NodeStatistics(nodeId, queueEWMA, responseEWMA, avgServiceTimeNanos);\n            } else {"}
{"magic_number_smell": "\n        @Override\n        public long ramBytesUsed() {\n            return RamUsageEstimator.shallowSizeOfInstance(And.class) + first.ramBytesUsed() + second.ramBytesUsed();\n        }\n\n        @Override", "refactored_code": "        private static final long SHALLOW_RAM_BYTES_USED = RamUsageEstimator.shallowSizeOfInstance(And.class);\n\n        @Override\n        public long ramBytesUsed() {\n            return SHALLOW_RAM_BYTES_USED + first.ramBytesUsed() + second.ramBytesUsed();\n        }\n\n        @Override"}
{"magic_number_smell": "     */\n    public static final RepositoryData EMPTY = new RepositoryData(\n        MISSING_UUID,\n        -1L,\n        Collections.emptyMap(),\n        Collections.emptyMap(),\n        Collections.emptyMap(),", "refactored_code": "    public static final long EMPTY_REPO_GEN = -1L;\n     */\n    public static final RepositoryData EMPTY = new RepositoryData(\n        MISSING_UUID,\n        EMPTY_REPO_GEN,\n        Collections.emptyMap(),\n        Collections.emptyMap(),\n        Collections.emptyMap(),"}
{"magic_number_smell": "    private final boolean archived;\n\n    public RepositoryStatsSnapshot(RepositoryInfo repositoryInfo, RepositoryStats repositoryStats, long clusterVersion, boolean archived) {\n        assert archived != (clusterVersion == -1);\n        this.repositoryInfo = repositoryInfo;\n        this.repositoryStats = repositoryStats;\n        this.clusterVersion = clusterVersion;", "refactored_code": "    public static final long UNKNOWN_CLUSTER_VERSION = -1;\n    private final boolean archived;\n\n    public RepositoryStatsSnapshot(RepositoryInfo repositoryInfo, RepositoryStats repositoryStats, long clusterVersion, boolean archived) {\n        assert archived != (clusterVersion == UNKNOWN_CLUSTER_VERSION);\n        this.repositoryInfo = repositoryInfo;\n        this.repositoryStats = repositoryStats;\n        this.clusterVersion = clusterVersion;"}
{"magic_number_smell": "    public T deserialize(String repoName, NamedXContentRegistry namedXContentRegistry, InputStream input) throws IOException {\n        final DeserializeMetaBlobInputStream deserializeMetaBlobInputStream = new DeserializeMetaBlobInputStream(input);\n        try {\n            CodecUtil.checkHeader(new InputStreamDataInput(deserializeMetaBlobInputStream), codec, 1, 1);\n            final InputStream wrappedStream;\n            if (deserializeMetaBlobInputStream.nextBytesCompressed()) {\n                wrappedStream = CompressorFactory.COMPRESSOR.threadLocalInputStream(deserializeMetaBlobInputStream);", "refactored_code": "    public static final int VERSION = 1;\n    public T deserialize(String repoName, NamedXContentRegistry namedXContentRegistry, InputStream input) throws IOException {\n        final DeserializeMetaBlobInputStream deserializeMetaBlobInputStream = new DeserializeMetaBlobInputStream(input);\n        try {\n            CodecUtil.checkHeader(new InputStreamDataInput(deserializeMetaBlobInputStream), codec, VERSION, VERSION);\n            final InputStream wrappedStream;\n            if (deserializeMetaBlobInputStream.nextBytesCompressed()) {\n                wrappedStream = CompressorFactory.COMPRESSOR.threadLocalInputStream(deserializeMetaBlobInputStream);"}
{"magic_number_smell": "     * @param currentSize the current size of the list\n     */\n    protected final void checkMaxSize(int currentSize) {\n        if (currentSize >= 100) {\n            throw new IllegalArgumentException(\n                String.format(\n                    Locale.ROOT,", "refactored_code": "    public static final int MAX_VALUES = 100;\n     * @param currentSize the current size of the list\n     */\n    protected final void checkMaxSize(int currentSize) {\n        if (currentSize >= MAX_VALUES) {\n            throw new IllegalArgumentException(\n                String.format(\n                    Locale.ROOT,"}
{"magic_number_smell": "\n    private void checkMaxChars(String v) {\n        chars += v.length();\n        if (chars > 1024 * 1024) {\n            throw new IllegalArgumentException(\n                String.format(\n                    Locale.ROOT,", "refactored_code": "    public static final long MAX_CHARS = 1024 * 1024;\n\n    private void checkMaxChars(String v) {\n        chars += v.length();\n        if (chars > MAX_CHARS) {\n            throw new IllegalArgumentException(\n                String.format(\n                    Locale.ROOT,"}
{"magic_number_smell": "\n    protected ReadWriteLock lock = new ReentrantReadWriteLock();\n\n    protected Counter fiveMinutes = new Counter(15 * 1, 5 * MINUTE);\n    protected Counter fifteenMinutes = new Counter(90 * 1, 15 * MINUTE);\n    protected Counter twentyFourHours = new Counter(15 * MINUTE, 24 * HOUR);\n    protected final LongSupplier timeProvider;", "refactored_code": "    public static final int SECOND = 1;\n\n    protected ReadWriteLock lock = new ReentrantReadWriteLock();\n\n    protected Counter fiveMinutes = new Counter(15 * SECOND, 5 * MINUTE);\n    protected Counter fifteenMinutes = new Counter(90 * SECOND, 15 * MINUTE);\n    protected Counter twentyFourHours = new Counter(15 * MINUTE, 24 * HOUR);\n    protected final LongSupplier timeProvider;"}
{"magic_number_smell": "    @Override\n    public float getMagnitude() {\n        if (magnitudeDecoded == false) {\n            magnitude = ByteBuffer.wrap(docVector.bytes, docVector.offset + dims, 4).getFloat();\n            magnitudeDecoded = true;\n        }\n        return magnitude;", "refactored_code": "    public static final int MAGNITUDE_BYTES = 4;\n    @Override\n    public float getMagnitude() {\n        if (magnitudeDecoded == false) {\n            magnitude = ByteBuffer.wrap(docVector.bytes, docVector.offset + dims, MAGNITUDE_BYTES).getFloat();\n            magnitudeDecoded = true;\n        }\n        return magnitude;"}
{"magic_number_smell": "    private SearchHit(int nestedTopDocId, String id, NestedIdentity nestedIdentity, @Nullable RefCounted refCounted) {\n        this(\n            nestedTopDocId,\n            Float.NaN,\n            NO_RANK,\n            id == null ? null : new Text(id),\n            nestedIdentity,", "refactored_code": "    private static final float DEFAULT_SCORE = Float.NaN;\n    private SearchHit(int nestedTopDocId, String id, NestedIdentity nestedIdentity, @Nullable RefCounted refCounted) {\n        this(\n            nestedTopDocId,\n            DEFAULT_SCORE,\n            NO_RANK,\n            id == null ? null : new Text(id),\n            nestedIdentity,"}
{"magic_number_smell": "                context.from(DEFAULT_FROM);\n            }\n            if (context.size() == -1) {\n                context.size(10);\n            }\n            context.setTask(task);\n", "refactored_code": "    public static final int DEFAULT_SIZE = 10;\n                context.from(DEFAULT_FROM);\n            }\n            if (context.size() == -1) {\n                context.size(DEFAULT_SIZE);\n            }\n            context.setTask(task);\n"}
{"magic_number_smell": "\n    static int calculateMaxClauseValue(long threadPoolSize, long heapInMb) {\n        if (threadPoolSize <= 0 || heapInMb <= 0) {\n            return 1024;\n        }\n        // In a worst-case scenario, each clause may end up using up to 16k of memory\n        // to load postings, positions, offsets, impacts, etc. So we calculate the", "refactored_code": "    public static final int DEFAULT_MAX_CLAUSE_COUNT = 1024;\n\n    static int calculateMaxClauseValue(long threadPoolSize, long heapInMb) {\n        if (threadPoolSize <= 0 || heapInMb <= 0) {\n            return DEFAULT_MAX_CLAUSE_COUNT;\n        }\n        // In a worst-case scenario, each clause may end up using up to 16k of memory\n        // to load postings, positions, offsets, impacts, etc. So we calculate the"}
{"magic_number_smell": "     * reason.\n     */\n    public long bytesToPreallocate() {\n        return 1024 * 6;\n    }\n\n    /** Common xcontent fields shared among aggregator builders */", "refactored_code": "    public static final long DEFAULT_PREALLOCATION = 1024 * 6;\n     * reason.\n     */\n    public long bytesToPreallocate() {\n        return DEFAULT_PREALLOCATION;\n    }\n\n    /** Common xcontent fields shared among aggregator builders */"}
{"magic_number_smell": "                return ScoreMode.COMPLETE; // unreachable\n            }\n        };\n        addRequestCircuitBreakerBytes(1024 * 5);\n    }\n\n    /**", "refactored_code": "    public static final int DEFAULT_WEIGHT = 1024 * 5; // 5kb\n                return ScoreMode.COMPLETE; // unreachable\n            }\n        };\n        addRequestCircuitBreakerBytes(DEFAULT_WEIGHT);\n    }\n\n    /**"}
{"magic_number_smell": "     * Order by the (higher) count of each bucket.\n     */\n    static final InternalOrder COUNT_DESC = new SimpleOrder(\n        1,\n        \"_count\",\n        SortOrder.DESC,\n        comparingCounts().reversed(),", "refactored_code": "    private static final byte COUNT_DESC_ID = 1;\n     * Order by the (higher) count of each bucket.\n     */\n    static final InternalOrder COUNT_DESC = new SimpleOrder(\n        COUNT_DESC_ID,\n        \"_count\",\n        SortOrder.DESC,\n        comparingCounts().reversed(),"}
{"magic_number_smell": "    public static final int 65536 = 65536;\n    public static final Setting<Integer> MAX_BUCKET_SETTING = Setting.intSetting(\n        \"search.max_buckets\",\n        65536,\n        0,\n        Setting.Property.NodeScope,\n        Setting.Property.Dynamic", "refactored_code": "    public static final int DEFAULT_MAX_BUCKETS = 65536;\n    public static final int DEFAULT_MAX_BUCKETS = 65536;\n    public static final Setting<Integer> MAX_BUCKET_SETTING = Setting.intSetting(\n        \"search.max_buckets\",\n        DEFAULT_MAX_BUCKETS,\n        0,\n        Setting.Property.NodeScope,\n        Setting.Property.Dynamic"}
{"magic_number_smell": "\n    public int getDocCount(int doc) throws IOException {\n        if (docCountPostings == null) {\n            return DocCountFieldMapper.DocCountFieldType.DEFAULT_VALUE;\n        }\n        if (docCountPostings.docID() < doc) {\n            docCountPostings.advance(doc);", "refactored_code": "    public static final int DEFAULT_VALUE = DocCountFieldMapper.DocCountFieldType.DEFAULT_VALUE;\n\n    public int getDocCount(int doc) throws IOException {\n        if (docCountPostings == null) {\n            return DEFAULT_VALUE;\n        }\n        if (docCountPostings.docID() < doc) {\n            docCountPostings.advance(doc);"}
{"magic_number_smell": "     * the slot if the candidate is already in the queue or null if the candidate is not present.\n     */\n    Integer compareCurrent() {\n        return map.get(new Slot(Integer.MAX_VALUE));\n    }\n\n    /**", "refactored_code": "    private static final int CANDIDATE_SLOT = Integer.MAX_VALUE;\n     * the slot if the candidate is already in the queue or null if the candidate is not present.\n     */\n    Integer compareCurrent() {\n        return map.get(new Slot(CANDIDATE_SLOT));\n    }\n\n    /**"}
{"magic_number_smell": "         * included and {@code maxOrd} included.\n         */\n        private void update(long minOrd, long maxOrd) throws IOException {\n            final int maxTerms = Math.min(128, IndexSearcher.getMaxClauseCount());\n            final long size = Math.max(0, maxOrd - minOrd + 1);\n            if (size > maxTerms) {\n                if (docsWithField == null) {", "refactored_code": "    public static final int MAX_TERMS_FOR_DYNAMIC_PRUNING = 128;\n         * included and {@code maxOrd} included.\n         */\n        private void update(long minOrd, long maxOrd) throws IOException {\n            final int maxTerms = Math.min(MAX_TERMS_FOR_DYNAMIC_PRUNING, IndexSearcher.getMaxClauseCount());\n            final long size = Math.max(0, maxOrd - minOrd + 1);\n            if (size > maxTerms) {\n                if (docsWithField == null) {"}
{"magic_number_smell": "\n    public GeoHashGridAggregationBuilder(String name) {\n        super(name);\n        precision(5);\n        size(DEFAULT_MAX_NUM_CELLS);\n        shardSize = -1;\n    }", "refactored_code": "    public static final int DEFAULT_PRECISION = 5;\n\n    public GeoHashGridAggregationBuilder(String name) {\n        super(name);\n        precision(DEFAULT_PRECISION);\n        size(DEFAULT_MAX_NUM_CELLS);\n        shardSize = -1;\n    }"}
{"magic_number_smell": "\n    public GeoTileGridAggregationBuilder(String name) {\n        super(name);\n        precision(7);\n        size(DEFAULT_MAX_NUM_CELLS);\n        shardSize = -1;\n    }", "refactored_code": "    public static final int DEFAULT_PRECISION = 7;\n\n    public GeoTileGridAggregationBuilder(String name) {\n        super(name);\n        precision(DEFAULT_PRECISION);\n        size(DEFAULT_MAX_NUM_CELLS);\n        shardSize = -1;\n    }"}
{"magic_number_smell": "     * @param tiles     the number of tiles per column for a pre-determined zoom-level\n     */\n    public static int getYTile(double latitude, int tiles) {\n        final double latSin = SloppyMath.cos(Math.PI / 2.0 - Math.toRadians(normalizeLat(latitude)));\n        final double yTile = (0.5 - (ESSloppyMath.log((1.0 + latSin) / (1.0 - latSin)) / PI_TIMES_4)) * tiles;\n        // Edge values may generate invalid values, and need to be clipped.\n        // For example, polar regions (above/below lat 85.05112878) get normalized.", "refactored_code": "    private static final double PI_DIV_2 = Math.PI / 2.0;\n     * @param tiles     the number of tiles per column for a pre-determined zoom-level\n     */\n    public static int getYTile(double latitude, int tiles) {\n        final double latSin = SloppyMath.cos(PI_DIV_2 - Math.toRadians(normalizeLat(latitude)));\n        final double yTile = (0.5 - (ESSloppyMath.log((1.0 + latSin) / (1.0 - latSin)) / PI_TIMES_4)) * tiles;\n        // Edge values may generate invalid values, and need to be clipped.\n        // For example, polar regions (above/below lat 85.05112878) get normalized."}
{"magic_number_smell": "            throwOnInvalidFieldValue(\n                PREFIX_LENGTH_FIELD.getPreferredName(),\n                0,\n                isIpv6 ? 128 : IPV4_MAX_PREFIX_LENGTH,\n                prefixLength\n            );\n        }", "refactored_code": "    private static final int IPV6_MAX_PREFIX_LENGTH = 128;\n            throwOnInvalidFieldValue(\n                PREFIX_LENGTH_FIELD.getPreferredName(),\n                0,\n                isIpv6 ? IPV6_MAX_PREFIX_LENGTH : IPV4_MAX_PREFIX_LENGTH,\n                prefixLength\n            );\n        }"}
{"magic_number_smell": "        if (false == valuesSourceConfig.alignesWithSearchIndex()) {\n            return null;\n        }\n        if (averageDocsPerRange < 5000) {\n            return null;\n        }\n        if (valuesSourceConfig.fieldType() instanceof DateFieldType", "refactored_code": "    public static final double DOCS_PER_RANGE_TO_USE_FILTERS = 5000;\n        if (false == valuesSourceConfig.alignesWithSearchIndex()) {\n            return null;\n        }\n        if (averageDocsPerRange < DOCS_PER_RANGE_TO_USE_FILTERS) {\n            return null;\n        }\n        if (valuesSourceConfig.fieldType() instanceof DateFieldType"}
{"magic_number_smell": "    // and need different memory sizes\n    protected long getPriorityQueueSlotSize() {\n        // Generic sentinel object\n        return RamUsageEstimator.shallowSizeOfInstance(Object.class);\n    }\n\n    @Override", "refactored_code": "    private static final long SENTINEL_SIZE = RamUsageEstimator.shallowSizeOfInstance(Object.class);\n    // and need different memory sizes\n    protected long getPriorityQueueSlotSize() {\n        // Generic sentinel object\n        return SENTINEL_SIZE;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    private int shardSize = SamplerAggregationBuilder.DEFAULT_SHARD_SAMPLE_SIZE;\n    private int maxDocsPerValue = 1;\n    private String executionHint = null;\n\n    public DiversifiedAggregationBuilder(String name) {", "refactored_code": "    public static final int MAX_DOCS_PER_VALUE_DEFAULT = 1;\n    }\n\n    private int shardSize = SamplerAggregationBuilder.DEFAULT_SHARD_SAMPLE_SIZE;\n    private int maxDocsPerValue = MAX_DOCS_PER_VALUE_DEFAULT;\n    private String executionHint = null;\n\n    public DiversifiedAggregationBuilder(String name) {"}
{"magic_number_smell": "\n    public static final int 100 = 100;\n\n    private int shardSize = 100;\n\n    public SamplerAggregationBuilder(String name) {\n        super(name);", "refactored_code": "    public static final int DEFAULT_SHARD_SAMPLE_SIZE = 100;\n\n    public static final int DEFAULT_SHARD_SAMPLE_SIZE = 100;\n\n    private int shardSize = DEFAULT_SHARD_SAMPLE_SIZE;\n\n    public SamplerAggregationBuilder(String name) {\n        super(name);"}
{"magic_number_smell": "public class FastGeometric {\n    private static final float[] LOOKUP_TABLE_FOR_FAST_LOG_2;\n    private static final int 13 = 13;\n    private static final int SHIFT = 23 - 13;\n\n    // E[log_2(U[0,1])] = [x log(x) - x]_0^1 / log(2) = -1.0 / log(2). The difference\n    // between sum{ fastLog2((float)(j)) - log2RngRange } over all distinct integers", "refactored_code": "    private static final int BITS = 13;\npublic class FastGeometric {\n    private static final float[] LOOKUP_TABLE_FOR_FAST_LOG_2;\n    private static final int BITS = 13;\n    private static final int SHIFT = 23 - BITS;\n\n    // E[log_2(U[0,1])] = [x log(x) - x]_0^1 / log(2) = -1.0 / log(2). The difference\n    // between sum{ fastLog2((float)(j)) - log2RngRange } over all distinct integers"}
{"magic_number_smell": "    class PartitionedStringFilter extends StringFilter {\n        @Override\n        public boolean accept(BytesRef value) {\n            return Math.floorMod(StringHelper.murmurhash3_x86_32(value, 31), incNumPartitions) == incZeroBasedPartition;\n        }\n    }\n", "refactored_code": "    private static final int HASH_PARTITIONING_SEED = 31;\n    class PartitionedStringFilter extends StringFilter {\n        @Override\n        public boolean accept(BytesRef value) {\n            return Math.floorMod(StringHelper.murmurhash3_x86_32(value, HASH_PARTITIONING_SEED), incNumPartitions) == incZeroBasedPartition;\n        }\n    }\n"}
{"magic_number_smell": "            );\n        }\n        // TODO review: what size cap should we put on this?\n        if (maxDocCount > 100) {\n            throw new IllegalArgumentException(\n                \"[\" + MAX_DOC_COUNT_FIELD_NAME.getPreferredName() + \"] must be smaller\" + \"than \" + 100 + \"in [\" + name + \"]\"\n            );", "refactored_code": "    private static final int MAX_MAX_DOC_COUNT = 100;\n            );\n        }\n        // TODO review: what size cap should we put on this?\n        if (maxDocCount > MAX_MAX_DOC_COUNT) {\n            throw new IllegalArgumentException(\n                \"[\" + MAX_DOC_COUNT_FIELD_NAME.getPreferredName() + \"] must be smaller\" + \"than \" + MAX_MAX_DOC_COUNT + \"in [\" + name + \"]\"\n            );"}
{"magic_number_smell": "                        long newTrieSize = spotter.getEstimatedSizeInBytes();\n                        long growth = newTrieSize - lastTrieSize;\n                        // Only update the circuitbreaker after\n                        if (growth > 5000) {\n                            addRequestCircuitBreakerBytes.accept(growth);\n                            lastTrieSize = newTrieSize;\n                        }", "refactored_code": "    private static final int MEMORY_GROWTH_REPORTING_INTERVAL_BYTES = 5000;\n                        long newTrieSize = spotter.getEstimatedSizeInBytes();\n                        long growth = newTrieSize - lastTrieSize;\n                        // Only update the circuitbreaker after\n                        if (growth > MEMORY_GROWTH_REPORTING_INTERVAL_BYTES) {\n                            addRequestCircuitBreakerBytes.accept(growth);\n                            lastTrieSize = newTrieSize;\n                        }"}
{"magic_number_smell": "    public static boolean supportsParallelCollection(long cardinality, BucketOrder order, BucketCountThresholds bucketCountThresholds) {\n        if (cardinality != -1) {\n            if (InternalOrder.isKeyOrder(order)) {\n                return cardinality <= 50;\n            }\n            BucketCountThresholds adjusted = TermsAggregatorFactory.adjustBucketCountThresholds(bucketCountThresholds, order);\n            return cardinality <= adjusted.getShardSize();", "refactored_code": "    public static final int KEY_ORDER_CONCURRENCY_THRESHOLD = 50;\n    public static boolean supportsParallelCollection(long cardinality, BucketOrder order, BucketCountThresholds bucketCountThresholds) {\n        if (cardinality != -1) {\n            if (InternalOrder.isKeyOrder(order)) {\n                return cardinality <= KEY_ORDER_CONCURRENCY_THRESHOLD;\n            }\n            BucketCountThresholds adjusted = TermsAggregatorFactory.adjustBucketCountThresholds(bucketCountThresholds, order);\n            return cardinality <= adjusted.getShardSize();"}
{"magic_number_smell": "            frequencies.N1_,\n            frequencies.N_1,\n            frequencies.N\n        )) / Math.log(2.0);\n\n        if (Double.isNaN(score)) {\n            score = Double.NEGATIVE_INFINITY;", "refactored_code": "    private static final double log2 = Math.log(2.0);\n            frequencies.N1_,\n            frequencies.N_1,\n            frequencies.N\n        )) / log2;\n\n        if (Double.isNaN(score)) {\n            score = Double.NEGATIVE_INFINITY;"}
{"magic_number_smell": "    protected final int p;\n\n    AbstractCardinalityAlgorithm(int precision) {\n        if (precision < 4) {\n            throw new IllegalArgumentException(\"precision must be >= 4\");\n        }\n        if (precision > MAX_PRECISION) {", "refactored_code": "    public static final int MIN_PRECISION = 4;\n    protected final int p;\n\n    AbstractCardinalityAlgorithm(int precision) {\n        if (precision < MIN_PRECISION) {\n            throw new IllegalArgumentException(\"precision must be >= 4\");\n        }\n        if (precision > MAX_PRECISION) {"}
{"magic_number_smell": "\n    static int decodeRunLen(int encoded, int p) {\n        if ((encoded & 1) == 1) {\n            return (((encoded >>> 1) & 0x3F) + (25 - p));\n        } else {\n            final int bits = encoded << (31 + p - 25);\n            assert bits != 0;", "refactored_code": "    private static final int P2 = 25;\n\n    static int decodeRunLen(int encoded, int p) {\n        if ((encoded & 1) == 1) {\n            return (((encoded >>> 1) & 0x3F) + (P2 - p));\n        } else {\n            final int bits = encoded << (31 + p - P2);\n            assert bits != 0;"}
{"magic_number_smell": "\n    @Override\n    public long cardinality(long bucketOrd) {\n        final long m = 1 << 25;\n        final long v = m - size(bucketOrd);\n        return linearCounting(m, v);\n    }", "refactored_code": "    private static final int P2 = 25;\n\n    @Override\n    public long cardinality(long bucketOrd) {\n        final long m = 1 << P2;\n        final long v = m - size(bucketOrd);\n        return linearCounting(m, v);\n    }"}
{"magic_number_smell": "         * Return an approximate memory overhead per bucket for this collector.\n         */\n        public static long memoryOverhead(long maxOrd) {\n            return RamUsageEstimator.NUM_BYTES_OBJECT_REF + RamUsageEstimator.shallowSizeOfInstance(FixedBitSet.class) + (maxOrd + 7) / 8; // 1 bit per ord\n        }\n\n        private final BigArrays bigArrays;", "refactored_code": "        private static final long SHALLOW_FIXEDBITSET_SIZE = RamUsageEstimator.shallowSizeOfInstance(FixedBitSet.class);\n         * Return an approximate memory overhead per bucket for this collector.\n         */\n        public static long memoryOverhead(long maxOrd) {\n            return RamUsageEstimator.NUM_BYTES_OBJECT_REF + SHALLOW_FIXEDBITSET_SIZE + (maxOrd + 7) / 8; // 1 bit per ord\n        }\n\n        private final BigArrays bigArrays;"}
{"magic_number_smell": "     * Increments the Kahan sum by adding a value without a correction term.\n     */\n    public CompensatedSum add(double value) {\n        return add(value, 0.0);\n    }\n\n    /**", "refactored_code": "    private static final double NO_CORRECTION = 0.0;\n     * Increments the Kahan sum by adding a value without a correction term.\n     */\n    public CompensatedSum add(double value) {\n        return add(value, NO_CORRECTION);\n    }\n\n    /**"}
{"magic_number_smell": "\n    @Override\n    public ScoreMode scoreMode() {\n        if (field != null && valuesSource.needsScores() == false && maxOrd <= 1024) {\n            return ScoreMode.TOP_DOCS;\n        } else if (valuesSource.needsScores()) {\n            return ScoreMode.COMPLETE;", "refactored_code": "    private static final int MAX_FIELD_CARDINALITY_FOR_DYNAMIC_PRUNING = 1024;\n\n    @Override\n    public ScoreMode scoreMode() {\n        if (field != null && valuesSource.needsScores() == false && maxOrd <= MAX_FIELD_CARDINALITY_FOR_DYNAMIC_PRUNING) {\n            return ScoreMode.TOP_DOCS;\n        } else if (valuesSource.needsScores()) {\n            return ScoreMode.COMPLETE;"}
{"magic_number_smell": "     * Compute the required precision so that <code>count</code> distinct entries would be counted with linear counting.\n     */\n    public static int precisionFromThreshold(long count) {\n        final long hashTableEntries = (long) Math.ceil(count / 0.75f);\n        int precision = PackedInts.bitsRequired(hashTableEntries * Integer.BYTES);\n        precision = Math.max(precision, AbstractHyperLogLog.MIN_PRECISION);\n        precision = Math.min(precision, AbstractHyperLogLog.MAX_PRECISION);", "refactored_code": "    private static final float MAX_LOAD_FACTOR = 0.75f;\n     * Compute the required precision so that <code>count</code> distinct entries would be counted with linear counting.\n     */\n    public static int precisionFromThreshold(long count) {\n        final long hashTableEntries = (long) Math.ceil(count / MAX_LOAD_FACTOR);\n        int precision = PackedInts.bitsRequired(hashTableEntries * Integer.BYTES);\n        precision = Math.max(precision, AbstractHyperLogLog.MIN_PRECISION);\n        precision = Math.min(precision, AbstractHyperLogLog.MAX_PRECISION);"}
{"magic_number_smell": "                        // this is the first leaf with a live doc so the value is the minimum for this segment.\n                        throw new CollectionTerminatedException();\n                    }\n                    if (++lookupCounter > 1024) {\n                        throw new CollectionTerminatedException();\n                    }\n                }", "refactored_code": "    private static final int MAX_BKD_LOOKUPS = 1024;\n                        // this is the first leaf with a live doc so the value is the minimum for this segment.\n                        throw new CollectionTerminatedException();\n                    }\n                    if (++lookupCounter > MAX_BKD_LOOKUPS) {\n                        throw new CollectionTerminatedException();\n                    }\n                }"}
{"magic_number_smell": "                states = bigArrays().grow(states, owningBucketOrd + 1);\n                State state = states.get(owningBucketOrd);\n                if (state == null) {\n                    addRequestCircuitBreakerBytes(1024 * 5);\n                    state = new State();\n                    states.set(owningBucketOrd, state);\n                }", "refactored_code": "    private static final long BUCKET_COST_ESTIMATE = 1024 * 5;\n                states = bigArrays().grow(states, owningBucketOrd + 1);\n                State state = states.get(owningBucketOrd);\n                if (state == null) {\n                    addRequestCircuitBreakerBytes(BUCKET_COST_ESTIMATE);\n                    state = new State();\n                    states.set(owningBucketOrd, state);\n                }"}
{"magic_number_smell": "        // Create LeafWalker for each subreader\n        List<LeafWalker> leafWalkers = new ArrayList<>();\n        for (LeafReaderContext leaf : searcher.getIndexReader().leaves()) {\n            if (++seen % 1 << 11 == 0) {\n                checkCancelled();\n            }\n            Scorer scorer = weight.scorer(leaf);", "refactored_code": "    private static final int CHECK_CANCELLED_SCORER_INTERVAL = 1 << 11;\n        // Create LeafWalker for each subreader\n        List<LeafWalker> leafWalkers = new ArrayList<>();\n        for (LeafReaderContext leaf : searcher.getIndexReader().leaves()) {\n            if (++seen % CHECK_CANCELLED_SCORER_INTERVAL == 0) {\n                checkCancelled();\n            }\n            Scorer scorer = weight.scorer(leaf);"}
{"magic_number_smell": "        if (patterns.isEmpty()) {\n            return null;\n        }\n        return new CharacterRunAutomaton(Regex.simpleMatchToAutomaton(patterns.toArray(String[]::new)), 100000);\n    }\n\n    /**", "refactored_code": "    private static final int AUTOMATON_MAX_DETERMINIZED_STATES = 100000;\n        if (patterns.isEmpty()) {\n            return null;\n        }\n        return new CharacterRunAutomaton(Regex.simpleMatchToAutomaton(patterns.toArray(String[]::new)), AUTOMATON_MAX_DETERMINIZED_STATES);\n    }\n\n    /**"}
{"magic_number_smell": "        .boundaryChars(SimpleBoundaryScanner.DEFAULT_BOUNDARY_CHARS)\n        .boundaryScannerLocale(Locale.ROOT)\n        .noMatchSize(DEFAULT_NO_MATCH_SIZE)\n        .phraseLimit(256)\n        .build();\n\n    private final List<Field> fields;", "refactored_code": "    public static final int DEFAULT_PHRASE_LIMIT = 256;\n        .boundaryChars(SimpleBoundaryScanner.DEFAULT_BOUNDARY_CHARS)\n        .boundaryScannerLocale(Locale.ROOT)\n        .noMatchSize(DEFAULT_NO_MATCH_SIZE)\n        .phraseLimit(DEFAULT_PHRASE_LIMIT)\n        .build();\n\n    private final List<Field> fields;"}
{"magic_number_smell": "\n    @Override\n    public int score(LeafCollector collector, Bits acceptDocs, int min, int max) throws IOException {\n        int interval = 1 << 11;\n        while (min < max) {\n            checkCancelled.run();\n            final int newMax = (int) Math.min((long) min + interval, max);", "refactored_code": "    private static final int INITIAL_INTERVAL = 1 << 11;\n\n    @Override\n    public int score(LeafCollector collector, Bits acceptDocs, int min, int max) throws IOException {\n        int interval = INITIAL_INTERVAL;\n        while (min < max) {\n            checkCancelled.run();\n            final int newMax = (int) Math.min((long) min + interval, max);"}
{"magic_number_smell": "        int seen = 0;\n        checkCancelled.run();\n        for (int docId = iterator.nextDoc(); docId < DocIdSetIterator.NO_MORE_DOCS; docId = iterator.nextDoc()) {\n            if (++seen % 1 << 11 == 0) {\n                checkCancelled.run();\n            }\n            collector.collect(docId);", "refactored_code": "    private static final int CHECK_CANCELLED_SCORER_INTERVAL = 1 << 11;\n        int seen = 0;\n        checkCancelled.run();\n        for (int docId = iterator.nextDoc(); docId < DocIdSetIterator.NO_MORE_DOCS; docId = iterator.nextDoc()) {\n            if (++seen % CHECK_CANCELLED_SCORER_INTERVAL == 0) {\n                checkCancelled.run();\n            }\n            collector.collect(docId);"}
{"magic_number_smell": "\n            @Override\n            public boolean get(int index) {\n                if (calls++ % 10 == 0) {\n                    queryCancellation.checkCancelled();\n                }\n                return updatedAcceptDocs.get(index);", "refactored_code": "            private static final int MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK = 10;\n\n            @Override\n            public boolean get(int index) {\n                if (calls++ % MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK == 0) {\n                    queryCancellation.checkCancelled();\n                }\n                return updatedAcceptDocs.get(index);"}
{"magic_number_smell": "    }\n\n    public long getStartTimeInNano() {\n        return System.nanoTime();\n    }\n}\n", "refactored_code": "    private final long startTimeInNano = System.nanoTime();\n    }\n\n    public long getStartTimeInNano() {\n        return startTimeInNano;\n    }\n}\n"}
{"magic_number_smell": "    private static final int 3 = 3;\n\n    private int from;\n    private int size = 3;\n    private SortAndFormats sort;\n    private ParsedQuery parsedQuery;\n    private Query query;", "refactored_code": "    private static final int DEFAULT_SIZE = 3;\n    private static final int DEFAULT_SIZE = 3;\n\n    private int from;\n    private int size = DEFAULT_SIZE;\n    private SortAndFormats sort;\n    private ParsedQuery parsedQuery;\n    private Query query;"}
{"magic_number_smell": "    /**\n     * Create a new {@link SearchLookup} that looks fields up the same as the one provided as argument,\n     * while also tracking field references starting from the provided field name. It detects cycles\n     * and prevents resolving fields that depend on more than {@link #5} fields.\n     * @param searchLookup the existing lookup to create a new one from\n     * @param fieldChain the chain of fields that required the field currently being loaded\n     */", "refactored_code": "    private static final int MAX_FIELD_CHAIN_DEPTH = 5;\n    /**\n     * Create a new {@link SearchLookup} that looks fields up the same as the one provided as argument,\n     * while also tracking field references starting from the provided field name. It detects cycles\n     * and prevents resolving fields that depend on more than {@link #MAX_FIELD_CHAIN_DEPTH} fields.\n     * @param searchLookup the existing lookup to create a new one from\n     * @param fieldChain the chain of fields that required the field currently being loaded\n     */"}
{"magic_number_smell": "     * If this document has been ranked, this is its final\n     * rrf ranking from all the result sets.\n     */\n    public int rank = -1;\n\n    public RankDoc(int doc, float score, int shardIndex) {\n        super(doc, score, shardIndex);", "refactored_code": "    public static final int NO_RANK = -1;\n     * If this document has been ranked, this is its final\n     * rrf ranking from all the result sets.\n     */\n    public int rank = NO_RANK;\n\n    public RankDoc(int doc, float score, int shardIndex) {\n        super(doc, score, shardIndex);"}
{"magic_number_smell": "    public static final float DEFAULT_QUERYWEIGHT = 1.0f;\n    public static final QueryRescoreMode DEFAULT_SCORE_MODE = QueryRescoreMode.Total;\n    private final QueryBuilder queryBuilder;\n    private float rescoreQueryWeight = 1.0f;\n    private float queryWeight = DEFAULT_QUERYWEIGHT;\n    private QueryRescoreMode scoreMode = DEFAULT_SCORE_MODE;\n", "refactored_code": "    public static final float DEFAULT_RESCORE_QUERYWEIGHT = 1.0f;\n    public static final float DEFAULT_QUERYWEIGHT = 1.0f;\n    public static final QueryRescoreMode DEFAULT_SCORE_MODE = QueryRescoreMode.Total;\n    private final QueryBuilder queryBuilder;\n    private float rescoreQueryWeight = DEFAULT_RESCORE_QUERYWEIGHT;\n    private float queryWeight = DEFAULT_QUERYWEIGHT;\n    private QueryRescoreMode scoreMode = DEFAULT_SCORE_MODE;\n"}
{"magic_number_smell": "        if (isWindowSizeRequired()) {\n            assert windowSize != null;\n        }\n        int finalWindowSize = windowSize == null ? 10 : windowSize;\n        RescoreContext rescoreContext = innerBuildContext(finalWindowSize, context);\n        return rescoreContext;\n    }", "refactored_code": "    public static final int DEFAULT_WINDOW_SIZE = 10;\n        if (isWindowSizeRequired()) {\n            assert windowSize != null;\n        }\n        int finalWindowSize = windowSize == null ? DEFAULT_WINDOW_SIZE : windowSize;\n        RescoreContext rescoreContext = innerBuildContext(finalWindowSize, context);\n        return rescoreContext;\n    }"}
{"magic_number_smell": "\n            @Override\n            public float matchCost() {\n                return 9000f;\n            }\n        };\n    }", "refactored_code": "    protected static final float MATCH_COST = 9000f;\n\n            @Override\n            public float matchCost() {\n                return MATCH_COST;\n            }\n        };\n    }"}
{"magic_number_smell": "        for (BytesRef term = te.next(); term != null; term = te.next()) {\n            // use a fixed seed instead of term.hashCode() otherwise this query may return inconsistent results when\n            // running on another replica (StringHelper sets its default seed at startup with current time)\n            int hashCode = StringHelper.murmurhash3_x86_32(term, 7919);\n            if (contains(hashCode)) {\n                docsEnum = te.postings(docsEnum, PostingsEnum.NONE);\n                builder.add(docsEnum);", "refactored_code": "    public static final int SEED = 7919;\n        for (BytesRef term = te.next(); term != null; term = te.next()) {\n            // use a fixed seed instead of term.hashCode() otherwise this query may return inconsistent results when\n            // running on another replica (StringHelper sets its default seed at startup with current time)\n            int hashCode = StringHelper.murmurhash3_x86_32(term, SEED);\n            if (contains(hashCode)) {\n                docsEnum = te.postings(docsEnum, PostingsEnum.NONE);\n                builder.add(docsEnum);"}
{"magic_number_smell": "\n        @Override\n        public int typeComparisonKey() {\n            return -2;\n        }\n\n        @Override", "refactored_code": "        private static final int SORT_VALUE = -2;\n\n        @Override\n        public int typeComparisonKey() {\n            return SORT_VALUE;\n        }\n\n        @Override"}
{"magic_number_smell": "    public static final float DEFAULT_MIN_DOC_FREQ = 0f;\n\n    private SuggestMode suggestMode = DEFAULT_SUGGEST_MODE;\n    private float accuracy = 0.5f;\n    private SortBy sort = DEFAULT_SORT;\n    private StringDistance stringDistance = DEFAULT_STRING_DISTANCE;\n    private int maxEdits = DEFAULT_MAX_EDITS;", "refactored_code": "    public static final float DEFAULT_ACCURACY = 0.5f;\n    public static final float DEFAULT_MIN_DOC_FREQ = 0f;\n\n    private SuggestMode suggestMode = DEFAULT_SUGGEST_MODE;\n    private float accuracy = DEFAULT_ACCURACY;\n    private SortBy sort = DEFAULT_SORT;\n    private StringDistance stringDistance = DEFAULT_STRING_DISTANCE;\n    private int maxEdits = DEFAULT_MAX_EDITS;"}
{"magic_number_smell": "\n    public static class Builder extends ContextBuilder<GeoContextMapping> {\n\n        private int precision = 6;\n        private String fieldName = null;\n\n        public Builder(String name) {", "refactored_code": "    public static final int DEFAULT_PRECISION = 6;\n\n    public static class Builder extends ContextBuilder<GeoContextMapping> {\n\n        private int precision = DEFAULT_PRECISION;\n        private String fieldName = null;\n\n        public Builder(String name) {"}
{"magic_number_smell": "    // package protected for test\n    int thresholdTermFrequency(int docFreq) {\n        if (docFreq > 0) {\n            return (int) min(max(0, round(docFreq * (log10(docFreq - frequencyPlateau) * (1.0 / log10(5))) + 1)), Integer.MAX_VALUE);\n        }\n        return 0;\n    }", "refactored_code": "    private static final double LOG_BASE = 5;\n    // package protected for test\n    int thresholdTermFrequency(int docFreq) {\n        if (docFreq > 0) {\n            return (int) min(max(0, round(docFreq * (log10(docFreq - frequencyPlateau) * (1.0 / log10(LOG_BASE))) + 1)), Integer.MAX_VALUE);\n        }\n        return 0;\n    }"}
{"magic_number_smell": "    public static SmoothingModel fromXContent(XContentParser parser) throws IOException {\n        XContentParser.Token token;\n        String fieldName = null;\n        double alpha = 0.5;\n        while ((token = parser.nextToken()) != Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                fieldName = parser.currentName();", "refactored_code": "    public static final double DEFAULT_LAPLACE_ALPHA = 0.5;\n    public static SmoothingModel fromXContent(XContentParser parser) throws IOException {\n        XContentParser.Token token;\n        String fieldName = null;\n        double alpha = DEFAULT_LAPLACE_ALPHA;\n        while ((token = parser.nextToken()) != Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                fieldName = parser.currentName();"}
{"magic_number_smell": "    public static SmoothingModel fromXContent(XContentParser parser) throws IOException {\n        XContentParser.Token token;\n        String fieldName = null;\n        double discount = 0.4;\n        while ((token = parser.nextToken()) != Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                fieldName = parser.currentName();", "refactored_code": "    public static final double DEFAULT_BACKOFF_DISCOUNT = 0.4;\n    public static SmoothingModel fromXContent(XContentParser parser) throws IOException {\n        XContentParser.Token token;\n        String fieldName = null;\n        double discount = DEFAULT_BACKOFF_DISCOUNT;\n        while ((token = parser.nextToken()) != Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                fieldName = parser.currentName();"}
{"magic_number_smell": "                \"[\" + NUM_CANDS_FIELD.getPreferredName() + \"] cannot be less than \" + \"[\" + K_FIELD.getPreferredName() + \"]\"\n            );\n        }\n        if (numCandidates > 10_000) {\n            throw new IllegalArgumentException(\"[\" + NUM_CANDS_FIELD.getPreferredName() + \"] cannot exceed [\" + 10_000 + \"]\");\n        }\n        if (queryVector == null && queryVectorBuilder == null) {", "refactored_code": "    public static final int NUM_CANDS_LIMIT = 10_000;\n                \"[\" + NUM_CANDS_FIELD.getPreferredName() + \"] cannot be less than \" + \"[\" + K_FIELD.getPreferredName() + \"]\"\n            );\n        }\n        if (numCandidates > NUM_CANDS_LIMIT) {\n            throw new IllegalArgumentException(\"[\" + NUM_CANDS_FIELD.getPreferredName() + \"] cannot exceed [\" + NUM_CANDS_LIMIT + \"]\");\n        }\n        if (queryVector == null && queryVectorBuilder == null) {"}
{"magic_number_smell": "                    \"[\" + NUM_CANDS_FIELD.getPreferredName() + \"] cannot be less than \" + \"[\" + K_FIELD.getPreferredName() + \"]\"\n                );\n            }\n            if (numCands > 10000) {\n                throw new IllegalArgumentException(\"[\" + NUM_CANDS_FIELD.getPreferredName() + \"] cannot exceed [\" + 10000 + \"]\");\n            }\n            return new KnnVectorQueryBuilder(field, queryVector, numCands, null);", "refactored_code": "        private static final int NUM_CANDS_LIMIT = 10000;\n                    \"[\" + NUM_CANDS_FIELD.getPreferredName() + \"] cannot be less than \" + \"[\" + K_FIELD.getPreferredName() + \"]\"\n                );\n            }\n            if (numCands > NUM_CANDS_LIMIT) {\n                throw new IllegalArgumentException(\"[\" + NUM_CANDS_FIELD.getPreferredName() + \"] cannot exceed [\" + NUM_CANDS_LIMIT + \"]\");\n            }\n            return new KnnVectorQueryBuilder(field, queryVector, numCands, null);"}
{"magic_number_smell": "        Integer numCands,\n        Float vectorSimilarity\n    ) {\n        if (numCands != null && numCands > 10_000) {\n            throw new IllegalArgumentException(\"[\" + NUM_CANDS_FIELD.getPreferredName() + \"] cannot exceed [\" + 10_000 + \"]\");\n        }\n        if (queryVector == null && queryVectorBuilder == null) {", "refactored_code": "    private static final int NUM_CANDS_LIMIT = 10_000;\n        Integer numCands,\n        Float vectorSimilarity\n    ) {\n        if (numCands != null && numCands > NUM_CANDS_LIMIT) {\n            throw new IllegalArgumentException(\"[\" + NUM_CANDS_FIELD.getPreferredName() + \"] cannot exceed [\" + NUM_CANDS_LIMIT + \"]\");\n        }\n        if (queryVector == null && queryVectorBuilder == null) {"}
{"magic_number_smell": "    private static final Logger logger = LogManager.getLogger(SynonymsManagementAPIService.class);\n    private static final String SYNONYMS_INDEX_NAME_PATTERN = \".synonyms-*\";\n    private static final int 2 = 2;\n    private static final String SYNONYMS_INDEX_CONCRETE_NAME = \".synonyms-\" + 2;\n    private static final String SYNONYMS_ALIAS_NAME = \".synonyms\";\n    public static final String SYNONYMS_FEATURE_NAME = \"synonyms\";\n    // Stores the synonym set the rule belongs to", "refactored_code": "    private static final int SYNONYMS_INDEX_FORMAT = 2;\n    private static final Logger logger = LogManager.getLogger(SynonymsManagementAPIService.class);\n    private static final String SYNONYMS_INDEX_NAME_PATTERN = \".synonyms-*\";\n    private static final int SYNONYMS_INDEX_FORMAT = 2;\n    private static final String SYNONYMS_INDEX_CONCRETE_NAME = \".synonyms-\" + SYNONYMS_INDEX_FORMAT;\n    private static final String SYNONYMS_ALIAS_NAME = \".synonyms\";\n    public static final String SYNONYMS_FEATURE_NAME = \"synonyms\";\n    // Stores the synonym set the rule belongs to"}
{"magic_number_smell": "            {\n                builder.startObject(\"_meta\");\n                builder.field(TASK_RESULT_MAPPING_VERSION_META_FIELD, Version.CURRENT.toString());\n                builder.field(SystemIndexDescriptor.VERSION_META_KEY, 0);\n                builder.endObject();\n\n                builder.field(\"dynamic\", \"strict\");", "refactored_code": "    private static final int TASK_RESULTS_INDEX_MAPPINGS_VERSION = 0;\n            {\n                builder.startObject(\"_meta\");\n                builder.field(TASK_RESULT_MAPPING_VERSION_META_FIELD, Version.CURRENT.toString());\n                builder.field(SystemIndexDescriptor.VERSION_META_KEY, TASK_RESULTS_INDEX_MAPPINGS_VERSION);\n                builder.endObject();\n\n                builder.field(\"dynamic\", \"strict\");"}
{"magic_number_smell": "\n        @Override\n        public void close() {\n            final int toRelease = bytesToRelease.getAndSet(-1);\n            assert toRelease != -1;\n            if (toRelease > 0) {\n                circuitBreaker.get().addWithoutBreaking(-toRelease);", "refactored_code": "        private static final int CLOSED = -1;\n\n        @Override\n        public void close() {\n            final int toRelease = bytesToRelease.getAndSet(CLOSED);\n            assert toRelease != CLOSED;\n            if (toRelease > 0) {\n                circuitBreaker.get().addWithoutBreaking(-toRelease);"}
{"magic_number_smell": "                    return;\n                }\n                final int numElements = oldHead.pos + 1;\n                if (numElements >= 25) {\n                    final int backOffFactor = Math.min(numElements - 25, 30);\n                    if (dropped = Randomness.get().nextInt(1 << backOffFactor) != 0) {\n                        prevHead = oldHead.next;", "refactored_code": "    private static final int TARGET_RECORDS = 25;\n                    return;\n                }\n                final int numElements = oldHead.pos + 1;\n                if (numElements >= TARGET_RECORDS) {\n                    final int backOffFactor = Math.min(numElements - TARGET_RECORDS, 30);\n                    if (dropped = Randomness.get().nextInt(1 << backOffFactor) != 0) {\n                        prevHead = oldHead.next;"}
{"magic_number_smell": "    }\n\n    private void openConnections(ActionListener<Void> finished, int attemptNumber) {\n        if (attemptNumber <= 3) {\n            TransportAddress resolved = address.get();\n\n            int remaining = maxNumConnections - connectionManager.size();", "refactored_code": "    private static final int MAX_CONNECT_ATTEMPTS_PER_RUN = 3;\n    }\n\n    private void openConnections(ActionListener<Void> finished, int attemptNumber) {\n        if (attemptNumber <= MAX_CONNECT_ATTEMPTS_PER_RUN) {\n            TransportAddress resolved = address.get();\n\n            int remaining = maxNumConnections - connectionManager.size();"}
{"magic_number_smell": "\n    public static final int VARIABLE_HEADER_SIZE = 4;\n\n    public static final int BYTES_REQUIRED_FOR_MESSAGE_SIZE = 2 + MESSAGE_LENGTH_SIZE;\n\n    public static final int VERSION_POSITION = 2 + MESSAGE_LENGTH_SIZE + REQUEST_ID_SIZE + STATUS_SIZE;\n", "refactored_code": "    public static final int MARKER_BYTES_SIZE = 2;\n\n    public static final int VARIABLE_HEADER_SIZE = 4;\n\n    public static final int BYTES_REQUIRED_FOR_MESSAGE_SIZE = MARKER_BYTES_SIZE + MESSAGE_LENGTH_SIZE;\n\n    public static final int VERSION_POSITION = MARKER_BYTES_SIZE + MESSAGE_LENGTH_SIZE + REQUEST_ID_SIZE + STATUS_SIZE;\n"}
{"magic_number_smell": "     *                                               This is dependent on the available memory.\n     */\n    public static int readMessageLength(BytesReference networkBytes) throws IOException {\n        if (networkBytes.length() < TcpHeader.MARKER_BYTES_SIZE + TcpHeader.MESSAGE_LENGTH_SIZE) {\n            return -1;\n        } else {\n            return readHeaderBuffer(networkBytes);", "refactored_code": "    private static final int BYTES_NEEDED_FOR_MESSAGE_SIZE = TcpHeader.MARKER_BYTES_SIZE + TcpHeader.MESSAGE_LENGTH_SIZE;\n     *                                               This is dependent on the available memory.\n     */\n    public static int readMessageLength(BytesReference networkBytes) throws IOException {\n        if (networkBytes.length() < BYTES_NEEDED_FOR_MESSAGE_SIZE) {\n            return -1;\n        } else {\n            return readHeaderBuffer(networkBytes);"}
{"magic_number_smell": "        StatsTracker {\n            assert count.longValue() == 0L;\n            assert totalSize.longValue() == 0L;\n            assert histogram.length() == getBucketUpperBounds().length + 1;\n        }\n\n        StatsTracker() {", "refactored_code": "    private static final int MAX_BUCKET = getBucketUpperBounds().length;\n        StatsTracker {\n            assert count.longValue() == 0L;\n            assert totalSize.longValue() == 0L;\n            assert histogram.length() == MAX_BUCKET + 1;\n        }\n\n        StatsTracker() {"}
{"magic_number_smell": "                    // This is not an Elasticsearch transport message.\n                    return;\n                }\n                BytesReference withoutHeader = message.slice(TcpHeader.MARKER_BYTES_SIZE + TcpHeader.MESSAGE_LENGTH_SIZE, message.length() - TcpHeader.MARKER_BYTES_SIZE + TcpHeader.MESSAGE_LENGTH_SIZE);\n                String logMessage = format(channel, withoutHeader, \"WRITE\");\n                logger.trace(logMessage);\n            } catch (IOException e) {", "refactored_code": "    private static final int HEADER_SIZE = TcpHeader.MARKER_BYTES_SIZE + TcpHeader.MESSAGE_LENGTH_SIZE;\n                    // This is not an Elasticsearch transport message.\n                    return;\n                }\n                BytesReference withoutHeader = message.slice(HEADER_SIZE, message.length() - HEADER_SIZE);\n                String logMessage = format(channel, withoutHeader, \"WRITE\");\n                logger.trace(logMessage);\n            } catch (IOException e) {"}
{"magic_number_smell": "        public void run() {\n            if (responseHandlers.contains(requestId)) {\n                long timeoutTime = threadPool.relativeTimeInMillis();\n                timeoutInfoHandlers.put(requestId, new TimeoutInfoHolder(node, action, threadPool.relativeTimeInMillis(), timeoutTime));\n                // now that we have the information visible via timeoutInfoHandlers, we try to remove the request id\n                final Transport.ResponseContext<? extends TransportResponse> holder = responseHandlers.remove(requestId);\n                if (holder != null) {", "refactored_code": "        private final long sentTime = threadPool.relativeTimeInMillis();\n        public void run() {\n            if (responseHandlers.contains(requestId)) {\n                long timeoutTime = threadPool.relativeTimeInMillis();\n                timeoutInfoHandlers.put(requestId, new TimeoutInfoHolder(node, action, sentTime, timeoutTime));\n                // now that we have the information visible via timeoutInfoHandlers, we try to remove the request id\n                final Transport.ResponseContext<? extends TransportResponse> holder = responseHandlers.remove(requestId);\n                if (holder != null) {"}
{"magic_number_smell": "    private static final byte STATUS_HANDSHAKE = 1 << 3;\n\n    public static boolean isRequest(byte value) {\n        return (value & 1 << 0) == 0;\n    }\n\n    public static byte setRequest(byte value) {", "refactored_code": "    private static final byte STATUS_REQRES = 1 << 0;\n    private static final byte STATUS_HANDSHAKE = 1 << 3;\n\n    public static boolean isRequest(byte value) {\n        return (value & STATUS_REQRES) == 0;\n    }\n\n    public static byte setRequest(byte value) {"}
{"magic_number_smell": "    }\n\n    public void testEqualsAndHashCode() {\n        for (int round = 0; round < 30; round++) {\n            ClusterRerouteRequest request = randomRequest();\n            assertEquals(request, request);\n            assertEquals(request.hashCode(), request.hashCode());", "refactored_code": "    private static final int ROUNDS = 30;\n    }\n\n    public void testEqualsAndHashCode() {\n        for (int round = 0; round < ROUNDS; round++) {\n            ClusterRerouteRequest request = randomRequest();\n            assertEquals(request, request);\n            assertEquals(request.hashCode(), request.hashCode());"}
{"magic_number_smell": "                // Add language\n                String language = randomValueOtherThanMany(\n                    instance.info.languageContexts::containsKey,\n                    () -> randomAlphaOfLengthBetween(1, MAX_LENGTH)\n                );\n                Map<String, Set<String>> languageContexts = new HashMap<>();\n                instance.info.languageContexts.forEach(languageContexts::put);", "refactored_code": "    private static final int MIN_LENGTH = 1;\n                // Add language\n                String language = randomValueOtherThanMany(\n                    instance.info.languageContexts::containsKey,\n                    () -> randomAlphaOfLengthBetween(MIN_LENGTH, MAX_LENGTH)\n                );\n                Map<String, Set<String>> languageContexts = new HashMap<>();\n                instance.info.languageContexts.forEach(languageContexts::put);"}
{"magic_number_smell": "        }\n        return switch (randomIntBetween(0, 2)) {\n            case 0 -> new ScriptContextInfo(\n                randomValueOtherThanMany(names::contains, () -> randomAlphaOfLengthBetween(1, MAX_LENGTH)),\n                instance.execute,\n                instance.getters\n            );", "refactored_code": "    private static final int MIN_LENGTH = 1;\n        }\n        return switch (randomIntBetween(0, 2)) {\n            case 0 -> new ScriptContextInfo(\n                randomValueOtherThanMany(names::contains, () -> randomAlphaOfLengthBetween(MIN_LENGTH, MAX_LENGTH)),\n                instance.execute,\n                instance.getters\n            );"}
{"magic_number_smell": "        return switch (type) {\n            case EXECUTE -> new ScriptMethodInfo(\n                EXECUTE,\n                randomAlphaOfLengthBetween(1, MAX_LENGTH),\n                ScriptParameterInfoSerializingTests.randomInstances()\n            );\n            case GETTER -> new ScriptMethodInfo(", "refactored_code": "    private static final int MIN_LENGTH = 1;\n        return switch (type) {\n            case EXECUTE -> new ScriptMethodInfo(\n                EXECUTE,\n                randomAlphaOfLengthBetween(MIN_LENGTH, MAX_LENGTH),\n                ScriptParameterInfoSerializingTests.randomInstances()\n            );\n            case GETTER -> new ScriptMethodInfo("}
{"magic_number_smell": "    static void addRandomKnnVectors(Document doc) {\n        int numFields = randomFrom(1, 3);\n        for (int f = 0; f < numFields; f++) {\n            doc.add(new KnnFloatVectorField(\"knnvector-\" + f, randomVector(128)));\n        }\n    }\n", "refactored_code": "    private static final int DEFAULT_VECTOR_DIMENSION = 128;\n    static void addRandomKnnVectors(Document doc) {\n        int numFields = randomFrom(1, 3);\n        for (int f = 0; f < numFields; f++) {\n            doc.add(new KnnFloatVectorField(\"knnvector-\" + f, randomVector(DEFAULT_VECTOR_DIMENSION)));\n        }\n    }\n"}
{"magic_number_smell": "                .build()\n        )\n        .build();\n    private final IndexMetadata ds1BackingIndex1 = DataStreamTestHelper.createBackingIndex(dataStreamName, 1, randomMillisUpToYear9999())\n        .numberOfShards(2)\n        .build();\n    private final IndexMetadata ds1BackingIndex2 = DataStreamTestHelper.createBackingIndex(dataStreamName, 2, randomMillisUpToYear9999() + 1)", "refactored_code": "    private final long millis = randomMillisUpToYear9999();\n                .build()\n        )\n        .build();\n    private final IndexMetadata ds1BackingIndex1 = DataStreamTestHelper.createBackingIndex(dataStreamName, 1, millis)\n        .numberOfShards(2)\n        .build();\n    private final IndexMetadata ds1BackingIndex2 = DataStreamTestHelper.createBackingIndex(dataStreamName, 2, millis + 1)"}
{"magic_number_smell": "    public void setUp() throws Exception {\n        super.setUp();\n        this.threadPool = createThreadPool();\n        this.bulkClient = new MockBulkClient(threadPool, 5);\n        // Stash some random headers so we can assert that we preserve them\n        bulkClient.threadPool().getThreadContext().stashContext();\n        expectedHeaders.clear();", "refactored_code": "    private static final int CALLS_TO_FAIL = 5;\n    public void setUp() throws Exception {\n        super.setUp();\n        this.threadPool = createThreadPool();\n        this.bulkClient = new MockBulkClient(threadPool, CALLS_TO_FAIL);\n        // Stash some random headers so we can assert that we preserve them\n        bulkClient.threadPool().getThreadContext().stashContext();\n        expectedHeaders.clear();"}
{"magic_number_smell": "    public void setUp() throws Exception {\n        super.setUp();\n        this.threadPool = createThreadPool();\n        this.bulkClient = new MockBulkClient(threadPool, 5);\n        // Stash some random headers so we can assert that we preserve them\n        bulkClient.threadPool().getThreadContext().stashContext();\n        expectedHeaders.clear();", "refactored_code": "    private static final int CALLS_TO_FAIL = 5;\n    public void setUp() throws Exception {\n        super.setUp();\n        this.threadPool = createThreadPool();\n        this.bulkClient = new MockBulkClient(threadPool, CALLS_TO_FAIL);\n        // Stash some random headers so we can assert that we preserve them\n        bulkClient.threadPool().getThreadContext().stashContext();\n        expectedHeaders.clear();"}
{"magic_number_smell": "        }\n        assertThat(searchResponse.getProfileResults().values().size(), equalTo(totalShards));\n        for (SearchProfileShardResult profileShardResult : searchResponse.getProfileResults().values()) {\n            assertThat(profileShardResult.getFetchPhase().getTime(), equalTo(555));\n        }\n    }\n", "refactored_code": "    private static final long FETCH_PROFILE_TIME = 555;\n        }\n        assertThat(searchResponse.getProfileResults().values().size(), equalTo(totalShards));\n        for (SearchProfileShardResult profileShardResult : searchResponse.getProfileResults().values()) {\n            assertThat(profileShardResult.getFetchPhase().getTime(), equalTo(FETCH_PROFILE_TIME));\n        }\n    }\n"}
{"magic_number_smell": "            .startObject(\"properties\")\n            .startObject(\"vector\")\n            .field(\"type\", \"dense_vector\")\n            .field(\"dims\", 10)\n            .field(\"index\", true)\n            .field(\"similarity\", \"l2_norm\")\n            .endObject()", "refactored_code": "    private static final int VECTOR_DIMENSION = 10;\n            .startObject(\"properties\")\n            .startObject(\"vector\")\n            .field(\"type\", \"dense_vector\")\n            .field(\"dims\", VECTOR_DIMENSION)\n            .field(\"index\", true)\n            .field(\"similarity\", \"l2_norm\")\n            .endObject()"}
{"magic_number_smell": "        }\n\n        @Override\n        public int randomInt()() {\n            return randomInt();\n        }\n", "refactored_code": "        private final int order = randomInt();\n        }\n\n        @Override\n        public int order() {\n            return order;\n        }\n"}
{"magic_number_smell": "\n        void advanceTime() {\n            final long startTime = deterministicTaskQueue.getCurrentTimeMillis();\n            deterministicTaskQueue.scheduleAt(startTime + between(1000, 2000), new Runnable() {\n                @Override\n                public void run() {}\n", "refactored_code": "        public static final int MAX_ADVANCE_MILLIS = 2000;\n\n        void advanceTime() {\n            final long startTime = deterministicTaskQueue.getCurrentTimeMillis();\n            deterministicTaskQueue.scheduleAt(startTime + between(1000, MAX_ADVANCE_MILLIS), new Runnable() {\n                @Override\n                public void run() {}\n"}
{"magic_number_smell": "\n        var allocation = createRoutingAllocation(state, ClusterInfo.EMPTY, SnapshotShardSizeInfo.EMPTY);\n\n        assertThat(getExpectedShardSize(shard, randomLongBetween(-1, 0), allocation), equalTo(randomLongBetween(-1, 0)));\n        assertFalse(\n            \"Should NOT reserve space for locally initializing primaries\",\n            shouldReserveSpaceForInitializingShard(shard, allocation)", "refactored_code": "    private final long defaultValue = randomLongBetween(-1, 0);\n\n        var allocation = createRoutingAllocation(state, ClusterInfo.EMPTY, SnapshotShardSizeInfo.EMPTY);\n\n        assertThat(getExpectedShardSize(shard, defaultValue, allocation), equalTo(defaultValue));\n        assertFalse(\n            \"Should NOT reserve space for locally initializing primaries\",\n            shouldReserveSpaceForInitializingShard(shard, allocation)"}
{"magic_number_smell": "        public byte[] newInstance() {\n            byte[] value = new byte[pageSize()];\n            // \"fresh\" is intentionally not 0 to ensure we covered this code path\n            Arrays.fill(value, 1);\n            return value;\n        }\n", "refactored_code": "    protected static final byte FRESH = 1;\n        public byte[] newInstance() {\n            byte[] value = new byte[pageSize()];\n            // \"fresh\" is intentionally not 0 to ensure we covered this code path\n            Arrays.fill(value, FRESH);\n            return value;\n        }\n"}
{"magic_number_smell": "            assertTrue(isNotInFlight);\n\n            final long connectResultTime = deterministicTaskQueue.getCurrentTimeMillis() + (slowAddresses.contains(transportAddress)\n                ? 30000\n                : 0);\n\n            deterministicTaskQueue.scheduleAt(connectResultTime, new Runnable() {", "refactored_code": "    private static final long CONNECTION_TIMEOUT_MILLIS = 30000;\n            assertTrue(isNotInFlight);\n\n            final long connectResultTime = deterministicTaskQueue.getCurrentTimeMillis() + (slowAddresses.contains(transportAddress)\n                ? CONNECTION_TIMEOUT_MILLIS\n                : 0);\n\n            deterministicTaskQueue.scheduleAt(connectResultTime, new Runnable() {"}
{"magic_number_smell": "    }\n\n    public void testStopClosesChannelAfterRequest() throws Exception {\n        var grace = 20_000;\n        try (var noTimeout = LogExpectation.unexpectedTimeout(grace); var transport = new TestHttpServerTransport(gracePeriod(grace))) {\n\n            TestHttpChannel httpChannel = new TestHttpChannel();", "refactored_code": "    private static final int LONG_GRACE_PERIOD_MS = 20_000;\n    }\n\n    public void testStopClosesChannelAfterRequest() throws Exception {\n        var grace = LONG_GRACE_PERIOD_MS;\n        try (var noTimeout = LogExpectation.unexpectedTimeout(grace); var transport = new TestHttpServerTransport(gracePeriod(grace))) {\n\n            TestHttpChannel httpChannel = new TestHttpChannel();"}
{"magic_number_smell": "\n        @Override\n        public long absoluteTimeInMillis() {\n            return currentTimeInMillis + randomLong();\n        }\n\n        void setCurrentTimeInMillis(long currentTimeInMillis) {", "refactored_code": "        private final long absoluteTimeOffset = randomLong();\n\n        @Override\n        public long absoluteTimeInMillis() {\n            return currentTimeInMillis + absoluteTimeOffset;\n        }\n\n        void setCurrentTimeInMillis(long currentTimeInMillis) {"}
{"magic_number_smell": "    }\n\n    public void testRandomValues() throws IOException {\n        long[] arr = new long[ES87TSDBDocValuesFormat.NUMERIC_BLOCK_SIZE];\n        for (int i = 0; i < ES87TSDBDocValuesFormat.NUMERIC_BLOCK_SIZE; ++i) {\n            arr[i] = random().nextLong();\n        }", "refactored_code": "    private final int blockSize = ES87TSDBDocValuesFormat.NUMERIC_BLOCK_SIZE;\n    }\n\n    public void testRandomValues() throws IOException {\n        long[] arr = new long[blockSize];\n        for (int i = 0; i < blockSize; ++i) {\n            arr[i] = random().nextLong();\n        }"}
{"magic_number_smell": "            IndexWriterConfig conf = newIndexWriterConfig(analyzer);\n            conf.setMergePolicy(newLogMergePolicy());\n            try (RandomIndexWriter iwriter = new RandomIndexWriter(random(), directory, conf)) {\n                for (int i = 0; i < 10; i++) {\n                    Document doc = new Document();\n                    doc.add(new SortedDocValuesField(\"field\", newBytesRef(\"value\")));\n                    doc.add(new SortedDocValuesField(\"field\" + i, newBytesRef(\"value\" + i)));", "refactored_code": "    private static final int NUM_DOCS = 10;\n            IndexWriterConfig conf = newIndexWriterConfig(analyzer);\n            conf.setMergePolicy(newLogMergePolicy());\n            try (RandomIndexWriter iwriter = new RandomIndexWriter(random(), directory, conf)) {\n                for (int i = 0; i < NUM_DOCS; i++) {\n                    Document doc = new Document();\n                    doc.add(new SortedDocValuesField(\"field\", newBytesRef(\"value\")));\n                    doc.add(new SortedDocValuesField(\"field\" + i, newBytesRef(\"value\" + i)));"}
{"magic_number_smell": "    }\n\n    public void testFetchMillisFromIso8601() throws IOException {\n        assertFetch(dateMapperService(), \"field\", DEFAULT_DATE_TIME_FORMATTER.formatMillis(randomLongBetween(0, DEFAULT_DATE_TIME_FORMATTER.parseMillis(\"9999-12-12T23:59:59.999Z\"))), \"iso8601\");\n    }\n\n    public void testFetchMillisFromIso8601Nanos() throws IOException {", "refactored_code": "    private static final long MAX_ISO_DATE = DEFAULT_DATE_TIME_FORMATTER.parseMillis(\"9999-12-12T23:59:59.999Z\");\n    }\n\n    public void testFetchMillisFromIso8601() throws IOException {\n        assertFetch(dateMapperService(), \"field\", DEFAULT_DATE_TIME_FORMATTER.formatMillis(randomLongBetween(0, MAX_ISO_DATE)), \"iso8601\");\n    }\n\n    public void testFetchMillisFromIso8601Nanos() throws IOException {"}
{"magic_number_smell": "    private static final long 0 = 0;\n\n    public void testIsFieldWithinRangeEmptyReader() throws IOException {\n        QueryRewriteContext context = new QueryRewriteContext(parserConfig(), null, () -> 0);\n        IndexReader reader = new MultiReader();\n        DateFieldType ft = new DateFieldType(\"my_date\");\n        assertEquals(", "refactored_code": "    private static final long nowInMillis = 0;\n    private static final long nowInMillis = 0;\n\n    public void testIsFieldWithinRangeEmptyReader() throws IOException {\n        QueryRewriteContext context = new QueryRewriteContext(parserConfig(), null, () -> nowInMillis);\n        IndexReader reader = new MultiReader();\n        DateFieldType ft = new DateFieldType(\"my_date\");\n        assertEquals("}
{"magic_number_smell": "            assertThat(leafReader.numDocs(), equalTo(3));\n            var leaf = idLoader.leaf(null, leafReader, new int[] { 0, 1, 2 });\n            // NOTE: time series data is ordered by (tsid, timestamp)\n            assertThat(leaf.getId(0), equalTo(expectedId(docs.get(2), randomInt())));\n            assertThat(leaf.getId(1), equalTo(expectedId(docs.get(0), randomInt())));\n            assertThat(leaf.getId(2), equalTo(expectedId(docs.get(1), randomInt())));\n        };", "refactored_code": "    private final int routingHash = randomInt();\n            assertThat(leafReader.numDocs(), equalTo(3));\n            var leaf = idLoader.leaf(null, leafReader, new int[] { 0, 1, 2 });\n            // NOTE: time series data is ordered by (tsid, timestamp)\n            assertThat(leaf.getId(0), equalTo(expectedId(docs.get(2), routingHash)));\n            assertThat(leaf.getId(1), equalTo(expectedId(docs.get(0), routingHash)));\n            assertThat(leaf.getId(2), equalTo(expectedId(docs.get(1), routingHash)));\n        };"}
{"magic_number_smell": "                id,\n                BytesReference.bytes(builder),\n                builder.contentType(),\n                TimeSeriesRoutingHashFieldMapper.encode(7)\n            );\n            return mapperService.documentParser().parseDocument(sourceToParse, mapperService.mappingLookup());\n        }", "refactored_code": "    private static final int ROUTING_HASH = 7;\n                id,\n                BytesReference.bytes(builder),\n                builder.contentType(),\n                TimeSeriesRoutingHashFieldMapper.encode(ROUTING_HASH)\n            );\n            return mapperService.documentParser().parseDocument(sourceToParse, mapperService.mappingLookup());\n        }"}
{"magic_number_smell": "        @Override\n        public SyntheticSourceExample example(int maxValues) throws IOException {\n            Object value = elementType == ElementType.BYTE\n                ? randomList(between(5, 1000), between(5, 1000), ESTestCase::randomByte)\n                : randomList(between(5, 1000), between(5, 1000), ESTestCase::randomFloat);\n            return new SyntheticSourceExample(value, value, this::mapping);\n        }", "refactored_code": "        private final int dims = between(5, 1000);\n        @Override\n        public SyntheticSourceExample example(int maxValues) throws IOException {\n            Object value = elementType == ElementType.BYTE\n                ? randomList(dims, dims, ESTestCase::randomByte)\n                : randomList(dims, dims, ESTestCase::randomFloat);\n            return new SyntheticSourceExample(value, value, this::mapping);\n        }"}
{"magic_number_smell": "    }\n\n    public void testSerialization() throws Exception {\n        for (int runs = 0; runs < 20; runs++) {\n            InnerHitBuilder original = randomInnerHits();\n            InnerHitBuilder deserialized = serializedCopy(original);\n            assertEquals(deserialized, original);", "refactored_code": "    private static final int NUMBER_OF_TESTBUILDERS = 20;\n    }\n\n    public void testSerialization() throws Exception {\n        for (int runs = 0; runs < NUMBER_OF_TESTBUILDERS; runs++) {\n            InnerHitBuilder original = randomInnerHits();\n            InnerHitBuilder deserialized = serializedCopy(original);\n            assertEquals(deserialized, original);"}
{"magic_number_smell": "            .startObject(\"properties\")\n            .startObject(VECTOR_FIELD)\n            .field(\"type\", \"dense_vector\")\n            .field(\"dims\", 3)\n            .field(\"index\", true)\n            .field(\"similarity\", \"cosine\")\n            .endObject()", "refactored_code": "    private static final int VECTOR_DIMENSION = 3;\n            .startObject(\"properties\")\n            .startObject(VECTOR_FIELD)\n            .field(\"type\", \"dense_vector\")\n            .field(\"dims\", VECTOR_DIMENSION)\n            .field(\"index\", true)\n            .field(\"similarity\", \"cosine\")\n            .endObject()"}
{"magic_number_smell": "    }\n\n    public static void assertCloseTo(final GeoPoint point, final double lat, final double lon) {\n        assertEquals(point.lat(), lat, 1E-5);\n        assertEquals(point.lon(), lon, 1E-5);\n    }\n", "refactored_code": "    private static final double TOLERANCE = 1E-5;\n    }\n\n    public static void assertCloseTo(final GeoPoint point, final double lat, final double lon) {\n        assertEquals(point.lat(), lat, TOLERANCE);\n        assertEquals(point.lon(), lon, TOLERANCE);\n    }\n"}
{"magic_number_smell": "    public void testNormalizeLatInNormalRange() {\n        for (int i = 0; i < 100; i++) {\n            double testValue = (randomDouble() * 180.0) - 90.0;\n            assertThat(GeoUtils.normalizeLat(testValue), closeTo(testValue, 0.000000001));\n        }\n    }\n", "refactored_code": "    private static final double MAX_ACCEPTABLE_ERROR = 0.000000001;\n    public void testNormalizeLatInNormalRange() {\n        for (int i = 0; i < 100; i++) {\n            double testValue = (randomDouble() * 180.0) - 90.0;\n            assertThat(GeoUtils.normalizeLat(testValue), closeTo(testValue, MAX_ACCEPTABLE_ERROR));\n        }\n    }\n"}
{"magic_number_smell": "    public void testVerifyingIndexOutputOnTooShortFile() throws IOException {\n        final var metadata = new StoreFileMetadata(\n            \"foo.bar\",\n            between(0, 8 - 1),\n            randomAlphaOfLength(5),\n            MIN_SUPPORTED_LUCENE_VERSION.toString()\n        );", "refactored_code": "    private static final int CHECKSUM_LENGTH = 8;\n    public void testVerifyingIndexOutputOnTooShortFile() throws IOException {\n        final var metadata = new StoreFileMetadata(\n            \"foo.bar\",\n            between(0, CHECKSUM_LENGTH - 1),\n            randomAlphaOfLength(5),\n            MIN_SUPPORTED_LUCENE_VERSION.toString()\n        );"}
{"magic_number_smell": "        }\n        \"\"\";\n\n    private static final String MAPPINGS = getVersionedMappings(10);\n\n    /**\n     * Tests the various validation rules that are applied when creating a new system index descriptor.", "refactored_code": "    private static final int TEST_MAPPINGS_VERSION = 10;\n        }\n        \"\"\";\n\n    private static final String MAPPINGS = getVersionedMappings(TEST_MAPPINGS_VERSION);\n\n    /**\n     * Tests the various validation rules that are applied when creating a new system index descriptor."}
{"magic_number_smell": "            Geometry geometry = new Line(subX, subY);\n            calculator = new CentroidCalculator();\n            calculator.add(geometry);\n            assertThat(xRunningAvg[i], closeTo(calculator.getX(), 0.000000001));\n            assertThat(yRunningAvg[i], closeTo(calculator.getY(), 0.000000001));\n        }\n        calculator.add(new Point(0, 0));", "refactored_code": "    private static final double DELTA = 0.000000001;\n            Geometry geometry = new Line(subX, subY);\n            calculator = new CentroidCalculator();\n            calculator.add(geometry);\n            assertThat(xRunningAvg[i], closeTo(calculator.getX(), DELTA));\n            assertThat(yRunningAvg[i], closeTo(calculator.getY(), DELTA));\n        }\n        calculator.add(new Point(0, 0));"}
{"magic_number_smell": "\n    @Override\n    protected Settings nodeSettings() {\n        return Settings.builder().put(super.nodeSettings()).put(\"thread_pool.snapshot.max\", 3).build();\n    }\n\n    protected Collection<Class<? extends Plugin>> getPlugins() {", "refactored_code": "    private static final int MAX_SNAPSHOT_THREADS = 3;\n\n    @Override\n    protected Settings nodeSettings() {\n        return Settings.builder().put(super.nodeSettings()).put(\"thread_pool.snapshot.max\", MAX_SNAPSHOT_THREADS).build();\n    }\n\n    protected Collection<Class<? extends Plugin>> getPlugins() {"}
{"magic_number_smell": "    }\n\n    protected void reset() {\n        metadata = new ReindexMetadata(INDEX, ID, 5, ROUTING, OP, TIMESTAMP);\n    }\n\n    public void testIndex() {", "refactored_code": "    private static final long VERSION = 5;\n    }\n\n    protected void reset() {\n        metadata = new ReindexMetadata(INDEX, ID, VERSION, ROUTING, OP, TIMESTAMP);\n    }\n\n    public void testIndex() {"}
{"magic_number_smell": "    @Before\n    public void setUp() throws Exception {\n        super.setUp();\n        map = new UpdateCtxMap(\"myIndex\", \"myId\", 5, \"myRoute\", \"myType\", \"index\", 704289600000L, Map.of(\"foo\", \"bar\"));\n        meta = map.getMetadata();\n    }\n", "refactored_code": "    private final long TS = 704289600000L;\n    @Before\n    public void setUp() throws Exception {\n        super.setUp();\n        map = new UpdateCtxMap(\"myIndex\", \"myId\", 5, \"myRoute\", \"myType\", \"index\", TS, Map.of(\"foo\", \"bar\"));\n        meta = map.getMetadata();\n    }\n"}
{"magic_number_smell": "    }\n\n    private void assertGeoPointEquals(GeoPoint gp, final double longitude, final double latitude) {\n        assertThat(gp.lon(), closeTo(longitude, 1E-5D));\n        assertThat(gp.lat(), closeTo(latitude, 1E-5D));\n    }\n", "refactored_code": "    private static final double GEOTILE_TOLERANCE = 1E-5D;\n    }\n\n    private void assertGeoPointEquals(GeoPoint gp, final double longitude, final double latitude) {\n        assertThat(gp.lon(), closeTo(longitude, GEOTILE_TOLERANCE));\n        assertThat(gp.lat(), closeTo(latitude, GEOTILE_TOLERANCE));\n    }\n"}
{"magic_number_smell": "        });\n        deterministicScripts.put(VALUE_SCRIPT, vars -> {\n            final double value = ((Number) vars.get(\"_value\")).doubleValue();\n            return value + 1;\n        });\n        deterministicScripts.put(FIELD_SCRIPT_PARAMS, vars -> {\n            final String fieldName = (String) vars.get(\"field\");", "refactored_code": "    private static final long DEFAULT_INC_PARAM = 1;\n        });\n        deterministicScripts.put(VALUE_SCRIPT, vars -> {\n            final double value = ((Number) vars.get(\"_value\")).doubleValue();\n            return value + DEFAULT_INC_PARAM;\n        });\n        deterministicScripts.put(FIELD_SCRIPT_PARAMS, vars -> {\n            final String fieldName = (String) vars.get(\"field\");"}
{"magic_number_smell": "            FastGeometric geometric = new FastGeometric(rng::nextInt, p);\n            int[] counts = new int[size];\n            double mean = 0.0;\n            for (int i = 0; i < 10_000_000; ++i) {\n                int sample = (geometric.next() - 1);\n                if (sample < counts.length) {\n                    counts[sample]++;", "refactored_code": "    private static final int N = 10_000_000;\n            FastGeometric geometric = new FastGeometric(rng::nextInt, p);\n            int[] counts = new int[size];\n            double mean = 0.0;\n            for (int i = 0; i < N; ++i) {\n                int sample = (geometric.next() - 1);\n                if (sample < counts.length) {\n                    counts[sample]++;"}
{"magic_number_smell": "        testCase(RandomSamplerAggregatorTests::writeTestDocsWithTrueMinMax, (InternalRandomSampler result) -> {\n            Min min = result.getAggregations().get(\"min\");\n            Max max = result.getAggregations().get(\"max\");\n            assertThat(min.value(), equalTo((double) 2L));\n            assertThat(max.value(), equalTo((double) TRUE_MAX));\n        },\n            new AggTestConfig(", "refactored_code": "    private static final long TRUE_MIN = 2L;\n        testCase(RandomSamplerAggregatorTests::writeTestDocsWithTrueMinMax, (InternalRandomSampler result) -> {\n            Min min = result.getAggregations().get(\"min\");\n            Max max = result.getAggregations().get(\"max\");\n            assertThat(min.value(), equalTo((double) TRUE_MIN));\n            assertThat(max.value(), equalTo((double) TRUE_MAX));\n        },\n            new AggTestConfig("}
{"magic_number_smell": "            }\n        }, stats -> {\n            assertEquals(expected.count, stats.getCount(), 0);\n            assertEquals(expected.sum, stats.getSum(), 1e-5);\n            assertEquals(expected.min, stats.getMin(), 0);\n            assertEquals(expected.max, stats.getMax(), 0);\n            assertEquals(expected.sum / expected.count, stats.getAvg(), 1e-5);", "refactored_code": "    private static final double TOLERANCE = 1e-5;\n            }\n        }, stats -> {\n            assertEquals(expected.count, stats.getCount(), 0);\n            assertEquals(expected.sum, stats.getSum(), TOLERANCE);\n            assertEquals(expected.min, stats.getMin(), 0);\n            assertEquals(expected.max, stats.getMax(), 0);\n            assertEquals(expected.sum / expected.count, stats.getAvg(), TOLERANCE);"}
{"magic_number_smell": "            assertEquals(\"my_agg\", result.getName());\n            SpatialPoint centroid = result.centroid();\n            assertNotNull(centroid);\n            assertEquals(expectedCentroid.getX(), centroid.getX(), 1E-6D);\n            assertEquals(expectedCentroid.getY(), centroid.getY(), 1E-6D);\n            assertTrue(AggregationInspectionHelper.hasValue(result));\n        }", "refactored_code": "    private static final double GEOHASH_TOLERANCE = 1E-6D;\n            assertEquals(\"my_agg\", result.getName());\n            SpatialPoint centroid = result.centroid();\n            assertNotNull(centroid);\n            assertEquals(expectedCentroid.getX(), centroid.getX(), GEOHASH_TOLERANCE);\n            assertEquals(expectedCentroid.getY(), centroid.getY(), GEOHASH_TOLERANCE);\n            assertTrue(AggregationInspectionHelper.hasValue(result));\n        }"}
{"magic_number_smell": "            return values;\n        };\n\n        scripts.put(SCRIPT_NAME, script -> 19L);\n        scripts.put(SUM_FIELD_PARAMS_SCRIPT, vars -> {\n            String fieldname = (String) vars.get(\"field\");\n            return sum.apply(vars, fieldname);", "refactored_code": "    private static final long SCRIPT_VALUE = 19L;\n            return values;\n        };\n\n        scripts.put(SCRIPT_NAME, script -> SCRIPT_VALUE);\n        scripts.put(SUM_FIELD_PARAMS_SCRIPT, vars -> {\n            String fieldname = (String) vars.get(\"field\");\n            return sum.apply(vars, fieldname);"}
{"magic_number_smell": "\n        return writer -> {\n            for (int i = 0; i < size; i++) {\n                final long point = randomLongBetween(-1000000, SAMPLE_MAX);\n                Iterable<T> document = field.apply(point);\n                writer.addDocument(document);\n            }", "refactored_code": "    private static final int SAMPLE_MIN = -1000000;\n\n        return writer -> {\n            for (int i = 0; i < size; i++) {\n                final long point = randomLongBetween(SAMPLE_MIN, SAMPLE_MAX);\n                Iterable<T> document = field.apply(point);\n                writer.addDocument(document);\n            }"}
{"magic_number_smell": "            return values;\n        };\n\n        scripts.put(SCRIPT_NAME, script -> 19L);\n        scripts.put(SUM_FIELD_PARAMS_SCRIPT, vars -> {\n            String fieldname = (String) vars.get(\"field\");\n            return sum.apply(vars, fieldname);", "refactored_code": "    private static final long SCRIPT_VALUE = 19L;\n            return values;\n        };\n\n        scripts.put(SCRIPT_NAME, script -> SCRIPT_VALUE);\n        scripts.put(SUM_FIELD_PARAMS_SCRIPT, vars -> {\n            String fieldname = (String) vars.get(\"field\");\n            return sum.apply(vars, fieldname);"}
{"magic_number_smell": "            }\n        }, stats -> {\n            assertEquals(expected.count, stats.getCount(), 0);\n            assertEquals(expected.sum, stats.getSum(), 1e-10);\n            assertEquals(expected.min, stats.getMin(), 0);\n            assertEquals(expected.max, stats.getMax(), 0);\n            assertEquals(expected.sum / expected.count, stats.getAvg(), 1e-10);", "refactored_code": "    private static final double TOLERANCE = 1e-10;\n            }\n        }, stats -> {\n            assertEquals(expected.count, stats.getCount(), 0);\n            assertEquals(expected.sum, stats.getSum(), TOLERANCE);\n            assertEquals(expected.min, stats.getMin(), 0);\n            assertEquals(expected.max, stats.getMax(), 0);\n            assertEquals(expected.sum / expected.count, stats.getAvg(), TOLERANCE);"}
{"magic_number_smell": "     * Test serialization and deserialization of the highlighter builder\n     */\n    public void testSerialization() throws IOException {\n        for (int runs = 0; runs < 20; runs++) {\n            HighlightBuilder original = randomHighlighterBuilder();\n            HighlightBuilder deserialized = serializedCopy(original);\n            assertEquals(deserialized, original);", "refactored_code": "    private static final int NUMBER_OF_TESTBUILDERS = 20;\n     * Test serialization and deserialization of the highlighter builder\n     */\n    public void testSerialization() throws IOException {\n        for (int runs = 0; runs < NUMBER_OF_TESTBUILDERS; runs++) {\n            HighlightBuilder original = randomHighlighterBuilder();\n            HighlightBuilder deserialized = serializedCopy(original);\n            assertEquals(deserialized, original);"}
{"magic_number_smell": "     * Test serialization and deserialization of the rescore builder\n     */\n    public void testSerialization() throws IOException {\n        for (int runs = 0; runs < 20; runs++) {\n            RescorerBuilder<?> original = randomRescoreBuilder();\n            RescorerBuilder<?> deserialized = copy(original);\n            assertEquals(deserialized, original);", "refactored_code": "    private static final int NUMBER_OF_TESTBUILDERS = 20;\n     * Test serialization and deserialization of the rescore builder\n     */\n    public void testSerialization() throws IOException {\n        for (int runs = 0; runs < NUMBER_OF_TESTBUILDERS; runs++) {\n            RescorerBuilder<?> original = randomRescoreBuilder();\n            RescorerBuilder<?> deserialized = copy(original);\n            assertEquals(deserialized, original);"}
{"magic_number_smell": "    }\n\n    public void testSerialization() throws Exception {\n        for (int runs = 0; runs < 20; runs++) {\n            SearchAfterBuilder original = randomSearchAfterBuilder();\n            SearchAfterBuilder deserialized = serializedCopy(original);\n            assertEquals(deserialized, original);", "refactored_code": "    private static final int NUMBER_OF_TESTBUILDERS = 20;\n    }\n\n    public void testSerialization() throws Exception {\n        for (int runs = 0; runs < NUMBER_OF_TESTBUILDERS; runs++) {\n            SearchAfterBuilder original = randomSearchAfterBuilder();\n            SearchAfterBuilder deserialized = serializedCopy(original);\n            assertEquals(deserialized, original);"}
{"magic_number_smell": "    private static final int 20 = 20;\n\n    private static SliceBuilder randomSliceBuilder() {\n        int max = randomIntBetween(2, 20);\n        int id = randomIntBetween(1, max - 1);\n        String field = randomBoolean() ? randomAlphaOfLengthBetween(5, 20) : null;\n        return new SliceBuilder(field, id, max);", "refactored_code": "    private static final int MAX_SLICE = 20;\n    private static final int MAX_SLICE = 20;\n\n    private static SliceBuilder randomSliceBuilder() {\n        int max = randomIntBetween(2, MAX_SLICE);\n        int id = randomIntBetween(1, max - 1);\n        String field = randomBoolean() ? randomAlphaOfLengthBetween(5, 20) : null;\n        return new SliceBuilder(field, id, max);"}
{"magic_number_smell": "     * Test that creates new sort from a random test sort and checks both for equality\n     */\n    public void testFromXContent() throws IOException {\n        for (int runs = 0; runs < 20; runs++) {\n            T testItem = createTestItem();\n\n            XContentBuilder builder = XContentFactory.contentBuilder(randomFrom(XContentType.values()));", "refactored_code": "    private static final int NUMBER_OF_TESTBUILDERS = 20;\n     * Test that creates new sort from a random test sort and checks both for equality\n     */\n    public void testFromXContent() throws IOException {\n        for (int runs = 0; runs < NUMBER_OF_TESTBUILDERS; runs++) {\n            T testItem = createTestItem();\n\n            XContentBuilder builder = XContentFactory.contentBuilder(randomFrom(XContentType.values()));"}
{"magic_number_smell": "    }\n\n    public void testFromXContent() throws IOException {\n        for (int runs = 0; runs < 20; runs++) {\n            NestedSortBuilder testItem = createRandomNestedSort(3);\n            XContentBuilder builder = XContentFactory.contentBuilder(randomFrom(XContentType.values()));\n            testItem.toXContent(builder, ToXContent.EMPTY_PARAMS);", "refactored_code": "    private static final int NUMBER_OF_TESTBUILDERS = 20;\n    }\n\n    public void testFromXContent() throws IOException {\n        for (int runs = 0; runs < NUMBER_OF_TESTBUILDERS; runs++) {\n            NestedSortBuilder testItem = createRandomNestedSort(3);\n            XContentBuilder builder = XContentFactory.contentBuilder(randomFrom(XContentType.values()));\n            testItem.toXContent(builder, ToXContent.EMPTY_PARAMS);"}
{"magic_number_smell": "     * test parsing random syntax variations\n     */\n    public void testRandomSortBuilders() throws IOException {\n        for (int runs = 0; runs < 20; runs++) {\n            Set<String> expectedWarningHeaders = new HashSet<>();\n            List<SortBuilder<?>> testBuilders = randomSortBuilderList();\n            XContentBuilder xContentBuilder = XContentFactory.jsonBuilder();", "refactored_code": "    private static final int NUMBER_OF_RUNS = 20;\n     * test parsing random syntax variations\n     */\n    public void testRandomSortBuilders() throws IOException {\n        for (int runs = 0; runs < NUMBER_OF_RUNS; runs++) {\n            Set<String> expectedWarningHeaders = new HashSet<>();\n            List<SortBuilder<?>> testBuilders = randomSortBuilderList();\n            XContentBuilder xContentBuilder = XContentFactory.jsonBuilder();"}
{"magic_number_smell": "     * Test serialization and deserialization of the suggestion builder\n     */\n    public void testSerialization() throws IOException {\n        for (int runs = 0; runs < 20; runs++) {\n            SB original = randomTestBuilder();\n            SB deserialized = copy(original);\n            assertEquals(deserialized, original);", "refactored_code": "    private static final int NUMBER_OF_TESTBUILDERS = 20;\n     * Test serialization and deserialization of the suggestion builder\n     */\n    public void testSerialization() throws IOException {\n        for (int runs = 0; runs < NUMBER_OF_TESTBUILDERS; runs++) {\n            SB original = randomTestBuilder();\n            SB deserialized = copy(original);\n            assertEquals(deserialized, original);"}
{"magic_number_smell": "     *  creates random suggestion builder, renders it to xContent and back to new instance that should be equal to original\n     */\n    public void testFromXContent() throws IOException {\n        for (int runs = 0; runs < 20; runs++) {\n            SuggestBuilder suggestBuilder = randomSuggestBuilder();\n            XContentBuilder xContentBuilder = XContentFactory.contentBuilder(randomFrom(XContentType.values()));\n            if (randomBoolean()) {", "refactored_code": "    private static final int NUMBER_OF_RUNS = 20;\n     *  creates random suggestion builder, renders it to xContent and back to new instance that should be equal to original\n     */\n    public void testFromXContent() throws IOException {\n        for (int runs = 0; runs < NUMBER_OF_RUNS; runs++) {\n            SuggestBuilder suggestBuilder = randomSuggestBuilder();\n            XContentBuilder xContentBuilder = XContentFactory.contentBuilder(randomFrom(XContentType.values()));\n            if (randomBoolean()) {"}
{"magic_number_smell": "     * Test serialization and deserialization\n     */\n    public void testSerialization() throws IOException {\n        for (int i = 0; i < 20; i++) {\n            FuzzyOptions testModel = randomFuzzyOptions();\n            FuzzyOptions deserializedModel = copyWriteable(\n                testModel,", "refactored_code": "    private static final int NUMBER_OF_RUNS = 20;\n     * Test serialization and deserialization\n     */\n    public void testSerialization() throws IOException {\n        for (int i = 0; i < NUMBER_OF_RUNS; i++) {\n            FuzzyOptions testModel = randomFuzzyOptions();\n            FuzzyOptions deserializedModel = copyWriteable(\n                testModel,"}
{"magic_number_smell": "    protected abstract QC fromXContent(XContentParser parser) throws IOException;\n\n    public void testToXContext() throws IOException {\n        for (int i = 0; i < 20; i++) {\n            QC toXContent = createTestModel();\n            XContentBuilder builder = XContentFactory.jsonBuilder();\n            toXContent.toXContent(builder, ToXContent.EMPTY_PARAMS);", "refactored_code": "    private static final int NUMBER_OF_RUNS = 20;\n    protected abstract QC fromXContent(XContentParser parser) throws IOException;\n\n    public void testToXContext() throws IOException {\n        for (int i = 0; i < NUMBER_OF_RUNS; i++) {\n            QC toXContent = createTestModel();\n            XContentBuilder builder = XContentFactory.jsonBuilder();\n            toXContent.toXContent(builder, ToXContent.EMPTY_PARAMS);"}
{"magic_number_smell": "     * Test serialization and deserialization\n     */\n    public void testSerialization() throws IOException {\n        for (int i = 0; i < 20; i++) {\n            RegexOptions testOptions = randomRegexOptions();\n            RegexOptions deserializedModel = copyWriteable(\n                testOptions,", "refactored_code": "    private static final int NUMBER_OF_RUNS = 20;\n     * Test serialization and deserialization\n     */\n    public void testSerialization() throws IOException {\n        for (int i = 0; i < NUMBER_OF_RUNS; i++) {\n            RegexOptions testOptions = randomRegexOptions();\n            RegexOptions deserializedModel = copyWriteable(\n                testOptions,"}
{"magic_number_smell": "     * Test serialization and deserialization of the generator\n     */\n    public void testSerialization() throws IOException {\n        for (int runs = 0; runs < 20; runs++) {\n            DirectCandidateGeneratorBuilder original = randomCandidateGenerator();\n            DirectCandidateGeneratorBuilder deserialized = copy(original);\n            assertEquals(deserialized, original);", "refactored_code": "    private static final int NUMBER_OF_RUNS = 20;\n     * Test serialization and deserialization of the generator\n     */\n    public void testSerialization() throws IOException {\n        for (int runs = 0; runs < NUMBER_OF_RUNS; runs++) {\n            DirectCandidateGeneratorBuilder original = randomCandidateGenerator();\n            DirectCandidateGeneratorBuilder deserialized = copy(original);\n            assertEquals(deserialized, original);"}
{"magic_number_smell": "        createIndex(\n            indexName,\n            Settings.builder()\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, randomIntBetween(2, 7))\n                .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n                .build()\n        );", "refactored_code": "    private final int num_primaries = randomIntBetween(2, 7);\n        createIndex(\n            indexName,\n            Settings.builder()\n                .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, num_primaries)\n                .put(IndexMetadata.SETTING_NUMBER_OF_REPLICAS, 0)\n                .build()\n        );"}
{"magic_number_smell": "            .startObject(\"properties\")\n            .startObject(VECTOR_FIELD)\n            .field(\"type\", \"dense_vector\")\n            .field(\"dims\", 3)\n            .field(\"index\", true)\n            .field(\"similarity\", \"cosine\")\n            .endObject()", "refactored_code": "    private static final int VECTOR_DIMENSION = 3;\n            .startObject(\"properties\")\n            .startObject(VECTOR_FIELD)\n            .field(\"type\", \"dense_vector\")\n            .field(\"dims\", VECTOR_DIMENSION)\n            .field(\"index\", true)\n            .field(\"similarity\", \"cosine\")\n            .endObject()"}
{"magic_number_smell": "\n        VectorData vectorData = new VectorData(null, byteVector);\n        float[] actual = vectorData.asFloatVector();\n        assertArrayEquals(expected, actual, 1e-5f);\n    }\n\n    public void testShouldThrowForDecimalsWhenConvertingToByte() {", "refactored_code": "    private static final float DELTA = 1e-5f;\n\n        VectorData vectorData = new VectorData(null, byteVector);\n        float[] actual = vectorData.asFloatVector();\n        assertArrayEquals(expected, actual, DELTA);\n    }\n\n    public void testShouldThrowForDecimalsWhenConvertingToByte() {"}
{"magic_number_smell": "                safeAwait(startBarrier);\n\n                state.incrementAndGet();\n                tracker.put(task, randomIntBetween(-1, 10), item);\n                state.incrementAndGet();\n\n                Thread.yield();", "refactored_code": "        private final long requestId = randomIntBetween(-1, 10);\n                safeAwait(startBarrier);\n\n                state.incrementAndGet();\n                tracker.put(task, requestId, item);\n                state.incrementAndGet();\n\n                Thread.yield();"}
{"magic_number_smell": "         * full TaskId.\n         */\n        int expectedSize = 31; // 8 for the task number, 1 for the string length of the uuid, 22 for the actual uuid\n        for (int i = 0; i < 30; i++) {\n            TaskId taskId = new TaskId(UUIDs.randomBase64UUID(random()), randomInt());\n            TaskId roundTripped = roundTrip(taskId, expectedSize);\n            assertNotSame(taskId, roundTripped);", "refactored_code": "    private static final int ROUNDS = 30;\n         * full TaskId.\n         */\n        int expectedSize = 31; // 8 for the task number, 1 for the string length of the uuid, 22 for the actual uuid\n        for (int i = 0; i < ROUNDS; i++) {\n            TaskId taskId = new TaskId(UUIDs.randomBase64UUID(random()), randomInt());\n            TaskId roundTripped = roundTrip(taskId, expectedSize);\n            assertNotSame(taskId, roundTripped);"}
{"magic_number_smell": "            expected.clear();\n            toRelease.clear();\n            try (RecyclerBytesStreamOutput streamOutput = new RecyclerBytesStreamOutput(recycler)) {\n                while (streamOutput.size() < 128 * 1024) {\n                    final TransportVersion version = randomFrom(TransportVersion.current(), TransportVersions.MINIMUM_COMPATIBLE);\n                    final String value = randomRealisticUnicodeOfCodepointLength(randomIntBetween(200, 400));\n                    final boolean isRequest = randomBoolean();", "refactored_code": "    private static final int BYTE_THRESHOLD = 128 * 1024;\n            expected.clear();\n            toRelease.clear();\n            try (RecyclerBytesStreamOutput streamOutput = new RecyclerBytesStreamOutput(recycler)) {\n                while (streamOutput.size() < BYTE_THRESHOLD) {\n                    final TransportVersion version = randomFrom(TransportVersion.current(), TransportVersions.MINIMUM_COMPATIBLE);\n                    final String value = randomRealisticUnicodeOfCodepointLength(randomIntBetween(200, 400));\n                    final boolean isRequest = randomBoolean();"}
{"magic_number_smell": "            )\n        );\n        if (enabled) {\n            addExposedPort(9000);\n        }\n        this.enabled = enabled;\n    }", "refactored_code": "    private static final int servicePort = 9000;\n            )\n        );\n        if (enabled) {\n            addExposedPort(servicePort);\n        }\n        this.enabled = enabled;\n    }"}
{"magic_number_smell": "            private final int randomInt() = randomInt();\n\n            @Override\n            public int randomInt()() {\n                return randomInt();\n            }\n", "refactored_code": "            private final int order = randomInt();\n            private final int order = randomInt();\n\n            @Override\n            public int order() {\n                return order;\n            }\n"}
{"magic_number_smell": "    // 8. apply committed state on master (last one to apply cluster state)\n    // 9. complete the publication listener back on the master service thread\n    public static final int 9 = 9;\n    public static final long DEFAULT_CLUSTER_STATE_UPDATE_DELAY = 9 * DEFAULT_DELAY_VARIABILITY;\n\n    private static final int ELECTION_RETRIES = 10;\n", "refactored_code": "    public static final int CLUSTER_STATE_UPDATE_NUMBER_OF_DELAYS = 9;\n    // 8. apply committed state on master (last one to apply cluster state)\n    // 9. complete the publication listener back on the master service thread\n    public static final int CLUSTER_STATE_UPDATE_NUMBER_OF_DELAYS = 9;\n    public static final long DEFAULT_CLUSTER_STATE_UPDATE_DELAY = CLUSTER_STATE_UPDATE_NUMBER_OF_DELAYS * DEFAULT_DELAY_VARIABILITY;\n\n    private static final int ELECTION_RETRIES = 10;\n"}
{"magic_number_smell": "    public static IndexMetadata.Builder createBackingIndex(String dataStreamName, int generation, long epochMillis) {\n        return IndexMetadata.builder(DataStream.getDefaultBackingIndexName(dataStreamName, generation, epochMillis))\n            .settings(SETTINGS)\n            .numberOfShards(1)\n            .numberOfReplicas(NUMBER_OF_REPLICAS);\n    }\n", "refactored_code": "    private static final int NUMBER_OF_SHARDS = 1;\n    public static IndexMetadata.Builder createBackingIndex(String dataStreamName, int generation, long epochMillis) {\n        return IndexMetadata.builder(DataStream.getDefaultBackingIndexName(dataStreamName, generation, epochMillis))\n            .settings(SETTINGS)\n            .numberOfShards(NUMBER_OF_SHARDS)\n            .numberOfReplicas(NUMBER_OF_REPLICAS);\n    }\n"}
{"magic_number_smell": "    protected final BigArrays bigarrays = new BigArrays(null, new NoneCircuitBreakerService(), CircuitBreaker.REQUEST);\n\n    public void testGet() throws IOException {\n        int length = randomIntBetween(1, PageCacheRecycler.BYTE_PAGE_SIZE * 3);\n        BytesReference pbr = newBytesReference(length);\n\n        int sliceOffset = randomIntBetween(0, length / 2);", "refactored_code": "    protected static final int PAGE_SIZE = PageCacheRecycler.BYTE_PAGE_SIZE;\n    protected final BigArrays bigarrays = new BigArrays(null, new NoneCircuitBreakerService(), CircuitBreaker.REQUEST);\n\n    public void testGet() throws IOException {\n        int length = randomIntBetween(1, PAGE_SIZE * 3);\n        BytesReference pbr = newBytesReference(length);\n\n        int sliceOffset = randomIntBetween(0, length / 2);"}
{"magic_number_smell": "        assertNotNull(firstLine);\n\n        try (Stream<JsonLogLine> stream = JsonLogsStream.from(openReader(getLogFile()), getParser())) {\n            stream.limit(10).forEach(jsonLogLine -> {\n                assertThat(jsonLogLine.getDataset(), is(not(emptyOrNullString())));\n                assertThat(jsonLogLine.getTimestamp(), is(not(emptyOrNullString())));\n                assertThat(jsonLogLine.getLevel(), is(not(emptyOrNullString())));", "refactored_code": "    private static final int LINES_TO_CHECK = 10;\n        assertNotNull(firstLine);\n\n        try (Stream<JsonLogLine> stream = JsonLogsStream.from(openReader(getLogFile()), getParser())) {\n            stream.limit(LINES_TO_CHECK).forEach(jsonLogLine -> {\n                assertThat(jsonLogLine.getDataset(), is(not(emptyOrNullString())));\n                assertThat(jsonLogLine.getTimestamp(), is(not(emptyOrNullString())));\n                assertThat(jsonLogLine.getLevel(), is(not(emptyOrNullString())));"}
{"magic_number_smell": "    }\n\n    public static Polygon randomPolygon(boolean hasAlt) {\n        XYPolygon lucenePolygon = randomValueOtherThanMany(p -> area(p) <= 1e-10, XShapeTestUtil::nextPolygon);\n        if (lucenePolygon.numHoles() > 0) {\n            XYPolygon[] luceneHoles = lucenePolygon.getHoles();\n            List<LinearRing> holes = new ArrayList<>();", "refactored_code": "    public static final double MIN_VALID_AREA = 1e-10;\n    }\n\n    public static Polygon randomPolygon(boolean hasAlt) {\n        XYPolygon lucenePolygon = randomValueOtherThanMany(p -> area(p) <= MIN_VALID_AREA, XShapeTestUtil::nextPolygon);\n        if (lucenePolygon.numHoles() > 0) {\n            XYPolygon[] luceneHoles = lucenePolygon.getHoles();\n            List<LinearRing> holes = new ArrayList<>();"}
{"magic_number_smell": "            while (true) {\n                int gons = TestUtil.nextInt(random(), 4, 500);\n                try {\n                    return createRegularPolygon(nextDouble() * 0.001f, nextDouble() * 0.001f, nextRadius(), gons);\n                } catch (IllegalArgumentException iae) {\n                    // we tried to cross dateline or pole ... try again\n                }", "refactored_code": "    public static final float CENTER_SCALE_FACTOR = 0.001f;\n            while (true) {\n                int gons = TestUtil.nextInt(random(), 4, 500);\n                try {\n                    return createRegularPolygon(nextDouble() * CENTER_SCALE_FACTOR, nextDouble() * CENTER_SCALE_FACTOR, nextRadius(), gons);\n                } catch (IllegalArgumentException iae) {\n                    // we tried to cross dateline or pole ... try again\n                }"}
{"magic_number_smell": "    }\n\n    /**\n     * Create an {@link IngestDocument} with {@link #12345L} as the _version metadata, if _version is not already present.\n     */\n    public static IngestDocument withDefaultVersion(Map<String, Object> sourceAndMetadata) {\n        if (sourceAndMetadata.containsKey(VERSION) == false) {", "refactored_code": "    public static final long DEFAULT_VERSION = 12345L;\n    }\n\n    /**\n     * Create an {@link IngestDocument} with {@link #DEFAULT_VERSION} as the _version metadata, if _version is not already present.\n     */\n    public static IngestDocument withDefaultVersion(Map<String, Object> sourceAndMetadata) {\n        if (sourceAndMetadata.containsKey(VERSION) == false) {"}
{"magic_number_smell": "    }\n\n    public static void tcpReadinessProbeTrue(ReadinessService readinessService) throws InterruptedException {\n        for (int i = 1; i <= 3; ++i) {\n            if (socketIsOpen(readinessService)) {\n                return;\n            }", "refactored_code": "    private static final int RETRIES = 3;\n    }\n\n    public static void tcpReadinessProbeTrue(ReadinessService readinessService) throws InterruptedException {\n        for (int i = 1; i <= RETRIES; ++i) {\n            if (socketIsOpen(readinessService)) {\n                return;\n            }"}
{"magic_number_smell": "\n    public void testReadNonexistentBlobThrowsNoSuchFileException() {\n        final BlobContainer blobContainer = createBlobContainer(between(1, 5), null, null, null);\n        final long position = randomLongBetween(0, Long.MAX_VALUE - 1);\n        final int length = randomIntBetween(1, Math.toIntExact(Math.min(Integer.MAX_VALUE, Long.MAX_VALUE - 1 - position)));\n        final Exception exception = expectThrows(NoSuchFileException.class, () -> {\n            if (randomBoolean()) {", "refactored_code": "    private static final long MAX_RANGE_VAL = Long.MAX_VALUE - 1;\n\n    public void testReadNonexistentBlobThrowsNoSuchFileException() {\n        final BlobContainer blobContainer = createBlobContainer(between(1, 5), null, null, null);\n        final long position = randomLongBetween(0, MAX_RANGE_VAL);\n        final int length = randomIntBetween(1, Math.toIntExact(Math.min(Integer.MAX_VALUE, MAX_RANGE_VAL - position)));\n        final Exception exception = expectThrows(NoSuchFileException.class, () -> {\n            if (randomBoolean()) {"}
{"magic_number_smell": "    public TransportVersion getMinimalSupportedVersion() {\n        // this is what causes the failure - it always reports a version in the future, so it is never compatible with\n        // current or minimum CCS TransportVersion\n        return new TransportVersion(TransportVersion.current().id() + 11_111);\n    }\n}\n", "refactored_code": "    public static final int FUTURE_VERSION = TransportVersion.current().id() + 11_111;\n    public TransportVersion getMinimalSupportedVersion() {\n        // this is what causes the failure - it always reports a version in the future, so it is never compatible with\n        // current or minimum CCS TransportVersion\n        return new TransportVersion(FUTURE_VERSION);\n    }\n}\n"}
{"magic_number_smell": "\n        public void invalidateCoordinate(GeoBoundingBoxQueryBuilder qb, boolean useBrokenDouble) {\n            if (useBrokenDouble) {\n                fillIn(randomFrom(brokenDoubles), qb);\n            } else {\n                fillIn(invalidCoordinate, qb);\n            }", "refactored_code": "        private final double brokenCoordinate = randomFrom(brokenDoubles);\n\n        public void invalidateCoordinate(GeoBoundingBoxQueryBuilder qb, boolean useBrokenDouble) {\n            if (useBrokenDouble) {\n                fillIn(brokenCoordinate, qb);\n            } else {\n                fillIn(invalidCoordinate, qb);\n            }"}
{"magic_number_smell": "    // Large snapshot pool settings to set up nodes for tests involving multiple repositories that need to have enough\n    // threads so that blocking some threads on one repository doesn't block other repositories from doing work\n    protected static final Settings LARGE_SNAPSHOT_POOL_SETTINGS = Settings.builder()\n        .put(\"thread_pool.snapshot.core\", 10)\n        .put(\"thread_pool.snapshot.max\", 10)\n        .build();\n", "refactored_code": "    protected static final int LARGE_POOL_SIZE = 10;\n    // Large snapshot pool settings to set up nodes for tests involving multiple repositories that need to have enough\n    // threads so that blocking some threads on one repository doesn't block other repositories from doing work\n    protected static final Settings LARGE_SNAPSHOT_POOL_SETTINGS = Settings.builder()\n        .put(\"thread_pool.snapshot.core\", LARGE_POOL_SIZE)\n        .put(\"thread_pool.snapshot.max\", LARGE_POOL_SIZE)\n        .build();\n"}
{"magic_number_smell": "     * and asserts equality on the two queries.\n     */\n    public void testFromXContent() throws IOException {\n        for (int runs = 0; runs < 20; runs++) {\n            QB testQuery = createTestQueryBuilder();\n            XContentType xContentType = randomFrom(XContentType.values());\n            BytesReference shuffledXContent = toShuffledXContent(", "refactored_code": "    private static final int NUMBER_OF_TESTQUERIES = 20;\n     * and asserts equality on the two queries.\n     */\n    public void testFromXContent() throws IOException {\n        for (int runs = 0; runs < NUMBER_OF_TESTQUERIES; runs++) {\n            QB testQuery = createTestQueryBuilder();\n            XContentType xContentType = randomFrom(XContentType.values());\n            BytesReference shuffledXContent = toShuffledXContent("}
{"magic_number_smell": "     * versions of the instance are equal.\n     */\n    public final void testEqualsAndHashcode() {\n        for (int runs = 0; runs < 20; runs++) {\n            T testInstance = createTestInstance();\n            try {\n                EqualsHashCodeTestUtils.checkEqualsAndHashCode(testInstance, this::copyInstance, this::mutateInstance, this::dispose);", "refactored_code": "    protected static final int NUMBER_OF_TEST_RUNS = 20;\n     * versions of the instance are equal.\n     */\n    public final void testEqualsAndHashcode() {\n        for (int runs = 0; runs < NUMBER_OF_TEST_RUNS; runs++) {\n            T testInstance = createTestInstance();\n            try {\n                EqualsHashCodeTestUtils.checkEqualsAndHashCode(testInstance, this::copyInstance, this::mutateInstance, this::dispose);"}
{"magic_number_smell": "        private final CheckedBiFunction<T, XContentType, BytesReference, IOException> toXContent;\n        private final CheckedFunction<XContentParser, T, IOException> fromXContent;\n\n        private int numberOfTestRuns = 20;\n        private boolean supportsUnknownFields = false;\n        private String[] shuffleFieldsExceptions = Strings.EMPTY_ARRAY;\n        private Predicate<String> randomFieldsExcludeFilter = field -> false;", "refactored_code": "    public static final int NUMBER_OF_TEST_RUNS = 20;\n        private final CheckedBiFunction<T, XContentType, BytesReference, IOException> toXContent;\n        private final CheckedFunction<XContentParser, T, IOException> fromXContent;\n\n        private int numberOfTestRuns = NUMBER_OF_TEST_RUNS;\n        private boolean supportsUnknownFields = false;\n        private String[] shuffleFieldsExceptions = Strings.EMPTY_ARRAY;\n        private Predicate<String> randomFieldsExcludeFilter = field -> false;"}
{"magic_number_smell": "    ) throws IOException {\n        T remoteInstance = testInstance.get();\n        T localInstance = assertSerialization(remoteInstance, namedWriteableRegistry, reader);\n        for (int runs = 0; runs < NUMBER_OF_TEST_RUNS; runs++) {\n            T remoteChanges = modifier.apply(remoteInstance);\n            Diff<T> remoteDiffs = remoteChanges.diff(remoteInstance);\n            Diff<T> localDiffs = copyInstance(remoteDiffs, namedWriteableRegistry, diffReader);", "refactored_code": "    protected static final int NUMBER_OF_DIFF_TEST_RUNS = NUMBER_OF_TEST_RUNS;\n    ) throws IOException {\n        T remoteInstance = testInstance.get();\n        T localInstance = assertSerialization(remoteInstance, namedWriteableRegistry, reader);\n        for (int runs = 0; runs < NUMBER_OF_DIFF_TEST_RUNS; runs++) {\n            T remoteChanges = modifier.apply(remoteInstance);\n            Diff<T> remoteDiffs = remoteChanges.diff(remoteInstance);\n            Diff<T> localDiffs = copyInstance(remoteDiffs, namedWriteableRegistry, diffReader);"}
{"magic_number_smell": "        List<CountDownLatch> inFlightAsyncOperations = new ArrayList<>();\n        // If you are indexing just a few documents then frequently do it one at a time. If many then frequently in bulk.\n        final String[] indicesArray = indices.toArray(new String[] {});\n        if (builders.size() < 300 ? frequently() : builders.size() < ALWAYS_BULK_THRESHOLD ? rarely() : false) {\n            if (frequently()) {\n                logger.info(\"Index [{}] docs async: [{}] bulk: [{}]\", builders.size(), true, false);\n                for (IndexRequestBuilder indexRequestBuilder : builders) {", "refactored_code": "    private static final int FREQUENT_BULK_THRESHOLD = 300;\n        List<CountDownLatch> inFlightAsyncOperations = new ArrayList<>();\n        // If you are indexing just a few documents then frequently do it one at a time. If many then frequently in bulk.\n        final String[] indicesArray = indices.toArray(new String[] {});\n        if (builders.size() < FREQUENT_BULK_THRESHOLD ? frequently() : builders.size() < ALWAYS_BULK_THRESHOLD ? rarely() : false) {\n            if (frequently()) {\n                logger.info(\"Index [{}] docs async: [{}] bulk: [{}]\", builders.size(), true, false);\n                for (IndexRequestBuilder indexRequestBuilder : builders) {"}
{"magic_number_smell": "            }\n            Thread.sleep(timeInMillis);\n            sum += timeInMillis;\n            timeInMillis = Math.min(1000L, timeInMillis * 2);\n        }\n        timeInMillis = maxTimeInMillis - sum;\n        Thread.sleep(Math.max(timeInMillis, 0));", "refactored_code": "    private static final long AWAIT_BUSY_THRESHOLD = 1000L;\n            }\n            Thread.sleep(timeInMillis);\n            sum += timeInMillis;\n            timeInMillis = Math.min(AWAIT_BUSY_THRESHOLD, timeInMillis * 2);\n        }\n        timeInMillis = maxTimeInMillis - sum;\n        Thread.sleep(Math.max(timeInMillis, 0));"}
{"magic_number_smell": "            toReduce.add(reduced);\n        }\n        MultiBucketConsumer bucketConsumer = new MultiBucketConsumer(\n            100000,\n            new NoneCircuitBreakerService().getBreaker(CircuitBreaker.REQUEST)\n        );\n        AggregationReduceContext context = new AggregationReduceContext.ForFinal(", "refactored_code": "    public static final int DEFAULT_MAX_BUCKETS = 100000;\n            toReduce.add(reduced);\n        }\n        MultiBucketConsumer bucketConsumer = new MultiBucketConsumer(\n            DEFAULT_MAX_BUCKETS,\n            new NoneCircuitBreakerService().getBreaker(CircuitBreaker.REQUEST)\n        );\n        AggregationReduceContext context = new AggregationReduceContext.ForFinal("}
{"magic_number_smell": "    private static final int 10 = 10;\n\n    private Supplier<InternalAggregations> subAggregationsSupplier;\n    private int maxNumberOfBuckets = 10;\n\n    protected int randomNumberOfBuckets() {\n        return randomIntBetween(minNumberOfBuckets(), maxNumberOfBuckets());", "refactored_code": "    private static final int DEFAULT_MAX_NUMBER_OF_BUCKETS = 10;\n    private static final int DEFAULT_MAX_NUMBER_OF_BUCKETS = 10;\n\n    private Supplier<InternalAggregations> subAggregationsSupplier;\n    private int maxNumberOfBuckets = DEFAULT_MAX_NUMBER_OF_BUCKETS;\n\n    protected int randomNumberOfBuckets() {\n        return randomIntBetween(minNumberOfBuckets(), maxNumberOfBuckets());"}
{"magic_number_smell": "            if (useDedicatedMasterNodes) {\n                if (random.nextBoolean()) {\n                    // use a dedicated master, but only low number to reduce overhead to tests\n                    this.numSharedDedicatedMasterNodes = 1;\n                } else {\n                    this.numSharedDedicatedMasterNodes = DEFAULT_HIGH_NUM_MASTER_NODES;\n                }", "refactored_code": "    public static final int DEFAULT_LOW_NUM_MASTER_NODES = 1;\n            if (useDedicatedMasterNodes) {\n                if (random.nextBoolean()) {\n                    // use a dedicated master, but only low number to reduce overhead to tests\n                    this.numSharedDedicatedMasterNodes = DEFAULT_LOW_NUM_MASTER_NODES;\n                } else {\n                    this.numSharedDedicatedMasterNodes = DEFAULT_HIGH_NUM_MASTER_NODES;\n                }"}
{"magic_number_smell": "    static int maxKeyWidthForMatcher(Object item, Matcher<?> matcher) {\n        if (matcher instanceof MapMatcher) {\n            Map<?, ?> longestSubMap = item instanceof Map ? (Map<?, ?>) item : emptyMap();\n            return ((MapMatcher) matcher).keyWidth(longestSubMap) - 2;\n        }\n        if (matcher instanceof ListMatcher) {\n            List<?> longestSubList = item instanceof List ? (List<?>) item : emptyList();", "refactored_code": "    private static final int INDENT = 2;\n    static int maxKeyWidthForMatcher(Object item, Matcher<?> matcher) {\n        if (matcher instanceof MapMatcher) {\n            Map<?, ?> longestSubMap = item instanceof Map ? (Map<?, ?>) item : emptyMap();\n            return ((MapMatcher) matcher).keyWidth(longestSubMap) - INDENT;\n        }\n        if (matcher instanceof ListMatcher) {\n            List<?> longestSubList = item instanceof List ? (List<?>) item : emptyList();"}
{"magic_number_smell": "                    if (times > MAX_RETRY_DELETE_TIMES) {\n                        throw new IOException(\"File still exists after \" + times + \" waits.\");\n                    }\n                    Thread.sleep(OS.current() == OS.WINDOWS ? 500 : 0);\n                    // retry\n                    recursiveDelete(path);\n                    times++;", "refactored_code": "    private static final int RETRY_DELETE_MILLIS = OS.current() == OS.WINDOWS ? 500 : 0;\n                    if (times > MAX_RETRY_DELETE_TIMES) {\n                        throw new IOException(\"File still exists after \" + times + \" waits.\");\n                    }\n                    Thread.sleep(RETRY_DELETE_MILLIS);\n                    // retry\n                    recursiveDelete(path);\n                    times++;"}
{"magic_number_smell": "        assertTrue(\"schema lacks at least 1 required field\", jsonSchema.hasRequiredValidator());\n        assertSchemaStrictness(jsonSchema.getValidators().values(), jsonSchema.getSchemaPath());\n\n        for (int runs = 0; runs < 20; runs++) {\n            BytesReference xContent = XContentHelper.toXContent(createTestInstance(), XContentType.JSON, getToXContentParams(), false);\n            JsonNode jsonTree = mapper.readTree(xContent.streamInput());\n", "refactored_code": "    protected static final int NUMBER_OF_TEST_RUNS = 20;\n        assertTrue(\"schema lacks at least 1 required field\", jsonSchema.hasRequiredValidator());\n        assertSchemaStrictness(jsonSchema.getValidators().values(), jsonSchema.getSchemaPath());\n\n        for (int runs = 0; runs < NUMBER_OF_TEST_RUNS; runs++) {\n            BytesReference xContent = XContentHelper.toXContent(createTestInstance(), XContentType.JSON, getToXContentParams(), false);\n            JsonNode jsonTree = mapper.readTree(xContent.streamInput());\n"}
{"magic_number_smell": "        } catch (InvalidKeyException | IOException | NoSuchAlgorithmException | SignatureException e) {\n            throw new IllegalStateException(e);\n        }\n        final byte[] magic = new byte[13];\n        SecureRandom random = new SecureRandom();\n        random.nextBytes(magic);\n        final byte[] publicKeyBytes = Files.readAllBytes(publicKeyPath);", "refactored_code": "    private static final int MAGIC_LENGTH = 13;\n        } catch (InvalidKeyException | IOException | NoSuchAlgorithmException | SignatureException e) {\n            throw new IllegalStateException(e);\n        }\n        final byte[] magic = new byte[MAGIC_LENGTH];\n        SecureRandom random = new SecureRandom();\n        random.nextBytes(magic);\n        final byte[] publicKeyBytes = Files.readAllBytes(publicKeyPath);"}
{"magic_number_smell": "        double q3 = state.quantile(0.75);\n        double q1 = state.quantile(0.25);\n        double iqr = q3 - q1;\n        double upper = q3 + (1.5 * iqr);\n        double lower = q1 - (1.5 * iqr);\n        Centroid prev = null;\n        // Does this iterate in ascending order? if not, we might need to sort...", "refactored_code": "    public static final double IQR_MULTIPLIER = 1.5;\n        double q3 = state.quantile(0.75);\n        double q1 = state.quantile(0.25);\n        double iqr = q3 - q1;\n        double upper = q3 + (IQR_MULTIPLIER * iqr);\n        double lower = q1 - (IQR_MULTIPLIER * iqr);\n        Centroid prev = null;\n        // Does this iterate in ascending order? if not, we might need to sort..."}
{"magic_number_smell": "    @Override\n    public double value() {\n        long rateUnitSeconds = rateUnit.getField().getBaseUnit().getDuration().toSeconds();\n        return (endValue - startValue + resetCompensation) / (endTime - startTime) * 1_000 * rateUnitSeconds;\n    }\n\n    @Override", "refactored_code": "    private static final int MILLIS_IN_SECOND = 1_000;\n    @Override\n    public double value() {\n        long rateUnitSeconds = rateUnit.getField().getBaseUnit().getDuration().toSeconds();\n        return (endValue - startValue + resetCompensation) / (endTime - startTime) * MILLIS_IN_SECOND * rateUnitSeconds;\n    }\n\n    @Override"}
{"magic_number_smell": "        (args, name) -> {\n            @SuppressWarnings(\"unchecked\")\n            List<SortBuilder<?>> sorts = (List<SortBuilder<?>>) args[0];\n            int size = args[1] == null ? 1 : (Integer) args[1];\n            if (size < 1) {\n                throw new IllegalArgumentException(\"[size] must be more than 0 but was [\" + size + \"]\");\n            }", "refactored_code": "    private static final int DEFAULT_SIZE = 1;\n        (args, name) -> {\n            @SuppressWarnings(\"unchecked\")\n            List<SortBuilder<?>> sorts = (List<SortBuilder<?>>) args[0];\n            int size = args[1] == null ? DEFAULT_SIZE : (Integer) args[1];\n            if (size < 1) {\n                throw new IllegalArgumentException(\"[size] must be more than 0 but was [\" + size + \"]\");\n            }"}
{"magic_number_smell": "    private static final double MIN = -10;\n    private static final double MAX = 50;\n    private static final double SUM = 72;\n    private static final double MEAN = SUM / 10;\n\n    public void testRescaleZeroToOne() {\n        NormalizePipelineMethods.RescaleZeroToOne normalizer = new NormalizePipelineMethods.RescaleZeroToOne(DATA);", "refactored_code": "    private static final int COUNT = 10;\n    private static final double MIN = -10;\n    private static final double MAX = 50;\n    private static final double SUM = 72;\n    private static final double MEAN = SUM / COUNT;\n\n    public void testRescaleZeroToOne() {\n        NormalizePipelineMethods.RescaleZeroToOne normalizer = new NormalizePipelineMethods.RescaleZeroToOne(DATA);"}
{"magic_number_smell": "\n    private static final int 1_000 = 1_000;\n    private static final int SECONDS_IN_MINUTE = 60;\n    private static final int MILLIS_IN_MINUTE = 1_000 * SECONDS_IN_MINUTE;\n    private static final int MINUTES_IN_HOUR = 60;\n    private static final int MILLIS_IN_HOUR = 1_000 * SECONDS_IN_MINUTE * MINUTES_IN_HOUR;\n    private static final int HOURS_IN_DAY = 24;", "refactored_code": "    private static final int MILLIS_IN_SECOND = 1_000;\n\n    private static final int MILLIS_IN_SECOND = 1_000;\n    private static final int SECONDS_IN_MINUTE = 60;\n    private static final int MILLIS_IN_MINUTE = MILLIS_IN_SECOND * SECONDS_IN_MINUTE;\n    private static final int MINUTES_IN_HOUR = 60;\n    private static final int MILLIS_IN_HOUR = MILLIS_IN_SECOND * SECONDS_IN_MINUTE * MINUTES_IN_HOUR;\n    private static final int HOURS_IN_DAY = 24;"}
{"magic_number_smell": "            assertThat(r.getBuckets(), hasSize(2));\n            assertThat(\n                ((Rate) r.getBucketByKey(\"{dim=1}\").getAggregations().asList().get(0)).getValue(),\n                closeTo(59.0 / 3000.0 * 1_000, 0.00001)\n            );\n            assertThat(\n                ((Rate) r.getBucketByKey(\"{dim=2}\").getAggregations().asList().get(0)).getValue(),", "refactored_code": "    private static final int MILLIS_IN_SECOND = 1_000;\n            assertThat(r.getBuckets(), hasSize(2));\n            assertThat(\n                ((Rate) r.getBucketByKey(\"{dim=1}\").getAggregations().asList().get(0)).getValue(),\n                closeTo(59.0 / 3000.0 * MILLIS_IN_SECOND, 0.00001)\n            );\n            assertThat(\n                ((Rate) r.getBucketByKey(\"{dim=2}\").getAggregations().asList().get(0)).getValue(),"}
{"magic_number_smell": "    private int indexDocs(Client client, String index) {\n        int numDocs = between(500, 1200);\n        for (int i = 0; i < numDocs; i++) {\n            long ts = 1691348810000L + i;\n            if (i == numDocs - 1) {\n                ts = LATEST_TIMESTAMP;\n            }", "refactored_code": "    private static final long EARLIEST_TIMESTAMP = 1691348810000L;\n    private int indexDocs(Client client, String index) {\n        int numDocs = between(500, 1200);\n        for (int i = 0; i < numDocs; i++) {\n            long ts = EARLIEST_TIMESTAMP + i;\n            if (i == numDocs - 1) {\n                ts = LATEST_TIMESTAMP;\n            }"}
{"magic_number_smell": "\npublic abstract class AutoscalingStorageIntegTestCase extends DiskUsageIntegTestCase {\n    protected static final long 10240 = 10240;\n    protected static final long LOW_WATERMARK_BYTES = 2 * 10240;\n\n    @Override\n    protected Collection<Class<? extends Plugin>> nodePlugins() {", "refactored_code": "    protected static final long HIGH_WATERMARK_BYTES = 10240;\n\npublic abstract class AutoscalingStorageIntegTestCase extends DiskUsageIntegTestCase {\n    protected static final long HIGH_WATERMARK_BYTES = 10240;\n    protected static final long LOW_WATERMARK_BYTES = 2 * HIGH_WATERMARK_BYTES;\n\n    @Override\n    protected Collection<Class<? extends Plugin>> nodePlugins() {"}
{"magic_number_smell": "    @Before\n    public void setup() {\n        ClusterState clusterState = ClusterState.builder(new ClusterName(\"test\")).build();\n        clusterState = addRandomIndices(randomIntBetween(1, 8), randomIntBetween(1, 8), clusterState);\n        clusterState = addDataNodes(DATA_HOT_NODE_ROLE, \"hot\", clusterState, randomIntBetween(1, 8));\n        clusterState = addDataNodes(DATA_WARM_NODE_ROLE, \"warm\", clusterState, warmNodes);\n        this.state = clusterState;", "refactored_code": "    private final int hotNodes = randomIntBetween(1, 8);\n    @Before\n    public void setup() {\n        ClusterState clusterState = ClusterState.builder(new ClusterName(\"test\")).build();\n        clusterState = addRandomIndices(hotNodes, hotNodes, clusterState);\n        clusterState = addDataNodes(DATA_HOT_NODE_ROLE, \"hot\", clusterState, hotNodes);\n        clusterState = addDataNodes(DATA_WARM_NODE_ROLE, \"warm\", clusterState, warmNodes);\n        this.state = clusterState;"}
{"magic_number_smell": "            case FLUSH:\n            case READ:\n            default:\n                return 1024;\n        }\n    }\n}", "refactored_code": "    public static final int BUFFER_SIZE = 1024;\n            case FLUSH:\n            case READ:\n            default:\n                return BUFFER_SIZE;\n        }\n    }\n}"}
{"magic_number_smell": "        this.recentAutoFollowErrors = new LinkedHashMap<>() {\n            @Override\n            protected boolean removeEldestEntry(final Map.Entry<AutoFollowErrorKey, Tuple<Long, ElasticsearchException>> eldest) {\n                return size() > 256;\n            }\n        };\n", "refactored_code": "    private static final int MAX_AUTO_FOLLOW_ERRORS = 256;\n        this.recentAutoFollowErrors = new LinkedHashMap<>() {\n            @Override\n            protected boolean removeEldestEntry(final Map.Entry<AutoFollowErrorKey, Tuple<Long, ElasticsearchException>> eldest) {\n                return size() > MAX_AUTO_FOLLOW_ERRORS;\n            }\n        };\n"}
{"magic_number_smell": "        long n = Math.round(Math.pow(2, maxCurrentRetry - 1));\n        // + 1 here, because nextInt(...) bound is exclusive and otherwise the first delay would always be zero.\n        int k = Randomness.get().nextInt(Math.toIntExact(n + 1));\n        int backOffDelay = k * 50;\n        return Math.min(backOffDelay, maxRetryDelayInMillis);\n    }\n", "refactored_code": "    private static final int DELAY_MILLIS = 50;\n        long n = Math.round(Math.pow(2, maxCurrentRetry - 1));\n        // + 1 here, because nextInt(...) bound is exclusive and otherwise the first delay would always be zero.\n        int k = Randomness.get().nextInt(Math.toIntExact(n + 1));\n        int backOffDelay = k * DELAY_MILLIS;\n        return Math.min(backOffDelay, maxRetryDelayInMillis);\n    }\n"}
{"magic_number_smell": "        if (parameters.getMaxOutstandingWriteRequests() != null) {\n            maxOutstandingWriteRequests = parameters.getMaxOutstandingWriteRequests();\n        } else {\n            maxOutstandingWriteRequests = 9;\n        }\n\n        int maxWriteBufferCount;", "refactored_code": "    private static final int DEFAULT_MAX_OUTSTANDING_WRITE_REQUESTS = 9;\n        if (parameters.getMaxOutstandingWriteRequests() != null) {\n            maxOutstandingWriteRequests = parameters.getMaxOutstandingWriteRequests();\n        } else {\n            maxOutstandingWriteRequests = DEFAULT_MAX_OUTSTANDING_WRITE_REQUESTS;\n        }\n\n        int maxWriteBufferCount;"}
{"magic_number_smell": "\n    private static SecretKey deriveSecretKey(char[] passPhrase) {\n        try {\n            PBEKeySpec keySpec = new PBEKeySpec(passPhrase, SALT, 10000, ENCRYPTION_KEY_LENGTH);\n\n            SecretKey secretKey = SecretKeyFactory.getInstance(KDF_ALGORITHM).generateSecret(keySpec);\n            return new SecretKeySpec(secretKey.getEncoded(), CIPHER_ALGORITHM);", "refactored_code": "    private static final int KDF_ITERATION_COUNT = 10000;\n\n    private static SecretKey deriveSecretKey(char[] passPhrase) {\n        try {\n            PBEKeySpec keySpec = new PBEKeySpec(passPhrase, SALT, KDF_ITERATION_COUNT, ENCRYPTION_KEY_LENGTH);\n\n            SecretKey secretKey = SecretKeyFactory.getInstance(KDF_ALGORITHM).generateSecret(keySpec);\n            return new SecretKeySpec(secretKey.getEncoded(), CIPHER_ALGORITHM);"}
{"magic_number_smell": "            throw new IllegalStateException(\"issueDate has to be set\");\n        } else if (type == null) {\n            throw new IllegalStateException(\"type can not be null\");\n        } else if (subscriptionType == null && version == 1) {\n            throw new IllegalStateException(\"subscriptionType can not be null\");\n        } else if (uid == null) {\n            throw new IllegalStateException(\"uid can not be null\");", "refactored_code": "    public static final int VERSION_START = 1;\n            throw new IllegalStateException(\"issueDate has to be set\");\n        } else if (type == null) {\n            throw new IllegalStateException(\"type can not be null\");\n        } else if (subscriptionType == null && version == VERSION_START) {\n            throw new IllegalStateException(\"subscriptionType can not be null\");\n        } else if (uid == null) {\n            throw new IllegalStateException(\"uid can not be null\");"}
{"magic_number_smell": "            }\n\n            builder.field(\"status\", status.label());\n            if (expiryDate != Long.MAX_VALUE - TimeUnit.HOURS.toMillis(24 * 365)) {\n                builder.timeField(\"expiry_date_in_millis\", \"expiry_date\", expiryDate);\n            }\n            return builder.endObject();", "refactored_code": "    public static final long BASIC_SELF_GENERATED_LICENSE_EXPIRATION_MILLIS = Long.MAX_VALUE - TimeUnit.HOURS.toMillis(24 * 365);\n            }\n\n            builder.field(\"status\", status.label());\n            if (expiryDate != BASIC_SELF_GENERATED_LICENSE_EXPIRATION_MILLIS) {\n                builder.timeField(\"expiry_date_in_millis\", \"expiry_date\", expiryDate);\n            }\n            return builder.endObject();"}
{"magic_number_smell": "    public static final int DEFAULT_SHARD_MIN_DOC_COUNT = 2;\n\n    private String fieldName;\n    private int size = 5;\n    private Map<String, TermBoost> includes;\n    private Set<String> excludes;\n    private int minDocCount = DEFAULT_MIN_DOC_COUNT;", "refactored_code": "    public static final int DEFAULT_SIZE = 5;\n    public static final int DEFAULT_SHARD_MIN_DOC_COUNT = 2;\n\n    private String fieldName;\n    private int size = DEFAULT_SIZE;\n    private Map<String, TermBoost> includes;\n    private Set<String> excludes;\n    private int minDocCount = DEFAULT_MIN_DOC_COUNT;"}
{"magic_number_smell": "\n    public static final ConstructingObjectParser<PageParams, Void> PARSER = new ConstructingObjectParser<>(\n        PAGE.getPreferredName(),\n        a -> new PageParams(a[0] == null ? 0 : (int) a[0], a[1] == null ? DEFAULT_SIZE : (int) a[1])\n    );\n\n    static {", "refactored_code": "    public static final int DEFAULT_FROM = 0;\n\n    public static final ConstructingObjectParser<PageParams, Void> PARSER = new ConstructingObjectParser<>(\n        PAGE.getPreferredName(),\n        a -> new PageParams(a[0] == null ? DEFAULT_FROM : (int) a[0], a[1] == null ? DEFAULT_SIZE : (int) a[1])\n    );\n\n    static {"}
{"magic_number_smell": "                .startObject(SINGLE_MAPPING_NAME)\n                .startObject(\"_meta\")\n                .field(\"version\", Version.CURRENT)\n                .field(SystemIndexDescriptor.VERSION_META_KEY, 0)\n                .endObject()\n                .field(\"dynamic\", \"strict\")\n                .startObject(\"properties\")", "refactored_code": "    private static final int ASYNC_TASK_INDEX_MAPPINGS_VERSION = 0;\n                .startObject(SINGLE_MAPPING_NAME)\n                .startObject(\"_meta\")\n                .field(\"version\", Version.CURRENT)\n                .field(SystemIndexDescriptor.VERSION_META_KEY, ASYNC_TASK_INDEX_MAPPINGS_VERSION)\n                .endObject()\n                .field(\"dynamic\", \"strict\")\n                .startObject(\"properties\")"}
{"magic_number_smell": "                    validationException = addValidationError(\"[name] name must not start with '_'\", validationException);\n                }\n                int byteCount = name.getBytes(StandardCharsets.UTF_8).length;\n                if (byteCount > 255) {\n                    validationException = addValidationError(\n                        \"[name] name is too long (\" + byteCount + \" > \" + 255 + \")\",\n                        validationException", "refactored_code": "    private static final int MAX_NAME_BYTES = 255;\n                    validationException = addValidationError(\"[name] name must not start with '_'\", validationException);\n                }\n                int byteCount = name.getBytes(StandardCharsets.UTF_8).length;\n                if (byteCount > MAX_NAME_BYTES) {\n                    validationException = addValidationError(\n                        \"[name] name is too long (\" + byteCount + \" > \" + MAX_NAME_BYTES + \")\",\n                        validationException"}
{"magic_number_smell": "            builder.field(resourceField.get(), resourceId);\n        }\n\n        if (message.length() > 8191) {\n            assert message.length() > 8191 : \"Audit message is unexpectedly large\";\n            builder.field(MESSAGE.getPreferredName(), truncateMessage(message, 8191));\n        } else {", "refactored_code": "    public static final int MAX_AUDIT_MESSAGE_CHARS = 8191;\n            builder.field(resourceField.get(), resourceId);\n        }\n\n        if (message.length() > MAX_AUDIT_MESSAGE_CHARS) {\n            assert message.length() > MAX_AUDIT_MESSAGE_CHARS : \"Audit message is unexpectedly large\";\n            builder.field(MESSAGE.getPreferredName(), truncateMessage(message, MAX_AUDIT_MESSAGE_CHARS));\n        } else {"}
{"magic_number_smell": "        }\n        int byteCount = 0;\n        byteCount = policy.getBytes(StandardCharsets.UTF_8).length;\n        if (byteCount > 255) {\n            throw new IllegalArgumentException(\n                \"invalid policy name [\" + policy + \"]: name is too long, (\" + byteCount + \" > \" + 255 + \")\"\n            );", "refactored_code": "    private static final int MAX_INDEX_NAME_BYTES = 255;\n        }\n        int byteCount = 0;\n        byteCount = policy.getBytes(StandardCharsets.UTF_8).length;\n        if (byteCount > MAX_INDEX_NAME_BYTES) {\n            throw new IllegalArgumentException(\n                \"invalid policy name [\" + policy + \"]: name is too long, (\" + byteCount + \" > \" + MAX_INDEX_NAME_BYTES + \")\"\n            );"}
{"magic_number_smell": "        long currentMaxPrimaryShardDocs = conditions.getMaxPrimaryShardDocs() != null\n            ? conditions.getMaxPrimaryShardDocs()\n            : Long.MAX_VALUE;\n        builder.addMaxPrimaryShardDocsCondition(Math.min(currentMaxPrimaryShardDocs, 200_000_000L));\n        return builder.build();\n    }\n", "refactored_code": "    public static final long MAX_PRIMARY_SHARD_DOCS = 200_000_000L;\n        long currentMaxPrimaryShardDocs = conditions.getMaxPrimaryShardDocs() != null\n            ? conditions.getMaxPrimaryShardDocs()\n            : Long.MAX_VALUE;\n        builder.addMaxPrimaryShardDocsCondition(Math.min(currentMaxPrimaryShardDocs, MAX_PRIMARY_SHARD_DOCS));\n        return builder.build();\n    }\n"}
{"magic_number_smell": "        return Settings.builder()\n            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n            .put(IndexMetadata.SETTING_AUTO_EXPAND_REPLICAS, \"0-1\")\n            .put(IndexSettings.MAX_RESULT_WINDOW_SETTING.getKey(), 10_000)\n            .build();\n    }\n", "refactored_code": "    public static final int CONFIG_INDEX_MAX_RESULTS_WINDOW = 10_000;\n        return Settings.builder()\n            .put(IndexMetadata.SETTING_NUMBER_OF_SHARDS, 1)\n            .put(IndexMetadata.SETTING_AUTO_EXPAND_REPLICAS, \"0-1\")\n            .put(IndexSettings.MAX_RESULT_WINDOW_SETTING.getKey(), CONFIG_INDEX_MAX_RESULTS_WINDOW)\n            .build();\n    }\n"}
{"magic_number_smell": "            \"/ml/meta_index_mappings.json\",\n            MlIndexAndAlias.BWC_MAPPINGS_VERSION, // Only needed for BWC with pre-8.10.0 nodes\n            MAPPINGS_VERSION_VARIABLE,\n            Map.of(\"xpack.ml.managed.index.version\", Integer.toString(1))\n        );\n    }\n", "refactored_code": "    private static final int META_INDEX_MAPPINGS_VERSION = 1;\n            \"/ml/meta_index_mappings.json\",\n            MlIndexAndAlias.BWC_MAPPINGS_VERSION, // Only needed for BWC with pre-8.10.0 nodes\n            MAPPINGS_VERSION_VARIABLE,\n            Map.of(\"xpack.ml.managed.index.version\", Integer.toString(META_INDEX_MAPPINGS_VERSION))\n        );\n    }\n"}
{"magic_number_smell": "            \"/ml/stats_index_mappings.json\",\n            MlIndexAndAlias.BWC_MAPPINGS_VERSION, // Only needed for BWC with pre-8.10.0 nodes\n            MAPPINGS_VERSION_VARIABLE,\n            Map.of(\"xpack.ml.managed.index.version\", Integer.toString(1))\n        );\n    }\n", "refactored_code": "    public static final int STATS_INDEX_MAPPINGS_VERSION = 1;\n            \"/ml/stats_index_mappings.json\",\n            MlIndexAndAlias.BWC_MAPPINGS_VERSION, // Only needed for BWC with pre-8.10.0 nodes\n            MAPPINGS_VERSION_VARIABLE,\n            Map.of(\"xpack.ml.managed.index.version\", Integer.toString(STATS_INDEX_MAPPINGS_VERSION))\n        );\n    }\n"}
{"magic_number_smell": "        }\n\n        public void setMaxModelMemory(long numBytes) {\n            if (numBytes < ByteSizeValue.ofMb(1).getBytes()) {\n                throw new IllegalArgumentException(\"[\" + MAX_MODEL_MEMORY.getPreferredName() + \"] must be at least 1mb.\");\n            }\n            if (numBytes >= FORECAST_LOCAL_STORAGE_LIMIT.getBytes()) {", "refactored_code": "        private static final long MIN_MODEL_MEMORY = ByteSizeValue.ofMb(1).getBytes();\n        }\n\n        public void setMaxModelMemory(long numBytes) {\n            if (numBytes < MIN_MODEL_MEMORY) {\n                throw new IllegalArgumentException(\"[\" + MAX_MODEL_MEMORY.getPreferredName() + \"] must be at least 1mb.\");\n            }\n            if (numBytes >= FORECAST_LOCAL_STORAGE_LIMIT.getBytes()) {"}
{"magic_number_smell": "            if (totalParts <= 0) {\n                validationException = addValidationError(\"[total_parts] must be greater than 0\", validationException);\n            }\n            if (totalParts > 10_000) {\n                validationException = addValidationError(\n                    \"[total_parts] must be less than or equal to \" + 10_000,\n                    validationException", "refactored_code": "    public static final int MAX_NUM_NATIVE_DEFINITION_PARTS = 10_000;\n            if (totalParts <= 0) {\n                validationException = addValidationError(\"[total_parts] must be greater than 0\", validationException);\n            }\n            if (totalParts > MAX_NUM_NATIVE_DEFINITION_PARTS) {\n                validationException = addValidationError(\n                    \"[total_parts] must be less than or equal to \" + MAX_NUM_NATIVE_DEFINITION_PARTS,\n                    validationException"}
{"magic_number_smell": "            if (threadsPerAllocation < 1) {\n                validationException.addValidationError(\"[\" + THREADS_PER_ALLOCATION + \"] must be a positive integer\");\n            }\n            if (threadsPerAllocation > 32 || isPowerOf2(threadsPerAllocation) == false) {\n                validationException.addValidationError(\n                    \"[\" + THREADS_PER_ALLOCATION + \"] must be a power of 2 less than or equal to \" + 32\n                );", "refactored_code": "        private static final int MAX_THREADS_PER_ALLOCATION = 32;\n            if (threadsPerAllocation < 1) {\n                validationException.addValidationError(\"[\" + THREADS_PER_ALLOCATION + \"] must be a positive integer\");\n            }\n            if (threadsPerAllocation > MAX_THREADS_PER_ALLOCATION || isPowerOf2(threadsPerAllocation) == false) {\n                validationException.addValidationError(\n                    \"[\" + THREADS_PER_ALLOCATION + \"] must be a power of 2 less than or equal to \" + MAX_THREADS_PER_ALLOCATION\n                );"}
{"magic_number_smell": "                state,\n                masterNodeTimeout,\n                delegate,\n                1\n            )\n        );\n", "refactored_code": "    public static final int ANNOTATION_INDEX_MAPPINGS_VERSION = 1;\n                state,\n                masterNodeTimeout,\n                delegate,\n                ANNOTATION_INDEX_MAPPINGS_VERSION\n            )\n        );\n"}
{"magic_number_smell": "        private QueryProvider queryProvider = QueryProvider.defaultQuery();\n        private AggProvider aggProvider;\n        private List<SearchSourceBuilder.ScriptField> scriptFields;\n        private Integer scrollSize = 1000;\n        private ChunkingConfig chunkingConfig;\n        private Map<String, String> headers = Collections.emptyMap();\n        private DelayedDataCheckConfig delayedDataCheckConfig = DelayedDataCheckConfig.defaultDelayedDataCheckConfig();", "refactored_code": "    public static final int DEFAULT_SCROLL_SIZE = 1000;\n        private QueryProvider queryProvider = QueryProvider.defaultQuery();\n        private AggProvider aggProvider;\n        private List<SearchSourceBuilder.ScriptField> scriptFields;\n        private Integer scrollSize = DEFAULT_SCROLL_SIZE;\n        private ChunkingConfig chunkingConfig;\n        private Map<String, String> headers = Collections.emptyMap();\n        private DelayedDataCheckConfig delayedDataCheckConfig = DelayedDataCheckConfig.defaultDelayedDataCheckConfig();"}
{"magic_number_smell": "    @Override\n    public List<FieldCardinalityConstraint> getFieldCardinalityConstraints() {\n        // This restriction is due to the fact that currently the C++ backend only supports binomial classification.\n        return Collections.singletonList(FieldCardinalityConstraint.between(dependentVariable, 2, 100));\n    }\n\n    @SuppressWarnings(\"unchecked\")", "refactored_code": "    public static final int MAX_DEPENDENT_VARIABLE_CARDINALITY = 100;\n    @Override\n    public List<FieldCardinalityConstraint> getFieldCardinalityConstraints() {\n        // This restriction is due to the fact that currently the C++ backend only supports binomial classification.\n        return Collections.singletonList(FieldCardinalityConstraint.between(dependentVariable, 2, MAX_DEPENDENT_VARIABLE_CARDINALITY));\n    }\n\n    @SuppressWarnings(\"unchecked\")"}
{"magic_number_smell": "    private final SetOnce<Result> result = new SetOnce<>();\n\n    public Accuracy() {\n        this.matrix = new MulticlassConfusionMatrix(1000, NAME.getPreferredName() + \"_\");\n    }\n\n    public Accuracy(StreamInput in) throws IOException {", "refactored_code": "    private static final int MAX_CLASSES_CARDINALITY = 1000;\n    private final SetOnce<Result> result = new SetOnce<>();\n\n    public Accuracy() {\n        this.matrix = new MulticlassConfusionMatrix(MAX_CLASSES_CARDINALITY, NAME.getPreferredName() + \"_\");\n    }\n\n    public Accuracy(StreamInput in) throws IOException {"}
{"magic_number_smell": "        if (size != null && (size <= 0 || size > MAX_SIZE)) {\n            throw ExceptionsHelper.badRequestException(\"[{}] must be an integer in [1, {}]\", SIZE.getPreferredName(), MAX_SIZE);\n        }\n        this.size = size != null ? size : 10;\n        this.aggNamePrefix = aggNamePrefix != null ? aggNamePrefix : DEFAULT_AGG_NAME_PREFIX;\n    }\n", "refactored_code": "    private static final int DEFAULT_SIZE = 10;\n        if (size != null && (size <= 0 || size > MAX_SIZE)) {\n            throw ExceptionsHelper.badRequestException(\"[{}] must be an integer in [1, {}]\", SIZE.getPreferredName(), MAX_SIZE);\n        }\n        this.size = size != null ? size : DEFAULT_SIZE;\n        this.aggNamePrefix = aggNamePrefix != null ? aggNamePrefix : DEFAULT_AGG_NAME_PREFIX;\n    }\n"}
{"magic_number_smell": "                    AggregationBuilders.terms(ACTUAL_CLASSES_NAMES_AGG_NAME)\n                        .field(actualFieldName)\n                        .order(List.of(BucketOrder.count(false), BucketOrder.key(true)))\n                        .size(1000)\n                ),\n                List.of()\n            );", "refactored_code": "    private static final int MAX_CLASSES_CARDINALITY = 1000;\n                    AggregationBuilders.terms(ACTUAL_CLASSES_NAMES_AGG_NAME)\n                        .field(actualFieldName)\n                        .order(List.of(BucketOrder.count(false), BucketOrder.key(true)))\n                        .size(MAX_CLASSES_CARDINALITY)\n                ),\n                List.of()\n            );"}
{"magic_number_smell": "                AggregationBuilders.terms(BY_ACTUAL_CLASS_AGG_NAME)\n                    .field(actualFieldName)\n                    .order(List.of(BucketOrder.count(false), BucketOrder.key(true)))\n                    .size(1000)\n                    .subAggregation(AggregationBuilders.avg(PER_ACTUAL_CLASS_RECALL_AGG_NAME).script(script))\n            ),\n            List.of(", "refactored_code": "    private static final int MAX_CLASSES_CARDINALITY = 1000;\n                AggregationBuilders.terms(BY_ACTUAL_CLASS_AGG_NAME)\n                    .field(actualFieldName)\n                    .order(List.of(BucketOrder.count(false), BucketOrder.key(true)))\n                    .size(MAX_CLASSES_CARDINALITY)\n                    .subAggregation(AggregationBuilders.avg(PER_ACTUAL_CLASS_RECALL_AGG_NAME).script(script))\n            ),\n            List.of("}
{"magic_number_smell": "    }\n\n    public Huber() {\n        this(1.0);\n    }\n\n    public Huber(@Nullable Double delta) {", "refactored_code": "    private static final double DEFAULT_DELTA = 1.0;\n    }\n\n    public Huber() {\n        this(DEFAULT_DELTA);\n    }\n\n    public Huber(@Nullable Double delta) {"}
{"magic_number_smell": "    }\n\n    public MeanSquaredLogarithmicError(@Nullable Double offset) {\n        this.offset = offset != null ? offset : 1.0;\n    }\n\n    @Override", "refactored_code": "    private static final double DEFAULT_OFFSET = 1.0;\n    }\n\n    public MeanSquaredLogarithmicError(@Nullable Double offset) {\n        this.offset = offset != null ? offset : DEFAULT_OFFSET;\n    }\n\n    @Override"}
{"magic_number_smell": "                CircuitBreaker.Durability.PERMANENT\n            );\n        }\n        InputStream gzipStream = new GZIPInputStream(compressedBytes.streamInput(), 4096);\n        return new SimpleBoundedInputStream(gzipStream, streamSize);\n    }\n", "refactored_code": "    private static final int BUFFER_SIZE = 4096;\n                CircuitBreaker.Durability.PERMANENT\n            );\n        }\n        InputStream gzipStream = new GZIPInputStream(compressedBytes.streamInput(), BUFFER_SIZE);\n        return new SimpleBoundedInputStream(gzipStream, streamSize);\n    }\n"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        long size = RamUsageEstimator.shallowSizeOfInstance(TrainedModelDefinition.class);\n        size += RamUsageEstimator.sizeOf(trainedModel);\n        size += RamUsageEstimator.sizeOfCollection(preProcessors);\n        return size;", "refactored_code": "    private static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(TrainedModelDefinition.class);\n\n    @Override\n    public long ramBytesUsed() {\n        long size = SHALLOW_SIZE;\n        size += RamUsageEstimator.sizeOf(trainedModel);\n        size += RamUsageEstimator.sizeOfCollection(preProcessors);\n        return size;"}
{"magic_number_smell": "            \"/ml/inference_index_mappings.json\",\n            MlIndexAndAlias.BWC_MAPPINGS_VERSION, // Only needed for BWC with pre-8.10.0 nodes\n            MAPPINGS_VERSION_VARIABLE,\n            Map.of(\"xpack.ml.managed.index.version\", Integer.toString(3))\n        );\n    }\n", "refactored_code": "    public static final int INFERENCE_INDEX_MAPPINGS_VERSION = 3;\n            \"/ml/inference_index_mappings.json\",\n            MlIndexAndAlias.BWC_MAPPINGS_VERSION, // Only needed for BWC with pre-8.10.0 nodes\n            MAPPINGS_VERSION_VARIABLE,\n            Map.of(\"xpack.ml.managed.index.version\", Integer.toString(INFERENCE_INDEX_MAPPINGS_VERSION))\n        );\n    }\n"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        long size = RamUsageEstimator.shallowSizeOfInstance(CustomWordEmbedding.class);\n        for (byte[] bytes : embeddingsWeights) {\n            size += RamUsageEstimator.sizeOf(bytes);\n        }", "refactored_code": "    private static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(CustomWordEmbedding.class);\n\n    @Override\n    public long ramBytesUsed() {\n        long size = SHALLOW_SIZE;\n        for (byte[] bytes : embeddingsWeights) {\n            size += RamUsageEstimator.sizeOf(bytes);\n        }"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        long size = RamUsageEstimator.shallowSizeOfInstance(FrequencyEncoding.class);\n        size += RamUsageEstimator.sizeOf(field);\n        size += RamUsageEstimator.sizeOf(featureName);\n        // defSize:0 indicates that there is not a defined size. Finding the shallowSize of Double gives the best estimate", "refactored_code": "    public static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(FrequencyEncoding.class);\n\n    @Override\n    public long ramBytesUsed() {\n        long size = SHALLOW_SIZE;\n        size += RamUsageEstimator.sizeOf(field);\n        size += RamUsageEstimator.sizeOf(featureName);\n        // defSize:0 indicates that there is not a defined size. Finding the shallowSize of Double gives the best estimate"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        long size = RamUsageEstimator.shallowSizeOfInstance(Multi.class);\n        size += RamUsageEstimator.sizeOf(processors);\n        size += RamUsageEstimator.sizeOf(inputFields);\n        size += RamUsageEstimator.sizeOfMap(outputFields, 0);", "refactored_code": "    public static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(Multi.class);\n\n    @Override\n    public long ramBytesUsed() {\n        long size = SHALLOW_SIZE;\n        size += RamUsageEstimator.sizeOf(processors);\n        size += RamUsageEstimator.sizeOf(inputFields);\n        size += RamUsageEstimator.sizeOfMap(outputFields, 0);"}
{"magic_number_smell": "    private static final int MAX_GRAM = 5;\n\n    private static String defaultPrefix(Integer start, Integer length) {\n        return \"ngram_\" + (start == null ? 0 : start) + \"_\" + (length == null ? DEFAULT_LENGTH : length);\n    }\n\n    public static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(NGram.class);", "refactored_code": "    private static final int DEFAULT_START = 0;\n    private static final int MAX_GRAM = 5;\n\n    private static String defaultPrefix(Integer start, Integer length) {\n        return \"ngram_\" + (start == null ? DEFAULT_START : start) + \"_\" + (length == null ? DEFAULT_LENGTH : length);\n    }\n\n    public static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(NGram.class);"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        long size = RamUsageEstimator.shallowSizeOfInstance(OneHotEncoding.class);\n        size += RamUsageEstimator.sizeOf(field);\n        // defSize:0 does not do much in this case as sizeOf(String) is a known quantity\n        size += RamUsageEstimator.sizeOfMap(hotMap, 0);", "refactored_code": "    public static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(OneHotEncoding.class);\n\n    @Override\n    public long ramBytesUsed() {\n        long size = SHALLOW_SIZE;\n        size += RamUsageEstimator.sizeOf(field);\n        // defSize:0 does not do much in this case as sizeOf(String) is a known quantity\n        size += RamUsageEstimator.sizeOfMap(hotMap, 0);"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        long size = RamUsageEstimator.shallowSizeOfInstance(TargetMeanEncoding.class);\n        size += RamUsageEstimator.sizeOf(field);\n        size += RamUsageEstimator.sizeOf(featureName);\n        // defSize:0 indicates that there is not a defined size. Finding the shallowSize of Double gives the best estimate", "refactored_code": "    public static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(TargetMeanEncoding.class);\n\n    @Override\n    public long ramBytesUsed() {\n        long size = SHALLOW_SIZE;\n        size += RamUsageEstimator.sizeOf(field);\n        size += RamUsageEstimator.sizeOf(featureName);\n        // defSize:0 indicates that there is not a defined size. Finding the shallowSize of Double gives the best estimate"}
{"magic_number_smell": "    }\n\n    Hash32() {\n        this(0xBEEF);\n    }\n\n    public long hash(String input) {", "refactored_code": "    private static final int DEFAULT_SEED = 0xBEEF;\n    }\n\n    Hash32() {\n        this(DEFAULT_SEED);\n    }\n\n    public long hash(String input) {"}
{"magic_number_smell": "        this.vocabularyConfig = Optional.ofNullable(vocabularyConfig)\n            .orElse(new VocabularyConfig(InferenceIndexConstants.nativeDefinitionStore()));\n        this.tokenization = tokenization == null ? Tokenization.createDefault() : tokenization;\n        this.numTopClasses = numTopClasses == null ? 5 : numTopClasses;\n        this.resultsField = resultsField;\n        if (this.tokenization.span != -1) {\n            throw ExceptionsHelper.badRequestException(", "refactored_code": "    public static final int DEFAULT_NUM_RESULTS = 5;\n        this.vocabularyConfig = Optional.ofNullable(vocabularyConfig)\n            .orElse(new VocabularyConfig(InferenceIndexConstants.nativeDefinitionStore()));\n        this.tokenization = tokenization == null ? Tokenization.createDefault() : tokenization;\n        this.numTopClasses = numTopClasses == null ? DEFAULT_NUM_RESULTS : numTopClasses;\n        this.resultsField = resultsField;\n        if (this.tokenization.span != -1) {\n            throw ExceptionsHelper.badRequestException("}
{"magic_number_smell": "    }\n\n    private static boolean areClose(double value1, double value2) {\n        return Math.abs(value1 - value2) < 1.0E-9;\n    }\n\n    private static boolean isNumberQuickCheck(String stringRep) {", "refactored_code": "    private static final double EPS = 1.0E-9;\n    }\n\n    private static boolean areClose(double value1, double value2) {\n        return Math.abs(value1 - value2) < EPS;\n    }\n\n    private static boolean isNumberQuickCheck(String stringRep) {"}
{"magic_number_smell": "        @Nullable String resultsField\n    ) {\n        this.numTopClasses = Optional.ofNullable(numTopClasses).orElse(DEFAULT_NUM_TOP_CLASSES);\n        this.maxAnswerLength = Optional.ofNullable(maxAnswerLength).orElse(15);\n        if (this.numTopClasses < 0) {\n            throw ExceptionsHelper.badRequestException(\n                \"[{}] must be greater than or equal to [0]; provided [{}]\",", "refactored_code": "    public static final int DEFAULT_MAX_ANSWER_LENGTH = 15;\n        @Nullable String resultsField\n    ) {\n        this.numTopClasses = Optional.ofNullable(numTopClasses).orElse(DEFAULT_NUM_TOP_CLASSES);\n        this.maxAnswerLength = Optional.ofNullable(maxAnswerLength).orElse(DEFAULT_MAX_ANSWER_LENGTH);\n        if (this.numTopClasses < 0) {\n            throw ExceptionsHelper.badRequestException(\n                \"[{}] must be greater than or equal to [0]; provided [{}]\","}
{"magic_number_smell": "            for (int i = 0; i < pathDepth; i++) {\n                total += getScale(i) / pD--;\n            }\n            total *= (pathDepth + 1) / (fractionZero + Double.MIN_VALUE);\n        }\n\n        return total;", "refactored_code": "    private static final double DBL_EPSILON = Double.MIN_VALUE;\n            for (int i = 0; i < pathDepth; i++) {\n                total += getScale(i) / pD--;\n            }\n            total *= (pathDepth + 1) / (fractionZero + DBL_EPSILON);\n        }\n\n        return total;"}
{"magic_number_smell": "        }\n        this.doLowerCase = Optional.ofNullable(doLowerCase).orElse(DEFAULT_DO_LOWER_CASE);\n        this.withSpecialTokens = Optional.ofNullable(withSpecialTokens).orElse(DEFAULT_WITH_SPECIAL_TOKENS);\n        this.maxSequenceLength = Optional.ofNullable(maxSequenceLength).orElse(512);\n        this.truncate = Optional.ofNullable(truncate).orElse(DEFAULT_TRUNCATION);\n        this.span = Optional.ofNullable(span).orElse(UNSET_SPAN_VALUE);\n        if (this.span < 0 && this.span != UNSET_SPAN_VALUE) {", "refactored_code": "    public static final int DEFAULT_MAX_SEQUENCE_LENGTH = 512;\n        }\n        this.doLowerCase = Optional.ofNullable(doLowerCase).orElse(DEFAULT_DO_LOWER_CASE);\n        this.withSpecialTokens = Optional.ofNullable(withSpecialTokens).orElse(DEFAULT_WITH_SPECIAL_TOKENS);\n        this.maxSequenceLength = Optional.ofNullable(maxSequenceLength).orElse(DEFAULT_MAX_SEQUENCE_LENGTH);\n        this.truncate = Optional.ofNullable(truncate).orElse(DEFAULT_TRUNCATION);\n        this.span = Optional.ofNullable(span).orElse(UNSET_SPAN_VALUE);\n        if (this.span < 0 && this.span != UNSET_SPAN_VALUE) {"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        long size = RamUsageEstimator.shallowSizeOfInstance(Ensemble.class);\n        size += RamUsageEstimator.sizeOfCollection(featureNames);\n        size += RamUsageEstimator.sizeOfCollection(classificationLabels);\n        size += RamUsageEstimator.sizeOfCollection(models);", "refactored_code": "    private static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(Ensemble.class);\n\n    @Override\n    public long ramBytesUsed() {\n        long size = SHALLOW_SIZE;\n        size += RamUsageEstimator.sizeOfCollection(featureNames);\n        size += RamUsageEstimator.sizeOfCollection(classificationLabels);\n        size += RamUsageEstimator.sizeOfCollection(models);"}
{"magic_number_smell": "    @Override\n    public long ramBytesUsed() {\n        long weightSize = weights == null ? 0L : RamUsageEstimator.sizeOf(weights);\n        return RamUsageEstimator.shallowSizeOfInstance(Exponent.class) + weightSize;\n    }\n}\n", "refactored_code": "    public static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(Exponent.class);\n    @Override\n    public long ramBytesUsed() {\n        long weightSize = weights == null ? 0L : RamUsageEstimator.sizeOf(weights);\n        return SHALLOW_SIZE + weightSize;\n    }\n}\n"}
{"magic_number_smell": "    @Override\n    public long ramBytesUsed() {\n        long weightSize = weights == null ? 0L : RamUsageEstimator.sizeOf(weights);\n        return RamUsageEstimator.shallowSizeOfInstance(LogisticRegression.class) + weightSize;\n    }\n}\n", "refactored_code": "    public static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(LogisticRegression.class);\n    @Override\n    public long ramBytesUsed() {\n        long weightSize = weights == null ? 0L : RamUsageEstimator.sizeOf(weights);\n        return SHALLOW_SIZE + weightSize;\n    }\n}\n"}
{"magic_number_smell": "    @Override\n    public long ramBytesUsed() {\n        long weightSize = weights == null ? 0L : RamUsageEstimator.sizeOf(weights);\n        return RamUsageEstimator.shallowSizeOfInstance(WeightedMode.class) + weightSize;\n    }\n}\n", "refactored_code": "    private static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(WeightedMode.class);\n    @Override\n    public long ramBytesUsed() {\n        long weightSize = weights == null ? 0L : RamUsageEstimator.sizeOf(weights);\n        return SHALLOW_SIZE + weightSize;\n    }\n}\n"}
{"magic_number_smell": "    @Override\n    public long ramBytesUsed() {\n        long weightSize = weights == null ? 0L : RamUsageEstimator.sizeOf(weights);\n        return RamUsageEstimator.shallowSizeOfInstance(WeightedSum.class) + weightSize;\n    }\n}\n", "refactored_code": "    private static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(WeightedSum.class);\n    @Override\n    public long ramBytesUsed() {\n        long weightSize = weights == null ? 0L : RamUsageEstimator.sizeOf(weights);\n        return SHALLOW_SIZE + weightSize;\n    }\n}\n"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        long size = RamUsageEstimator.shallowSizeOfInstance(EnsembleInferenceModel.class);\n        size += RamUsageEstimator.sizeOf(featureNames);\n        size += RamUsageEstimator.sizeOfCollection(classificationLabels);\n        size += RamUsageEstimator.sizeOfCollection(models);", "refactored_code": "    public static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(EnsembleInferenceModel.class);\n\n    @Override\n    public long ramBytesUsed() {\n        long size = SHALLOW_SIZE;\n        size += RamUsageEstimator.sizeOf(featureNames);\n        size += RamUsageEstimator.sizeOfCollection(classificationLabels);\n        size += RamUsageEstimator.sizeOfCollection(models);"}
{"magic_number_smell": "    }\n\n    public long ramBytesUsed() {\n        long size = RamUsageEstimator.shallowSizeOfInstance(InferenceDefinition.class);\n        size += RamUsageEstimator.sizeOf(trainedModel);\n        size += RamUsageEstimator.sizeOfCollection(preProcessors);\n        return size;", "refactored_code": "    public static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(InferenceDefinition.class);\n    }\n\n    public long ramBytesUsed() {\n        long size = SHALLOW_SIZE;\n        size += RamUsageEstimator.sizeOf(trainedModel);\n        size += RamUsageEstimator.sizeOfCollection(preProcessors);\n        return size;"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        long size = shallowSizeOfInstance(TreeInferenceModel.class);\n        size += sizeOfCollection(classificationLabels);\n        size += sizeOf(featureNames);\n        size += sizeOf(nodes);", "refactored_code": "    public static final long SHALLOW_SIZE = shallowSizeOfInstance(TreeInferenceModel.class);\n\n    @Override\n    public long ramBytesUsed() {\n        long size = SHALLOW_SIZE;\n        size += sizeOfCollection(classificationLabels);\n        size += sizeOf(featureNames);\n        size += sizeOf(nodes);"}
{"magic_number_smell": "        final ClassificationConfig classificationConfig = (ClassificationConfig) config;\n        if (embeddedVector.isEmpty()) {\n            return new ClassificationInferenceResults(\n                LANGUAGE_NAMES.size() - 1,\n                MISSING_VALID_TXT_CLASSIFICATION_STR,\n                Collections.emptyList(),\n                Collections.emptyList(),", "refactored_code": "    private static final int MISSING_VALID_TXT_CLASSIFICATION = LANGUAGE_NAMES.size() - 1;\n        final ClassificationConfig classificationConfig = (ClassificationConfig) config;\n        if (embeddedVector.isEmpty()) {\n            return new ClassificationInferenceResults(\n                MISSING_VALID_TXT_CLASSIFICATION,\n                MISSING_VALID_TXT_CLASSIFICATION_STR,\n                Collections.emptyList(),\n                Collections.emptyList(),"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        long size = RamUsageEstimator.shallowSizeOfInstance(LangNetLayer.class);\n        size += RamUsageEstimator.sizeOf(weights);\n        size += RamUsageEstimator.sizeOf(bias);\n        return size;", "refactored_code": "    private static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(LangNetLayer.class);\n\n    @Override\n    public long ramBytesUsed() {\n        long size = SHALLOW_SIZE;\n        size += RamUsageEstimator.sizeOf(weights);\n        size += RamUsageEstimator.sizeOf(bias);\n        return size;"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        long size = RamUsageEstimator.shallowSizeOfInstance(Tree.class);\n        size += RamUsageEstimator.sizeOfCollection(classificationLabels);\n        size += RamUsageEstimator.sizeOfCollection(featureNames);\n        size += RamUsageEstimator.sizeOfCollection(nodes);", "refactored_code": "    private static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(Tree.class);\n\n    @Override\n    public long ramBytesUsed() {\n        long size = SHALLOW_SIZE;\n        size += RamUsageEstimator.sizeOfCollection(classificationLabels);\n        size += RamUsageEstimator.sizeOfCollection(featureNames);\n        size += RamUsageEstimator.sizeOfCollection(nodes);"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        return RamUsageEstimator.shallowSizeOfInstance(TreeNode.class) + this.leafValue.length * Double.BYTES;\n    }\n\n    public static class Builder {", "refactored_code": "    private static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(TreeNode.class);\n\n    @Override\n    public long ramBytesUsed() {\n        return SHALLOW_SIZE + this.leafValue.length * Double.BYTES;\n    }\n\n    public static class Builder {"}
{"magic_number_smell": "    private final Long categorizationExamplesLimit;\n\n    public AnalysisLimits(Long categorizationExamplesLimit) {\n        this(1024L, categorizationExamplesLimit);\n    }\n\n    public AnalysisLimits(Long modelMemoryLimitMb, Long categorizationExamplesLimit) {", "refactored_code": "    public static final long DEFAULT_MODEL_MEMORY_LIMIT_MB = 1024L;\n    private final Long categorizationExamplesLimit;\n\n    public AnalysisLimits(Long categorizationExamplesLimit) {\n        this(DEFAULT_MODEL_MEMORY_LIMIT_MB, categorizationExamplesLimit);\n    }\n\n    public AnalysisLimits(Long modelMemoryLimitMb, Long categorizationExamplesLimit) {"}
{"magic_number_smell": "        Builder addLimitFilter() {\n            Map<String, Object> limitFilter = new HashMap<>();\n            limitFilter.put(\"type\", \"limit\");\n            limitFilter.put(\"max_token_count\", 100);\n            addTokenFilter(limitFilter);\n            return this;\n        }", "refactored_code": "    public static final int MAX_TOKEN_COUNT = 100;\n        Builder addLimitFilter() {\n            Map<String, Object> limitFilter = new HashMap<>();\n            limitFilter.put(\"type\", \"limit\");\n            limitFilter.put(\"max_token_count\", MAX_TOKEN_COUNT);\n            addTokenFilter(limitFilter);\n            return this;\n        }"}
{"magic_number_smell": "        private ModelPlotConfig modelPlotConfig;\n        private Long renormalizationWindowDays;\n        private TimeValue backgroundPersistInterval;\n        private Long modelSnapshotRetentionDays = 10;\n        private Long dailyModelSnapshotRetentionAfterDays;\n        private Long resultsRetentionDays;\n        private Map<String, Object> customSettings;", "refactored_code": "    public static final long DEFAULT_MODEL_SNAPSHOT_RETENTION_DAYS = 10;\n        private ModelPlotConfig modelPlotConfig;\n        private Long renormalizationWindowDays;\n        private TimeValue backgroundPersistInterval;\n        private Long modelSnapshotRetentionDays = DEFAULT_MODEL_SNAPSHOT_RETENTION_DAYS;\n        private Long dailyModelSnapshotRetentionAfterDays;\n        private Long resultsRetentionDays;\n        private Map<String, Object> customSettings;"}
{"magic_number_smell": "            if (MlStrings.isValidId(id) == false) {\n                throw ExceptionsHelper.badRequestException(Messages.getMessage(Messages.INVALID_ID, ID.getPreferredName(), id));\n            }\n            if (items.size() > 10000) {\n                throw ExceptionsHelper.badRequestException(Messages.getMessage(Messages.FILTER_CONTAINS_TOO_MANY_ITEMS, id, 10000));\n            }\n            return new MlFilter(id, description, items);", "refactored_code": "    private static final int MAX_ITEMS = 10000;\n            if (MlStrings.isValidId(id) == false) {\n                throw ExceptionsHelper.badRequestException(Messages.getMessage(Messages.INVALID_ID, ID.getPreferredName(), id));\n            }\n            if (items.size() > MAX_ITEMS) {\n                throw ExceptionsHelper.badRequestException(Messages.getMessage(Messages.FILTER_CONTAINS_TOO_MANY_ITEMS, id, MAX_ITEMS));\n            }\n            return new MlFilter(id, description, items);"}
{"magic_number_smell": "            RESOURCE_PATH + \"results_index_mappings.json\",\n            MlIndexAndAlias.BWC_MAPPINGS_VERSION, // Only needed for BWC with pre-8.10.0 nodes\n            RESULTS_MAPPINGS_VERSION_VARIABLE,\n            Map.of(\"xpack.ml.managed.index.version\", Integer.toString(1))\n        );\n    }\n}", "refactored_code": "    public static final int RESULTS_INDEX_MAPPINGS_VERSION = 1;\n            RESOURCE_PATH + \"results_index_mappings.json\",\n            MlIndexAndAlias.BWC_MAPPINGS_VERSION, // Only needed for BWC with pre-8.10.0 nodes\n            RESULTS_MAPPINGS_VERSION_VARIABLE,\n            Map.of(\"xpack.ml.managed.index.version\", Integer.toString(RESULTS_INDEX_MAPPINGS_VERSION))\n        );\n    }\n}"}
{"magic_number_smell": "            RESOURCE_PATH + \"notifications_index_mappings.json\",\n            MlIndexAndAlias.BWC_MAPPINGS_VERSION, // Only needed for BWC with pre-8.10.0 nodes\n            MAPPINGS_VERSION_VARIABLE,\n            Map.of(\"xpack.ml.managed.index.version\", Integer.toString(1))\n        );\n    }\n}", "refactored_code": "    public static final int NOTIFICATIONS_INDEX_MAPPINGS_VERSION = 1;\n            RESOURCE_PATH + \"notifications_index_mappings.json\",\n            MlIndexAndAlias.BWC_MAPPINGS_VERSION, // Only needed for BWC with pre-8.10.0 nodes\n            MAPPINGS_VERSION_VARIABLE,\n            Map.of(\"xpack.ml.managed.index.version\", Integer.toString(NOTIFICATIONS_INDEX_MAPPINGS_VERSION))\n        );\n    }\n}"}
{"magic_number_smell": "\n    /**\n     * Checks if the given {@code id} has a valid length.\n     * We keep IDs in a length shorter or equal than {@link #64}\n     * in order to avoid unfriendly errors when storing docs with\n     * more than 512 bytes.\n     *", "refactored_code": "    public static final int ID_LENGTH_LIMIT = 64;\n\n    /**\n     * Checks if the given {@code id} has a valid length.\n     * We keep IDs in a length shorter or equal than {@link #ID_LENGTH_LIMIT}\n     * in order to avoid unfriendly errors when storing docs with\n     * more than 512 bytes.\n     *"}
{"magic_number_smell": "            SortedSet<Integer> st = null;\n            int t = 0;\n\n            int sec = cl.get(Calendar.0);\n            int min = cl.get(Calendar.MINUTE);\n\n            // get second.................................................", "refactored_code": "    private static final int SECOND = 0;\n            SortedSet<Integer> st = null;\n            int t = 0;\n\n            int sec = cl.get(Calendar.SECOND);\n            int min = cl.get(Calendar.MINUTE);\n\n            // get second................................................."}
{"magic_number_smell": "            conn = (HttpURLConnection) url.openConnection();\n        }\n        conn.setRequestMethod(method);\n        conn.setReadTimeout(35 * 1000);\n        // Add basic-auth header\n        conn.setRequestProperty(\"Authorization\", authorizationHeader);\n        conn.setRequestProperty(\"Content-Type\", XContentType.JSON.mediaType());", "refactored_code": "    private static final int READ_TIMEOUT = 35 * 1000;\n            conn = (HttpURLConnection) url.openConnection();\n        }\n        conn.setRequestMethod(method);\n        conn.setReadTimeout(READ_TIMEOUT);\n        // Add basic-auth header\n        conn.setRequestProperty(\"Authorization\", authorizationHeader);\n        conn.setRequestProperty(\"Content-Type\", XContentType.JSON.mediaType());"}
{"magic_number_smell": "    public static final Setting.AffixSetting<Integer> JWT_CACHE_SIZE = Setting.affixKeySetting(\n        RealmSettings.realmSettingPrefix(TYPE),\n        \"jwt.cache.size\",\n        key -> Setting.intSetting(key, 100_000, MIN_JWT_CACHE_SIZE, Setting.Property.NodeScope)\n    );\n\n    // Individual outgoing HTTP settings", "refactored_code": "    private static final int DEFAULT_JWT_CACHE_SIZE = 100_000;\n    public static final Setting.AffixSetting<Integer> JWT_CACHE_SIZE = Setting.affixKeySetting(\n        RealmSettings.realmSettingPrefix(TYPE),\n        \"jwt.cache.size\",\n        key -> Setting.intSetting(key, DEFAULT_JWT_CACHE_SIZE, MIN_JWT_CACHE_SIZE, Setting.Property.NodeScope)\n    );\n\n    // Individual outgoing HTTP settings"}
{"magic_number_smell": "    public static final Setting.AffixSetting<Integer> CACHE_MAX_USERS_SETTING = Setting.affixKeySetting(\n        RealmSettings.realmSettingPrefix(TYPE),\n        \"cache.max_users\",\n        key -> Setting.intSetting(key, 100_000, Property.NodeScope)\n    );\n\n    private KerberosRealmSettings() {}", "refactored_code": "    private static final int DEFAULT_MAX_USERS = 100_000; // 100k users\n    public static final Setting.AffixSetting<Integer> CACHE_MAX_USERS_SETTING = Setting.affixKeySetting(\n        RealmSettings.realmSettingPrefix(TYPE),\n        \"cache.max_users\",\n        key -> Setting.intSetting(key, DEFAULT_MAX_USERS, Property.NodeScope)\n    );\n\n    private KerberosRealmSettings() {}"}
{"magic_number_smell": "    public static final int 0 = 0;\n    public static final Function<String, Setting.AffixSetting<Integer>> POOL_INITIAL_SIZE = RealmSettings.affixSetting(\n        \"user_search.pool.initial_size\",\n        key -> Setting.intSetting(key, 0, 0, Setting.Property.NodeScope)\n    );\n\n    public static final int DEFAULT_CONNECTION_POOL_SIZE = 20;", "refactored_code": "    public static final int DEFAULT_CONNECTION_POOL_INITIAL_SIZE = 0;\n    public static final int DEFAULT_CONNECTION_POOL_INITIAL_SIZE = 0;\n    public static final Function<String, Setting.AffixSetting<Integer>> POOL_INITIAL_SIZE = RealmSettings.affixSetting(\n        \"user_search.pool.initial_size\",\n        key -> Setting.intSetting(key, DEFAULT_CONNECTION_POOL_INITIAL_SIZE, 0, Setting.Property.NodeScope)\n    );\n\n    public static final int DEFAULT_CONNECTION_POOL_SIZE = 20;"}
{"magic_number_smell": "    public static final Setting.AffixSetting<Integer> CACHE_MAX_USERS_SETTING = Setting.affixKeySetting(\n        RealmSettings.realmSettingPrefix(TYPE),\n        \"cache.max_users\",\n        key -> Setting.intSetting(key, 100_000, Setting.Property.NodeScope)\n    );\n\n    public static final Setting.AffixSetting<Boolean> DELEGATION_ENABLED_SETTING = Setting.affixKeySetting(", "refactored_code": "    private static final int DEFAULT_MAX_USERS = 100_000; // 100k users\n    public static final Setting.AffixSetting<Integer> CACHE_MAX_USERS_SETTING = Setting.affixKeySetting(\n        RealmSettings.realmSettingPrefix(TYPE),\n        \"cache.max_users\",\n        key -> Setting.intSetting(key, DEFAULT_MAX_USERS, Setting.Property.NodeScope)\n    );\n\n    public static final Setting.AffixSetting<Boolean> DELEGATION_ENABLED_SETTING = Setting.affixKeySetting("}
{"magic_number_smell": "     * @return  an encoded salt value\n     */\n    public static String gensalt() {\n        return gensalt(10);\n    }\n\n    /**", "refactored_code": "    private static final int GENSALT_DEFAULT_LOG2_ROUNDS = 10;\n     * @return  an encoded salt value\n     */\n    public static String gensalt() {\n        return gensalt(GENSALT_DEFAULT_LOG2_ROUNDS);\n    }\n\n    /**"}
{"magic_number_smell": "    private static final String CACHE_MAX_USERS_SUFFIX = \"cache.max_users\";\n    public static final Function<String, Setting.AffixSetting<Integer>> CACHE_MAX_USERS_SETTING = RealmSettings.affixSetting(\n        CACHE_MAX_USERS_SUFFIX,\n        key -> Setting.intSetting(key, 100_000, Setting.Property.NodeScope)\n    );\n\n    public static final Function<String, Setting.AffixSetting<Boolean>> AUTHC_ENABLED_SETTING = RealmSettings.affixSetting(", "refactored_code": "    private static final int DEFAULT_MAX_USERS = 100_000; // 100k users\n    private static final String CACHE_MAX_USERS_SUFFIX = \"cache.max_users\";\n    public static final Function<String, Setting.AffixSetting<Integer>> CACHE_MAX_USERS_SETTING = RealmSettings.affixSetting(\n        CACHE_MAX_USERS_SUFFIX,\n        key -> Setting.intSetting(key, DEFAULT_MAX_USERS, Setting.Property.NodeScope)\n    );\n\n    public static final Function<String, Setting.AffixSetting<Boolean>> AUTHC_ENABLED_SETTING = RealmSettings.affixSetting("}
{"magic_number_smell": "     */\n    public static Hasher resolveFromHash(char[] hash) {\n        if (isBcryptPrefix(hash)) {\n            int cost = Integer.parseInt(new String(Arrays.copyOfRange(hash, 4, hash.length - 54)));\n            return cost == BCRYPT_DEFAULT_COST ? Hasher.BCRYPT : resolve(\"bcrypt\" + cost);\n        } else if (CharArrays.charsBeginsWith(PBKDF2_STRETCH_PREFIX, hash)) {\n            int cost = parsePbkdf2Iterations(hash, PBKDF2_STRETCH_PREFIX);", "refactored_code": "    private static final int BCRYPT_PREFIX_LENGTH = 4;\n     */\n    public static Hasher resolveFromHash(char[] hash) {\n        if (isBcryptPrefix(hash)) {\n            int cost = Integer.parseInt(new String(Arrays.copyOfRange(hash, BCRYPT_PREFIX_LENGTH, hash.length - 54)));\n            return cost == BCRYPT_DEFAULT_COST ? Hasher.BCRYPT : resolve(\"bcrypt\" + cost);\n        } else if (CharArrays.charsBeginsWith(PBKDF2_STRETCH_PREFIX, hash)) {\n            int cost = parsePbkdf2Iterations(hash, PBKDF2_STRETCH_PREFIX);"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        return RamUsageEstimator.shallowSizeOfInstance(AutomatonFieldPredicate.class) + RamUsageEstimator.sizeOf(automatonHash); // automaton itself is a shallow copy so not counted here\n    }\n\n    private static String sha256(Automaton automaton) {", "refactored_code": "    private final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(AutomatonFieldPredicate.class);\n\n    @Override\n    public long ramBytesUsed() {\n        return SHALLOW_SIZE + RamUsageEstimator.sizeOf(automatonHash); // automaton itself is a shallow copy so not counted here\n    }\n\n    private static String sha256(Automaton automaton) {"}
{"magic_number_smell": "            ? FieldPredicate.ACCEPT_ALL\n            : new AutomatonFieldPredicate(originalAutomaton, this.permittedFieldsAutomaton);\n\n        long ramBytesUsed = RamUsageEstimator.shallowSizeOf(new FieldPermissionsDefinition(null, null));\n        ramBytesUsed += this.fieldPermissionsDefinitions.stream()\n            .mapToLong(FieldPermissions::ramBytesUsedForFieldPermissionsDefinition)\n            .sum();", "refactored_code": "    private static final long BASE_FIELD_PERM_DEF_BYTES = RamUsageEstimator.shallowSizeOf(new FieldPermissionsDefinition(null, null));\n            ? FieldPredicate.ACCEPT_ALL\n            : new AutomatonFieldPredicate(originalAutomaton, this.permittedFieldsAutomaton);\n\n        long ramBytesUsed = BASE_FIELD_PERM_DEF_BYTES;\n        ramBytesUsed += this.fieldPermissionsDefinitions.stream()\n            .mapToLong(FieldPermissions::ramBytesUsedForFieldPermissionsDefinition)\n            .sum();"}
{"magic_number_smell": "    public static final int 507 = 507;\n\n    public static Validation.Error validateUsername(String username, boolean allowReserved, Settings settings) {\n        return Validation.Users.validateUsername(username, allowReserved, settings, 507);\n    }\n\n    public static Validation.Error validateRoleName(String roleName, boolean allowReserved) {", "refactored_code": "    public static final int MAX_NAME_LENGTH = 507;\n    public static final int MAX_NAME_LENGTH = 507;\n\n    public static Validation.Error validateUsername(String username, boolean allowReserved, Settings settings) {\n        return Validation.Users.validateUsername(username, allowReserved, settings, MAX_NAME_LENGTH);\n    }\n\n    public static Validation.Error validateRoleName(String roleName, boolean allowReserved) {"}
{"magic_number_smell": "        }\n\n        public static Error validatePassword(SecureString password) {\n            return password.length() >= 6\n                ? null\n                : new Error(\"passwords must be at least [\" + 6 + \"] characters long\");\n        }", "refactored_code": "        private static final int MIN_PASSWD_LENGTH = 6;\n        }\n\n        public static Error validatePassword(SecureString password) {\n            return password.length() >= MIN_PASSWD_LENGTH\n                ? null\n                : new Error(\"passwords must be at least [\" + MIN_PASSWD_LENGTH + \"] characters long\");\n        }"}
{"magic_number_smell": "        }\n        if (x509Fields.contains(X509Field.SAN_OTHERNAME_COMMONNAME)) {\n            Set<String> otherNames = sans.stream()\n                .filter(pair -> ((Integer) pair.get(0)).intValue() == 0)\n                .map(pair -> pair.get(1))\n                .map(value -> decodeDerValue((byte[]) value, certificate))\n                .filter(Objects::nonNull)", "refactored_code": "    private static final int SAN_CODE_OTHERNAME = 0;\n        }\n        if (x509Fields.contains(X509Field.SAN_OTHERNAME_COMMONNAME)) {\n            Set<String> otherNames = sans.stream()\n                .filter(pair -> ((Integer) pair.get(0)).intValue() == SAN_CODE_OTHERNAME)\n                .map(pair -> pair.get(1))\n                .map(value -> decodeDerValue((byte[]) value, certificate))\n                .filter(Objects::nonNull)"}
{"magic_number_smell": "    @Override\n    public ActionRequestValidationException validate() {\n        ActionRequestValidationException validationException = null;\n        if (linesToSample != null && linesToSample < 2) {\n            validationException = addValidationError(\n                \"[\" + LINES_TO_SAMPLE.getPreferredName() + \"] must be at least [\" + 2 + \"] if specified\",\n                validationException", "refactored_code": "    public static final int MIN_SAMPLE_LINE_COUNT = 2;\n    @Override\n    public ActionRequestValidationException validate() {\n        ActionRequestValidationException validationException = null;\n        if (linesToSample != null && linesToSample < MIN_SAMPLE_LINE_COUNT) {\n            validationException = addValidationError(\n                \"[\" + LINES_TO_SAMPLE.getPreferredName() + \"] must be at least [\" + MIN_SAMPLE_LINE_COUNT + \"] if specified\",\n                validationException"}
{"magic_number_smell": "        @Override\n        public ActionRequestValidationException validate() {\n            ActionRequestValidationException exception = null;\n            if (getPageParams() != null && getPageParams().getSize() > 1000) {\n                exception = addValidationError(\n                    \"Param [\" + PageParams.SIZE.getPreferredName() + \"] has a max acceptable value of [\" + 1000 + \"]\",\n                    exception", "refactored_code": "        private static final int MAX_SIZE_RETURN = 1000;\n        @Override\n        public ActionRequestValidationException validate() {\n            ActionRequestValidationException exception = null;\n            if (getPageParams() != null && getPageParams().getSize() > MAX_SIZE_RETURN) {\n                exception = addValidationError(\n                    \"Param [\" + PageParams.SIZE.getPreferredName() + \"] has a max acceptable value of [\" + MAX_SIZE_RETURN + \"]\",\n                    exception"}
{"magic_number_smell": "        @Override\n        public ActionRequestValidationException validate() {\n            ActionRequestValidationException exception = null;\n            if (getPageParams() != null && getPageParams().getSize() > 1000) {\n                exception = addValidationError(\n                    \"Param [\" + PageParams.SIZE.getPreferredName() + \"] has a max acceptable value of [\" + 1000 + \"]\",\n                    exception", "refactored_code": "        public static final int MAX_SIZE_RETURN = 1000;\n        @Override\n        public ActionRequestValidationException validate() {\n            ActionRequestValidationException exception = null;\n            if (getPageParams() != null && getPageParams().getSize() > MAX_SIZE_RETURN) {\n                exception = addValidationError(\n                    \"Param [\" + PageParams.SIZE.getPreferredName() + \"] has a max acceptable value of [\" + MAX_SIZE_RETURN + \"]\",\n                    exception"}
{"magic_number_smell": "                validationException\n            );\n        }\n        if (numFailureRetries != null && (numFailureRetries < -1 || numFailureRetries > 100)) {\n            validationException = addValidationError(\n                \"settings.num_failure_retries [\"\n                    + numFailureRetries", "refactored_code": "    public static final int MAX_NUM_FAILURE_RETRIES = 100;\n                validationException\n            );\n        }\n        if (numFailureRetries != null && (numFailureRetries < -1 || numFailureRetries > MAX_NUM_FAILURE_RETRIES)) {\n            validationException = addValidationError(\n                \"settings.num_failure_retries [\"\n                    + numFailureRetries"}
{"magic_number_smell": "    // This changes how much \"weight\" past calculations have.\n    // The shorter the window, the less \"smoothing\" will occur.\n    private static final int 10 = 10;\n    private static final double ALPHA = 2.0 / (10 + 1);\n\n    private static final ConstructingObjectParser<TransformIndexerStats, Void> LENIENT_PARSER = new ConstructingObjectParser<>(\n        NAME,", "refactored_code": "    private static final int EXP_AVG_WINDOW = 10;\n    // This changes how much \"weight\" past calculations have.\n    // The shorter the window, the less \"smoothing\" will occur.\n    private static final int EXP_AVG_WINDOW = 10;\n    private static final double ALPHA = 2.0 / (EXP_AVG_WINDOW + 1);\n\n    private static final ConstructingObjectParser<TransformIndexerStats, Void> LENIENT_PARSER = new ConstructingObjectParser<>(\n        NAME,"}
{"magic_number_smell": "\n        @Override\n        public byte getIntervalTypeId() {\n            return 1;\n        }\n\n        @Override", "refactored_code": "    private static final int CALENDAR_INTERVAL_ID = 1;\n\n        @Override\n        public byte getIntervalTypeId() {\n            return CALENDAR_INTERVAL_ID;\n        }\n\n        @Override"}
{"magic_number_smell": "\n    /**\n     * Checks if the given {@code id} has a valid length.\n     * We keep IDs in a length shorter or equal than {@link #64}\n     * in order to avoid unfriendly errors when storing docs with\n     * more than 512 bytes.\n     *", "refactored_code": "    public static final int ID_LENGTH_LIMIT = 64;\n\n    /**\n     * Checks if the given {@code id} has a valid length.\n     * We keep IDs in a length shorter or equal than {@link #ID_LENGTH_LIMIT}\n     * in order to avoid unfriendly errors when storing docs with\n     * more than 512 bytes.\n     *"}
{"magic_number_smell": "     * Checks the format of an internal index and returns true if the index is up to date or false if upgrade is required\n     */\n    public static boolean checkInternalIndexFormat(IndexMetadata indexMetadata) {\n        return indexMetadata.getSettings().getAsInt(IndexMetadata.INDEX_FORMAT_SETTING.getKey(), 0) == 6;\n    }\n}\n", "refactored_code": "    public static final int EXPECTED_INDEX_FORMAT_VERSION = 6;\n     * Checks the format of an internal index and returns true if the index is up to date or false if upgrade is required\n     */\n    public static boolean checkInternalIndexFormat(IndexMetadata indexMetadata) {\n        return indexMetadata.getSettings().getAsInt(IndexMetadata.INDEX_FORMAT_SETTING.getKey(), 0) == EXPECTED_INDEX_FORMAT_VERSION;\n    }\n}\n"}
{"magic_number_smell": "    }\n\n    private static SecretKey readSystemKey(InputStream in) throws IOException {\n        final int keySizeBytes = 1024 / 8;\n        final byte[] keyBytes = new byte[keySizeBytes];\n        final int read = Streams.readFully(in, keyBytes);\n        if (read != keySizeBytes) {", "refactored_code": "    public static final int KEY_SIZE = 1024;\n    }\n\n    private static SecretKey readSystemKey(InputStream in) throws IOException {\n        final int keySizeBytes = KEY_SIZE / 8;\n        final byte[] keyBytes = new byte[keySizeBytes];\n        final int read = Streams.readFully(in, keyBytes);\n        if (read != keySizeBytes) {"}
{"magic_number_smell": "    // version 16: change watch history ILM policy\n    // Note: if you change this, also inform the kibana team around the watcher-ui\n    public static final int 16 = 16;\n    public static final String HISTORY_TEMPLATE_NAME = \".watch-history-\" + 16;\n    public static final String HISTORY_TEMPLATE_NAME_NO_ILM = \".watch-history-no-ilm-\" + 16;\n    public static final String[] TEMPLATE_NAMES = new String[] { HISTORY_TEMPLATE_NAME };\n    public static final String[] TEMPLATE_NAMES_NO_ILM = new String[] { HISTORY_TEMPLATE_NAME_NO_ILM };", "refactored_code": "    public static final int INDEX_TEMPLATE_VERSION = 16;\n    // version 16: change watch history ILM policy\n    // Note: if you change this, also inform the kibana team around the watcher-ui\n    public static final int INDEX_TEMPLATE_VERSION = 16;\n    public static final String HISTORY_TEMPLATE_NAME = \".watch-history-\" + INDEX_TEMPLATE_VERSION;\n    public static final String HISTORY_TEMPLATE_NAME_NO_ILM = \".watch-history-no-ilm-\" + INDEX_TEMPLATE_VERSION;\n    public static final String[] TEMPLATE_NAMES = new String[] { HISTORY_TEMPLATE_NAME };\n    public static final String[] TEMPLATE_NAMES_NO_ILM = new String[] { HISTORY_TEMPLATE_NAME_NO_ILM };"}
{"magic_number_smell": "                new IndexTemplateConfig(\n                    TEST_INDEX,\n                    \"/ml/notifications_index_template.json\",\n                    23456789,\n                    \"xpack.ml.version\",\n                    Map.of(\n                        \"xpack.ml.version.id\",", "refactored_code": "    private static final int TEST_TEMPLATE_VERSION = 23456789;\n                new IndexTemplateConfig(\n                    TEST_INDEX,\n                    \"/ml/notifications_index_template.json\",\n                    TEST_TEMPLATE_VERSION,\n                    \"xpack.ml.version\",\n                    Map.of(\n                        \"xpack.ml.version.id\","}
{"magic_number_smell": "    protected abstract T copyInstance(T instance);\n\n    public void testHashcodeAndEquals() {\n        for (int runs = 0; runs < 20; runs++) {\n            EqualsHashCodeTestUtils.checkEqualsAndHashCode(createRandomInstance(), this::copyInstance, this::mutateInstance);\n        }\n    }", "refactored_code": "    protected static final int NUMBER_OF_TEST_RUNS = 20;\n    protected abstract T copyInstance(T instance);\n\n    public void testHashcodeAndEquals() {\n        for (int runs = 0; runs < NUMBER_OF_TEST_RUNS; runs++) {\n            EqualsHashCodeTestUtils.checkEqualsAndHashCode(createRandomInstance(), this::copyInstance, this::mutateInstance);\n        }\n    }"}
{"magic_number_smell": "\n    @Override\n    protected SetPriorityAction createTestInstance() {\n        return new SetPriorityAction(randomIntBetween(0, Integer.MAX_VALUE));\n    }\n\n    @Override", "refactored_code": "    private final int priority = randomIntBetween(0, Integer.MAX_VALUE);\n\n    @Override\n    protected SetPriorityAction createTestInstance() {\n        return new SetPriorityAction(priority);\n    }\n\n    @Override"}
{"magic_number_smell": "        results = extractor.extractFeatures(\"just some plain text\");\n        assertThat(results.length, equalTo(1));\n        assertThat(results[0].getRow(), equalTo(ScriptDetector.Script.kScriptOtherUtf8OneByte.toInt()));\n        assertThat(results[0].getWeight(), closeTo(1.0, 0.000001));\n\n        results = extractor.extractFeatures(\"\u00e3\u0192\u00b8\u00e3\u0192\u201a\u00e3\u201a\u00a0\u00e3\u0192\u201a\");\n        assertThat(results.length, equalTo(1));", "refactored_code": "    private static final double eps = 0.000001;\n        results = extractor.extractFeatures(\"just some plain text\");\n        assertThat(results.length, equalTo(1));\n        assertThat(results[0].getRow(), equalTo(ScriptDetector.Script.kScriptOtherUtf8OneByte.toInt()));\n        assertThat(results[0].getWeight(), closeTo(1.0, eps));\n\n        results = extractor.extractFeatures(\"\u00e3\u0192\u00b8\u00e3\u0192\u201a\u00e3\u201a\u00a0\u00e3\u0192\u201a\");\n        assertThat(results.length, equalTo(1));"}
{"magic_number_smell": "    }\n\n    public void testSerializationFromEnsemble() throws Exception {\n        for (int i = 0; i < 20; ++i) {\n            int numberOfFeatures = randomIntBetween(1, 10);\n            Ensemble ensemble = EnsembleTests.createRandom(randomFrom(TargetType.values()), randomBoolean() ? 0 : numberOfFeatures);\n            assertThat(serializeFromTrainedModel(ensemble), is(not(nullValue())));", "refactored_code": "    private static final int NUMBER_OF_TEST_RUNS = 20;\n    }\n\n    public void testSerializationFromEnsemble() throws Exception {\n        for (int i = 0; i < NUMBER_OF_TEST_RUNS; ++i) {\n            int numberOfFeatures = randomIntBetween(1, 10);\n            Ensemble ensemble = EnsembleTests.createRandom(randomFrom(TargetType.values()), randomBoolean() ? 0 : numberOfFeatures);\n            assertThat(serializeFromTrainedModel(ensemble), is(not(nullValue())));"}
{"magic_number_smell": "    }\n\n    public void testSerializationFromEnsemble() throws Exception {\n        for (int i = 0; i < 20; ++i) {\n            Tree tree = TreeTests.createRandom(randomFrom(TargetType.values()));\n            assertThat(serializeFromTrainedModel(tree), is(not(nullValue())));\n        }", "refactored_code": "    private static final int NUMBER_OF_TEST_RUNS = 20;\n    }\n\n    public void testSerializationFromEnsemble() throws Exception {\n        for (int i = 0; i < NUMBER_OF_TEST_RUNS; ++i) {\n            Tree tree = TreeTests.createRandom(randomFrom(TargetType.values()));\n            assertThat(serializeFromTrainedModel(tree), is(not(nullValue())));\n        }"}
{"magic_number_smell": "        modelSnapshot.setTimestamp(DEFAULT_TIMESTAMP);\n        modelSnapshot.setDescription(DEFAULT_DESCRIPTION);\n        modelSnapshot.setSnapshotId(DEFAULT_ID);\n        modelSnapshot.setSnapshotDocCount(7);\n        ModelSizeStats.Builder modelSizeStatsBuilder = new ModelSizeStats.Builder(\"foo\");\n        modelSizeStatsBuilder.setLogTime(null);\n        modelSnapshot.setModelSizeStats(modelSizeStatsBuilder);", "refactored_code": "    private static final int DEFAULT_DOC_COUNT = 7;\n        modelSnapshot.setTimestamp(DEFAULT_TIMESTAMP);\n        modelSnapshot.setDescription(DEFAULT_DESCRIPTION);\n        modelSnapshot.setSnapshotId(DEFAULT_ID);\n        modelSnapshot.setSnapshotDocCount(DEFAULT_DOC_COUNT);\n        ModelSizeStats.Builder modelSizeStatsBuilder = new ModelSizeStats.Builder(\"foo\");\n        modelSizeStatsBuilder.setLogTime(null);\n        modelSnapshot.setModelSizeStats(modelSizeStatsBuilder);"}
{"magic_number_smell": "        IndexTemplateConfig notificationsTemplate = new IndexTemplateConfig(\n            NotificationsIndex.NOTIFICATIONS_INDEX,\n            \"/ml/notifications_index_template.json\",\n            12345678,\n            \"xpack.ml.version\",\n            Map.of(\n                \"xpack.ml.version.id\",", "refactored_code": "    private static final int TEST_TEMPLATE_VERSION = 12345678;\n        IndexTemplateConfig notificationsTemplate = new IndexTemplateConfig(\n            NotificationsIndex.NOTIFICATIONS_INDEX,\n            \"/ml/notifications_index_template.json\",\n            TEST_TEMPLATE_VERSION,\n            \"xpack.ml.version\",\n            Map.of(\n                \"xpack.ml.version.id\","}
{"magic_number_smell": "        final int numberOfIndices = randomIntBetween(3, 8);\n\n        // Force cache evictions by setting the size to be less than the number of distinct queries we search on.\n        final int maxCacheCount = randomIntBetween(10 / 2, 10 * 3 / 4);\n        final long maxCacheBytes = EXPECTED_BYTES_PER_BIT_SET * maxCacheCount;\n        final Settings settings = Settings.builder()\n            .put(DocumentSubsetBitsetCache.CACHE_SIZE_SETTING.getKey(), maxCacheBytes + \"b\")", "refactored_code": "    private static final int FIELD_COUNT = 10;\n        final int numberOfIndices = randomIntBetween(3, 8);\n\n        // Force cache evictions by setting the size to be less than the number of distinct queries we search on.\n        final int maxCacheCount = randomIntBetween(FIELD_COUNT / 2, FIELD_COUNT * 3 / 4);\n        final long maxCacheBytes = EXPECTED_BYTES_PER_BIT_SET * maxCacheCount;\n        final Settings settings = Settings.builder()\n            .put(DocumentSubsetBitsetCache.CACHE_SIZE_SETTING.getKey(), maxCacheBytes + \"b\")"}
{"magic_number_smell": "    }\n\n    public void testUsernameValidWithCustomLength() {\n        int length = randomIntBetween(Validation.MIN_NAME_LENGTH, 507);\n        String name = new String(generateValidName(length));\n        assertThat(Users.validateUsername(name, false, Settings.EMPTY, 507), nullValue());\n    }", "refactored_code": "    private static final int CUSTOM_MAX_NAME_LENGTH = 507;\n    }\n\n    public void testUsernameValidWithCustomLength() {\n        int length = randomIntBetween(Validation.MIN_NAME_LENGTH, CUSTOM_MAX_NAME_LENGTH);\n        String name = new String(generateValidName(length));\n        assertThat(Users.validateUsername(name, false, Settings.EMPTY, CUSTOM_MAX_NAME_LENGTH), nullValue());\n    }"}
{"magic_number_smell": "        IndexTemplateConfig config = new IndexTemplateConfig(\n            settingsConfigName,\n            \"/org/elasticsearch/xpack/core/template/custom-plugin-settings.json\",\n            3,\n            TEMPLATE_VERSION_VARIABLE\n        );\n        ComponentTemplate componentTemplate = null;", "refactored_code": "    public static final int REGISTRY_VERSION = 3;\n        IndexTemplateConfig config = new IndexTemplateConfig(\n            settingsConfigName,\n            \"/org/elasticsearch/xpack/core/template/custom-plugin-settings.json\",\n            REGISTRY_VERSION,\n            TEMPLATE_VERSION_VARIABLE\n        );\n        ComponentTemplate componentTemplate = null;"}
{"magic_number_smell": "            new IndexTemplateConfig(\n                DEPRECATION_INDEXING_MAPPINGS_NAME,\n                \"/deprecation/deprecation-indexing-mappings.json\",\n                1,\n                DEPRECATION_INDEXING_TEMPLATE_VERSION_VARIABLE\n            ),\n            new IndexTemplateConfig(", "refactored_code": "    public static final int INDEX_TEMPLATE_VERSION = 1;\n            new IndexTemplateConfig(\n                DEPRECATION_INDEXING_MAPPINGS_NAME,\n                \"/deprecation/deprecation-indexing-mappings.json\",\n                INDEX_TEMPLATE_VERSION,\n                DEPRECATION_INDEXING_TEMPLATE_VERSION_VARIABLE\n            ),\n            new IndexTemplateConfig("}
{"magic_number_smell": "            \"1986-01-08T23:40:53.384Z\",\n            \"2022-01-08T23:40:53.384Z\",\n            lifecycle,\n            50_000,\n            \"1990-09-09T18:00:00\"\n        );\n", "refactored_code": "    public static final int DOC_COUNT = 50_000;\n            \"1986-01-08T23:40:53.384Z\",\n            \"2022-01-08T23:40:53.384Z\",\n            lifecycle,\n            DOC_COUNT,\n            \"1990-09-09T18:00:00\"\n        );\n"}
{"magic_number_smell": "            \"1986-01-08T23:40:53.384Z\",\n            \"2022-01-08T23:40:53.384Z\",\n            lifecycle,\n            50_000,\n            \"1990-09-09T18:00:00\"\n        );\n", "refactored_code": "    public static final int DOC_COUNT = 50_000;\n            \"1986-01-08T23:40:53.384Z\",\n            \"2022-01-08T23:40:53.384Z\",\n            lifecycle,\n            DOC_COUNT,\n            \"1990-09-09T18:00:00\"\n        );\n"}
{"magic_number_smell": "        // THEN\n        final AcknowledgedResponse downsampleResponse = testCluster.masterClient()\n            .execute(DownsampleAction.INSTANCE, downsampleRequest)\n            .actionGet(TimeValue.timeValueMillis(10_000));\n        assertTrue(downsampleResponse.isAcknowledged());\n\n        assertIndexExists(testCluster.coordinatorName(), SOURCE_INDEX_NAME);", "refactored_code": "    private static final int DOWNSAMPLE_ACTION_TIMEOUT_MILLIS = 10_000;\n        // THEN\n        final AcknowledgedResponse downsampleResponse = testCluster.masterClient()\n            .execute(DownsampleAction.INSTANCE, downsampleRequest)\n            .actionGet(TimeValue.timeValueMillis(DOWNSAMPLE_ACTION_TIMEOUT_MILLIS));\n        assertTrue(downsampleResponse.isAcknowledged());\n\n        assertIndexExists(testCluster.coordinatorName(), SOURCE_INDEX_NAME);"}
{"magic_number_smell": "                .field(FIELD_METRIC_COUNTER, counterValue)\n                .endObject();\n        };\n        int indexedDocs = bulkIndex(sourceIndex, sourceSupplier, 10_000);\n        final CountDownLatch disruptionStart = new CountDownLatch(1);\n        final CountDownLatch disruptionEnd = new CountDownLatch(1);\n", "refactored_code": "    public static final int DOC_COUNT = 10_000;\n                .field(FIELD_METRIC_COUNTER, counterValue)\n                .endObject();\n        };\n        int indexedDocs = bulkIndex(sourceIndex, sourceSupplier, DOC_COUNT);\n        final CountDownLatch disruptionStart = new CountDownLatch(1);\n        final CountDownLatch disruptionEnd = new CountDownLatch(1);\n"}
{"magic_number_smell": "            settings,\n            DOWNSAMPLE_TASK_THREAD_POOL_NAME,\n            ThreadPool.oneEighthAllocatedProcessors(EsExecutors.allocatedProcessors(settings)),\n            256,\n            \"xpack.downsample.thread_pool\",\n            EsExecutors.TaskTrackingConfig.DO_NOT_TRACK\n        );", "refactored_code": "    private static final int DOWNSAMPLE_TASK_THREAD_POOL_QUEUE_SIZE = 256;\n            settings,\n            DOWNSAMPLE_TASK_THREAD_POOL_NAME,\n            ThreadPool.oneEighthAllocatedProcessors(EsExecutors.allocatedProcessors(settings)),\n            DOWNSAMPLE_TASK_THREAD_POOL_QUEUE_SIZE,\n            \"xpack.downsample.thread_pool\",\n            EsExecutors.TaskTrackingConfig.DO_NOT_TRACK\n        );"}
{"magic_number_smell": "        };\n\n        return BulkProcessor2.builder(client::bulk, listener, client.threadPool())\n            .setBulkActions(10000)\n            .setBulkSize(DOWNSAMPLE_BULK_SIZE)\n            .setMaxBytesInFlight(downsampleMaxBytesInFlight)\n            .setMaxNumberOfRetries(3)", "refactored_code": "    public static final int DOWNSAMPLE_BULK_ACTIONS = 10000;\n        };\n\n        return BulkProcessor2.builder(client::bulk, listener, client.threadPool())\n            .setBulkActions(DOWNSAMPLE_BULK_ACTIONS)\n            .setBulkSize(DOWNSAMPLE_BULK_SIZE)\n            .setMaxBytesInFlight(downsampleMaxBytesInFlight)\n            .setMaxNumberOfRetries(3)"}
{"magic_number_smell": "        numOfReplicas = randomIntBetween(0, 0);\n\n        // Values for keyword dimensions\n        dimensionValues = new ArrayList<>(5);\n        for (int j = 0; j < randomIntBetween(1, 5); j++) {\n            dimensionValues.add(randomAlphaOfLength(6));\n        }", "refactored_code": "    private static final int MAX_DIM_VALUES = 5;\n        numOfReplicas = randomIntBetween(0, 0);\n\n        // Values for keyword dimensions\n        dimensionValues = new ArrayList<>(MAX_DIM_VALUES);\n        for (int j = 0; j < randomIntBetween(1, MAX_DIM_VALUES); j++) {\n            dimensionValues.add(randomAlphaOfLength(6));\n        }"}
{"magic_number_smell": "        } else {\n            // DSL has been introduced with the version 3 of the registry.\n            // Wait for this version to be deployed.\n            assertBusy(() -> assertDataStreamTemplateExists(EVENT_DATA_STREAM_LEGACY_TEMPLATE_NAME, 3));\n        }\n    }\n", "refactored_code": "    private static final int DSL_REGISTRY_VERSION = 3;\n        } else {\n            // DSL has been introduced with the version 3 of the registry.\n            // Wait for this version to be deployed.\n            assertBusy(() -> assertDataStreamTemplateExists(EVENT_DATA_STREAM_LEGACY_TEMPLATE_NAME, DSL_REGISTRY_VERSION));\n        }\n    }\n"}
{"magic_number_smell": "    private static final int MAX_BULK_SIZE = 1000;\n    public static final Setting<Integer> MAX_NUMBER_OF_EVENTS_PER_BULK_SETTING = Setting.intSetting(\n        Strings.format(\"%s.%s\", SETTING_ROOT_PATH, \"bulk_processor.max_events_per_bulk\"),\n        500,\n        MIN_BULK_SIZE,\n        MAX_BULK_SIZE,\n        Setting.Property.NodeScope", "refactored_code": "    private static final int DEFAULT_BULK_SIZE = 500;\n    private static final int MAX_BULK_SIZE = 1000;\n    public static final Setting<Integer> MAX_NUMBER_OF_EVENTS_PER_BULK_SETTING = Setting.intSetting(\n        Strings.format(\"%s.%s\", SETTING_ROOT_PATH, \"bulk_processor.max_events_per_bulk\"),\n        DEFAULT_BULK_SIZE,\n        MIN_BULK_SIZE,\n        MAX_BULK_SIZE,\n        Setting.Property.NodeScope"}
{"magic_number_smell": "            \"/connector-secrets.json\",\n            Version.CURRENT.toString(),\n            MAPPING_VERSION_VARIABLE,\n            Map.of(MAPPING_MANAGED_VERSION_VARIABLE, Integer.toString(1))\n        );\n        request.source(templateSource, XContentType.JSON);\n", "refactored_code": "    private static final int CURRENT_INDEX_VERSION = 1;\n            \"/connector-secrets.json\",\n            Version.CURRENT.toString(),\n            MAPPING_VERSION_VARIABLE,\n            Map.of(MAPPING_MANAGED_VERSION_VARIABLE, Integer.toString(CURRENT_INDEX_VERSION))\n        );\n        request.source(templateSource, XContentType.JSON);\n"}
{"magic_number_smell": "     */\n    public static final Setting<Integer> MAX_RULE_LIMIT_SETTING = Setting.intSetting(\n        Strings.format(\"%s.%s\", SETTING_ROOT_PATH, \"max_rules_per_ruleset\"),\n        100,\n        MIN_RULE_LIMIT,\n        MAX_RULE_LIMIT,\n        Setting.Property.Dynamic,", "refactored_code": "    private static final int DEFAULT_RULE_LIMIT = 100;\n     */\n    public static final Setting<Integer> MAX_RULE_LIMIT_SETTING = Setting.intSetting(\n        Strings.format(\"%s.%s\", SETTING_ROOT_PATH, \"max_rules_per_ruleset\"),\n        DEFAULT_RULE_LIMIT,\n        MIN_RULE_LIMIT,\n        MAX_RULE_LIMIT,\n        Setting.Property.Dynamic,"}
{"magic_number_smell": "            {\n                builder.startObject(\"_meta\");\n                builder.field(\"version\", Version.CURRENT.toString());\n                builder.field(SystemIndexDescriptor.VERSION_META_KEY, 1);\n                builder.endObject();\n\n                builder.field(\"dynamic\", \"strict\");", "refactored_code": "    private static final int QUERY_RULES_INDEX_MAPPINGS_VERSION = 1;\n            {\n                builder.startObject(\"_meta\");\n                builder.field(\"version\", Version.CURRENT.toString());\n                builder.field(SystemIndexDescriptor.VERSION_META_KEY, QUERY_RULES_INDEX_MAPPINGS_VERSION);\n                builder.endObject();\n\n                builder.field(\"dynamic\", \"strict\");"}
{"magic_number_smell": "            {\n                builder.startObject(\"_meta\");\n                builder.field(\"version\", Version.CURRENT.toString());\n                builder.field(SystemIndexDescriptor.VERSION_META_KEY, 1);\n                builder.endObject();\n\n                builder.field(\"dynamic\", \"strict\");", "refactored_code": "    private static final int SEARCH_APPLICATION_INDEX_MAPPINGS_VERSION = 1;\n            {\n                builder.startObject(\"_meta\");\n                builder.field(\"version\", Version.CURRENT.toString());\n                builder.field(SystemIndexDescriptor.VERSION_META_KEY, SEARCH_APPLICATION_INDEX_MAPPINGS_VERSION);\n                builder.endObject();\n\n                builder.field(\"dynamic\", \"strict\");"}
{"magic_number_smell": "                latch.countDown();\n            }\n        });\n        assertTrue(\"Timeout waiting for delete request\", latch.await(10, TimeUnit.SECONDS));\n        if (exc.get() != null) {\n            throw exc.get();\n        }", "refactored_code": "    private static final int REQUEST_TIMEOUT_SECONDS = 10;\n                latch.countDown();\n            }\n        });\n        assertTrue(\"Timeout waiting for delete request\", latch.await(REQUEST_TIMEOUT_SECONDS, TimeUnit.SECONDS));\n        if (exc.get() != null) {\n            throw exc.get();\n        }"}
{"magic_number_smell": "            throw exception.get();\n        }\n\n        boolean requestTimedOut = latch.await(10, TimeUnit.SECONDS);\n        PostConnectorSecretResponse response = responseRef.get();\n\n        assertTrue(\"Timeout waiting for post request\", requestTimedOut);", "refactored_code": "    private static final int TIMEOUT_SECONDS = 10;\n            throw exception.get();\n        }\n\n        boolean requestTimedOut = latch.await(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n        PostConnectorSecretResponse response = responseRef.get();\n\n        assertTrue(\"Timeout waiting for post request\", requestTimedOut);"}
{"magic_number_smell": "        ActionFuture<DocWriteResponse> index = client().index(indexRequest);\n\n        // wait 10 seconds for connector creation\n        return index.get(10, TimeUnit.SECONDS).getId();\n    }\n\n    public void testCreateConnectorSyncJob() throws Exception {", "refactored_code": "    private static final int TIMEOUT_SECONDS = 10;\n        ActionFuture<DocWriteResponse> index = client().index(indexRequest);\n\n        // wait 10 seconds for connector creation\n        return index.get(TIMEOUT_SECONDS, TimeUnit.SECONDS).getId();\n    }\n\n    public void testCreateConnectorSyncJob() throws Exception {"}
{"magic_number_smell": "                latch.countDown();\n            }\n        });\n        assertTrue(\"Timeout waiting for put request\", latch.await(10, TimeUnit.SECONDS));\n        if (exc.get() != null) {\n            throw exc.get();\n        }", "refactored_code": "    private static final int REQUEST_TIMEOUT_SECONDS = 10;\n                latch.countDown();\n            }\n        });\n        assertTrue(\"Timeout waiting for put request\", latch.await(REQUEST_TIMEOUT_SECONDS, TimeUnit.SECONDS));\n        if (exc.get() != null) {\n            throw exc.get();\n        }"}
{"magic_number_smell": "        clusterService = getInstanceFromNode(ClusterService.class);\n        BigArrays bigArrays = getInstanceFromNode(BigArrays.class);\n        this.searchAppService = new SearchApplicationIndexService(client(), clusterService, writableRegistry(), bigArrays);\n        for (int i = 0; i < 10; i++) {\n            client().admin().indices().prepareCreate(\"index_\" + i).execute().get();\n        }\n    }", "refactored_code": "    private static final int NUM_INDICES = 10;\n        clusterService = getInstanceFromNode(ClusterService.class);\n        BigArrays bigArrays = getInstanceFromNode(BigArrays.class);\n        this.searchAppService = new SearchApplicationIndexService(client(), clusterService, writableRegistry(), bigArrays);\n        for (int i = 0; i < NUM_INDICES; i++) {\n            client().admin().indices().prepareCreate(\"index_\" + i).execute().get();\n        }\n    }"}
{"magic_number_smell": "\n    public static long winFileTimeToUnix(final long filetime) {\n        long ts = (filetime / FILETIME_ONE_MILLISECOND);\n        return ts - 11644473600000L;\n    }\n\n    private static XContentParser createParser(XContent xContent, InputStream data) throws IOException {", "refactored_code": "    private static final long FILETIME_EPOCH_DIFF = 11644473600000L; // millis delta from the start of year 1601 (Windows filetime) to 1970\n\n    public static long winFileTimeToUnix(final long filetime) {\n        long ts = (filetime / FILETIME_ONE_MILLISECOND);\n        return ts - FILETIME_EPOCH_DIFF;\n    }\n\n    private static XContentParser createParser(XContent xContent, InputStream data) throws IOException {"}
{"magic_number_smell": "    }\n\n    protected static TimeValue timeout() {\n        return TimeValue.timeValueSeconds(40L);\n    }\n\n    // returned client is used to load the test data, either in the local cluster (for rest/javaRestTests) or a remote one (for", "refactored_code": "    private static final long CLIENT_TIMEOUT = 40L; // upped from 10s to accomodate for max measured throughput decline\n    }\n\n    protected static TimeValue timeout() {\n        return TimeValue.timeValueSeconds(CLIENT_TIMEOUT);\n    }\n\n    // returned client is used to load the test data, either in the local cluster (for rest/javaRestTests) or a remote one (for"}
{"magic_number_smell": "                }\n\n                boolean hasNullValue = false;\n                Set<Object> keyValues = Sets.newHashSetWithExpectedSize(BoxedQueryRequest.128);\n                // check the given keys but make sure to double check for\n                // null as it translates to a different query (missing/not exists)\n                for (List<Object> value : values) {", "refactored_code": "    public static final int MAX_TERMS = 128;\n                }\n\n                boolean hasNullValue = false;\n                Set<Object> keyValues = Sets.newHashSetWithExpectedSize(BoxedQueryRequest.MAX_TERMS);\n                // check the given keys but make sure to double check for\n                // null as it translates to a different query (missing/not exists)\n                for (List<Object> value : values) {"}
{"magic_number_smell": "     * Sample assembler\n     */\n    public Executable assemble(List<List<Attribute>> listOfKeys, List<PhysicalPlan> plans, Limit limit) {\n        if (cfg.fetchSize() > 1000) {\n            throw new InvalidArgumentException(\"Fetch size cannot be greater than [{}]\", 1000);\n        }\n", "refactored_code": "    private static final int SAMPLE_MAX_PAGE_SIZE = 1000;\n     * Sample assembler\n     */\n    public Executable assemble(List<List<Attribute>> listOfKeys, List<PhysicalPlan> plans, Limit limit) {\n        if (cfg.fetchSize() > SAMPLE_MAX_PAGE_SIZE) {\n            throw new InvalidArgumentException(\"Fetch size cannot be greater than [{}]\", SAMPLE_MAX_PAGE_SIZE);\n        }\n"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        return RamUsageEstimator.shallowSizeOfInstance(Sample.class) + RamUsageEstimator.sizeOf(key) + RamUsageEstimator.sizeOf(matches);\n    }\n\n    @Override", "refactored_code": "    private static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(Sample.class);\n\n    @Override\n    public long ramBytesUsed() {\n        return SHALLOW_SIZE + RamUsageEstimator.sizeOf(key) + RamUsageEstimator.sizeOf(matches);\n    }\n\n    @Override"}
{"magic_number_smell": "    protected void pushToStack(Page nextPage) {\n        stack.push(nextPage);\n        totalPageSize += nextPage.size;\n        if (totalPageSize - previousTotalPageSize >= 1000) {\n            updateMemoryUsage();\n            previousTotalPageSize = totalPageSize;\n        }", "refactored_code": "    protected static final int CB_STACK_SIZE_PRECISION = 1000;\n    protected void pushToStack(Page nextPage) {\n        stack.push(nextPage);\n        totalPageSize += nextPage.size;\n        if (totalPageSize - previousTotalPageSize >= CB_STACK_SIZE_PRECISION) {\n            updateMemoryUsage();\n            previousTotalPageSize = totalPageSize;\n        }"}
{"magic_number_smell": "    @Override\n    public long ramBytesUsed() {\n        // index string is cached in TumblingWindow and there is no need of accounting for it\n        return RamUsageEstimator.shallowSizeOfInstance(HitReference.class) + RamUsageEstimator.sizeOf(id);\n    }\n\n    @Override", "refactored_code": "    private static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(HitReference.class);\n    @Override\n    public long ramBytesUsed() {\n        // index string is cached in TumblingWindow and there is no need of accounting for it\n        return SHALLOW_SIZE + RamUsageEstimator.sizeOf(id);\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        return RamUsageEstimator.shallowSizeOfInstance(Ordinal.class);\n    }\n\n    @Override", "refactored_code": "    private static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(Ordinal.class);\n\n    @Override\n    public long ramBytesUsed() {\n        return SHALLOW_SIZE;\n    }\n\n    @Override"}
{"magic_number_smell": "\n        @Override\n        public long ramBytesUsed() {\n            long size = RamUsageEstimator.shallowSizeOfInstance(SequenceEntry.class);\n            if (until != null) {\n                size += until.ramBytesUsed();\n            }", "refactored_code": "        private static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(SequenceEntry.class);\n\n        @Override\n        public long ramBytesUsed() {\n            long size = SHALLOW_SIZE;\n            if (until != null) {\n                size += until.ramBytesUsed();\n            }"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        return RamUsageEstimator.shallowSizeOfInstance(Match.class) + RamUsageEstimator.sizeOf(ordinal) + RamUsageEstimator.sizeOf(hit);\n    }\n\n    @Override", "refactored_code": "    private static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(Match.class);\n\n    @Override\n    public long ramBytesUsed() {\n        return SHALLOW_SIZE + RamUsageEstimator.sizeOf(ordinal) + RamUsageEstimator.sizeOf(hit);\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        return RamUsageEstimator.shallowSizeOfInstance(OrdinalGroup.class) + RamUsageEstimator.sizeOfCollection(elements);\n    }\n\n    @Override", "refactored_code": "    private static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(OrdinalGroup.class);\n\n    @Override\n    public long ramBytesUsed() {\n        return SHALLOW_SIZE + RamUsageEstimator.sizeOfCollection(elements);\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        return RamUsageEstimator.shallowSizeOfInstance(Sequence.class) + RamUsageEstimator.sizeOf(key) + RamUsageEstimator.sizeOf(matches);\n    }\n\n    @Override", "refactored_code": "    private static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(Sequence.class);\n\n    @Override\n    public long ramBytesUsed() {\n        return SHALLOW_SIZE + RamUsageEstimator.sizeOf(key) + RamUsageEstimator.sizeOf(matches);\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        return RamUsageEstimator.shallowSizeOfInstance(SequenceKey.class) + RamUsageEstimator.sizeOfObject(keys);\n    }\n\n    @Override", "refactored_code": "    private static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(SequenceKey.class);\n\n    @Override\n    public long ramBytesUsed() {\n        return SHALLOW_SIZE + RamUsageEstimator.sizeOfObject(keys);\n    }\n\n    @Override"}
{"magic_number_smell": "    private final Map<String, String> stringCache = new LinkedHashMap<>(16, 0.75f, true) {\n        @Override\n        protected boolean removeEldestEntry(Map.Entry<String, String> eldest) {\n            return this.size() >= 64;\n        }\n    };\n", "refactored_code": "    private static final int CACHE_MAX_SIZE = 64;\n    private final Map<String, String> stringCache = new LinkedHashMap<>(16, 0.75f, true) {\n        @Override\n        protected boolean removeEldestEntry(Map.Entry<String, String> eldest) {\n            return this.size() >= CACHE_MAX_SIZE;\n        }\n    };\n"}
{"magic_number_smell": "\n            queries.add(joinTerm);\n            int numberOfQueries = queries.size();\n            if (numberOfQueries > 5) {\n                throw new ParsingException(\n                    source(joinTermCtx),\n                    \"A sample cannot contain more than {} queries, found [{}]\",", "refactored_code": "    private static final int MAX_SAMPLE_QUERIES = 5;\n\n            queries.add(joinTerm);\n            int numberOfQueries = queries.size();\n            if (numberOfQueries > MAX_SAMPLE_QUERIES) {\n                throw new ParsingException(\n                    source(joinTermCtx),\n                    \"A sample cannot contain more than {} queries, found [{}]\","}
{"magic_number_smell": "    private final int randomIntBetween(3, 10) = randomIntBetween(3, 10);\n\n    public ImplicitTiebreakerTests() {\n        this.implicitTiebreakerValues = new ArrayList<>(randomIntBetween(3, 10));\n        for (int i = 0; i < randomIntBetween(3, 10); i++) {\n            implicitTiebreakerValues.add(randomLong());\n        }", "refactored_code": "    private final int stages = randomIntBetween(3, 10);\n    private final int stages = randomIntBetween(3, 10);\n\n    public ImplicitTiebreakerTests() {\n        this.implicitTiebreakerValues = new ArrayList<>(stages);\n        for (int i = 0; i < stages; i++) {\n            implicitTiebreakerValues.add(randomLong());\n        }"}
{"magic_number_smell": "\n    public void testCircuitBreakerTumblingWindow() {\n        QueryClient client = new TestQueryClient();\n        List<SequenceCriterion> criteria = buildCriteria(randomIntBetween(3, 10));\n\n        SequenceMatcher matcher = new SequenceMatcher(\n            randomIntBetween(3, 10),", "refactored_code": "    private final int stages = randomIntBetween(3, 10);\n\n    public void testCircuitBreakerTumblingWindow() {\n        QueryClient client = new TestQueryClient();\n        List<SequenceCriterion> criteria = buildCriteria(stages);\n\n        SequenceMatcher matcher = new SequenceMatcher(\n            stages,"}
{"magic_number_smell": "    protected static final int 20 = 20;\n\n    protected static void run(Callable<Void> callable) throws Exception {\n        for (int runs = 0; runs < 20; runs++) {\n            callable.call();\n        }\n    }", "refactored_code": "    protected static final int NUMBER_OF_TEST_RUNS = 20;\n    protected static final int NUMBER_OF_TEST_RUNS = 20;\n\n    protected static void run(Callable<Void> callable) throws Exception {\n        for (int runs = 0; runs < NUMBER_OF_TEST_RUNS; runs++) {\n            callable.call();\n        }\n    }"}
{"magic_number_smell": "    }\n\n    private long ramBytesUsedOnlyBlock() {\n        return RamUsageEstimator.shallowSizeOfInstance(BooleanArrayBlock.class) + BlockRamUsageEstimator.sizeOf(firstValueIndexes) + BlockRamUsageEstimator.sizeOfBitSet(nullsMask);\n    }\n\n    @Override", "refactored_code": "    private static final long BASE_RAM_BYTES_USED = RamUsageEstimator.shallowSizeOfInstance(BooleanArrayBlock.class);\n    }\n\n    private long ramBytesUsedOnlyBlock() {\n        return BASE_RAM_BYTES_USED + BlockRamUsageEstimator.sizeOf(firstValueIndexes) + BlockRamUsageEstimator.sizeOfBitSet(nullsMask);\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    private long ramBytesUsedOnlyBlock() {\n        return 0 + BlockRamUsageEstimator.sizeOf(firstValueIndexes) + BlockRamUsageEstimator.sizeOfBitSet(nullsMask);\n    }\n\n    @Override", "refactored_code": "    private static final long BASE_RAM_BYTES_USED = 0; // TODO: fix this\n    }\n\n    private long ramBytesUsedOnlyBlock() {\n        return BASE_RAM_BYTES_USED + BlockRamUsageEstimator.sizeOf(firstValueIndexes) + BlockRamUsageEstimator.sizeOfBitSet(nullsMask);\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        return 0 + RamUsageEstimator.sizeOf(values);\n    }\n\n    @Override", "refactored_code": "    private static final long BASE_RAM_BYTES_USED = 0; // FIXME\n\n    @Override\n    public long ramBytesUsed() {\n        return BASE_RAM_BYTES_USED + RamUsageEstimator.sizeOf(values);\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    private long ramBytesUsedOnlyBlock() {\n        return RamUsageEstimator.shallowSizeOfInstance(BytesRefArrayBlock.class) + BlockRamUsageEstimator.sizeOf(firstValueIndexes) + BlockRamUsageEstimator.sizeOfBitSet(nullsMask);\n    }\n\n    @Override", "refactored_code": "    private static final long BASE_RAM_BYTES_USED = RamUsageEstimator.shallowSizeOfInstance(BytesRefArrayBlock.class);\n    }\n\n    private long ramBytesUsedOnlyBlock() {\n        return BASE_RAM_BYTES_USED + BlockRamUsageEstimator.sizeOf(firstValueIndexes) + BlockRamUsageEstimator.sizeOfBitSet(nullsMask);\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    private long ramBytesUsedOnlyBlock() {\n        return RamUsageEstimator.shallowSizeOfInstance(DoubleArrayBlock.class) + BlockRamUsageEstimator.sizeOf(firstValueIndexes) + BlockRamUsageEstimator.sizeOfBitSet(nullsMask);\n    }\n\n    @Override", "refactored_code": "    private static final long BASE_RAM_BYTES_USED = RamUsageEstimator.shallowSizeOfInstance(DoubleArrayBlock.class);\n    }\n\n    private long ramBytesUsedOnlyBlock() {\n        return BASE_RAM_BYTES_USED + BlockRamUsageEstimator.sizeOf(firstValueIndexes) + BlockRamUsageEstimator.sizeOfBitSet(nullsMask);\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    private long ramBytesUsedOnlyBlock() {\n        return 0 + BlockRamUsageEstimator.sizeOf(firstValueIndexes) + BlockRamUsageEstimator.sizeOfBitSet(nullsMask);\n    }\n\n    @Override", "refactored_code": "    private static final long BASE_RAM_BYTES_USED = 0; // TODO: fix this\n    }\n\n    private long ramBytesUsedOnlyBlock() {\n        return BASE_RAM_BYTES_USED + BlockRamUsageEstimator.sizeOf(firstValueIndexes) + BlockRamUsageEstimator.sizeOfBitSet(nullsMask);\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        return 0 + RamUsageEstimator.sizeOf(values);\n    }\n\n    @Override", "refactored_code": "    private static final long BASE_RAM_BYTES_USED = 0; // FIXME\n\n    @Override\n    public long ramBytesUsed() {\n        return BASE_RAM_BYTES_USED + RamUsageEstimator.sizeOf(values);\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    private long ramBytesUsedOnlyBlock() {\n        return RamUsageEstimator.shallowSizeOfInstance(IntArrayBlock.class) + BlockRamUsageEstimator.sizeOf(firstValueIndexes) + BlockRamUsageEstimator.sizeOfBitSet(nullsMask);\n    }\n\n    @Override", "refactored_code": "    private static final long BASE_RAM_BYTES_USED = RamUsageEstimator.shallowSizeOfInstance(IntArrayBlock.class);\n    }\n\n    private long ramBytesUsedOnlyBlock() {\n        return BASE_RAM_BYTES_USED + BlockRamUsageEstimator.sizeOf(firstValueIndexes) + BlockRamUsageEstimator.sizeOfBitSet(nullsMask);\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    private long ramBytesUsedOnlyBlock() {\n        return 0 + BlockRamUsageEstimator.sizeOf(firstValueIndexes) + BlockRamUsageEstimator.sizeOfBitSet(nullsMask);\n    }\n\n    @Override", "refactored_code": "    private static final long BASE_RAM_BYTES_USED = 0; // TODO: fix this\n    }\n\n    private long ramBytesUsedOnlyBlock() {\n        return BASE_RAM_BYTES_USED + BlockRamUsageEstimator.sizeOf(firstValueIndexes) + BlockRamUsageEstimator.sizeOfBitSet(nullsMask);\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        return 0 + RamUsageEstimator.sizeOf(values);\n    }\n\n    @Override", "refactored_code": "    private static final long BASE_RAM_BYTES_USED = 0; // FIXME\n\n    @Override\n    public long ramBytesUsed() {\n        return BASE_RAM_BYTES_USED + RamUsageEstimator.sizeOf(values);\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    private long ramBytesUsedOnlyBlock() {\n        return RamUsageEstimator.shallowSizeOfInstance(LongArrayBlock.class) + BlockRamUsageEstimator.sizeOf(firstValueIndexes) + BlockRamUsageEstimator.sizeOfBitSet(nullsMask);\n    }\n\n    @Override", "refactored_code": "    private static final long BASE_RAM_BYTES_USED = RamUsageEstimator.shallowSizeOfInstance(LongArrayBlock.class);\n    }\n\n    private long ramBytesUsedOnlyBlock() {\n        return BASE_RAM_BYTES_USED + BlockRamUsageEstimator.sizeOf(firstValueIndexes) + BlockRamUsageEstimator.sizeOfBitSet(nullsMask);\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    private long ramBytesUsedOnlyBlock() {\n        return 0 + BlockRamUsageEstimator.sizeOf(firstValueIndexes) + BlockRamUsageEstimator.sizeOfBitSet(nullsMask);\n    }\n\n    @Override", "refactored_code": "    private static final long BASE_RAM_BYTES_USED = 0; // TODO: fix this\n    }\n\n    private long ramBytesUsedOnlyBlock() {\n        return BASE_RAM_BYTES_USED + BlockRamUsageEstimator.sizeOf(firstValueIndexes) + BlockRamUsageEstimator.sizeOfBitSet(nullsMask);\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        return 0 + RamUsageEstimator.sizeOf(values);\n    }\n\n    @Override", "refactored_code": "    private static final long BASE_RAM_BYTES_USED = 0; // FIXME\n\n    @Override\n    public long ramBytesUsed() {\n        return BASE_RAM_BYTES_USED + RamUsageEstimator.sizeOf(values);\n    }\n\n    @Override"}
{"magic_number_smell": "                         * you may as well have just gone with either of the two other\n                         * strategies. So we just don't try it for now.\n                         */\n                        if (count < 20) {\n                            copyMissing(first, count);\n                            writeUniquedWork(builder);\n                        } else {", "refactored_code": "    private static final int ALWAYS_COPY_MISSING = 20;  // TODO BytesRef should try adding to the hash *first* and then comparing.\n                         * you may as well have just gone with either of the two other\n                         * strategies. So we just don't try it for now.\n                         */\n                        if (count < ALWAYS_COPY_MISSING) {\n                            copyMissing(first, count);\n                            writeUniquedWork(builder);\n                        } else {"}
{"magic_number_smell": "                         * you may as well have just gone with either of the two other\n                         * strategies. So we just don't try it for now.\n                         */\n                        if (count < 110) {\n                            copyMissing(first, count);\n                            writeUniquedWork(builder);\n                        } else {", "refactored_code": "    private static final int ALWAYS_COPY_MISSING = 110;\n                         * you may as well have just gone with either of the two other\n                         * strategies. So we just don't try it for now.\n                         */\n                        if (count < ALWAYS_COPY_MISSING) {\n                            copyMissing(first, count);\n                            writeUniquedWork(builder);\n                        } else {"}
{"magic_number_smell": "                         * you may as well have just gone with either of the two other\n                         * strategies. So we just don't try it for now.\n                         */\n                        if (count < 300) {\n                            copyMissing(first, count);\n                            writeUniquedWork(builder);\n                        } else {", "refactored_code": "    private static final int ALWAYS_COPY_MISSING = 300;\n                         * you may as well have just gone with either of the two other\n                         * strategies. So we just don't try it for now.\n                         */\n                        if (count < ALWAYS_COPY_MISSING) {\n                            copyMissing(first, count);\n                            writeUniquedWork(builder);\n                        } else {"}
{"magic_number_smell": "                         * you may as well have just gone with either of the two other\n                         * strategies. So we just don't try it for now.\n                         */\n                        if (count < 300) {\n                            copyMissing(first, count);\n                            writeUniquedWork(builder);\n                        } else {", "refactored_code": "    private static final int ALWAYS_COPY_MISSING = 300;\n                         * you may as well have just gone with either of the two other\n                         * strategies. So we just don't try it for now.\n                         */\n                        if (count < ALWAYS_COPY_MISSING) {\n                            copyMissing(first, count);\n                            writeUniquedWork(builder);\n                        } else {"}
{"magic_number_smell": "    }\n\n    public static void combine(SingleState current, boolean v) {\n        current.bits |= v ? BIT_TRUE : 0b01;\n    }\n\n    public static void combineIntermediate(SingleState current, boolean fbit, boolean tbit) {", "refactored_code": "    private static final byte BIT_FALSE = 0b01;\n    }\n\n    public static void combine(SingleState current, boolean v) {\n        current.bits |= v ? BIT_TRUE : BIT_FALSE;\n    }\n\n    public static void combineIntermediate(SingleState current, boolean fbit, boolean tbit) {"}
{"magic_number_smell": "        }\n\n        private void doCollect(long hash) {\n            hll.collect(0, hash);\n        }\n\n        long cardinality() {", "refactored_code": "        private static final int SINGLE_BUCKET_ORD = 0;\n        }\n\n        private void doCollect(long hash) {\n            hll.collect(SINGLE_BUCKET_ORD, hash);\n        }\n\n        long cardinality() {"}
{"magic_number_smell": "\n        Block evaluateMedianAbsoluteDeviation(DriverContext driverContext) {\n            BlockFactory blockFactory = driverContext.blockFactory();\n            assert percentile == 50.0 : \"Median must be 50th percentile [percentile = \" + percentile + \"]\";\n            if (digest.size() == 0) {\n                return blockFactory.newConstantNullBlock(1);\n            }", "refactored_code": "    public static final double MEDIAN = 50.0;\n\n        Block evaluateMedianAbsoluteDeviation(DriverContext driverContext) {\n            BlockFactory blockFactory = driverContext.blockFactory();\n            assert percentile == MEDIAN : \"Median must be 50th percentile [percentile = \" + percentile + \"]\";\n            if (digest.size() == 0) {\n                return blockFactory.newConstantNullBlock(1);\n            }"}
{"magic_number_smell": "    public static long sizeOfBitSet(long size) {\n        // BitSet is normally made up of words, represented by longs. So we need to divide and round up.\n        long wordCount = (size + Long.SIZE - 1) / Long.SIZE;\n        return RamUsageEstimator.shallowSizeOfInstance(BitSet.class) + wordCount * Long.BYTES;\n    }\n}\n", "refactored_code": "    private static final long BITSET_BASE_RAM_USAGE = RamUsageEstimator.shallowSizeOfInstance(BitSet.class);\n    public static long sizeOfBitSet(long size) {\n        // BitSet is normally made up of words, represented by longs. So we need to divide and round up.\n        long wordCount = (size + Long.SIZE - 1) / Long.SIZE;\n        return BITSET_BASE_RAM_USAGE + wordCount * Long.BYTES;\n    }\n}\n"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        return RamUsageEstimator.shallowSizeOfInstance(ConstantNullBlock.class);\n    }\n\n    @Override", "refactored_code": "    private static final long BASE_RAM_BYTES_USED = RamUsageEstimator.shallowSizeOfInstance(ConstantNullBlock.class);\n\n    @Override\n    public long ramBytesUsed() {\n        return BASE_RAM_BYTES_USED;\n    }\n\n    @Override"}
{"magic_number_smell": "                \"invalid position count [\" + shards.getPositionCount() + \" != \" + docs.getPositionCount() + \"]\"\n            );\n        }\n        blockFactory().adjustBreaker(RamUsageEstimator.shallowSizeOfInstance(DocVector.class));\n    }\n\n    public IntVector shards() {", "refactored_code": "    private static final long BASE_RAM_BYTES_USED = RamUsageEstimator.shallowSizeOfInstance(DocVector.class);\n                \"invalid position count [\" + shards.getPositionCount() + \" != \" + docs.getPositionCount() + \"]\"\n            );\n        }\n        blockFactory().adjustBreaker(BASE_RAM_BYTES_USED);\n    }\n\n    public IntVector shards() {"}
{"magic_number_smell": "    }\n\n    public LuceneCountOperator(BlockFactory blockFactory, LuceneSliceQueue sliceQueue, int limit) {\n        super(blockFactory, 1, sliceQueue);\n        this.remainingDocs = limit;\n        this.leafCollector = new LeafCollector() {\n            @Override", "refactored_code": "    private static final int PAGE_SIZE = 1;\n    }\n\n    public LuceneCountOperator(BlockFactory blockFactory, LuceneSliceQueue sliceQueue, int limit) {\n        super(blockFactory, PAGE_SIZE, sliceQueue);\n        this.remainingDocs = limit;\n        this.leafCollector = new LeafCollector() {\n            @Override"}
{"magic_number_smell": "    }\n\n    static List<List<PartialLeafReaderContext>> segmentSlices(List<LeafReaderContext> leafContexts) {\n        IndexSearcher.LeafSlice[] gs = IndexSearcher.slices(leafContexts, 250_000, MAX_SEGMENTS_PER_SLICE);\n        return Arrays.stream(gs).map(g -> Arrays.stream(g.leaves).map(PartialLeafReaderContext::new).toList()).toList();\n    }\n}", "refactored_code": "    private static final int MAX_DOCS_PER_SLICE = 250_000; // copied from IndexSearcher\n    }\n\n    static List<List<PartialLeafReaderContext>> segmentSlices(List<LeafReaderContext> leafContexts) {\n        IndexSearcher.LeafSlice[] gs = IndexSearcher.slices(leafContexts, MAX_DOCS_PER_SLICE, MAX_SEGMENTS_PER_SLICE);\n        return Arrays.stream(gs).map(g -> Arrays.stream(g.leaves).map(PartialLeafReaderContext::new).toList()).toList();\n    }\n}"}
{"magic_number_smell": "\n        @Override\n        public long ramBytesUsed() {\n            return RamUsageEstimator.shallowSizeOfInstance(MVEncoder.class) + RamUsageEstimator.sizeOf(counts) + RamUsageEstimator.sizeOf(valueOffsets);\n        }\n\n        /**", "refactored_code": "        private static final long SHALLOW_SIZE = RamUsageEstimator.shallowSizeOfInstance(MVEncoder.class);\n\n        @Override\n        public long ramBytesUsed() {\n            return SHALLOW_SIZE + RamUsageEstimator.sizeOf(counts) + RamUsageEstimator.sizeOf(valueOffsets);\n        }\n\n        /**"}
{"magic_number_smell": "                int first = block.getFirstValueIndex(p);\n                switch (count) {\n                    case 0 -> {\n                        everSeen[0] = true;\n                        builder.appendInt(0);\n                    }\n                    case 1 -> builder.appendInt(hashOrd(everSeen, block.getBoolean(first)));", "refactored_code": "    public static final int NULL_ORD = 0;\n                int first = block.getFirstValueIndex(p);\n                switch (count) {\n                    case 0 -> {\n                        everSeen[NULL_ORD] = true;\n                        builder.appendInt(NULL_ORD);\n                    }\n                    case 1 -> builder.appendInt(hashOrd(everSeen, block.getBoolean(first)));"}
{"magic_number_smell": "\n        byte nul() {\n            if (nullsFirst) {\n                return asc ? 0x01 : BIG_NULL;\n            } else {\n                return asc ? BIG_NULL : 0x01;\n            }", "refactored_code": "    private static final byte SMALL_NULL = 0x01; // \"null\" representation for \"nulls first\"\n\n        byte nul() {\n            if (nullsFirst) {\n                return asc ? SMALL_NULL : BIG_NULL;\n            } else {\n                return asc ? BIG_NULL : SMALL_NULL;\n            }"}
{"magic_number_smell": "        int end = value.offset + value.length;\n        for (int i = value.offset; i < end; i++) {\n            byte b = value.bytes[i];\n            if ((b & 0b1000_0000) == 0) {\n                b++;\n            }\n            bytesRefBuilder.append(b);", "refactored_code": "    private static final int CONTINUATION_BYTE = 0b1000_0000;\n        int end = value.offset + value.length;\n        for (int i = value.offset; i < end; i++) {\n            byte b = value.bytes[i];\n            if ((b & CONTINUATION_BYTE) == 0) {\n                b++;\n            }\n            bytesRefBuilder.append(b);"}
{"magic_number_smell": "    private final List<Tuple<Long, Boolean>> values;\n\n    public LongBooleanTupleBlockSourceOperator(BlockFactory blockFactory, Stream<Tuple<Long, Boolean>> values) {\n        this(blockFactory, values, 8 * 1024);\n    }\n\n    public LongBooleanTupleBlockSourceOperator(BlockFactory blockFactory, Stream<Tuple<Long, Boolean>> values, int maxPagePositions) {", "refactored_code": "    private static final int DEFAULT_MAX_PAGE_POSITIONS = 8 * 1024;\n    private final List<Tuple<Long, Boolean>> values;\n\n    public LongBooleanTupleBlockSourceOperator(BlockFactory blockFactory, Stream<Tuple<Long, Boolean>> values) {\n        this(blockFactory, values, DEFAULT_MAX_PAGE_POSITIONS);\n    }\n\n    public LongBooleanTupleBlockSourceOperator(BlockFactory blockFactory, Stream<Tuple<Long, Boolean>> values, int maxPagePositions) {"}
{"magic_number_smell": "    private final List<Tuple<Long, BytesRef>> values;\n\n    public LongBytesRefTupleBlockSourceOperator(BlockFactory blockFactory, Stream<Tuple<Long, BytesRef>> values) {\n        this(blockFactory, values, 8 * 1024);\n    }\n\n    public LongBytesRefTupleBlockSourceOperator(BlockFactory blockFactory, Stream<Tuple<Long, BytesRef>> values, int maxPagePositions) {", "refactored_code": "    private static final int DEFAULT_MAX_PAGE_POSITIONS = 8 * 1024;\n    private final List<Tuple<Long, BytesRef>> values;\n\n    public LongBytesRefTupleBlockSourceOperator(BlockFactory blockFactory, Stream<Tuple<Long, BytesRef>> values) {\n        this(blockFactory, values, DEFAULT_MAX_PAGE_POSITIONS);\n    }\n\n    public LongBytesRefTupleBlockSourceOperator(BlockFactory blockFactory, Stream<Tuple<Long, BytesRef>> values, int maxPagePositions) {"}
{"magic_number_smell": "    private final List<Tuple<Long, Double>> values;\n\n    public LongDoubleTupleBlockSourceOperator(BlockFactory blockFactory, Stream<Tuple<Long, Double>> values) {\n        this(blockFactory, values, 8 * 1024);\n    }\n\n    public LongDoubleTupleBlockSourceOperator(BlockFactory blockFactory, Stream<Tuple<Long, Double>> values, int maxPagePositions) {", "refactored_code": "    private static final int DEFAULT_MAX_PAGE_POSITIONS = 8 * 1024;\n    private final List<Tuple<Long, Double>> values;\n\n    public LongDoubleTupleBlockSourceOperator(BlockFactory blockFactory, Stream<Tuple<Long, Double>> values) {\n        this(blockFactory, values, DEFAULT_MAX_PAGE_POSITIONS);\n    }\n\n    public LongDoubleTupleBlockSourceOperator(BlockFactory blockFactory, Stream<Tuple<Long, Double>> values, int maxPagePositions) {"}
{"magic_number_smell": "    private final List<Tuple<Long, Integer>> values;\n\n    public LongIntBlockSourceOperator(BlockFactory blockFactory, Stream<Tuple<Long, Integer>> values) {\n        this(blockFactory, values, 8 * 1024);\n    }\n\n    public LongIntBlockSourceOperator(BlockFactory blockFactory, Stream<Tuple<Long, Integer>> values, int maxPagePositions) {", "refactored_code": "    private static final int DEFAULT_MAX_PAGE_POSITIONS = 8 * 1024;\n    private final List<Tuple<Long, Integer>> values;\n\n    public LongIntBlockSourceOperator(BlockFactory blockFactory, Stream<Tuple<Long, Integer>> values) {\n        this(blockFactory, values, DEFAULT_MAX_PAGE_POSITIONS);\n    }\n\n    public LongIntBlockSourceOperator(BlockFactory blockFactory, Stream<Tuple<Long, Integer>> values, int maxPagePositions) {"}
{"magic_number_smell": "    private final List<Tuple<Long, Long>> values;\n\n    public TupleBlockSourceOperator(BlockFactory blockFactory, Stream<Tuple<Long, Long>> values) {\n        this(blockFactory, values, 8 * 1024);\n    }\n\n    public TupleBlockSourceOperator(BlockFactory blockFactory, Stream<Tuple<Long, Long>> values, int maxPagePositions) {", "refactored_code": "    private static final int DEFAULT_MAX_PAGE_POSITIONS = 8 * 1024;\n    private final List<Tuple<Long, Long>> values;\n\n    public TupleBlockSourceOperator(BlockFactory blockFactory, Stream<Tuple<Long, Long>> values) {\n        this(blockFactory, values, DEFAULT_MAX_PAGE_POSITIONS);\n    }\n\n    public TupleBlockSourceOperator(BlockFactory blockFactory, Stream<Tuple<Long, Long>> values, int maxPagePositions) {"}
{"magic_number_smell": "            List.of(LONG),\n            List.of(DEFAULT_UNSORTABLE),\n            List.of(new TopNOperator.SortOrder(0, true, false)),\n            randomPageSize()\n        );\n    }\n", "refactored_code": "    private final int pageSize = randomPageSize();\n            List.of(LONG),\n            List.of(DEFAULT_UNSORTABLE),\n            List.of(new TopNOperator.SortOrder(0, true, false)),\n            pageSize\n        );\n    }\n"}
{"magic_number_smell": "    public void test() {\n        List<String> indices = availableIndices();\n        List<CsvTestsDataLoader.EnrichConfig> policies = availableEnrichPolicies();\n        for (int i = 0; i < 50; i++) {\n            String command = EsqlQueryGenerator.sourceCommand(indices);\n            EsqlQueryGenerator.QueryExecuted result = execute(command, 0);\n            if (result.exception() != null) {", "refactored_code": "    public static final int ITERATIONS = 50;\n    public void test() {\n        List<String> indices = availableIndices();\n        List<CsvTestsDataLoader.EnrichConfig> policies = availableEnrichPolicies();\n        for (int i = 0; i < ITERATIONS; i++) {\n            String command = EsqlQueryGenerator.sourceCommand(indices);\n            EsqlQueryGenerator.QueryExecuted result = execute(command, 0);\n            if (result.exception() != null) {"}
{"magic_number_smell": "                    }\n                }\n                lineNumber++;\n                if (builder.length() > 100_000) {\n                    sendBulkRequest(indexName, builder, client, logger, failures);\n                    builder.setLength(0);\n                }", "refactored_code": "    private static final int BULK_DATA_SIZE = 100_000;\n                    }\n                }\n                lineNumber++;\n                if (builder.length() > BULK_DATA_SIZE) {\n                    sendBulkRequest(indexName, builder, client, logger, failures);\n                    builder.setLength(0);\n                }"}
{"magic_number_smell": "    }\n\n    private static StringBuilder trimOrPad(StringBuilder buffer) {\n        if (buffer.length() > 20) {\n            buffer.setLength(20 - 1);\n            buffer.append(\"~\");\n        } else {", "refactored_code": "    private static final int MAX_WIDTH = 20;\n    }\n\n    private static StringBuilder trimOrPad(StringBuilder buffer) {\n        if (buffer.length() > MAX_WIDTH) {\n            buffer.setLength(MAX_WIDTH - 1);\n            buffer.append(\"~\");\n        } else {"}
{"magic_number_smell": "    public void testLong() throws InterruptedException, IOException {\n        createIndexWithConstRuntimeField(\"long\");\n        try (EsqlQueryResponse response = run(\"from test | stats sum(const)\")) {\n            assertThat(getValuesList(response), equalTo(List.of(List.of((long) between(10, 100)))));\n        }\n    }\n", "refactored_code": "    private final int SIZE = between(10, 100);\n    public void testLong() throws InterruptedException, IOException {\n        createIndexWithConstRuntimeField(\"long\");\n        try (EsqlQueryResponse response = run(\"from test | stats sum(const)\")) {\n            assertThat(getValuesList(response), equalTo(List.of(List.of((long) SIZE))));\n        }\n    }\n"}
{"magic_number_smell": "                    running = false;\n                }\n\n                return new TimeValue(endTimeNS - System.nanoTime(), TimeUnit.NANOSECONDS);\n            }\n        }\n    }", "refactored_code": "        private final long startTimeNS = System.nanoTime();\n                    running = false;\n                }\n\n                return new TimeValue(endTimeNS - startTimeNS, TimeUnit.NANOSECONDS);\n            }\n        }\n    }"}
{"magic_number_smell": "    @Override\n    public AggregatorFunctionSupplier supplier(List<Integer> inputChannels) {\n        DataType type = field().dataType();\n        int precision = this.precision == null ? 3000 : ((Number) this.precision.fold()).intValue();\n        if (type == DataTypes.BOOLEAN) {\n            // Booleans ignore the precision because there are only two possible values anyway\n            return new CountDistinctBooleanAggregatorFunctionSupplier(inputChannels);", "refactored_code": "    private static final int DEFAULT_PRECISION = 3000;\n    @Override\n    public AggregatorFunctionSupplier supplier(List<Integer> inputChannels) {\n        DataType type = field().dataType();\n        int precision = this.precision == null ? DEFAULT_PRECISION : ((Number) this.precision.fold()).intValue();\n        if (type == DataTypes.BOOLEAN) {\n            // Booleans ignore the precision because there are only two possible values anyway\n            return new CountDistinctBooleanAggregatorFunctionSupplier(inputChannels);"}
{"magic_number_smell": "\n    @Override\n    public Object fold() {\n        return Math.PI * 2;\n    }\n\n    @Override", "refactored_code": "    public static final double TAU = Math.PI * 2;\n\n    @Override\n    public Object fold() {\n        return TAU;\n    }\n\n    @Override"}
{"magic_number_smell": "                }\n\n                b.append(\"\\\"]\\n\");\n                if (b.length() >= 1024 * 64) {\n                    b.append(\"...snip...\");\n                    break too_big;\n                }", "refactored_code": "    private static final int MAX_LENGTH = 1024 * 64;\n                }\n\n                b.append(\"\\\"]\\n\");\n                if (b.length() >= MAX_LENGTH) {\n                    b.append(\"...snip...\");\n                    break too_big;\n                }"}
{"magic_number_smell": "        width = new int[columns.size()];\n        for (int i = 0; i < width.length; i++) {\n            // TODO read the width from the data type?\n            width[i] = Math.max(15, columns.get(i).name().length());\n        }\n\n        // 2. Expand columns to fit the largest value", "refactored_code": "    private static final int MIN_COLUMN_WIDTH = 15;\n        width = new int[columns.size()];\n        for (int i = 0; i < width.length; i++) {\n            // TODO read the width from the data type?\n            width[i] = Math.max(MIN_COLUMN_WIDTH, columns.get(i).name().length());\n        }\n\n        // 2. Expand columns to fit the largest value"}
{"magic_number_smell": "\n        @Override\n        public float matchCost() {\n            return 10;\n        }\n    }\n", "refactored_code": "    private static final int SORTED_NUMERIC_MATCH_COST = 10;\n\n        @Override\n        public float matchCost() {\n            return SORTED_NUMERIC_MATCH_COST;\n        }\n    }\n"}
{"magic_number_smell": "    private static final int 32 = 32;\n\n    // simple non-thread-safe cache for avoiding unnecessary IO (which while fast it still I/O)\n    private final Map<String, FieldStat> cache = new LinkedHashMap<>(32, 0.75f, true) {\n        @Override\n        protected boolean removeEldestEntry(Map.Entry<String, FieldStat> eldest) {\n            return size() > 32;", "refactored_code": "    private static final int CACHE_SIZE = 32;\n    private static final int CACHE_SIZE = 32;\n\n    // simple non-thread-safe cache for avoiding unnecessary IO (which while fast it still I/O)\n    private final Map<String, FieldStat> cache = new LinkedHashMap<>(CACHE_SIZE, 0.75f, true) {\n        @Override\n        protected boolean removeEldestEntry(Map.Entry<String, FieldStat> eldest) {\n            return size() > CACHE_SIZE;"}
{"magic_number_smell": "\n    public void testImplicitMaxLimitAfterLimit() {\n        for (int i = -1; i <= 1; i++) {\n            var plan = analyze(\"from test | limit \" + (EsqlPlugin.QUERY_RESULT_TRUNCATION_MAX_SIZE.getDefault(Settings.EMPTY) + i));\n            var limit = as(plan, Limit.class);\n            assertThat(limit.limit().fold(), equalTo(EsqlPlugin.QUERY_RESULT_TRUNCATION_MAX_SIZE.getDefault(Settings.EMPTY)));\n            limit = as(limit.child(), Limit.class);", "refactored_code": "    private static final int MAX_LIMIT = EsqlPlugin.QUERY_RESULT_TRUNCATION_MAX_SIZE.getDefault(Settings.EMPTY);\n\n    public void testImplicitMaxLimitAfterLimit() {\n        for (int i = -1; i <= 1; i++) {\n            var plan = analyze(\"from test | limit \" + (MAX_LIMIT + i));\n            var limit = as(plan, Limit.class);\n            assertThat(limit.limit().fold(), equalTo(MAX_LIMIT));\n            limit = as(limit.child(), Limit.class);"}
{"magic_number_smell": "    }\n\n    private void strings(List<TestCaseSupplier> suppliers) {\n        for (int count = 1; count < 10; count++) {\n            for (boolean multivalued : new boolean[] { false, true }) {\n                int paramCount = count;\n                suppliers.add(", "refactored_code": "    private static final int MAX_WIDTH = 10;\n    }\n\n    private void strings(List<TestCaseSupplier> suppliers) {\n        for (int count = 1; count < MAX_WIDTH; count++) {\n            for (boolean multivalued : new boolean[] { false, true }) {\n                int paramCount = count;\n                suppliers.add("}
{"magic_number_smell": "        assertThat(order.direction(), is(ASC));\n        assertThat(name(order.field()), is(\"last_name\"));\n        // last name is keyword, salary, emp_no, doc id, segment, forwards and backwards doc id maps are all ints\n        int estimatedSize = EstimatesRowSize.estimateSize(DataTypes.KEYWORD) + Integer.BYTES * 6;\n        assertThat(source.estimatedRowSize(), equalTo(estimatedSize));\n    }\n", "refactored_code": "    private static final int KEYWORD_EST = EstimatesRowSize.estimateSize(DataTypes.KEYWORD);\n        assertThat(order.direction(), is(ASC));\n        assertThat(name(order.field()), is(\"last_name\"));\n        // last name is keyword, salary, emp_no, doc id, segment, forwards and backwards doc id maps are all ints\n        int estimatedSize = KEYWORD_EST + Integer.BYTES * 6;\n        assertThat(source.estimatedRowSize(), equalTo(estimatedSize));\n    }\n"}
{"magic_number_smell": "            .setVersionMetaKey(VERSION_KEY)\n            .setMappings(request.mappings())\n            .setSettings(request.settings())\n            .setPrimaryIndex(\".fleet-actions-\" + 7)\n            .setIndexPattern(\".fleet-actions~(-results*)\")\n            .setAliasName(\".fleet-actions\")\n            .setDescription(\"Fleet agents\")", "refactored_code": "    private static final int CURRENT_INDEX_VERSION = 7;\n            .setVersionMetaKey(VERSION_KEY)\n            .setMappings(request.mappings())\n            .setSettings(request.settings())\n            .setPrimaryIndex(\".fleet-actions-\" + CURRENT_INDEX_VERSION)\n            .setIndexPattern(\".fleet-actions~(-results*)\")\n            .setAliasName(\".fleet-actions\")\n            .setDescription(\"Fleet agents\")"}
{"magic_number_smell": "        new IndexTemplateConfig(\n            \".fleet-fileds-fromhost-meta\",\n            \"/fleet-file-fromhost-meta.json\",\n            1,\n            TEMPLATE_VERSION_VARIABLE\n        ),\n        new IndexTemplateConfig(", "refactored_code": "    public static final int INDEX_TEMPLATE_VERSION = 1;\n        new IndexTemplateConfig(\n            \".fleet-fileds-fromhost-meta\",\n            \"/fleet-file-fromhost-meta.json\",\n            INDEX_TEMPLATE_VERSION,\n            TEMPLATE_VERSION_VARIABLE\n        ),\n        new IndexTemplateConfig("}
{"magic_number_smell": "\n    public static final Setting<Integer> CACHE_SIZE = Setting.intSetting(\n        \"xpack.idp.privileges.cache.size\",\n        100,\n        Setting.Property.NodeScope\n    );\n    public static final Setting<TimeValue> CACHE_TTL = Setting.timeSetting(", "refactored_code": "    private static final int CACHE_SIZE_DEFAULT = 100;\n\n    public static final Setting<Integer> CACHE_SIZE = Setting.intSetting(\n        \"xpack.idp.privileges.cache.size\",\n        CACHE_SIZE_DEFAULT,\n        Setting.Property.NodeScope\n    );\n    public static final Setting<TimeValue> CACHE_TTL = Setting.timeSetting("}
{"magic_number_smell": "\n    public static final Setting<Integer> CACHE_SIZE = Setting.intSetting(\n        \"xpack.idp.sp.cache.size\",\n        1000,\n        Setting.Property.NodeScope\n    );\n    public static final Setting<TimeValue> CACHE_TTL = Setting.timeSetting(", "refactored_code": "    private static final int CACHE_SIZE_DEFAULT = 1000;\n\n    public static final Setting<Integer> CACHE_SIZE = Setting.intSetting(\n        \"xpack.idp.sp.cache.size\",\n        CACHE_SIZE_DEFAULT,\n        Setting.Property.NodeScope\n    );\n    public static final Setting<TimeValue> CACHE_TTL = Setting.timeSetting("}
{"magic_number_smell": "    public static final NodeFeature MANAGED_BY_DATA_STREAM_LIFECYCLE = new NodeFeature(\"ilm-history-managed-by-dsl\");\n\n    public static final String ILM_TEMPLATE_VERSION_VARIABLE = \"xpack.ilm_history.template.version\";\n    public static final String ILM_TEMPLATE_NAME = \"ilm-history-\" + 7;\n\n    public static final String ILM_POLICY_NAME = \"ilm-history-ilm-policy\";\n    private final FeatureService featureService;", "refactored_code": "    public static final int INDEX_TEMPLATE_VERSION = 7;\n    public static final NodeFeature MANAGED_BY_DATA_STREAM_LIFECYCLE = new NodeFeature(\"ilm-history-managed-by-dsl\");\n\n    public static final String ILM_TEMPLATE_VERSION_VARIABLE = \"xpack.ilm_history.template.version\";\n    public static final String ILM_TEMPLATE_NAME = \"ilm-history-\" + INDEX_TEMPLATE_VERSION;\n\n    public static final String ILM_POLICY_NAME = \"ilm-history-ilm-policy\";\n    private final FeatureService featureService;"}
{"magic_number_smell": "            return jsonBuilder().startObject()\n                .startObject(SINGLE_MAPPING_NAME)\n                .startObject(\"_meta\")\n                .field(SystemIndexDescriptor.VERSION_META_KEY, 1)\n                .endObject()\n                .field(\"dynamic\", \"strict\")\n                .startObject(\"properties\")", "refactored_code": "    private static final int INDEX_MAPPING_VERSION = 1;\n            return jsonBuilder().startObject()\n                .startObject(SINGLE_MAPPING_NAME)\n                .startObject(\"_meta\")\n                .field(SystemIndexDescriptor.VERSION_META_KEY, INDEX_MAPPING_VERSION)\n                .endObject()\n                .field(\"dynamic\", \"strict\")\n                .startObject(\"properties\")"}
{"magic_number_smell": "            return jsonBuilder().startObject()\n                .startObject(SINGLE_MAPPING_NAME)\n                .startObject(\"_meta\")\n                .field(SystemIndexDescriptor.VERSION_META_KEY, 1)\n                .endObject()\n                .field(\"dynamic\", \"strict\")\n                .startObject(\"properties\")", "refactored_code": "    private static final int INDEX_MAPPING_VERSION = 1;\n            return jsonBuilder().startObject()\n                .startObject(SINGLE_MAPPING_NAME)\n                .startObject(\"_meta\")\n                .field(SystemIndexDescriptor.VERSION_META_KEY, INDEX_MAPPING_VERSION)\n                .endObject()\n                .field(\"dynamic\", \"strict\")\n                .startObject(\"properties\")"}
{"magic_number_smell": "    private static final double 3 = 3;\n\n    public static double countTokens(String text) {\n        return Math.ceil(text.length() / 3);\n    }\n\n    private volatile double reductionPercentage;", "refactored_code": "    private static final double CHARS_PER_TOKEN = 3;\n    private static final double CHARS_PER_TOKEN = 3;\n\n    public static double countTokens(String text) {\n        return Math.ceil(text.length() / CHARS_PER_TOKEN);\n    }\n\n    private volatile double reductionPercentage;"}
{"magic_number_smell": "                    {\n                        builder.startObject(\"_meta\");\n                        builder.field(\"logstash-version\", Version.CURRENT);\n                        builder.field(SystemIndexDescriptor.VERSION_META_KEY, 1);\n                        builder.endObject();\n                    }\n                    {", "refactored_code": "    public static final int LOGSTASH_INDEX_MAPPINGS_VERSION = 1;\n                    {\n                        builder.startObject(\"_meta\");\n                        builder.field(\"logstash-version\", Version.CURRENT);\n                        builder.field(SystemIndexDescriptor.VERSION_META_KEY, LOGSTASH_INDEX_MAPPINGS_VERSION);\n                        builder.endObject();\n                    }\n                    {"}
{"magic_number_smell": "    private static long unsignedToSortableSignedLong(long value) {\n        // subtracting 2^63 or 10000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000\n        // equivalent to flipping the first bit\n        return value ^ 0x8000000000000000L;\n    }\n\n    /**", "refactored_code": "    private static final long MASK_2_63 = 0x8000000000000000L;\n    private static long unsignedToSortableSignedLong(long value) {\n        // subtracting 2^63 or 10000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000\n        // equivalent to flipping the first bit\n        return value ^ MASK_2_63;\n    }\n\n    /**"}
{"magic_number_smell": "            int length = Character.charCount(c);\n\n            switch (c) {\n                case '*':\n                    automata.add(Automata.makeAnyString());\n                    break;\n                case WILDCARD_CHAR:", "refactored_code": "    private static final byte WILDCARD_STRING = '*';\n            int length = Character.charCount(c);\n\n            switch (c) {\n                case WILDCARD_STRING:\n                    automata.add(Automata.makeAnyString());\n                    break;\n                case WILDCARD_CHAR:"}
{"magic_number_smell": "        openJob(\"job1\");\n        openJob(\"job2\");\n        long expectedTierBytes = (long) Math.ceil(\n            ByteSizeValue.ofMb(100 + 10 + 200 + 10 + PER_NODE_OVERHEAD_MB).getBytes() * 100 / 30.0\n        );\n        long expectedNodeBytes = (long) Math.ceil(\n            ByteSizeValue.ofMb(200 + 10 + PER_NODE_OVERHEAD_MB).getBytes() * 100 / 30.0", "refactored_code": "    private static final long PER_JOB_OVERHEAD_MB = 10;\n        openJob(\"job1\");\n        openJob(\"job2\");\n        long expectedTierBytes = (long) Math.ceil(\n            ByteSizeValue.ofMb(100 + PER_JOB_OVERHEAD_MB + 200 + PER_JOB_OVERHEAD_MB + PER_NODE_OVERHEAD_MB).getBytes() * 100 / 30.0\n        );\n        long expectedNodeBytes = (long) Math.ceil(\n            ByteSizeValue.ofMb(200 + PER_JOB_OVERHEAD_MB + PER_NODE_OVERHEAD_MB).getBytes() * 100 / 30.0"}
{"magic_number_smell": "    @Before\n    public void putPastDataIntoIndex() {\n        client().admin().indices().prepareCreate(index).setMapping(\"time\", \"type=date\", \"value\", \"type=long\").get();\n        long twoDaysAgo = System.currentTimeMillis() - DAY * 2;\n        long threeDaysAgo = System.currentTimeMillis() - DAY * 3;\n        writeData(logger, index, 250, threeDaysAgo, twoDaysAgo);\n    }", "refactored_code": "    private final long now = System.currentTimeMillis();\n    @Before\n    public void putPastDataIntoIndex() {\n        client().admin().indices().prepareCreate(index).setMapping(\"time\", \"type=date\", \"value\", \"type=long\").get();\n        long twoDaysAgo = now - DAY * 2;\n        long threeDaysAgo = now - DAY * 3;\n        writeData(logger, index, 250, threeDaysAgo, twoDaysAgo);\n    }"}
{"magic_number_smell": "    public void putDataintoIndex() {\n        client().admin().indices().prepareCreate(index).setMapping(\"time\", \"type=date\", \"value\", \"type=long\").get();\n        numDocs = randomIntBetween(32, 128);\n        long oneDayAgo = System.currentTimeMillis() - 86400000;\n        writeData(logger, index, numDocs, oneDayAgo, System.currentTimeMillis());\n    }\n", "refactored_code": "    private final long now = System.currentTimeMillis();\n    public void putDataintoIndex() {\n        client().admin().indices().prepareCreate(index).setMapping(\"time\", \"type=date\", \"value\", \"type=long\").get();\n        numDocs = randomIntBetween(32, 128);\n        long oneDayAgo = now - 86400000;\n        writeData(logger, index, numDocs, oneDayAgo, now);\n    }\n"}
{"magic_number_smell": "        AnalysisConfig.Builder analysisConfig = new AnalysisConfig.Builder(\n            Collections.singletonList(new Detector.Builder(\"max\", \"value\").build())\n        );\n        analysisConfig.setBucketSpan(TimeValue.timeValueSeconds(1000));\n        DataDescription.Builder dataDescription = new DataDescription.Builder();\n        dataDescription.setTimeFormat(\"epoch\");\n        Job.Builder job = new Job.Builder(jobId);", "refactored_code": "    private static final long BUCKET_SPAN_SECONDS = 1000;\n        AnalysisConfig.Builder analysisConfig = new AnalysisConfig.Builder(\n            Collections.singletonList(new Detector.Builder(\"max\", \"value\").build())\n        );\n        analysisConfig.setBucketSpan(TimeValue.timeValueSeconds(BUCKET_SPAN_SECONDS));\n        DataDescription.Builder dataDescription = new DataDescription.Builder();\n        dataDescription.setTimeFormat(\"epoch\");\n        Job.Builder job = new Job.Builder(jobId);"}
{"magic_number_smell": "        for (int i = numSnapshotsTotal; i > 0; --i) {\n            String snapshotId = String.valueOf(i);\n            createModelSnapshot(jobId, snapshotId, new Date(timeMs), numDocsPerSnapshot, i == numSnapshotsTotal);\n            if (timeMs >= now - TimeValue.timeValueDays(1).millis() * modelSnapshotRetentionDays) {\n                expectedModelSnapshotDocIds.add(ModelSnapshot.documentId(jobId, snapshotId));\n                for (int j = 1; j <= numDocsPerSnapshot; ++j) {\n                    expectedModelStateDocIds.add(ModelState.documentId(jobId, snapshotId, j));", "refactored_code": "    private static final long MS_IN_DAY = TimeValue.timeValueDays(1).millis();\n        for (int i = numSnapshotsTotal; i > 0; --i) {\n            String snapshotId = String.valueOf(i);\n            createModelSnapshot(jobId, snapshotId, new Date(timeMs), numDocsPerSnapshot, i == numSnapshotsTotal);\n            if (timeMs >= now - MS_IN_DAY * modelSnapshotRetentionDays) {\n                expectedModelSnapshotDocIds.add(ModelSnapshot.documentId(jobId, snapshotId));\n                for (int j = 1; j <= numDocsPerSnapshot; ++j) {\n                    expectedModelStateDocIds.add(ModelState.documentId(jobId, snapshotId, j));"}
{"magic_number_smell": "        AnalysisConfig.Builder analysisConfig = new AnalysisConfig.Builder(\n            Collections.singletonList(new Detector.Builder(\"count\", null).build())\n        );\n        analysisConfig.setBucketSpan(TimeValue.timeValueSeconds(3600));\n        DataDescription.Builder dataDescription = new DataDescription.Builder();\n        dataDescription.setTimeFormat(\"epoch\");\n        Job.Builder job = new Job.Builder(JOB_ID);", "refactored_code": "    private static final long BUCKET_SPAN_SECONDS = 3600;\n        AnalysisConfig.Builder analysisConfig = new AnalysisConfig.Builder(\n            Collections.singletonList(new Detector.Builder(\"count\", null).build())\n        );\n        analysisConfig.setBucketSpan(TimeValue.timeValueSeconds(BUCKET_SPAN_SECONDS));\n        DataDescription.Builder dataDescription = new DataDescription.Builder();\n        dataDescription.setTimeFormat(\"epoch\");\n        Job.Builder job = new Job.Builder(JOB_ID);"}
{"magic_number_smell": "public class PersistJobIT extends MlNativeAutodetectIntegTestCase {\n\n    private static final long 300 = 300;\n    private static final TimeValue BUCKET_SPAN = TimeValue.timeValueSeconds(300);\n\n    @After\n    public void cleanUpJobs() {", "refactored_code": "    private static final long BUCKET_SPAN_SECONDS = 300;\npublic class PersistJobIT extends MlNativeAutodetectIntegTestCase {\n\n    private static final long BUCKET_SPAN_SECONDS = 300;\n    private static final TimeValue BUCKET_SPAN = TimeValue.timeValueSeconds(BUCKET_SPAN_SECONDS);\n\n    @After\n    public void cleanUpJobs() {"}
{"magic_number_smell": "        AnalysisConfig.Builder analysisConfig = new AnalysisConfig.Builder(\n            Collections.singletonList(new Detector.Builder(\"count\", null).build())\n        );\n        analysisConfig.setBucketSpan(TimeValue.timeValueSeconds(3600));\n        DataDescription.Builder dataDescription = new DataDescription.Builder();\n        dataDescription.setTimeFormat(\"epoch\");\n        Job.Builder job = new Job.Builder(JOB_ID);", "refactored_code": "    private static final long BUCKET_SPAN_SECONDS = 3600;\n        AnalysisConfig.Builder analysisConfig = new AnalysisConfig.Builder(\n            Collections.singletonList(new Detector.Builder(\"count\", null).build())\n        );\n        analysisConfig.setBucketSpan(TimeValue.timeValueSeconds(BUCKET_SPAN_SECONDS));\n        DataDescription.Builder dataDescription = new DataDescription.Builder();\n        dataDescription.setTimeFormat(\"epoch\");\n        Job.Builder job = new Job.Builder(JOB_ID);"}
{"magic_number_smell": "            new DWord(forWrite ? PIPE_ACCESS_OUTBOUND : PIPE_ACCESS_INBOUND),\n            new DWord(PIPE_TYPE_BYTE | PIPE_WAIT | PIPE_REJECT_REMOTE_CLIENTS),\n            new DWord(1),\n            new DWord(4096),\n            new DWord(4096),\n            new DWord(NMPWAIT_USE_DEFAULT_WAIT),\n            Pointer.NULL", "refactored_code": "    private static final int BUFFER_SIZE = 4096;\n            new DWord(forWrite ? PIPE_ACCESS_OUTBOUND : PIPE_ACCESS_INBOUND),\n            new DWord(PIPE_TYPE_BYTE | PIPE_WAIT | PIPE_REJECT_REMOTE_CLIENTS),\n            new DWord(1),\n            new DWord(BUFFER_SIZE),\n            new DWord(BUFFER_SIZE),\n            new DWord(NMPWAIT_USE_DEFAULT_WAIT),\n            Pointer.NULL"}
{"magic_number_smell": "    private void createBuckets(String jobId, int count) {\n        JobResultsPersister.Builder builder = jobResultsPersister.bulkPersisterBuilder(jobId);\n        for (int i = 1; i <= count; ++i) {\n            Bucket bucket = new Bucket(jobId, new Date(AnalysisConfig.Builder.DEFAULT_BUCKET_SPAN.getMillis() * i), AnalysisConfig.Builder.DEFAULT_BUCKET_SPAN.getMillis());\n            builder.persistBucket(bucket);\n        }\n        builder.executeRequest();", "refactored_code": "    private final long bucketSpan = AnalysisConfig.Builder.DEFAULT_BUCKET_SPAN.getMillis();\n    private void createBuckets(String jobId, int count) {\n        JobResultsPersister.Builder builder = jobResultsPersister.bulkPersisterBuilder(jobId);\n        for (int i = 1; i <= count; ++i) {\n            Bucket bucket = new Bucket(jobId, new Date(bucketSpan * i), bucketSpan);\n            builder.persistBucket(bucket);\n        }\n        builder.executeRequest();"}
{"magic_number_smell": "    private void createBuckets(String jobId, int from, int count) {\n        JobResultsPersister.Builder builder = jobResultsPersister.bulkPersisterBuilder(jobId);\n        for (int i = from; i <= count + from; ++i) {\n            Bucket bucket = new Bucket(jobId, new Date(AnalysisConfig.Builder.DEFAULT_BUCKET_SPAN.getMillis() * i), AnalysisConfig.Builder.DEFAULT_BUCKET_SPAN.getMillis());\n            builder.persistBucket(bucket);\n        }\n        builder.executeRequest();", "refactored_code": "    private static final long bucketSpan = AnalysisConfig.Builder.DEFAULT_BUCKET_SPAN.getMillis();\n    private void createBuckets(String jobId, int from, int count) {\n        JobResultsPersister.Builder builder = jobResultsPersister.bulkPersisterBuilder(jobId);\n        for (int i = from; i <= count + from; ++i) {\n            Bucket bucket = new Bucket(jobId, new Date(bucketSpan * i), bucketSpan);\n            builder.persistBucket(bucket);\n        }\n        builder.executeRequest();"}
{"magic_number_smell": "     */\n    private static TimeValue delayToNextTime(ClusterName clusterName) {\n        Random random = new Random(clusterName.hashCode());\n        int minutesOffset = random.ints(0, 120).findFirst().getAsInt();\n\n        ZonedDateTime now = ZonedDateTime.now(Clock.systemDefaultZone());\n        ZonedDateTime next = now.plusDays(1).toLocalDate().atStartOfDay(now.getZone()).plusMinutes(30).plusMinutes(minutesOffset);", "refactored_code": "    private static final int MAX_TIME_OFFSET_MINUTES = 120;\n     */\n    private static TimeValue delayToNextTime(ClusterName clusterName) {\n        Random random = new Random(clusterName.hashCode());\n        int minutesOffset = random.ints(0, MAX_TIME_OFFSET_MINUTES).findFirst().getAsInt();\n\n        ZonedDateTime now = ZonedDateTime.now(Clock.systemDefaultZone());\n        ZonedDateTime next = now.plusDays(1).toLocalDate().atStartOfDay(now.getZone()).plusMinutes(30).plusMinutes(minutesOffset);"}
{"magic_number_smell": "        BoolQueryBuilder query = QueryBuilders.boolQuery()\n            .filter(QueryBuilders.termQuery(Result.RESULT_TYPE.getPreferredName(), ForecastRequestStats.RESULT_TYPE_VALUE));\n        QueryBuilderHelper.buildTokenFilterQuery(Forecast.FORECAST_ID.getPreferredName(), forecastIds).ifPresent(query::filter);\n        SearchSourceBuilder source = new SearchSourceBuilder().size(10_000)\n            // We only need forecast id and status, there is no need fetching the whole source\n            .fetchSource(false)\n            .docValueField(ForecastRequestStats.FORECAST_ID.getPreferredName())", "refactored_code": "    private static final int MAX_FORECAST_TO_SEARCH = 10_000;\n        BoolQueryBuilder query = QueryBuilders.boolQuery()\n            .filter(QueryBuilders.termQuery(Result.RESULT_TYPE.getPreferredName(), ForecastRequestStats.RESULT_TYPE_VALUE));\n        QueryBuilderHelper.buildTokenFilterQuery(Forecast.FORECAST_ID.getPreferredName(), forecastIds).ifPresent(query::filter);\n        SearchSourceBuilder source = new SearchSourceBuilder().size(MAX_FORECAST_TO_SEARCH)\n            // We only need forecast id and status, there is no need fetching the whole source\n            .fetchSource(false)\n            .docValueField(ForecastRequestStats.FORECAST_ID.getPreferredName())"}
{"magic_number_smell": "\n    static ByteSizeValue roundUpToNextMb(long bytes) {\n        assert bytes >= 0 : \"negative bytes \" + bytes;\n        return ByteSizeValue.ofMb(addNonNegativeLongsWithMaxValueCap(bytes, ByteSizeValue.ofMb(1).getBytes() - 1) / ByteSizeValue.ofMb(1).getBytes());\n    }\n\n    /**", "refactored_code": "    private static final long BYTES_IN_MB = ByteSizeValue.ofMb(1).getBytes();\n\n    static ByteSizeValue roundUpToNextMb(long bytes) {\n        assert bytes >= 0 : \"negative bytes \" + bytes;\n        return ByteSizeValue.ofMb(addNonNegativeLongsWithMaxValueCap(bytes, BYTES_IN_MB - 1) / BYTES_IN_MB);\n    }\n\n    /**"}
{"magic_number_smell": "        ) {\n            this.indices = jobsContext.indices;\n            this.maxBucketSpanMillis = jobsContext.maxBucketSpan.millis();\n            this.chunkMillis = 1000 * maxBucketSpanMillis;\n            this.endTime = endTime;\n            this.curTime = startTime;\n            this.excludeInterim = excludeInterim;", "refactored_code": "        private static final int BUCKETS_PER_CHUNK = 1000;\n        ) {\n            this.indices = jobsContext.indices;\n            this.maxBucketSpanMillis = jobsContext.maxBucketSpan.millis();\n            this.chunkMillis = BUCKETS_PER_CHUNK * maxBucketSpanMillis;\n            this.endTime = endTime;\n            this.curTime = startTime;\n            this.excludeInterim = excludeInterim;"}
{"magic_number_smell": "                    // The datafeeds that were running on the node that dropped out of the cluster\n                    // will just have their persistent tasks cancelled. Datafeeds that were stopped\n                    // by the previous attempt will be noops in the subsequent attempt.\n                    if (attempt <= 10) {\n                        logger.warn(\n                            \"Node [{}] failed while processing stop datafeed request - retrying\",\n                            ((FailedNodeException) unwrapped).nodeId()", "refactored_code": "    private static final int MAX_ATTEMPTS = 10;\n                    // The datafeeds that were running on the node that dropped out of the cluster\n                    // will just have their persistent tasks cancelled. Datafeeds that were stopped\n                    // by the previous attempt will be noops in the subsequent attempt.\n                    if (attempt <= MAX_ATTEMPTS) {\n                        logger.warn(\n                            \"Node [{}] failed while processing stop datafeed request - retrying\",\n                            ((FailedNodeException) unwrapped).nodeId()"}
{"magic_number_smell": "        // class does not store usage counts for each token. So instead we simply chop the sequence of\n        // tokens at an appropriate limit when mapping back to strings.\n        List<Integer> keyTokenIndexes = new ArrayList<>();\n        int budgetRemaining = 10000 + 1;\n        for (TokenListCategory.TokenAndWeight tokenAndWeight : category.getBaseWeightedTokenIds()) {\n            if (category.isTokenIdCommon(tokenAndWeight) == false) {\n                continue;", "refactored_code": "    public static final int KEY_BUDGET = 10000;\n        // class does not store usage counts for each token. So instead we simply chop the sequence of\n        // tokens at an appropriate limit when mapping back to strings.\n        List<Integer> keyTokenIndexes = new ArrayList<>();\n        int budgetRemaining = KEY_BUDGET + 1;\n        for (TokenListCategory.TokenAndWeight tokenAndWeight : category.getBaseWeightedTokenIds()) {\n            if (category.isTokenIdCommon(tokenAndWeight) == false) {\n                continue;"}
{"magic_number_smell": "        CharTermAttribute termAtt = ts.addAttribute(CharTermAttribute.class);\n        ts.reset();\n        WeightCalculator weightCalculator = new WeightCalculator(partOfSpeechDictionary);\n        // Only categorize the first 100 tokens\n        while (ts.incrementToken() && weightedTokenIds.size() < 100) {\n            if (termAtt.length() > 0) {\n                // Convert the CharSequence to a String. Although this seems wasteful it's not because:", "refactored_code": "    public static final int MAX_TOKENS = 100;\n        CharTermAttribute termAtt = ts.addAttribute(CharTermAttribute.class);\n        ts.reset();\n        WeightCalculator weightCalculator = new WeightCalculator(partOfSpeechDictionary);\n        // Only categorize the first MAX_TOKENS tokens\n        while (ts.incrementToken() && weightedTokenIds.size() < MAX_TOKENS) {\n            if (termAtt.length() > 0) {\n                // Convert the CharSequence to a String. Although this seems wasteful it's not because:"}
{"magic_number_smell": "\n    // For testing - should return the same value as the method above, just more slowly.\n    long ramBytesUsedSlow() {\n        return shallowSizeOfInstance(TokenListCategory.class) + sizeOfCollection(baseWeightedTokenIds) + sizeOfCollection(commonUniqueTokenIds);\n    }\n\n    private void cacheRamUsage() {", "refactored_code": "    private static final long SHALLOW_SIZE = shallowSizeOfInstance(TokenListCategory.class);\n\n    // For testing - should return the same value as the method above, just more slowly.\n    long ramBytesUsedSlow() {\n        return SHALLOW_SIZE + sizeOfCollection(baseWeightedTokenIds) + sizeOfCollection(commonUniqueTokenIds);\n    }\n\n    private void cacheRamUsage() {"}
{"magic_number_smell": "    private static double changePValueThreshold(int nValues) {\n        // This was obtained by simulating the test power for a fixed size effect as a\n        // function of the bucket value count.\n        return P_VALUE_THRESHOLD * Math.exp(-0.04 * (double) (nValues - 2 * (10 + 1)));\n    }\n\n    private static int lowerBound(int[] x, int start, int end, int xs) {", "refactored_code": "    private static final int MINIMUM_BUCKETS = 10;\n    private static double changePValueThreshold(int nValues) {\n        // This was obtained by simulating the test power for a fixed size effect as a\n        // function of the bucket value count.\n        return P_VALUE_THRESHOLD * Math.exp(-0.04 * (double) (nValues - 2 * (MINIMUM_BUCKETS + 1)));\n    }\n\n    private static int lowerBound(int[] x, int start, int end, int xs) {"}
{"magic_number_smell": "            return dev > 0 ? 1.0d : 0.0d;\n        }\n        // We use the fact that erf(-x) = -erf(x) and substitute for erfc(x) = 1 - erf(x)\n        return 0.5 * Erf.erfc(-dev / (bandwidth * FastMath.sqrt(2.0)));\n    }\n\n    double normSf(double mean, double x) {", "refactored_code": "    private static final double SQRT2 = FastMath.sqrt(2.0);\n            return dev > 0 ? 1.0d : 0.0d;\n        }\n        // We use the fact that erf(-x) = -erf(x) and substitute for erfc(x) = 1 - erf(x)\n        return 0.5 * Erf.erfc(-dev / (bandwidth * SQRT2));\n    }\n\n    double normSf(double mean, double x) {"}
{"magic_number_smell": "\n        SingularValueDecomposition svd = new SingularValueDecomposition(x);\n        double[] singularValues = svd.getSingularValues();\n        if (singularValues[0] > 1e+15 * singularValues[n - 1]) {\n            return OptionalDouble.empty();\n        }\n        RealMatrix r = svd.getSolver().solve(y);", "refactored_code": "    private static final double SINGLE_VALUE_DECOMPOSITION_MAX_COND = 1e+15;\n\n        SingularValueDecomposition svd = new SingularValueDecomposition(x);\n        double[] singularValues = svd.getSingularValues();\n        if (singularValues[0] > SINGLE_VALUE_DECOMPOSITION_MAX_COND * singularValues[n - 1]) {\n            return OptionalDouble.empty();\n        }\n        RealMatrix r = svd.getSolver().solve(y);"}
{"magic_number_smell": "        this.cacheNumberOfTransactions = cacheNumberOfTransactions;\n        transactionSkipCounts = new long[cacheTraversalDepth - 1];\n        transactionSkipList = new BitSet((cacheTraversalDepth - 1) * cacheNumberOfTransactions);\n        occurencesStack = new long[10];\n        visited = new java.util.BitSet();\n    }\n", "refactored_code": "    private static final int OCCURENCES_SIZE_INCREMENT = 10;\n        this.cacheNumberOfTransactions = cacheNumberOfTransactions;\n        transactionSkipCounts = new long[cacheTraversalDepth - 1];\n        transactionSkipList = new BitSet((cacheTraversalDepth - 1) * cacheNumberOfTransactions);\n        occurencesStack = new long[OCCURENCES_SIZE_INCREMENT];\n        visited = new java.util.BitSet();\n    }\n"}
{"magic_number_smell": "            long previousMinCount = 0;\n\n            while (setTraverser.next(minCount)) {\n                if (numberOfSetsChecked % 100000 == 0) {\n                    logger.debug(\"checked {} sets\", numberOfSetsChecked);\n\n                    if (isCanceledSupplier.get()) {", "refactored_code": "    private static final int ITERATION_CHECK_INTERVAL = 100000;\n            long previousMinCount = 0;\n\n            while (setTraverser.next(minCount)) {\n                if (numberOfSetsChecked % ITERATION_CHECK_INTERVAL == 0) {\n                    logger.debug(\"checked {} sets\", numberOfSetsChecked);\n\n                    if (isCanceledSupplier.get()) {"}
{"magic_number_smell": "\n        private FrequentItemSetCandidate() {\n            this.id = -1;\n            this.items = new ItemSetBitSet(64);\n            this.docCount = -1;\n        }\n", "refactored_code": "        private static final int STARTBITS = 64;\n\n        private FrequentItemSetCandidate() {\n            this.id = -1;\n            this.items = new ItemSetBitSet(STARTBITS);\n            this.docCount = -1;\n        }\n"}
{"magic_number_smell": "        (args, context) -> {\n            @SuppressWarnings(\"unchecked\")\n            List<MultiValuesSourceFieldConfig> fields = (List<MultiValuesSourceFieldConfig>) args[0];\n            double minimumSupport = args[1] == null ? 0.01 : (double) args[1];\n            int minimumSetSize = args[2] == null ? DEFAULT_MINIMUM_SET_SIZE : (int) args[2];\n            int size = args[3] == null ? DEFAULT_SIZE : (int) args[3];\n            QueryBuilder filter = (QueryBuilder) args[4];", "refactored_code": "    public static final double DEFAULT_MINIMUM_SUPPORT = 0.01;\n        (args, context) -> {\n            @SuppressWarnings(\"unchecked\")\n            List<MultiValuesSourceFieldConfig> fields = (List<MultiValuesSourceFieldConfig>) args[0];\n            double minimumSupport = args[1] == null ? DEFAULT_MINIMUM_SUPPORT : (double) args[1];\n            int minimumSetSize = args[2] == null ? DEFAULT_MINIMUM_SET_SIZE : (int) args[2];\n            int size = args[3] == null ? DEFAULT_SIZE : (int) args[3];\n            QueryBuilder filter = (QueryBuilder) args[4];"}
{"magic_number_smell": "        boolean success = false;\n\n        try {\n            this.items = new BytesRefHash(PageCacheRecycler.LONG_PAGE_SIZE, bigArrays);\n            this.itemCounts = bigArrays.newLongArray(PageCacheRecycler.LONG_PAGE_SIZE, true);\n            this.transactions = new BytesRefHash(INITIAL_TRANSACTION_CAPACITY, bigArrays);\n            this.transactionCounts = bigArrays.newLongArray(INITIAL_TRANSACTION_CAPACITY, true);", "refactored_code": "    private static final int INITIAL_ITEM_CAPACITY = PageCacheRecycler.LONG_PAGE_SIZE;\n        boolean success = false;\n\n        try {\n            this.items = new BytesRefHash(INITIAL_ITEM_CAPACITY, bigArrays);\n            this.itemCounts = bigArrays.newLongArray(INITIAL_ITEM_CAPACITY, true);\n            this.transactions = new BytesRefHash(INITIAL_TRANSACTION_CAPACITY, bigArrays);\n            this.transactionCounts = bigArrays.newLongArray(INITIAL_TRANSACTION_CAPACITY, true);"}
{"magic_number_smell": "\n    // taken from {@code BitSet}\n    private static final int 6 = 6;\n    private static final int BITS_PER_WORD = 1 << 6;\n\n    /* Used to shift left or right for a partial word mask */\n    private static final long WORD_MASK = 0xffffffffffffffffL;", "refactored_code": "    private static final int ADDRESS_BITS_PER_WORD = 6;\n\n    // taken from {@code BitSet}\n    private static final int ADDRESS_BITS_PER_WORD = 6;\n    private static final int BITS_PER_WORD = 1 << ADDRESS_BITS_PER_WORD;\n\n    /* Used to shift left or right for a partial word mask */\n    private static final long WORD_MASK = 0xffffffffffffffffL;"}
{"magic_number_smell": "    // stack implementation: to avoid object churn this is not implemented as classical stack, but optimized for re-usage\n    // non-optimized: Stack<TransactionStore.TopItemIds.IdIterator> itemIterators = new Stack<>();\n    private final List<TransactionStore.TopItemIds.IdIterator> itemIterators = new ArrayList<>();\n    private LongsRef itemIdStack = new LongsRef(100);\n\n    private final ItemSetBitSet itemPositionsVector;\n    private final ItemSetBitSet itemPositionsVectorParent;", "refactored_code": "    private static final int SIZE_INCREMENT = 100;\n    // stack implementation: to avoid object churn this is not implemented as classical stack, but optimized for re-usage\n    // non-optimized: Stack<TransactionStore.TopItemIds.IdIterator> itemIterators = new Stack<>();\n    private final List<TransactionStore.TopItemIds.IdIterator> itemIterators = new ArrayList<>();\n    private LongsRef itemIdStack = new LongsRef(SIZE_INCREMENT);\n\n    private final ItemSetBitSet itemPositionsVector;\n    private final ItemSetBitSet itemPositionsVectorParent;"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        return RamUsageEstimator.shallowSizeOfInstance(TransactionsLookupTable.class) + startOffsets.ramBytesUsed() + longs.ramBytesUsed();\n    }\n}\n", "refactored_code": "    private static final long BASE_RAM_BYTES_USED = RamUsageEstimator.shallowSizeOfInstance(TransactionsLookupTable.class);\n\n    @Override\n    public long ramBytesUsed() {\n        return BASE_RAM_BYTES_USED + startOffsets.ramBytesUsed() + longs.ramBytesUsed();\n    }\n}\n"}
{"magic_number_smell": "            if (FastMath.floor(z2) == z2) {\n                ret = EXACT_STIRLING_ERRORS[(int) z2];\n            } else {\n                ret = Gamma.logGamma(z + 1.0) - (z + 0.5) * FastMath.log(z) + z - 0.5 * FastMath.log(MathUtils.TWO_PI);\n            }\n        } else {\n            double z2 = z * z;", "refactored_code": "    private static final double HALF_LOG_2_PI = 0.5 * FastMath.log(MathUtils.TWO_PI);\n            if (FastMath.floor(z2) == z2) {\n                ret = EXACT_STIRLING_ERRORS[(int) z2];\n            } else {\n                ret = Gamma.logGamma(z + 1.0) - (z + 0.5) * FastMath.log(z) + z - HALF_LOG_2_PI;\n            }\n        } else {\n            double z2 = z * z;"}
{"magic_number_smell": "        }\n\n        Map<String, Double> result = Stream.generate(() -> ksTest(nSamples, fX, fY, monotonic, samplingMethod.cdfPoints(), alternatives))\n            .limit(20)\n            .reduce(new HashMap<>(), (memo, v) -> {\n                v.forEach(\n                    (alternative, ksTestValue) -> memo.merge(alternative, ksTestValue, (v1, v2) -> v1 + (v2 == 0.0 ? 0.0 : Math.log(v2)))", "refactored_code": "    private static final int NUM_ITERATIONS = 20;\n        }\n\n        Map<String, Double> result = Stream.generate(() -> ksTest(nSamples, fX, fY, monotonic, samplingMethod.cdfPoints(), alternatives))\n            .limit(NUM_ITERATIONS)\n            .reduce(new HashMap<>(), (memo, v) -> {\n                v.forEach(\n                    (alternative, ksTestValue) -> memo.merge(alternative, ksTestValue, (v1, v2) -> v1 + (v2 == 0.0 ? 0.0 : Math.log(v2)))"}
{"magic_number_smell": "    private final int bulkLimit;\n\n    public AnnotationPersister(ResultsPersisterService resultsPersisterService) {\n        this(resultsPersisterService, 10_000);\n    }\n\n    // For testing", "refactored_code": "    private static final int DEFAULT_BULK_LIMIT = 10_000;\n    private final int bulkLimit;\n\n    public AnnotationPersister(ResultsPersisterService resultsPersisterService) {\n        this(resultsPersisterService, DEFAULT_BULK_LIMIT);\n    }\n\n    // For testing"}
{"magic_number_smell": "            ByteSizeValue.ofBytes(Math.min(scaleDownResult.nodeSize().getBytes(), currentCapacity.nodeSize().getBytes())),\n            ByteSizeValue.ofBytes(Math.min(scaleDownResult.tierSize().getBytes(), currentCapacity.tierSize().getBytes()))\n        ).setReason(scaleDownResult.reason()).build();\n        if (scaleDownResult.nodeSize().getBytes() - newCapacity.nodeSize().getBytes() > ByteSizeValue.ofMb(1).getBytes()\n            || scaleDownResult.tierSize().getBytes() - newCapacity.tierSize().getBytes() > ByteSizeValue.ofMb(1).getBytes()) {\n            logger.warn(\n                \"scale down accidentally requested a scale up, auto-corrected; initial scaling [{}], corrected [{}]\",", "refactored_code": "    private static final long ACCEPTABLE_DIFFERENCE = ByteSizeValue.ofMb(1).getBytes();\n            ByteSizeValue.ofBytes(Math.min(scaleDownResult.nodeSize().getBytes(), currentCapacity.nodeSize().getBytes())),\n            ByteSizeValue.ofBytes(Math.min(scaleDownResult.tierSize().getBytes(), currentCapacity.tierSize().getBytes()))\n        ).setReason(scaleDownResult.reason()).build();\n        if (scaleDownResult.nodeSize().getBytes() - newCapacity.nodeSize().getBytes() > ACCEPTABLE_DIFFERENCE\n            || scaleDownResult.tierSize().getBytes() - newCapacity.tierSize().getBytes() > ACCEPTABLE_DIFFERENCE) {\n            logger.warn(\n                \"scale down accidentally requested a scale up, auto-corrected; initial scaling [{}], corrected [{}]\","}
{"magic_number_smell": "\n    ScaleTimer(LongSupplier timeSupplier) {\n        this.timeSupplier = Objects.requireNonNull(timeSupplier);\n        this.scaleDownDetected = -1L;\n    }\n\n    void markScale() {", "refactored_code": "    private static final long NO_SCALE_DOWN_POSSIBLE = -1L;\n\n    ScaleTimer(LongSupplier timeSupplier) {\n        this.timeSupplier = Objects.requireNonNull(timeSupplier);\n        this.scaleDownDetected = NO_SCALE_DOWN_POSSIBLE;\n    }\n\n    void markScale() {"}
{"magic_number_smell": "        // we run 30s past the minute. If frequency is 1s and query delay 10s,\n        // we don't add anything and we'll run every second.\n        long next = currentTimeSupplier.get() + frequencyMs;\n        return toIntervalStartEpochMs(next) + queryDelayMs % frequencyMs + 100;\n    }\n\n    private long toIntervalStartEpochMs(long epochMs) {", "refactored_code": "    private static final int NEXT_TASK_DELAY_MS = 100;\n        // we run 30s past the minute. If frequency is 1s and query delay 10s,\n        // we don't add anything and we'll run every second.\n        long next = currentTimeSupplier.get() + frequencyMs;\n        return toIntervalStartEpochMs(next) + queryDelayMs % frequencyMs + NEXT_TASK_DELAY_MS;\n    }\n\n    private long toIntervalStartEpochMs(long epochMs) {"}
{"magic_number_smell": "\n    /**\n     * Updates the tracking of empty data cycles. If the number of consecutive empty data\n     * cycles reaches {@code 10} or the 24 hours of empty data counts\n     * have passed a warning is reported.\n     */\n    public int reportEmptyDataCount() {", "refactored_code": "    private static final int EMPTY_DATA_WARN_COUNT = 10;\n\n    /**\n     * Updates the tracking of empty data cycles. If the number of consecutive empty data\n     * cycles reaches {@code EMPTY_DATA_WARN_COUNT} or the 24 hours of empty data counts\n     * have passed a warning is reported.\n     */\n    public int reportEmptyDataCount() {"}
{"magic_number_smell": "            return 0;\n        }\n        if (currentWindow == null) { // we should provide a good default as the user did not specify a window\n            return Math.max(DEFAULT_CHECK_WINDOW_MS, 8 * bucketSpan.millis());\n        }\n        if (currentWindow.compareTo(bucketSpan) < 0) {\n            throw new IllegalArgumentException(", "refactored_code": "    private static final int DEFAULT_NUMBER_OF_BUCKETS_TO_SPAN = 8;\n            return 0;\n        }\n        if (currentWindow == null) { // we should provide a good default as the user did not specify a window\n            return Math.max(DEFAULT_CHECK_WINDOW_MS, DEFAULT_NUMBER_OF_BUCKETS_TO_SPAN * bucketSpan.millis());\n        }\n        if (currentWindow.compareTo(bucketSpan) < 0) {\n            throw new IllegalArgumentException("}
{"magic_number_smell": "                    // Thus, the interval would be (scrollSize * dataTimeSpread) / totalHits.\n                    // However, assuming this as the chunk span may often lead to half-filled pages or empty searches.\n                    // It is beneficial to take a multiple of that. Based on benchmarking, we set this to 10x.\n                    chunkSpan = Math.max(60000L, 10 * (context.scrollSize() * timeSpread) / dataSummary.totalHits());\n                }\n            }\n", "refactored_code": "    private static final long MIN_CHUNK_SPAN = 60000L;\n                    // Thus, the interval would be (scrollSize * dataTimeSpread) / totalHits.\n                    // However, assuming this as the chunk span may often lead to half-filled pages or empty searches.\n                    // It is beneficial to take a multiple of that. Based on benchmarking, we set this to 10x.\n                    chunkSpan = Math.max(MIN_CHUNK_SPAN, 10 * (context.scrollSize() * timeSpread) / dataSummary.totalHits());\n                }\n            }\n"}
{"magic_number_smell": "                    bulkIndexer.addAndExecuteIfNeeded(createIndexRequest(doc, inferenceResults, config.getDest().getResultsField()));\n\n                    processedDocCount++;\n                    int progressPercent = Math.min((int) (processedDocCount * 100.0 / totalDocCount), 98);\n                    progressTracker.updateInferenceProgress(progressPercent);\n                }\n            }", "refactored_code": "    private static final int MAX_PROGRESS_BEFORE_COMPLETION = 98;\n                    bulkIndexer.addAndExecuteIfNeeded(createIndexRequest(doc, inferenceResults, config.getDest().getResultsField()));\n\n                    processedDocCount++;\n                    int progressPercent = Math.min((int) (processedDocCount * 100.0 / totalDocCount), MAX_PROGRESS_BEFORE_COMPLETION);\n                    progressTracker.updateInferenceProgress(progressPercent);\n                }\n            }"}
{"magic_number_smell": "     */\n    public void getMultiple(String ids, boolean allowNoMatch, ActionListener<List<DataFrameAnalyticsConfig>> listener) {\n        GetDataFrameAnalyticsAction.Request request = new GetDataFrameAnalyticsAction.Request();\n        request.setPageParams(new PageParams(0, 10000));\n        request.setResourceId(ids);\n        request.setAllowNoResources(allowNoMatch);\n        executeAsyncWithOrigin(", "refactored_code": "    private static final int MAX_CONFIGS_SIZE = 10000;\n     */\n    public void getMultiple(String ids, boolean allowNoMatch, ActionListener<List<DataFrameAnalyticsConfig>> listener) {\n        GetDataFrameAnalyticsAction.Request request = new GetDataFrameAnalyticsAction.Request();\n        request.setPageParams(new PageParams(0, MAX_CONFIGS_SIZE));\n        request.setResourceId(ids);\n        request.setAllowNoResources(allowNoMatch);\n        executeAsyncWithOrigin("}
{"magic_number_smell": "    }\n\n    private void updateResultsProgress(int progress) {\n        statsHolder.getProgressTracker().updateWritingResultsProgress(Math.min(progress, 98));\n    }\n\n    private void completeResultsProgress() {", "refactored_code": "    private static final int MAX_PROGRESS_BEFORE_COMPLETION = 98;\n    }\n\n    private void updateResultsProgress(int progress) {\n        statsHolder.getProgressTracker().updateWritingResultsProgress(Math.min(progress, MAX_PROGRESS_BEFORE_COMPLETION));\n    }\n\n    private void completeResultsProgress() {"}
{"magic_number_smell": "\n        CountDownLatch latch = storeTrainedModelDoc(trainedModelDefinitionDoc);\n        try {\n            if (latch.await(30, TimeUnit.SECONDS) == false) {\n                LOGGER.error(\"[{}] Timed out (30s) waiting for chunked inference definition to be stored\", analytics.getId());\n                if (trainedModelDefinitionChunk.isEos()) {\n                    this.readyToStoreNewModel.set(true);", "refactored_code": "    private static final int STORE_TIMEOUT_SEC = 30;\n\n        CountDownLatch latch = storeTrainedModelDoc(trainedModelDefinitionDoc);\n        try {\n            if (latch.await(STORE_TIMEOUT_SEC, TimeUnit.SECONDS) == false) {\n                LOGGER.error(\"[{}] Timed out (30s) waiting for chunked inference definition to be stored\", analytics.getId());\n                if (trainedModelDefinitionChunk.isEos()) {\n                    this.readyToStoreNewModel.set(true);"}
{"magic_number_smell": "\n    private void addResultAndJoinIfEndOfBatch(RowResults rowResults) {\n        currentResults.add(rowResults);\n        if (currentResults.size() == 1000) {\n            joinCurrentResults();\n        }\n    }", "refactored_code": "    private static final int RESULTS_BATCH_SIZE = 1000;\n\n    private void addResultAndJoinIfEndOfBatch(RowResults rowResults) {\n        currentResults.add(rowResults);\n        if (currentResults.size() == RESULTS_BATCH_SIZE) {\n            joinCurrentResults();\n        }\n    }"}
{"magic_number_smell": "     */\n    private static final int MEMORY_COMPLEXITY_LIMIT = 10_000_000;\n\n    private final Random random = new Random(738921734L);\n\n    private final List<Node> nodes;\n    private final List<AssignmentPlan.Deployment> deployments;", "refactored_code": "    private static final long RANDOMIZATION_SEED = 738921734L;\n     */\n    private static final int MEMORY_COMPLEXITY_LIMIT = 10_000_000;\n\n    private final Random random = new Random(RANDOMIZATION_SEED);\n\n    private final List<Node> nodes;\n    private final List<AssignmentPlan.Deployment> deployments;"}
{"magic_number_smell": "\n    private static boolean isInteger(double value) {\n        // it is possible that the solver results in values that are really close to an int, we should treat those as ints\n        return Double.isFinite(value) && Math.abs(value - Math.rint(value)) < 1e-6;\n    }\n}\n", "refactored_code": "    private static final double EPS = 1e-6;\n\n    private static boolean isInteger(double value) {\n        // it is possible that the solver results in values that are really close to an int, we should treat those as ints\n        return Double.isFinite(value) && Math.abs(value - Math.rint(value)) < EPS;\n    }\n}\n"}
{"magic_number_smell": "                resultProcessor.stop();\n                stateStreamer.cancel();\n\n                if (startsCount.get() <= 3) {\n                    {\n                        String logAndAuditMessage = \"Inference process [\"\n                            + task.getDeploymentId()", "refactored_code": "    public static final int NUM_RESTART_ATTEMPTS = 3;\n                resultProcessor.stop();\n                stateStreamer.cancel();\n\n                if (startsCount.get() <= NUM_RESTART_ATTEMPTS) {\n                    {\n                        String logAndAuditMessage = \"Inference process [\"\n                            + task.getDeploymentId()"}
{"magic_number_smell": "            );\n        }\n\n        if (span == -2) {\n            span = defaultSpanForChunking(windowSize);\n        }\n", "refactored_code": "    public static final int CALC_DEFAULT_SPAN_VALUE = -2;\n            );\n        }\n\n        if (span == CALC_DEFAULT_SPAN_VALUE) {\n            span = defaultSpanForChunking(windowSize);\n        }\n"}
{"magic_number_smell": "    }\n\n    public void setSearchSize(int searchSize) {\n        if (searchSize > 20) {\n            throw new IllegalArgumentException(\"search size [\" + searchSize + \"] cannot be bigger than [\" + 20 + \"]\");\n        }\n        if (searchSize <= 0) {", "refactored_code": "    private static final int MAX_NUM_DEFINITION_DOCS = 20;\n    }\n\n    public void setSearchSize(int searchSize) {\n        if (searchSize > MAX_NUM_DEFINITION_DOCS) {\n            throw new IllegalArgumentException(\"search size [\" + searchSize + \"] cannot be bigger than [\" + MAX_NUM_DEFINITION_DOCS + \"]\");\n        }\n        if (searchSize <= 0) {"}
{"magic_number_smell": "    private static final String MODEL_RESOURCE_FILE_EXT = \".json\";\n    private static final int 16 * 1024 * 1024 = 16 * 1024 * 1024;\n    private static final int MAX_NUM_DEFINITION_DOCS = 100;\n    private static final int MAX_COMPRESSED_MODEL_SIZE = 16 * 1024 * 1024 * MAX_NUM_DEFINITION_DOCS;\n\n    private static final Logger logger = LogManager.getLogger(TrainedModelProvider.class);\n    private final Client client;", "refactored_code": "    private static final int COMPRESSED_MODEL_CHUNK_SIZE = 16 * 1024 * 1024;\n    private static final String MODEL_RESOURCE_FILE_EXT = \".json\";\n    private static final int COMPRESSED_MODEL_CHUNK_SIZE = 16 * 1024 * 1024;\n    private static final int MAX_NUM_DEFINITION_DOCS = 100;\n    private static final int MAX_COMPRESSED_MODEL_SIZE = COMPRESSED_MODEL_CHUNK_SIZE * MAX_NUM_DEFINITION_DOCS;\n\n    private static final Logger logger = LogManager.getLogger(TrainedModelProvider.class);\n    private final Client client;"}
{"magic_number_smell": "            }\n        }\n\n        if (bestCandidate == null || numRecurse >= 10) {\n            if (bestCandidate != null) {\n                logger.warn(\"[{}] exited grok discovery early, reached max depth [{}]\", jobId, 10);\n            }", "refactored_code": "    private static final int MAX_RECURSE_DEPTH = 10;\n            }\n        }\n\n        if (bestCandidate == null || numRecurse >= MAX_RECURSE_DEPTH) {\n            if (bestCandidate != null) {\n                logger.warn(\"[{}] exited grok discovery early, reached max depth [{}]\", jobId, MAX_RECURSE_DEPTH);\n            }"}
{"magic_number_smell": "    public static final int 100 = 100;\n\n    private int from = 0;\n    private int size = 100;\n    private boolean expand = false;\n    private boolean includeInterim = false;\n    private double anomalyScoreFilter = 0.0;", "refactored_code": "    public static final int DEFAULT_SIZE = 100;\n    public static final int DEFAULT_SIZE = 100;\n\n    private int from = 0;\n    private int size = DEFAULT_SIZE;\n    private boolean expand = false;\n    private boolean includeInterim = false;\n    private double anomalyScoreFilter = 0.0;"}
{"magic_number_smell": "\n    public class InfluencersQuery {\n        private int from = 0;\n        private int size = 100;\n        private boolean includeInterim = false;\n        private double influencerScoreFilter = 0.0d;\n        private String start;", "refactored_code": "    public static final int DEFAULT_SIZE = 100;\n\n    public class InfluencersQuery {\n        private int from = 0;\n        private int size = DEFAULT_SIZE;\n        private boolean includeInterim = false;\n        private double influencerScoreFilter = 0.0d;\n        private String start;"}
{"magic_number_smell": "\n    private void deleteModelState(@SuppressWarnings(\"HiddenField\") String jobId, ActionListener<BulkByScrollResponse> listener) {\n        GetModelSnapshotsAction.Request request = new GetModelSnapshotsAction.Request(jobId, null);\n        request.setPageParams(new PageParams(0, 10000));\n        executeAsyncWithOrigin(client, ML_ORIGIN, GetModelSnapshotsAction.INSTANCE, request, ActionListener.wrap(response -> {\n            List<ModelSnapshot> deleteCandidates = response.getPage().results();\n            deleteModelSnapshots(deleteCandidates, listener);", "refactored_code": "    private static final int MAX_SNAPSHOTS_TO_DELETE = 10000;\n\n    private void deleteModelState(@SuppressWarnings(\"HiddenField\") String jobId, ActionListener<BulkByScrollResponse> listener) {\n        GetModelSnapshotsAction.Request request = new GetModelSnapshotsAction.Request(jobId, null);\n        request.setPageParams(new PageParams(0, MAX_SNAPSHOTS_TO_DELETE));\n        executeAsyncWithOrigin(client, ML_ORIGIN, GetModelSnapshotsAction.INSTANCE, request, ActionListener.wrap(response -> {\n            List<ModelSnapshot> deleteCandidates = response.getPage().results();\n            deleteModelSnapshots(deleteCandidates, listener);"}
{"magic_number_smell": "            jobId,\n            bucket,\n            0,\n            10000,\n            includeInterim,\n            AnomalyRecord.PROBABILITY.getPreferredName(),\n            false,", "refactored_code": "    private static final int RECORDS_SIZE_PARAM = 10000;\n            jobId,\n            bucket,\n            0,\n            RECORDS_SIZE_PARAM,\n            includeInterim,\n            AnomalyRecord.PROBABILITY.getPreferredName(),\n            false,"}
{"magic_number_smell": "    );\n\n    private int from = 0;\n    private int size = 100;\n    private boolean includeInterim = false;\n    private String sortField;\n    private boolean sortDescending = true;", "refactored_code": "    public static final int DEFAULT_SIZE = 100;\n    );\n\n    private int from = 0;\n    private int size = DEFAULT_SIZE;\n    private boolean includeInterim = false;\n    private String sortField;\n    private boolean sortDescending = true;"}
{"magic_number_smell": "    public static final int 1000 = 1000;\n\n    private Integer from = 0;\n    private Integer size = 1000;\n\n    private String[] calendarIds;\n    private String start;", "refactored_code": "    public static final int DEFAULT_SIZE = 1000;\n    public static final int DEFAULT_SIZE = 1000;\n\n    private Integer from = 0;\n    private Integer size = DEFAULT_SIZE;\n\n    private String[] calendarIds;\n    private String start;"}
{"magic_number_smell": "    // Though this setting is dynamic, it is only set when a new job is opened. So, already running jobs will not get the updated value.\n    public static final Setting<Integer> MAX_ANOMALY_RECORDS_SETTING_DYNAMIC = Setting.intSetting(\n        \"xpack.ml.max_anomaly_records\",\n        500,\n        Setting.Property.NodeScope,\n        Setting.Property.Dynamic\n    );", "refactored_code": "    private static final int DEFAULT_MAX_NUM_RECORDS = 500;\n    // Though this setting is dynamic, it is only set when a new job is opened. So, already running jobs will not get the updated value.\n    public static final Setting<Integer> MAX_ANOMALY_RECORDS_SETTING_DYNAMIC = Setting.intSetting(\n        \"xpack.ml.max_anomaly_records\",\n        DEFAULT_MAX_NUM_RECORDS,\n        Setting.Property.NodeScope,\n        Setting.Property.Dynamic\n    );"}
{"magic_number_smell": "            Long epochStart = null;\n            Long epochEnd = null;\n            if (start.isEmpty() == false) {\n                epochStart = paramToEpochIfValidOrThrow(START_PARAM, start) / 1000;\n                epochEnd = paramToEpochIfValidOrThrow(END_PARAM, end) / 1000;\n                if (end.isEmpty() || epochEnd.equals(epochStart)) {\n                    epochEnd = epochStart + 1;", "refactored_code": "    public static final int MILLISECONDS_IN_SECOND = 1000;\n            Long epochStart = null;\n            Long epochEnd = null;\n            if (start.isEmpty() == false) {\n                epochStart = paramToEpochIfValidOrThrow(START_PARAM, start) / MILLISECONDS_IN_SECOND;\n                epochEnd = paramToEpochIfValidOrThrow(END_PARAM, end) / MILLISECONDS_IN_SECOND;\n                if (end.isEmpty() || epochEnd.equals(epochStart)) {\n                    epochEnd = epochStart + 1;"}
{"magic_number_smell": "    protected boolean transformTimeAndWrite(String[] record, long numberOfFieldsRead) throws IOException {\n        long epochMs;\n        try {\n            epochMs = dateTransformer.transform(record[0]);\n        } catch (CannotParseTimestampException e) {\n            dataCountsReporter.reportDateParseError(numberOfFieldsRead);\n            logger.error(e.getMessage());", "refactored_code": "    private static final int TIME_FIELD_OUT_INDEX = 0;\n    protected boolean transformTimeAndWrite(String[] record, long numberOfFieldsRead) throws IOException {\n        long epochMs;\n        try {\n            epochMs = dateTransformer.transform(record[TIME_FIELD_OUT_INDEX]);\n        } catch (CannotParseTimestampException e) {\n            dataCountsReporter.reportDateParseError(numberOfFieldsRead);\n            logger.error(e.getMessage());"}
{"magic_number_smell": "    public long transform(String timestamp) throws CannotParseTimestampException {\n        try {\n            long longValue = Double.valueOf(timestamp).longValue();\n            return isMillisecond ? longValue : longValue * 1000;\n        } catch (NumberFormatException e) {\n            String message = String.format(Locale.ROOT, \"Cannot parse timestamp '%s' as epoch value\", timestamp);\n            throw new CannotParseTimestampException(message, e);", "refactored_code": "    private static final long MS_IN_SECOND = 1000;\n    public long transform(String timestamp) throws CannotParseTimestampException {\n        try {\n            long longValue = Double.valueOf(timestamp).longValue();\n            return isMillisecond ? longValue : longValue * MS_IN_SECOND;\n        } catch (NumberFormatException e) {\n            String message = String.format(Locale.ROOT, \"Cannot parse timestamp '%s' as epoch value\", timestamp);\n            throw new CannotParseTimestampException(message, e);"}
{"magic_number_smell": "    BucketDiagnostics(Job job, DataCounts dataCounts, BucketFlushListener bucketFlushListener) {\n        bucketSpanMs = job.getAnalysisConfig().getBucketSpan().millis();\n        latencyMs = job.getAnalysisConfig().getLatency() == null ? 0 : job.getAnalysisConfig().getLatency().millis();\n        maxSize = Math.max((int) (Intervals.alignToCeil(latencyMs, bucketSpanMs) / bucketSpanMs), 10);\n        buckets = new long[maxSize];\n        this.bucketFlushListener = bucketFlushListener;\n", "refactored_code": "    private static final int MIN_BUCKETS = 10;\n    BucketDiagnostics(Job job, DataCounts dataCounts, BucketFlushListener bucketFlushListener) {\n        bucketSpanMs = job.getAnalysisConfig().getBucketSpan().millis();\n        latencyMs = job.getAnalysisConfig().getLatency() == null ? 0 : job.getAnalysisConfig().getLatency().millis();\n        maxSize = Math.max((int) (Intervals.alignToCeil(latencyMs, bucketSpanMs) / bucketSpanMs), MIN_BUCKETS);\n        buckets = new long[maxSize];\n        this.bucketFlushListener = bucketFlushListener;\n"}
{"magic_number_smell": "                double logBucketSize = Math.log(flushedBucketCount);\n                double sparsityScore = logAverageBucketSize - logBucketSize;\n\n                if (sparsityScore > 2) {\n                    LOGGER.debug(\n                        \"Sparse bucket {}, this bucket: {} average: {}, sparsity score: {}\",\n                        flushedBucketStartMs,", "refactored_code": "    private static final int DATA_SPARSITY_THRESHOLD = 2;\n                double logBucketSize = Math.log(flushedBucketCount);\n                double sparsityScore = logAverageBucketSize - logBucketSize;\n\n                if (sparsityScore > DATA_SPARSITY_THRESHOLD) {\n                    LOGGER.debug(\n                        \"Sparse bucket {}, this bucket: {} average: {}, sparsity score: {}\",\n                        flushedBucketStartMs,"}
{"magic_number_smell": "                Result<Bucket> current = buckets.removeFirst();\n                if (current.result.isNormalizable()) {\n                    bucketsToRenormalize.add(new BucketNormalizable(current.result, current.index));\n                    if (bucketsToRenormalize.size() >= 100000) {\n                        normalizeBuckets(normalizer, bucketsToRenormalize, quantilesState, counts);\n                        bucketsToRenormalize.clear();\n                    }", "refactored_code": "    private static final int TARGET_BUCKETS_TO_RENORMALIZE = 100000;\n                Result<Bucket> current = buckets.removeFirst();\n                if (current.result.isNormalizable()) {\n                    bucketsToRenormalize.add(new BucketNormalizable(current.result, current.index));\n                    if (bucketsToRenormalize.size() >= TARGET_BUCKETS_TO_RENORMALIZE) {\n                        normalizeBuckets(normalizer, bucketsToRenormalize, quantilesState, counts);\n                        bucketsToRenormalize.clear();\n                    }"}
{"magic_number_smell": "    public void process() throws IOException {\n        XContent xContent = XContentFactory.xContent(XContentType.JSON);\n        BytesReference bytesRef = null;\n        byte[] readBuf = new byte[1024];\n        for (int bytesRead = inputStream.read(readBuf); bytesRead != -1; bytesRead = inputStream.read(readBuf)) {\n            if (bytesRef == null) {\n                bytesRef = new BytesArray(readBuf, 0, bytesRead);", "refactored_code": "    private static final int READ_BUF_SIZE = 1024;\n    public void process() throws IOException {\n        XContent xContent = XContentFactory.xContent(XContentType.JSON);\n        BytesReference bytesRef = null;\n        byte[] readBuf = new byte[READ_BUF_SIZE];\n        for (int bytesRead = inputStream.read(readBuf); bytesRead != -1; bytesRead = inputStream.read(readBuf)) {\n            if (bytesRef == null) {\n                bytesRef = new BytesArray(readBuf, 0, bytesRead);"}
{"magic_number_smell": "                .filter(QueryBuilders.termQuery(Result.RESULT_TYPE.getPreferredName(), ForecastRequestStats.RESULT_TYPE_VALUE))\n                .filter(QueryBuilders.existsQuery(ForecastRequestStats.EXPIRY_TIME.getPreferredName()))\n        );\n        source.size(10000);\n        source.trackTotalHits(true);\n        source.fetchSource(false);\n        source.docValueField(Job.ID.getPreferredName(), null);", "refactored_code": "    private static final int MAX_FORECASTS = 10000;\n                .filter(QueryBuilders.termQuery(Result.RESULT_TYPE.getPreferredName(), ForecastRequestStats.RESULT_TYPE_VALUE))\n                .filter(QueryBuilders.existsQuery(ForecastRequestStats.EXPIRY_TIME.getPreferredName()))\n        );\n        source.size(MAX_FORECASTS);\n        source.trackTotalHits(true);\n        source.fetchSource(false);\n        source.docValueField(Job.ID.getPreferredName(), null);"}
{"magic_number_smell": "                        long timestampMs = snapshot.getTimestamp().getTime();\n                        if (timestampMs >= nextToKeepMs) {\n                            do {\n                                nextToKeepMs += TimeValue.timeValueDays(1).getMillis();\n                            } while (timestampMs >= nextToKeepMs);\n                            continue;\n                        }", "refactored_code": "    private static final long MS_IN_ONE_DAY = TimeValue.timeValueDays(1).getMillis();\n                        long timestampMs = snapshot.getTimestamp().getTime();\n                        if (timestampMs >= nextToKeepMs) {\n                            do {\n                                nextToKeepMs += MS_IN_ONE_DAY;\n                            } while (timestampMs >= nextToKeepMs);\n                            continue;\n                        }"}
{"magic_number_smell": "    public void process(InputStream in) throws IOException {\n        BytesReference bytesToDate = null;\n        List<BytesReference> newBlocks = new ArrayList<>();\n        byte[] readBuf = new byte[8192];\n        int searchFrom = 0;\n        // The original implementation of this loop created very deeply nested\n        // CompositeBytesReference objects, which caused problems for the bulk persister.", "refactored_code": "    private static final int READ_BUF_SIZE = 8192;\n    public void process(InputStream in) throws IOException {\n        BytesReference bytesToDate = null;\n        List<BytesReference> newBlocks = new ArrayList<>();\n        byte[] readBuf = new byte[READ_BUF_SIZE];\n        int searchFrom = 0;\n        // The original implementation of this loop created very deeply nested\n        // CompositeBytesReference objects, which caused problems for the bulk persister."}
{"magic_number_smell": "     * @param inputStream May not be null.\n     */\n    public CppLogMessageHandler(String jobId, InputStream inputStream) {\n        this(inputStream, jobId, 1024, DEFAULT_ERROR_STORE_SIZE);\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_READBUF_SIZE = 1024;\n     * @param inputStream May not be null.\n     */\n    public CppLogMessageHandler(String jobId, InputStream inputStream) {\n        this(inputStream, jobId, DEFAULT_READBUF_SIZE, DEFAULT_ERROR_STORE_SIZE);\n    }\n\n    /**"}
{"magic_number_smell": "    // todo(hendrikm): workaround, see\n    // https://github.com/elastic/machine-learning-cpp/issues/123\n    protected void fillCommandBuffer() throws IOException {\n        char[] spaces = new char[2048];\n        Arrays.fill(spaces, ' ');\n        writeMessage(new String(spaces));\n    }", "refactored_code": "    public static final int FLUSH_SPACES_LENGTH = 2048;\n    // todo(hendrikm): workaround, see\n    // https://github.com/elastic/machine-learning-cpp/issues/123\n    protected void fillCommandBuffer() throws IOException {\n        char[] spaces = new char[FLUSH_SPACES_LENGTH];\n        Arrays.fill(spaces, ' ');\n        writeMessage(new String(spaces));\n    }"}
{"magic_number_smell": "    private final boolean onlyScorePrunedTokens;\n\n    public TokenPruningConfig() {\n        this(5, DEFAULT_TOKENS_WEIGHT_THRESHOLD, false);\n    }\n\n    public TokenPruningConfig(float tokensFreqRatioThreshold, float tokensWeightThreshold, boolean onlyScorePrunedTokens) {", "refactored_code": "    public static final float DEFAULT_TOKENS_FREQ_RATIO_THRESHOLD = 5;\n    private final boolean onlyScorePrunedTokens;\n\n    public TokenPruningConfig() {\n        this(DEFAULT_TOKENS_FREQ_RATIO_THRESHOLD, DEFAULT_TOKENS_WEIGHT_THRESHOLD, false);\n    }\n\n    public TokenPruningConfig(float tokensFreqRatioThreshold, float tokensWeightThreshold, boolean onlyScorePrunedTokens) {"}
{"magic_number_smell": "        int level\n    ) {\n        // arbitrary, but we must limit this somehow\n        if (level > 10) {\n            return;\n        }\n        if (processorType == null || processorDefinition == null) {", "refactored_code": "    private static final int MAX_INFERENCE_PROCESSOR_SEARCH_RECURSIONS = 10;\n        int level\n    ) {\n        // arbitrary, but we must limit this somehow\n        if (level > MAX_INFERENCE_PROCESSOR_SEARCH_RECURSIONS) {\n            return;\n        }\n        if (processorType == null || processorDefinition == null) {"}
{"magic_number_smell": "                if (timeoutMillisRemaining <= 0) {\n                    propagatePrivilegedException(e);\n                }\n                long thisSleep = Math.min(timeoutMillisRemaining, 20);\n                timeoutMillisRemaining -= thisSleep;\n                try {\n                    Thread.sleep(thisSleep);", "refactored_code": "    private static final long PAUSE_TIME_MS = 20;\n                if (timeoutMillisRemaining <= 0) {\n                    propagatePrivilegedException(e);\n                }\n                long thisSleep = Math.min(timeoutMillisRemaining, PAUSE_TIME_MS);\n                timeoutMillisRemaining -= thisSleep;\n                try {\n                    Thread.sleep(thisSleep);"}
{"magic_number_smell": "    public static long allowedBytesForMl(long machineMemory, int maxMemoryPercent, boolean useAuto) {\n        return allowedBytesForMl(\n            machineMemory,\n            useAuto ? dynamicallyCalculateJvmSizeFromNodeSize(machineMemory) : Math.min(machineMemory / 2, ByteSizeValue.ofGb(31).getBytes()),\n            maxMemoryPercent,\n            useAuto\n        );", "refactored_code": "    public static final long STATIC_JVM_UPPER_THRESHOLD = ByteSizeValue.ofGb(31).getBytes();\n    public static long allowedBytesForMl(long machineMemory, int maxMemoryPercent, boolean useAuto) {\n        return allowedBytesForMl(\n            machineMemory,\n            useAuto ? dynamicallyCalculateJvmSizeFromNodeSize(machineMemory) : Math.min(machineMemory / 2, STATIC_JVM_UPPER_THRESHOLD),\n            maxMemoryPercent,\n            useAuto\n        );"}
{"magic_number_smell": "        searchRequest.indicesOptions(MlIndicesUtils.addIgnoreUnavailable(SearchRequest.DEFAULT_INDICES_OPTIONS));\n        searchRequest.scroll(CONTEXT_ALIVE_DURATION);\n        searchRequest.source(\n            new SearchSourceBuilder().size(10000)\n                .query(getQuery())\n                .fetchSource(shouldFetchSource())\n                .trackTotalHits(true)", "refactored_code": "    private static final int BATCH_SIZE = 10000;\n        searchRequest.indicesOptions(MlIndicesUtils.addIgnoreUnavailable(SearchRequest.DEFAULT_INDICES_OPTIONS));\n        searchRequest.scroll(CONTEXT_ALIVE_DURATION);\n        searchRequest.source(\n            new SearchSourceBuilder().size(BATCH_SIZE)\n                .query(getQuery())\n                .fetchSource(shouldFetchSource())\n                .trackTotalHits(true)"}
{"magic_number_smell": "    }\n\n    public void addAndExecuteIfNeeded(IndexRequest indexRequest) {\n        if (currentRamBytes + indexRequest.ramBytesUsed() > bytesLimit || currentBulkRequest.numberOfActions() == 1000) {\n            execute();\n        }\n        currentBulkRequest.add(indexRequest);", "refactored_code": "    private static final int BATCH_SIZE = 1000;\n    }\n\n    public void addAndExecuteIfNeeded(IndexRequest indexRequest) {\n        if (currentRamBytes + indexRequest.ramBytesUsed() > bytesLimit || currentBulkRequest.numberOfActions() == BATCH_SIZE) {\n            execute();\n        }\n        currentBulkRequest.add(indexRequest);"}
{"magic_number_smell": "    private final boolean trackTotalHits;\n    private final AtomicLong totalHits = new AtomicLong();\n    private final AtomicBoolean lastSearchReturnedResults;\n    private int batchSize = 10_000;\n\n    protected SearchAfterDocumentsIterator(OriginSettingClient client, String index) {\n        this(client, index, false);", "refactored_code": "    private static final int BATCH_SIZE = 10_000;\n    private final boolean trackTotalHits;\n    private final AtomicLong totalHits = new AtomicLong();\n    private final AtomicBoolean lastSearchReturnedResults;\n    private int batchSize = BATCH_SIZE;\n\n    protected SearchAfterDocumentsIterator(OriginSettingClient client, String index) {\n        this(client, index, false);"}
{"magic_number_smell": "    private static final int 10 = 10;\n\n    public void testValidateForecastStateWithAllFailedFinished() {\n        for (int i = 0; i < 10; ++i) {\n            List<SearchHit> forecastRequestStatsHits = Stream.generate(\n                () -> createForecastStatsHit(\n                    randomFrom(ForecastRequestStats.ForecastRequestStatus.FAILED, ForecastRequestStats.ForecastRequestStatus.FINISHED)", "refactored_code": "    private static final int TEST_RUNS = 10;\n    private static final int TEST_RUNS = 10;\n\n    public void testValidateForecastStateWithAllFailedFinished() {\n        for (int i = 0; i < TEST_RUNS; ++i) {\n            List<SearchHit> forecastRequestStatsHits = Stream.generate(\n                () -> createForecastStatsHit(\n                    randomFrom(ForecastRequestStats.ForecastRequestStatus.FAILED, ForecastRequestStats.ForecastRequestStatus.FINISHED)"}
{"magic_number_smell": "    }\n\n    public void testPValueScore() {\n        assertThat(FastMath.exp(-new PValueScore(false, null).getScore(10, 100, 100, 1000)), closeTo(1.0, 1e-9));\n        assertThat(FastMath.exp(-new PValueScore(false, 200L).getScore(10, 100, 100, 1000)), closeTo(1.0, 1e-9));\n        assertThat(FastMath.exp(-new PValueScore(false, null).getScore(10, 100, 10, 1000)), closeTo(0.003972388976814195, 1e-9));\n        assertThat(FastMath.exp(-new PValueScore(false, 200L).getScore(10, 100, 10, 1000)), closeTo(0.020890782016496683, 1e-9));", "refactored_code": "    private static final double eps = 1e-9;\n    }\n\n    public void testPValueScore() {\n        assertThat(FastMath.exp(-new PValueScore(false, null).getScore(10, 100, 100, 1000)), closeTo(1.0, eps));\n        assertThat(FastMath.exp(-new PValueScore(false, 200L).getScore(10, 100, 100, 1000)), closeTo(1.0, eps));\n        assertThat(FastMath.exp(-new PValueScore(false, null).getScore(10, 100, 10, 1000)), closeTo(0.003972388976814195, eps));\n        assertThat(FastMath.exp(-new PValueScore(false, 200L).getScore(10, 100, 10, 1000)), closeTo(0.020890782016496683, eps));"}
{"magic_number_smell": "    private static final long ByteSizeValue.ofMb(360).getBytes() = ByteSizeValue.ofMb(360).getBytes();\n\n    private static final long[] NODE_TIERS_WITH_MONITORING = Arrays.stream(NODE_TIERS_NO_MONITORING)\n        .map(m -> m - ByteSizeValue.ofMb(360).getBytes())\n        .toArray();\n\n    private static final long BYTES_IN_4MB = ByteSizeValue.ofMb(4).getBytes();", "refactored_code": "    private static final long MONITORING_ALLOWANCE_BYTES = ByteSizeValue.ofMb(360).getBytes();\n    private static final long MONITORING_ALLOWANCE_BYTES = ByteSizeValue.ofMb(360).getBytes();\n\n    private static final long[] NODE_TIERS_WITH_MONITORING = Arrays.stream(NODE_TIERS_NO_MONITORING)\n        .map(m -> m - MONITORING_ALLOWANCE_BYTES)\n        .toArray();\n\n    private static final long BYTES_IN_4MB = ByteSizeValue.ofMb(4).getBytes();"}
{"magic_number_smell": "    private static final long ByteSizeValue.ofMb(360).getBytes() = ByteSizeValue.ofMb(360).getBytes();\n\n    private static final long[] NODE_TIERS_WITH_MONITORING = Arrays.stream(NODE_TIERS_NO_MONITORING)\n        .map(m -> m - ByteSizeValue.ofMb(360).getBytes())\n        .toArray();\n\n    private static final long BYTES_IN_4MB = ByteSizeValue.ofMb(4).getBytes();", "refactored_code": "    private static final long MONITORING_ALLOWANCE_BYTES = ByteSizeValue.ofMb(360).getBytes();\n    private static final long MONITORING_ALLOWANCE_BYTES = ByteSizeValue.ofMb(360).getBytes();\n\n    private static final long[] NODE_TIERS_WITH_MONITORING = Arrays.stream(NODE_TIERS_NO_MONITORING)\n        .map(m -> m - MONITORING_ALLOWANCE_BYTES)\n        .toArray();\n\n    private static final long BYTES_IN_4MB = ByteSizeValue.ofMb(4).getBytes();"}
{"magic_number_smell": "                equalTo(0L)\n            );\n        }\n        for (int i = 0; i < 10; i++) {\n            int memoryPercentage = randomIntBetween(5, 200);\n            { // tiny memory\n                long nodeMemory = randomLongBetween(ByteSizeValue.ofKb(100).getBytes(), ByteSizeValue.ofMb(500).getBytes());", "refactored_code": "    private static final int NUM_TEST_RUNS = 10;\n                equalTo(0L)\n            );\n        }\n        for (int i = 0; i < NUM_TEST_RUNS; i++) {\n            int memoryPercentage = randomIntBetween(5, 200);\n            { // tiny memory\n                long nodeMemory = randomLongBetween(ByteSizeValue.ofKb(100).getBytes(), ByteSizeValue.ofMb(500).getBytes());"}
{"magic_number_smell": "        annotationDocId = \"AnnotationDocId\";\n        flushJobResponse = new FlushJobAction.Response(true, Instant.now());\n        delayedDataDetector = mock(DelayedDataDetector.class);\n        when(delayedDataDetector.getWindow()).thenReturn(TimeValue.timeValueMinutes(15).millis());\n        currentTime = 0;\n        when(dataExtractor.hasNext()).thenReturn(true).thenReturn(false);\n        byte[] contentBytes = \"content\".getBytes(StandardCharsets.UTF_8);", "refactored_code": "    private static final long DELAYED_DATA_WINDOW = TimeValue.timeValueMinutes(15).millis();\n        annotationDocId = \"AnnotationDocId\";\n        flushJobResponse = new FlushJobAction.Response(true, Instant.now());\n        delayedDataDetector = mock(DelayedDataDetector.class);\n        when(delayedDataDetector.getWindow()).thenReturn(DELAYED_DATA_WINDOW);\n        currentTime = 0;\n        when(dataExtractor.hasNext()).thenReturn(true).thenReturn(false);\n        byte[] contentBytes = \"content\".getBytes(StandardCharsets.UTF_8);"}
{"magic_number_smell": "    @Before\n    public void setUpTests() {\n        auditor = mock(AnomalyDetectionAuditor.class);\n        problemTracker = new ProblemTracker(auditor, \"foo\", 24L);\n    }\n\n    public void testReportExtractionProblem() {", "refactored_code": "    private static final long NUM_SEARCHES_IN_DAY = 24L;\n    @Before\n    public void setUpTests() {\n        auditor = mock(AnomalyDetectionAuditor.class);\n        problemTracker = new ProblemTracker(auditor, \"foo\", NUM_SEARCHES_IN_DAY);\n    }\n\n    public void testReportExtractionProblem() {"}
{"magic_number_smell": "            assertThat(extractValue(\"_doc.properties.alias-to-numerical-field.type\", map), equalTo(\"alias\"));\n            assertThat(extractValue(\"_doc.properties.alias-to-nested-field.type\", map), equalTo(\"alias\"));\n            assertThat(extractValue(\"_doc._meta.analytics\", map), equalTo(ANALYTICS_ID));\n            assertThat(extractValue(\"_doc._meta.creation_date_in_millis\", map), equalTo(123456789));\n            assertThat(extractValue(\"_doc._meta.created_by\", map), equalTo(CREATED_BY));\n            return map;\n        }", "refactored_code": "    private static final int CURRENT_TIME_MILLIS = 123456789;\n            assertThat(extractValue(\"_doc.properties.alias-to-numerical-field.type\", map), equalTo(\"alias\"));\n            assertThat(extractValue(\"_doc.properties.alias-to-nested-field.type\", map), equalTo(\"alias\"));\n            assertThat(extractValue(\"_doc._meta.analytics\", map), equalTo(ANALYTICS_ID));\n            assertThat(extractValue(\"_doc._meta.creation_date_in_millis\", map), equalTo(CURRENT_TIME_MILLIS));\n            assertThat(extractValue(\"_doc._meta.created_by\", map), equalTo(CREATED_BY));\n            return map;\n        }"}
{"magic_number_smell": "        trainedModelProvider = mock(TrainedModelProvider.class);\n\n        task = mock(DataFrameAnalyticsTask.class);\n        when(task.getAllocationId()).thenReturn(123);\n        when(task.getStatsHolder()).thenReturn(newStatsHolder());\n        when(task.getParentTaskId()).thenReturn(new TaskId(\"\"));\n        dataFrameAnalyticsConfig = DataFrameAnalyticsConfigTests.createRandomBuilder(CONFIG_ID, false, OutlierDetectionTests.createRandom())", "refactored_code": "    private static final long TASK_ALLOCATION_ID = 123;\n        trainedModelProvider = mock(TrainedModelProvider.class);\n\n        task = mock(DataFrameAnalyticsTask.class);\n        when(task.getAllocationId()).thenReturn(TASK_ALLOCATION_ID);\n        when(task.getStatsHolder()).thenReturn(newStatsHolder());\n        when(task.getParentTaskId()).thenReturn(new TaskId(\"\"));\n        dataFrameAnalyticsConfig = DataFrameAnalyticsConfigTests.createRandomBuilder(CONFIG_ID, false, OutlierDetectionTests.createRandom())"}
{"magic_number_smell": "        processFactory = mock(AnalyticsProcessFactory.class);\n        when(processFactory.createAnalyticsProcess(any(), any(), anyBoolean(), any(), any())).thenReturn(process);\n        dataExtractor = mock(DataFrameDataExtractor.class);\n        when(dataExtractor.collectDataSummary()).thenReturn(new DataFrameDataExtractor.DataSummary(100, NUM_COLS));\n        dataExtractorFactory = mock(DataFrameDataExtractorFactory.class);\n        when(dataExtractorFactory.newExtractor(anyBoolean())).thenReturn(dataExtractor);\n        when(dataExtractorFactory.getExtractedFields()).thenReturn(mock(ExtractedFields.class));", "refactored_code": "    private static final int NUM_ROWS = 100;\n        processFactory = mock(AnalyticsProcessFactory.class);\n        when(processFactory.createAnalyticsProcess(any(), any(), anyBoolean(), any(), any())).thenReturn(process);\n        dataExtractor = mock(DataFrameDataExtractor.class);\n        when(dataExtractor.collectDataSummary()).thenReturn(new DataFrameDataExtractor.DataSummary(NUM_ROWS, NUM_COLS));\n        dataExtractorFactory = mock(DataFrameDataExtractorFactory.class);\n        when(dataExtractorFactory.newExtractor(anyBoolean())).thenReturn(dataExtractor);\n        when(dataExtractorFactory.getExtractedFields()).thenReturn(mock(ExtractedFields.class));"}
{"magic_number_smell": "        long classB = 0;\n        long classC = 0;\n\n        classValuesPerRow = new String[500];\n        for (int i = 0; i < classValuesPerRow.length; i++) {\n            double randomDouble = randomDoubleBetween(0.0, 1.0, true);\n            if (randomDouble < 0.2) {", "refactored_code": "    private static final int ROWS_COUNT = 500;\n        long classB = 0;\n        long classC = 0;\n\n        classValuesPerRow = new String[ROWS_COUNT];\n        for (int i = 0; i < classValuesPerRow.length; i++) {\n            double randomDouble = randomDoubleBetween(0.0, 1.0, true);\n            if (randomDouble < 0.2) {"}
{"magic_number_smell": "            maxRunningJobsPerNode,\n            2,\n            maxMachineMemoryPercent,\n            ByteSizeValue.ofGb(1).getBytes(),\n            false\n        );\n        assertNull(result.getExecutorNode());", "refactored_code": "    private static final long MAX_JOB_BYTES = ByteSizeValue.ofGb(1).getBytes();\n            maxRunningJobsPerNode,\n            2,\n            maxMachineMemoryPercent,\n            MAX_JOB_BYTES,\n            false\n        );\n        assertNull(result.getExecutorNode());"}
{"magic_number_smell": "                                    new StartTrainedModelDeploymentAction.TaskParams(\n                                        \"model1\",\n                                        \"deployment1\",\n                                        ByteSizeValue.ofMb(50).getBytes(),\n                                        1,\n                                        1,\n                                        1024,", "refactored_code": "    private static final long MODEL_MEMORY_REQUIREMENT = ByteSizeValue.ofMb(50).getBytes();\n                                    new StartTrainedModelDeploymentAction.TaskParams(\n                                        \"model1\",\n                                        \"deployment1\",\n                                        MODEL_MEMORY_REQUIREMENT,\n                                        1,\n                                        1,\n                                        1024,"}
{"magic_number_smell": "    }\n\n    private ProcessWorkerExecutorService createExecutorService() {\n        return new ProcessWorkerExecutorService(threadPool.getThreadContext(), TEST_PROCESS, 100);\n    }\n}\n", "refactored_code": "    private static final int QUEUE_SIZE = 100;\n    }\n\n    private ProcessWorkerExecutorService createExecutorService() {\n        return new ProcessWorkerExecutorService(threadPool.getThreadContext(), TEST_PROCESS, QUEUE_SIZE);\n    }\n}\n"}
{"magic_number_smell": "                \"foo\",\n                mock(NativeController.class),\n                processPipes,\n                5,\n                null,\n                new ProcessResultsParser<>(AutodetectResult.PARSER, NamedXContentRegistry.EMPTY),\n                mock(Consumer.class)", "refactored_code": "    private static final int NUMBER_FIELDS = 5;\n                \"foo\",\n                mock(NativeController.class),\n                processPipes,\n                NUMBER_FIELDS,\n                null,\n                new ProcessResultsParser<>(AutodetectResult.PARSER, NamedXContentRegistry.EMPTY),\n                mock(Consumer.class)"}
{"magic_number_smell": "            persister,\n            annotationPersister,\n            process,\n            new ModelSizeStats.Builder(JOB_ID).setTimestamp(new Date(1000)).build(),\n            new TimingStats(JOB_ID),\n            Clock.fixed(CURRENT_TIME, ZoneId.systemDefault()),\n            flushListener", "refactored_code": "    private static final long BUCKET_SPAN_MS = 1000;\n            persister,\n            annotationPersister,\n            process,\n            new ModelSizeStats.Builder(JOB_ID).setTimestamp(new Date(BUCKET_SPAN_MS)).build(),\n            new TimingStats(JOB_ID),\n            Clock.fixed(CURRENT_TIME, ZoneId.systemDefault()),\n            flushListener"}
{"magic_number_smell": "    @Before\n    public void setUpMocks() {\n        AnalysisConfig.Builder acBuilder = new AnalysisConfig.Builder(Arrays.asList(new Detector.Builder(\"metric\", \"field\").build()));\n        acBuilder.setBucketSpan(TimeValue.timeValueMillis(60000));\n        acBuilder.setLatency(TimeValue.ZERO);\n        acBuilder.setDetectors(Arrays.asList(new Detector.Builder(\"metric\", \"field\").build()));\n", "refactored_code": "    private static final long BUCKET_SPAN = 60000;\n    @Before\n    public void setUpMocks() {\n        AnalysisConfig.Builder acBuilder = new AnalysisConfig.Builder(Arrays.asList(new Detector.Builder(\"metric\", \"field\").build()));\n        acBuilder.setBucketSpan(TimeValue.timeValueMillis(BUCKET_SPAN));\n        acBuilder.setLatency(TimeValue.ZERO);\n        acBuilder.setDetectors(Arrays.asList(new Detector.Builder(\"metric\", \"field\").build()));\n"}
{"magic_number_smell": "    }\n\n    public void testGetProbability() {\n        assertEquals(0.05, new BucketInfluencerNormalizable(bucketInfluencer, INDEX_NAME).getProbability(), 0.0001);\n    }\n\n    public void testGetNormalizedScore() {", "refactored_code": "    private static final double EPSILON = 0.0001;\n    }\n\n    public void testGetProbability() {\n        assertEquals(0.05, new BucketInfluencerNormalizable(bucketInfluencer, INDEX_NAME).getProbability(), EPSILON);\n    }\n\n    public void testGetNormalizedScore() {"}
{"magic_number_smell": "    }\n\n    public void testGetNormalizedScore() {\n        assertEquals(88.0, new BucketNormalizable(bucket, INDEX_NAME).getNormalizedScore(), 0.0001);\n    }\n\n    public void testSetNormalizedScore() {", "refactored_code": "    private static final double EPSILON = 0.0001;\n    }\n\n    public void testGetNormalizedScore() {\n        assertEquals(88.0, new BucketNormalizable(bucket, INDEX_NAME).getNormalizedScore(), EPSILON);\n    }\n\n    public void testSetNormalizedScore() {"}
{"magic_number_smell": "    }\n\n    public void testGetProbability() {\n        assertEquals(0.05, new InfluencerNormalizable(influencer, INDEX_NAME).getProbability(), 0.0001);\n    }\n\n    public void testGetNormalizedScore() {", "refactored_code": "    private static final double EPSILON = 0.0001;\n    }\n\n    public void testGetProbability() {\n        assertEquals(0.05, new InfluencerNormalizable(influencer, INDEX_NAME).getProbability(), EPSILON);\n    }\n\n    public void testGetNormalizedScore() {"}
{"magic_number_smell": "        assertNull(msg.getPersonFieldValue());\n        assertNull(msg.getFunctionName());\n        assertNull(msg.getValueFieldName());\n        assertEquals(0.0, msg.getProbability(), 0.0000000001);\n        assertEquals(0.0, msg.getNormalizedScore(), 0.0000000001);\n    }\n", "refactored_code": "    private static final double EPSILON = 0.0000000001;\n        assertNull(msg.getPersonFieldValue());\n        assertNull(msg.getFunctionName());\n        assertNull(msg.getValueFieldName());\n        assertEquals(0.0, msg.getProbability(), EPSILON);\n        assertEquals(0.0, msg.getNormalizedScore(), EPSILON);\n    }\n"}
{"magic_number_smell": "    private static final double FACTOR = 2.0;\n\n    private Bucket generateBucket(Date timestamp) {\n        return new Bucket(JOB_ID, timestamp, 600);\n    }\n\n    private BucketInfluencer createTimeBucketInfluencer(Date timestamp, double probability, double anomalyScore) {", "refactored_code": "    private static final int BUCKET_SPAN = 600;\n    private static final double FACTOR = 2.0;\n\n    private Bucket generateBucket(Date timestamp) {\n        return new Bucket(JOB_ID, timestamp, BUCKET_SPAN);\n    }\n\n    private BucketInfluencer createTimeBucketInfluencer(Date timestamp, double probability, double anomalyScore) {"}
{"magic_number_smell": "    private ScoresUpdater scoresUpdater;\n\n    private Bucket generateBucket(Date timestamp) {\n        return new Bucket(JOB_ID, timestamp, 3600);\n    }\n\n    @Before", "refactored_code": "    private static final long DEFAULT_BUCKET_SPAN = 3600;\n    private ScoresUpdater scoresUpdater;\n\n    private Bucket generateBucket(Date timestamp) {\n        return new Bucket(JOB_ID, timestamp, DEFAULT_BUCKET_SPAN);\n    }\n\n    @Before"}
{"magic_number_smell": "            ShortCircuitingRenormalizer renormalizer = new ShortCircuitingRenormalizer(JOB_ID, scoresUpdater, threadpool);\n\n            // Blast through many sets of quantiles in quick succession, faster than the normalizer can process them\n            for (int i = 1; i < 1000 / 2; ++i) {\n                Quantiles quantiles = new Quantiles(JOB_ID, new Date(), Integer.toString(i));\n                renormalizer.renormalize(quantiles, () -> {});\n            }", "refactored_code": "    private static final int TEST_SIZE = 1000;\n            ShortCircuitingRenormalizer renormalizer = new ShortCircuitingRenormalizer(JOB_ID, scoresUpdater, threadpool);\n\n            // Blast through many sets of quantiles in quick succession, faster than the normalizer can process them\n            for (int i = 1; i < TEST_SIZE / 2; ++i) {\n                Quantiles quantiles = new Quantiles(JOB_ID, new Date(), Integer.toString(i));\n                renormalizer.renormalize(quantiles, () -> {});\n            }"}
{"magic_number_smell": "        handler.process();\n        List<NormalizerResult> results = handler.getNormalizedResults();\n        assertEquals(3, results.size());\n        assertEquals(88.88, results.get(0).getNormalizedScore(), 0.0000001);\n        assertEquals(44.44, results.get(1).getNormalizedScore(), 0.0000001);\n        assertEquals(22.22, results.get(2).getNormalizedScore(), 0.0000001);\n    }", "refactored_code": "    private static final double EPSILON = 0.0000001;\n        handler.process();\n        List<NormalizerResult> results = handler.getNormalizedResults();\n        assertEquals(3, results.size());\n        assertEquals(88.88, results.get(0).getNormalizedScore(), EPSILON);\n        assertEquals(44.44, results.get(1).getNormalizedScore(), EPSILON);\n        assertEquals(22.22, results.get(2).getNormalizedScore(), EPSILON);\n    }"}
{"magic_number_smell": "    }\n\n    public Bucket createTestInstance(String jobId) {\n        Bucket bucket = new Bucket(jobId, randomDate(), randomLongBetween(1, 100_000_000_000L));\n        if (randomBoolean()) {\n            bucket.setAnomalyScore(randomDouble());\n        }", "refactored_code": "    private static final long MAX_BUCKET_SPAN_SEC = 100_000_000_000L;  // bucket span of > 3000 years should be enough for everyone\n    }\n\n    public Bucket createTestInstance(String jobId) {\n        Bucket bucket = new Bucket(jobId, randomDate(), randomLongBetween(1, MAX_BUCKET_SPAN_SEC));\n        if (randomBoolean()) {\n            bucket.setAnomalyScore(randomDouble());\n        }"}
{"magic_number_smell": "    public void testLargeStateRead() throws Exception {\n        when(searchResponse.getHits()).thenReturn(SearchHits.EMPTY_WITH_TOTAL_HITS);\n\n        StringBuilder builder = new StringBuilder(2 * (LARGE_DOC_SIZE + 10)); // 10 for header and separators\n        for (int docNum = 1; docNum <= 2; ++docNum) {\n            builder.append(\"{\\\"index\\\":{\\\"_index\\\":\\\"header\").append(docNum).append(\"\\\",\\\"_id\\\":\\\"doc\").append(docNum).append(\"\\\"}}\\n\");\n            for (int count = 0; count < (LARGE_DOC_SIZE / \"data\".length()); ++count) {", "refactored_code": "    private static final int NUM_LARGE_DOCS = 2;\n    public void testLargeStateRead() throws Exception {\n        when(searchResponse.getHits()).thenReturn(SearchHits.EMPTY_WITH_TOTAL_HITS);\n\n        StringBuilder builder = new StringBuilder(NUM_LARGE_DOCS * (LARGE_DOC_SIZE + 10)); // 10 for header and separators\n        for (int docNum = 1; docNum <= NUM_LARGE_DOCS; ++docNum) {\n            builder.append(\"{\\\"index\\\":{\\\"_index\\\":\\\"header\").append(docNum).append(\"\\\",\\\"_id\\\":\\\"doc\").append(docNum).append(\"\\\"}}\\n\");\n            for (int count = 0; count < (LARGE_DOC_SIZE / \"data\".length()); ++count) {"}
{"magic_number_smell": "        // Randomisation cannot be used here as {@code #doAssertLuceneQuery}\n        // asserts that 2 rewritten queries are the same\n        var tokens = new ArrayList<TextExpansionResults.WeightedToken>();\n        for (int i = 0; i < 10; i++) {\n            tokens.add(new TextExpansionResults.WeightedToken(Integer.toString(i), (i + 1) * 1.0f));\n        }\n", "refactored_code": "    private static final int NUM_TOKENS = 10;\n        // Randomisation cannot be used here as {@code #doAssertLuceneQuery}\n        // asserts that 2 rewritten queries are the same\n        var tokens = new ArrayList<TextExpansionResults.WeightedToken>();\n        for (int i = 0; i < NUM_TOKENS; i++) {\n            tokens.add(new TextExpansionResults.WeightedToken(Integer.toString(i), (i + 1) * 1.0f));\n        }\n"}
{"magic_number_smell": "        assertThat(query, instanceOf(BooleanQuery.class));\n        BooleanQuery booleanQuery = (BooleanQuery) query;\n        assertEquals(booleanQuery.getMinimumNumberShouldMatch(), 1);\n        assertThat(booleanQuery.clauses(), hasSize(WEIGHTED_TOKENS.size()));\n\n        Class<?> featureQueryClass = FeatureField.newLinearQuery(\"\", \"\", 0.5f).getClass();\n        // if the weight is 1.0f a BoostQuery is returned", "refactored_code": "    private static final int NUM_TOKENS = WEIGHTED_TOKENS.size();\n        assertThat(query, instanceOf(BooleanQuery.class));\n        BooleanQuery booleanQuery = (BooleanQuery) query;\n        assertEquals(booleanQuery.getMinimumNumberShouldMatch(), 1);\n        assertThat(booleanQuery.clauses(), hasSize(NUM_TOKENS));\n\n        Class<?> featureQueryClass = FeatureField.newLinearQuery(\"\", \"\", 0.5f).getClass();\n        // if the weight is 1.0f a BoostQuery is returned"}
{"magic_number_smell": "    );\n\n    public void testAllowedBytesForMLWhenAutoIsFalse() {\n        for (int i = 0; i < 10; i++) {\n            long nodeSize = randomLongBetween(ByteSizeValue.ofMb(500).getBytes(), ByteSizeValue.ofGb(64).getBytes());\n            int percent = randomIntBetween(5, 200);\n            DiscoveryNode node = newNode(randomLongBetween(1, nodeSize / 2), nodeSize);", "refactored_code": "    private static final int NUM_TEST_RUNS = 10;\n    );\n\n    public void testAllowedBytesForMLWhenAutoIsFalse() {\n        for (int i = 0; i < NUM_TEST_RUNS; i++) {\n            long nodeSize = randomLongBetween(ByteSizeValue.ofMb(500).getBytes(), ByteSizeValue.ofGb(64).getBytes());\n            int percent = randomIntBetween(5, 200);\n            DiscoveryNode node = newNode(randomLongBetween(1, nodeSize / 2), nodeSize);"}
{"magic_number_smell": "\n        InputStream modelInputStream = ModelLoaderUtils.getInputStreamFromModelRepository(uri);\n\n        ModelLoaderUtils.InputStreamChunker chunkIterator = new ModelLoaderUtils.InputStreamChunker(modelInputStream, 1024 * 1024);\n\n        // simple round up\n        int totalParts = (int) ((size + 1024 * 1024 - 1) / 1024 * 1024);", "refactored_code": "    private static final int DEFAULT_CHUNK_SIZE = 1024 * 1024; // 1MB\n\n        InputStream modelInputStream = ModelLoaderUtils.getInputStreamFromModelRepository(uri);\n\n        ModelLoaderUtils.InputStreamChunker chunkIterator = new ModelLoaderUtils.InputStreamChunker(modelInputStream, DEFAULT_CHUNK_SIZE);\n\n        // simple round up\n        int totalParts = (int) ((size + DEFAULT_CHUNK_SIZE - 1) / DEFAULT_CHUNK_SIZE);"}
{"magic_number_smell": "\n    /**\n     * Current version of templates used in their name to differentiate from breaking changes (separate from product version).\n     * This would have been used for {@link MonitoringTemplateRegistry#8_12_00_99}, but the legacy monitoring\n     * template installation process used the release version of the last template change in the template version\n     * field instead. We keep it around to substitute into the template names.\n     */", "refactored_code": "    public static final int REGISTRY_VERSION = 8_12_00_99;\n\n    /**\n     * Current version of templates used in their name to differentiate from breaking changes (separate from product version).\n     * This would have been used for {@link MonitoringTemplateRegistry#REGISTRY_VERSION}, but the legacy monitoring\n     * template installation process used the release version of the last template change in the template version\n     * field instead. We keep it around to substitute into the template names.\n     */"}
{"magic_number_smell": "            source = source.replace(CLUSTER_UUID_PROPERTY, clusterUuid);\n            source = source.replace(WATCH_ID_PROPERTY, watchId);\n            source = source.replace(UNIQUE_WATCH_ID_PROPERTY, uniqueWatchId);\n            source = source.replace(VERSION_CREATED_PROPERTY, Integer.toString(7_05_00_99));\n\n            return source;\n        } catch (final IOException e) {", "refactored_code": "    public static final int LAST_UPDATED_VERSION = 7_05_00_99;\n            source = source.replace(CLUSTER_UUID_PROPERTY, clusterUuid);\n            source = source.replace(WATCH_ID_PROPERTY, watchId);\n            source = source.replace(UNIQUE_WATCH_ID_PROPERTY, uniqueWatchId);\n            source = source.replace(VERSION_CREATED_PROPERTY, Integer.toString(LAST_UPDATED_VERSION));\n\n            return source;\n        } catch (final IOException e) {"}
{"magic_number_smell": "        final String host = fakeTransportAddress.address().getHostString();\n        final String transportAddress = fakeTransportAddress.toString();\n        final String ip = fakeTransportAddress.getAddress();\n        final long timestamp = RandomNumbers.randomLongBetween(random, 0, 253402300799999L);\n\n        return new MonitoringDoc.Node(id, host, transportAddress, ip, name, timestamp);\n    }", "refactored_code": "    public static final long MAX_MILLIS_BEFORE_10000 = 253402300799999L;\n        final String host = fakeTransportAddress.address().getHostString();\n        final String transportAddress = fakeTransportAddress.toString();\n        final String ip = fakeTransportAddress.getAddress();\n        final long timestamp = RandomNumbers.randomLongBetween(random, 0, MAX_MILLIS_BEFORE_10000);\n\n        return new MonitoringDoc.Node(id, host, transportAddress, ip, name, timestamp);\n    }"}
{"magic_number_smell": "    private final Index index = new Index(\"logstash-2017.10.27\", \"aBcDeFg\");\n    private final int randomIntBetween(1, 5) = randomIntBetween(1, 5);\n    private final int replicas = randomIntBetween(0, 2);\n    private final int total = randomIntBetween(1, 5) + (randomIntBetween(1, 5) * replicas);\n    private final int activePrimaries = randomInt(randomIntBetween(1, 5));\n    private final int activeReplicas = randomInt(activePrimaries * replicas);\n    private final int initializing = randomInt(randomIntBetween(1, 5) - activePrimaries + Math.max(0, activePrimaries * replicas - activeReplicas));", "refactored_code": "    private final int primaries = randomIntBetween(1, 5);\n    private final Index index = new Index(\"logstash-2017.10.27\", \"aBcDeFg\");\n    private final int primaries = randomIntBetween(1, 5);\n    private final int replicas = randomIntBetween(0, 2);\n    private final int total = primaries + (primaries * replicas);\n    private final int activePrimaries = randomInt(primaries);\n    private final int activeReplicas = randomInt(activePrimaries * replicas);\n    private final int initializing = randomInt(primaries - activePrimaries + Math.max(0, activePrimaries * replicas - activeReplicas));"}
{"magic_number_smell": "    public void testDoCheckGetWatchExists() throws IOException {\n        when(licenseState.isAllowed(Monitoring.MONITORING_CLUSTER_ALERTS_FEATURE)).thenReturn(true);\n\n        final HttpEntity entity = entityForClusterAlert(true, Math.min(ClusterAlertsUtil.LAST_UPDATED_VERSION, Version.CURRENT.id));\n\n        doCheckWithStatusCode(resource, \"/_watcher/watch\", watchId, successfulCheckStatus(), true, entity);\n    }", "refactored_code": "    private final int minimumVersion = Math.min(ClusterAlertsUtil.LAST_UPDATED_VERSION, Version.CURRENT.id);\n    public void testDoCheckGetWatchExists() throws IOException {\n        when(licenseState.isAllowed(Monitoring.MONITORING_CLUSTER_ALERTS_FEATURE)).thenReturn(true);\n\n        final HttpEntity entity = entityForClusterAlert(true, minimumVersion);\n\n        doCheckWithStatusCode(resource, \"/_watcher/watch\", watchId, successfulCheckStatus(), true, entity);\n    }"}
{"magic_number_smell": "\n    private final RestClient client = mock(RestClient.class);\n    private final Response versionResponse = mock(Response.class);\n    private final List<String> templateNames = new ArrayList<>(TEMPLATE_NAMES.length);\n    private final List<String> watchNames = new ArrayList<>(EXPECTED_WATCHES);\n\n    private final Settings exporterSettings = Settings.builder()", "refactored_code": "    private final int EXPECTED_TEMPLATES = TEMPLATE_NAMES.length;\n\n    private final RestClient client = mock(RestClient.class);\n    private final Response versionResponse = mock(Response.class);\n    private final List<String> templateNames = new ArrayList<>(EXPECTED_TEMPLATES);\n    private final List<String> watchNames = new ArrayList<>(EXPECTED_WATCHES);\n\n    private final Settings exporterSettings = Settings.builder()"}
{"magic_number_smell": "    public void testBuilder() {\n        assertHttpHost(HttpHostBuilder.builder(hostname), Scheme.HTTP, hostname, 9200);\n        assertHttpHost(HttpHostBuilder.builder(scheme.toString() + \"://\" + hostname), scheme, hostname, 9200);\n        assertHttpHost(HttpHostBuilder.builder(scheme.toString() + \"://\" + hostname + \":\" + randomIntBetween(1, 65535)), scheme, hostname, randomIntBetween(1, 65535));\n        // weird randomIntBetween(1, 65535), but I don't expect it to explode\n        assertHttpHost(HttpHostBuilder.builder(scheme.toString() + \"://\" + hostname + \":-1\"), scheme, hostname, 9200);\n        // randomIntBetween(1, 65535) without scheme", "refactored_code": "    private final int port = randomIntBetween(1, 65535);\n    public void testBuilder() {\n        assertHttpHost(HttpHostBuilder.builder(hostname), Scheme.HTTP, hostname, 9200);\n        assertHttpHost(HttpHostBuilder.builder(scheme.toString() + \"://\" + hostname), scheme, hostname, 9200);\n        assertHttpHost(HttpHostBuilder.builder(scheme.toString() + \"://\" + hostname + \":\" + port), scheme, hostname, port);\n        // weird port, but I don't expect it to explode\n        assertHttpHost(HttpHostBuilder.builder(scheme.toString() + \"://\" + hostname + \":-1\"), scheme, hostname, 9200);\n        // port without scheme"}
{"magic_number_smell": "    private final TemplateHttpResource resource = new TemplateHttpResource(owner, masterTimeout, templateName);\n\n    public void testDoCheckExists() {\n        final HttpEntity entity = entityForResource(true, templateName, Math.min(MonitoringTemplateUtils.LAST_UPDATED_VERSION, Version.CURRENT.id));\n\n        doCheckWithStatusCode(resource, \"/_template\", templateName, successfulCheckStatus(), true, entity);\n    }", "refactored_code": "    private final int minimumVersion = Math.min(MonitoringTemplateUtils.LAST_UPDATED_VERSION, Version.CURRENT.id);\n    private final TemplateHttpResource resource = new TemplateHttpResource(owner, masterTimeout, templateName);\n\n    public void testDoCheckExists() {\n        final HttpEntity entity = entityForResource(true, templateName, minimumVersion);\n\n        doCheckWithStatusCode(resource, \"/_template\", templateName, successfulCheckStatus(), true, entity);\n    }"}
{"magic_number_smell": "\n    @Before\n    public void configureTimeouts() {\n        when(connectTimeout.millis()).thenReturn((long) randomInt());\n        when(socketTimeout.millis()).thenReturn((long) socketTimeoutMillis);\n    }\n", "refactored_code": "    private final int connectTimeoutMillis = randomInt();\n\n    @Before\n    public void configureTimeouts() {\n        when(connectTimeout.millis()).thenReturn((long) connectTimeoutMillis);\n        when(socketTimeout.millis()).thenReturn((long) socketTimeoutMillis);\n    }\n"}
{"magic_number_smell": "            if (magic != CodecUtil.CODEC_MAGIC) {\n                throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n            }\n            format = CodecUtil.checkHeaderNoMagic(input, \"segments\", 6, VERSION_CURRENT);\n            byte[] id = new byte[StringHelper.ID_LENGTH];\n            input.readBytes(id, 0, id.length);\n            CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));", "refactored_code": "    public static final int VERSION_53 = 6;\n            if (magic != CodecUtil.CODEC_MAGIC) {\n                throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);\n            }\n            format = CodecUtil.checkHeaderNoMagic(input, \"segments\", VERSION_53, VERSION_CURRENT);\n            byte[] id = new byte[StringHelper.ID_LENGTH];\n            input.readBytes(id, 0, id.length);\n            CodecUtil.checkIndexHeaderSuffix(input, Long.toString(generation, Character.MAX_RADIX));"}
{"magic_number_smell": "    /**\n     * Returns the next ordinal for the current document (previously\n     * set by {@link #setDocument(int)}.\n     * @return next ordinal for the document, or {@link #-1}.\n     *         ordinals are dense, start at 0, then increment by 1 for\n     *         the next value in sorted order.\n     */", "refactored_code": "    public static final long NO_MORE_ORDS = -1;\n    /**\n     * Returns the next ordinal for the current document (previously\n     * set by {@link #setDocument(int)}.\n     * @return next ordinal for the document, or {@link #NO_MORE_ORDS}.\n     *         ordinals are dense, start at 0, then increment by 1 for\n     *         the next value in sorted order.\n     */"}
{"magic_number_smell": "            version = CodecUtil.checkIndexHeader(\n                termsIn,\n                TERMS_CODEC_NAME,\n                2,\n                VERSION_CURRENT,\n                state.segmentInfo.getId(),\n                state.segmentSuffix", "refactored_code": "    public static final int VERSION_START = 2;\n            version = CodecUtil.checkIndexHeader(\n                termsIn,\n                TERMS_CODEC_NAME,\n                VERSION_START,\n                VERSION_CURRENT,\n                state.segmentInfo.getId(),\n                state.segmentSuffix"}
{"magic_number_smell": "\n    @Override\n    public String toString() {\n        return getName() + \"(blocksize=\" + 128 + \")\";\n    }\n\n    @Override", "refactored_code": "    public static final int BLOCK_SIZE = 128;\n\n    @Override\n    public String toString() {\n        return getName() + \"(blocksize=\" + BLOCK_SIZE + \")\";\n    }\n\n    @Override"}
{"magic_number_smell": "     */\n    void writeBlock(int[] data, byte[] encoded, IndexOutput out) throws IOException {\n        if (isAllEqual(data)) {\n            out.writeByte((byte) 0);\n            out.writeVInt(data[0]);\n            return;\n        }", "refactored_code": "    private static final int ALL_VALUES_EQUAL = 0;\n     */\n    void writeBlock(int[] data, byte[] encoded, IndexOutput out) throws IOException {\n        if (isAllEqual(data)) {\n            out.writeByte((byte) ALL_VALUES_EQUAL);\n            out.writeVInt(data[0]);\n            return;\n        }"}
{"magic_number_smell": "    final int version;\n\n    public MetadataOnlyBKDReader(IndexInput metaIn) throws IOException {\n        version = CodecUtil.checkHeader(metaIn, \"BKD\", 0, VERSION_CURRENT);\n        final int numDims = metaIn.readVInt();\n        final int numIndexDims;\n        if (version >= VERSION_SELECTIVE_INDEXING) {", "refactored_code": "    public static final int VERSION_START = 0;\n    final int version;\n\n    public MetadataOnlyBKDReader(IndexInput metaIn) throws IOException {\n        version = CodecUtil.checkHeader(metaIn, \"BKD\", VERSION_START, VERSION_CURRENT);\n        final int numDims = metaIn.readVInt();\n        final int numIndexDims;\n        if (version >= VERSION_SELECTIVE_INDEXING) {"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed(BytesRef output) {\n        return RamUsageEstimator.shallowSizeOf(NO_OUTPUT) + RamUsageEstimator.sizeOf(output.bytes);\n    }\n\n    @Override", "refactored_code": "    private static final long BASE_NUM_BYTES = RamUsageEstimator.shallowSizeOf(NO_OUTPUT);\n\n    @Override\n    public long ramBytesUsed(BytesRef output) {\n        return BASE_NUM_BYTES + RamUsageEstimator.sizeOf(output.bytes);\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        long size = RamUsageEstimator.shallowSizeOfInstance(FST.class);\n        if (this.fstStore != null) {\n            size += this.fstStore.ramBytesUsed();\n        } else {", "refactored_code": "    private static final long BASE_RAM_BYTES_USED = RamUsageEstimator.shallowSizeOfInstance(FST.class);\n\n    @Override\n    public long ramBytesUsed() {\n        long size = BASE_RAM_BYTES_USED;\n        if (this.fstStore != null) {\n            size += this.fstStore.ramBytesUsed();\n        } else {"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        return RamUsageEstimator.shallowSizeOfInstance(OffHeapFSTStore.class);\n    }\n\n    @Override", "refactored_code": "    private static final long BASE_RAM_BYTES_USED = RamUsageEstimator.shallowSizeOfInstance(OffHeapFSTStore.class);\n\n    @Override\n    public long ramBytesUsed() {\n        return BASE_RAM_BYTES_USED;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public long ramBytesUsed() {\n        return RamUsageEstimator.shallowSizeOfInstance(OnHeapFSTStore.class) + size();\n    }\n\n    @Override", "refactored_code": "    private static final long BASE_RAM_BYTES_USED = RamUsageEstimator.shallowSizeOfInstance(OnHeapFSTStore.class);\n\n    @Override\n    public long ramBytesUsed() {\n        return BASE_RAM_BYTES_USED + size();\n    }\n\n    @Override"}
{"magic_number_smell": "        doc.add(field6);\n        doc.add(field7);\n        doc.add(field8);\n        for (int i = 0; i < TEST_NIGHTLY ? Lucene50PostingsFormat.BLOCK_SIZE * 20 : Lucene50PostingsFormat.BLOCK_SIZE * 3; i++) {\n            String stringValue = Integer.toString(i)\n                + \" verycommon \"\n                + English.intToEnglish(i).replace('-', ' ')", "refactored_code": "    private final int MAXDOC = TEST_NIGHTLY ? Lucene50PostingsFormat.BLOCK_SIZE * 20 : Lucene50PostingsFormat.BLOCK_SIZE * 3;\n        doc.add(field6);\n        doc.add(field7);\n        doc.add(field8);\n        for (int i = 0; i < MAXDOC; i++) {\n            String stringValue = Integer.toString(i)\n                + \" verycommon \"\n                + English.intToEnglish(i).replace('-', ' ')"}
{"magic_number_smell": "    }\n\n    public double getAnnualCO2Tons(String hostID, long samples) {\n        double annualCoreHours = CostCalculator.annualCoreHours(samplingDurationInSeconds, samples, 20.0d);\n\n        HostMetadata host = hostMetadata.get(hostID);\n        if (host == null) {", "refactored_code": "    private static final double DEFAULT_SAMPLING_FREQUENCY = 20.0d;\n    }\n\n    public double getAnnualCO2Tons(String hostID, long samples) {\n        double annualCoreHours = CostCalculator.annualCoreHours(samplingDurationInSeconds, samples, DEFAULT_SAMPLING_FREQUENCY);\n\n        HostMetadata host = hostMetadata.get(hostID);\n        if (host == null) {"}
{"magic_number_smell": "    }\n\n    public double annualCostsUSD(String hostID, double samples) {\n        double annualCoreHours = annualCoreHours(samplingDurationInSeconds, samples, 20.0d);\n\n        HostMetadata host = hostMetadata.get(hostID);\n        if (host == null) {", "refactored_code": "    private static final double DEFAULT_SAMPLING_FREQUENCY = 20.0d;\n    }\n\n    public double annualCostsUSD(String hostID, double samples) {\n        double annualCoreHours = annualCoreHours(samplingDurationInSeconds, samples, DEFAULT_SAMPLING_FREQUENCY);\n\n        HostMetadata host = hostMetadata.get(hostID);\n        if (host == null) {"}
{"magic_number_smell": "\n    // Start with counting the results in the index down-sampled by 5^6.\n    // That is in the middle of our down-sampled indexes.\n    public static final EventsIndex MEDIUM_DOWNSAMPLED = fromFactorAndExponent(5, 6);\n\n    private final String name;\n", "refactored_code": "    private static final int SAMPLING_FACTOR = 5;\n\n    // Start with counting the results in the index down-sampled by 5^6.\n    // That is in the middle of our down-sampled indexes.\n    public static final EventsIndex MEDIUM_DOWNSAMPLED = fromFactorAndExponent(SAMPLING_FACTOR, 6);\n\n    private final String name;\n"}
{"magic_number_smell": "        Double customPerCoreWattARM64,\n        Double customCostPerCoreHour\n    ) {\n        this.sampleSize = sampleSize != null ? sampleSize : 20_000;\n        this.requestedDuration = requestedDuration;\n        this.awsCostFactor = awsCostFactor;\n        this.azureCostFactor = azureCostFactor;", "refactored_code": "    private static final int DEFAULT_SAMPLE_SIZE = 20_000;\n        Double customPerCoreWattARM64,\n        Double customCostPerCoreHour\n    ) {\n        this.sampleSize = sampleSize != null ? sampleSize : DEFAULT_SAMPLE_SIZE;\n        this.requestedDuration = requestedDuration;\n        this.awsCostFactor = awsCostFactor;\n        this.azureCostFactor = azureCostFactor;"}
{"magic_number_smell": "        new LifecyclePolicyConfig(\n            \"profiling-60-days\",\n            \"/profiling/ilm-policy/profiling-60-days.json\",\n            Map.of(PROFILING_TEMPLATE_VERSION_VARIABLE, String.valueOf(7))\n        )\n    );\n", "refactored_code": "    public static final int INDEX_TEMPLATE_VERSION = 7;\n        new LifecyclePolicyConfig(\n            \"profiling-60-days\",\n            \"/profiling/ilm-policy/profiling-60-days.json\",\n            Map.of(PROFILING_TEMPLATE_VERSION_VARIABLE, String.valueOf(INDEX_TEMPLATE_VERSION))\n        )\n    );\n"}
{"magic_number_smell": "    public static StackTrace fromSource(Map<String, Object> source) {\n        String inputFrameIDs = ObjectPath.eval(PATH_FRAME_IDS, source);\n        String inputFrameTypes = ObjectPath.eval(PATH_FRAME_TYPES, source);\n        int countsFrameIDs = inputFrameIDs.length() / 32;\n\n        String[] fileIDs = new String[countsFrameIDs];\n        String[] frameIDs = new String[countsFrameIDs];", "refactored_code": "    private static final int BASE64_FRAME_ID_LENGTH = 32;\n    public static StackTrace fromSource(Map<String, Object> source) {\n        String inputFrameIDs = ObjectPath.eval(PATH_FRAME_IDS, source);\n        String inputFrameTypes = ObjectPath.eval(PATH_FRAME_TYPES, source);\n        int countsFrameIDs = inputFrameIDs.length() / BASE64_FRAME_ID_LENGTH;\n\n        String[] fileIDs = new String[countsFrameIDs];\n        String[] frameIDs = new String[countsFrameIDs];"}
{"magic_number_smell": "        RandomSamplerAggregationBuilder randomSampler = new RandomSamplerAggregationBuilder(\"sample\").setSeed(request.hashCode())\n            .setProbability(responseBuilder.getSamplingRate())\n            .subAggregation(\n                new CountedTermsAggregationBuilder(\"group_by\").size(150_000).field(request.getStackTraceIdsField())\n            );\n        // shard seed is only set in tests and ensures consistent results\n        if (request.getShardSeed() != null) {", "refactored_code": "    private static final int MAX_TRACE_EVENTS_RESULT_SIZE = 150_000;\n        RandomSamplerAggregationBuilder randomSampler = new RandomSamplerAggregationBuilder(\"sample\").setSeed(request.hashCode())\n            .setProbability(responseBuilder.getSamplingRate())\n            .subAggregation(\n                new CountedTermsAggregationBuilder(\"group_by\").size(MAX_TRACE_EVENTS_RESULT_SIZE).field(request.getStackTraceIdsField())\n            );\n        // shard seed is only set in tests and ensures consistent results\n        if (request.getShardSeed() != null) {"}
{"magic_number_smell": "                        \"c5n.xlarge\"\n                    ),\n                    \"\", // Doesn't matter for cost calculation.\n                    8 // number of cores\n                )\n            ),\n            Map.entry(HOST_ID_AZURE,", "refactored_code": "    private static final int HOST_ID_A_NUM_CORES = 8;\n                        \"c5n.xlarge\"\n                    ),\n                    \"\", // Doesn't matter for cost calculation.\n                    HOST_ID_A_NUM_CORES // number of cores\n                )\n            ),\n            Map.entry(HOST_ID_AZURE,"}
{"magic_number_smell": "    }\n\n    public static String classPackageAsPrefix(Class<?> function) {\n        String prefix = function.getPackageName().substring(\"org.elasticsearch.xpack.\".length());\n        int index = prefix.indexOf('.');\n        Check.isTrue(index > 0, \"invalid package {}\", prefix);\n        return \"{\" + prefix.substring(0, index) + \"}\";", "refactored_code": "    private static final int PKG_LENGTH = \"org.elasticsearch.xpack.\".length();\n    }\n\n    public static String classPackageAsPrefix(Class<?> function) {\n        String prefix = function.getPackageName().substring(PKG_LENGTH);\n        int index = prefix.indexOf('.');\n        Check.isTrue(index > 0, \"invalid package {}\", prefix);\n        return \"{\" + prefix.substring(0, index) + \"}\";"}
{"magic_number_smell": "        if (fields.isEmpty() == false) {\n            InnerHitBuilder ihb = new InnerHitBuilder();\n            ihb.setSize(0);\n            ihb.setSize(99);\n            ihb.setName(path + \"_\" + COUNTER++);\n\n            for (Map.Entry<String, Map.Entry<Boolean, String>> entry : fields.entrySet()) {", "refactored_code": "    private static final int MAX_INNER_HITS = 99;\n        if (fields.isEmpty() == false) {\n            InnerHitBuilder ihb = new InnerHitBuilder();\n            ihb.setSize(0);\n            ihb.setSize(MAX_INNER_HITS);\n            ihb.setName(path + \"_\" + COUNTER++);\n\n            for (Map.Entry<String, Map.Entry<Boolean, String>> entry : fields.entrySet()) {"}
{"magic_number_smell": "        @SuppressWarnings(\"HiddenField\")\n        List<?> children = children();\n        // eliminate children (they are rendered as part of the tree)\n        int remainingProperties = 10;\n        int maxWidth = 0;\n        boolean needsComma = false;\n", "refactored_code": "    private static final int TO_STRING_MAX_PROP = 10;\n        @SuppressWarnings(\"HiddenField\")\n        List<?> children = children();\n        // eliminate children (they are rendered as part of the tree)\n        int remainingProperties = TO_STRING_MAX_PROP;\n        int maxWidth = 0;\n        boolean needsComma = false;\n"}
{"magic_number_smell": "        }\n\n        // ..]\n        StringBuilder sb = new StringBuilder(52 + 4);\n        sb.append('[');\n        for (;;) {\n            E e = it.next();", "refactored_code": "    private static final int TO_STRING_LIMIT = 52;\n        }\n\n        // ..]\n        StringBuilder sb = new StringBuilder(TO_STRING_LIMIT + 4);\n        sb.append('[');\n        for (;;) {\n            E e = it.next();"}
{"magic_number_smell": "\n            @Override\n            public boolean hasNext() {\n                return pos < size() - 1;\n            }\n\n            @Override", "refactored_code": "            private final int size = size();\n\n            @Override\n            public boolean hasNext() {\n                return pos < size - 1;\n            }\n\n            @Override"}
{"magic_number_smell": "        .toFormatter(Locale.ROOT);\n\n    private static final int 60 = 60;\n    private static final int SECONDS_PER_HOUR = 60 * 60;\n    private static final int SECONDS_PER_DAY = SECONDS_PER_HOUR * 24;\n\n    private StringUtils() {}", "refactored_code": "    private static final int SECONDS_PER_MINUTE = 60;\n        .toFormatter(Locale.ROOT);\n\n    private static final int SECONDS_PER_MINUTE = 60;\n    private static final int SECONDS_PER_HOUR = SECONDS_PER_MINUTE * 60;\n    private static final int SECONDS_PER_DAY = SECONDS_PER_HOUR * 24;\n\n    private StringUtils() {}"}
{"magic_number_smell": "    public static final DateFormatter UTC_DATE_TIME_FORMATTER = DateFormatter.forPattern(\"strict_date_optional_time\").withZone(UTC);\n\n    public static final int 60 = 60;\n    public static final int SECONDS_PER_HOUR = 60 * 60;\n    public static final int SECONDS_PER_DAY = SECONDS_PER_HOUR * 24;\n\n    private DateUtils() {}", "refactored_code": "    public static final int SECONDS_PER_MINUTE = 60;\n    public static final DateFormatter UTC_DATE_TIME_FORMATTER = DateFormatter.forPattern(\"strict_date_optional_time\").withZone(UTC);\n\n    public static final int SECONDS_PER_MINUTE = 60;\n    public static final int SECONDS_PER_HOUR = SECONDS_PER_MINUTE * 60;\n    public static final int SECONDS_PER_DAY = SECONDS_PER_HOUR * 24;\n\n    private DateUtils() {}"}
{"magic_number_smell": "        // first determine node info\n        StringBuilder nodeInfo = new StringBuilder();\n        nodeInfo.append(\"\\n\");\n        indent(nodeInfo, currentIndent + 12);\n        nodeInfo.append(\"\"\"\n            <table border=\"0\" cellborder=\"1\" cellspacing=\"0\">\n            \"\"\");", "refactored_code": "    private static final int NODE_LABEL_INDENT = 12;\n        // first determine node info\n        StringBuilder nodeInfo = new StringBuilder();\n        nodeInfo.append(\"\\n\");\n        indent(nodeInfo, currentIndent + NODE_LABEL_INDENT);\n        nodeInfo.append(\"\"\"\n            <table border=\"0\" cellborder=\"1\" cellspacing=\"0\">\n            \"\"\");"}
{"magic_number_smell": "        // Converting it to a double and back will yield a larger unsigned long, so the double comparison is still preferred, but\n        // it'll require the equality check. (BigDecimal comparisons only make sense for string-recovered floating point numbers.)\n        // This also means that 18446744073709551615.0 is actually a double too high to be converted as an unsigned long.\n        return d >= 0 && d < UNSIGNED_LONG_MAX.doubleValue();\n    }\n\n    public static BigInteger asUnsignedLong(BigInteger bi) {", "refactored_code": "    public static final double UNSIGNED_LONG_MAX_AS_DOUBLE = UNSIGNED_LONG_MAX.doubleValue();\n        // Converting it to a double and back will yield a larger unsigned long, so the double comparison is still preferred, but\n        // it'll require the equality check. (BigDecimal comparisons only make sense for string-recovered floating point numbers.)\n        // This also means that 18446744073709551615.0 is actually a double too high to be converted as an unsigned long.\n        return d >= 0 && d < UNSIGNED_LONG_MAX_AS_DOUBLE;\n    }\n\n    public static BigInteger asUnsignedLong(BigInteger bi) {"}
{"magic_number_smell": "        }\n\n        private int checkCoordinate(int i) {\n            if (i > XYEncodingUtils.encode((float) XYEncodingUtils.MAX_VAL_INCL) || i < MIN_VAL_ENCODED) {\n                throw new IllegalArgumentException(\"Failed to convert invalid encoded value to cartesian point\");\n            }\n            return i;", "refactored_code": "        private static final int MAX_VAL_ENCODED = XYEncodingUtils.encode((float) XYEncodingUtils.MAX_VAL_INCL);\n        }\n\n        private int checkCoordinate(int i) {\n            if (i > MAX_VAL_ENCODED || i < MIN_VAL_ENCODED) {\n                throw new IllegalArgumentException(\"Failed to convert invalid encoded value to cartesian point\");\n            }\n            return i;"}
{"magic_number_smell": "\n    static final ConstructingObjectParser<RRFRankBuilder, Void> PARSER = new ConstructingObjectParser<>(RRFRankPlugin.NAME, args -> {\n        int windowSize = args[0] == null ? DEFAULT_WINDOW_SIZE : (int) args[0];\n        int rankConstant = args[1] == null ? 60 : (int) args[1];\n        if (rankConstant < 1) {\n            throw new IllegalArgumentException(\"[rank_constant] must be greater than [0] for [rrf]\");\n        }", "refactored_code": "    public static final int DEFAULT_RANK_CONSTANT = 60;\n\n    static final ConstructingObjectParser<RRFRankBuilder, Void> PARSER = new ConstructingObjectParser<>(RRFRankPlugin.NAME, args -> {\n        int windowSize = args[0] == null ? DEFAULT_WINDOW_SIZE : (int) args[0];\n        int rankConstant = args[1] == null ? DEFAULT_RANK_CONSTANT : (int) args[1];\n        if (rankConstant < 1) {\n            throw new IllegalArgumentException(\"[rank_constant] must be greater than [0] for [rrf]\");\n        }"}
{"magic_number_smell": "\n    public String getID() {\n        setFlag();\n        MurmurHash3.Hash128 hasher = MurmurHash3.hash128(id.bytes(), 0, id.length(), 19, new MurmurHash3.Hash128());\n        byte[] hashedBytes = new byte[16];\n        System.arraycopy(Numbers.longToBytes(hasher.h1), 0, hashedBytes, 0, 8);\n        System.arraycopy(Numbers.longToBytes(hasher.h2), 0, hashedBytes, 8, 8);", "refactored_code": "    private static final long SEED = 19;\n\n    public String getID() {\n        setFlag();\n        MurmurHash3.Hash128 hasher = MurmurHash3.hash128(id.bytes(), 0, id.length(), SEED, new MurmurHash3.Hash128());\n        byte[] hashedBytes = new byte[16];\n        System.arraycopy(Numbers.longToBytes(hasher.h1), 0, hashedBytes, 0, 8);\n        System.arraycopy(Numbers.longToBytes(hasher.h2), 0, hashedBytes, 8, 8);"}
{"magic_number_smell": "            throw new IllegalArgumentException(\"[\" + NAME + \"] ids and docs cannot both be used\");\n        }\n        if (ids != null) {\n            if (ids.size() > 100) {\n                throw new IllegalArgumentException(\n                    \"[\" + NAME + \"] Max of \" + 100 + \" ids exceeded: \" + ids.size() + \" provided.\"\n                );", "refactored_code": "    public static final int MAX_NUM_PINNED_HITS = 100;\n            throw new IllegalArgumentException(\"[\" + NAME + \"] ids and docs cannot both be used\");\n        }\n        if (ids != null) {\n            if (ids.size() > MAX_NUM_PINNED_HITS) {\n                throw new IllegalArgumentException(\n                    \"[\" + NAME + \"] Max of \" + MAX_NUM_PINNED_HITS + \" ids exceeded: \" + ids.size() + \" provided.\"\n                );"}
{"magic_number_smell": "    protected Settings nodeSettings(int nodeOrdinal, Settings otherSettings) {\n        return Settings.builder()\n            .put(super.nodeSettings(nodeOrdinal, otherSettings))\n            .put(ShardLimitValidator.SETTING_CLUSTER_MAX_SHARDS_PER_NODE.getKey(), 3)\n            .put(ShardLimitValidator.SETTING_CLUSTER_MAX_SHARDS_PER_NODE_FROZEN.getKey(), MAX_FROZEN)\n            .build();\n    }", "refactored_code": "    private static final int MAX_NORMAL = 3;\n    protected Settings nodeSettings(int nodeOrdinal, Settings otherSettings) {\n        return Settings.builder()\n            .put(super.nodeSettings(nodeOrdinal, otherSettings))\n            .put(ShardLimitValidator.SETTING_CLUSTER_MAX_SHARDS_PER_NODE.getKey(), MAX_NORMAL)\n            .put(ShardLimitValidator.SETTING_CLUSTER_MAX_SHARDS_PER_NODE_FROZEN.getKey(), MAX_FROZEN)\n            .build();\n    }"}
{"magic_number_smell": "    protected Settings nodeSettings(int nodeOrdinal, Settings otherSettings) {\n        return Settings.builder()\n            .put(super.nodeSettings(nodeOrdinal, otherSettings))\n            .put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(), new ByteSizeValue(10, ByteSizeUnit.KB).getBytes() + \"b\")\n            .put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(), new ByteSizeValue(10, ByteSizeUnit.KB).getBytes() + \"b\")\n            .put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_DISK_FLOOD_STAGE_WATERMARK_SETTING.getKey(), \"0b\")\n            .put(SELF_GENERATED_LICENSE_TYPE.getKey(), \"trial\")", "refactored_code": "    private static final long WATERMARK_BYTES = new ByteSizeValue(10, ByteSizeUnit.KB).getBytes();\n    protected Settings nodeSettings(int nodeOrdinal, Settings otherSettings) {\n        return Settings.builder()\n            .put(super.nodeSettings(nodeOrdinal, otherSettings))\n            .put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(), WATERMARK_BYTES + \"b\")\n            .put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(), WATERMARK_BYTES + \"b\")\n            .put(DiskThresholdSettings.CLUSTER_ROUTING_ALLOCATION_DISK_FLOOD_STAGE_WATERMARK_SETTING.getKey(), \"0b\")\n            .put(SELF_GENERATED_LICENSE_TYPE.getKey(), \"trial\")"}
{"magic_number_smell": "            .put(SearchableSnapshots.CACHE_FETCH_ASYNC_THREAD_POOL_SETTING + \".keep_alive\", \"1s\")\n            .put(SearchableSnapshots.CACHE_PREWARMING_THREAD_POOL_SETTING + \".max\", randomIntBetween(1, 32))\n            .put(SearchableSnapshots.CACHE_PREWARMING_THREAD_POOL_SETTING + \".keep_alive\", \"1s\")\n            .put(ThrottlingAllocationDecider.CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_RECOVERIES_SETTING.getKey(), 10)\n            .build();\n    }\n", "refactored_code": "    private static final int MAX_NUMBER_OF_INDICES = 10;\n            .put(SearchableSnapshots.CACHE_FETCH_ASYNC_THREAD_POOL_SETTING + \".keep_alive\", \"1s\")\n            .put(SearchableSnapshots.CACHE_PREWARMING_THREAD_POOL_SETTING + \".max\", randomIntBetween(1, 32))\n            .put(SearchableSnapshots.CACHE_PREWARMING_THREAD_POOL_SETTING + \".keep_alive\", \"1s\")\n            .put(ThrottlingAllocationDecider.CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_RECOVERIES_SETTING.getKey(), MAX_NUMBER_OF_INDICES)\n            .build();\n    }\n"}
{"magic_number_smell": "                    {\n                        builder.startObject(\"_meta\");\n                        builder.field(\"version\", Version.CURRENT);\n                        builder.field(SystemIndexDescriptor.VERSION_META_KEY, 1);\n                        builder.endObject();\n                    }\n                    {", "refactored_code": "    private static final int SEARCHABLE_SNAPSHOTS_INDEX_MAPPINGS_VERSION = 1;\n                    {\n                        builder.startObject(\"_meta\");\n                        builder.field(\"version\", Version.CURRENT);\n                        builder.field(SystemIndexDescriptor.VERSION_META_KEY, SEARCHABLE_SNAPSHOTS_INDEX_MAPPINGS_VERSION);\n                        builder.endObject();\n                    }\n                    {"}
{"magic_number_smell": "            }\n            return ByteRange.of(0L, Math.min(fileLength, maxAllowedLengthInBytes));\n        }\n        return ByteRange.of(0L, Math.min(fileLength, ByteSizeUnit.KB.toIntBytes(1)));\n    }\n\n    private static void logExceedingFile(ShardId shardId, LuceneFilesExtensions extension, long length, ByteSizeValue maxAllowedLength) {", "refactored_code": "    public static final int DEFAULT_CACHED_BLOB_SIZE = ByteSizeUnit.KB.toIntBytes(1);\n            }\n            return ByteRange.of(0L, Math.min(fileLength, maxAllowedLengthInBytes));\n        }\n        return ByteRange.of(0L, Math.min(fileLength, DEFAULT_CACHED_BLOB_SIZE));\n    }\n\n    private static void logExceedingFile(ShardId shardId, LuceneFilesExtensions extension, long length, ByteSizeValue maxAllowedLength) {"}
{"magic_number_smell": "     * @return the number of bytes read\n     */\n    private int readOptimized(int part, long pos, ByteBuffer b, int length) throws IOException {\n        if (sequentialReadSize == 0L) {\n            return 0;\n        }\n", "refactored_code": "    private static final long NO_SEQUENTIAL_READ_OPTIMIZATION = 0L;\n     * @return the number of bytes read\n     */\n    private int readOptimized(int part, long pos, ByteBuffer b, int length) throws IOException {\n        if (sequentialReadSize == NO_SEQUENTIAL_READ_OPTIMIZATION) {\n            return 0;\n        }\n"}
{"magic_number_smell": "    }\n\n    public void testCachedBytesReadsAndWritesNoCache() throws Exception {\n        final ByteSizeValue uncachedChunkSize = ByteSizeValue.ofBytes(randomIntBetween(512, 10_000));\n        executeTestCaseWithoutCache(uncachedChunkSize, (fileName, fileContent, directory) -> {\n            try (IndexInput input = directory.openInput(fileName, randomIOContext())) {\n                final long length = input.length();", "refactored_code": "    private static final int MAX_FILE_LENGTH = 10_000;\n    }\n\n    public void testCachedBytesReadsAndWritesNoCache() throws Exception {\n        final ByteSizeValue uncachedChunkSize = ByteSizeValue.ofBytes(randomIntBetween(512, MAX_FILE_LENGTH));\n        executeTestCaseWithoutCache(uncachedChunkSize, (fileName, fileContent, directory) -> {\n            try (IndexInput input = directory.openInput(fileName, randomIOContext())) {\n                final long length = input.length();"}
{"magic_number_smell": "                    transportCaCert,\n                    transportCaKey,\n                    false,\n                    99 * 365,\n                    SIGNATURE_ALGORITHM\n                );\n", "refactored_code": "    private static final int TRANSPORT_CERTIFICATE_DAYS = 99 * 365;\n                    transportCaCert,\n                    transportCaKey,\n                    false,\n                    TRANSPORT_CERTIFICATE_DAYS,\n                    SIGNATURE_ALGORITHM\n                );\n"}
{"magic_number_smell": "     */\n    public static BigInteger getSerial() {\n        SecureRandom random = Randomness.createSecure();\n        BigInteger serial = new BigInteger(20 * 8, random);\n        assert serial.compareTo(BigInteger.valueOf(0L)) >= 0;\n        return serial;\n    }", "refactored_code": "    private static final int SERIAL_BIT_LENGTH = 20 * 8;\n     */\n    public static BigInteger getSerial() {\n        SecureRandom random = Randomness.createSecure();\n        BigInteger serial = new BigInteger(SERIAL_BIT_LENGTH, random);\n        assert serial.compareTo(BigInteger.valueOf(0L)) >= 0;\n        return serial;\n    }"}
{"magic_number_smell": "            final String dn = options.has(caDnSpec) ? caDnSpec.value(options) : AUTO_GEN_CA_DN;\n            final boolean prompt = options.has(caPasswordSpec);\n            final char[] keyPass = options.hasArgument(caPasswordSpec) ? caPasswordSpec.value(options).toCharArray() : null;\n            final int days = options.hasArgument(daysSpec) ? daysSpec.value(options) : 3 * 365;\n            final char[] p12Password;\n            if (options.hasArgument(p12Spec)) {\n                p12Password = p12Spec.value(options).toCharArray();", "refactored_code": "    private static final int DEFAULT_DAYS = 3 * 365;\n            final String dn = options.has(caDnSpec) ? caDnSpec.value(options) : AUTO_GEN_CA_DN;\n            final boolean prompt = options.has(caPasswordSpec);\n            final char[] keyPass = options.hasArgument(caPasswordSpec) ? caPasswordSpec.value(options).toCharArray() : null;\n            final int days = options.hasArgument(daysSpec) ? daysSpec.value(options) : DEFAULT_DAYS;\n            final char[] p12Password;\n            if (options.hasArgument(p12Spec)) {\n                p12Password = p12Spec.value(options).toCharArray();"}
{"magic_number_smell": "            if (options.has(daysSpec)) {\n                return daysSpec.value(options);\n            } else {\n                return 3 * 365;\n            }\n        }\n", "refactored_code": "    private static final int DEFAULT_DAYS = 3 * 365;\n            if (options.has(daysSpec)) {\n                return daysSpec.value(options);\n            } else {\n                return DEFAULT_DAYS;\n            }\n        }\n"}
{"magic_number_smell": "        final String usersPasswdHashed = new String(getFastStoredHashAlgoForTests().hash(USERS_PASSWD));\n\n        StringBuilder builder = new StringBuilder(super.configUsers());\n        for (int i = 1; i <= scaledRandomIntBetween(3, 99); i++) {\n            builder.append(\"user\").append(i).append(':').append(usersPasswdHashed).append('\\n');\n        }\n        return builder.toString();", "refactored_code": "    private final int numberOfRoles = scaledRandomIntBetween(3, 99);\n        final String usersPasswdHashed = new String(getFastStoredHashAlgoForTests().hash(USERS_PASSWD));\n\n        StringBuilder builder = new StringBuilder(super.configUsers());\n        for (int i = 1; i <= numberOfRoles; i++) {\n            builder.append(\"user\").append(i).append(':').append(usersPasswdHashed).append('\\n');\n        }\n        return builder.toString();"}
{"magic_number_smell": "            .put(super.nodeSettings(nodeOrdinal, otherSettings))\n            .put(XPackSettings.API_KEY_SERVICE_ENABLED_SETTING.getKey(), true)\n            .put(XPackSettings.TOKEN_SERVICE_ENABLED_SETTING.getKey(), true)\n            .put(ApiKeyService.DELETE_INTERVAL.getKey(), TimeValue.timeValueMillis(100L))\n            .put(ApiKeyService.DELETE_TIMEOUT.getKey(), TimeValue.timeValueSeconds(5L))\n            .put(ApiKeyService.DELETE_RETENTION_PERIOD.getKey(), TimeValue.timeValueDays(deleteRetentionPeriodDays))\n            .put(\"xpack.security.crypto.thread_pool.queue_size\", CRYPTO_THREAD_POOL_QUEUE_SIZE)", "refactored_code": "    private static final long DELETE_INTERVAL_MILLIS = 100L;\n            .put(super.nodeSettings(nodeOrdinal, otherSettings))\n            .put(XPackSettings.API_KEY_SERVICE_ENABLED_SETTING.getKey(), true)\n            .put(XPackSettings.TOKEN_SERVICE_ENABLED_SETTING.getKey(), true)\n            .put(ApiKeyService.DELETE_INTERVAL.getKey(), TimeValue.timeValueMillis(DELETE_INTERVAL_MILLIS))\n            .put(ApiKeyService.DELETE_TIMEOUT.getKey(), TimeValue.timeValueSeconds(5L))\n            .put(ApiKeyService.DELETE_RETENTION_PERIOD.getKey(), TimeValue.timeValueDays(deleteRetentionPeriodDays))\n            .put(\"xpack.security.crypto.thread_pool.queue_size\", CRYPTO_THREAD_POOL_QUEUE_SIZE)"}
{"magic_number_smell": "\n    @BeforeClass\n    public static void initPort() {\n        randomClientPort = randomIntBetween(49152, 65535 - Constants.WINDOWS ? 300 : 100);\n    }\n\n    @Override", "refactored_code": "    private static final int NUMBER_OF_CLIENT_PORTS = Constants.WINDOWS ? 300 : 100;\n\n    @BeforeClass\n    public static void initPort() {\n        randomClientPort = randomIntBetween(49152, 65535 - NUMBER_OF_CLIENT_PORTS);\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @BeforeClass\n    public static void getRandomPort() {\n        randomClientPort = randomIntBetween(49152, 65535 - Constants.WINDOWS ? 300 : 100); // ephemeral port\n    }\n\n    @Override", "refactored_code": "    private static final int NUMBER_OF_CLIENT_PORTS = Constants.WINDOWS ? 300 : 100;\n\n    @BeforeClass\n    public static void getRandomPort() {\n        randomClientPort = randomIntBetween(49152, 65535 - NUMBER_OF_CLIENT_PORTS); // ephemeral port\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @BeforeClass\n    public static void getRandomPort() {\n        randomClientPort = randomIntBetween(49152, 65535 - Constants.WINDOWS ? 300 : 100);\n    }\n\n    @Override", "refactored_code": "    private static final int NUMBER_OF_CLIENT_PORTS = Constants.WINDOWS ? 300 : 100;\n\n    @BeforeClass\n    public static void getRandomPort() {\n        randomClientPort = randomIntBetween(49152, 65535 - NUMBER_OF_CLIENT_PORTS);\n    }\n\n    @Override"}
{"magic_number_smell": "        final Instant created = clock.instant();\n        final Instant expiration = getApiKeyExpiration(created, request.getExpiration());\n        final SecureString apiKey = UUIDs.randomBase64UUIDSecureString();\n        assert ApiKey.Type.CROSS_CLUSTER != request.getType() || 22 == apiKey.length();\n        final Version version = clusterService.state().nodes().getMinNodeVersion();\n\n        computeHashForApiKey(apiKey, listener.delegateFailure((l, apiKeyHashChars) -> {", "refactored_code": "    private static final int API_KEY_SECRET_LENGTH = 22;\n        final Instant created = clock.instant();\n        final Instant expiration = getApiKeyExpiration(created, request.getExpiration());\n        final SecureString apiKey = UUIDs.randomBase64UUIDSecureString();\n        assert ApiKey.Type.CROSS_CLUSTER != request.getType() || API_KEY_SECRET_LENGTH == apiKey.length();\n        final Version version = clusterService.state().nodes().getMinNodeVersion();\n\n        computeHashForApiKey(apiKey, listener.delegateFailure((l, apiKeyHashChars) -> {"}
{"magic_number_smell": "            QueryBuilders.boolQuery()\n                .filter(QueryBuilders.termsQuery(\"doc_type\", TokenService.TOKEN_DOC_TYPE))\n                .filter(\n                    QueryBuilders.rangeQuery(\"creation_time\").lte(now.minus(24L, ChronoUnit.HOURS).toEpochMilli())\n                )\n        );\n        logger.trace(() -> \"Removing old tokens: [\" + Strings.toString(expiredDbq) + \"]\");", "refactored_code": "    public static final long MAXIMUM_TOKEN_LIFETIME_HOURS = 24L;\n            QueryBuilders.boolQuery()\n                .filter(QueryBuilders.termsQuery(\"doc_type\", TokenService.TOKEN_DOC_TYPE))\n                .filter(\n                    QueryBuilders.rangeQuery(\"creation_time\").lte(now.minus(MAXIMUM_TOKEN_LIFETIME_HOURS, ChronoUnit.HOURS).toEpochMilli())\n                )\n        );\n        logger.trace(() -> \"Removing old tokens: [\" + Strings.toString(expiredDbq) + \"]\");"}
{"magic_number_smell": "    }\n\n    private SecureString generateTokenKey() {\n        byte[] keyBytes = new byte[64];\n        byte[] encode = new byte[0];\n        char[] ref = new char[0];\n        try {", "refactored_code": "    private static final int KEY_BYTES = 64;\n    }\n\n    private SecureString generateTokenKey() {\n        byte[] keyBytes = new byte[KEY_BYTES];\n        byte[] encode = new byte[0];\n        char[] ref = new char[0];\n        try {"}
{"magic_number_smell": "            return;\n        }\n\n        if (serviceAccountToken.getSecret().length() < 10) {\n            logger.debug(\n                \"failing authentication for service account token [{}],\"\n                    + \" the provided credential has length [{}]\"", "refactored_code": "    private static final int MIN_TOKEN_SECRET_LENGTH = 10;\n            return;\n        }\n\n        if (serviceAccountToken.getSecret().length() < MIN_TOKEN_SECRET_LENGTH) {\n            logger.debug(\n                \"failing authentication for service account token [{}],\"\n                    + \" the provided credential has length [{}]\""}
{"magic_number_smell": "    public static final byte TOKEN_TYPE = '\\1';\n    public static final byte RESERVED_BYTE = '\\0';\n    public static final byte FORMAT_VERSION = '\\1';\n    public static final byte[] PREFIX = new byte[] { '\u0000', TOKEN_TYPE, RESERVED_BYTE, FORMAT_VERSION };\n\n    private static final Logger logger = LogManager.getLogger(ServiceAccountToken.class);\n", "refactored_code": "    public static final byte MAGIC_BYTE = '\\0';\n    public static final byte TOKEN_TYPE = '\\1';\n    public static final byte RESERVED_BYTE = '\\0';\n    public static final byte FORMAT_VERSION = '\\1';\n    public static final byte[] PREFIX = new byte[] { MAGIC_BYTE, TOKEN_TYPE, RESERVED_BYTE, FORMAT_VERSION };\n\n    private static final Logger logger = LogManager.getLogger(ServiceAccountToken.class);\n"}
{"magic_number_smell": "            return;\n        }\n        // Prevent infinite recursion. It is practically impossible to get this many clashes\n        if (differentiator >= 9) {\n            listener.onFailure(\n                new ElasticsearchException(\"profile differentiator value is too high for base Uid [{}]\", uid.substring(0, index))\n            );", "refactored_code": "    private static final int DIFFERENTIATOR_UPPER_LIMIT = 9;\n            return;\n        }\n        // Prevent infinite recursion. It is practically impossible to get this many clashes\n        if (differentiator >= DIFFERENTIATOR_UPPER_LIMIT) {\n            listener.onFailure(\n                new ElasticsearchException(\"profile differentiator value is too high for base Uid [{}]\", uid.substring(0, index))\n            );"}
{"magic_number_smell": "            .setMappings(getMainIndexMappings())\n            .setSettings(getMainIndexSettings())\n            .setAliasName(SECURITY_MAIN_ALIAS)\n            .setIndexFormat(6)\n            .setVersionMetaKey(\"security-version\")\n            .setOrigin(SECURITY_ORIGIN)\n            .setThreadPools(ExecutorNames.CRITICAL_SYSTEM_INDEX_THREAD_POOLS)", "refactored_code": "    public static final int INTERNAL_MAIN_INDEX_FORMAT = 6;\n            .setMappings(getMainIndexMappings())\n            .setSettings(getMainIndexSettings())\n            .setAliasName(SECURITY_MAIN_ALIAS)\n            .setIndexFormat(INTERNAL_MAIN_INDEX_FORMAT)\n            .setVersionMetaKey(\"security-version\")\n            .setOrigin(SECURITY_ORIGIN)\n            .setThreadPools(ExecutorNames.CRITICAL_SYSTEM_INDEX_THREAD_POOLS)"}
{"magic_number_smell": "        }\n\n        final String username = generateUsername(\"autogenerated_\", null, 8);\n        try (SecureString password = new SecureString(generatePassword(14))) {\n            final Hasher hasher = Hasher.resolve(XPackSettings.PASSWORD_HASHING_ALGORITHM.get(settings));\n            final Path passwordFile = FileUserPasswdStore.resolveFile(newEnv);\n            final Path rolesFile = FileUserRolesStore.resolveFile(newEnv);", "refactored_code": "    private static final int PASSWORD_LENGTH = 14;\n        }\n\n        final String username = generateUsername(\"autogenerated_\", null, 8);\n        try (SecureString password = new SecureString(generatePassword(PASSWORD_LENGTH))) {\n            final Hasher hasher = Hasher.resolve(XPackSettings.PASSWORD_HASHING_ALGORITHM.get(settings));\n            final Path passwordFile = FileUserPasswdStore.resolveFile(newEnv);\n            final Path rolesFile = FileUserRolesStore.resolveFile(newEnv);"}
{"magic_number_smell": "     * @param encodedJwkSetPkcPublicBytes UTF-8 bytes of the encoded PKC JWKSet.\n     * @throws Exception Error for configuration or start error.\n     */\n    @SuppressForbidden(reason = \"MockHttpServer.createHttps requires InetSocketAddress, 0=0 resolves to an available ephemeral port.\")\n    public JwtIssuerHttpsServer(final byte[] encodedJwkSetPkcPublicBytes) throws Exception {\n        this.httpsServer = MockHttpServer.createHttps(new InetSocketAddress(ADDRESS, 0), BACKLOG);\n        this.url = \"https://\" + ADDRESS + \":\" + this.httpsServer.getAddress().getPort() + PATH; // get ephemeral port", "refactored_code": "    private static final int PORT = 0; // 443, 0 (ephemeral port)\n     * @param encodedJwkSetPkcPublicBytes UTF-8 bytes of the encoded PKC JWKSet.\n     * @throws Exception Error for configuration or start error.\n     */\n    @SuppressForbidden(reason = \"MockHttpServer.createHttps requires InetSocketAddress, PORT=0 resolves to an available ephemeral port.\")\n    public JwtIssuerHttpsServer(final byte[] encodedJwkSetPkcPublicBytes) throws Exception {\n        this.httpsServer = MockHttpServer.createHttps(new InetSocketAddress(ADDRESS, PORT), BACKLOG);\n        this.url = \"https://\" + ADDRESS + \":\" + this.httpsServer.getAddress().getPort() + PATH; // get ephemeral port"}
{"magic_number_smell": "        final SecureString jwt = signJwt(algJwkPairHmac.jwk(), unsignedJwt);\n\n        // Verify authc+authz, then print all artifacts\n        doMultipleAuthcAuthzAndVerifySuccess(jwtIssuerAndRealm.realm(), user, jwt, clientSecret, 1);\n        printArtifacts(jwtIssuer, config, clientSecret, jwt);\n    }\n", "refactored_code": "    private static final int JWT_AUTHC_REPEATS_1 = 1;\n        final SecureString jwt = signJwt(algJwkPairHmac.jwk(), unsignedJwt);\n\n        // Verify authc+authz, then print all artifacts\n        doMultipleAuthcAuthzAndVerifySuccess(jwtIssuerAndRealm.realm(), user, jwt, clientSecret, JWT_AUTHC_REPEATS_1);\n        printArtifacts(jwtIssuer, config, clientSecret, jwt);\n    }\n"}
{"magic_number_smell": "    private final BigArrays bigarrays = new BigArrays(null, new NoneCircuitBreakerService(), CircuitBreaker.REQUEST);\n    private final Settings settings = Settings.builder()\n        .put(\"node.name\", \"SecurityNetty4HeaderSizeLimitTests\")\n        .put(RemoteClusterPortSettings.MAX_REQUEST_HEADER_SIZE.getKey(), randomIntBetween(64, 128) + \"b\")\n        .put(XPackSettings.TRANSPORT_SSL_ENABLED.getKey(), \"false\")\n        .put(XPackSettings.REMOTE_CLUSTER_SERVER_SSL_ENABLED.getKey(), \"false\")\n        .put(XPackSettings.REMOTE_CLUSTER_CLIENT_SSL_ENABLED.getKey(), \"false\")", "refactored_code": "    private final int maxHeaderSize = randomIntBetween(64, 128);\n    private final BigArrays bigarrays = new BigArrays(null, new NoneCircuitBreakerService(), CircuitBreaker.REQUEST);\n    private final Settings settings = Settings.builder()\n        .put(\"node.name\", \"SecurityNetty4HeaderSizeLimitTests\")\n        .put(RemoteClusterPortSettings.MAX_REQUEST_HEADER_SIZE.getKey(), maxHeaderSize + \"b\")\n        .put(XPackSettings.TRANSPORT_SSL_ENABLED.getKey(), \"false\")\n        .put(XPackSettings.REMOTE_CLUSTER_SERVER_SSL_ENABLED.getKey(), \"false\")\n        .put(XPackSettings.REMOTE_CLUSTER_CLIENT_SSL_ENABLED.getKey(), \"false\")"}
{"magic_number_smell": "    public static final NodeFeature MANAGED_BY_DATA_STREAM_LIFECYCLE = new NodeFeature(\"slm-history-managed-by-dsl\");\n\n    public static final String SLM_TEMPLATE_VERSION_VARIABLE = \"xpack.slm.template.version\";\n    public static final String SLM_TEMPLATE_NAME = \".slm-history-\" + 7;\n\n    public static final String SLM_POLICY_NAME = \"slm-history-ilm-policy\";\n    private final FeatureService featureService;", "refactored_code": "    public static final int INDEX_TEMPLATE_VERSION = 7;\n    public static final NodeFeature MANAGED_BY_DATA_STREAM_LIFECYCLE = new NodeFeature(\"slm-history-managed-by-dsl\");\n\n    public static final String SLM_TEMPLATE_VERSION_VARIABLE = \"xpack.slm.template.version\";\n    public static final String SLM_TEMPLATE_NAME = \".slm-history-\" + INDEX_TEMPLATE_VERSION;\n\n    public static final String SLM_POLICY_NAME = \"slm-history-ilm-policy\";\n    private final FeatureService featureService;"}
{"magic_number_smell": "        final AtomicLong throttleNanos = new AtomicLong();\n        final InputStream throttledInputStream = blobStoreRepository.maybeRateLimitRestores(rawInputStream, throttleNanos::addAndGet);\n        final CRC32 crc32 = new CRC32();\n        final byte[] buffer = new byte[ByteSizeUnit.KB.toIntBytes(8)];\n        long bytesRead = 0L;\n        final long startTimeNanos = System.nanoTime();\n        long firstByteNanos = startTimeNanos;", "refactored_code": "    private static final int BUFFER_SIZE = ByteSizeUnit.KB.toIntBytes(8);\n        final AtomicLong throttleNanos = new AtomicLong();\n        final InputStream throttledInputStream = blobStoreRepository.maybeRateLimitRestores(rawInputStream, throttleNanos::addAndGet);\n        final CRC32 crc32 = new CRC32();\n        final byte[] buffer = new byte[BUFFER_SIZE];\n        long bytesRead = 0L;\n        final long startTimeNanos = System.nanoTime();\n        long firstByteNanos = startTimeNanos;"}
{"magic_number_smell": "    }\n\n    /** It stores the points for the given h3 in the provided arrays. The arrays\n     * should be at least have the length of {@link #15}. It returns the number of point added. */\n    public static int computePoints(final long h3, final double[] xs, final double[] ys) {\n        final double[][] cached = CACHED_H3.get(h3);\n        if (cached != null) {", "refactored_code": "    public static final int MAX_ARRAY_SIZE = 15;\n    }\n\n    /** It stores the points for the given h3 in the provided arrays. The arrays\n     * should be at least have the length of {@link #MAX_ARRAY_SIZE}. It returns the number of point added. */\n    public static int computePoints(final long h3, final double[] xs, final double[] ys) {\n        final double[][] cached = CACHED_H3.get(h3);\n        if (cached != null) {"}
{"magic_number_smell": "            }\n            // Unfortunately, h3 bin edges are fuzzy and cannot be represented easily. We need to buffer\n            // the bounding boxes to make sure we don't reject valid points\n            this.minX = Math.max(GeoUtils.MIN_LON_INCL, minX - 1e-4);\n            this.maxX = Math.min(GeoUtils.MAX_LON_INCL, maxX + 1e-4);\n            this.minY = Math.max(GeoUtils.MIN_LAT_INCL, minY - 1e-4);\n            this.maxY = Math.min(GeoUtils.MAX_LAT_INCL, maxY + 1e-4);", "refactored_code": "        private static final double BBOX_EDGE_DELTA = 1e-4;\n            }\n            // Unfortunately, h3 bin edges are fuzzy and cannot be represented easily. We need to buffer\n            // the bounding boxes to make sure we don't reject valid points\n            this.minX = Math.max(GeoUtils.MIN_LON_INCL, minX - BBOX_EDGE_DELTA);\n            this.maxX = Math.min(GeoUtils.MAX_LON_INCL, maxX + BBOX_EDGE_DELTA);\n            this.minY = Math.max(GeoUtils.MIN_LAT_INCL, minY - BBOX_EDGE_DELTA);\n            this.maxY = Math.min(GeoUtils.MAX_LAT_INCL, maxY + BBOX_EDGE_DELTA);"}
{"magic_number_smell": "    }\n\n    private double roundDegrees(double degree) {\n        return Math.round(degree * Math.pow(10, 6)) / Math.pow(10, 6);\n    }\n\n    @Override", "refactored_code": "    private static final double SCALE = Math.pow(10, 6);\n    }\n\n    private double roundDegrees(double degree) {\n        return Math.round(degree * SCALE) / SCALE;\n    }\n\n    @Override"}
{"magic_number_smell": "        this.valuesSources = valuesSources;\n        this.bucketSize = bucketSize;\n        this.geoLineBuilder = geoLineBuilder;\n        this.currentBucket = -1;\n        this.simplifier = new TimeSeriesGeoLineBuckets.Simplifier(bucketSize, circuitBreaker);\n    }\n", "refactored_code": "    private static final long NO_BUCKET = -1;\n        this.valuesSources = valuesSources;\n        this.bucketSize = bucketSize;\n        this.geoLineBuilder = geoLineBuilder;\n        this.currentBucket = NO_BUCKET;\n        this.simplifier = new TimeSeriesGeoLineBuckets.Simplifier(bucketSize, circuitBreaker);\n    }\n"}
{"magic_number_smell": "\n    public GeoHexGridAggregationBuilder(String name) {\n        super(name);\n        precision(5);\n        size(DEFAULT_MAX_NUM_CELLS);\n        shardSize = -1;\n    }", "refactored_code": "    private static final int DEFAULT_PRECISION = 5;\n\n    public GeoHexGridAggregationBuilder(String name) {\n        super(name);\n        precision(DEFAULT_PRECISION);\n        size(DEFAULT_MAX_NUM_CELLS);\n        shardSize = -1;\n    }"}
{"magic_number_smell": "            this.resolution = resolution;\n            inflatedBboxes = new GeoBoundingBox[resolution];\n            for (int i = 0; i < resolution; i++) {\n                inflatedBboxes[i] = inflateBbox(i, bbox, 0.37);\n            }\n        }\n", "refactored_code": "        private static final double FACTOR = 0.37;\n            this.resolution = resolution;\n            inflatedBboxes = new GeoBoundingBox[resolution];\n            for (int i = 0; i < resolution; i++) {\n                inflatedBboxes[i] = inflateBbox(i, bbox, FACTOR);\n            }\n        }\n"}
{"magic_number_smell": "        }\n\n        if (bounds.checkNoTopLatitudeBound()) {\n            assertEquals(90d, boundingBox.top(), 1e-7);\n        } else {\n            assertEquals(Math.toDegrees(bounds.getMaxLatitude()), boundingBox.top(), 1e-7);\n        }", "refactored_code": "    private static final double LAT_DELTA = 1e-7;\n        }\n\n        if (bounds.checkNoTopLatitudeBound()) {\n            assertEquals(90d, boundingBox.top(), LAT_DELTA);\n        } else {\n            assertEquals(Math.toDegrees(bounds.getMaxLatitude()), boundingBox.top(), LAT_DELTA);\n        }"}
{"magic_number_smell": "            assertEquals(\"my_agg\", result.getName());\n            SpatialPoint centroid = result.centroid();\n            assertNotNull(centroid);\n            assertEquals(expectedCentroid.getX(), centroid.getX(), 1E-6D);\n            assertEquals(expectedCentroid.getY(), centroid.getY(), 1E-6D);\n            assertTrue(AggregationInspectionHelper.hasValue(result));\n        }", "refactored_code": "    private static final double GEOHASH_TOLERANCE = 1E-6D;\n            assertEquals(\"my_agg\", result.getName());\n            SpatialPoint centroid = result.centroid();\n            assertNotNull(centroid);\n            assertEquals(expectedCentroid.getX(), centroid.getX(), GEOHASH_TOLERANCE);\n            assertEquals(expectedCentroid.getY(), centroid.getY(), GEOHASH_TOLERANCE);\n            assertTrue(AggregationInspectionHelper.hasValue(result));\n        }"}
{"magic_number_smell": "    static EsType of(SQLType sqlType, int scaleOrLength) throws SQLException {\n        EsType esType;\n        if (sqlType.getVendorTypeNumber() == BIGINT) {\n            esType = scaleOrLength > String.valueOf(Long.MAX_VALUE).length() ? EsType.UNSIGNED_LONG : EsType.LONG;\n        } else {\n            esType = TypeUtils.of(sqlType);\n        }", "refactored_code": "    public static final int LONG_MAX_LENGTH = String.valueOf(Long.MAX_VALUE).length(); // type length value as defined in ES\n    static EsType of(SQLType sqlType, int scaleOrLength) throws SQLException {\n        EsType esType;\n        if (sqlType.getVendorTypeNumber() == BIGINT) {\n            esType = scaleOrLength > LONG_MAX_LENGTH ? EsType.UNSIGNED_LONG : EsType.LONG;\n        } else {\n            esType = TypeUtils.of(sqlType);\n        }"}
{"magic_number_smell": "    }\n\n    private static StringBuilder trimOrPad(StringBuilder buffer) {\n        if (buffer.length() > 20) {\n            buffer.setLength(20 - 1);\n            buffer.append(\"~\");\n        } else {", "refactored_code": "    private static final int MAX_WIDTH = 20;\n    }\n\n    private static StringBuilder trimOrPad(StringBuilder buffer) {\n        if (buffer.length() > MAX_WIDTH) {\n            buffer.setLength(MAX_WIDTH - 1);\n            buffer.append(\"~\");\n        } else {"}
{"magic_number_smell": "        // whole hours apart from the UTC, check also that timezone against being within the \"rolling\" interval. (This won't catch the case\n        // when the random TZ and the local machine's are both having hour-fractional deltas from UTC, but this case should be negligible).\n        if (testName.toUpperCase(Locale.ROOT).endsWith(\"TZSYNC\")) {\n            Assume.assumeTrue(LocalDateTime.now(TimeZone.getDefault().toZoneId()).getMinute() <= 55);\n            Assume.assumeTrue(LocalDateTime.now(ZoneId.of(\"UTC\")).getMinute() <= 55);\n        }\n", "refactored_code": "    private final int TZSYNC_MINUTE_THRESHOLD = 55;\n        // whole hours apart from the UTC, check also that timezone against being within the \"rolling\" interval. (This won't catch the case\n        // when the random TZ and the local machine's are both having hour-fractional deltas from UTC, but this case should be negligible).\n        if (testName.toUpperCase(Locale.ROOT).endsWith(\"TZSYNC\")) {\n            Assume.assumeTrue(LocalDateTime.now(TimeZone.getDefault().toZoneId()).getMinute() <= TZSYNC_MINUTE_THRESHOLD);\n            Assume.assumeTrue(LocalDateTime.now(ZoneId.of(\"UTC\")).getMinute() <= TZSYNC_MINUTE_THRESHOLD);\n        }\n"}
{"magic_number_smell": "    }\n\n    protected static TimeValue timeout() {\n        return TimeValue.timeValueSeconds(40L);\n    }\n\n    /**", "refactored_code": "    private static final long CLIENT_TIMEOUT = 40L; // upped from 10s to accommodate for max measured throughput decline\n    }\n\n    protected static TimeValue timeout() {\n        return TimeValue.timeValueSeconds(CLIENT_TIMEOUT);\n    }\n\n    /**"}
{"magic_number_smell": "    public final byte build; // the build is required for id-compatibility with ES's version\n\n    public static final int 100 = 100;\n    public static final int MINOR_MULTIPLIER = 100 * 100;\n    public static final int MAJOR_MULTIPLIER = 100 * MINOR_MULTIPLIER;\n\n    public static final SqlVersion V_7_7_0 = new SqlVersion(7, 7, 0);", "refactored_code": "    public static final int REVISION_MULTIPLIER = 100;\n    public final byte build; // the build is required for id-compatibility with ES's version\n\n    public static final int REVISION_MULTIPLIER = 100;\n    public static final int MINOR_MULTIPLIER = REVISION_MULTIPLIER * REVISION_MULTIPLIER;\n    public static final int MAJOR_MULTIPLIER = REVISION_MULTIPLIER * MINOR_MULTIPLIER;\n\n    public static final SqlVersion V_7_7_0 = new SqlVersion(7, 7, 0);"}
{"magic_number_smell": "        .toFormatter(Locale.ROOT);\n\n    private static final int 60 = 60;\n    private static final int SECONDS_PER_HOUR = 60 * 60;\n    private static final int SECONDS_PER_DAY = SECONDS_PER_HOUR * 24;\n\n    private StringUtils() {}", "refactored_code": "    private static final int SECONDS_PER_MINUTE = 60;\n        .toFormatter(Locale.ROOT);\n\n    private static final int SECONDS_PER_MINUTE = 60;\n    private static final int SECONDS_PER_HOUR = SECONDS_PER_MINUTE * 60;\n    private static final int SECONDS_PER_DAY = SECONDS_PER_HOUR * 24;\n\n    private StringUtils() {}"}
{"magic_number_smell": "        width = new int[columns.size()];\n        for (int i = 0; i < width.length; i++) {\n            // TODO read the width from the data type?\n            width[i] = Math.max(15, columns.get(i).name().length());\n        }\n\n        // 2. Expand columns to fit the largest value", "refactored_code": "    private static final int MIN_COLUMN_WIDTH = 15;\n        width = new int[columns.size()];\n        for (int i = 0; i < width.length; i++) {\n            // TODO read the width from the data type?\n            width[i] = Math.max(MIN_COLUMN_WIDTH, columns.get(i).name().length());\n        }\n\n        // 2. Expand columns to fit the largest value"}
{"magic_number_smell": "        LocalAggregationSorterListener(ActionListener<Page> listener, List<Tuple<Integer, Comparator>> sortingColumns, int limit) {\n            super(listener);\n\n            int size = MultiBucketConsumerService.DEFAULT_MAX_BUCKETS;\n            if (limit < 0) {\n                noLimit = true;\n            } else {", "refactored_code": "        private static final int MAXIMUM_SIZE = MultiBucketConsumerService.DEFAULT_MAX_BUCKETS;\n        LocalAggregationSorterListener(ActionListener<Page> listener, List<Tuple<Integer, Comparator>> sortingColumns, int limit) {\n            super(listener);\n\n            int size = MAXIMUM_SIZE;\n            if (limit < 0) {\n                noLimit = true;\n            } else {"}
{"magic_number_smell": "        }\n\n        if (l instanceof OffsetTime) {\n            r = Duration.ofMillis(r.toMillis() % 60 * 60 * 24 * 1000L);\n        }\n\n        if (operation == IntervalOperation.ADD) {", "refactored_code": "    public static final long DAY_IN_MILLIS = 60 * 60 * 24 * 1000L;\n        }\n\n        if (l instanceof OffsetTime) {\n            r = Duration.ofMillis(r.toMillis() % DAY_IN_MILLIS);\n        }\n\n        if (operation == IntervalOperation.ADD) {"}
{"magic_number_smell": "            }\n        }\n\n        restResponse.addHeader(HEADER_NAME_TOOK_NANOS, Long.toString(System.nanoTime() - System.nanoTime()));\n        return restResponse;\n    }\n", "refactored_code": "    private final long startNanos = System.nanoTime();\n            }\n        }\n\n        restResponse.addHeader(HEADER_NAME_TOOK_NANOS, Long.toString(System.nanoTime() - startNanos));\n        return restResponse;\n    }\n"}
{"magic_number_smell": "\n            @Override\n            public boolean hasNext() {\n                return pos < columnCount();\n            }\n\n            @Override", "refactored_code": "            private final int rowSize = columnCount();\n\n            @Override\n            public boolean hasNext() {\n                return pos < rowSize;\n            }\n\n            @Override"}
{"magic_number_smell": "     * Creates an date for SQL TIME type from the millis since epoch.\n     */\n    public static OffsetTime asTimeOnly(long millis) {\n        return OffsetTime.ofInstant(Instant.ofEpochMilli(millis % 60 * 60 * 24 * 1000L), UTC);\n    }\n\n    /**", "refactored_code": "    public static final long DAY_IN_MILLIS = 60 * 60 * 24 * 1000L;\n     * Creates an date for SQL TIME type from the millis since epoch.\n     */\n    public static OffsetTime asTimeOnly(long millis) {\n        return OffsetTime.ofInstant(Instant.ofEpochMilli(millis % DAY_IN_MILLIS), UTC);\n    }\n\n    /**"}
{"magic_number_smell": "\n    private BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n        BigDecimal seconds = new BigDecimal(\n            RandomNumbers.randomLongBetween(random, (minYear - 1970) * 365 * 24 * 60 * 60L, (maxYear - 1970) * 365 * 24 * 60 * 60L)\n        );\n        BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(random, 0, 999_999)).movePointLeft(6);\n        return seconds.add(fractions);", "refactored_code": "    private static final long SECONDS_IN_YEAR = 365 * 24 * 60 * 60L;\n\n    private BigDecimal randomSecondsWithFractions(int minYear, int maxYear) {\n        BigDecimal seconds = new BigDecimal(\n            RandomNumbers.randomLongBetween(random, (minYear - 1970) * SECONDS_IN_YEAR, (maxYear - 1970) * SECONDS_IN_YEAR)\n        );\n        BigDecimal fractions = new BigDecimal(RandomNumbers.randomIntBetween(random, 0, 999_999)).movePointLeft(6);\n        return seconds.add(fractions);"}
{"magic_number_smell": "\n    public void testSysColumnsNoArg() {\n        executeCommand(\"SYS COLUMNS\", emptyList(), r -> {\n            assertEquals(20, r.size());\n            assertEquals(CLUSTER_NAME, r.column(0));\n            // no index specified\n            assertEquals(\"test\", r.column(2));", "refactored_code": "    private static final int FIELD_COUNT1 = 20;\n\n    public void testSysColumnsNoArg() {\n        executeCommand(\"SYS COLUMNS\", emptyList(), r -> {\n            assertEquals(FIELD_COUNT1, r.size());\n            assertEquals(CLUSTER_NAME, r.column(0));\n            // no index specified\n            assertEquals(\"test\", r.column(2));"}
{"magic_number_smell": "            new IndexTemplateConfig(\n                DATA_STREAMS_MAPPINGS_COMPONENT_TEMPLATE_NAME,\n                \"/data-streams@mappings.json\",\n                4,\n                TEMPLATE_VERSION_VARIABLE,\n                ADDITIONAL_TEMPLATE_VARIABLES\n            ),", "refactored_code": "    public static final int REGISTRY_VERSION = 4;\n            new IndexTemplateConfig(\n                DATA_STREAMS_MAPPINGS_COMPONENT_TEMPLATE_NAME,\n                \"/data-streams@mappings.json\",\n                REGISTRY_VERSION,\n                TEMPLATE_VERSION_VARIABLE,\n                ADDITIONAL_TEMPLATE_VARIABLES\n            ),"}
{"magic_number_smell": "            new IndexTemplateConfig(\n                DATA_STREAMS_MAPPINGS_COMPONENT_TEMPLATE_NAME,\n                \"/data-streams@mappings.json\",\n                8,\n                TEMPLATE_VERSION_VARIABLE,\n                ADDITIONAL_TEMPLATE_VARIABLES\n            ),", "refactored_code": "    public static final int REGISTRY_VERSION = 8;\n            new IndexTemplateConfig(\n                DATA_STREAMS_MAPPINGS_COMPONENT_TEMPLATE_NAME,\n                \"/data-streams@mappings.json\",\n                REGISTRY_VERSION,\n                TEMPLATE_VERSION_VARIABLE,\n                ADDITIONAL_TEMPLATE_VARIABLES\n            ),"}
{"magic_number_smell": "        // there are \"message\" fields that are much longer than the other\n        // fields, vary enormously between rows, and skew the comparison.\n        DoubleSummaryStatistics firstRowStats = otherRows.stream()\n            .limit(100)\n            .mapToDouble(otherRow -> (double) levenshteinFieldwiseCompareRows(firstRow, otherRow, shortFieldMask))\n            .collect(DoubleSummaryStatistics::new, DoubleSummaryStatistics::accept, DoubleSummaryStatistics::combine);\n", "refactored_code": "    private static final int MAX_LEVENSHTEIN_COMPARISONS = 100;\n        // there are \"message\" fields that are much longer than the other\n        // fields, vary enormously between rows, and skew the comparison.\n        DoubleSummaryStatistics firstRowStats = otherRows.stream()\n            .limit(MAX_LEVENSHTEIN_COMPARISONS)\n            .mapToDouble(otherRow -> (double) levenshteinFieldwiseCompareRows(firstRow, otherRow, shortFieldMask))\n            .collect(DoubleSummaryStatistics::new, DoubleSummaryStatistics::accept, DoubleSummaryStatistics::combine);\n"}
{"magic_number_smell": "        // If a pattern like this is matched against a line that nearly matches but not quite (which is basically guaranteed in\n        // the not-quite-valid-CSV file case) then the backtracking will cause the match attempt to run for many days. Therefore\n        // it's better to just error out in this case and let the user try again with overrides.\n        if (complexity >= 8) {\n            throw new IllegalArgumentException(\n                \"Generated multi-line start pattern based on timestamp position [\"\n                    + builder", "refactored_code": "    private static final int TOO_MANY_IDENTICAL_DELIMITERS_BEFORE_WILDCARDS = 8;\n        // If a pattern like this is matched against a line that nearly matches but not quite (which is basically guaranteed in\n        // the not-quite-valid-CSV file case) then the backtracking will cause the match attempt to run for many days. Therefore\n        // it's better to just error out in this case and let the user try again with overrides.\n        if (complexity >= TOO_MANY_IDENTICAL_DELIMITERS_BEFORE_WILDCARDS) {\n            throw new IllegalArgumentException(\n                \"Generated multi-line start pattern based on timestamp position [\"\n                    + builder"}
{"magic_number_smell": "     * @param idealSampleLineCount Ideally, how many lines from the stream will be read to determine the structure?\n     *                             If the stream has fewer lines then an attempt will still be made, providing at\n     *                             least {@link AbstractFindStructureRequest#MIN_SAMPLE_LINE_COUNT} lines can be read.  If\n     *                             <code>null</code> the value of {@link #1000} will be used.\n     * @param lineMergeSizeLimit Maximum number of characters permitted when lines are merged to create messages.\n     *                           If <code>null</code> the value of {@link #DEFAULT_LINE_MERGE_SIZE_LIMIT} will be used.\n     * @param fromText A stream from which the sample will be read.", "refactored_code": "    public static final int DEFAULT_IDEAL_SAMPLE_LINE_COUNT = 1000;\n     * @param idealSampleLineCount Ideally, how many lines from the stream will be read to determine the structure?\n     *                             If the stream has fewer lines then an attempt will still be made, providing at\n     *                             least {@link AbstractFindStructureRequest#MIN_SAMPLE_LINE_COUNT} lines can be read.  If\n     *                             <code>null</code> the value of {@link #DEFAULT_IDEAL_SAMPLE_LINE_COUNT} will be used.\n     * @param lineMergeSizeLimit Maximum number of characters permitted when lines are merged to create messages.\n     *                           If <code>null</code> the value of {@link #DEFAULT_LINE_MERGE_SIZE_LIMIT} will be used.\n     * @param fromText A stream from which the sample will be read."}
{"magic_number_smell": "        FieldStatsCalculator calculator = new FieldStatsCalculator(mapping);\n        calculator.accept(fieldValues);\n        timeoutChecker.check(\"field stats calculation\");\n        return calculator.calculate(10);\n    }\n\n    /**", "refactored_code": "    private static final int NUM_TOP_HITS = 10;\n        FieldStatsCalculator calculator = new FieldStatsCalculator(mapping);\n        calculator.accept(fieldValues);\n        timeoutChecker.check(\"field stats calculation\");\n        return calculator.calculate(NUM_TOP_HITS);\n    }\n\n    /**"}
{"magic_number_smell": "    private static final String TRANSFORM_NAME = \"transform-crud-latest\";\n\n    private static Integer getUserIdForRow(int row) {\n        int userId = row % (28 + 1);\n        return userId < 28 ? userId : null;\n    }\n", "refactored_code": "    private static final int NUM_USERS = 28;\n    private static final String TRANSFORM_NAME = \"transform-crud-latest\";\n\n    private static Integer getUserIdForRow(int row) {\n        int userId = row % (NUM_USERS + 1);\n        return userId < NUM_USERS ? userId : null;\n    }\n"}
{"magic_number_smell": "        String transformId = \"transform-permissions-nodefer-\" + (unattended ? 1 : 0);\n        String sourceIndexName = transformId + \"-index\";\n        String destIndexName = transformId + \"-dest\";\n        createReviewsIndex(sourceIndexName, 10, 28, TransformIT::getUserIdForRow, TransformIT::getDateStringForRow);\n\n        TransformConfig config = createConfig(transformId, sourceIndexName, destIndexName, null, unattended);\n", "refactored_code": "    private static final int NUM_USERS = 28;\n        String transformId = \"transform-permissions-nodefer-\" + (unattended ? 1 : 0);\n        String sourceIndexName = transformId + \"-index\";\n        String destIndexName = transformId + \"-dest\";\n        createReviewsIndex(sourceIndexName, 10, NUM_USERS, TransformIT::getUserIdForRow, TransformIT::getDateStringForRow);\n\n        TransformConfig config = createConfig(transformId, sourceIndexName, destIndexName, null, unattended);\n"}
{"magic_number_smell": "    private static final int 28 = 28;\n\n    static Integer getUserIdForRow(int row) {\n        return row % 28;\n    }\n\n    static String getDateStringForRow(int row) {", "refactored_code": "    private static final int NUM_USERS = 28;\n    private static final int NUM_USERS = 28;\n\n    static Integer getUserIdForRow(int row) {\n        return row % NUM_USERS;\n    }\n\n    static String getDateStringForRow(int row) {"}
{"magic_number_smell": "\n    @Before\n    public void createReviewsIndex() throws Exception {\n        createReviewsIndex(REVIEWS_INDEX_NAME, 100, 28, TransformIT::getUserIdForRow, TransformIT::getDateStringForRow);\n    }\n\n    @After", "refactored_code": "    private static final int NUM_USERS = 28;\n\n    @Before\n    public void createReviewsIndex() throws Exception {\n        createReviewsIndex(REVIEWS_INDEX_NAME, 100, NUM_USERS, TransformIT::getUserIdForRow, TransformIT::getDateStringForRow);\n    }\n\n    @After"}
{"magic_number_smell": "                        Strings.format(\n                            \"Timeout [%ds] waiting for transform [%s] to finish next checkpoint, \"\n                                + \"iteration [%d], state [%s], reason in case of failure [%s], last search time [%d]\",\n                            120,\n                            testCase.getName(),\n                            iteration,\n                            stats.get(\"state\"),", "refactored_code": "    public static final int MAX_WAIT_TIME_ONE_ITERATION_SECONDS = 120;\n                        Strings.format(\n                            \"Timeout [%ds] waiting for transform [%s] to finish next checkpoint, \"\n                                + \"iteration [%d], state [%s], reason in case of failure [%s], last search time [%d]\",\n                            MAX_WAIT_TIME_ONE_ITERATION_SECONDS,\n                            testCase.getName(),\n                            iteration,\n                            stats.get(\"state\"),"}
{"magic_number_smell": "    // In order to ensure BWC, this cluster-level setting serves as a fallback in case the transform-level setting is not specified.\n    public static final Setting<Integer> NUM_FAILURE_RETRIES_SETTING = Setting.intSetting(\n        \"xpack.transform.num_transform_failure_retries\",\n        10,\n        0,\n        SettingsConfig.MAX_NUM_FAILURE_RETRIES,\n        Setting.Property.NodeScope,", "refactored_code": "    public static final int DEFAULT_FAILURE_RETRIES = 10;\n    // In order to ensure BWC, this cluster-level setting serves as a fallback in case the transform-level setting is not specified.\n    public static final Setting<Integer> NUM_FAILURE_RETRIES_SETTING = Setting.intSetting(\n        \"xpack.transform.num_transform_failure_retries\",\n        DEFAULT_FAILURE_RETRIES,\n        0,\n        SettingsConfig.MAX_NUM_FAILURE_RETRIES,\n        Setting.Property.NodeScope,"}
{"magic_number_smell": "            // recording the time spend would be complex and crosses machine boundaries, that's why we use a heuristic here\n            TimeValue.timeValueMillis(\n                (long) ((request.getTimeout() != null ? request.getTimeout().millis() : AcknowledgedRequest.DEFAULT_ACK_TIMEOUT.millis())\n                    * 0.8)\n            )\n        );\n    }", "refactored_code": "    private static final double CHECKPOINT_INFO_TIMEOUT_SHARE = 0.8;\n            // recording the time spend would be complex and crosses machine boundaries, that's why we use a heuristic here\n            TimeValue.timeValueMillis(\n                (long) ((request.getTimeout() != null ? request.getTimeout().millis() : AcknowledgedRequest.DEFAULT_ACK_TIMEOUT.millis())\n                    * CHECKPOINT_INFO_TIMEOUT_SHARE)\n            )\n        );\n    }"}
{"magic_number_smell": "                source,\n                // Use deduced mappings for generating preview even if \"settings.deduce_mappings\" is set to false\n                deducedMappings,\n                100,\n                previewListener\n            );\n        }, listener::onFailure);", "refactored_code": "    private static final int NUMBER_OF_PREVIEW_BUCKETS = 100;\n                source,\n                // Use deduced mappings for generating preview even if \"settings.deduce_mappings\" is set to false\n                deducedMappings,\n                NUMBER_OF_PREVIEW_BUCKETS,\n                previewListener\n            );\n        }, listener::onFailure);"}
{"magic_number_smell": "            Set<String> removedIndexes = Sets.difference(lastSourceIndexes, newSourceIndexes);\n            Set<String> addedIndexes = Sets.difference(newSourceIndexes, lastSourceIndexes);\n\n            if (removedIndexes.size() + addedIndexes.size() > 10) {\n                String message = \"Source index resolve found more than \"\n                    + 10\n                    + \" changes, [\"", "refactored_code": "    private static final int AUDIT_CONCRETED_SOURCE_INDEX_CHANGES = 10;\n            Set<String> removedIndexes = Sets.difference(lastSourceIndexes, newSourceIndexes);\n            Set<String> addedIndexes = Sets.difference(newSourceIndexes, lastSourceIndexes);\n\n            if (removedIndexes.size() + addedIndexes.size() > AUDIT_CONCRETED_SOURCE_INDEX_CHANGES) {\n                String message = \"Source index resolve found more than \"\n                    + AUDIT_CONCRETED_SOURCE_INDEX_CHANGES\n                    + \" changes, [\""}
{"magic_number_smell": "\n    @Override\n    public void getAllTransformIds(TimeValue timeout, ActionListener<Set<String>> listener) {\n        expandAllTransformIds(false, 10_000, timeout, listener.delegateFailureAndWrap((l, r) -> l.onResponse(r.v2())));\n    }\n\n    @Override", "refactored_code": "    private static final int MAX_RESULTS_WINDOW = 10_000;\n\n    @Override\n    public void getAllTransformIds(TimeValue timeout, ActionListener<Set<String>> listener) {\n        expandAllTransformIds(false, MAX_RESULTS_WINDOW, timeout, listener.delegateFailureAndWrap((l, r) -> l.onResponse(r.v2())));\n    }\n\n    @Override"}
{"magic_number_smell": "    private static XContentBuilder addMetaInformation(XContentBuilder builder) throws IOException {\n        return builder.startObject(\"_meta\")\n            .field(\"version\", LEGACY_VERSION_FIELD_VALUE)\n            .field(SystemIndexDescriptor.VERSION_META_KEY, 1)\n            .endObject();\n    }\n", "refactored_code": "    public static final int TRANSFORM_INDEX_MAPPINGS_VERSION = 1;\n    private static XContentBuilder addMetaInformation(XContentBuilder builder) throws IOException {\n        return builder.startObject(\"_meta\")\n            .field(\"version\", LEGACY_VERSION_FIELD_VALUE)\n            .field(SystemIndexDescriptor.VERSION_META_KEY, TRANSFORM_INDEX_MAPPINGS_VERSION)\n            .endObject();\n    }\n"}
{"magic_number_smell": "                v = EMPTY_VALUE;\n            }\n            buffer.append(v, 0, v.length);\n            buffer.append('$');\n\n            // keep the 1st byte of every object\n            if (hashedBytes.length() <= MAX_FIRST_BYTES) {", "refactored_code": "    private static final byte DELIM = '$';\n                v = EMPTY_VALUE;\n            }\n            buffer.append(v, 0, v.length);\n            buffer.append(DELIM);\n\n            // keep the 1st byte of every object\n            if (hashedBytes.length() <= MAX_FIRST_BYTES) {"}
{"magic_number_smell": "        // Since our schedule fires again very quickly after failures it is possible to run into the same failure numerous\n        // times in a row, very quickly. We do not want to spam the audit log with repeated failures, so only record the first one\n        // and if the number of retries is about to exceed\n        if (repeatedFailure == false || failureCount % 10 == 0 || failureCount == numFailureRetries) {\n            String retryMessage = format(\n                \"Transform encountered an exception: [%s]; Will automatically retry [%d/%d]\",\n                message,", "refactored_code": "    public static final int LOG_FAILURE_EVERY = 10;\n        // Since our schedule fires again very quickly after failures it is possible to run into the same failure numerous\n        // times in a row, very quickly. We do not want to spam the audit log with repeated failures, so only record the first one\n        // and if the number of retries is about to exceed\n        if (repeatedFailure == false || failureCount % LOG_FAILURE_EVERY == 0 || failureCount == numFailureRetries) {\n            String retryMessage = format(\n                \"Transform encountered an exception: [%s]; Will automatically retry [%d/%d]\",\n                message,"}
{"magic_number_smell": "                () -> format(\n                    \"[%s] Interrupt waiting (%ss) for transform state to be stored.\",\n                    getJobId(),\n                    5\n                ),\n                e\n            );", "refactored_code": "    private static final int PERSIST_STOP_AT_CHECKPOINT_TIMEOUT_SEC = 5;\n                () -> format(\n                    \"[%s] Interrupt waiting (%ss) for transform state to be stored.\",\n                    getJobId(),\n                    PERSIST_STOP_AT_CHECKPOINT_TIMEOUT_SEC\n                ),\n                e\n            );"}
{"magic_number_smell": "            )\n        );\n        try {\n            latch.await(90, TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n            logger.error(\"Timeout waiting for task [\" + task.getTransformId() + \"] to be marked as failed in cluster state\", e);\n        }", "refactored_code": "    private static final int MARK_AS_FAILED_TIMEOUT_SEC = 90;\n            )\n        );\n        try {\n            latch.await(MARK_AS_FAILED_TIMEOUT_SEC, TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n            logger.error(\"Timeout waiting for task [\" + task.getTransformId() + \"] to be marked as failed in cluster state\", e);\n        }"}
{"magic_number_smell": "        TimeValue timeout,\n        ActionListener<Boolean> listener\n    ) {\n        SearchRequest searchRequest = buildSearchRequest(sourceConfig, timeout, 50);\n        ClientHelper.executeWithHeadersAsync(\n            headers,\n            ClientHelper.TRANSFORM_ORIGIN,", "refactored_code": "    public static final int TEST_QUERY_PAGE_SIZE = 50;\n        TimeValue timeout,\n        ActionListener<Boolean> listener\n    ) {\n        SearchRequest searchRequest = buildSearchRequest(sourceConfig, timeout, TEST_QUERY_PAGE_SIZE);\n        ClientHelper.executeWithHeadersAsync(\n            headers,\n            ClientHelper.TRANSFORM_ORIGIN,"}
{"magic_number_smell": "\n    @Override\n    public int getInitialPageSize() {\n        return 5000;\n    }\n\n    @Override", "refactored_code": "    public static final int DEFAULT_INITIAL_MAX_PAGE_SEARCH_SIZE = 5000;\n\n    @Override\n    public int getInitialPageSize() {\n        return DEFAULT_INITIAL_MAX_PAGE_SEARCH_SIZE;\n    }\n\n    @Override"}
{"magic_number_smell": "                return null;\n            }\n            // (upperBound - lowerBound) >= interval, so never 0.\n            if ((maxUpperBound - minLowerBound) / (upperBound - lowerBound) < 1.2) {\n                return null;\n            }\n", "refactored_code": "        private static final double MIN_CUT_OFF = 1.2;\n                return null;\n            }\n            // (upperBound - lowerBound) >= interval, so never 0.\n            if ((maxUpperBound - minLowerBound) / (upperBound - lowerBound) < MIN_CUT_OFF) {\n                return null;\n            }\n"}
{"magic_number_smell": "        }\n\n        // Math.min(failureCount, 32) is applied in order to avoid overflow.\n        long delayMillis = Math.min(Math.max((1L << Math.min(failureCount, 32)) * 1000, Duration.ofSeconds(5).toMillis()), MAX_DELAY_MILLIS);\n        return baseTime + delayMillis;\n    }\n}", "refactored_code": "    private static final long MIN_DELAY_MILLIS = Duration.ofSeconds(5).toMillis();\n        }\n\n        // Math.min(failureCount, 32) is applied in order to avoid overflow.\n        long delayMillis = Math.min(Math.max((1L << Math.min(failureCount, 32)) * 1000, MIN_DELAY_MILLIS), MAX_DELAY_MILLIS);\n        return baseTime + delayMillis;\n    }\n}"}
{"magic_number_smell": "    private static final String CREATED_BY = \"transform\";\n\n    private Client client;\n    private final Clock clock = Clock.fixed(Instant.ofEpochMilli(123456789), ZoneId.systemDefault());\n\n    @Before\n    public void setUpMocks() {", "refactored_code": "    private static final int CURRENT_TIME_MILLIS = 123456789;\n    private static final String CREATED_BY = \"transform\";\n\n    private Client client;\n    private final Clock clock = Clock.fixed(Instant.ofEpochMilli(CURRENT_TIME_MILLIS), ZoneId.systemDefault());\n\n    @Before\n    public void setUpMocks() {"}
{"magic_number_smell": "\n        when(minTimestamp.getName()).thenReturn(\"_transform_change_collector.output_timestamp.min\");\n        when(maxTimestamp.getName()).thenReturn(\"_transform_change_collector.output_timestamp.max\");\n        when(minTimestamp.value()).thenReturn(122_633);\n        when(maxTimestamp.value()).thenReturn(MAX_TIMESTAMP_VALUE);\n\n        groups = new HashMap<>();", "refactored_code": "    private static final double MIN_TIMESTAMP_VALUE = 122_633;\n\n        when(minTimestamp.getName()).thenReturn(\"_transform_change_collector.output_timestamp.min\");\n        when(maxTimestamp.getName()).thenReturn(\"_transform_change_collector.output_timestamp.max\");\n        when(minTimestamp.value()).thenReturn(MIN_TIMESTAMP_VALUE);\n        when(maxTimestamp.value()).thenReturn(MAX_TIMESTAMP_VALUE);\n\n        groups = new HashMap<>();"}
{"magic_number_smell": "    private static final Listener LISTENER = event -> {};\n\n    public void testBasics() {\n        TransformScheduledTask task = new TransformScheduledTask(TRANSFORM_ID, FREQUENCY, 100000L, 0, 123, LISTENER);\n        assertThat(task.getTransformId(), is(equalTo(TRANSFORM_ID)));\n        assertThat(task.getFrequency(), is(equalTo(FREQUENCY)));\n        assertThat(task.getLastTriggeredTimeMillis(), is(equalTo(100000L)));", "refactored_code": "    private static final long LAST_TRIGGERED_TIME_MILLIS = 100000L;\n    private static final Listener LISTENER = event -> {};\n\n    public void testBasics() {\n        TransformScheduledTask task = new TransformScheduledTask(TRANSFORM_ID, FREQUENCY, LAST_TRIGGERED_TIME_MILLIS, 0, 123, LISTENER);\n        assertThat(task.getTransformId(), is(equalTo(TRANSFORM_ID)));\n        assertThat(task.getFrequency(), is(equalTo(FREQUENCY)));\n        assertThat(task.getLastTriggeredTimeMillis(), is(equalTo(LAST_TRIGGERED_TIME_MILLIS)));"}
{"magic_number_smell": "        // Following the same strategy of the _search API, some parameters can be defined in the body or as URL parameters.\n        // URL parameters takes precedence so we check them here.\n        if (restRequest.hasParam(SearchSourceBuilder.SIZE_FIELD.getPreferredName())) {\n            request.setSize(restRequest.paramAsInt(SearchSourceBuilder.SIZE_FIELD.getPreferredName(), Defaults.10000));\n        }\n        if (restRequest.hasParam(GRID_PRECISION_FIELD.getPreferredName())) {\n            request.setGridPrecision(restRequest.paramAsInt(GRID_PRECISION_FIELD.getPreferredName(), Defaults.GRID_PRECISION));", "refactored_code": "        public static final int SIZE = 10000;\n        // Following the same strategy of the _search API, some parameters can be defined in the body or as URL parameters.\n        // URL parameters takes precedence so we check them here.\n        if (restRequest.hasParam(SearchSourceBuilder.SIZE_FIELD.getPreferredName())) {\n            request.setSize(restRequest.paramAsInt(SearchSourceBuilder.SIZE_FIELD.getPreferredName(), Defaults.SIZE));\n        }\n        if (restRequest.hasParam(GRID_PRECISION_FIELD.getPreferredName())) {\n            request.setGridPrecision(restRequest.paramAsInt(GRID_PRECISION_FIELD.getPreferredName(), Defaults.GRID_PRECISION));"}
{"magic_number_smell": "                {\n                    builder.startObject(\"_meta\");\n                    builder.field(\"version\", LEGACY_VERSION_FIELD_VALUE);\n                    builder.field(SystemIndexDescriptor.VERSION_META_KEY, 1);\n                    builder.endObject();\n                }\n                {", "refactored_code": "    private static final int WATCHES_INDEX_MAPPINGS_VERSION = 1;\n                {\n                    builder.startObject(\"_meta\");\n                    builder.field(\"version\", LEGACY_VERSION_FIELD_VALUE);\n                    builder.field(SystemIndexDescriptor.VERSION_META_KEY, WATCHES_INDEX_MAPPINGS_VERSION);\n                    builder.endObject();\n                }\n                {"}
{"magic_number_smell": "        }\n\n        clientBuilder.evictExpiredConnections();\n        clientBuilder.setMaxConnPerRoute(500);\n        clientBuilder.setMaxConnTotal(500);\n        /*\n         * This client will potentially be used by multiple users. We do not want it to keep any state like cookies, because that will", "refactored_code": "    private static final int MAX_CONNECTIONS = 500;\n        }\n\n        clientBuilder.evictExpiredConnections();\n        clientBuilder.setMaxConnPerRoute(MAX_CONNECTIONS);\n        clientBuilder.setMaxConnTotal(MAX_CONNECTIONS);\n        /*\n         * This client will potentially be used by multiple users. We do not want it to keep any state like cookies, because that will"}
{"magic_number_smell": "        HttpClient httpClient = scenario.client();\n        HttpMethod method = randomFrom(HttpMethod.GET, HttpMethod.POST, HttpMethod.PUT, HttpMethod.DELETE, HttpMethod.HEAD);\n\n        HttpRequestTemplate httpRequest = getHttpRequestTemplate(method, TEST_HOST, 8089, testPath, testBody, null);\n\n        WebhookAction action = new WebhookAction(httpRequest);\n        WebhookService webhookService = new WebhookService(", "refactored_code": "    private static final int TEST_PORT = 8089;\n        HttpClient httpClient = scenario.client();\n        HttpMethod method = randomFrom(HttpMethod.GET, HttpMethod.POST, HttpMethod.PUT, HttpMethod.DELETE, HttpMethod.HEAD);\n\n        HttpRequestTemplate httpRequest = getHttpRequestTemplate(method, TEST_HOST, TEST_PORT, testPath, testBody, null);\n\n        WebhookAction action = new WebhookAction(httpRequest);\n        WebhookService webhookService = new WebhookService("}
{"magic_number_smell": "    static final NamedAnalyzer WILDCARD_ANALYZER_7_10 = new NamedAnalyzer(\"_wildcard_7_10\", AnalyzerScope.GLOBAL, new Analyzer() {\n        @Override\n        public TokenStreamComponents createComponents(String fieldName) {\n            Tokenizer tokenizer = new NGramTokenizer(3, 3);\n            TokenStream tok = new LowerCaseFilter(tokenizer);\n            tok = new PunctuationFoldingFilter(tok);\n            return new TokenStreamComponents(tokenizer::setReader, tok);", "refactored_code": "    public static final int NGRAM_SIZE = 3;\n    static final NamedAnalyzer WILDCARD_ANALYZER_7_10 = new NamedAnalyzer(\"_wildcard_7_10\", AnalyzerScope.GLOBAL, new Analyzer() {\n        @Override\n        public TokenStreamComponents createComponents(String fieldName) {\n            Tokenizer tokenizer = new NGramTokenizer(NGRAM_SIZE, NGRAM_SIZE);\n            TokenStream tok = new LowerCaseFilter(tokenizer);\n            tok = new PunctuationFoldingFilter(tok);\n            return new TokenStreamComponents(tokenizer::setReader, tok);"}
{"magic_number_smell": "    @Before\n    public void setup() {\n        WildcardFieldMapper.Builder builder = new WildcardFieldMapper.Builder(WILDCARD_FIELD_NAME, IndexVersion.current());\n        builder.ignoreAbove(30);\n        wildcardFieldMapper = builder.build(MapperBuilderContext.root(false, false));\n\n        wildcardFieldType = wildcardFieldMapper.fieldType();", "refactored_code": "    private static final int MAX_FIELD_LENGTH = 30;\n    @Before\n    public void setup() {\n        WildcardFieldMapper.Builder builder = new WildcardFieldMapper.Builder(WILDCARD_FIELD_NAME, IndexVersion.current());\n        builder.ignoreAbove(MAX_FIELD_LENGTH);\n        wildcardFieldMapper = builder.build(MapperBuilderContext.root(false, false));\n\n        wildcardFieldType = wildcardFieldMapper.fieldType();"}
{"magic_number_smell": "            Map<?, ?> indices = ObjectPath.eval(\"metadata.indices\", getClusterStateResponse);\n            var dotWatchesIndex = indices.get(\".watches\"); // ObjectPath.eval(...) doesn't handle keys containing .\n            var indexFormat = Integer.parseInt(ObjectPath.eval(\"settings.index.format\", dotWatchesIndex));\n            assertEquals(\"The watches index needs to be upgraded\", 6, indexFormat);\n\n            // Wait for watcher to actually start....\n            startWatcher();", "refactored_code": "    public static final int UPGRADE_FIELD_EXPECTED_INDEX_FORMAT_VERSION = 6;\n            Map<?, ?> indices = ObjectPath.eval(\"metadata.indices\", getClusterStateResponse);\n            var dotWatchesIndex = indices.get(\".watches\"); // ObjectPath.eval(...) doesn't handle keys containing .\n            var indexFormat = Integer.parseInt(ObjectPath.eval(\"settings.index.format\", dotWatchesIndex));\n            assertEquals(\"The watches index needs to be upgraded\", UPGRADE_FIELD_EXPECTED_INDEX_FORMAT_VERSION, indexFormat);\n\n            // Wait for watcher to actually start....\n            startWatcher();"}
{"magic_number_smell": "    @ClassRule\n    public static ElasticsearchCluster cluster = ElasticsearchCluster.local()\n        .distribution(DistributionType.DEFAULT)\n        .nodes(2)\n        .keystorePassword(KEYSTORE_PASSWORD)\n        .name(\"javaRestTest\")\n        .keystore(nodeSpec -> Map.of(\"xpack.security.transport.ssl.secure_key_passphrase\", \"transport-password\"))", "refactored_code": "    private static final int NUM_NODES = 2;\n    @ClassRule\n    public static ElasticsearchCluster cluster = ElasticsearchCluster.local()\n        .distribution(DistributionType.DEFAULT)\n        .nodes(NUM_NODES)\n        .keystorePassword(KEYSTORE_PASSWORD)\n        .name(\"javaRestTest\")\n        .keystore(nodeSpec -> Map.of(\"xpack.security.transport.ssl.secure_key_passphrase\", \"transport-password\"))"}
{"magic_number_smell": "        );\n        withNetworkAliases(\"oidc-provider\");\n        withNetwork(network);\n        addExposedPort(8080);\n    }\n\n    @Override", "refactored_code": "    private static final int PORT = 8080;\n        );\n        withNetworkAliases(\"oidc-provider\");\n        withNetwork(network);\n        addExposedPort(PORT);\n    }\n\n    @Override"}
{"magic_number_smell": "        );\n        // addExposedPort(389);\n        // addExposedPort(3268);\n        addExposedPort(636);\n        addExposedPort(AD_LDAP_GC_PORT);\n    }\n", "refactored_code": "    public static final int AD_LDAP_PORT = 636;\n        );\n        // addExposedPort(389);\n        // addExposedPort(3268);\n        addExposedPort(AD_LDAP_PORT);\n        addExposedPort(AD_LDAP_GC_PORT);\n    }\n"}
{"magic_number_smell": "\t}\n\n    public ANTLRInputStream(Reader r) throws IOException {\n        this(r, INITIAL_BUFFER_SIZE, 1024);\n    }\n\n    public ANTLRInputStream(Reader r, int initialSize) throws IOException {", "refactored_code": "    public static final int READ_BUFFER_SIZE = 1024;\n\t}\n\n    public ANTLRInputStream(Reader r) throws IOException {\n        this(r, INITIAL_BUFFER_SIZE, READ_BUFFER_SIZE);\n    }\n\n    public ANTLRInputStream(Reader r, int initialSize) throws IOException {"}
{"magic_number_smell": "\t\t\treturn fromChannel(\n\t\t\t\tchannel,\n\t\t\t\tcharset,\n\t\t\t\t4096,\n\t\t\t\tCodingErrorAction.REPLACE,\n\t\t\t\tpath.toString(),\n\t\t\t\tsize);", "refactored_code": "\tprivate static final int DEFAULT_BUFFER_SIZE = 4096;\n\t\t\treturn fromChannel(\n\t\t\t\tchannel,\n\t\t\t\tcharset,\n\t\t\t\tDEFAULT_BUFFER_SIZE,\n\t\t\t\tCodingErrorAction.REPLACE,\n\t\t\t\tpath.toString(),\n\t\t\t\tsize);"}
{"magic_number_smell": "\t * between \"on-channel\" and \"off-channel\" tokens).\n\t *\n\t * @throws IllegalStateException if an attempt is made to consume the\n\t * end of the stream (i.e. if {@code LA(1)==}{@link #-1 -1} before calling\n\t * {@code consume}).\n\t */\n\tvoid consume();", "refactored_code": "\tpublic static final int EOF = -1;\n\t * between \"on-channel\" and \"off-channel\" tokens).\n\t *\n\t * @throws IllegalStateException if an attempt is made to consume the\n\t * end of the stream (i.e. if {@code LA(1)==}{@link #EOF EOF} before calling\n\t * {@code consume}).\n\t */\n\tvoid consume();"}
{"magic_number_smell": "\tpublic int _type;\n\n\tpublic final IntegerStack _modeStack = new IntegerStack();\n\tpublic int _mode = Lexer.0;\n\n\t/** You can set the text for the current token to override what is in\n\t *  the input char buffer.  Use setText() or can set this instance var.", "refactored_code": "\tpublic static final int DEFAULT_MODE = 0;\n\tpublic int _type;\n\n\tpublic final IntegerStack _modeStack = new IntegerStack();\n\tpublic int _mode = Lexer.DEFAULT_MODE;\n\n\t/** You can set the text for the current token to override what is in\n\t *  the input char buffer.  Use setText() or can set this instance var."}
{"magic_number_smell": "\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tresult.put(\"-1\", Token.-1);\n\t\t\t\tresult = Collections.unmodifiableMap(result);\n\t\t\t\ttokenTypeMapCache.put(vocabulary, result);\n\t\t\t}", "refactored_code": "\tpublic static final int EOF=-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tresult.put(\"EOF\", Token.EOF);\n\t\t\t\tresult = Collections.unmodifiableMap(result);\n\t\t\t\ttokenTypeMapCache.put(vocabulary, result);\n\t\t\t}"}
{"magic_number_smell": "\t\tthis.tokens = tokens;\n\t\tprograms = new HashMap<String, List<RewriteOperation>>();\n\t\tprograms.put(DEFAULT_PROGRAM_NAME,\n\t\t\t\t\t new ArrayList<RewriteOperation>(100));\n\t\tlastRewriteTokenIndexes = new HashMap<String, Integer>();\n\t}\n", "refactored_code": "\tpublic static final int PROGRAM_INIT_SIZE = 100;\n\t\tthis.tokens = tokens;\n\t\tprograms = new HashMap<String, List<RewriteOperation>>();\n\t\tprograms.put(DEFAULT_PROGRAM_NAME,\n\t\t\t\t\t new ArrayList<RewriteOperation>(PROGRAM_INIT_SIZE));\n\t\tlastRewriteTokenIndexes = new HashMap<String, Integer>();\n\t}\n"}
{"magic_number_smell": "\t * {@link #isPrecedenceFilterSuppressed} method.\n\t */\n\tpublic final int getOuterContextDepth() {\n\t\treturn reachesIntoOuterContext & ~0x40000000;\n\t}\n\n\tpublic final boolean isPrecedenceFilterSuppressed() {", "refactored_code": "\tprivate static final int SUPPRESS_PRECEDENCE_FILTER = 0x40000000;\n\t * {@link #isPrecedenceFilterSuppressed} method.\n\t */\n\tpublic final int getOuterContextDepth() {\n\t\treturn reachesIntoOuterContext & ~SUPPRESS_PRECEDENCE_FILTER;\n\t}\n\n\tpublic final boolean isPrecedenceFilterSuppressed() {"}
{"magic_number_smell": "\n\t/** Track the transitions emanating from this ATN state. */\n\tprotected final List<Transition> transitions =\n\t\tnew ArrayList<Transition>(4);\n\n\t/** Used to cache lookahead during parsing, not used during construction */\n    public IntervalSet nextTokenWithinRule;", "refactored_code": "\tpublic static final int INITIAL_NUM_TRANSITIONS = 4;\n\n\t/** Track the transitions emanating from this ATN state. */\n\tprotected final List<Transition> transitions =\n\t\tnew ArrayList<Transition>(INITIAL_NUM_TRANSITIONS);\n\n\t/** Used to cache lookahead during parsing, not used during construction */\n    public IntervalSet nextTokenWithinRule;"}
{"magic_number_smell": "\t */\n\n\tprotected DFAState getExistingTargetState(DFAState s, int t) {\n\t\tif (s.edges == null || t < 0 || t > MAX_DFA_EDGE) {\n\t\t\treturn null;\n\t\t}\n", "refactored_code": "\tpublic static final int MIN_DFA_EDGE = 0;\n\t */\n\n\tprotected DFAState getExistingTargetState(DFAState s, int t) {\n\t\tif (s.edges == null || t < MIN_DFA_EDGE || t > MAX_DFA_EDGE) {\n\t\t\treturn null;\n\t\t}\n"}
{"magic_number_smell": "\t\t\t\t  look[alt], lookBusy, new BitSet(), seeThruPreds, false);\n\t\t\t// Wipe out lookahead for this alternative if we found nothing\n\t\t\t// or we had a predicate when we !seeThruPreds\n\t\t\tif ( look[alt].size()==0 || look[alt].contains(Token.INVALID_TYPE) ) {\n\t\t\t\tlook[alt] = null;\n\t\t\t}\n\t\t}", "refactored_code": "\tpublic static final int HIT_PRED = Token.INVALID_TYPE;\n\t\t\t\t  look[alt], lookBusy, new BitSet(), seeThruPreds, false);\n\t\t\t// Wipe out lookahead for this alternative if we found nothing\n\t\t\t// or we had a predicate when we !seeThruPreds\n\t\t\tif ( look[alt].size()==0 || look[alt].contains(HIT_PRED) ) {\n\t\t\t\tlook[alt] = null;\n\t\t\t}\n\t\t}"}
{"magic_number_smell": "\t}\n\n\tpublic boolean hasEmptyPath() {\n\t\t// since Integer.MAX_VALUE can only appear in the last position, we check last one\n\t\treturn getReturnState(size() - 1) == Integer.MAX_VALUE;\n\t}\n", "refactored_code": "\tpublic static final int EMPTY_RETURN_STATE = Integer.MAX_VALUE;\n\t}\n\n\tpublic boolean hasEmptyPath() {\n\t\t// since EMPTY_RETURN_STATE can only appear in the last position, we check last one\n\t\treturn getReturnState(size() - 1) == EMPTY_RETURN_STATE;\n\t}\n"}
{"magic_number_smell": "\tpublic static final List<String> serializationNames =\n\t\tCollections.unmodifiableList(Arrays.asList(\n\t\t\t\"INVALID\",\n\t\t\t\"1\",\n\t\t\t\"RANGE\",\n\t\t\t\"RULE\",\n\t\t\t\"PREDICATE\",", "refactored_code": "\tpublic static final int EPSILON\t\t\t= 1;\n\tpublic static final List<String> serializationNames =\n\t\tCollections.unmodifiableList(Arrays.asList(\n\t\t\t\"INVALID\",\n\t\t\t\"EPSILON\",\n\t\t\t\"RANGE\",\n\t\t\t\"RULE\",\n\t\t\t\"PREDICATE\","}
{"magic_number_smell": "\tprotected final int initialBucketCapacity;\n\n\tpublic Array2DHashSet() {\n\t\tthis(null, 16, INITAL_BUCKET_CAPACITY);\n\t}\n\n\tpublic Array2DHashSet(AbstractEqualityComparator<? super T> comparator) {", "refactored_code": "\tpublic static final int INITAL_CAPACITY = 16; // must be power of 2\n\tprotected final int initialBucketCapacity;\n\n\tpublic Array2DHashSet() {\n\t\tthis(null, INITAL_CAPACITY, INITAL_BUCKET_CAPACITY);\n\t}\n\n\tpublic Array2DHashSet(AbstractEqualityComparator<? super T> comparator) {"}
{"magic_number_smell": "\tprotected final int initialBucketCapacity;\n\n\tpublic FlexibleHashMap() {\n\t\tthis(null, 16, INITAL_BUCKET_CAPACITY);\n\t}\n\n\tpublic FlexibleHashMap(AbstractEqualityComparator<? super K> comparator) {", "refactored_code": "\tpublic static final int INITAL_CAPACITY = 16; // must be power of 2\n\tprotected final int initialBucketCapacity;\n\n\tpublic FlexibleHashMap() {\n\t\tthis(null, INITAL_CAPACITY, INITAL_BUCKET_CAPACITY);\n\t}\n\n\tpublic FlexibleHashMap(AbstractEqualityComparator<? super K> comparator) {"}
{"magic_number_smell": "\n\t\tint newLength;\n\t\tif (_data.length == 0) {\n\t\t\tnewLength = 4;\n\t\t}\n\t\telse {\n\t\t\tnewLength = _data.length;", "refactored_code": "\tprivate static final int INITIAL_SIZE = 4;\n\n\t\tint newLength;\n\t\tif (_data.length == 0) {\n\t\t\tnewLength = INITIAL_SIZE;\n\t\t}\n\t\telse {\n\t\t\tnewLength = _data.length;"}
{"magic_number_smell": "\n\tpublic static final Interval INVALID = new Interval(-1,-2);\n\n\tstatic final Interval[] cache = new Interval[1000+1];\n\n\tpublic int a;\n\tpublic int b;", "refactored_code": "\tpublic static final int INTERVAL_POOL_MAX_VALUE = 1000;\n\n\tpublic static final Interval INVALID = new Interval(-1,-2);\n\n\tstatic final Interval[] cache = new Interval[INTERVAL_POOL_MAX_VALUE+1];\n\n\tpublic int a;\n\tpublic int b;"}
{"magic_number_smell": "\t * @return the intermediate hash value\n\t */\n\tpublic static int initialize() {\n\t\treturn initialize(0);\n\t}\n\n\t/**", "refactored_code": "\tprivate static final int DEFAULT_SEED = 0;\n\t * @return the intermediate hash value\n\t */\n\tpublic static int initialize() {\n\t\treturn initialize(DEFAULT_SEED);\n\t}\n\n\t/**"}
{"magic_number_smell": "\t * }\n\t *\n\t * X : 'foo' -&gt; channel(HIDDEN);           // ok\n\t * Y : 'bar' -&gt; channel(HIDDEN + 1);           // warning 155\n\t * </pre>\n\t *\n\t * @since 4.2", "refactored_code": "\t * public static final int CUSTOM = HIDDEN + 1;\n\t * }\n\t *\n\t * X : 'foo' -&gt; channel(HIDDEN);           // ok\n\t * Y : 'bar' -&gt; channel(CUSTOM);           // warning 155\n\t * </pre>\n\t *\n\t * @since 4.2"}
{"magic_number_smell": "\t\t\t\"grammar M;\\n\"+\n\t\t\t\"import S,T;\\n\"+\n\t\t\t\"s : x y ; // matches AA, which should be 'aa'\\n\"+\n\t\t\t\"B : 'b' ; // another order: B, A, 6\\n\"+\n\t\t\t\"A : 'a' ;\\n\"+\n\t\t\t\"6 : 'c' ;\\n\"+\n\t\t\t\"WS : (' '|'\\\\n') -> skip ;\\n\";", "refactored_code": "\t\t\t\"// public static final int C=6;\\n\"+\n\t\t\t\"grammar M;\\n\"+\n\t\t\t\"import S,T;\\n\"+\n\t\t\t\"s : x y ; // matches AA, which should be 'aa'\\n\"+\n\t\t\t\"B : 'b' ; // another order: B, A, C\\n\"+\n\t\t\t\"A : 'a' ;\\n\"+\n\t\t\t\"C : 'c' ;\\n\"+\n\t\t\t\"WS : (' '|'\\\\n') -> skip ;\\n\";"}
{"magic_number_smell": "\n\t\tfor (int i = 0; i < PASSES; i++) {\n\t\t\tif (COMPUTE_TRANSITION_STATS) {\n\t\t\t\ttotalTransitionsPerFile[i] = new long[Math.min(sources.size(), Integer.MAX_VALUE)];\n\t\t\t\tcomputedTransitionsPerFile[i] = new long[Math.min(sources.size(), Integer.MAX_VALUE)];\n\n\t\t\t\tif (DETAILED_DFA_STATE_STATS) {", "refactored_code": "\tprivate static final int MAX_FILES_PER_PARSE_ITERATION = Integer.MAX_VALUE;\n\n\t\tfor (int i = 0; i < PASSES; i++) {\n\t\t\tif (COMPUTE_TRANSITION_STATS) {\n\t\t\t\ttotalTransitionsPerFile[i] = new long[Math.min(sources.size(), MAX_FILES_PER_PARSE_ITERATION)];\n\t\t\t\tcomputedTransitionsPerFile[i] = new long[Math.min(sources.size(), MAX_FILES_PER_PARSE_ITERATION)];\n\n\t\t\t\tif (DETAILED_DFA_STATE_STATS) {"}
{"magic_number_smell": "  private static class DeflateClient extends WebSocketClient {\n\n    public DeflateClient() throws URISyntaxException {\n      super(new URI(\"ws://localhost:\" + 8887), perMessageDeflateDraft);\n    }\n\n    @Override", "refactored_code": "  private static final int PORT = 8887;\n  private static class DeflateClient extends WebSocketClient {\n\n    public DeflateClient() throws URISyntaxException {\n      super(new URI(\"ws://localhost:\" + PORT), perMessageDeflateDraft);\n    }\n\n    @Override"}
{"magic_number_smell": "  public CloseFrame() {\n    super(Opcode.CLOSING);\n    setReason(\"\");\n    setCode(CloseFrame.1000);\n  }\n\n  /**", "refactored_code": "  public static final int NORMAL = 1000;\n  public CloseFrame() {\n    super(Opcode.CLOSING);\n    setReason(\"\");\n    setCode(CloseFrame.NORMAL);\n  }\n\n  /**"}
{"magic_number_smell": "   * @see #WebSocketServer(InetSocketAddress, int, List, Collection) more details here\n   */\n  public WebSocketServer() {\n    this(new InetSocketAddress(WebSocketImpl.DEFAULT_PORT), Runtime.getRuntime().availableProcessors(), null);\n  }\n\n  /**", "refactored_code": "  private static final int AVAILABLE_PROCESSORS = Runtime.getRuntime().availableProcessors();\n   * @see #WebSocketServer(InetSocketAddress, int, List, Collection) more details here\n   */\n  public WebSocketServer() {\n    this(new InetSocketAddress(WebSocketImpl.DEFAULT_PORT), AVAILABLE_PROCESSORS, null);\n  }\n\n  /**"}
{"magic_number_smell": "    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n      encoded = encodeBytes(source, 0, source.length, 0);\n    } catch (java.io.IOException ex) {\n      assert false : ex.getMessage();\n    }   // end catch", "refactored_code": "  public static final int NO_OPTIONS = 0;\n    // we should not force the user to have to catch it.\n    String encoded = null;\n    try {\n      encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);\n    } catch (java.io.IOException ex) {\n      assert false : ex.getMessage();\n    }   // end catch"}
{"magic_number_smell": "\n  @Parameterized.Parameters\n  public static Collection<Integer[]> data() {\n    List<Integer[]> ret = new ArrayList<Integer[]>(10);\n    for (int i = 0; i < 10; i++) {\n      ret.add(new Integer[]{i});\n    }", "refactored_code": "  private static final int NUMBER_OF_TESTS = 10;\n\n  @Parameterized.Parameters\n  public static Collection<Integer[]> data() {\n    List<Integer[]> ret = new ArrayList<Integer[]>(NUMBER_OF_TESTS);\n    for (int i = 0; i < NUMBER_OF_TESTS; i++) {\n      ret.add(new Integer[]{i});\n    }"}
{"magic_number_smell": "\n  @Parameterized.Parameters\n  public static Collection<Integer[]> data() {\n    List<Integer[]> ret = new ArrayList<Integer[]>(10);\n    for (int i = 0; i < 10; i++) {\n      ret.add(new Integer[]{i});\n    }", "refactored_code": "  private static final int NUMBER_OF_TESTS = 10;\n\n  @Parameterized.Parameters\n  public static Collection<Integer[]> data() {\n    List<Integer[]> ret = new ArrayList<Integer[]>(NUMBER_OF_TESTS);\n    for (int i = 0; i < NUMBER_OF_TESTS; i++) {\n      ret.add(new Integer[]{i});\n    }"}
{"magic_number_smell": "\n  @Parameterized.Parameters\n  public static Collection<Integer[]> data() {\n    List<Integer[]> ret = new ArrayList<Integer[]>(20);\n    for (int i = 1; i <= 20 + 1; i++) {\n      ret.add(new Integer[]{(int) Math.round(Math.pow(2, i))});\n    }", "refactored_code": "  private static final int NUMBER_OF_TESTS = 20;\n\n  @Parameterized.Parameters\n  public static Collection<Integer[]> data() {\n    List<Integer[]> ret = new ArrayList<Integer[]>(NUMBER_OF_TESTS);\n    for (int i = 1; i <= NUMBER_OF_TESTS + 1; i++) {\n      ret.add(new Integer[]{(int) Math.round(Math.pow(2, i))});\n    }"}
{"magic_number_smell": "\n  @Parameterized.Parameters\n  public static Collection<Integer[]> data() {\n    List<Integer[]> ret = new ArrayList<Integer[]>(20);\n    for (int i = 0; i < 20; i++) {\n      ret.add(new Integer[]{25 + i * 25});\n    }", "refactored_code": "  private static final int NUMBER_OF_TESTS = 20;\n\n  @Parameterized.Parameters\n  public static Collection<Integer[]> data() {\n    List<Integer[]> ret = new ArrayList<Integer[]>(NUMBER_OF_TESTS);\n    for (int i = 0; i < NUMBER_OF_TESTS; i++) {\n      ret.add(new Integer[]{25 + i * 25});\n    }"}
{"magic_number_smell": "    }\n\n    /**\n     * Create an instance of the {@link FibonacciPollInterval} with the supplied time unit starting with offset equal to {@value #0}.\n     *\n     * @param unit The time unit\n     * @see FibonacciPollInterval#FibonacciPollInterval(int, TimeUnit)", "refactored_code": "    private static final int DEFAULT_OFFSET = 0;\n    }\n\n    /**\n     * Create an instance of the {@link FibonacciPollInterval} with the supplied time unit starting with offset equal to {@value #DEFAULT_OFFSET}.\n     *\n     * @param unit The time unit\n     * @see FibonacciPollInterval#FibonacciPollInterval(int, TimeUnit)"}
{"magic_number_smell": "        private final long delayBetweenRetry;\n\n        public DelayedRetry() {\n            this(DEFAULT_TRIES, 20);\n        }\n\n        public DelayedRetry(final int tries, final long delayBetweenRetry) {", "refactored_code": "        public static final long DEFAULT_DELAY_MS = 20;\n        private final long delayBetweenRetry;\n\n        public DelayedRetry() {\n            this(DEFAULT_TRIES, DEFAULT_DELAY_MS);\n        }\n\n        public DelayedRetry(final int tries, final long delayBetweenRetry) {"}
{"magic_number_smell": "     * @throws IOException\n     */\n    public void inputGraph(InputStream inputStream) throws IOException {\n        GMLReader.inputGraph(this.graph, inputStream, 1000, this.defaultEdgeLabel,\n                this.vertexIdKey, this.edgeIdKey, this.edgeLabelKey);\n    }\n", "refactored_code": "    private static final int DEFAULT_BUFFER_SIZE = 1000;\n     * @throws IOException\n     */\n    public void inputGraph(InputStream inputStream) throws IOException {\n        GMLReader.inputGraph(this.graph, inputStream, DEFAULT_BUFFER_SIZE, this.defaultEdgeLabel,\n                this.vertexIdKey, this.edgeIdKey, this.edgeLabelKey);\n    }\n"}
{"magic_number_smell": "\n    private final VertexCache cache;\n\n    private long bufferSize = 100000;\n    private long remainingBufferSize;\n\n    private BatchEdge currentEdge = null;", "refactored_code": "    public static final long DEFAULT_BUFFER_SIZE = 100000;\n\n    private final VertexCache cache;\n\n    private long bufferSize = DEFAULT_BUFFER_SIZE;\n    private long remainingBufferSize;\n\n    private BatchEdge currentEdge = null;"}
{"magic_number_smell": "    public StringIDVertexCache(final StringCompression compression) {\n        if (compression == null) throw new IllegalArgumentException(\"Compression expected.\");\n        this.compression = compression;\n        map = new HashMap<String, Object>(1000);\n        mapKeysInCurrentTx = new HashSet<String>(INITIAL_TX_CAPACITY);\n    }\n", "refactored_code": "    private static final int INITIAL_CAPACITY = 1000;\n    public StringIDVertexCache(final StringCompression compression) {\n        if (compression == null) throw new IllegalArgumentException(\"Compression expected.\");\n        this.compression = compression;\n        map = new HashMap<String, Object>(INITIAL_CAPACITY);\n        mapKeysInCurrentTx = new HashSet<String>(INITIAL_TX_CAPACITY);\n    }\n"}
{"magic_number_smell": "        GraphMLReader.inputGraph(graph, GraphMLReader.class.getResourceAsStream(\"graph-example-2.xml\"));\n        graph.shutdown();\n\n        for (int i = 0; i < 10; i++) {\n            graph = graphTest.generateGraph();\n            GraphDatabaseService neo4j = ((Neo4jGraph) graph).getRawGraph();\n            int counter = 0;", "refactored_code": "    private static final int TOTAL_RUNS = 10;\n        GraphMLReader.inputGraph(graph, GraphMLReader.class.getResourceAsStream(\"graph-example-2.xml\"));\n        graph.shutdown();\n\n        for (int i = 0; i < TOTAL_RUNS; i++) {\n            graph = graphTest.generateGraph();\n            GraphDatabaseService neo4j = ((Neo4jGraph) graph).getRawGraph();\n            int counter = 0;"}
{"magic_number_smell": "        GraphMLReader.inputGraph(graph, GraphMLReader.class.getResourceAsStream(\"graph-example-2.xml\"));\n        graph.shutdown();\n\n        for (int i = 0; i < 10; i++) {\n            graph = graphTest.generateGraph();\n            GraphDatabaseService neo4j = ((Neo4j2Graph) graph).getRawGraph();\n            int counter = 0;", "refactored_code": "    private static final int TOTAL_RUNS = 10;\n        GraphMLReader.inputGraph(graph, GraphMLReader.class.getResourceAsStream(\"graph-example-2.xml\"));\n        graph.shutdown();\n\n        for (int i = 0; i < TOTAL_RUNS; i++) {\n            graph = graphTest.generateGraph();\n            GraphDatabaseService neo4j = ((Neo4j2Graph) graph).getRawGraph();\n            int counter = 0;"}
{"magic_number_smell": "     * Construct a RexsterGraph with no authentication and default buffer size.\n     */\n    public RexsterGraph(final String graphURI) {\n        this(graphURI, 100);\n    }\n\n    /**", "refactored_code": "    public static final int DEFAULT_BUFFER_SIZE = 100;\n     * Construct a RexsterGraph with no authentication and default buffer size.\n     */\n    public RexsterGraph(final String graphURI) {\n        this(graphURI, DEFAULT_BUFFER_SIZE);\n    }\n\n    /**"}
{"magic_number_smell": "        if (!graph.typeScope.get())\n        {\n            if (graph.getRawGraph().getType(getObjectType()).getObjectType() == com.sparsity.sparksee.gdb.ObjectType.Node) {\n                attrType = com.sparsity.sparksee.gdb.Type.NodesType;\n            } else {\n                attrType = EDGE_SCOPE;\n            }", "refactored_code": "    private static final int NODE_SCOPE  = com.sparsity.sparksee.gdb.Type.NodesType;\n        if (!graph.typeScope.get())\n        {\n            if (graph.getRawGraph().getType(getObjectType()).getObjectType() == com.sparsity.sparksee.gdb.ObjectType.Node) {\n                attrType = NODE_SCOPE;\n            } else {\n                attrType = EDGE_SCOPE;\n            }"}
{"magic_number_smell": "            com.sparsity.sparksee.gdb.TypeList tlist = rawGraph.findNodeTypes();\n            List<Iterable<Vertex>> vertices = new ArrayList<Iterable<Vertex>>();\n            for (Integer type : tlist) {\n                int attrType = typeScope.get() ? type : com.sparsity.sparksee.gdb.Type.NodesType;\n                int attr = rawGraph.findAttribute(attrType, key);\n                if (com.sparsity.sparksee.gdb.Attribute.InvalidAttribute != attr) {\n                    com.sparsity.sparksee.gdb.Attribute adata = rawGraph.getAttribute(attr);", "refactored_code": "    private static final int NODE_SCOPE  = com.sparsity.sparksee.gdb.Type.NodesType;\n            com.sparsity.sparksee.gdb.TypeList tlist = rawGraph.findNodeTypes();\n            List<Iterable<Vertex>> vertices = new ArrayList<Iterable<Vertex>>();\n            for (Integer type : tlist) {\n                int attrType = typeScope.get() ? type : NODE_SCOPE;\n                int attr = rawGraph.findAttribute(attrType, key);\n                if (com.sparsity.sparksee.gdb.Attribute.InvalidAttribute != attr) {\n                    com.sparsity.sparksee.gdb.Attribute adata = rawGraph.getAttribute(attr);"}
{"magic_number_smell": "        GraphMLReader.inputGraph(graph, GraphMLReader.class.getResourceAsStream(\"graph-example-2.xml\"));\n        graph.shutdown();\n\n        for (int i = 0; i < 10; i++) {\n            graph = graphTest.generateGraph();\n            this.stopWatch();\n            int counter = 0;", "refactored_code": "    private static final int TOTAL_RUNS = 10;\n        GraphMLReader.inputGraph(graph, GraphMLReader.class.getResourceAsStream(\"graph-example-2.xml\"));\n        graph.shutdown();\n\n        for (int i = 0; i < TOTAL_RUNS; i++) {\n            graph = graphTest.generateGraph();\n            this.stopWatch();\n            int counter = 0;"}
{"magic_number_smell": "        Graph graph = graphTest.generateGraph();\n        GraphMLReader.inputGraph(graph, GraphMLReader.class.getResourceAsStream(\"graph-example-2.xml\"));\n\n        for (int i = 0; i < 10; i++) {\n            this.stopWatch();\n            int counter = 0;\n            for (final Vertex vertex : graph.getVertices()) {", "refactored_code": "    private static final int TOTAL_RUNS = 10;\n        Graph graph = graphTest.generateGraph();\n        GraphMLReader.inputGraph(graph, GraphMLReader.class.getResourceAsStream(\"graph-example-2.xml\"));\n\n        for (int i = 0; i < TOTAL_RUNS; i++) {\n            this.stopWatch();\n            int counter = 0;\n            for (final Vertex vertex : graph.getVertices()) {"}
{"magic_number_smell": "\n        private void verifyCounts() {\n            //System.out.println(\"Committed (vertices/edges): \" + counter.numVertices + \" / \" + counter.numEdges);\n            assertEquals(counter.numVertices, BaseTest.count(graph.getVertices()) - (first ? 0 : 10));\n            assertEquals(counter.numEdges, BaseTest.count(graph.getEdges()));\n            for (Edge e : getEdges()) {\n                int id = ((Number) e.getProperty(UID)).intValue();", "refactored_code": "        private static final int keepLast = 10;\n\n        private void verifyCounts() {\n            //System.out.println(\"Committed (vertices/edges): \" + counter.numVertices + \" / \" + counter.numEdges);\n            assertEquals(counter.numVertices, BaseTest.count(graph.getVertices()) - (first ? 0 : keepLast));\n            assertEquals(counter.numEdges, BaseTest.count(graph.getEdges()));\n            for (Edge e : getEdges()) {\n                int id = ((Number) e.getProperty(UID)).intValue();"}
{"magic_number_smell": "\t\tif (log_rounds < 4 || log_rounds > 31)\n\t\t\tthrow new IllegalArgumentException (\"Bad number of rounds\");\n\t\trounds = 1 << log_rounds;\n\t\tif (salt.length != 16)\n\t\t\tthrow new IllegalArgumentException (\"Bad salt length\");\n\n\t\tinit_key();", "refactored_code": "\tprivate static final int BCRYPT_SALT_LEN = 16;\n\t\tif (log_rounds < 4 || log_rounds > 31)\n\t\t\tthrow new IllegalArgumentException (\"Bad number of rounds\");\n\t\trounds = 1 << log_rounds;\n\t\tif (salt.length != BCRYPT_SALT_LEN)\n\t\t\tthrow new IllegalArgumentException (\"Bad salt length\");\n\n\t\tinit_key();"}
{"magic_number_smell": "        *                   BOM marker. Give NULL to use system-level default.\n        */\n       UnicodeReader(InputStream in, String defaultEnc) {\n          internalIn = new PushbackInputStream(in, 4);\n          this.defaultEnc = defaultEnc;\n       }\n", "refactored_code": "       private static final int BOM_SIZE = 4;\n        *                   BOM marker. Give NULL to use system-level default.\n        */\n       UnicodeReader(InputStream in, String defaultEnc) {\n          internalIn = new PushbackInputStream(in, BOM_SIZE);\n          this.defaultEnc = defaultEnc;\n       }\n"}
{"magic_number_smell": "\n        private int precision = UNSET;\n\n        private StringBuilder strFlags = new StringBuilder(6);\n\n        private char dateSuffix;// will be used in new feature.\n", "refactored_code": "        private static final int FLAGT_TYPE_COUNT = 6;\n\n        private int precision = UNSET;\n\n        private StringBuilder strFlags = new StringBuilder(FLAGT_TYPE_COUNT);\n\n        private char dateSuffix;// will be used in new feature.\n"}
{"magic_number_smell": "        if (caseGap < 0) throw new IllegalArgumentException();\n\n        StringBuffer result = new StringBuffer();\n        boolean justFunctionBody = (0 != (flags & Decompiler.1 << 0));\n        boolean toSource = (0 != (flags & Decompiler.TO_SOURCE_FLAG));\n\n        // Spew tokens in source, for debugging.", "refactored_code": "    public static final int ONLY_BODY_FLAG = 1 << 0;\n        if (caseGap < 0) throw new IllegalArgumentException();\n\n        StringBuffer result = new StringBuffer();\n        boolean justFunctionBody = (0 != (flags & Decompiler.ONLY_BODY_FLAG));\n        boolean toSource = (0 != (flags & Decompiler.TO_SOURCE_FLAG));\n\n        // Spew tokens in source, for debugging."}
{"magic_number_smell": "            double df;           /* The fractional part of d */\n            BigInteger b;\n\n            buffer = new char[1078];\n            p = 0;\n            df = d - dfloor;\n", "refactored_code": "    private static final int DTOBASESTR_BUFFER_SIZE = 1078;\n            double df;           /* The fractional part of d */\n            BigInteger b;\n\n            buffer = new char[DTOBASESTR_BUFFER_SIZE];\n            p = 0;\n            df = d - dfloor;\n"}
{"magic_number_smell": "            }\n            int index = (id - 1) * SLOT_SPAN;\n            synchronized (this) {\n                Object value2 = array[index + 0];\n                if (value2 == null) {\n                    array[index + 0] = value;\n                    array[index + NAME_SLOT] = name;", "refactored_code": "        private static final int VALUE_SLOT = 0;\n            }\n            int index = (id - 1) * SLOT_SPAN;\n            synchronized (this) {\n                Object value2 = array[index + VALUE_SLOT];\n                if (value2 == null) {\n                    array[index + VALUE_SLOT] = value;\n                    array[index + NAME_SLOT] = name;"}
{"magic_number_smell": "        label = itsLabelTableTop;\n        if (itsLabelTable == null || label == itsLabelTable.length) {\n            if (itsLabelTable == null) {\n                itsLabelTable = new int[32];\n            }else {\n                int[] tmp = new int[itsLabelTable.length * 2];\n                System.arraycopy(itsLabelTable, 0, tmp, 0, label);", "refactored_code": "    private static final int MIN_LABEL_TABLE_SIZE = 32;\n        label = itsLabelTableTop;\n        if (itsLabelTable == null || label == itsLabelTable.length) {\n            if (itsLabelTable == null) {\n                itsLabelTable = new int[MIN_LABEL_TABLE_SIZE];\n            }else {\n                int[] tmp = new int[itsLabelTable.length * 2];\n                System.arraycopy(itsLabelTable, 0, tmp, 0, label);"}
{"magic_number_smell": "        if (d != d ||\n            d == Double.POSITIVE_INFINITY ||\n            d == Double.NEGATIVE_INFINITY ||\n            Math.abs(d) > 8.64e15)\n        {\n            return ScriptRuntime.NaN;\n        }", "refactored_code": "    private static final double HalfTimeDomain = 8.64e15;\n        if (d != d ||\n            d == Double.POSITIVE_INFINITY ||\n            d == Double.NEGATIVE_INFINITY ||\n            Math.abs(d) > HalfTimeDomain)\n        {\n            return ScriptRuntime.NaN;\n        }"}
{"magic_number_smell": "\n    /**\n     * Determine which of two signatures is the closer fit.\n     * Returns one of 0, PREFERENCE_FIRST_ARG,\n     * PREFERENCE_SECOND_ARG, or PREFERENCE_AMBIGUOUS.\n     */\n    private static int preferSignature(Object[] args, ", "refactored_code": "    private static final int PREFERENCE_EQUAL      = 0;\n\n    /**\n     * Determine which of two signatures is the closer fit.\n     * Returns one of PREFERENCE_EQUAL, PREFERENCE_FIRST_ARG,\n     * PREFERENCE_SECOND_ARG, or PREFERENCE_AMBIGUOUS.\n     */\n    private static int preferSignature(Object[] args, "}
{"magic_number_smell": "\n        switch (fromCode) {\n\n        case 0:\n            if (to == ScriptRuntime.StringClass ||\n                to == ScriptRuntime.ObjectClass) {\n                return 1;", "refactored_code": "    private static final int JSTYPE_UNDEFINED   = 0; // undefined type\n\n        switch (fromCode) {\n\n        case JSTYPE_UNDEFINED:\n            if (to == ScriptRuntime.StringClass ||\n                to == ScriptRuntime.ObjectClass) {\n                return 1;"}
{"magic_number_smell": "            /* We allow a larger range of precision than\n               ECMA requires; this is permitted by ECMA. */\n            precision = ScriptRuntime.toInt32(args[0]);\n            if (precision < precisionMin || precision > 100) {\n                String msg = ScriptRuntime.getMessage1(\n                    \"msg.bad.precision\", ScriptRuntime.toString(args[0]));\n                throw ScriptRuntime.constructError(\"RangeError\", msg);", "refactored_code": "    private static final int MAX_PRECISION = 100;\n            /* We allow a larger range of precision than\n               ECMA requires; this is permitted by ECMA. */\n            precision = ScriptRuntime.toInt32(args[0]);\n            if (precision < precisionMin || precision > MAX_PRECISION) {\n                String msg = ScriptRuntime.getMessage1(\n                    \"msg.bad.precision\", ScriptRuntime.toString(args[0]));\n                throw ScriptRuntime.constructError(\"RangeError\", msg);"}
{"magic_number_smell": "     */\n    public void put(String name, Scriptable start, Object value)\n    {\n        if (putImpl(name, 0, start, value, 0x00))\n            return;\n\n        if (start == this) throw Kit.codeBug();", "refactored_code": "    public static final int EMPTY =     0x00;\n     */\n    public void put(String name, Scriptable start, Object value)\n    {\n        if (putImpl(name, 0, start, value, EMPTY))\n            return;\n\n        if (start == this) throw Kit.codeBug();"}
{"magic_number_smell": "\n        if (!cx.hasFeature(Context.FEATURE_PARENT_PROTO_PROPERTIES)) {\n            // Clear special after checking for valid name!\n            type = 0;\n        }\n\n        return new SpecialRef(target, type, name);", "refactored_code": "    private static final int SPECIAL_NONE = 0;\n\n        if (!cx.hasFeature(Context.FEATURE_PARENT_PROTO_PROPERTIES)) {\n            // Clear special after checking for valid name!\n            type = SPECIAL_NONE;\n        }\n\n        return new SpecialRef(target, type, name);"}
{"magic_number_smell": "     * Tag to mark non-existing values.\n     */\n    public static final UniqueTag\n        NOT_FOUND = new UniqueTag(1);\n\n    /**\n     * Tag to distinguish between uninitialized and null values.", "refactored_code": "    private static final int ID_NOT_FOUND    = 1;\n     * Tag to mark non-existing values.\n     */\n    public static final UniqueTag\n        NOT_FOUND = new UniqueTag(ID_NOT_FOUND);\n\n    /**\n     * Tag to distinguish between uninitialized and null values."}
{"magic_number_smell": "        cfw.addAStore(variableObjectLocal);\n\n        String exceptionName;\n        if (exceptionType == 0) {\n            exceptionName = \"org/mozilla/javascript/JavaScriptException\";\n        } else if (exceptionType == EVALUATOR_EXCEPTION) {\n            exceptionName = \"org/mozilla/javascript/EvaluatorException\";", "refactored_code": "    private static final int JAVASCRIPT_EXCEPTION  = 0;\n        cfw.addAStore(variableObjectLocal);\n\n        String exceptionName;\n        if (exceptionType == JAVASCRIPT_EXCEPTION) {\n            exceptionName = \"org/mozilla/javascript/JavaScriptException\";\n        } else if (exceptionType == EVALUATOR_EXCEPTION) {\n            exceptionName = \"org/mozilla/javascript/EvaluatorException\";"}
{"magic_number_smell": "            buf.append(\"(?:)\");\n        }\n        buf.append('/');\n        if ((re.flags & 0x1) != 0)\n            buf.append('g');\n        if ((re.flags & JSREG_FOLD) != 0)\n            buf.append('i');", "refactored_code": "    public static final int JSREG_GLOB = 0x1;       // 'g' flag: global\n            buf.append(\"(?:)\");\n        }\n        buf.append('/');\n        if ((re.flags & JSREG_GLOB) != 0)\n            buf.append('g');\n        if ((re.flags & JSREG_FOLD) != 0)\n            buf.append('i');"}
{"magic_number_smell": "                    returnValue = this.returnValue;\n                }\n                switch (returnValue) {\n                case 0:\n                    contextData.breakNextLine = true;\n                    contextData.stopAtFrameDepth = contextData.frameCount();\n                    break;", "refactored_code": "    public static final int STEP_OVER = 0;\n                    returnValue = this.returnValue;\n                }\n                switch (returnValue) {\n                case STEP_OVER:\n                    contextData.breakNextLine = true;\n                    contextData.stopAtFrameDepth = contextData.frameCount();\n                    break;"}
{"magic_number_smell": "         * Exit action.\n         */\n        public void run() {\n            if (type != 1) Kit.codeBug();\n            System.exit(0);\n        }\n", "refactored_code": "        public static final int EXIT_ACTION = 1;\n         * Exit action.\n         */\n        public void run() {\n            if (type != EXIT_ACTION) Kit.codeBug();\n            System.exit(0);\n        }\n"}
{"magic_number_smell": "    /**\n     * Serializable magic number.\n     */\n    private static final long -8217029773456711621L = -3918033649601064194L;\n\n    /**\n     * The debugger GUI.", "refactored_code": "    private static final long serialVersionUID = -8217029773456711621L;\n    /**\n     * Serializable magic number.\n     */\n    private static final long serialVersionUID = -3918033649601064194L;\n\n    /**\n     * The debugger GUI."}
{"magic_number_smell": "    }\n\n    public void qchar(int c) {\n        int pos = ensure_area(2 + 6);\n        buffer[pos] = '\\'';\n        pos = put_string_literal_char(pos + 1, c, false);\n        buffer[pos] = '\\'';", "refactored_code": "    private static final int LITERAL_CHAR_MAX_SIZE = 6;\n    }\n\n    public void qchar(int c) {\n        int pos = ensure_area(2 + LITERAL_CHAR_MAX_SIZE);\n        buffer[pos] = '\\'';\n        pos = put_string_literal_char(pos + 1, c, false);\n        buffer[pos] = '\\'';"}
{"magic_number_smell": "                                    securityDomain);\n        } catch (EvaluatorException ee) {\n            // Already printed message.\n            exitCode = 3;\n        } catch (RhinoException rex) {\n            ToolErrorReporter.reportException(\n                cx.getErrorReporter(), rex);", "refactored_code": "    static private final int EXITCODE_RUNTIME_ERROR = 3;\n                                    securityDomain);\n        } catch (EvaluatorException ee) {\n            // Already printed message.\n            exitCode = EXITCODE_RUNTIME_ERROR;\n        } catch (RhinoException rex) {\n            ToolErrorReporter.reportException(\n                cx.getErrorReporter(), rex);"}
{"magic_number_smell": "\n        token = consumeToken();\n        if (token.getType() == Token.NAME) {\n            if (mode == 1) {\n                // Get the name of the function and declare it in the current scope.\n                symbol = token.getValue();\n                if (currentScope.getIdentifier(symbol) != null) {", "refactored_code": "    private static final int BUILDING_SYMBOL_TREE = 1;\n\n        token = consumeToken();\n        if (token.getType() == Token.NAME) {\n            if (mode == BUILDING_SYMBOL_TREE) {\n                // Get the name of the function and declare it in the current scope.\n                symbol = token.getValue();\n                if (currentScope.getIdentifier(symbol) != null) {"}
{"magic_number_smell": "        if (caseGap < 0) throw new IllegalArgumentException();\n\n        StringBuffer result = new StringBuffer();\n        boolean justFunctionBody = (0 != (flags & Decompiler.1 << 0));\n        boolean toSource = (0 != (flags & Decompiler.TO_SOURCE_FLAG));\n\n        // Spew tokens in source, for debugging.", "refactored_code": "    public static final int ONLY_BODY_FLAG = 1 << 0;\n        if (caseGap < 0) throw new IllegalArgumentException();\n\n        StringBuffer result = new StringBuffer();\n        boolean justFunctionBody = (0 != (flags & Decompiler.ONLY_BODY_FLAG));\n        boolean toSource = (0 != (flags & Decompiler.TO_SOURCE_FLAG));\n\n        // Spew tokens in source, for debugging."}
{"magic_number_smell": "  }\n\n  void add(double i) {\n    if (intervalupdates.intValue() >= 1000)\n      return;\n    if (!latencies.offer(i)) {\n      latencies.poll();", "refactored_code": "  private static final int UPDATES_PER_INTERVAL = 1000;\n  }\n\n  void add(double i) {\n    if (intervalupdates.intValue() >= UPDATES_PER_INTERVAL)\n      return;\n    if (!latencies.offer(i)) {\n      latencies.poll();"}
{"magic_number_smell": "   * @return\n   */\n  public long getExecutionTimeMicro() {\n    return execTime / 1000;\n  }\n\n", "refactored_code": "  private static final int MICRO_DENOM = 1000;\n   * @return\n   */\n  public long getExecutionTimeMicro() {\n    return execTime / MICRO_DENOM;\n  }\n\n"}
{"magic_number_smell": "      if (versions != 1) {\n        Thread.sleep(WAIT_FOR_SCHEMA_AGREEMENT_SLEEP_TIME);\n        waited += WAIT_FOR_SCHEMA_AGREEMENT_SLEEP_TIME;\n        if (waited > 30 * 1000)\n          throw new RuntimeException(\"Could not reach schema agreement in \" + 30 * 1000 + \"ms\");\n      }\n    }", "refactored_code": "  public static final int RING_DELAY = 30 * 1000; // delay after which we assume ring has stablized\n      if (versions != 1) {\n        Thread.sleep(WAIT_FOR_SCHEMA_AGREEMENT_SLEEP_TIME);\n        waited += WAIT_FOR_SCHEMA_AGREEMENT_SLEEP_TIME;\n        if (waited > RING_DELAY)\n          throw new RuntimeException(\"Could not reach schema agreement in \" + RING_DELAY + \"ms\");\n      }\n    }"}
{"magic_number_smell": "  }\n\n  public static int parsePortFromUrl(String urlPort) {\n    return urlPort.lastIndexOf(':') > 0 ? Integer.parseInt(urlPort.substring(urlPort.lastIndexOf(':')+1, urlPort.length())) : 9160;\n  }\n\n  public boolean getLifo() {", "refactored_code": "  public static final int DEFAULT_PORT = 9160;\n  }\n\n  public static int parsePortFromUrl(String urlPort) {\n    return urlPort.lastIndexOf(':') > 0 ? Integer.parseInt(urlPort.substring(urlPort.lastIndexOf(':')+1, urlPort.length())) : DEFAULT_PORT;\n  }\n\n  public boolean getLifo() {"}
{"magic_number_smell": "\tprivate ColumnSliceFinish<N> finish;\n\tprivate SliceFilter<HColumn<N, V>> filter = null;\n\tprivate boolean reversed;\n\tprivate int count = 100;\n\tprivate int columns = 0;\n\n\t/**", "refactored_code": "\tprivate static final int DEFAULT_COUNT = 100;\n\tprivate ColumnSliceFinish<N> finish;\n\tprivate SliceFilter<HColumn<N, V>> filter = null;\n\tprivate boolean reversed;\n\tprivate int count = DEFAULT_COUNT;\n\tprivate int columns = 0;\n\n\t/**"}
{"magic_number_smell": "\t * internal variable to hold maxColumnCountPerRow which is passed. It is\n\t * defaulted to 100.\n\t */\n\tprivate int maxColumnCount = 100;\n\n\t/**\n\t * internal variable to hold thread count which is calculated through", "refactored_code": "\tprivate static final int DEFAULT_MAXCOL_COUNT = 100;\n\t * internal variable to hold maxColumnCountPerRow which is passed. It is\n\t * defaulted to 100.\n\t */\n\tprivate int maxColumnCount = DEFAULT_MAXCOL_COUNT;\n\n\t/**\n\t * internal variable to hold thread count which is calculated through"}
{"magic_number_smell": "\tprivate SliceCounterFinish<N> finish;\n\tprivate SliceFilter<HCounterColumn<N>> filter = null;\n\tprivate boolean reversed;\n\tprivate int count = 100;\n\tprivate int columns = 0;\n\n\t/**", "refactored_code": "\tprivate static final int DEFAULT_COUNT = 100;\n\tprivate SliceCounterFinish<N> finish;\n\tprivate SliceFilter<HCounterColumn<N>> filter = null;\n\tprivate boolean reversed;\n\tprivate int count = DEFAULT_COUNT;\n\tprivate int columns = 0;\n\n\t/**"}
{"magic_number_smell": "    this.columnFactory = columnFactory;\n    this.mutator = mutator;\n    this.clock = template.getClock();\n    this.globalTtl = 0; \n  }\n  \n  public AbstractTemplateUpdater<K,N> addKey(K key) {", "refactored_code": "  protected static final int DEF_TTL = 0; \n    this.columnFactory = columnFactory;\n    this.mutator = mutator;\n    this.clock = template.getClock();\n    this.globalTtl = DEF_TTL; \n  }\n  \n  public AbstractTemplateUpdater<K,N> addKey(K key) {"}
{"magic_number_smell": "    System.out.println((score2 - score1) / score2);\n    // score 2 has things around 500 and score 1 has things around 100 so it is approx 25% bad\n    assertTrue(\"Error The Badness threshold value is not taken into account!\",\n        (score2 - score1) / score2 > 0.24);\n  }\n\n}", "refactored_code": "  private static final double DYNAMIC_BADNESS_THRESHOLD = 0.24;\n    System.out.println((score2 - score1) / score2);\n    // score 2 has things around 500 and score 1 has things around 100 so it is approx 25% bad\n    assertTrue(\"Error The Badness threshold value is not taken into account!\",\n        (score2 - score1) / score2 > DYNAMIC_BADNESS_THRESHOLD);\n  }\n\n}"}
{"magic_number_smell": "    List<ColumnFamilyDefinition> cf_defs = new ArrayList<ColumnFamilyDefinition>();\n\n    List<ColumnDef> columns = new ArrayList<ColumnDef>();\n    for (int i = 0; i < 6; i++) {\n      String cName = \"col\" + i;\n      log.info(\"Creating column \" + cName);\n      columns.add(newIndexedColumnDef(cName, \"BytesType\"));", "refactored_code": "  private static final int colCount = 6;\n    List<ColumnFamilyDefinition> cf_defs = new ArrayList<ColumnFamilyDefinition>();\n\n    List<ColumnDef> columns = new ArrayList<ColumnDef>();\n    for (int i = 0; i < colCount; i++) {\n      String cName = \"col\" + i;\n      log.info(\"Creating column \" + cName);\n      columns.add(newIndexedColumnDef(cName, \"BytesType\"));"}
{"magic_number_smell": "\n  private static final int 100 = 100;\n\n  private int maxNumColumns = 100;\n  private ClassCacheMgr cacheMgr;\n  private KeyConcatenationStrategy keyConcatStrategy = new KeyConcatenationDelimiterStrategyImpl();\n  private CollectionMapperHelper collMapperHelper = new CollectionMapperHelper();", "refactored_code": "  private static final int MAX_NUM_COLUMNS = 100;\n\n  private static final int MAX_NUM_COLUMNS = 100;\n\n  private int maxNumColumns = MAX_NUM_COLUMNS;\n  private ClassCacheMgr cacheMgr;\n  private KeyConcatenationStrategy keyConcatStrategy = new KeyConcatenationDelimiterStrategyImpl();\n  private CollectionMapperHelper collMapperHelper = new CollectionMapperHelper();"}
{"magic_number_smell": "        // warm everybody up to ensure they are compiled.\n        // must run them all since loading later test can force recompilation\n        System.err.println(\"# HotSpot warmup\");\n        for (Method m : benchmarks) m.invoke(suite,10000);\n\n        System.err.println(\"# Computing number of reps per trial\");\n        // Compute a reps num that kicks each benchmark over MIN_BENCHMARK_TIME_IN_MS", "refactored_code": "    private static final int WARMUP_REPS = 10000; // HotSpot needs this to warm up\n        // warm everybody up to ensure they are compiled.\n        // must run them all since loading later test can force recompilation\n        System.err.println(\"# HotSpot warmup\");\n        for (Method m : benchmarks) m.invoke(suite,WARMUP_REPS);\n\n        System.err.println(\"# Computing number of reps per trial\");\n        // Compute a reps num that kicks each benchmark over MIN_BENCHMARK_TIME_IN_MS"}
{"magic_number_smell": "    }\n\n    /** Operand stack, grows upwards. */\n    Object[] operands = new Object[100];\n    /** Stack pointer register. */\n    int sp = -1;\n    /** The number of characters written on this template line so far. */", "refactored_code": "    public static final int DEFAULT_OPERAND_STACK_SIZE = 100;\n    }\n\n    /** Operand stack, grows upwards. */\n    Object[] operands = new Object[DEFAULT_OPERAND_STACK_SIZE];\n    /** Stack pointer register. */\n    int sp = -1;\n    /** The number of characters written on this template line so far. */"}
{"magic_number_smell": "\n    public static class Instruction {\n        public String name; // E.g., \"load_str\", \"new\"\n        public OperandType[] type = new OperandType[2];\n        public int nopnds = 0;\n        public Instruction(String name) {\n            this(name,OperandType.NONE,OperandType.NONE); nopnds =0;", "refactored_code": "    public static final int MAX_OPNDS = 2;\n\n    public static class Instruction {\n        public String name; // E.g., \"load_str\", \"new\"\n        public OperandType[] type = new OperandType[MAX_OPNDS];\n        public int nopnds = 0;\n        public Instruction(String name) {\n            this(name,OperandType.NONE,OperandType.NONE); nopnds =0;"}
{"magic_number_smell": "    /*\n    public static String getCardinalityName(int cardinality) {\n        switch (cardinality) {\n            case 1 : return \"optional\";\n            case REQUIRED : return \"exactly one\";\n            case ZERO_OR_MORE : return \"zero-or-more\";\n            case ONE_OR_MORE : return \"one-or-more\";", "refactored_code": "    public static final int OPTIONAL = 1;     // a?\n    /*\n    public static String getCardinalityName(int cardinality) {\n        switch (cardinality) {\n            case OPTIONAL : return \"optional\";\n            case REQUIRED : return \"exactly one\";\n            case ZERO_OR_MORE : return \"zero-or-more\";\n            case ONE_OR_MORE : return \"one-or-more\";"}
{"magic_number_smell": "            if ( txt!=null ) txt = Misc.replaceEscapes(txt);\n            else txt = \"<no text>\";\n            String tokenName;\n            if ( type==CharStream.EOF ) tokenName = \"EOF\";\n            else tokenName = STParser.tokenNames[type];\n            return \"[@\"+getTokenIndex()+\",\"+start+\":\"+stop+\"='\"+txt+\"',<\"+ tokenName +\">\"+channelStr+\",\"+line+\":\"+getCharPositionInLine()+\"]\";\n        }", "refactored_code": "    public static final int EOF_TYPE = CharStream.EOF;  // EOF token type\n            if ( txt!=null ) txt = Misc.replaceEscapes(txt);\n            else txt = \"<no text>\";\n            String tokenName;\n            if ( type==EOF_TYPE ) tokenName = \"EOF\";\n            else tokenName = STParser.tokenNames[type];\n            return \"[@\"+getTokenIndex()+\",\"+start+\":\"+stop+\"='\"+txt+\"',<\"+ tokenName +\">\"+channelStr+\",\"+line+\":\"+getCharPositionInLine()+\"]\";\n        }"}
{"magic_number_smell": "         } catch (AssertionError e) {\n            error = e;\n         }\n         Thread.sleep(5000 / 30);\n      }\n      if (error != null)\n         throw error;", "refactored_code": "   private static final int INCONSISTENCY_WINDOW = 5000;\n         } catch (AssertionError e) {\n            error = e;\n         }\n         Thread.sleep(INCONSISTENCY_WINDOW / 30);\n      }\n      if (error != null)\n         throw error;"}
{"magic_number_smell": "   public int hashCode() {\n      final int prime = 31;\n      int result = 1;\n      result = prime * result + 0;\n      result = prime * result + unit;\n      return result;\n   }", "refactored_code": "   private static final int bus = 0;\n   public int hashCode() {\n      final int prime = 31;\n      int result = 1;\n      result = prime * result + bus;\n      result = prime * result + unit;\n      return result;\n   }"}
{"magic_number_smell": "   @Test(enabled = false, dependsOnMethods = \"testCreateRunningInstance\")\n   void testCreateAndAttachVolume() {\n      volume = client.getElasticBlockStoreServices().createVolumeInAvailabilityZone(instance.getAvailabilityZone(),\n            2);\n      System.out.printf(\"%d: %s awaiting volume to become available%n\", System.currentTimeMillis(), volume.getId());\n\n      assert volumeTester.apply(volume);", "refactored_code": "   private static final int VOLUME_SIZE = 2;\n   @Test(enabled = false, dependsOnMethods = \"testCreateRunningInstance\")\n   void testCreateAndAttachVolume() {\n      volume = client.getElasticBlockStoreServices().createVolumeInAvailabilityZone(instance.getAvailabilityZone(),\n            VOLUME_SIZE);\n      System.out.printf(\"%d: %s awaiting volume to become available%n\", System.currentTimeMillis(), volume.getId());\n\n      assert volumeTester.apply(volume);"}
{"magic_number_smell": "            error = e;\n         }\n         try {\n            Thread.sleep(5000 / 30);\n         } catch (InterruptedException e) {\n         }\n      }", "refactored_code": "   private static final int INCONSISTENCY_WINDOW = 5000;\n            error = e;\n         }\n         try {\n            Thread.sleep(INCONSISTENCY_WINDOW / 30);\n         } catch (InterruptedException e) {\n         }\n      }"}
{"magic_number_smell": "   public int hashCode() {\n      final int prime = 31;\n      int result = 1;\n      result = prime * result + 0;\n      result = prime * result + unit;\n      return result;\n   }", "refactored_code": "   private static final int bus = 0;\n   public int hashCode() {\n      final int prime = 31;\n      int result = 1;\n      result = prime * result + bus;\n      result = prime * result + unit;\n      return result;\n   }"}
{"magic_number_smell": "            error = e;\n         }\n         try {\n            Thread.sleep(5000 / 30);\n         } catch (InterruptedException e) {\n         }\n      }", "refactored_code": "   private static final int INCONSISTENCY_WINDOW = 5000;\n            error = e;\n         }\n         try {\n            Thread.sleep(INCONSISTENCY_WINDOW / 30);\n         } catch (InterruptedException e) {\n         }\n      }"}
{"magic_number_smell": "   @Override\n   public AccessControlList load(String bucketName) {\n      ResourceNotFoundException last = null;\n      for (int currentTries = 0; currentTries < 5; currentTries++) {\n         try {\n            return client.getBucketACL(bucketName);\n         } catch (ResourceNotFoundException e) {", "refactored_code": "   private static final int maxTries = 5;\n   @Override\n   public AccessControlList load(String bucketName) {\n      ResourceNotFoundException last = null;\n      for (int currentTries = 0; currentTries < maxTries; currentTries++) {\n         try {\n            return client.getBucketACL(bucketName);\n         } catch (ResourceNotFoundException e) {"}
{"magic_number_smell": "         } catch (AssertionError e) {\n            error = e;\n         }\n         Uninterruptibles.sleepUninterruptibly(10000 / 30, TimeUnit.MILLISECONDS);\n      }\n      if (error != null)\n         throw error;", "refactored_code": "   private static final int INCONSISTENCY_WINDOW = 10000;\n         } catch (AssertionError e) {\n            error = e;\n         }\n         Uninterruptibles.sleepUninterruptibly(INCONSISTENCY_WINDOW / 30, TimeUnit.MILLISECONDS);\n      }\n      if (error != null)\n         throw error;"}
{"magic_number_smell": "   public static class StaticTimeAndTemporaryUrlKeyModule extends TemporaryUrlExtensionModule<SwiftAsyncClient> {\n      @Override\n      protected Long unixEpochTimestampProvider() {\n         return 123456789L;\n      }\n\n      @Override", "refactored_code": "   public static final long UNIX_EPOCH_TIMESTAMP = 123456789L;\n   public static class StaticTimeAndTemporaryUrlKeyModule extends TemporaryUrlExtensionModule<SwiftAsyncClient> {\n      @Override\n      protected Long unixEpochTimestampProvider() {\n         return UNIX_EPOCH_TIMESTAMP;\n      }\n\n      @Override"}
{"magic_number_smell": "\n      @Override\n      protected Long unixEpochTimestampProvider() {\n         return 123456789L;\n      }\n   }\n", "refactored_code": "      public static final long UNIX_EPOCH_TIMESTAMP = 123456789L;\n\n      @Override\n      protected Long unixEpochTimestampProvider() {\n         return UNIX_EPOCH_TIMESTAMP;\n      }\n   }\n"}
{"magic_number_smell": "               .getApi());\n\n      connection.getOrgClient().findOrgNamed(null);\n      Thread.sleep(40 * 1000);\n      connection.getOrgClient().findOrgNamed(null);\n   }\n", "refactored_code": "   private static final int timeOut = 40;\n               .getApi());\n\n      connection.getOrgClient().findOrgNamed(null);\n      Thread.sleep(timeOut * 1000);\n      connection.getOrgClient().findOrgNamed(null);\n   }\n"}
{"magic_number_smell": "         @Override\n         public String get() {\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < 10; i++) {\n               sb.append(goodChar[r.nextInt(goodChar.length)]);\n            }\n            return sb.toString();", "refactored_code": "         public static final int MIN_LENGTH = 10;\n         @Override\n         public String get() {\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < MIN_LENGTH; i++) {\n               sb.append(goodChar[r.nextInt(goodChar.length)]);\n            }\n            return sb.toString();"}
{"magic_number_smell": "            rounds = Math.max(ROUNDS_MIN, Math.min(srounds, ROUNDS_MAX));\n         }\n\n         if (shadowPrefix.length() > 16) {\n            shadowPrefix = shadowPrefix.substring(0, 16);\n         }\n      } else {", "refactored_code": "   private static final int SALT_LEN_MAX = 16;\n            rounds = Math.max(ROUNDS_MIN, Math.min(srounds, ROUNDS_MAX));\n         }\n\n         if (shadowPrefix.length() > SALT_LEN_MAX) {\n            shadowPrefix = shadowPrefix.substring(0, SALT_LEN_MAX);\n         }\n      } else {"}
{"magic_number_smell": "\n   private static Statement authorizePortInIpTables() {\n      return new StatementList(\n            exec(\"iptables -I INPUT 1 -p tcp --dport \" + 8080 + \" -j ACCEPT\"),\n            exec(\"iptables-save\"));\n   }\n   ", "refactored_code": "   public static final int port = 8080;\n\n   private static Statement authorizePortInIpTables() {\n      return new StatementList(\n            exec(\"iptables -I INPUT 1 -p tcp --dport \" + port + \" -j ACCEPT\"),\n            exec(\"iptables-save\"));\n   }\n   "}
{"magic_number_smell": "      }\n      long timetaken = stopwatch.elapsed(MILLISECONDS);\n\n      assertTrue(timetaken >= timeoutMs - EARLY_GRACE && timetaken <= timeoutMs + 700, \"timetaken=\" + timetaken);\n\n   }\n", "refactored_code": "   private static final long SLOW_GRACE = 700;\n      }\n      long timetaken = stopwatch.elapsed(MILLISECONDS);\n\n      assertTrue(timetaken >= timeoutMs - EARLY_GRACE && timetaken <= timeoutMs + SLOW_GRACE, \"timetaken=\" + timetaken);\n\n   }\n"}
{"magic_number_smell": "      writeLength(output, length);\n      for (BigInteger part : seq) {\n         byte[] bytes = part.toByteArray();\n         output.add((byte) 0x02);\n         writeLength(output, bytes.length);\n         output.addAll(Bytes.asList(bytes));\n      }", "refactored_code": "   private static final int TAG = 0x02;\n      writeLength(output, length);\n      for (BigInteger part : seq) {\n         byte[] bytes = part.toByteArray();\n         output.add((byte) TAG);\n         writeLength(output, bytes.length);\n         output.addAll(Bytes.asList(bytes));\n      }"}
{"magic_number_smell": "         private static final long 1L = 1L;\n      });\n      this.asyncClientType = checkBound(new TypeToken<A>(getClass()) {\n         private static final long 1L = 1L;\n      });\n   }\n", "refactored_code": "         private static final long serialVersionUID = 1L;\n         private static final long serialVersionUID = 1L;\n      });\n      this.asyncClientType = checkBound(new TypeToken<A>(getClass()) {\n         private static final long serialVersionUID = 1L;\n      });\n   }\n"}
{"magic_number_smell": "      @SuppressWarnings(\"unchecked\")\n      protected Builder() {\n         this.api = Class.class.cast(checkBound(new TypeToken<A>(getClass()) {\n            private static final long 1L = 1L;\n         }).getRawType());\n         init();\n      }", "refactored_code": "         private static final long serialVersionUID = 1L;\n      @SuppressWarnings(\"unchecked\")\n      protected Builder() {\n         this.api = Class.class.cast(checkBound(new TypeToken<A>(getClass()) {\n            private static final long serialVersionUID = 1L;\n         }).getRawType());\n         init();\n      }"}
{"magic_number_smell": "      private static final long 1L = 1L;\n   };\n   private static final TypeToken<ListenableFuture<String>> futureStringToken = new TypeToken<ListenableFuture<String>>() {\n      private static final long 1L = 1L;\n   };\n   private static final TypeToken<ListenableFuture<Void>> futureVoidToken = new TypeToken<ListenableFuture<Void>>() {\n      private static final long 1L = 1L;", "refactored_code": "      private static final long serialVersionUID = 1L;\n      private static final long serialVersionUID = 1L;\n   };\n   private static final TypeToken<ListenableFuture<String>> futureStringToken = new TypeToken<ListenableFuture<String>>() {\n      private static final long serialVersionUID = 1L;\n   };\n   private static final TypeToken<ListenableFuture<Void>> futureVoidToken = new TypeToken<ListenableFuture<Void>>() {\n      private static final long serialVersionUID = 1L;"}
{"magic_number_smell": "    * is 50ms, and {@code maxPeriod} 1s.\n    */\n   public static <T> Predicate<T> retry(Predicate<T> findOrBreak, long timeout) {\n      return retry(findOrBreak, timeout, 50l, DEFAULT_MAX_PERIOD, MILLISECONDS);\n   }\n\n   private static class RetryablePredicate<T> implements Predicate<T> {", "refactored_code": "   public static final long DEFAULT_PERIOD = 50l;\n    * is 50ms, and {@code maxPeriod} 1s.\n    */\n   public static <T> Predicate<T> retry(Predicate<T> findOrBreak, long timeout) {\n      return retry(findOrBreak, timeout, DEFAULT_PERIOD, DEFAULT_MAX_PERIOD, MILLISECONDS);\n   }\n\n   private static class RetryablePredicate<T> implements Predicate<T> {"}
{"magic_number_smell": "      private static final long 1L = 1L;\n   }.getType();\n   private Type fluentIterableResourceType = new TypeToken<FluentIterable<Resource>>() {\n      private static final long 1L = 1L;\n   }.getType();\n\n   public void testFluentIterable() {", "refactored_code": "      private static final long serialVersionUID = 1L;\n      private static final long serialVersionUID = 1L;\n   }.getType();\n   private Type fluentIterableResourceType = new TypeToken<FluentIterable<Resource>>() {\n      private static final long serialVersionUID = 1L;\n   }.getType();\n\n   public void testFluentIterable() {"}
{"magic_number_smell": "\n   public static void main(String[] args) throws InterruptedException {\n\n      if (args.length < 4)\n         throw new IllegalArgumentException(INVALID_SYNTAX);\n\n      boolean isEnterprise = System.getProperties().containsKey(\"jclouds.enterprise\");", "refactored_code": "   public static final int PARAMETERS = 4;\n\n   public static void main(String[] args) throws InterruptedException {\n\n      if (args.length < PARAMETERS)\n         throw new IllegalArgumentException(INVALID_SYNTAX);\n\n      boolean isEnterprise = System.getProperties().containsKey(\"jclouds.enterprise\");"}
{"magic_number_smell": "\n   public ChunkedFileInputStream(File file, long offset, long length) {\n      try {\n         this.chunks = new ChunkedFile(new RandomAccessFile(file, \"r\"), offset, length, 8192);\n      } catch (IOException ex) {\n         this.ex = ex;\n      }", "refactored_code": "   private static final int CHUNK_SIZE = 8192;\n\n   public ChunkedFileInputStream(File file, long offset, long length) {\n      try {\n         this.chunks = new ChunkedFile(new RandomAccessFile(file, \"r\"), offset, length, CHUNK_SIZE);\n      } catch (IOException ex) {\n         this.ex = ex;\n      }"}
{"magic_number_smell": "   public void setupContext() {\n      super.setupContext();\n      client = view.unwrap(AWSEC2ApiMetadata.CONTEXT_TOKEN).getApi();\n      activeTester = retry(new SpotInstanceRequestActive(client), 600, 1, 1, SECONDS);\n   }\n\n   @Test", "refactored_code": "   private static final int SPOT_DELAY_SECONDS = 600;\n   public void setupContext() {\n      super.setupContext();\n      client = view.unwrap(AWSEC2ApiMetadata.CONTEXT_TOKEN).getApi();\n      activeTester = retry(new SpotInstanceRequestActive(client), SPOT_DELAY_SECONDS, 1, 1, SECONDS);\n   }\n\n   @Test"}
{"magic_number_smell": "    * The Zone or other resource already exists\n    */\n   public static class TargetExistsException extends IllegalStateException {\n      private static final long 1L = 1L;\n\n      public TargetExistsException(String message, Throwable cause) {\n         super(message, cause);", "refactored_code": "      private static final long serialVersionUID = 1L;\n    * The Zone or other resource already exists\n    */\n   public static class TargetExistsException extends IllegalStateException {\n      private static final long serialVersionUID = 1L;\n\n      public TargetExistsException(String message, Throwable cause) {\n         super(message, cause);"}
{"magic_number_smell": "\n      @Override\n      protected Long unixEpochTimestampProvider() {\n         return 123456789L;\n      }\n   }\n}", "refactored_code": "      public static final long UNIX_EPOCH_TIMESTAMP = 123456789L;\n\n      @Override\n      protected Long unixEpochTimestampProvider() {\n         return UNIX_EPOCH_TIMESTAMP;\n      }\n   }\n}"}
{"magic_number_smell": "      String hardwareId = hardwareId().apply(ImmutableList.of(coresItem, ramItem, volumeItem));\n      double cores = ProductItems.capacity().apply(coresItem).doubleValue();\n      Matcher cpuMatcher = cpuDescriptionRegex.matcher(coresItem.getDescription());\n      double coreSpeed = (cpuMatcher.matches()) ? Double.parseDouble(cpuMatcher.group(cpuMatcher.groupCount())) : 2.0;\n      int ram = ProductItems.capacity().apply(ramItem).intValue();\n\n      return new HardwareBuilder().ids(hardwareId).processors(ImmutableList.of(new Processor(cores, coreSpeed))).ram(", "refactored_code": "   private static final double DEFAULT_CORE_SPEED = 2.0;\n      String hardwareId = hardwareId().apply(ImmutableList.of(coresItem, ramItem, volumeItem));\n      double cores = ProductItems.capacity().apply(coresItem).doubleValue();\n      Matcher cpuMatcher = cpuDescriptionRegex.matcher(coresItem.getDescription());\n      double coreSpeed = (cpuMatcher.matches()) ? Double.parseDouble(cpuMatcher.group(cpuMatcher.groupCount())) : DEFAULT_CORE_SPEED;\n      int ram = ProductItems.capacity().apply(ramItem).intValue();\n\n      return new HardwareBuilder().ids(hardwareId).processors(ImmutableList.of(new Processor(cores, coreSpeed))).ram("}
{"magic_number_smell": "    * Error 7021: Geolocation/Source IP overlap(s) found: Region: Utah (Group: US )\n    */\n   public static class DirectionalGroupOverlapException extends IllegalStateException {\n      private static final long 1L = 1L;\n\n      public DirectionalGroupOverlapException(String message, Throwable cause) {\n         super(message, cause);", "refactored_code": "      private static final long serialVersionUID = 1L;\n    * Error 7021: Geolocation/Source IP overlap(s) found: Region: Utah (Group: US )\n    */\n   public static class DirectionalGroupOverlapException extends IllegalStateException {\n      private static final long serialVersionUID = 1L;\n\n      public DirectionalGroupOverlapException(String message, Throwable cause) {\n         super(message, cause);"}
{"magic_number_smell": "   private final Provider<UriBuilder> builder;\n\n   public final long 1000000000 = 1000000000;\n   public final long MINUTES = 60 * 1000000000;\n\n   private final AtomicReference<String> authToken;\n   private final AtomicLong trigger = new AtomicLong(0);", "refactored_code": "   public final long BILLION = 1000000000;\n   private final Provider<UriBuilder> builder;\n\n   public final long BILLION = 1000000000;\n   public final long MINUTES = 60 * BILLION;\n\n   private final AtomicReference<String> authToken;\n   private final AtomicLong trigger = new AtomicLong(0);"}
{"magic_number_smell": "         } catch (AssertionError e) {\n            error = e;\n         }\n         Thread.sleep(10000 / 30);\n      }\n      if (error != null)\n         throw error;", "refactored_code": "   private static final int INCONSISTENCY_WINDOW = 10000;\n         } catch (AssertionError e) {\n            error = e;\n         }\n         Thread.sleep(INCONSISTENCY_WINDOW / 30);\n      }\n      if (error != null)\n         throw error;"}
{"magic_number_smell": "    int result = year;\n    \n    if(year.toString().length() <= 2) {\n      int century = (year > ((_currentYear - 2000) + 20)) ? 1900 : 2000;\n      result = year + century;\n    }\n    ", "refactored_code": "  private static final int TWO_DIGIT_YEAR_CENTURY_THRESHOLD = 20;\n    int result = year;\n    \n    if(year.toString().length() <= 2) {\n      int century = (year > ((_currentYear - 2000) + TWO_DIGIT_YEAR_CENTURY_THRESHOLD)) ? 1900 : 2000;\n      result = year + century;\n    }\n    "}
{"magic_number_smell": "        this.host = line.getOptionValue(\"rexsterhost\", DEFAULT_HOST);\n\n        final String portString = line.getOptionValue(\"rexsterport\");\n        this.port = parseInt(portString, 8184);\n\n        if (line.hasOption(\"rexsterport\") && !Integer.toString(this.port).equals(portString)) {\n            System.out.println(\"the rexsterport parameter must be an integer value. Defaulting to: [\" + port + \"]\");", "refactored_code": "    private final int DEFAULT_PORT = 8184;\n        this.host = line.getOptionValue(\"rexsterhost\", DEFAULT_HOST);\n\n        final String portString = line.getOptionValue(\"rexsterport\");\n        this.port = parseInt(portString, DEFAULT_PORT);\n\n        if (line.hasOption(\"rexsterport\") && !Integer.toString(this.port).equals(portString)) {\n            System.out.println(\"the rexsterport parameter must be an integer value. Defaulting to: [\" + port + \"]\");"}
{"magic_number_smell": "\n    @Override\n    public long getStartTime() {\n        return this.System.currentTimeMillis();\n    }\n\n    @Override", "refactored_code": "    protected final long startTime = System.currentTimeMillis();\n\n    @Override\n    public long getStartTime() {\n        return this.startTime;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public RexProMessage sendMessage(RexProMessage messageToSend) throws IOException {\n        return sendMessage(messageToSend, 100);\n    }\n\n    public RexProMessage sendMessage(RexProMessage messageToSend, int timeoutSeconds) throws IOException {", "refactored_code": "    public static final int DEFAULT_TIMEOUT_SECONDS = 100;\n    }\n\n    public RexProMessage sendMessage(RexProMessage messageToSend) throws IOException {\n        return sendMessage(messageToSend, DEFAULT_TIMEOUT_SECONDS);\n    }\n\n    public RexProMessage sendMessage(RexProMessage messageToSend, int timeoutSeconds) throws IOException {"}
{"magic_number_smell": "     */\n    public static byte[] serialize(RexProMessage msg) throws IOException {\n        byte[] message = msgpack.write(msg);\n        ByteBuffer bb = ByteBuffer.allocate(6 + message.length);\n\n        //version\n        bb.put((byte)0);", "refactored_code": "    public static final int MESSAGE_HEADER_SIZE = 6;\n     */\n    public static byte[] serialize(RexProMessage msg) throws IOException {\n        byte[] message = msgpack.write(msg);\n        ByteBuffer bb = ByteBuffer.allocate(MESSAGE_HEADER_SIZE + message.length);\n\n        //version\n        bb.put((byte)0);"}
{"magic_number_smell": "\n    @Override\n    public byte getSerializerId() {\n        return 1;\n    }\n}\n", "refactored_code": "    public static final byte SERIALIZER_ID = 1;\n\n    @Override\n    public byte getSerializerId() {\n        return SERIALIZER_ID;\n    }\n}\n"}
{"magic_number_smell": "\n    @Override\n    public byte getSerializerId() {\n        return 0;\n    }\n}\n", "refactored_code": "    public static final byte SERIALIZER_ID = 0;\n\n    @Override\n    public byte getSerializerId() {\n        return SERIALIZER_ID;\n    }\n}\n"}
{"magic_number_smell": "     */\n    public RexProSessionMonitor() {\n        setDaemon(true);\n        reconfigure(1000, MIN_IDLE_TIME);\n        start();\n    }\n", "refactored_code": "    private static final long MIN_UPDATE_INTERVAL = 1000;\n     */\n    public RexProSessionMonitor() {\n        setDaemon(true);\n        reconfigure(MIN_UPDATE_INTERVAL, MIN_IDLE_TIME);\n        start();\n    }\n"}
{"magic_number_smell": "\n        try {\n            rexsterGraphUriToConnectTo = context.getProperties().getString(Tokens.REXSTER_GRAPH_LOCATION, null);\n            bufferSize = context.getProperties().getInt(Tokens.REXSTER_GRAPH_BUFFER_SIZE, 100);\n        } catch (Exception ex) {\n            throw new GraphConfigurationException(ex);\n        }", "refactored_code": "    public static final int DEFAULT_BUFFER_SIZE = 100;\n\n        try {\n            rexsterGraphUriToConnectTo = context.getProperties().getString(Tokens.REXSTER_GRAPH_LOCATION, null);\n            bufferSize = context.getProperties().getInt(Tokens.REXSTER_GRAPH_BUFFER_SIZE, DEFAULT_BUFFER_SIZE);\n        } catch (Exception ex) {\n            throw new GraphConfigurationException(ex);\n        }"}
{"magic_number_smell": "    private static final int 1000 = 1000;\n\n    private static final Map<String, CharsetHolder> charsetCache = Collections.synchronizedMap(\n            new LinkedHashMap(1000) {\n\n                private static final long serialVersionUID = 2546245625L;\n", "refactored_code": "    private static final int CACHE_MAX_SIZE = 1000;\n    private static final int CACHE_MAX_SIZE = 1000;\n\n    private static final Map<String, CharsetHolder> charsetCache = Collections.synchronizedMap(\n            new LinkedHashMap(CACHE_MAX_SIZE) {\n\n                private static final long serialVersionUID = 2546245625L;\n"}
{"magic_number_smell": "     * Commands waiting to be executed. Number of waiting commands is capped,\n     * since this is meant to be used by a single client.\n     */\n    protected BlockingQueue<GremlinEvaluationJob> jobQueue = new ArrayBlockingQueue<GremlinEvaluationJob>(128);\n\n    /**\n     * Should I shut down?", "refactored_code": "    public static final int MAX_COMMANDS_WAITING = 128;\n     * Commands waiting to be executed. Number of waiting commands is capped,\n     * since this is meant to be used by a single client.\n     */\n    protected BlockingQueue<GremlinEvaluationJob> jobQueue = new ArrayBlockingQueue<GremlinEvaluationJob>(MAX_COMMANDS_WAITING);\n\n    /**\n     * Should I shut down?"}
{"magic_number_smell": "\n    private void readCommonConfiguration() {\n        this.timeUnit = this.registryConfiguration == null ? DEFAULT_TIME_UNIT : this.registryConfiguration.getString(Tokens.REXSTER_REPORTER_TIME_UNIT, DEFAULT_TIME_UNIT);\n        this.period = this.registryConfiguration == null ? 60l : this.registryConfiguration.getLong(Tokens.REXSTER_REPORTER_PERIOD, 60l);\n        this.rateTimeUnitConversion = this.registryConfiguration == null ? DEFAULT_TIME_UNIT : this.registryConfiguration.getString(Tokens.REXSTER_REPORTER_RATES_TIME_UNIT, DEFAULT_TIME_UNIT);\n        this.durationTimeUnitConversion = this.registryConfiguration == null ? DEFAULT_TIME_UNIT : this.registryConfiguration.getString(Tokens.REXSTER_REPORTER_DURATION_TIME_UNIT, DEFAULT_TIME_UNIT);\n        this.inclusion = this.registryConfiguration == null ? null : this.registryConfiguration.getString(Tokens.REXSTER_REPORTER_INCLUDES, null);", "refactored_code": "    public static final long DEFAULT_PERIOD = 60l;\n\n    private void readCommonConfiguration() {\n        this.timeUnit = this.registryConfiguration == null ? DEFAULT_TIME_UNIT : this.registryConfiguration.getString(Tokens.REXSTER_REPORTER_TIME_UNIT, DEFAULT_TIME_UNIT);\n        this.period = this.registryConfiguration == null ? DEFAULT_PERIOD : this.registryConfiguration.getLong(Tokens.REXSTER_REPORTER_PERIOD, DEFAULT_PERIOD);\n        this.rateTimeUnitConversion = this.registryConfiguration == null ? DEFAULT_TIME_UNIT : this.registryConfiguration.getString(Tokens.REXSTER_REPORTER_RATES_TIME_UNIT, DEFAULT_TIME_UNIT);\n        this.durationTimeUnitConversion = this.registryConfiguration == null ? DEFAULT_TIME_UNIT : this.registryConfiguration.getString(Tokens.REXSTER_REPORTER_DURATION_TIME_UNIT, DEFAULT_TIME_UNIT);\n        this.inclusion = this.registryConfiguration == null ? null : this.registryConfiguration.getString(Tokens.REXSTER_REPORTER_INCLUDES, null);"}
{"magic_number_smell": "\n        super.onCreate(icicle);\n\n        if (layout != -1) {\n            setContentView(layout);\n        }\n", "refactored_code": "    protected static final int NO_LAYOUT = -1;\n\n        super.onCreate(icicle);\n\n        if (layout != NO_LAYOUT) {\n            setContentView(layout);\n        }\n"}
{"magic_number_smell": "         * Make sure we only ask for what we might possibly want.\n         */\n        switch (mListType) {\n            case 1:\n                filter.addAction(ACTION_EVENTS_LIST_USER_RECEIVED);\n                break;\n            case LIST_USER_PUBLIC:", "refactored_code": "    public static final int LIST_USER_PRIVATE = 1;\n         * Make sure we only ask for what we might possibly want.\n         */\n        switch (mListType) {\n            case LIST_USER_PRIVATE:\n                filter.addAction(ACTION_EVENTS_LIST_USER_RECEIVED);\n                break;\n            case LIST_USER_PUBLIC:"}
{"magic_number_smell": "         * Make sure we only receive what we might actually want.\n         */\n        switch (mListType) {\n            case 1:\n                filter.addAction(ACTION_REPOS_LIST_ORG_OWNED);\n                filter.addAction(ACTION_REPOS_LIST_SELF_OWNED);\n                filter.addAction(ACTION_REPOS_LIST_USER_OWNED);", "refactored_code": "    public static final int LIST_USER = 1;\n         * Make sure we only receive what we might actually want.\n         */\n        switch (mListType) {\n            case LIST_USER:\n                filter.addAction(ACTION_REPOS_LIST_ORG_OWNED);\n                filter.addAction(ACTION_REPOS_LIST_SELF_OWNED);\n                filter.addAction(ACTION_REPOS_LIST_USER_OWNED);"}
{"magic_number_smell": "         * Make sure we only receive what we might actually want.\n         */\n        switch (mListType) {\n            case 1:\n                filter.addAction(ACTION_USERS_LIST_FOLLOWERS);\n                break;\n            case LIST_FOLLOWING:", "refactored_code": "    public static final int LIST_FOLLOWERS = 1;\n         * Make sure we only receive what we might actually want.\n         */\n        switch (mListType) {\n            case LIST_FOLLOWERS:\n                filter.addAction(ACTION_USERS_LIST_FOLLOWERS);\n                break;\n            case LIST_FOLLOWING:"}
{"magic_number_smell": "        }\n\n        mPaintDrawable = new PaintDrawable(Color.TRANSPARENT);\n        mPaintDrawable.setCornerRadius(3);\n        setBackgroundDrawable(mPaintDrawable);\n\n        mTextView = new TextView(getContext());", "refactored_code": "    private static final float OCTICON_CORNER_RADIUS = 3;\n        }\n\n        mPaintDrawable = new PaintDrawable(Color.TRANSPARENT);\n        mPaintDrawable.setCornerRadius(OCTICON_CORNER_RADIUS);\n        setBackgroundDrawable(mPaintDrawable);\n\n        mTextView = new TextView(getContext());"}
{"magic_number_smell": "    private final DefaultTextEqualsMessageValidator validator = new DefaultTextEqualsMessageValidator().enableTrim();\n\n    private final int SocketUtils.findAvailableTcpPort(8080) = SocketUtils.findAvailableTcpPort(8080);\n    private final String uri = \"http://localhost:\" + SocketUtils.findAvailableTcpPort(8080) + \"/test\";\n\n    private HttpServer httpServer;\n    private HttpClient httpClient;", "refactored_code": "    private final int port = SocketUtils.findAvailableTcpPort(8080);\n    private final DefaultTextEqualsMessageValidator validator = new DefaultTextEqualsMessageValidator().enableTrim();\n\n    private final int port = SocketUtils.findAvailableTcpPort(8080);\n    private final String uri = \"http://localhost:\" + port + \"/test\";\n\n    private HttpServer httpServer;\n    private HttpClient httpClient;"}
{"magic_number_smell": "\n    @BindToRegistry\n    private final HttpServer httpServer = new HttpServerBuilder()\n            .SocketUtils.findAvailableTcpPort(8080)(SocketUtils.findAvailableTcpPort(8080))\n            .timeout(5000L)\n            .autoStart(true)\n            .defaultStatus(HttpStatus.NO_CONTENT)", "refactored_code": "    private final int port = SocketUtils.findAvailableTcpPort(8080);\n\n    @BindToRegistry\n    private final HttpServer httpServer = new HttpServerBuilder()\n            .port(port)\n            .timeout(5000L)\n            .autoStart(true)\n            .defaultStatus(HttpStatus.NO_CONTENT)"}
{"magic_number_smell": "\n    @BindToRegistry\n    private final HttpServer httpServer = new HttpServerBuilder()\n            .SocketUtils.findAvailableTcpPort(8080)(SocketUtils.findAvailableTcpPort(8080))\n            .timeout(5000L)\n            .autoStart(true)\n            .defaultStatus(HttpStatus.NO_CONTENT)", "refactored_code": "    private final int port = SocketUtils.findAvailableTcpPort(8080);\n\n    @BindToRegistry\n    private final HttpServer httpServer = new HttpServerBuilder()\n            .port(port)\n            .timeout(5000L)\n            .autoStart(true)\n            .defaultStatus(HttpStatus.NO_CONTENT)"}
{"magic_number_smell": "    private final DefaultTextEqualsMessageValidator validator = new DefaultTextEqualsMessageValidator().enableTrim();\n\n    private final int SocketUtils.findAvailableTcpPort(8080) = SocketUtils.findAvailableTcpPort(8080);\n    private final String uri = \"http://localhost:\" + SocketUtils.findAvailableTcpPort(8080) + \"/test\";\n\n    private HttpServer httpServer;\n    private HttpClient httpClient;", "refactored_code": "    private final int port = SocketUtils.findAvailableTcpPort(8080);\n    private final DefaultTextEqualsMessageValidator validator = new DefaultTextEqualsMessageValidator().enableTrim();\n\n    private final int port = SocketUtils.findAvailableTcpPort(8080);\n    private final String uri = \"http://localhost:\" + port + \"/test\";\n\n    private HttpServer httpServer;\n    private HttpClient httpClient;"}
{"magic_number_smell": "    private final DefaultTextEqualsMessageValidator validator = new DefaultTextEqualsMessageValidator().enableTrim();\n\n    private final int SocketUtils.findAvailableTcpPort(8080) = SocketUtils.findAvailableTcpPort(8080);\n    private final String uri = \"http://localhost:\" + SocketUtils.findAvailableTcpPort(8080) + \"/test\";\n\n    private HttpServer httpServer;\n    private HttpClient httpClient;", "refactored_code": "    private final int port = SocketUtils.findAvailableTcpPort(8080);\n    private final DefaultTextEqualsMessageValidator validator = new DefaultTextEqualsMessageValidator().enableTrim();\n\n    private final int port = SocketUtils.findAvailableTcpPort(8080);\n    private final String uri = \"http://localhost:\" + port + \"/test\";\n\n    private HttpServer httpServer;\n    private HttpClient httpClient;"}
{"magic_number_smell": "\n\n    public static int findAvailableTcpPort() {\n        return findAvailableTcpPort(1024);\n    }\n\n    public static int findAvailableTcpPort(int min) {", "refactored_code": "    private static final int PORT_RANGE_MIN = 1024;\n\n\n    public static int findAvailableTcpPort() {\n        return findAvailableTcpPort(PORT_RANGE_MIN);\n    }\n\n    public static int findAvailableTcpPort(int min) {"}
{"magic_number_smell": "\n        timer.execute(context);\n\n        assertTimerIndex(3, timer);\n\n        verify(action, times(3)).execute(context);\n    }", "refactored_code": "    private final int defaultRepeatCount = 3;\n\n        timer.execute(context);\n\n        assertTimerIndex(defaultRepeatCount, timer);\n\n        verify(action, times(defaultRepeatCount)).execute(context);\n    }"}
{"magic_number_smell": "    private final DefaultTextEqualsMessageValidator validator = new DefaultTextEqualsMessageValidator().enableTrim();\n\n    private final int SocketUtils.findAvailableTcpPort(8080) = SocketUtils.findAvailableTcpPort(8080);\n    private final String uri = \"http://localhost:\" + SocketUtils.findAvailableTcpPort(8080) + \"/test\";\n\n    private HttpServer httpServer;\n    private HttpClient httpClient;", "refactored_code": "    private final int port = SocketUtils.findAvailableTcpPort(8080);\n    private final DefaultTextEqualsMessageValidator validator = new DefaultTextEqualsMessageValidator().enableTrim();\n\n    private final int port = SocketUtils.findAvailableTcpPort(8080);\n    private final String uri = \"http://localhost:\" + port + \"/test\";\n\n    private HttpServer httpServer;\n    private HttpClient httpClient;"}
{"magic_number_smell": "\n    @BindToRegistry\n    private final HttpServer basicAuthServer = new HttpServerBuilder()\n            .findAvailableTcpPort(8888)(findAvailableTcpPort(8888))\n            .autoStart(true)\n            .defaultStatus(HttpStatus.NO_CONTENT)\n            .authentication(\"/secured/*\", basic(\"citrus\", \"secr3t\"))", "refactored_code": "    private final int port = findAvailableTcpPort(8888);\n\n    @BindToRegistry\n    private final HttpServer basicAuthServer = new HttpServerBuilder()\n            .port(port)\n            .autoStart(true)\n            .defaultStatus(HttpStatus.NO_CONTENT)\n            .authentication(\"/secured/*\", basic(\"citrus\", \"secr3t\"))"}
{"magic_number_smell": "    private final int SocketUtils.findAvailableTcpPort() = SocketUtils.findAvailableTcpPort();\n\n    private HttpServer httpServer = new HttpServerBuilder()\n            .port(SocketUtils.findAvailableTcpPort())\n            .timeout(500L)\n            .build();\n", "refactored_code": "    private final int serverPort = SocketUtils.findAvailableTcpPort();\n    private final int serverPort = SocketUtils.findAvailableTcpPort();\n\n    private HttpServer httpServer = new HttpServerBuilder()\n            .port(serverPort)\n            .timeout(500L)\n            .build();\n"}
{"magic_number_smell": "public class HttpServerTest extends AbstractTestNGUnitTest {\n\n    private final int SocketUtils.findAvailableTcpPort(8080) = SocketUtils.findAvailableTcpPort(8080);\n    private final String uri = \"http://localhost:\" + SocketUtils.findAvailableTcpPort(8080) + \"/test\";\n\n    private HttpClient client;\n    private final HttpServer server = new HttpServer();", "refactored_code": "    private final int port = SocketUtils.findAvailableTcpPort(8080);\npublic class HttpServerTest extends AbstractTestNGUnitTest {\n\n    private final int port = SocketUtils.findAvailableTcpPort(8080);\n    private final String uri = \"http://localhost:\" + port + \"/test\";\n\n    private HttpClient client;\n    private final HttpServer server = new HttpServer();"}
{"magic_number_smell": "    private final DefaultTextEqualsMessageValidator validator = new DefaultTextEqualsMessageValidator().enableTrim();\n\n    private final int SocketUtils.findAvailableTcpPort(8080) = SocketUtils.findAvailableTcpPort(8080);\n    private final String uri = \"http://localhost:\" + SocketUtils.findAvailableTcpPort(8080) + \"/test\";\n\n    private HttpServer httpServer;\n    private HttpClient httpClient;", "refactored_code": "    private final int port = SocketUtils.findAvailableTcpPort(8080);\n    private final DefaultTextEqualsMessageValidator validator = new DefaultTextEqualsMessageValidator().enableTrim();\n\n    private final int port = SocketUtils.findAvailableTcpPort(8080);\n    private final String uri = \"http://localhost:\" + port + \"/test\";\n\n    private HttpServer httpServer;\n    private HttpClient httpClient;"}
{"magic_number_smell": "    private final DefaultTextEqualsMessageValidator validator = new DefaultTextEqualsMessageValidator().enableTrim();\n\n    private final int SocketUtils.findAvailableTcpPort(8080) = SocketUtils.findAvailableTcpPort(8080);\n    private final String uri = \"http://localhost:\" + SocketUtils.findAvailableTcpPort(8080) + \"/test\";\n\n    private HttpServer httpServer;\n    private HttpClient httpClient;", "refactored_code": "    private final int port = SocketUtils.findAvailableTcpPort(8080);\n    private final DefaultTextEqualsMessageValidator validator = new DefaultTextEqualsMessageValidator().enableTrim();\n\n    private final int port = SocketUtils.findAvailableTcpPort(8080);\n    private final String uri = \"http://localhost:\" + port + \"/test\";\n\n    private HttpServer httpServer;\n    private HttpClient httpClient;"}
{"magic_number_smell": "    public static final String OK_MESSAGE = \"Ok\";\n\n    @XmlElement(required = true, defaultValue = \"250\")\n    protected int code = 250;\n    @XmlElement(required = true, defaultValue = \"Ok\")\n    protected String message = OK_MESSAGE;\n", "refactored_code": "    public static final int OK_CODE = 250;\n    public static final String OK_MESSAGE = \"Ok\";\n\n    @XmlElement(required = true, defaultValue = \"250\")\n    protected int code = OK_CODE;\n    @XmlElement(required = true, defaultValue = \"Ok\")\n    protected String message = OK_MESSAGE;\n"}
{"magic_number_smell": "        endpointConfiguration.setHost(\"planck\");\n        endpointConfiguration.setUser(\"roland\");\n        endpointConfiguration.setPort(1968);\n        endpointConfiguration.setConnectionTimeout(50);\n        endpointConfiguration.setCommandTimeout(2 * 60 * 1000);\n\n        session = Mockito.mock(Session.class);", "refactored_code": "    private static final int CONNECTTION_TIMEOUT = 50;\n        endpointConfiguration.setHost(\"planck\");\n        endpointConfiguration.setUser(\"roland\");\n        endpointConfiguration.setPort(1968);\n        endpointConfiguration.setConnectionTimeout(CONNECTTION_TIMEOUT);\n        endpointConfiguration.setCommandTimeout(2 * 60 * 1000);\n\n        session = Mockito.mock(Session.class);"}
{"magic_number_smell": "public class AssertSoapFaultTest extends AbstractGroovyActionDslTest {\n\n    private final int SocketUtils.findAvailableTcpPort(8080) = SocketUtils.findAvailableTcpPort(8080);\n    private final String uri = \"http://localhost:\" + SocketUtils.findAvailableTcpPort(8080) + \"/test\";\n\n    private WebServiceServer soapServer;\n    private WebServiceClient soapClient;", "refactored_code": "    private final int port = SocketUtils.findAvailableTcpPort(8080);\npublic class AssertSoapFaultTest extends AbstractGroovyActionDslTest {\n\n    private final int port = SocketUtils.findAvailableTcpPort(8080);\n    private final String uri = \"http://localhost:\" + port + \"/test\";\n\n    private WebServiceServer soapServer;\n    private WebServiceClient soapClient;"}
{"magic_number_smell": "public class SoapClientTest extends AbstractGroovyActionDslTest {\n\n    private final int SocketUtils.findAvailableTcpPort(8080) = SocketUtils.findAvailableTcpPort(8080);\n    private final String uri = \"http://localhost:\" + SocketUtils.findAvailableTcpPort(8080) + \"/test\";\n\n    private WebServiceServer soapServer;\n    private WebServiceClient soapClient;", "refactored_code": "    private final int port = SocketUtils.findAvailableTcpPort(8080);\npublic class SoapClientTest extends AbstractGroovyActionDslTest {\n\n    private final int port = SocketUtils.findAvailableTcpPort(8080);\n    private final String uri = \"http://localhost:\" + port + \"/test\";\n\n    private WebServiceServer soapServer;\n    private WebServiceClient soapClient;"}
{"magic_number_smell": "public class AssertSoapFaultTest extends AbstractXmlActionTest {\n\n    private final int SocketUtils.findAvailableTcpPort(8080) = SocketUtils.findAvailableTcpPort(8080);\n    private final String uri = \"http://localhost:\" + SocketUtils.findAvailableTcpPort(8080) + \"/test\";\n\n    private WebServiceServer soapServer;\n    private WebServiceClient soapClient;", "refactored_code": "    private final int port = SocketUtils.findAvailableTcpPort(8080);\npublic class AssertSoapFaultTest extends AbstractXmlActionTest {\n\n    private final int port = SocketUtils.findAvailableTcpPort(8080);\n    private final String uri = \"http://localhost:\" + port + \"/test\";\n\n    private WebServiceServer soapServer;\n    private WebServiceClient soapClient;"}
{"magic_number_smell": "public class SoapClientTest extends AbstractXmlActionTest {\n\n    private final int SocketUtils.findAvailableTcpPort(8080) = SocketUtils.findAvailableTcpPort(8080);\n    private final String uri = \"http://localhost:\" + SocketUtils.findAvailableTcpPort(8080) + \"/test\";\n\n    private WebServiceServer soapServer;\n    private WebServiceClient soapClient;", "refactored_code": "    private final int port = SocketUtils.findAvailableTcpPort(8080);\npublic class SoapClientTest extends AbstractXmlActionTest {\n\n    private final int port = SocketUtils.findAvailableTcpPort(8080);\n    private final String uri = \"http://localhost:\" + port + \"/test\";\n\n    private WebServiceServer soapServer;\n    private WebServiceClient soapClient;"}
{"magic_number_smell": "public class AssertSoapFaultTest extends AbstractYamlActionTest {\n\n    private final int SocketUtils.findAvailableTcpPort(8080) = SocketUtils.findAvailableTcpPort(8080);\n    private final String uri = \"http://localhost:\" + SocketUtils.findAvailableTcpPort(8080) + \"/test\";\n\n    private WebServiceServer soapServer;\n    private WebServiceClient soapClient;", "refactored_code": "    private final int port = SocketUtils.findAvailableTcpPort(8080);\npublic class AssertSoapFaultTest extends AbstractYamlActionTest {\n\n    private final int port = SocketUtils.findAvailableTcpPort(8080);\n    private final String uri = \"http://localhost:\" + port + \"/test\";\n\n    private WebServiceServer soapServer;\n    private WebServiceClient soapClient;"}
{"magic_number_smell": "public class SoapClientTest extends AbstractYamlActionTest {\n\n    private final int SocketUtils.findAvailableTcpPort(8080) = SocketUtils.findAvailableTcpPort(8080);\n    private final String uri = \"http://localhost:\" + SocketUtils.findAvailableTcpPort(8080) + \"/test\";\n\n    private WebServiceServer soapServer;\n    private WebServiceClient soapClient;", "refactored_code": "    private final int port = SocketUtils.findAvailableTcpPort(8080);\npublic class SoapClientTest extends AbstractYamlActionTest {\n\n    private final int port = SocketUtils.findAvailableTcpPort(8080);\n    private final String uri = \"http://localhost:\" + port + \"/test\";\n\n    private WebServiceServer soapServer;\n    private WebServiceClient soapClient;"}
{"magic_number_smell": "        public Builder delete(String path) {\n            Delete command = new Delete();\n            command.path(path);\n            command.version(0);\n            return command(command);\n        }\n", "refactored_code": "        public static final int DEFAULT_VERSION = 0;\n        public Builder delete(String path) {\n            Delete command = new Delete();\n            command.path(path);\n            command.version(DEFAULT_VERSION);\n            return command(command);\n        }\n"}
{"magic_number_smell": "\n        private String id;\n        private String url = DEFAULT_URL;\n        private int timeout = 2000;\n\n        public ZooKeeperClientConfigBuilder withId(String id) {\n            this.id = id;", "refactored_code": "        public static final int DEFAULT_TIMEOUT = 2000;\n\n        private String id;\n        private String url = DEFAULT_URL;\n        private int timeout = DEFAULT_TIMEOUT;\n\n        public ZooKeeperClientConfigBuilder withId(String id) {\n            this.id = id;"}
{"magic_number_smell": "\n    @BeforeClass\n    public void startServer() throws IOException {\n        server = HttpServer.create(new InetSocketAddress(\"localhost\", SocketUtils.findAvailableTcpPort()), 0);\n        server.createContext(\"/test\", httpExchange -> httpExchange.sendResponseHeaders(200, 0));\n        server.setExecutor(Executors.newSingleThreadExecutor());\n        server.start();", "refactored_code": "    private final int serverPort = SocketUtils.findAvailableTcpPort();\n\n    @BeforeClass\n    public void startServer() throws IOException {\n        server = HttpServer.create(new InetSocketAddress(\"localhost\", serverPort), 0);\n        server.createContext(\"/test\", httpExchange -> httpExchange.sendResponseHeaders(200, 0));\n        server.setExecutor(Executors.newSingleThreadExecutor());\n        server.start();"}
{"magic_number_smell": "        private static final int 0 = 0;\n        private static final int ERRORS = 1;\n\n        private int exitStatus = 0;\n\n        @Override\n        public void generateReport(TestResults testResults) {", "refactored_code": "        private static final int DEFAULT = 0;\n        private static final int DEFAULT = 0;\n        private static final int ERRORS = 1;\n\n        private int exitStatus = DEFAULT;\n\n        @Override\n        public void generateReport(TestResults testResults) {"}
{"magic_number_smell": "            ReadableByteChannel receivedBytes = Channels.newChannel(receivedInput);\n            ReadableByteChannel controlBytes = Channels.newChannel(controlInput);\n\n            ByteBuffer receivedBuffer = ByteBuffer.allocateDirect(1024);\n            ByteBuffer controlBuffer = ByteBuffer.allocateDirect(1024);\n\n            while (true) {", "refactored_code": "    private static final int BUFFER_SIZE = 1024;\n            ReadableByteChannel receivedBytes = Channels.newChannel(receivedInput);\n            ReadableByteChannel controlBytes = Channels.newChannel(controlInput);\n\n            ByteBuffer receivedBuffer = ByteBuffer.allocateDirect(BUFFER_SIZE);\n            ByteBuffer controlBuffer = ByteBuffer.allocateDirect(BUFFER_SIZE);\n\n            while (true) {"}
{"magic_number_smell": "            fin = new FileInputStream(f);\n            DataInputStream din = new DataInputStream(fin);\n            \n            if (din.readLong() != 0x81057FAB7272F10l)\n                throw new IOException(\"Magic number mismatch\");\n\n            while (true)", "refactored_code": "    public static final long BREAKPOINT_MAGIC = 0x81057FAB7272F10l;\n            fin = new FileInputStream(f);\n            DataInputStream din = new DataInputStream(fin);\n            \n            if (din.readLong() != BREAKPOINT_MAGIC)\n                throw new IOException(\"Magic number mismatch\");\n\n            while (true)"}
{"magic_number_smell": "    public static int[] extract(Processor cpu)\n    {\n        int[] regs = new int[30];\n        regs[0] = cpu.r_eax.get32();\n        regs[ECX] = cpu.r_ecx.get32();\n        regs[EDX] = cpu.r_edx.get32();\n        regs[EBX] = cpu.r_ebx.get32();", "refactored_code": "    public static final int EAX = 0;\n    public static int[] extract(Processor cpu)\n    {\n        int[] regs = new int[30];\n        regs[EAX] = cpu.r_eax.get32();\n        regs[ECX] = cpu.r_ecx.get32();\n        regs[EDX] = cpu.r_edx.get32();\n        regs[EBX] = cpu.r_ebx.get32();"}
{"magic_number_smell": "            fin = new FileInputStream(f);\n            DataInputStream din = new DataInputStream(fin);\n            \n            if (din.readLong() != 0x81057FAB7272F11l)\n                throw new IOException(\"Magic number mismatch\");\n\n            while (true)", "refactored_code": "    public static final long WATCHPOINT_MAGIC = 0x81057FAB7272F11l;\n            fin = new FileInputStream(f);\n            DataInputStream din = new DataInputStream(fin);\n            \n            if (din.readLong() != WATCHPOINT_MAGIC)\n                throw new IOException(\"Magic number mismatch\");\n\n            while (true)"}
{"magic_number_smell": "     * @throws java.io.IOException propogated from bios resource loading\n     */\n    public PC(Clock clock, DriveSet drives, Calendar startTime) throws IOException {\n        this(clock, drives, Option.ram.intValue(16) * 1024 * 1024, startTime);\n    }\n\n    public PC(Clock clock, DriveSet drives) throws IOException {", "refactored_code": "    public static final int DEFAULT_RAM_SIZE = Option.ram.intValue(16) * 1024 * 1024;\n     * @throws java.io.IOException propogated from bios resource loading\n     */\n    public PC(Clock clock, DriveSet drives, Calendar startTime) throws IOException {\n        this(clock, drives, DEFAULT_RAM_SIZE, startTime);\n    }\n\n    public PC(Clock clock, DriveSet drives) throws IOException {"}
{"magic_number_smell": "    public static final int ZF = 1 << 6;\n    public static final int SF = 1 << 7;\n    public static final int OF = 1 << 11;\n    public static final int OSZAPC = 1 << 0 | PF | AF | ZF | SF | OF;\n    public static final int OSZPC = 1 << 0 | PF | ZF | SF | OF;\n    public static final int OSZP = PF | ZF | SF | OF;\n    public static final int SZAPC = 1 << 0 | PF | AF | ZF | SF;", "refactored_code": "    public static final int CF = 1 << 0;\n    public static final int ZF = 1 << 6;\n    public static final int SF = 1 << 7;\n    public static final int OF = 1 << 11;\n    public static final int OSZAPC = CF | PF | AF | ZF | SF | OF;\n    public static final int OSZPC = CF | PF | ZF | SF | OF;\n    public static final int OSZP = PF | ZF | SF | OF;\n    public static final int SZAPC = CF | PF | AF | ZF | SF;"}
{"magic_number_smell": "    public BackgroundCompiler(CodeBlockCompiler immediate, CodeBlockCompiler delayed) {\n        this.immediate = immediate;\n        this.delayed = delayed;\n        compilerQueue = new CompilerQueue(256);\n\n        int compilerCount = 1;\n//        int compilerCount = Runtime.getRuntime().availableProcessors() - 1;", "refactored_code": "    private static final int COMPILER_QUEUE_SIZE = 256;\n    public BackgroundCompiler(CodeBlockCompiler immediate, CodeBlockCompiler delayed) {\n        this.immediate = immediate;\n        this.delayed = delayed;\n        compilerQueue = new CompilerQueue(COMPILER_QUEUE_SIZE);\n\n        int compilerCount = 1;\n//        int compilerCount = Runtime.getRuntime().availableProcessors() - 1;"}
{"magic_number_smell": "\n    private boolean watchedAddress(int addr)\n    {\n        if (addr < Option.min_addr_watch.intValue(0))\n            return false;\n        if ((addr & 0xFFFFFFFFL) > (MAX_ADDR_WATCH & 0xFFFFFFFFL))\n            return false;", "refactored_code": "    public static final int MIN_ADDR_WATCH = Option.min_addr_watch.intValue(0);\n\n    private boolean watchedAddress(int addr)\n    {\n        if (addr < MIN_ADDR_WATCH)\n            return false;\n        if ((addr & 0xFFFFFFFFL) > (MAX_ADDR_WATCH & 0xFFFFFFFFL))\n            return false;"}
{"magic_number_smell": "        boolean delayInterrupts = false;\n        while (!currentInsn.isBranch())\n        {\n            if (((delayInterrupts) || (count >= Option.max_instructions_per_block.intValue(10000))) && !delayInterrupts(currentInsn))\n            {\n                Executable eip = getEipUpdate(mode, startAddr, currentInsn);\n                current.next = eip;", "refactored_code": "    public static final int MAX_INSTRUCTIONS_PER_BLOCK = Option.max_instructions_per_block.intValue(10000);\n        boolean delayInterrupts = false;\n        while (!currentInsn.isBranch())\n        {\n            if (((delayInterrupts) || (count >= MAX_INSTRUCTIONS_PER_BLOCK)) && !delayInterrupts(currentInsn))\n            {\n                Executable eip = getEipUpdate(mode, startAddr, currentInsn);\n                current.next = eip;"}
{"magic_number_smell": "        boolean delayInterrupts = false;\n        while (!current.isBranch())\n        {\n            if (((delayInterrupts) || (count >= Option.max_instructions_per_block.intValue(10000))) && !delayInterrupts(current))\n            {\n                Executable eip;\n                if (mode == 1)", "refactored_code": "    public static final int MAX_INSTRUCTIONS_PER_BLOCK = Option.max_instructions_per_block.intValue(10000);\n        boolean delayInterrupts = false;\n        while (!current.isBranch())\n        {\n            if (((delayInterrupts) || (count >= MAX_INSTRUCTIONS_PER_BLOCK)) && !delayInterrupts(current))\n            {\n                Executable eip;\n                if (mode == 1)"}
{"magic_number_smell": "public abstract class AddressSpace extends AbstractMemory \n{\n    public static final int 4*1024 = 4*1024;\n    public static final int BLOCK_MASK = 4*1024-1;\n    public static final int INDEX_MASK = ~(BLOCK_MASK);\n    public static final int INDEX_SHIFT = 12;\n    public static final int INDEX_SIZE = 1 << (32 - INDEX_SHIFT);", "refactored_code": "    public static final int BLOCK_SIZE = 4*1024;\npublic abstract class AddressSpace extends AbstractMemory \n{\n    public static final int BLOCK_SIZE = 4*1024;\n    public static final int BLOCK_MASK = BLOCK_SIZE-1;\n    public static final int INDEX_MASK = ~(BLOCK_MASK);\n    public static final int INDEX_SHIFT = 12;\n    public static final int INDEX_SIZE = 1 << (32 - INDEX_SHIFT);"}
{"magic_number_smell": "        try {\n            System.arraycopy(buffer, address, buf, off, len);\n        } catch (NullPointerException e) {\n            if (++nullReadCount == 10) {\n                allocateBuffer();\n                System.arraycopy(buffer, address, buf, off, len);\n            } else {", "refactored_code": "    private static final int ALLOCATION_THRESHOLD = 10;\n        try {\n            System.arraycopy(buffer, address, buf, off, len);\n        } catch (NullPointerException e) {\n            if (++nullReadCount == ALLOCATION_THRESHOLD) {\n                allocateBuffer();\n                System.arraycopy(buffer, address, buf, off, len);\n            } else {"}
{"magic_number_smell": "            {\n                int i = (a << BOTTOM_INDEX_BITS) | b;\n\n                if ((i & (0xffefffff >>> INDEX_SHIFT)) == i)\n                {\n                    int modi = i | (~0xffefffff >>> INDEX_SHIFT);\n                    int moda = modi >>> BOTTOM_INDEX_BITS;", "refactored_code": "    private static final int GATEA20_MASK = 0xffefffff;\n            {\n                int i = (a << BOTTOM_INDEX_BITS) | b;\n\n                if ((i & (GATEA20_MASK >>> INDEX_SHIFT)) == i)\n                {\n                    int modi = i | (~GATEA20_MASK >>> INDEX_SHIFT);\n                    int moda = modi >>> BOTTOM_INDEX_BITS;"}
{"magic_number_smell": "    private static final int pagePortList1 = 0x2;\n    private static final int pagePortList2 = 0x3;\n    private static final int pagePortList3 = 0x7;\n    private static final int[] pagePortList = new int[]{0x1,\n            pagePortList1, pagePortList2, pagePortList3};\n    private static final int COMMAND_MEMORY_TO_MEMORY = 0x01;\n    private static final int COMMAND_ADDRESS_HOLD = 0x02;", "refactored_code": "    private static final int pagePortList0 = 0x1;\n    private static final int pagePortList1 = 0x2;\n    private static final int pagePortList2 = 0x3;\n    private static final int pagePortList3 = 0x7;\n    private static final int[] pagePortList = new int[]{pagePortList0,\n            pagePortList1, pagePortList2, pagePortList3};\n    private static final int COMMAND_MEMORY_TO_MEMORY = 0x01;\n    private static final int COMMAND_ADDRESS_HOLD = 0x02;"}
{"magic_number_smell": "     */\n    public IOPortHandler()\n    {\n        ioPortDevice = new IODevice[65536];\n        for (int i = 0; i < ioPortDevice.length; i++)\n            ioPortDevice[i] = defaultDevice;\n    }", "refactored_code": "    private static final int MAX_IOPORTS = 65536;\n     */\n    public IOPortHandler()\n    {\n        ioPortDevice = new IODevice[MAX_IOPORTS];\n        for (int i = 0; i < ioPortDevice.length; i++)\n            ioPortDevice[i] = defaultDevice;\n    }"}
{"magic_number_smell": "                    /* XXX: not supported */\n                    cmosData[this.cmosIndex] = (byte) data;\n                    break;\n                case 0:\n                case RTC_MINUTES:\n                case RTC_HOURS:\n                case RTC_DAY_OF_WEEK:", "refactored_code": "    private static final int RTC_SECONDS = 0;\n                    /* XXX: not supported */\n                    cmosData[this.cmosIndex] = (byte) data;\n                    break;\n                case RTC_SECONDS:\n                case RTC_MINUTES:\n                case RTC_HOURS:\n                case RTC_DAY_OF_WEEK:"}
{"magic_number_smell": "    {\n\tif ((data & BM_CMD_START) == 0) {\n\t    /* XXX: do it better */\n\t    this.status &= ~0x01;\n\t    this.command = (byte)(data & 0x09);\n\t} else {\n\t    this.status |= 0x01;", "refactored_code": "    public static final int BM_STATUS_DMAING = 0x01;\n    {\n\tif ((data & BM_CMD_START) == 0) {\n\t    /* XXX: do it better */\n\t    this.status &= ~BM_STATUS_DMAING;\n\t    this.command = (byte)(data & 0x09);\n\t} else {\n\t    this.status |= BM_STATUS_DMAING;"}
{"magic_number_smell": "\n    public EthernetCard(EthernetOutput output)\n    {\n        setIRQIndex(9);\n\n        putConfigWord(PCI_CONFIG_VENDOR_ID, (short) 0x10ec); // Realtek\n        putConfigWord(PCI_CONFIG_DEVICE_ID, (short) 0x8029); // 8029", "refactored_code": "    private static final int IRQ = 9;\n\n    public EthernetCard(EthernetOutput output)\n    {\n        setIRQIndex(IRQ);\n\n        putConfigWord(PCI_CONFIG_VENDOR_ID, (short) 0x10ec); // Realtek\n        putConfigWord(PCI_CONFIG_DEVICE_ID, (short) 0x8029); // 8029"}
{"magic_number_smell": "        }\n\n        public void abortCommand() {\n            status = READY_STAT | 0x01;\n            error = ABRT_ERR;\n        }\n", "refactored_code": "        public static final int ERR_STAT = 0x01;\n        }\n\n        public void abortCommand() {\n            status = READY_STAT | ERR_STAT;\n            error = ABRT_ERR;\n        }\n"}
{"magic_number_smell": "        bankOffset = 0;\n\n        vbeRegs[VBE_DISPI_INDEX_ID] = VBE_DISPI_ID0;\n        vbeBankMask = ((16 * 1024 * 1024 >>> 16) - 1);\n        vbeRegs[VBE_DISPI_INDEX_XRES] = 1600;\n        vbeRegs[VBE_DISPI_INDEX_YRES] = 1200;\n        vbeRegs[VBE_DISPI_INDEX_BPP] = 32;", "refactored_code": "    private static final int VGA_RAM_SIZE = 16 * 1024 * 1024;\n        bankOffset = 0;\n\n        vbeRegs[VBE_DISPI_INDEX_ID] = VBE_DISPI_ID0;\n        vbeBankMask = ((VGA_RAM_SIZE >>> 16) - 1);\n        vbeRegs[VBE_DISPI_INDEX_XRES] = 1600;\n        vbeRegs[VBE_DISPI_INDEX_YRES] = 1200;\n        vbeRegs[VBE_DISPI_INDEX_BPP] = 32;"}
{"magic_number_smell": "//            }\n//            //Writing a keyon to a 2nd address enables dual opl2 otherwise\n//            //Maybe also check for rhythm\n//            if ( header.hardware == 0 && regFull >= 0x1b0 && regFull <=0x1b8 && val ) {\n//                header.hardware = HW_DUALOPL2;\n//            }\n//            /*Bit8u*/short raw = ToRaw[ regMask ];", "refactored_code": "    static private final int HW_OPL2 = 0;\n//            }\n//            //Writing a keyon to a 2nd address enables dual opl2 otherwise\n//            //Maybe also check for rhythm\n//            if ( header.hardware == HW_OPL2 && regFull >= 0x1b0 && regFull <=0x1b8 && val ) {\n//                header.hardware = HW_DUALOPL2;\n//            }\n//            /*Bit8u*/short raw = ToRaw[ regMask ];"}
{"magic_number_smell": "    static /*Bit16u*/int[] SinTable;\n\n    static {\n        if ( DBOPL_WAVE == 10 || DBOPL_WAVE == WAVE_TABLELOG)\n            ExpTable = new int[256];\n        if ( DBOPL_WAVE == 10 )\n            SinTable = new int[512]; //PI table used by WAVEHANDLER", "refactored_code": "    static private final int WAVE_HANDLER = 10;\n    static /*Bit16u*/int[] SinTable;\n\n    static {\n        if ( DBOPL_WAVE == WAVE_HANDLER || DBOPL_WAVE == WAVE_TABLELOG)\n            ExpTable = new int[256];\n        if ( DBOPL_WAVE == WAVE_HANDLER )\n            SinTable = new int[512]; //PI table used by WAVEHANDLER"}
{"magic_number_smell": "        config = (byte) 0x60; /* Implicit Seek, polling & fifo enabled */\n        state = CONTROL_ACTIVE;\n\n        fifo = new byte[512];\n    }\n\n    public void saveState(DataOutput output) throws IOException", "refactored_code": "    private static final int SECTOR_LENGTH = 512;\n        config = (byte) 0x60; /* Implicit Seek, polling & fifo enabled */\n        state = CONTROL_ACTIVE;\n\n        fifo = new byte[SECTOR_LENGTH];\n    }\n\n    public void saveState(DataOutput output) throws IOException"}
{"magic_number_smell": "    private static final Logger LOGGING = Logger.getLogger(PCSpeaker.class.getName());\n    \n    private static final int 22050 = 22050;\n    private static final int SPEAKER_MAX_FREQ = 22050 >> 1;\n    private static final int SPEAKER_MIN_FREQ = 10;\n    private static final int SPEAKER_VOLUME = 16000;\n    private static final int SPEAKER_OFF = 0, SPEAKER_ON = 2, SPEAKER_PIT_ON = 3, SPEAKER_PIT_OFF = 1;", "refactored_code": "    private static final int SPEAKER_SAMPLE_RATE = 22050;\n    private static final Logger LOGGING = Logger.getLogger(PCSpeaker.class.getName());\n    \n    private static final int SPEAKER_SAMPLE_RATE = 22050;\n    private static final int SPEAKER_MAX_FREQ = SPEAKER_SAMPLE_RATE >> 1;\n    private static final int SPEAKER_MIN_FREQ = 10;\n    private static final int SPEAKER_VOLUME = 16000;\n    private static final int SPEAKER_OFF = 0, SPEAKER_ON = 2, SPEAKER_PIT_ON = 3, SPEAKER_PIT_OFF = 1;"}
{"magic_number_smell": "//        for (i=0;i<ReadHandler.length;i++) {\n//            ReadHandler[i] = new IoHandler.IO_ReadHandleObject();\n//        }\n        sb.hw.base = Option.sbbase.intValue(0x220, 16);\n        sb.hw.irq = Option.sb_irq.intValue(IRQ);\n        /*Bitu*/int dma8bit = Option.sb_dma.intValue(DMA);\n        if (dma8bit>0xff) dma8bit=0xff;", "refactored_code": "    public static final int BASE = 0x220;\n//        for (i=0;i<ReadHandler.length;i++) {\n//            ReadHandler[i] = new IoHandler.IO_ReadHandleObject();\n//        }\n        sb.hw.base = Option.sbbase.intValue(BASE, 16);\n        sb.hw.irq = Option.sb_irq.intValue(IRQ);\n        /*Bitu*/int dma8bit = Option.sb_dma.intValue(DMA);\n        if (dma8bit>0xff) dma8bit=0xff;"}
{"magic_number_smell": "\n    public boolean isAccessed()\n    {\n        return (getType() & 0x1) != 0;\n    }\n\n    public boolean isConforming()", "refactored_code": "    public static final int TYPE_ACCESSED = 0x1;\n\n    public boolean isAccessed()\n    {\n        return (getType() & TYPE_ACCESSED) != 0;\n    }\n\n    public boolean isConforming()"}
{"magic_number_smell": "\n    public static Segment createProtectedModeSegment(AddressSpace memory, int selector, long descriptor, boolean isStack)\n    {\n        switch ((int) ((descriptor & (0x100000000000L | SEGMENT_TYPE)) >>> 40)) {\n\n            // System Segments \n            default:", "refactored_code": "    private static final long DESCRIPTOR_TYPE = 0x100000000000L;\n\n    public static Segment createProtectedModeSegment(AddressSpace memory, int selector, long descriptor, boolean isStack)\n    {\n        switch ((int) ((descriptor & (DESCRIPTOR_TYPE | SEGMENT_TYPE)) >>> 40)) {\n\n            // System Segments \n            default:"}
{"magic_number_smell": "            setStackFault();\n            conditionCode |= 2; // C1 set to indicate stack overflow\n            checkExceptions();\n            x = -1.5;\n        }\n        data[top] = x;\n        tag[top] = tagCode(x);", "refactored_code": "    public static final double DEFAULT_NAN = -1.5; // Double.longBitsToDouble(0xFFF8000000000000L);// to match Bochs' floatx80_default_nan truncation\n            setStackFault();\n            conditionCode |= 2; // C1 set to indicate stack overflow\n            checkExceptions();\n            x = DEFAULT_NAN;\n        }\n        data[top] = x;\n        tag[top] = tagCode(x);"}
{"magic_number_smell": "                JFrame help = new JFrame(\"JPC - Getting Started\");\n                help.setIconImage(Toolkit.getDefaultToolkit().getImage(ClassLoader.getSystemResource(\"resources/icon.png\")));\n                help.getContentPane().add(\"Center\", new JScrollPane(LICENCE));\n                help.setBounds(300, 200, 720 + 20, MONITOR_HEIGHT - 70);\n                help.setVisible(true);\n                getContentPane().validate();\n                getContentPane().repaint();", "refactored_code": "    private static final int MONITOR_WIDTH = 720;\n                JFrame help = new JFrame(\"JPC - Getting Started\");\n                help.setIconImage(Toolkit.getDefaultToolkit().getImage(ClassLoader.getSystemResource(\"resources/icon.png\")));\n                help.getContentPane().add(\"Center\", new JScrollPane(LICENCE));\n                help.setBounds(300, 200, MONITOR_WIDTH + 20, MONITOR_HEIGHT - 70);\n                help.setVisible(true);\n                getContentPane().validate();\n                getContentPane().repaint();"}
{"magic_number_smell": "        if (t2 - time < 100)\n            return false;\n        \n        //count = 10000000 - count;\n        float mhz = count * 1000.0F / (t2 - time) / 1000000;\n\n        speedDisplay.setValue((int)(mhz/1000));", "refactored_code": "    private static final int COUNTDOWN = 10000000;\n        if (t2 - time < 100)\n            return false;\n        \n        //count = COUNTDOWN - count;\n        float mhz = count * 1000.0F / (t2 - time) / 1000000;\n\n        speedDisplay.setValue((int)(mhz/1000));"}
{"magic_number_smell": "            if (nanoDelay > 0)\n            {\n                nanosToSleep += nanoDelay;\n                if (nanosToSleep > 10000000L) // don't waste time with loads of tiny sleeps (eg. mixer)\n                {\n                    try\n                    {", "refactored_code": "    private static final long MIN_SLEEP_NANOS = 10000000L; // 10 milli-seconds\n            if (nanoDelay > 0)\n            {\n                nanosToSleep += nanoDelay;\n                if (nanosToSleep > MIN_SLEEP_NANOS) // don't waste time with loads of tiny sleeps (eg. mixer)\n                {\n                    try\n                    {"}
{"magic_number_smell": "                        ((mbr[i + PART_SIZE + 2] & 0xff) << 16) |\n                        ((mbr[i + PART_SIZE + 3] & 0xff) << 24);\n                if (numberSectors != 0) {\n                    detectedHeads = 1 + (mbr[i + 0x5] & 0xff);\n                    detectedSectors = mbr[i + 0x5 + 1] & 0x3f;\n                    if (detectedSectors == 0) continue;\n                    detectedCylinders = (int) (this.getTotalSectors() / (detectedHeads * detectedSectors));", "refactored_code": "    private static final int PART_END_CHS = 0x5;\n                        ((mbr[i + PART_SIZE + 2] & 0xff) << 16) |\n                        ((mbr[i + PART_SIZE + 3] & 0xff) << 24);\n                if (numberSectors != 0) {\n                    detectedHeads = 1 + (mbr[i + PART_END_CHS] & 0xff);\n                    detectedSectors = mbr[i + PART_END_CHS + 1] & 0x3f;\n                    if (detectedSectors == 0) continue;\n                    detectedCylinders = (int) (this.getTotalSectors() / (detectedHeads * detectedSectors));"}
{"magic_number_smell": "\n    public RemoteSeekableIODevice(URI drive) throws IOException\n    {\n        this(drive, 4*1024, DEFAULT_CACHE_SIZE);\n    }\n\n    public RemoteSeekableIODevice(URI drive, int sectorSize, int cacheSize) throws IOException", "refactored_code": "    public static final int DEFAULT_SECTOR_SIZE = 4*1024;\n\n    public RemoteSeekableIODevice(URI drive) throws IOException\n    {\n        this(drive, DEFAULT_SECTOR_SIZE, DEFAULT_CACHE_SIZE);\n    }\n\n    public RemoteSeekableIODevice(URI drive, int sectorSize, int cacheSize) throws IOException"}
{"magic_number_smell": "    {\n        byte[] mbr = new byte[SECTOR_SIZE];\n        //partition table\n        mbr[PART_1 + 0x0] = (byte) 0x00;// 80 means system partition, 00 means do not use for booting\n\n        mbr[PART_1 + PART_START_CHS] = (byte) getHead(start);\n        mbr[PART_1 + PART_START_CHS + 1] = (byte) (((getCylinder(start) >> 2) & 0xC0) | (0x3F & getSector(start)));", "refactored_code": "    private static final int PART_BOOT = 0x0;\n    {\n        byte[] mbr = new byte[SECTOR_SIZE];\n        //partition table\n        mbr[PART_1 + PART_BOOT] = (byte) 0x00;// 80 means system partition, 00 means do not use for booting\n\n        mbr[PART_1 + PART_START_CHS] = (byte) getHead(start);\n        mbr[PART_1 + PART_START_CHS + 1] = (byte) (((getCylinder(start) >> 2) & 0xC0) | (0x3F & getSector(start)));"}
{"magic_number_smell": "            }\n            else\n            {\n                if (compareFlags && ((fast[i]&~0x000) != (old[i]&~0x000)))\n                {\n                    if (same)\n                    {", "refactored_code": "    public static final int flagMask = ~0x000; // OF IF\n            }\n            else\n            {\n                if (compareFlags && ((fast[i]&flagMask) != (old[i]&flagMask)))\n                {\n                    if (same)\n                    {"}
{"magic_number_smell": "            }\n            else\n            {\n                if (compareFlags && ((fast[i]&~0) != (old[i]&~0)))\n                {\n                    if (same)\n                    {", "refactored_code": "    public static final int flagMask = ~0;\n            }\n            else\n            {\n                if (compareFlags && ((fast[i]&flagMask) != (old[i]&flagMask)))\n                {\n                    if (same)\n                    {"}
{"magic_number_smell": "            inputState[13] = 0x5000; inputState[33] = inputState[13] << 4;// ss\n            inputState[14] = 0x6000; inputState[34] = inputState[14] << 4;// fs\n            inputState[15] = 0x7000; inputState[35] = inputState[15] << 4;// gs\n            // 1 segment limits (not used)\n            for (int i=0; i < 6; i++)\n                inputState[17 + i] = 0xffff;\n            inputState[25] = inputState[27] = inputState[29] = 0xffff;", "refactored_code": "    public static final int RM = 1;\n            inputState[13] = 0x5000; inputState[33] = inputState[13] << 4;// ss\n            inputState[14] = 0x6000; inputState[34] = inputState[14] << 4;// fs\n            inputState[15] = 0x7000; inputState[35] = inputState[15] << 4;// gs\n            // RM segment limits (not used)\n            for (int i=0; i < 6; i++)\n                inputState[17 + i] = 0xffff;\n            inputState[25] = inputState[27] = inputState[29] = 0xffff;"}
{"magic_number_smell": "    private static final long 0L = 0L;\n\n    public static class InvalidOptionException extends RuntimeException {\n        private static final long 0L = 0L;\n\n        public InvalidOptionException(String msg) {\n            super(msg);", "refactored_code": "    private static final long serialVersionUID = 0L;\n    private static final long serialVersionUID = 0L;\n\n    public static class InvalidOptionException extends RuntimeException {\n        private static final long serialVersionUID = 0L;\n\n        public InvalidOptionException(String msg) {\n            super(msg);"}
{"magic_number_smell": "    private static final long 0L = 0L;\n\n    public static final TypeSet EMPTY = new TypeSet() {\n            private static final long 0L = 0L;\n            @Override\n            public boolean add(IRubyObject type) {\n                throw new UnsupportedOperationException();", "refactored_code": "    private static final long serialVersionUID = 0L;\n    private static final long serialVersionUID = 0L;\n\n    public static final TypeSet EMPTY = new TypeSet() {\n            private static final long serialVersionUID = 0L;\n            @Override\n            public boolean add(IRubyObject type) {\n                throw new UnsupportedOperationException();"}
{"magic_number_smell": "    }\n\n    protected Node node;\n    protected int capacity = 5 + 1;\n    protected TypeSet typeSet;\n    protected IRubyObject singleType;\n    protected boolean megamorphic;", "refactored_code": "    public static final int MEGAMORPHIC_THRESHOLD = 5;\n    }\n\n    protected Node node;\n    protected int capacity = MEGAMORPHIC_THRESHOLD + 1;\n    protected TypeSet typeSet;\n    protected IRubyObject singleType;\n    protected boolean megamorphic;"}
{"magic_number_smell": "     */\n    public Biomorph(int[] genes)\n    {\n        if (genes.length != 9)\n        {\n            throw new IllegalArgumentException(\"Biomorph must have \" + 9 + \" genes.\");\n        }", "refactored_code": "    public static final int GENE_COUNT = 9;\n     */\n    public Biomorph(int[] genes)\n    {\n        if (genes.length != GENE_COUNT)\n        {\n            throw new IllegalArgumentException(\"Biomorph must have \" + GENE_COUNT + \" genes.\");\n        }"}
{"magic_number_smell": "\n    public static void main(String[] args)\n    {\n        evolveBits(20);\n    }\n\n", "refactored_code": "    private static final int BITS = 20;\n\n    public static void main(String[] args)\n    {\n        evolveBits(BITS);\n    }\n\n"}
{"magic_number_smell": "        {\n            this.rootNode = rootNode;\n            int minHeight = rootNode.getDepth() * NODE_HEIGHT;\n            int minWidth = rootNode.getWidth() * 30;\n            Dimension size = new Dimension(minWidth, minHeight);\n            setMinimumSize(size);\n            setPreferredSize(size);", "refactored_code": "        private static final int NODE_WIDTH = 30;\n        {\n            this.rootNode = rootNode;\n            int minHeight = rootNode.getDepth() * NODE_HEIGHT;\n            int minWidth = rootNode.getWidth() * NODE_WIDTH;\n            Dimension size = new Dimension(minWidth, minHeight);\n            setMinimumSize(size);\n            setPreferredSize(size);"}
{"magic_number_smell": "        ImageComponent(List<ColouredPolygon> candidate)\n        {\n            this.candidate = candidate;\n            this.minimumSize = new Dimension(targetImage.getWidth() * 2 + 10,\n                                             targetImage.getHeight() + FOOTER);\n        }\n", "refactored_code": "        private static final int GAP = 10;\n        ImageComponent(List<ColouredPolygon> candidate)\n        {\n            this.candidate = candidate;\n            this.minimumSize = new Dimension(targetImage.getWidth() * 2 + GAP,\n                                             targetImage.getHeight() + FOOTER);\n        }\n"}
{"magic_number_smell": "    /** The dimensions (in cells) of the puzzle square. */\n    public static final int 9 = 9;\n    private static final int MIN_VALUE = 1;\n    private static final int MAX_VALUE = 9;\n\n    private final Cell[][] cells;\n", "refactored_code": "    public static final int SIZE = 9;\n    /** The dimensions (in cells) of the puzzle square. */\n    public static final int SIZE = 9;\n    private static final int MIN_VALUE = 1;\n    private static final int MAX_VALUE = SIZE;\n\n    private final Cell[][] cells;\n"}
{"magic_number_smell": "        {\n            if (lastID == Integer.MAX_VALUE)\n            {\n                long hours = (System.currentTimeMillis() - startTime) / 3600L;\n                throw new IDSourceExhaustedException(\"32-bit ID source exhausted after \" + hours + \" hours.\");\n            }\n            ++lastID;", "refactored_code": "    private static final long SECONDS_IN_HOUR = 3600L;\n        {\n            if (lastID == Integer.MAX_VALUE)\n            {\n                long hours = (System.currentTimeMillis() - startTime) / SECONDS_IN_HOUR;\n                throw new IDSourceExhaustedException(\"32-bit ID source exhausted after \" + hours + \" hours.\");\n            }\n            ++lastID;"}
{"magic_number_smell": "        {\n            if (lastID == Long.MAX_VALUE)\n            {\n                long days = (System.currentTimeMillis() - startTime) / 86400;\n                throw new IDSourceExhaustedException(\"64-bit ID source exhausted after \" + days + \" days.\");\n            }\n            ++lastID;", "refactored_code": "    private static final int SECONDS_IN_DAY = 86400;\n        {\n            if (lastID == Long.MAX_VALUE)\n            {\n                long days = (System.currentTimeMillis() - startTime) / SECONDS_IN_DAY;\n                throw new IDSourceExhaustedException(\"64-bit ID source exhausted after \" + days + \" days.\");\n            }\n            ++lastID;"}
{"magic_number_smell": "    @Test\n    public void testUnseededPopulation()\n    {\n        CandidateFactory<BitString> factory = new BitStringFactory(10);\n        List<BitString> population = factory.generateInitialPopulation(populationSize, FrameworkTestUtils.getRNG());\n        validatePopulation(population);\n    }", "refactored_code": "    private final int candidateLength = 10;\n    @Test\n    public void testUnseededPopulation()\n    {\n        CandidateFactory<BitString> factory = new BitStringFactory(candidateLength);\n        List<BitString> population = factory.generateInitialPopulation(populationSize, FrameworkTestUtils.getRNG());\n        validatePopulation(population);\n    }"}
{"magic_number_smell": "{\n    private final int 10 = 10;\n    private final int populationSize = 5;\n    private final List<Integer> elements = new ArrayList<Integer>(10);\n    {\n        for (int i = 1; i <= 10; i++)\n        {", "refactored_code": "    private final int candidateLength = 10;\n{\n    private final int candidateLength = 10;\n    private final int populationSize = 5;\n    private final List<Integer> elements = new ArrayList<Integer>(candidateLength);\n    {\n        for (int i = 1; i <= candidateLength; i++)\n        {"}
{"magic_number_smell": "        assert population.size() == populationSize : \"Wrong size population generated: \" + population.size();\n        for (Integer[] candidate : population)\n        {\n            assert candidate.length == 10 : \"Wrong size candidate generated: \" + candidate.length;\n            for (int i = 1; i < 10; i++)\n            {\n                assert contains(candidate, i) : \"Candidate is missing element \" + i + \".\";", "refactored_code": "    private final int candidateLength = 10;\n        assert population.size() == populationSize : \"Wrong size population generated: \" + population.size();\n        for (Integer[] candidate : population)\n        {\n            assert candidate.length == candidateLength : \"Wrong size candidate generated: \" + candidate.length;\n            for (int i = 1; i < candidateLength; i++)\n            {\n                assert contains(candidate, i) : \"Candidate is missing element \" + i + \".\";"}
{"magic_number_smell": "    @Test\n    public void testUnseededPopulation()\n    {\n        CandidateFactory<String> factory = new StringFactory(alphabet, 8);\n        List<String> population = factory.generateInitialPopulation(populationSize, FrameworkTestUtils.getRNG());\n        assert population.size() == populationSize : \"Wrong size population generated: \" + population.size();\n", "refactored_code": "    private final int candidateLength = 8;\n    @Test\n    public void testUnseededPopulation()\n    {\n        CandidateFactory<String> factory = new StringFactory(alphabet, candidateLength);\n        List<String> population = factory.generateInitialPopulation(populationSize, FrameworkTestUtils.getRNG());\n        assert population.size() == populationSize : \"Wrong size population generated: \" + population.size();\n"}
{"magic_number_smell": "    JVMView()\n    {\n        super(new BorderLayout());\n        double maxMemory = (double) memoryBean.getHeapMemoryUsage().getMax() / 1048576;\n\n        ChartPanel heapPanel = new ChartPanel(createHeapChart(maxMemory),\n                                              false, // Properties", "refactored_code": "    private static final int MEGABYTE = 1048576;\n    JVMView()\n    {\n        super(new BorderLayout());\n        double maxMemory = (double) memoryBean.getHeapMemoryUsage().getMax() / MEGABYTE;\n\n        ChartPanel heapPanel = new ChartPanel(createHeapChart(maxMemory),\n                                              false, // Properties"}
{"magic_number_smell": "        domainAxis.setStandardTickUnits(NumberAxis.createIntegerTickUnits());\n        domainAxis.setLowerMargin(0);\n        domainAxis.setUpperMargin(0.05);\n        domainAxis.setRangeWithMargins(0, 200);\n        rangeAxis.setRange(minY, maxY);\n        ChartPanel chartPanel = new ChartPanel(chart,\n                                               ChartPanel.DEFAULT_WIDTH,", "refactored_code": "    private static final int SHOW_FIXED_GENERATIONS = 200;\n        domainAxis.setStandardTickUnits(NumberAxis.createIntegerTickUnits());\n        domainAxis.setLowerMargin(0);\n        domainAxis.setUpperMargin(0.05);\n        domainAxis.setRangeWithMargins(0, SHOW_FIXED_GENERATIONS);\n        rangeAxis.setRange(minY, maxY);\n        ChartPanel chartPanel = new ChartPanel(chart,\n                                               ChartPanel.DEFAULT_WIDTH,"}
{"magic_number_smell": "\t\tfinal boolean debugLog = sDebugLogSettings == null ? true : sDebugLogSettings\n\t\t\t\t.isDebugLogEnabled();\n\n\t\tif (record.getLevel().intValue() <= Level.FINE.intValue()) {\n\t\t\treturn debugLog;\n\t\t}\n\t\treturn true;", "refactored_code": "\tprivate static final int FINE_INT = Level.FINE.intValue();\n\t\tfinal boolean debugLog = sDebugLogSettings == null ? true : sDebugLogSettings\n\t\t\t\t.isDebugLogEnabled();\n\n\t\tif (record.getLevel().intValue() <= FINE_INT) {\n\t\t\treturn debugLog;\n\t\t}\n\t\treturn true;"}
{"magic_number_smell": "    private static final int READ_TIMEOUT_MS = 60000;\n\n    private static final OkHttpClient CLIENT = new OkHttpClient.Builder()\n        .connectTimeout(30000, TimeUnit.MILLISECONDS)\n        .readTimeout(READ_TIMEOUT_MS, TimeUnit.MILLISECONDS)\n        .build();\n", "refactored_code": "    private static final int CONNECT_TIMEOUT_MS = 30000;\n    private static final int READ_TIMEOUT_MS = 60000;\n\n    private static final OkHttpClient CLIENT = new OkHttpClient.Builder()\n        .connectTimeout(CONNECT_TIMEOUT_MS, TimeUnit.MILLISECONDS)\n        .readTimeout(READ_TIMEOUT_MS, TimeUnit.MILLISECONDS)\n        .build();\n"}
{"magic_number_smell": "     *\n     */\n    public MoveRunner(final List<FileMover> episodes) {\n        this(episodes, null, 120);\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_TIMEOUT = 120;\n     *\n     */\n    public MoveRunner(final List<FileMover> episodes) {\n        this(episodes, null, DEFAULT_TIMEOUT);\n    }\n\n    /**"}
{"magic_number_smell": "    // in the show's catalog, the file does not need to actually be present.\n    private Path pathObj;\n    private String fileNameString;\n    private long fileSize = -1L;\n\n    // After we've looked up the filenameShow from the provider, we try to get a Show from\n    // the provider.  If we do not find any options, or if there is any kind of error", "refactored_code": "    private static final long NO_FILE_SIZE = -1L;\n    // in the show's catalog, the file does not need to actually be present.\n    private Path pathObj;\n    private String fileNameString;\n    private long fileSize = NO_FILE_SIZE;\n\n    // After we've looked up the filenameShow from the provider, we try to get a Show from\n    // the provider.  If we do not find any options, or if there is any kind of error"}
{"magic_number_smell": "                logger.log(Level.WARNING, \"Exception trying to close version file\", ioe);\n            }\n        }\n        if (bytesRead < 3) {\n            throw new RuntimeException(\"Unable to extract version from version file\");\n        }\n        return StringUtils.makeString(buffer).trim();", "refactored_code": "    private static final int MIN_BYTES_FOR_VERSION = 3;\n                logger.log(Level.WARNING, \"Exception trying to close version file\", ioe);\n            }\n        }\n        if (bytesRead < MIN_BYTES_FOR_VERSION) {\n            throw new RuntimeException(\"Unable to extract version from version file\");\n        }\n        return StringUtils.makeString(buffer).trim();"}
{"magic_number_smell": "\n        // Create the About <application-name> menu command\n        Object aboutMenuItem =\n            invoke(nsmenuCls, appMenu, \"itemAtIndex\", new Object[] { wrapPointer(0) });\n        Object nsStr = invoke(nsstringCls, \"stringWith\", new Object[] { \"About \" + appName });\n        invoke(nsmenuitemCls, aboutMenuItem, \"setTitle\", new Object[] { nsStr });\n        // Rename the quit action.", "refactored_code": "    private static final long kAboutMenuItem = 0;\n\n        // Create the About <application-name> menu command\n        Object aboutMenuItem =\n            invoke(nsmenuCls, appMenu, \"itemAtIndex\", new Object[] { wrapPointer(kAboutMenuItem) });\n        Object nsStr = invoke(nsstringCls, \"stringWith\", new Object[] { \"About \" + appName });\n        invoke(nsmenuitemCls, aboutMenuItem, \"setTitle\", new Object[] { nsStr });\n        // Rename the quit action."}
{"magic_number_smell": "\n    private void createDragSource(final List sourceList) {\n        Transfer[] types = new Transfer[] { TextTransfer.getInstance() };\n        DragSource dragSource = new DragSource(sourceList, DND.DROP_MOVE);\n        dragSource.setTransfer(types);\n        dragSource.addDragListener(new PreferencesDragSourceListener(sourceList));\n    }", "refactored_code": "    private static final int DND_OPERATIONS = DND.DROP_MOVE;\n\n    private void createDragSource(final List sourceList) {\n        Transfer[] types = new Transfer[] { TextTransfer.getInstance() };\n        DragSource dragSource = new DragSource(sourceList, DND_OPERATIONS);\n        dragSource.setTransfer(types);\n        dragSource.addDragListener(new PreferencesDragSourceListener(sourceList));\n    }"}
{"magic_number_smell": "        } catch (IllegalArgumentException | SWTException ignored) {\n            // We'll just fall through and return the sentinel.\n        }\n        return -1;\n    }\n\n    private boolean tableContainsTableItem(final TableItem item) {", "refactored_code": "    private static final int ITEM_NOT_IN_TABLE = -1;\n        } catch (IllegalArgumentException | SWTException ignored) {\n            // We'll just fall through and return the sentinel.\n        }\n        return ITEM_NOT_IN_TABLE;\n    }\n\n    private boolean tableContainsTableItem(final TableItem item) {"}
{"magic_number_smell": "\t\tthis.timein = timein;\n\t\tthis.ttl = ttl;\n\t\tlong unsafeZone = (long) (ttl * (1 - RenderResultCache.SAFE_TIME_ZONE));\n\t\tif (unsafeZone < 1000) {\n\t\t\t// make a minimum 1s alert advance\n\t\t\tsafeBefore = timein + ttl - 1000;\n\t\t}", "refactored_code": "\tprivate static final int MIN_ALERT_ADVANCE = 1000;\n\t\tthis.timein = timein;\n\t\tthis.ttl = ttl;\n\t\tlong unsafeZone = (long) (ttl * (1 - RenderResultCache.SAFE_TIME_ZONE));\n\t\tif (unsafeZone < MIN_ALERT_ADVANCE) {\n\t\t\t// make a minimum 1s alert advance\n\t\t\tsafeBefore = timein + ttl - MIN_ALERT_ADVANCE;\n\t\t}"}
{"magic_number_smell": "\t\t\t\tr.path = pathSpec + paramNames + pathEnding;\n\t\t\t\tr.action = act;\n\t\t\t\tr.routesFile = \"_autopath\";\n\t\t\t\tr.routesFileLine = -1;\n\t\t\t\tr.compute();\n\t\t\t\troutes.add(r);\n", "refactored_code": "\tpublic static final int AUTO_ROUTE_LINE = -1;\n\t\t\t\tr.path = pathSpec + paramNames + pathEnding;\n\t\t\t\tr.action = act;\n\t\t\t\tr.routesFile = \"_autopath\";\n\t\t\t\tr.routesFileLine = AUTO_ROUTE_LINE;\n\t\t\t\tr.compute();\n\t\t\t\troutes.add(r);\n"}
{"magic_number_smell": "\t\tString holder = \"\";\n\t\tint i = 0;\n\t\tlong t = System.currentTimeMillis();\n\t\twhile (i++ < 10000) {\n\t\t\tStackTraceElement[] ste = new Throwable().getStackTrace();\n\t\t\tholder = ste[2].getClassName();\n\t\t\tholder += ste[2].getMethodName();", "refactored_code": "\tprivate static final int LOOPS = 10000;\n\t\tString holder = \"\";\n\t\tint i = 0;\n\t\tlong t = System.currentTimeMillis();\n\t\twhile (i++ < LOOPS) {\n\t\t\tStackTraceElement[] ste = new Throwable().getStackTrace();\n\t\t\tholder = ste[2].getClassName();\n\t\t\tholder += ste[2].getMethodName();"}
{"magic_number_smell": "  @Override\n  protected void compute() { }\n /** \n    if ((high - low) < 500) {\n      try {\n        for (int i = low; i < high; ++i) {\n          generatePut(this.inputTerms[i]);", "refactored_code": "  private static final int THRESHOLD = 500;\n  @Override\n  protected void compute() { }\n /** \n    if ((high - low) < THRESHOLD) {\n      try {\n        for (int i = low; i < high; ++i) {\n          generatePut(this.inputTerms[i]);"}
{"magic_number_smell": "    docMap.put(key, new SortFieldDoc(doc, currentScore, 1));\n    // TODO: only 1 sort field under consideration now\n    ++pendingDocs;\n    if (this.pendingDocs == 1000) {\n      this.appendToPQ();\n      this.pendingDocs = 0;\n    }", "refactored_code": "  private static final int DOCS_THRESHOLD = 1000;\n    docMap.put(key, new SortFieldDoc(doc, currentScore, 1));\n    // TODO: only 1 sort field under consideration now\n    ++pendingDocs;\n    if (this.pendingDocs == DOCS_THRESHOLD) {\n      this.appendToPQ();\n      this.pendingDocs = 0;\n    }"}
{"magic_number_smell": "    // TEST_UTIL.startMiniCluster(1);\n    HBaseIndexStore.dropLuceneIndexTable(TEST_INDEX, conf);\n    HBaseIndexStore.createLuceneIndexTable(TEST_INDEX, conf, true);\n    this.tablePool = new HTablePool(conf, 20);\n    HBaseIndexStore hbaseIndex = new HBaseIndexStore(this.tablePool, conf, TEST_INDEX);\n\n    this.indexWriter = new HBaseIndexWriter(hbaseIndex, PK_FIELD);", "refactored_code": "  protected static final int DEFAULT_POOL_SIZE = 20;\n    // TEST_UTIL.startMiniCluster(1);\n    HBaseIndexStore.dropLuceneIndexTable(TEST_INDEX, conf);\n    HBaseIndexStore.createLuceneIndexTable(TEST_INDEX, conf, true);\n    this.tablePool = new HTablePool(conf, DEFAULT_POOL_SIZE);\n    HBaseIndexStore hbaseIndex = new HBaseIndexStore(this.tablePool, conf, TEST_INDEX);\n\n    this.indexWriter = new HBaseIndexWriter(hbaseIndex, PK_FIELD);"}
{"magic_number_smell": "\t */\n\tpublic DHGexParameters(int pref_group_len)\n\t{\n\t\tif ((pref_group_len < 1024) || (pref_group_len > MAX_ALLOWED))\n\t\t\tthrow new IllegalArgumentException(\"pref_group_len out of range!\");\n\n\t\tthis.pref_group_len = pref_group_len;", "refactored_code": "\tprivate static final int MIN_ALLOWED = 1024;\n\t */\n\tpublic DHGexParameters(int pref_group_len)\n\t{\n\t\tif ((pref_group_len < MIN_ALLOWED) || (pref_group_len > MAX_ALLOWED))\n\t\t\tthrow new IllegalArgumentException(\"pref_group_len out of range!\");\n\n\t\tthis.pref_group_len = pref_group_len;"}
{"magic_number_smell": "\t\t\t\tboolean res = matchKeys(ke.key, remoteKey);\n\n\t\t\t\tif (res)\n\t\t\t\t\treturn 0;\n\n\t\t\t\tresult = HOSTKEY_HAS_CHANGED;\n\t\t\t}", "refactored_code": "\tpublic static final int HOSTKEY_IS_OK = 0;\n\t\t\t\tboolean res = matchKeys(ke.key, remoteKey);\n\n\t\t\t\tif (res)\n\t\t\t\t\treturn HOSTKEY_IS_OK;\n\n\t\t\t\tresult = HOSTKEY_HAS_CHANGED;\n\t\t\t}"}
{"magic_number_smell": "\t{\n\t\tsynchronized (packets)\n\t\t{\n\t\t\tlong waitUntil = System.currentTimeMillis() + Long.valueOf(System.getProperty(PROPERTY_TIMEOUT,\"120000\"));\n\t\t\tlong now = System.currentTimeMillis();\n\n\t\t\twhile (packets.size() == 0 && now < waitUntil)", "refactored_code": "\tpublic static final long TIMEOUT = Long.valueOf(System.getProperty(PROPERTY_TIMEOUT,\"120000\"));\n\t{\n\t\tsynchronized (packets)\n\t\t{\n\t\t\tlong waitUntil = System.currentTimeMillis() + TIMEOUT;\n\t\t\tlong now = System.currentTimeMillis();\n\n\t\t\twhile (packets.size() == 0 && now < waitUntil)"}
{"magic_number_smell": "\t\t\tif (line.startsWith(\"-----BEGIN RSA PRIVATE KEY-----\"))\n\t\t\t{\n\t\t\t\tendLine = \"-----END RSA PRIVATE KEY-----\";\n\t\t\t\tps.pemType = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}", "refactored_code": "\tprivate static final int PEM_RSA_PRIVATE_KEY = 1;\n\t\t\tif (line.startsWith(\"-----BEGIN RSA PRIVATE KEY-----\"))\n\t\t\t{\n\t\t\t\tendLine = \"-----END RSA PRIVATE KEY-----\";\n\t\t\t\tps.pemType = PEM_RSA_PRIVATE_KEY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}"}
{"magic_number_smell": "\n\tprivate final int FFmulX(int x)\n\t{\n\t\treturn (((x & m2) << 1) ^ (((x & 0x80808080) >>> 7) * m3));\n\t}\n\n\t/*", "refactored_code": "\tprivate static final int m1 = 0x80808080;\n\n\tprivate final int FFmulX(int x)\n\t{\n\t\treturn (((x & m2) << 1) ^ (((x & m1) >>> 7) * m3));\n\t}\n\n\t/*"}
{"magic_number_smell": "\tprivate static final int 16 = 16;\n\tprivate static final int BLOCK_SIZE = 8; // bytes = 64 bits\n\tprivate static final int SBOX_SK = 256;\n\tprivate static final int P_SZ = 16 + 2;\n\n\tprivate final int[] S0, S1, S2, S3; // the s-boxes\n\tprivate final int[] P; // the p-array", "refactored_code": "\tprivate static final int ROUNDS = 16;\n\tprivate static final int ROUNDS = 16;\n\tprivate static final int BLOCK_SIZE = 8; // bytes = 64 bits\n\tprivate static final int SBOX_SK = 256;\n\tprivate static final int P_SZ = ROUNDS + 2;\n\n\tprivate final int[] S0, S1, S2, S3; // the s-boxes\n\tprivate final int[] P; // the p-array"}
{"magic_number_smell": "\t * Used to test known vectors.\n\t */\n\tpublic Curve25519Exchange(byte[] secret) throws InvalidKeyException {\n\t\tif (secret.length != 32) {\n\t\t\tthrow new AssertionError(\"secret must be key size\");\n\t\t}\n\t\tclientPrivate = secret.clone();", "refactored_code": "\tpublic static final int KEY_SIZE = 32;\n\t * Used to test known vectors.\n\t */\n\tpublic Curve25519Exchange(byte[] secret) throws InvalidKeyException {\n\t\tif (secret.length != KEY_SIZE) {\n\t\t\tthrow new AssertionError(\"secret must be key size\");\n\t\t}\n\t\tclientPrivate = secret.clone();"}
{"magic_number_smell": "\n\tstatic\n\t{\n\t\treverseNames[1] = \"1\";\n\t\treverseNames[2] = \"SSH_MSG_IGNORE\";\n\t\treverseNames[3] = \"SSH_MSG_UNIMPLEMENTED\";\n\t\treverseNames[4] = \"SSH_MSG_DEBUG\";", "refactored_code": "\tpublic static final int SSH_MSG_DISCONNECT = 1;\n\n\tstatic\n\t{\n\t\treverseNames[1] = \"SSH_MSG_DISCONNECT\";\n\t\treverseNames[2] = \"SSH_MSG_IGNORE\";\n\t\treverseNames[3] = \"SSH_MSG_UNIMPLEMENTED\";\n\t\treverseNames[4] = \"SSH_MSG_DEBUG\";"}
{"magic_number_smell": "\t * to this file, and no data can be written to the file.\n\t * <p>\n\t * This bit implies a stronger level of protection than\n\t * 0x00000001, the file permission mask or ACLs.\n\t * Typically even the superuser cannot write to immutable files, and\n\t * only the superuser can set or remove the bit.\n\t */", "refactored_code": "\tpublic static final int SSH_FILEXFER_ATTR_FLAGS_READONLY = 0x00000001;\n\t * to this file, and no data can be written to the file.\n\t * <p>\n\t * This bit implies a stronger level of protection than\n\t * SSH_FILEXFER_ATTR_FLAGS_READONLY, the file permission mask or ACLs.\n\t * Typically even the superuser cannot write to immutable files, and\n\t * only the superuser can set or remove the bit.\n\t */"}
{"magic_number_smell": "\n\tprivate static final String[][] messages = {\n\n\t\t\t{ \"0\", \"Indicates successful completion of the operation.\" },\n\t\t\t{ \"SSH_FX_EOF\",\n\t\t\t\t\t\"An attempt to read past the end-of-file was made; or, there are no more directory entries to return.\" },\n\t\t\t{ \"SSH_FX_NO_SUCH_FILE\", \"A reference was made to a file which does not exist.\" },", "refactored_code": "\tpublic static final int SSH_FX_OK = 0;\n\n\tprivate static final String[][] messages = {\n\n\t\t\t{ \"SSH_FX_OK\", \"Indicates successful completion of the operation.\" },\n\t\t\t{ \"SSH_FX_EOF\",\n\t\t\t\t\t\"An attempt to read past the end-of-file was made; or, there are no more directory entries to return.\" },\n\t\t\t{ \"SSH_FX_NO_SUCH_FILE\", \"A reference was made to a file which does not exist.\" },"}
{"magic_number_smell": "\n        writeLength(totalLength - 2, os);\n\n        os.write(0x02);\n        writeLength(rLength, os);\n        if (rLength != r.length) {\n            os.write(ANS1_ZERO);", "refactored_code": "    private static final byte ANS1_INTEGER = 0x02;\n\n        writeLength(totalLength - 2, os);\n\n        os.write(ANS1_INTEGER);\n        writeLength(rLength, os);\n        if (rLength != r.length) {\n            os.write(ANS1_ZERO);"}
{"magic_number_smell": "    @Test\n    public void connectionTest() throws Exception {\n        SFTPClient sftpClient = new SFTPClient(con.getConnection());\n        sftpClient.mkdirs(TMP_TEST, 0700);\n\n        OutputStream out = sftpClient.writeToFile(PATH_FILE);\n        assertNotNull(out);", "refactored_code": "    public static final int POSIX_PERMISSION = 0700;\n    @Test\n    public void connectionTest() throws Exception {\n        SFTPClient sftpClient = new SFTPClient(con.getConnection());\n        sftpClient.mkdirs(TMP_TEST, POSIX_PERMISSION);\n\n        OutputStream out = sftpClient.writeToFile(PATH_FILE);\n        assertNotNull(out);"}
{"magic_number_smell": "        String publicKey = IOUtils.toString(getClass().getResourceAsStream(\"../crypto/cipher/key.pem.pub\"));\n        String privateKey =  IOUtils.toString(getClass().getResourceAsStream(\"../crypto/cipher/key.pem\"));\n        sshContainer.withEnv(\"JENKINS_AGENT_SSH_PUBKEY\", publicKey)\n                    .withExposedPorts(22)\n                    .start();\n\n        int port = sshContainer.getMappedPort(22);", "refactored_code": "    public static final int SSH_PORT = 22;\n        String publicKey = IOUtils.toString(getClass().getResourceAsStream(\"../crypto/cipher/key.pem.pub\"));\n        String privateKey =  IOUtils.toString(getClass().getResourceAsStream(\"../crypto/cipher/key.pem\"));\n        sshContainer.withEnv(\"JENKINS_AGENT_SSH_PUBKEY\", publicKey)\n                    .withExposedPorts(SSH_PORT)\n                    .start();\n\n        int port = sshContainer.getMappedPort(SSH_PORT);"}
{"magic_number_smell": "\n        prefsNoAds = DonationHelper.hideAds(this);\n\t\tif (!prefsNoAds) {\n\t\t\tfinal long random = System.currentTimeMillis() % 7;\n\t\t\tprefsInterstitialAd = random == 0 && !p.getBoolean(PREFS_AUTOEXIT, false);\n\t\t}\n\t\tthis.setButtons();", "refactored_code": "\tprivate static final int INTERSTITIAL_ADS_RATION = 7;\n\n        prefsNoAds = DonationHelper.hideAds(this);\n\t\tif (!prefsNoAds) {\n\t\t\tfinal long random = System.currentTimeMillis() % INTERSTITIAL_ADS_RATION;\n\t\t\tprefsInterstitialAd = random == 0 && !p.getBoolean(PREFS_AUTOEXIT, false);\n\t\t}\n\t\tthis.setButtons();"}
{"magic_number_smell": "                final Vibrator v = (Vibrator) context\n                        .getSystemService(Context.VIBRATOR_SERVICE);\n                if (v != null) {\n                    v.vibrate(100L);\n                    v.cancel();\n                }\n            }", "refactored_code": "    private static final long VIBRATOR_SEND = 100L;\n                final Vibrator v = (Vibrator) context\n                        .getSystemService(Context.VIBRATOR_SERVICE);\n                if (v != null) {\n                    v.vibrate(VIBRATOR_SEND);\n                    v.cancel();\n                }\n            }"}
{"magic_number_smell": "            getListener().onConfirmOk(dialogId);\n        } else if (actionOnDismiss == ACTION_CANCEL) {\n            getListener().onConfirmCancelled(dialogId);\n        } else if (actionOnDismiss == 0) {\n            // nothing to do\n        }\n        super.onCancel(dialog);", "refactored_code": "    public static final int ACTION_NONE   = 0;\n            getListener().onConfirmOk(dialogId);\n        } else if (actionOnDismiss == ACTION_CANCEL) {\n            getListener().onConfirmCancelled(dialogId);\n        } else if (actionOnDismiss == ACTION_NONE) {\n            // nothing to do\n        }\n        super.onCancel(dialog);"}
{"magic_number_smell": "                startActivityForResult(\n                        EditRuleActivity.createStartIntent(getActivity().getApplicationContext(),\n                                -1, null),\n                        1001);\n                return true;\n            case R.id.cancel:\n                // finish without saving the rules", "refactored_code": "    private static final int REQ_CODE_NEW  = 1001;\n                startActivityForResult(\n                        EditRuleActivity.createStartIntent(getActivity().getApplicationContext(),\n                                -1, null),\n                        REQ_CODE_NEW);\n                return true;\n            case R.id.cancel:\n                // finish without saving the rules"}
{"magic_number_smell": "    }\n\n    public int getOffsetFromText() {\n        return OFFSET_FROM_TEXT+9/2;\n    }\n\n    @Override", "refactored_code": "    private static final int FOLDING_ICON_WIDTH = 9;\n    }\n\n    public int getOffsetFromText() {\n        return OFFSET_FROM_TEXT+FOLDING_ICON_WIDTH/2;\n    }\n\n    @Override"}
{"magic_number_smell": "            g.setColor(c);\n\n            switch(shape) {\n                case 1: {\n                    int width = r2.x-r1.x;\n                    int triangle_size = 5;\n                    for(int triangle=0; triangle<width/triangle_size; triangle++) {", "refactored_code": "    public static final int SHAPE_SAW_TOOTH = 1;\n            g.setColor(c);\n\n            switch(shape) {\n                case SHAPE_SAW_TOOTH: {\n                    int width = r2.x-r1.x;\n                    int triangle_size = 5;\n                    for(int triangle=0; triangle<width/triangle_size; triangle++) {"}
{"magic_number_smell": "        int sp = position;\n        while(nextCharacter()) {\n            if((c0 == '\\'' || matchNewLine()) && !controlCharacter) {\n                return createNewToken(1, sp);\n            }\n        }\n        return null;", "refactored_code": "    public static final int TOKEN_SINGLE_QUOTE_STRING = 1;\n        int sp = position;\n        while(nextCharacter()) {\n            if((c0 == '\\'' || matchNewLine()) && !controlCharacter) {\n                return createNewToken(TOKEN_SINGLE_QUOTE_STRING, sp);\n            }\n        }\n        return null;"}
{"magic_number_smell": "        } else {\n            tabs.remove(index);\n            tabs.add(index, tab);\n            bottomTab.removeTabAt(index+4);\n            bottomTab.insertTab(tab.getTabName(), null, tab.getTabComponent(), null, index+4);\n        }\n", "refactored_code": "    private static final int CLOSING_INDEX_LIMIT = 4;\n        } else {\n            tabs.remove(index);\n            tabs.add(index, tab);\n            bottomTab.removeTabAt(index+CLOSING_INDEX_LIMIT);\n            bottomTab.insertTab(tab.getTabName(), null, tab.getTabComponent(), null, index+CLOSING_INDEX_LIMIT);\n        }\n"}
{"magic_number_smell": "    }\n\n    public void customizeFileMenu(XJMenu menu) {\n        menu.insertItemAfter(new XJMenuItem(resourceBundle.getString(\"menu.item.print\"), KeyEvent.VK_P, 5, this), XJMainMenuBar.MI_SAVEAS);\n        menu.insertSeparatorAfter(XJMainMenuBar.MI_SAVEAS);\n\n        XJMenu exportMenu = new XJMenu();", "refactored_code": "    public static final int MI_PRINT = 5;\n    }\n\n    public void customizeFileMenu(XJMenu menu) {\n        menu.insertItemAfter(new XJMenuItem(resourceBundle.getString(\"menu.item.print\"), KeyEvent.VK_P, MI_PRINT, this), XJMainMenuBar.MI_SAVEAS);\n        menu.insertSeparatorAfter(XJMainMenuBar.MI_SAVEAS);\n\n        XJMenu exportMenu = new XJMenu();"}
{"magic_number_smell": "\n    public static String getEventName(int type) {\n        switch(type) {\n            case -1: return \"-\";\n            case CONSUME_TOKEN: return \"Consume\";\n            case CONSUME_HIDDEN_TOKEN: return \"Consume hidden\";\n            case ENTER_RULE:    return \"Enter rule\";", "refactored_code": "    public static final int NO_EVENT = -1;\n\n    public static String getEventName(int type) {\n        switch(type) {\n            case NO_EVENT: return \"-\";\n            case CONSUME_TOKEN: return \"Consume\";\n            case CONSUME_HIDDEN_TOKEN: return \"Consume hidden\";\n            case ENTER_RULE:    return \"Enter rule\";"}
{"magic_number_smell": "\n    public DBEventRewind() {\n        super(REWIND);\n        this.id = Integer.MIN_VALUE;\n    }\n\n    public boolean rewindToLastMark() {", "refactored_code": "    public static final int REWIND_TO_LAST_MARK = Integer.MIN_VALUE;\n\n    public DBEventRewind() {\n        super(REWIND);\n        this.id = REWIND_TO_LAST_MARK;\n    }\n\n    public boolean rewindToLastMark() {"}
{"magic_number_smell": "\n        public String getColumnName(int column) {\n            switch(column) {\n                case 0: return \"#\";\n                case INFO_COLUMN_EVENT: return \"Event\";\n                case INFO_COLUMN_SUBRULE: return \"Subrule\";\n                case INFO_COLUMN_DECISION: return \"Decision\";", "refactored_code": "    public static final int INFO_COLUMN_COUNT = 0;\n\n        public String getColumnName(int column) {\n            switch(column) {\n                case INFO_COLUMN_COUNT: return \"#\";\n                case INFO_COLUMN_EVENT: return \"Event\";\n                case INFO_COLUMN_SUBRULE: return \"Subrule\";\n                case INFO_COLUMN_DECISION: return \"Decision\";"}
{"magic_number_smell": "\n        public String getColumnName(int column) {\n            switch(column) {\n                case DBStackPanel.0: return \"#\";\n                case DBStackPanel.INFO_COLUMN_RULE: return \"Rule\";\n            }\n            return super.getColumnName(column);", "refactored_code": "    public static final int INFO_COLUMN_COUNT = 0;\n\n        public String getColumnName(int column) {\n            switch(column) {\n                case DBStackPanel.INFO_COLUMN_COUNT: return \"#\";\n                case DBStackPanel.INFO_COLUMN_RULE: return \"Rule\";\n            }\n            return super.getColumnName(column);"}
{"magic_number_smell": "    public static final int MAX_RETRY = 12;\n\n    protected DebuggerTab debuggerTab;\n    protected int status = 0;\n    protected boolean cancelled;\n\n\tpublic static class FixBugRemoteDebugEventSocketListener", "refactored_code": "    public static final int STATUS_STOPPED = 0;\n    public static final int MAX_RETRY = 12;\n\n    protected DebuggerTab debuggerTab;\n    protected int status = STATUS_STOPPED;\n    protected boolean cancelled;\n\n\tpublic static class FixBugRemoteDebugEventSocketListener"}
{"magic_number_smell": "    }\n\n    public void dialogWillDisplay() {\n        guiManager = new StatisticsManager(StatisticsReporter.0);\n        grammarManager = new StatisticsManager(StatisticsReporter.TYPE_GRAMMAR);\n        runtimeManager = new StatisticsManager(StatisticsReporter.TYPE_RUNTIME);\n", "refactored_code": "    public static final int TYPE_GUI = 0;\n    }\n\n    public void dialogWillDisplay() {\n        guiManager = new StatisticsManager(StatisticsReporter.TYPE_GUI);\n        grammarManager = new StatisticsManager(StatisticsReporter.TYPE_GRAMMAR);\n        runtimeManager = new StatisticsManager(StatisticsReporter.TYPE_RUNTIME);\n"}
{"magic_number_smell": "\n    private String getGrammarType() {\n        switch (grammarTypeComboBox.getSelectedIndex()) {\n            case 0:\n                return \"parser grammar\";\n            case GRAMMAR_TYPE_LEXER:\n                return \"lexer grammar\";", "refactored_code": "    public static final int GRAMMAR_TYPE_PARSER = 0;\n\n    private String getGrammarType() {\n        switch (grammarTypeComboBox.getSelectedIndex()) {\n            case GRAMMAR_TYPE_PARSER:\n                return \"parser grammar\";\n            case GRAMMAR_TYPE_LEXER:\n                return \"lexer grammar\";"}
{"magic_number_smell": "    }\n\n    public int[] getAvailableTypes() {\n        return new int[] { ANALYSIS_ITEM_WARNING, 0, ANALYSIS_ITEM_OTHER };\n    }\n\n    public List<ATEAnalysisItem> getItemsForType(int type) {", "refactored_code": "    protected static final int ANALYSIS_ITEM_ERROR = 0;\n    }\n\n    public int[] getAvailableTypes() {\n        return new int[] { ANALYSIS_ITEM_WARNING, ANALYSIS_ITEM_ERROR, ANALYSIS_ITEM_OTHER };\n    }\n\n    public List<ATEAnalysisItem> getItemsForType(int type) {"}
{"magic_number_smell": "    public ATEFoldingEntityProxy createEntityProxy(ATEFoldingEntity entity) {\n        int tag;\n        if(entity instanceof ElementRule)\n            tag = 0;\n        else if(entity instanceof ElementAction)\n            tag = TAG_ACTIONS;\n        else", "refactored_code": "    protected static final int TAG_RULES = 0;\n    public ATEFoldingEntityProxy createEntityProxy(ATEFoldingEntity entity) {\n        int tag;\n        if(entity instanceof ElementRule)\n            tag = TAG_RULES;\n        else if(entity instanceof ElementAction)\n            tag = TAG_ACTIONS;\n        else"}
{"magic_number_smell": "    public int getColumnWidth(String column) {\n        int width = 0;\n        if(column.equals(BREAKPOINTS) && breakpoints.isEmpty()) {\n            width = 5;\n        }\n        List<ATEGutterItem> items = getGutterItems(column);\n        for (ATEGutterItem item : items) {", "refactored_code": "    private static final int DEFAULT_NO_BREAKPOINTS_WIDTH = 5; // to have enough room to click with the mouse if no breakpoints\n    public int getColumnWidth(String column) {\n        int width = 0;\n        if(column.equals(BREAKPOINTS) && breakpoints.isEmpty()) {\n            width = DEFAULT_NO_BREAKPOINTS_WIDTH;\n        }\n        List<ATEGutterItem> items = getGutterItems(column);\n        for (ATEGutterItem item : items) {"}
{"magic_number_smell": "                TextLayout layout = new TextLayout(action.name, ideasList.getFont(), ((Graphics2D)ideasList.getGraphics()).getFontRenderContext());\n                width = Math.max(width, (int)layout.getBounds().getWidth());\n            }\n            height = height*Math.min(10, size)+5;\n            ideasScrollPane.setBounds(r.x,  r.y+r.height, width+10, height);\n        }\n    }", "refactored_code": "    protected static final int VISIBLE_IDEAS = 10;\n                TextLayout layout = new TextLayout(action.name, ideasList.getFont(), ((Graphics2D)ideasList.getGraphics()).getFontRenderContext());\n                width = Math.max(width, (int)layout.getBounds().getWidth());\n            }\n            height = height*Math.min(VISIBLE_IDEAS, size)+5;\n            ideasScrollPane.setBounds(r.x,  r.y+r.height, width+10, height);\n        }\n    }"}
{"magic_number_smell": "        int height = matchingRuleList.getFixedCellHeight();\n        int size = matchingRuleListModel.size();\n        if(size > 0) {\n            height = height*Math.min(15, size)+5;\n            matchingRuleScrollPane.setBounds(r.x,  r.y+r.height, r.width, height);\n        }\n    }", "refactored_code": "    public static final int VISIBLE_MATCHING_RULES = 15;\n        int height = matchingRuleList.getFixedCellHeight();\n        int size = matchingRuleListModel.size();\n        if(size > 0) {\n            height = height*Math.min(VISIBLE_MATCHING_RULES, size)+5;\n            matchingRuleScrollPane.setBounds(r.x,  r.y+r.height, r.width, height);\n        }\n    }"}
{"magic_number_smell": "    }\n\n    public int getType() {\n        int t = 0;\n        if(type != null) {\n            t = types.indexOf(type.getAttribute());\n        }", "refactored_code": "    public static final int COMBINED = 0;\n    }\n\n    public int getType() {\n        int t = COMBINED;\n        if(type != null) {\n            t = types.indexOf(type.getAttribute());\n        }"}
{"magic_number_smell": "\n            types.clear();\n            if(override) {\n                types.add(1);\n            }\n            if(isOverridden) {\n                types.add(ITEM_TYPE_OVERRIDDEN);                ", "refactored_code": "    public static final int ITEM_TYPE_OVERRIDE = 1;\n\n            types.clear();\n            if(override) {\n                types.add(ITEM_TYPE_OVERRIDE);\n            }\n            if(isOverridden) {\n                types.add(ITEM_TYPE_OVERRIDDEN);                "}
{"magic_number_smell": "    }\n\n    static {\n        register(0, \"Export as bitmap\");\n        register(EVENT_EXPORT_AS_EPS, \"Export as EPS\");\n        register(EVENT_EXPORT_AS_DOT, \"Export as DOT\");\n        register(EVENT_EXPORT_EVENTS_AS_TEXT, \"Export events as text\");", "refactored_code": "    public static final int EVENT_EXPORT_AS_BITMAP = 0;\n    }\n\n    static {\n        register(EVENT_EXPORT_AS_BITMAP, \"Export as bitmap\");\n        register(EVENT_EXPORT_AS_EPS, \"Export as EPS\");\n        register(EVENT_EXPORT_AS_DOT, \"Export as DOT\");\n        register(EVENT_EXPORT_EVENTS_AS_TEXT, \"Export events as text\");"}
{"magic_number_smell": "\n    protected void addRawLine(String line) {\n        rawLines.add(line);\n        if(rawLines.size() > 1000)\n            rawLines.remove(0);\n    }\n", "refactored_code": "    public static final int MAX_REPORTS = 1000;\n\n    protected void addRawLine(String line) {\n        rawLines.add(line);\n        if(rawLines.size() > MAX_REPORTS)\n            rawLines.remove(0);\n    }\n"}
{"magic_number_smell": "    }\n\n    public void customizeFileMenu(XJMenu menu) {\n        menu.insertItemAfter(new XJMenuItem(resourceBundle.getString(\"menu.item.print\"), KeyEvent.VK_P, 5, this), XJMainMenuBar.MI_SAVEAS);\n        menu.insertSeparatorAfter(XJMainMenuBar.MI_SAVEAS);\n    }\n", "refactored_code": "    public static final int MI_PRINT = 5;\n    }\n\n    public void customizeFileMenu(XJMenu menu) {\n        menu.insertItemAfter(new XJMenuItem(resourceBundle.getString(\"menu.item.print\"), KeyEvent.VK_P, MI_PRINT, this), XJMainMenuBar.MI_SAVEAS);\n        menu.insertSeparatorAfter(XJMainMenuBar.MI_SAVEAS);\n    }\n"}
{"magic_number_smell": "        nextCharacter(); // consume first ':'\n        nextCharacter(); // consume second ':'\n        if (c0 == '=') {\n            return createNewToken(101, sp, Math.min(position+1, text.length()));\n        } else {\n            while (nextCharacter()) {\n                if(isWhitespace()) {", "refactored_code": "    public static final int TOKEN_DEFINED_TO_BE = 101;\n        nextCharacter(); // consume first ':'\n        nextCharacter(); // consume second ':'\n        if (c0 == '=') {\n            return createNewToken(TOKEN_DEFINED_TO_BE, sp, Math.min(position+1, text.length()));\n        } else {\n            while (nextCharacter()) {\n                if(isWhitespace()) {"}
{"magic_number_smell": "\n    public void setComponent(Component c, int index) {\n        switch(index) {\n            case 0: setLeftComponent(c); break;\n            case MIDDLE_INDEX: setMiddleComponent(c); break;\n            case RIGHT_INDEX: setRightComponent(c); break;\n        }", "refactored_code": "    public static final int LEFT_INDEX = 0;\n\n    public void setComponent(Component c, int index) {\n        switch(index) {\n            case LEFT_INDEX: setLeftComponent(c); break;\n            case MIDDLE_INDEX: setMiddleComponent(c); break;\n            case RIGHT_INDEX: setRightComponent(c); break;\n        }"}
{"magic_number_smell": "    public abstract boolean overlayWillDisplay();\n\n    public int overlayDefaultWidth() {\n        return 300;\n    }\n\n    public int overlayDefaultHeight() {", "refactored_code": "    public static final int DEFAULT_WIDTH = 300;\n    public abstract boolean overlayWillDisplay();\n\n    public int overlayDefaultWidth() {\n        return DEFAULT_WIDTH;\n    }\n\n    public int overlayDefaultHeight() {"}
{"magic_number_smell": "                TextLayout layout = new TextLayout(e, tipsList.getFont(), ((Graphics2D)tipsList.getGraphics()).getFontRenderContext());\n                width = Math.max(width, (int)layout.getBounds().getWidth());\n            }\n            height = height*Math.min(10, size)+5;\n            Dimension d = new Dimension(width+10, height);\n            setSize(d);\n            tipsList.setSize(d);", "refactored_code": "    protected static final int VISIBLE_TIPS = 10;\n                TextLayout layout = new TextLayout(e, tipsList.getFont(), ((Graphics2D)tipsList.getGraphics()).getFontRenderContext());\n                width = Math.max(width, (int)layout.getBounds().getWidth());\n            }\n            height = height*Math.min(VISIBLE_TIPS, size)+5;\n            Dimension d = new Dimension(width+10, height);\n            setSize(d);\n            tipsList.setSize(d);"}
{"magic_number_smell": "\n        /** Add a gap if there is already a child otherwise use the parent left coordinate */\n        if(x > 0)\n            x += 20;\n        else\n            x = parent.getLeft();\n", "refactored_code": "    public static final int HORIZONTAL_GAP = 20;\n\n        /** Add a gap if there is already a child otherwise use the parent left coordinate */\n        if(x > 0)\n            x += HORIZONTAL_GAP;\n        else\n            x = parent.getLeft();\n"}
{"magic_number_smell": "                XJApplication.startingUp = false;\n                XJApplication.delegate.appDidLaunch(launchArguments, documentsToOpenAtStartup);\n                documentsToOpenAtStartup.clear();\n                new java.util.Timer().schedule(new ScheduledTimer(), 1000, 1000*60*1);\n            }\n        });\n    }", "refactored_code": "    protected static final long SCHEDULED_TIMER_MINUTES = 1;\n                XJApplication.startingUp = false;\n                XJApplication.delegate.appDidLaunch(launchArguments, documentsToOpenAtStartup);\n                documentsToOpenAtStartup.clear();\n                new java.util.Timer().schedule(new ScheduledTimer(), 1000, 1000*60*SCHEDULED_TIMER_MINUTES);\n            }\n        });\n    }"}
{"magic_number_smell": "    }\n\n    public void writeData(ObjectOutputStream oos) throws IOException {\n        oos.writeInt(1);\n        oos.writeObject(dictionary);\n    }\n", "refactored_code": "    private static final int VERSION = 1;\n    }\n\n    public void writeData(ObjectOutputStream oos) throws IOException {\n        oos.writeInt(VERSION);\n        oos.writeObject(dictionary);\n    }\n"}
{"magic_number_smell": "        button.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent event) {\n                dialogWillCloseCancel();\n                closeWithReturnCode(0);\n            }\n        });\n    }", "refactored_code": "    public static final int BUTTON_CANCEL = 0;\n        button.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent event) {\n                dialogWillCloseCancel();\n                closeWithReturnCode(BUTTON_CANCEL);\n            }\n        });\n    }"}
{"magic_number_smell": "        Rectangle r = new Rectangle(pos.x, pos.y, s.width, s.height);\n        XJPreferences prefs = XJApplication.shared().getPreferences();\n\n        // cleanup the prefs by making sure no more than 100\n        // are existing in the prefs.\n        String[] keys = prefs.getKeys();\n        if(keys != null) {", "refactored_code": "    private static final int MAX_WINDOWS_BOUND_KEYS = 100;\n        Rectangle r = new Rectangle(pos.x, pos.y, s.width, s.height);\n        XJPreferences prefs = XJApplication.shared().getPreferences();\n\n        // cleanup the prefs by making sure no more than MAX_WINDOWS_BOUND_KEYS\n        // are existing in the prefs.\n        String[] keys = prefs.getKeys();\n        if(keys != null) {"}
{"magic_number_smell": "    }\n\n    public double eventLinkFlateness() {\n        return 40;\n    }\n\n    public void eventCreateLink(GElement source, String sourceAnchorKey, GElement target, String targetAnchorKey, int shape, Point p) {", "refactored_code": "    public static final double DEFAULT_LINK_FLATENESS = 40;\n    }\n\n    public double eventLinkFlateness() {\n        return DEFAULT_LINK_FLATENESS;\n    }\n\n    public void eventCreateLink(GElement source, String sourceAnchorKey, GElement target, String targetAnchorKey, int shape, Point p) {"}
{"magic_number_smell": "        while(iterator.hasNext()) {\n            GAbstractEvent eventObject = iterator.next();\n            switch(action) {\n                case 1:\n                    eventObject.draw((Graphics)param);\n                    break;\n                case EVENT_MOUSE_PRESSED:", "refactored_code": "    public static final int EVENT_DRAW = 1;\n        while(iterator.hasNext()) {\n            GAbstractEvent eventObject = iterator.next();\n            switch(action) {\n                case EVENT_DRAW:\n                    eventObject.draw((Graphics)param);\n                    break;\n                case EVENT_MOUSE_PRESSED:"}
{"magic_number_smell": "\n    public static final int 20 = 20;\n\n    protected double radius = 20;\n\n    public GElementCircle() {\n    }", "refactored_code": "    public static final int DEFAULT_RADIUS = 20;\n\n    public static final int DEFAULT_RADIUS = 20;\n\n    protected double radius = DEFAULT_RADIUS;\n\n    public GElementCircle() {\n    }"}
{"magic_number_smell": "    public static final int 40 = 40;\n    public static final int DEFAULT_HEIGHT = 40;\n\n    protected double width = 40;\n    protected double height = DEFAULT_HEIGHT;\n\n    public GElementRect() {", "refactored_code": "    public static final int DEFAULT_WIDTH = 40;\n    public static final int DEFAULT_WIDTH = 40;\n    public static final int DEFAULT_HEIGHT = 40;\n\n    protected double width = DEFAULT_WIDTH;\n    protected double height = DEFAULT_HEIGHT;\n\n    public GElementRect() {"}
{"magic_number_smell": "\n    protected SLink link = null;\n\n    protected int shape = 0;\n\n    public GLink() {\n        super();", "refactored_code": "    public static final int SHAPE_ARC = 0;\n\n    protected SLink link = null;\n\n    protected int shape = SHAPE_ARC;\n\n    public GLink() {\n        super();"}
{"magic_number_smell": "            double f = nz.length()/originalZLength;\n            double lb = p.getX();\n            double lc = p.getY();\n            if(mode == 1) {\n                // End-point is always at the same relative position\n                return end.add(originalEndPointOffset);\n            } else {", "refactored_code": "    protected static final int MODE_END = 1;\n            double f = nz.length()/originalZLength;\n            double lb = p.getX();\n            double lc = p.getY();\n            if(mode == MODE_END) {\n                // End-point is always at the same relative position\n                return end.add(originalEndPointOffset);\n            } else {"}
{"magic_number_smell": "    public void updateBottomBottom() {\n        this.path = link.path;\n        if(Math.abs(link.end.x-link.start.x)>=GElementRect.DEFAULT_WIDTH*0.5+10) {\n            buildHorizontalPath(0);\n        } else {\n            // Objects are too close\n            if(link.start.y>=link.end.y)", "refactored_code": "    public static final int BOTTOM_BOTTOM = 0;\n    public void updateBottomBottom() {\n        this.path = link.path;\n        if(Math.abs(link.end.x-link.start.x)>=GElementRect.DEFAULT_WIDTH*0.5+10) {\n            buildHorizontalPath(BOTTOM_BOTTOM);\n        } else {\n            // Objects are too close\n            if(link.start.y>=link.end.y)"}
{"magic_number_smell": "    public void updateLeftLeft() {\n        this.path = link.path;\n        if(Math.abs(link.end.y-link.start.y)>=GElementRect.DEFAULT_WIDTH*0.5+10) {\n            buildVerticalPath(0);\n        } else {\n            // Objects are too close\n            if(link.start.x<link.end.x)", "refactored_code": "    public static final int LEFT_LEFT = 0;\n    public void updateLeftLeft() {\n        this.path = link.path;\n        if(Math.abs(link.end.y-link.start.y)>=GElementRect.DEFAULT_WIDTH*0.5+10) {\n            buildVerticalPath(LEFT_LEFT);\n        } else {\n            // Objects are too close\n            if(link.start.x<link.end.x)"}
{"magic_number_smell": "            if(Math.abs(link.end.y-link.start.y)>=GElementRect.DEFAULT_WIDTH+10) {\n                buildVerticalPath();\n            } else {\n                buildVerticalBottomPath(0);\n            }\n        }\n    }", "refactored_code": "    public static final int LEFT_RIGHT = 0;\n            if(Math.abs(link.end.y-link.start.y)>=GElementRect.DEFAULT_WIDTH+10) {\n                buildVerticalPath();\n            } else {\n                buildVerticalBottomPath(LEFT_RIGHT);\n            }\n        }\n    }"}
{"magic_number_smell": "            if(Math.abs(link.end.x-link.start.x)>=GElementRect.DEFAULT_WIDTH+10) {\n                buildHorizontalPath();\n            } else {\n                buildHorizontalRightPath(0);\n            }\n        }\n    }", "refactored_code": "    public static final int TOP_BOTTOM = 0;\n            if(Math.abs(link.end.x-link.start.x)>=GElementRect.DEFAULT_WIDTH+10) {\n                buildHorizontalPath();\n            } else {\n                buildHorizontalRightPath(TOP_BOTTOM);\n            }\n        }\n    }"}
{"magic_number_smell": "                x = Float.parseFloat(posTokens[0]);\n                y = (height - Float.parseFloat(posTokens[2]));\n            } else if(tokens[index].equals(\"width\")) {\n                w = Float.parseFloat(tokens[index+=2])*72;\n            } else if(tokens[index].equals(\"height\")) {\n                h = Float.parseFloat(tokens[index+=2])*72;\n            } else if(tokens[index].equals(\"shape\")) {", "refactored_code": "    public static final int INCH_TO_PIXEL = 72;\n                x = Float.parseFloat(posTokens[0]);\n                y = (height - Float.parseFloat(posTokens[2]));\n            } else if(tokens[index].equals(\"width\")) {\n                w = Float.parseFloat(tokens[index+=2])*INCH_TO_PIXEL;\n            } else if(tokens[index].equals(\"height\")) {\n                h = Float.parseFloat(tokens[index+=2])*INCH_TO_PIXEL;\n            } else if(tokens[index].equals(\"shape\")) {"}
{"magic_number_smell": "    public static final int 0 = 0;\n    public static final int VERTICAL = 1;\n\n    private int kind = 0;\n    private double factor = 0;\n    private boolean visible = false;\n", "refactored_code": "    public static final int HORIZONTAL = 0;\n    public static final int HORIZONTAL = 0;\n    public static final int VERTICAL = 1;\n\n    private int kind = HORIZONTAL;\n    private double factor = 0;\n    private boolean visible = false;\n"}
{"magic_number_smell": "\n        menuFile = new XJMenu();\n        menuFile.setTitle(XJLocalizable.getXJString(\"File\"));\n        menuFile.addItem(buildMenuItem(XJLocalizable.getXJString(\"New\"), KeyEvent.VK_N, 10000));\n        if(persistence) {\n            menuFile.addItem(buildMenuItem(XJLocalizable.getXJString(\"Open\"), KeyEvent.VK_O, MI_OPEN));\n            menuFile.addItem(createRecentFilesMenu());", "refactored_code": "    public static final int MI_NEW = 10000;\n\n        menuFile = new XJMenu();\n        menuFile.setTitle(XJLocalizable.getXJString(\"File\"));\n        menuFile.addItem(buildMenuItem(XJLocalizable.getXJString(\"New\"), KeyEvent.VK_N, MI_NEW));\n        if(persistence) {\n            menuFile.addItem(buildMenuItem(XJLocalizable.getXJString(\"Open\"), KeyEvent.VK_O, MI_OPEN));\n            menuFile.addItem(createRecentFilesMenu());"}
{"magic_number_smell": "    // EPSImage.java, (c) March 1999 MageLang Institute, with its authorization\n\n    protected static final int 1 = 1;\n    protected static final int BitsPerComponent = 1 * 8;\n    protected static final int ComponentsPerPixel = 3;\n    protected static char[] hexmap = {  '0','1','2','3','4',\n                                        '5','6','7','8','9',", "refactored_code": "    protected static final int BytesPerComponent = 1;\n    // EPSImage.java, (c) March 1999 MageLang Institute, with its authorization\n\n    protected static final int BytesPerComponent = 1;\n    protected static final int BitsPerComponent = BytesPerComponent * 8;\n    protected static final int ComponentsPerPixel = 3;\n    protected static char[] hexmap = {  '0','1','2','3','4',\n                                        '5','6','7','8','9',"}
{"magic_number_smell": "        Graphics2D g2d = (Graphics2D) g;\n        AffineTransform tr = g2d.getTransform();\n        switch(rotation) {\n            case 1:\n                tr.rotate(Math.PI/2);\n                tr.translate(0, -computedHeight);\n                g2d.setTransform(tr);", "refactored_code": "    public static final int ROTATE_90 = 1;\n        Graphics2D g2d = (Graphics2D) g;\n        AffineTransform tr = g2d.getTransform();\n        switch(rotation) {\n            case ROTATE_90:\n                tr.rotate(Math.PI/2);\n                tr.translate(0, -computedHeight);\n                g2d.setTransform(tr);"}
{"magic_number_smell": "        Rectangle outer = getBounds();\n        Rectangle inner = getParent().getBounds();\n\n        return new Insets(inner.y-outer.y+12, inner.x-outer.x+12,\n                outer.height-inner.height+12,\n                outer.width-inner.width+12);\n    }", "refactored_code": "    protected final int AUTOSCROLL_MARGIN = 12;\n        Rectangle outer = getBounds();\n        Rectangle inner = getParent().getBounds();\n\n        return new Insets(inner.y-outer.y+AUTOSCROLL_MARGIN, inner.x-outer.x+AUTOSCROLL_MARGIN,\n                outer.height-inner.height+AUTOSCROLL_MARGIN,\n                outer.width-inner.width+AUTOSCROLL_MARGIN);\n    }"}
{"magic_number_smell": "\t\t\ttry {\n\t\t\t\tdouble version = Double.valueOf(majorMRJVersion).doubleValue();\n\t\t\t\tif (version == 2) {\n\t\t\t\t\tjvm = 0;\n\t\t\t\t} else if (version >= 2.1 && version < 3) {\n\t\t\t\t\t// Assume that all 2.x versions of MRJ work the same.  MRJ 2.1 actually\n\t\t\t\t\t// works via Runtime.exec() and 2.2 supports that but has an openURL() method", "refactored_code": "\tprivate static final int MRJ_2_0 = 0;\n\t\t\ttry {\n\t\t\t\tdouble version = Double.valueOf(majorMRJVersion).doubleValue();\n\t\t\t\tif (version == 2) {\n\t\t\t\t\tjvm = MRJ_2_0;\n\t\t\t\t} else if (version >= 2.1 && version < 3) {\n\t\t\t\t\t// Assume that all 2.x versions of MRJ work the same.  MRJ 2.1 actually\n\t\t\t\t\t// works via Runtime.exec() and 2.2 supports that but has an openURL() method"}
{"magic_number_smell": "\n    public void actionPerformed(ActionEvent e) {\n        k++;\n        if(k>10) {\n            c.scrollRectToVisible(dest);\n            timer.stop();\n            timer = null;", "refactored_code": "    protected static final int steps = 10;\n\n    public void actionPerformed(ActionEvent e) {\n        k++;\n        if(k>steps) {\n            c.scrollRectToVisible(dest);\n            timer.stop();\n            timer = null;"}
{"magic_number_smell": "\t\t\t\tConstructorDeclaration defaultConstructor = new ConstructorDeclaration(compilationResult);\n\t\t\t\tdefaultConstructor.bits |= ASTNode.IsDefaultConstructor;\n\t\t\t\tdefaultConstructor.constructorCall = new ExplicitConstructorCall(ExplicitConstructorCall.ImplicitSuper);\n\t\t\t\tdefaultConstructor.modifiers = decl.modifiers & 7;\n\t\t\t\tdefaultConstructor.selector = toName(type.astName());\n\t\t\t\tdefaultConstructor.sourceStart = defaultConstructor.declarationSourceStart =\n\t\t\t\t\t\tdefaultConstructor.constructorCall.sourceStart =", "refactored_code": "\tprivate static final int VISIBILITY_MASK = 7;\n\t\t\t\tConstructorDeclaration defaultConstructor = new ConstructorDeclaration(compilationResult);\n\t\t\t\tdefaultConstructor.bits |= ASTNode.IsDefaultConstructor;\n\t\t\t\tdefaultConstructor.constructorCall = new ExplicitConstructorCall(ExplicitConstructorCall.ImplicitSuper);\n\t\t\t\tdefaultConstructor.modifiers = decl.modifiers & VISIBILITY_MASK;\n\t\t\t\tdefaultConstructor.selector = toName(type.astName());\n\t\t\t\tdefaultConstructor.sourceStart = defaultConstructor.declarationSourceStart =\n\t\t\t\t\t\tdefaultConstructor.constructorCall.sourceStart ="}
{"magic_number_smell": "\t\t\tif (body != null) body.pos = node.getPosition().getStart();\n\t\t\tif (!posIsSet && body != null) setPos(node.astBody(), newClass);\n\t\t\t\n\t\t\tJCModifiers mods = treeMaker.Modifiers(Flags.PUBLIC | Flags.STATIC | Flags.FINAL | Flags.ENUM, toList(JCAnnotation.class, node.astAnnotations()));\n\t\t\tif (!node.astAnnotations().isEmpty()) {\n\t\t\t\tint modStart = node.astAnnotations().first().getPosition().getStart();\n\t\t\t\tint modEnd = node.astAnnotations().last().getPosition().getEnd();", "refactored_code": "\t\tprivate static final long ENUM_CONSTANT_FLAGS = Flags.PUBLIC | Flags.STATIC | Flags.FINAL | Flags.ENUM;\n\t\t\tif (body != null) body.pos = node.getPosition().getStart();\n\t\t\tif (!posIsSet && body != null) setPos(node.astBody(), newClass);\n\t\t\t\n\t\t\tJCModifiers mods = treeMaker.Modifiers(ENUM_CONSTANT_FLAGS, toList(JCAnnotation.class, node.astAnnotations()));\n\t\t\tif (!node.astAnnotations().isEmpty()) {\n\t\t\t\tint modStart = node.astAnnotations().first().getPosition().getStart();\n\t\t\t\tint modEnd = node.astAnnotations().last().getPosition().getEnd();"}
{"magic_number_smell": "\t\t\t\tfor (JCTree def : node.defs) {\n\t\t\t\t\tif (def instanceof JCVariableDecl) {\n\t\t\t\t\t\tJCVariableDecl vd = (JCVariableDecl) def;\n\t\t\t\t\t\tif (vd.mods != null && (vd.mods.flags & Flags.PUBLIC | Flags.STATIC | Flags.FINAL | Flags.ENUM) == Flags.PUBLIC | Flags.STATIC | Flags.FINAL | Flags.ENUM) {\n\t\t\t\t\t\t\t// This is an enum constant, not a field of the enum class.\n\t\t\t\t\t\t\tEnumConstant ec = new EnumConstant();\n\t\t\t\t\t\t\tsetPos(def, ec);", "refactored_code": "\t\tprivate static final long ENUM_CONSTANT_FLAGS = Flags.PUBLIC | Flags.STATIC | Flags.FINAL | Flags.ENUM;\n\t\t\t\tfor (JCTree def : node.defs) {\n\t\t\t\t\tif (def instanceof JCVariableDecl) {\n\t\t\t\t\t\tJCVariableDecl vd = (JCVariableDecl) def;\n\t\t\t\t\t\tif (vd.mods != null && (vd.mods.flags & ENUM_CONSTANT_FLAGS) == ENUM_CONSTANT_FLAGS) {\n\t\t\t\t\t\t\t// This is an enum constant, not a field of the enum class.\n\t\t\t\t\t\t\tEnumConstant ec = new EnumConstant();\n\t\t\t\t\t\t\tsetPos(def, ec);"}
{"magic_number_smell": "\tprivate static final Map<String, Integer> TO_FLAG_MAP = ImmutableMap.<String, Integer>builder()\n\t\t.put(\"private\", K_PRIVATE)\n\t\t.put(\"protected\", K_PROTECTED)\n\t\t.put(\"public\", 0x0001)\n\t\t.put(\"final\", K_FINAL)\n\t\t.put(\"native\", K_NATIVE)\n\t\t.put(\"strictfp\", K_STRICTFP)", "refactored_code": "\tprivate static final int K_PUBLIC       = 0x0001;\n\tprivate static final Map<String, Integer> TO_FLAG_MAP = ImmutableMap.<String, Integer>builder()\n\t\t.put(\"private\", K_PRIVATE)\n\t\t.put(\"protected\", K_PROTECTED)\n\t\t.put(\"public\", K_PUBLIC)\n\t\t.put(\"final\", K_FINAL)\n\t\t.put(\"native\", K_NATIVE)\n\t\t.put(\"strictfp\", K_STRICTFP)"}
{"magic_number_smell": "\tpublic void init() {\n\t\tif (VERBOSE) {\n\t\t\tSystem.out.printf(\"[%20s / %30s] Per entry: time in millis for %d reps [lombok takes X longer than ~ : ~ takes X longer than javac]\\n\",\n\t\t\t\t\t\"path\", \"file\", 50);\n\t\t}\n\t}\n\t", "refactored_code": "\tprivate static final int REPS = 50;\n\tpublic void init() {\n\t\tif (VERBOSE) {\n\t\t\tSystem.out.printf(\"[%20s / %30s] Per entry: time in millis for %d reps [lombok takes X longer than ~ : ~ takes X longer than javac]\\n\",\n\t\t\t\t\t\"path\", \"file\", REPS);\n\t\t}\n\t}\n\t"}
{"magic_number_smell": "\tprivate String getCharsAfterPosition(int pos, String raw) {\n\t\tint max = raw.length();\n\t\tif (pos < 0) pos = 0;\n\t\treturn pos >= max ? \"\" : raw.substring(pos, Math.min(pos + 12, max));\n\t}\n\t\n\tprivate String getCharsBeforePosition(int pos, String raw) {", "refactored_code": "\tprivate static final int RANGE = 12;\n\tprivate String getCharsAfterPosition(int pos, String raw) {\n\t\tint max = raw.length();\n\t\tif (pos < 0) pos = 0;\n\t\treturn pos >= max ? \"\" : raw.substring(pos, Math.min(pos + RANGE, max));\n\t}\n\t\n\tprivate String getCharsBeforePosition(int pos, String raw) {"}
{"magic_number_smell": "\t\t\tChildrenRecordStore store, Dispatcher dispatcher) {\n\t\tsuper(screen, uiStack, dispatcher);\n\t\tthis.store = store;\n\t\tthis.sortState = 0;\n\t}\n\n\tpublic void viewAllChildren() {", "refactored_code": "\tprivate final int SORT_NAME = 0;\n\t\t\tChildrenRecordStore store, Dispatcher dispatcher) {\n\t\tsuper(screen, uiStack, dispatcher);\n\t\tthis.store = store;\n\t\tthis.sortState = SORT_NAME;\n\t}\n\n\tpublic void viewAllChildren() {"}
{"magic_number_smell": "\t}\n\n\tprotected void layout(int width, int height) {\n\t\tthis.setExtent(20, HEIGHT);\n\t}\n\n\tprotected boolean navigationClick(int status, int time){", "refactored_code": "\tprivate static final int WIDTH = 20;\n\t}\n\n\tprotected void layout(int width, int height) {\n\t\tthis.setExtent(WIDTH, HEIGHT);\n\t}\n\n\tprotected boolean navigationClick(int status, int time){"}
{"magic_number_smell": "            int centerHeight = height / 2;\n\n            //Draw the top triangle.\n            int[] xPts = {centerWidth, centerWidth + 6, centerWidth - 6, centerWidth};\n            int[] yPts = {TRIANGLE_OFFSET, TRIANGLE_OFFSET + 6, TRIANGLE_OFFSET + 6, TRIANGLE_OFFSET};\n\n            graphics.drawShadedFilledPath(xPts, yPts, null, COLOURS, null);", "refactored_code": "    private static final int TRIANGLE_SIZE = 6;     //The scroll arrow size.\n            int centerHeight = height / 2;\n\n            //Draw the top triangle.\n            int[] xPts = {centerWidth, centerWidth + TRIANGLE_SIZE, centerWidth - TRIANGLE_SIZE, centerWidth};\n            int[] yPts = {TRIANGLE_OFFSET, TRIANGLE_OFFSET + TRIANGLE_SIZE, TRIANGLE_OFFSET + TRIANGLE_SIZE, TRIANGLE_OFFSET};\n\n            graphics.drawShadedFilledPath(xPts, yPts, null, COLOURS, null);"}
{"magic_number_smell": "\t\tint textLength = this.getFont().getAdvance(userName);\n\t\tint textHeight = this.getFont().getHeight();\n\t\tif(textLength >= (this.fieldWidth - bitmap.getWidth())){\n\t\t\tuserName = userName.substring(0,6 - 1) + \"...\";\n\t\t\ttextLength = this.getFont().getAdvance(userName);\n\t\t}\n\t\tgraphics.drawText(userName,this.fieldWidth - textLength, bitmap.getHeight() - textHeight);", "refactored_code": "\tprivate static final int OVERFLOW_TRUNC = 6;\n\t\tint textLength = this.getFont().getAdvance(userName);\n\t\tint textHeight = this.getFont().getHeight();\n\t\tif(textLength >= (this.fieldWidth - bitmap.getWidth())){\n\t\t\tuserName = userName.substring(0,OVERFLOW_TRUNC - 1) + \"...\";\n\t\t\ttextLength = this.getFont().getAdvance(userName);\n\t\t}\n\t\tgraphics.drawText(userName,this.fieldWidth - textLength, bitmap.getHeight() - textHeight);"}
{"magic_number_smell": "                       RequestListener listener, Object context) throws IOException {\n        int sent = 0;\n        // optimization if a small amount of data is being sent\n        if (data.length <= 512) {\n            os.write(data);\n            sent += data.length;\n            if (listener != null) {", "refactored_code": "    private static final int BUFFER_SIZE = 512;\n                       RequestListener listener, Object context) throws IOException {\n        int sent = 0;\n        // optimization if a small amount of data is being sent\n        if (data.length <= BUFFER_SIZE) {\n            os.write(data);\n            sent += data.length;\n            if (listener != null) {"}
{"magic_number_smell": "\tprivate static final int 10 = 10;\n\n\tpublic WorkQueue() {\n\t\tthreads = new Thread[10];\n\t\tmakeEmpty();\n\t}\n", "refactored_code": "\tprivate static final int INITIAL_CAPACITY = 10;\n\tprivate static final int INITIAL_CAPACITY = 10;\n\n\tpublic WorkQueue() {\n\t\tthreads = new Thread[INITIAL_CAPACITY];\n\t\tmakeEmpty();\n\t}\n"}
{"magic_number_smell": "\tprivate static final int 200 = 200;\n\n\tprivate final PasswordEditField passwordField = new PasswordEditField(\n\t\t\t\"Password:\", \"\", 200, USE_ALL_WIDTH);\n\tprivate final BasicEditField usernameField = basicField(\"Username:\");\n\tprivate final BasicEditField urlField = basicField(\"Url:\");\n", "refactored_code": "\tprivate static final int MAX_SIZE = 200;\n\tprivate static final int MAX_SIZE = 200;\n\n\tprivate final PasswordEditField passwordField = new PasswordEditField(\n\t\t\t\"Password:\", \"\", MAX_SIZE, USE_ALL_WIDTH);\n\tprivate final BasicEditField usernameField = basicField(\"Username:\");\n\tprivate final BasicEditField urlField = basicField(\"Url:\");\n"}
{"magic_number_smell": "\tprivate static final int 200 = 200;\n\n\tprivate final BasicEditField searchTextField = new BasicEditField(\"\", \"\",\n\t\t\t200, USE_ALL_WIDTH | TextField.NO_NEWLINE);\n\n\tprivate Button searchButton;\n\tprivate Button resetButton;", "refactored_code": "\tprivate static final int MAX_SIZE = 200;\n\tprivate static final int MAX_SIZE = 200;\n\n\tprivate final BasicEditField searchTextField = new BasicEditField(\"\", \"\",\n\t\t\tMAX_SIZE, USE_ALL_WIDTH | TextField.NO_NEWLINE);\n\n\tprivate Button searchButton;\n\tprivate Button resetButton;"}
{"magic_number_smell": "\n\tpublic void setChildren(Children children) {\n\t\tchildrenList.displayChildren(children);\n\t\tchildrenList.setRowHeight(100);\n\t}\n\n\tprivate ViewChildrenController getController() {", "refactored_code": "\tprivate static final int ROW_HEIGHT = 100;\n\n\tpublic void setChildren(Children children) {\n\t\tchildrenList.displayChildren(children);\n\t\tchildrenList.setRowHeight(ROW_HEIGHT);\n\t}\n\n\tprivate ViewChildrenController getController() {"}
{"magic_number_smell": "    private Logger() {}\n    \n    public static void register() {\n        EventLogger.register(0x4c9d3452d87923f2L, \"RapidFTR\", EventLogger.VIEWER_STRING);\n    }\n\n    public static void log(String message) {", "refactored_code": "    private static final long APP_GUID = 0x4c9d3452d87923f2L;\n    private Logger() {}\n    \n    public static void register() {\n        EventLogger.register(APP_GUID, \"RapidFTR\", EventLogger.VIEWER_STRING);\n    }\n\n    public static void log(String message) {"}
{"magic_number_smell": "\t\n\t//public static final int 0xF4F1EA = 0xF4F1EA;\n\t\n\tpublic static final int 0xF4F1EA = Color.RED;\n\tpublic static final int COLOR_FIELD_BACKGROUND = 0x31353E;\n\tpublic static final int COLOR_FIELD_HIGHLIGHT = Color.ROYALBLUE;\n\tpublic static final int COLOR_FIELD_DISABLED = Color.GRAY;", "refactored_code": "\t//public static final int COLOR_SCREEN_BACKGROUND = 0xF4F1EA;\n\t\n\t//public static final int COLOR_SCREEN_BACKGROUND = 0xF4F1EA;\n\t\n\tpublic static final int COLOR_SCREEN_BACKGROUND = Color.RED;\n\tpublic static final int COLOR_FIELD_BACKGROUND = 0x31353E;\n\tpublic static final int COLOR_FIELD_HIGHLIGHT = Color.ROYALBLUE;\n\tpublic static final int COLOR_FIELD_DISABLED = Color.GRAY;"}
{"magic_number_smell": "    public JSONWriter(Writer w) {\n        this.comma = false;\n        this.mode = 'i';\n        this.stack = new char[20];\n        this.top = 0;\n        this.writer = w;\n    }", "refactored_code": "    private static final int maxdepth = 20;\n    public JSONWriter(Writer w) {\n        this.comma = false;\n        this.mode = 'i';\n        this.stack = new char[maxdepth];\n        this.top = 0;\n        this.writer = w;\n    }"}
{"magic_number_smell": "        TimeZone easternStandardTime = TimeZone.getTimeZone(\"Australia/Brisbane\");\n        long convertedTime = timeZoneConverter.convertUTCto(easternStandardTime, utcTime);\n\n        long expectedTime = utcTime + (10 * 60 * 60 * 1000);\n\n        assertEquals(expectedTime, convertedTime);\n    }", "refactored_code": "    private final long MILLISECONDS_PER_HOUR = 60 * 60 * 1000;\n        TimeZone easternStandardTime = TimeZone.getTimeZone(\"Australia/Brisbane\");\n        long convertedTime = timeZoneConverter.convertUTCto(easternStandardTime, utcTime);\n\n        long expectedTime = utcTime + (10 * MILLISECONDS_PER_HOUR);\n\n        assertEquals(expectedTime, convertedTime);\n    }"}
{"magic_number_smell": "\t}\n\n\tclass JumpToMapAction extends AbstractAction {\n\t\tprivate static final long -4624762713662343786L = -531070508254258791L;\n\n\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\tif (sPositionToRecover != null) {", "refactored_code": "\t\tprivate static final long serialVersionUID = -4624762713662343786L;\n\t}\n\n\tclass JumpToMapAction extends AbstractAction {\n\t\tprivate static final long serialVersionUID = -531070508254258791L;\n\n\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\tif (sPositionToRecover != null) {"}
{"magic_number_smell": "\n\tprivate static final String WINDOW_PREFERENCE_STORAGE_PROPERTY = \"accessories.plugins.dialogs.ChooseFormatPopupDialog.window_storage\";\n\n\tprivate int result = -1;\n\n\tprivate javax.swing.JPanel jContentPane = null;\n", "refactored_code": "\tpublic static final int CANCEL = -1;\n\n\tprivate static final String WINDOW_PREFERENCE_STORAGE_PROPERTY = \"accessories.plugins.dialogs.ChooseFormatPopupDialog.window_storage\";\n\n\tprivate int result = CANCEL;\n\n\tprivate javax.swing.JPanel jContentPane = null;\n"}
{"magic_number_smell": "\n\tpublic static final int OK = 1;\n\n\tprivate int result = -1;\n\n\tprivate javax.swing.JPanel jContentPane = null;\n", "refactored_code": "\tpublic static final int CANCEL = -1;\n\n\tpublic static final int OK = 1;\n\n\tprivate int result = CANCEL;\n\n\tprivate javax.swing.JPanel jContentPane = null;\n"}
{"magic_number_smell": "\n\tpublic static final int OK = 1;\n\n\tprivate int result = -1;\n\n\tprivate javax.swing.JPanel jContentPane = null;\n", "refactored_code": "\tpublic static final int CANCEL = -1;\n\n\tpublic static final int OK = 1;\n\n\tprivate int result = CANCEL;\n\n\tprivate javax.swing.JPanel jContentPane = null;\n"}
{"magic_number_smell": "\t\t\t\t\tdays[index] = new DecoratorButton();\n\t\t\t\t} else {\n\t\t\t\t\tdays[index] = new JButton(\"x\") {\n\t\t\t\t\t\tprivate static final long 5876398337018781820L = -7433645992591669725L;\n\n\t\t\t\t\t\tpublic void paint(Graphics g) {\n\t\t\t\t\t\t\tif (Tools.isWindows()||Tools.isMacOsX()) {", "refactored_code": "\tprivate static final long serialVersionUID = 5876398337018781820L;\n\t\t\t\t\tdays[index] = new DecoratorButton();\n\t\t\t\t} else {\n\t\t\t\t\tdays[index] = new JButton(\"x\") {\n\t\t\t\t\t\tprivate static final long serialVersionUID = -7433645992591669725L;\n\n\t\t\t\t\t\tpublic void paint(Graphics g) {\n\t\t\t\t\t\t\tif (Tools.isWindows()||Tools.isMacOsX()) {"}
{"magic_number_smell": "\n\t\tif (hasSpinner) {\n\t\t\tspinner = new JSpinner() {\n\t\t\t\tprivate static final long -2028361332231218527L = 1L;\n\n\t\t\t\tprivate JTextField textField = new JTextField();\n", "refactored_code": "\tprivate static final long serialVersionUID = -2028361332231218527L;\n\n\t\tif (hasSpinner) {\n\t\t\tspinner = new JSpinner() {\n\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\tprivate JTextField textField = new JTextField();\n"}
{"magic_number_smell": "\t\ttextField.setText(Integer.toString(value));\n\t\ttextField.addFocusListener(this);\n\t\tspinner = new JSpinner() {\n\t\t\tprivate static final long 1694904792717740650L = -6287709243342021172L;\n\t\t\tprivate JTextField textField = new JTextField();\n\n\t\t\tpublic Dimension getPreferredSize() {", "refactored_code": "\tprivate static final long serialVersionUID = 1694904792717740650L;\n\t\ttextField.setText(Integer.toString(value));\n\t\ttextField.addFocusListener(this);\n\t\tspinner = new JSpinner() {\n\t\t\tprivate static final long serialVersionUID = -6287709243342021172L;\n\t\t\tprivate JTextField textField = new JTextField();\n\n\t\t\tpublic Dimension getPreferredSize() {"}
{"magic_number_smell": "\t\tif (directive == EMPTY_DIRECTIVE) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new Arrow(directive.direction == -1, size,\n\t\t\t\tsortingColumns.indexOf(directive));\n\t}\n", "refactored_code": "\tpublic static final int DESCENDING = -1;\n\t\tif (directive == EMPTY_DIRECTIVE) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new Arrow(directive.direction == DESCENDING, size,\n\t\t\t\tsortingColumns.indexOf(directive));\n\t}\n"}
{"magic_number_smell": "\t\t\t}\n\t\t\tmTypeDelayTimer = new Timer();\n\t\t\tmTypeDelayTimer.schedule(new DelayedTextEntry(event),\n\t\t\t\t\t500);\n\t\t}\n\n\t\tpublic void insertUpdate(DocumentEvent event) {", "refactored_code": "\tprivate static final int TYPE_DELAY_TIME = 500;\n\t\t\t}\n\t\t\tmTypeDelayTimer = new Timer();\n\t\t\tmTypeDelayTimer.schedule(new DelayedTextEntry(event),\n\t\t\t\t\tTYPE_DELAY_TIME);\n\t\t}\n\n\t\tpublic void insertUpdate(DocumentEvent event) {"}
{"magic_number_smell": "\tpublic final int Restriction_Id = 9;\n\tpublic final int Enumeration_Id = 10;\n\tpublic final int Group_Id = 11;\n\tElementTypes Schema = new ElementTypes(0);\n\tElementTypes ComplexType = new ElementTypes(ComplexType_Id);\n\tElementTypes Sequence = new ElementTypes(Sequence_Id);\n\tElementTypes Choice = new ElementTypes(Choice_Id);", "refactored_code": "\tpublic final int Schema_Id = 0;\n\tpublic final int Restriction_Id = 9;\n\tpublic final int Enumeration_Id = 10;\n\tpublic final int Group_Id = 11;\n\tElementTypes Schema = new ElementTypes(Schema_Id);\n\tElementTypes ComplexType = new ElementTypes(ComplexType_Id);\n\tElementTypes Sequence = new ElementTypes(Sequence_Id);\n\tElementTypes Choice = new ElementTypes(Choice_Id);"}
{"magic_number_smell": "\t\t\tif (isInterrupted()) {\n\t\t\t\tagain = false;\n\t\t\t}\n\t\t\tif (System.currentTimeMillis() - startTime > 1000) {\n\t\t\t\t// mProgressMonitor.setModal(true);\n\t\t\t\tEventQueue.invokeLater(new Runnable() {\n\t\t\t\t\tpublic void run() {", "refactored_code": "\tprivate static final long TIME_TO_DISPLAY_PROGRESS_BAR_IN_MILLIS = 1000;\n\t\t\tif (isInterrupted()) {\n\t\t\t\tagain = false;\n\t\t\t}\n\t\t\tif (System.currentTimeMillis() - startTime > TIME_TO_DISPLAY_PROGRESS_BAR_IN_MILLIS) {\n\t\t\t\t// mProgressMonitor.setModal(true);\n\t\t\t\tEventQueue.invokeLater(new Runnable() {\n\t\t\t\t\tpublic void run() {"}
{"magic_number_smell": "\n\tprivate int transformString(String string) {\n\t\tif (string == null) {\n\t\t\treturn 2;\n\t\t}\n\t\tif (string.toLowerCase().equals(mTrueValue)) {\n\t\t\treturn TRUE_VALUE_INT;", "refactored_code": "\tprotected static final int DON_T_TOUCH_VALUE_INT = 2;\n\n\tprivate int transformString(String string) {\n\t\tif (string == null) {\n\t\t\treturn DON_T_TOUCH_VALUE_INT;\n\t\t}\n\t\tif (string.toLowerCase().equals(mTrueValue)) {\n\t\t\treturn TRUE_VALUE_INT;"}
{"magic_number_smell": "\t *            to use system-level default.\n\t */\n\tpublic UnicodeReader(InputStream in, String defaultEnc) {\n\t\tinternalIn = new PushbackInputStream(in, 4);\n\t\tthis.defaultEnc = defaultEnc;\n\t}\n", "refactored_code": "\tprivate static final int BOM_SIZE = 4;\n\t *            to use system-level default.\n\t */\n\tpublic UnicodeReader(InputStream in, String defaultEnc) {\n\t\tinternalIn = new PushbackInputStream(in, BOM_SIZE);\n\t\tthis.defaultEnc = defaultEnc;\n\t}\n"}
{"magic_number_smell": "\t\t\tmLastStatesMap.addMindmapLastStateStorage(pStore);\n\t\t}\n\t\t// size limit\n\t\tif (mLastStatesMap.sizeMindmapLastStateStorageList() > 50) {\n\t\t\t// make map from date to object:\n\t\t\tTreeMap dateToStoreMap = new TreeMap();\n\t\t\tfor (Iterator it = mLastStatesMap", "refactored_code": "\tpublic static final int LIST_AMOUNT_LIMIT = 50;\n\t\t\tmLastStatesMap.addMindmapLastStateStorage(pStore);\n\t\t}\n\t\t// size limit\n\t\tif (mLastStatesMap.sizeMindmapLastStateStorageList() > LIST_AMOUNT_LIMIT) {\n\t\t\t// make map from date to object:\n\t\t\tTreeMap dateToStoreMap = new TreeMap();\n\t\t\tfor (Iterator it = mLastStatesMap"}
{"magic_number_smell": "\tpublic static final String AMOUNT_OF_VISIBLE_MENU_ITEMS = \"AMOUNT_OF_VISIBLE_MENU_ITEMS\";\n\tpublic static final int 16 = 16;\n\tprivate String mOutputString;\n\tprivate static Icon blindIcon = new BlindIcon(16);\n\tprivate static final String SELECTED_ICON_PATH = \"images/button_ok.png\";\n\n\tprivate static final String SEPARATOR_TEXT = \"000\";", "refactored_code": "\tpublic static final int ICON_SIZE = 16;\n\tpublic static final String AMOUNT_OF_VISIBLE_MENU_ITEMS = \"AMOUNT_OF_VISIBLE_MENU_ITEMS\";\n\tpublic static final int ICON_SIZE = 16;\n\tprivate String mOutputString;\n\tprivate static Icon blindIcon = new BlindIcon(ICON_SIZE);\n\tprivate static final String SELECTED_ICON_PATH = \"images/button_ok.png\";\n\n\tprivate static final String SEPARATOR_TEXT = \"000\";"}
{"magic_number_smell": "\t\t */\n\t\tpublic void itemStateChanged(ItemEvent e) {\n\t\t\tif (e.getStateChange() == ItemEvent.SELECTED) {\n\t\t\t\tif (attributes.getSelectedIndex() == 0) {\n\t\t\t\t\tsimpleCondition.setModel(simpleNodeConditionComboBoxModel);\n\t\t\t\t\tsimpleCondition.setEnabled(true);\n\t\t\t\t\tvalues.setEditable(true);", "refactored_code": "\tprivate static final int NODE_POSITION = 0;\n\t\t */\n\t\tpublic void itemStateChanged(ItemEvent e) {\n\t\t\tif (e.getStateChange() == ItemEvent.SELECTED) {\n\t\t\t\tif (attributes.getSelectedIndex() == NODE_POSITION) {\n\t\t\t\t\tsimpleCondition.setModel(simpleNodeConditionComboBoxModel);\n\t\t\t\t\tsimpleCondition.setEnabled(true);\n\t\t\t\t\tvalues.setEditable(true);"}
{"magic_number_smell": "\n\tpublic int add(Comparable key, Object value) {\n\t\tint index = findElement(key);\n\t\tif ((index & 1 << 31) != 0) {\n\t\t\tindex &= ~1 << 31;\n\t\t\telements.add(index, new MapElement(key, value));\n\t\t}", "refactored_code": "\tprivate static final int ELEMENT_NOT_FOUND_FLAG = 1 << 31;\n\n\tpublic int add(Comparable key, Object value) {\n\t\tint index = findElement(key);\n\t\tif ((index & ELEMENT_NOT_FOUND_FLAG) != 0) {\n\t\t\tindex &= ~ELEMENT_NOT_FOUND_FLAG;\n\t\t\telements.add(index, new MapElement(key, value));\n\t\t}"}
{"magic_number_smell": "\t\t\tbuf.append('.');\n\t\t\tbuf.append(mMin);\n\t\t\tswitch (mType) {\n\t\t\tcase 0:\n\t\t\t\tbuf.append(' ');\n\t\t\t\tbuf.append(\"Alpha\");\n\t\t\t\tbreak;", "refactored_code": "\tpublic static final int VERSION_TYPE_ALPHA = 0;\n\t\t\tbuf.append('.');\n\t\t\tbuf.append(mMin);\n\t\t\tswitch (mType) {\n\t\t\tcase VERSION_TYPE_ALPHA:\n\t\t\t\tbuf.append(' ');\n\t\t\t\tbuf.append(\"Alpha\");\n\t\t\t\tbreak;"}
{"magic_number_smell": "\t\t\t\t// Encode the string into bytes using utf-8\n\t\t\t\tbyte[] utf8 = str.getBytes(\"UTF8\");\n\t\t\t\t// determine salt by random:\n\t\t\t\tbyte[] newSalt = new byte[8];\n\t\t\t\tfor (int i = 0; i < newSalt.length; i++) {\n\t\t\t\t\tnewSalt[i] = (byte) (Math.random() * 256l - 128l);\n\t\t\t\t}", "refactored_code": "\t\tprivate static final int SALT_LENGTH = 8;\n\t\t\t\t// Encode the string into bytes using utf-8\n\t\t\t\tbyte[] utf8 = str.getBytes(\"UTF8\");\n\t\t\t\t// determine salt by random:\n\t\t\t\tbyte[] newSalt = new byte[SALT_LENGTH];\n\t\t\t\tfor (int i = 0; i < newSalt.length; i++) {\n\t\t\t\t\tnewSalt[i] = (byte) (Math.random() * 256l - 128l);\n\t\t\t\t}"}
{"magic_number_smell": "\t * compatible. If the major version is different, you may need to modify the\n\t * client source code.\n\t * \n\t * @see freemind.main.XMLElement#2\n\t */\n\tpublic static final int NANOXML_MINOR_VERSION = 2;\n", "refactored_code": "\tpublic static final int NANOXML_MAJOR_VERSION = 2;\n\t * compatible. If the major version is different, you may need to modify the\n\t * client source code.\n\t * \n\t * @see freemind.main.XMLElement#NANOXML_MAJOR_VERSION\n\t */\n\tpublic static final int NANOXML_MINOR_VERSION = 2;\n"}
{"magic_number_smell": "\n\t/**\n\t * The line number in the source code where the error occurred, or\n\t * <code>-1</code> if the line number is unknown.\n\t * \n\t * <dl>\n\t * <dt><b>Invariants:</b></dt>", "refactored_code": "\tpublic static final int NO_LINE = -1;\n\n\t/**\n\t * The line number in the source code where the error occurred, or\n\t * <code>NO_LINE</code> if the line number is unknown.\n\t * \n\t * <dl>\n\t * <dt><b>Invariants:</b></dt>"}
{"magic_number_smell": "\n\tpublic EdgeAdapter(MindMapNode target, FreeMindMain frame) {\n\t\tsuper(target, frame);\n\t\tNORMAL_WIDTH = -1;\n\t\tif (listener == null) {\n\t\t\tlistener = new EdgeAdapterListener();\n\t\t\tController.addPropertyChangeListener(listener);", "refactored_code": "\tpublic static final int WIDTH_PARENT = -1;\n\n\tpublic EdgeAdapter(MindMapNode target, FreeMindMain frame) {\n\t\tsuper(target, frame);\n\t\tNORMAL_WIDTH = WIDTH_PARENT;\n\t\tif (listener == null) {\n\t\t\tlistener = new EdgeAdapterListener();\n\t\t\tController.addPropertyChangeListener(listener);"}
{"magic_number_smell": "\tpublic LineAdapter(MindMapNode target, FreeMindMain frame) {\n\t\tthis.frame = frame;\n\t\tthis.target = target;\n\t\twidth = -1;\n\t\tupdateStandards();\n\n\t}", "refactored_code": "\tpublic static final int DEFAULT_WIDTH = -1;\n\tpublic LineAdapter(MindMapNode target, FreeMindMain frame) {\n\t\tthis.frame = frame;\n\t\tthis.target = target;\n\t\twidth = DEFAULT_WIDTH;\n\t\tupdateStandards();\n\n\t}"}
{"magic_number_smell": "\t\tmTimerForFileChangeObservation = new Timer();\n\t\tmTimerForFileChangeObservation.schedule(\n\t\t\t\tnew FileChangeInspectorTimerTask(),\n\t\t\t\t5000,\n\t\t\t\t5000);\n\t}\n", "refactored_code": "\tprivate static final int INTERVAL_BETWEEN_FILE_MODIFICATION_TIME_CHECKS = 5000;\n\t\tmTimerForFileChangeObservation = new Timer();\n\t\tmTimerForFileChangeObservation.schedule(\n\t\t\t\tnew FileChangeInspectorTimerTask(),\n\t\t\t\tINTERVAL_BETWEEN_FILE_MODIFICATION_TIME_CHECKS,\n\t\t\t\tINTERVAL_BETWEEN_FILE_MODIFICATION_TIME_CHECKS);\n\t}\n"}
{"magic_number_smell": "\t */\n\tprivate static HashMap createdIcons = new HashMap();\n\tprivate static final int -1 = -1;\n\tpublic static final int LAST = -1;\n\tstatic int nextNumber = -1 - 1;\n\tprivate JComponent component = null;\n", "refactored_code": "\tprivate static final int UNKNOWN = -1;\n\t */\n\tprivate static HashMap createdIcons = new HashMap();\n\tprivate static final int UNKNOWN = -1;\n\tpublic static final int LAST = UNKNOWN;\n\tstatic int nextNumber = UNKNOWN - 1;\n\tprivate JComponent component = null;\n"}
{"magic_number_smell": "\tpublic static final String SHOW_ALL = \"extended\";\n\tpublic static final String HIDE_ALL = \"hide\";\n\tpublic static final int 75 = 75;\n\tprivate int[] width = { 75, 75 };\n\n\tprivate EventListenerList listenerList = null;\n\tChangeEvent changeEvent = null;", "refactored_code": "\tpublic static final int DEFAULT_COLUMN_WIDTH = 75;\n\tpublic static final String SHOW_ALL = \"extended\";\n\tpublic static final String HIDE_ALL = \"hide\";\n\tpublic static final int DEFAULT_COLUMN_WIDTH = 75;\n\tprivate int[] width = { DEFAULT_COLUMN_WIDTH, DEFAULT_COLUMN_WIDTH };\n\n\tprivate EventListenerList listenerList = null;\n\tChangeEvent changeEvent = null;"}
{"magic_number_smell": "\n\tprivate void allocateAttributes(int size) {\n\t\tif (attributes == null && size > 0)\n\t\t\tattributes = new Vector(size, 10);\n\t}\n\n\tpublic NodeAttributeTableModel(MindMapNode node) {", "refactored_code": "\tprivate static final int CAPACITY_INCREMENT = 10;\n\n\tprivate void allocateAttributes(int size) {\n\t\tif (attributes == null && size > 0)\n\t\t\tattributes = new Vector(size, CAPACITY_INCREMENT);\n\t}\n\n\tpublic NodeAttributeTableModel(MindMapNode node) {"}
{"magic_number_smell": "\n\tpublic static final int OK = 1;\n\n\tprivate int result = -1;\n\n\tprivate javax.swing.JPanel jContentPane = null;\n", "refactored_code": "\tpublic static final int CANCEL = -1;\n\n\tpublic static final int OK = 1;\n\n\tprivate int result = CANCEL;\n\n\tprivate javax.swing.JPanel jContentPane = null;\n"}
{"magic_number_smell": "\t\t\tstateAdded = !stateAdded;\n\t\t\tsetRemindUserAt(System.currentTimeMillis()\n\t\t\t\t\t+ BLINK_INTERVAL_IN_MILLIES); // 3\n\t\t\tdisplayState((stateAdded) ? CLOCK_VISIBLE : 0,\n\t\t\t\t\tgetNode(), true);\n\n\t\t}", "refactored_code": "\tprivate static final int CLOCK_INVISIBLE = 0;\n\t\t\tstateAdded = !stateAdded;\n\t\t\tsetRemindUserAt(System.currentTimeMillis()\n\t\t\t\t\t+ BLINK_INTERVAL_IN_MILLIES); // 3\n\t\t\tdisplayState((stateAdded) ? CLOCK_VISIBLE : CLOCK_INVISIBLE,\n\t\t\t\t\tgetNode(), true);\n\n\t\t}"}
{"magic_number_smell": "\tpublic void nodeStructureChanged(MindMapNode node);\n\n\t/**\n\t * The following modes are present: public final int 1\n\t * = 1; // old model of insertion public final int NEW_CHILD = 2; public\n\t * final int NEW_SIBLING_BEHIND = 3; public final int NEW_SIBLING_BEFORE =\n\t * 4; see MindMapController", "refactored_code": "\tpublic static final int NEW_CHILD_WITHOUT_FOCUS = 1; // old model of\n\tpublic void nodeStructureChanged(MindMapNode node);\n\n\t/**\n\t * The following modes are present: public final int NEW_CHILD_WITHOUT_FOCUS\n\t * = 1; // old model of insertion public final int NEW_CHILD = 2; public\n\t * final int NEW_SIBLING_BEHIND = 3; public final int NEW_SIBLING_BEFORE =\n\t * 4; see MindMapController"}
{"magic_number_smell": "\t\tXmlAction dcUndo = Tools.deepCopy(pair.getUndoAction());\n\t\tlong currentTime = System.currentTimeMillis();\n\t\tif ((actionPairList.size() > 0)\n\t\t\t\t&& (actionFrameStarted || currentTime - timeOfLastAdd < 100)) {\n\t\t\t// the actions are gathered in one compound action.\n\t\t\tActionPair firstPair = (ActionPair) actionPairList.get(0);\n\t\t\tCompoundAction action;", "refactored_code": "\tprivate static final long TIME_TO_BEGIN_NEW_ACTION = 100;\n\t\tXmlAction dcUndo = Tools.deepCopy(pair.getUndoAction());\n\t\tlong currentTime = System.currentTimeMillis();\n\t\tif ((actionPairList.size() > 0)\n\t\t\t\t&& (actionFrameStarted || currentTime - timeOfLastAdd < TIME_TO_BEGIN_NEW_ACTION)) {\n\t\t\t// the actions are gathered in one compound action.\n\t\t\tActionPair firstPair = (ActionPair) actionPairList.get(0);\n\t\t\tCompoundAction action;"}
{"magic_number_smell": "\t\t\tDefaultMutableTreeNode node = (DefaultMutableTreeNode) value;\n\t\t\tTreeNodeInfo info = (TreeNodeInfo) node.getUserObject();\n\t\t\tswitch (info.getSelected()) {\n\t\t\tcase TreeNodeInfo.0:\n\t\t\t\tsetIcon(iconFull);\n\t\t\t\tbreak;\n\t\t\tcase TreeNodeInfo.PARTIAL_SELECTED:", "refactored_code": "\t\tstatic private final int FULL_SELECTED = 0;\n\t\t\tDefaultMutableTreeNode node = (DefaultMutableTreeNode) value;\n\t\t\tTreeNodeInfo info = (TreeNodeInfo) node.getUserObject();\n\t\t\tswitch (info.getSelected()) {\n\t\t\tcase TreeNodeInfo.FULL_SELECTED:\n\t\t\t\tsetIcon(iconFull);\n\t\t\t\tbreak;\n\t\t\tcase TreeNodeInfo.PARTIAL_SELECTED:"}
{"magic_number_smell": "\t\t// flatten the curve and test for intersection (bug fix, fc, 16.1.2004).\n\t\tFlatteningPathIterator pi = new FlatteningPathIterator(\n\t\t\t\tarrowLinkCurve.getPathIterator(null),\n\t\t\t\t16 / 4, 10/*\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t * =maximal\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t * 2^10=1024\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t * points.", "refactored_code": "\tprivate final int MAXIMAL_RECTANGLE_SIZE_FOR_COLLISION_DETECTION = 16;\n\t\t// flatten the curve and test for intersection (bug fix, fc, 16.1.2004).\n\t\tFlatteningPathIterator pi = new FlatteningPathIterator(\n\t\t\t\tarrowLinkCurve.getPathIterator(null),\n\t\t\t\tMAXIMAL_RECTANGLE_SIZE_FOR_COLLISION_DETECTION / 4, 10/*\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t * =maximal\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t * 2^10=1024\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t * points."}
{"magic_number_smell": "\t\t\t\t&& !VerticalRootNodeViewLayout.USE_COMMON_OUT_POINT_FOR_ROOT_NODE) {\n\t\t\tsourceSign = 0;\n\t\t}\n\t\tint xctrl = getMap().getZoomed(sourceSign * sign * 12);\n\t\tint childXctrl = getMap().getZoomed(-1 * sign * CHILD_XCTRL);\n\n\t\tgraph.setCurve(start.x, start.y, start.x + xctrl, start.y, end.x", "refactored_code": "\tprivate static final int XCTRL = 12;// the distance between endpoint and\n\t\t\t\t&& !VerticalRootNodeViewLayout.USE_COMMON_OUT_POINT_FOR_ROOT_NODE) {\n\t\t\tsourceSign = 0;\n\t\t}\n\t\tint xctrl = getMap().getZoomed(sourceSign * sign * XCTRL);\n\t\tint childXctrl = getMap().getZoomed(-1 * sign * CHILD_XCTRL);\n\n\t\tgraph.setCurve(start.x, start.y, start.x + xctrl, start.y, end.x"}
{"magic_number_smell": "\t\t\tprefSize.width += getNodeView().getMap().getZoomed(10);\n\t\t}\n\t\tprefSize.width = Math.max(\n\t\t\t\tgetNodeView().getMap().getZoomed(10),\n\t\t\t\tprefSize.width);\n\t\tif (isEmpty) {\n\t\t\tsetText(\"\");", "refactored_code": "\tprivate static final int MIN_HOR_NODE_SIZE = 10;\n\t\t\tprefSize.width += getNodeView().getMap().getZoomed(10);\n\t\t}\n\t\tprefSize.width = Math.max(\n\t\t\t\tgetNodeView().getMap().getZoomed(MIN_HOR_NODE_SIZE),\n\t\t\t\tprefSize.width);\n\t\tif (isEmpty) {\n\t\t\tsetText(\"\");"}
{"magic_number_smell": "\tpublic Insets getAutoscrollInsets() {\n\t\tRectangle outer = getBounds();\n\t\tRectangle inner = getParent().getBounds();\n\t\treturn new Insets(inner.y - outer.y + 20, inner.x - outer.x\n\t\t\t\t+ 20, outer.height - inner.height - inner.y + outer.y\n\t\t\t\t+ 20, outer.width - inner.width - inner.x + outer.x\n\t\t\t\t+ 20);", "refactored_code": "\tprivate static final int margin = 20;\n\tpublic Insets getAutoscrollInsets() {\n\t\tRectangle outer = getBounds();\n\t\tRectangle inner = getParent().getBounds();\n\t\treturn new Insets(inner.y - outer.y + margin, inner.x - outer.x\n\t\t\t\t+ margin, outer.height - inner.height - inner.y + outer.y\n\t\t\t\t+ margin, outer.width - inner.width - inner.x + outer.x\n\t\t\t\t+ margin);"}
{"magic_number_smell": "\t\t\t\tpublic void mouseClicked(MouseEvent pE) {\n\t\t\t\t}\n\t\t\t});\n\t\t\tint delay = 50;\n\t\t\tActionListener taskPerformer = new ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent evt) {\n\t\t\t\t\tif (mIsEntered && mColorCounter < COLOR_COUNTER_MAX) {", "refactored_code": "\tprivate static final int TIMER_DELAY = 50;\n\t\t\t\tpublic void mouseClicked(MouseEvent pE) {\n\t\t\t\t}\n\t\t\t});\n\t\t\tint delay = TIMER_DELAY;\n\t\t\tActionListener taskPerformer = new ActionListener() {\n\t\t\t\tpublic void actionPerformed(ActionEvent evt) {\n\t\t\t\t\tif (mIsEntered && mColorCounter < COLOR_COUNTER_MAX) {"}
{"magic_number_smell": "\n\tprivate void update() {\n\t\tfloat zoom = getMap().getZoom();\n\t\tfloat xctrlRelative = 12 * zoom;\n\t\t// YCTRL could be implemented but then we had to check whether target is\n\t\t// above or below source.\n\t\tif (getTarget().isLeft()) {", "refactored_code": "\tprivate static final float XCTRL = 12;// the distance between endpoint and\n\n\tprivate void update() {\n\t\tfloat zoom = getMap().getZoom();\n\t\tfloat xctrlRelative = XCTRL * zoom;\n\t\t// YCTRL could be implemented but then we had to check whether target is\n\t\t// above or below source.\n\t\tif (getTarget().isLeft()) {"}
{"magic_number_smell": "\t\tfloat zoom = getZoom();\n\t\tDimension dimension = super.getPreferredSize();\n\t\tdimension.width = Math.min((int) (MAX_WIDTH * zoom), dimension.width);\n\t\tdimension.height = Math.min((int) (300 * zoom)\n\t\t\t\t- getTableHeaderHeight(), dimension.height);\n\t\treturn dimension;\n\t}", "refactored_code": "\tprivate static final int MAX_HEIGTH = 300;\n\t\tfloat zoom = getZoom();\n\t\tDimension dimension = super.getPreferredSize();\n\t\tdimension.width = Math.min((int) (MAX_WIDTH * zoom), dimension.width);\n\t\tdimension.height = Math.min((int) (MAX_HEIGTH * zoom)\n\t\t\t\t- getTableHeaderHeight(), dimension.height);\n\t\treturn dimension;\n\t}"}
{"magic_number_smell": "\n\tpublic ExtendedAttributeTableModelDecorator(AttributeView attrView) {\n\t\tsuper(attrView);\n\t\tnewRow = Integer.MAX_VALUE;\n\t}\n\n\tpublic int getRowCount() {", "refactored_code": "\tprivate static final int AFTER_LAST_ROW = Integer.MAX_VALUE;\n\n\tpublic ExtendedAttributeTableModelDecorator(AttributeView attrView) {\n\t\tsuper(attrView);\n\t\tnewRow = AFTER_LAST_ROW;\n\t}\n\n\tpublic int getRowCount() {"}
{"magic_number_smell": "        // the listener classes,\n        //to enable JabberListener to react to accepting/declining map share\n        // invitations.\n        setState(1);\n        addListeners();\n\n        //TODO: Evil hack. Need to retrieve the title here for real", "refactored_code": "    private final int STATE_NOT_CONNECTED = 1;\n        // the listener classes,\n        //to enable JabberListener to react to accepting/declining map share\n        // invitations.\n        setState(STATE_NOT_CONNECTED);\n        addListeners();\n\n        //TODO: Evil hack. Need to retrieve the title here for real"}
{"magic_number_smell": "        notificationMessageDisplayPanel.setLayout(layout);\n\n        notificationMessageDisplayPanel.remove(notificationMessage);\n        notificationMessage.setSize(INFO_MESSAGE_WIDTH, 20);\n        notificationMessage.setBackground(BACKGROUNDCOLOR);\n        notificationMessage.setText(message);\n        notificationMessageDisplayPanel.add(notificationMessage);", "refactored_code": "    private static final int INFO_MESSAGE_HEIGHT = 20;\n        notificationMessageDisplayPanel.setLayout(layout);\n\n        notificationMessageDisplayPanel.remove(notificationMessage);\n        notificationMessage.setSize(INFO_MESSAGE_WIDTH, INFO_MESSAGE_HEIGHT);\n        notificationMessage.setBackground(BACKGROUNDCOLOR);\n        notificationMessage.setText(message);\n        notificationMessageDisplayPanel.add(notificationMessage);"}
{"magic_number_smell": "\t\tmLockId = null;\n\t\tint lockTries = 0;\n\t\tint timeout = 0;\n\t\twhile(lockTries < 5) {\n\t\t\tCollaborationRequireLock lockRequest = new CollaborationRequireLock();\n\t\t\tsetCurrentState(STATE_WAIT_FOR_LOCK);\n\t\t\tif (!send(lockRequest)) {", "refactored_code": "\tprivate static final int MAX_LOCK_RETRIES = 5;\n\t\tmLockId = null;\n\t\tint lockTries = 0;\n\t\tint timeout = 0;\n\t\twhile(lockTries < MAX_LOCK_RETRIES) {\n\t\t\tCollaborationRequireLock lockRequest = new CollaborationRequireLock();\n\t\t\tsetCurrentState(STATE_WAIT_FOR_LOCK);\n\t\t\tif (!send(lockRequest)) {"}
{"magic_number_smell": "\t\t\t\tlogger.finest(\"Waiting for message\");\n\t\t\t\tSocket client = mServer.accept();\n\t\t\t\tlogger.info(\"Received new client.\");\n\t\t\t\tclient.setSoTimeout(500);\n\t\t\t\tServerCommunication c = new ServerCommunication(\n\t\t\t\t\t\tMindMapMaster.this, client, getMindMapController());\n\t\t\t\tc.start();", "refactored_code": "\tpublic static final int SOCKET_TIMEOUT_IN_MILLIES = 500;\n\t\t\t\tlogger.finest(\"Waiting for message\");\n\t\t\t\tSocket client = mServer.accept();\n\t\t\t\tlogger.info(\"Received new client.\");\n\t\t\t\tclient.setSoTimeout(SOCKET_TIMEOUT_IN_MILLIES);\n\t\t\t\tServerCommunication c = new ServerCommunication(\n\t\t\t\t\t\tMindMapMaster.this, client, getMindMapController());\n\t\t\t\tc.start();"}
{"magic_number_smell": "\t\t */\n\t\tpublic Class getColumnClass(int arg0) {\n\t\t\tswitch (arg0) {\n\t\t\tcase 0:\n\t\t\t\treturn String.class;\n\t\t\tcase SEARCH_DISTANCE_COLUMN:\n\t\t\t\treturn Double.class;", "refactored_code": "\tprivate static final int SEARCH_DESCRIPTION_COLUMN = 0;\n\t\t */\n\t\tpublic Class getColumnClass(int arg0) {\n\t\t\tswitch (arg0) {\n\t\t\tcase SEARCH_DESCRIPTION_COLUMN:\n\t\t\t\treturn String.class;\n\t\t\tcase SEARCH_DISTANCE_COLUMN:\n\t\t\t\treturn Double.class;"}
{"magic_number_smell": "\t/**\n\t * \n\t */\n\tprivate static final int CIRCLE_DIAMETER = 5 * 2;\n\tprotected MapDialog mMapDialog;\n\tboolean mSelected = false;\n\tprotected static java.util.logging.Logger logger = null;", "refactored_code": "\tpublic static final int CIRCLE_RADIUS = 5;\n\t/**\n\t * \n\t */\n\tprivate static final int CIRCLE_DIAMETER = CIRCLE_RADIUS * 2;\n\tprotected MapDialog mMapDialog;\n\tboolean mSelected = false;\n\tprotected static java.util.logging.Logger logger = null;"}
{"magic_number_smell": "\t\t\tGraphics2D g2 = (Graphics2D) pG;\n\t\t\tStroke oldStroke = g2.getStroke();\n\t\t\tg2.setStroke(new BasicStroke(4));\n\t\t\tint xo = pPosition.x - CIRCLE_RADIUS * 2;\n\t\t\tint xu = pPosition.x + CIRCLE_RADIUS * 2;\n\t\t\tint yo = pPosition.y - CIRCLE_RADIUS * 2;\n\t\t\tint yu = pPosition.y + CIRCLE_RADIUS * 2;", "refactored_code": "\tpublic static final int CIRCLE_SELECTED_FACTOR = 2;\n\t\t\tGraphics2D g2 = (Graphics2D) pG;\n\t\t\tStroke oldStroke = g2.getStroke();\n\t\t\tg2.setStroke(new BasicStroke(4));\n\t\t\tint xo = pPosition.x - CIRCLE_RADIUS * CIRCLE_SELECTED_FACTOR;\n\t\t\tint xu = pPosition.x + CIRCLE_RADIUS * CIRCLE_SELECTED_FACTOR;\n\t\t\tint yo = pPosition.y - CIRCLE_RADIUS * CIRCLE_SELECTED_FACTOR;\n\t\t\tint yu = pPosition.y + CIRCLE_RADIUS * CIRCLE_SELECTED_FACTOR;"}
{"magic_number_smell": "\tpublic void checkAccept(String pHost, int pPort) {\n\t\tif (mWithoutNetworkRestriction)\n\t\t\treturn;\n\t\tthrow getException(PERM_GROUP_NETWORK, 0);\n\t}\n\n\tpublic void checkConnect(String pHost, int pPort, Object pContext) {", "refactored_code": "\tprivate static final int PERM_Accept = 0;\n\tpublic void checkAccept(String pHost, int pPort) {\n\t\tif (mWithoutNetworkRestriction)\n\t\t\treturn;\n\t\tthrow getException(PERM_GROUP_NETWORK, PERM_Accept);\n\t}\n\n\tpublic void checkConnect(String pHost, int pPort, Object pContext) {"}
{"magic_number_smell": "\tprivate void addPaper(MediaSizeName name, String displayName) {\n\t\tMediaSize mSize = MediaSize.getMediaSizeForName(name);\n\t\tPaper paper = new Paper();\n\t\tpaper.setSize(mSize.getX(MediaSize.MM) * 96 / 25.4, mSize.getY(MediaSize.MM)\n\t\t\t\t* 96 / 25.4);\n\t\tpaperFormats.put(displayName, paper);\n\t}", "refactored_code": "\tprivate static final double ppmm = 96 / 25.4;\n\tprivate void addPaper(MediaSizeName name, String displayName) {\n\t\tMediaSize mSize = MediaSize.getMediaSizeForName(name);\n\t\tPaper paper = new Paper();\n\t\tpaper.setSize(mSize.getX(MediaSize.MM) * ppmm, mSize.getY(MediaSize.MM)\n\t\t\t\t* ppmm);\n\t\tpaperFormats.put(displayName, paper);\n\t}"}
{"magic_number_smell": "\t\t * @param pAmountOfSteps\n\t\t */\n\t\tpublic TestTask(JFrame pFrame) {\n\t\t\tsuper(pFrame, 10, \"TestTask\");\n\t\t}\n\n\t\tprivate int i = 10;", "refactored_code": "\t\tprivate static final int AMOUNT_OF_TIME = 10;\n\t\t * @param pAmountOfSteps\n\t\t */\n\t\tpublic TestTask(JFrame pFrame) {\n\t\t\tsuper(pFrame, AMOUNT_OF_TIME, \"TestTask\");\n\t\t}\n\n\t\tprivate int i = AMOUNT_OF_TIME;"}
{"magic_number_smell": "    * precedes aChild, which must be a child of this node; otherwise, retrun null.  \n    * @return the child node that immediately precede aChild node.\n    ***************************************************************************/\n    public Node getChildBefore(Node aChild){ return getChild(aChild, 0); }\n\n    \n   /***************************************************************************", "refactored_code": "\tprivate static final int BEFORE  = 0;  // used in getChildBefore()\n    * precedes aChild, which must be a child of this node; otherwise, retrun null.  \n    * @return the child node that immediately precede aChild node.\n    ***************************************************************************/\n    public Node getChildBefore(Node aChild){ return getChild(aChild, BEFORE); }\n\n    \n   /***************************************************************************"}
{"magic_number_smell": "\n        String user = System.getProperty(\"user.name\", \"\");\n\n        if (user.length() > 31) {\n            user = user.substring(0, 31);\n        }\n", "refactored_code": "    public static final int MAX_NAMELEN = 31;\n\n        String user = System.getProperty(\"user.name\", \"\");\n\n        if (user.length() > MAX_NAMELEN) {\n            user = user.substring(0, MAX_NAMELEN);\n        }\n"}
{"magic_number_smell": "        if (currEntry != null && currEntry.isGNULongNameEntry()) {\n            // read in the name\n            StringBuffer longName = new StringBuffer();\n            byte[] buf = new byte[256];\n            int length = 0;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));", "refactored_code": "    private static final int SMALL_BUFFER_SIZE = 256;\n        if (currEntry != null && currEntry.isGNULongNameEntry()) {\n            // read in the name\n            StringBuffer longName = new StringBuffer();\n            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n            int length = 0;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));"}
{"magic_number_smell": "    protected int       assemLen;\n    protected byte[]    assemBuf;\n    protected TarBuffer buffer;\n    protected int       longFileMode = 0;\n    // CheckStyle:VisibilityModifier ON\n\n    private boolean closed = false;", "refactored_code": "    public static final int LONGFILE_ERROR = 0;\n    protected int       assemLen;\n    protected byte[]    assemBuf;\n    protected TarBuffer buffer;\n    protected int       longFileMode = LONGFILE_ERROR;\n    // CheckStyle:VisibilityModifier ON\n\n    private boolean closed = false;"}
{"magic_number_smell": "        long sum = 0;\n\n        for (int i = 0; i < buf.length; ++i) {\n            sum += 255 & buf[i];\n        }\n\n        return sum;", "refactored_code": "    private static final int BYTE_MASK = 255;\n        long sum = 0;\n\n        for (int i = 0; i < buf.length; ++i) {\n            sum += BYTE_MASK & buf[i];\n        }\n\n        return sum;"}
{"magic_number_smell": "\n\n    private void write(ByteBuffer buffer, MetaData metaData) {\n        writeString(buffer, 0, metaData.getHost());\n        writeNumber(buffer, TYPE_TIME, metaData.getTimestamp());\n        writeString(buffer, TYPE_PLUGIN, metaData.getPlugin());\n        writeString(buffer, TYPE_PLUGIN_INSTANCE, metaData.getPluginInstance());", "refactored_code": "    private static final int TYPE_HOST = 0;\n\n\n    private void write(ByteBuffer buffer, MetaData metaData) {\n        writeString(buffer, TYPE_HOST, metaData.getHost());\n        writeNumber(buffer, TYPE_TIME, metaData.getTimestamp());\n        writeString(buffer, TYPE_PLUGIN, metaData.getPlugin());\n        writeString(buffer, TYPE_PLUGIN_INSTANCE, metaData.getPluginInstance());"}
{"magic_number_smell": "    private final Deque<Chunk> chunks = new ArrayDeque<>();\n\n    ChunkedAssociativeLongArray() {\n        this(512);\n    }\n\n    ChunkedAssociativeLongArray(int chunkSize) {", "refactored_code": "    private static final int DEFAULT_CHUNK_SIZE = 512;\n    private final Deque<Chunk> chunks = new ArrayDeque<>();\n\n    ChunkedAssociativeLongArray() {\n        this(DEFAULT_CHUNK_SIZE);\n    }\n\n    ChunkedAssociativeLongArray(int chunkSize) {"}
{"magic_number_smell": "    private void printWithBanner(String s, char c) {\n        output.print(s);\n        output.print(' ');\n        for (int i = 0; i < (80 - s.length() - 1); i++) {\n            output.print(c);\n        }\n        output.println();", "refactored_code": "    private static final int CONSOLE_WIDTH = 80;\n    private void printWithBanner(String s, char c) {\n        output.print(s);\n        output.print(' ');\n        for (int i = 0; i < (CONSOLE_WIDTH - s.length() - 1); i++) {\n            output.print(c);\n        }\n        output.println();"}
{"magic_number_smell": "    private static final int ONE_MINUTE = 1;\n    private static final int FIVE_MINUTES = 5;\n    private static final int FIFTEEN_MINUTES = 15;\n    private static final double M1_ALPHA = 1 - exp(-5 / SECONDS_PER_MINUTE / ONE_MINUTE);\n    private static final double M5_ALPHA = 1 - exp(-5 / SECONDS_PER_MINUTE / FIVE_MINUTES);\n    private static final double M15_ALPHA = 1 - exp(-5 / SECONDS_PER_MINUTE / FIFTEEN_MINUTES);\n", "refactored_code": "    private static final int INTERVAL = 5;\n    private static final int ONE_MINUTE = 1;\n    private static final int FIVE_MINUTES = 5;\n    private static final int FIFTEEN_MINUTES = 15;\n    private static final double M1_ALPHA = 1 - exp(-INTERVAL / SECONDS_PER_MINUTE / ONE_MINUTE);\n    private static final double M5_ALPHA = 1 - exp(-INTERVAL / SECONDS_PER_MINUTE / FIVE_MINUTES);\n    private static final double M15_ALPHA = 1 - exp(-INTERVAL / SECONDS_PER_MINUTE / FIFTEEN_MINUTES);\n"}
{"magic_number_smell": "     * factor of 0.015, which heavily biases the reservoir to the past 5 minutes of measurements.\n     */\n    public ExponentiallyDecayingReservoir() {\n        this(1028, DEFAULT_ALPHA);\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_SIZE = 1028;\n     * factor of 0.015, which heavily biases the reservoir to the past 5 minutes of measurements.\n     */\n    public ExponentiallyDecayingReservoir() {\n        this(DEFAULT_SIZE, DEFAULT_ALPHA);\n    }\n\n    /**"}
{"magic_number_smell": "        final long oldTick = lastTick.get();\n        final long newTick = clock.getTick();\n        final long age = newTick - oldTick;\n        if (age > TimeUnit.SECONDS.toNanos(5)) {\n            final long newIntervalStartTick = newTick - age % TimeUnit.SECONDS.toNanos(5);\n            if (lastTick.compareAndSet(oldTick, newIntervalStartTick)) {\n                final long requiredTicks = age / TimeUnit.SECONDS.toNanos(5);", "refactored_code": "    private static final long TICK_INTERVAL = TimeUnit.SECONDS.toNanos(5);\n        final long oldTick = lastTick.get();\n        final long newTick = clock.getTick();\n        final long age = newTick - oldTick;\n        if (age > TICK_INTERVAL) {\n            final long newIntervalStartTick = newTick - age % TICK_INTERVAL;\n            if (lastTick.compareAndSet(oldTick, newIntervalStartTick)) {\n                final long requiredTicks = age / TICK_INTERVAL;"}
{"magic_number_smell": "\n    private LockFreeExponentiallyDecayingReservoir(int size, double alpha, Duration rescaleThreshold, Clock clock) {\n        // Scale alpha to nanoseconds\n        double alphaNanos = alpha * .000_000_001D;\n        this.size = size;\n        this.clock = clock;\n        this.rescaleThresholdNanos = rescaleThreshold.toNanos();", "refactored_code": "    private static final double SECONDS_PER_NANO = .000_000_001D;\n\n    private LockFreeExponentiallyDecayingReservoir(int size, double alpha, Duration rescaleThreshold, Clock clock) {\n        // Scale alpha to nanoseconds\n        double alphaNanos = alpha * SECONDS_PER_NANO;\n        this.size = size;\n        this.clock = clock;\n        this.rescaleThresholdNanos = rescaleThreshold.toNanos();"}
{"magic_number_smell": "    private static final long 256L = 256L;\n    // only trim on updating once every N\n    private static final long TRIM_THRESHOLD = 256L;\n    private static final long CLEAR_BUFFER = TimeUnit.HOURS.toNanos(1) * 256L;\n\n    private final Clock clock;\n    private final ChunkedAssociativeLongArray measurements;", "refactored_code": "    private static final long COLLISION_BUFFER = 256L;\n    private static final long COLLISION_BUFFER = 256L;\n    // only trim on updating once every N\n    private static final long TRIM_THRESHOLD = 256L;\n    private static final long CLEAR_BUFFER = TimeUnit.HOURS.toNanos(1) * COLLISION_BUFFER;\n\n    private final Clock clock;\n    private final ChunkedAssociativeLongArray measurements;"}
{"magic_number_smell": "\n    private static final long 15 = 15;\n    private static final long TICK_INTERVAL = TimeUnit.SECONDS.toNanos(1);\n    private static final Duration TIME_WINDOW_DURATION = Duration.ofMinutes(15);\n\n    // package private for the benefit of the unit test\n    static final int NUMBER_OF_BUCKETS = (int) (TIME_WINDOW_DURATION.toNanos() / TICK_INTERVAL);", "refactored_code": "    private static final long TIME_WINDOW_DURATION_MINUTES = 15;\n\n    private static final long TIME_WINDOW_DURATION_MINUTES = 15;\n    private static final long TICK_INTERVAL = TimeUnit.SECONDS.toNanos(1);\n    private static final Duration TIME_WINDOW_DURATION = Duration.ofMinutes(TIME_WINDOW_DURATION_MINUTES);\n\n    // package private for the benefit of the unit test\n    static final int NUMBER_OF_BUCKETS = (int) (TIME_WINDOW_DURATION.toNanos() / TICK_INTERVAL);"}
{"magic_number_smell": "    // only trim on updating once every N\n    private static final int TRIM_THRESHOLD = 256;\n    // offsets the front of the time window for the purposes of clearing the buffer in trim\n    private static final long CLEAR_BUFFER = TimeUnit.HOURS.toNanos(1) * 256;\n\n    private final Clock clock;\n    private final ConcurrentSkipListMap<Long, Long> measurements;", "refactored_code": "    private static final int COLLISION_BUFFER = 256;\n    // only trim on updating once every N\n    private static final int TRIM_THRESHOLD = 256;\n    // offsets the front of the time window for the purposes of clearing the buffer in trim\n    private static final long CLEAR_BUFFER = TimeUnit.HOURS.toNanos(1) * COLLISION_BUFFER;\n\n    private final Clock clock;\n    private final ConcurrentSkipListMap<Long, Long> measurements;"}
{"magic_number_smell": "     * with a 5% margin of error assuming a normal distribution.\n     */\n    public UniformReservoir() {\n        this(1028);\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_SIZE = 1028;\n     * with a 5% margin of error assuming a normal distribution.\n     */\n    public UniformReservoir() {\n        this(DEFAULT_SIZE);\n    }\n\n    /**"}
{"magic_number_smell": "            return value.incrementAndGet();\n        }\n    };\n    private final ExecutorService executor = Executors.newFixedThreadPool(10);\n\n    @Test\n    public void cachesTheValueForTheGivenPeriod() {", "refactored_code": "    private static final int THREAD_COUNT = 10;\n            return value.incrementAndGet();\n        }\n    };\n    private final ExecutorService executor = Executors.newFixedThreadPool(THREAD_COUNT);\n\n    @Test\n    public void cachesTheValueForTheGivenPeriod() {"}
{"magic_number_smell": "    private final ThreadFactory factory = Executors.defaultThreadFactory();\n    private final MetricRegistry registry = new MetricRegistry();\n    private final InstrumentedThreadFactory instrumentedFactory = new InstrumentedThreadFactory(factory, registry, \"factory\");\n    private final ExecutorService executor = Executors.newFixedThreadPool(10, instrumentedFactory);\n\n    /**\n     * Tests all parts of the InstrumentedThreadFactory except for termination since that", "refactored_code": "    private static final int THREAD_COUNT = 10;\n    private final ThreadFactory factory = Executors.defaultThreadFactory();\n    private final MetricRegistry registry = new MetricRegistry();\n    private final InstrumentedThreadFactory instrumentedFactory = new InstrumentedThreadFactory(factory, registry, \"factory\");\n    private final ExecutorService executor = Executors.newFixedThreadPool(THREAD_COUNT, instrumentedFactory);\n\n    /**\n     * Tests all parts of the InstrumentedThreadFactory except for termination since that"}
{"magic_number_smell": "\n    @Before\n    public void setUp() {\n        when(clock.getTime()).thenReturn(1000198 * 1000);\n    }\n\n    @Test", "refactored_code": "    private final long timestamp = 1000198;\n\n    @Before\n    public void setUp() {\n        when(clock.getTime()).thenReturn(timestamp * 1000);\n    }\n\n    @Test"}
{"magic_number_smell": "    private final String host = \"example.com\";\n    private final int 1234 = 1234;\n    private final SocketFactory socketFactory = mock(SocketFactory.class);\n    private final InetSocketAddress address = new InetSocketAddress(host, 1234);\n\n    private final Socket socket = mock(Socket.class);\n    private final ByteArrayOutputStream output = spy(ByteArrayOutputStream.class);", "refactored_code": "    private final int port = 1234;\n    private final String host = \"example.com\";\n    private final int port = 1234;\n    private final SocketFactory socketFactory = mock(SocketFactory.class);\n    private final InetSocketAddress address = new InetSocketAddress(host, port);\n\n    private final Socket socket = mock(Socket.class);\n    private final ByteArrayOutputStream output = spy(ByteArrayOutputStream.class);"}
{"magic_number_smell": "\n    @Test\n    public void connects() throws Exception {\n        graphiteUDP = new GraphiteUDP(host, 1234);\n        graphiteUDP.connect();\n\n        assertThat(graphiteUDP.getDatagramChannel()).isNotNull();", "refactored_code": "    private final int port = 1234;\n\n    @Test\n    public void connects() throws Exception {\n        graphiteUDP = new GraphiteUDP(host, port);\n        graphiteUDP.connect();\n\n        assertThat(graphiteUDP.getDatagramChannel()).isNotNull();"}
{"magic_number_smell": "        @Override\n        public int hashCode() {\n            int result = healthy ? 1 : 0;\n            result = 31 * result + (message != null ? message.hashCode() : 0);\n            result = 31 * result + (error != null ? error.hashCode() : 0);\n            result = 31 * result + (Long.hashCode(time));\n            return result;", "refactored_code": "        private static final int PRIME = 31;\n        @Override\n        public int hashCode() {\n            int result = healthy ? 1 : 0;\n            result = PRIME * result + (message != null ? message.hashCode() : 0);\n            result = PRIME * result + (error != null ? error.hashCode() : 0);\n            result = PRIME * result + (Long.hashCode(time));\n            return result;"}
{"magic_number_smell": "     * Creates a new {@link HealthCheckRegistry}.\n     */\n    public HealthCheckRegistry() {\n        this(2);\n    }\n\n    /**", "refactored_code": "    private static final int ASYNC_EXECUTOR_POOL_SIZE = 2;\n     * Creates a new {@link HealthCheckRegistry}.\n     */\n    public HealthCheckRegistry() {\n        this(ASYNC_EXECUTOR_POOL_SIZE);\n    }\n\n    /**"}
{"magic_number_smell": "\n    private static final long 1551002401000L = 1551002401000L;\n    \n    private static final Clock FIXED_CLOCK = clockWithFixedTime(1551002401000L);\n\n    private static final HealthCheck.Result EXPECTED_EXPIRED_RESULT = HealthCheck.Result\n            .builder()", "refactored_code": "    private static final long CURRENT_TIME = 1551002401000L;\n\n    private static final long CURRENT_TIME = 1551002401000L;\n    \n    private static final Clock FIXED_CLOCK = clockWithFixedTime(CURRENT_TIME);\n\n    private static final HealthCheck.Result EXPECTED_EXPIRED_RESULT = HealthCheck.Result\n            .builder()"}
{"magic_number_smell": "\n    private static Map<Integer, String> createMeterNamesByStatusCode() {\n        final Map<Integer, String> meterNamesByStatusCode = new HashMap<>(6);\n        meterNamesByStatusCode.put(200, NAME_PREFIX + \"ok\");\n        meterNamesByStatusCode.put(CREATED, NAME_PREFIX + \"created\");\n        meterNamesByStatusCode.put(NO_CONTENT, NAME_PREFIX + \"noContent\");\n        meterNamesByStatusCode.put(BAD_REQUEST, NAME_PREFIX + \"badRequest\");", "refactored_code": "    private static final int OK = 200;\n\n    private static Map<Integer, String> createMeterNamesByStatusCode() {\n        final Map<Integer, String> meterNamesByStatusCode = new HashMap<>(6);\n        meterNamesByStatusCode.put(OK, NAME_PREFIX + \"ok\");\n        meterNamesByStatusCode.put(CREATED, NAME_PREFIX + \"created\");\n        meterNamesByStatusCode.put(NO_CONTENT, NAME_PREFIX + \"noContent\");\n        meterNamesByStatusCode.put(BAD_REQUEST, NAME_PREFIX + \"badRequest\");"}
{"magic_number_smell": "\n    private static Map<Integer, String> createMeterNamesByStatusCode() {\n        final Map<Integer, String> meterNamesByStatusCode = new HashMap<>(6);\n        meterNamesByStatusCode.put(200, NAME_PREFIX + \"ok\");\n        meterNamesByStatusCode.put(CREATED, NAME_PREFIX + \"created\");\n        meterNamesByStatusCode.put(NO_CONTENT, NAME_PREFIX + \"noContent\");\n        meterNamesByStatusCode.put(BAD_REQUEST, NAME_PREFIX + \"badRequest\");", "refactored_code": "    private static final int OK = 200;\n\n    private static Map<Integer, String> createMeterNamesByStatusCode() {\n        final Map<Integer, String> meterNamesByStatusCode = new HashMap<>(6);\n        meterNamesByStatusCode.put(OK, NAME_PREFIX + \"ok\");\n        meterNamesByStatusCode.put(CREATED, NAME_PREFIX + \"created\");\n        meterNamesByStatusCode.put(NO_CONTENT, NAME_PREFIX + \"noContent\");\n        meterNamesByStatusCode.put(BAD_REQUEST, NAME_PREFIX + \"badRequest\");"}
{"magic_number_smell": "\n    private static class CounterSerializer extends StdSerializer<Counter> {\n\n        private static final long 1L = 1L;\n\n        private CounterSerializer() {\n            super(Counter.class);", "refactored_code": "        private static final long serialVersionUID = 1L;\n\n    private static class CounterSerializer extends StdSerializer<Counter> {\n\n        private static final long serialVersionUID = 1L;\n\n        private CounterSerializer() {\n            super(Counter.class);"}
{"magic_number_smell": "        final long[] ids = threads.findDeadlockedThreads();\n        if (ids != null) {\n            final Set<String> deadlocks = new HashSet<>();\n            for (ThreadInfo info : threads.getThreadInfo(ids, 100)) {\n                final StringBuilder stackTrace = new StringBuilder();\n                for (StackTraceElement element : info.getStackTrace()) {\n                    stackTrace.append(\"\\t at \")", "refactored_code": "    private static final int MAX_STACK_TRACE_DEPTH = 100;\n        final long[] ids = threads.findDeadlockedThreads();\n        if (ids != null) {\n            final Set<String> deadlocks = new HashSet<>();\n            for (ThreadInfo info : threads.getThreadInfo(ids, MAX_STACK_TRACE_DEPTH)) {\n                final StringBuilder stackTrace = new StringBuilder();\n                for (StackTraceElement element : info.getStackTrace()) {\n                    stackTrace.append(\"\\t at \")"}
{"magic_number_smell": "\n    private static Map<Integer, String> createMeterNamesByStatusCode() {\n        final Map<Integer, String> meterNamesByStatusCode = new HashMap<>(6);\n        meterNamesByStatusCode.put(200, NAME_PREFIX + \"ok\");\n        meterNamesByStatusCode.put(CREATED, NAME_PREFIX + \"created\");\n        meterNamesByStatusCode.put(NO_CONTENT, NAME_PREFIX + \"noContent\");\n        meterNamesByStatusCode.put(BAD_REQUEST, NAME_PREFIX + \"badRequest\");", "refactored_code": "    private static final int OK = 200;\n\n    private static Map<Integer, String> createMeterNamesByStatusCode() {\n        final Map<Integer, String> meterNamesByStatusCode = new HashMap<>(6);\n        meterNamesByStatusCode.put(OK, NAME_PREFIX + \"ok\");\n        meterNamesByStatusCode.put(CREATED, NAME_PREFIX + \"created\");\n        meterNamesByStatusCode.put(NO_CONTENT, NAME_PREFIX + \"noContent\");\n        meterNamesByStatusCode.put(BAD_REQUEST, NAME_PREFIX + \"badRequest\");"}
{"magic_number_smell": "    protected void initCipher(javax.crypto.Cipher cipher, Mode mode, byte[] key, byte[] iv) {\n        this.mode = mode;\n\n        cipherKey = getKeySpec(Arrays.copyOfRange(key, 0, 32));\n        aadCipherKey = getKeySpec(Arrays.copyOfRange(key, 32, 2 * 32));\n\n        try {", "refactored_code": "    private static final int CHACHA_KEY_SIZE = 32;\n    protected void initCipher(javax.crypto.Cipher cipher, Mode mode, byte[] key, byte[] iv) {\n        this.mode = mode;\n\n        cipherKey = getKeySpec(Arrays.copyOfRange(key, 0, CHACHA_KEY_SIZE));\n        aadCipherKey = getKeySpec(Arrays.copyOfRange(key, CHACHA_KEY_SIZE, 2 * CHACHA_KEY_SIZE));\n\n        try {"}
{"magic_number_smell": "        int i, n, l = lr[off], r = lr[off + 1];\n\n        l ^= P[0];\n        for (i = 0; i <= 16 - 2;) {\n            // Feistel substitution on left word\n            n = S[(l >> 24) & 0xff];\n            n += S[0x100 | ((l >> 16) & 0xff)];", "refactored_code": "    private static final int BLOWFISH_NUM_ROUNDS = 16;\n        int i, n, l = lr[off], r = lr[off + 1];\n\n        l ^= P[0];\n        for (i = 0; i <= BLOWFISH_NUM_ROUNDS - 2;) {\n            // Feistel substitution on left word\n            n = S[(l >> 24) & 0xff];\n            n += S[0x100 | ((l >> 16) & 0xff)];"}
{"magic_number_smell": "    private SocketFactory socketFactory = SocketFactory.getDefault();\n\n    private static final int 0 = 0;\n    private int connectTimeout = 0;\n\n    private int timeout = 0;\n", "refactored_code": "    private static final int DEFAULT_CONNECT_TIMEOUT = 0;\n    private SocketFactory socketFactory = SocketFactory.getDefault();\n\n    private static final int DEFAULT_CONNECT_TIMEOUT = 0;\n    private int connectTimeout = DEFAULT_CONNECT_TIMEOUT;\n\n    private int timeout = 0;\n"}
{"magic_number_smell": "     * @param config {@link Config} instance\n     */\n    public SSHClient(Config config) {\n        super(22);\n\tloggerFactory = config.getLoggerFactory();\n\tlog = loggerFactory.getLogger(getClass());\n        this.trans = new TransportImpl(config);", "refactored_code": "    public static final int DEFAULT_PORT = 22;\n     * @param config {@link Config} instance\n     */\n    public SSHClient(Config config) {\n        super(DEFAULT_PORT);\n\tloggerFactory = config.getLoggerFactory();\n\tlog = loggerFactory.getLogger(getClass());\n        this.trans = new TransportImpl(config);"}
{"magic_number_smell": "    protected int rpos;\n    protected int wpos;\n\n    /** @see #256 */\n    public Buffer() {\n        this(256);\n    }", "refactored_code": "    public static final int DEFAULT_SIZE = 256;\n    protected int rpos;\n    protected int wpos;\n\n    /** @see #DEFAULT_SIZE */\n    public Buffer() {\n        this(DEFAULT_SIZE);\n    }"}
{"magic_number_smell": "\n    protected void init(int recipient, long remoteWinSize, long remoteMaxPacketSize) {\n        this.recipient = recipient;\n        rwin = new Window.Remote(remoteWinSize, (int) Math.min(remoteMaxPacketSize, 1024 * 1024),\n            conn.getTimeoutMs(), loggerFactory);\n        out = new ChannelOutputStream(this, trans, rwin);\n        log.debug(\"Initialized - {}\", this);", "refactored_code": "    private static final int REMOTE_MAX_PACKET_SIZE_CEILING = 1024 * 1024;\n\n    protected void init(int recipient, long remoteWinSize, long remoteMaxPacketSize) {\n        this.recipient = recipient;\n        rwin = new Window.Remote(remoteWinSize, (int) Math.min(remoteMaxPacketSize, REMOTE_MAX_PACKET_SIZE_CEILING),\n            conn.getTimeoutMs(), loggerFactory);\n        out = new ChannelOutputStream(this, trans, rwin);\n        log.debug(\"Initialized - {}\", this);"}
{"magic_number_smell": "    public static final int 65535 = 65535;\n\n    public DirectConnection(Connection conn, String remoteHost, int remotePort) {\n        super(conn, new Parameters(LOCALHOST, 65535, remoteHost, remotePort));\n    }\n\n    public String getRemoteHost() {", "refactored_code": "    public static final int LOCALPORT = 65535;\n    public static final int LOCALPORT = 65535;\n\n    public DirectConnection(Connection conn, String remoteHost, int remotePort) {\n        super(conn, new Parameters(LOCALHOST, LOCALPORT, remoteHost, remotePort));\n    }\n\n    public String getRemoteHost() {"}
{"magic_number_smell": "\n    public SFTPEngine init()\n            throws IOException {\n        return init(3);\n    }\n\n    /**", "refactored_code": "    public static final int MAX_SUPPORTED_VERSION = 3;\n\n    public SFTPEngine init()\n            throws IOException {\n        return init(MAX_SUPPORTED_VERSION);\n    }\n\n    /**"}
{"magic_number_smell": "    }\n\n    private void checkPacketLength(int len) throws TransportException {\n        if (len < 5 || len > 256 * 1024) { // Check packet length validity\n            log.error(\"Error decoding packet (invalid length) {}\", inputBuffer.printHex());\n            throw new TransportException(DisconnectReason.PROTOCOL_ERROR, \"invalid packet length: \" + len);\n        }", "refactored_code": "    private static final int MAX_PACKET_LEN = 256 * 1024;\n    }\n\n    private void checkPacketLength(int len) throws TransportException {\n        if (len < 5 || len > MAX_PACKET_LEN) { // Check packet length validity\n            log.error(\"Error decoding packet (invalid length) {}\", inputBuffer.printHex());\n            throw new TransportException(DisconnectReason.PROTOCOL_ERROR, \"invalid packet length: \" + len);\n        }"}
{"magic_number_smell": "\n    private static final int 4096 = 4096;\n\n    private final byte[] tempBuf = new byte[4096];\n\n    private Deflater deflater;\n    private Inflater inflater;", "refactored_code": "    private static final int BUF_SIZE = 4096;\n\n    private static final int BUF_SIZE = 4096;\n\n    private final byte[] tempBuf = new byte[BUF_SIZE];\n\n    private Deflater deflater;\n    private Inflater inflater;"}
{"magic_number_smell": "        digest.init();\n\n        log.debug(\"Sending {}\", Message.KEX_DH_GEX_REQUEST);\n        trans.write(new SSHPacket(Message.KEX_DH_GEX_REQUEST).putUInt32(1024).putUInt32(preferredBits).putUInt32(maxBits));\n    }\n\n    @Override", "refactored_code": "    private final int minBits = 1024;\n        digest.init();\n\n        log.debug(\"Sending {}\", Message.KEX_DH_GEX_REQUEST);\n        trans.write(new SSHPacket(Message.KEX_DH_GEX_REQUEST).putUInt32(minBits).putUInt32(preferredBits).putUInt32(maxBits));\n    }\n\n    @Override"}
{"magic_number_smell": "        final byte[] encoded = publicKey.getEncoded();\n\n        // Encoded public key consists of the algorithm identifier and public key\n        if (encoded.length == 44) {\n            final byte[] publicKeyEncoded = new byte[KEY_LENGTH];\n            System.arraycopy(encoded, ALGORITHM_ID_LENGTH, publicKeyEncoded, 0, KEY_LENGTH);\n            setE(publicKeyEncoded);", "refactored_code": "    private static final int ENCODED_ALGORITHM_ID_KEY_LENGTH = 44;\n        final byte[] encoded = publicKey.getEncoded();\n\n        // Encoded public key consists of the algorithm identifier and public key\n        if (encoded.length == ENCODED_ALGORITHM_ID_KEY_LENGTH) {\n            final byte[] publicKeyEncoded = new byte[KEY_LENGTH];\n            System.arraycopy(encoded, ALGORITHM_ID_LENGTH, publicKeyEncoded, 0, KEY_LENGTH);\n            setE(publicKeyEncoded);"}
{"magic_number_smell": "\n    private DSAParameters getDsaParameters(final AlgorithmIdentifier algorithmIdentifier) {\n        final ASN1Sequence sequence = ASN1Sequence.getInstance(algorithmIdentifier.getParameters());\n        final ASN1Integer p = ASN1Integer.getInstance(sequence.getObjectAt(0));\n        final ASN1Integer q = ASN1Integer.getInstance(sequence.getObjectAt(Q_INDEX));\n        final ASN1Integer g = ASN1Integer.getInstance(sequence.getObjectAt(G_INDEX));\n        return new DSAParameters(p.getValue(), q.getValue(), g.getValue());", "refactored_code": "    private static final int P_INDEX = 0;\n\n    private DSAParameters getDsaParameters(final AlgorithmIdentifier algorithmIdentifier) {\n        final ASN1Sequence sequence = ASN1Sequence.getInstance(algorithmIdentifier.getParameters());\n        final ASN1Integer p = ASN1Integer.getInstance(sequence.getObjectAt(P_INDEX));\n        final ASN1Integer q = ASN1Integer.getInstance(sequence.getObjectAt(Q_INDEX));\n        final ASN1Integer g = ASN1Integer.getInstance(sequence.getObjectAt(G_INDEX));\n        return new DSAParameters(p.getValue(), q.getValue(), g.getValue());"}
{"magic_number_smell": "    public SCPFileTransfer(SessionFactory sessionFactory, LoggerFactory loggerFactory) {\n\tsuper(loggerFactory);\n        this.sessionFactory = sessionFactory;\n        this.bandwidthLimit = -1;\n    }\n\n    public SCPDownloadClient newSCPDownloadClient() {", "refactored_code": "    private static final int DEFAULT_BANDWIDTH_LIMIT = -1;\n    public SCPFileTransfer(SessionFactory sessionFactory, LoggerFactory loggerFactory) {\n\tsuper(loggerFactory);\n        this.sessionFactory = sessionFactory;\n        this.bandwidthLimit = DEFAULT_BANDWIDTH_LIMIT;\n    }\n\n    public SCPDownloadClient newSCPDownloadClient() {"}
{"magic_number_smell": "        final DefaultConfig defaultConfig = new DefaultConfig();\n        defaultConfig.setKeepAliveProvider(KeepAliveProvider.KEEP_ALIVE);\n        final SSHClient sshClient = fixture.setupClient(defaultConfig);\n        sshClient.getConnection().getKeepAlive().setKeepAliveInterval(1);\n        return sshClient;\n    }\n}", "refactored_code": "    private static final int KEEP_ALIVE_SECONDS = 1;\n        final DefaultConfig defaultConfig = new DefaultConfig();\n        defaultConfig.setKeepAliveProvider(KeepAliveProvider.KEEP_ALIVE);\n        final SSHClient sshClient = fixture.setupClient(defaultConfig);\n        sshClient.getConnection().getKeepAlive().setKeepAliveInterval(KEEP_ALIVE_SECONDS);\n        return sshClient;\n    }\n}"}
{"magic_number_smell": "        Arrays.fill(key, (byte) 1);\n        enc.init(Cipher.Mode.Encrypt, key, new byte[0]);\n\n        byte[] aad = new byte[4];\n        byte[] ptBytes = PLAINTEXT.getBytes(StandardCharsets.UTF_8);\n        byte[] message = new byte[4 + ptBytes.length + POLY_TAG_LENGTH];\n        Arrays.fill(aad, (byte) 2);", "refactored_code": "    private static final int AAD_LENGTH = 4;\n        Arrays.fill(key, (byte) 1);\n        enc.init(Cipher.Mode.Encrypt, key, new byte[0]);\n\n        byte[] aad = new byte[AAD_LENGTH];\n        byte[] ptBytes = PLAINTEXT.getBytes(StandardCharsets.UTF_8);\n        byte[] message = new byte[AAD_LENGTH + ptBytes.length + POLY_TAG_LENGTH];\n        Arrays.fill(aad, (byte) 2);"}
{"magic_number_smell": "        final byte[] publicKeyEncoded = dh.getE();\n\n        assertNotNull(publicKeyEncoded);\n        assertEquals(32, publicKeyEncoded.length);\n    }\n\n    @Test", "refactored_code": "    private static final int KEY_LENGTH = 32;\n        final byte[] publicKeyEncoded = dh.getE();\n\n        assertNotNull(publicKeyEncoded);\n        assertEquals(KEY_LENGTH, publicKeyEncoded.length);\n    }\n\n    @Test"}
{"magic_number_smell": "\n        private void doReceive() {\n            ZMsg msg;\n            int remainingBuffer = 1024;\n            while (active && remainingBuffer-- > 0 && (msg = ZMsg.recvMsg(socket, ZMQ.DONTWAIT)) != null && msg.size() > 0 && msg.getFirst().hasData()) {\n                in.add(msg);\n            }", "refactored_code": "        private static final int BUFFER_SIZE = 1024;\n\n        private void doReceive() {\n            ZMsg msg;\n            int remainingBuffer = BUFFER_SIZE;\n            while (active && remainingBuffer-- > 0 && (msg = ZMsg.recvMsg(socket, ZMQ.DONTWAIT)) != null && msg.size() > 0 && msg.getFirst().hasData()) {\n                in.add(msg);\n            }"}
{"magic_number_smell": "\n        long indexSize = 0;\n        long now = System.currentTimeMillis();\n        boolean measureIndexSize = now - _lastMeasureTime > 1000 * 60 ? true : false;\n        _lastMeasureTime = now;\n\n        Iterator<Integer> it = _zoieSystemMap.keySet().iterator();", "refactored_code": "  private static final long MEASURE_INTERVAL = 1000 * 60; // 1 minute\n\n        long indexSize = 0;\n        long now = System.currentTimeMillis();\n        boolean measureIndexSize = now - _lastMeasureTime > MEASURE_INTERVAL ? true : false;\n        _lastMeasureTime = now;\n\n        Iterator<Integer> it = _zoieSystemMap.keySet().iterator();"}
{"magic_number_smell": "    Assert.state(storedFile != null, \"The FileStorage is not initialized\");    \n    try {\n      for (Update update : updates) {       \n         ensureCapacity(update.index * 8 + 8);        \n         if (activateMemoryMappedBuffers) {\n           buffer.putLong(update.index * 8, update.value);\n         } else {", "refactored_code": "  private static final int BYTES_IN_LONG = 8;\n    Assert.state(storedFile != null, \"The FileStorage is not initialized\");    \n    try {\n      for (Update update : updates) {       \n         ensureCapacity(update.index * BYTES_IN_LONG + BYTES_IN_LONG);        \n         if (activateMemoryMappedBuffers) {\n           buffer.putLong(update.index * BYTES_IN_LONG, update.value);\n         } else {"}
{"magic_number_smell": "  }\n\n  public void init() {\n    init(5000);\n  }\n\n  public void init(int count) {", "refactored_code": "  private static final int DEFAULT_INITIAL_CAPACITY = 5000;\n  }\n\n  public void init() {\n    init(DEFAULT_INITIAL_CAPACITY);\n  }\n\n  public void init(int count) {"}
{"magic_number_smell": "              activityPrimitiveValues.init();\n              return activityPrimitiveValues;\n            }\n            activityPrimitiveValues.init((int) (count * 1.5));\n            if (fileLength < count * activityPrimitiveValues.getFieldSizeInBytes()) {\n              logger.warn(\"The  activityIndex is corrupted. The file \"+ fieldName +\" contains \" + (fileLength / activityPrimitiveValues.getFieldSizeInBytes()) + \" records, while metadata has a bigger number \" + count);\n              logger.warn(\"adding extra space\");", "refactored_code": "  public static final double INIT_GROWTH_RATIO = 1.5;\n              activityPrimitiveValues.init();\n              return activityPrimitiveValues;\n            }\n            activityPrimitiveValues.init((int) (count * INIT_GROWTH_RATIO));\n            if (fileLength < count * activityPrimitiveValues.getFieldSizeInBytes()) {\n              logger.warn(\"The  activityIndex is corrupted. The file \"+ fieldName +\" contains \" + (fileLength / activityPrimitiveValues.getFieldSizeInBytes()) + \" records, while metadata has a bigger number \" + count);\n              logger.warn(\"adding extra space\");"}
{"magic_number_smell": "    }\n    double growthFactor = 1.2;\n    \n    int newSize = array.length < capacityThreshold ? array.length + 2 : (int) (array.length * growthFactor);\n    int[] oldArr = array;\n    array = new int[newSize];\n    System.arraycopy(oldArr, startIndex, array, 0, actualSize);", "refactored_code": "  private static final int initialGrowthFactor = 2;\n    }\n    double growthFactor = 1.2;\n    \n    int newSize = array.length < capacityThreshold ? array.length + initialGrowthFactor : (int) (array.length * growthFactor);\n    int[] oldArr = array;\n    array = new int[newSize];\n    System.arraycopy(oldArr, startIndex, array, 0, actualSize);"}
{"magic_number_smell": "      /**\n       * \n       */\n      private static final long 1L = 1L;\n\n      @Override\n      public RandomAccessDocIdSet getRandomAccessDocIdSet(BoboIndexReader reader)", "refactored_code": "      private static final long serialVersionUID = 1L;\n      /**\n       * \n       */\n      private static final long serialVersionUID = 1L;\n\n      @Override\n      public RandomAccessDocIdSet getRandomAccessDocIdSet(BoboIndexReader reader)"}
{"magic_number_smell": "    /**\n     *\n     */\n    private static final long 1L = 1L;\n\n    private final HashMap<String, BrowseFacet> _facetMap;\n    private final BrowseFacet[] _facets;", "refactored_code": "    private static final long serialVersionUID = 1L;\n    /**\n     *\n     */\n    private static final long serialVersionUID = 1L;\n\n    private final HashMap<String, BrowseFacet> _facetMap;\n    private final BrowseFacet[] _facets;"}
{"magic_number_smell": " \n  public class ScoreAdjusterWeight extends Weight\n  {\n    private static final long 1L = 1L;\n    \n    Weight _innerWeight;\n", "refactored_code": "  private static final long serialVersionUID = 1L;\n \n  public class ScoreAdjusterWeight extends Weight\n  {\n    private static final long serialVersionUID = 1L;\n    \n    Weight _innerWeight;\n"}
{"magic_number_smell": "\n  public static class SenseiNodeInfo implements Serializable\n  {\n    private static final long 1L = 1L;\n\n    private int _id;\n    private int[] _partitions;", "refactored_code": "    private static final long serialVersionUID = 1L;\n\n  public static class SenseiNodeInfo implements Serializable\n  {\n    private static final long serialVersionUID = 1L;\n\n    private int _id;\n    private int[] _partitions;"}
{"magic_number_smell": "  public SenseiMapFunctionWrapper(SenseiMapReduce mapReduceStrategy, Set<SenseiFacetInfo> facetInfos) {\n    super();\n    this.mapReduceStrategy = mapReduceStrategy;   \n    partialDocIds = new int[2048];\n    result = new MapReduceResult();\n    this.facetInfos = facetInfos;\n  }", "refactored_code": "  public static final int BUFFER_SIZE = 2048;\n  public SenseiMapFunctionWrapper(SenseiMapReduce mapReduceStrategy, Set<SenseiFacetInfo> facetInfos) {\n    super();\n    this.mapReduceStrategy = mapReduceStrategy;   \n    partialDocIds = new int[BUFFER_SIZE];\n    result = new MapReduceResult();\n    this.facetInfos = facetInfos;\n  }"}
{"magic_number_smell": "    compositeActivityValues = CompositeActivityValues.createCompositeValues(ActivityPersistenceFactory.getInstance(indexDirPath), java.util.Arrays.asList(PurgeUnusedActivitiesJobTest.getLikesFieldDefinition()), Collections.EMPTY_LIST, ZoieConfig.DEFAULT_VERSION_COMPARATOR);\n    final int valueCount = 100000;   \n    for (int i = 0; i < valueCount; i++) {\n      compositeActivityValues.update(10000000000L + i, String.format(\"%08d\", valueCount + i), toMap(new JSONObject().put(\"likes\", \"+1\")));\n    }  \n    compositeActivityValues.flush();\n    compositeActivityValues.syncWithPersistentVersion(String.format(\"%08d\",  valueCount - 1));", "refactored_code": "  private static final long UID_BASE = 10000000000L;\n    compositeActivityValues = CompositeActivityValues.createCompositeValues(ActivityPersistenceFactory.getInstance(indexDirPath), java.util.Arrays.asList(PurgeUnusedActivitiesJobTest.getLikesFieldDefinition()), Collections.EMPTY_LIST, ZoieConfig.DEFAULT_VERSION_COMPARATOR);\n    final int valueCount = 100000;   \n    for (int i = 0; i < valueCount; i++) {\n      compositeActivityValues.update(UID_BASE + i, String.format(\"%08d\", valueCount + i), toMap(new JSONObject().put(\"likes\", \"+1\")));\n    }  \n    compositeActivityValues.flush();\n    compositeActivityValues.syncWithPersistentVersion(String.format(\"%08d\",  valueCount - 1));"}
{"magic_number_smell": "  {\n    SenseiRequest aRequest = new SenseiRequest();\n\n    aRequest.setCount(72);\n    aRequest.setOffset(EXPECTED_OFFSET);\n    aRequest.setFetchStoredFields(EXPECTED_FETCH_STORED_FIELDS);\n    aRequest.setShowExplanation(EXPECTED_SHOW_EXPLANATION);", "refactored_code": "  private static final int EXPECTED_COUNT = 72;\n  {\n    SenseiRequest aRequest = new SenseiRequest();\n\n    aRequest.setCount(EXPECTED_COUNT);\n    aRequest.setOffset(EXPECTED_OFFSET);\n    aRequest.setFetchStoredFields(EXPECTED_FETCH_STORED_FIELDS);\n    aRequest.setShowExplanation(EXPECTED_SHOW_EXPLANATION);"}
{"magic_number_smell": "  }\n\n  private boolean isEqualsJsonArray(JSONArray a, JSONArray b) {\n    if (policy == 1) {\n      if (a.length() != b.length()) {\n        return false;\n      }", "refactored_code": "  public static final int STRICT = 1;\n  }\n\n  private boolean isEqualsJsonArray(JSONArray a, JSONArray b) {\n    if (policy == STRICT) {\n      if (a.length() != b.length()) {\n        return false;\n      }"}
{"magic_number_smell": "        // can we avoid the extra copy?\n        IndexInput input = null;\n        try {\n          input = dir.openInput(names[i], 1024);\n\n          int position = 0;\n          byte[] buffer = new byte[1024];", "refactored_code": "  private static final int BUFFER_SIZE = 1024; // RAMOutputStream.BUFFER_SIZE;\n        // can we avoid the extra copy?\n        IndexInput input = null;\n        try {\n          input = dir.openInput(names[i], BUFFER_SIZE);\n\n          int position = 0;\n          byte[] buffer = new byte[BUFFER_SIZE];"}
{"magic_number_smell": "\t\tIntent intent = new Intent(a, BrowsePlaylistActivity.class);\n\t\tintent.putExtra(\"mode\", Mode.Save);\n\t\tintent.putExtra(\"playlist\", playlist);\n\t\ta.startActivityForResult(intent, 666668);\n\t}\n\n\t// layout", "refactored_code": "\tpublic static final int SAVE_REQUEST_CODE = 666668;\n\t\tIntent intent = new Intent(a, BrowsePlaylistActivity.class);\n\t\tintent.putExtra(\"mode\", Mode.Save);\n\t\tintent.putExtra(\"playlist\", playlist);\n\t\ta.startActivityForResult(intent, SAVE_REQUEST_CODE);\n\t}\n\n\t// layout"}
{"magic_number_smell": "\t\t@Override\n\t\tpublic void onCreateContextMenu(ContextMenu menu, View v,\n\t\t\t\tContextMenuInfo menuInfo) {\n\t\t\tmenu.add(0, 0x01, 0, R.string.remove);\n\t\t\tmenu.add(0, CONTEXT_DOWNLOAD, 0, R.string.download);\n\t\t\tmenu.add(0, CONTEXT_SHARE, 0, R.string.share);\n\t\t\t//menu.add(0, CONTEXT_MOVE, 0, R.string.move);", "refactored_code": "\tprotected static final int CONTEXT_REMOVE = 0x01; \n\t\t@Override\n\t\tpublic void onCreateContextMenu(ContextMenu menu, View v,\n\t\t\t\tContextMenuInfo menuInfo) {\n\t\t\tmenu.add(0, CONTEXT_REMOVE, 0, R.string.remove);\n\t\t\tmenu.add(0, CONTEXT_DOWNLOAD, 0, R.string.download);\n\t\t\tmenu.add(0, CONTEXT_SHARE, 0, R.string.share);\n\t\t\t//menu.add(0, CONTEXT_MOVE, 0, R.string.move);"}
{"magic_number_smell": "\t\t\n\t\tint currentPage = 1;\n\t\t\n\t\twhile ((tracks = getAlbumTracks(album, encoding, 10, currentPage++)) != null) {\n\t\t\tallTracks.addAll(Arrays.asList(tracks));\n\t\t}\n\t\t", "refactored_code": "\tprivate static final int TRACKS_PER_PAGE = 10;\n\t\t\n\t\tint currentPage = 1;\n\t\t\n\t\twhile ((tracks = getAlbumTracks(album, encoding, TRACKS_PER_PAGE, currentPage++)) != null) {\n\t\t\tallTracks.addAll(Arrays.asList(tracks));\n\t\t}\n\t\t"}
{"magic_number_smell": "\tprivate static final long 1000 = 1000;\n\t\n\t/**\n\t * Acceptable number of fails within 1000\n\t */\n\tprivate static final int ACCEPTABLE_FAIL_NUMBER = 2;\n\t", "refactored_code": "\tprivate static final long FAIL_TIME_FRAME = 1000;\n\tprivate static final long FAIL_TIME_FRAME = 1000;\n\t\n\t/**\n\t * Acceptable number of fails within FAIL_TIME_FRAME\n\t */\n\tprivate static final int ACCEPTABLE_FAIL_NUMBER = 2;\n\t"}
{"magic_number_smell": "\t\t\t\tnotificationMessage, contentIntent );\n\t\tnotification.flags |= Notification.FLAG_AUTO_CANCEL;\n\n\t\tmNotificationManager.notify( 667668, notification );\n\t}\n\t\n", "refactored_code": "\tprivate static final int DOWNLOAD_NOTIFY_ID = 667668;\n\t\t\t\tnotificationMessage, contentIntent );\n\t\tnotification.flags |= Notification.FLAG_AUTO_CANCEL;\n\n\t\tmNotificationManager.notify( DOWNLOAD_NOTIFY_ID, notification );\n\t}\n\t\n"}
{"magic_number_smell": "\t\t\t// NO-OP setForeground(false);\n\t\t\tmWifiLock.release();\n\t\t\t\n\t\t\tmNotificationManager.cancel(667667);\n\t\t\tif(mRemoteEngineListener != null){\n\t\t\t\tmRemoteEngineListener.onTrackStop();\n\t\t\t}", "refactored_code": "\tprivate static final int PLAYING_NOTIFY_ID = 667667;\n\t\t\t// NO-OP setForeground(false);\n\t\t\tmWifiLock.release();\n\t\t\t\n\t\t\tmNotificationManager.cancel(PLAYING_NOTIFY_ID);\n\t\t\tif(mRemoteEngineListener != null){\n\t\t\t\tmRemoteEngineListener.onTrackStop();\n\t\t\t}"}
{"magic_number_smell": "\t\t\t@Override\n\t\t\tpublic void onTick(long millisUntilFinished) {\n\t\t\t\tlong time = MILIS_IN_FUTURE - millisUntilFinished;\t\t\t\t\n\t\t\t\tif (time > 500) {\t\t\t\t\t\n\t\t\t\t\tswitch (mSeekToMode) {\n\t\t\t\t\tcase ERewind: {\n\t\t\t\t\t\tmPlayerEngine.rewind(stepOfSeekTo);", "refactored_code": "\tprivate static final int HOLD_BUTTON_THRESHOLD = 500;\n\t\t\t@Override\n\t\t\tpublic void onTick(long millisUntilFinished) {\n\t\t\t\tlong time = MILIS_IN_FUTURE - millisUntilFinished;\t\t\t\t\n\t\t\t\tif (time > HOLD_BUTTON_THRESHOLD) {\t\t\t\t\t\n\t\t\t\t\tswitch (mSeekToMode) {\n\t\t\t\t\tcase ERewind: {\n\t\t\t\t\t\tmPlayerEngine.rewind(stepOfSeekTo);"}
{"magic_number_smell": "\t\tif (mDb == null)\n\t\t\treturn;\n\n\t\tif (mDb.getVersion() < 1) {\n\t\t\tnew UpdaterBuilder().getUpdater(1).update();\n\t\t}\n\t}", "refactored_code": "\tprivate static final int DB_VERSION = 1;\n\t\tif (mDb == null)\n\t\t\treturn;\n\n\t\tif (mDb.getVersion() < DB_VERSION) {\n\t\t\tnew UpdaterBuilder().getUpdater(DB_VERSION).update();\n\t\t}\n\t}"}
{"magic_number_smell": "  /**\n   * maps uid to a lucene docid\n   * @param uid UID to be mapped.\n   * @return {@link #-1} if uid is not found\n   */\n  int getDocID(long uid);\n}", "refactored_code": "  public static final int NOT_FOUND = -1;\n  /**\n   * maps uid to a lucene docid\n   * @param uid UID to be mapped.\n   * @return {@link #NOT_FOUND} if uid is not found\n   */\n  int getDocID(long uid);\n}"}
{"magic_number_smell": "public class ZoieHealth {\n  public static final long 0 = 0;\n  public static final long HEALTH_FATAL = 100;\n  public static volatile long health = 0;\n\n  public static void setFatal() {\n    health = HEALTH_FATAL;", "refactored_code": "  public static final long HEALTH_OK = 0;\npublic class ZoieHealth {\n  public static final long HEALTH_OK = 0;\n  public static final long HEALTH_FATAL = 100;\n  public static volatile long health = HEALTH_OK;\n\n  public static void setFatal() {\n    health = HEALTH_FATAL;"}
{"magic_number_smell": "    Bits liveDocs = reader.getLiveDocs();\n    for (int i = 0; i < maxDoc; ++i) {\n      if (liveDocs != null && !liveDocs.get(i)) {\n        _uidArray[i] = ZoieSegmentReader.Long.MIN_VALUE;\n        continue;\n      }\n      _uidArray[i] = uidValues.get(i);", "refactored_code": "  public static final long DELETED_UID = Long.MIN_VALUE;\n    Bits liveDocs = reader.getLiveDocs();\n    for (int i = 0; i < maxDoc; ++i) {\n      if (liveDocs != null && !liveDocs.get(i)) {\n        _uidArray[i] = ZoieSegmentReader.DELETED_UID;\n        continue;\n      }\n      _uidArray[i] = uidValues.get(i);"}
{"magic_number_smell": "    // bit. from one miss, we can tell the uid is definitely not inside the _uidArray.\n    for (long uid : uidArray) {\n      if (uid != ZoieSegmentReader.DELETED_UID) {\n        // the hash function is (int)((uid >>> 32) ^ uid) * 2147482951,\n        // and we mod number of partions by \"& _mask\" (because & is much faster than mod).\n        int h = (int) ((uid >> 32) ^ uid) * 2147482951;\n", "refactored_code": "  private static final int MIXER = 2147482951; // a prime number\n    // bit. from one miss, we can tell the uid is definitely not inside the _uidArray.\n    for (long uid : uidArray) {\n      if (uid != ZoieSegmentReader.DELETED_UID) {\n        // the hash function is (int)((uid >>> 32) ^ uid) * MIXER,\n        // and we mod number of partions by \"& _mask\" (because & is much faster than mod).\n        int h = (int) ((uid >> 32) ^ uid) * MIXER;\n"}
{"magic_number_smell": "  public static final int DEFAULT_MERGE_FACTOR = 6;\n\n  private boolean _partialExpunge = false;\n  private int _numLargeSegments = 6;\n  private int _maxSmallSegments = DEFAULT_NUM_SMALL_SEGMENTS; // default merge factor plus 1.\n  private int _maxSegments = _numLargeSegments + _maxSmallSegments;\n", "refactored_code": "  public static final int DEFAULT_NUM_LARGE_SEGMENTS = 6;\n  public static final int DEFAULT_MERGE_FACTOR = 6;\n\n  private boolean _partialExpunge = false;\n  private int _numLargeSegments = DEFAULT_NUM_LARGE_SEGMENTS;\n  private int _maxSmallSegments = DEFAULT_NUM_SMALL_SEGMENTS; // default merge factor plus 1.\n  private int _maxSegments = _numLargeSegments + _maxSmallSegments;\n"}
{"magic_number_smell": "    _filter = new long[mask + 1];\n    IntIterator iter = set.iterator();\n    while (iter.hasNext()) {\n      int h = iter.nextInt() * 2147482951;\n\n      long bits = _filter[h & _mask];\n      bits |= ((1L << (h >>> 26)));", "refactored_code": "  private static final int MIXER = 2147482951; // a prime number\n    _filter = new long[mask + 1];\n    IntIterator iter = set.iterator();\n    while (iter.hasNext()) {\n      int h = iter.nextInt() * MIXER;\n\n      long bits = _filter[h & _mask];\n      bits |= ((1L << (h >>> 26)));"}
{"magic_number_smell": "    LongIterator iter = set.iterator();\n    while (iter.hasNext()) {\n      long l = iter.nextLong();\n      int h = (int) ((l >>> 32) ^ l) * 2147482951;\n\n      long bits = _filter[h & _mask];\n      bits |= ((1L << (h >>> 26)));", "refactored_code": "  private static final int MIXER = 2147482951; // a prime number\n    LongIterator iter = set.iterator();\n    while (iter.hasNext()) {\n      long l = iter.nextLong();\n      int h = (int) ((l >>> 32) ^ l) * MIXER;\n\n      long bits = _filter[h & _mask];\n      bits |= ((1L << (h >>> 26)));"}
{"magic_number_smell": "    _conn = null;\n    _stmt = null;\n    _res = null;\n    _pullTime = 1000;\n  }\n\n  public void setPullTime(long pullTime) {", "refactored_code": "  private static final long DEFAULT_PULL_TIME = 1000;\n    _conn = null;\n    _stmt = null;\n    _res = null;\n    _pullTime = DEFAULT_PULL_TIME;\n  }\n\n  public void setPullTime(long pullTime) {"}
{"magic_number_smell": "      long count = 0;\n      for (int i = 0; i < 60; i++) {\n        int id = (slot - i + 60) % 60;\n        if (i < 3) countwindow += last60[id];\n        count += last60[id];\n      }\n      // use the higher of the rates in the time 3 and last 60 seconds", "refactored_code": "    private static final int window = 3;// window size 3 seconds\n      long count = 0;\n      for (int i = 0; i < 60; i++) {\n        int id = (slot - i + 60) % 60;\n        if (i < window) countwindow += last60[id];\n        count += last60[id];\n      }\n      // use the higher of the rates in the time window and last 60 seconds"}
{"magic_number_smell": "   * 10000 events and 5 minutes respectively. Indexing mode default to realtime.\n   */\n  public ZoieConfig(Comparator<String> versionComparator) {\n    this.batchSize = 10000;\n    this.batchDelay = DEFAULT_SETTING_BATCHDELAY;\n    this.rtIndexing = true;\n    this.maxBatchSize = DEFAULT_MAX_BATCH_SIZE;", "refactored_code": "  public static final int DEFAULT_SETTING_BATCHSIZE = 10000;\n   * 10000 events and 5 minutes respectively. Indexing mode default to realtime.\n   */\n  public ZoieConfig(Comparator<String> versionComparator) {\n    this.batchSize = DEFAULT_SETTING_BATCHSIZE;\n    this.batchDelay = DEFAULT_SETTING_BATCHDELAY;\n    this.rtIndexing = true;\n    this.maxBatchSize = DEFAULT_MAX_BATCH_SIZE;"}
{"magic_number_smell": "      return null;\n    }\n\n    int numTries = 5;\n    ZoieMultiReader<R> reader = null;\n\n    // try max of 5 times, there might be a case where the segment file is being updated", "refactored_code": "  private static final int INDEX_OPEN_NUM_RETRIES = 5;\n      return null;\n    }\n\n    int numTries = INDEX_OPEN_NUM_RETRIES;\n    ZoieMultiReader<R> reader = null;\n\n    // try max of 5 times, there might be a case where the segment file is being updated"}
{"magic_number_smell": "\tpublic static final int WARNING = IStatus.WARNING; // 2\n\tpublic static final int ERROR = IStatus.ERROR; // 4\n\n\tpublic static final int OK_DEBUG = 200 + IStatus.OK;\n\tpublic static final int INFO_DEBUG = 200 + INFO;\n\tpublic static final int WARNING_DEBUG = 200 + WARNING;\n\tpublic static final int ERROR_DEBUG = 200 + ERROR;", "refactored_code": "\tpublic static final int OK = IStatus.OK; // 0\n\tpublic static final int WARNING = IStatus.WARNING; // 2\n\tpublic static final int ERROR = IStatus.ERROR; // 4\n\n\tpublic static final int OK_DEBUG = 200 + OK;\n\tpublic static final int INFO_DEBUG = 200 + INFO;\n\tpublic static final int WARNING_DEBUG = 200 + WARNING;\n\tpublic static final int ERROR_DEBUG = 200 + ERROR;"}
{"magic_number_smell": "        FileOutputStream outputStream = new FileOutputStream(outputFile);\n\n        int byteReadCount = 0;\n        final byte[] data = new byte[8 * 1024];\n\n        try {\n            while ((byteReadCount = gzipInputStream.read(data, 0, 8 * 1024)) != -1) {", "refactored_code": "    private static final int BUFFER_SIZE = 8 * 1024;\n        FileOutputStream outputStream = new FileOutputStream(outputFile);\n\n        int byteReadCount = 0;\n        final byte[] data = new byte[BUFFER_SIZE];\n\n        try {\n            while ((byteReadCount = gzipInputStream.read(data, 0, BUFFER_SIZE)) != -1) {"}
{"magic_number_smell": "\tpublic static final int WARNING = IStatus.WARNING; // 2\n\tpublic static final int ERROR = IStatus.ERROR; // 4\n\n\tpublic static final int OK_DEBUG = 200 + IStatus.OK;\n\tpublic static final int INFO_DEBUG = 200 + INFO;\n\tpublic static final int WARNING_DEBUG = 200 + WARNING;\n\tpublic static final int ERROR_DEBUG = 200 + ERROR;", "refactored_code": "\tpublic static final int OK = IStatus.OK; // 0\n\tpublic static final int WARNING = IStatus.WARNING; // 2\n\tpublic static final int ERROR = IStatus.ERROR; // 4\n\n\tpublic static final int OK_DEBUG = 200 + OK;\n\tpublic static final int INFO_DEBUG = 200 + INFO;\n\tpublic static final int WARNING_DEBUG = 200 + WARNING;\n\tpublic static final int ERROR_DEBUG = 200 + ERROR;"}
{"magic_number_smell": "\tpublic static final int WARNING = IStatus.WARNING; // 2\n\tpublic static final int ERROR = IStatus.ERROR; // 4\n\n\tpublic static final int OK_DEBUG = 200 + IStatus.OK;\n\tpublic static final int INFO_DEBUG = 200 + INFO;\n\tpublic static final int WARNING_DEBUG = 200 + WARNING;\n\tpublic static final int ERROR_DEBUG = 200 + ERROR;", "refactored_code": "\tpublic static final int OK = IStatus.OK; // 0\n\tpublic static final int WARNING = IStatus.WARNING; // 2\n\tpublic static final int ERROR = IStatus.ERROR; // 4\n\n\tpublic static final int OK_DEBUG = 200 + OK;\n\tpublic static final int INFO_DEBUG = 200 + INFO;\n\tpublic static final int WARNING_DEBUG = 200 + WARNING;\n\tpublic static final int ERROR_DEBUG = 200 + ERROR;"}
{"magic_number_smell": "    public static final ImageDescriptor DESC_WIZBAN_IMPORT_PROJECT = create(T_WIZBAN, \"importer.gif\");//$NON-NLS-1$\n\n    private static ImageDescriptor createManagedFromKey(String prefix, String key) {\n        return createManaged(prefix, key.substring(NAME_PREFIX.length()), key);\n    }\n\n    private static ImageDescriptor createManaged(String prefix, String name,", "refactored_code": "    private static final int NAME_PREFIX_LENGTH = NAME_PREFIX.length();\n    public static final ImageDescriptor DESC_WIZBAN_IMPORT_PROJECT = create(T_WIZBAN, \"importer.gif\");//$NON-NLS-1$\n\n    private static ImageDescriptor createManagedFromKey(String prefix, String key) {\n        return createManaged(prefix, key.substring(NAME_PREFIX_LENGTH), key);\n    }\n\n    private static ImageDescriptor createManaged(String prefix, String name,"}
{"magic_number_smell": "\n        SyntheticService edited = null;\n\n        if (index != 0) {\n            edited = (SyntheticService) serviceList.getSelectedElements().get(0);\n        }\n        if (index == 0 || index == IDX_EDIT) {", "refactored_code": "    private static final int IDX_ADD = 0;\n\n        SyntheticService edited = null;\n\n        if (index != IDX_ADD) {\n            edited = (SyntheticService) serviceList.getSelectedElements().get(0);\n        }\n        if (index == IDX_ADD || index == IDX_EDIT) {"}
{"magic_number_smell": "  private static final long 1L = 1L;\n\n  public static class BoboTerm implements Serializable {\n    private static final long 1L = 1L;\n    public String term;\n    public Integer freq;\n    public List<Integer> positions;", "refactored_code": "  private static final long serialVersionUID = 1L;\n  private static final long serialVersionUID = 1L;\n\n  public static class BoboTerm implements Serializable {\n    private static final long serialVersionUID = 1L;\n    public String term;\n    public Integer freq;\n    public List<Integer> positions;"}
{"magic_number_smell": "  private final ArrayList<Integer> _interSectionResult = new ArrayList<Integer>();\n\n  public class DescDocIdSetComparator implements Comparator<StatefulDSIterator>, Serializable {\n    private static final long 1L = 1L;\n\n    @Override\n    public int compare(StatefulDSIterator o1, StatefulDSIterator o2) {", "refactored_code": "  private static final long serialVersionUID = 1L;\n  private final ArrayList<Integer> _interSectionResult = new ArrayList<Integer>();\n\n  public class DescDocIdSetComparator implements Comparator<StatefulDSIterator>, Serializable {\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public int compare(StatefulDSIterator o1, StatefulDSIterator o2) {"}
{"magic_number_smell": "  /**\n   *\n   */\n  private static final long 1L = 1L;\n  /**\n   * The transaction ID\n   */", "refactored_code": "    private static final long serialVersionUID = 1L;\n  /**\n   *\n   */\n  private static final long serialVersionUID = 1L;\n  /**\n   * The transaction ID\n   */"}
{"magic_number_smell": "\n  public double getPrimitiveValue(int index) {\n    if (index < _elements.length) return _elements[index];\n    else return Double.MIN_VALUE;\n  }\n\n  @Override", "refactored_code": "  public static final double VALUE_MISSING = Double.MIN_VALUE;\n\n  public double getPrimitiveValue(int index) {\n    if (index < _elements.length) return _elements[index];\n    else return VALUE_MISSING;\n  }\n\n  @Override"}
{"magic_number_smell": "\n  public float getPrimitiveValue(int index) {\n    if (index < _elements.length) return _elements[index];\n    else return Float.MIN_VALUE;\n  }\n\n  @Override", "refactored_code": "  public static final float VALUE_MISSING = Float.MIN_VALUE;\n\n  public float getPrimitiveValue(int index) {\n    if (index < _elements.length) return _elements[index];\n    else return VALUE_MISSING;\n  }\n\n  @Override"}
{"magic_number_smell": "\n  public int getPrimitiveValue(int index) {\n    if (index < _elements.length) return _elements[index];\n    else return TermIntList.Integer.MIN_VALUE;\n  }\n\n  @Override", "refactored_code": "  public static final int VALUE_MISSING = Integer.MIN_VALUE;\n\n  public int getPrimitiveValue(int index) {\n    if (index < _elements.length) return _elements[index];\n    else return TermIntList.VALUE_MISSING;\n  }\n\n  @Override"}
{"magic_number_smell": "\n  public long getPrimitiveValue(int index) {\n    if (index < _elements.length) return _elements[index];\n    else return Long.MIN_VALUE;\n  }\n\n  @Override", "refactored_code": "  public static final long VALUE_MISSING = Long.MIN_VALUE;\n\n  public long getPrimitiveValue(int index) {\n    if (index < _elements.length) return _elements[index];\n    else return VALUE_MISSING;\n  }\n\n  @Override"}
{"magic_number_smell": "\n  public short getPrimitiveValue(int index) {\n    if (index < _elements.length) return _elements[index];\n    else return Short.MIN_VALUE;\n  }\n\n  @Override", "refactored_code": "  public static final short VALUE_MISSING = Short.MIN_VALUE;\n\n  public short getPrimitiveValue(int index) {\n    if (index < _elements.length) return _elements[index];\n    else return VALUE_MISSING;\n  }\n\n  @Override"}
{"magic_number_smell": "      return new String[] { \"\" };\n    } else {\n      int count = 1;\n      ArrayList<String> valList = new ArrayList<String>(32);\n\n      while (encoded != 0) {\n        if ((encoded & 0x00000001) != 0x0) {", "refactored_code": "  private static final int MAX_VAL_COUNT = 32;\n      return new String[] { \"\" };\n    } else {\n      int count = 1;\n      ArrayList<String> valList = new ArrayList<String>(MAX_VAL_COUNT);\n\n      while (encoded != 0) {\n        if ((encoded & 0x00000001) != 0x0) {"}
{"magic_number_smell": "        @Override\n        public int advance(int target) throws IOException {\n          doc = target;\n          while (doc < reader.maxDoc()) {\n            if (acceptDocs != null && !acceptDocs.get(doc)) {\n              ++doc;\n              continue;", "refactored_code": "        private final int maxDoc = reader.maxDoc();\n        @Override\n        public int advance(int target) throws IOException {\n          doc = target;\n          while (doc < maxDoc) {\n            if (acceptDocs != null && !acceptDocs.get(doc)) {\n              ++doc;\n              continue;"}
{"magic_number_smell": "    _reader = reader;\n\n    int maxDoc = reader.maxDoc();\n    _list = new int[(maxDoc + 1024 - 1) / 1024][];\n    _curPageNo = 0;\n    _curSlot = 0;\n    _curData = 1024;", "refactored_code": "  private static final int MAX_SLOTS = 1024;\n    _reader = reader;\n\n    int maxDoc = reader.maxDoc();\n    _list = new int[(maxDoc + MAX_SLOTS - 1) / MAX_SLOTS][];\n    _curPageNo = 0;\n    _curSlot = 0;\n    _curData = MAX_SLOTS;"}
{"magic_number_smell": "  abstract public int fetchSec(int targetSec) throws IOException;\n\n  protected int fetchPos() throws IOException {\n    return Integer.MAX_VALUE;\n  }\n}\n", "refactored_code": "  public static final int NO_MORE_POSITIONS = Integer.MAX_VALUE;\n  abstract public int fetchSec(int targetSec) throws IOException;\n\n  protected int fetchPos() throws IOException {\n    return NO_MORE_POSITIONS;\n  }\n}\n"}
{"magic_number_smell": "  }\n\n  public int alloc(int size) {\n    if (size > 1024) throw new IllegalArgumentException(\"size too big\");\n\n    if ((_mark + size) > _allocSize) {\n      int[] page = new int[1024];", "refactored_code": "  private static final int PAGESIZE = 1024;\n  }\n\n  public int alloc(int size) {\n    if (size > PAGESIZE) throw new IllegalArgumentException(\"size too big\");\n\n    if ((_mark + size) > _allocSize) {\n      int[] page = new int[PAGESIZE];"}
{"magic_number_smell": "    Arrays.fill(MISSING_PAGE, MISSING);\n  }\n\n  private int _maxItems = 1024;\n  private int[][] _list;\n  private int _size;\n", "refactored_code": "  public static final int MAX_ITEMS = 1024;\n    Arrays.fill(MISSING_PAGE, MISSING);\n  }\n\n  private int _maxItems = MAX_ITEMS;\n  private int[][] _list;\n  private int _size;\n"}
{"magic_number_smell": "  }\n\n  public static float getMilesRadiusCosine(float radiusInMiles) {\n    float radiusCosine = (float) (Math.cos(radiusInMiles / 3956.0f));\n    return radiusCosine;\n  }\n", "refactored_code": "  public static final float EARTH_RADIUS_MILES = 3956.0f;\n  }\n\n  public static float getMilesRadiusCosine(float radiusInMiles) {\n    float radiusCosine = (float) (Math.cos(radiusInMiles / EARTH_RADIUS_MILES));\n    return radiusCosine;\n  }\n"}
{"magic_number_smell": "        on++;\n      }\n    }\n    if (((float) on) / ((float) floats.length) < 0.75f) {\n      // it's worth compressing\n      if (0 == on) {\n        // it's worth super-compressing", "refactored_code": "  private static final float ON_RATIO_CUTOFF = 0.75f;\n        on++;\n      }\n    }\n    if (((float) on) / ((float) floats.length) < ON_RATIO_CUTOFF) {\n      // it's worth compressing\n      if (0 == on) {\n        // it's worth super-compressing"}
{"magic_number_smell": "\n  public void testMute() throws Throwable {\n    try {\n      Random rand = new Random(-7862018348108294439L);\n\n      float[] orig = new float[1024];\n      MutableSparseFloatArray fromEmpty = new MutableSparseFloatArray(new float[1024]);", "refactored_code": "  private static final long SEED = -7862018348108294439L;\n\n  public void testMute() throws Throwable {\n    try {\n      Random rand = new Random(SEED);\n\n      float[] orig = new float[1024];\n      MutableSparseFloatArray fromEmpty = new MutableSparseFloatArray(new float[1024]);"}
{"magic_number_smell": "    try {\n      float[] orig = new float[32 * 1024 * 1024];\n      float density = 0.4f;\n      Random rand = new Random(-1587797429870936371L);\n      int idx = 0;\n      while (rand.nextFloat() > density) {\n        idx++;", "refactored_code": "  private static final long SEED = -1587797429870936371L;\n    try {\n      float[] orig = new float[32 * 1024 * 1024];\n      float density = 0.4f;\n      Random rand = new Random(SEED);\n      int idx = 0;\n      while (rand.nextFloat() > density) {\n        idx++;"}
{"magic_number_smell": "\n    /**\n     * Called when the host view is attempting to determine if an item's position\n     * has changed. Returns {@link #-1} if the position of the given\n     * item has not changed or {@link #POSITION_NONE} if the item is no longer present\n     * in the adapter.\n     *", "refactored_code": "    public static final int POSITION_UNCHANGED = -1;\n\n    /**\n     * Called when the host view is attempting to determine if an item's position\n     * has changed. Returns {@link #POSITION_UNCHANGED} if the position of the given\n     * item has not changed or {@link #POSITION_NONE} if the item is no longer present\n     * in the adapter.\n     *"}
{"magic_number_smell": "\n    private boolean mPopulatePending;\n    private boolean mScrolling;\n    private int mOffscreenPageLimit = 1;\n\n    private boolean mIsBeingDragged;\n    private boolean mIsUnableToDrag;", "refactored_code": "    private static final int DEFAULT_OFFSCREEN_PAGES = 1;\n\n    private boolean mPopulatePending;\n    private boolean mScrolling;\n    private int mOffscreenPageLimit = DEFAULT_OFFSCREEN_PAGES;\n\n    private boolean mIsBeingDragged;\n    private boolean mIsUnableToDrag;"}
{"magic_number_smell": "\tpublic static Bitmap createBitmap(Context context, int style, Bitmap coverArt, Song song, int width, int height)\n\t{\n\t\tswitch (style) {\n\t\tcase 0:\n\t\t\treturn createOverlappingBitmap(context, coverArt, song, width, height);\n\t\tcase STYLE_INFO_BELOW:\n\t\t\treturn createSeparatedBitmap(context, coverArt, song, width, height);", "refactored_code": "\tpublic static final int STYLE_OVERLAPPING_BOX = 0;\n\tpublic static Bitmap createBitmap(Context context, int style, Bitmap coverArt, Song song, int width, int height)\n\t{\n\t\tswitch (style) {\n\t\tcase STYLE_OVERLAPPING_BOX:\n\t\t\treturn createOverlappingBitmap(context, coverArt, song, width, height);\n\t\tcase STYLE_INFO_BELOW:\n\t\t\treturn createSeparatedBitmap(context, coverArt, song, width, height);"}
{"magic_number_smell": "\tpublic boolean handleMessage(Message message)\n\t{\n\t\tswitch (message.what) {\n\t\tcase 0:\n\t\t\tgenerateBitmap(message.arg1);\n\t\t\tbreak;\n\t\tcase MSG_LONG_CLICK:", "refactored_code": "\tprivate static final int MSG_GENERATE_BITMAP = 0;\n\tpublic boolean handleMessage(Message message)\n\t{\n\t\tswitch (message.what) {\n\t\tcase MSG_GENERATE_BITMAP:\n\t\t\tgenerateBitmap(message.arg1);\n\t\t\tbreak;\n\t\tcase MSG_LONG_CLICK:"}
{"magic_number_smell": "\t\t// Force expansion on next motion event\n\t\tmDragPos = INVALID_POSITION;\n\n\t\tmHandler.sendEmptyMessageDelayed(0, 50);\n\t}\n\n\t/**", "refactored_code": "\tprivate static final int MSG_SCROLL = 0;\n\t\t// Force expansion on next motion event\n\t\tmDragPos = INVALID_POSITION;\n\n\t\tmHandler.sendEmptyMessageDelayed(MSG_SCROLL, 50);\n\t}\n\n\t/**"}
{"magic_number_smell": "\t\t\tcoverStyle = CoverBitmap.STYLE_NO_INFO;\n\t\t\tlayout = R.layout.full_playback_alt;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tcoverStyle = CoverBitmap.STYLE_OVERLAPPING_BOX;\n\t\t\tbreak;\n\t\tcase DISPLAY_INFO_BELOW:", "refactored_code": "\tpublic static final int DISPLAY_INFO_OVERLAP = 0;\n\t\t\tcoverStyle = CoverBitmap.STYLE_NO_INFO;\n\t\t\tlayout = R.layout.full_playback_alt;\n\t\t\tbreak;\n\t\tcase DISPLAY_INFO_OVERLAP:\n\t\t\tcoverStyle = CoverBitmap.STYLE_OVERLAPPING_BOX;\n\t\t\tbreak;\n\t\tcase DISPLAY_INFO_BELOW:"}
{"magic_number_smell": "\t@Override\n\tpublic CharSequence getSummary()\n\t{\n\t\treturn formatTime(getPersistedInt(3600));\n\t}\n\n\t@Override", "refactored_code": "\tprivate static final int DEFAULT_VALUE = 3600;\n\t@Override\n\tpublic CharSequence getSummary()\n\t{\n\t\treturn formatTime(getPersistedInt(DEFAULT_VALUE));\n\t}\n\n\t@Override"}
{"magic_number_smell": "\t/**\n\t * The last used action from the menu. Used with ACTION_LAST_USED.\n\t */\n\tprivate int mLastAction = 0;\n\t/**\n\t * The id of the media that was last pressed in the current adapter. Used to\n\t * open the playback activity when an item is pressed twice.", "refactored_code": "\tpublic static final int ACTION_PLAY = 0;\n\t/**\n\t * The last used action from the menu. Used with ACTION_LAST_USED.\n\t */\n\tprivate int mLastAction = ACTION_PLAY;\n\t/**\n\t * The id of the media that was last pressed in the current adapter. Used to\n\t * open the playback activity when an item is pressed twice."}
{"magic_number_smell": "\t * The ListView for each adapter. Each index corresponds to that list's\n\t * MediaUtils id.\n\t */\n\tprivate final ListView[] mLists = new ListView[6];\n\t/**\n\t * The adapters. Each index corresponds to that adapter's MediaUtils id.\n\t */", "refactored_code": "\tpublic static final int MAX_ADAPTER_COUNT = 6;\n\t * The ListView for each adapter. Each index corresponds to that list's\n\t * MediaUtils id.\n\t */\n\tprivate final ListView[] mLists = new ListView[MAX_ADAPTER_COUNT];\n\t/**\n\t * The adapters. Each index corresponds to that adapter's MediaUtils id.\n\t */"}
{"magic_number_smell": "\n\t\t\tif (action == KeyEvent.ACTION_DOWN) {\n\t\t\t\tlong time = SystemClock.uptimeMillis();\n\t\t\t\tif (time - sLastClickTime < 400) {\n\t\t\t\t\tbeep(context);\n\t\t\t\t\tact = PlaybackService.ACTION_NEXT_SONG_AUTOPLAY;\n\t\t\t\t} else {", "refactored_code": "\tprivate static final int DOUBLE_CLICK_DELAY = 400;\n\n\t\t\tif (action == KeyEvent.ACTION_DOWN) {\n\t\t\t\tlong time = SystemClock.uptimeMillis();\n\t\t\t\tif (time - sLastClickTime < DOUBLE_CLICK_DELAY) {\n\t\t\t\t\tbeep(context);\n\t\t\t\t\tact = PlaybackService.ACTION_NEXT_SONG_AUTOPLAY;\n\t\t\t\t} else {"}
{"magic_number_smell": "\tpublic void onCreateContextMenu(ContextMenu menu, View view, ContextMenu.ContextMenuInfo menuInfo)\n\t{\n\t\tif (view == mShuffleButton) {\n\t\t\tmenu.add(100, SongTimeline.SHUFFLE_NONE, 0, R.string.no_shuffle);\n\t\t\tmenu.add(100, SongTimeline.SHUFFLE_SONGS, 0, R.string.shuffle_songs);\n\t\t\tmenu.add(100, SongTimeline.SHUFFLE_ALBUMS, 0, R.string.shuffle_albums);\n\t\t} else if (view == mEndButton) {", "refactored_code": "\tprivate static final int GROUP_SHUFFLE = 100;\n\tpublic void onCreateContextMenu(ContextMenu menu, View view, ContextMenu.ContextMenuInfo menuInfo)\n\t{\n\t\tif (view == mShuffleButton) {\n\t\t\tmenu.add(GROUP_SHUFFLE, SongTimeline.SHUFFLE_NONE, 0, R.string.no_shuffle);\n\t\t\tmenu.add(GROUP_SHUFFLE, SongTimeline.SHUFFLE_SONGS, 0, R.string.shuffle_songs);\n\t\t\tmenu.add(GROUP_SHUFFLE, SongTimeline.SHUFFLE_ALBUMS, 0, R.string.shuffle_albums);\n\t\t} else if (view == mEndButton) {"}
{"magic_number_smell": "\t\ttry {\n\t\t\tDataInputStream in = new DataInputStream(openFileInput(STATE_FILE));\n\n\t\t\tif (in.readLong() == 0x1533574DC74B6ECL && in.readInt() == STATE_VERSION) {\n\t\t\t\tmPendingSeek = in.readInt();\n\t\t\t\tmPendingSeekSong = in.readLong();\n\t\t\t\tmTimeline.readState(in);", "refactored_code": "\tprivate static final long STATE_FILE_MAGIC = 0x1533574DC74B6ECL;\n\t\ttry {\n\t\t\tDataInputStream in = new DataInputStream(openFileInput(STATE_FILE));\n\n\t\t\tif (in.readLong() == STATE_FILE_MAGIC && in.readInt() == STATE_VERSION) {\n\t\t\t\tmPendingSeek = in.readInt();\n\t\t\t\tmPendingSeekSong = in.readLong();\n\t\t\t\tmTimeline.readState(in);"}
{"magic_number_smell": "\t\tintent.putExtra(\"position\", info.position);\n\t\tintent.putExtra(\"audioId\", (Long)info.targetView.getTag());\n\n\t\tmenu.add(0, LibraryActivity.ACTION_PLAY, 0, R.string.play).setIntent(intent);\n\t\tmenu.add(0, MENU_PLAY_ALL, 0, R.string.play_all).setIntent(intent);\n\t\tmenu.add(0, MENU_ENQUEUE, 0, R.string.enqueue).setIntent(intent);\n\t\tmenu.add(0, MENU_ENQUEUE_ALL, 0, R.string.enqueue_all).setIntent(intent);", "refactored_code": "\tprivate static final int MENU_PLAY = LibraryActivity.ACTION_PLAY;\n\t\tintent.putExtra(\"position\", info.position);\n\t\tintent.putExtra(\"audioId\", (Long)info.targetView.getTag());\n\n\t\tmenu.add(0, MENU_PLAY, 0, R.string.play).setIntent(intent);\n\t\tmenu.add(0, MENU_PLAY_ALL, 0, R.string.play_all).setIntent(intent);\n\t\tmenu.add(0, MENU_ENQUEUE, 0, R.string.enqueue).setIntent(intent);\n\t\tmenu.add(0, MENU_ENQUEUE_ALL, 0, R.string.enqueue_all).setIntent(intent);"}
{"magic_number_smell": "\tpublic boolean handleMessage(Message message)\n\t{\n\t\tswitch (message.what) {\n\t\tcase 1: {\n\t\t\tCursor cursor = runQuery(mContext.getContentResolver());\n\t\t\tmUiHandler.sendMessage(mUiHandler.obtainMessage(MSG_UPDATE_CURSOR, cursor));\n\t\t\tbreak;", "refactored_code": "\tpublic static final int MSG_RUN_QUERY = 1;\n\tpublic boolean handleMessage(Message message)\n\t{\n\t\tswitch (message.what) {\n\t\tcase MSG_RUN_QUERY: {\n\t\t\tCursor cursor = runQuery(mContext.getContentResolver());\n\t\t\tmUiHandler.sendMessage(mUiHandler.obtainMessage(MSG_UPDATE_CURSOR, cursor));\n\t\t\tbreak;"}
{"magic_number_smell": "\tpublic int trackNumber;\n\n\t/**\n\t * Song flags. Currently {@link #0x1} or {@link #FLAG_NO_COVER}.\n\t */\n\tpublic int flags;\n", "refactored_code": "\tpublic static final int FLAG_RANDOM = 0x1;\n\tpublic int trackNumber;\n\n\t/**\n\t * Song flags. Currently {@link #FLAG_RANDOM} or {@link #FLAG_NO_COVER}.\n\t */\n\tpublic int flags;\n"}
{"magic_number_smell": "\tpublic boolean isEndOfQueue()\n\t{\n\t\tsynchronized (this) {\n\t\t\treturn mFinishAction == 0 && mCurrentPos == mSongs.size() - 1;\n\t\t}\n\t}\n", "refactored_code": "\tpublic static final int FINISH_STOP = 0;\n\tpublic boolean isEndOfQueue()\n\t{\n\t\tsynchronized (this) {\n\t\t\treturn mFinishAction == FINISH_STOP && mCurrentPos == mSongs.size() - 1;\n\t\t}\n\t}\n"}
{"magic_number_smell": "    @Override public String toString() {\n      return \"forMap(\" + map + \", defaultValue=\" + defaultValue + \")\";\n    }\n    private static final long 0 = 0;\n  }\n\n  /**", "refactored_code": "    private static final long serialVersionUID = 0;\n    @Override public String toString() {\n      return \"forMap(\" + map + \", defaultValue=\" + defaultValue + \")\";\n    }\n    private static final long serialVersionUID = 0;\n  }\n\n  /**"}
{"magic_number_smell": "    @Override public String toString() {\n      return \"And(\" + commaJoiner.join(components) + \")\";\n    }\n    private static final long 0 = 0;\n  }\n\n  /** @see Predicates#or(Iterable) */", "refactored_code": "    private static final long serialVersionUID = 0;\n    @Override public String toString() {\n      return \"And(\" + commaJoiner.join(components) + \")\";\n    }\n    private static final long serialVersionUID = 0;\n  }\n\n  /** @see Predicates#or(Iterable) */"}
{"magic_number_smell": "\n  static class ComputingImpl<K, V, E> extends Impl<K, V, E> {\n\n    static final long 0 = 0;\n\n    final ComputingStrategy<K, V, E> computingStrategy;\n    final Function<? super K, ? extends V> computer;", "refactored_code": "    private static final long serialVersionUID = 0;\n\n  static class ComputingImpl<K, V, E> extends Impl<K, V, E> {\n\n    static final long serialVersionUID = 0;\n\n    final ComputingStrategy<K, V, E> computingStrategy;\n    final Function<? super K, ? extends V> computer;"}
{"magic_number_smell": "    private final int maxIterations;\n    \n    public BigSquareRoot() {\n        this(50, DEFAULT_SCALE);\n    }\n    \n    public BigSquareRoot(int maxIterations, int scale) {", "refactored_code": "    public static final int DEFAULT_MAX_ITERATIONS = 50;\n    private final int maxIterations;\n    \n    public BigSquareRoot() {\n        this(DEFAULT_MAX_ITERATIONS, DEFAULT_SCALE);\n    }\n    \n    public BigSquareRoot(int maxIterations, int scale) {"}
{"magic_number_smell": "  public static final int MINUTES_MASK = 1 << MINUTES_COMPONENT;\n  public static final int SECONDS_MASK = 1 << SECONDS_COMPONENT;\n  public static final int TIMEZONE_MASK = 1 << TIMEZONE_COMPONENT;\n  public static final int DATE_MASK = 1 << YEAR_COMPONENT|MONTH_MASK|DAY_MASK;\n  public static final int TIME_MASK = HOURS_MASK|MINUTES_MASK|SECONDS_MASK;\n\n  public int components() { return mask & ~TIMEZONE_MASK; }", "refactored_code": "  public static final int YEAR_MASK = 1 << YEAR_COMPONENT;\n  public static final int MINUTES_MASK = 1 << MINUTES_COMPONENT;\n  public static final int SECONDS_MASK = 1 << SECONDS_COMPONENT;\n  public static final int TIMEZONE_MASK = 1 << TIMEZONE_COMPONENT;\n  public static final int DATE_MASK = YEAR_MASK|MONTH_MASK|DAY_MASK;\n  public static final int TIME_MASK = HOURS_MASK|MINUTES_MASK|SECONDS_MASK;\n\n  public int components() { return mask & ~TIMEZONE_MASK; }"}
{"magic_number_smell": "        Cell[] cellsLocalRef = cells;\n        int insertPos;\n        if(count == 0) {\n            cellsLocalRef = new Cell[4];\n            cells = cellsLocalRef;\n            insertPos = getCellIndex(cellsLocalRef.length, hash);\n        } else {", "refactored_code": "    private static final int INITIAL_CELL_SIZE = 4;\n        Cell[] cellsLocalRef = cells;\n        int insertPos;\n        if(count == 0) {\n            cellsLocalRef = new Cell[INITIAL_CELL_SIZE];\n            cells = cellsLocalRef;\n            insertPos = getCellIndex(cellsLocalRef.length, hash);\n        } else {"}
{"magic_number_smell": "    }\n\n    public final boolean isTrue() {\n        return (body.flags & 1 << 0) == 0;\n    }\n\n    public final boolean isFrozen() {", "refactored_code": "    public static final int FALSY_F = 1 << 0;\n    }\n\n    public final boolean isTrue() {\n        return (body.flags & FALSY_F) == 0;\n    }\n\n    public final boolean isFrozen() {"}
{"magic_number_smell": "    public static void initRuntime(IokeObject obj) throws ControlFlow {\n        obj.setKind(\"Runtime\");\n\n        obj.registerMethod(obj.runtime.newNativeMethod(\"returns the node getNextId() for the runtime it's called on\", new TypeCheckingNativeMethod.WithNoArguments(\"nodeId\", obj) {\n                @Override\n                public Object activate(IokeObject method, Object on, List<Object> args, Map<String, Object> keywords, IokeObject context, IokeObject message) throws ControlFlow {\n                    Runtime r = (Runtime)IokeObject.data(on);", "refactored_code": "    private final int id = getNextId();\n    public static void initRuntime(IokeObject obj) throws ControlFlow {\n        obj.setKind(\"Runtime\");\n\n        obj.registerMethod(obj.runtime.newNativeMethod(\"returns the node id for the runtime it's called on\", new TypeCheckingNativeMethod.WithNoArguments(\"nodeId\", obj) {\n                @Override\n                public Object activate(IokeObject method, Object on, List<Object> args, Map<String, Object> keywords, IokeObject context, IokeObject message) throws ControlFlow {\n                    Runtime r = (Runtime)IokeObject.data(on);"}
{"magic_number_smell": "   */\n   public static final int ACCEPT_INCOMPLETE=8;\n\n   //see search(1|...)\n   private static Term startAnchor=new Term(TermType.START);\n\n   //see search(ANCHOR_LASTMATCH|...)", "refactored_code": "   public static final int ANCHOR_START=1;\n   */\n   public static final int ACCEPT_INCOMPLETE=8;\n\n   //see search(ANCHOR_START|...)\n   private static Term startAnchor=new Term(TermType.START);\n\n   //see search(ANCHOR_LASTMATCH|...)"}
{"magic_number_smell": "            return new Optimizer(term,dist);\n         case BITSET:\n         case BITSET2:\n            if(term.weight<=20) return new Optimizer(term,dist);\n            else return find(term.next,dist+1);\n         case ANY_CHAR:\n         case ANY_CHAR_NE:", "refactored_code": "   public static final int THRESHOLD=20;\n            return new Optimizer(term,dist);\n         case BITSET:\n         case BITSET2:\n            if(term.weight<=THRESHOLD) return new Optimizer(term,dist);\n            else return find(term.next,dist+1);\n         case ANY_CHAR:\n         case ANY_CHAR_NE:"}
{"magic_number_smell": "\n      re.root=optimized;\n      re.root0=first;\n      re.memregs=vars[0];\n      re.counters=vars[CNTREG_COUNT];\n      re.lookaheads=vars[LOOKAHEAD_COUNT];\n      re.namedGroupMap=groupNames;", "refactored_code": "   private static final int MEMREG_COUNT=0;    //refers current memreg index\n\n      re.root=optimized;\n      re.root0=first;\n      re.memregs=vars[MEMREG_COUNT];\n      re.counters=vars[CNTREG_COUNT];\n      re.lookaheads=vars[LOOKAHEAD_COUNT];\n      re.namedGroupMap=groupNames;"}
{"magic_number_smell": "\npublic class PathPattern extends Pattern{\n   private static final int 1=1;\n   private static int GRP_NO=1+1;\n   private static final int ANY_G=GRP_NO++;\n   private static final int FS_G=GRP_NO++;\n   private static final int STAR_G=GRP_NO++;", "refactored_code": "   private static final int RESERVED=1;\n\npublic class PathPattern extends Pattern{\n   private static final int RESERVED=1;\n   private static int GRP_NO=RESERVED+1;\n   private static final int ANY_G=GRP_NO++;\n   private static final int FS_G=GRP_NO++;\n   private static final int STAR_G=GRP_NO++;"}
{"magic_number_smell": "        if (version != 0) {\n            builder.addElement(\"version\", version);\n        } else {\n            builder.addElement(\"version\", 2);\n        }\n\n        return builder;", "refactored_code": "    private static final int DEFAULT_VERSION = 2;\n        if (version != 0) {\n            builder.addElement(\"version\", version);\n        } else {\n            builder.addElement(\"version\", DEFAULT_VERSION);\n        }\n\n        return builder;"}
{"magic_number_smell": "            pos = 0;\n            readPos = 0;\n        } else {\n            byte[] b = new byte[buffer.length * 2];\n            System.arraycopy(buffer, 0, b, 0, buffer.length);\n            buffer = b;\n        }", "refactored_code": "    private static final int DEFAULT_BUFFER_RESIZE_FACTOR = 2;\n            pos = 0;\n            readPos = 0;\n        } else {\n            byte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\n            System.arraycopy(buffer, 0, b, 0, buffer.length);\n            buffer = b;\n        }"}
{"magic_number_smell": "\n        token = consumeToken();\n        if (token.getType() == Token.NAME) {\n            if (mode == 1) {\n                // Get the name of the function and declare it in the current scope.\n                symbol = token.getValue();\n                if (currentScope.getIdentifier(symbol) != null) {", "refactored_code": "    private static final int BUILDING_SYMBOL_TREE = 1;\n\n        token = consumeToken();\n        if (token.getType() == Token.NAME) {\n            if (mode == BUILDING_SYMBOL_TREE) {\n                // Get the name of the function and declare it in the current scope.\n                symbol = token.getValue();\n                if (currentScope.getIdentifier(symbol) != null) {"}
{"magic_number_smell": "        if (caseGap < 0) throw new IllegalArgumentException();\n\n        StringBuffer result = new StringBuffer();\n        boolean justFunctionBody = (0 != (flags & Decompiler.1 << 0));\n        boolean toSource = (0 != (flags & Decompiler.TO_SOURCE_FLAG));\n\n        // Spew tokens in source, for debugging.", "refactored_code": "    public static final int ONLY_BODY_FLAG = 1 << 0;\n        if (caseGap < 0) throw new IllegalArgumentException();\n\n        StringBuffer result = new StringBuffer();\n        boolean justFunctionBody = (0 != (flags & Decompiler.ONLY_BODY_FLAG));\n        boolean toSource = (0 != (flags & Decompiler.TO_SOURCE_FLAG));\n\n        // Spew tokens in source, for debugging."}
{"magic_number_smell": "\t\t\t// shouldn't happen\n\t\t}\n\t\t\n\t\tflags |= (1 << 4);\n\t\t\n\t\tif (getOptions() != null && getOptions().length > 0)\n\t\t\tflags |= 0x04;", "refactored_code": "\tprivate static final byte MetadataVersion = 1;\n\t\t\t// shouldn't happen\n\t\t}\n\t\t\n\t\tflags |= (MetadataVersion << 4);\n\t\t\n\t\tif (getOptions() != null && getOptions().length > 0)\n\t\t\tflags |= 0x04;"}
{"magic_number_smell": "\t\t\t\t\t\t// Got the entire length field; switch mode to reading the message itself\n\t\t\t\t\t  int length = new DataInputStream(\n\t\t\t\t\t  \t\tnew ByteArrayInputStream(lengthBuf)).readInt();\n\t\t\t\t\t\tif (length <= 0 || length > 256*1024) {\n\t\t\t\t\t\t\tSocket sock = channel.socket();\n\t\t\t\t\t\t\tLOG.warn(\"Closing ReadReportsThread for \"\n\t\t\t\t\t\t\t\t+ sock.getInetAddress() + \":\" + sock.getPort() ", "refactored_code": "\tprivate static final int MAX_REPORT_LENGTH = 256*1024;\n\t\t\t\t\t\t// Got the entire length field; switch mode to reading the message itself\n\t\t\t\t\t  int length = new DataInputStream(\n\t\t\t\t\t  \t\tnew ByteArrayInputStream(lengthBuf)).readInt();\n\t\t\t\t\t\tif (length <= 0 || length > MAX_REPORT_LENGTH) {\n\t\t\t\t\t\t\tSocket sock = channel.socket();\n\t\t\t\t\t\t\tLOG.warn(\"Closing ReadReportsThread for \"\n\t\t\t\t\t\t\t\t+ sock.getInetAddress() + \":\" + sock.getPort() "}
{"magic_number_smell": "\t\t\t\tLOG.info(\"Starting TcpClientHandler for \"\n\t\t\t\t\t\t+ sock.getInetAddress() + \":\" + sock.getPort());\n\t\t\t\t\n\t\t\t\tbyte[] buf = new byte[256*1024];\n\t\t\t\tDataInputStream in = new DataInputStream(sock.getInputStream());\n\t\t\t\twhile (true) {\n\t\t\t\t\tint length = in.readInt();", "refactored_code": "\tprivate static final int MAX_REPORT_LENGTH = 256*1024;\n\t\t\t\tLOG.info(\"Starting TcpClientHandler for \"\n\t\t\t\t\t\t+ sock.getInetAddress() + \":\" + sock.getPort());\n\t\t\t\t\n\t\t\t\tbyte[] buf = new byte[MAX_REPORT_LENGTH];\n\t\t\t\tDataInputStream in = new DataInputStream(sock.getInputStream());\n\t\t\t\twhile (true) {\n\t\t\t\t\tint length = in.readInt();"}
{"magic_number_smell": "\t\tcontext.put(\"showStats\", showDbStats);\n    context.put(\"JSON_DATE_FORMAT\", JSON_DATE_FORMAT);\n    context.put(\"HTML_DATE_FORMAT\", HTML_DATE_FORMAT);\n    context.put(\"25\", 25);\n    // Return Velocity results\n\t\ttry {\n\t\t\tVelocity.mergeTemplate(\"tasks.vm\", \"UTF-8\", context, response.getWriter());", "refactored_code": "\tprivate static final int PAGE_LENGTH = 25;\n\t\tcontext.put(\"showStats\", showDbStats);\n    context.put(\"JSON_DATE_FORMAT\", JSON_DATE_FORMAT);\n    context.put(\"HTML_DATE_FORMAT\", HTML_DATE_FORMAT);\n    context.put(\"PAGE_LENGTH\", PAGE_LENGTH);\n    // Return Velocity results\n\t\ttry {\n\t\t\tVelocity.mergeTemplate(\"tasks.vm\", \"UTF-8\", context, response.getWriter());"}
{"magic_number_smell": "\t@Test\n\tpublic void testMetadataXtrTaskIDInt() {\n\t\tfor (int i = 0; i < goodTasks.length; i++) {\n\t\t\tfor (int j = 0; j < 10000; j++) {\n\t\t\t\tXTraceMetadata md = new XTraceMetadata(goodTasks[i], rnd.nextInt());\n\t\t\t\tassertNotNull(md);\n\t\t\t\tassertTrue(md.isValid());", "refactored_code": "\tprivate static final int BigStochasticTests = 10000;\n\t@Test\n\tpublic void testMetadataXtrTaskIDInt() {\n\t\tfor (int i = 0; i < goodTasks.length; i++) {\n\t\t\tfor (int j = 0; j < BigStochasticTests; j++) {\n\t\t\t\tXTraceMetadata md = new XTraceMetadata(goodTasks[i], rnd.nextInt());\n\t\t\t\tassertNotNull(md);\n\t\t\t\tassertTrue(md.isValid());"}
{"magic_number_smell": "\tpublic void TODOtestMultipleInsertion() throws XTraceException {\n\t\tif (!canTest) return;\n\t\t\n\t\tfinal int TOTAL_REPORTS = 100 * NUM_STOCHASTIC_REPORTS_PER_TASK;\n\t\t\n\t\tlong startTime = System.currentTimeMillis();\n\t\t", "refactored_code": "\tprivate static final int NUM_STOCHASTIC_TASKS = 100;\n\tpublic void TODOtestMultipleInsertion() throws XTraceException {\n\t\tif (!canTest) return;\n\t\t\n\t\tfinal int TOTAL_REPORTS = NUM_STOCHASTIC_TASKS * NUM_STOCHASTIC_REPORTS_PER_TASK;\n\t\t\n\t\tlong startTime = System.currentTimeMillis();\n\t\t"}
{"magic_number_smell": "    public static final int DEFAULT_LOAD_FACTOR = Integer.parseInt(System.getProperty(PROPERTY_PREFIX + \"DEFAULT_LOAD_FACTOR\", \"75\"));\n    private Codec<Key> keyCodec = new ObjectCodec<Key>();\n    private Codec<Value> valueCodec = new ObjectCodec<Value>();\n    private int initialBucketCapacity = Integer.parseInt(System.getProperty(PROPERTY_PREFIX + \"DEFAULT_BUCKET_CAPACITY\", \"1024\"));\n    private int maximumBucketCapacity = DEFAULT_MAXIMUM_BUCKET_CAPACITY;\n    private int minimumBucketCapacity = DEFAULT_MINIMUM_BUCKET_CAPACITY;\n    private int loadFactor = DEFAULT_LOAD_FACTOR;", "refactored_code": "    public static final int DEFAULT_BUCKET_CAPACITY = Integer.parseInt(System.getProperty(PROPERTY_PREFIX + \"DEFAULT_BUCKET_CAPACITY\", \"1024\"));\n    public static final int DEFAULT_LOAD_FACTOR = Integer.parseInt(System.getProperty(PROPERTY_PREFIX + \"DEFAULT_LOAD_FACTOR\", \"75\"));\n    private Codec<Key> keyCodec = new ObjectCodec<Key>();\n    private Codec<Value> valueCodec = new ObjectCodec<Value>();\n    private int initialBucketCapacity = DEFAULT_BUCKET_CAPACITY;\n    private int maximumBucketCapacity = DEFAULT_MAXIMUM_BUCKET_CAPACITY;\n    private int minimumBucketCapacity = DEFAULT_MINIMUM_BUCKET_CAPACITY;\n    private int loadFactor = DEFAULT_LOAD_FACTOR;"}
{"magic_number_smell": "        private int limit;\n\n        public PredicateVisitor(Predicate<Key> predicate) {\n            this(predicate, -1);\n        }\n\n        public PredicateVisitor(Predicate<Key> predicate, int limit) {", "refactored_code": "        public static final int UNLIMITED=-1;\n        private int limit;\n\n        public PredicateVisitor(Predicate<Key> predicate) {\n            this(predicate, UNLIMITED);\n        }\n\n        public PredicateVisitor(Predicate<Key> predicate, int limit) {"}
{"magic_number_smell": "    \n    \n    public ExtentOutputStream(Paged paged) {\n        this(paged, 128);\n    }\n    \n    public ExtentOutputStream(Paged paged, short extentSize) {", "refactored_code": "    private static final short DEFAULT_EXTENT_SIZE = 128; // 128 * 4k = .5MB\n    \n    \n    public ExtentOutputStream(Paged paged) {\n        this(paged, DEFAULT_EXTENT_SIZE);\n    }\n    \n    public ExtentOutputStream(Paged paged, short extentSize) {"}
{"magic_number_smell": "                    + \" }\";\n        }\n\n        private final DataByteArrayOutputStream os = new DataByteArrayOutputStream(1024 * 4);\n\n        Buffer encode() {\n            try {", "refactored_code": "    public static final int FILE_HEADER_SIZE = 1024 * 4;\n                    + \" }\";\n        }\n\n        private final DataByteArrayOutputStream os = new DataByteArrayOutputStream(FILE_HEADER_SIZE);\n\n        Buffer encode() {\n            try {"}
{"magic_number_smell": "    \n    public Update(Update update) {\n        this.shadow = update.shadow;\n        this.flags = (byte) (update.flags & (0x01 << 0|PAGE_FREED));\n        this.history = update.history;\n    }\n", "refactored_code": "    public static final byte PAGE_ALLOCATED   = 0x01 << 0;\n    \n    public Update(Update update) {\n        this.shadow = update.shadow;\n        this.flags = (byte) (update.flags & (PAGE_ALLOCATED|PAGE_FREED));\n        this.history = update.history;\n    }\n"}
{"magic_number_smell": "    private static final long 8340484139329633582L = 8340484139329633582L;\n\n    final public static class Range implements Serializable {\n        private static final long 8340484139329633582L = -4904483630105365841L;\n        \n        public volatile int start;\n        public volatile int end;", "refactored_code": "    private static final long serialVersionUID = 8340484139329633582L;\n    private static final long serialVersionUID = 8340484139329633582L;\n\n    final public static class Range implements Serializable {\n        private static final long serialVersionUID = -4904483630105365841L;\n        \n        public volatile int start;\n        public volatile int end;"}
{"magic_number_smell": "    }\n    \n    public static void copyInputStream(InputStream in, OutputStream out) throws IOException {\n        byte[] buffer = new byte[4096];\n        int len = in.read(buffer);\n        while (len >= 0) {\n            out.write(buffer, 0, len);", "refactored_code": "    private static final int DEFAULT_BUFFER_SIZE = 4096;\n    }\n    \n    public static void copyInputStream(InputStream in, OutputStream out) throws IOException {\n        byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];\n        int len = in.read(buffer);\n        while (len >= 0) {\n            out.write(buffer, 0, len);"}
{"magic_number_smell": "\n    public static class TreeEntry<K, V> implements Map.Entry<K, V>, Serializable {\n\n        private static final long 6107175734705142096L = 8490652911043012737L;\n        \n        volatile TreeMap<K, V> map;\n        volatile V value;", "refactored_code": "    private static final long serialVersionUID = 6107175734705142096L;\n\n    public static class TreeEntry<K, V> implements Map.Entry<K, V>, Serializable {\n\n        private static final long serialVersionUID = 8490652911043012737L;\n        \n        volatile TreeMap<K, V> map;\n        volatile V value;"}
{"magic_number_smell": "                try {\n                    \n                    index.put(counter++, new Buffer(DATA));\n                    if( (counter%5000000)==0 ) {\n                        counter=0;\n                    }\n                    ", "refactored_code": "    private static final int KEY_SPACE = 5000000;\n                try {\n                    \n                    index.put(counter++, new Buffer(DATA));\n                    if( (counter%KEY_SPACE)==0 ) {\n                        counter=0;\n                    }\n                    "}
{"magic_number_smell": "    @Test\n    public void testReloadFromDisk() throws Exception {\n        createPageFileAndIndex((short) 500);\n        doInsert(10000);\n        reloadAll();\n        checkRetrieve(10000);\n    }", "refactored_code": "    private static final int COUNT = 10000;\n    @Test\n    public void testReloadFromDisk() throws Exception {\n        createPageFileAndIndex((short) 500);\n        doInsert(COUNT);\n        reloadAll();\n        checkRetrieve(COUNT);\n    }"}
{"magic_number_smell": "    public void testGrowIssue() throws Exception {\n\n        // a 1kb string for testing\n        StringBuilder sb = new StringBuilder(1024);\n        for (int i = 0; i < 1024; i++) {\n            sb.append(\"X\");\n        }", "refactored_code": "    private final int size = 1024;\n    public void testGrowIssue() throws Exception {\n\n        // a 1kb string for testing\n        StringBuilder sb = new StringBuilder(size);\n        for (int i = 0; i < 1024; i++) {\n            sb.append(\"X\");\n        }"}
{"magic_number_smell": "                throw new OperatorException(\"Invalid coefficient file: no nadir view \\\"a\\\" coefficients set\");\n            }\n\n            a0[i] = aCoefficients[0] * 1.0f;\n            a1[i] = aCoefficients[1];\n            a2[i] = aCoefficients[2];\n", "refactored_code": "    private static final float COEFF_0_SCALE = 1.0f;\n                throw new OperatorException(\"Invalid coefficient file: no nadir view \\\"a\\\" coefficients set\");\n            }\n\n            a0[i] = aCoefficients[0] * COEFF_0_SCALE;\n            a1[i] = aCoefficients[1];\n            a2[i] = aCoefficients[2];\n"}
{"magic_number_smell": "        String[] aStrings = StringUtils.split(a_values, _separators, true);\n\n        // check that we have THREE values\n        if (aStrings.length != 3) {\n            throw new OperatorException(\"illegal coefficient file format: a.x must have \" + 3 + \" values\");\n        }\n", "refactored_code": "    private static final int _numACoeffs = 3;\n        String[] aStrings = StringUtils.split(a_values, _separators, true);\n\n        // check that we have THREE values\n        if (aStrings.length != _numACoeffs) {\n            throw new OperatorException(\"illegal coefficient file format: a.x must have \" + _numACoeffs + \" values\");\n        }\n"}
{"magic_number_smell": "\n            final boolean isSouth = leaderFile.isUTMSouthHemisphere();\n\n            double easting = leaderFile.getUTMEasting() * 1000;     // km -> meter\n            double northing = leaderFile.getUTMNorthing() * 1000;    // km -> meter\n            // easting and northing already do take into account false-easting and false-northing (rq - 14.10.2008)\n", "refactored_code": "    private static final int METER_PER_KILOMETER = 1000;\n\n            final boolean isSouth = leaderFile.isUTMSouthHemisphere();\n\n            double easting = leaderFile.getUTMEasting() * METER_PER_KILOMETER;     // km -> meter\n            double northing = leaderFile.getUTMNorthing() * METER_PER_KILOMETER;    // km -> meter\n            // easting and northing already do take into account false-easting and false-northing (rq - 14.10.2008)\n"}
{"magic_number_smell": "            final MapProjection projection = new MapProjection(StereographicDescriptor.NAME, transform);\n            final double pixelSizeX = leaderFile.getNominalInterPixelDistance();\n            final double pixelSizeY = leaderFile.getNominalInterLineDistance();\n            final double easting = leaderFile.getPSXCoordinate() * 1000;\n            final double northing = leaderFile.getPSYCoordinate() * 1000;\n            final int sceneRasterWidth = product.getSceneRasterWidth();\n            final int sceneRasterHeight = product.getSceneRasterHeight();", "refactored_code": "    private static final int METER_PER_KILOMETER = 1000;\n            final MapProjection projection = new MapProjection(StereographicDescriptor.NAME, transform);\n            final double pixelSizeX = leaderFile.getNominalInterPixelDistance();\n            final double pixelSizeY = leaderFile.getNominalInterLineDistance();\n            final double easting = leaderFile.getPSXCoordinate() * METER_PER_KILOMETER;\n            final double northing = leaderFile.getPSYCoordinate() * METER_PER_KILOMETER;\n            final int sceneRasterWidth = product.getSceneRasterWidth();\n            final int sceneRasterHeight = product.getSceneRasterHeight();"}
{"magic_number_smell": "        final Calendar calendar = Calendar.getInstance();\n        final int days = Integer.parseInt(_dateImageWasTaken.substring(0, 2));\n        final int month = (Integer) MONTH_TABLE.get(_dateImageWasTaken.substring(2, 5));\n        final int year = Integer.parseInt(_dateImageWasTaken.substring(5, 7)) + 2000;\n\n        calendar.set(year, month - 1, days, 0, 0, 0);\n        return calendar;", "refactored_code": "    private static final int YEAR_OFFSET = 2000;\n        final Calendar calendar = Calendar.getInstance();\n        final int days = Integer.parseInt(_dateImageWasTaken.substring(0, 2));\n        final int month = (Integer) MONTH_TABLE.get(_dateImageWasTaken.substring(2, 5));\n        final int year = Integer.parseInt(_dateImageWasTaken.substring(5, 7)) + YEAR_OFFSET;\n\n        calendar.set(year, month - 1, days, 0, 0, 0);\n        return calendar;"}
{"magic_number_smell": "                                                                    IllegalCeosFormatException {\n        BaseRecordTest.assertRecord(record);\n        assertEquals(_prefix.length(), record.getStartPos());\n        assertEquals(_prefix.length() + 4680, _ios.getStreamPosition());\n\n        assertEquals(16959, record.getNumNominalPixelsPerLine_1A_1B1());\n        assertEquals(14000, record.getNumNominalLinesPerScene_1A_1B1());", "refactored_code": "    private static final int RECORD_LENGTH = 4680;\n                                                                    IllegalCeosFormatException {\n        BaseRecordTest.assertRecord(record);\n        assertEquals(_prefix.length(), record.getStartPos());\n        assertEquals(_prefix.length() + RECORD_LENGTH, _ios.getStreamPosition());\n\n        assertEquals(16959, record.getNumNominalPixelsPerLine_1A_1B1());\n        assertEquals(14000, record.getNumNominalLinesPerScene_1A_1B1());"}
{"magic_number_smell": "    private void assertRecord(final Ancillary2Record record) throws IOException {\n        BaseRecordTest.assertRecord(record);\n        assertEquals(_prefix.length(), record.getStartPos());\n        assertEquals(_prefix.length() + 4680, _ios.getStreamPosition());\n\n        assertEquals(\"OB4 \", record.getSensorOperationMode());\n        assertEquals(1234, record.getLowerLimitOfStrengthAfterCorrection());", "refactored_code": "    private static final int RECORD_LENGTH = 4680;\n    private void assertRecord(final Ancillary2Record record) throws IOException {\n        BaseRecordTest.assertRecord(record);\n        assertEquals(_prefix.length(), record.getStartPos());\n        assertEquals(_prefix.length() + RECORD_LENGTH, _ios.getStreamPosition());\n\n        assertEquals(\"OB4 \", record.getSensorOperationMode());\n        assertEquals(1234, record.getLowerLimitOfStrengthAfterCorrection());"}
{"magic_number_smell": "        assertIntAttribute(elem, \"Record type code\", 0300);\n        assertIntAttribute(elem, \"Second record subtype\", 022);\n        assertIntAttribute(elem, \"Third record subtype\", 021);\n        assertIntAttribute(elem, \"Record length\", 4680);\n    }\n\n    public static void assertIntAttribute(MetadataElement elem, String attributeName, int expectedValue) {", "refactored_code": "    public static final int RECORD_LENGTH = 4680;\n        assertIntAttribute(elem, \"Record type code\", 0300);\n        assertIntAttribute(elem, \"Second record subtype\", 022);\n        assertIntAttribute(elem, \"Third record subtype\", 021);\n        assertIntAttribute(elem, \"Record length\", RECORD_LENGTH);\n    }\n\n    public static void assertIntAttribute(MetadataElement elem, String attributeName, int expectedValue) {"}
{"magic_number_smell": "\n    public void testInit_Level1A_SimpleConstructor() throws IOException,\n                                                            IllegalCeosFormatException {\n        writeRecordData(_ios, 0);\n        _ios.writeBytes(\"nq3tf9\u00c3\u01788nvnvpdi er 0 324p3f\"); // as suffix\n        final CeosFileReader reader = new CeosFileReader(_ios);\n        reader.seek(_prefix.length());", "refactored_code": "    private final int _level1A = 0;\n\n    public void testInit_Level1A_SimpleConstructor() throws IOException,\n                                                            IllegalCeosFormatException {\n        writeRecordData(_ios, _level1A);\n        _ios.writeBytes(\"nq3tf9\u00c3\u01788nvnvpdi er 0 324p3f\"); // as suffix\n        final CeosFileReader reader = new CeosFileReader(_ios);\n        reader.seek(_prefix.length());"}
{"magic_number_smell": "                                   int sourceStepX,\n                                   int sourceStepY, int destOffsetX, int destOffsetY, int destWidth, int destHeight,\n                                   ProductData destBuffer, ProgressMonitor pm) throws IOException {\n        setStreamPos(sourceOffsetX, sourceOffsetY, 1);\n\n        float[] targetData = (float[]) destBuffer.getElems();\n        byte[] line = new byte[sourceWidth];", "refactored_code": "    private static final int _pixelSize = 1;\n                                   int sourceStepX,\n                                   int sourceStepY, int destOffsetX, int destOffsetY, int destWidth, int destHeight,\n                                   ProductData destBuffer, ProgressMonitor pm) throws IOException {\n        setStreamPos(sourceOffsetX, sourceOffsetY, _pixelSize);\n\n        float[] targetData = (float[]) destBuffer.getElems();\n        byte[] line = new byte[sourceWidth];"}
{"magic_number_smell": "    public static final int CH_5 = 5;\n\n    public static final String[] CH_STRINGS = {\n        \"1\", //0\n        \"2\", //CH_2\n        \"3a\", //CH_3A\n        \"3b\", //CH_3B", "refactored_code": "    public static final int CH_1 = 0;\n    public static final int CH_5 = 5;\n\n    public static final String[] CH_STRINGS = {\n        \"1\", //CH_1\n        \"2\", //CH_2\n        \"3a\", //CH_3A\n        \"3b\", //CH_3B"}
{"magic_number_smell": "\t\tthis.constant1 = constant1;\n\t\tthis.constant2 = constant2;\n\t\tthis.c2vc = C2 * vc;\n\t\tthis.c1vc3 = 1.1910427E-5 * vc * vc * vc;\n\t}\n\n\t@Override", "refactored_code": "\tprivate static final double C1 = 1.1910427E-5;\n\t\tthis.constant1 = constant1;\n\t\tthis.constant2 = constant2;\n\t\tthis.c2vc = C2 * vc;\n\t\tthis.c1vc3 = C1 * vc * vc * vc;\n\t}\n\n\t@Override"}
{"magic_number_smell": "        int bandNo = AvhrrConstants.CH_DATASET_INDEXES[channel];\n        int indexRaw = FIRST[bandNo];\n        for (int i = 0; i < lineOfCounts.length; i++) {\n            lineOfCounts[i] = (rawData[indexRaw] & (0b1111111111 << SHIFT[bandNo][j])) >> SHIFT[bandNo][j];\n            indexRaw += INCREMENT[bandNo][j];\n            j = j == 2 ? 0 : j + 1;\n        }", "refactored_code": "    private static final int TEN_BITS = 0b1111111111;\n        int bandNo = AvhrrConstants.CH_DATASET_INDEXES[channel];\n        int indexRaw = FIRST[bandNo];\n        for (int i = 0; i < lineOfCounts.length; i++) {\n            lineOfCounts[i] = (rawData[indexRaw] & (TEN_BITS << SHIFT[bandNo][j])) >> SHIFT[bandNo][j];\n            indexRaw += INCREMENT[bandNo][j];\n            j = j == 2 ? 0 : j + 1;\n        }"}
{"magic_number_smell": "\n    @Override\n    public boolean isValid(int recordIndex) throws IOException {\n        return (getDataRecord(recordIndex).getInt(qualityDataIndex) & 0b11001100000000000000000000000000) == 0;\n    }\n\n    @Override", "refactored_code": "    private static final int QUALITY_INDICATOR_BIT_MASK = 0b11001100000000000000000000000000;\n\n    @Override\n    public boolean isValid(int recordIndex) throws IOException {\n        return (getDataRecord(recordIndex).getInt(qualityDataIndex) & QUALITY_INDICATOR_BIT_MASK) == 0;\n    }\n\n    @Override"}
{"magic_number_smell": "\n        final float[] targetData = (float[]) targetBuffer.getElems();\n        final int[] videoData = new int[WORDS_PER_SCAN];\n        final int[] countData = new int[2048];\n\n        int targetIdx = targetStart;\n        pm.beginTask(\"Reading AVHRR band '\" + getBandName() + \"'...\", maxY - minY);", "refactored_code": "    private static final int POINTS_PER_SCAN = 2048;\n\n        final float[] targetData = (float[]) targetBuffer.getElems();\n        final int[] videoData = new int[WORDS_PER_SCAN];\n        final int[] countData = new int[POINTS_PER_SCAN];\n\n        int targetIdx = targetStart;\n        pm.beginTask(\"Reading AVHRR band '\" + getBandName() + \"'...\", maxY - minY);"}
{"magic_number_smell": "            y = imageH - 1;\n        }\n\n        final int minX = max(x - 128, 0);\n        final int minY = max(y - 128, 0);\n        final int maxX = min(x + 128, imageW - 1);\n        final int maxY = min(y + 128, imageH - 1);", "refactored_code": "    private static final int R = 128;\n            y = imageH - 1;\n        }\n\n        final int minX = max(x - R, 0);\n        final int minY = max(y - R, 0);\n        final int maxX = min(x + R, imageW - 1);\n        final int maxY = min(y + R, imageH - 1);"}
{"magic_number_smell": "        int subsamplingXOffset = sourceOffsetX % sourceStepX;\n        int subsamplingYOffset = sourceOffsetY % sourceStepY;\n        readParam.setSourceSubsampling(sourceStepX, sourceStepY, subsamplingXOffset, subsamplingYOffset);\n        RenderedImage subsampledImage = imageReader.readAsRenderedImage(0, readParam);\n\n        return subsampledImage.getData(new Rectangle(destOffsetX, destOffsetY, destWidth, destHeight));\n    }", "refactored_code": "    private static final int FIRST_IMAGE = 0;\n        int subsamplingXOffset = sourceOffsetX % sourceStepX;\n        int subsamplingYOffset = sourceOffsetY % sourceStepY;\n        readParam.setSourceSubsampling(sourceStepX, sourceStepY, subsamplingXOffset, subsamplingYOffset);\n        RenderedImage subsampledImage = imageReader.readAsRenderedImage(FIRST_IMAGE, readParam);\n\n        return subsampledImage.getData(new Rectangle(destOffsetX, destOffsetY, destWidth, destHeight));\n    }"}
{"magic_number_smell": "    }\n\n    private int[] getGeoKeyDirValues() {\n        if (!containsField(34735)) {\n            throw new IllegalStateException(\"no GEO_KEY_DIRECTORY\");\n        }\n        final TIFFField field = getField(34735);", "refactored_code": "    private static final int TAG_GEO_KEY_DIRECTORY___SPOT = 34735;\n    }\n\n    private int[] getGeoKeyDirValues() {\n        if (!containsField(TAG_GEO_KEY_DIRECTORY___SPOT)) {\n            throw new IllegalStateException(\"no GEO_KEY_DIRECTORY\");\n        }\n        final TIFFField field = getField(TAG_GEO_KEY_DIRECTORY___SPOT);"}
{"magic_number_smell": "    }\n\n    public long getSize() {\n        return 12 + getReferencedValuesSizeInBytes();\n    }\n\n    public boolean mustValuesBeReferenced() {", "refactored_code": "    public static final short BYTES_PER_ENTRY = 12;\n    }\n\n    public long getSize() {\n        return BYTES_PER_ENTRY + getReferencedValuesSizeInBytes();\n    }\n\n    public boolean mustValuesBeReferenced() {"}
{"magic_number_smell": "    private TiffShort[] createColorMap(Product product) {\n        final ImageInfo imageInfo = product.getBandAt(0).getImageInfo(null, ProgressMonitor.NULL);\n        final ColorPaletteDef paletteDef = imageInfo.getColorPaletteDef();\n        final TiffShort[] redColor = new TiffShort[256];\n        Arrays.fill(redColor, new TiffShort(0));\n        final TiffShort[] greenColor = new TiffShort[256];\n        Arrays.fill(greenColor, new TiffShort(0));", "refactored_code": "    private static final int TIFF_COLORMAP_SIZE = 256;\n    private TiffShort[] createColorMap(Product product) {\n        final ImageInfo imageInfo = product.getBandAt(0).getImageInfo(null, ProgressMonitor.NULL);\n        final ColorPaletteDef paletteDef = imageInfo.getColorPaletteDef();\n        final TiffShort[] redColor = new TiffShort[TIFF_COLORMAP_SIZE];\n        Arrays.fill(redColor, new TiffShort(0));\n        final TiffShort[] greenColor = new TiffShort[TIFF_COLORMAP_SIZE];\n        Arrays.fill(greenColor, new TiffShort(0));"}
{"magic_number_smell": "        TiffValueRangeChecker.checkValueTiffRational(numerator, \"numerator\");\n        TiffValueRangeChecker.checkValueTiffRational(denominator, \"denominator\");\n        setData(ProductData.createInstance(ProductData.TYPE_UINT32, 2));\n        getData().setElemUIntAt(0, numerator);\n        getData().setElemUIntAt(DENOMINATOR_INDEX, denominator);\n    }\n", "refactored_code": "    private static final int NUMERATOR_INDEX = 0;\n        TiffValueRangeChecker.checkValueTiffRational(numerator, \"numerator\");\n        TiffValueRangeChecker.checkValueTiffRational(denominator, \"denominator\");\n        setData(ProductData.createInstance(ProductData.TYPE_UINT32, 2));\n        getData().setElemUIntAt(NUMERATOR_INDEX, numerator);\n        getData().setElemUIntAt(DENOMINATOR_INDEX, denominator);\n    }\n"}
{"magic_number_smell": "     * 8-bit unsigned integer,\n     */\n    public static final byte 1 = 1;\n    public static final TiffShort BYTE = new TiffShort(1);\n\n    /**\n     * a byte sequence that contains a 7-bit ASCII code;", "refactored_code": "    public static final byte BYTE_TYPE = 1;\n     * 8-bit unsigned integer,\n     */\n    public static final byte BYTE_TYPE = 1;\n    public static final TiffShort BYTE = new TiffShort(BYTE_TYPE);\n\n    /**\n     * a byte sequence that contains a 7-bit ASCII code;"}
{"magic_number_smell": "    private static final int UNSIGNED_SHORT_MAX = 0xffff;\n\n    public static void checkValueTiffRational(final long value, final String name) {\n        checkValue(value, name, 1, 0xffffffffL);\n    }\n\n    public static void checkValueTiffLong(final long value, final String name) {", "refactored_code": "    private static final long UNSIGNED_INT_MAX = 0xffffffffL;\n    private static final int UNSIGNED_SHORT_MAX = 0xffff;\n\n    public static void checkValueTiffRational(final long value, final String name) {\n        checkValue(value, name, 1, UNSIGNED_INT_MAX);\n    }\n\n    public static void checkValueTiffLong(final long value, final String name) {"}
{"magic_number_smell": "\n        final double h = 24.0 * (time - startTime);\n\n        if (h - 1.0 / (60.0 * 60.0 * 1000) < 0) {\n            // pixel is attached to data-periods (p-n)\n            return Membership.PREVIOUS_PERIODS;\n        } else if (h + 1.0 / (60.0 * 60.0 * 1000) > 24.0 * duration) {", "refactored_code": "    private static final double EPS = 1.0 / (60.0 * 60.0 * 1000); // 1 ms\n\n        final double h = 24.0 * (time - startTime);\n\n        if (h - EPS < 0) {\n            // pixel is attached to data-periods (p-n)\n            return Membership.PREVIOUS_PERIODS;\n        } else if (h + EPS > 24.0 * duration) {"}
{"magic_number_smell": "                                      binManager,\n                                      compositingType,\n                                      getSuperSampling() != null ? getSuperSampling() : SUPER_SAMPLING_DEFAULT,\n                                      getMaxDistanceOnEarth() != null ? getMaxDistanceOnEarth() : -1,\n                                      dataPeriod,\n                                      region);\n    }", "refactored_code": "    private static final int MAX_EARTH_DISTANCE_DEFAULT = -1;\n                                      binManager,\n                                      compositingType,\n                                      getSuperSampling() != null ? getSuperSampling() : SUPER_SAMPLING_DEFAULT,\n                                      getMaxDistanceOnEarth() != null ? getMaxDistanceOnEarth() : MAX_EARTH_DISTANCE_DEFAULT,\n                                      dataPeriod,\n                                      region);\n    }"}
{"magic_number_smell": "    }\n\n    private static int getNumBinsPerFile(long maxBinCount) {\n        int numCacheFiles = (int) Math.ceil(maxBinCount / (float) 100000);\n        numCacheFiles = Math.min(numCacheFiles, MAX_NUMBER_OF_CACHE_FILES);\n        int binsPerFile = (int) Math.ceil(maxBinCount / (float) numCacheFiles);\n        return Math.max(100000, binsPerFile);", "refactored_code": "    private static final int DEFAULT_NUM_BINS_PER_FILE = 100000;\n    }\n\n    private static int getNumBinsPerFile(long maxBinCount) {\n        int numCacheFiles = (int) Math.ceil(maxBinCount / (float) DEFAULT_NUM_BINS_PER_FILE);\n        numCacheFiles = Math.min(numCacheFiles, MAX_NUMBER_OF_CACHE_FILES);\n        int binsPerFile = (int) Math.ceil(maxBinCount / (float) numCacheFiles);\n        return Math.max(DEFAULT_NUM_BINS_PER_FILE, binsPerFile);"}
{"magic_number_smell": "    private boolean firstGet;\n\n    public TemporalBinList(int numberOfBins) throws IOException {\n        this(numberOfBins, 10000, DEFAULT_BINS_PER_FILE);\n    }\n\n    TemporalBinList(int numberOfBins, int maxNumberOfCacheFiles, int preferredBinsPerFile) throws IOException {", "refactored_code": "    public static final int DEFAULT_MAX_CACHE_FILES = 10000;\n    private boolean firstGet;\n\n    public TemporalBinList(int numberOfBins) throws IOException {\n        this(numberOfBins, DEFAULT_MAX_CACHE_FILES, DEFAULT_BINS_PER_FILE);\n    }\n\n    TemporalBinList(int numberOfBins, int maxNumberOfCacheFiles, int preferredBinsPerFile) throws IOException {"}
{"magic_number_smell": "    }\n\n    static String toPixelSizeString(int numRows) {\n        return Double.toString((6378.145 * Math.PI) / (numRows - 1));\n    }\n\n    private void extractSpiMetadata(OperatorSpi spi) {", "refactored_code": "    private static final double RE = 6378.145;\n    }\n\n    static String toPixelSizeString(int numRows) {\n        return Double.toString((RE * Math.PI) / (numRows - 1));\n    }\n\n    private void extractSpiMetadata(OperatorSpi spi) {"}
{"magic_number_smell": "    public SeadasGrid(PlanetaryGrid baseGrid) {\n\n        if (!isCompatibleBaseGrid(baseGrid)) {\n            throw new IllegalArgumentException(\"Base grid has more than \" + Integer.MAX_VALUE - 1 + \" bins\");\n        }\n\n        this.baseGrid = baseGrid;", "refactored_code": "    public static final int MAX_NUM_BINS = Integer.MAX_VALUE - 1;\n    public SeadasGrid(PlanetaryGrid baseGrid) {\n\n        if (!isCompatibleBaseGrid(baseGrid)) {\n            throw new IllegalArgumentException(\"Base grid has more than \" + MAX_NUM_BINS + \" bins\");\n        }\n\n        this.baseGrid = baseGrid;"}
{"magic_number_smell": "    private final long numBins;\n\n    public SEAGrid() {\n        this(2160);\n    }\n\n    public SEAGrid(int numRows) {", "refactored_code": "    public static final int DEFAULT_NUM_ROWS = 2160;\n    private final long numBins;\n\n    public SEAGrid() {\n        this(DEFAULT_NUM_ROWS);\n    }\n\n    public SEAGrid(int numRows) {"}
{"magic_number_smell": "    public Membership getObservationMembership(double lon, double time) {\n\n        final double h = 24.0 * (time - startTime);\n        final double h0 = minDataHour + (lon + 180.0) * -24.0 / 360.0;\n\n        if (h - EPS < h0) {\n            // pixel is attached to data-periods (p-n)", "refactored_code": "    private static final double SLOPE = -24.0 / 360.0;\n    public Membership getObservationMembership(double lon, double time) {\n\n        final double h = 24.0 * (time - startTime);\n        final double h0 = minDataHour + (lon + 180.0) * SLOPE;\n\n        if (h - EPS < h0) {\n            // pixel is attached to data-periods (p-n)"}
{"magic_number_smell": "    }\n\n    private SpatialBin createSpatialBin(int binIndex) {\n        SpatialBin bin = new SpatialBin(binIndex, 2);\n        for (int i = 0; i < 2; i++) {\n            bin.getFeatureValues()[i] = (float) Math.random();\n        }", "refactored_code": "    private static final int NUM_FEATURES = 2;\n    }\n\n    private SpatialBin createSpatialBin(int binIndex) {\n        SpatialBin bin = new SpatialBin(binIndex, NUM_FEATURES);\n        for (int i = 0; i < NUM_FEATURES; i++) {\n            bin.getFeatureValues()[i] = (float) Math.random();\n        }"}
{"magic_number_smell": "                // for first pixel in previous period: create a product that starts at latest at T0 + 10 * H\n                double productStartTime = T0 - 12 * H;\n                product.setStartTime(new ProductData.UTC(productStartTime));\n                Assert.assertEquals(DataPeriod.Membership.PREVIOUS_PERIODS, dataPeriod.getObservationMembership(10.0F, productStartTime));\n                break;\n            }\n            case CURRENT_PERIOD: {", "refactored_code": "    public static final float EASTERN_LON = 10.0F;\n                // for first pixel in previous period: create a product that starts at latest at T0 + 10 * H\n                double productStartTime = T0 - 12 * H;\n                product.setStartTime(new ProductData.UTC(productStartTime));\n                Assert.assertEquals(DataPeriod.Membership.PREVIOUS_PERIODS, dataPeriod.getObservationMembership(EASTERN_LON, productStartTime));\n                break;\n            }\n            case CURRENT_PERIOD: {"}
{"magic_number_smell": "                                       int targetWidth,\n                                       int targetHeight,\n                                       ProgressMonitor pm) throws IOException {\n        final int minBandIndex = max(bandIndex - 1, 0);\n        final int maxBandIndex = min(bandIndex + 1, spectralBandCount - 1);\n        final int bandCount = maxBandIndex - minBandIndex + 1;\n", "refactored_code": "    private static final int NEIGHBORING_BAND_COUNT = 1;\n                                       int targetWidth,\n                                       int targetHeight,\n                                       ProgressMonitor pm) throws IOException {\n        final int minBandIndex = max(bandIndex - NEIGHBORING_BAND_COUNT, 0);\n        final int maxBandIndex = min(bandIndex + NEIGHBORING_BAND_COUNT, spectralBandCount - 1);\n        final int bandCount = maxBandIndex - minBandIndex + 1;\n"}
{"magic_number_smell": "                        if (y < sourceRectangle.y || y >= sourceRectangle.y + sourceRectangle.height) {\n                            continue;\n                        }\n                        for (int j = 0, x = tx - 1; j < 3; ++j, ++x) {\n                            if (x < sourceRectangle.x || x >= sourceRectangle.x + sourceRectangle.width) {\n                                continue;\n                            }", "refactored_code": "    private static final int M_WIDTH = 3;\n                        if (y < sourceRectangle.y || y >= sourceRectangle.y + sourceRectangle.height) {\n                            continue;\n                        }\n                        for (int j = 0, x = tx - 1; j < M_WIDTH; ++j, ++x) {\n                            if (x < sourceRectangle.x || x >= sourceRectangle.x + sourceRectangle.width) {\n                                continue;\n                            }"}
{"magic_number_smell": "\n        clusterMapBand = new Band(\"class_indices\", ProductData.TYPE_UINT8, width, height);\n        clusterMapBand.setDescription(\"Class_indices\");\n        clusterMapBand.setNoDataValue(0xFF);\n        clusterMapBand.setNoDataValueUsed(true);\n        targetProduct.addBand(clusterMapBand);\n", "refactored_code": "    private static final int NO_DATA_VALUE = 0xFF;\n\n        clusterMapBand = new Band(\"class_indices\", ProductData.TYPE_UINT8, width, height);\n        clusterMapBand.setDescription(\"Class_indices\");\n        clusterMapBand.setNoDataValue(NO_DATA_VALUE);\n        clusterMapBand.setNoDataValueUsed(true);\n        targetProduct.addBand(clusterMapBand);\n"}
{"magic_number_smell": "\n        clusterMapBand = new Band(\"class_indices\", ProductData.TYPE_UINT8, width, height);\n        clusterMapBand.setDescription(\"Class_indices\");\n        clusterMapBand.setNoDataValue(0xFF);\n        clusterMapBand.setNoDataValueUsed(true);\n        targetProduct.addBand(clusterMapBand);\n", "refactored_code": "    private static final int NO_DATA_VALUE = 0xFF;\n\n        clusterMapBand = new Band(\"class_indices\", ProductData.TYPE_UINT8, width, height);\n        clusterMapBand.setDescription(\"Class_indices\");\n        clusterMapBand.setNoDataValue(NO_DATA_VALUE);\n        clusterMapBand.setNoDataValueUsed(true);\n        targetProduct.addBand(clusterMapBand);\n"}
{"magic_number_smell": "\n    public void testFindClusters() {\n        final double[][] points = createRandomPoints(new double[]{\n                1.0, B, 1.0, B, 1.0, B, 1.0, B,\n                B, 1.0, B, 1.0, B, 1.0, B, 1.0,\n                1.0, B, 1.0, B, 1.0, B, 1.0, B,\n                B, 1.0, B, 1.0, B, 1.0, B, 1.0,", "refactored_code": "    private static final double A = 1.0;\n\n    public void testFindClusters() {\n        final double[][] points = createRandomPoints(new double[]{\n                A, B, A, B, A, B, A, B,\n                B, A, B, A, B, A, B, A,\n                A, B, A, B, A, B, A, B,\n                B, A, B, A, B, A, B, A,"}
{"magic_number_smell": "            public boolean evalB(EvalEnv env, Term[] args) throws EvalException {\n                final double x1 = args[0].evalD(env);\n                final double x2 = args[1].evalD(env);\n                return ExtMath.feq(x1, x2, 1e-6);\n            }\n        });\n", "refactored_code": "    private static final double EPS = 1e-6;\n            public boolean evalB(EvalEnv env, Term[] args) throws EvalException {\n                final double x1 = args[0].evalD(env);\n                final double x2 = args[1].evalD(env);\n                return ExtMath.feq(x1, x2, EPS);\n            }\n        });\n"}
{"magic_number_smell": "        eatWhite();\n\n        if (isEos()) {\n            type = -1;\n        } else if (isNameStart()) {\n            eatName();\n        } else if (isEscapedNameStart()) {", "refactored_code": "    public static final int TT_EOS = -1;\n        eatWhite();\n\n        if (isEos()) {\n            type = TT_EOS;\n        } else if (isNameStart()) {\n            eatName();\n        } else if (isEscapedNameStart()) {"}
{"magic_number_smell": "        int enviType;\n        switch (dataType) {\n            case ProductData.TYPE_INT8:\n                enviType = 1;\n                break;\n\n            case ProductData.TYPE_UINT8:", "refactored_code": "    private static final int _enviTypeByte = 1;\n        int enviType;\n        switch (dataType) {\n            case ProductData.TYPE_INT8:\n                enviType = _enviTypeByte;\n                break;\n\n            case ProductData.TYPE_UINT8:"}
{"magic_number_smell": "                    biggestIndex = biggestIndex > lonIndex ? biggestIndex : lonIndex;\n                    biggestIndex = biggestIndex > latIndex ? biggestIndex : latIndex;\n                    stdColIndexes = new ArrayList<>(6);\n                    stdColIndexes.add(0, nameIndex);\n                    stdColIndexes.add(INDEX_FOR_LON, lonIndex);\n                    stdColIndexes.add(INDEX_FOR_LAT, latIndex);\n                    stdColIndexes.add(INDEX_FOR_DESC, descIndex);", "refactored_code": "    private static final int INDEX_FOR_NAME = 0;\n                    biggestIndex = biggestIndex > lonIndex ? biggestIndex : lonIndex;\n                    biggestIndex = biggestIndex > latIndex ? biggestIndex : latIndex;\n                    stdColIndexes = new ArrayList<>(6);\n                    stdColIndexes.add(INDEX_FOR_NAME, nameIndex);\n                    stdColIndexes.add(INDEX_FOR_LON, lonIndex);\n                    stdColIndexes.add(INDEX_FOR_LAT, latIndex);\n                    stdColIndexes.add(INDEX_FOR_DESC, descIndex);"}
{"magic_number_smell": "\n    public ProductFlipper(int flipType, boolean sourceProductOwner) {\n        super(sourceProductOwner);\n        if ((flipType != 1) && (flipType != FLIP_VERTICAL) && (flipType != FLIP_BOTH)) {\n            throw new IllegalArgumentException(\"invalid flip type\");\n        }\n        this.flipType = flipType;", "refactored_code": "    public static final int FLIP_HORIZONTAL = 1;\n\n    public ProductFlipper(int flipType, boolean sourceProductOwner) {\n        super(sourceProductOwner);\n        if ((flipType != FLIP_HORIZONTAL) && (flipType != FLIP_VERTICAL) && (flipType != FLIP_BOTH)) {\n            throw new IllegalArgumentException(\"invalid flip type\");\n        }\n        this.flipType = flipType;"}
{"magic_number_smell": "    public boolean equals(Object obj) {\n        if (obj instanceof AngularDirection) {\n            AngularDirection other = (AngularDirection) obj;\n            return Math.abs(other.azimuth - azimuth) < 1.0e-10 &&\n                   Math.abs(other.zenith - zenith) < 1.0e-10;\n        }\n        return false;", "refactored_code": "    private static final double EPS = 1.0e-10;\n    public boolean equals(Object obj) {\n        if (obj instanceof AngularDirection) {\n            AngularDirection other = (AngularDirection) obj;\n            return Math.abs(other.azimuth - azimuth) < EPS &&\n                   Math.abs(other.zenith - zenith) < EPS;\n        }\n        return false;"}
{"magic_number_smell": "     * @param pixelPos the pixel position.\n     */\n    void findPixelPos(GeoPos geoPos, PixelPos pixelPos) {\n        final int searchRadius = 2 * 30;\n\n        int x0 = (int) Math.floor(pixelPos.x);\n        int y0 = (int) Math.floor(pixelPos.y);", "refactored_code": "    private static final int MAX_SEARCH_CYCLE_COUNT = 30; // enough for MERIS FSG where we have duplicated pixels\n     * @param pixelPos the pixel position.\n     */\n    void findPixelPos(GeoPos geoPos, PixelPos pixelPos) {\n        final int searchRadius = 2 * MAX_SEARCH_CYCLE_COUNT;\n\n        int x0 = (int) Math.floor(pixelPos.x);\n        int y0 = (int) Math.floor(pixelPos.y);"}
{"magic_number_smell": "     * @return a new approximation or {@code null} if the accuracy goal cannot not be met.\n     */\n    static GeoApproximation create(double[][] data, double accuracy, Rectangle range) {\n        final Point2D centerPoint = Rotator.calculateCenter(data, LON, 0);\n        final double centerLon = centerPoint.getX();\n        final double centerLat = centerPoint.getY();\n        // the equation below is correct, if and only if, the cosine distance is used for calculating distances", "refactored_code": "    private static final int LAT = 0;\n     * @return a new approximation or {@code null} if the accuracy goal cannot not be met.\n     */\n    static GeoApproximation create(double[][] data, double accuracy, Rectangle range) {\n        final Point2D centerPoint = Rotator.calculateCenter(data, LON, LAT);\n        final double centerLon = centerPoint.getX();\n        final double centerLat = centerPoint.getY();\n        // the equation below is correct, if and only if, the cosine distance is used for calculating distances"}
{"magic_number_smell": "\n    @Override\n    public int getSourceDimensions() {\n        return 2;\n    }\n\n    @Override", "refactored_code": "    private static final int DIMS = 2;\n\n    @Override\n    public int getSourceDimensions() {\n        return DIMS;\n    }\n\n    @Override"}
{"magic_number_smell": "public class GeoPos {\n\n    private static final float 60.0F = 60.0F;\n    private static final float _SEC_PER_DEG = 60.0F * 60.0F;\n\n    /**\n     * The geographical latitude in decimal degree, valid range is -90 to +90.", "refactored_code": "    private static final float _MIN_PER_DEG = 60.0F;\npublic class GeoPos {\n\n    private static final float _MIN_PER_DEG = 60.0F;\n    private static final float _SEC_PER_DEG = _MIN_PER_DEG * 60.0F;\n\n    /**\n     * The geographical latitude in decimal degree, valid range is -90 to +90."}
{"magic_number_smell": "        this.raster = raster;\n        usingHeader = true;\n        headerText = \"\";\n        orientation = 0;\n        font = _DEFAULT_FONT;\n        antialiasing = false;\n        backgroundColor = Color.white;", "refactored_code": "    public static final int HORIZONTAL = 0;\n        this.raster = raster;\n        usingHeader = true;\n        headerText = \"\";\n        orientation = HORIZONTAL;\n        font = _DEFAULT_FONT;\n        antialiasing = false;\n        backgroundColor = Color.white;"}
{"magic_number_smell": "            colorType.setDefaultValue(DEFAULT_COLOR);\n\n            PropertyDescriptor transparencyType = new PropertyDescriptor(PROPERTY_NAME_TRANSPARENCY, Double.TYPE);\n            transparencyType.setDefaultValue(0.5);\n\n            PropertyContainer imageConfig = new PropertyContainer();\n            imageConfig.addProperty(new Property(colorType, new DefaultPropertyAccessor()));", "refactored_code": "        public static final double DEFAULT_TRANSPARENCY = 0.5;\n            colorType.setDefaultValue(DEFAULT_COLOR);\n\n            PropertyDescriptor transparencyType = new PropertyDescriptor(PROPERTY_NAME_TRANSPARENCY, Double.TYPE);\n            transparencyType.setDefaultValue(DEFAULT_TRANSPARENCY);\n\n            PropertyContainer imageConfig = new PropertyContainer();\n            imageConfig.addProperty(new Property(colorType, new DefaultPropertyAccessor()));"}
{"magic_number_smell": "                y1 = (int) Math.floor(pixelPos.y);\n                minDelta = findBestPixel(x1, y1, lat0, lon0, pixelPos);\n            }\n            while (++cycles < 10 && (x1 != (int) pixelPos.x || y1 != (int) pixelPos.y) && bestPixelIsOnSearchBorder(\n                    x1, y1, pixelPos));\n            if (Math.sqrt(minDelta) < deltaThreshold) {\n                pixelPos.setLocation(pixelPos.x + 0.5f, pixelPos.y + 0.5f);", "refactored_code": "    private static final int MAX_SEARCH_CYCLES = 10;\n                y1 = (int) Math.floor(pixelPos.y);\n                minDelta = findBestPixel(x1, y1, lat0, lon0, pixelPos);\n            }\n            while (++cycles < MAX_SEARCH_CYCLES && (x1 != (int) pixelPos.x || y1 != (int) pixelPos.y) && bestPixelIsOnSearchBorder(\n                    x1, y1, pixelPos));\n            if (Math.sqrt(minDelta) < deltaThreshold) {\n                pixelPos.setLocation(pixelPos.x + 0.5f, pixelPos.y + 0.5f);"}
{"magic_number_smell": "        } else if (TYPESTRING_UTC.equals(type)) {\n            return TYPE_UTC;\n        }\n        return 0;\n    }\n\n//    /**", "refactored_code": "    public static final int TYPE_UNDEFINED = 0;\n        } else if (TYPESTRING_UTC.equals(type)) {\n            return TYPE_UTC;\n        }\n        return TYPE_UNDEFINED;\n    }\n\n//    /**"}
{"magic_number_smell": "                    product.setRefNo(getNextRefNo() + 1);\n                }\n                product.addProductNodeListener(productNodeNameChangeListener);\n                fireEvent(product, 1);\n            }\n        }\n    }", "refactored_code": "    private static final int PRODUCT_ADDED = 1;\n                    product.setRefNo(getNextRefNo() + 1);\n                }\n                product.addProductNodeListener(productNodeNameChangeListener);\n                fireEvent(product, PRODUCT_ADDED);\n            }\n        }\n    }"}
{"magic_number_smell": "\n    private int getReadBufferLineCount() {\n        final int sizePerLine = getRasterWidth() * ProductData.getElemSize(getDataType());\n        int bufferLineCount = 8 * 1024 * 1024 / sizePerLine;\n        if (bufferLineCount == 0) {\n            bufferLineCount = 1;\n        }", "refactored_code": "    private static final int READ_BUFFER_MAX_SIZE = 8 * 1024 * 1024; // 8 MB\n\n    private int getReadBufferLineCount() {\n        final int sizePerLine = getRasterWidth() * ProductData.getElemSize(getDataType());\n        int bufferLineCount = READ_BUFFER_MAX_SIZE / sizePerLine;\n        if (bufferLineCount == 0) {\n            bufferLineCount = 1;\n        }"}
{"magic_number_smell": "                }\n\n                if (mustComputeHistogramStx) {\n                    int binCount = histogramBinCount != null ? histogramBinCount : 512;\n                    final HistogramStxOp histogramOp = new HistogramStxOp(binCount, minimum, maximum, intHistogram, logHistogram);\n                    for (int i = 0; i < filteredRasters.length; i++) {\n                        final RasterDataNode rasterDataNode = filteredRasters[i];", "refactored_code": "    public static final int DEFAULT_BIN_COUNT = 512;\n                }\n\n                if (mustComputeHistogramStx) {\n                    int binCount = histogramBinCount != null ? histogramBinCount : DEFAULT_BIN_COUNT;\n                    final HistogramStxOp histogramOp = new HistogramStxOp(binCount, minimum, maximum, intHistogram, logHistogram);\n                    for (int i = 0; i < filteredRasters.length; i++) {\n                        final RasterDataNode rasterDataNode = filteredRasters[i];"}
{"magic_number_smell": "                        index = i;\n                        rmseMin = rmse;\n                    }\n                    if (maxError < 0.5) { // this accuracy is sufficient\n                        index = i;\n                        break;\n                    }", "refactored_code": "    private static final double ABS_ERROR_LIMIT = 0.5; // pixels\n                        index = i;\n                        rmseMin = rmse;\n                    }\n                    if (maxError < ABS_ERROR_LIMIT) { // this accuracy is sufficient\n                        index = i;\n                        break;\n                    }"}
{"magic_number_smell": "public class Orthorectifier implements GeoCoding {\n\n    public static final float 0.1f = 0.1f;\n    public static final float PIXEL_EPS_SQR = 0.1f * 0.1f;\n\n    private final int sceneRasterWidth;\n    private final int sceneRasterHeight;", "refactored_code": "    public static final float PIXEL_EPS = 0.1f;\npublic class Orthorectifier implements GeoCoding {\n\n    public static final float PIXEL_EPS = 0.1f;\n    public static final float PIXEL_EPS_SQR = PIXEL_EPS * PIXEL_EPS;\n\n    private final int sceneRasterWidth;\n    private final int sceneRasterHeight;"}
{"magic_number_smell": "public class Orthorectifier2 extends Orthorectifier {\n\n    public static final float 1.0f / (60.0f * 60.0f) = 1.0f / (60.0f * 60.0f);\n    public static final float DEGREE_EPS_SQR = 1.0f / (60.0f * 60.0f) * 1.0f / (60.0f * 60.0f);\n\n    public static final double RE = RsMathUtils.MEAN_EARTH_RADIUS;\n", "refactored_code": "    public static final float DEGREE_EPS = 1.0f / (60.0f * 60.0f);\npublic class Orthorectifier2 extends Orthorectifier {\n\n    public static final float DEGREE_EPS = 1.0f / (60.0f * 60.0f);\n    public static final float DEGREE_EPS_SQR = DEGREE_EPS * DEGREE_EPS;\n\n    public static final double RE = RsMathUtils.MEAN_EARTH_RADIUS;\n"}
{"magic_number_smell": "            _lam0 = Math.toRadians(lam0);\n\n\n            if (Math.abs(_phi1 + _phi2) < 1e-10) {\n                throw new IllegalArgumentException(\"Invalid parameter set.\");\n            }\n", "refactored_code": "        private static final double eps10 = 1e-10;\n            _lam0 = Math.toRadians(lam0);\n\n\n            if (Math.abs(_phi1 + _phi2) < eps10) {\n                throw new IllegalArgumentException(\"Invalid parameter set.\");\n            }\n"}
{"magic_number_smell": "    public static final String NAME = \"Integerized Sinusoidal Equal Area Grid\";\n    public static final String MAP_UNIT = \"units\";\n    public static final int 2160 = 2160;\n    private static final Parameter[] PARAMETERS = new Parameter[] {new Parameter(\"rowCount\", 2160)};\n    private static final double[] PARAMETER_DEFAULT_VALUES = new double[] {2160};\n\n    public void registerProjections() {", "refactored_code": "    public static final int DEFAULT_ROW_COUNT_VALUE = 2160;\n    public static final String NAME = \"Integerized Sinusoidal Equal Area Grid\";\n    public static final String MAP_UNIT = \"units\";\n    public static final int DEFAULT_ROW_COUNT_VALUE = 2160;\n    private static final Parameter[] PARAMETERS = new Parameter[] {new Parameter(\"rowCount\", DEFAULT_ROW_COUNT_VALUE)};\n    private static final double[] PARAMETER_DEFAULT_VALUES = new double[] {DEFAULT_ROW_COUNT_VALUE};\n\n    public void registerProjections() {"}
{"magic_number_smell": "            double phi0 = MathUtils.DTOR * _parameterValues[LambertConformalConicDescriptor.LATITUDE_OF_ORIGIN_INDEX];\n            double phi1 = MathUtils.DTOR * _parameterValues[LambertConformalConicDescriptor.LATITUDE_OF_INTERSECTION_1_INDEX];\n            double phi2 = MathUtils.DTOR * _parameterValues[LambertConformalConicDescriptor.LATITUDE_OF_INTERSECTION_2_INDEX];\n            if (Math.abs(phi1 + phi2) < 1e-10) {\n                throw new IllegalArgumentException(\"Invalid parameter set.\");\n            }\n", "refactored_code": "        private static final double _epsilon = 1e-10;\n            double phi0 = MathUtils.DTOR * _parameterValues[LambertConformalConicDescriptor.LATITUDE_OF_ORIGIN_INDEX];\n            double phi1 = MathUtils.DTOR * _parameterValues[LambertConformalConicDescriptor.LATITUDE_OF_INTERSECTION_1_INDEX];\n            double phi2 = MathUtils.DTOR * _parameterValues[LambertConformalConicDescriptor.LATITUDE_OF_INTERSECTION_2_INDEX];\n            if (Math.abs(phi1 + phi2) < _epsilon) {\n                throw new IllegalArgumentException(\"Invalid parameter set.\");\n            }\n"}
{"magic_number_smell": "        _pixelSizeY = pixelSizeY;\n        _datum = datum;\n        _sceneSizeFitted = false;\n        _noDataValue = 9999;\n        _elevationModelName = null;\n        _resampling = Resampling.NEAREST_NEIGHBOUR;\n        alterMapTransform();", "refactored_code": "    public static final double DEFAULT_NO_DATA_VALUE = 9999;\n        _pixelSizeY = pixelSizeY;\n        _datum = datum;\n        _sceneSizeFitted = false;\n        _noDataValue = DEFAULT_NO_DATA_VALUE;\n        _elevationModelName = null;\n        _resampling = Resampling.NEAREST_NEIGHBOUR;\n        alterMapTransform();"}
{"magic_number_smell": "            super(parameterValues[CENTRAL_MERIDIAN_INDEX],\n                  parameterValues[FALSE_EASTING_INDEX],\n                  parameterValues[FALSE_NORTHING_INDEX],\n                  parameterValues[0]);\n\n            final double b = parameterValues[SEMI_MINOR_INDEX];\n", "refactored_code": "    private static final int SEMI_MAJOR_INDEX = 0;\n            super(parameterValues[CENTRAL_MERIDIAN_INDEX],\n                  parameterValues[FALSE_EASTING_INDEX],\n                  parameterValues[FALSE_NORTHING_INDEX],\n                  parameterValues[SEMI_MAJOR_INDEX]);\n\n            final double b = parameterValues[SEMI_MINOR_INDEX];\n"}
{"magic_number_smell": "            super(parameterValues[CENTRAL_MERIDIAN_INDEX], // lam0\n                  parameterValues[FALSE_EASING_INDEX], // x0\n                  parameterValues[FALSE_NORTHING_INDEX], // y0\n                  parameterValues[0]);  // a\n            double a = parameterValues[0]; // a\n            double b = parameterValues[SEMI_MINOR_INDEX]; // b\n            _k0 = parameterValues[SCALE_FACTOR_INDEX]; // k0", "refactored_code": "    private static final int SEMI_MAJOR_INDEX = 0;\n            super(parameterValues[CENTRAL_MERIDIAN_INDEX], // lam0\n                  parameterValues[FALSE_EASING_INDEX], // x0\n                  parameterValues[FALSE_NORTHING_INDEX], // y0\n                  parameterValues[SEMI_MAJOR_INDEX]);  // a\n            double a = parameterValues[SEMI_MAJOR_INDEX]; // a\n            double b = parameterValues[SEMI_MINOR_INDEX]; // b\n            _k0 = parameterValues[SCALE_FACTOR_INDEX]; // k0"}
{"magic_number_smell": "\n        double k = cp * Math.sin(y);\n        int i;\n        for (i = 10; i != 0; i--) {\n            double v = (y + Math.sin(y) - k) / (1.0 + Math.cos(y));\n            y -= v;\n            if (Math.abs(v) < TOLERANCE) {", "refactored_code": "    private static final int MAX_ITER = 10;\n\n        double k = cp * Math.sin(y);\n        int i;\n        for (i = MAX_ITER; i != 0; i--) {\n            double v = (y + Math.sin(y) - k) / (1.0 + Math.cos(y));\n            y -= v;\n            if (Math.abs(v) < TOLERANCE) {"}
{"magic_number_smell": "            lon = +PI;\n        }\n        double lat = y;\n        if (lat < -PI/2) {\n            lon = 0;\n            lat = -PI/2;\n        }", "refactored_code": "    private static final double HALF_PI = PI/2;\n            lon = +PI;\n        }\n        double lat = y;\n        if (lat < -HALF_PI) {\n            lon = 0;\n            lat = -HALF_PI;\n        }"}
{"magic_number_smell": "\n    public static double hanning(final double x) {\n        return (x >= -halfFilterLength && x <= halfFilterLength) ?\n                0.5 * (1.0 + FastMath.cos(2.0 * Math.PI * x / (filterLength + 1))) : 0.0;\n    }\n\n    @Override", "refactored_code": "    private static final double DoublePI = 2.0 * Math.PI;\n\n    public static double hanning(final double x) {\n        return (x >= -halfFilterLength && x <= halfFilterLength) ?\n                0.5 * (1.0 + FastMath.cos(DoublePI * x / (filterLength + 1))) : 0.0;\n    }\n\n    @Override"}
{"magic_number_smell": "        resAutoModel.getDescriptor().setAlias(ALIAS_NAME_RES_AUTO);\n        vc.addProperty(resAutoModel);\n\n        final Property resPixelsModel = Property.create(PROPERTY_NAME_RES_PIXELS, Integer.class, 128, true);\n        resPixelsModel.getDescriptor().setAlias(ALIAS_NAME_RES_PIXELS);\n        vc.addProperty(resPixelsModel);\n", "refactored_code": "    public static final int DEFAULT_RES_PIXELS = 128;\n        resAutoModel.getDescriptor().setAlias(ALIAS_NAME_RES_AUTO);\n        vc.addProperty(resAutoModel);\n\n        final Property resPixelsModel = Property.create(PROPERTY_NAME_RES_PIXELS, Integer.class, DEFAULT_RES_PIXELS, true);\n        resPixelsModel.getDescriptor().setAlias(ALIAS_NAME_RES_PIXELS);\n        vc.addProperty(resPixelsModel);\n"}
{"magic_number_smell": "            for (int i = 0, k = w * y; i < pixelCount; i += colCount, k += w) {\n                for (int j = 0, l = x; j < colCount; j++, l++) {\n                    env.setElemIndex(i + j);\n                    productData.setElemUIntAt(k + l, term.evalB(env) ? 255 : FALSE);\n                }\n            }\n        } else {", "refactored_code": "    private static final int TRUE = 255;\n            for (int i = 0, k = w * y; i < pixelCount; i += colCount, k += w) {\n                for (int j = 0, l = x; j < colCount; j++, l++) {\n                    env.setElemIndex(i + j);\n                    productData.setElemUIntAt(k + l, term.evalB(env) ? TRUE : FALSE);\n                }\n            }\n        } else {"}
{"magic_number_smell": "     * function used during the training of the NN.\n     */\n    private void makeAlphaTab() {\n        double delta = (-2.0 * -10.0) / (NUM_ALPHA - 1.0);\n        double sum = -10.0 + (0.5 * delta);\n        for (int i = 0; i < NUM_ALPHA; i++) {\n            this.alphaTab[i] = 1.0 / (1.0 + Math.exp(-sum));", "refactored_code": "    private static final double ALPHA_START = -10.0;\n     * function used during the training of the NN.\n     */\n    private void makeAlphaTab() {\n        double delta = (-2.0 * ALPHA_START) / (NUM_ALPHA - 1.0);\n        double sum = ALPHA_START + (0.5 * delta);\n        for (int i = 0; i < NUM_ALPHA; i++) {\n            this.alphaTab[i] = 1.0 / (1.0 + Math.exp(-sum));"}
{"magic_number_smell": "     * @return the UTC date/time\n     */\n    public static Date jdToUTC(double jd) {\n        long millis = Math.round((jd - 2440587.5) * MILLIS_PER_DAY);\n        return new Date(millis);\n    }\n", "refactored_code": "    public static final double JD_OFFSET = 2440587.5;\n     * @return the UTC date/time\n     */\n    public static Date jdToUTC(double jd) {\n        long millis = Math.round((jd - JD_OFFSET) * MILLIS_PER_DAY);\n        return new Date(millis);\n    }\n"}
{"magic_number_smell": "        table = new int[bufferSize];\n        this.tableOffset = tableOffset;\n        this.size = 0;\n        Arrays.fill(table, Integer.MIN_VALUE);\n    }\n\n    public int getSize() {", "refactored_code": "    public static final int NULL = Integer.MIN_VALUE;\n        table = new int[bufferSize];\n        this.tableOffset = tableOffset;\n        this.size = 0;\n        Arrays.fill(table, NULL);\n    }\n\n    public int getSize() {"}
{"magic_number_smell": "    public static int getLogLevel(String logLevelStr) {\n        int logLevel = LL_INFO;\n        if (LLS_DEBUG.equalsIgnoreCase(logLevelStr)) {\n            logLevel = 10;\n        } else if (LLS_INFO.equalsIgnoreCase(logLevelStr)) {\n            logLevel = LL_INFO;\n        } else if (LLS_ERROR.equalsIgnoreCase(logLevelStr)) {", "refactored_code": "    public static final int LL_DEBUG = 10;\n    public static int getLogLevel(String logLevelStr) {\n        int logLevel = LL_INFO;\n        if (LLS_DEBUG.equalsIgnoreCase(logLevelStr)) {\n            logLevel = LL_DEBUG;\n        } else if (LLS_INFO.equalsIgnoreCase(logLevelStr)) {\n            logLevel = LL_INFO;\n        } else if (LLS_ERROR.equalsIgnoreCase(logLevelStr)) {"}
{"magic_number_smell": "    public static final String IIO_IMAGE_FORMAT_NAME = \"TIFF\";\n\n    public GeoTIFFMetadata() {\n        this(1,\n                DEFAULT_KEY_REVISION_MAJOR,\n                DEFAULT_KEY_REVISION_MINOR);\n    }", "refactored_code": "    private static final int DEFAULT_GEOTIFF_VERSION = 1;\n    public static final String IIO_IMAGE_FORMAT_NAME = \"TIFF\";\n\n    public GeoTIFFMetadata() {\n        this(DEFAULT_GEOTIFF_VERSION,\n                DEFAULT_KEY_REVISION_MAJOR,\n                DEFAULT_KEY_REVISION_MINOR);\n    }"}
{"magic_number_smell": "    public static final int F_TILEINFO = 0x0002;\n    public static final int F_STATISTICS = 0x0004;\n    public static final int F_PROPERTIES = 0x0008;\n    public static final int F_ALL = 0x0001\n                                    | F_TILEINFO\n                                    | F_STATISTICS\n                                    | F_PROPERTIES;", "refactored_code": "    public static final int F_ATTRIBUTES = 0x0001;\n    public static final int F_TILEINFO = 0x0002;\n    public static final int F_STATISTICS = 0x0004;\n    public static final int F_PROPERTIES = 0x0008;\n    public static final int F_ALL = F_ATTRIBUTES\n                                    | F_TILEINFO\n                                    | F_STATISTICS\n                                    | F_PROPERTIES;"}
{"magic_number_smell": "     * @return the skipped value range, that include 95% of the sum of all bin values\n     */\n    public Range findRangeFor95Percent() {\n        return findRange(0.025F, RIGHT_AREA_SKIPPED_95);\n    }\n\n    /**", "refactored_code": "    public static final float LEFT_AREA_SKIPPED_95 = 0.025F;\n     * @return the skipped value range, that include 95% of the sum of all bin values\n     */\n    public Range findRangeFor95Percent() {\n        return findRange(LEFT_AREA_SKIPPED_95, RIGHT_AREA_SKIPPED_95);\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    public static boolean equalValues(final float x1,\n                                      final float x2) {\n        return Math.abs(x1 - x2) <= 1.0E-6F;\n    }\n\n    /**", "refactored_code": "    public static final float EPS_F = 1.0E-6F;\n     */\n    public static boolean equalValues(final float x1,\n                                      final float x2) {\n        return Math.abs(x1 - x2) <= EPS_F;\n    }\n\n    /**"}
{"magic_number_smell": "\n    /**\n     * A constant used for the barometric formula - normalize to input in hPa. It's value is <code>GRAVITY_ACC *\n     * 1.26895 * 1e-2</code>.\n     */\n    public static final double BAROMETRIC_CONST = GRAVITY_ACC * 1.26895 * 1e-2;\n", "refactored_code": "    public static final double SPEC_WEIGHT_AIR = 1.26895;\n\n    /**\n     * A constant used for the barometric formula - normalize to input in hPa. It's value is <code>GRAVITY_ACC *\n     * SPEC_WEIGHT_AIR * 1e-2</code>.\n     */\n    public static final double BAROMETRIC_CONST = GRAVITY_ACC * SPEC_WEIGHT_AIR * 1e-2;\n"}
{"magic_number_smell": "\n        _testFile = new File(outputDirectory, \"testData\");\n\n        final float[] floats = new float[_numLines * 4];\n        final Random random = new Random();\n        for (int i = 0; i < floats.length; i++) {\n            floats[i] = random.nextFloat();", "refactored_code": "    private final int _lineLength = 4;\n\n        _testFile = new File(outputDirectory, \"testData\");\n\n        final float[] floats = new float[_numLines * _lineLength];\n        final Random random = new Random();\n        for (int i = 0; i < floats.length; i++) {\n            floats[i] = random.nextFloat();"}
{"magic_number_smell": "    }\n\n    public void testCreateProduct_with_GcpGeoCoding() throws ParseException {\n        int geocodingType = 3;\n        StringWriter sw;\n        Product product = createProduct(geocodingType);\n        sw = new StringWriter();", "refactored_code": "    private static final int GCP_GEOCODING = 3;\n    }\n\n    public void testCreateProduct_with_GcpGeoCoding() throws ParseException {\n        int geocodingType = GCP_GEOCODING;\n        StringWriter sw;\n        Product product = createProduct(geocodingType);\n        sw = new StringWriter();"}
{"magic_number_smell": "    private static final String _ellipsoidName = \"EllipsoidName\";\n    private static final double 1234.0 = 1234.0;\n    private static final double _semiMajor = 5678.0;\n    private static final double[] _expValues = new double[]{_semiMajor, 1234.0, 15, 16, 17, 18, 19};\n    private static final String _datumName = \"DatumName\";\n    private static final float _pixelX = 3.2f;\n    private static final float _pixelY = 4.3f;", "refactored_code": "    private static final double _semiMinor = 1234.0;\n    private static final String _ellipsoidName = \"EllipsoidName\";\n    private static final double _semiMinor = 1234.0;\n    private static final double _semiMajor = 5678.0;\n    private static final double[] _expValues = new double[]{_semiMajor, _semiMinor, 15, 16, 17, 18, 19};\n    private static final String _datumName = \"DatumName\";\n    private static final float _pixelX = 3.2f;\n    private static final float _pixelY = 4.3f;"}
{"magic_number_smell": "        assertEquals(\"this is a band\", cfb.getDescription());\n        assertEquals(ProductData.TYPE_FLOAT32, cfb.getDataType());\n        assertEquals(\"l\", cfb.getUnit());\n        assertEquals(0.0, cfb.getSolarFlux(), 1e-6);\n        assertEquals(0.0, cfb.getSpectralWavelength(), 1e-6);\n        assertEquals(0.0, cfb.getSpectralBandwidth(), 1e-6);\n        assertEquals(1.0, cfb.getScalingFactor(), 1e-6);", "refactored_code": "    private static final double EPS = 1e-6;\n        assertEquals(\"this is a band\", cfb.getDescription());\n        assertEquals(ProductData.TYPE_FLOAT32, cfb.getDataType());\n        assertEquals(\"l\", cfb.getUnit());\n        assertEquals(0.0, cfb.getSolarFlux(), EPS);\n        assertEquals(0.0, cfb.getSpectralWavelength(), EPS);\n        assertEquals(0.0, cfb.getSpectralBandwidth(), EPS);\n        assertEquals(1.0, cfb.getScalingFactor(), EPS);"}
{"magic_number_smell": "        assertEquals(gfb.getUnit(), xmlElement.getChildTextTrim(DimapProductConstants.TAG_PHYSICAL_UNIT));\n        assertTrue(xmlElement.getChild(DimapProductConstants.TAG_SOLAR_FLUX) != null);\n        assertEquals(gfb.getSolarFlux(),\n                     Float.parseFloat(xmlElement.getChildTextTrim(DimapProductConstants.TAG_SOLAR_FLUX)), 1e-6);\n        assertTrue(xmlElement.getChild(DimapProductConstants.TAG_BAND_WAVELEN) != null);\n        assertEquals(gfb.getSpectralWavelength(),\n                     Float.parseFloat(xmlElement.getChildTextTrim(DimapProductConstants.TAG_BAND_WAVELEN)), 1e-6);", "refactored_code": "    private static final double EPS = 1e-6;\n        assertEquals(gfb.getUnit(), xmlElement.getChildTextTrim(DimapProductConstants.TAG_PHYSICAL_UNIT));\n        assertTrue(xmlElement.getChild(DimapProductConstants.TAG_SOLAR_FLUX) != null);\n        assertEquals(gfb.getSolarFlux(),\n                     Float.parseFloat(xmlElement.getChildTextTrim(DimapProductConstants.TAG_SOLAR_FLUX)), EPS);\n        assertTrue(xmlElement.getChild(DimapProductConstants.TAG_BAND_WAVELEN) != null);\n        assertEquals(gfb.getSpectralWavelength(),\n                     Float.parseFloat(xmlElement.getChildTextTrim(DimapProductConstants.TAG_BAND_WAVELEN)), EPS);"}
{"magic_number_smell": "\n    @Test\n    public void testReadWritePlacemarksTextFileWithAdditionalData() throws Exception {\n        StringWriter writer = new StringWriter(200);\n        PinDescriptor pinDescriptor = PinDescriptor.getInstance();\n        List<Placemark> expectedPlacemarks = createPlacemarks(pinDescriptor, GEO_CODING, DATA_BOUNDS);\n        String[] stdColumnName = {\"X\", \"Y\", \"Lon\", \"Lat\", \"Label\"};", "refactored_code": "    private static final int WRITER_INITIAL_SIZE = 200;\n\n    @Test\n    public void testReadWritePlacemarksTextFileWithAdditionalData() throws Exception {\n        StringWriter writer = new StringWriter(WRITER_INITIAL_SIZE);\n        PinDescriptor pinDescriptor = PinDescriptor.getInstance();\n        List<Placemark> expectedPlacemarks = createPlacemarks(pinDescriptor, GEO_CODING, DATA_BOUNDS);\n        String[] stdColumnName = {\"X\", \"Y\", \"Lon\", \"Lat\", \"Label\"};"}
{"magic_number_smell": "\n        @Override\n        public Product readProductNodesImpl() throws IOException {\n            return new Product(\"X product\", _prodType, 400, _sceneHeight);\n        }\n\n        @Override", "refactored_code": "    private static final int _sceneWidth = 400;\n\n        @Override\n        public Product readProductNodesImpl() throws IOException {\n            return new Product(\"X product\", _prodType, _sceneWidth, _sceneHeight);\n        }\n\n        @Override"}
{"magic_number_smell": "    @Before\n    public void setUp() throws Exception {\n\n        product = new Product(\"p\", \"t\", 11, PRODUCT_HEIGHT);\n        TiePointGrid lat = new TiePointGrid(\"t1\", 3, 3, 0, 0, 5, 5,\n                new float[]{\n                        2.0f, 2.0f, 2.0f,", "refactored_code": "    private static final int PRODUCT_WIDTH = 11;\n    @Before\n    public void setUp() throws Exception {\n\n        product = new Product(\"p\", \"t\", PRODUCT_WIDTH, PRODUCT_HEIGHT);\n        TiePointGrid lat = new TiePointGrid(\"t1\", 3, 3, 0, 0, 5, 5,\n                new float[]{\n                        2.0f, 2.0f, 2.0f,"}
{"magic_number_smell": "    }\n\n    public void testGetAndSetSubSampling() {\n        assertEquals(\"initially, getSubSamplingX() should return 1\", 1.0f, _subset.getSubSamplingX(), 1e-5f);\n        assertEquals(\"initially, getSubSamplingY() should return 1\", 1.0f, _subset.getSubSamplingY(), 1e-5f);\n\n        _subset.setSubSampling(1, 10);", "refactored_code": "    private static final float EPS = 1e-5f;\n    }\n\n    public void testGetAndSetSubSampling() {\n        assertEquals(\"initially, getSubSamplingX() should return 1\", 1.0f, _subset.getSubSamplingX(), EPS);\n        assertEquals(\"initially, getSubSamplingY() should return 1\", 1.0f, _subset.getSubSamplingY(), EPS);\n\n        _subset.setSubSampling(1, 10);"}
{"magic_number_smell": "\n        @Override\n        protected Product readProductNodesImpl() throws IOException {\n            Product product = new Product(\"A\", \"B\", 1000, 1000, this);\n            if (projected) {\n                setMapGeoCoding(product);\n            }", "refactored_code": "    private static final int SIZE = 1000;\n\n        @Override\n        protected Product readProductNodesImpl() throws IOException {\n            Product product = new Product(\"A\", \"B\", SIZE, SIZE, this);\n            if (projected) {\n                setMapGeoCoding(product);\n            }"}
{"magic_number_smell": "    private static final int 4 = 4;\n    private static final int GW = 3;\n    private static final int GH = 5;\n    private static final int PW = (GW - 1) * 4 + 1;\n    private static final int PH = (GH - 1) * 4 + 1;\n    private static final float LAT_1 = 53.0f;\n    private static final float LAT_2 = 50.0f;", "refactored_code": "    private static final int S = 4;\n    private static final int S = 4;\n    private static final int GW = 3;\n    private static final int GH = 5;\n    private static final int PW = (GW - 1) * S + 1;\n    private static final int PH = (GH - 1) * S + 1;\n    private static final float LAT_1 = 53.0f;\n    private static final float LAT_2 = 50.0f;"}
{"magic_number_smell": "    @Override\n    protected void setUp() {\n        _productManager = new ProductManager();\n        _product1 = new Product(\"product1\", _prodName, 400, _sceneHeight);\n        _product2 = new Product(\"product2\", _prodName, 400, _sceneHeight);\n        _product3 = new Product(\"product3\", _prodName, 400, _sceneHeight);\n    }", "refactored_code": "    private static final int _sceneWidth = 400;\n    @Override\n    protected void setUp() {\n        _productManager = new ProductManager();\n        _product1 = new Product(\"product1\", _prodName, _sceneWidth, _sceneHeight);\n        _product2 = new Product(\"product2\", _prodName, _sceneWidth, _sceneHeight);\n        _product3 = new Product(\"product3\", _prodName, _sceneWidth, _sceneHeight);\n    }"}
{"magic_number_smell": "\n    @Before\n    public void setUp() throws Exception {\n        product = new Product(\"product\", _prodType, 20, _sceneHeight);\n        product.setModified(false);\n    }\n", "refactored_code": "    private static final int _sceneWidth = 20;\n\n    @Before\n    public void setUp() throws Exception {\n        product = new Product(\"product\", _prodType, _sceneWidth, _sceneHeight);\n        product.setModified(false);\n    }\n"}
{"magic_number_smell": "    protected void setUp() {\n        p = createTestProduct();\n        pr = (TestProductReader) p.getProductReader();\n        rectangle = new Rectangle(0, 0, 5, SH);\n    }\n\n    public void testThatSourceImagesGeneratedForBandsAreCached() throws IOException {", "refactored_code": "    private static final int SW = 5; // scene width\n    protected void setUp() {\n        p = createTestProduct();\n        pr = (TestProductReader) p.getProductReader();\n        rectangle = new Rectangle(0, 0, SW, SH);\n    }\n\n    public void testThatSourceImagesGeneratedForBandsAreCached() throws IOException {"}
{"magic_number_smell": "    private static final int 4 = 4;\n    private static final int GW = 3;\n    private static final int GH = 5;\n    private static final int PW = (GW - 1) * 4 + 1;\n    private static final int PH = (GH - 1) * 4 + 1;\n    private static final float LAT_1 = 53.0f;\n    private static final float LAT_2 = 50.0f;", "refactored_code": "    private static final int S = 4;\n    private static final int S = 4;\n    private static final int GW = 3;\n    private static final int GH = 5;\n    private static final int PW = (GW - 1) * S + 1;\n    private static final int PH = (GH - 1) * S + 1;\n    private static final float LAT_1 = 53.0f;\n    private static final float LAT_2 = 50.0f;"}
{"magic_number_smell": "            for (int i = 0; i < 4; i++) {\n                int x = i * 4 / 2;\n                int y = j * 2 / 2;\n                assertEquals(interpolated[j][i], grid.getPixelFloat(x, y), 1.e-10F);\n            }\n        }\n    }", "refactored_code": "    private final float _eps = 1.e-10F;\n            for (int i = 0; i < 4; i++) {\n                int x = i * 4 / 2;\n                int y = j * 2 / 2;\n                assertEquals(interpolated[j][i], grid.getPixelFloat(x, y), _eps);\n            }\n        }\n    }"}
{"magic_number_smell": "        final RasterDataEvalEnv evalEnv = new RasterDataEvalEnv(0, 0, 1, 1);\n\n        long t1 = System.currentTimeMillis();\n        for (int i = 0; i < 10000000; i++) {\n        }\n        long t2 = System.currentTimeMillis();\n        for (int i = 0; i < 10000000; i++) {", "refactored_code": "    private static final int MAX_NUM_TEST_LOOPS = 10000000;\n        final RasterDataEvalEnv evalEnv = new RasterDataEvalEnv(0, 0, 1, 1);\n\n        long t1 = System.currentTimeMillis();\n        for (int i = 0; i < MAX_NUM_TEST_LOOPS; i++) {\n        }\n        long t2 = System.currentTimeMillis();\n        for (int i = 0; i < MAX_NUM_TEST_LOOPS; i++) {"}
{"magic_number_smell": "            geoPt.lon = (float) _srcCoords_1[n][0];\n            ptRet = trans.forward(geoPt, ptRet);\n\n            assertEquals(_targCoords_1[n][0], ptRet.getX(), 1e-4);\n            assertEquals(_targCoords_1[n][1], ptRet.getY(), 1e-4);\n        }\n", "refactored_code": "    private static final double _metricDelta = 1e-4;\n            geoPt.lon = (float) _srcCoords_1[n][0];\n            ptRet = trans.forward(geoPt, ptRet);\n\n            assertEquals(_targCoords_1[n][0], ptRet.getX(), _metricDelta);\n            assertEquals(_targCoords_1[n][1], ptRet.getY(), _metricDelta);\n        }\n"}
{"magic_number_smell": "\n        Point2D mapPoint = transform.forward(geoPos, null);\n\n        assertEquals(0.0, mapPoint.getX(), 1.0e-6);\n        assertEquals(0.0, mapPoint.getY(), 1.0e-6);\n    }\n", "refactored_code": "    private static final double EPSILON = 1.0e-6;\n\n        Point2D mapPoint = transform.forward(geoPos, null);\n\n        assertEquals(0.0, mapPoint.getX(), EPSILON);\n        assertEquals(0.0, mapPoint.getY(), EPSILON);\n    }\n"}
{"magic_number_smell": "    private static void doTransform(DirectPosition source, DirectPosition target,\n                                    MathTransform transform, final int datasetIndex) throws TransformException {\n        DirectPosition calculated = transform.transform(source, null);\n        assertPositionEquals(target, calculated, 1.0E-4, datasetIndex);\n    }\n\n    private static void doTransformInverse(DirectPosition source, DirectPosition target,", "refactored_code": "    private static final double TOLERANCE = 1.0E-4;\n    private static void doTransform(DirectPosition source, DirectPosition target,\n                                    MathTransform transform, final int datasetIndex) throws TransformException {\n        DirectPosition calculated = transform.transform(source, null);\n        assertPositionEquals(target, calculated, TOLERANCE, datasetIndex);\n    }\n\n    private static void doTransformInverse(DirectPosition source, DirectPosition target,"}
{"magic_number_smell": "    @Test\n    public void testBandWithLog10Scaling() {\n        Band band = createBand(1.0, 0.0, true);\n        checkTargetImageSampleValues(band, 1.0e-3);\n    }\n\n    @Test", "refactored_code": "    private static final double EPS_L = 1.0e-3;\n    @Test\n    public void testBandWithLog10Scaling() {\n        Band band = createBand(1.0, 0.0, true);\n        checkTargetImageSampleValues(band, EPS_L);\n    }\n\n    @Test"}
{"magic_number_smell": "            final int x = tile.getMinX() + dbIndex % tile.getWidth();\n            final int y = tile.getMinY() + dbIndex / tile.getWidth();\n            final double actual = dataBuffer.getElemDouble(dbIndex);\n            if (x >= 0 && x < 10 && y >= 0 && y < IMAGE_H) {\n                final double expected = coefficients[0] * pdIndex + coefficients[1];\n                assertEquals(\"Inside image bounds: dataBuffer.getElemDouble(\" + dbIndex + \")\", expected, actual, 0.0);\n                pdIndex++;", "refactored_code": "    private static final int IMAGE_W = 10;\n            final int x = tile.getMinX() + dbIndex % tile.getWidth();\n            final int y = tile.getMinY() + dbIndex / tile.getWidth();\n            final double actual = dataBuffer.getElemDouble(dbIndex);\n            if (x >= 0 && x < IMAGE_W && y >= 0 && y < IMAGE_H) {\n                final double expected = coefficients[0] * pdIndex + coefficients[1];\n                assertEquals(\"Inside image bounds: dataBuffer.getElemDouble(\" + dbIndex + \")\", expected, actual, 0.0);\n                pdIndex++;"}
{"magic_number_smell": "        Raster data = im0.getData(new Rectangle(0, 0, 100, 100));\n        assertEquals(0, data.getSample(0, 0, 0));\n        assertEquals(99, data.getSample(99, 0, 0));\n        assertEquals(99 * 1000, data.getSample(0, 99, 0));\n        assertEquals(99 * 1000 + 99, data.getSample(99, 99, 0));\n    }\n", "refactored_code": "    private static final int Y_FACTOR = 1000;\n        Raster data = im0.getData(new Rectangle(0, 0, 100, 100));\n        assertEquals(0, data.getSample(0, 0, 0));\n        assertEquals(99, data.getSample(99, 0, 0));\n        assertEquals(99 * Y_FACTOR, data.getSample(0, 99, 0));\n        assertEquals(99 * Y_FACTOR + 99, data.getSample(99, 99, 0));\n    }\n"}
{"magic_number_smell": "\n        assertEquals(\"ranges repeated for easier input\", r.rString());\n        assertEquals(6, r.rlong());\n        assertEquals(-1.61093, r.rdouble(), 1.0e-8);\n        assertEquals(3.9984, r.rdouble(), 1.0e-8);\n\n        final double[] d4 = r.rdouble(4);", "refactored_code": "    private static final double EPS = 1.0e-8;\n\n        assertEquals(\"ranges repeated for easier input\", r.rString());\n        assertEquals(6, r.rlong());\n        assertEquals(-1.61093, r.rdouble(), EPS);\n        assertEquals(3.9984, r.rdouble(), EPS);\n\n        final double[] d4 = r.rdouble(4);"}
{"magic_number_smell": "\n    private static void testCoord(final PixelPos[] pixelCoords, final int i, final float x, final float y) {\n        assertNotNull(pixelCoords[i]);\n        assertEquals(x, pixelCoords[i].x, 1.0e-6f);\n        assertEquals(y, pixelCoords[i].y, 1.0e-6f);\n    }\n", "refactored_code": "    private static final float EPS = 1.0e-6f;\n\n    private static void testCoord(final PixelPos[] pixelCoords, final int i, final float x, final float y) {\n        assertNotNull(pixelCoords[i]);\n        assertEquals(x, pixelCoords[i].x, EPS);\n        assertEquals(y, pixelCoords[i].y, EPS);\n    }\n"}
{"magic_number_smell": "\npublic class FastMathPerformance {\n    private static final int Integer.parseInt(System.getProperty(\"testRuns\", \"10000000\")) = Integer.parseInt(System.getProperty(\"testRuns\", \"10000000\"));\n    private static final double F1 = 1d / Integer.parseInt(System.getProperty(\"testRuns\", \"10000000\"));\n\n    private static List<Double> results = new ArrayList<>();\n", "refactored_code": "    private static final int RUNS = Integer.parseInt(System.getProperty(\"testRuns\", \"10000000\"));\n\npublic class FastMathPerformance {\n    private static final int RUNS = Integer.parseInt(System.getProperty(\"testRuns\", \"10000000\"));\n    private static final double F1 = 1d / RUNS;\n\n    private static List<Double> results = new ArrayList<>();\n"}
{"magic_number_smell": "\n        // check for correct values\n        assertEquals(0.1692265f, RsMathUtils.radianceToReflectance(rad, sza, BeamConstants.MERIS_SOLAR_FLUXES[0]),\n                     1e-5F);\n        assertEquals(0.1757149f, RsMathUtils.radianceToReflectance(rad, sza, BeamConstants.MERIS_SOLAR_FLUXES[5]),\n                     1e-5F);\n        assertEquals(0.23116349f, RsMathUtils.radianceToReflectance(rad, sza, BeamConstants.MERIS_SOLAR_FLUXES[10]),", "refactored_code": "    public static final double EPS = 1e-5F;\n\n        // check for correct values\n        assertEquals(0.1692265f, RsMathUtils.radianceToReflectance(rad, sza, BeamConstants.MERIS_SOLAR_FLUXES[0]),\n                     EPS);\n        assertEquals(0.1757149f, RsMathUtils.radianceToReflectance(rad, sza, BeamConstants.MERIS_SOLAR_FLUXES[5]),\n                     EPS);\n        assertEquals(0.23116349f, RsMathUtils.radianceToReflectance(rad, sza, BeamConstants.MERIS_SOLAR_FLUXES[10]),"}
{"magic_number_smell": "\n    private void writeProperties() {\n        // todo - implement\n        if ((config & 1) != 1) {\n        }\n    }\n", "refactored_code": "    public static final int WRITE_PROPERTIES = 1;\n\n    private void writeProperties() {\n        // todo - implement\n        if ((config & WRITE_PROPERTIES) != WRITE_PROPERTIES) {\n        }\n    }\n"}
{"magic_number_smell": "            pw.print(\"\\t\" + Header.BEAM_PROPERTIES + \" = [\" + sensingStartStop + \"]\");\n        }\n        pw.println(\"}\");\n        pw.println(EnviConstants.HEADER_KEY_SAMPLES + \" = \" + 25);\n        pw.println(EnviConstants.HEADER_KEY_LINES + \" = \" + HEIGHT);\n        pw.println(EnviConstants.HEADER_KEY_BANDS + \" = \" + NUM_BANDS);\n        pw.println(EnviConstants.HEADER_KEY_HEADER_OFFSET + \" = \" + HEADER_OFFSET);", "refactored_code": "    private static final int WIDTH = 25;\n            pw.print(\"\\t\" + Header.BEAM_PROPERTIES + \" = [\" + sensingStartStop + \"]\");\n        }\n        pw.println(\"}\");\n        pw.println(EnviConstants.HEADER_KEY_SAMPLES + \" = \" + WIDTH);\n        pw.println(EnviConstants.HEADER_KEY_LINES + \" = \" + HEIGHT);\n        pw.println(EnviConstants.HEADER_KEY_BANDS + \" = \" + NUM_BANDS);\n        pw.println(EnviConstants.HEADER_KEY_HEADER_OFFSET + \" = \" + HEADER_OFFSET);"}
{"magic_number_smell": "            throws DDDBException {\n        ProductInfo productInfo = getProductInfo(productType);\n        Debug.assertNotNull(productInfo);\n        int i0 = 3;\n        int numBinaryDatasets = productInfo.datasetInfos.size() - i0;\n        if (numBinaryDatasets < 0) {\n            throw new DDDBException(\"illegal DDDB file content for product type '\" + productType + \"'\"); /*I18N*/", "refactored_code": "    private final int _firstBinaryDsIndex = 3;\n            throws DDDBException {\n        ProductInfo productInfo = getProductInfo(productType);\n        Debug.assertNotNull(productInfo);\n        int i0 = _firstBinaryDsIndex;\n        int numBinaryDatasets = productInfo.datasetInfos.size() - i0;\n        if (numBinaryDatasets < 0) {\n            throw new DDDBException(\"illegal DDDB file content for product type '\" + productType + \"'\"); /*I18N*/"}
{"magic_number_smell": "     */\n    @Override\n    protected void postProcessMPH(Map parameters) throws IOException {\n        _ioddVersion = -1;\n    }\n\n    /**", "refactored_code": "    public static final int IODD_VERSION_UNKNOWN = -1;\n     */\n    @Override\n    protected void postProcessMPH(Map parameters) throws IOException {\n        _ioddVersion = IODD_VERSION_UNKNOWN;\n    }\n\n    /**"}
{"magic_number_smell": "    public BaselineAlgorithm() {\n        lambdaFactor = 1.0;\n        inverseDelta = 1.0;\n        cloudCorrectionFactor = 1.005f;\n    }\n\n    /**", "refactored_code": "    public static final float DEFAULT_CLOUD_CORRECT = 1.005f;\n    public BaselineAlgorithm() {\n        lambdaFactor = 1.0;\n        inverseDelta = 1.0;\n        cloudCorrectionFactor = DEFAULT_CLOUD_CORRECT;\n    }\n\n    /**"}
{"magic_number_smell": "        int subsamplingXOffset = sourceOffsetX % sourceStepX;\n        int subsamplingYOffset = sourceOffsetY % sourceStepY;\n        readParam.setSourceSubsampling(sourceStepX, sourceStepY, subsamplingXOffset, subsamplingYOffset);\n        RenderedImage subsampledImage = imageReader.readAsRenderedImage(0, readParam);\n\n        return subsampledImage.getData(new Rectangle(destOffsetX, destOffsetY, destWidth, destHeight));\n    }", "refactored_code": "    private static final int FIRST_IMAGE = 0;\n        int subsamplingXOffset = sourceOffsetX % sourceStepX;\n        int subsamplingYOffset = sourceOffsetY % sourceStepY;\n        readParam.setSourceSubsampling(sourceStepX, sourceStepY, subsamplingXOffset, subsamplingYOffset);\n        RenderedImage subsampledImage = imageReader.readAsRenderedImage(FIRST_IMAGE, readParam);\n\n        return subsampledImage.getData(new Rectangle(destOffsetX, destOffsetY, destWidth, destHeight));\n    }"}
{"magic_number_smell": "\n\n    private int[] getGeoKeyDirValues() {\n        if (!containsField(34735)) {\n            throw new IllegalStateException(\"no GEO_KEY_DIRECTORY\");\n        }\n        final TIFFField field = getField(34735);", "refactored_code": "    private static final int TAG_GEO_KEY_DIRECTORY___SPOT = 34735;\n\n\n    private int[] getGeoKeyDirValues() {\n        if (!containsField(TAG_GEO_KEY_DIRECTORY___SPOT)) {\n            throw new IllegalStateException(\"no GEO_KEY_DIRECTORY\");\n        }\n        final TIFFField field = getField(TAG_GEO_KEY_DIRECTORY___SPOT);"}
{"magic_number_smell": "    }\n\n    public long getSize() {\n        return 12 + getReferencedValuesSizeInBytes();\n    }\n\n    public boolean mustValuesBeReferenced() {", "refactored_code": "    public static final short BYTES_PER_ENTRY = 12;\n    }\n\n    public long getSize() {\n        return BYTES_PER_ENTRY + getReferencedValuesSizeInBytes();\n    }\n\n    public boolean mustValuesBeReferenced() {"}
{"magic_number_smell": "    private TiffShort[] createColorMap(Product product) {\n        final ImageInfo imageInfo = product.getBandAt(0).getImageInfo(null, ProgressMonitor.NULL);\n        final ColorPaletteDef paletteDef = imageInfo.getColorPaletteDef();\n        final TiffShort[] redColor = new TiffShort[256];\n        Arrays.fill(redColor, new TiffShort(0));\n        final TiffShort[] greenColor = new TiffShort[256];\n        Arrays.fill(greenColor, new TiffShort(0));", "refactored_code": "    private static final int TIFF_COLORMAP_SIZE = 256;\n    private TiffShort[] createColorMap(Product product) {\n        final ImageInfo imageInfo = product.getBandAt(0).getImageInfo(null, ProgressMonitor.NULL);\n        final ColorPaletteDef paletteDef = imageInfo.getColorPaletteDef();\n        final TiffShort[] redColor = new TiffShort[TIFF_COLORMAP_SIZE];\n        Arrays.fill(redColor, new TiffShort(0));\n        final TiffShort[] greenColor = new TiffShort[TIFF_COLORMAP_SIZE];\n        Arrays.fill(greenColor, new TiffShort(0));"}
{"magic_number_smell": "        TiffValueRangeChecker.checkValueTiffRational(numerator, \"numerator\");\n        TiffValueRangeChecker.checkValueTiffRational(denominator, \"denominator\");\n        setData(ProductData.createInstance(ProductData.TYPE_UINT32, 2));\n        getData().setElemUIntAt(0, numerator);\n        getData().setElemUIntAt(DENOMINATOR_INDEX, denominator);\n    }\n", "refactored_code": "    private static final int NUMERATOR_INDEX = 0;\n        TiffValueRangeChecker.checkValueTiffRational(numerator, \"numerator\");\n        TiffValueRangeChecker.checkValueTiffRational(denominator, \"denominator\");\n        setData(ProductData.createInstance(ProductData.TYPE_UINT32, 2));\n        getData().setElemUIntAt(NUMERATOR_INDEX, numerator);\n        getData().setElemUIntAt(DENOMINATOR_INDEX, denominator);\n    }\n"}
{"magic_number_smell": "     * 8-bit unsigned integer,\n     */\n    public static final byte 1 = 1;\n    public static final TiffShort BYTE = new TiffShort(1);\n\n    /**\n     * a byte sequence that contains a 7-bit ASCII code;", "refactored_code": "    public static final byte BYTE_TYPE = 1;\n     * 8-bit unsigned integer,\n     */\n    public static final byte BYTE_TYPE = 1;\n    public static final TiffShort BYTE = new TiffShort(BYTE_TYPE);\n\n    /**\n     * a byte sequence that contains a 7-bit ASCII code;"}
{"magic_number_smell": "    private static final int UNSIGNED_SHORT_MAX = 0xffff;\n\n    public static void checkValueTiffRational(final long value, final String name) {\n        checkValue(value, name, 1, 0xffffffffL);\n    }\n\n    public static void checkValueTiffLong(final long value, final String name) {", "refactored_code": "    private static final long UNSIGNED_INT_MAX = 0xffffffffL;\n    private static final int UNSIGNED_SHORT_MAX = 0xffff;\n\n    public static void checkValueTiffRational(final long value, final String name) {\n        checkValue(value, name, 1, UNSIGNED_INT_MAX);\n    }\n\n    public static void checkValueTiffLong(final long value, final String name) {"}
{"magic_number_smell": "    @Override\n    protected void setUp() throws Exception {\n        _ios = new MemoryCacheImageOutputStream(new ByteArrayOutputStream());\n        _product = new Product(\"name\", \"type\", 20, _HEIGHT);\n\n    }\n", "refactored_code": "    private static final int _WIDTH = 20;\n    @Override\n    protected void setUp() throws Exception {\n        _ios = new MemoryCacheImageOutputStream(new ByteArrayOutputStream());\n        _product = new Product(\"name\", \"type\", _WIDTH, _HEIGHT);\n\n    }\n"}
{"magic_number_smell": "    @Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        _product = new Product(\"name\", \"type\", 10, HEIGHT);\n    }\n\n    public void testTiffIFDCreation_WithEmptyProduct() {", "refactored_code": "    private static final int WIDTH = 10;\n    @Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        _product = new Product(\"name\", \"type\", WIDTH, HEIGHT);\n    }\n\n    public void testTiffIFDCreation_WithEmptyProduct() {"}
{"magic_number_smell": "    private final long _TIFFLONG_MIN = 0;\n\n    public void testCreation_WithMaxValue() {\n        new TiffLong(0xffffffffL);\n    }\n\n    public void testCreation_WithMinValue() {", "refactored_code": "    private final long _TIFFLONG_MAX = 0xffffffffL;\n    private final long _TIFFLONG_MIN = 0;\n\n    public void testCreation_WithMaxValue() {\n        new TiffLong(_TIFFLONG_MAX);\n    }\n\n    public void testCreation_WithMinValue() {"}
{"magic_number_smell": "    private static final long _TIFFRATIONAL_MIN = 1;\n\n    public void testCreation() {\n        new TiffRational(0xffffffffL, 0xffffffffL);\n        new TiffRational(0xffffffffL, _TIFFRATIONAL_MIN);\n        new TiffRational(_TIFFRATIONAL_MIN, _TIFFRATIONAL_MIN);\n        new TiffRational(_TIFFRATIONAL_MIN, 0xffffffffL);", "refactored_code": "    private static final long _TIFFRATIONAL_MAX = 0xffffffffL;\n    private static final long _TIFFRATIONAL_MIN = 1;\n\n    public void testCreation() {\n        new TiffRational(_TIFFRATIONAL_MAX, _TIFFRATIONAL_MAX);\n        new TiffRational(_TIFFRATIONAL_MAX, _TIFFRATIONAL_MIN);\n        new TiffRational(_TIFFRATIONAL_MIN, _TIFFRATIONAL_MIN);\n        new TiffRational(_TIFFRATIONAL_MIN, _TIFFRATIONAL_MAX);"}
{"magic_number_smell": "    private static final int _TIFFSHORT_MIN = 0;\n\n    public void testCreation_WithMaxValue() {\n        new TiffShort(0xffff);\n    }\n\n    public void testCreation_WithMinValue() {", "refactored_code": "    private static final int _TIFFSHORT_MAX = 0xffff;\n    private static final int _TIFFSHORT_MIN = 0;\n\n    public void testCreation_WithMaxValue() {\n        new TiffShort(_TIFFSHORT_MAX);\n    }\n\n    public void testCreation_WithMinValue() {"}
{"magic_number_smell": "    public static final int DEGREE_RES = GETASSE30ElevationModelDescriptor.DEGREE_RES;\n    public static final int NUM_PIXELS_PER_TILE = GETASSE30ElevationModelDescriptor.PIXEL_RES;\n    public static final int NO_DATA_VALUE = GETASSE30ElevationModelDescriptor.NO_DATA_VALUE;\n    public static final int RASTER_WIDTH = GETASSE30ElevationModelDescriptor.NUM_X_TILES * NUM_PIXELS_PER_TILE;\n    public static final int RASTER_HEIGHT = NUM_Y_TILES * NUM_PIXELS_PER_TILE;\n\n    private final GETASSE30ElevationModelDescriptor descriptor;", "refactored_code": "    public static final int NUM_X_TILES = GETASSE30ElevationModelDescriptor.NUM_X_TILES;\n    public static final int DEGREE_RES = GETASSE30ElevationModelDescriptor.DEGREE_RES;\n    public static final int NUM_PIXELS_PER_TILE = GETASSE30ElevationModelDescriptor.PIXEL_RES;\n    public static final int NO_DATA_VALUE = GETASSE30ElevationModelDescriptor.NO_DATA_VALUE;\n    public static final int RASTER_WIDTH = NUM_X_TILES * NUM_PIXELS_PER_TILE;\n    public static final int RASTER_HEIGHT = NUM_Y_TILES * NUM_PIXELS_PER_TILE;\n\n    private final GETASSE30ElevationModelDescriptor descriptor;"}
{"magic_number_smell": "    public static final int DEGREE_RES = 15;\n    public static final int PIXEL_RES = 1800;\n    public static final int NO_DATA_VALUE = -9999;\n    public static final int RASTER_WIDTH = 24 * PIXEL_RES;\n    public static final int RASTER_HEIGHT = NUM_Y_TILES * PIXEL_RES;\n    public static final Datum DATUM = Datum.WGS_84;\n", "refactored_code": "    public static final int NUM_X_TILES = 24;\n    public static final int DEGREE_RES = 15;\n    public static final int PIXEL_RES = 1800;\n    public static final int NO_DATA_VALUE = -9999;\n    public static final int RASTER_WIDTH = NUM_X_TILES * PIXEL_RES;\n    public static final int RASTER_HEIGHT = NUM_Y_TILES * PIXEL_RES;\n    public static final Datum DATUM = Datum.WGS_84;\n"}
{"magic_number_smell": "        }\n\n        private int[] parseImpl() throws ParseException {\n            final int[] eastingNorthing = new int[]{-999, -999};\n            parseDirectionValueAndAssign(eastingNorthing); // one per direction\n            parseDirectionValueAndAssign(eastingNorthing); // one per direction\n            validateThatValuesAreAssigned(eastingNorthing);", "refactored_code": "        private static final int ILLEGAL_DIRECTION_VALUE = -999;\n        }\n\n        private int[] parseImpl() throws ParseException {\n            final int[] eastingNorthing = new int[]{ILLEGAL_DIRECTION_VALUE, ILLEGAL_DIRECTION_VALUE};\n            parseDirectionValueAndAssign(eastingNorthing); // one per direction\n            parseDirectionValueAndAssign(eastingNorthing); // one per direction\n            validateThatValuesAreAssigned(eastingNorthing);"}
{"magic_number_smell": "public class CommandLineArgs {\n\n    private static final int 1024 = 1024;\n    private static final int M = 1024 * 1024;\n    private static final int G = M * 1024;\n    public static final String DEFAULT_TARGET_FILEPATH = \"target.dim\";\n    public static final String DEFAULT_METADATA_FILEPATH = \"metadata.properties\";", "refactored_code": "    private static final int K = 1024;\npublic class CommandLineArgs {\n\n    private static final int K = 1024;\n    private static final int M = K * 1024;\n    private static final int G = M * 1024;\n    public static final String DEFAULT_TARGET_FILEPATH = \"target.dim\";\n    public static final String DEFAULT_METADATA_FILEPATH = \"metadata.properties\";"}
{"magic_number_smell": "\n        VelocityContext context = new VelocityContext();\n        context.put(\"docTitle\", TileUsageReportGenerator.class.getName());\n        context.put(\"chartWidth\", 1500);\n        context.put(\"totalTime\", nanosToRoundedSecs(endNanosMax - startNanosMin));\n        context.put(\"events\", events);\n        context.put(\"tasks\", tasks);", "refactored_code": "    public static final int CHART_WIDTH = 1500;\n\n        VelocityContext context = new VelocityContext();\n        context.put(\"docTitle\", TileUsageReportGenerator.class.getName());\n        context.put(\"chartWidth\", CHART_WIDTH);\n        context.put(\"totalTime\", nanosToRoundedSecs(endNanosMax - startNanosMin));\n        context.put(\"events\", events);\n        context.put(\"tasks\", tasks);"}
{"magic_number_smell": "    private static MathTransform2D toMathTransform2D(final MathTransform transform,\n                                                     final MathTransformFactory mtFactory) throws FactoryException {\n        final DimensionFilter filter = new DimensionFilter(mtFactory);\n        filter.addSourceDimension(0);\n        filter.addSourceDimension(DIMENSION_Y_INDEX);\n        MathTransform candidate = filter.separate(transform);\n        if (candidate instanceof MathTransform2D) {", "refactored_code": "    private static final int DIMENSION_X_INDEX = 0;\n    private static MathTransform2D toMathTransform2D(final MathTransform transform,\n                                                     final MathTransformFactory mtFactory) throws FactoryException {\n        final DimensionFilter filter = new DimensionFilter(mtFactory);\n        filter.addSourceDimension(DIMENSION_X_INDEX);\n        filter.addSourceDimension(DIMENSION_Y_INDEX);\n        MathTransform candidate = filter.separate(transform);\n        if (candidate instanceof MathTransform2D) {"}
{"magic_number_smell": "\n        @Override\n        public void initialize() {\n            targetProduct = new Product(\"Op1Name\", \"Op1Type\", 3, RASTER_HEIGHT);\n            targetProduct.addBand(new Band(\"Op1A\", ProductData.TYPE_INT8, 3, RASTER_HEIGHT));\n        }\n", "refactored_code": "    public static final int RASTER_WIDTH = 3;\n\n        @Override\n        public void initialize() {\n            targetProduct = new Product(\"Op1Name\", \"Op1Type\", RASTER_WIDTH, RASTER_HEIGHT);\n            targetProduct.addBand(new Band(\"Op1A\", ProductData.TYPE_INT8, RASTER_WIDTH, RASTER_HEIGHT));\n        }\n"}
{"magic_number_smell": "\n    private static final int 16 = 16;\n    private static final int H = 8;\n    private static final int N = 16 * H;\n    private static final int N05 = N / 2;\n\n    @Test", "refactored_code": "    private static final int W = 16;\n\n    private static final int W = 16;\n    private static final int H = 8;\n    private static final int N = W * H;\n    private static final int N05 = N / 2;\n\n    @Test"}
{"magic_number_smell": "\n        // test some valid value\n        lineArgs = parseArgs(\"Reproject\", \"source.dim\", \"-q\", \"1\", \"-c\", \"16000K\");\n        assertEquals(16000 * 1024, lineArgs.getTileCacheCapacity());\n        assertEquals(1, lineArgs.getTileSchedulerParallelism());\n\n        // test some valid value", "refactored_code": "    private static final int K = 1024;\n\n        // test some valid value\n        lineArgs = parseArgs(\"Reproject\", \"source.dim\", \"-q\", \"1\", \"-c\", \"16000K\");\n        assertEquals(16000 * K, lineArgs.getTileCacheCapacity());\n        assertEquals(1, lineArgs.getTileSchedulerParallelism());\n\n        // test some valid value"}
{"magic_number_smell": "\n    private static final long[] CACHE_SIZES = {\n            0L,\n            16L * 1024 * 1024,\n            32L * 1024 * 1024,\n            64L * 1024 * 1024,\n            128L * 1024 * 1024,", "refactored_code": "    private static final int M = 1024 * 1024;\n\n    private static final long[] CACHE_SIZES = {\n            0L,\n            16L * M,\n            32L * M,\n            64L * M,\n            128L * M,"}
{"magic_number_smell": "    public void testMosaickingWithInvalidSourceSamples() throws IOException {\n        final Product product1Copy = ProductSubsetBuilder.createProductSubset(product1, null, \"P1\", \"Descr\");\n        final Band flagBand = product1Copy.addBand(\"flag\", ProductData.TYPE_INT32);\n        final BufferedImage flagImage = new BufferedImage(10, HEIGHT, DataBuffer.TYPE_INT);\n        int[] flagData = new int[10 * HEIGHT];\n        Arrays.fill(flagData, 1);\n        Arrays.fill(flagData, 0, 3 * 10, 0);", "refactored_code": "    private static final int WIDTH = 10;\n    public void testMosaickingWithInvalidSourceSamples() throws IOException {\n        final Product product1Copy = ProductSubsetBuilder.createProductSubset(product1, null, \"P1\", \"Descr\");\n        final Band flagBand = product1Copy.addBand(\"flag\", ProductData.TYPE_INT32);\n        final BufferedImage flagImage = new BufferedImage(WIDTH, HEIGHT, DataBuffer.TYPE_INT);\n        int[] flagData = new int[WIDTH * HEIGHT];\n        Arrays.fill(flagData, 1);\n        Arrays.fill(flagData, 0, 3 * WIDTH, 0);"}
{"magic_number_smell": "        @Override\n        public void initialize() {\n\n            targetProduct = new Product(\"name\", \"desc\", 4, RASTER_HEIGHT);\n            targetProduct.addBand(\"OperatorBand\", ProductData.TYPE_INT8);\n            targetProduct.addBand(\"ConstantBand\", ProductData.TYPE_INT8).setSourceImage(new BufferedImage(4, RASTER_HEIGHT, BufferedImage.TYPE_BYTE_INDEXED));\n            targetProduct.addBand(new VirtualBand(\"VirtualBand\", ProductData.TYPE_FLOAT32, 4, RASTER_HEIGHT, \"OperatorBand + ConstantBand\"));", "refactored_code": "    private static final int RASTER_WIDTH = 4;\n        @Override\n        public void initialize() {\n\n            targetProduct = new Product(\"name\", \"desc\", RASTER_WIDTH, RASTER_HEIGHT);\n            targetProduct.addBand(\"OperatorBand\", ProductData.TYPE_INT8);\n            targetProduct.addBand(\"ConstantBand\", ProductData.TYPE_INT8).setSourceImage(new BufferedImage(RASTER_WIDTH, RASTER_HEIGHT, BufferedImage.TYPE_BYTE_INDEXED));\n            targetProduct.addBand(new VirtualBand(\"VirtualBand\", ProductData.TYPE_FLOAT32, RASTER_WIDTH, RASTER_HEIGHT, \"OperatorBand + ConstantBand\"));"}
{"magic_number_smell": "     */\n    private static double calculateGain(final double lMin, final double lMax, final int formular) {\n\n        Guardian.assertTrue(\"formular == AFTER1990 || formular == 1\",\n                            formular == AFTER1990 || formular == 1);\n        double gain = 0;\n        if (formular == AFTER1990) {", "refactored_code": "    private static final int BEFORE1990 = 1;\n     */\n    private static double calculateGain(final double lMin, final double lMax, final int formular) {\n\n        Guardian.assertTrue(\"formular == AFTER1990 || formular == BEFORE1990\",\n                            formular == AFTER1990 || formular == BEFORE1990);\n        double gain = 0;\n        if (formular == AFTER1990) {"}
{"magic_number_smell": "                      final ProductData destBuffer,\n                      ProgressMonitor pm) throws IOException {\n\n        setStreamPos(sourceOffsetX, sourceOffsetY, 1);\n\n        final byte[] targetData = (byte[]) destBuffer.getElems();\n        final byte[] line = new byte[sourceWidth];", "refactored_code": "    private static final int pixelSize = 1;\n                      final ProductData destBuffer,\n                      ProgressMonitor pm) throws IOException {\n\n        setStreamPos(sourceOffsetX, sourceOffsetY, pixelSize);\n\n        final byte[] targetData = (byte[]) destBuffer.getElems();\n        final byte[] line = new byte[sourceWidth];"}
{"magic_number_smell": "     */\n    private static double[] calculateLmax(final double[] gain, final double[] Lmin, int formularUsed) {\n        Guardian.assertTrue(\"Lmin.length == gain.length\", Lmin.length == gain.length);\n        Guardian.assertTrue(\"formularUsed == AFTER1990 || formularUsed == 1\",\n                            formularUsed == AFTER1990 || formularUsed == 1);\n        double[] Lmax = new double[Lmin.length];\n        for (int i = 0; i < Lmax.length; i++) {", "refactored_code": "    private static final int BEFORE1990 = 1;\n     */\n    private static double[] calculateLmax(final double[] gain, final double[] Lmin, int formularUsed) {\n        Guardian.assertTrue(\"Lmin.length == gain.length\", Lmin.length == gain.length);\n        Guardian.assertTrue(\"formularUsed == AFTER1990 || formularUsed == BEFORE1990\",\n                            formularUsed == AFTER1990 || formularUsed == BEFORE1990);\n        double[] Lmax = new double[Lmin.length];\n        for (int i = 0; i < Lmax.length; i++) {"}
{"magic_number_smell": "    }\n\n    public final int getFormat() {\n        return LandsatConstants.CEOS;\n    }\n\n    private void init() throws", "refactored_code": "    private static final int FORMAT = LandsatConstants.CEOS;\n    }\n\n    public final int getFormat() {\n        return FORMAT;\n    }\n\n    private void init() throws"}
{"magic_number_smell": "        int size = Landsat5FASTConstants.RADIANCE_VALUE_DATA_SIZE;\n        final int offset = Landsat5FASTConstants.RADIOMETRIC_DATA_FASTB_OFFSET;\n\n        final int[] maxOffsets = generateMaxRadianceOffsets(size, offset, (number == 0) ? 7 : number);\n        final int[] minOffsets = generateMinRadianceOffsets(size, offset + size,\n                                                            (number == 0) ? 7 : number);\n", "refactored_code": "    private static final int DEFAULT_NUMBER = 7;\n        int size = Landsat5FASTConstants.RADIANCE_VALUE_DATA_SIZE;\n        final int offset = Landsat5FASTConstants.RADIOMETRIC_DATA_FASTB_OFFSET;\n\n        final int[] maxOffsets = generateMaxRadianceOffsets(size, offset, (number == 0) ? DEFAULT_NUMBER : number);\n        final int[] minOffsets = generateMinRadianceOffsets(size, offset + size,\n                                                            (number == 0) ? DEFAULT_NUMBER : number);\n"}
{"magic_number_smell": "        String attributeKey = String.format(\"%s_MULT_BAND_%s\", spectralInput, bandId);\n        MetadataElement radiometricRescalingElement = getMetaDataElementRoot().getElement(\"RADIOMETRIC_RESCALING\");\n        if (radiometricRescalingElement.getAttribute(attributeKey) == null) {\n            return 1.0;\n        }\n\n        final double scalingFactor = radiometricRescalingElement.getAttributeDouble(attributeKey);", "refactored_code": "    private static final double DEFAULT_SCALE_FACTOR = 1.0;\n        String attributeKey = String.format(\"%s_MULT_BAND_%s\", spectralInput, bandId);\n        MetadataElement radiometricRescalingElement = getMetaDataElementRoot().getElement(\"RADIOMETRIC_RESCALING\");\n        if (radiometricRescalingElement.getAttribute(attributeKey) == null) {\n            return DEFAULT_SCALE_FACTOR;\n        }\n\n        final double scalingFactor = radiometricRescalingElement.getAttributeDouble(attributeKey);"}
{"magic_number_smell": "    private float[] centralWavelenthRr;\n\n    public CentralWavelengthProvider() {\n        centralWavelenthRr = new float[925];\n    }\n\n    /**", "refactored_code": "    private static final int DETECTOR_LENGTH_RR = 925;\n    private float[] centralWavelenthRr;\n\n    public CentralWavelengthProvider() {\n        centralWavelenthRr = new float[DETECTOR_LENGTH_RR];\n    }\n\n    /**"}
{"magic_number_smell": "\n        cloudBand = new Band(CLOUD_PROP_BAND, ProductData.TYPE_INT16, sceneWidth, sceneHeight);\n        cloudBand.setDescription(\"Probability of clouds\");\n        cloudBand.setScalingFactor(0.0001f);\n        cloudBand.setNoDataValueUsed(true);\n        cloudBand.setNoDataValue(-1);\n        outputProduct.addBand(cloudBand);", "refactored_code": "    private static final float SCALING_FACTOR = 0.0001f;\n\n        cloudBand = new Band(CLOUD_PROP_BAND, ProductData.TYPE_INT16, sceneWidth, sceneHeight);\n        cloudBand.setDescription(\"Probability of clouds\");\n        cloudBand.setScalingFactor(SCALING_FACTOR);\n        cloudBand.setNoDataValueUsed(true);\n        cloudBand.setNoDataValue(-1);\n        outputProduct.addBand(cloudBand);"}
{"magic_number_smell": "        }\n        double value = sourceRadiance.getDouble();\n        boolean isValidDetectorIndex = detectorIndex >= 0;\n        if (doCalibration && isValidDetectorIndex && value < sourceRadiance.getNode().scale(65435.0)) {\n            value = calibrationAlgorithm.calibrate(bandIndex, detectorIndex, value);\n        }\n        if (doSmile) {", "refactored_code": "    private static final double RAW_SATURATION_THRESHOLD = 65435.0;\n        }\n        double value = sourceRadiance.getDouble();\n        boolean isValidDetectorIndex = detectorIndex >= 0;\n        if (doCalibration && isValidDetectorIndex && value < sourceRadiance.getNode().scale(RAW_SATURATION_THRESHOLD)) {\n            value = calibrationAlgorithm.calibrate(bandIndex, detectorIndex, value);\n        }\n        if (doSmile) {"}
{"magic_number_smell": "        this.resolution = resolution;\n        this.cntJD = cntJD;\n\n        oldGains = new double[15][resolution.getPixelCount()];\n        newGains = new double[15][resolution.getPixelCount()];\n\n        initGains(new MemoryCacheImageInputStream(sourceRacStream), oldGains);", "refactored_code": "    private static final int B = 15;\n        this.resolution = resolution;\n        this.cntJD = cntJD;\n\n        oldGains = new double[B][resolution.getPixelCount()];\n        newGains = new double[B][resolution.getPixelCount()];\n\n        initGains(new MemoryCacheImageInputStream(sourceRacStream), oldGains);"}
{"magic_number_smell": "        final String parsedDate = calibrationFileName.substring(14, 22);\n        final int date = Integer.parseInt(parsedDate);\n        if (isReduced) {\n            return getReprocessingVersion(date, 20050607, REPRO3_RR_START_DATE);\n        } else {\n            return getReprocessingVersion(date, REPRO2_FR_START_DATE, REPRO3_FR_START_DATE);\n        }", "refactored_code": "    private static final int REPRO2_RR_START_DATE = 20050607;\n        final String parsedDate = calibrationFileName.substring(14, 22);\n        final int date = Integer.parseInt(parsedDate);\n        if (isReduced) {\n            return getReprocessingVersion(date, REPRO2_RR_START_DATE, REPRO3_RR_START_DATE);\n        } else {\n            return getReprocessingVersion(date, REPRO2_FR_START_DATE, REPRO3_FR_START_DATE);\n        }"}
{"magic_number_smell": "        return new SmileCorrectionAuxdata(auxdataDir,\n                                          _CENTRAL_WAVELEN_FR_FILENAME,\n                                          _SUN_SPECTRAL_FLUX_FR_FILENAME,\n                                          3700,\n                                          EnvisatConstants.MERIS_L1B_NUM_SPECTRAL_BANDS);\n    }\n", "refactored_code": "    private static final int _NUM_DETECTORS_FR = 3700;\n        return new SmileCorrectionAuxdata(auxdataDir,\n                                          _CENTRAL_WAVELEN_FR_FILENAME,\n                                          _SUN_SPECTRAL_FLUX_FR_FILENAME,\n                                          _NUM_DETECTORS_FR,\n                                          EnvisatConstants.MERIS_L1B_NUM_SPECTRAL_BANDS);\n    }\n"}
{"magic_number_smell": "    public static Product createL1bProduct(String resolutionString) throws ParseException, java.text.ParseException {\n        boolean isFSG = resolutionString.equals(\"FSG\");\n        String productType = String.format(\"MER_%s_1P\", resolutionString);\n        Product product = new Product(\"MERIS-TEST-PRODUCT\", productType, 10, SCENE_HEIGHT);\n\n        final float[] MERIS_WAVELENGTHS = new float[]{\n                412.0f, 442.0f, 490.0f, 510.0f, 560.0f, 620.0f, 665.0f,", "refactored_code": "    public static final int SCENE_WIDTH = 10;\n    public static Product createL1bProduct(String resolutionString) throws ParseException, java.text.ParseException {\n        boolean isFSG = resolutionString.equals(\"FSG\");\n        String productType = String.format(\"MER_%s_1P\", resolutionString);\n        Product product = new Product(\"MERIS-TEST-PRODUCT\", productType, SCENE_WIDTH, SCENE_HEIGHT);\n\n        final float[] MERIS_WAVELENGTHS = new float[]{\n                412.0f, 442.0f, 490.0f, 510.0f, 560.0f, 620.0f, 665.0f,"}
{"magic_number_smell": "    @Test\n    public void validGainFR() throws IOException {\n        // Document PO-TN-MEL-GS-0003, Sect. 6.3.5\n        assertValidity(\"Gain_FR\", 15, new String[]{\"gain\"}, new int[]{5 * 740});\n    }\n\n    @Test", "refactored_code": "    private static final int FR_ELEMENT_COUNT = 5 * 740;\n    @Test\n    public void validGainFR() throws IOException {\n        // Document PO-TN-MEL-GS-0003, Sect. 6.3.5\n        assertValidity(\"Gain_FR\", 15, new String[]{\"gain\"}, new int[]{FR_ELEMENT_COUNT});\n    }\n\n    @Test"}
{"magic_number_smell": "                continue;\n            }\n            // parameter setup\n            us = Math.cos(sza[n] * Math.PI / 180.0);\n            invUs = 1.0 / us;\n            us2 = us * us;\n", "refactored_code": "    private static final double _cdr = Math.PI / 180.0;\n                continue;\n            }\n            // parameter setup\n            us = Math.cos(sza[n] * _cdr);\n            invUs = 1.0 / us;\n            us2 = us * us;\n"}
{"magic_number_smell": "        logger.info(\"Loading MERIS ADS\");\n\n        // sun zenith angle\n        String gridName = EnvisatConstants.MERIS_TIE_POINT_GRID_NAMES[6];\n        szaBand = product.getTiePointGrid(gridName);\n        checkForNull(gridName, szaBand);\n        logger.fine(LOG_MSG_LOADED + gridName);", "refactored_code": "    private static final int merisSzaIndex = 6;\n        logger.info(\"Loading MERIS ADS\");\n\n        // sun zenith angle\n        String gridName = EnvisatConstants.MERIS_TIE_POINT_GRID_NAMES[merisSzaIndex];\n        szaBand = product.getTiePointGrid(gridName);\n        checkForNull(gridName, szaBand);\n        logger.fine(LOG_MSG_LOADED + gridName);"}
{"magic_number_smell": "\n    public ISINGrid(int rowCount) {\n        this.rowCount = rowCount;\n        binSize = Math.PI * 6378.137 / rowCount;\n        deltaLat = 180.0 / rowCount;\n\n        /* effective size (km and deg) of a cell in latitudinal direction */", "refactored_code": "    public static final double RE = 6378.137;\n\n    public ISINGrid(int rowCount) {\n        this.rowCount = rowCount;\n        binSize = Math.PI * RE / rowCount;\n        deltaLat = 180.0 / rowCount;\n\n        /* effective size (km and deg) of a cell in latitudinal direction */"}
{"magic_number_smell": "     *\n     * @param scaleMethod the scale method as string\n     * @return the enum value either {@link #SCALE_LINEAR}, {@link #SCALE_EXPONENTIAL},\n     *         {@link #SCALE_POW_10}, {@link #SCALE_SLOPE_INTERCEPT} or {@link #0} if the given string\n     *         can not be converted.\n     */\n    public static int decodeScalingMethod(final String scaleMethod) {", "refactored_code": "    public static final int SCALE_UNKNOWN = 0;\n     *\n     * @param scaleMethod the scale method as string\n     * @return the enum value either {@link #SCALE_LINEAR}, {@link #SCALE_EXPONENTIAL},\n     *         {@link #SCALE_POW_10}, {@link #SCALE_SLOPE_INTERCEPT} or {@link #SCALE_UNKNOWN} if the given string\n     *         can not be converted.\n     */\n    public static int decodeScalingMethod(final String scaleMethod) {"}
{"magic_number_smell": "\n                        public double[] getParameterDefaultValues() {\n                            return new double[]{\n                                    6371007.181000, VAL, VAL, VAL, VAL, VAL, VAL, VAL, VAL, VAL, VAL, VAL, VAL\n                            };\n                        }\n", "refactored_code": "                        public static final double semiMajor = 6371007.181000;\n\n                        public double[] getParameterDefaultValues() {\n                            return new double[]{\n                                    semiMajor, VAL, VAL, VAL, VAL, VAL, VAL, VAL, VAL, VAL, VAL, VAL, VAL\n                            };\n                        }\n"}
{"magic_number_smell": "                            records[1], records[2], records[3], records[4],\n                            records[5], records[6], records[7], records[8],\n                            records[9], records[10], records[11]);\n                } else if (records.length == ModisProductDb.9) {\n                    description.addBand(\n                            records[1], records[2], records[3], records[4],\n                            records[5], records[6], records[7], records[8]);", "refactored_code": "    public static final int EXP_NUM_SDS_DEFAULT_RECORD = 9;\n                            records[1], records[2], records[3], records[4],\n                            records[5], records[6], records[7], records[8],\n                            records[9], records[10], records[11]);\n                } else if (records.length == ModisProductDb.EXP_NUM_SDS_DEFAULT_RECORD) {\n                    description.addBand(\n                            records[1], records[2], records[3], records[4],\n                            records[5], records[6], records[7], records[8]);"}
{"magic_number_smell": "                    ndviValue = (nir - red) / (nir + red);\n                    ndviFlagsValue = 0;\n                    if (Float.isNaN(ndviValue) || Float.isInfinite(ndviValue)) {\n                        ndviFlagsValue |= 1;\n                        ndviValue = 0.0f;\n                    }\n                    if (ndviValue < 0.0f) {", "refactored_code": "    public static final int NDVI_ARITHMETIC_FLAG_VALUE = 1;\n                    ndviValue = (nir - red) / (nir + red);\n                    ndviFlagsValue = 0;\n                    if (Float.isNaN(ndviValue) || Float.isInfinite(ndviValue)) {\n                        ndviFlagsValue |= NDVI_ARITHMETIC_FLAG_VALUE;\n                        ndviValue = 0.0f;\n                    }\n                    if (ndviValue < 0.0f) {"}
{"magic_number_smell": "        if (geoCoding == null && tpCoordinatesAtt != null) {\n            final String[] tpGridNames = tpCoordinatesAtt.getStringValue().split(\" \");\n            if (tpGridNames.length == 2\n                && p.containsTiePointGrid(tpGridNames[0])\n                && p.containsTiePointGrid(tpGridNames[LAT_INDEX])) {\n                final TiePointGrid lon = p.getTiePointGrid(tpGridNames[0]);\n                final TiePointGrid lat = p.getTiePointGrid(tpGridNames[LAT_INDEX]);", "refactored_code": "    private static final int LON_INDEX = 0;\n        if (geoCoding == null && tpCoordinatesAtt != null) {\n            final String[] tpGridNames = tpCoordinatesAtt.getStringValue().split(\" \");\n            if (tpGridNames.length == 2\n                && p.containsTiePointGrid(tpGridNames[LON_INDEX])\n                && p.containsTiePointGrid(tpGridNames[LAT_INDEX])) {\n                final TiePointGrid lon = p.getTiePointGrid(tpGridNames[LON_INDEX]);\n                final TiePointGrid lat = p.getTiePointGrid(tpGridNames[LAT_INDEX]);"}
{"magic_number_smell": "    }\n\n    private static Color createColor(Attribute colorAttribute) {\n        final int r = colorAttribute.getNumericValue(0).intValue();\n        final int g = colorAttribute.getNumericValue(INDEX_GREEN).intValue();\n        final int b = colorAttribute.getNumericValue(INDEX_BLUE).intValue();\n        final Color color;", "refactored_code": "    public static final int INDEX_RED = 0;\n    }\n\n    private static Color createColor(Attribute colorAttribute) {\n        final int r = colorAttribute.getNumericValue(INDEX_RED).intValue();\n        final int g = colorAttribute.getNumericValue(INDEX_GREEN).intValue();\n        final int b = colorAttribute.getNumericValue(INDEX_BLUE).intValue();\n        final Color color;"}
{"magic_number_smell": "            final Attribute sampleFrequencies = variable.findAttributeIgnoreCase(SAMPLE_FREQUENCIES);\n\n            if (statistics != null && sampleFrequencies != null && statistics.getLength() >= 2) {\n                final double min = statistics.getNumericValue(0).doubleValue();\n                final double max = statistics.getNumericValue(INDEX_SCALED_MAX).doubleValue();\n\n                final Number meanNumber = statistics.getNumericValue(INDEX_MEAN);", "refactored_code": "    public final int INDEX_SCALED_MIN = 0;\n            final Attribute sampleFrequencies = variable.findAttributeIgnoreCase(SAMPLE_FREQUENCIES);\n\n            if (statistics != null && sampleFrequencies != null && statistics.getLength() >= 2) {\n                final double min = statistics.getNumericValue(INDEX_SCALED_MIN).doubleValue();\n                final double max = statistics.getNumericValue(INDEX_SCALED_MAX).doubleValue();\n\n                final Number meanNumber = statistics.getNumericValue(INDEX_MEAN);"}
{"magic_number_smell": "        AffineTransform transform = new AffineTransform();\n        transform.translate(upperLeftLon, upperLeftLat);\n        transform.scale(pixelSizeX, -pixelSizeY);\n        transform.translate(0.0, 0.0);\n        Rectangle imageBounds = new Rectangle(p.getSceneRasterWidth(), p.getSceneRasterHeight());\n\n        if (projection.equals(\"GCTP_GEO\")) {", "refactored_code": "    private static final double PIXEL_CENTER = 0.0;\n        AffineTransform transform = new AffineTransform();\n        transform.translate(upperLeftLon, upperLeftLat);\n        transform.scale(pixelSizeX, -pixelSizeY);\n        transform.translate(PIXEL_CENTER, PIXEL_CENTER);\n        Rectangle imageBounds = new Rectangle(p.getSceneRasterWidth(), p.getSceneRasterHeight());\n\n        if (projection.equals(\"GCTP_GEO\")) {"}
{"magic_number_smell": "\n    @Override\n    public NVariable addVariable(String name, DataType dataType, boolean unsigned, Dimension tileSize, String dims) throws IOException {\n        return addVariable(name, dataType, unsigned, tileSize, dims, 6);\n    }\n\n    @Override", "refactored_code": "    private static final int DEFAULT_COMPRESSION = 6;\n\n    @Override\n    public NVariable addVariable(String name, DataType dataType, boolean unsigned, Dimension tileSize, String dims) throws IOException {\n        return addVariable(name, dataType, unsigned, tileSize, dims, DEFAULT_COMPRESSION);\n    }\n\n    @Override"}
{"magic_number_smell": "\n\n    public static NetcdfFile open(Object input) throws IOException {\n        byte[] buffer = new byte[8];\n        readMagicBytes(input, buffer);\n        IOServiceProvider spi = getIOSpi(buffer);\n        if (spi != null) {", "refactored_code": "    private static final int MAGIC_BUFFER_LENGTH = 8;\n\n\n    public static NetcdfFile open(Object input) throws IOException {\n        byte[] buffer = new byte[MAGIC_BUFFER_LENGTH];\n        readMagicBytes(input, buffer);\n        IOServiceProvider spi = getIOSpi(buffer);\n        if (spi != null) {"}
{"magic_number_smell": "    public void leafAdded(OpendapLeaf leaf, boolean hasNestedDatasets) {\n        VariableFilterPreparator filterPreparator = new VariableFilterPreparator(leaf);\n\n        if (filterPreparators.size() <= 10) {\n            filterPreparators.add(filterPreparator);\n            filterPreparator.execute();\n            filterCheckBox.setEnabled(false);", "refactored_code": "    private static final int MAX_THREAD_COUNT = 10;\n    public void leafAdded(OpendapLeaf leaf, boolean hasNestedDatasets) {\n        VariableFilterPreparator filterPreparator = new VariableFilterPreparator(leaf);\n\n        if (filterPreparators.size() <= MAX_THREAD_COUNT) {\n            filterPreparators.add(filterPreparator);\n            filterPreparator.execute();\n            filterCheckBox.setEnabled(false);"}
{"magic_number_smell": "        pm.setPostMessage(workDone + \" MB/\" + totalWorkString + \" MB (\" + OpendapUtils.format(percentage) + \"%)\");\n        String preMessageString = preMessageBuilder.toString();\n        pm.setTooltip(\"Downloading \" + preMessageString);\n        final String shortenedFilename = fileName.substring(0, Math.min(fileName.length(), 15));\n        pm.setPreMessage(\"Downloading \" + preMessageString.replace(fileName, shortenedFilename + \"...\"));\n    }\n", "refactored_code": "    private static final int MAX_FILENAME_DISPLAY_LENGTH = 15;\n        pm.setPostMessage(workDone + \" MB/\" + totalWorkString + \" MB (\" + OpendapUtils.format(percentage) + \"%)\");\n        String preMessageString = preMessageBuilder.toString();\n        pm.setTooltip(\"Downloading \" + preMessageString);\n        final String shortenedFilename = fileName.substring(0, Math.min(fileName.length(), MAX_FILENAME_DISPLAY_LENGTH));\n        pm.setPreMessage(\"Downloading \" + preMessageString.replace(fileName, shortenedFilename + \"...\"));\n    }\n"}
{"magic_number_smell": "    @Test\n    public void testCreateScatterPlotsForSingleProduct() throws Exception {\n        Measurement[] productMeasurements = new Measurement[]{\n                new Measurement(0, \"someName\", 0, -1, -1, null, null, new Object[]{7, 4.0}, true),\n                new Measurement(1, \"someOtherName\", 0, -1, -1, null, null, new Object[]{9, 3.0}, true)\n        };\n", "refactored_code": "    private static final long PRODUCT_ID_0 = 0;\n    @Test\n    public void testCreateScatterPlotsForSingleProduct() throws Exception {\n        Measurement[] productMeasurements = new Measurement[]{\n                new Measurement(0, \"someName\", PRODUCT_ID_0, -1, -1, null, null, new Object[]{7, 4.0}, true),\n                new Measurement(1, \"someOtherName\", PRODUCT_ID_0, -1, -1, null, null, new Object[]{9, 3.0}, true)\n        };\n"}
{"magic_number_smell": "\n    @Override\n    protected void configureSourceSamples(SampleConfigurer sampleConfigurer) throws OperatorException {\n        sampleConfigurer.defineSample(0, sourceQualityBandName);\n    }\n\n    @Override", "refactored_code": "    private static final int SRC_FLAG = 0;\n\n    @Override\n    protected void configureSourceSamples(SampleConfigurer sampleConfigurer) throws OperatorException {\n        sampleConfigurer.defineSample(SRC_FLAG, sourceQualityBandName);\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    protected void configureSourceSamples(SampleConfigurer sampleConfigurer) throws OperatorException {\n        sampleConfigurer.defineSample(0, ProbaVConstants.SM_BAND_NAME);\n    }\n\n    @Override", "refactored_code": "    private static final int SRC_FLAG = 0;\n\n    @Override\n    protected void configureSourceSamples(SampleConfigurer sampleConfigurer) throws OperatorException {\n        sampleConfigurer.defineSample(SRC_FLAG, ProbaVConstants.SM_BAND_NAME);\n    }\n\n    @Override"}
{"magic_number_smell": "        logger.info(\"\");\n        logger.info(INDENT + \"Number of test products: \" + testProductList.size());\n        logger.info(INDENT + \"Number of ReaderPlugIns: \" + testDefinitionList.size());\n        logger.info(INDENT + \"Logging only decode qualification tests >\" + 50 + \"ms\");\n        logger.info(\"\");\n\n        for (TestDefinition testDefinition : testDefinitionList) {", "refactored_code": "    private static final int DECODE_QUALI_LOG_THRESHOLD = 50;\n        logger.info(\"\");\n        logger.info(INDENT + \"Number of test products: \" + testProductList.size());\n        logger.info(INDENT + \"Number of ReaderPlugIns: \" + testDefinitionList.size());\n        logger.info(INDENT + \"Logging only decode qualification tests >\" + DECODE_QUALI_LOG_THRESHOLD + \"ms\");\n        logger.info(\"\");\n\n        for (TestDefinition testDefinition : testDefinitionList) {"}
{"magic_number_smell": "\n    @Before\n    public void setUp() throws Exception {\n        product = new Product(\"Hans Wurst\", \"T\", 10, HEIGHT);\n        product.setStartTime(ProductData.UTC.parse(\"23-AUG-1983 12:10:10\"));\n        product.setEndTime(ProductData.UTC.parse(\"23-AUG-1983 12:14:41\"));\n        product.setGeoCoding(new CrsGeoCoding(DefaultGeographicCRS.WGS84, 10, HEIGHT, 0.0, 0.0, 1.0, -1.0));", "refactored_code": "    private static final int WIDTH = 10;\n\n    @Before\n    public void setUp() throws Exception {\n        product = new Product(\"Hans Wurst\", \"T\", WIDTH, HEIGHT);\n        product.setStartTime(ProductData.UTC.parse(\"23-AUG-1983 12:10:10\"));\n        product.setEndTime(ProductData.UTC.parse(\"23-AUG-1983 12:14:41\"));\n        product.setGeoCoding(new CrsGeoCoding(DefaultGeographicCRS.WGS84, WIDTH, HEIGHT, 0.0, 0.0, 1.0, -1.0));"}
{"magic_number_smell": "                    AffineTransform transform = new AffineTransform();\n                    transform.translate(upperLeftLon, upperLeftLat);\n                    transform.scale(pixelSize, -pixelSize);\n                    transform.translate(-0.5, -0.5);\n                    return new CrsGeoCoding(DefaultGeographicCRS.WGS84, imageBounds, transform);\n                } catch (TransformException e) {\n                    // ?", "refactored_code": "    private static final double PIXEL_CENTER = 0.5;\n                    AffineTransform transform = new AffineTransform();\n                    transform.translate(upperLeftLon, upperLeftLat);\n                    transform.scale(pixelSize, -pixelSize);\n                    transform.translate(-PIXEL_CENTER, -PIXEL_CENTER);\n                    return new CrsGeoCoding(DefaultGeographicCRS.WGS84, imageBounds, transform);\n                } catch (TransformException e) {\n                    // ?"}
{"magic_number_smell": "                final Histogram histogram = histogramMap.get(regionName).getHistogram();\n                final HashMap<String, Number> stxMap = new HashMap<String, Number>();\n                if (histogram.getTotals()[0] == 0) {\n                    stxMap.put(MINIMUM, -999.0);\n                    stxMap.put(MAXIMUM, -999.0);\n                    stxMap.put(AVERAGE, -999.0);\n                    stxMap.put(SIGMA, -999.0);", "refactored_code": "    private static final double FILL_VALUE = -999.0;\n                final Histogram histogram = histogramMap.get(regionName).getHistogram();\n                final HashMap<String, Number> stxMap = new HashMap<String, Number>();\n                if (histogram.getTotals()[0] == 0) {\n                    stxMap.put(MINIMUM, FILL_VALUE);\n                    stxMap.put(MAXIMUM, FILL_VALUE);\n                    stxMap.put(AVERAGE, FILL_VALUE);\n                    stxMap.put(SIGMA, FILL_VALUE);"}
{"magic_number_smell": "        if (Util.getFeatureName(originalFeature).equals(regionId)) {\n            return statistics.get(algorithmName);\n        } else {\n            return -999.0;\n        }\n    }\n", "refactored_code": "    private static final double FILL_VALUE = -999.0;\n        if (Util.getFeatureName(originalFeature).equals(regionId)) {\n            return statistics.get(algorithmName);\n        } else {\n            return FILL_VALUE;\n        }\n    }\n"}
{"magic_number_smell": "    /**\n     * Returns the initial number of bin cells for the histogram, according to the given accuracy.\n     *\n     * @param accuracy a value in the range 0 ... {@link #6}\n     * @return the initial number of bin cells.\n     */\n    public static int computeBinCount(int accuracy) {", "refactored_code": "    public static final int MAX_ACCURACY = 6;\n    /**\n     * Returns the initial number of bin cells for the histogram, according to the given accuracy.\n     *\n     * @param accuracy a value in the range 0 ... {@link #MAX_ACCURACY}\n     * @return the initial number of bin cells.\n     */\n    public static int computeBinCount(int accuracy) {"}
{"magic_number_smell": "    }\n\n    private ProductData.UTC before(ProductData.UTC date) {\n        final long time = date.getAsDate().getTime() - 1000;\n        return ProductData.UTC.create(new Date(time), 0);\n    }\n", "refactored_code": "    private final int oneSecond = 1000; // == 1000 milliseconds\n    }\n\n    private ProductData.UTC before(ProductData.UTC date) {\n        final long time = date.getAsDate().getTime() - oneSecond;\n        return ProductData.UTC.create(new Date(time), 0);\n    }\n"}
{"magic_number_smell": "\n    @Override\n    public int getMinNumPoints() {\n        return 2;\n    }\n\n    /**", "refactored_code": "    private final int minNumPoints = 2;\n\n    @Override\n    public int getMinNumPoints() {\n        return minNumPoints;\n    }\n\n    /**"}
{"magic_number_smell": "\n    @Override\n    public int getMinNumPoints() {\n        return 3;\n    }\n\n    @Override", "refactored_code": "    private final int minNumPoints = 3;\n\n    @Override\n    public int getMinNumPoints() {\n        return minNumPoints;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getMinNumPoints() {\n        return 3;\n    }\n\n    /**", "refactored_code": "    private final int minNumPoints = 3;\n\n    @Override\n    public int getMinNumPoints() {\n        return minNumPoints;\n    }\n\n    /**"}
{"magic_number_smell": "\n    @Test\n    public void testThatGapsAreFilledWithoutStartAndStopReplacement() {\n        float[] input = new float[]{1, Float.NaN, Float.NaN, Float.NaN, 5};\n        float[] expected = new float[]{1, 2, 3, 4, 5};\n\n        GapFiller.fillGaps(input, LINEAR, startValueFallback, endValueFallback);", "refactored_code": "    private final float xx = Float.NaN;\n\n    @Test\n    public void testThatGapsAreFilledWithoutStartAndStopReplacement() {\n        float[] input = new float[]{1, xx, xx, xx, 5};\n        float[] expected = new float[]{1, 2, 3, 4, 5};\n\n        GapFiller.fillGaps(input, LINEAR, startValueFallback, endValueFallback);"}
{"magic_number_smell": "\n    @Test\n    public void testThatStartAndEndValueIsSetIfValueIsNAN() {\n        float[] input = {Float.NaN, Float.NaN, Float.NaN, Float.NaN, Float.NaN};\n        float[] expected = {2.2f, Float.NaN, Float.NaN, Float.NaN, 4.1f};\n\n        GapFiller.fillStartAndEndWithFallback(input, startValueFallback, endValueFallback);", "refactored_code": "    private final float xx = Float.NaN;\n\n    @Test\n    public void testThatStartAndEndValueIsSetIfValueIsNAN() {\n        float[] input = {xx, xx, xx, xx, xx};\n        float[] expected = {2.2f, xx, xx, xx, 4.1f};\n\n        GapFiller.fillStartAndEndWithFallback(input, startValueFallback, endValueFallback);"}
{"magic_number_smell": "public class TimeSeriesChangeEvent {\n\n    public static final int 1 = 1;\n    public static final int START_TIME_PROPERTY_NAME = 1 << 1;\n    public static final int END_TIME_PROPERTY_NAME = START_TIME_PROPERTY_NAME << 1;\n    public static final int PROPERTY_PRODUCT_LOCATIONS = END_TIME_PROPERTY_NAME << 1;\n    public static final int PROPERTY_EO_VARIABLE_SELECTION = PROPERTY_PRODUCT_LOCATIONS << 1;", "refactored_code": "    public static final int BAND_TO_BE_REMOVED = 1;\npublic class TimeSeriesChangeEvent {\n\n    public static final int BAND_TO_BE_REMOVED = 1;\n    public static final int START_TIME_PROPERTY_NAME = BAND_TO_BE_REMOVED << 1;\n    public static final int END_TIME_PROPERTY_NAME = START_TIME_PROPERTY_NAME << 1;\n    public static final int PROPERTY_PRODUCT_LOCATIONS = END_TIME_PROPERTY_NAME << 1;\n    public static final int PROPERTY_EO_VARIABLE_SELECTION = PROPERTY_PRODUCT_LOCATIONS << 1;"}
{"magic_number_smell": "            KmlFeature kmlFeature = createKmlFeature();\n            final FileOutputStream fileOutputStream = new FileOutputStream(output);\n            ZipOutputStream zipStream = new ZipOutputStream(\n                    new BufferedOutputStream(fileOutputStream, 5 * 1012 * 1024));\n            try {\n                final KmzExporter exporter = new KmzExporter();\n                exporter.export(kmlFeature, zipStream, pm);", "refactored_code": "        private static final int ONE_MEGABYTE = 1012 * 1024;\n            KmlFeature kmlFeature = createKmlFeature();\n            final FileOutputStream fileOutputStream = new FileOutputStream(output);\n            ZipOutputStream zipStream = new ZipOutputStream(\n                    new BufferedOutputStream(fileOutputStream, 5 * ONE_MEGABYTE));\n            try {\n                final KmzExporter exporter = new KmzExporter();\n                exporter.export(kmlFeature, zipStream, pm);"}
{"magic_number_smell": "        } else {\n            timeSeriesCount = displayAxisMapping.getRasterCount();\n            if (TimeSeriesType.CURSOR.equals(type)) {\n                collectionOffset = 0;\n            } else {\n                collectionOffset = PIN_COLLECTION_INDEX_OFFSET;\n            }", "refactored_code": "    private static final int CURSOR_COLLECTION_INDEX_OFFSET = 0;\n        } else {\n            timeSeriesCount = displayAxisMapping.getRasterCount();\n            if (TimeSeriesType.CURSOR.equals(type)) {\n                collectionOffset = CURSOR_COLLECTION_INDEX_OFFSET;\n            } else {\n                collectionOffset = PIN_COLLECTION_INDEX_OFFSET;\n            }"}
{"magic_number_smell": "public class TimeSeriesMatrixToolView extends AbstractToolView {\n\n    private static final int 3 = 3;\n    private static final int MATRIX_DEFAULT_VALUE = 3;\n    private static final int MATRIX_MAXIMUM = 15;\n    private static final int MATRIX_STEP_SIZE = 2;\n", "refactored_code": "    private static final int MATRIX_MINIMUM = 3;\npublic class TimeSeriesMatrixToolView extends AbstractToolView {\n\n    private static final int MATRIX_MINIMUM = 3;\n    private static final int MATRIX_DEFAULT_VALUE = MATRIX_MINIMUM;\n    private static final int MATRIX_MAXIMUM = 15;\n    private static final int MATRIX_STEP_SIZE = 2;\n"}
{"magic_number_smell": "\n    private static class InternalFrameProxy extends JComponent {\n\n        private static final long -9125146428340482204L = 1961531463465924691L;\n\n        private final JInternalFrame internalFrame;\n", "refactored_code": "    private static final long serialVersionUID = -9125146428340482204L;\n\n    private static class InternalFrameProxy extends JComponent {\n\n        private static final long serialVersionUID = 1961531463465924691L;\n\n        private final JInternalFrame internalFrame;\n"}
{"magic_number_smell": "    }\n\n    public Component getContent() {\n        return dockableFrame.getContentPane().getComponent(0);\n    }\n\n    public void setContent(Component component) {", "refactored_code": "    private static final int CONTENT_INDEX = 0;\n    }\n\n    public Component getContent() {\n        return dockableFrame.getContentPane().getComponent(CONTENT_INDEX);\n    }\n\n    public void setContent(Component component) {"}
{"magic_number_smell": "            }\n        }\n\n        if ((buttonMask & 0x0001) != 0) {\n            JButton button = new JButton(\"OK\");  /*I18N*/\n            button.setMnemonic('O');\n            button.setName(getQualifiedPropertyName(\"ok\"));", "refactored_code": "    public static final int ID_OK = 0x0001;\n            }\n        }\n\n        if ((buttonMask & ID_OK) != 0) {\n            JButton button = new JButton(\"OK\");  /*I18N*/\n            button.setMnemonic('O');\n            button.setName(getQualifiedPropertyName(\"ok\"));"}
{"magic_number_smell": "    private Point computeButtonLocation(int buttonIndex) {\n        final int xIndex = buttonIndex % numCols;\n        final int yIndex = buttonIndex / numCols;\n        int xLocation = (int) buttonArea.x + xIndex * (buttonDimension.width + 3);\n        int yLocation = (int) buttonArea.y + yIndex * (buttonDimension.height + 3);\n        return new Point(xLocation, yLocation);\n    }", "refactored_code": "    private static final int BUTTON_SPACING = 3;\n    private Point computeButtonLocation(int buttonIndex) {\n        final int xIndex = buttonIndex % numCols;\n        final int yIndex = buttonIndex / numCols;\n        int xLocation = (int) buttonArea.x + xIndex * (buttonDimension.width + BUTTON_SPACING);\n        int yLocation = (int) buttonArea.y + yIndex * (buttonDimension.height + BUTTON_SPACING);\n        return new Point(xLocation, yLocation);\n    }"}
{"magic_number_smell": "    public void loadCodeHistory() {\n        if (preferences != null) {\n            history.clear();\n            for (int index = 0; index < 100; index++) {\n                final String code = preferences.getPropertyString(CODE_HISTORY_PREFERENCES_PREFIX + index);\n                addToCodeHistory(code, false);\n            }", "refactored_code": "    private static final int CODE_HISTORY_MAX = 100;\n    public void loadCodeHistory() {\n        if (preferences != null) {\n            history.clear();\n            for (int index = 0; index < CODE_HISTORY_MAX; index++) {\n                final String code = preferences.getPropertyString(CODE_HISTORY_PREFERENCES_PREFIX + index);\n                addToCodeHistory(code, false);\n            }"}
{"magic_number_smell": "    public static final Dimension PREF_COMPONENT_SIZE\n            = new Dimension(PREF_HISTO_WIDTH + 2 * HOR_BORDER_SIZE,\n                            PREF_HISTO_HEIGHT + PALETTE_HEIGHT + SLIDER_HEIGHT / 2\n                            + 2 * HOR_BORDER_SIZE + 9);\n    public static final BasicStroke STROKE_1 = new BasicStroke(1.0f);\n    public static final BasicStroke STROKE_2 = new BasicStroke(2.0f);\n    public static final BasicStroke DASHED_STROKE = new BasicStroke(0.75F, BasicStroke.CAP_SQUARE,", "refactored_code": "    public static final int FONT_SIZE = 9;\n    public static final Dimension PREF_COMPONENT_SIZE\n            = new Dimension(PREF_HISTO_WIDTH + 2 * HOR_BORDER_SIZE,\n                            PREF_HISTO_HEIGHT + PALETTE_HEIGHT + SLIDER_HEIGHT / 2\n                            + 2 * HOR_BORDER_SIZE + FONT_SIZE);\n    public static final BasicStroke STROKE_1 = new BasicStroke(1.0f);\n    public static final BasicStroke STROKE_2 = new BasicStroke(2.0f);\n    public static final BasicStroke DASHED_STROKE = new BasicStroke(0.75F, BasicStroke.CAP_SQUARE,"}
{"magic_number_smell": "public class ModalDialog extends AbstractDialog {\n\n    public static final int ID_OK | ID_CANCEL = ID_OK | ID_CANCEL;\n    public static final int ID_OK_CANCEL_HELP = ID_OK | ID_CANCEL | ID_HELP;\n    public static final int ID_OK_APPLY_CANCEL = ID_OK | ID_APPLY | ID_CANCEL;\n    public static final int ID_OK_APPLY_CANCEL_HELP = ID_OK_APPLY_CANCEL | ID_HELP;\n    public static final int ID_YES_NO = ID_YES | ID_NO;", "refactored_code": "    public static final int ID_OK_CANCEL = ID_OK | ID_CANCEL;\npublic class ModalDialog extends AbstractDialog {\n\n    public static final int ID_OK_CANCEL = ID_OK | ID_CANCEL;\n    public static final int ID_OK_CANCEL_HELP = ID_OK_CANCEL | ID_HELP;\n    public static final int ID_OK_APPLY_CANCEL = ID_OK | ID_APPLY | ID_CANCEL;\n    public static final int ID_OK_APPLY_CANCEL_HELP = ID_OK_APPLY_CANCEL | ID_HELP;\n    public static final int ID_YES_NO = ID_YES | ID_NO;"}
{"magic_number_smell": "public class ModelessDialog extends AbstractDialog {\n\n    public static final int ID_APPLY | ID_CLOSE = ID_APPLY | ID_CLOSE;\n    public static final int ID_APPLY_CLOSE_HELP = ID_APPLY | ID_CLOSE | ID_HELP;\n\n    public ModelessDialog(Window parent, String title, int buttonMask, String helpID) {\n        this(parent, title, buttonMask, null, helpID);", "refactored_code": "    public static final int ID_APPLY_CLOSE = ID_APPLY | ID_CLOSE;\npublic class ModelessDialog extends AbstractDialog {\n\n    public static final int ID_APPLY_CLOSE = ID_APPLY | ID_CLOSE;\n    public static final int ID_APPLY_CLOSE_HELP = ID_APPLY_CLOSE | ID_HELP;\n\n    public ModelessDialog(Window parent, String title, int buttonMask, String helpID) {\n        this(parent, title, buttonMask, null, helpID);"}
{"magic_number_smell": "    private boolean selectCurrentRaster(String rasterName, JTable table) {\n        final TableModel model = table.getModel();\n        for (int i = 0; i < model.getRowCount(); i++) {\n            final String s = model.getValueAt(i, 0).toString();\n            if (rasterName.equals(s)) {\n                table.changeSelection(i, 0, false, false);\n                return true;", "refactored_code": "    private static final int _NAME_COLUMN = 0;\n    private boolean selectCurrentRaster(String rasterName, JTable table) {\n        final TableModel model = table.getModel();\n        for (int i = 0; i < model.getRowCount(); i++) {\n            final String s = model.getValueAt(i, _NAME_COLUMN).toString();\n            if (rasterName.equals(s)) {\n                table.changeSelection(i, _NAME_COLUMN, false, false);\n                return true;"}
{"magic_number_smell": "        }\n\n        private void updateRectanglesForDragCursor() {\n            Rectangle2D.Double rectangleForDragCursor = new Rectangle2D.Double(movableRectangle.getX() + 6,\n                                                                               movableRectangle.getY() + 6,\n                                                                               movableRectangle.getWidth() - 2 * 6,\n                                                                               movableRectangle.getHeight() - 2 * 6);", "refactored_code": "    private static final int OFFSET = 6;\n        }\n\n        private void updateRectanglesForDragCursor() {\n            Rectangle2D.Double rectangleForDragCursor = new Rectangle2D.Double(movableRectangle.getX() + OFFSET,\n                                                                               movableRectangle.getY() + OFFSET,\n                                                                               movableRectangle.getWidth() - 2 * OFFSET,\n                                                                               movableRectangle.getHeight() - 2 * OFFSET);"}
{"magic_number_smell": "        backButton.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                buttonID = 0x0001;\n                onBack();\n            }\n        });", "refactored_code": "    public static final int ID_BACK = 0x0001;\n        backButton.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                buttonID = ID_BACK;\n                onBack();\n            }\n        });"}
{"magic_number_smell": "        int dy2 = Math.abs(y2 - y);\n\n        sliderSectionX = -1;\n        if (dx1 <= 6) {\n            sliderSectionX = 0;   // left slider handle selected\n        } else if (dx2 <= 6) {\n            sliderSectionX = 2;   // right slider handle selected", "refactored_code": "    private static final int HANDLE_SIZE = 6;\n        int dy2 = Math.abs(y2 - y);\n\n        sliderSectionX = -1;\n        if (dx1 <= HANDLE_SIZE) {\n            sliderSectionX = 0;   // left slider handle selected\n        } else if (dx2 <= HANDLE_SIZE) {\n            sliderSectionX = 2;   // right slider handle selected"}
{"magic_number_smell": "\n    public static final Color HEADER_COLOR = new Color(82, 109, 165);\n    public static final int 6 = 6;\n    public static final EmptyBorder DIALOG_BORDER = new EmptyBorder(6, 6, 6, 6);\n    public static final Border SLIDER_BOX_BORDER = BorderFactory.createEtchedBorder(new Color(166, 202, 240),\n                                                                                    new Color(91, 135, 206));\n", "refactored_code": "    public static final int INSET_SIZE = 6;\n\n    public static final Color HEADER_COLOR = new Color(82, 109, 165);\n    public static final int INSET_SIZE = 6;\n    public static final EmptyBorder DIALOG_BORDER = new EmptyBorder(INSET_SIZE, INSET_SIZE, INSET_SIZE, INSET_SIZE);\n    public static final Border SLIDER_BOX_BORDER = BorderFactory.createEtchedBorder(new Color(166, 202, 240),\n                                                                                    new Color(91, 135, 206));\n"}
{"magic_number_smell": "        init(null,\n             null,\n             FIT_PRODUCT_SIZE_DEFAULT,\n             1,\n             sourcePropertySet);\n    }\n", "refactored_code": "    private static final int REFERENCE_PIXEL_DEFAULT = 1;\n        init(null,\n             null,\n             FIT_PRODUCT_SIZE_DEFAULT,\n             REFERENCE_PIXEL_DEFAULT,\n             sourcePropertySet);\n    }\n"}
{"magic_number_smell": "//        String text = \"\";\n//        boolean elemEnum = isNumericAttribute(attributeRef.getAttribute())\n//                && attributeRef.getAttribute().getNumDataElems() > 1;\n//        if (column == 0) {\n//            if (elemEnum) {\n//                text = attributeRef.getAttribute().getName() + \".\" + (attributeRef.getElementIndex() + 1);\n//            } else {", "refactored_code": "    public static final int NAME_COL_INDEX = 0;\n//        String text = \"\";\n//        boolean elemEnum = isNumericAttribute(attributeRef.getAttribute())\n//                && attributeRef.getAttribute().getNumDataElems() > 1;\n//        if (column == NAME_COL_INDEX) {\n//            if (elemEnum) {\n//                text = attributeRef.getAttribute().getName() + \".\" + (attributeRef.getElementIndex() + 1);\n//            } else {"}
{"magic_number_smell": "            imageScrollPane = new JScrollPane(imageCanvas);\n            imageScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n            imageScrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);\n            imageScrollPane.getViewport().setExtentSize(new Dimension(148, 2 * 148));\n            setComponentName(imageScrollPane, \"ImageScrollPane\");\n\n", "refactored_code": "    private static final int MAX_THUMBNAIL_WIDTH = 148;\n            imageScrollPane = new JScrollPane(imageCanvas);\n            imageScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n            imageScrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);\n            imageScrollPane.getViewport().setExtentSize(new Dimension(MAX_THUMBNAIL_WIDTH, 2 * MAX_THUMBNAIL_WIDTH));\n            setComponentName(imageScrollPane, \"ImageScrollPane\");\n\n"}
{"magic_number_smell": "            style.setSymbolName(\"circle\");\n            style.setStrokeColor(STROKE_COLOR);\n            style.setStrokeWidth(STROKE_WIDTH);\n            style.setStrokeOpacity(0.8);\n            style.setFillColor(FILL_COLOR);\n            style.setFillOpacity(FILL_OPACITY);\n            strokePaint = style.getStrokePaint();", "refactored_code": "        public static final double STROKE_OPACITY = 0.8;\n            style.setSymbolName(\"circle\");\n            style.setStrokeColor(STROKE_COLOR);\n            style.setStrokeWidth(STROKE_WIDTH);\n            style.setStrokeOpacity(STROKE_OPACITY);\n            style.setFillColor(FILL_COLOR);\n            style.setFillOpacity(FILL_OPACITY);\n            strokePaint = style.getStrokePaint();"}
{"magic_number_smell": "        sortableTableModel.setColumnSortable(spectrumStrokeIndex, false);\n        sortableTableModel.setColumnSortable(spectrumShapeIndex, false);\n\n        final TableColumn selectionColumn = spectraTable.getColumnModel().getColumn(0);\n        final TristateCheckBoxCellEditor tristateCheckBoxCellEditor = new TristateCheckBoxCellEditor();\n        selectionColumn.setCellEditor(tristateCheckBoxCellEditor);\n        selectionColumn.setCellRenderer(new TriStateRenderer());", "refactored_code": "    private static final int spectrumSelectedIndex = 0;\n        sortableTableModel.setColumnSortable(spectrumStrokeIndex, false);\n        sortableTableModel.setColumnSortable(spectrumShapeIndex, false);\n\n        final TableColumn selectionColumn = spectraTable.getColumnModel().getColumn(spectrumSelectedIndex);\n        final TristateCheckBoxCellEditor tristateCheckBoxCellEditor = new TristateCheckBoxCellEditor();\n        selectionColumn.setCellEditor(tristateCheckBoxCellEditor);\n        selectionColumn.setCellRenderer(new TriStateRenderer());"}
{"magic_number_smell": "    }\n\n    public static Shape getScaledShape(int shapeIndex, int scaleGrade) {\n        if(scaleGrade == 3) {\n            return shapes[shapeIndex];\n        } else {\n            final Path2D.Double convertedShape = new Path2D.Double(shapes[shapeIndex]);", "refactored_code": "    public static final int DEFAULT_SCALE_GRADE = 3;\n    }\n\n    public static Shape getScaledShape(int shapeIndex, int scaleGrade) {\n        if(scaleGrade == DEFAULT_SCALE_GRADE) {\n            return shapes[shapeIndex];\n        } else {\n            final Path2D.Double convertedShape = new Path2D.Double(shapes[shapeIndex]);"}
{"magic_number_smell": "        }\n\n        Icon icon = button.getIcon();\n        int minWidth = 16;\n        int minHeight = 16;\n        if (icon != null) {\n            button.setText(null);", "refactored_code": "    private static final int BUTTON_MIN_SIZE = 16;\n        }\n\n        Icon icon = button.getIcon();\n        int minWidth = BUTTON_MIN_SIZE;\n        int minHeight = BUTTON_MIN_SIZE;\n        if (icon != null) {\n            button.setText(null);"}
{"magic_number_smell": "\n    @Test\n    public void testValidBounds() {\n        assertTrue(RegionSelectableWorldMapPane.geoBoundsAreValid(75.0, validEastBound, validSouthBound, validWestBound));\n    }\n\n    @Test", "refactored_code": "    private final double validNorthBound = 75.0;\n\n    @Test\n    public void testValidBounds() {\n        assertTrue(RegionSelectableWorldMapPane.geoBoundsAreValid(validNorthBound, validEastBound, validSouthBound, validWestBound));\n    }\n\n    @Test"}
{"magic_number_smell": "\n        final JScrollPane pane = new JScrollPane(conditionsTable);\n        pane.setName(labelName);\n        pane.setPreferredSize(new Dimension(520, 80));\n\n        return pane;\n    }", "refactored_code": "    private static final int PREFERRED_TABLE_WIDTH = 520;\n\n        final JScrollPane pane = new JScrollPane(conditionsTable);\n        pane.setName(labelName);\n        pane.setPreferredSize(new Dimension(PREFERRED_TABLE_WIDTH, 80));\n\n        return pane;\n    }"}
{"magic_number_smell": "    public static JPanel createPageUIContentPane(JPanel pane) {\n        JPanel contentPane = GridBagUtils.createPanel();\n        final GridBagConstraints gbc = GridBagUtils.createConstraints(\"fill=HORIZONTAL,anchor=NORTHWEST\");\n        gbc.insets.top = 15;\n        gbc.weightx = 1;\n        gbc.weighty = 0;\n        contentPane.add(pane, gbc);", "refactored_code": "    private static final int _PAGE_INSET_TOP = 15;\n    public static JPanel createPageUIContentPane(JPanel pane) {\n        JPanel contentPane = GridBagUtils.createPanel();\n        final GridBagConstraints gbc = GridBagUtils.createConstraints(\"fill=HORIZONTAL,anchor=NORTHWEST\");\n        gbc.insets.top = _PAGE_INSET_TOP;\n        gbc.weightx = 1;\n        gbc.weighty = 0;\n        contentPane.add(pane, gbc);"}
{"magic_number_smell": "            _latBox = new JComboBox<>(_bandNames);\n            doPreSelection(_lonBox, \"lon\");\n            doPreSelection(_latBox, \"lat\");\n            _radiusSpinner = UIUtils.createSpinner(6, _minRadius, _maxRadius,\n                                                   _smallRadiusStep, _bigRadiusStep, \"#0\");\n            _validMaskField = new JTextField(createDefaultValidMask(_product));\n            _validMaskField.setCaretPosition(0);", "refactored_code": "        private final int _defaultRadius = 6;\n            _latBox = new JComboBox<>(_bandNames);\n            doPreSelection(_lonBox, \"lon\");\n            doPreSelection(_latBox, \"lat\");\n            _radiusSpinner = UIUtils.createSpinner(_defaultRadius, _minRadius, _maxRadius,\n                                                   _smallRadiusStep, _bigRadiusStep, \"#0\");\n            _validMaskField = new JTextField(createDefaultValidMask(_product));\n            _validMaskField.setCaretPosition(0);"}
{"magic_number_smell": "        bindingContext.bind(\"tolerance\", toleranceField);\n        toleranceField.setText(String.valueOf(interactor.getModel().getTolerance()));\n\n        toleranceSlider = new JSlider(0, 1000);\n        toleranceSlider.setSnapToTicks(false);\n        toleranceSlider.setPaintTicks(false);\n        toleranceSlider.setPaintLabels(false);", "refactored_code": "    public static final int TOLERANCE_SLIDER_RESOLUTION = 1000;\n        bindingContext.bind(\"tolerance\", toleranceField);\n        toleranceField.setText(String.valueOf(interactor.getModel().getTolerance()));\n\n        toleranceSlider = new JSlider(0, TOLERANCE_SLIDER_RESOLUTION);\n        toleranceSlider.setSnapToTicks(false);\n        toleranceSlider.setPaintTicks(false);\n        toleranceSlider.setPaintLabels(false);"}
{"magic_number_smell": "        }\n\n        private void adjustCellSize(JTable table, int row, int column, String[] values) {\n            setRowHeight(table, row, 100);\n\n            final int lablesLength = getMaxStringLength(propertyLables, getFontMetrics(getFont()));\n            int columnIndex = 0;", "refactored_code": "        private static final int ROW_HEIGHT = 100;\n        }\n\n        private void adjustCellSize(JTable table, int row, int column, String[] values) {\n            setRowHeight(table, row, ROW_HEIGHT);\n\n            final int lablesLength = getMaxStringLength(propertyLables, getFontMetrics(getFont()));\n            int columnIndex = 0;"}
{"magic_number_smell": "\n    private static void addDefaultDataProvider(final RepositoryManager repositoryManager) {\n        repositoryManager.addDataProvider(new ProductPropertiesProvider());\n        repositoryManager.addDataProvider(new QuicklookProvider(150));\n        repositoryManager.addDataProvider(new WorldMapProvider(false));\n    }\n", "refactored_code": "    private static final int quickLookWidth = 150;\n\n    private static void addDefaultDataProvider(final RepositoryManager repositoryManager) {\n        repositoryManager.addDataProvider(new ProductPropertiesProvider());\n        repositoryManager.addDataProvider(new QuicklookProvider(quickLookWidth));\n        repositoryManager.addDataProvider(new WorldMapProvider(false));\n    }\n"}
{"magic_number_smell": "//                    fireTableDataChanged();\n                    _tableHeader.repaint();\n                }\n                // Cycle the sorting states through {NOT_SORTED, ASCENDING, -1} or\n                // {NOT_SORTED, -1, ASCENDING} depending on whether shift is pressed.\n                direction = direction + (e.isShiftDown() ? -1 : 1);\n                direction = (direction + 4) % 3 - 1; // signed mod, returning {-1, 0, 1}", "refactored_code": "    private static final int DESCENDING = -1;\n//                    fireTableDataChanged();\n                    _tableHeader.repaint();\n                }\n                // Cycle the sorting states through {NOT_SORTED, ASCENDING, DESCENDING} or\n                // {NOT_SORTED, DESCENDING, ASCENDING} depending on whether shift is pressed.\n                direction = direction + (e.isShiftDown() ? -1 : 1);\n                direction = (direction + 4) % 3 - 1; // signed mod, returning {-1, 0, 1}"}
{"magic_number_smell": "            gbc.weightx = 1;\n            add(paramGeophysUnit.getEditor().getComponent(), gbc);\n\n            gbc.insets.top += 10;\n            gbc.gridy++;\n            gbc.weightx = 0;\n            add(paramNoDataValueUsed.getEditor().getComponent(), gbc);", "refactored_code": "        private static final int GROUP_GAP = 10;\n            gbc.weightx = 1;\n            add(paramGeophysUnit.getEditor().getComponent(), gbc);\n\n            gbc.insets.top += GROUP_GAP;\n            gbc.gridy++;\n            gbc.weightx = 0;\n            add(paramNoDataValueUsed.getEditor().getComponent(), gbc);"}
{"magic_number_smell": "     */\n    public void start(VisatApp visatApp) {\n        if (!isVersionCheckQuestionSuppressed() || isVersionCheckEnabled()) {\n            final Timer timer = new Timer(5 * 1000, new ActionListener() {\n                public void actionPerformed(ActionEvent e) {\n                    runAuto();\n                }", "refactored_code": "    private static final int DELAY_MILLIS = 5 * 1000;  // 5 seconds delay\n     */\n    public void start(VisatApp visatApp) {\n        if (!isVersionCheckQuestionSuppressed() || isVersionCheckEnabled()) {\n            final Timer timer = new Timer(DELAY_MILLIS, new ActionListener() {\n                public void actionPerformed(ActionEvent e) {\n                    runAuto();\n                }"}
{"magic_number_smell": "     * Mask management mode, with visibility control.\n     */\n    private static final int[] IDXS_MODE_MANAG_BAND = {\n            0,\n            IDX_NAME,\n            IDX_TYPE,\n            IDX_COLOR,", "refactored_code": "    private static final int IDX_VISIBILITY = 0;\n     * Mask management mode, with visibility control.\n     */\n    private static final int[] IDXS_MODE_MANAG_BAND = {\n            IDX_VISIBILITY,\n            IDX_NAME,\n            IDX_TYPE,\n            IDX_COLOR,"}
{"magic_number_smell": "        graphics.setXORMode(Color.BLACK);\n        graphics.draw(pixelViewRect);\n\n        if (pixelViewRect.getBounds2D().getWidth() < 20) {\n            drawCrosshair(graphics, i2vTransform, centerPixel, pixelViewRect);\n        }\n    }", "refactored_code": "    private static final int MAX_CROSSHAIR_SIZE = 20;\n        graphics.setXORMode(Color.BLACK);\n        graphics.draw(pixelViewRect);\n\n        if (pixelViewRect.getBounds2D().getWidth() < MAX_CROSSHAIR_SIZE) {\n            drawCrosshair(graphics, i2vTransform, centerPixel, pixelViewRect);\n        }\n    }"}
{"magic_number_smell": "\n        zoomSlider = new JSlider(JSlider.HORIZONTAL);\n        zoomSlider.setValue(0);\n        zoomSlider.setMinimum(-100);\n        zoomSlider.setMaximum(MAX_SLIDER_VALUE);\n        zoomSlider.setPaintTicks(false);\n        zoomSlider.setPaintLabels(false);", "refactored_code": "    private static final int MIN_SLIDER_VALUE = -100;\n\n        zoomSlider = new JSlider(JSlider.HORIZONTAL);\n        zoomSlider.setValue(0);\n        zoomSlider.setMinimum(MIN_SLIDER_VALUE);\n        zoomSlider.setMaximum(MAX_SLIDER_VALUE);\n        zoomSlider.setPaintTicks(false);\n        zoomSlider.setPaintLabels(false);"}
{"magic_number_smell": "        }\n\n        switch (columnIndex) {\n            case 0:\n                return x;\n            case yIndex:\n                return y;", "refactored_code": "    private final int xIndex = 0;\n        }\n\n        switch (columnIndex) {\n            case xIndex:\n                return x;\n            case yIndex:\n                return y;"}
{"magic_number_smell": "        bindingContext.addPropertyChangeListener(roiMaskActionEnabler);\n        RefreshActionEnabler rangeControlActionEnabler = new RefreshActionEnabler(refreshButton, PROPERTY_NAME_MIN, PROPERTY_NAME_AUTO_MIN_MAX,\n                                                                                  PROPERTY_NAME_MAX);\n        axisRangeControls[0].getBindingContext().addPropertyChangeListener(rangeControlActionEnabler);\n        axisRangeControls[Y_VAR].getBindingContext().addPropertyChangeListener(rangeControlActionEnabler);\n    }\n", "refactored_code": "    private static final int X_VAR = 0;\n        bindingContext.addPropertyChangeListener(roiMaskActionEnabler);\n        RefreshActionEnabler rangeControlActionEnabler = new RefreshActionEnabler(refreshButton, PROPERTY_NAME_MIN, PROPERTY_NAME_AUTO_MIN_MAX,\n                                                                                  PROPERTY_NAME_MAX);\n        axisRangeControls[X_VAR].getBindingContext().addPropertyChangeListener(rangeControlActionEnabler);\n        axisRangeControls[Y_VAR].getBindingContext().addPropertyChangeListener(rangeControlActionEnabler);\n    }\n"}
{"magic_number_smell": "        updateXAxis();\n        if (xAxisRangeControl.isAutoMinMax()) {\n            xAxisRangeControl.getBindingContext().getPropertySet().getDescriptor(\"min\").setDefaultValue(\n                    0.0);\n            xAxisRangeControl.getBindingContext().getPropertySet().getDescriptor(\"max\").setDefaultValue(\n                    HISTO_MAX_DEFAULT);\n        }", "refactored_code": "    private static final double HISTO_MIN_DEFAULT = 0.0;\n        updateXAxis();\n        if (xAxisRangeControl.isAutoMinMax()) {\n            xAxisRangeControl.getBindingContext().getPropertySet().getDescriptor(\"min\").setDefaultValue(\n                    HISTO_MIN_DEFAULT);\n            xAxisRangeControl.getBindingContext().getPropertySet().getDescriptor(\"max\").setDefaultValue(\n                    HISTO_MAX_DEFAULT);\n        }"}
{"magic_number_smell": "            getTable().setModel(tableModel);\n            getTable().setAutoResizeMode(JTable.AUTO_RESIZE_OFF);\n        }\n        getTable().getColumnModel().getColumn(0).setPreferredWidth(widthOfNameColumn);\n        getTable().getColumnModel().getColumn(0).setMinWidth(widthOfNameColumn);\n        getTable().getColumnModel().getColumn(0).setMaxWidth(widthOfNameColumn);\n        getTable().getColumnModel().getColumn(index_of_value_and_unit_column).setPreferredWidth(widthOfValueAndUnitColumn);", "refactored_code": "    private static final int index_of_name_column = 0;\n            getTable().setModel(tableModel);\n            getTable().setAutoResizeMode(JTable.AUTO_RESIZE_OFF);\n        }\n        getTable().getColumnModel().getColumn(index_of_name_column).setPreferredWidth(widthOfNameColumn);\n        getTable().getColumnModel().getColumn(index_of_name_column).setMinWidth(widthOfNameColumn);\n        getTable().getColumnModel().getColumn(index_of_name_column).setMaxWidth(widthOfNameColumn);\n        getTable().getColumnModel().getColumn(index_of_value_and_unit_column).setPreferredWidth(widthOfValueAndUnitColumn);"}
{"magic_number_smell": "        final XYPlot plot = getPlot();\n        plot.setAxisOffset(new RectangleInsets(5, 5, 5, 5));\n        plot.setNoDataMessage(NO_DATA_MESSAGE);\n        plot.setDataset(0, acceptableDeviationDataset);\n        plot.setDataset(REGRESSION_DSINDEX, regressionDataset);\n        plot.setDataset(SCATTERPOINTS_DSINDEX, scatterpointsDataset);\n", "refactored_code": "    private final int CONFIDENCE_DSINDEX = 0;\n        final XYPlot plot = getPlot();\n        plot.setAxisOffset(new RectangleInsets(5, 5, 5, 5));\n        plot.setNoDataMessage(NO_DATA_MESSAGE);\n        plot.setDataset(CONFIDENCE_DSINDEX, acceptableDeviationDataset);\n        plot.setDataset(REGRESSION_DSINDEX, regressionDataset);\n        plot.setDataset(SCATTERPOINTS_DSINDEX, scatterpointsDataset);\n"}
{"magic_number_smell": "            final PropertyDescriptor borderShownDescriptor = new PropertyDescriptor(\"borderShown\", Boolean.class);\n            borderShownDescriptor.setDefaultValue(DEFAULT_BORDER_SHOWN);\n            final PropertyDescriptor borderWidthDescriptor = new PropertyDescriptor(\"borderWidth\", Double.class);\n            borderWidthDescriptor.setDefaultValue(1.0);\n            final PropertyDescriptor borderColorDescriptor = new PropertyDescriptor(\"borderColor\", Color.class);\n            borderColorDescriptor.setDefaultValue(DEFAULT_BORDER_COLOR);\n", "refactored_code": "        private static final double DEFAULT_BORDER_WIDTH = 1.0;\n            final PropertyDescriptor borderShownDescriptor = new PropertyDescriptor(\"borderShown\", Boolean.class);\n            borderShownDescriptor.setDefaultValue(DEFAULT_BORDER_SHOWN);\n            final PropertyDescriptor borderWidthDescriptor = new PropertyDescriptor(\"borderWidth\", Double.class);\n            borderWidthDescriptor.setDefaultValue(DEFAULT_BORDER_WIDTH);\n            final PropertyDescriptor borderColorDescriptor = new PropertyDescriptor(\"borderColor\", Color.class);\n            borderColorDescriptor.setDefaultValue(DEFAULT_BORDER_COLOR);\n"}
{"magic_number_smell": "    public Component getOptionsPanel() {\n        JPanel panel = new JPanel(new GridLayout(0, 1, 6, 6));\n        JButton selectAllButton = new JButton(new AbstractAction(\"Select All\") {\n            private static final long -5982509597978327419L = 6274336964872530476L;\n\n            public void actionPerformed(ActionEvent e) {\n                _list.getCheckBoxListSelectionModel().addSelectionInterval(0, _list.getModel().getSize() - 1);", "refactored_code": "    private static final long serialVersionUID = -5982509597978327419L;\n    public Component getOptionsPanel() {\n        JPanel panel = new JPanel(new GridLayout(0, 1, 6, 6));\n        JButton selectAllButton = new JButton(new AbstractAction(\"Select All\") {\n            private static final long serialVersionUID = 6274336964872530476L;\n\n            public void actionPerformed(ActionEvent e) {\n                _list.getCheckBoxListSelectionModel().addSelectionInterval(0, _list.getModel().getSize() - 1);"}
{"magic_number_smell": "        final float lat3 = geoPos.lat;\n        float lon3 = geoPos.lon;\n\n        final float epsL = 0.04F;\n        final float latMin = min(lat0, min(lat1, min(lat2, lat3))) - epsL;\n        final float latMax = max(lat0, max(lat1, max(lat2, lat3))) + epsL;\n        float lonMin;", "refactored_code": "    private static final float EPS = 0.04F; // used by quad-tree search\n        final float lat3 = geoPos.lat;\n        float lon3 = geoPos.lon;\n\n        final float epsL = EPS;\n        final float latMin = min(lat0, min(lat1, min(lat2, lat3))) - epsL;\n        final float latMax = max(lat0, max(lat1, max(lat2, lat3))) + epsL;\n        float lonMin;"}
{"magic_number_smell": "     * @since 4.2\n     */\n    public NetworkInterface egressInterface() throws EgressResolutionException {\n        return fromDefaultMechanisms(5000);\n    }\n\n    /**", "refactored_code": "    public static final int DEFAULT_TIMEOUT_MILLIS = 5000;\n     * @since 4.2\n     */\n    public NetworkInterface egressInterface() throws EgressResolutionException {\n        return fromDefaultMechanisms(DEFAULT_TIMEOUT_MILLIS);\n    }\n\n    /**"}
{"magic_number_smell": "             * loop if clock happened to be moved backwards by, say,\n             * an hour...\n             */\n            if (++counter > 50) {\n                break;\n            }\n        } while (System.currentTimeMillis() < waitUntil);", "refactored_code": "    private static final int MAX_WAIT_COUNT = 50;\n             * loop if clock happened to be moved backwards by, say,\n             * an hour...\n             */\n            if (++counter > MAX_WAIT_COUNT) {\n                break;\n            }\n        } while (System.currentTimeMillis() < waitUntil);"}
{"magic_number_smell": "    protected final UUIDClock _clock;\n\n    private long _lastTimestamp = -1;\n    private final byte[] _lastEntropy  = new byte[10];\n    private final Lock lock = new ReentrantLock();\n\n    /*", "refactored_code": "    private static final int ENTROPY_BYTE_LENGTH = 10;\n    protected final UUIDClock _clock;\n\n    private long _lastTimestamp = -1;\n    private final byte[] _lastEntropy  = new byte[ENTROPY_BYTE_LENGTH];\n    private final Lock lock = new ReentrantLock();\n\n    /*"}
{"magic_number_smell": "     */\n    protected final UUIDClock _clock;\n\n    private final byte[] _lastEntropy  = new byte[10];\n    private final Lock lock = new ReentrantLock();\n\n    /*", "refactored_code": "    private static final int ENTROPY_BYTE_LENGTH = 10;\n     */\n    protected final UUIDClock _clock;\n\n    private final byte[] _lastEntropy  = new byte[ENTROPY_BYTE_LENGTH];\n    private final Lock lock = new ReentrantLock();\n\n    /*"}
{"magic_number_smell": "    \n            case 0:\n                msg = \"JDK, random\";\n                testJDK(uuids, 250);\n                break;\n\n            case 1:", "refactored_code": "    private static final int ROUNDS = 250;\n    \n            case 0:\n                msg = \"JDK, random\";\n                testJDK(uuids, ROUNDS);\n                break;\n\n            case 1:"}
{"magic_number_smell": "        \"00:00:00:00:00:00\";\n    private static final long NULL_ETHERNET_ADDRESS_LONG = 0x0000000000000000L;\n    private static final byte[] NULL_ETHERNET_ADDRESS_BYTE_ARRAY =\n        new byte[6];\n    //private static final int[] NULL_ETHERNET_ADDRESS_INT_ARRAY = new int[6];\n    private static final EthernetAddress NULL_ETHERNET_ADDRESS =\n        new EthernetAddress(0L);", "refactored_code": "    private static final int ETHERNET_ADDRESS_ARRAY_LENGTH = 6;\n        \"00:00:00:00:00:00\";\n    private static final long NULL_ETHERNET_ADDRESS_LONG = 0x0000000000000000L;\n    private static final byte[] NULL_ETHERNET_ADDRESS_BYTE_ARRAY =\n        new byte[ETHERNET_ADDRESS_ARRAY_LENGTH];\n    //private static final int[] NULL_ETHERNET_ADDRESS_INT_ARRAY = new int[ETHERNET_ADDRESS_ARRAY_LENGTH];\n    private static final EthernetAddress NULL_ETHERNET_ADDRESS =\n        new EthernetAddress(0L);"}
{"magic_number_smell": "        // generally good behavior, so we'll create a bunch to make sure the\n        // general patterns are observed\n        EthernetAddress ethernet_address_array[] =\n            new EthernetAddress[9000];\n        \n        // now create the array of uuids\n        Random rnd = new Random(123L);", "refactored_code": "    private static final int SIZE_OF_TEST_ARRAY = 9000;\n        // generally good behavior, so we'll create a bunch to make sure the\n        // general patterns are observed\n        EthernetAddress ethernet_address_array[] =\n            new EthernetAddress[SIZE_OF_TEST_ARRAY];\n        \n        // now create the array of uuids\n        Random rnd = new Random(123L);"}
{"magic_number_smell": "    private static final String NULL_UUID_STRING =\n        \"00000000-0000-0000-0000-000000000000\";\n    private static final byte[] NULL_UUID_BYTE_ARRAY =\n        new byte[16];\n    \n    private static final String UPPER_CASE_VALID_UUID_STRING =\n        \"4D687664-3A1E-4F30-ACC1-87F59306D30C\";", "refactored_code": "    private static final int UUID_BYTE_ARRAY_LENGTH = 16;\n    private static final String NULL_UUID_STRING =\n        \"00000000-0000-0000-0000-000000000000\";\n    private static final byte[] NULL_UUID_BYTE_ARRAY =\n        new byte[UUID_BYTE_ARRAY_LENGTH];\n    \n    private static final String UPPER_CASE_VALID_UUID_STRING =\n        \"4D687664-3A1E-4F30-ACC1-87F59306D30C\";"}
{"magic_number_smell": "        UUIDTimer uuid_timer = new UUIDTimer(secure_random, null);\n        \n        // we'll do a simple run to see that it at least produces output\n        byte[] test_array = new byte[10];\n        uuid_timer.getAndSetTimestamp(test_array);\n        // check that it's not all null\n        assertArrayNotEqual(test_array,", "refactored_code": "    private static final int UUID_TIMER_ARRAY_LENGTH = 10;\n        UUIDTimer uuid_timer = new UUIDTimer(secure_random, null);\n        \n        // we'll do a simple run to see that it at least produces output\n        byte[] test_array = new byte[UUID_TIMER_ARRAY_LENGTH];\n        uuid_timer.getAndSetTimestamp(test_array);\n        // check that it's not all null\n        assertArrayNotEqual(test_array,"}
{"magic_number_smell": "    private ABGestureListener mGestureListener;\n    public boolean mInterceptClicks=false;\n    private static final int 1 = 1;\n    private int mOrientation = 1;\n    private SwipeListener mSwipeListener;\n    \n\tpublic ActionButton(Context context) {", "refactored_code": "    private static final int ORIENTATION_HORIZONTAL = 1;\n    private ABGestureListener mGestureListener;\n    public boolean mInterceptClicks=false;\n    private static final int ORIENTATION_HORIZONTAL = 1;\n    private int mOrientation = ORIENTATION_HORIZONTAL;\n    private SwipeListener mSwipeListener;\n    \n\tpublic ActionButton(Context context) {"}
{"magic_number_smell": "        Resources res = launcher.getResources();\n        \n        mItems.add(new ListItem(res, R.string.group_shortcuts,\n                R.drawable.ic_launcher_shortcut, 0));\n\n        mItems.add(new ListItem(res, R.string.pref_label_shirtcuts,\n                R.drawable.ic_launcher_shortcut, ITEM_ANYCUT));", "refactored_code": "    public static final int ITEM_SHORTCUT = 0;\n        Resources res = launcher.getResources();\n        \n        mItems.add(new ListItem(res, R.string.group_shortcuts,\n                R.drawable.ic_launcher_shortcut, ITEM_SHORTCUT));\n\n        mItems.add(new ListItem(res, R.string.pref_label_shirtcuts,\n                R.drawable.ic_launcher_shortcut, ITEM_ANYCUT));"}
{"magic_number_smell": "    private int mTotalScreens;\n    private int mCurrentHolder=1;\n    private int mPageWidth;\n    private final int mDefaultScreen=0;\n    private int mNextScreen = INVALID_SCREEN;\n    private Scroller mScroller;\n    private VelocityTracker mVelocityTracker;", "refactored_code": "    private static final int DEFAULT_SCREEN = 0;\n    private int mTotalScreens;\n    private int mCurrentHolder=1;\n    private int mPageWidth;\n    private final int mDefaultScreen=DEFAULT_SCREEN;\n    private int mNextScreen = INVALID_SCREEN;\n    private Scroller mScroller;\n    private VelocityTracker mVelocityTracker;"}
{"magic_number_smell": "        //mPaint.setColor(getContext().getResources().getColor(R.color.bubble_dark_background));\n        mPaint.setColor(color);\n        final float scale = getContext().getResources().getDisplayMetrics().density;\n        //mCornerRadius = 8.0f * scale;\n        mCornerRadius = mCustomCornerRadius * scale;\n        mPaddingH = PADDING_H * scale;\n        //noinspection PointlessArithmeticExpression", "refactored_code": "    //private static final float CORNER_RADIUS = 8.0f;\n        //mPaint.setColor(getContext().getResources().getColor(R.color.bubble_dark_background));\n        mPaint.setColor(color);\n        final float scale = getContext().getResources().getDisplayMetrics().density;\n        //mCornerRadius = CORNER_RADIUS * scale;\n        mCornerRadius = mCustomCornerRadius * scale;\n        mPaddingH = PADDING_H * scale;\n        //noinspection PointlessArithmeticExpression"}
{"magic_number_smell": "\n            void release() {\n                synchronized (sLock) {\n                    if (sAcquiredCount < 100) {\n                        sAcquiredCount++;\n                        next = sRoot;\n                        sRoot = this;", "refactored_code": "            private static final int POOL_LIMIT = 100;\n\n            void release() {\n                synchronized (sLock) {\n                    if (sAcquiredCount < POOL_LIMIT) {\n                        sAcquiredCount++;\n                        next = sRoot;\n                        sRoot = this;"}
{"magic_number_smell": "                        }\n                    } else {\n                        float angle = (float)java.lang.Math.atan2(y, x);\n                        // need to turn angle [-3.1415926f ... 3.1415926f] into unit [0....1]\n                        float unit = angle/(2*3.1415926f);\n                        if (unit < 0) {\n                            unit += 1;", "refactored_code": "        private static final float PI = 3.1415926f;\n                        }\n                    } else {\n                        float angle = (float)java.lang.Math.atan2(y, x);\n                        // need to turn angle [-PI ... PI] into unit [0....1]\n                        float unit = angle/(2*PI);\n                        if (unit < 0) {\n                            unit += 1;"}
{"magic_number_smell": "     *        content up.\n     */\n    public void startScroll(int startX, int startY, int dx, int dy) {\n        startScroll(startX, startY, dx, dy, 250);\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_DURATION = 250;\n     *        content up.\n     */\n    public void startScroll(int startX, int startY, int dx, int dy) {\n        startScroll(startX, startY, dx, dy, DEFAULT_DURATION);\n    }\n\n    /**"}
{"magic_number_smell": "\t\t\t\t\tbtPickIcon.setImageBitmap(mBitmap);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tUri photoUri = data.getData();\n\t\t\t\ttry {\n\t\t\t\t\tInputStream is = getContentResolver().openInputStream(", "refactored_code": "\tprivate static final int PICK_CUSTOM_ICON=1;\n\t\t\t\t\tbtPickIcon.setImageBitmap(mBitmap);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PICK_CUSTOM_ICON:\n\t\t\t\tUri photoUri = data.getData();\n\t\t\t\ttry {\n\t\t\t\t\tInputStream is = getContentResolver().openInputStream("}
{"magic_number_smell": "        super(context, attrs, defStyle);\n\n        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.DeleteZone, defStyle, 0);\n        mOrientation = a.getInt(R.styleable.DeleteZone_direction, 1);\n        a.recycle();\n    }\n", "refactored_code": "    private static final int ORIENTATION_HORIZONTAL = 1;\n        super(context, attrs, defStyle);\n\n        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.DeleteZone, defStyle, 0);\n        mOrientation = a.getInt(R.styleable.DeleteZone_direction, ORIENTATION_HORIZONTAL);\n        a.recycle();\n    }\n"}
{"magic_number_smell": "\t}\n\tprivate void initIndicator(Context context){\n\t\tswitch(mIndicatorType){\n\t\tcase 1:\n\t\t\tmIndicator=new PreviewPager(context);\n\t\t\t((PreviewPager) mIndicator).setTotalItems(mItems);\n\t\t\t((PreviewPager) mIndicator).setCurrentItem(mCurrent);", "refactored_code": "\tpublic static final int INDICATOR_TYPE_PAGER=1;\n\t}\n\tprivate void initIndicator(Context context){\n\t\tswitch(mIndicatorType){\n\t\tcase INDICATOR_TYPE_PAGER:\n\t\t\tmIndicator=new PreviewPager(context);\n\t\t\t((PreviewPager) mIndicator).setTotalItems(mItems);\n\t\t\t((PreviewPager) mIndicator).setCurrentItem(mCurrent);"}
{"magic_number_smell": "    private int mContentId;\n    private View mHandle;\n    private int mState=CLOSED;\n    private int mPosition=0;\n    private boolean mFirstLayout=true;\n    //private View mContent;\n    private GestureDetector mGestureDetector;", "refactored_code": "    public static final int TOP=0;\n    private int mContentId;\n    private View mHandle;\n    private int mState=CLOSED;\n    private int mPosition=TOP;\n    private boolean mFirstLayout=true;\n    //private View mContent;\n    private GestureDetector mGestureDetector;"}
{"magic_number_smell": "\n            if ((x < SCROLL_ZONE) || (x > getWidth() - SCROLL_ZONE)) {\n                mScrollState = SCROLL_WAITING_IN_ZONE;\n                postDelayed(mScrollRunnable, 600);\n            } else {\n                mScrollState = SCROLL_OUTSIDE_ZONE;\n            }", "refactored_code": "    private static final int SCROLL_DELAY = 600;\n\n            if ((x < SCROLL_ZONE) || (x > getWidth() - SCROLL_ZONE)) {\n                mScrollState = SCROLL_WAITING_IN_ZONE;\n                postDelayed(mScrollRunnable, SCROLL_DELAY);\n            } else {\n                mScrollState = SCROLL_OUTSIDE_ZONE;\n            }"}
{"magic_number_smell": "\n            if (mListener != null) {\n            \tint Direction = FLING_NONE;\n\t            if (velocityX > 500) {\n\t            \tDirection = FLING_LEFT;\n\t            } else if (velocityX < -500) {\n\t            \tDirection = FLING_RIGHT;", "refactored_code": "    private static final int SNAP_VELOCITY = 500;\n\n            if (mListener != null) {\n            \tint Direction = FLING_NONE;\n\t            if (velocityX > SNAP_VELOCITY) {\n\t            \tDirection = FLING_LEFT;\n\t            } else if (velocityX < -SNAP_VELOCITY) {\n\t            \tDirection = FLING_RIGHT;"}
{"magic_number_smell": "    private static final int 1 = 1;\n\n    private Launcher mLauncher;\n    private int mOrientation = 1;\n\n    public HandleView(Context context) {\n        super(context);", "refactored_code": "    private static final int ORIENTATION_HORIZONTAL = 1;\n    private static final int ORIENTATION_HORIZONTAL = 1;\n\n    private Launcher mLauncher;\n    private int mOrientation = ORIENTATION_HORIZONTAL;\n\n    public HandleView(Context context) {\n        super(context);"}
{"magic_number_smell": "        if (mDesktopLocked && mSavedInstanceState == null) return false;\n\n        super.onCreateOptionsMenu(menu);\n        menu.add(1, MENU_ADD, 0, R.string.menu_add)\n                .setIcon(android.R.drawable.ic_menu_add)\n                .setAlphabeticShortcut('A');\n        menu.add(MENU_GROUP_NORMAL, MENU_WALLPAPER_SETTINGS, 0, R.string.menu_wallpaper)", "refactored_code": "    private static final int MENU_GROUP_ADD = 1;\n        if (mDesktopLocked && mSavedInstanceState == null) return false;\n\n        super.onCreateOptionsMenu(menu);\n        menu.add(MENU_GROUP_ADD, MENU_ADD, 0, R.string.menu_add)\n                .setIcon(android.R.drawable.ic_menu_add)\n                .setAlphabeticShortcut('A');\n        menu.add(MENU_GROUP_NORMAL, MENU_WALLPAPER_SETTINGS, 0, R.string.menu_wallpaper)"}
{"magic_number_smell": "            mPendingCheckForLongPress = new CheckForLongPress();\n        }\n        mPendingCheckForLongPress.rememberWindowAttachCount();\n        postDelayed(mPendingCheckForLongPress, 700);\n    }\n\n    @Override", "refactored_code": "    private static final long WIDGET_LONG_CLICK_TIMEOUT = 700;\n            mPendingCheckForLongPress = new CheckForLongPress();\n        }\n        mPendingCheckForLongPress.rememberWindowAttachCount();\n        postDelayed(mPendingCheckForLongPress, WIDGET_LONG_CLICK_TIMEOUT);\n    }\n\n    @Override"}
{"magic_number_smell": "        ChangeNotifier(ApplicationsAdapter applicationList, boolean first) {\n            mApplicationList = applicationList;\n            mFirst = first;\n            mBuffer = new ArrayList<ApplicationInfo>(4);\n        }\n\n        public void run() {", "refactored_code": "    private static final int UI_NOTIFICATION_RATE = 4;\n        ChangeNotifier(ApplicationsAdapter applicationList, boolean first) {\n            mApplicationList = applicationList;\n            mFirst = first;\n            mBuffer = new ArrayList<ApplicationInfo>(UI_NOTIFICATION_RATE);\n        }\n\n        public void run() {"}
{"magic_number_smell": "        private final AppWidgetHost mAppWidgetHost;\n\n        DatabaseHelper(Context context) {\n            super(context, DATABASE_NAME, null, 5);\n            mContext = context;\n            mAppWidgetHost = new AppWidgetHost(context, Launcher.APPWIDGET_HOST_ID);\n        }", "refactored_code": "    private static final int DATABASE_VERSION = 5;\n        private final AppWidgetHost mAppWidgetHost;\n\n        DatabaseHelper(Context context) {\n            super(context, DATABASE_NAME, null, DATABASE_VERSION);\n            mContext = context;\n            mAppWidgetHost = new AppWidgetHost(context, Launcher.APPWIDGET_HOST_ID);\n        }"}
{"magic_number_smell": "    private static final int VERTICAL=0;\n\tprivate Launcher mLauncher;\n    //private View mDeleteView;\n    private int mOrientation=1;\n    private int mNumCells=4;\n    private int mCellWidth=20;\n    private int mCellHeight=20;", "refactored_code": "    private static final int HORIZONTAL=1;\n    private static final int VERTICAL=0;\n\tprivate Launcher mLauncher;\n    //private View mDeleteView;\n    private int mOrientation=HORIZONTAL;\n    private int mNumCells=4;\n    private int mCellWidth=20;\n    private int mCellHeight=20;"}
{"magic_number_smell": "\n\t            Intent pickIntent = new Intent(Intent.ACTION_PICK_ACTIVITY);\n\t            pickIntent.putExtra(Intent.EXTRA_INTENT, mainIntent);\n\t            startActivityForResult(pickIntent,0);\n\t\t\t}\n\t\t}\n\t\telse if(preference.getKey().equals(\"homeBinding\"))", "refactored_code": "    private static final int REQUEST_SWIPE_DOWN_APP_CHOOSER = 0;\n\n\t            Intent pickIntent = new Intent(Intent.ACTION_PICK_ACTIVITY);\n\t            pickIntent.putExtra(Intent.EXTRA_INTENT, mainIntent);\n\t            startActivityForResult(pickIntent,REQUEST_SWIPE_DOWN_APP_CHOOSER);\n\t\t\t}\n\t\t}\n\t\telse if(preference.getKey().equals(\"homeBinding\"))"}
{"magic_number_smell": "        }\n\n        mStart = DEFAULT_MIN;\n        mEnd = 200;\n    }\n\n    @Override", "refactored_code": "    private static final int DEFAULT_MAX = 200;\n        }\n\n        mStart = DEFAULT_MIN;\n        mEnd = DEFAULT_MAX;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    private int getAnimationDuration() {\n        return (int) (getWidgetTop() / 1.0f);\n    }\n\n    /**", "refactored_code": "    private static final float ANIMATION_VELOCITY = 1.0f;\n    }\n\n    private int getAnimationDuration() {\n        return (int) (getWidgetTop() / ANIMATION_VELOCITY);\n    }\n\n    /**"}
{"magic_number_smell": "    private boolean mFirstLayout = true;\n\n    //private int mCurrentScreen;\n    private int mNextScreen = -1;\n    private CustomScroller mScroller;\n    private final FlingGesture mFlingGesture;\n", "refactored_code": "    private static final int INVALID_SCREEN = -1;\n    private boolean mFirstLayout = true;\n\n    //private int mCurrentScreen;\n    private int mNextScreen = INVALID_SCREEN;\n    private CustomScroller mScroller;\n    private final FlingGesture mFlingGesture;\n"}
{"magic_number_smell": "        Resources res = launcher.getResources();\n\n        mItems.add(new ListItem(res, R.string.AppGroupAdd, APP_GROUP_ADD));\n\t\tmItems.add(new ListItem(res, R.string.AppGroupAll, -1));\n\n\t\tfor(AppCatalogueFilters.Catalogue itm : AppCatalogueFilters.getInstance().getAllGroups()) {\n\t\t\taddListItem(res, itm);", "refactored_code": "    public static final int APP_GROUP_ALL = -1;\n        Resources res = launcher.getResources();\n\n        mItems.add(new ListItem(res, R.string.AppGroupAdd, APP_GROUP_ADD));\n\t\tmItems.add(new ListItem(res, R.string.AppGroupAll, APP_GROUP_ALL));\n\n\t\tfor(AppCatalogueFilters.Catalogue itm : AppCatalogueFilters.getInstance().getAllGroups()) {\n\t\t\taddListItem(res, itm);"}
{"magic_number_smell": "\n\t\t@Override\n\t    protected int getTag() {\n\t    \treturn 99;\n\t    }\n\n\t\t@Override", "refactored_code": "\t\tpublic static final int tag = 99;\n\n\t\t@Override\n\t    protected int getTag() {\n\t    \treturn tag;\n\t    }\n\n\t\t@Override"}
{"magic_number_smell": "\n\t@Override\n\tpublic int getViewTypeCount() {\n\t\treturn 1;\n\t}\n\n\t@Override", "refactored_code": "\tprivate static final int NB_MAX_VIEWS_TYPES = 1;\n\n\t@Override\n\tpublic int getViewTypeCount() {\n\t\treturn NB_MAX_VIEWS_TYPES;\n\t}\n\n\t@Override"}
{"magic_number_smell": "\t\t\t\tanchorAtThisPositionAndScale();\n\t\t\t\t// Need to let events settle before moving things, to help with event noise on touchdown\n\t\t\t\tmSettleStartTime = mCurrPt.getEventTime();\n\t\t\t\tmSettleEndTime = mSettleStartTime + 20;\n\n\t\t\t} else {\n\t\t\t\t// Point 1 is still down and point 2 did not change state, just do single-point drag to new location", "refactored_code": "\tprivate static final long EVENT_SETTLE_TIME_INTERVAL = 20;\n\t\t\t\tanchorAtThisPositionAndScale();\n\t\t\t\t// Need to let events settle before moving things, to help with event noise on touchdown\n\t\t\t\tmSettleStartTime = mCurrPt.getEventTime();\n\t\t\t\tmSettleEndTime = mSettleStartTime + EVENT_SETTLE_TIME_INTERVAL;\n\n\t\t\t} else {\n\t\t\t\t// Point 1 is still down and point 2 did not change state, just do single-point drag to new location"}
{"magic_number_smell": "        }\n    }\n\n    final private ArrayList<String> traces = TRACE ? new ArrayList<String>(Integer.getInteger(\"org.fusesource.hawtdispatch.BaseRetained.MAX_TRACES\", 100)+1) : null;\n    final private void trace(final String action, final     int counter) {\n        if( traces.size() < Integer.getInteger(\"org.fusesource.hawtdispatch.BaseRetained.MAX_TRACES\", 100)) {\n            Exception ex = new Exception() {", "refactored_code": "    private static final int MAX_TRACES = Integer.getInteger(\"org.fusesource.hawtdispatch.BaseRetained.MAX_TRACES\", 100);\n        }\n    }\n\n    final private ArrayList<String> traces = TRACE ? new ArrayList<String>(MAX_TRACES+1) : null;\n    final private void trace(final String action, final     int counter) {\n        if( traces.size() < MAX_TRACES) {\n            Exception ex = new Exception() {"}
{"magic_number_smell": "        private static final long waiterOffset =\n            objectFieldOffset(UNSAFE, \"waiter\", Node.class);\n\n        private static final long -3223113410248163686L = -3375979862319811754L;\n    }\n\n    /** head of the queue; null until first enqueue */", "refactored_code": "    private static final long serialVersionUID = -3223113410248163686L;\n        private static final long waiterOffset =\n            objectFieldOffset(UNSAFE, \"waiter\", Node.class);\n\n        private static final long serialVersionUID = -3375979862319811754L;\n    }\n\n    /** head of the queue; null until first enqueue */"}
{"magic_number_smell": "    private volatile int workerCounts;\n\n    private static int totalCountOf(int s)           { return s >>> 16;  }\n    private static int runningCountOf(int s)         { return s & 0xffff; }\n    private static int workerCountsFor(int t, int r) { return (t << 16) + r; }\n\n    /**", "refactored_code": "    private static final int  shortMask = 0xffff;\n    private volatile int workerCounts;\n\n    private static int totalCountOf(int s)           { return s >>> 16;  }\n    private static int runningCountOf(int s)         { return s & shortMask; }\n    private static int workerCountsFor(int t, int r) { return (t << 16) + r; }\n\n    /**"}
{"magic_number_smell": "    protected void onStart() {\n        // Allocate while starting to improve chances of thread-local\n        // isolation\n        queue = new Task[1 << 13];\n        // Initial value of seed need not be especially random but\n        // should differ across threads and must be nonzero\n        int p = poolIndex + 1;", "refactored_code": "    private static final int INITIAL_QUEUE_CAPACITY = 1 << 13;\n    protected void onStart() {\n        // Allocate while starting to improve chances of thread-local\n        // isolation\n        queue = new Task[INITIAL_QUEUE_CAPACITY];\n        // Initial value of seed need not be especially random but\n        // should differ across threads and must be nonzero\n        int p = poolIndex + 1;"}
{"magic_number_smell": "    this._writer.open();\n    \n    if(newFile) {\n      this._version = 0;\n      this._arrayLwmScn = 0;\n      this._arrayHwmScn = 0;\n      this._arrayLength = initialLength;", "refactored_code": "  public static final long STORAGE_VERSION  = 0;\n    this._writer.open();\n    \n    if(newFile) {\n      this._version = STORAGE_VERSION;\n      this._arrayLwmScn = 0;\n      this._arrayHwmScn = 0;\n      this._arrayLength = initialLength;"}
{"magic_number_smell": "    private final static int LIVE_SEGMENT = 1;\n\n    private final int 4 = 4;\n    private final int _segmentDataStart = 1 << 4;\n    private final int _bytesPerSegment = 1 << 4;\n    private final int _bytesPerSection = _bytesPerSegment >> 1;\n    private final int _initialSegmentCount = 100;", "refactored_code": "    private final int _segmentDataShift = 4;\n    private final static int LIVE_SEGMENT = 1;\n\n    private final int _segmentDataShift = 4;\n    private final int _segmentDataStart = 1 << _segmentDataShift;\n    private final int _bytesPerSegment = 1 << _segmentDataShift;\n    private final int _bytesPerSection = _bytesPerSegment >> 1;\n    private final int _initialSegmentCount = 100;"}
{"magic_number_smell": "    private volatile int _nextIndexCount = 0;\n    private final int 10000 = 10000;\n    private final NextIndexLookup _nextIndexLookup = new NextIndexLookup();\n    private final LinkedBlockingQueue<Integer> _nextIndexQueue = new LinkedBlockingQueue<Integer>(10000);\n    private ExecutorService _nextIndexExecutor = null;\n    \n    /**", "refactored_code": "    private final int _nextIndexQueueCapacity = 10000;\n    private volatile int _nextIndexCount = 0;\n    private final int _nextIndexQueueCapacity = 10000;\n    private final NextIndexLookup _nextIndexLookup = new NextIndexLookup();\n    private final LinkedBlockingQueue<Integer> _nextIndexQueue = new LinkedBlockingQueue<Integer>(_nextIndexQueueCapacity);\n    private ExecutorService _nextIndexExecutor = null;\n    \n    /**"}
{"magic_number_smell": "        long hash = FNV_BASIS;\n        for(int i = 0; i < key.length; i++) {\n            hash *= FNV_PRIME;\n            hash &= 0xffffffffL;\n            hash ^= 0xFF & key[i];\n        }\n        ", "refactored_code": "    public static final long BITS_MASK = 0xffffffffL; \n        long hash = FNV_BASIS;\n        for(int i = 0; i < key.length; i++) {\n            hash *= FNV_PRIME;\n            hash &= BITS_MASK;\n            hash ^= 0xFF & key[i];\n        }\n        "}
{"magic_number_smell": "    \n    @Override\n    public final long hash(byte[] key) {\n        long hash = 0xcbf29ce484222325L;\n        for(int i = 0; i < key.length; i++) {\n            hash *= FNV_PRIME;\n            hash ^= 0xFF & key[i];", "refactored_code": "    public static final long FNV_BASIS = 0xcbf29ce484222325L;\n    \n    @Override\n    public final long hash(byte[] key) {\n        long hash = FNV_BASIS;\n        for(int i = 0; i < key.length; i++) {\n            hash *= FNV_PRIME;\n            hash ^= 0xFF & key[i];"}
{"magic_number_smell": "     * Do addition and turn into 4 bytes. \n     */\n    private long add(long val, long add) {\n        return (val + add) & 0xFFFFFFFFL;\n    }\n    \n    /**", "refactored_code": "    private static final long MAX_VALUE = 0xFFFFFFFFL; \n     * Do addition and turn into 4 bytes. \n     */\n    private long add(long val, long add) {\n        return (val + add) & MAX_VALUE;\n    }\n    \n    /**"}
{"magic_number_smell": "\tprivate static final MathLib[] functions;\n\tstatic {\n\t\tnames = new String[NUM_FUNCTIONS];\n\t\tnames[0] = \"abs\";\n\t\tnames[ACOS] = \"acos\";\n\t\tnames[ASIN] = \"asin\";\n\t\tnames[ATAN] = \"atan\";", "refactored_code": "\tprivate static final int ABS = 0;\n\tprivate static final MathLib[] functions;\n\tstatic {\n\t\tnames = new String[NUM_FUNCTIONS];\n\t\tnames[ABS] = \"abs\";\n\t\tnames[ACOS] = \"acos\";\n\t\tnames[ASIN] = \"asin\";\n\t\tnames[ATAN] = \"atan\";"}
{"magic_number_smell": "\t\n\tpublic int call(LuaCallFrame callFrame, int nArguments) {\n\t\tswitch (index) {\n\t\tcase 0: return loadstring(callFrame, nArguments);\n\t\tcase LOADSTREAM: return loadstream(callFrame, nArguments);\n\t\t}\n\t\treturn 0;", "refactored_code": "\tprivate static final int LOADSTRING = 0;\n\t\n\tpublic int call(LuaCallFrame callFrame, int nArguments) {\n\t\tswitch (index) {\n\t\tcase LOADSTRING: return loadstring(callFrame, nArguments);\n\t\tcase LOADSTREAM: return loadstream(callFrame, nArguments);\n\t\t}\n\t\treturn 0;"}
{"magic_number_smell": "\n\tstatic {\n\t\tnames = new String[NUM_FUNCTIONS];\n\t\tnames[0] = \"pcall\";\n\t\tnames[PRINT] = \"print\";\n\t\tnames[SELECT] = \"select\";\n\t\tnames[TYPE] = \"type\";", "refactored_code": "\tprivate static final int PCALL = 0;\n\n\tstatic {\n\t\tnames = new String[NUM_FUNCTIONS];\n\t\tnames[PCALL] = \"pcall\";\n\t\tnames[PRINT] = \"print\";\n\t\tnames[SELECT] = \"select\";\n\t\tnames[TYPE] = \"type\";"}
{"magic_number_smell": "\t\n\tstatic {\n\t\tnames = new String[NUM_FUNCTIONS];\n\t\tnames[0] = \"create\";\n\t\tnames[RESUME] = \"resume\";\n\t\tnames[YIELD] = \"yield\";\n\t\tnames[STATUS] = \"status\";", "refactored_code": "\tprivate static final int CREATE = 0;\n\t\n\tstatic {\n\t\tnames = new String[NUM_FUNCTIONS];\n\t\tnames[CREATE] = \"create\";\n\t\tnames[RESUME] = \"resume\";\n\t\tnames[YIELD] = \"yield\";\n\t\tnames[STATUS] = \"status\";"}
{"magic_number_smell": "\n\tstatic {\n\t\tfuncnames = new String[NUM_FUNCS];\n\t\tfuncnames[0] = \"date\";\n\t\tfuncnames[DIFFTIME] = \"difftime\";\n\t\tfuncnames[TIME] = \"time\";\n", "refactored_code": "\tprivate static final int DATE = 0;\n\n\tstatic {\n\t\tfuncnames = new String[NUM_FUNCS];\n\t\tfuncnames[DATE] = \"date\";\n\t\tfuncnames[DIFFTIME] = \"difftime\";\n\t\tfuncnames[TIME] = \"time\";\n"}
{"magic_number_smell": "    private static final RandomLib[] functions;\n    static {\n        names = new String[NUM_FUNCTIONS];\n        names[0] = \"random\";\n        names[RANDOMSEED] = \"seed\";\n        names[NEWRANDOM] = \"newrandom\";\n        functions = new RandomLib[NUM_FUNCTIONS];", "refactored_code": "    private static final int RANDOM = 0;\n    private static final RandomLib[] functions;\n    static {\n        names = new String[NUM_FUNCTIONS];\n        names[RANDOM] = \"random\";\n        names[RANDOMSEED] = \"seed\";\n        names[NEWRANDOM] = \"newrandom\";\n        functions = new RandomLib[NUM_FUNCTIONS];"}
{"magic_number_smell": "\t\n\tstatic {\n\t\tnames = new String[NUM_FUNCTIONS];\n\t\tnames[0] = \"sub\";\n\t\tnames[CHAR] = \"char\";\n\t\tnames[BYTE] = \"byte\";\n\t\tnames[LOWER] = \"lower\";", "refactored_code": "\tprivate static final int SUB = 0;\n\t\n\tstatic {\n\t\tnames = new String[NUM_FUNCTIONS];\n\t\tnames[SUB] = \"sub\";\n\t\tnames[CHAR] = \"char\";\n\t\tnames[BYTE] = \"byte\";\n\t\tnames[LOWER] = \"lower\";"}
{"magic_number_smell": "\t\n\tstatic {\n\t\tnames = new String[NUM_FUNCTIONS];\n\t\tnames[0] = \"concat\";\n\t\tnames[INSERT] = \"insert\";\n\t\tnames[REMOVE] = \"remove\";\n\t\tnames[NEWARRAY] = \"newarray\";", "refactored_code": "\tprivate static final int CONCAT = 0;\n\t\n\tstatic {\n\t\tnames = new String[NUM_FUNCTIONS];\n\t\tnames[CONCAT] = \"concat\";\n\t\tnames[INSERT] = \"insert\";\n\t\tnames[REMOVE] = \"remove\";\n\t\tnames[NEWARRAY] = \"newarray\";"}
{"magic_number_smell": "\t\tif (metatable == null) {\n\t\t\tmetatable = platform.newTable();\n\t\t\tmetatable.rawset(\"__metatable\", \"restricted\");\n\t\t\tmetatable.rawset(\"__len\", new UserdataArray(0));\n\t\t\tmetatable.rawset(\"__index\", new UserdataArray(INDEX));\n\t\t\tmetatable.rawset(\"__newindex\", new UserdataArray(NEWINDEX));\n", "refactored_code": "\tprivate static final int LENGTH = 0;\n\t\tif (metatable == null) {\n\t\t\tmetatable = platform.newTable();\n\t\t\tmetatable.rawset(\"__metatable\", \"restricted\");\n\t\t\tmetatable.rawset(\"__len\", new UserdataArray(LENGTH));\n\t\t\tmetatable.rawset(\"__index\", new UserdataArray(INDEX));\n\t\t\tmetatable.rawset(\"__newindex\", new UserdataArray(NEWINDEX));\n"}
{"magic_number_smell": "\t}\n\n\tprivate final void ensureStacksize(int index) {\n\t\tif (index > 1000) {\n\t\t\tthrow new RuntimeException(\"Stack overflow\");\t\t\t\n\t\t}\n\t\tint oldSize = objectStack.length;", "refactored_code": "\tprivate static final int MAX_STACK_SIZE = 1000;\n\t}\n\n\tprivate final void ensureStacksize(int index) {\n\t\tif (index > MAX_STACK_SIZE) {\n\t\t\tthrow new RuntimeException(\"Stack overflow\");\t\t\t\n\t\t}\n\t\tint oldSize = objectStack.length;"}
{"magic_number_smell": "\t\t\t\t\t\tc = opcodes[callFrame.pc++];\n\t\t\t\t\t}\n\n\t\t\t\t\tint offset = (c - 1) * 50;\n\n\t\t\t\t\tKahluaTable t = (KahluaTable) callFrame.get(a);\n\t\t\t\t\tfor (int i = 1; i <= b; i++) {", "refactored_code": "\tprivate static final int FIELDS_PER_FLUSH = 50;\n\t\t\t\t\t\tc = opcodes[callFrame.pc++];\n\t\t\t\t\t}\n\n\t\t\t\t\tint offset = (c - 1) * FIELDS_PER_FLUSH;\n\n\t\t\t\t\tKahluaTable t = (KahluaTable) callFrame.get(a);\n\t\t\t\t\tfor (int i = 1; i <= b; i++) {"}
{"magic_number_smell": "\tprivate final Thread worker = new Thread() {\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tlong runTime = 50;\n\t\t\ttry {\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (buffer.length() > 0) {", "refactored_code": "\tprivate static final int MIN_RUNTIME = 50;\n\tprivate final Thread worker = new Thread() {\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tlong runTime = MIN_RUNTIME;\n\t\t\ttry {\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (buffer.length() > 0) {"}
{"magic_number_smell": "            this.fireIntervalRemoved(this, 0, getSize() - 1);\n        }\n        delegate.clear();\n        if (matches.size() >= 500) {\n            Iterator<T> iterator = matches.iterator();\n            for (int i = 0; i < 500; i++) {\n                delegate.add(iterator.next());", "refactored_code": "    private static final int MAX_SIZE = 500;\n            this.fireIntervalRemoved(this, 0, getSize() - 1);\n        }\n        delegate.clear();\n        if (matches.size() >= MAX_SIZE) {\n            Iterator<T> iterator = matches.iterator();\n            for (int i = 0; i < MAX_SIZE; i++) {\n                delegate.add(iterator.next());"}
{"magic_number_smell": "\tprivate static final MathLib[] functions;\n\tstatic {\n\t\tnames = new String[NUM_FUNCTIONS];\n\t\tnames[0] = \"abs\";\n\t\tnames[ACOS] = \"acos\";\n\t\tnames[ASIN] = \"asin\";\n\t\tnames[ATAN] = \"atan\";", "refactored_code": "\tprivate static final int ABS = 0;\n\tprivate static final MathLib[] functions;\n\tstatic {\n\t\tnames = new String[NUM_FUNCTIONS];\n\t\tnames[ABS] = \"abs\";\n\t\tnames[ACOS] = \"acos\";\n\t\tnames[ASIN] = \"asin\";\n\t\tnames[ATAN] = \"atan\";"}
{"magic_number_smell": "                ret = new Conversation(context, cursor, sync);\n                CACHE.put(ret.getThreadId(), ret);\n                Log.d(TAG, \"cachesize: \", CACHE.size());\n                while (CACHE.size() > 50) {\n                    Integer i = CACHE.keySet().iterator().next();\n                    Log.d(TAG, \"rm con. from cache: \", i);\n                    Conversation cc = CACHE.remove(i);", "refactored_code": "    private static final int CACHESIZE = 50;\n                ret = new Conversation(context, cursor, sync);\n                CACHE.put(ret.getThreadId(), ret);\n                Log.d(TAG, \"cachesize: \", CACHE.size());\n                while (CACHE.size() > CACHESIZE) {\n                    Integer i = CACHE.keySet().iterator().next();\n                    Log.d(TAG, \"rm con. from cache: \", i);\n                    Conversation cc = CACHE.remove(i);"}
{"magic_number_smell": "        @Override\n        protected void onQueryComplete(final int token, final Object cookie, final Cursor cursor) {\n            switch (token) {\n                case 0:\n                    ConversationAdapter.this.changeCursor(cursor);\n                    ConversationAdapter.this.activity\n                            .setProgressBarIndeterminateVisibility(Boolean.FALSE);", "refactored_code": "    private static final int MESSAGE_LIST_QUERY_TOKEN = 0;\n        @Override\n        protected void onQueryComplete(final int token, final Object cookie, final Cursor cursor) {\n            switch (token) {\n                case MESSAGE_LIST_QUERY_TOKEN:\n                    ConversationAdapter.this.changeCursor(cursor);\n                    ConversationAdapter.this.activity\n                            .setProgressBarIndeterminateVisibility(Boolean.FALSE);"}
{"magic_number_smell": "        final AbsListView list = getListView();\n        list.setOnItemClickListener(this);\n        list.setOnItemLongClickListener(this);\n        longItemClickDialog = new String[6];\n        longItemClickDialog[WHICH_ANSWER] = getString(R.string.reply);\n        longItemClickDialog[WHICH_CALL] = getString(R.string.call);\n        longItemClickDialog[WHICH_VIEW_CONTACT] = getString(R.string.view_contact_);", "refactored_code": "    private static final int WHICH_N = 6;\n        final AbsListView list = getListView();\n        list.setOnItemClickListener(this);\n        list.setOnItemLongClickListener(this);\n        longItemClickDialog = new String[WHICH_N];\n        longItemClickDialog[WHICH_ANSWER] = getString(R.string.reply);\n        longItemClickDialog[WHICH_CALL] = getString(R.string.call);\n        longItemClickDialog[WHICH_VIEW_CONTACT] = getString(R.string.view_contact_);"}
{"magic_number_smell": "                ret = new Message(context, cursor);\n                CACHE.put(id, ret);\n                Log.d(TAG, \"cachesize: \", CACHE.size());\n                while (CACHE.size() > 50) {\n                    Integer i = CACHE.keySet().iterator().next();\n                    Log.d(TAG, \"rm msg. from cache: \", i);\n                    Message cc = CACHE.remove(i);", "refactored_code": "    private static final int CAHCESIZE = 50;\n                ret = new Message(context, cursor);\n                CACHE.put(id, ret);\n                Log.d(TAG, \"cachesize: \", CACHE.size());\n                while (CACHE.size() > CAHCESIZE) {\n                    Integer i = CACHE.keySet().iterator().next();\n                    Log.d(TAG, \"rm msg. from cache: \", i);\n                    Message cc = CACHE.remove(i);"}
{"magic_number_smell": "    /**\n     * Dialog items shown if an item was long clicked.\n     */\n    private final String[] longItemClickDialog = new String[8];\n\n    /**\n     * Marked a message unread?", "refactored_code": "    private static final int WHICH_N = 8;\n    /**\n     * Dialog items shown if an item was long clicked.\n     */\n    private final String[] longItemClickDialog = new String[WHICH_N];\n\n    /**\n     * Marked a message unread?"}
{"magic_number_smell": "            tvTextLabel.setVisibility(View.GONE);\n        } else {\n            tvPaste.setVisibility(View.GONE);\n            if (len > 50) {\n                try {\n                    int[] l = SmsMessage.calculateLength(s.toString(), false);\n                    tvTextLabel.setText(l[0] + \"/\" + l[2]);", "refactored_code": "    private static final int TEXT_LABLE_MIN_LEN = 50;\n            tvTextLabel.setVisibility(View.GONE);\n        } else {\n            tvPaste.setVisibility(View.GONE);\n            if (len > TEXT_LABLE_MIN_LEN) {\n                try {\n                    int[] l = SmsMessage.calculateLength(s.toString(), false);\n                    tvTextLabel.setText(l[0] + \"/\" + l[2]);"}
{"magic_number_smell": "    static String fixNumber(final Context context, final String number) {\n        String ret = number;\n        final SharedPreferences p = PreferenceManager.getDefaultSharedPreferences(context);\n        for (int i = 1; i <= 3; i++) {\n            final String regex = p.getString(PREFS_REGEX + i, null);\n            if (!TextUtils.isEmpty(regex)) {\n                try {", "refactored_code": "    private static final int PREFS_REGEX_COUNT = 3;\n    static String fixNumber(final Context context, final String number) {\n        String ret = number;\n        final SharedPreferences p = PreferenceManager.getDefaultSharedPreferences(context);\n        for (int i = 1; i <= PREFS_REGEX_COUNT; i++) {\n            final String regex = p.getString(PREFS_REGEX + i, null);\n            if (!TextUtils.isEmpty(regex)) {\n                try {"}
{"magic_number_smell": "                return new int[]{-1, -1};\n            }\n            final int[] ret = new int[]{-1, retSMS[ID_COUNT] + retMMS[ID_COUNT]};\n            if (retMMS[0] <= 0 || retSMS[0] == retMMS[0]) {\n                ret[0] = retSMS[0];\n            } else if (retSMS[0] <= 0) {\n                ret[0] = retMMS[0];", "refactored_code": "    private static final int ID_TID = 0;\n                return new int[]{-1, -1};\n            }\n            final int[] ret = new int[]{-1, retSMS[ID_COUNT] + retMMS[ID_COUNT]};\n            if (retMMS[ID_TID] <= 0 || retSMS[ID_TID] == retMMS[ID_TID]) {\n                ret[ID_TID] = retSMS[ID_TID];\n            } else if (retSMS[ID_TID] <= 0) {\n                ret[ID_TID] = retMMS[ID_TID];"}
{"magic_number_smell": "         * @param context {@link Context}\n         */\n        DatabaseHelper(final Context context) {\n            super(context, DATABASE_NAME, null, 1);\n        }\n\n        @Override", "refactored_code": "    private static final int DATABASE_VERSION = 1;\n         * @param context {@link Context}\n         */\n        DatabaseHelper(final Context context) {\n            super(context, DATABASE_NAME, null, DATABASE_VERSION);\n        }\n\n        @Override"}
{"magic_number_smell": "\t */\n\tpublic static long copyLarge(final InputStream input,\n\t\t\tfinal OutputStream output) throws IOException {\n\t\tbyte[] buffer = new byte[1024 * 4];\n\t\tlong count = 0;\n\t\tint n;\n\t\twhile (-1 != (n = input.read(buffer))) {", "refactored_code": "\tprivate static final int DEFAULT_BUFFER_SIZE = 1024 * 4;\n\t */\n\tpublic static long copyLarge(final InputStream input,\n\t\t\tfinal OutputStream output) throws IOException {\n\t\tbyte[] buffer = new byte[DEFAULT_BUFFER_SIZE];\n\t\tlong count = 0;\n\t\tint n;\n\t\twhile (-1 != (n = input.read(buffer))) {"}
{"magic_number_smell": "                // The full header should fit in here.\n                // Apache's default header limit is 8KB.\n                // Do NOT assume that a single read will get the entire header at once!\n                byte[] buf = new byte[8192];\n                int splitbyte = 0;\n                int rlen = 0;\n                {", "refactored_code": "        public static final int BUFSIZE = 8192;\n                // The full header should fit in here.\n                // Apache's default header limit is 8KB.\n                // Do NOT assume that a single read will get the entire header at once!\n                byte[] buf = new byte[BUFSIZE];\n                int splitbyte = 0;\n                int rlen = 0;\n                {"}
{"magic_number_smell": "\t}\n\n\tpublic void onClick(DialogInterface dialog, int which) {\n\t\tif (which == BUTTON1) {\n\t\t\ttry {\n\t\t\t\tCookieDomainManager.getInstance().addToWhitelist(mUrl.getText().toString(), getContext());\n\t\t\t} catch (URISyntaxException e) {", "refactored_code": "\tpublic static final int SAVE_BUTTON = BUTTON1;\n\t}\n\n\tpublic void onClick(DialogInterface dialog, int which) {\n\t\tif (which == SAVE_BUTTON) {\n\t\t\ttry {\n\t\t\t\tCookieDomainManager.getInstance().addToWhitelist(mUrl.getText().toString(), getContext());\n\t\t\t} catch (URISyntaxException e) {"}
{"magic_number_smell": "\t\t\ta.setAnimationListener(this);\n\t\t}\n\t\t\n\t\ta.setDuration(200);\n\t\tmBlockedCookiesView.startAnimation(a);\n\t}\n\t", "refactored_code": "\tprivate static final int ANIMATION_DURATION = 200; // 200ms\n\t\t\ta.setAnimationListener(this);\n\t\t}\n\t\t\n\t\ta.setDuration(ANIMATION_DURATION);\n\t\tmBlockedCookiesView.startAnimation(a);\n\t}\n\t"}
{"magic_number_smell": "\tprivate long getAvailableCache() {\n\n\t\tlong availableToAllocate = (long) ((float) Runtime.getRuntime()\n\t\t\t\t.freeMemory() * 0.75f);\n\t\tlong availableBeforeMax = MAX_CACHE_SIZE - mCacheSize;\n\n\t\t// Return the smaller of the two", "refactored_code": "\tprivate static final float CACHE_SIZE_PROP = 0.75f;\n\tprivate long getAvailableCache() {\n\n\t\tlong availableToAllocate = (long) ((float) Runtime.getRuntime()\n\t\t\t\t.freeMemory() * CACHE_SIZE_PROP);\n\t\tlong availableBeforeMax = MAX_CACHE_SIZE - mCacheSize;\n\n\t\t// Return the smaller of the two"}
{"magic_number_smell": "\t\n\t/**\n\t * Set the behaviour of the cookie manager.\n\t * @param behaviour one of 1, WHITELIST, BLOCK_ALL\n\t */\n\tpublic void setBehaviour(int behaviour) {\n\t\tmBehaviour = behaviour;", "refactored_code": "\tpublic static final int ACCEPT_ALL = 1;\n\t\n\t/**\n\t * Set the behaviour of the cookie manager.\n\t * @param behaviour one of ACCEPT_ALL, WHITELIST, BLOCK_ALL\n\t */\n\tpublic void setBehaviour(int behaviour) {\n\t\tmBehaviour = behaviour;"}
{"magic_number_smell": "\tprivate SQLiteDatabase db = null;\n\n\tpublic CookieManagerDataStore(Context context) {\n\t\tsuper(context, DB_NAME, null, 1);\n\t\tthis.db = this.getWritableDatabase();\n\t}\n", "refactored_code": "\tprivate static final int DB_VERSION = 1;\n\tprivate SQLiteDatabase db = null;\n\n\tpublic CookieManagerDataStore(Context context) {\n\t\tsuper(context, DB_NAME, null, DB_VERSION);\n\t\tthis.db = this.getWritableDatabase();\n\t}\n"}
{"magic_number_smell": "   */\n  public void run() {\n    try {\n      char[] cbuf = new char[2048];\n      int count;\n      //System.out.println(\"opening streamredirectthread\");\n      while ((count = in.read(cbuf, 0, 2048)) >= 0) {", "refactored_code": "  private static final int BUFFER_SIZE = 2048;\n   */\n  public void run() {\n    try {\n      char[] cbuf = new char[BUFFER_SIZE];\n      int count;\n      //System.out.println(\"opening streamredirectthread\");\n      while ((count = in.read(cbuf, 0, BUFFER_SIZE)) >= 0) {"}
{"magic_number_smell": "\n\tpublic File build(Config c) throws IOException {\n\t\t_sb.append(\"LANGUAGE \");\n\t\t_sb.append(0);\n\t\t_sb.append(\", \");\n\t\t_sb.append(SUBLANG_DEFAULT);\n\t\t_sb.append('\\n');", "refactored_code": "\tpublic static final int LANG_NEUTRAL = 0;\n\n\tpublic File build(Config c) throws IOException {\n\t\t_sb.append(\"LANGUAGE \");\n\t\t_sb.append(LANG_NEUTRAL);\n\t\t_sb.append(\", \");\n\t\t_sb.append(SUBLANG_DEFAULT);\n\t\t_sb.append('\\n');"}
{"magic_number_smell": "   * setting, rather than fighting with renderers about whether that\n   * renderer supports thick lines.\n   */\n  public float strokeWeight = 1;\n\n  /**\n   * Set by strokeJoin() (read-only). This has a default setting", "refactored_code": "  static protected final float DEFAULT_STROKE_WEIGHT = 1;\n   * setting, rather than fighting with renderers about whether that\n   * renderer supports thick lines.\n   */\n  public float strokeWeight = DEFAULT_STROKE_WEIGHT;\n\n  /**\n   * Set by strokeJoin() (read-only). This has a default setting"}
{"magic_number_smell": "   * setting, rather than fighting with renderers about whether that\n   * renderer supports thick lines.\n   */\n  public float strokeWeight = 1;\n\n  /**\n   * Set by strokeJoin() (read-only). This has a default setting", "refactored_code": "  static protected final float DEFAULT_STROKE_WEIGHT = 1;\n   * setting, rather than fighting with renderers about whether that\n   * renderer supports thick lines.\n   */\n  public float strokeWeight = DEFAULT_STROKE_WEIGHT;\n\n  /**\n   * Set by strokeJoin() (read-only). This has a default setting"}
{"magic_number_smell": "    reapplySettings();\n\n    // init lights (in resize() instead of allocate() b/c needed by opengl)\n    lightType = new int[8];\n    lightPosition = new PVector[8];\n    lightNormal = new PVector[8];\n    for (int i = 0; i < 8; i++) {", "refactored_code": "  public static final int MAX_LIGHTS = 8;\n    reapplySettings();\n\n    // init lights (in resize() instead of allocate() b/c needed by opengl)\n    lightType = new int[MAX_LIGHTS];\n    lightPosition = new PVector[MAX_LIGHTS];\n    lightNormal = new PVector[MAX_LIGHTS];\n    for (int i = 0; i < MAX_LIGHTS; i++) {"}
{"magic_number_smell": "  static public final int PATH = 2;\n  /** Collections of vertices created with beginShape(). */\n  static public final int GEOMETRY = 3;\n  /** The shape type, one of 0, PRIMITIVE, PATH, or GEOMETRY. */\n  protected int family;\n\n  /** ELLIPSE, LINE, QUAD; TRIANGLE_FAN, QUAD_STRIP; etc. */", "refactored_code": "  static public final int GROUP = 0;\n  static public final int PATH = 2;\n  /** Collections of vertices created with beginShape(). */\n  static public final int GEOMETRY = 3;\n  /** The shape type, one of GROUP, PRIMITIVE, PATH, or GEOMETRY. */\n  protected int family;\n\n  /** ELLIPSE, LINE, QUAD; TRIANGLE_FAN, QUAD_STRIP; etc. */"}
{"magic_number_smell": "  // the power of 2 that tells how many pixels to interpolate\n  // for between  exactly computed texture coordinates\n  private static final int 3 = 3;\n  private static int TEX_INTERP_POWER = 3;\n\n  // Vertex coordinates\n  private float[] x_array;", "refactored_code": "  private static final int DEFAULT_INTERP_POWER = 3;\n  // the power of 2 that tells how many pixels to interpolate\n  // for between  exactly computed texture coordinates\n  private static final int DEFAULT_INTERP_POWER = 3;\n  private static int TEX_INTERP_POWER = DEFAULT_INTERP_POWER;\n\n  // Vertex coordinates\n  private float[] x_array;"}
{"magic_number_smell": "     * Creates an empty element to be used for #PCDATA content.\n     */\n    public XMLElement() {\n        this(null, null, null, -1);\n    }\n\n", "refactored_code": "    public static final int NO_LINE = -1;\n     * Creates an empty element to be used for #PCDATA content.\n     */\n    public XMLElement() {\n        this(null, null, null, NO_LINE);\n    }\n\n"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSCertificateManagerAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSCertificateManagerAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonApiGatewayAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonApiGatewayAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSApplicationAutoScalingAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSApplicationAutoScalingAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonAppStreamAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonAppStreamAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonAutoScalingAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonAutoScalingAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSBatchAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSBatchAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSBudgetsAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSBudgetsAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonCloudDirectoryAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonCloudDirectoryAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonCloudFormationAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonCloudFormationAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonCloudFrontAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonCloudFrontAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSCloudHSMAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSCloudHSMAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonCloudSearchDomainAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonCloudSearchDomainAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonCloudSearchAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonCloudSearchAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSCloudTrailAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSCloudTrailAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonCloudWatchAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonCloudWatchAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    private EndpointConfiguration endpointConfiguration;\n\n    private int metricQueueSize = 1000;\n\n    /**\n     * Returns the credential provider that holds the credentials to connect to", "refactored_code": "    public static final int DEFAULT_METRICS_QSIZE = 1000;\n     */\n    private EndpointConfiguration endpointConfiguration;\n\n    private int metricQueueSize = DEFAULT_METRICS_QSIZE;\n\n    /**\n     * Returns the credential provider that holds the credentials to connect to"}
{"magic_number_smell": "    @Override\n    public int compare(Dimension dim1, Dimension dim2) {\n        int result = nullCompare(dim1, dim2);\n        if (result == 2) {\n            result = nullSafeCompare(dim1.getName(), dim2.getName());\n            if (result == 0) {\n                return nullSafeCompare(dim1.getValue(), dim2.getValue());", "refactored_code": "    private static final int NON_NULLS = 2;\n    @Override\n    public int compare(Dimension dim1, Dimension dim2) {\n        int result = nullCompare(dim1, dim2);\n        if (result == NON_NULLS) {\n            result = nullSafeCompare(dim1.getName(), dim2.getName());\n            if (result == 0) {\n                return nullSafeCompare(dim1.getValue(), dim2.getValue());"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSCodeBuildAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSCodeBuildAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSCodeCommitAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSCodeCommitAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonCodeDeployAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonCodeDeployAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSCodePipelineAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSCodePipelineAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonCognitoIdentityAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonCognitoIdentityAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSCognitoIdentityProviderAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSCognitoIdentityProviderAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonCognitoSyncAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonCognitoSyncAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonConfigAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonConfigAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     * The amount of time to wait (in milliseconds) when initially establishing a connection before\n     * giving up and timing out. A value of 0 means infinity, and is not recommended.\n     */\n    private int connectionTimeout = 10 * 1000;\n\n    /**\n     * The amount of time to wait (in milliseconds) for a request to complete before giving up and", "refactored_code": "    public static final int DEFAULT_CONNECTION_TIMEOUT = 10 * 1000;\n     * The amount of time to wait (in milliseconds) when initially establishing a connection before\n     * giving up and timing out. A value of 0 means infinity, and is not recommended.\n     */\n    private int connectionTimeout = DEFAULT_CONNECTION_TIMEOUT;\n\n    /**\n     * The amount of time to wait (in milliseconds) for a request to complete before giving up and"}
{"magic_number_smell": "\n    protected static final InternalLogApi log = InternalLogFactory.getLog(AWS4Signer.class);\n    private static final int 300 = 300;\n    private static final FIFOCache<SignerKey> signerCache = new FIFOCache<SignerKey>(300);\n    private static final List<String> listOfHeadersToIgnoreInLowerCase = Arrays.asList(\"connection\", \"x-amzn-trace-id\");\n\n    private final SdkClock clock;", "refactored_code": "    private static final int SIGNER_CACHE_MAX_SIZE = 300;\n\n    protected static final InternalLogApi log = InternalLogFactory.getLog(AWS4Signer.class);\n    private static final int SIGNER_CACHE_MAX_SIZE = 300;\n    private static final FIFOCache<SignerKey> signerCache = new FIFOCache<SignerKey>(SIGNER_CACHE_MAX_SIZE);\n    private static final List<String> listOfHeadersToIgnoreInLowerCase = Arrays.asList(\"connection\", \"x-amzn-trace-id\");\n\n    private final SdkClock clock;"}
{"magic_number_smell": "    }\n\n    /**\n     * Returns true if it has been 1000 * 60 * 60 millis since we last refreshed the credentials from IMDS.\n     */\n    private boolean noRecentInstanceProfileCheck() {\n        return lastInstanceProfileCheck != null &&", "refactored_code": "    private static final int REFRESH_THRESHOLD = 1000 * 60 * 60;\n    }\n\n    /**\n     * Returns true if it has been REFRESH_THRESHOLD millis since we last refreshed the credentials from IMDS.\n     */\n    private boolean noRecentInstanceProfileCheck() {\n        return lastInstanceProfileCheck != null &&"}
{"magic_number_smell": "\n    @Override\n    public boolean shouldRetry(int retriesAttempted, CredentialsEndpointRetryParameters retryParams) {\n        if (retriesAttempted >= 5) {\n            return false;\n        }\n", "refactored_code": "    private static final int MAX_RETRIES = 5;\n\n    @Override\n    public boolean shouldRetry(int retriesAttempted, CredentialsEndpointRetryParameters retryParams) {\n        if (retriesAttempted >= MAX_RETRIES) {\n            return false;\n        }\n"}
{"magic_number_smell": "                    private void handleAsyncRefreshError(Exception e) {\n                        LOG.warn(\"Failed when refreshing credentials asynchronously.\", e);\n                    }\n                }, 0, 1, TimeUnit.MINUTES);\n            }\n        }\n    }", "refactored_code": "    private static final int ASYNC_REFRESH_INTERVAL_TIME_MINUTES = 1;\n                    private void handleAsyncRefreshError(Exception e) {\n                        LOG.warn(\"Failed when refreshing credentials asynchronously.\", e);\n                    }\n                }, 0, ASYNC_REFRESH_INTERVAL_TIME_MINUTES, TimeUnit.MINUTES);\n            }\n        }\n    }"}
{"magic_number_smell": "     * Default force reload interval\n     */\n    private static final long DEFAULT_FORCE_RELOAD_INTERVAL_NANOS =\n            2 * 5 * 60 * 1000 * 1000 * 1000L;\n\n    /**\n     * The credential profiles file from which this provider loads the security credentials. Lazily", "refactored_code": "    private static final long DEFAULT_REFRESH_INTERVAL_NANOS = 5 * 60 * 1000 * 1000 * 1000L;\n     * Default force reload interval\n     */\n    private static final long DEFAULT_FORCE_RELOAD_INTERVAL_NANOS =\n            2 * DEFAULT_REFRESH_INTERVAL_NANOS;\n\n    /**\n     * The credential profiles file from which this provider loads the security credentials. Lazily"}
{"magic_number_smell": "        new EnumMap<ProgressEventType, Integer>(ProgressEventType.class);\n    static {\n        legacyEventCodes.put(ProgressEventType.BYTE_TRANSFER_EVENT,              0);\n        legacyEventCodes.put(ProgressEventType.TRANSFER_PREPARING_EVENT,         1);\n        legacyEventCodes.put(ProgressEventType.TRANSFER_STARTED_EVENT,           STARTED_EVENT_CODE);\n        legacyEventCodes.put(ProgressEventType.TRANSFER_COMPLETED_EVENT,         COMPLETED_EVENT_CODE);\n        legacyEventCodes.put(ProgressEventType.TRANSFER_FAILED_EVENT,            FAILED_EVENT_CODE);", "refactored_code": "    @Deprecated public static final int PREPARING_EVENT_CODE = 1;\n        new EnumMap<ProgressEventType, Integer>(ProgressEventType.class);\n    static {\n        legacyEventCodes.put(ProgressEventType.BYTE_TRANSFER_EVENT,              0);\n        legacyEventCodes.put(ProgressEventType.TRANSFER_PREPARING_EVENT,         PREPARING_EVENT_CODE);\n        legacyEventCodes.put(ProgressEventType.TRANSFER_STARTED_EVENT,           STARTED_EVENT_CODE);\n        legacyEventCodes.put(ProgressEventType.TRANSFER_COMPLETED_EVENT,         COMPLETED_EVENT_CODE);\n        legacyEventCodes.put(ProgressEventType.TRANSFER_FAILED_EVENT,            FAILED_EVENT_CODE);"}
{"magic_number_smell": "    private long notifiedByteCount;\n\n    public ProgressInputStream(InputStream is, ProgressListener listener) {\n        this(is, listener, 8 * 1024);\n    }\n\n    public ProgressInputStream(InputStream is, ProgressListener listener, int notifyThresHold) {", "refactored_code": "    private static final int DEFAULT_NOTIFICATION_THRESHOLD = 8 * 1024;\n    private long notifiedByteCount;\n\n    public ProgressInputStream(InputStream is, ProgressListener listener) {\n        this(is, listener, DEFAULT_NOTIFICATION_THRESHOLD);\n    }\n\n    public ProgressInputStream(InputStream is, ProgressListener listener, int notifyThresHold) {"}
{"magic_number_smell": "        // When enabled, total retry capacity is computed based on retry cost\n        // and desired number of retries.\n        int throttledRetryMaxCapacity = clientConfig.useThrottledRetries()\n                ? 5 * config.getMaxConsecutiveRetriesBeforeThrottling() : -1;\n        this.retryCapacity = new CapacityManager(throttledRetryMaxCapacity);\n        this.tokenBucket = new TokenBucket();\n        this.sdkRequestHeaderProvider = new SdkRequestRetryHeaderProvider(config, this.retryPolicy, clockSkewAdjuster);", "refactored_code": "    private static final int THROTTLED_RETRY_COST = 5;\n        // When enabled, total retry capacity is computed based on retry cost\n        // and desired number of retries.\n        int throttledRetryMaxCapacity = clientConfig.useThrottledRetries()\n                ? THROTTLED_RETRY_COST * config.getMaxConsecutiveRetriesBeforeThrottling() : -1;\n        this.retryCapacity = new CapacityManager(throttledRetryMaxCapacity);\n        this.tokenBucket = new TokenBucket();\n        this.sdkRequestHeaderProvider = new SdkRequestRetryHeaderProvider(config, this.retryPolicy, clockSkewAdjuster);"}
{"magic_number_smell": "                    }\n                }\n\n                Thread.sleep(1000 * 60);\n            } catch (Throwable t) {\n                LOG.debug(\"Reaper thread: \", t);\n            }", "refactored_code": "    private static final int PERIOD_MILLISECONDS = 1000 * 60;\n                    }\n                }\n\n                Thread.sleep(PERIOD_MILLISECONDS);\n            } catch (Throwable t) {\n                LOG.debug(\"Reaper thread: \", t);\n            }"}
{"magic_number_smell": "        String stringTimeout = System.getenv(SDKGlobalConfiguration.AWS_METADATA_SERVICE_TIMEOUT_ENV_VAR);\n\n        if (StringUtils.isNullOrEmpty(stringTimeout)) {\n            return 1000;\n        }\n\n        // To match the CLI behavior, we need to support both integers and doubles. We try int first so that we can get exact", "refactored_code": "    private static final int DEFAULT_TIMEOUT_MILLIS = 1000;\n        String stringTimeout = System.getenv(SDKGlobalConfiguration.AWS_METADATA_SERVICE_TIMEOUT_ENV_VAR);\n\n        if (StringUtils.isNullOrEmpty(stringTimeout)) {\n            return DEFAULT_TIMEOUT_MILLIS;\n        }\n\n        // To match the CLI behavior, we need to support both integers and doubles. We try int first so that we can get exact"}
{"magic_number_smell": "    public final long skip(final long n) throws IOException {\n        if (n <= 0)\n            return n;\n        byte[] b = new byte[(int)Math.min(2*1024, n)];\n        long m = n; // remaining number of bytes to read\n        while (m > 0) {\n            int len = read(b, 0, (int)Math.min(m, b.length));", "refactored_code": "    private static final int SKIP_BUF_SIZE = 2*1024;\n    public final long skip(final long n) throws IOException {\n        if (n <= 0)\n            return n;\n        byte[] b = new byte[(int)Math.min(SKIP_BUF_SIZE, n)];\n        long m = n; // remaining number of bytes to read\n        while (m > 0) {\n            int len = read(b, 0, (int)Math.min(m, b.length));"}
{"magic_number_smell": "     * _TokenBucketUpdateRate(new_rps)\n     *   # Refill based on our current rate before we update to the new fill rate.\n     *   _TokenBucketRefill()\n     *   fill_rate = max(new_rps, 0.5)\n     *   max_capacity = max(new_rps, MIN_CAPACITY)\n     *   # When we scale down we can't have a current capacity that exceeds our\n     *   # max_capacity.", "refactored_code": "    private static final double MIN_FILL_RATE = 0.5;\n     * _TokenBucketUpdateRate(new_rps)\n     *   # Refill based on our current rate before we update to the new fill rate.\n     *   _TokenBucketRefill()\n     *   fill_rate = max(new_rps, MIN_FILL_RATE)\n     *   max_capacity = max(new_rps, MIN_CAPACITY)\n     *   # When we scale down we can't have a current capacity that exceeds our\n     *   # max_capacity."}
{"magic_number_smell": "    }\n\n    long startTiming() {\n        if (TimeUnit.NANOSECONDS.toSeconds(getDurationNano()) > 10) {\n            reportMetrics();\n        }\n        return System.nanoTime();", "refactored_code": "    private static final int REPORT_INTERVAL_SECS = 10;\n    }\n\n    long startTiming() {\n        if (TimeUnit.NANOSECONDS.toSeconds(getDurationNano()) > REPORT_INTERVAL_SECS) {\n            reportMetrics();\n        }\n        return System.nanoTime();"}
{"magic_number_smell": "@NotThreadSafe\npublic class ServiceLatencyProvider {\n    private final long System.nanoTime() = System.nanoTime();\n    private long endNano = System.nanoTime();\n    private final ServiceMetricType serviceMetricType;\n\n    public ServiceLatencyProvider(ServiceMetricType type) { ", "refactored_code": "    private final long startNano = System.nanoTime();\n@NotThreadSafe\npublic class ServiceLatencyProvider {\n    private final long startNano = System.nanoTime();\n    private long endNano = startNano;\n    private final ServiceMetricType serviceMetricType;\n\n    public ServiceLatencyProvider(ServiceMetricType type) { "}
{"magic_number_smell": "            channel = DatagramChannel.open();\n            channel.configureBlocking(false);\n\n            if (channel.socket().getSendBufferSize() < 8192) {\n                channel.socket().setSendBufferSize(8192);\n            }\n", "refactored_code": "    private static final int MAX_BUFFER_SIZE = 8192;\n            channel = DatagramChannel.open();\n            channel.configureBlocking(false);\n\n            if (channel.socket().getSendBufferSize() < MAX_BUFFER_SIZE) {\n                channel.socket().setSendBufferSize(MAX_BUFFER_SIZE);\n            }\n"}
{"magic_number_smell": "\n    public synchronized void init() {\n        if (!initialized) {\n            tasks = new LinkedBlockingQueue<WriteTask>(4096);\n            exec = Executors.newSingleThreadExecutor(new ThreadFactory() {\n                @Override\n                public Thread newThread(Runnable r) {", "refactored_code": "    private static final int QUEUE_SIZE = 4096;\n\n    public synchronized void init() {\n        if (!initialized) {\n            tasks = new LinkedBlockingQueue<WriteTask>(QUEUE_SIZE);\n            exec = Executors.newSingleThreadExecutor(new ThreadFactory() {\n                @Override\n                public Thread newThread(Runnable r) {"}
{"magic_number_smell": "\n        CBORGenerator generator = (CBORGenerator) getGenerator();\n        try {\n            generator.writeTag(1);\n            generator.writeNumber(date.getTime());\n        } catch (IOException e) {\n            throw new JsonGenerationException(e);", "refactored_code": "    private static final int CBOR_TAG_TIMESTAP = 1;\n\n        CBORGenerator generator = (CBORGenerator) getGenerator();\n        try {\n            generator.writeTag(CBOR_TAG_TIMESTAP);\n            generator.writeNumber(date.getTime());\n        } catch (IOException e) {\n            throw new JsonGenerationException(e);"}
{"magic_number_smell": "        }\n    }\n\n    private final ByteArrayOutputStream baos = new ByteArrayOutputStream(1024);\n\n    private final JsonGenerator generator;\n", "refactored_code": "    private static final int DEFAULT_BUFFER_SIZE = 1024;\n        }\n    }\n\n    private final ByteArrayOutputStream baos = new ByteArrayOutputStream(DEFAULT_BUFFER_SIZE);\n\n    private final JsonGenerator generator;\n"}
{"magic_number_smell": "        }\n\n        int requestClockSkew = timeSkewInSeconds(getClientDate(adjustmentRequest), serverDate);\n        return Math.abs(requestClockSkew) > 4 * 60;\n    }\n\n    /**", "refactored_code": "    private static final int CLOCK_SKEW_ADJUST_THRESHOLD_IN_SECONDS = 4 * 60;\n        }\n\n        int requestClockSkew = timeSkewInSeconds(getClientDate(adjustmentRequest), serverDate);\n        return Math.abs(requestClockSkew) > CLOCK_SKEW_ADJUST_THRESHOLD_IN_SECONDS;\n    }\n\n    /**"}
{"magic_number_smell": "\n        public SDKDefaultBackoffStrategy() {\n            fullJitterBackoffStrategy = new PredefinedBackoffStrategies.FullJitterBackoffStrategy(\n                    100, SDK_DEFAULT_MAX_BACKOFF_IN_MILLISECONDS);\n            equalJitterBackoffStrategy = new PredefinedBackoffStrategies.EqualJitterBackoffStrategy(\n                    SDK_DEFAULT_THROTTLED_BASE_DELAY, SDK_DEFAULT_MAX_BACKOFF_IN_MILLISECONDS);\n        }", "refactored_code": "    private static final int SDK_DEFAULT_BASE_DELAY = 100;\n\n        public SDKDefaultBackoffStrategy() {\n            fullJitterBackoffStrategy = new PredefinedBackoffStrategies.FullJitterBackoffStrategy(\n                    SDK_DEFAULT_BASE_DELAY, SDK_DEFAULT_MAX_BACKOFF_IN_MILLISECONDS);\n            equalJitterBackoffStrategy = new PredefinedBackoffStrategies.EqualJitterBackoffStrategy(\n                    SDK_DEFAULT_THROTTLED_BASE_DELAY, SDK_DEFAULT_MAX_BACKOFF_IN_MILLISECONDS);\n        }"}
{"magic_number_smell": "    public static RetryPolicy getDefaultRetryPolicy() {\n        return new RetryPolicy(DEFAULT_RETRY_CONDITION,\n                               DEFAULT_BACKOFF_STRATEGY,\n                               3,\n                               true,\n                               true,\n                               true);", "refactored_code": "    public static final int DEFAULT_MAX_ERROR_RETRY = 3;\n    public static RetryPolicy getDefaultRetryPolicy() {\n        return new RetryPolicy(DEFAULT_RETRY_CONDITION,\n                               DEFAULT_BACKOFF_STRATEGY,\n                               DEFAULT_MAX_ERROR_RETRY,\n                               true,\n                               true,\n                               true);"}
{"magic_number_smell": "                else if (i >= 'A' && i <= 'F')\n                    dest[i] = (byte)(i - OFFSET_OF_A);\n                else if (i >= 'a' && i <= 'f')\n                    dest[i] = (byte)(i - 'a' - 10);\n                else\n                    dest[i] = -1;\n            }", "refactored_code": "    private static final int OFFSET_OF_a = 'a' - 10;\n                else if (i >= 'A' && i <= 'F')\n                    dest[i] = (byte)(i - OFFSET_OF_A);\n                else if (i >= 'a' && i <= 'f')\n                    dest[i] = (byte)(i - OFFSET_OF_a);\n                else\n                    dest[i] = -1;\n            }"}
{"magic_number_smell": "                if (i >= 'A' && i <= 'Z')\n                    dest[i] = (byte)(i - 'A');\n                else if (i >= '2' && i <= '7')\n                    dest[i] = (byte)(i - '2' - 26);\n                else if (i >= 'a' && i <= 'z')\n                    dest[i] = (byte)(i - 'a');\n                else ", "refactored_code": "    private static final int OFFSET_OF_2 = '2' - 26;\n                if (i >= 'A' && i <= 'Z')\n                    dest[i] = (byte)(i - 'A');\n                else if (i >= '2' && i <= '7')\n                    dest[i] = (byte)(i - OFFSET_OF_2);\n                else if (i >= 'a' && i <= 'z')\n                    dest[i] = (byte)(i - 'a');\n                else "}
{"magic_number_smell": "                else if (i == '/')\n                    dest[i] = (byte)(i - OFFSET_OF_SLASH);\n                else if (i >= 'a' && i <= 'z')\n                    dest[i] = (byte)(i - 'a' - 26);\n                else \n                    dest[i] = -1;\n            }", "refactored_code": "    private static final int OFFSET_OF_a = 'a' - 26;\n                else if (i == '/')\n                    dest[i] = (byte)(i - OFFSET_OF_SLASH);\n                else if (i >= 'a' && i <= 'z')\n                    dest[i] = (byte)(i - OFFSET_OF_a);\n                else \n                    dest[i] = -1;\n            }"}
{"magic_number_smell": "            // 292278994;  So we parse the date string by first adjusting\n            // the year to 292278993. Then we add 1 year back afterwards.\n            final long milliLess365Days = iso8601DateFormat.parseMillis(temp);\n            final long milli = milliLess365Days + 365L*24*60*60*1000;\n            if (milli < 0) { // overflow!\n                // re-parse the original date string using JodaTime so as to\n                // throw  an exception with a consistent message", "refactored_code": "    private static final long MILLI_SECONDS_OF_365_DAYS = 365L*24*60*60*1000;\n            // 292278994;  So we parse the date string by first adjusting\n            // the year to 292278993. Then we add 1 year back afterwards.\n            final long milliLess365Days = iso8601DateFormat.parseMillis(temp);\n            final long milli = milliLess365Days + MILLI_SECONDS_OF_365_DAYS;\n            if (milli < 0) { // overflow!\n                // re-parse the original date string using JodaTime so as to\n                // throw  an exception with a consistent message"}
{"magic_number_smell": "    }\n\n    public static String getData(String path) {\n        return getData(path, 3);\n    }\n\n    public static String getData(String path, int tries) {", "refactored_code": "    private static final int DEFAULT_QUERY_RETRIES = 3;\n    }\n\n    public static String getData(String path) {\n        return getData(path, DEFAULT_QUERY_RETRIES);\n    }\n\n    public static String getData(String path, int tries) {"}
{"magic_number_smell": "                              + \"component is missing.\", object, paramName));\n        }\n\n        if (hostnameComponent.length() > 63) {\n            throw new IllegalArgumentException(\n                String.format(\"The provided %s is not valid: the '%s' \"\n                              + \"component exceeds the maximum length of %d characters.\", object, paramName, 63));", "refactored_code": "    private static final int HOSTNAME_MAX_LENGTH = 63;\n                              + \"component is missing.\", object, paramName));\n        }\n\n        if (hostnameComponent.length() > HOSTNAME_MAX_LENGTH) {\n            throw new IllegalArgumentException(\n                String.format(\"The provided %s is not valid: the '%s' \"\n                              + \"component exceeds the maximum length of %d characters.\", object, paramName, HOSTNAME_MAX_LENGTH));"}
{"magic_number_smell": "    public static byte[] toByteArray(InputStream is) throws IOException {\n        ByteArrayOutputStream output = new ByteArrayOutputStream();\n        try {\n            byte[] b = new byte[1024 * 4];\n            int n = 0;\n            while ((n = is.read(b)) != -1) {\n                output.write(b, 0, n);", "refactored_code": "    private static final int BUFFER_SIZE = 1024 * 4;\n    public static byte[] toByteArray(InputStream is) throws IOException {\n        ByteArrayOutputStream output = new ByteArrayOutputStream();\n        try {\n            byte[] b = new byte[BUFFER_SIZE];\n            int n = 0;\n            while ((n = is.read(b)) != -1) {\n                output.write(b, 0, n);"}
{"magic_number_smell": "        BufferedInputStream bis = new BufferedInputStream(is);\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            byte[] buffer = new byte[1 << 14];\n            int bytesRead;\n            while ( (bytesRead = bis.read(buffer, 0, buffer.length)) != -1 ) {\n                messageDigest.update(buffer, 0, bytesRead);", "refactored_code": "    private static final int SIXTEEN_K = 1 << 14;\n        BufferedInputStream bis = new BufferedInputStream(is);\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            byte[] buffer = new byte[SIXTEEN_K];\n            int bytesRead;\n            while ( (bytesRead = bis.read(buffer, 0, buffer.length)) != -1 ) {\n                messageDigest.update(buffer, 0, bytesRead);"}
{"magic_number_smell": "                buf.append('+');\n            } else {\n                buf.append(\"%\");\n                final char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n                final char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n                buf.append(hex1);\n                buf.append(hex2);", "refactored_code": "    private static final int RADIX = 16;\n                buf.append('+');\n            } else {\n                buf.append(\"%\");\n                final char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));\n                final char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));\n                buf.append(hex1);\n                buf.append(hex2);"}
{"magic_number_smell": "        TestCredentialsProvider credentialsProvider = new TestCredentialsProvider();\n\n        // The provider should not refresh credentials when they aren't close to expiring and are recent\n        stubForSuccessResonseWithCustomExpirationDate(200, DateUtils.formatISO8601Date(new Date(System.currentTimeMillis() + 1000L * 60 * 60 * 24)).toString());\n        credentialsProvider.getCredentials();\n        assertFalse(credentialsProvider.needsToLoadCredentials());\n", "refactored_code": "    private static final long ONE_MINUTE = 1000L * 60;\n        TestCredentialsProvider credentialsProvider = new TestCredentialsProvider();\n\n        // The provider should not refresh credentials when they aren't close to expiring and are recent\n        stubForSuccessResonseWithCustomExpirationDate(200, DateUtils.formatISO8601Date(new Date(System.currentTimeMillis() + ONE_MINUTE * 60 * 24)).toString());\n        credentialsProvider.getCredentials();\n        assertFalse(credentialsProvider.needsToLoadCredentials());\n"}
{"magic_number_smell": "        // Swap out the credential.\n        FileUtils.writeStringToFile(profilesFile, REFRESHED_CREDS);\n\n        final CyclicBarrier barrier = new CyclicBarrier(10);\n\n        // Thread runnable will increment the count in the map for the key it got.\n        final Runnable credentialGetter = new Runnable() {", "refactored_code": "    private static final int THREAD_COUNT = 10;\n        // Swap out the credential.\n        FileUtils.writeStringToFile(profilesFile, REFRESHED_CREDS);\n\n        final CyclicBarrier barrier = new CyclicBarrier(THREAD_COUNT);\n\n        // Thread runnable will increment the count in the map for the key it got.\n        final Runnable credentialGetter = new Runnable() {"}
{"magic_number_smell": "    @Test(timeout = 60 * 1000)\n    public void testSslHandshakeTimeout() {\n        AmazonHttpClient httpClient = new AmazonHttpClient(new ClientConfiguration()\n                .withSocketTimeout(1 * 1000).withMaxErrorRetry(0));\n\n        System.out.println(\"Sending request to localhost...\");\n", "refactored_code": "    private static final int CLIENT_SOCKET_TO = 1 * 1000;\n    @Test(timeout = 60 * 1000)\n    public void testSslHandshakeTimeout() {\n        AmazonHttpClient httpClient = new AmazonHttpClient(new ClientConfiguration()\n                .withSocketTimeout(CLIENT_SOCKET_TO).withMaxErrorRetry(0));\n\n        System.out.println(\"Sending request to localhost...\");\n"}
{"magic_number_smell": "\n    private static void waitBeforeAssertOnExecutor() {\n        try {\n            Thread.sleep(500);\n        } catch (InterruptedException ignored) {\n        }\n    }", "refactored_code": "    private static final int WAIT_BEFORE_ASSERT_ON_EXECUTOR = 500;\n\n    private static void waitBeforeAssertOnExecutor() {\n        try {\n            Thread.sleep(WAIT_BEFORE_ASSERT_ON_EXECUTOR);\n        } catch (InterruptedException ignored) {\n        }\n    }"}
{"magic_number_smell": "    @Override\n    protected MockServer buildMockServer() {\n        return new MockServer(\n                MockServer.DummyResponseServerBehavior.build(500, \"Internal Server Failure\", \"Dummy response\"));\n    }\n\n    @Test(timeout = TEST_TIMEOUT, expected = ClientExecutionTimeoutException.class)", "refactored_code": "    private static final int STATUS_CODE = 500;\n    @Override\n    protected MockServer buildMockServer() {\n        return new MockServer(\n                MockServer.DummyResponseServerBehavior.build(STATUS_CODE, \"Internal Server Failure\", \"Dummy response\"));\n    }\n\n    @Test(timeout = TEST_TIMEOUT, expected = ClientExecutionTimeoutException.class)"}
{"magic_number_smell": "\n    @Override\n    protected MockServer buildMockServer() {\n        return new MockServer(MockServer.DummyResponseServerBehavior.build(200, \"OK\", \"Hi\"));\n    }\n\n    @Test(timeout = TEST_TIMEOUT, expected = ClientExecutionTimeoutException.class)", "refactored_code": "    private static final int STATUS_CODE = 200;\n\n    @Override\n    protected MockServer buildMockServer() {\n        return new MockServer(MockServer.DummyResponseServerBehavior.build(STATUS_CODE, \"OK\", \"Hi\"));\n    }\n\n    @Test(timeout = TEST_TIMEOUT, expected = ClientExecutionTimeoutException.class)"}
{"magic_number_smell": "    public void clientExecutionTimeoutEnabled_WithLongerSocketTimeout_ThrowsClientExecutionTimeoutException()\n            throws IOException {\n        httpClient = new AmazonHttpClient(new ClientConfiguration().withClientExecutionTimeout(CLIENT_EXECUTION_TIMEOUT)\n                .withSocketTimeout(CLIENT_EXECUTION_TIMEOUT * PRECISION_MULTIPLIER).withMaxErrorRetry(0));\n\n        try {\n            httpClient.requestExecutionBuilder().request(newGetRequest()).execute();", "refactored_code": "    private static final int LONGER_SOCKET_TIMEOUT = CLIENT_EXECUTION_TIMEOUT * PRECISION_MULTIPLIER;\n    public void clientExecutionTimeoutEnabled_WithLongerSocketTimeout_ThrowsClientExecutionTimeoutException()\n            throws IOException {\n        httpClient = new AmazonHttpClient(new ClientConfiguration().withClientExecutionTimeout(CLIENT_EXECUTION_TIMEOUT)\n                .withSocketTimeout(LONGER_SOCKET_TIMEOUT).withMaxErrorRetry(0));\n\n        try {\n            httpClient.requestExecutionBuilder().request(newGetRequest()).execute();"}
{"magic_number_smell": "    @Override\n    protected MockServer buildMockServer() {\n        return new MockServer(\n                MockServer.DummyResponseServerBehavior.build(500, \"Internal Server Failure\", \"Dummy response\"));\n    }\n\n    @Test(timeout = TEST_TIMEOUT)", "refactored_code": "    private static final int STATUS_CODE = 500;\n    @Override\n    protected MockServer buildMockServer() {\n        return new MockServer(\n                MockServer.DummyResponseServerBehavior.build(STATUS_CODE, \"Internal Server Failure\", \"Dummy response\"));\n    }\n\n    @Test(timeout = TEST_TIMEOUT)"}
{"magic_number_smell": "public class UnresponsiveServerTests extends UnresponsiveMockServerTestBase {\n\n    private static final int 5 * 1000 = 5 * 1000;\n    private static final int LONGER_SOCKET_TIMEOUT = 5 * 1000 * PRECISION_MULTIPLIER;\n    private static final int SHORTER_SOCKET_TIMEOUT = 5 * 1000 / PRECISION_MULTIPLIER;\n\n    private AmazonHttpClient httpClient;", "refactored_code": "    private static final int REQUEST_TIMEOUT = 5 * 1000;\npublic class UnresponsiveServerTests extends UnresponsiveMockServerTestBase {\n\n    private static final int REQUEST_TIMEOUT = 5 * 1000;\n    private static final int LONGER_SOCKET_TIMEOUT = REQUEST_TIMEOUT * PRECISION_MULTIPLIER;\n    private static final int SHORTER_SOCKET_TIMEOUT = REQUEST_TIMEOUT / PRECISION_MULTIPLIER;\n\n    private AmazonHttpClient httpClient;"}
{"magic_number_smell": "        @Override\n        public boolean shouldRetry(int retriesAttempted, CredentialsEndpointRetryParameters retryParams) {\n\n            if (retriesAttempted >= 3) {\n                return false;\n            }\n", "refactored_code": "        private static final int MAX_RETRIES = 3;\n        @Override\n        public boolean shouldRetry(int retriesAttempted, CredentialsEndpointRetryParameters retryParams) {\n\n            if (retriesAttempted >= MAX_RETRIES) {\n                return false;\n            }\n"}
{"magic_number_smell": "                lastCalculatedRate = tb.cubicSuccess(tc.timestamp);\n            }\n\n            assertThat(lastCalculatedRate, closeTo(tc.expectedCalculatedRate, 1E-6));\n        }\n    }\n", "refactored_code": "    private static final double EPSILON = 1E-6;\n                lastCalculatedRate = tb.cubicSuccess(tc.timestamp);\n            }\n\n            assertThat(lastCalculatedRate, closeTo(tc.expectedCalculatedRate, EPSILON));\n        }\n    }\n"}
{"magic_number_smell": "        TOKEN_BUCKET.updateClientSendingRate(testCase.throttled);\n\n        assertThat(\"The calculated fill rate is not within error of the expected value\",\n                TOKEN_BUCKET.getFillRate(), closeTo(testCase.expectedNewFillRate, 1E-6));\n        assertThat(\"The calculated tx rate is not within error of the expected value\",\n                TOKEN_BUCKET.getMeasuredTxRate(), closeTo(testCase.measuredTxRate, 1E-6));\n", "refactored_code": "    private static final double EPSILON = 1E-6;\n        TOKEN_BUCKET.updateClientSendingRate(testCase.throttled);\n\n        assertThat(\"The calculated fill rate is not within error of the expected value\",\n                TOKEN_BUCKET.getFillRate(), closeTo(testCase.expectedNewFillRate, EPSILON));\n        assertThat(\"The calculated tx rate is not within error of the expected value\",\n                TOKEN_BUCKET.getMeasuredTxRate(), closeTo(testCase.measuredTxRate, EPSILON));\n"}
{"magic_number_smell": "public class AmazonHttpClientRetryPolicyTest extends RetryPolicyTestBase {\n\n    private static final int 5 = 5;\n    private static final int EXPECTED_SHOULD_RETRY_CALL_COUNT = 5 + 1;\n    private static final Random random = new Random();\n    private AmazonHttpClient testedClient;\n", "refactored_code": "    private static final int EXPECTED_RETRY_COUNT = 5;\npublic class AmazonHttpClientRetryPolicyTest extends RetryPolicyTestBase {\n\n    private static final int EXPECTED_RETRY_COUNT = 5;\n    private static final int EXPECTED_SHOULD_RETRY_CALL_COUNT = EXPECTED_RETRY_COUNT + 1;\n    private static final Random random = new Random();\n    private AmazonHttpClient testedClient;\n"}
{"magic_number_smell": "\npublic class ClockSkewAdjusterTest {\n    private static final int 60 * 60 = 60 * 60;\n    private static final int SKEWED_MILLIS = 60 * 60 * 1000;\n\n    private ClockSkewAdjuster adjuster = new ClockSkewAdjuster();\n    private Date unskewedDate = new Date();", "refactored_code": "    private static final int SKEWED_SECONDS = 60 * 60;\n\npublic class ClockSkewAdjusterTest {\n    private static final int SKEWED_SECONDS = 60 * 60;\n    private static final int SKEWED_MILLIS = SKEWED_SECONDS * 1000;\n\n    private ClockSkewAdjuster adjuster = new ClockSkewAdjuster();\n    private Date unskewedDate = new Date();"}
{"magic_number_smell": "    @Test\n    public void testFullJitterStrategy() {\n        int[] expectedLowerBound = new int[10];\n        expectInRange(new PredefinedBackoffStrategies.FullJitterBackoffStrategy(100, BOUNDED_MAX_DELAY), expectedLowerBound, EXPONENTIAL_BACKOFF_VALUES);\n        expectMeanIncreasing(new PredefinedBackoffStrategies.FullJitterBackoffStrategy(100, UNBOUNDED_MAX_DELAY));\n        expectNonZeroStandardDeviation(new PredefinedBackoffStrategies.FullJitterBackoffStrategy(100, UNBOUNDED_MAX_DELAY));\n    }", "refactored_code": "    private static final int BASE_DELAY = 100;\n    @Test\n    public void testFullJitterStrategy() {\n        int[] expectedLowerBound = new int[10];\n        expectInRange(new PredefinedBackoffStrategies.FullJitterBackoffStrategy(BASE_DELAY, BOUNDED_MAX_DELAY), expectedLowerBound, EXPONENTIAL_BACKOFF_VALUES);\n        expectMeanIncreasing(new PredefinedBackoffStrategies.FullJitterBackoffStrategy(BASE_DELAY, UNBOUNDED_MAX_DELAY));\n        expectNonZeroStandardDeviation(new PredefinedBackoffStrategies.FullJitterBackoffStrategy(BASE_DELAY, UNBOUNDED_MAX_DELAY));\n    }"}
{"magic_number_smell": "        assertEquals(\"stringVal\", node.get(\"stringProp\").textValue());\n        assertEquals(42, node.get(\"integralProp\").longValue());\n        assertEquals(true, node.get(\"booleanProp\").booleanValue());\n        assertEquals(123.456, node.get(\"doubleProp\").doubleValue(), .0001);\n    }\n\n    @Test", "refactored_code": "    private static final double DELTA = .0001;\n        assertEquals(\"stringVal\", node.get(\"stringProp\").textValue());\n        assertEquals(42, node.get(\"integralProp\").longValue());\n        assertEquals(true, node.get(\"booleanProp\").booleanValue());\n        assertEquals(123.456, node.get(\"doubleProp\").doubleValue(), DELTA);\n    }\n\n    @Test"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSCostAndUsageReportAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSCostAndUsageReportAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public DataPipelineAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public DataPipelineAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSDeviceFarmAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSDeviceFarmAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonDirectConnectAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonDirectConnectAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSDirectoryServiceAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSDirectoryServiceAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSApplicationDiscoveryAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSApplicationDiscoveryAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSDatabaseMigrationServiceAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSDatabaseMigrationServiceAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonDynamoDBAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonDynamoDBAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonDynamoDBStreamsAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonDynamoDBStreamsAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "        @Override\n        public boolean shouldRetry(BatchLoadContext batchLoadContext) {\n            Map<String, KeysAndAttributes> unprocessedKeys = batchLoadContext.getBatchGetItemResult().getUnprocessedKeys();\n            return (unprocessedKeys != null && unprocessedKeys.size() > 0 && batchLoadContext.getRetriesAttempted() < 5);\n        }\n\n        public final DynamoDBMapperConfig config() {", "refactored_code": "        private static final int MAX_RETRIES = 5;\n        @Override\n        public boolean shouldRetry(BatchLoadContext batchLoadContext) {\n            Map<String, KeysAndAttributes> unprocessedKeys = batchLoadContext.getBatchGetItemResult().getUnprocessedKeys();\n            return (unprocessedKeys != null && unprocessedKeys.size() > 0 && batchLoadContext.getRetriesAttempted() < MAX_RETRIES);\n        }\n\n        public final DynamoDBMapperConfig config() {"}
{"magic_number_smell": "     * Source and target conversion type pair.\n     */\n    private static final class Key<S,T> extends SimpleImmutableEntry<Class<S>,Class<T>> {\n        private static final long -1L = -1L;\n\n        private Key(Class<S> sourceType, Class<T> targetType) {\n            super(sourceType, targetType);", "refactored_code": "        private static final long serialVersionUID = -1L;\n     * Source and target conversion type pair.\n     */\n    private static final class Key<S,T> extends SimpleImmutableEntry<Class<S>,Class<T>> {\n        private static final long serialVersionUID = -1L;\n\n        private Key(Class<S> sourceType, Class<T> targetType) {\n            super(sourceType, targetType);"}
{"magic_number_smell": "                                return desc;\n                            case CREATING:\n                            case UPDATING:\n                                Thread.sleep(5000);\n                                continue retry;\n                            default:\n                                throw new IllegalArgumentException(", "refactored_code": "    private static final long SLEEP_TIME_MILLIS = 5000;\n                                return desc;\n                            case CREATING:\n                            case UPDATING:\n                                Thread.sleep(SLEEP_TIME_MILLIS);\n                                continue retry;\n                            default:\n                                throw new IllegalArgumentException("}
{"magic_number_smell": "                if (TableStatus.fromValue(status) == TableStatus.ACTIVE)\n                    return desc;\n                else\n                    Thread.sleep(5000);\n            }\n        } catch(ResourceNotFoundException deleted) {\n        }", "refactored_code": "    private static final long SLEEP_TIME_MILLIS = 5000;\n                if (TableStatus.fromValue(status) == TableStatus.ACTIVE)\n                    return desc;\n                else\n                    Thread.sleep(SLEEP_TIME_MILLIS);\n            }\n        } catch(ResourceNotFoundException deleted) {\n        }"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonEC2AsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonEC2AsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonECRAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonECRAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonECSAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonECSAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonElasticFileSystemAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonElasticFileSystemAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonElastiCacheAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonElastiCacheAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSElasticBeanstalkAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSElasticBeanstalkAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonElasticLoadBalancingAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonElasticLoadBalancingAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonElasticLoadBalancingAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonElasticLoadBalancingAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSElasticsearchAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSElasticsearchAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonElasticTranscoderAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonElasticTranscoderAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonElasticMapReduceAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonElasticMapReduceAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonCloudWatchEventsAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonCloudWatchEventsAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonGameLiftAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonGameLiftAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonGlacierAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonGlacierAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "        int totalBytesRead = 0;\n        int lastBytesRead = 0;\n        while ( totalBytesRead < len && lastBytesRead > -1 ) {\n            int bytesToRead = Math.min(1024 * 1024 - byteOffset, len - totalBytesRead);\n\n            lastBytesRead = super.read(b, off + totalBytesRead, bytesToRead);\n            if ( lastBytesRead > 0 ) {", "refactored_code": "    private static final int MB = 1024 * 1024;\n        int totalBytesRead = 0;\n        int lastBytesRead = 0;\n        while ( totalBytesRead < len && lastBytesRead > -1 ) {\n            int bytesToRead = Math.min(MB - byteOffset, len - totalBytesRead);\n\n            lastBytesRead = super.read(b, off + totalBytesRead, bytesToRead);\n            if ( lastBytesRead > 0 ) {"}
{"magic_number_smell": "    private long calculatePartSize(long fileSize) {\n        long partSize = MINIMUM_PART_SIZE;\n        int approxNumParts = 1;\n        while (partSize * approxNumParts < fileSize && partSize*2 <= 1024L * 1024 * 1024 * 4) {\n            partSize *= 2;\n            approxNumParts *= 2;\n        }", "refactored_code": "    private static final long MAXIMUM_UPLOAD_PART_SIZE = 1024L * 1024 * 1024 * 4;\n    private long calculatePartSize(long fileSize) {\n        long partSize = MINIMUM_PART_SIZE;\n        int approxNumParts = 1;\n        while (partSize * approxNumParts < fileSize && partSize*2 <= MAXIMUM_UPLOAD_PART_SIZE) {\n            partSize *= 2;\n            approxNumParts *= 2;\n        }"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSHealthAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSHealthAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonIdentityManagementAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonIdentityManagementAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonImportExportAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonImportExportAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonInspectorAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonInspectorAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSIotAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSIotAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSIotDataAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSIotDataAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonKinesisAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonKinesisAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonKinesisAnalyticsAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonKinesisAnalyticsAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonKinesisFirehoseAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonKinesisFirehoseAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "\n    /**\n     * Sets the timeout (in milliseconds) when establishing new connections to the service. The default if not specified is\n     * {@value #10000} milliseconds.\n     *\n     * @param connectionTimeoutInMillis New connection timeout value in milliseconds.\n     */", "refactored_code": "    private static final int DEFAULT_CONNECTION_TIMEOUT = 10000;\n\n    /**\n     * Sets the timeout (in milliseconds) when establishing new connections to the service. The default if not specified is\n     * {@value #DEFAULT_CONNECTION_TIMEOUT} milliseconds.\n     *\n     * @param connectionTimeoutInMillis New connection timeout value in milliseconds.\n     */"}
{"magic_number_smell": "        for (; readerIndex < writerIndex; ++readerIndex) {\n            // Read one byte at a time to avoid incrementing reader index\n            byte c = in.getByte(readerIndex);\n            if ('\n' == c) {\n                ByteBuf json = extractObject(in, in.readerIndex(), readerIndex - in.readerIndex());\n                if (json != null) {\n                    decodedOut.add(unmarshall(json));", "refactored_code": "    private static final byte NEW_LINE = '\\n';\n        for (; readerIndex < writerIndex; ++readerIndex) {\n            // Read one byte at a time to avoid incrementing reader index\n            byte c = in.getByte(readerIndex);\n            if (NEW_LINE == c) {\n                ByteBuf json = extractObject(in, in.readerIndex(), readerIndex - in.readerIndex());\n                if (json != null) {\n                    decodedOut.add(unmarshall(json));"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSKMSAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSKMSAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSLambdaAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSLambdaAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonLightsailAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonLightsailAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSLogsAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSLogsAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonMachineLearningAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonMachineLearningAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSMarketplaceCommerceAnalyticsAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSMarketplaceCommerceAnalyticsAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSMarketplaceMeteringAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSMarketplaceMeteringAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "    protected ClientConfiguration getDefaultConfig() {\n        return super.getDefaultConfig().withRetryPolicy(PredefinedRetryPolicies.NO_RETRY_POLICY)\n                                        .withCacheResponseMetadata(DEFAULT_CACHE_RESPONSE_METADATA)\n                                        .withSocketTimeout(35 * 1000);\n    }\n\n    @Override", "refactored_code": "    public static final int DEFAULT_SOCKET_TIMEOUT = 35 * 1000;\n    protected ClientConfiguration getDefaultConfig() {\n        return super.getDefaultConfig().withRetryPolicy(PredefinedRetryPolicies.NO_RETRY_POLICY)\n                                        .withCacheResponseMetadata(DEFAULT_CACHE_RESPONSE_METADATA)\n                                        .withSocketTimeout(DEFAULT_SOCKET_TIMEOUT);\n    }\n\n    @Override"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSOpsWorksAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSOpsWorksAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSOpsWorksCMAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSOpsWorksCMAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSOrganizationsAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSOrganizationsAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonPinpointAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonPinpointAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonPollyAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonPollyAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "\n    /**\n     * Presign a {@link SynthesizeSpeechRequest} to be vended to consumers. The expiration time of the presigned URL is {@value\n     * #15} from generation time.\n     */\n    public URL getPresignedSynthesizeSpeechUrl(SynthesizeSpeechPresignRequest synthesizeSpeechPresignRequest) {\n        Request<?> request = newRequest(synthesizeSpeechPresignRequest.getSigningCredentials());", "refactored_code": "    private static final int SYNTHESIZE_SPEECH_DEFAULT_EXPIRATION_MINUTES = 15;\n\n    /**\n     * Presign a {@link SynthesizeSpeechRequest} to be vended to consumers. The expiration time of the presigned URL is {@value\n     * #SYNTHESIZE_SPEECH_DEFAULT_EXPIRATION_MINUTES} from generation time.\n     */\n    public URL getPresignedSynthesizeSpeechUrl(SynthesizeSpeechPresignRequest synthesizeSpeechPresignRequest) {\n        Request<?> request = newRequest(synthesizeSpeechPresignRequest.getSigningCredentials());"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonRDSAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonRDSAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "    }\n\n    private Date getExpirationDate() {\n        return new DateTime(clock.currentTimeMillis()).plusMinutes(15).toDate();\n    }\n\n    public static Builder builder() {", "refactored_code": "    private static final int DEFAULT_EXPIRATION_IN_MINUTES = 15;\n    }\n\n    private Date getExpirationDate() {\n        return new DateTime(clock.currentTimeMillis()).plusMinutes(DEFAULT_EXPIRATION_IN_MINUTES).toDate();\n    }\n\n    public static Builder builder() {"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonRedshiftAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonRedshiftAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonRekognitionAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonRekognitionAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonRoute53AsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonRoute53AsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonRoute53DomainsAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonRoute53DomainsAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "            decodedStreamBuffer = null;\n        }\n\n        if (maxBufferSize < 128 * 1024)\n            throw new IllegalArgumentException(\"Max buffer size should not be less than chunk size\");\n        try {\n            this.sha256 = MessageDigest.getInstance(\"SHA-256\");", "refactored_code": "    private static final int DEFAULT_CHUNK_SIZE = 128 * 1024;\n            decodedStreamBuffer = null;\n        }\n\n        if (maxBufferSize < DEFAULT_CHUNK_SIZE)\n            throw new IllegalArgumentException(\"Max buffer size should not be less than chunk size\");\n        try {\n            this.sha256 = MessageDigest.getInstance(\"SHA-256\");"}
{"magic_number_smell": "    private static final int 300 = 300;\n\n    private static final Map<String, String> bucketRegionCache =\n                 Collections.synchronizedMap(new LinkedHashMap<String, String>(300, 1.1f, true) {\n                     private static final long serialVersionUID = 23453L;\n\n                     @Override", "refactored_code": "    private static final int BUCKET_REGION_CACHE_SIZE = 300;\n    private static final int BUCKET_REGION_CACHE_SIZE = 300;\n\n    private static final Map<String, String> bucketRegionCache =\n                 Collections.synchronizedMap(new LinkedHashMap<String, String>(BUCKET_REGION_CACHE_SIZE, 1.1f, true) {\n                     private static final long serialVersionUID = 23453L;\n\n                     @Override"}
{"magic_number_smell": "\n        Integer outpostIdEndIndex = null;\n\n        for (int i = \"outpost\".length() + 1; i < resource.length(); ++i) {\n            char ch = resource.charAt(i);\n\n            if (ch == ':' || ch == '/') {", "refactored_code": "    private static final int OUTPOST_ID_START_INDEX = \"outpost\".length() + 1;\n\n        Integer outpostIdEndIndex = null;\n\n        for (int i = OUTPOST_ID_START_INDEX; i < resource.length(); ++i) {\n            char ch = resource.charAt(i);\n\n            if (ch == ':' || ch == '/') {"}
{"magic_number_smell": "            return exception(throwOnError, \"Bucket name cannot be null\");\n        }\n\n        if (bucketName.length() < 3 ||\n            bucketName.length() > MAX_BUCKET_NAME_LENGTH) {\n\n            return exception(", "refactored_code": "    private static final int MIN_BUCKET_NAME_LENGTH = 3;\n            return exception(throwOnError, \"Bucket name cannot be null\");\n        }\n\n        if (bucketName.length() < MIN_BUCKET_NAME_LENGTH ||\n            bucketName.length() > MAX_BUCKET_NAME_LENGTH) {\n\n            return exception("}
{"magic_number_smell": "    private final int maxCompleteMultipartUploadRetries;\n\n    public CompleteMultipartUploadRetryCondition() {\n        this(new CompleteMultipartUploadRetryablePredicate(), 3);\n    }\n\n    /**", "refactored_code": "    private static final int MAX_RETRY_ATTEMPTS = 3;\n    private final int maxCompleteMultipartUploadRetries;\n\n    public CompleteMultipartUploadRetryCondition() {\n        this(new CompleteMultipartUploadRetryablePredicate(), MAX_RETRY_ATTEMPTS);\n    }\n\n    /**"}
{"magic_number_smell": "            long skippedBytes = super.skip(requestedOffset - currentPosition);\n            if (skippedBytes == 0) {\n                count++;\n                if (count > 100) {\n                    throw new SdkClientException(\n                            \"Unable to position the currentPosition from \"\n                                    + currentPosition + \" to \"", "refactored_code": "    private static final int MAX_SKIPS = 100;\n            long skippedBytes = super.skip(requestedOffset - currentPosition);\n            if (skippedBytes == 0) {\n                count++;\n                if (count > MAX_SKIPS) {\n                    throw new SdkClientException(\n                            \"Unable to position the currentPosition from \"\n                                    + currentPosition + \" to \""}
{"magic_number_smell": "            int count=0;\n            int len;\n            do {\n                if (count > 1000)\n                    throw new IOException(\"exceeded maximum number of attempts to read next chunk of data\");\n                len = nextChunk();\n                // if buf != null, it means that data is being read off of the InputStream", "refactored_code": "    private static final int MAX_RETRY = 1000;\n            int count=0;\n            int len;\n            do {\n                if (count > MAX_RETRY)\n                    throw new IOException(\"exceeded maximum number of attempts to read next chunk of data\");\n                len = nextChunk();\n                // if buf != null, it means that data is being read off of the InputStream"}
{"magic_number_smell": "    public byte[] unwrapCek(byte[] encryptedCek, Key key) {\n        ByteBuffer encryptedCekBuff = ByteBuffer.wrap(encryptedCek);\n        // Split the IV from the front of the ciphertext\n        byte[] iv = new byte[12];\n        byte[] taggedCek = new byte[encryptedCek.length - 12];\n        encryptedCekBuff.get(iv);\n        encryptedCekBuff.get(taggedCek);", "refactored_code": "    private static final int IV_LENGTH_IN_BYTES = 12;\n    public byte[] unwrapCek(byte[] encryptedCek, Key key) {\n        ByteBuffer encryptedCekBuff = ByteBuffer.wrap(encryptedCek);\n        // Split the IV from the front of the ciphertext\n        byte[] iv = new byte[IV_LENGTH_IN_BYTES];\n        byte[] taggedCek = new byte[encryptedCek.length - IV_LENGTH_IN_BYTES];\n        encryptedCekBuff.get(iv);\n        encryptedCekBuff.get(taggedCek);"}
{"magic_number_smell": "                                        req.isLastPart());\n            return cipherLite.markSupported()\n                   ? new CipherLiteInputStream(isCurr, cipherLite,\n                                               1024*2,\n                                               IS_MULTI_PART, req.isLastPart())\n                   : new RenewableCipherLiteInputStream(isCurr, cipherLite,\n                                                        1024*2,", "refactored_code": "    protected static final int DEFAULT_BUFFER_SIZE = 1024*2;    // 2K\n                                        req.isLastPart());\n            return cipherLite.markSupported()\n                   ? new CipherLiteInputStream(isCurr, cipherLite,\n                                               DEFAULT_BUFFER_SIZE,\n                                               IS_MULTI_PART, req.isLastPart())\n                   : new RenewableCipherLiteInputStream(isCurr, cipherLite,\n                                                        DEFAULT_BUFFER_SIZE,"}
{"magic_number_smell": "                                        req.isLastPart());\n            return cipherLite.markSupported()\n                   ? new CipherLiteInputStream(isCurr, cipherLite,\n                                               1024*2,\n                                               IS_MULTI_PART, req.isLastPart())\n                   : new RenewableCipherLiteInputStream(isCurr, cipherLite,\n                                                        1024*2,", "refactored_code": "    protected static final int DEFAULT_BUFFER_SIZE = 1024*2;    // 2K\n                                        req.isLastPart());\n            return cipherLite.markSupported()\n                   ? new CipherLiteInputStream(isCurr, cipherLite,\n                                               DEFAULT_BUFFER_SIZE,\n                                               IS_MULTI_PART, req.isLastPart())\n                   : new RenewableCipherLiteInputStream(isCurr, cipherLite,\n                                                        DEFAULT_BUFFER_SIZE,"}
{"magic_number_smell": " */\npublic class Message {\n    private static final int 4 = 4;\n    static final int MESSAGE_OVERHEAD = Prelude.LENGTH_WITH_CRC + 4;\n\n    private final Map<String, HeaderValue> headers;\n    private final byte[] payload;", "refactored_code": "    private static final int TRAILING_CRC_LENGTH = 4;\n */\npublic class Message {\n    private static final int TRAILING_CRC_LENGTH = 4;\n    static final int MESSAGE_OVERHEAD = Prelude.LENGTH_WITH_CRC + TRAILING_CRC_LENGTH;\n\n    private final Map<String, HeaderValue> headers;\n    private final byte[] payload;"}
{"magic_number_smell": "     * and is not strictly guaranteed.  As a result this timeout should not be relied on in cases where exact precision is\n     * required.\n     */\n    private long timeoutMillis = -1L;\n\n    /**\n     * Set the download size while making partial S3 GET requests. This parameter is used in parallel downloads.", "refactored_code": "    private static final long DEFAULT_TIMEOUT = -1L;\n     * and is not strictly guaranteed.  As a result this timeout should not be relied on in cases where exact precision is\n     * required.\n     */\n    private long timeoutMillis = DEFAULT_TIMEOUT;\n\n    /**\n     * Set the download size while making partial S3 GET requests. This parameter is used in parallel downloads."}
{"magic_number_smell": "\n            objectContent = object.getObjectContent();\n\n            final byte[] buffer = new byte[2 * MB];\n            int bytesRead;\n\n            final ByteBuffer byteBuffer = ByteBuffer.wrap(buffer);", "refactored_code": "    private static final int BUFFER_SIZE = 2 * MB;\n\n            objectContent = object.getObjectContent();\n\n            final byte[] buffer = new byte[BUFFER_SIZE];\n            int bytesRead;\n\n            final ByteBuffer byteBuffer = ByteBuffer.wrap(buffer);"}
{"magic_number_smell": "\n    private String getUploadIdOrTimeout() {\n        try {\n            return multipartUploadId.get(30, TimeUnit.SECONDS);\n        } catch (Exception e) {\n            throw new IllegalStateException(\"Failed to retrieve an upload ID after \" +\n                                            30 + \" seconds.\");", "refactored_code": "    private final int MULTIPART_UPLOAD_ID_RETRIEVAL_TIMEOUT_SECONDS = 30;\n\n    private String getUploadIdOrTimeout() {\n        try {\n            return multipartUploadId.get(MULTIPART_UPLOAD_ID_RETRIEVAL_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n        } catch (Exception e) {\n            throw new IllegalStateException(\"Failed to retrieve an upload ID after \" +\n                                            MULTIPART_UPLOAD_ID_RETRIEVAL_TIMEOUT_SECONDS + \" seconds.\");"}
{"magic_number_smell": "\n    private void skipBytes(FileInputStream fs, long n) throws IOException {\n        long skippedSoFar = 0;\n        for (int skips = 0; skips < 100 && skippedSoFar < n; ++skips) {\n            skippedSoFar += fs.skip(n - skippedSoFar);\n        }\n        if (skippedSoFar != n) {", "refactored_code": "    private static final int MAX_SKIPS = 100;\n\n    private void skipBytes(FileInputStream fs, long n) throws IOException {\n        long skippedSoFar = 0;\n        for (int skips = 0; skips < MAX_SKIPS && skippedSoFar < n; ++skips) {\n            skippedSoFar += fs.skip(n - skippedSoFar);\n        }\n        if (skippedSoFar != n) {"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSServerMigrationAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSServerMigrationAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSServiceCatalogAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSServiceCatalogAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonSimpleEmailServiceAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonSimpleEmailServiceAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSShieldAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSShieldAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonSimpleDBAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonSimpleDBAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonSimpleWorkflowAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonSimpleWorkflowAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonSnowballAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonSnowballAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonSNSAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonSNSAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonSQSAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonSQSAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    private static void updateLengthAndBytes(MessageDigest digest, String str) throws UnsupportedEncodingException {\n        byte[] utf8Encoded = str.getBytes(UTF8);\n        ByteBuffer lengthBytes = ByteBuffer.allocate(4).putInt(utf8Encoded.length);\n        digest.update(lengthBytes.array());\n        digest.update(utf8Encoded);\n    }", "refactored_code": "    private static final int INTEGER_SIZE_IN_BYTES = 4;\n     */\n    private static void updateLengthAndBytes(MessageDigest digest, String str) throws UnsupportedEncodingException {\n        byte[] utf8Encoded = str.getBytes(UTF8);\n        ByteBuffer lengthBytes = ByteBuffer.allocate(INTEGER_SIZE_IN_BYTES).putInt(utf8Encoded.length);\n        digest.update(lengthBytes.array());\n        digest.update(utf8Encoded);\n    }"}
{"magic_number_smell": "    public QueueBufferConfig() {\n        this(MAX_BATCH_OPEN_MS_DEFAULT, MAX_INFLIGHT_OUTBOUND_BATCHES_DEFAULT, MAX_INFLIGHT_RECEIVE_BATCHES_DEFAULT,\n                MAX_DONE_RECEIVE_BATCHES_DEFAULT, LONG_POLL_DEFAULT, MAX_BATCH_SIZE_BYTES_DEFAULT,\n                VISIBILITY_TIMEOUT_SECONDS_DEFAULT, LONGPOLL_WAIT_TIMEOUT_SECONDS_DEFAULT, 10);\n    }\n\n    /** copy constructor */", "refactored_code": "    public static final int MAX_BATCH_SIZE_DEFAULT = 10;\n    public QueueBufferConfig() {\n        this(MAX_BATCH_OPEN_MS_DEFAULT, MAX_INFLIGHT_OUTBOUND_BATCHES_DEFAULT, MAX_INFLIGHT_RECEIVE_BATCHES_DEFAULT,\n                MAX_DONE_RECEIVE_BATCHES_DEFAULT, LONG_POLL_DEFAULT, MAX_BATCH_SIZE_BYTES_DEFAULT,\n                VISIBILITY_TIMEOUT_SECONDS_DEFAULT, LONGPOLL_WAIT_TIMEOUT_SECONDS_DEFAULT, MAX_BATCH_SIZE_DEFAULT);\n    }\n\n    /** copy constructor */"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSSimpleSystemsManagementAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSSimpleSystemsManagementAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSStepFunctionsAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSStepFunctionsAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSStorageGatewayAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSStorageGatewayAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "    private void blockingRefresh() {\n        try {\n            if (blockingRefreshLock\n                    .tryLock(5, TimeUnit.SECONDS)) {\n                try {\n                    // Return if successful refresh occurred while waiting for the lock\n                    if (!shouldDoBlockingRefresh()) {", "refactored_code": "    private static final long BLOCKING_REFRESH_MAX_WAIT_IN_SECONDS = 5;\n    private void blockingRefresh() {\n        try {\n            if (blockingRefreshLock\n                    .tryLock(BLOCKING_REFRESH_MAX_WAIT_IN_SECONDS, TimeUnit.SECONDS)) {\n                try {\n                    // Return if successful refresh occurred while waiting for the lock\n                    if (!shouldDoBlockingRefresh()) {"}
{"magic_number_smell": "        Date expiryTime = sessionCredentialsHolder.getSessionCredentialsExpiration();\n        if (expiryTime != null) {\n            long timeRemaining = expiryTime.getTime() - System.currentTimeMillis();\n            return timeRemaining < TimeUnit.MINUTES.toMillis(5);\n        }\n        return false;\n    }", "refactored_code": "    private static final long ASYNC_REFRESH_EXPIRATION_IN_MILLIS = TimeUnit.MINUTES.toMillis(5);\n        Date expiryTime = sessionCredentialsHolder.getSessionCredentialsExpiration();\n        if (expiryTime != null) {\n            long timeRemaining = expiryTime.getTime() - System.currentTimeMillis();\n            return timeRemaining < ASYNC_REFRESH_EXPIRATION_IN_MILLIS;\n        }\n        return false;\n    }"}
{"magic_number_smell": "     */\n    private static boolean expiring(Date expiry) {\n        long timeRemaining = expiry.getTime() - System.currentTimeMillis();\n        return timeRemaining < 60 * 1000;\n    }\n}\n", "refactored_code": "    private static final int EXPIRY_TIME_MILLIS = 60 * 1000;\n     */\n    private static boolean expiring(Date expiry) {\n        long timeRemaining = expiry.getTime() - System.currentTimeMillis();\n        return timeRemaining < EXPIRY_TIME_MILLIS;\n    }\n}\n"}
{"magic_number_smell": "        if (builder.roleSessionDurationSeconds != 0) {\n            this.roleSessionDurationSeconds = builder.roleSessionDurationSeconds;\n        } else {\n            this.roleSessionDurationSeconds = 900;\n        }\n\n        this.refreshableTask = createRefreshableTask(builder.asyncRefreshExecutor);", "refactored_code": "    public static final int DEFAULT_DURATION_SECONDS = 900;\n        if (builder.roleSessionDurationSeconds != 0) {\n            this.roleSessionDurationSeconds = builder.roleSessionDurationSeconds;\n        } else {\n            this.roleSessionDurationSeconds = DEFAULT_DURATION_SECONDS;\n        }\n\n        this.refreshableTask = createRefreshableTask(builder.asyncRefreshExecutor);"}
{"magic_number_smell": "     *            Primary AWS account credentials.\n     */\n    public STSSessionCredentials(AWSCredentials credentials) {\n        this(credentials, 3600);\n    }\n\n\t/**", "refactored_code": "    public static final int DEFAULT_DURATION_SECONDS = 3600;\n     *            Primary AWS account credentials.\n     */\n    public STSSessionCredentials(AWSCredentials credentials) {\n        this(credentials, DEFAULT_DURATION_SECONDS);\n    }\n\n\t/**"}
{"magic_number_smell": "\n    private SessionCredentialsHolder newSession() {\n        GetSessionTokenResult sessionTokenResult = securityTokenService.getSessionToken(\n                new GetSessionTokenRequest().withDurationSeconds(3600));\n        return new SessionCredentialsHolder(sessionTokenResult.getCredentials());\n    }\n", "refactored_code": "    public static final int DEFAULT_DURATION_SECONDS = 3600;\n\n    private SessionCredentialsHolder newSession() {\n        GetSessionTokenResult sessionTokenResult = securityTokenService.getSessionToken(\n                new GetSessionTokenRequest().withDurationSeconds(DEFAULT_DURATION_SECONDS));\n        return new SessionCredentialsHolder(sessionTokenResult.getCredentials());\n    }\n"}
{"magic_number_smell": "        this.wifProvider = wifProvider;\n        this.wifToken = wifToken;\n        this.roleArn = roleArn;\n        this.sessionDuration = 3600;\n        this.refreshThreshold = DEFAULT_THRESHOLD_SECONDS;\n    }\n", "refactored_code": "    public static final int DEFAULT_DURATION_SECONDS = 3600;\n        this.wifProvider = wifProvider;\n        this.wifToken = wifToken;\n        this.roleArn = roleArn;\n        this.sessionDuration = DEFAULT_DURATION_SECONDS;\n        this.refreshThreshold = DEFAULT_THRESHOLD_SECONDS;\n    }\n"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSSecurityTokenServiceAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSSecurityTokenServiceAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSSupportAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSSupportAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "            System.arraycopy(bytes, 0, b, off, bytesToRead);\n        } else {\n            for (int i = 0; i < bytesToRead; i++) {\n                b[off+i] = (byte) (RANDOM.nextInt(MAX_CHAR_CODE - 32) + 32);\n            }\n        }\n", "refactored_code": "    private static final int MIN_CHAR_CODE = 32;\n            System.arraycopy(bytes, 0, b, off, bytesToRead);\n        } else {\n            for (int i = 0; i < bytesToRead; i++) {\n                b[off+i] = (byte) (RANDOM.nextInt(MAX_CHAR_CODE - MIN_CHAR_CODE) + MIN_CHAR_CODE);\n            }\n        }\n"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSWAFAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSWAFAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSWAFRegionalAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSWAFRegionalAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AmazonWorkspacesAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AmazonWorkspacesAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public AWSXRayAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(50));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_THREAD_POOL_SIZE = 50;\n     */\n    @Deprecated\n    public AWSXRayAsyncClient(AWSCredentials awsCredentials) {\n        this(awsCredentials, newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "                    new AttributeDefinition(HASH_KEY, ScalarAttributeType.N),\n                    new AttributeDefinition(RANGE_KEY, ScalarAttributeType.S))\n                .withProvisionedThroughput(\n                    new ProvisionedThroughput(1, WRITE_CAPACITY));\n            table = dynamo.createTable(createTableRequest);\n            table.waitForActive();\n        }", "refactored_code": "    private static final long READ_CAPACITY = 1;\n                    new AttributeDefinition(HASH_KEY, ScalarAttributeType.N),\n                    new AttributeDefinition(RANGE_KEY, ScalarAttributeType.S))\n                .withProvisionedThroughput(\n                    new ProvisionedThroughput(READ_CAPACITY, WRITE_CAPACITY));\n            table = dynamo.createTable(createTableRequest);\n            table.waitForActive();\n        }"}
{"magic_number_smell": "            do\n            {\n                // Sleep for 60 seconds.\n                Thread.sleep(5000);\n\n                // Initialize the timer to now, and then subtract 15 minutes, so we can\n                // compare to see if we have exceeded 15 minutes compared to the startTime.", "refactored_code": "    private static final long SLEEP_CYCLE = 5000;\n            do\n            {\n                // Sleep for 60 seconds.\n                Thread.sleep(SLEEP_CYCLE);\n\n                // Initialize the timer to now, and then subtract 15 minutes, so we can\n                // compare to see if we have exceeded 15 minutes compared to the startTime."}
{"magic_number_smell": "            do\n            {\n                // Sleep for 60 seconds.\n                Thread.sleep(60000);\n            } while (requests.areAnyOpen());\n\n            // Cancel all requests and terminate all running instances.", "refactored_code": "    private static final long SLEEP_CYCLE = 60000;\n            do\n            {\n                // Sleep for 60 seconds.\n                Thread.sleep(SLEEP_CYCLE);\n            } while (requests.areAnyOpen());\n\n            // Cancel all requests and terminate all running instances."}
{"magic_number_smell": "\n                // backoff if we encounter an exception.\n                try {\n                    Thread.sleep(3000L);\n                } catch (InterruptedException e) {\n                    LOG.debug(\"Interrupted sleep\", e);\n                }", "refactored_code": "    private static final long BACKOFF_TIME_IN_MILLIS = 3000L;\n\n                // backoff if we encounter an exception.\n                try {\n                    Thread.sleep(BACKOFF_TIME_IN_MILLIS);\n                } catch (InterruptedException e) {\n                    LOG.debug(\"Interrupted sleep\", e);\n                }"}
{"magic_number_smell": "                    recordList.add(record);\n                    batchSize++;\n\n                    if (batchSize == 500) {\n                        putRecordBatch(recordList);\n\n                        recordList.clear();", "refactored_code": "    private static final int BATCH_PUT_MAX_SIZE = 500;\n                    recordList.add(record);\n                    batchSize++;\n\n                    if (batchSize == BATCH_PUT_MAX_SIZE) {\n                        putRecordBatch(recordList);\n\n                        recordList.clear();"}
{"magic_number_smell": "\n  private static final int 1024 = 1024;\n\n  private byte[] buffer = new byte[1024];\n  private NoCopyByteArrayOutputStream leftBos = new NoCopyByteArrayOutputStream();\n  private NoCopyByteArrayOutputStream rightBos = new NoCopyByteArrayOutputStream();\n", "refactored_code": "  private static final int BUFFER_SIZE = 1024;\n\n  private static final int BUFFER_SIZE = 1024;\n\n  private byte[] buffer = new byte[BUFFER_SIZE];\n  private NoCopyByteArrayOutputStream leftBos = new NoCopyByteArrayOutputStream();\n  private NoCopyByteArrayOutputStream rightBos = new NoCopyByteArrayOutputStream();\n"}
{"magic_number_smell": " */\npublic class RawSequenceFileRecordReader extends RecordReader<DataInputBuffer, DataInputBuffer> {\n  public static final int 1024 * 1024 = 1024 * 1024;\n  private final DataOutputBuffer kobuf = new DataOutputBuffer(1024 * 1024);\n  private final DataOutputBuffer vobuf = new DataOutputBuffer(1024 * 1024);\n  private final DataInputBuffer kibuf = new DataInputBuffer();\n  private final DataInputBuffer vibuf = new DataInputBuffer();", "refactored_code": "  public static final int DEFAULT_BUFFER_SIZE = 1024 * 1024;\n */\npublic class RawSequenceFileRecordReader extends RecordReader<DataInputBuffer, DataInputBuffer> {\n  public static final int DEFAULT_BUFFER_SIZE = 1024 * 1024;\n  private final DataOutputBuffer kobuf = new DataOutputBuffer(DEFAULT_BUFFER_SIZE);\n  private final DataOutputBuffer vobuf = new DataOutputBuffer(DEFAULT_BUFFER_SIZE);\n  private final DataInputBuffer kibuf = new DataInputBuffer();\n  private final DataInputBuffer vibuf = new DataInputBuffer();"}
{"magic_number_smell": "  }\n\n  public BinaryBlockWriter(OutputStream out, Class<M> protoClass, BinaryConverter<M> binaryConverter) {\n    this(out, protoClass, binaryConverter, 100);\n  }\n\n  public void write(M message) throws IOException {", "refactored_code": "  protected static final int DEFAULT_NUM_RECORDS_PER_BLOCK = 100;\n  }\n\n  public BinaryBlockWriter(OutputStream out, Class<M> protoClass, BinaryConverter<M> binaryConverter) {\n    this(out, protoClass, binaryConverter, DEFAULT_NUM_RECORDS_PER_BLOCK);\n  }\n\n  public void write(M message) throws IOException {"}
{"magic_number_smell": "\n  private static void logWarning(String message, Throwable t) {\n    // does not need to be thread safe\n    if ( numWarningsLogged < 100 ) {\n      LOG.info(message, t);\n      numWarningsLogged++;\n    }", "refactored_code": "  private static final int MAX_WARNINGS = 100;\n\n  private static void logWarning(String message, Throwable t) {\n    // does not need to be thread safe\n    if ( numWarningsLogged < MAX_WARNINGS ) {\n      LOG.info(message, t);\n      numWarningsLogged++;\n    }"}
{"magic_number_smell": "\n  private static void logWarning(String message, Throwable t) {\n    // does not need to be thread safe\n    if ( numWarningsLogged < 100 ) {\n      LOG.info(message, t);\n      numWarningsLogged++;\n    }", "refactored_code": "  private static final int MAX_WARNINGS = 100;\n\n  private static void logWarning(String message, Throwable t) {\n    // does not need to be thread safe\n    if ( numWarningsLogged < MAX_WARNINGS ) {\n      LOG.info(message, t);\n      numWarningsLogged++;\n    }"}
{"magic_number_smell": "                                                                         (byte)0xbd, (byte)0xff };\n\n  public static final byte '\n' = '\\n';\n  public static final byte[] NEWLINE_UTF8_BYTES = new byte[]{'\n'};\n\n  public static final String IGNORE_KEY = \"IGNORE\";\n", "refactored_code": "  public static final byte NEWLINE_UTF8_BYTE = '\\n';\n                                                                         (byte)0xbd, (byte)0xff };\n\n  public static final byte NEWLINE_UTF8_BYTE = '\\n';\n  public static final byte[] NEWLINE_UTF8_BYTES = new byte[]{NEWLINE_UTF8_BYTE};\n\n  public static final String IGNORE_KEY = \"IGNORE\";\n"}
{"magic_number_smell": "  public void testWithIndex() throws NoSuchAlgorithmException, IOException,\n      InterruptedException {\n\n    runTest(true, 10485760);\n    runTest(true, OUTPUT_SMALL);\n  }\n", "refactored_code": "  private static final int OUTPUT_BIG = 10485760;\n  public void testWithIndex() throws NoSuchAlgorithmException, IOException,\n      InterruptedException {\n\n    runTest(true, OUTPUT_BIG);\n    runTest(true, OUTPUT_SMALL);\n  }\n"}
{"magic_number_smell": "\npublic class TestLzoTextOutputFormat {\n  private static final long 1000L = 1000L;\n  private static final long BIG_MIN_SIZE = 1000L * 1000;\n  private Path outputDir_;\n  private Configuration conf_;\n  private FileSystem lfs_;", "refactored_code": "  private static final long SMALL_MIN_SIZE = 1000L;\n\npublic class TestLzoTextOutputFormat {\n  private static final long SMALL_MIN_SIZE = 1000L;\n  private static final long BIG_MIN_SIZE = SMALL_MIN_SIZE * 1000;\n  private Path outputDir_;\n  private Configuration conf_;\n  private FileSystem lfs_;"}
{"magic_number_smell": "   * @return the max number of indexes per split\n   */\n  public static long getMaxNumIndexesPerSplit(Configuration conf) {\n    return conf.getLong(MAX_NUM_INDEXES_PER_SPLIT_KEY, 200);\n  }\n\n  /**", "refactored_code": "  private static final long DEFAULT_MAX_NUM_INDEXES_PER_SPLIT = 200;\n   * @return the max number of indexes per split\n   */\n  public static long getMaxNumIndexesPerSplit(Configuration conf) {\n    return conf.getLong(MAX_NUM_INDEXES_PER_SPLIT_KEY, DEFAULT_MAX_NUM_INDEXES_PER_SPLIT);\n  }\n\n  /**"}
{"magic_number_smell": "  private final File inputDir = new File(testDir, \"in\");\n\n  private final int 1000 * 1000 = 1000 * 1000;\n  private final byte[] expectedRecords = new byte[1000 * 1000];\n\n  @Before\n  public void setUp() throws Exception {", "refactored_code": "  private final int NUM_RECORDS = 1000 * 1000;\n  private final File inputDir = new File(testDir, \"in\");\n\n  private final int NUM_RECORDS = 1000 * 1000;\n  private final byte[] expectedRecords = new byte[NUM_RECORDS];\n\n  @Before\n  public void setUp() throws Exception {"}
{"magic_number_smell": "\n    // write same data using PigStorage() and RCFileStorage() and\n    OutputStream out = new FileOutputStream(new File(pigDir, \"part-1.txt\"));\n    for(int i=0; i<5; i++) {\n      writePersonTuple(out, i);\n    }\n    out.close();", "refactored_code": "  private final int numRecords = 5;\n\n    // write same data using PigStorage() and RCFileStorage() and\n    OutputStream out = new FileOutputStream(new File(pigDir, \"part-1.txt\"));\n    for(int i=0; i<numRecords; i++) {\n      writePersonTuple(out, i);\n    }\n    out.close();"}
{"magic_number_smell": "    }\n\n    private byte[] makeBuffer() {\n        return new byte[1024];\n    }\n\n    @Test", "refactored_code": "    private static final int BUFFER_SIZE = 1024;\n    }\n\n    private byte[] makeBuffer() {\n        return new byte[BUFFER_SIZE];\n    }\n\n    @Test"}
{"magic_number_smell": "\n    public static class Email implements Serializable {\n\n        private static final long 1L = 1L;\n\n        private String _name;\n        private String _email;", "refactored_code": "        private static final long serialVersionUID = 1L;\n\n    public static class Email implements Serializable {\n\n        private static final long serialVersionUID = 1L;\n\n        private String _name;\n        private String _email;"}
{"magic_number_smell": "\t    while (line != null) {\n\t\tm = timep.matcher(line);\n\t\tif (m.lookingAt()) {\n\t\t    if (size % 10000 == 0) {\n\t\t\tlong time = timestampFromText(dateformat, m.group(1));\n\t\t\tskiplist.addMark(time, lastFp, size);\n\t\t    }", "refactored_code": "    private static final int skipN = 10000;\n\t    while (line != null) {\n\t\tm = timep.matcher(line);\n\t\tif (m.lookingAt()) {\n\t\t    if (size % skipN == 0) {\n\t\t\tlong time = timestampFromText(dateformat, m.group(1));\n\t\t\tskiplist.addMark(time, lastFp, size);\n\t\t    }"}
{"magic_number_smell": "\npublic class MeasureThroughput {\n    private static final int 1000 = 1000;\n    private static final int MS_PER_MIN = 1000*60;\n    private static final int MS_PER_HOUR = MS_PER_MIN*60;\n    \n    public static void main(String[] args) throws IOException {\t", "refactored_code": "    private static final int MS_PER_SEC = 1000;\n\npublic class MeasureThroughput {\n    private static final int MS_PER_SEC = 1000;\n    private static final int MS_PER_MIN = MS_PER_SEC*60;\n    private static final int MS_PER_HOUR = MS_PER_MIN*60;\n    \n    public static void main(String[] args) throws IOException {\t"}
{"magic_number_smell": "\t    }\n\t}\n\n\tbuffer = new byte[512*1024];\n\tbuffersize = 0;\n\tbufferoffset = 0;\n\tfileoffset = 0;", "refactored_code": "    private static final int DEFAULT_BUFFER_SIZE = 512*1024; // 512k\n\t    }\n\t}\n\n\tbuffer = new byte[DEFAULT_BUFFER_SIZE];\n\tbuffersize = 0;\n\tbufferoffset = 0;\n\tfileoffset = 0;"}
{"magic_number_smell": "\t\t}\n\t\tendtime = hdr.getTime();\n\n\t\tif (size % 10000 == 0) {\n\t\t    skiplist.addMark(hdr.getTime(), lastFp, size);\n\t\t}\n\t\tsize++;", "refactored_code": "    private static final int skipN = 10000;\n\t\t}\n\t\tendtime = hdr.getTime();\n\n\t\tif (size % skipN == 0) {\n\t\t    skiplist.addMark(hdr.getTime(), lastFp, size);\n\t\t}\n\t\tsize++;"}
{"magic_number_smell": "\t    if (period > 0) {\n\t\tendtime = starttime + period;\n\t    } else {\n\t\tendtime = starttime + 1000; \n\t    }\n\t}\n", "refactored_code": "    private static final int DEFAULT_PERIOD = 1000;\n\t    if (period > 0) {\n\t\tendtime = starttime + period;\n\t    } else {\n\t\tendtime = starttime + DEFAULT_PERIOD; \n\t    }\n\t}\n"}
{"magic_number_smell": "public class Throughput extends JsonServlet\n{\n    private static final int 1000 = 1000;\n    private static final int MS_PER_MIN = 1000*60;\n    private static final int MS_PER_HOUR = MS_PER_MIN*60;\n\n    private LogSource source = null;", "refactored_code": "    private static final int MS_PER_SEC = 1000;\npublic class Throughput extends JsonServlet\n{\n    private static final int MS_PER_SEC = 1000;\n    private static final int MS_PER_MIN = MS_PER_SEC*60;\n    private static final int MS_PER_HOUR = MS_PER_MIN*60;\n\n    private LogSource source = null;"}
{"magic_number_smell": "   protected static final String CONTEXT_PATH = \"/zk\";\n   protected static final int 10104 = 10104;\n   protected static final String BASEURI = String.format(\n           \"http://localhost:%d%s\", 10104, CONTEXT_PATH);\n   protected static final String ZKHOSTPORT = \"localhost:22182\";\n   protected Client client;\n   protected WebResource znodesr, sessionsr;", "refactored_code": "   protected static final int GRIZZLY_PORT = 10104;\n   protected static final String CONTEXT_PATH = \"/zk\";\n   protected static final int GRIZZLY_PORT = 10104;\n   protected static final String BASEURI = String.format(\n           \"http://localhost:%d%s\", GRIZZLY_PORT, CONTEXT_PATH);\n   protected static final String ZKHOSTPORT = \"localhost:22182\";\n   protected Client client;\n   protected WebResource znodesr, sessionsr;"}
{"magic_number_smell": "    public byte[] readBuffer(String tag) throws IOException {\n        int len = readInt(tag);\n        if (len == -1) return null;\n        if (len < 0 || len > determineMaxBuffer()) {\n            throw new IOException(\"Unreasonable length = \" + len);\n        }\n        byte[] arr = new byte[len];", "refactored_code": "    static public final int maxBuffer = determineMaxBuffer();\n    public byte[] readBuffer(String tag) throws IOException {\n        int len = readInt(tag);\n        if (len == -1) return null;\n        if (len < 0 || len > maxBuffer) {\n            throw new IOException(\"Unreasonable length = \" + len);\n        }\n        byte[] arr = new byte[len];"}
{"magic_number_smell": "    }\n\n    private static class SessionTimeoutException extends IOException {\n        private static final long -5438877188796231422L = 824482094072071178L;\n\n        public SessionTimeoutException(String msg) {\n            super(msg);", "refactored_code": "        private static final long serialVersionUID = -5438877188796231422L;\n    }\n\n    private static class SessionTimeoutException extends IOException {\n        private static final long serialVersionUID = 824482094072071178L;\n\n        public SessionTimeoutException(String msg) {\n            super(msg);"}
{"magic_number_smell": "     */\n    public static enum Code implements CodeDeprecated {\n        /** Everything is OK */\n        OK (0),\n\n        /** System and server-side errors.\n         * This is never thrown by the server, it shouldn't be used other than", "refactored_code": "        public static final int Ok = 0;\n     */\n    public static enum Code implements CodeDeprecated {\n        /** Everything is OK */\n        OK (Ok),\n\n        /** System and server-side errors.\n         * This is never thrown by the server, it shouldn't be used other than"}
{"magic_number_smell": "     */\n    private static final float TICKET_RENEW_JITTER = 0.05f;\n\n    // Regardless of 0.80f setting above and the ticket expiry time,\n    // thread will not sleep between refresh attempts any less than 1 minute (60*1000 milliseconds = 1 minute).\n    // Change the '1' to e.g. 5, to change this to 5 minutes.\n    private static final long MIN_TIME_BEFORE_RELOGIN = 1 * 60 * 1000L;", "refactored_code": "    private static final float TICKET_RENEW_WINDOW = 0.80f;\n     */\n    private static final float TICKET_RENEW_JITTER = 0.05f;\n\n    // Regardless of TICKET_RENEW_WINDOW setting above and the ticket expiry time,\n    // thread will not sleep between refresh attempts any less than 1 minute (60*1000 milliseconds = 1 minute).\n    // Change the '1' to e.g. 5, to change this to 5 minutes.\n    private static final long MIN_TIME_BEFORE_RELOGIN = 1 * 60 * 1000L;"}
{"magic_number_smell": "                        .singletonList(new ACL(Perms.READ, ANYONE_ID_UNSAFE)));\n    }\n\n    final public static String[] opNames = { \"0\", \"create\",\n            \"delete\", \"exists\", \"getData\", \"setData\", \"getACL\", \"setACL\",\n            \"getChildren\", \"getChildren2\", \"getMaxChildren\", \"setMaxChildren\", \"ping\" };\n}", "refactored_code": "        public final int notification = 0;\n                        .singletonList(new ACL(Perms.READ, ANYONE_ID_UNSAFE)));\n    }\n\n    final public static String[] opNames = { \"notification\", \"create\",\n            \"delete\", \"exists\", \"getData\", \"setData\", \"getACL\", \"setACL\",\n            \"getChildren\", \"getChildren2\", \"getMaxChildren\", \"setMaxChildren\", \"ping\" };\n}"}
{"magic_number_smell": "\n        String hostsList[] = connectString.split(\",\");\n        for (String host : hostsList) {\n            int port = 2181;\n            int pidx = host.lastIndexOf(':');\n            if (pidx >= 0) {\n                // otherwise : is at the end of the string, ignore", "refactored_code": "    private static final int DEFAULT_PORT = 2181;\n\n        String hostsList[] = connectString.split(\",\");\n        for (String host : hostsList) {\n            int port = DEFAULT_PORT;\n            int pidx = host.lastIndexOf(':');\n            if (pidx >= 0) {\n                // otherwise : is at the end of the string, ignore"}
{"magic_number_smell": "    }\n\n    protected static class EndOfStreamException extends IOException {\n        private static final long -7854505709816442681L = -8255690282104294178L;\n\n        public EndOfStreamException(String msg) {\n            super(msg);", "refactored_code": "        private static final long serialVersionUID = -7854505709816442681L;\n    }\n\n    protected static class EndOfStreamException extends IOException {\n        private static final long serialVersionUID = -8255690282104294178L;\n\n        public EndOfStreamException(String msg) {\n            super(msg);"}
{"magic_number_smell": "        WriteLock wl = logLock.writeLock();\n        try {\n            wl.lock();\n            if (committedLog.size() > 500) {\n                committedLog.removeFirst();\n                minCommittedLog = committedLog.getFirst().packet.getZxid();\n            }", "refactored_code": "    public static final int commitLogCount = 500;\n        WriteLock wl = logLock.writeLock();\n        try {\n            wl.lock();\n            if (committedLog.size() > commitLogCount) {\n                committedLog.removeFirst();\n                minCommittedLog = committedLog.getFirst().packet.getZxid();\n            }"}
{"magic_number_smell": "    }\n\n    public static final int 3000 = 3000;\n    protected int tickTime = 3000;\n    /** value of -1 indicates unset, use default */\n    protected int minSessionTimeout = -1;\n    /** value of -1 indicates unset, use default */", "refactored_code": "    public static final int DEFAULT_TICK_TIME = 3000;\n    }\n\n    public static final int DEFAULT_TICK_TIME = 3000;\n    protected int tickTime = DEFAULT_TICK_TIME;\n    /** value of -1 indicates unset, use default */\n    protected int minSessionTimeout = -1;\n    /** value of -1 indicates unset, use default */"}
{"magic_number_smell": "            CheckedOutputStream crcOut = new CheckedOutputStream(sessOS, new Adler32());\n            //CheckedOutputStream cout = new CheckedOutputStream()\n            OutputArchive oa = BinaryOutputArchive.getArchive(crcOut);\n            FileHeader header = new FileHeader(SNAP_MAGIC, 2, dbId);\n            serialize(dt,sessions,oa, header);\n            long val = crcOut.getChecksum().getValue();\n            oa.writeLong(val, \"val\");", "refactored_code": "    private static final int VERSION=2;\n            CheckedOutputStream crcOut = new CheckedOutputStream(sessOS, new Adler32());\n            //CheckedOutputStream cout = new CheckedOutputStream()\n            OutputArchive oa = BinaryOutputArchive.getArchive(crcOut);\n            FileHeader header = new FileHeader(SNAP_MAGIC, VERSION, dbId);\n            serialize(dt,sessions,oa, header);\n            long val = crcOut.getChecksum().getValue();\n            oa.writeLong(val, \"val\");"}
{"magic_number_smell": "            }\n        }\n        \n        // Reset to 3 if invalid (less than 3)\n        // PurgeTxnLog.purge(File, File, int) will not allow to purge less\n        // than 3.\n        if (snapRetainCount < 3) {", "refactored_code": "    private final int MIN_SNAP_RETAIN_COUNT = 3;\n            }\n        }\n        \n        // Reset to MIN_SNAP_RETAIN_COUNT if invalid (less than 3)\n        // PurgeTxnLog.purge(File, File, int) will not allow to purge less\n        // than 3.\n        if (snapRetainCount < MIN_SNAP_RETAIN_COUNT) {"}
{"magic_number_smell": "    public UpgradeMain(File dataDir, File snapShotDir) {\n        this.snapShotDir = snapShotDir; \n        this.dataDir = dataDir;\n        this.bkupdataDir = new File(dataDir, dirName + 1);\n        this.bkupsnapShotDir = new File(snapShotDir, dirName + 1 );\n        this.currentsnapShotDir = new File(snapShotDir, dirName + CURRENTVERSION);\n        this.currentdataDir = new File(dataDir, dirName + CURRENTVERSION);", "refactored_code": "    private static final int LASTVERSION = 1;\n    public UpgradeMain(File dataDir, File snapShotDir) {\n        this.snapShotDir = snapShotDir; \n        this.dataDir = dataDir;\n        this.bkupdataDir = new File(dataDir, dirName + LASTVERSION);\n        this.bkupsnapShotDir = new File(snapShotDir, dirName + LASTVERSION );\n        this.currentsnapShotDir = new File(snapShotDir, dirName + CURRENTVERSION);\n        this.currentdataDir = new File(dataDir, dirName + CURRENTVERSION);"}
{"magic_number_smell": "        this.assignmentsNode = prefix + '/' + this.assignmentsNode;\n        this.reportsNode = prefix + '/' + this.reportsNode;\n        this.statusNode = prefix + '/' + this.statusNode;\n        for(int i = 0; i < 3; i++) {\n            try {\n                setupNodes(zk);\n                break;", "refactored_code": "    private static final int maxTries = 3;\n        this.assignmentsNode = prefix + '/' + this.assignmentsNode;\n        this.reportsNode = prefix + '/' + this.reportsNode;\n        this.statusNode = prefix + '/' + this.statusNode;\n        for(int i = 0; i < maxTries; i++) {\n            try {\n                setupNodes(zk);\n                break;"}
{"magic_number_smell": "                    return;\n                }\n                System.err.println(\"SnapDir = \" + snapDir + \" LogDir = \" + logDir);\n                peer = new QuorumPeer(peers, snapDir, logDir, clientAddr.getPort(), 0, serverId, tickTime, initLimit, 3);\n                peer.start();\n                for(int i = 0; i < 5; i++) {\n                    Thread.sleep(500);", "refactored_code": "    private static final int syncLimit = 3;\n                    return;\n                }\n                System.err.println(\"SnapDir = \" + snapDir + \" LogDir = \" + logDir);\n                peer = new QuorumPeer(peers, snapDir, logDir, clientAddr.getPort(), 0, serverId, tickTime, initLimit, syncLimit);\n                peer.start();\n                for(int i = 0; i < 5; i++) {\n                    Thread.sleep(500);"}
{"magic_number_smell": "        ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n        f.startup(zks);\n        Assert.assertTrue(\"waiting for server being up \",\n                ClientBase.waitForServerUp(HOSTPORT,3000));\n        zks.sessionTracker = new MySessionTracker(); \n        PrepRequestProcessor processor = new PrepRequestProcessor(zks, new MyRequestProcessor());\n        Request foo = new Request(null, 1l, 1, OpCode.create, ByteBuffer.allocate(3), null);", "refactored_code": "    private static final int CONNECTION_TIMEOUT = 3000;\n        ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n        f.startup(zks);\n        Assert.assertTrue(\"waiting for server being up \",\n                ClientBase.waitForServerUp(HOSTPORT,CONNECTION_TIMEOUT));\n        zks.sessionTracker = new MySessionTracker(); \n        PrepRequestProcessor processor = new PrepRequestProcessor(zks, new MyRequestProcessor());\n        Request foo = new Request(null, 1l, 1, OpCode.create, ByteBuffer.allocate(3), null);"}
{"magic_number_smell": "\n        private synchronized void incOutstanding() throws InterruptedException {\n            outstanding++;\n            while(outstanding > 30) {\n                wait();\n            }\n        }", "refactored_code": "        private static final int MAX_OUTSTANDING = 30;\n\n        private synchronized void incOutstanding() throws InterruptedException {\n            outstanding++;\n            while(outstanding > MAX_OUTSTANDING) {\n                wait();\n            }\n        }"}
{"magic_number_smell": "            try {\n                for (; current < count; current++) {\n                    // Simulate a bit of network latency...\n                    Thread.sleep(5);\n                    zk.create(prefix + current, b, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n                }\n            } catch (Throwable t) {", "refactored_code": "    private static final long HAMMERTHREAD_LATENCY = 5;\n            try {\n                for (; current < count; current++) {\n                    // Simulate a bit of network latency...\n                    Thread.sleep(HAMMERTHREAD_LATENCY);\n                    zk.create(prefix + current, b, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n                }\n            } catch (Throwable t) {"}
{"magic_number_smell": "\n                Message m = null;\n                int numRetries = 1;\n                while((m == null) && (numRetries++ <= 4)){\n                    m = cnxManager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);\n                    if(m == null) cnxManager.connectAll();\n                }", "refactored_code": "    protected static final int THRESHOLD = 4;\n\n                Message m = null;\n                int numRetries = 1;\n                while((m == null) && (numRetries++ <= THRESHOLD)){\n                    m = cnxManager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);\n                    if(m == null) cnxManager.connectAll();\n                }"}
{"magic_number_smell": "        qu.start(1);\n        qu.start(2);\n        Assert.assertTrue(\"Waiting for server up\", ClientBase.waitForServerUp(\"127.0.0.1:\"\n                + qu.getPeer(1).clientPort, ClientBase.ClientTest.CONNECTION_TIMEOUT));\n        Assert.assertTrue(\"Waiting for server up\", ClientBase.waitForServerUp(\"127.0.0.1:\"\n                + qu.getPeer(2).clientPort, ClientBase.ClientTest.CONNECTION_TIMEOUT));\n", "refactored_code": "    public static final long CONNECTION_TIMEOUT = ClientTest.CONNECTION_TIMEOUT;\n        qu.start(1);\n        qu.start(2);\n        Assert.assertTrue(\"Waiting for server up\", ClientBase.waitForServerUp(\"127.0.0.1:\"\n                + qu.getPeer(1).clientPort, ClientBase.CONNECTION_TIMEOUT));\n        Assert.assertTrue(\"Waiting for server up\", ClientBase.waitForServerUp(\"127.0.0.1:\"\n                + qu.getPeer(2).clientPort, ClientBase.CONNECTION_TIMEOUT));\n"}
{"magic_number_smell": "        ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n        f.startup(zks);\n        Assert.assertTrue(\"waiting for server being up \",\n                ClientBase.waitForServerUp(HOSTPORT,3000));\n        ZooKeeper zk = new ZooKeeper(HOSTPORT, 3000, this);\n\n        // generate some transactions that will get logged", "refactored_code": "    private static final int CONNECTION_TIMEOUT = 3000;\n        ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n        f.startup(zks);\n        Assert.assertTrue(\"waiting for server being up \",\n                ClientBase.waitForServerUp(HOSTPORT,CONNECTION_TIMEOUT));\n        ZooKeeper zk = new ZooKeeper(HOSTPORT, CONNECTION_TIMEOUT, this);\n\n        // generate some transactions that will get logged"}
{"magic_number_smell": "        ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n        f.startup(zks);\n        Assert.assertTrue(\"waiting for server being up \",\n                ClientBase.waitForServerUp(HOSTPORT,3000));\n        ZooKeeper zk = new ZooKeeper(HOSTPORT, 3000, this);\n        try {\n            for (int i = 0; i< 2000; i++) {", "refactored_code": "    private static final int CONNECTION_TIMEOUT = 3000;\n        ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n        f.startup(zks);\n        Assert.assertTrue(\"waiting for server being up \",\n                ClientBase.waitForServerUp(HOSTPORT,CONNECTION_TIMEOUT));\n        ZooKeeper zk = new ZooKeeper(HOSTPORT, CONNECTION_TIMEOUT, this);\n        try {\n            for (int i = 0; i< 2000; i++) {"}
{"magic_number_smell": "    volatile int errors = 0;\n    @Test\n    public void testLeaderShutdown() throws IOException, InterruptedException, KeeperException {\n        ZooKeeper zk = new DisconnectableZooKeeper(qb.hostPort, ClientBase.ClientTest.CONNECTION_TIMEOUT, new Watcher() {\n            public void process(WatchedEvent event) {\n        }});\n        zk.create(\"/blah\", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);", "refactored_code": "    public static final long CONNECTION_TIMEOUT = ClientTest.CONNECTION_TIMEOUT;\n    volatile int errors = 0;\n    @Test\n    public void testLeaderShutdown() throws IOException, InterruptedException, KeeperException {\n        ZooKeeper zk = new DisconnectableZooKeeper(qb.hostPort, ClientBase.CONNECTION_TIMEOUT, new Watcher() {\n            public void process(WatchedEvent event) {\n        }});\n        zk.create(\"/blah\", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);"}
{"magic_number_smell": "        ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n        f.startup(zks);\n        Assert.assertTrue(\"waiting for server being up \",\n                ClientBase.waitForServerUp(HOSTPORT,3000));\n        ZooKeeper zk = new ZooKeeper(HOSTPORT, 3000, this);\n        try {\n            for (int i = 0; i< 2000; i++) {", "refactored_code": "    private static final int CONNECTION_TIMEOUT = 3000;\n        ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n        f.startup(zks);\n        Assert.assertTrue(\"waiting for server being up \",\n                ClientBase.waitForServerUp(HOSTPORT,CONNECTION_TIMEOUT));\n        ZooKeeper zk = new ZooKeeper(HOSTPORT, CONNECTION_TIMEOUT, this);\n        try {\n            for (int i = 0; i< 2000; i++) {"}
{"magic_number_smell": "        }\n\n        ClientBase.setupTestEnv();\n        ZooKeeperServer zs = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n\n        final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n        serverFactory = ServerCnxnFactory.createFactory(PORT, -1);", "refactored_code": "    private final int TICK_TIME = 3000;\n        }\n\n        ClientBase.setupTestEnv();\n        ZooKeeperServer zs = new ZooKeeperServer(tmpDir, tmpDir, TICK_TIME);\n\n        final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n        serverFactory = ServerCnxnFactory.createFactory(PORT, -1);"}
{"magic_number_smell": "            String hp = list[i];\n          Assert.assertTrue(\"waiting for server up\",\n                       ClientBase.waitForServerUp(hp,\n                                    ClientTest.CONNECTION_TIMEOUT));\n            LOG.info(hp + \" is accepting client connections\");\n        }\n", "refactored_code": "    public static final long CONNECTION_TIMEOUT = ClientTest.CONNECTION_TIMEOUT;\n            String hp = list[i];\n          Assert.assertTrue(\"waiting for server up\",\n                       ClientBase.waitForServerUp(hp,\n                                    CONNECTION_TIMEOUT));\n            LOG.info(hp + \" is accepting client connections\");\n        }\n"}
{"magic_number_smell": "    private List<? extends GuardingDynamicLinker> fallbackLinkers;\n    private int runtimeContextArgCount = 0;\n    private boolean syncOnRelink = false;\n    private int unstableRelinkThreshold = 8;\n    private GuardedInvocationFilter prelinkFilter;\n    private MethodTypeConversionStrategy autoConversionStrategy;\n    private MethodHandleTransformer internalObjectsFilter;", "refactored_code": "    public static final int DEFAULT_UNSTABLE_RELINK_THRESHOLD = 8;\n    private List<? extends GuardingDynamicLinker> fallbackLinkers;\n    private int runtimeContextArgCount = 0;\n    private boolean syncOnRelink = false;\n    private int unstableRelinkThreshold = DEFAULT_UNSTABLE_RELINK_THRESHOLD;\n    private GuardedInvocationFilter prelinkFilter;\n    private MethodTypeConversionStrategy autoConversionStrategy;\n    private MethodHandleTransformer internalObjectsFilter;"}
{"magic_number_smell": "\n    private static final int '$' = '$';\n    private static final int MAX_ENCODING = ']';\n    private static final char[] ENCODING = new char[MAX_ENCODING - '$' + 1];\n    private static final int MIN_DECODING = '!';\n    private static final int MAX_DECODING = '}';\n    private static final char[] DECODING = new char[MAX_DECODING - MIN_DECODING + 1];", "refactored_code": "    private static final int MIN_ENCODING = '$';\n\n    private static final int MIN_ENCODING = '$';\n    private static final int MAX_ENCODING = ']';\n    private static final char[] ENCODING = new char[MAX_ENCODING - MIN_ENCODING + 1];\n    private static final int MIN_DECODING = '!';\n    private static final int MAX_DECODING = '}';\n    private static final char[] DECODING = new char[MAX_DECODING - MIN_DECODING + 1];"}
{"magic_number_smell": "    public float getTcpPingVar() { return tcpPingVar_; }\n    \n    // optional .MumbleProto.Version version = 12;\n    public static final int 1 = 12;\n    private boolean hasVersion;\n    private net.sf.mumble.MumbleProto.Version version_;\n    public boolean hasVersion() { return hasVersion; }", "refactored_code": "    public static final int VERSION_FIELD_NUMBER = 1;\n    public float getTcpPingVar() { return tcpPingVar_; }\n    \n    // optional .MumbleProto.Version version = 12;\n    public static final int VERSION_FIELD_NUMBER = 12;\n    private boolean hasVersion;\n    private net.sf.mumble.MumbleProto.Version version_;\n    public boolean hasVersion() { return hasVersion; }"}
{"magic_number_smell": "\n\t@Override\n\tpublic final boolean onCreateOptionsMenu(final Menu menu) {\n\t\tmenu.add(0, Menu.FIRST, 0, \"Chat\").setIcon(\n\t\t\tandroid.R.drawable.ic_btn_speak_now);\n\t\treturn true;\n\t}", "refactored_code": "\tprivate static final int MENU_CHAT = Menu.FIRST;\n\n\t@Override\n\tpublic final boolean onCreateOptionsMenu(final Menu menu) {\n\t\tmenu.add(0, MENU_CHAT, 0, \"Chat\").setIcon(\n\t\t\tandroid.R.drawable.ic_btn_speak_now);\n\t\treturn true;\n\t}"}
{"magic_number_smell": "\n\t@Override\n\tpublic final boolean onCreateOptionsMenu(final Menu menu) {\n\t\tmenu.add(0, Menu.FIRST, 0, \"Clear\").setIcon(\n\t\t\tandroid.R.drawable.ic_menu_delete);\n\t\treturn true;\n\t}", "refactored_code": "\tprivate static final int MENU_CLEAR = Menu.FIRST;\n\n\t@Override\n\tpublic final boolean onCreateOptionsMenu(final Menu menu) {\n\t\tmenu.add(0, MENU_CLEAR, 0, \"Clear\").setIcon(\n\t\t\tandroid.R.drawable.ic_menu_delete);\n\t\treturn true;\n\t}"}
{"magic_number_smell": "\n\tprivate void addServer() {\n\t\tfinal Intent i = new Intent(this, ServerInfo.class);\n\t\tstartActivityForResult(i, 0);\n\t}\n\n\t/**", "refactored_code": "\tprivate static final int ACTIVITY_ADD_SERVER = 0;\n\n\tprivate void addServer() {\n\t\tfinal Intent i = new Intent(this, ServerInfo.class);\n\t\tstartActivityForResult(i, ACTIVITY_ADD_SERVER);\n\t}\n\n\t/**"}
{"magic_number_smell": "\n\tprivate static void S2(final byte[] block) {\n\t\tfinal int carry = (block[0] >> 7) & 0x1;\n\t\tfor (int i = 0; i < 16 - 1; i++) {\n\t\t\tblock[i] = (byte) ((block[i] << 1) | ((block[i + 1] >> 7) & 0x1));\n\t\t}\n\t\tblock[16 - 1] = (byte) ((block[16 - 1] << 1) ^ (carry * 0x87));", "refactored_code": "\tprivate static final int AES_BLOCK_SIZE = 16;\n\n\tprivate static void S2(final byte[] block) {\n\t\tfinal int carry = (block[0] >> 7) & 0x1;\n\t\tfor (int i = 0; i < AES_BLOCK_SIZE - 1; i++) {\n\t\t\tblock[i] = (byte) ((block[i] << 1) | ((block[i + 1] >> 7) & 0x1));\n\t\t}\n\t\tblock[AES_BLOCK_SIZE - 1] = (byte) ((block[AES_BLOCK_SIZE - 1] << 1) ^ (carry * 0x87));"}
{"magic_number_smell": "\tpublic static final int UDPMESSAGETYPE_UDPVOICECELTBETA = 3;\n\n\tpublic static final int CODEC_NOCODEC = -1;\n\tpublic static final int CODEC_ALPHA = 0;\n\tpublic static final int CODEC_BETA = UDPMESSAGETYPE_UDPVOICECELTBETA;\n\n\tpublic static final int SAMPLE_RATE = 48000;", "refactored_code": "\tpublic static final int UDPMESSAGETYPE_UDPVOICECELTALPHA = 0;\n\tpublic static final int UDPMESSAGETYPE_UDPVOICECELTBETA = 3;\n\n\tpublic static final int CODEC_NOCODEC = -1;\n\tpublic static final int CODEC_ALPHA = UDPMESSAGETYPE_UDPVOICECELTALPHA;\n\tpublic static final int CODEC_BETA = UDPMESSAGETYPE_UDPVOICECELTBETA;\n\n\tpublic static final int SAMPLE_RATE = 48000;"}
{"magic_number_smell": "\t\t}\n\n\t\tLog.i(Globals.LOG_TAG, \"MumbleService: Created\");\n\t\tserviceState = 0;\n\t}\n\n\t@Override", "refactored_code": "\tpublic static final int CONNECTION_STATE_DISCONNECTED = 0;\n\t\t}\n\n\t\tLog.i(Globals.LOG_TAG, \"MumbleService: Created\");\n\t\tserviceState = CONNECTION_STATE_DISCONNECTED;\n\t}\n\n\t@Override"}
{"magic_number_smell": "\t\t\tceltConstants.CELT_SET_VBR_RATE_REQUEST,\n\t\t\taudioQuality);\n\n\t\tif (recordingSampleRate != MumbleProtocol.SAMPLE_RATE) {\n\t\t\tspeexResamplerState = Native.speex_resampler_init(\n\t\t\t\t1,\n\t\t\t\trecordingSampleRate,", "refactored_code": "\tprivate static final int TARGET_SAMPLE_RATE = MumbleProtocol.SAMPLE_RATE;\n\t\t\tceltConstants.CELT_SET_VBR_RATE_REQUEST,\n\t\t\taudioQuality);\n\n\t\tif (recordingSampleRate != TARGET_SAMPLE_RATE) {\n\t\t\tspeexResamplerState = Native.speex_resampler_init(\n\t\t\t\t1,\n\t\t\t\trecordingSampleRate,"}
{"magic_number_smell": "    private String remoteControlJarPath;\n\n    public AgentConfiguration() {\n        this.port = 4443;\n        this.remoteControlWrapperJarPath = DEFAULT_RC_WRAPPER_JAR_PATH;\n        this.remoteControlJarPath = DEFAULT_RC_JAR_PATH;\n    }", "refactored_code": "    public static final int DEFAULT_PORT_NUMBER = 4443;\n    private String remoteControlJarPath;\n\n    public AgentConfiguration() {\n        this.port = DEFAULT_PORT_NUMBER;\n        this.remoteControlWrapperJarPath = DEFAULT_RC_WRAPPER_JAR_PATH;\n        this.remoteControlJarPath = DEFAULT_RC_JAR_PATH;\n    }"}
{"magic_number_smell": "        launcher = new JVMLauncher(classpath, \"com.thoughtworks.selenium.grid.agent.AgentServer\");\n        handle = launcher.launchNewJVM();\n        assertTrue(handle.alive());\n        Thread.sleep(4 * 1000);\n        handle.kill();\n        Thread.sleep(1 * 1000);\n        assertFalse(handle.alive());", "refactored_code": "    public static final int SECOND = 1000;\n        launcher = new JVMLauncher(classpath, \"com.thoughtworks.selenium.grid.agent.AgentServer\");\n        handle = launcher.launchNewJVM();\n        assertTrue(handle.alive());\n        Thread.sleep(4 * SECOND);\n        handle.kill();\n        Thread.sleep(1 * SECOND);\n        assertFalse(handle.alive());"}
{"magic_number_smell": "        } catch (Exception e) {\n            LOGGER.warn(\"Remote Control at \" + host + \":\" + port + \" is unresponsive\");\n\n            if (this.sessionInProgress() && (failedHeartbeatCount < 3)) {\n                LOGGER.warn(String.format(\"... attempt %d of %d -- trying again.\", failedHeartbeatCount + 1, 3));\n\n                failedHeartbeatCount++;", "refactored_code": "    private static final int MAX_FAILED_HEARTBEATS = 3;\n        } catch (Exception e) {\n            LOGGER.warn(\"Remote Control at \" + host + \":\" + port + \" is unresponsive\");\n\n            if (this.sessionInProgress() && (failedHeartbeatCount < MAX_FAILED_HEARTBEATS)) {\n                LOGGER.warn(String.format(\"... attempt %d of %d -- trying again.\", failedHeartbeatCount + 1, MAX_FAILED_HEARTBEATS));\n\n                failedHeartbeatCount++;"}
{"magic_number_smell": "    @Test\n    public void forwardGetNewBrowserSessionToRemoteControl() throws IOException {\n      HttpClient proxy = new HttpClient();\n      Response response = proxy.get(\"http://localhost:\" + 5555 + \"/selenium-server/driver/?cmd=getNewBrowserSession&1=*firefox&2=http://www.google.com\");\n      assertEquals(200, response.statusCode());\n      assertTrue(response.body().startsWith(\"OK,\"));\n    }", "refactored_code": "    private static final int VALID_PORT = 5555;\n    @Test\n    public void forwardGetNewBrowserSessionToRemoteControl() throws IOException {\n      HttpClient proxy = new HttpClient();\n      Response response = proxy.get(\"http://localhost:\" + VALID_PORT + \"/selenium-server/driver/?cmd=getNewBrowserSession&1=*firefox&2=http://www.google.com\");\n      assertEquals(200, response.statusCode());\n      assertTrue(response.body().startsWith(\"OK,\"));\n    }"}
{"magic_number_smell": "\t@Test\n\tpublic void forwardGetNewBrowserSessionToRemoteControl() throws IOException {\n\t\tHttpClient client = new HttpClient();\n\t\tRemoteControlProxy proxy = new RemoteControlProxy(\"localhost\", 5555, \"env\", client);\n\t\tHttpParameters parameters = new HttpParameters();\n\t\tparameters.put(\"cmd\", \"getNewBrowserSession\");\n\t\tparameters.put(\"1\", \"*firefox\");", "refactored_code": "\tprivate static final int VALID_PORT = 5555;\n\t@Test\n\tpublic void forwardGetNewBrowserSessionToRemoteControl() throws IOException {\n\t\tHttpClient client = new HttpClient();\n\t\tRemoteControlProxy proxy = new RemoteControlProxy(\"localhost\", VALID_PORT, \"env\", client);\n\t\tHttpParameters parameters = new HttpParameters();\n\t\tparameters.put(\"cmd\", \"getNewBrowserSession\");\n\t\tparameters.put(\"1\", \"*firefox\");"}
{"magic_number_smell": "     * Execute a block of code in a new thread after expiration of a delay of 1 second.\n     */\n    public ConcurrentAction() {\n        this(1);\n    }\n\n    /**", "refactored_code": "    public static final int ONE_SECOND_DELAY = 1;\n     * Execute a block of code in a new thread after expiration of a delay of 1 second.\n     */\n    public ConcurrentAction() {\n        this(ONE_SECOND_DELAY);\n    }\n\n    /**"}
{"magic_number_smell": "                throw new IllegalStateException(\"Could not find '\" + resourcePath + \"' in classpath. Root is \" + root);\n            }\n            inputStream = resource.openStream();\n            IOHelper.copyStream(inputStream, writer, 1024);\n            return writer.toString();\n        } catch (IOException e) {\n            throw new RuntimeException(e);", "refactored_code": "    private static final int COPY_BUFFER_SIZE = 1024;\n                throw new IllegalStateException(\"Could not find '\" + resourcePath + \"' in classpath. Root is \" + root);\n            }\n            inputStream = resource.openStream();\n            IOHelper.copyStream(inputStream, writer, COPY_BUFFER_SIZE);\n            return writer.toString();\n        } catch (IOException e) {\n            throw new RuntimeException(e);"}
{"magic_number_smell": "          String newTraceLine = null;\n          if (bufferedTextCount > 0)\n          {\n            newTraceLine = newTraceLines.poll(100, \n                                              TimeUnit.MILLISECONDS);\n          }\n          else", "refactored_code": "  private static final long MIN_UPDATE_GAP = 100; // milliseconds\n          String newTraceLine = null;\n          if (bufferedTextCount > 0)\n          {\n            newTraceLine = newTraceLines.poll(MIN_UPDATE_GAP, \n                                              TimeUnit.MILLISECONDS);\n          }\n          else"}
{"magic_number_smell": "\t\t\tset.put(this, new Object());\n\n\t\t\tList<String> traceEventsForSingleBatch = new ArrayList<String>(\n\t\t\t\t\t16 * 1024);\n\t\t\tList<TraceEventForBatch> tmp = new ArrayList<TraceEventForBatch>(\n\t\t\t\t\t16 * 1024);\n\t\t\twhile (true) {", "refactored_code": "\tprivate static final int EST_EVENT_COUNT_PER_BATCH = 16 * 1024;\n\t\t\tset.put(this, new Object());\n\n\t\t\tList<String> traceEventsForSingleBatch = new ArrayList<String>(\n\t\t\t\t\tEST_EVENT_COUNT_PER_BATCH);\n\t\t\tList<TraceEventForBatch> tmp = new ArrayList<TraceEventForBatch>(\n\t\t\t\t\tEST_EVENT_COUNT_PER_BATCH);\n\t\t\twhile (true) {"}
{"magic_number_smell": "  {\n    // Handle rolling over between files\n    writtenLines++;\n    if (writtenLines > 100 * 1000)\n    {\n      writtenLines = 0;\n      file1Active = !file1Active;", "refactored_code": "  private static final int MAX_LINES_PER_FILE = 100 * 1000; // 100k lines\n  {\n    // Handle rolling over between files\n    writtenLines++;\n    if (writtenLines > MAX_LINES_PER_FILE)\n    {\n      writtenLines = 0;\n      file1Active = !file1Active;"}
{"magic_number_smell": "\t\treturn newPizza;\n        }\n        private Pizza createTypeThree(long baseline) {\n                Pizza newPizza = new Pizza( baseline + offsetC, 3 );\n                return newPizza;\n        }\n\t@Test ", "refactored_code": "\tpublic static final int POISON_PILL = 3;\n\t\treturn newPizza;\n        }\n        private Pizza createTypeThree(long baseline) {\n                Pizza newPizza = new Pizza( baseline + offsetC, POISON_PILL );\n                return newPizza;\n        }\n\t@Test "}
{"magic_number_smell": "    {\n        if ( executor == null )\n        {\n            int threads = ConfigUtils.getInteger( config, 5, CFG_PREFIX + \".threads\" );\n\n            if ( threads <= 1 )\n            {", "refactored_code": "    private static final int MAX_POOL_SIZE = 5;\n    {\n        if ( executor == null )\n        {\n            int threads = ConfigUtils.getInteger( config, MAX_POOL_SIZE, CFG_PREFIX + \".threads\" );\n\n            if ( threads <= 1 )\n            {"}
{"magic_number_smell": "\n        UpdateCheck<Metadata, MetadataTransferException> check = newMetadataCheck();\n\n        long lastUpdate = new Date().getTime() - 60 * 60 * 1000;\n        check.setLocalLastUpdated( lastUpdate );\n\n        // ! file.exists && updateRequired -> check in remote repo", "refactored_code": "    private static final int HOUR = 60 * 60 * 1000;\n\n        UpdateCheck<Metadata, MetadataTransferException> check = newMetadataCheck();\n\n        long lastUpdate = new Date().getTime() - HOUR;\n        check.setLocalLastUpdated( lastUpdate );\n\n        // ! file.exists && updateRequired -> check in remote repo"}
{"magic_number_smell": "                    }\n                    else\n                    {\n                        kind = 3;\n                        value = new BigInteger( token );\n                    }\n                }", "refactored_code": "        private static final int KIND_BIGINT = 3;\n                    }\n                    else\n                    {\n                        kind = KIND_BIGINT;\n                        value = new BigInteger( token );\n                    }\n                }"}
{"magic_number_smell": "        {\n            for ( int j = i + 1; j < versions.length; j++ )\n            {\n                assertOrder( -1, versions[i], versions[j] );\n            }\n        }\n    }", "refactored_code": "    protected static final int X_LT_Y = -1;\n        {\n            for ( int j = i + 1; j < versions.length; j++ )\n            {\n                assertOrder( X_LT_Y, versions[i], versions[j] );\n            }\n        }\n    }"}
{"magic_number_smell": "  private void runWorkload() throws Exception {\n    final Object state = workload.initThread(workloadProps,0,0);\n    LOG.debug(\"load\");\n    for (int i = 0; i < 2000; i++) {\n      assertTrue(\"insert failed.\", workload.doInsert(client, state));\n    }\n    // Ensure we wait long enough for the batch writer to flush", "refactored_code": "  private static final int INSERT_COUNT = 2000;\n  private void runWorkload() throws Exception {\n    final Object state = workload.initThread(workloadProps,0,0);\n    LOG.debug(\"load\");\n    for (int i = 0; i < INSERT_COUNT; i++) {\n      assertTrue(\"insert failed.\", workload.doInsert(client, state));\n    }\n    // Ensure we wait long enough for the batch writer to flush"}
{"magic_number_smell": "    AzureCosmosClient.databaseName = this.getStringProperty(\"azurecosmos.databaseName\", DEFAULT_DATABASE_NAME);\n\n    AzureCosmosClient.maxDegreeOfParallelism = this.getIntProperty(\"azurecosmos.maxDegreeOfParallelism\",\n        -1);\n\n    AzureCosmosClient.maxBufferedItemCount = this.getIntProperty(\"azurecosmos.maxBufferedItemCount\",\n        DEFAULT_MAX_BUFFERED_ITEM_COUNT);", "refactored_code": "  private static final int DEFAULT_MAX_DEGREE_OF_PARALLELISM = -1;\n    AzureCosmosClient.databaseName = this.getStringProperty(\"azurecosmos.databaseName\", DEFAULT_DATABASE_NAME);\n\n    AzureCosmosClient.maxDegreeOfParallelism = this.getIntProperty(\"azurecosmos.maxDegreeOfParallelism\",\n        DEFAULT_MAX_DEGREE_OF_PARALLELISM);\n\n    AzureCosmosClient.maxBufferedItemCount = this.getIntProperty(\"azurecosmos.maxBufferedItemCount\",\n        DEFAULT_MAX_BUFFERED_ITEM_COUNT);"}
{"magic_number_smell": "    String table = props.getProperty(TABLE, TABLE_DEFAULT);\n    partitionKey = props.getProperty(PARTITIONKEY, PARTITIONKEY_DEFAULT);\n    batchSize = Integer.parseInt(props.getProperty(BATCHSIZE, BATCHSIZE_DEFAULT));\n    if (batchSize < 1 || batchSize > 100) {\n      throw new DBException(String.format(\"Batchsize must be between 1 and %d!\\n\", \n          100));\n    }", "refactored_code": "  private static final int BATCHSIZE_UPPERBOUND = 100;\n    String table = props.getProperty(TABLE, TABLE_DEFAULT);\n    partitionKey = props.getProperty(PARTITIONKEY, PARTITIONKEY_DEFAULT);\n    batchSize = Integer.parseInt(props.getProperty(BATCHSIZE, BATCHSIZE_DEFAULT));\n    if (batchSize < 1 || batchSize > BATCHSIZE_UPPERBOUND) {\n      throw new DBException(String.format(\"Batchsize must be between 1 and %d!\\n\", \n          BATCHSIZE_UPPERBOUND));\n    }"}
{"magic_number_smell": "   */\n  public static long fnvhash64(long val) {\n    //from http://en.wikipedia.org/wiki/Fowler_Noll_Vo_hash\n    long hashval = 0xCBF29CE484222325L;\n\n    for (int i = 0; i < 8; i++) {\n      long octet = val & 0x00ff;", "refactored_code": "  public static final long FNV_OFFSET_BASIS_64 = 0xCBF29CE484222325L;\n   */\n  public static long fnvhash64(long val) {\n    //from http://en.wikipedia.org/wiki/Fowler_Noll_Vo_hash\n    long hashval = FNV_OFFSET_BASIS_64;\n\n    for (int i = 0; i < 8; i++) {\n      long octet = val & 0x00ff;"}
{"magic_number_smell": "   * Make a generated counter value available via lastInt().\n   */\n  public void acknowledge(long value) {\n    final int currentSlot = (int)(value & WINDOW_SIZE - 1);\n    if (window[currentSlot]) {\n      throw new RuntimeException(\"Too many unacknowledged insertion keys.\");\n    }", "refactored_code": "  private static final int WINDOW_MASK = WINDOW_SIZE - 1;\n   * Make a generated counter value available via lastInt().\n   */\n  public void acknowledge(long value) {\n    final int currentSlot = (int)(value & WINDOW_MASK);\n    if (window[currentSlot]) {\n      throw new RuntimeException(\"Too many unacknowledged insertion keys.\");\n    }"}
{"magic_number_smell": "   * characters from the ASCII set. \n   */\n  public IncrementingPrintableStringGenerator() {\n    this(8, printableBasicAlphaASCIISet());\n  }\n\n  /**", "refactored_code": "  public static final int DEFAULTSTRINGLENGTH = 8;\n   * characters from the ASCII set. \n   */\n  public IncrementingPrintableStringGenerator() {\n    this(DEFAULTSTRINGLENGTH, printableBasicAlphaASCIISet());\n  }\n\n  /**"}
{"magic_number_smell": "   * @param timeUnits The time units of the returned Unix Epoch timestamp (as well\n   * as the units for the interval).\n   * @param intervals The total number of intervals for the generator.\n   * @throws IllegalArgumentException if the intervals is larger than {@link #16777216}\n   */\n  public RandomDiscreteTimestampGenerator(final long interval, final TimeUnit timeUnits, \n                                          final int intervals) {", "refactored_code": "  public static final int MAX_INTERVALS = 16777216;\n   * @param timeUnits The time units of the returned Unix Epoch timestamp (as well\n   * as the units for the interval).\n   * @param intervals The total number of intervals for the generator.\n   * @throws IllegalArgumentException if the intervals is larger than {@link #MAX_INTERVALS}\n   */\n  public RandomDiscreteTimestampGenerator(final long interval, final TimeUnit timeUnits, \n                                          final int intervals) {"}
{"magic_number_smell": "    this.max = max;\n    itemcount = this.max - this.min + 1;\n    if (zipfianconstant == USED_ZIPFIAN_CONSTANT) {\n      gen = new ZipfianGenerator(0, ITEM_COUNT, zipfianconstant, 26.46902820178302);\n    } else {\n      gen = new ZipfianGenerator(0, ITEM_COUNT, zipfianconstant);\n    }", "refactored_code": "  public static final double ZETAN = 26.46902820178302;\n    this.max = max;\n    itemcount = this.max - this.min + 1;\n    if (zipfianconstant == USED_ZIPFIAN_CONSTANT) {\n      gen = new ZipfianGenerator(0, ITEM_COUNT, zipfianconstant, ZETAN);\n    } else {\n      gen = new ZipfianGenerator(0, ITEM_COUNT, zipfianconstant);\n    }"}
{"magic_number_smell": "   * @param max The largest integer to generate in the sequence.\n   */\n  public ZipfianGenerator(long min, long max) {\n    this(min, max, 0.99);\n  }\n\n  /**", "refactored_code": "  public static final double ZIPFIAN_CONSTANT = 0.99;\n   * @param max The largest integer to generate in the sequence.\n   */\n  public ZipfianGenerator(long min, long max) {\n    this(min, max, ZIPFIAN_CONSTANT);\n  }\n\n  /**"}
{"magic_number_smell": "  @Override\n  public void init(Properties p) throws WorkloadException {\n    disksize = Long.parseLong(p.getProperty(DISK_SIZE_PROPERTY, String.valueOf(DISK_SIZE_PROPERTY_DEFAULT)));\n    storageages = Long.parseLong(p.getProperty(STORAGE_AGE_PROPERTY, String.valueOf(10)));\n    occupancy = Double.parseDouble(p.getProperty(OCCUPANCY_PROPERTY, String.valueOf(OCCUPANCY_PROPERTY_DEFAULT)));\n\n    if (p.getProperty(Client.RECORD_COUNT_PROPERTY) != null ||", "refactored_code": "  public static final long STORAGE_AGE_PROPERTY_DEFAULT = 10;\n  @Override\n  public void init(Properties p) throws WorkloadException {\n    disksize = Long.parseLong(p.getProperty(DISK_SIZE_PROPERTY, String.valueOf(DISK_SIZE_PROPERTY_DEFAULT)));\n    storageages = Long.parseLong(p.getProperty(STORAGE_AGE_PROPERTY, String.valueOf(STORAGE_AGE_PROPERTY_DEFAULT)));\n    occupancy = Double.parseDouble(p.getProperty(OCCUPANCY_PROPERTY, String.valueOf(OCCUPANCY_PROPERTY_DEFAULT)));\n\n    if (p.getProperty(Client.RECORD_COUNT_PROPERTY) != null ||"}
{"magic_number_smell": "\n    this.indexKey = props.getProperty(\"es.index.key\", DEFAULT_INDEX_KEY);\n\n    int numberOfShards = parseIntegerProperty(props, \"es.number_of_shards\", 1);\n    int numberOfReplicas = parseIntegerProperty(props, \"es.number_of_replicas\", NUMBER_OF_REPLICAS);\n\n    Boolean newdb = Boolean.parseBoolean(props.getProperty(\"es.newdb\", \"false\"));", "refactored_code": "  private static final int NUMBER_OF_SHARDS = 1;\n\n    this.indexKey = props.getProperty(\"es.index.key\", DEFAULT_INDEX_KEY);\n\n    int numberOfShards = parseIntegerProperty(props, \"es.number_of_shards\", NUMBER_OF_SHARDS);\n    int numberOfReplicas = parseIntegerProperty(props, \"es.number_of_replicas\", NUMBER_OF_REPLICAS);\n\n    Boolean newdb = Boolean.parseBoolean(props.getProperty(\"es.newdb\", \"false\"));"}
{"magic_number_smell": "\n    this.indexKey = props.getProperty(\"es.index.key\", DEFAULT_INDEX_KEY);\n\n    final int numberOfShards = parseIntegerProperty(props, \"es.number_of_shards\", 1);\n    final int numberOfReplicas = parseIntegerProperty(props, \"es.number_of_replicas\", NUMBER_OF_REPLICAS);\n\n    final Boolean newIndex = Boolean.parseBoolean(props.getProperty(\"es.new_index\", \"false\"));", "refactored_code": "  private static final int NUMBER_OF_SHARDS = 1;\n\n    this.indexKey = props.getProperty(\"es.index.key\", DEFAULT_INDEX_KEY);\n\n    final int numberOfShards = parseIntegerProperty(props, \"es.number_of_shards\", NUMBER_OF_SHARDS);\n    final int numberOfReplicas = parseIntegerProperty(props, \"es.number_of_replicas\", NUMBER_OF_REPLICAS);\n\n    final Boolean newIndex = Boolean.parseBoolean(props.getProperty(\"es.new_index\", \"false\"));"}
{"magic_number_smell": "\n    this.indexKey = props.getProperty(\"es.index.key\", DEFAULT_INDEX_KEY);\n\n    final int numberOfShards = parseIntegerProperty(props, \"es.number_of_shards\", 1);\n    final int numberOfReplicas = parseIntegerProperty(props, \"es.number_of_replicas\", NUMBER_OF_REPLICAS);\n\n    final Boolean newIndex = Boolean.parseBoolean(props.getProperty(\"es.new_index\", \"false\"));", "refactored_code": "  private static final int NUMBER_OF_SHARDS = 1;\n\n    this.indexKey = props.getProperty(\"es.index.key\", DEFAULT_INDEX_KEY);\n\n    final int numberOfShards = parseIntegerProperty(props, \"es.number_of_shards\", NUMBER_OF_SHARDS);\n    final int numberOfReplicas = parseIntegerProperty(props, \"es.number_of_replicas\", NUMBER_OF_REPLICAS);\n\n    final Boolean newIndex = Boolean.parseBoolean(props.getProperty(\"es.new_index\", \"false\"));"}
{"magic_number_smell": "\n      Row row = container.createRow();\n\n      row.setValue(0, rowKey);\n\n      for (int i = 1; i < containerInfo.getColumnCount(); i++) {\n        ByteIterator byteIterator = values.get(containerInfo.getColumnInfo(i).getName());", "refactored_code": "  public static final int ROW_KEY_COLUMN_POS = 0;\n\n      Row row = container.createRow();\n\n      row.setValue(ROW_KEY_COLUMN_POS, rowKey);\n\n      for (int i = 1; i < containerInfo.getColumnCount(); i++) {\n        ByteIterator byteIterator = values.get(containerInfo.getColumnInfo(i).getName());"}
{"magic_number_smell": "        Socket socket = null;\n        try {\n            // Connect\n            socket = new Socket(InetAddress.getLocalHost(), 10040);\n            assertThat(\"Socket is not bound.\", socket.getLocalPort(), not(-1));\n        } catch (IOException connectFailed) {\n            assumeNoException(\"GridDB is not running. Skipping tests.\",", "refactored_code": "    private static final int GRIDDB_DEFAULT_PORT = 10040;\n        Socket socket = null;\n        try {\n            // Connect\n            socket = new Socket(InetAddress.getLocalHost(), GRIDDB_DEFAULT_PORT);\n            assertThat(\"Socket is not bound.\", socket.getLocalPort(), not(-1));\n        } catch (IOException connectFailed) {\n            assumeNoException(\"GridDB is not running. Skipping tests.\","}
{"magic_number_smell": "        That method is neither public nor static so we need a copy.\n     */\n    private String buildDeterministicValue(String key, String fieldkey) {\n        int size = 32;\n        StringBuilder sb = new StringBuilder(size);\n        sb.append(key);\n        sb.append(':');", "refactored_code": "    private static final int FIELD_LENGTH = 32;\n        That method is neither public nor static so we need a copy.\n     */\n    private String buildDeterministicValue(String key, String fieldkey) {\n        int size = FIELD_LENGTH;\n        StringBuilder sb = new StringBuilder(size);\n        sb.append(key);\n        sb.append(':');"}
{"magic_number_smell": "        return;\n      }\n      int numTablets = getIntFromProp(prop, PRE_SPLIT_NUM_TABLETS_OPT, 4);\n      if (numTablets > 9000) {\n        throw new DBException(\"Specified number of tablets (\" + numTablets\n            + \") must be equal \" + \"or below \" + 9000);\n      }", "refactored_code": "  private static final int MAX_TABLETS = 9000;\n        return;\n      }\n      int numTablets = getIntFromProp(prop, PRE_SPLIT_NUM_TABLETS_OPT, 4);\n      if (numTablets > MAX_TABLETS) {\n        throw new DBException(\"Specified number of tablets (\" + numTablets\n            + \") must be equal \" + \"or below \" + MAX_TABLETS);\n      }"}
{"magic_number_smell": "    String[] hosts = getProperties().getProperty(HOSTS_PROPERTY).split(\",\");\n    for (String address : hosts) {\n      int colon = address.indexOf(\":\");\n      int port = 11211;\n      String host = address;\n      if (colon != -1) {\n        port = Integer.parseInt(address.substring(colon + 1));", "refactored_code": "  public static final int DEFAULT_PORT = 11211;\n    String[] hosts = getProperties().getProperty(HOSTS_PROPERTY).split(\",\");\n    for (String address : hosts) {\n      int colon = address.indexOf(\":\");\n      int port = DEFAULT_PORT;\n      String host = address;\n      if (colon != -1) {\n        port = Integer.parseInt(address.substring(colon + 1));"}
{"magic_number_smell": "      if (fields != null) {\n        final DocumentBuilder fieldsDoc = BuilderFactory.start();\n        for (final String field : fields) {\n          fieldsDoc.add(field, 1);\n        }\n\n        find.projection(fieldsDoc);", "refactored_code": "  protected static final int INCLUDE = 1;\n      if (fields != null) {\n        final DocumentBuilder fieldsDoc = BuilderFactory.start();\n        for (final String field : fields) {\n          fieldsDoc.add(field, INCLUDE);\n        }\n\n        find.projection(fieldsDoc);"}
{"magic_number_smell": "    Socket socket = null;\n    try {\n      // Connect\n      socket = new Socket(InetAddress.getLocalHost(), 27017);\n      assertThat(\"Socket is not bound.\", socket.getLocalPort(), not(-1));\n    } catch (IOException connectFailed) {\n      assumeNoException(\"MongoDB is not running. Skipping tests.\",", "refactored_code": "  private static final int MONGODB_DEFAULT_PORT = 27017;\n    Socket socket = null;\n    try {\n      // Connect\n      socket = new Socket(InetAddress.getLocalHost(), MONGODB_DEFAULT_PORT);\n      assertThat(\"Socket is not bound.\", socket.getLocalPort(), not(-1));\n    } catch (IOException connectFailed) {\n      assumeNoException(\"MongoDB is not running. Skipping tests.\","}
{"magic_number_smell": "      That method is neither public nor static so we need a copy.\n   */\n  private String buildDeterministicValue(String key, String fieldkey) {\n    int size = 32;\n    StringBuilder sb = new StringBuilder(size);\n    sb.append(key);\n    sb.append(':');", "refactored_code": "  private static final int    FIELD_LENGTH = 32;\n      That method is neither public nor static so we need a copy.\n   */\n  private String buildDeterministicValue(String key, String fieldkey) {\n    int size = FIELD_LENGTH;\n    StringBuilder sb = new StringBuilder(size);\n    sb.append(key);\n    sb.append(':');"}
{"magic_number_smell": "\n  /** The properties settings */\n  private static final String HOST_NAME  = \"localhost\";\n  private static final String TEST_DB_URL = \"jdbc:postgresql://\" + HOST_NAME + \":\" + 5432 + \"/\" + DATABASE_NAME;\n  private static final String TABLE_NAME = \"usertable\";\n  private static final int FIELD_LENGTH = 32;\n  private static final String FIELD_PREFIX = \"FIELD\";", "refactored_code": "  private static final int DEFAULT_PORT = 5432;\n\n  /** The properties settings */\n  private static final String HOST_NAME  = \"localhost\";\n  private static final String TEST_DB_URL = \"jdbc:postgresql://\" + HOST_NAME + \":\" + DEFAULT_PORT + \"/\" + DATABASE_NAME;\n  private static final String TABLE_NAME = \"usertable\";\n  private static final int FIELD_LENGTH = 32;\n  private static final String FIELD_PREFIX = \"FIELD\";"}
{"magic_number_smell": "    }\n\n    // Just add some records to work on...\n    for (int i = 0; i < 20; i++) {\n      // Abort the entire test whenever the dataset population operation fails.\n      assumeThat(\"Riak KV is NOT RUNNING, aborting test.\",\n          riakClient.insert(bucket, keyPrefix + String.valueOf(i), StringByteIterator.getByteIteratorMap(", "refactored_code": "  private static final int recordsToInsert = 20;\n    }\n\n    // Just add some records to work on...\n    for (int i = 0; i < recordsToInsert; i++) {\n      // Abort the entire test whenever the dataset population operation fails.\n      assumeThat(\"Riak KV is NOT RUNNING, aborting test.\",\n          riakClient.insert(bucket, keyPrefix + String.valueOf(i), StringByteIterator.getByteIteratorMap("}
{"magic_number_smell": "\n  private static final Map<String, ByteIterator> MOCK_DATA;\n  static {\n    MOCK_DATA = new HashMap<>(10);\n    for (int i = 0; i < 10; i++) {\n      MOCK_DATA.put(FIELD_PREFIX + i, new StringByteIterator(\"value\" + i));\n    }", "refactored_code": "  private static final int NUM_RECORDS = 10;\n\n  private static final Map<String, ByteIterator> MOCK_DATA;\n  static {\n    MOCK_DATA = new HashMap<>(NUM_RECORDS);\n    for (int i = 0; i < NUM_RECORDS; i++) {\n      MOCK_DATA.put(FIELD_PREFIX + i, new StringByteIterator(\"value\" + i));\n    }"}
{"magic_number_smell": "    Socket socket = null;\n    try {\n      // Connect\n      socket = new Socket(serverNamesArray[0], 21212);\n      dbThere = true;\n    } catch (IOException connectFailed) {\n      dbThere = false;", "refactored_code": "  private static final int VOLTDB_DEFAULT_PORT = 21212;\n    Socket socket = null;\n    try {\n      // Connect\n      socket = new Socket(serverNamesArray[0], VOLTDB_DEFAULT_PORT);\n      dbThere = true;\n    } catch (IOException connectFailed) {\n      dbThere = false;"}
{"magic_number_smell": "   * public nor static so we need a copy.\n   */\n  private String buildDeterministicValue(String key, String fieldkey) {\n    int size = 32;\n    StringBuilder sb = new StringBuilder(size);\n    sb.append(key);\n    sb.append(':');", "refactored_code": "  private static final int FIELD_LENGTH = 32;\n   * public nor static so we need a copy.\n   */\n  private String buildDeterministicValue(String key, String fieldkey) {\n    int size = FIELD_LENGTH;\n    StringBuilder sb = new StringBuilder(size);\n    sb.append(key);\n    sb.append(':');"}
{"magic_number_smell": "    if (sessionTimeoutString != null) {\n      sessionTimeout = Integer.parseInt(sessionTimeoutString);\n    } else {\n      sessionTimeout = TimeUnit.SECONDS.toMillis(30L);\n    }\n\n    try {", "refactored_code": "  private static final long DEFAULT_SESSION_TIMEOUT = TimeUnit.SECONDS.toMillis(30L);\n    if (sessionTimeoutString != null) {\n      sessionTimeout = Integer.parseInt(sessionTimeoutString);\n    } else {\n      sessionTimeout = DEFAULT_SESSION_TIMEOUT;\n    }\n\n    try {"}
{"magic_number_smell": "\n  @BeforeClass\n  public static void setUpClass() throws Exception {\n    zkTestServer = new TestingServer(2181);\n    zkTestServer.start();\n  }\n", "refactored_code": "  private static final int PORT = 2181;\n\n  @BeforeClass\n  public static void setUpClass() throws Exception {\n    zkTestServer = new TestingServer(PORT);\n    zkTestServer.start();\n  }\n"}
{"magic_number_smell": "    public static final int                1  = 1;\n    public static final int                MSG_AVAILABLE    = 2;\n    public static final int                TIMED_OUT        = 3;\n    public static final Event              spaceAvailble = new Event(1);\n    public static final Event              messageAvailable = new Event(MSG_AVAILABLE);\n    public static final Event              timedOut         = new Event(TIMED_OUT);\n    // private static final String defaultName_ = \"DEFAULT-CELL\";", "refactored_code": "    public static final int                SPACE_AVAILABLE  = 1;\n    public static final int                SPACE_AVAILABLE  = 1;\n    public static final int                MSG_AVAILABLE    = 2;\n    public static final int                TIMED_OUT        = 3;\n    public static final Event              spaceAvailble = new Event(SPACE_AVAILABLE);\n    public static final Event              messageAvailable = new Event(MSG_AVAILABLE);\n    public static final Event              timedOut         = new Event(TIMED_OUT);\n    // private static final String defaultName_ = \"DEFAULT-CELL\";"}
{"magic_number_smell": "                pc = 0;\n//                if (debug) System.out.println(\"\\nup(not pausing)\" + this);;\n//                if (debug) ds();\n                return 0;\n            } else {\n                stack[d] = null; // clean up\n                pc = cs.pc;", "refactored_code": "    public static final int   NOT_PAUSING__NO_STATE  = 0;\n                pc = 0;\n//                if (debug) System.out.println(\"\\nup(not pausing)\" + this);;\n//                if (debug) ds();\n                return NOT_PAUSING__NO_STATE;\n            } else {\n                stack[d] = null; // clean up\n                pc = cs.pc;"}
{"magic_number_smell": "    public static final int 1 = 1;\n    public static final int MSG_AVAILABLE = 2;\n    public static final int TIMED_OUT = 3;\n    public static final Event spaceAvailble = new Event(1);\n    public static final Event messageAvailable = new Event(MSG_AVAILABLE);\n    public static final Event timedOut = new Event(TIMED_OUT);\n    ", "refactored_code": "    public static final int SPACE_AVAILABLE = 1;\n    public static final int SPACE_AVAILABLE = 1;\n    public static final int MSG_AVAILABLE = 2;\n    public static final int TIMED_OUT = 3;\n    public static final Event spaceAvailble = new Event(SPACE_AVAILABLE);\n    public static final Event messageAvailable = new Event(MSG_AVAILABLE);\n    public static final Event timedOut = new Event(TIMED_OUT);\n    "}
{"magic_number_smell": "\tpublic static final int MSG_AVAILABLE = 2;\n\tpublic static final int TIMED_OUT = 3;\n\n        public static final Event spaceAvailble = new Event(1);\n        public static final Event messageAvailable = new Event(MSG_AVAILABLE);\n\tpublic static final Event timedOut = new Event(TIMED_OUT);\n", "refactored_code": "\tpublic static final int SPACE_AVAILABLE = 1;\n\tpublic static final int MSG_AVAILABLE = 2;\n\tpublic static final int TIMED_OUT = 3;\n\n        public static final Event spaceAvailble = new Event(SPACE_AVAILABLE);\n        public static final Event messageAvailable = new Event(MSG_AVAILABLE);\n\tpublic static final Event timedOut = new Event(TIMED_OUT);\n"}
{"magic_number_smell": "\tpublic static final int MSG_AVAILABLE = 2;\n\tpublic static final int TIMED_OUT = 3;\n\n        public static final Event spaceAvailble = new Event(1);\n        public static final Event messageAvailable = new Event(MSG_AVAILABLE);\n\tpublic static final Event timedOut = new Event(TIMED_OUT);\n", "refactored_code": "\tpublic static final int SPACE_AVAILABLE = 1;\n\tpublic static final int MSG_AVAILABLE = 2;\n\tpublic static final int TIMED_OUT = 3;\n\n        public static final Event spaceAvailble = new Event(SPACE_AVAILABLE);\n        public static final Event messageAvailable = new Event(MSG_AVAILABLE);\n\tpublic static final Event timedOut = new Event(TIMED_OUT);\n"}
{"magic_number_smell": "\t\t}\n\t\tmask = this.capacity - 1;\n\t\t// pad data on either end with some empty slots.\n\t\tbuffer = (E[]) new Object[(this.capacity << SPARSE_SHIFT) + 64\n\t\t\t\t* 2];\n\t}\n", "refactored_code": "\tprotected static final int BUFFER_PAD = 64; // to\n\t\t}\n\t\tmask = this.capacity - 1;\n\t\t// pad data on either end with some empty slots.\n\t\tbuffer = (E[]) new Object[(this.capacity << SPARSE_SHIFT) + BUFFER_PAD\n\t\t\t\t* 2];\n\t}\n"}
{"magic_number_smell": "            exitmb2.getb();\n            final long duration = System.nanoTime() - start;\n            final long ops = (REPETITIONS * 1000L * 1000L * 1000L) / duration;\n            if (result != 777) throw new RuntimeException(\"wrong value: \" + result);\n            System.out.format(\"%8d ops/sec\\n\", ops);\n\n    }", "refactored_code": "    public static final int TEST_VALUE = 777;\n            exitmb2.getb();\n            final long duration = System.nanoTime() - start;\n            final long ops = (REPETITIONS * 1000L * 1000L * 1000L) / duration;\n            if (result != TEST_VALUE) throw new RuntimeException(\"wrong value: \" + result);\n            System.out.format(\"%8d ops/sec\\n\", ops);\n\n    }"}
{"magic_number_smell": "\n    \n    public int getPausableStatus(String className, String methodName, String desc) {\n        int ret = 0;\n        // array methods (essentially methods deferred to Object (clone, wait etc)\n        // and constructor methods are not pausable\n        if (isNonPausableClass(className) || isNonPausableMethod(methodName)) {", "refactored_code": "    public static final int METHOD_NOT_FOUND_OR_PAUSABLE = 0; // either not found, or not pausable if found.\n\n    \n    public int getPausableStatus(String className, String methodName, String desc) {\n        int ret = METHOD_NOT_FOUND_OR_PAUSABLE;\n        // array methods (essentially methods deferred to Object (clone, wait etc)\n        // and constructor methods are not pausable\n        if (isNonPausableClass(className) || isNonPausableMethod(methodName)) {"}
{"magic_number_smell": "    public volatile boolean onHeap = false; //true if timer is already on timerHeap\n\n    public static final int                3        = 3;\n    public static final Event              timedOut         = new Event(3);\n    \n    \n\tpublic int index;", "refactored_code": "    public static final int                TIMED_OUT        = 3;\n    public volatile boolean onHeap = false; //true if timer is already on timerHeap\n\n    public static final int                TIMED_OUT        = 3;\n    public static final Event              timedOut         = new Event(TIMED_OUT);\n    \n    \n\tpublic int index;"}
{"magic_number_smell": "\n    public static void performanceRun() {\n        // Init mailbox with maxSize given\n        Mailbox<Integer> mbox = new Mailbox<Integer>(32 * 1024,\n                32 * 1024);\n        Mailbox<ExitMsg> exitmb1 = new Mailbox<ExitMsg>();\n        Mailbox<ExitMsg> exitmb2 = new Mailbox<ExitMsg>();", "refactored_code": "    public static final int MAILBOX_CAPACITY = 32 * 1024;\n\n    public static void performanceRun() {\n        // Init mailbox with maxSize given\n        Mailbox<Integer> mbox = new Mailbox<Integer>(MAILBOX_CAPACITY,\n                MAILBOX_CAPACITY);\n        Mailbox<ExitMsg> exitmb1 = new Mailbox<ExitMsg>();\n        Mailbox<ExitMsg> exitmb2 = new Mailbox<ExitMsg>();"}
{"magic_number_smell": "    private static final int 16 = 16;\n\n    StylesheetCache() {\n        super(16,  0.75f, true);\n    }\n\n    protected boolean removeEldestEntry(java.util.Map.Entry<String, Stylesheet> eldest) {", "refactored_code": "    private static final int cacheCapacity = 16;\n    private static final int cacheCapacity = 16;\n\n    StylesheetCache() {\n        super(cacheCapacity,  0.75f, true);\n    }\n\n    protected boolean removeEldestEntry(java.util.Map.Entry<String, Stylesheet> eldest) {"}
{"magic_number_smell": "          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = -1;\n            break zzForAction;\n          }\n          else {", "refactored_code": "  public static final int YYEOF = -1;\n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {"}
{"magic_number_smell": "        _cssText = cssText;\n\n        if (type == CSSPrimitiveValue.CSS_NUMBER && floatValue != 0.0f) {\n            _propertyValueType = 1;\n        } else {\n            _propertyValueType = VALUE_TYPE_LENGTH;\n        }", "refactored_code": "    public static final short VALUE_TYPE_NUMBER = 1;\n        _cssText = cssText;\n\n        if (type == CSSPrimitiveValue.CSS_NUMBER && floatValue != 0.0f) {\n            _propertyValueType = VALUE_TYPE_NUMBER;\n        } else {\n            _propertyValueType = VALUE_TYPE_LENGTH;\n        }"}
{"magic_number_smell": "    public static final int VERTICAL_BAR = 53;\n    public static final int EOF = 54;\n\n    public static final Token TK_S = new Token(1, \"1\", \"whitespace\");\n    public static final Token TK_CDO = new Token(CDO, \"CDO\", \"<!--\");\n    public static final Token TK_CDC = new Token(CDC, \"CDC\", \"-->\");\n    public static final Token TK_INCLUDES = new Token(INCLUDES, \"INCLUDES\", \"an attribute word match\");", "refactored_code": "    public static final int S = 1;\n    public static final int VERTICAL_BAR = 53;\n    public static final int EOF = 54;\n\n    public static final Token TK_S = new Token(S, \"S\", \"whitespace\");\n    public static final Token TK_CDO = new Token(CDO, \"CDO\", \"<!--\");\n    public static final Token TK_CDC = new Token(CDC, \"CDC\", \"-->\");\n    public static final Token TK_INCLUDES = new Token(INCLUDES, \"INCLUDES\", \"an attribute word match\");"}
{"magic_number_smell": "        RectPropertySet padding = getPaddingRect(cbWidth, cssCtx);\n\n        return switch (which) {\n            case 1 -> (int) (margin.left() + border.left() + padding.left());\n            case RIGHT -> (int) (margin.right() + border.right() + padding.right());\n            case TOP -> (int) (margin.top() + border.top() + padding.top());\n            case BOTTOM -> (int) (margin.bottom() + border.bottom() + padding.bottom());", "refactored_code": "    public static final int LEFT = 1;\n        RectPropertySet padding = getPaddingRect(cbWidth, cssCtx);\n\n        return switch (which) {\n            case LEFT -> (int) (margin.left() + border.left() + padding.left());\n            case RIGHT -> (int) (margin.right() + border.right() + padding.right());\n            case TOP -> (int) (margin.top() + border.top() + padding.top());\n            case BOTTOM -> (int) (margin.bottom() + border.bottom() + padding.bottom());"}
{"magic_number_smell": "            relayoutDataList = new RelayoutDataList(localChildren.size());\n        }\n\n        int pageCount = -1;\n        BlockBox previousChildBox = null;\n        for (Box localChild : localChildren) {\n            BlockBox child = (BlockBox) localChild;", "refactored_code": "    private static final int NO_PAGE_TRIM = -1;\n            relayoutDataList = new RelayoutDataList(localChildren.size());\n        }\n\n        int pageCount = NO_PAGE_TRIM;\n        BlockBox previousChildBox = null;\n        for (Box localChild : localChildren) {\n            BlockBox child = (BlockBox) localChild;"}
{"magic_number_smell": "            if (cellStyle != null) {\n                TableCellBox cell = createMarginBox(c, cellStyle, alwaysCreate);\n                if (cell != null) {\n                    if (direction == 1) {\n                        CalculatedStyle tableRowStyle = pageStyle.createAnonymousStyle(IdentValue.TABLE_ROW);\n                        row = (TableRowBox) createBlockBox(tableRowStyle, info, false);\n                        row.setStyle(tableRowStyle);", "refactored_code": "    public static final int MARGIN_BOX_VERTICAL = 1;\n            if (cellStyle != null) {\n                TableCellBox cell = createMarginBox(c, cellStyle, alwaysCreate);\n                if (cell != null) {\n                    if (direction == MARGIN_BOX_VERTICAL) {\n                        CalculatedStyle tableRowStyle = pageStyle.createAnonymousStyle(IdentValue.TABLE_ROW);\n                        row = (TableRowBox) createBlockBox(tableRowStyle, info, false);\n                        row.setStyle(tableRowStyle);"}
{"magic_number_smell": "\n    public void floatBox(LayoutContext c, Layer layer, BlockFormattingContext bfc, BlockBox box) {\n        if (box.getStyle().isFloatedLeft()) {\n            position(c, bfc, box, 1);\n            save(box, layer, bfc, 1);\n        } else if (box.getStyle().isFloatedRight()) {\n            position(c, bfc, box, RIGHT);", "refactored_code": "    private static final int LEFT = 1;\n\n    public void floatBox(LayoutContext c, Layer layer, BlockFormattingContext bfc, BlockBox box) {\n        if (box.getStyle().isFloatedLeft()) {\n            position(c, bfc, box, LEFT);\n            save(box, layer, bfc, LEFT);\n        } else if (box.getStyle().isFloatedRight()) {\n            position(c, bfc, box, RIGHT);"}
{"magic_number_smell": "\n                int q = 0;\n                do {\n                    if (q++ > 100000) {\n                        throw new XRRuntimeException(\"Too many iterations (\" + q + \") in InlineBoxing, giving up.\");\n                    }\n", "refactored_code": "    private static final int MAX_ITERATION_COUNT = 100000;\n\n                int q = 0;\n                do {\n                    if (q++ > MAX_ITERATION_COUNT) {\n                        throw new XRRuntimeException(\"Too many iterations (\" + q + \") in InlineBoxing, giving up.\");\n                    }\n"}
{"magic_number_smell": "        int paintingTop = additionalClearance;\n        for (PageBox page : pages) {\n            page.setPaintingTop(paintingTop);\n            if (mode == 1) {\n                page.setPaintingBottom(paintingTop + page.getHeight(cssCtx));\n            } else if (mode == PAGED_MODE_PRINT) {\n                page.setPaintingBottom(paintingTop + page.getContentHeight(cssCtx));", "refactored_code": "    public static final short PAGED_MODE_SCREEN = 1;\n        int paintingTop = additionalClearance;\n        for (PageBox page : pages) {\n            page.setPaintingTop(paintingTop);\n            if (mode == PAGED_MODE_SCREEN) {\n                page.setPaintingBottom(paintingTop + page.getHeight(cssCtx));\n            } else if (mode == PAGED_MODE_PRINT) {\n                page.setPaintingBottom(paintingTop + page.getContentHeight(cssCtx));"}
{"magic_number_smell": "     */\n    public void setDPI(float dpi) {\n        this.dpi = dpi;\n        mm_per_dot = (CM__PER__IN * 10) / dpi;\n    }\n\n    /**", "refactored_code": "    private static final int MM__PER__CM = 10;\n     */\n    public void setDPI(float dpi) {\n        this.dpi = dpi;\n        mm_per_dot = (CM__PER__IN * MM__PER__CM) / dpi;\n    }\n\n    /**"}
{"magic_number_smell": "        BorderPropertySet border = getStyle().getBorder(c);\n        // For border left, we need to check, in order of precedence:\n        // (1) Our left border.\n        CollapsedBorderValue result = CollapsedBorderValue.borderLeft(border, 10);\n\n        // (2) The previous cell's right border.\n        TableCellBox prevCell = getTable().cellLeft(this);", "refactored_code": "    private static final int BCELL = 10;\n        BorderPropertySet border = getStyle().getBorder(c);\n        // For border left, we need to check, in order of precedence:\n        // (1) Our left border.\n        CollapsedBorderValue result = CollapsedBorderValue.borderLeft(border, BCELL);\n\n        // (2) The previous cell's right border.\n        TableCellBox prevCell = getTable().cellLeft(this);"}
{"magic_number_smell": "\n    public static final int 1 = 1;\n    public static final int POSITION_HORIZONTALLY = 2;\n    public static final int POSITION_BOTH = 1 | POSITION_HORIZONTALLY;\n\n    public static final int CONTENT_UNKNOWN = 0;\n    public static final int CONTENT_INLINE = 1;", "refactored_code": "    public static final int POSITION_VERTICALLY = 1;\n\n    public static final int POSITION_VERTICALLY = 1;\n    public static final int POSITION_HORIZONTALLY = 2;\n    public static final int POSITION_BOTH = POSITION_VERTICALLY | POSITION_HORIZONTALLY;\n\n    public static final int CONTENT_UNKNOWN = 0;\n    public static final int CONTENT_INLINE = 1;"}
{"magic_number_smell": "    public static final int LEFT = 2;\n    public static final int BOTTOM = 4;\n    public static final int RIGHT = 8;\n    public static final int ALL = 1 + LEFT + BOTTOM + RIGHT;\n\n    /**\n     * Generates a full round rectangle that is made of bounds and border", "refactored_code": "    public static final int TOP = 1;\n    public static final int LEFT = 2;\n    public static final int BOTTOM = 4;\n    public static final int RIGHT = 8;\n    public static final int ALL = TOP + LEFT + BOTTOM + RIGHT;\n\n    /**\n     * Generates a full round rectangle that is made of bounds and border"}
{"magic_number_smell": "    public static final int CHILDREN_FLUX = 2;\n    public static final int DONE = 3;\n\n    private int _state = 0;\n\n    public static final int DUMP_RENDER = 2;\n", "refactored_code": "    public static final int NOTHING = 0;\n    public static final int CHILDREN_FLUX = 2;\n    public static final int DONE = 3;\n\n    private int _state = NOTHING;\n\n    public static final int DUMP_RENDER = 2;\n"}
{"magic_number_smell": "public class ContentLimit {\n    public static final int -1 = -1;\n\n    private int _top = -1;\n    private int _bottom = -1;\n\n    public int getTop() {", "refactored_code": "    public static final int UNDEFINED = -1;\npublic class ContentLimit {\n    public static final int UNDEFINED = -1;\n\n    private int _top = UNDEFINED;\n    private int _bottom = UNDEFINED;\n\n    public int getTop() {"}
{"magic_number_smell": " */\npublic class LineBox extends Box implements InlinePaintable {\n    private static final float 0.20f = 0.20f;\n    private static final float JUSTIFY_SPACE_SHARE = 1 - 0.20f;\n\n    private boolean _endsOnNL;\n    private boolean _containsContent;", "refactored_code": "    private static final float JUSTIFY_NON_SPACE_SHARE = 0.20f;\n */\npublic class LineBox extends Box implements InlinePaintable {\n    private static final float JUSTIFY_NON_SPACE_SHARE = 0.20f;\n    private static final float JUSTIFY_SPACE_SHARE = 1 - JUSTIFY_NON_SPACE_SHARE;\n\n    private boolean _endsOnNL;\n    private boolean _containsContent;"}
{"magic_number_smell": "    }\n\n    public void exportLeadingText(RenderingContext c, Writer writer) throws IOException {\n        for (int i = 0; i < 5; i++) {\n            MarginAreaContainer container = _marginAreas[i];\n            if (container != null) {\n                container.getTable().exportText(c, writer);", "refactored_code": "    private static final int LEADING_TRAILING_SPLIT = 5;\n    }\n\n    public void exportLeadingText(RenderingContext c, Writer writer) throws IOException {\n        for (int i = 0; i < LEADING_TRAILING_SPLIT; i++) {\n            MarginAreaContainer container = _marginAreas[i];\n            if (container != null) {\n                container.getTable().exportText(c, writer);"}
{"magic_number_smell": "    private void setDefaultActionMap(JComponent view) {\n        view.getActionMap().put(PAGE_DOWN,\n                new AbstractAction() {\n                    private static final long 2L = 1L;\n\n                    @Override\n                    public void actionPerformed(ActionEvent evt) {", "refactored_code": "    private static final long serialVersionUID = 2L;\n    private void setDefaultActionMap(JComponent view) {\n        view.getActionMap().put(PAGE_DOWN,\n                new AbstractAction() {\n                    private static final long serialVersionUID = 1L;\n\n                    @Override\n                    public void actionPerformed(ActionEvent evt) {"}
{"magic_number_smell": "                String output = f.getAbsolutePath();\n                output = output.substring(0, output.lastIndexOf(\".\")) + \".png\";\n                System.out.println(\"Saving image to \" + output);\n                renderToImage(f, output, 1024);\n            } else {\n                usage(\"File to render is not found: \" + url);\n            }", "refactored_code": "    public static final int DEFAULT_WIDTH = 1024;\n                String output = f.getAbsolutePath();\n                output = output.substring(0, output.lastIndexOf(\".\")) + \".png\";\n                System.out.println(\"Saving image to \" + output);\n                renderToImage(f, output, DEFAULT_WIDTH);\n            } else {\n                usage(\"File to render is not found: \" + url);\n            }"}
{"magic_number_smell": "        if (e.getNodeName().equalsIgnoreCase(\"textarea\")) {\n            _multiline = true;\n            _password = false;\n            _size = getIntAttribute(e, \"cols\", 20);\n            _rows = getIntAttribute(e, \"rows\", DEFAULT_ROWS);\n            _maxlength = -1;\n            setInitialValue(collectText(e));", "refactored_code": "    public static final int DEFAULT_SIZE = 20;\n        if (e.getNodeName().equalsIgnoreCase(\"textarea\")) {\n            _multiline = true;\n            _password = false;\n            _size = getIntAttribute(e, \"cols\", DEFAULT_SIZE);\n            _rows = getIntAttribute(e, \"rows\", DEFAULT_ROWS);\n            _maxlength = -1;\n            setInitialValue(collectText(e));"}
{"magic_number_smell": "\n        final int pagePaintingClearanceWidth = isCenteredPagedView() ?\n                calcCenteredPageLeftOffset(root.getMaxPageWidth(c, 0)) :\n                10;\n        root.assignPagePaintingPositions(\n                c, Layer.PAGED_MODE_SCREEN, PAGE_PAINTING_CLEARANCE_HEIGHT);\n", "refactored_code": "    private static final int PAGE_PAINTING_CLEARANCE_WIDTH = 10;\n\n        final int pagePaintingClearanceWidth = isCenteredPagedView() ?\n                calcCenteredPageLeftOffset(root.getMaxPageWidth(c, 0)) :\n                PAGE_PAINTING_CLEARANCE_WIDTH;\n        root.assignPagePaintingPositions(\n                c, Layer.PAGED_MODE_SCREEN, PAGE_PAINTING_CLEARANCE_HEIGHT);\n"}
{"magic_number_smell": "    }\n\n    private void layout(int width) {\n        Rectangle rect = new Rectangle(0, 0, width, 1000);\n        sharedContext.setTemporaryCanvas(rect);\n        BlockBox root = BoxBuilder.createRootBox(layoutContext, doc);\n        root.setContainingBlock(new ViewportBox(rect));", "refactored_code": "    private static final int DEFAULT_HEIGHT = 1000;\n    }\n\n    private void layout(int width) {\n        Rectangle rect = new Rectangle(0, 0, width, DEFAULT_HEIGHT);\n        sharedContext.setTemporaryCanvas(rect);\n        BlockBox root = BoxBuilder.createRootBox(layoutContext, doc);\n        root.setContainingBlock(new ViewportBox(rect));"}
{"magic_number_smell": "}\n\nfinal class ElementPropertiesPanel extends JPanel {\n    private static final long 1L = 1L;\n\n    //private SharedContext _context;\n    private final StyleReference _sr;", "refactored_code": "    private static final long serialVersionUID = 1L;\n}\n\nfinal class ElementPropertiesPanel extends JPanel {\n    private static final long serialVersionUID = 1L;\n\n    //private SharedContext _context;\n    private final StyleReference _sr;"}
{"magic_number_smell": "    }\n\n    static final class QuitAction extends AbstractAction {\n        private static final long 1L = 1L;\n\n        QuitAction() {\n            super(\"Quit\");", "refactored_code": "            private static final long serialVersionUID = 1L;\n    }\n\n    static final class QuitAction extends AbstractAction {\n        private static final long serialVersionUID = 1L;\n\n        QuitAction() {\n            super(\"Quit\");"}
{"magic_number_smell": "    }\n\n    private void layout(int width) {\n        Rectangle rect = new Rectangle(0, 0, width, 1000);\n        sharedContext.setTemporaryCanvas(rect);\n        LayoutContext c = newLayoutContext();\n        BlockBox root = BoxBuilder.createRootBox(c, doc);", "refactored_code": "    private static final int DEFAULT_HEIGHT = 1000;\n    }\n\n    private void layout(int width) {\n        Rectangle rect = new Rectangle(0, 0, width, DEFAULT_HEIGHT);\n        sharedContext.setTemporaryCanvas(rect);\n        LayoutContext c = newLayoutContext();\n        BlockBox root = BoxBuilder.createRootBox(c, doc);"}
{"magic_number_smell": "     * Creates a new instance of NaiveUserAgent with a max image cache of 16 images.\n     */\n    public NaiveUserAgent() {\n        this(16);\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_IMAGE_CACHE_SIZE = 16;\n     * Creates a new instance of NaiveUserAgent with a max image cache of 16 images.\n     */\n    public NaiveUserAgent() {\n        this(DEFAULT_IMAGE_CACHE_SIZE);\n    }\n\n    /**"}
{"magic_number_smell": "    public void repaintRequested(final boolean doLayout) {\n        final long now = System.currentTimeMillis();\n        final long el = now - lastRepaintRunAt;\n        if (!doLayout || el > 50 || pendingRepaintCount > 5) {\n            XRLog.general(Level.FINE, \"*** Repainting panel, by request, el: \" + el + \" pending \" + pendingRepaintCount);\n            if (doLayout) {\n                relayout();", "refactored_code": "    private final long maxRepaintRequestWaitMs = 50;\n    public void repaintRequested(final boolean doLayout) {\n        final long now = System.currentTimeMillis();\n        final long el = now - lastRepaintRunAt;\n        if (!doLayout || el > maxRepaintRequestWaitMs || pendingRepaintCount > 5) {\n            XRLog.general(Level.FINE, \"*** Repainting panel, by request, el: \" + el + \" pending \" + pendingRepaintCount);\n            if (doLayout) {\n                relayout();"}
{"magic_number_smell": "\n    private static final long serialVersionUID = 1L;\n\n    private int scalePolicy = 0;\n    private double scale = -1.0d;\n    private final java.util.List<ScaleChangeListener> scListeners = new ArrayList<>();\n    /**", "refactored_code": "    public static final int SCALE_POLICY_NONE = 0;\n\n    private static final long serialVersionUID = 1L;\n\n    private int scalePolicy = SCALE_POLICY_NONE;\n    private double scale = -1.0d;\n    private final java.util.List<ScaleChangeListener> scListeners = new ArrayList<>();\n    /**"}
{"magic_number_smell": "    private static final int 500 = 500;\n    private static final int height = 500;\n\n    private void runTests(File dir, int 500, int height) throws Exception {\n        File[] files = dir.listFiles();\n        for (File file : files) {\n            if (file.isDirectory()) {", "refactored_code": "    private static final int width = 500;\n    private static final int width = 500;\n    private static final int height = 500;\n\n    private void runTests(File dir, int width, int height) throws Exception {\n        File[] files = dir.listFiles();\n        for (File file : files) {\n            if (file.isDirectory()) {"}
{"magic_number_smell": "\n    public ContentTypeDetectingInputStreamWrapper(InputStream source) throws IOException {\n        super(source);\n        byte[] MAGIC_BYTES=new byte[4];\n        mark(4);\n\n        try {", "refactored_code": "    protected static final int MAX_MAGIC_BYTES=4;\n\n    public ContentTypeDetectingInputStreamWrapper(InputStream source) throws IOException {\n        super(source);\n        byte[] MAGIC_BYTES=new byte[MAX_MAGIC_BYTES];\n        mark(MAX_MAGIC_BYTES);\n\n        try {"}
{"magic_number_smell": "    }\n\n    static final class GridGlassPane extends JPanel {\n        private static final long 1L = 1L;\n\n        private final Color mainUltraLightColor = new Color(128, 192, 255);\n        private final Color mainLightColor = new Color(0, 128, 255);", "refactored_code": "        private static final long serialVersionUID = 1L;\n    }\n\n    static final class GridGlassPane extends JPanel {\n        private static final long serialVersionUID = 1L;\n\n        private final Color mainUltraLightColor = new Color(128, 192, 255);\n        private final Color mainLightColor = new Color(0, 128, 255);"}
{"magic_number_smell": "        public final static double MIN_SCALE = 0.2;\n        JViewport jvp = null;\n        public final int 2 = 2;\n        public final int SCROLLBAR_WIDTH = 2 + ((Integer) UIManager.get(\"ScrollBar.width\")).intValue();\n\n        public FSPagePanel() {\n            super();", "refactored_code": "        public final int SCROLLBAR_BORDER = 2;\n        public final static double MIN_SCALE = 0.2;\n        JViewport jvp = null;\n        public final int SCROLLBAR_BORDER = 2;\n        public final int SCROLLBAR_WIDTH = SCROLLBAR_BORDER + ((Integer) UIManager.get(\"ScrollBar.width\")).intValue();\n\n        public FSPagePanel() {\n            super();"}
{"magic_number_smell": "    }\n\n    private void deferredChangePage(final int startAt) {\n        deferredLoadAndRender(startAt, 1);\n    }\n\n    private void deferredLoadAndRender(final int startAt, final int renderTo) {", "refactored_code": "    private static final int TO_SWING = 1;\n    }\n\n    private void deferredChangePage(final int startAt) {\n        deferredLoadAndRender(startAt, TO_SWING);\n    }\n\n    private void deferredLoadAndRender(final int startAt, final int renderTo) {"}
{"magic_number_smell": "     */\n    private final int 16 = 16;\n    private final Map<String, ImageResource> imageCache =\n            new LinkedHashMap<>(16, 0.75f, true) {\n                @Override\n                protected boolean removeEldestEntry(Map.Entry<String, ImageResource> eldest) {\n                    return size() > 16;", "refactored_code": "    private final int imageCacheCapacity = 16;\n     */\n    private final int imageCacheCapacity = 16;\n    private final Map<String, ImageResource> imageCache =\n            new LinkedHashMap<>(imageCacheCapacity, 0.75f, true) {\n                @Override\n                protected boolean removeEldestEntry(Map.Entry<String, ImageResource> eldest) {\n                    return size() > imageCacheCapacity;"}
{"magic_number_smell": "            case RESET:\n                root.panel.view.resetFontSize();\n                break;\n            case 0:\n                root.panel.view.decrementFontSize();\n                break;\n        }", "refactored_code": "    public static final int DECREMENT = 0;\n            case RESET:\n                root.panel.view.resetFontSize();\n                break;\n            case DECREMENT:\n                root.panel.view.decrementFontSize();\n                break;\n        }"}
{"magic_number_smell": "            if (cssHeight != -1) {\n                setWidth(cssHeight);\n            } else {\n                setWidth((int) (box.getStyle().getFont(c).size * 0.80f));\n            }\n        }\n", "refactored_code": "    private static final float FONT_SIZE_ADJUSTMENT = 0.80f;\n            if (cssHeight != -1) {\n                setWidth(cssHeight);\n            } else {\n                setWidth((int) (box.getStyle().getFont(c).size * FONT_SIZE_ADJUSTMENT));\n            }\n        }\n"}
{"magic_number_smell": "    private static final int SM_DARKER_OR_LIGHTER = 3;\n\n    private FontDescription findByWeight(List<FontDescription> matches, int desiredWeight, int searchMode) {\n        if (searchMode == 1) {\n            for (FontDescription description : matches) {\n                if (description.getWeight() == desiredWeight) {\n                    return description;", "refactored_code": "    private static final int SM_EXACT = 1;\n    private static final int SM_DARKER_OR_LIGHTER = 3;\n\n    private FontDescription findByWeight(List<FontDescription> matches, int desiredWeight, int searchMode) {\n        if (searchMode == SM_EXACT) {\n            for (FontDescription description : matches) {\n                if (description.getWeight() == desiredWeight) {\n                    return description;"}
{"magic_number_smell": "            name = element.getTextContent();\n        }\n        name = WS.matcher(name.trim()).replaceAll(\" \");\n        if (name.length() > 200) {\n            name = name.substring(0, 200);\n        }\n        return name;", "refactored_code": "    private static final int MAX_NAME_LENGTH = 200;\n            name = element.getTextContent();\n        }\n        name = WS.matcher(name.trim()).replaceAll(\" \");\n        if (name.length() > MAX_NAME_LENGTH) {\n            name = name.substring(0, MAX_NAME_LENGTH);\n        }\n        return name;"}
{"magic_number_smell": "\n    @Override\n    public void fill(Shape s) {\n        followPath(s, 1);\n    }\n\n    @Override", "refactored_code": "    private static final int FILL = 1;\n\n    @Override\n    public void fill(Shape s) {\n        followPath(s, FILL);\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public ITextRenderer() {\n        this(20f * 4f / 3f, DEFAULT_DOTS_PER_PIXEL);\n    }\n\n    public ITextRenderer(FontResolver fontResolver) {", "refactored_code": "    public static final float DEFAULT_DOTS_PER_POINT = 20f * 4f / 3f;\n    }\n\n    public ITextRenderer() {\n        this(DEFAULT_DOTS_PER_POINT, DEFAULT_DOTS_PER_PIXEL);\n    }\n\n    public ITextRenderer(FontResolver fontResolver) {"}
{"magic_number_smell": "    public int getWidth(FontContext context, FSFont font, String string) {\n        BaseFont bf = ((ITextFSFont)font).getFontDescription().getFont();\n        float result = bf.getWidthPoint(string, font.getSize2D());\n        if (result - Math.floor(result) < 0.01f) {\n            return (int)result;\n        } else {\n            return (int)Math.ceil(result);", "refactored_code": "    private static final float TEXT_MEASURING_DELTA = 0.01f;\n    public int getWidth(FontContext context, FSFont font, String string) {\n        BaseFont bf = ((ITextFSFont)font).getFontDescription().getFont();\n        float result = bf.getWidthPoint(string, font.getSize2D());\n        if (result - Math.floor(result) < TEXT_MEASURING_DELTA) {\n            return (int)result;\n        } else {\n            return (int)Math.ceil(result);"}
{"magic_number_smell": "    private final int dotsPerPixel;\n\n    public ITextUserAgent(ITextOutputDevice outputDevice, int dotsPerPixel) {\n        super(Configuration.valueAsInt(\"xr.image.cache-capacity\", 32));\n        _outputDevice = outputDevice;\n        this.dotsPerPixel = dotsPerPixel;\n    }", "refactored_code": "    private static final int IMAGE_CACHE_CAPACITY = 32;\n    private final int dotsPerPixel;\n\n    public ITextUserAgent(ITextOutputDevice outputDevice, int dotsPerPixel) {\n        super(Configuration.valueAsInt(\"xr.image.cache-capacity\", IMAGE_CACHE_CAPACITY));\n        _outputDevice = outputDevice;\n        this.dotsPerPixel = dotsPerPixel;\n    }"}
{"magic_number_smell": "            return c.getTextRenderer().getWidth(\n                    c.getFontContext(),\n                    box.getStyle().getFSFont(c),\n                    spaces(10));\n        } else {\n            int maxWidth = 0;\n            for (Option option : options) {", "refactored_code": "    private static final int EMPTY_SPACE_COUNT = 10;\n            return c.getTextRenderer().getWidth(\n                    c.getFontContext(),\n                    box.getStyle().getFSFont(c),\n                    spaces(EMPTY_SPACE_COUNT));\n        } else {\n            int maxWidth = 0;\n            for (Option option : options) {"}
{"magic_number_smell": "    String sSize = elem.getAttribute(\"size\");\n    if (Util.isNullOrEmpty(sSize))\n    {\n      return 15;\n    }\n    else\n    {", "refactored_code": "  private static final int DEFAULT_SIZE = 15;\n    String sSize = elem.getAttribute(\"size\");\n    if (Util.isNullOrEmpty(sSize))\n    {\n      return DEFAULT_SIZE;\n    }\n    else\n    {"}
{"magic_number_smell": "            if (cssHeight != -1) {\n                setWidth(cssHeight);\n            } else {\n                setWidth((int) (box.getStyle().getFont(c).size * 0.80f));\n            }\n        }\n", "refactored_code": "    private static final float FONT_SIZE_ADJUSTMENT = 0.80f;\n            if (cssHeight != -1) {\n                setWidth(cssHeight);\n            } else {\n                setWidth((int) (box.getStyle().getFont(c).size * FONT_SIZE_ADJUSTMENT));\n            }\n        }\n"}
{"magic_number_smell": "            name = element.getTextContent();\n        }\n        name = WS.matcher(name.trim()).replaceAll(\" \");\n        if (name.length() > 200) {\n            name = name.substring(0, 200);\n        }\n        return name;", "refactored_code": "    private static final int MAX_NAME_LENGTH = 200;\n            name = element.getTextContent();\n        }\n        name = WS.matcher(name.trim()).replaceAll(\" \");\n        if (name.length() > MAX_NAME_LENGTH) {\n            name = name.substring(0, MAX_NAME_LENGTH);\n        }\n        return name;"}
{"magic_number_smell": "        @Nullable\n        @CheckReturnValue\n        private FontDescription findByWeight(List<FontDescription> matches, int desiredWeight, int searchMode) {\n            if (searchMode == 1) {\n                for (FontDescription description : matches) {\n                    if (description.getWeight() == desiredWeight) {\n                        return description;", "refactored_code": "        private static final int SM_EXACT = 1;\n        @Nullable\n        @CheckReturnValue\n        private FontDescription findByWeight(List<FontDescription> matches, int desiredWeight, int searchMode) {\n            if (searchMode == SM_EXACT) {\n                for (FontDescription description : matches) {\n                    if (description.getWeight() == desiredWeight) {\n                        return description;"}
{"magic_number_smell": "\n    @Override\n    public void fill(Shape s) {\n        followPath(s, 1);\n    }\n\n    @Override", "refactored_code": "    private static final int FILL = 1;\n\n    @Override\n    public void fill(Shape s) {\n        followPath(s, FILL);\n    }\n\n    @Override"}
{"magic_number_smell": "    private PDFCreationListener _listener;\n\n    public ITextRenderer() {\n        this(20f * 4f / 3f, DEFAULT_DOTS_PER_PIXEL);\n    }\n\n    public ITextRenderer(float dotsPerPoint, int dotsPerPixel) {", "refactored_code": "    private static final float DEFAULT_DOTS_PER_POINT = 20f * 4f / 3f;\n    private PDFCreationListener _listener;\n\n    public ITextRenderer() {\n        this(DEFAULT_DOTS_PER_POINT, DEFAULT_DOTS_PER_PIXEL);\n    }\n\n    public ITextRenderer(float dotsPerPoint, int dotsPerPixel) {"}
{"magic_number_smell": "    public int getWidth(FontContext context, FSFont font, String string) {\n        BaseFont bf = ((ITextFSFont)font).getFontDescription().getFont();\n        float result = bf.getWidthPoint(string, font.getSize2D());\n        if (result - Math.floor(result) < 0.01f) {\n            return (int)result;\n        } else {\n            return (int)Math.ceil(result);", "refactored_code": "    private static final float TEXT_MEASURING_DELTA = 0.01f;\n    public int getWidth(FontContext context, FSFont font, String string) {\n        BaseFont bf = ((ITextFSFont)font).getFontDescription().getFont();\n        float result = bf.getWidthPoint(string, font.getSize2D());\n        if (result - Math.floor(result) < TEXT_MEASURING_DELTA) {\n            return (int)result;\n        } else {\n            return (int)Math.ceil(result);"}
{"magic_number_smell": "    private final int dotsPerPixel;\n\n    public ITextUserAgent(ITextOutputDevice outputDevice, int dotsPerPixel) {\n        super(Configuration.valueAsInt(\"xr.image.cache-capacity\", 32));\n        this.dotsPerPixel = dotsPerPixel;\n        _outputDevice = outputDevice;\n    }", "refactored_code": "    private static final int IMAGE_CACHE_CAPACITY = 32;\n    private final int dotsPerPixel;\n\n    public ITextUserAgent(ITextOutputDevice outputDevice, int dotsPerPixel) {\n        super(Configuration.valueAsInt(\"xr.image.cache-capacity\", IMAGE_CACHE_CAPACITY));\n        this.dotsPerPixel = dotsPerPixel;\n        _outputDevice = outputDevice;\n    }"}
{"magic_number_smell": "            return c.getTextRenderer().getWidth(\n                    c.getFontContext(),\n                    box.getStyle().getFSFont(c),\n                    spaces(10));\n        } else {\n            int maxWidth = 0;\n            for (Option option : options) {", "refactored_code": "    private static final int EMPTY_SPACE_COUNT = 10;\n            return c.getTextRenderer().getWidth(\n                    c.getFontContext(),\n                    box.getStyle().getFSFont(c),\n                    spaces(EMPTY_SPACE_COUNT));\n        } else {\n            int maxWidth = 0;\n            for (Option option : options) {"}
{"magic_number_smell": "  private int getSize(Element elem) {\n    String sSize = elem.getAttribute(\"size\");\n    if (Util.isNullOrEmpty(sSize)) {\n      return 15;\n    }\n    else {\n      try {", "refactored_code": "  private static final int DEFAULT_SIZE = 15;\n  private int getSize(Element elem) {\n    String sSize = elem.getAttribute(\"size\");\n    if (Util.isNullOrEmpty(sSize)) {\n      return DEFAULT_SIZE;\n    }\n    else {\n      try {"}
{"magic_number_smell": "            rootLayer.trimEmptyPages(intrinsic_size.height);\n            if (rootLayer.getLastPage() != null) {\n                rootLayer.assignPagePaintingPositions(_layout_context, Layer.PAGED_MODE_SCREEN,\n                        10);\n                _drawnSize = new Point(rootLayer.getMaxPageWidth(_layout_context,\n                        10), rootLayer.getLastPage().getPaintingBottom()\n                        + 10);", "refactored_code": "    private static final int PAGE_PAINTING_CLEARANCE = 10;\n            rootLayer.trimEmptyPages(intrinsic_size.height);\n            if (rootLayer.getLastPage() != null) {\n                rootLayer.assignPagePaintingPositions(_layout_context, Layer.PAGED_MODE_SCREEN,\n                        PAGE_PAINTING_CLEARANCE);\n                _drawnSize = new Point(rootLayer.getMaxPageWidth(_layout_context,\n                        PAGE_PAINTING_CLEARANCE), rootLayer.getLastPage().getPaintingBottom()\n                        + PAGE_PAINTING_CLEARANCE);"}
{"magic_number_smell": "     * an LRU cache\n     */\n    private final int 16 = 16;\n    private final Map<String, ImageResource> _imageCache = new LinkedHashMap<>(16, 0.75f, true);\n\n    private String _baseURL;\n", "refactored_code": "    private final int _imageCacheCapacity = 16;\n     * an LRU cache\n     */\n    private final int _imageCacheCapacity = 16;\n    private final Map<String, ImageResource> _imageCache = new LinkedHashMap<>(_imageCacheCapacity, 0.75f, true);\n\n    private String _baseURL;\n"}
{"magic_number_smell": "                            layout();\n                        }\n                    });\n                    wait(5000);\n                } catch (InterruptedException e) {\n                    break;\n                }", "refactored_code": "    private static final int REFRESH_INTERVAL = 5000;\n                            layout();\n                        }\n                    });\n                    wait(REFRESH_INTERVAL);\n                } catch (InterruptedException e) {\n                    break;\n                }"}
{"magic_number_smell": "     */\n    public @NonNull GHCheckRun create() throws IOException {\n        List<Annotation> extraAnnotations;\n        if (output != null && output.annotations != null && output.annotations.size() > 50) {\n            extraAnnotations = output.annotations.subList(50, output.annotations.size());\n            output.annotations = output.annotations.subList(0, 50);\n        } else {", "refactored_code": "    private static final int MAX_ANNOTATIONS = 50;\n     */\n    public @NonNull GHCheckRun create() throws IOException {\n        List<Annotation> extraAnnotations;\n        if (output != null && output.annotations != null && output.annotations.size() > MAX_ANNOTATIONS) {\n            extraAnnotations = output.annotations.subList(MAX_ANNOTATIONS, output.annotations.size());\n            output.annotations = output.annotations.subList(0, MAX_ANNOTATIONS);\n        } else {"}
{"magic_number_smell": "\n        Iterator<GHCommit.File[]> pageIterator;\n\n        if (files != null && files.length < 300) {\n            // create a page iterator that only provides one page\n            pageIterator = Collections.singleton(files).iterator();\n        } else {", "refactored_code": "    private static final int GH_FILE_LIMIT_PER_COMMIT_PAGE = 300;\n\n        Iterator<GHCommit.File[]> pageIterator;\n\n        if (files != null && files.length < GH_FILE_LIMIT_PER_COMMIT_PAGE) {\n            // create a page iterator that only provides one page\n            pageIterator = Collections.singleton(files).iterator();\n        } else {"}
{"magic_number_smell": "         *\n         * @see GHRateLimit#getMergedRateLimit(GHRateLimit)\n         */\n        static long unknownLimitResetSeconds = Duration.ofSeconds(30).getSeconds();\n\n        /** The Constant unknownLimit. */\n        static final int unknownLimit = 1000000;", "refactored_code": "        private static final long defaultUnknownLimitResetSeconds = Duration.ofSeconds(30).getSeconds();\n         *\n         * @see GHRateLimit#getMergedRateLimit(GHRateLimit)\n         */\n        static long unknownLimitResetSeconds = defaultUnknownLimitResetSeconds;\n\n        /** The Constant unknownLimit. */\n        static final int unknownLimit = 1000000;"}
{"magic_number_smell": "        PagedIterable<GHRepositoryStatistics.ContributorStats> stats = getContributorStatsImpl();\n\n        if (stats == null && waitTillReady) {\n            for (int i = 0; i < 3; i += 1) {\n                // Wait a few seconds and try again.\n                Thread.sleep(WAIT_SLEEP_INTERVAL);\n                stats = getContributorStatsImpl();", "refactored_code": "    private static final int MAX_WAIT_ITERATIONS = 3;\n        PagedIterable<GHRepositoryStatistics.ContributorStats> stats = getContributorStatsImpl();\n\n        if (stats == null && waitTillReady) {\n            for (int i = 0; i < MAX_WAIT_ITERATIONS; i += 1) {\n                // Wait a few seconds and try again.\n                Thread.sleep(WAIT_SLEEP_INTERVAL);\n                stats = getContributorStatsImpl();"}
{"magic_number_smell": "            throws IOException {\n        // WARNING: This is an unsupported environment variable.\n        // The GitHubClient class is internal and may change at any time.\n        int retryCount = Math.max(2,\n                Integer.getInteger(GitHubClient.class.getName() + \".retryCount\", 2));\n\n        int retries = retryCount;", "refactored_code": "    private static final int DEFAULT_CONNECTION_ERROR_RETRIES = 2;\n            throws IOException {\n        // WARNING: This is an unsupported environment variable.\n        // The GitHubClient class is internal and may change at any time.\n        int retryCount = Math.max(DEFAULT_CONNECTION_ERROR_RETRIES,\n                Integer.getInteger(GitHubClient.class.getName() + \".retryCount\", DEFAULT_CONNECTION_ERROR_RETRIES));\n\n        int retries = retryCount;"}
{"magic_number_smell": "    }\n\n    public static abstract class PushConfig extends AbstractDescribableImpl<PushConfig> implements Serializable {\n        private static final long 1L = 1L;\n        \n        private String targetRepoName;\n", "refactored_code": "    private static final long serialVersionUID = 1L;\n    }\n\n    public static abstract class PushConfig extends AbstractDescribableImpl<PushConfig> implements Serializable {\n        private static final long serialVersionUID = 1L;\n        \n        private String targetRepoName;\n"}
{"magic_number_smell": "     */\n    String determineSwitchOnSize(Long sizeOfRepo, GitTool tool) {\n        if (sizeOfRepo != 0L) {\n            if (sizeOfRepo < 5000) {\n                if (!JGIT_SUPPORTED) {\n                    return \"NONE\";\n                }", "refactored_code": "    private static final int SIZE_TO_SWITCH = 5000;\n     */\n    String determineSwitchOnSize(Long sizeOfRepo, GitTool tool) {\n        if (sizeOfRepo != 0L) {\n            if (sizeOfRepo < SIZE_TO_SWITCH) {\n                if (!JGIT_SUPPORTED) {\n                    return \"NONE\";\n                }"}
{"magic_number_smell": "    @Test\n    public void timestampInRange() {\n        long timestamp = changeSet.getTimestamp();\n        assertThat(timestamp, is(greaterThanOrEqualTo(1198029565000L)));\n        assertThat(timestamp, is(lessThan(NOW)));\n    }\n}", "refactored_code": "    private static final long FIRST_COMMIT_TIMESTAMP = 1198029565000L;\n    @Test\n    public void timestampInRange() {\n        long timestamp = changeSet.getTimestamp();\n        assertThat(timestamp, is(greaterThanOrEqualTo(FIRST_COMMIT_TIMESTAMP)));\n        assertThat(timestamp, is(lessThan(NOW)));\n    }\n}"}
{"magic_number_smell": "            // Run all tests when not in CI environment\n            return true;\n        }\n        return stopwatch.runtime(SECONDS) <= 180;\n    }\n\n    private void addChangelogToBranchExtension(GitSCM scm) {", "refactored_code": "    private static final int MAX_SECONDS_FOR_THESE_TESTS = 180;\n            // Run all tests when not in CI environment\n            return true;\n        }\n        return stopwatch.runtime(SECONDS) <= MAX_SECONDS_FOR_THESE_TESTS;\n    }\n\n    private void addChangelogToBranchExtension(GitSCM scm) {"}
{"magic_number_smell": "            // Run all tests when not in CI environment\n            return true;\n        }\n        return stopwatch.runtime(SECONDS) <= 570;\n    }\n\n    @BeforeClass", "refactored_code": "    private static final int MAX_SECONDS_FOR_THESE_TESTS = 570;\n            // Run all tests when not in CI environment\n            return true;\n        }\n        return stopwatch.runtime(SECONDS) <= MAX_SECONDS_FOR_THESE_TESTS;\n    }\n\n    @BeforeClass"}
{"magic_number_smell": "            // Run all tests when not in CI environment\n            return true;\n        }\n        return stopwatch.runtime(SECONDS) <= 120;\n    }\n\n    @Rule", "refactored_code": "    private static final int MAX_SECONDS_FOR_THESE_TESTS = 120;\n            // Run all tests when not in CI environment\n            return true;\n        }\n        return stopwatch.runtime(SECONDS) <= MAX_SECONDS_FOR_THESE_TESTS;\n    }\n\n    @Rule"}
{"magic_number_smell": "\n    @Before\n    public void setUp() {\n        option = new CheckoutOption(10);\n    }\n\n    @Test", "refactored_code": "    private static final int INITIAL_TIMEOUT = 10;\n\n    @Before\n    public void setUp() {\n        option = new CheckoutOption(INITIAL_TIMEOUT);\n    }\n\n    @Test"}
{"magic_number_smell": "    private final Result BUILD_RESULT = Result.NOT_BUILT;\n\n    /* A build with no revision */\n    private final Build nullRevisionBuild = new Build(null, 1, BUILD_RESULT);\n\n    /* A build of revision that has marked the same revision */\n    private final ObjectId objectId = ObjectId.fromString(\"b04752abaaa9ee3112b0c9d1910093c977d4e583\");", "refactored_code": "    private final int BUILD_NUMBER = 1;\n    private final Result BUILD_RESULT = Result.NOT_BUILT;\n\n    /* A build with no revision */\n    private final Build nullRevisionBuild = new Build(null, BUILD_NUMBER, BUILD_RESULT);\n\n    /* A build of revision that has marked the same revision */\n    private final ObjectId objectId = ObjectId.fromString(\"b04752abaaa9ee3112b0c9d1910093c977d4e583\");"}
{"magic_number_smell": "            // Run all tests when not in CI environment\n            return true;\n        }\n        return stopwatch.runtime(SECONDS) <= 210;\n    }\n\n    // TODO AbstractGitSCMSourceRetrieveHeadsTest *sounds* like it would be the right place, but it does not in fact retrieve any heads!", "refactored_code": "    private static final int MAX_SECONDS_FOR_THESE_TESTS = 210;\n            // Run all tests when not in CI environment\n            return true;\n        }\n        return stopwatch.runtime(SECONDS) <= MAX_SECONDS_FOR_THESE_TESTS;\n    }\n\n    // TODO AbstractGitSCMSourceRetrieveHeadsTest *sounds* like it would be the right place, but it does not in fact retrieve any heads!"}
{"magic_number_smell": "            // Run all tests when not in CI environment\n            return true;\n        }\n        return stopwatch.runtime(SECONDS) <= 200;\n    }\n\n    @Test", "refactored_code": "    private static final int MAX_SECONDS_FOR_THESE_TESTS = 200;\n            // Run all tests when not in CI environment\n            return true;\n        }\n        return stopwatch.runtime(SECONDS) <= MAX_SECONDS_FOR_THESE_TESTS;\n    }\n\n    @Test"}
{"magic_number_smell": "            // Run all tests when not in CI environment\n            return true;\n        }\n        return stopwatch.runtime(SECONDS) <= 150;\n    }\n\n    /*", "refactored_code": "    private static final int MAX_SECONDS_FOR_THESE_TESTS = 150;\n            // Run all tests when not in CI environment\n            return true;\n        }\n        return stopwatch.runtime(SECONDS) <= MAX_SECONDS_FOR_THESE_TESTS;\n    }\n\n    /*"}
{"magic_number_smell": "            // Run all tests when not in CI environment\n            return true;\n        }\n        return stopwatch.runtime(SECONDS) <= 200;\n    }\n\n    private final String username;", "refactored_code": "    private static final int MAX_SECONDS_FOR_THESE_TESTS = 200;\n            // Run all tests when not in CI environment\n            return true;\n        }\n        return stopwatch.runtime(SECONDS) <= MAX_SECONDS_FOR_THESE_TESTS;\n    }\n\n    private final String username;"}
{"magic_number_smell": "    private static final long new Random().nextLong() = new Random().nextLong();\n    @Override\n    public Ordering create(Ordering.Context context) {\n        return Ordering.shuffledBy(new Random(new Random().nextLong()));\n    }\n}\n", "refactored_code": "    private static final long SEED = new Random().nextLong();\n    private static final long SEED = new Random().nextLong();\n    @Override\n    public Ordering create(Ordering.Context context) {\n        return Ordering.shuffledBy(new Random(SEED));\n    }\n}\n"}
{"magic_number_smell": "\n    /**\n     * Initializes a SOAP Envelope. The version parameter must be set to one of\n     * 100, VER11 or VER12\n     */\n    public SoapEnvelope(int version) {\n        this.version = version;", "refactored_code": "    public static final int VER10 = 100;\n\n    /**\n     * Initializes a SOAP Envelope. The version parameter must be set to one of\n     * VER10, VER11 or VER12\n     */\n    public SoapEnvelope(int version) {\n        this.version = version;"}
{"magic_number_smell": "            multiRef.addElement(bodyOut);\n            Object[] qName = getInfo(null, bodyOut);\n            \n            writer.startTag((dotNet) ? \"\" : (String) qName[QNAME_NAMESPACE], (String) qName[1]);\n            \n                if (dotNet) {\n                    writer.attribute(null, \"xmlns\", (String) qName[QNAME_NAMESPACE]);", "refactored_code": "    protected static final int QNAME_TYPE = 1;\n            multiRef.addElement(bodyOut);\n            Object[] qName = getInfo(null, bodyOut);\n            \n            writer.startTag((dotNet) ? \"\" : (String) qName[QNAME_NAMESPACE], (String) qName[QNAME_TYPE]);\n            \n                if (dotNet) {\n                    writer.attribute(null, \"xmlns\", (String) qName[QNAME_NAMESPACE]);"}
{"magic_number_smell": "\n            for (int i = 0; i < array.getPropertyCount(); i++) {\n                SoapObject obj = (SoapObject) array.getProperty(i);\n                String name = obj.getPropertyAsString(0).toLowerCase();\n                // String ext = obj.getPropertyAsString(IMAGE_EXTENSION).toLowerCase();\n            }\n        } catch (Exception exception) {", "refactored_code": "    private static final int IMAGE_NAME = 0;\n\n            for (int i = 0; i < array.getPropertyCount(); i++) {\n                SoapObject obj = (SoapObject) array.getProperty(i);\n                String name = obj.getPropertyAsString(IMAGE_NAME).toLowerCase();\n                // String ext = obj.getPropertyAsString(IMAGE_EXTENSION).toLowerCase();\n            }\n        } catch (Exception exception) {"}
{"magic_number_smell": "    public static class Builder {\n        private final HttpUrl url;\n        private Proxy proxy = null;\n        private int timeout = 20000;\n        private String userAgent = null;\n        private Headers headers = null;\n        private OkHttpClient client = null;", "refactored_code": "    public static final int DEFAULT_TIMEOUT = 20000;\n    public static class Builder {\n        private final HttpUrl url;\n        private Proxy proxy = null;\n        private int timeout = DEFAULT_TIMEOUT;\n        private String userAgent = null;\n        private Headers headers = null;\n        private OkHttpClient client = null;"}
{"magic_number_smell": "\t}\n\n\tpublic static byte[] decodeBase64(Reader rdr) throws IOException {\n\t\treturn decodeBase64(rdr, 65000);\n\t}\n\n\tpublic static byte[] decodeBase64(Reader rdr, int maxLength) throws IOException {", "refactored_code": "\tprivate static final int\t\tDEFAULT_MAX_INPUT_LENGTH\t= 65000;\n\t}\n\n\tpublic static byte[] decodeBase64(Reader rdr) throws IOException {\n\t\treturn decodeBase64(rdr, DEFAULT_MAX_INPUT_LENGTH);\n\t}\n\n\tpublic static byte[] decodeBase64(Reader rdr, int maxLength) throws IOException {"}
{"magic_number_smell": "\tfinal static EnvironmentCalculator\t\t\t\t\thc\t\t\t\t\t\t= new EnvironmentCalculator();\n\tprivate static final Pattern\t\t\t\t\t\tWINDOWS_MACROS\t\t\t= Pattern.compile(\"%(?<key>[^%]+)%\");\n\tprivate static final int\t\t\t\t\t\t\tIOConstants.PAGE_SIZE * 16\t\t\t\t= IOConstants.PAGE_SIZE * 16;\n\tprivate static final int\t\t\t\t\t\t\tDIRECT_MAP_THRESHOLD\t= IOConstants.PAGE_SIZE * 16;\n\tstatic final public File\t\t\t\t\t\t\twork\t\t\t\t\t= new File(\n\t\tSystem.getProperty(\"user.dir\"));\n\tstatic final public File\t\t\t\t\t\t\thome;", "refactored_code": "\tprivate static final int\t\t\t\t\t\t\tBUFFER_SIZE\t\t\t\t= IOConstants.PAGE_SIZE * 16;\n\tfinal static EnvironmentCalculator\t\t\t\t\thc\t\t\t\t\t\t= new EnvironmentCalculator();\n\tprivate static final Pattern\t\t\t\t\t\tWINDOWS_MACROS\t\t\t= Pattern.compile(\"%(?<key>[^%]+)%\");\n\tprivate static final int\t\t\t\t\t\t\tBUFFER_SIZE\t\t\t\t= IOConstants.PAGE_SIZE * 16;\n\tprivate static final int\t\t\t\t\t\t\tDIRECT_MAP_THRESHOLD\t= BUFFER_SIZE;\n\tstatic final public File\t\t\t\t\t\t\twork\t\t\t\t\t= new File(\n\t\tSystem.getProperty(\"user.dir\"));\n\tstatic final public File\t\t\t\t\t\t\thome;"}
{"magic_number_smell": "\t */\n\tprivate static int write(OutputStream out, int width, byte[] bytes) throws IOException {\n\t\tfor (int position = 0, limit = bytes.length, remaining; (remaining = limit - position) > 0;) {\n\t\t\tif (width >= 72 - EOL.length) {\n\t\t\t\tout.write(EOL);\n\t\t\t\tout.write(' ');\n\t\t\t\twidth = 1;", "refactored_code": "\tprivate static final int\t\t\t\tMAX_LENGTH\t\t= 72 - EOL.length;\n\t */\n\tprivate static int write(OutputStream out, int width, byte[] bytes) throws IOException {\n\t\tfor (int position = 0, limit = bytes.length, remaining; (remaining = limit - position) > 0;) {\n\t\t\tif (width >= MAX_LENGTH) {\n\t\t\t\tout.write(EOL);\n\t\t\t\tout.write(' ');\n\t\t\t\twidth = 1;"}
{"magic_number_smell": "\tprivate final static SecureRandom\tsecureRandom\t\t\t= new SecureRandom();\n\n\tpublic static byte[] encrypt(final byte[] payload, final String passPhrase) throws Exception {\n\t\tbyte[] salt = new byte[8];\n\t\tsecureRandom.nextBytes(salt);\n\t\tCipher cipher = createCipher(passPhrase, salt, Cipher.ENCRYPT_MODE);\n\t\tbyte[] encryptedBytes = cipher.doFinal(payload);", "refactored_code": "\tprivate static final int\t\t\tSALT_SIZE\t\t\t\t= 8;\n\tprivate final static SecureRandom\tsecureRandom\t\t\t= new SecureRandom();\n\n\tpublic static byte[] encrypt(final byte[] payload, final String passPhrase) throws Exception {\n\t\tbyte[] salt = new byte[SALT_SIZE];\n\t\tsecureRandom.nextBytes(salt);\n\t\tCipher cipher = createCipher(passPhrase, salt, Cipher.ENCRYPT_MODE);\n\t\tbyte[] encryptedBytes = cipher.doFinal(payload);"}
{"magic_number_smell": "\t * Add a ZIP extra field from a String.\n\t * <p>\n\t * The String is UTF-8 encoded and the extra field uses the Header ID\n\t * {@link #0xBDEA}.\n\t *\n\t * @param extra The extra field to modify by adding or replacing the\n\t *            {@link #0xBDEA} header. May be {@code null}.", "refactored_code": "\tpublic static final int EXTID_BND = 0xBDEA;\n\t * Add a ZIP extra field from a String.\n\t * <p>\n\t * The String is UTF-8 encoded and the extra field uses the Header ID\n\t * {@link #EXTID_BND}.\n\t *\n\t * @param extra The extra field to modify by adding or replacing the\n\t *            {@link #EXTID_BND} header. May be {@code null}."}
{"magic_number_smell": "\n\tstatic public class MapBuilder extends LinkedHashMap<String, Object> {\n\n\t\tprivate static final long 1L = 1L;\n\n\t\tpublic MapBuilder set(String key, Object value) {\n\t\t\tthis.put(key, value);", "refactored_code": "\t\tprivate static final long serialVersionUID = 1L;\n\n\tstatic public class MapBuilder extends LinkedHashMap<String, Object> {\n\n\t\tprivate static final long serialVersionUID = 1L;\n\n\t\tpublic MapBuilder set(String key, Object value) {\n\t\t\tthis.put(key, value);"}
{"magic_number_smell": "\t\tif (entry instanceof Info info) {\n\t\t\treturn info.tag();\n\t\t} else if (entry instanceof String) {\n\t\t\treturn 1;\n\t\t} else if (entry instanceof Integer) {\n\t\t\treturn CONSTANT_Integer;\n\t\t} else if (entry instanceof Long) {", "refactored_code": "\tpublic static final int\tCONSTANT_Utf8\t\t\t\t= 1;\n\t\tif (entry instanceof Info info) {\n\t\t\treturn info.tag();\n\t\t} else if (entry instanceof String) {\n\t\t\treturn CONSTANT_Utf8;\n\t\t} else if (entry instanceof Integer) {\n\t\t\treturn CONSTANT_Integer;\n\t\t} else if (entry instanceof Long) {"}
{"magic_number_smell": "\n\t\t@Override\n\t\tpublic int type() {\n\t\t\treturn 63;\n\t\t}\n\t}\n", "refactored_code": "\t\tpublic static final int\tSAME\t\t\t\t\t\t\t\t= 63;\n\n\t\t@Override\n\t\tpublic int type() {\n\t\t\treturn SAME;\n\t\t}\n\t}\n"}
{"magic_number_smell": "\t\t\t\t\t\t// constructed object\n\t\t\tcase 0x15 : // receiver type of method or constructor\n\t\t\t\ttarget_info = new byte[0];\n\t\t\t\ttarget_index = -1;\n\t\t\t\tbreak;\n\n\t\t\tcase 0x16 : // type in formal parameter declaration of method,", "refactored_code": "\tpublic static final int\tTYPEUSE_INDEX_NONE\t\t\t\t= -1;\n\t\t\t\t\t\t// constructed object\n\t\t\tcase 0x15 : // receiver type of method or constructor\n\t\t\t\ttarget_info = new byte[0];\n\t\t\t\ttarget_index = TYPEUSE_INDEX_NONE;\n\t\t\t\tbreak;\n\n\t\t\tcase 0x16 : // type in formal parameter declaration of method,"}
{"magic_number_smell": "\t}\n\n\tprivate static final class SerializationProxy implements Serializable {\n\t\tprivate static final long\t1L\t= 1L;\n\t\tprivate transient Object[]\tdata;\n\n\t\tSerializationProxy(ImmutableList<?> list) {", "refactored_code": "\tprivate static final long serialVersionUID = 1L;\n\t}\n\n\tprivate static final class SerializationProxy implements Serializable {\n\t\tprivate static final long\tserialVersionUID\t= 1L;\n\t\tprivate transient Object[]\tdata;\n\n\t\tSerializationProxy(ImmutableList<?> list) {"}
{"magic_number_smell": "\t}\n\n\tprivate static final class SerializationProxy implements Serializable {\n\t\tprivate static final long\t1L\t= 1L;\n\t\tprivate transient Object[]\tdata;\n\n\t\tSerializationProxy(ImmutableMap<?, ?> map) {", "refactored_code": "\tprivate static final long serialVersionUID = 1L;\n\t}\n\n\tprivate static final class SerializationProxy implements Serializable {\n\t\tprivate static final long\tserialVersionUID\t= 1L;\n\t\tprivate transient Object[]\tdata;\n\n\t\tSerializationProxy(ImmutableMap<?, ?> map) {"}
{"magic_number_smell": "\t}\n\n\tprivate static final class SerializationProxy implements Serializable {\n\t\tprivate static final long\t1L\t= 1L;\n\t\tprivate transient Object[]\tdata;\n\n\t\tSerializationProxy(ImmutableSet<?> set) {", "refactored_code": "\tprivate static final long serialVersionUID = 1L;\n\t}\n\n\tprivate static final class SerializationProxy implements Serializable {\n\t\tprivate static final long\tserialVersionUID\t= 1L;\n\t\tprivate transient Object[]\tdata;\n\n\t\tSerializationProxy(ImmutableSet<?> set) {"}
{"magic_number_smell": "\t\t\tClassFile clazz = ClassFile.parseClassFile(new DataInputStream(stream));\n\t\t\tassertThat(clazz.this_class).isEqualTo(\"Expr\");\n\t\t\tassertThat(clazz.super_class).isEqualTo(\"java/lang/Object\");\n\t\t\tassertThat(clazz.major_version).isGreaterThanOrEqualTo(61);\n\n\t\t\tassertPermittedSubclasses(clazz).containsExactlyInAnyOrder(\"ConstantExpr\", \"PlusExpr\", \"TimesExpr\",\n\t\t\t\t\"NegExpr\", \"OtherExpr\", \"SubExpr\");", "refactored_code": "\tprivate static final int MAJOR_JAVA_17 = 61;\n\t\t\tClassFile clazz = ClassFile.parseClassFile(new DataInputStream(stream));\n\t\t\tassertThat(clazz.this_class).isEqualTo(\"Expr\");\n\t\t\tassertThat(clazz.super_class).isEqualTo(\"java/lang/Object\");\n\t\t\tassertThat(clazz.major_version).isGreaterThanOrEqualTo(MAJOR_JAVA_17);\n\n\t\t\tassertPermittedSubclasses(clazz).containsExactlyInAnyOrder(\"ConstantExpr\", \"PlusExpr\", \"TimesExpr\",\n\t\t\t\t\"NegExpr\", \"OtherExpr\", \"SubExpr\");"}
{"magic_number_smell": "\t\t\tClassFile clazz = ClassFile.parseClassFile(new DataInputStream(stream));\n\t\t\tassertThat(clazz.this_class).isEqualTo(\"MinMax\");\n\t\t\tassertThat(clazz.super_class).isEqualTo(\"java/lang/Record\");\n\t\t\tassertThat(clazz.major_version).isGreaterThanOrEqualTo(60);\n\n\t\t\tRecordAttribute recordAttribute = Arrays.stream(clazz.attributes)\n\t\t\t\t.filter(RecordAttribute.class::isInstance)", "refactored_code": "\tprivate static final int MAJOR_JAVA_16 = 60;\n\t\t\tClassFile clazz = ClassFile.parseClassFile(new DataInputStream(stream));\n\t\t\tassertThat(clazz.this_class).isEqualTo(\"MinMax\");\n\t\t\tassertThat(clazz.super_class).isEqualTo(\"java/lang/Record\");\n\t\t\tassertThat(clazz.major_version).isGreaterThanOrEqualTo(MAJOR_JAVA_16);\n\n\t\t\tRecordAttribute recordAttribute = Arrays.stream(clazz.attributes)\n\t\t\t\t.filter(RecordAttribute.class::isInstance)"}
{"magic_number_smell": "\t}\n\n\tpublic <T> T readLocked(Callable<T> callable, BooleanSupplier canceled) throws Exception {\n\t\treturn workspaceLock.locked(workspaceLock.readLock(), 120_000L, callable, canceled);\n\t}\n\n\tpublic <T> T readLocked(Callable<T> callable, long timeoutInMs) throws Exception {", "refactored_code": "\tprivate static final long\t\tWORKSPACE_LOCK_DEFAULT_TIMEOUTMS\t= 120_000L;\n\t}\n\n\tpublic <T> T readLocked(Callable<T> callable, BooleanSupplier canceled) throws Exception {\n\t\treturn workspaceLock.locked(workspaceLock.readLock(), WORKSPACE_LOCK_DEFAULT_TIMEOUTMS, callable, canceled);\n\t}\n\n\tpublic <T> T readLocked(Callable<T> callable, long timeoutInMs) throws Exception {"}
{"magic_number_smell": "\t */\n\tprivate void copyPackage(Jar dest, List<Jar> providers, String path, int splitStrategy) {\n\t\tswitch (splitStrategy) {\n\t\t\tcase 1 :\n\t\t\t\tfor (Jar srce : providers) {\n\t\t\t\t\tcopy(dest, srce, path, true);\n\t\t\t\t}", "refactored_code": "\tprivate static final int\t\t\tSPLIT_MERGE_LAST\t\t\t= 1;\n\t */\n\tprivate void copyPackage(Jar dest, List<Jar> providers, String path, int splitStrategy) {\n\t\tswitch (splitStrategy) {\n\t\t\tcase SPLIT_MERGE_LAST :\n\t\t\t\tfor (Jar srce : providers) {\n\t\t\t\t\tcopy(dest, srce, path, true);\n\t\t\t\t}"}
{"magic_number_smell": "\t\tif (buffer != null) {\n\t\t\treturn buffer.duplicate();\n\t\t}\n\t\tif (IO.isWindows() && (size > IOConstants.PAGE_SIZE * 16)) {\n\t\t\treturn null;\n\t\t}\n\t\treturn (buffer = IO.read(file)).duplicate();", "refactored_code": "\tprivate static final int\t\tTHRESHOLD\t= IOConstants.PAGE_SIZE * 16;\n\t\tif (buffer != null) {\n\t\t\treturn buffer.duplicate();\n\t\t}\n\t\tif (IO.isWindows() && (size > THRESHOLD)) {\n\t\t\treturn null;\n\t\t}\n\t\treturn (buffer = IO.read(file)).duplicate();"}
{"magic_number_smell": "\tstatic final class ZipResourceSpliterator extends AbstractSpliterator<Resource> implements Runnable {\n\t\tprivate final ZipInputStream\t\t\tjin;\n\t\tprivate final Predicate<String>\t\t\tfilter;\n\t\tprivate final ByteBufferOutputStream\tbbos\t= new ByteBufferOutputStream(IOConstants.PAGE_SIZE * 16);\n\n\t\tZipResourceSpliterator(Resource resource, Predicate<String> filter) throws Exception {\n\t\t\tsuper(Long.MAX_VALUE, Spliterator.DISTINCT | Spliterator.ORDERED | Spliterator.NONNULL);", "refactored_code": "\tprivate static final int\tBUFFER_SIZE\t\t\t\t= IOConstants.PAGE_SIZE * 16;\n\tstatic final class ZipResourceSpliterator extends AbstractSpliterator<Resource> implements Runnable {\n\t\tprivate final ZipInputStream\t\t\tjin;\n\t\tprivate final Predicate<String>\t\t\tfilter;\n\t\tprivate final ByteBufferOutputStream\tbbos\t= new ByteBufferOutputStream(BUFFER_SIZE);\n\n\t\tZipResourceSpliterator(Resource resource, Predicate<String> filter) throws Exception {\n\t\t\tsuper(Long.MAX_VALUE, Spliterator.DISTINCT | Spliterator.ORDERED | Spliterator.NONNULL);"}
{"magic_number_smell": "\n\t\tsynchronized (failures) {\n\t\t\tLong l = failures.get(rds.url);\n\t\t\tif (l != null && (System.currentTimeMillis() - l) < 4 * 3600 * 1000) {\n\t\t\t\tlogger.debug(\"descriptor {}, had earlier failure not retrying\", Hex.toHexString(rd));\n\t\t\t\treturn null;\n\t\t\t}", "refactored_code": "\tprivate static final long\t\t\t\t\t\tTHRESHOLD\t\t\t\t\t\t= 4 * 3600 * 1000;\t\t\t\t\t// 4\n\n\t\tsynchronized (failures) {\n\t\t\tLong l = failures.get(rds.url);\n\t\t\tif (l != null && (System.currentTimeMillis() - l) < THRESHOLD) {\n\t\t\t\tlogger.debug(\"descriptor {}, had earlier failure not retrying\", Hex.toHexString(rd));\n\t\t\t\treturn null;\n\t\t\t}"}
{"magic_number_smell": "\tprivate static Item parseItem(boolean isDigit, String buf) {\n\t\tif (isDigit) {\n\t\t\tbuf = stripLeadingZeroes(buf);\n\t\t\tif (buf.length() <= 9) {\n\t\t\t\t// lower than 2^31\n\t\t\t\treturn new IntItem(buf);\n\t\t\t} else if (buf.length() <= MAX_LONGITEM_LENGTH) {", "refactored_code": "\tprivate static final int\tMAX_INTITEM_LENGTH\t= 9;\n\tprivate static Item parseItem(boolean isDigit, String buf) {\n\t\tif (isDigit) {\n\t\t\tbuf = stripLeadingZeroes(buf);\n\t\t\tif (buf.length() <= MAX_INTITEM_LENGTH) {\n\t\t\t\t// lower than 2^31\n\t\t\t\treturn new IntItem(buf);\n\t\t\t} else if (buf.length() <= MAX_LONGITEM_LENGTH) {"}
{"magic_number_smell": "\tpublic static final int\t\t\t\t\t999999999\t\t\t= 999999999;\n\n\tprivate static final String\t\t\t\tLATEST_POSTFIX\t\t= \"-\" + Constants.VERSION_ATTR_LATEST + \".jar\";\n\tpublic static final Version\t\t\t\tLATEST_VERSION\t\t= new Version(999999999, 0, 0);\n\tprivate static final SortedSet<Version>\tLATEST_SET\t\t\t= new TreeSet<>(Collections.singleton(LATEST_VERSION));\n\n\tfinal static JSONCodec\t\t\t\t\tcodec\t\t\t\t= new JSONCodec();", "refactored_code": "\tpublic static final int\t\t\t\t\tMAX_MAJOR\t\t\t= 999999999;\n\tpublic static final int\t\t\t\t\tMAX_MAJOR\t\t\t= 999999999;\n\n\tprivate static final String\t\t\t\tLATEST_POSTFIX\t\t= \"-\" + Constants.VERSION_ATTR_LATEST + \".jar\";\n\tpublic static final Version\t\t\t\tLATEST_VERSION\t\t= new Version(MAX_MAJOR, 0, 0);\n\tprivate static final SortedSet<Version>\tLATEST_SET\t\t\t= new TreeSet<>(Collections.singleton(LATEST_VERSION));\n\n\tfinal static JSONCodec\t\t\t\t\tcodec\t\t\t\t= new JSONCodec();"}
{"magic_number_smell": "\n\t\tassertEquals(1, values.get(\"t\"));\n\t\tassertEquals(0, values.get(\"f\"));\n\t\tassertEquals((int) Byte.MAX_VALUE, values.get(\"Byte.MAX_VALUE\"));\n\t\tassertEquals((int) Short.MAX_VALUE, values.get(\"shrt\"));\n\t\tassertEquals((int) Character.MAX_VALUE, values.get(\"chr\"));\n\t\tassertEquals(Integer.MAX_VALUE, values.get(\"intgr\"));", "refactored_code": "\tpublic static final byte\tbt\t\t= Byte.MAX_VALUE;\n\n\t\tassertEquals(1, values.get(\"t\"));\n\t\tassertEquals(0, values.get(\"f\"));\n\t\tassertEquals((int) Byte.MAX_VALUE, values.get(\"bt\"));\n\t\tassertEquals((int) Short.MAX_VALUE, values.get(\"shrt\"));\n\t\tassertEquals((int) Character.MAX_VALUE, values.get(\"chr\"));\n\t\tassertEquals(Integer.MAX_VALUE, values.get(\"intgr\"));"}
{"magic_number_smell": "\t\t/**\n\t\t *\n\t\t */\n\t\tprivate static final long 1L = 1L;\n\t}\n\n\t@Test", "refactored_code": "\t\tprivate static final long serialVersionUID = 1L;\n\t\t/**\n\t\t *\n\t\t */\n\t\tprivate static final long serialVersionUID = 1L;\n\t}\n\n\t@Test"}
{"magic_number_smell": "\t */\n\t@Component()\n\tpublic static class DS11_basic implements Serializable, Runnable {\n\t\tprivate static final long 1L = 1L;\n\n\t\t@Activate\n\t\tvoid activate(@SuppressWarnings(\"unused\") ComponentContext cc, @SuppressWarnings(\"unused\") BundleContext ctx) {}", "refactored_code": "\t\tprivate static final long serialVersionUID = 1L;\n\t */\n\t@Component()\n\tpublic static class DS11_basic implements Serializable, Runnable {\n\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t@Activate\n\t\tvoid activate(@SuppressWarnings(\"unused\") ComponentContext cc, @SuppressWarnings(\"unused\") BundleContext ctx) {}"}
{"magic_number_smell": "\n\t\t@Override\n\t\tpublic int compareTo(Request o) {\n\t\t\treturn Long.compare(System.currentTimeMillis(), o.System.currentTimeMillis());\n\t\t}\n\t}\n", "refactored_code": "\t\tpublic final long\t\t\t\ttime\t= System.currentTimeMillis();\n\n\t\t@Override\n\t\tpublic int compareTo(Request o) {\n\t\t\treturn Long.compare(time, o.time);\n\t\t}\n\t}\n"}
{"magic_number_smell": "\t\tFiles.createDirectories(f.getParentFile()\n\t\t\t.toPath());\n\t\ttry (InputStream in = resource.openStream(); OutputStream out = Files.newOutputStream(f.toPath())) {\n\t\t\tbyte[] buffer = new byte[4096 * 16];\n\t\t\tfor (int size; (size = in.read(buffer, 0, buffer.length)) > 0;) {\n\t\t\t\tout.write(buffer, 0, size);\n\t\t\t}", "refactored_code": "\tprivate static final int\tBUFFER_SIZE\t\t\t= 4096 * 16;\n\t\tFiles.createDirectories(f.getParentFile()\n\t\t\t.toPath());\n\t\ttry (InputStream in = resource.openStream(); OutputStream out = Files.newOutputStream(f.toPath())) {\n\t\t\tbyte[] buffer = new byte[BUFFER_SIZE];\n\t\t\tfor (int size; (size = in.read(buffer, 0, buffer.length)) > 0;) {\n\t\t\t\tout.write(buffer, 0, size);\n\t\t\t}"}
{"magic_number_smell": "\n\t\t\tlong timeout = service.timeout();\n\t\t\tif (timeout <= 0)\n\t\t\t\ttimeout = 60000L;\n\n\t\t\tboolean multiple = isMultiple(param.type);\n\t\t\tint cardinality = multiple ? service.minimum() : 1;", "refactored_code": "\tprivate static final long\t\t\t\t\tSERVICE_DEFAULT_TIMEOUT\t= 60000L;\n\n\t\t\tlong timeout = service.timeout();\n\t\t\tif (timeout <= 0)\n\t\t\t\ttimeout = SERVICE_DEFAULT_TIMEOUT;\n\n\t\t\tboolean multiple = isMultiple(param.type);\n\t\t\tint cardinality = multiple ? service.minimum() : 1;"}
{"magic_number_smell": "\t\t\t\t\t\t\t\t// highly likely since they are usually\n\t\t\t\t\t\t\t\t// tramsmitted in a single go\n\n\t\t\t\t\t\t\t\tif (b == 255) {\n\n\t\t\t\t\t\t\t\t\t// Next is the command type\n", "refactored_code": "\tprivate static final int\tIAC\t\t\t\t\t\t= 255;\n\t\t\t\t\t\t\t\t// highly likely since they are usually\n\t\t\t\t\t\t\t\t// tramsmitted in a single go\n\n\t\t\t\t\t\t\t\tif (b == IAC) {\n\n\t\t\t\t\t\t\t\t\t// Next is the command type\n"}
{"magic_number_smell": "\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t\tif (retryTimeout > 0) {\n\t\t\t\t\tretryTimeout = Math.max(retryTimeout - 200, 0);\n\t\t\t\t}\n\t\t\t\tThread.sleep(200);\n\t\t\t}", "refactored_code": "\tprivate static final int\t\t\t\t\t\tconnectWait\t= 200;\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t\tif (retryTimeout > 0) {\n\t\t\t\t\tretryTimeout = Math.max(retryTimeout - connectWait, 0);\n\t\t\t\t}\n\t\t\t\tThread.sleep(connectWait);\n\t\t\t}"}
{"magic_number_smell": "\t\t\tfor (IRepositoryContentProvider provider : contentProviders) {\n\t\t\t\tCheckResult checkResult;\n\t\t\t\ttry {\n\t\t\t\t\tbufferedStream.mark(5 * 1024 * 1024);\n\t\t\t\t\tcheckResult = provider.checkStream(name, new ProtectedStream(bufferedStream));\n\t\t\t\t} finally {\n\t\t\t\t\tbufferedStream.reset();", "refactored_code": "\tprivate static final int READ_AHEAD_MAX = 5 * 1024 * 1024;\n\t\t\tfor (IRepositoryContentProvider provider : contentProviders) {\n\t\t\t\tCheckResult checkResult;\n\t\t\t\ttry {\n\t\t\t\t\tbufferedStream.mark(READ_AHEAD_MAX);\n\t\t\t\t\tcheckResult = provider.checkStream(name, new ProtectedStream(bufferedStream));\n\t\t\t\t} finally {\n\t\t\t\t\tbufferedStream.reset();"}
{"magic_number_smell": "\t\t\t\t.containsKey(Constants.GESTALT_OFFLINE))) {\n\t\t\treturn;\n\t\t}\n\t\tint polltime = configuration.poll_time(300);\n\t\tif (polltime > 0) {\n\t\t\tAtomicBoolean inPoll = new AtomicBoolean();\n\t\t\tpomPoller = Processor.getScheduledExecutor()", "refactored_code": "\tprivate static final int\tDEFAULT_POLL_TIME\t= 300;\n\t\t\t\t.containsKey(Constants.GESTALT_OFFLINE))) {\n\t\t\treturn;\n\t\t}\n\t\tint polltime = configuration.poll_time(DEFAULT_POLL_TIME);\n\t\tif (polltime > 0) {\n\t\t\tAtomicBoolean inPoll = new AtomicBoolean();\n\t\t\tpomPoller = Processor.getScheduledExecutor()"}
{"magic_number_smell": "\t\t\t\t.containsKey(Constants.GESTALT_OFFLINE))) {\n\t\t\treturn;\n\t\t}\n\t\tint polltime = configuration.poll_time(5);\n\t\tif (polltime > 0) {\n\t\t\tAtomicBoolean inPoll = new AtomicBoolean();\n\t\t\tindexPoller = Processor.getScheduledExecutor()", "refactored_code": "\tprivate static final int\t\t\t\t\tDEFAULT_POLL_TIME\t= 5;\n\t\t\t\t.containsKey(Constants.GESTALT_OFFLINE))) {\n\t\t\treturn;\n\t\t}\n\t\tint polltime = configuration.poll_time(DEFAULT_POLL_TIME);\n\t\tif (polltime > 0) {\n\t\t\tAtomicBoolean inPoll = new AtomicBoolean();\n\t\t\tindexPoller = Processor.getScheduledExecutor()"}
{"magic_number_smell": "\t\tIO.createSymbolicLinkOrCopy(link, source);\n\n\t\tPromise<File> go = client.build()\n\t\t\t.useCache(TimeUnit.DAYS.toMillis(100))\n\t\t\t.asTag()\n\t\t\t.async(url.toURL())\n\t\t\t.map(tag -> processor.unpackAndLinkIfNeeded(tag, link));", "refactored_code": "\tprivate static final long\t\t\t\tMAX_STALE\t= TimeUnit.DAYS.toMillis(100);\n\t\tIO.createSymbolicLinkOrCopy(link, source);\n\n\t\tPromise<File> go = client.build()\n\t\t\t.useCache(MAX_STALE)\n\t\t\t.asTag()\n\t\t\t.async(url.toURL())\n\t\t\t.map(tag -> processor.unpackAndLinkIfNeeded(tag, link));"}
{"magic_number_smell": "\t\t// MAX\n\t\t//\n\n\t\tif (System.currentTimeMillis() - nexusStagingBug > 60 * 60 * 1000) {\n\t\t\tThread.sleep(5000);\n\t\t\tnexusStagingBug = System.currentTimeMillis();\n\t\t}", "refactored_code": "\tprivate static final int\t\t\t\tSTAGING_DELAY\t\t= 60 * 60 * 1000;\t\t\t\t\t\t\t\t\t\t// 1\n\t\t// MAX\n\t\t//\n\n\t\tif (System.currentTimeMillis() - nexusStagingBug > STAGING_DELAY) {\n\t\t\tThread.sleep(5000);\n\t\t\tnexusStagingBug = System.currentTimeMillis();\n\t\t}"}
{"magic_number_smell": "\tprivate boolean\t\t\t\tkeepLogFile\t\t= false;\n\n\tpublic ResolverLogger() {\n\t\tthis(4);\n\t}\n\n\tpublic ResolverLogger(int level) {", "refactored_code": "\tpublic static final int\t\tDEFAULT_LEVEL\t= 4;\n\tprivate boolean\t\t\t\tkeepLogFile\t\t= false;\n\n\tpublic ResolverLogger() {\n\t\tthis(DEFAULT_LEVEL);\n\t}\n\n\tpublic ResolverLogger(int level) {"}
{"magic_number_smell": "\t\tInstant startInstant = this.startInstants.getOrDefault(testIdentifier, Instant.EPOCH);\n\t\tInstant endInstant = this.endInstants.getOrDefault(testIdentifier, startInstant);\n\t\treturn Duration.between(startInstant, endInstant)\n\t\t\t.toMillis() / (double) 1000;\n\t}\n\n\tString getSkipReason(TestIdentifier testIdentifier) {", "refactored_code": "\tprivate static final int\t\t\t\t\t\t\t\tMILLIS_PER_SECOND\t= 1000;\n\t\tInstant startInstant = this.startInstants.getOrDefault(testIdentifier, Instant.EPOCH);\n\t\tInstant endInstant = this.endInstants.getOrDefault(testIdentifier, startInstant);\n\t\treturn Duration.between(startInstant, endInstant)\n\t\t\t.toMillis() / (double) MILLIS_PER_SECOND;\n\t}\n\n\tString getSkipReason(TestIdentifier testIdentifier) {"}
{"magic_number_smell": "\t}\n\n\tpublic void full(String string, Object... args) {\n\t\tif (level < 2)\n\t\t\treturn;\n\n\t\tmessage(string, args);", "refactored_code": "\tpublic static final int\t\tLOG_FULL\t= 2;\n\t}\n\n\tpublic void full(String string, Object... args) {\n\t\tif (level < LOG_FULL)\n\t\t\treturn;\n\n\t\tmessage(string, args);"}
{"magic_number_smell": "\t * A project IClasspathEntry replacement used for object serialization\n\t */\n\tstatic final class ProjectEntryReplace implements Serializable {\n\t\tprivate static final long\t\t\t1L\t= 1L;\n\n\t\tprivate final IPath\t\t\t\t\tpath;\n\t\tprivate final IAccessRule[]\t\t\taccessRules;", "refactored_code": "\t\tprivate static final long\t\t\tserialVersionUID\t= 1L;\n\t * A project IClasspathEntry replacement used for object serialization\n\t */\n\tstatic final class ProjectEntryReplace implements Serializable {\n\t\tprivate static final long\t\t\tserialVersionUID\t= 1L;\n\n\t\tprivate final IPath\t\t\t\t\tpath;\n\t\tprivate final IAccessRule[]\t\t\taccessRules;"}
{"magic_number_smell": "\t\t\t\tdelta.accept(delta1 -> {\n\t\t\t\t\tString name = delta1.getFullPath()\n\t\t\t\t\t\t.lastSegment();\n\t\t\t\t\tif (name != null && name.endsWith(\".bndrun\") && (delta1.getKind() & IResourceDelta.ADDED | IResourceDelta.REMOVED) > 0) {\n\t\t\t\t\t\tbndrunChanged.set(true);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}", "refactored_code": "\t\tprivate final int kind = IResourceDelta.ADDED | IResourceDelta.REMOVED;\n\t\t\t\tdelta.accept(delta1 -> {\n\t\t\t\t\tString name = delta1.getFullPath()\n\t\t\t\t\t\t.lastSegment();\n\t\t\t\t\tif (name != null && name.endsWith(\".bndrun\") && (delta1.getKind() & kind) > 0) {\n\t\t\t\t\t\tbndrunChanged.set(true);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}"}
{"magic_number_smell": "\t\t\t\t\t\t\t\t.getBounds().height;\n\t\t\t\t\t\t\tint numVisibleItems = treeHeight / getViewer().getTree()\n\t\t\t\t\t\t\t\t.getItemHeight();\n\t\t\t\t\t\t\tlong stopTime = 200 + System.currentTimeMillis();\n\t\t\t\t\t\t\tif (items.length > 0 && recursiveExpand(items, monitor, stopTime, new int[] {\n\t\t\t\t\t\t\t\tnumVisibleItems\n\t\t\t\t\t\t\t})) {", "refactored_code": "\tprivate static final long\tSOFT_MAX_EXPAND_TIME\t= 200;\n\t\t\t\t\t\t\t\t.getBounds().height;\n\t\t\t\t\t\t\tint numVisibleItems = treeHeight / getViewer().getTree()\n\t\t\t\t\t\t\t\t.getItemHeight();\n\t\t\t\t\t\t\tlong stopTime = SOFT_MAX_EXPAND_TIME + System.currentTimeMillis();\n\t\t\t\t\t\t\tif (items.length > 0 && recursiveExpand(items, monitor, stopTime, new int[] {\n\t\t\t\t\t\t\t\tnumVisibleItems\n\t\t\t\t\t\t\t})) {"}
{"magic_number_smell": "\t */\n\t@Override\n\tprotected void createButtonsForButtonBar(Composite parent) {\n\t\tcreateButton(parent, IDialogConstants.CLIENT_ID + 1, NewWizardMessages.SuperInterfaceSelectionDialog_addButton_label, true);\n\t\tsuper.createButtonsForButtonBar(parent);\n\t}\n", "refactored_code": "\tprivate static final int\t\tADD_ID\t= IDialogConstants.CLIENT_ID + 1;\n\t */\n\t@Override\n\tprotected void createButtonsForButtonBar(Composite parent) {\n\t\tcreateButton(parent, ADD_ID, NewWizardMessages.SuperInterfaceSelectionDialog_addButton_label, true);\n\t\tsuper.createButtonsForButtonBar(parent);\n\t}\n"}
{"magic_number_smell": "\t\tif (resource instanceof IFile) {\n\t\t\tIFile node = (IFile) resource;\n\t\t\tJAREditor.background(\"Loading \" + resource.getName(), mon -> {\n\t\t\t\ttry (InputStream in = limitRead ? new LimitedInputStream(node.getContents(), 1000000)\n\t\t\t\t\t: node.getContents()) {\n\t\t\t\t\treturn IO.copy(in, new ByteBufferOutputStream())\n\t\t\t\t\t\t.toByteBuffer();", "refactored_code": "\tprivate static final int\tREAD_LIMIT\t\t= 1000000;\n\t\tif (resource instanceof IFile) {\n\t\t\tIFile node = (IFile) resource;\n\t\t\tJAREditor.background(\"Loading \" + resource.getName(), mon -> {\n\t\t\t\ttry (InputStream in = limitRead ? new LimitedInputStream(node.getContents(), READ_LIMIT)\n\t\t\t\t\t: node.getContents()) {\n\t\t\t\t\treturn IO.copy(in, new ByteBufferOutputStream())\n\t\t\t\t\t\t.toByteBuffer();"}
{"magic_number_smell": "\n\tpublic ProgressMonitorReporter(IProgressMonitor monitor, String taskName) {\n\t\tthis.monitor = monitor;\n\t\tmonitor.beginTask(taskName, 1000);\n\t}\n\n\t@Override", "refactored_code": "\tprivate static final int\t\tTOTAL\t\t\t= 1000;\n\n\tpublic ProgressMonitorReporter(IProgressMonitor monitor, String taskName) {\n\t\tthis.monitor = monitor;\n\t\tmonitor.beginTask(taskName, TOTAL);\n\t}\n\n\t@Override"}
{"magic_number_smell": "\t\t\t\tscheduledFilterLock.lock();\n\t\t\t\tif (scheduledFilterUpdate != null)\n\t\t\t\t\tscheduledFilterUpdate.cancel(true);\n\t\t\t\tscheduledFilterUpdate = scheduler.schedule(updateFilterTask, 300, TimeUnit.MILLISECONDS);\n\t\t\t} finally {\n\t\t\t\tscheduledFilterLock.unlock();\n\t\t\t}", "refactored_code": "\tprivate static final long\t\t\t\tSEARCH_DELAY\t\t\t= 300;\n\t\t\t\tscheduledFilterLock.lock();\n\t\t\t\tif (scheduledFilterUpdate != null)\n\t\t\t\t\tscheduledFilterUpdate.cancel(true);\n\t\t\t\tscheduledFilterUpdate = scheduler.schedule(updateFilterTask, SEARCH_DELAY, TimeUnit.MILLISECONDS);\n\t\t\t} finally {\n\t\t\t\tscheduledFilterLock.unlock();\n\t\t\t}"}
{"magic_number_smell": "\t\t\t\t\tupdate();\n\t\t\t\t}\n\t\t\t};\n\t\t\ttimer.schedule(trigger, 500);\n\t\t}\n\t}\n", "refactored_code": "\tprivate static final int\t\t\t\t\t\t\t\tGRACE_PERIOD\t= 500;\n\t\t\t\t\tupdate();\n\t\t\t\t}\n\t\t\t};\n\t\t\ttimer.schedule(trigger, GRACE_PERIOD);\n\t\t}\n\t}\n"}
{"magic_number_smell": "\n\t\tfinal TableViewerColumn colName = new TableViewerColumn(listViewer, SWT.NONE);\n\t\tcolName.getColumn()\n\t\t\t.setWidth(100);\n\t\tcolName.getColumn()\n\t\t\t.setText(TableColumn_Name);\n\t\tcolName.setLabelProvider(new ColumnLabelProvider() {", "refactored_code": "\tprivate static final int\t\t\t\tTABLE_COLUMN_WIDTH\t\t= 100;\n\n\t\tfinal TableViewerColumn colName = new TableViewerColumn(listViewer, SWT.NONE);\n\t\tcolName.getColumn()\n\t\t\t.setWidth(TABLE_COLUMN_WIDTH);\n\t\tcolName.getColumn()\n\t\t\t.setText(TableColumn_Name);\n\t\tcolName.setLabelProvider(new ColumnLabelProvider() {"}
{"magic_number_smell": "\t */\n\tprivate void manageBookselves() {\n\t\tIntent i = new Intent(this, Bookshelf.class);\n\t\tstartActivityForResult(i, 1);\n\t}\n\t\n\t/**", "refactored_code": "\tprivate static final int ACTIVITY_BOOKSHELF=1;\n\t */\n\tprivate void manageBookselves() {\n\t\tIntent i = new Intent(this, Bookshelf.class);\n\t\tstartActivityForResult(i, ACTIVITY_BOOKSHELF);\n\t}\n\t\n\t/**"}
{"magic_number_smell": "\n\t\t@Override\n\t\tpublic long getCategory() {\n\t\t\treturn 1;\n\t\t}\n\t}\n", "refactored_code": "\tpublic static final long CAT_LEGACY = 1;\n\n\t\t@Override\n\t\tpublic long getCategory() {\n\t\t\treturn CAT_LEGACY;\n\t\t}\n\t}\n"}
{"magic_number_smell": "\t\t\t\t\tholder.title.view.setText(rowView.getTitle());\n\n\t\t\t\tif (holder.image.show) {\n\t\t\t\t\t//CatalogueDBAdapter.fetchThumbnailIntoImageView(cursor.getId(),holder.image.view, 60, 60, true, mTaskQueue);\n\t\t\t\t\tmUtils.fetchBookCoverIntoImageView(holder.image.view, 60, 60, true, rowView.getBookUuid(), \n\t\t\t\t\t\t\t\t\t\t\t\t\t\tBooklistPreferencesActivity.isThumbnailCacheEnabled(), BooklistPreferencesActivity.isBackgroundThumbnailsEnabled());\n\t\t\t\t}", "refactored_code": "\tprivate static final int LIST_THUMBNAIL_SIZE=60;\n\t\t\t\t\tholder.title.view.setText(rowView.getTitle());\n\n\t\t\t\tif (holder.image.show) {\n\t\t\t\t\t//CatalogueDBAdapter.fetchThumbnailIntoImageView(cursor.getId(),holder.image.view, LIST_THUMBNAIL_SIZE, LIST_THUMBNAIL_SIZE, true, mTaskQueue);\n\t\t\t\t\tmUtils.fetchBookCoverIntoImageView(holder.image.view, LIST_THUMBNAIL_SIZE, LIST_THUMBNAIL_SIZE, true, rowView.getBookUuid(), \n\t\t\t\t\t\t\t\t\t\t\t\t\t\tBooklistPreferencesActivity.isThumbnailCacheEnabled(), BooklistPreferencesActivity.isBackgroundThumbnailsEnabled());\n\t\t\t\t}"}
{"magic_number_smell": "\tprivate boolean mGotCameraImage = false;\n\t\n\tprotected android.util.DisplayMetrics mMetrics;\n\t/** Minimum of 256 and 1/3rd of largest screen dimension */\n\tprotected Integer mThumbEditSize;\n\t/** Zoom size is minimum of MAX_ZOOM_THUMBNAIL_SIZE and largest screen dimension. */\n\tprotected Integer mThumbZoomSize;", "refactored_code": "\tprotected static final int MAX_EDIT_THUMBNAIL_SIZE = 256;\n\tprivate boolean mGotCameraImage = false;\n\t\n\tprotected android.util.DisplayMetrics mMetrics;\n\t/** Minimum of MAX_EDIT_THUMBNAIL_SIZE and 1/3rd of largest screen dimension */\n\tprotected Integer mThumbEditSize;\n\t/** Zoom size is minimum of MAX_ZOOM_THUMBNAIL_SIZE and largest screen dimension. */\n\tprotected Integer mThumbZoomSize;"}
{"magic_number_smell": "\t\t\t}\n\t\t\tBookEdit.viewBook(a, id, listTable, position);\n\t\t} else {\n\t\t\tBookEdit.editBook(a, id, BookEdit.0);\n\t\t}\n\t}\n", "refactored_code": "\tpublic static final int TAB_EDIT = 0;\n\t\t\t}\n\t\t\tBookEdit.viewBook(a, id, listTable, position);\n\t\t} else {\n\t\t\tBookEdit.editBook(a, id, BookEdit.TAB_EDIT);\n\t\t}\n\t}\n"}
{"magic_number_smell": "\t@Override\n\tpublic void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {\n\t\tsuper.onCreateContextMenu(menu, v, menuInfo);\n\t\tmenu.add(0, Menu.FIRST, 0, R.string.menu_delete_anthology);\n\t}\n\t\n\t@Override", "refactored_code": "\tprivate static final int DELETE_ID = Menu.FIRST;\n\t@Override\n\tpublic void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {\n\t\tsuper.onCreateContextMenu(menu, v, menuInfo);\n\t\tmenu.add(0, DELETE_ID, 0, R.string.menu_delete_anthology);\n\t}\n\t\n\t@Override"}
{"magic_number_smell": "\t\t\t\t\ti.putExtra(CatalogueDBAdapter.KEY_ROWID, mEditManager.getBookData().getRowId());\n\t\t\t\t\ti.putExtra(\"title_label\", CatalogueDBAdapter.KEY_TITLE);\n\t\t\t\t\ti.putExtra(\"title\", mFields.getField(R.id.title).getValue().toString());\n\t\t\t\t\tstartActivityForResult(i, 1000);\n\t\t\t\t}\n\t\t\t});\n\t\t\t", "refactored_code": "\tpublic static final int ACTIVITY_EDIT_AUTHORS = 1000;\n\t\t\t\t\ti.putExtra(CatalogueDBAdapter.KEY_ROWID, mEditManager.getBookData().getRowId());\n\t\t\t\t\ti.putExtra(\"title_label\", CatalogueDBAdapter.KEY_TITLE);\n\t\t\t\t\ti.putExtra(\"title\", mFields.getField(R.id.title).getValue().toString());\n\t\t\t\t\tstartActivityForResult(i, ACTIVITY_EDIT_AUTHORS);\n\t\t\t\t}\n\t\t\t});\n\t\t\t"}
{"magic_number_smell": "\t\t//menu.clear();\n\t\tfinal Long currRow = mEditManager.getBookData().getRowId();\n\t\tif (currRow != null && currRow != 0) {\n\t\t\tMenuItem delete = menu.add(0, 1, 0, R.string.menu_delete);\n\t\t\tdelete.setIcon(android.R.drawable.ic_menu_delete);\n\n\t\t\tMenuItem duplicate = menu.add(0, DUPLICATE_ID, 0, R.string.menu_duplicate);", "refactored_code": "\tprivate static final int DELETE_ID = 1;\n\t\t//menu.clear();\n\t\tfinal Long currRow = mEditManager.getBookData().getRowId();\n\t\tif (currRow != null && currRow != 0) {\n\t\t\tMenuItem delete = menu.add(0, DELETE_ID, 0, R.string.menu_delete);\n\t\t\tdelete.setIcon(android.R.drawable.ic_menu_delete);\n\n\t\t\tMenuItem duplicate = menu.add(0, DUPLICATE_ID, 0, R.string.menu_duplicate);"}
{"magic_number_smell": "\t * @author Philip Warner\n\t */\n\tpublic static class GrSendBookEvent extends BookEvent {\n\t\tprivate static final long 74746691665235897L = 1L;\n\n\t\tpublic GrSendBookEvent(long bookId, String message) {\n\t\t\tsuper(bookId, message);", "refactored_code": "\t\tprivate static final long serialVersionUID = 74746691665235897L;\n\t * @author Philip Warner\n\t */\n\tpublic static class GrSendBookEvent extends BookEvent {\n\t\tprivate static final long serialVersionUID = 1L;\n\n\t\tpublic GrSendBookEvent(long bookId, String message) {\n\t\t\tsuper(bookId, message);"}
{"magic_number_smell": "\t\n    private void createBookshelf() {\n        Intent i = new Intent(this, BookshelfEdit.class);\n        startActivityForResult(i, 0);\n    }\n    \n    @Override", "refactored_code": "\tprivate static final int ACTIVITY_CREATE=0;\n\t\n    private void createBookshelf() {\n        Intent i = new Intent(this, BookshelfEdit.class);\n        startActivityForResult(i, ACTIVITY_CREATE);\n    }\n    \n    @Override"}
{"magic_number_smell": "\t\t\t\t\t// Let the activity know\n\t\t\t\t\tif (context instanceof BooklistChangeListener) {\n\t\t\t\t\t\tfinal BooklistChangeListener l = (BooklistChangeListener) context;\n\t\t\t\t\t\tl.onBooklistChange(BooklistChangeListener.1 | BooklistChangeListener.FLAG_SERIES);\n\t\t\t\t\t}\n\t\t\t\t}});\n\t\t\t// Display an error, if any", "refactored_code": "\t\tpublic static final int FLAG_AUTHOR = 1;\n\t\t\t\t\t// Let the activity know\n\t\t\t\t\tif (context instanceof BooklistChangeListener) {\n\t\t\t\t\t\tfinal BooklistChangeListener l = (BooklistChangeListener) context;\n\t\t\t\t\t\tl.onBooklistChange(BooklistChangeListener.FLAG_AUTHOR | BooklistChangeListener.FLAG_SERIES);\n\t\t\t\t\t}\n\t\t\t\t}});\n\t\t\t// Display an error, if any"}
{"magic_number_smell": "\n\t\tmMenuHandler.addCreateBookItems(menu);\n\n\t\ti = mMenuHandler.addItem(menu, MenuHandler.FIRST+1, R.string.sort_and_style_ellipsis, android.R.drawable.ic_menu_sort_alphabetically);\n\t\ti.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);\n\t\t\t;\n\t\t//mMenuHandler.addItem(menu, MNU_EDIT_STYLE, R.string.edit_style, android.R.drawable.ic_menu_manage);", "refactored_code": "\tprivate static final int MNU_SORT = MenuHandler.FIRST+1; \n\n\t\tmMenuHandler.addCreateBookItems(menu);\n\n\t\ti = mMenuHandler.addItem(menu, MNU_SORT, R.string.sort_and_style_ellipsis, android.R.drawable.ic_menu_sort_alphabetically);\n\t\ti.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);\n\t\t\t;\n\t\t//mMenuHandler.addItem(menu, MNU_EDIT_STYLE, R.string.edit_style, android.R.drawable.ic_menu_manage);"}
{"magic_number_smell": "\t\t\t/* KEY_SERIES_NUM + \" text, \" + */\n\t\t\tKEY_NOTES + \" text, \" +\n\t\t\tKEY_LIST_PRICE + \" text, \" +\n\t\t\tKEY_ANTHOLOGY_MASK + \" int not null default \" + 0 + \", \" + \n\t\t\tKEY_LOCATION + \" text, \" +\n\t\t\tKEY_READ_START + \" date, \" +\n\t\t\tKEY_READ_END + \" date, \" +", "refactored_code": "\tpublic static final int ANTHOLOGY_NO = 0;\n\t\t\t/* KEY_SERIES_NUM + \" text, \" + */\n\t\t\tKEY_NOTES + \" text, \" +\n\t\t\tKEY_LIST_PRICE + \" text, \" +\n\t\t\tKEY_ANTHOLOGY_MASK + \" int not null default \" + ANTHOLOGY_NO + \", \" + \n\t\t\tKEY_LOCATION + \" text, \" +\n\t\t\tKEY_READ_START + \" date, \" +\n\t\t\tKEY_READ_END + \" date, \" +"}
{"magic_number_smell": "\tprotected static final TaskSwitch getMessageSwitch() { return mMessageSwitch; }\n\n\tprivate final long mMessageSwitch.createSender(mController) = mMessageSwitch.createSender(mController);\n\tpublic long getSenderId() { return mMessageSwitch.createSender(mController); }\n}\n", "refactored_code": "\tprivate final long mMessageSenderId = mMessageSwitch.createSender(mController);\n\tprotected static final TaskSwitch getMessageSwitch() { return mMessageSwitch; }\n\n\tprivate final long mMessageSenderId = mMessageSwitch.createSender(mController);\n\tpublic long getSenderId() { return mMessageSenderId; }\n}\n"}
{"magic_number_smell": "\t * @param menu\tRoot menu\n\t */\n\tpublic void addCreateBookItems(Menu menu) {\n\t\tSubMenu addMenu = menu.addSubMenu(0, Menu.FIRST+1, mSort++, BookCatalogueApp.getResourceString(R.string.menu_insert) + \"...\");\n\t\t//addMenu.setIcon(android.R.drawable.ic_menu_add);\n\t\taddMenu.setIcon(R.drawable.ic_action_book_add);\n\t\taddMenu.getItem().setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS);", "refactored_code": "\tprivate static final int MNU_ADD_BOOK = Menu.FIRST+1;\n\t * @param menu\tRoot menu\n\t */\n\tpublic void addCreateBookItems(Menu menu) {\n\t\tSubMenu addMenu = menu.addSubMenu(0, MNU_ADD_BOOK, mSort++, BookCatalogueApp.getResourceString(R.string.menu_insert) + \"...\");\n\t\t//addMenu.setIcon(android.R.drawable.ic_menu_add);\n\t\taddMenu.setIcon(R.drawable.ic_action_book_add);\n\t\taddMenu.getItem().setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS);"}
{"magic_number_smell": "\t/** Booklist Compatibility mode property values */\n\tprivate static ItemEntries<Integer> mListGenerationOptionsListItems = new ItemEntries<Integer>()\n\t\t\t.add(null, R.string.use_default_setting)\n\t\t\t.add(1, R.string.force_compatibility_mode)\n\t\t\t.add(BOOKLIST_GENERATE_FLAT_TRIGGER, R.string.force_enhanced_compatibility_mode)\n\t\t\t.add(BOOKLIST_GENERATE_NESTED_TRIGGER, R.string.force_fully_featured)\n\t\t\t.add(BOOKLIST_GENERATE_AUTOMATIC, R.string.automatically_use_recommended_option)", "refactored_code": "\tpublic static final int BOOKLIST_GENERATE_OLD_STYLE = 1;\n\t/** Booklist Compatibility mode property values */\n\tprivate static ItemEntries<Integer> mListGenerationOptionsListItems = new ItemEntries<Integer>()\n\t\t\t.add(null, R.string.use_default_setting)\n\t\t\t.add(BOOKLIST_GENERATE_OLD_STYLE, R.string.force_compatibility_mode)\n\t\t\t.add(BOOKLIST_GENERATE_FLAT_TRIGGER, R.string.force_enhanced_compatibility_mode)\n\t\t\t.add(BOOKLIST_GENERATE_NESTED_TRIGGER, R.string.force_fully_featured)\n\t\t\t.add(BOOKLIST_GENERATE_AUTOMATIC, R.string.automatically_use_recommended_option)"}
{"magic_number_smell": "\t/** Flag indicating a search source to use */\n\tpublic static final int SEARCH_GOODREADS = 8;\n\t/** Mask including all search sources */\n\tpublic static final int SEARCH_ALL = 1 | SEARCH_BC | SEARCH_LIBRARY_THING | SEARCH_GOODREADS;\n\t\n\t// ENHANCE: Allow user to change the default search data priority\n\t// NOTE: BCDB search will return AMAZON, GOOGLE, BCDB and OPENLIBRARY", "refactored_code": "\tpublic static final int SEARCH_GOOGLE = 1;\n\t/** Flag indicating a search source to use */\n\tpublic static final int SEARCH_GOODREADS = 8;\n\t/** Mask including all search sources */\n\tpublic static final int SEARCH_ALL = SEARCH_GOOGLE | SEARCH_BC | SEARCH_LIBRARY_THING | SEARCH_GOODREADS;\n\t\n\t// ENHANCE: Allow user to change the default search data priority\n\t// NOTE: BCDB search will return AMAZON, GOOGLE, BCDB and OPENLIBRARY"}
{"magic_number_smell": "\n\tpublic void stage3Startup() {\n\t\tBookCataloguePreferences prefs = BookCatalogueApp.getAppPreferences();\n\t\tint opened = prefs.getInt(STATE_OPENED, 5);\n\t\tint startCount = prefs.getInt(PREF_START_COUNT, 0) + 1;\n\n\t\tEditor ed = prefs.edit();", "refactored_code": "\tprivate static final int BACKUP_PROMPT_WAIT = 5;\n\n\tpublic void stage3Startup() {\n\t\tBookCataloguePreferences prefs = BookCatalogueApp.getAppPreferences();\n\t\tint opened = prefs.getInt(STATE_OPENED, BACKUP_PROMPT_WAIT);\n\t\tint startCount = prefs.getInt(PREF_START_COUNT, 0) + 1;\n\n\t\tEditor ed = prefs.edit();"}
{"magic_number_smell": "\tprivate final long mMessageSwitch.createSender(mController) = mMessageSwitch.createSender(mController);\n\n\tpublic long getSenderId() {\n\t\treturn mMessageSwitch.createSender(mController);\n\t}\n\n\t/* ====================================================================================================", "refactored_code": "\tprivate final long mMessageSenderId = mMessageSwitch.createSender(mController);\n\tprivate final long mMessageSenderId = mMessageSwitch.createSender(mController);\n\n\tpublic long getSenderId() {\n\t\treturn mMessageSenderId;\n\t}\n\n\t/* ===================================================================================================="}
{"magic_number_smell": "\tpublic static final int EXPORT_DETAILS = 32;\n\t/** Flag value to indicate ALL books should be exported */\n\tpublic static final int EXPORT_ALL = EXPORT_PREFERENCES | EXPORT_STYLES | EXPORT_COVERS | EXPORT_DETAILS;\n\tpublic static final int EXPORT_ALL_SINCE = EXPORT_PREFERENCES | EXPORT_STYLES | EXPORT_COVERS | EXPORT_DETAILS | 2;\n\tpublic static final int EXPORT_MASK = EXPORT_ALL | 2;\n\n\t/**", "refactored_code": "\tpublic static final int EXPORT_SINCE = 2;\n\tpublic static final int EXPORT_DETAILS = 32;\n\t/** Flag value to indicate ALL books should be exported */\n\tpublic static final int EXPORT_ALL = EXPORT_PREFERENCES | EXPORT_STYLES | EXPORT_COVERS | EXPORT_DETAILS;\n\tpublic static final int EXPORT_ALL_SINCE = EXPORT_PREFERENCES | EXPORT_STYLES | EXPORT_COVERS | EXPORT_DETAILS | EXPORT_SINCE;\n\tpublic static final int EXPORT_MASK = EXPORT_ALL | EXPORT_SINCE;\n\n\t/**"}
{"magic_number_smell": "\t\turlConnection.setRequestMethod(method == Methods.Post ? \"POST\" : \"GET\");\n\t\turlConnection.setRequestProperty(\"Accept-Language\", UTF8);\n\t\t// Set a tmeout\n\t\turlConnection.setConnectTimeout(30000);\n\n\t\t//urlConnection.setRequestProperty(\"Authorization\", \"Basic \" + getApiToken());\n", "refactored_code": "\tprivate static final int API_TIMEOUT = 30000;\n\t\turlConnection.setRequestMethod(method == Methods.Post ? \"POST\" : \"GET\");\n\t\turlConnection.setRequestProperty(\"Accept-Language\", UTF8);\n\t\t// Set a tmeout\n\t\turlConnection.setConnectTimeout(API_TIMEOUT);\n\n\t\t//urlConnection.setRequestProperty(\"Authorization\", \"Basic \" + getApiToken());\n"}
{"magic_number_smell": "\t\t\tmListTable.addDomain(DOM_ROOT_KEY);\t// Will use expression based on first group; determined later\n\t\n\t\t\t// Add the domains that have simple pre-determined expressions as sources\n\t\t\tsummary.addDomain(DOM_LEVEL, Integer.toString(mStyle.size()+1), SummaryBuilder.0);\n\t\t\tsummary.addDomain(DOM_KIND, \"\" + ROW_KIND_BOOK, SummaryBuilder.0);\n\t\t\tsummary.addDomain(DOM_BOOK, TBL_BOOKS.dot(DOM_ID), SummaryBuilder.0);\n\t\t\tsummary.addDomain(DOM_BOOK_COUNT, \"1\", SummaryBuilder.0);", "refactored_code": "\t\tpublic static final int FLAG_NONE = 0;\n\t\t\tmListTable.addDomain(DOM_ROOT_KEY);\t// Will use expression based on first group; determined later\n\t\n\t\t\t// Add the domains that have simple pre-determined expressions as sources\n\t\t\tsummary.addDomain(DOM_LEVEL, Integer.toString(mStyle.size()+1), SummaryBuilder.FLAG_NONE);\n\t\t\tsummary.addDomain(DOM_KIND, \"\" + ROW_KIND_BOOK, SummaryBuilder.FLAG_NONE);\n\t\t\tsummary.addDomain(DOM_BOOK, TBL_BOOKS.dot(DOM_ID), SummaryBuilder.FLAG_NONE);\n\t\t\tsummary.addDomain(DOM_BOOK_COUNT, \"1\", SummaryBuilder.FLAG_NONE);"}
{"magic_number_smell": "\t * @param <V>\tType of data values\n\t */\n\tprivate static class UniqueMap<K, V> extends HashMap<K, V> {\n\t\tprivate static final long 1012206875683862714L = 1L;\n\n\t\t/**\n\t\t * Add a value, throwing an exception if key already stored", "refactored_code": "\tprivate static final long serialVersionUID = 1012206875683862714L;\n\t * @param <V>\tType of data values\n\t */\n\tprivate static class UniqueMap<K, V> extends HashMap<K, V> {\n\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t/**\n\t\t * Add a value, throwing an exception if key already stored"}
{"magic_number_smell": "\t\t\tmBooklistStateListItems, \n\t\t\tPREF_BOOKLISTS_STATE, \n\t\t\tPropertyGroup.GRP_GENERAL, \n\t\t\tR.string.book_list_state, null, PREF_BOOKLISTS_STATE, 1);\n\tstatic {\n\t\tmBooklistStateListItems.add(null, R.string.use_default_setting);\n\t\tmBooklistStateListItems.add(1, R.string.always_start_booklists_expanded);", "refactored_code": "\tpublic static final int BOOKLISTS_ALWAYS_EXPANDED = 1;\n\t\t\tmBooklistStateListItems, \n\t\t\tPREF_BOOKLISTS_STATE, \n\t\t\tPropertyGroup.GRP_GENERAL, \n\t\t\tR.string.book_list_state, null, PREF_BOOKLISTS_STATE, BOOKLISTS_ALWAYS_EXPANDED);\n\tstatic {\n\t\tmBooklistStateListItems.add(null, R.string.use_default_setting);\n\t\tmBooklistStateListItems.add(BOOKLISTS_ALWAYS_EXPANDED, R.string.always_start_booklists_expanded);"}
{"magic_number_smell": "\t\t\t\t\t.setPositiveButton(R.string.ok, new OnClickListener() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void onClick(DialogInterface dialogInterface, int i) {\n\t\t\t\t\t\t\tActivityCompat.requestPermissions(BookCatalogueActivity.this, list, 666);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.setOnCancelListener(new OnCancelListener() {", "refactored_code": "\tprivate static final int PERMISSIONS_RESULT = 666;\n\t\t\t\t\t.setPositiveButton(R.string.ok, new OnClickListener() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void onClick(DialogInterface dialogInterface, int i) {\n\t\t\t\t\t\t\tActivityCompat.requestPermissions(BookCatalogueActivity.this, list, PERMISSIONS_RESULT);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.setOnCancelListener(new OnCancelListener() {"}
{"magic_number_smell": "\tpublic static void showStorageToast(Activity activity, int remaining) {\n\t\tString noStorageText = null;\n\n\t\tif (remaining == -1) {\n\t\t\tString state = Environment.getExternalStorageState();\n\t\t\tif (state == Environment.MEDIA_CHECKING) {\n\t\t\t\tnoStorageText = \"Preparing card\";", "refactored_code": "\tpublic static final int NO_STORAGE_ERROR = -1;\n\tpublic static void showStorageToast(Activity activity, int remaining) {\n\t\tString noStorageText = null;\n\n\t\tif (remaining == NO_STORAGE_ERROR) {\n\t\t\tString state = Environment.getExternalStorageState();\n\t\t\tif (state == Environment.MEDIA_CHECKING) {\n\t\t\t\tnoStorageText = \"Preparing card\";"}
{"magic_number_smell": "\t\t// look bad if it's a small icon.\n\t\t// However, we need to crop small thumbnails on huge phones...so\n\t\t// there is little choice. We now have no effective limit.\n\t\tfloat widthScale = Math.min(viewWidth / w, Float.MAX_VALUE);\n\t\tfloat heightScale = Math.min(viewHeight / h, Float.MAX_VALUE);\n\t\tfloat scale = Math.min(widthScale, heightScale);\n", "refactored_code": "\tprivate static final float SCALE_LIMIT_MAX = Float.MAX_VALUE;\n\t\t// look bad if it's a small icon.\n\t\t// However, we need to crop small thumbnails on huge phones...so\n\t\t// there is little choice. We now have no effective limit.\n\t\tfloat widthScale = Math.min(viewWidth / w, SCALE_LIMIT_MAX);\n\t\tfloat heightScale = Math.min(viewHeight / h, SCALE_LIMIT_MAX);\n\t\tfloat scale = Math.min(widthScale, heightScale);\n"}
{"magic_number_smell": "\t\t\tthrow new RuntimeException(\"Covers database unavailable\");\n\n\t\tif (mHelper == null) {\n\t\t\tmHelper = new CoversHelper(COVERS_DATABASE_NAME, mTrackedCursorFactory, 1);\n\t\t}\n\t\tif (mSharedDb == null) {\n\t\t\t// Try to connect.", "refactored_code": "\tprivate static final int COVERS_DATABASE_VERSION = 1;\n\t\t\tthrow new RuntimeException(\"Covers database unavailable\");\n\n\t\tif (mHelper == null) {\n\t\t\tmHelper = new CoversHelper(COVERS_DATABASE_NAME, mTrackedCursorFactory, COVERS_DATABASE_VERSION);\n\t\t}\n\t\tif (mSharedDb == null) {\n\t\t\t// Try to connect."}
{"magic_number_smell": "\t@Override\n\tpublic void onTaskFinished(SimpleTaskQueueProgressFragment fragment, int taskId, boolean success, boolean cancelled, FragmentTask task) {\n\t\t// Is it a task we care about?\n\t\tif (taskId == 1) {\n\t\t\tif (!success) {\n\t\t\t\tString msg = getString(R.string.backup_failed)\n\t\t\t\t\t\t+ \" \" + getString(R.string.please_check_sd_writable)", "refactored_code": "\tprivate static final int TASK_ID_SAVE = 1;\n\t@Override\n\tpublic void onTaskFinished(SimpleTaskQueueProgressFragment fragment, int taskId, boolean success, boolean cancelled, FragmentTask task) {\n\t\t// Is it a task we care about?\n\t\tif (taskId == TASK_ID_SAVE) {\n\t\t\tif (!success) {\n\t\t\t\tString msg = getString(R.string.backup_failed)\n\t\t\t\t\t\t+ \" \" + getString(R.string.please_check_sd_writable)"}
{"magic_number_smell": "\t\t\tpublic GeneralException(Throwable inner) { m_inner = inner; };\n\t\t}\n\t\tpublic static class NotAuthorizedException extends GeneralException {\n\t\t\tprivate static final long 5762518476144652354L = 5589234170614368111L;\n\t\t\tpublic NotAuthorizedException(Throwable inner) { super(inner); }\n\t\t};\n\t\tpublic static class BookNotFoundException extends GeneralException {", "refactored_code": "\t\t\tprivate static final long serialVersionUID = 5762518476144652354L;\n\t\t\tpublic GeneralException(Throwable inner) { m_inner = inner; };\n\t\t}\n\t\tpublic static class NotAuthorizedException extends GeneralException {\n\t\t\tprivate static final long serialVersionUID = 5589234170614368111L;\n\t\t\tpublic NotAuthorizedException(Throwable inner) { super(inner); }\n\t\t};\n\t\tpublic static class BookNotFoundException extends GeneralException {"}
{"magic_number_smell": "\t\t/** accessor */\n\t\t@Override\n\t\tpublic long getId() {\n\t\t\treturn ++mSenderIdCounter;\n\t\t}\n\n\t\t/** Accessor */", "refactored_code": "\t\tprivate final long mId = ++mSenderIdCounter;\n\t\t/** accessor */\n\t\t@Override\n\t\tpublic long getId() {\n\t\t\treturn mId;\n\t\t}\n\n\t\t/** Accessor */"}
{"magic_number_smell": "\tprivate static final PropertyGroups mGroups = new PropertyGroups();\n\n\t/** Global PropertyGroup definition */\n\tpublic static final PropertyGroup GRP_GENERAL = mGroups.addGroup(++GRP_COUNT, R.string.general, 0);\n\t/** Global PropertyGroup definition */\n\tpublic static final PropertyGroup GRP_EXTRA_BOOK_DETAILS = mGroups.addGroup(GRP_EXTRA_BOOK_DETAILS_ID, R.string.extra_book_details, 100);\n\t/** Global PropertyGroup definition */", "refactored_code": "\tprivate static final int GRP_GENERAL_ID = ++GRP_COUNT;\n\tprivate static final PropertyGroups mGroups = new PropertyGroups();\n\n\t/** Global PropertyGroup definition */\n\tpublic static final PropertyGroup GRP_GENERAL = mGroups.addGroup(GRP_GENERAL_ID, R.string.general, 0);\n\t/** Global PropertyGroup definition */\n\tpublic static final PropertyGroup GRP_EXTRA_BOOK_DETAILS = mGroups.addGroup(GRP_EXTRA_BOOK_DETAILS_ID, R.string.extra_book_details, 100);\n\t/** Global PropertyGroup definition */"}
{"magic_number_smell": "\t * Build the collection\n\t */\n\tstatic {\n\t\tmyScannerFactories.put(1, new ScannerFactory() {\n\t\t\t@Override\n\t\t\tpublic Scanner newInstance() {\n\t\t\t\treturn new ZxingScanner(false);", "refactored_code": "\tpublic static final int SCANNER_ZXING_COMPATIBLE = 1;\n\t * Build the collection\n\t */\n\tstatic {\n\t\tmyScannerFactories.put(SCANNER_ZXING_COMPATIBLE, new ScannerFactory() {\n\t\t\t@Override\n\t\t\tpublic Scanner newInstance() {\n\t\t\t\treturn new ZxingScanner(false);"}
{"magic_number_smell": "    \t\n    \t//System.out.println(\"State: \" + state);\n        switch (state) {\n            case 0:\n                mHandler.removeCallbacks(mScrollFade);\n                mList.invalidate();\n                break;", "refactored_code": "    private static final int STATE_NONE = 0;\n    \t\n    \t//System.out.println(\"State: \" + state);\n        switch (state) {\n            case STATE_NONE:\n                mHandler.removeCallbacks(mScrollFade);\n                mList.invalidate();\n                break;"}
{"magic_number_smell": "\t@Override\n\tpublic boolean onInterceptTouchEvent(MotionEvent ev) {\n\t\t\tif (mRemoveListener != null && mGestureDetector == null) {\n\t\t\t\t\tif (mRemoveMode == 0) {\n\t\t\t\t\t\t\tmGestureDetector = new GestureDetector(getContext(), new SimpleOnGestureListener() {\n\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\tpublic boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX,", "refactored_code": "\tpublic static final int FLING = 0;\n\t@Override\n\tpublic boolean onInterceptTouchEvent(MotionEvent ev) {\n\t\t\tif (mRemoveListener != null && mGestureDetector == null) {\n\t\t\t\t\tif (mRemoveMode == FLING) {\n\t\t\t\t\t\t\tmGestureDetector = new GestureDetector(getContext(), new SimpleOnGestureListener() {\n\t\t\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\t\t\tpublic boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX,"}
{"magic_number_smell": "    {\n        private ArrayList<Location> locations = new ArrayList<>();\n        private Map<RiakOption<?>, Object> options = new HashMap<>();\n        private int maxInFlight = 10;\n\n        /**\n         * Add a location to the list of locations to interact with as part of", "refactored_code": "    private static final int DEFAULT_MAX_IN_FLIGHT = 10;\n    {\n        private ArrayList<Location> locations = new ArrayList<>();\n        private Map<RiakOption<?>, Object> options = new HashMap<>();\n        private int maxInFlight = DEFAULT_MAX_IN_FLIGHT;\n\n        /**\n         * Add a location to the list of locations to interact with as part of"}
{"magic_number_smell": "    @Override\n    protected RiakMessage createChannelMessage()\n    {\n        return new RiakMessage(RiakMessageCodes.MSG_TsTtbMsg, requestBuilder.build(), false);\n    }\n\n    @Override", "refactored_code": "    protected final byte reqMessageCode = RiakMessageCodes.MSG_TsTtbMsg;\n    @Override\n    protected RiakMessage createChannelMessage()\n    {\n        return new RiakMessage(reqMessageCode, requestBuilder.build(), false);\n    }\n\n    @Override"}
{"magic_number_smell": "\n    private void initVarchar(String stringValue)\n    {\n        setBitfieldType(0x00000001);\n        this.varcharValue = stringValue;\n    }\n", "refactored_code": "    private static final int VARCHAR_MASK = 0x00000001;\n\n    private void initVarchar(String stringValue)\n    {\n        setBitfieldType(VARCHAR_MASK);\n        this.varcharValue = stringValue;\n    }\n"}
{"magic_number_smell": "      /**\n       * <code>COUNTER = 1;</code>\n       */\n      public static final int 1 = 1;\n      /**\n       * <code>SET = 2;</code>\n       */", "refactored_code": "      public static final int COUNTER_VALUE = 1;\n      /**\n       * <code>COUNTER = 1;</code>\n       */\n      public static final int COUNTER_VALUE = 1;\n      /**\n       * <code>SET = 2;</code>\n       */"}
{"magic_number_smell": "    }\n\n    private int bitField0_;\n    public static final int 1 = 1;\n    private com.google.protobuf.ByteString clientId_;\n    /**\n     * <code>required bytes client_id = 1;</code>", "refactored_code": "    public static final int CLIENT_ID_FIELD_NUMBER = 1;\n    }\n\n    private int bitField0_;\n    public static final int CLIENT_ID_FIELD_NUMBER = 1;\n    private com.google.protobuf.ByteString clientId_;\n    /**\n     * <code>required bytes client_id = 1;</code>"}
{"magic_number_smell": "    }\n\n    private int bitField0_;\n    public static final int 1 = 1;\n    private com.google.protobuf.ByteString name_;\n    /**\n     * <code>optional bytes name = 1;</code>", "refactored_code": "    public static final int NAME_FIELD_NUMBER = 1;\n    }\n\n    private int bitField0_;\n    public static final int NAME_FIELD_NUMBER = 1;\n    private com.google.protobuf.ByteString name_;\n    /**\n     * <code>optional bytes name = 1;</code>"}
{"magic_number_smell": "                // ChunkedResponseIterator polls the response queue when created,\n                // so we'll use that to simulate a Thread interrupt.\n                new ChunkedResponseIterator<>(coreFuture,\n                                              1000,\n                                              Long::new,\n                                              FakeResponse::iterator);\n            }", "refactored_code": "    private final int timeout = 1000;\n                // ChunkedResponseIterator polls the response queue when created,\n                // so we'll use that to simulate a Thread interrupt.\n                new ChunkedResponseIterator<>(coreFuture,\n                                              timeout,\n                                              Long::new,\n                                              FakeResponse::iterator);\n            }"}
{"magic_number_smell": "    public Acceptor(ServerSocketChannel server)\n    {\n        this.server = server;\n        this.readBuffer = ByteBuffer.allocate(4096);\n\n        RiakKvPB.RpbContent content = RiakKvPB.RpbContent.newBuilder()\n                                      .setValue(ByteString.copyFromUtf8(\"This is a value!\"))", "refactored_code": "    public static final int DEFAULT_BUFFER_SIZE = 4096;\n    public Acceptor(ServerSocketChannel server)\n    {\n        this.server = server;\n        this.readBuffer = ByteBuffer.allocate(DEFAULT_BUFFER_SIZE);\n\n        RiakKvPB.RpbContent content = RiakKvPB.RpbContent.newBuilder()\n                                      .setValue(ByteString.copyFromUtf8(\"This is a value!\"))"}
{"magic_number_smell": "        {\n            Namespace yokoNamespace = getYokoNamespace(bucketName);\n\n            setupYokoIndexAndBucketProps(client, yokoNamespace, indexName, 45000);\n            setupData(client, yokoNamespace);\n        }\n", "refactored_code": "    public static final int DEFAULT_STORE_INDEX_TIMEOUT = 45000;\n        {\n            Namespace yokoNamespace = getYokoNamespace(bucketName);\n\n            setupYokoIndexAndBucketProps(client, yokoNamespace, indexName, DEFAULT_STORE_INDEX_TIMEOUT);\n            setupData(client, yokoNamespace);\n        }\n"}
{"magic_number_smell": "        RiakNode.Builder builder = new RiakNode.Builder()\n                                        .withRemoteAddress(hostname)\n                                        .withRemotePort(pbcPort)\n                                        .withMinConnections(10);\n\n        if (security)\n        {", "refactored_code": "    protected static final int NUMBER_OF_PARALLEL_REQUESTS = 10;\n        RiakNode.Builder builder = new RiakNode.Builder()\n                                        .withRemoteAddress(hostname)\n                                        .withRemotePort(pbcPort)\n                                        .withMinConnections(NUMBER_OF_PARALLEL_REQUESTS);\n\n        if (security)\n        {"}
{"magic_number_smell": "public class ITestSecondaryIndexQueryOp extends ITestBase\n{\n    private static final long new Random().nextLong() = new Random().nextLong();\n    private static final String bucketName = \"ITestSecondaryIndexQueryOp\" + new Random().nextLong();\n\n    private static final Namespace defaultTypeNamespace = new Namespace(bucketName);\n    private static final Namespace typedNamespace = new Namespace(bucketType.toString(), bucketName);", "refactored_code": "    private static final long bucketSeed = new Random().nextLong();\npublic class ITestSecondaryIndexQueryOp extends ITestBase\n{\n    private static final long bucketSeed = new Random().nextLong();\n    private static final String bucketName = \"ITestSecondaryIndexQueryOp\" + bucketSeed;\n\n    private static final Namespace defaultTypeNamespace = new Namespace(bucketName);\n    private static final Namespace typedNamespace = new Namespace(bucketType.toString(), bucketName);"}
{"magic_number_smell": "    {\n        RiakNode.Builder builder = new RiakNode.Builder();\n        builder.withMinConnections(1);\n        builder.withRemotePort(Integer.getInteger(\"com.basho.riak.pbcport\", RiakNode.Builder.DEFAULT_REMOTE_PORT));\n        return builder;\n    }\n}", "refactored_code": "    private static final int testRiakPort = Integer.getInteger(\"com.basho.riak.pbcport\", RiakNode.Builder.DEFAULT_REMOTE_PORT);\n    {\n        RiakNode.Builder builder = new RiakNode.Builder();\n        builder.withMinConnections(1);\n        builder.withRemotePort(testRiakPort);\n        return builder;\n    }\n}"}
{"magic_number_smell": "    {\n        RiakNode.Builder builder = new RiakNode.Builder();\n        builder.withMinConnections(1);\n        builder.withRemotePort(Integer.getInteger(\"com.basho.riak.pbcport\", RiakNode.Builder.DEFAULT_REMOTE_PORT));\n        return builder;\n    }\n", "refactored_code": "    private static final int testRiakPort = Integer.getInteger(\"com.basho.riak.pbcport\", RiakNode.Builder.DEFAULT_REMOTE_PORT);\n    {\n        RiakNode.Builder builder = new RiakNode.Builder();\n        builder.withMinConnections(1);\n        builder.withRemotePort(testRiakPort);\n        return builder;\n    }\n"}
{"magic_number_smell": "    private final String tableName = \"my_table\";\n    private final List<Cell> keyValues = Arrays.asList(new Cell(\"my_family\"),\n                                                             new Cell(\"my_series\"),\n                                                             Cell.newTimestamp(1443796900000L),\n                                                             null);\n\n    @Test", "refactored_code": "    private final long now = 1443796900000L; // \"now\"\n    private final String tableName = \"my_table\";\n    private final List<Cell> keyValues = Arrays.asList(new Cell(\"my_family\"),\n                                                             new Cell(\"my_series\"),\n                                                             Cell.newTimestamp(now),\n                                                             null);\n\n    @Test"}
{"magic_number_smell": "    private final long 1443796900000L = 1443796900000L; // \"1443796900000L\"\n    private final String tableName = \"my_table\";\n    private final List<Cell> keyValues = Arrays.asList(\n            new Cell(\"my_family\"), new Cell(\"my_series\"), Cell.newTimestamp(1443796900000L), null);\n\n    @Test\n    public void shouldBuildADescriptiveQueryInfoString()", "refactored_code": "    private final long now = 1443796900000L; // \"now\"\n    private final long now = 1443796900000L; // \"now\"\n    private final String tableName = \"my_table\";\n    private final List<Cell> keyValues = Arrays.asList(\n            new Cell(\"my_family\"), new Cell(\"my_series\"), Cell.newTimestamp(now), null);\n\n    @Test\n    public void shouldBuildADescriptiveQueryInfoString()"}
{"magic_number_smell": "    private void launchPatternLock() {\n        Intent intent = new Intent(this, ConfirmLockPattern.class);\n        intent.putExtra(ConfirmLockPattern.HEADER_TEXT, getText(R.string.patternlock_header));\n        startActivityForResult(intent, 42);\n    }\n\n    private void writeLockTime() {", "refactored_code": "    private static final int PATTERNLOCK_UNLOCK = 42;\n    private void launchPatternLock() {\n        Intent intent = new Intent(this, ConfirmLockPattern.class);\n        intent.putExtra(ConfirmLockPattern.HEADER_TEXT, getText(R.string.patternlock_header));\n        startActivityForResult(intent, PATTERNLOCK_UNLOCK);\n    }\n\n    private void writeLockTime() {"}
{"magic_number_smell": "    private void launchPatternLock() {\n        Intent intent = new Intent(this, ConfirmLockPattern.class);\n        intent.putExtra(ConfirmLockPattern.HEADER_TEXT, getText(R.string.patternlock_header));\n        startActivityForResult(intent, 42);\n    }\n\n    private void writeLockTime() {", "refactored_code": "    private static final int PATTERNLOCK_UNLOCK = 42;\n    private void launchPatternLock() {\n        Intent intent = new Intent(this, ConfirmLockPattern.class);\n        intent.putExtra(ConfirmLockPattern.HEADER_TEXT, getText(R.string.patternlock_header));\n        startActivityForResult(intent, PATTERNLOCK_UNLOCK);\n    }\n\n    private void writeLockTime() {"}
{"magic_number_smell": "    // already\n    private void postClearPatternRunnable() {\n        mLockPatternView.removeCallbacks(mClearPatternRunnable);\n        mLockPatternView.postDelayed(mClearPatternRunnable, 2000);\n    }\n\n    private void saveChosenPatternAndFinish() {", "refactored_code": "    private static final int WRONG_PATTERN_CLEAR_TIMEOUT_MS = 2000;\n    // already\n    private void postClearPatternRunnable() {\n        mLockPatternView.removeCallbacks(mClearPatternRunnable);\n        mLockPatternView.postDelayed(mClearPatternRunnable, WRONG_PATTERN_CLEAR_TIMEOUT_MS);\n    }\n\n    private void saveChosenPatternAndFinish() {"}
{"magic_number_smell": "        } else if (v == mNextButton) {\n            stopAnimation(mAnimation);\n            Intent intent = new Intent(this, ChooseLockPattern.class);\n            startActivityForResult(intent, 1);\n        }\n    }\n", "refactored_code": "    private static final int REQUESTCODE_CHOOSE = 1;\n        } else if (v == mNextButton) {\n            stopAnimation(mAnimation);\n            Intent intent = new Intent(this, ChooseLockPattern.class);\n            startActivityForResult(intent, REQUESTCODE_CHOOSE);\n        }\n    }\n"}
{"magic_number_smell": "            finish();\n        } else if (v == mNextButton) {\n            startActivityForResult(new Intent(this, ChooseLockPatternExample.class),\n                    1);\n        }\n    }\n", "refactored_code": "    private static final int REQUESTCODE_EXAMPLE = 1;\n            finish();\n        } else if (v == mNextButton) {\n            startActivityForResult(new Intent(this, ChooseLockPatternExample.class),\n                    REQUESTCODE_EXAMPLE);\n        }\n    }\n"}
{"magic_number_smell": "    // already\n    private void postClearPatternRunnable() {\n        mLockPatternView.removeCallbacks(mClearPatternRunnable);\n        mLockPatternView.postDelayed(mClearPatternRunnable, 2000);\n    }\n\n    private void handleAttemptLockout(long elapsedRealtimeDeadline) {", "refactored_code": "    private static final int WRONG_PATTERN_CLEAR_TIMEOUT_MS = 2000;\n    // already\n    private void postClearPatternRunnable() {\n        mLockPatternView.removeCallbacks(mClearPatternRunnable);\n        mLockPatternView.postDelayed(mClearPatternRunnable, WRONG_PATTERN_CLEAR_TIMEOUT_MS);\n    }\n\n    private void handleAttemptLockout(long elapsedRealtimeDeadline) {"}
{"magic_number_smell": "    /**\n     * The minimum number of dots the user must include in a wrong pattern\n     * attempt for it to be counted against the counts that affect\n     * {@link #5} and {@link #FAILED_ATTEMPTS_BEFORE_RESET}\n     */\n    public static final int MIN_PATTERN_REGISTER_FAIL = 3;\n", "refactored_code": "    public static final int FAILED_ATTEMPTS_BEFORE_TIMEOUT = 5;\n    /**\n     * The minimum number of dots the user must include in a wrong pattern\n     * attempt for it to be counted against the counts that affect\n     * {@link #FAILED_ATTEMPTS_BEFORE_TIMEOUT} and {@link #FAILED_ATTEMPTS_BEFORE_RESET}\n     */\n    public static final int MIN_PATTERN_REGISTER_FAIL = 3;\n"}
{"magic_number_smell": "            // figure out which circles to draw\n\n            // + 1 so we pause on complete pattern\n            final int oneCycle = (count + 1) * 700;\n            final int spotInCycle = (int) (SystemClock.elapsedRealtime() -\n                    mAnimatingPeriodStart) % oneCycle;\n            final int numCircles = spotInCycle / 700;", "refactored_code": "    private static final int MILLIS_PER_CIRCLE_ANIMATING = 700;\n            // figure out which circles to draw\n\n            // + 1 so we pause on complete pattern\n            final int oneCycle = (count + 1) * MILLIS_PER_CIRCLE_ANIMATING;\n            final int spotInCycle = (int) (SystemClock.elapsedRealtime() -\n                    mAnimatingPeriodStart) % oneCycle;\n            final int numCircles = spotInCycle / MILLIS_PER_CIRCLE_ANIMATING;"}
{"magic_number_smell": "\n        @Override\n        protected Bank getBankFromDb(long bankId, Context parent) {\n            Assert.assertEquals(5, bankId);\n            return banks[0];\n        }\n", "refactored_code": "    private static final int BANK_ID = 5;\n\n        @Override\n        protected Bank getBankFromDb(long bankId, Context parent) {\n            Assert.assertEquals(BANK_ID, bankId);\n            return banks[0];\n        }\n"}
{"magic_number_smell": "    }\n\n    public int getInputTypeExtras() {\n        return InputType.TYPE_CLASS_TEXT;\n    }\n\n    public String getInputHintUsername() {", "refactored_code": "    private static final int INPUT_TYPE_EXTRAS = InputType.TYPE_CLASS_TEXT;\n    }\n\n    public int getInputTypeExtras() {\n        return INPUT_TYPE_EXTRAS;\n    }\n\n    public String getInputHintUsername() {"}
{"magic_number_smell": "\n    public AbsIkanoPartner(Context context, @DrawableRes int logoResource) {\n        super(context, logoResource);\n        super.inputTypeUsername = InputType.TYPE_CLASS_PHONE;\n        super.inputTypePassword = INPUT_TYPE_PASSWORD;\n        super.inputHintUsername = INPUT_HINT_USERNAME;\n        super.staticBalance = true;", "refactored_code": "    private static final int INPUT_TYPE_USERNAME = InputType.TYPE_CLASS_PHONE;\n\n    public AbsIkanoPartner(Context context, @DrawableRes int logoResource) {\n        super(context, logoResource);\n        super.inputTypeUsername = INPUT_TYPE_USERNAME;\n        super.inputTypePassword = INPUT_TYPE_PASSWORD;\n        super.inputHintUsername = INPUT_HINT_USERNAME;\n        super.staticBalance = true;"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return IBankTypes.AKELIUSINVEST;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = IBankTypes.AKELIUSINVEST;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return IBankTypes.AKELIUSSPAR;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = IBankTypes.AKELIUSSPAR;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return Bank.APPEAKPOKER;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = Bank.APPEAKPOKER;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return IBankTypes.BETTERGLOBE;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = IBankTypes.BETTERGLOBE;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return Bank.BIOKLUBBEN;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = Bank.BIOKLUBBEN;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return IBankTypes.BLEKINGETRAFIKEN;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = IBankTypes.BLEKINGETRAFIKEN;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return IBankTypes.BRUMMER_KF;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = IBankTypes.BRUMMER_KF;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return IBankTypes.CHALMREST;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = IBankTypes.CHALMREST;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return IBankTypes.CSN;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = IBankTypes.CSN;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return IBankTypes.DANSKEBANK;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = IBankTypes.DANSKEBANK;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return IBankTypes.EVERYDAYCARD;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = IBankTypes.EVERYDAYCARD;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return IBankTypes.FIRSTCARD;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = IBankTypes.FIRSTCARD;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return IBankTypes.HEMKOP;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = IBankTypes.HEMKOP;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return IBankTypes.HORS;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = IBankTypes.HORS;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return Bank.IKEA;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = Bank.IKEA;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return IBankTypes.JOJO;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = IBankTypes.JOJO;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return Bank.MCDONALDS;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = Bank.MCDONALDS;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return IBankTypes.MENIGA;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = IBankTypes.MENIGA;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return IBankTypes.NORDNET;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = IBankTypes.NORDNET;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return IBankTypes.OKQ8;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = IBankTypes.OKQ8;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return IBankTypes.OSTGOTATRAFIKEN;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = IBankTypes.OSTGOTATRAFIKEN;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return IBankTypes.OSUUSPANKKI;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = IBankTypes.OSUUSPANKKI;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return IBankTypes.PAYSON;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = IBankTypes.PAYSON;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return IBankTypes.PLUSGIROT;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = IBankTypes.PLUSGIROT;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return IBankTypes.SEVENDAY;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = IBankTypes.SEVENDAY;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return IBankTypes.SVEADIREKT;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = IBankTypes.SVEADIREKT;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return Bank.SVENSKASPEL;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = Bank.SVENSKASPEL;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return IBankTypes.TESTBANK;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = IBankTypes.TESTBANK;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return Bank.RIKSKORTET;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = Bank.RIKSKORTET;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return IBankTypes.VASTTRAFIK;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = IBankTypes.VASTTRAFIK;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return IBankTypes.ZIDISHA;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = IBankTypes.ZIDISHA;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return IBankTypes.AMERICANEXPRESS;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = IBankTypes.AMERICANEXPRESS;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return IBankTypes.BITCOIN;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = IBankTypes.BITCOIN;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return IBankTypes.COOP;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = IBankTypes.COOP;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return IBankTypes.LANSFORSAKRINGAR;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = IBankTypes.LANSFORSAKRINGAR;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return IBankTypes.NORDEA;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = IBankTypes.NORDEA;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getBanktypeId() {\n        return Bank.RIKSLUNCHEN;\n    }\n\n    @Override", "refactored_code": "    private static final int BANKTYPE_ID = Bank.RIKSLUNCHEN;\n\n    @Override\n    public int getBanktypeId() {\n        return BANKTYPE_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n\tpublic File build(Config c) throws IOException {\n\t\t_sb.append(\"LANGUAGE \");\n\t\t_sb.append(0);\n\t\t_sb.append(\", \");\n\t\t_sb.append(SUBLANG_DEFAULT);\n\t\t_sb.append('\\n');", "refactored_code": "\tpublic static final int LANG_NEUTRAL = 0;\n\n\tpublic File build(Config c) throws IOException {\n\t\t_sb.append(\"LANGUAGE \");\n\t\t_sb.append(LANG_NEUTRAL);\n\t\t_sb.append(\", \");\n\t\t_sb.append(SUBLANG_DEFAULT);\n\t\t_sb.append('\\n');"}
{"magic_number_smell": "  {\n    setLayout( new BorderLayout() );\n    setOpaque( false );\n    setPreferredSize( new Dimension(1280, PHEIGHT));\n\n    GraphicsConfiguration config =\n\t\t\t\t\tSimpleUniverse.getPreferredConfiguration();", "refactored_code": "  private static final int PWIDTH = 1280;   // size of panel\n  {\n    setLayout( new BorderLayout() );\n    setOpaque( false );\n    setPreferredSize( new Dimension(PWIDTH, PHEIGHT));\n\n    GraphicsConfiguration config =\n\t\t\t\t\tSimpleUniverse.getPreferredConfiguration();"}
{"magic_number_smell": "    if (e.getSource() == saveBut)   // save coord info\n      w3d.saveCoordFile();\n    else if (e.getSource() == xPosLeftBut)   // X move\n      w3d.movePos(0, DECR);\n    else if (e.getSource() == xPosRightBut)\n      w3d.movePos(0, INCR);\n    else if (e.getSource() == yPosLeftBut)   // Y move", "refactored_code": "  private static final int X_AXIS = 0;\n    if (e.getSource() == saveBut)   // save coord info\n      w3d.saveCoordFile();\n    else if (e.getSource() == xPosLeftBut)   // X move\n      w3d.movePos(X_AXIS, DECR);\n    else if (e.getSource() == xPosRightBut)\n      w3d.movePos(X_AXIS, INCR);\n    else if (e.getSource() == yPosLeftBut)   // Y move"}
{"magic_number_smell": "        break;\n      }\n      if (rotNum == 1)         // positive x-axis rotation\n        rotate(0, INCR);   \n      else if (rotNum == 2)    // negative\n        rotate(0, DECR);\n      else if (rotNum == 3)    // positive y-axis rotation", "refactored_code": "  private static final int X_AXIS = 0;\n        break;\n      }\n      if (rotNum == 1)         // positive x-axis rotation\n        rotate(X_AXIS, INCR);   \n      else if (rotNum == 2)    // negative\n        rotate(X_AXIS, DECR);\n      else if (rotNum == 3)    // positive y-axis rotation"}
{"magic_number_smell": "  {\n    setLayout( new BorderLayout() );\n    setOpaque( false );\n    setPreferredSize( new Dimension(512, PHEIGHT));\n\n    // load the object (the prop) and optional placement info\n    propMan = new PropManager(filename, hasCoordsInfo);", "refactored_code": "  private static final int PWIDTH = 512;   // size of panel\n  {\n    setLayout( new BorderLayout() );\n    setOpaque( false );\n    setPreferredSize( new Dimension(PWIDTH, PHEIGHT));\n\n    // load the object (the prop) and optional placement info\n    propMan = new PropManager(filename, hasCoordsInfo);"}
{"magic_number_smell": "    this.adaptNo = adaptNo;\n    setLayout( new BorderLayout() );\n    setOpaque( false );\n    setPreferredSize( new Dimension(512, PHEIGHT));\n\n    GraphicsConfiguration config =\n\t\t\t\t\tSimpleUniverse.getPreferredConfiguration();", "refactored_code": "  private static final int PWIDTH = 512;   // size of panel\n    this.adaptNo = adaptNo;\n    setLayout( new BorderLayout() );\n    setOpaque( false );\n    setPreferredSize( new Dimension(PWIDTH, PHEIGHT));\n\n    GraphicsConfiguration config =\n\t\t\t\t\tSimpleUniverse.getPreferredConfiguration();"}
{"magic_number_smell": "            delayBeteenCardsInSec,\n            false,\n            true);\n        cardPlayerContext.setCurrentCard(helper.getCardDao().queryForId(5));\n    }\n\n    @SmallTest", "refactored_code": "    private final int TEST_CARD_ID = 5;\n            delayBeteenCardsInSec,\n            false,\n            true);\n        cardPlayerContext.setCurrentCard(helper.getCardDao().queryForId(TEST_CARD_ID));\n    }\n\n    @SmallTest"}
{"magic_number_smell": "    /* Package private constructor used in Manager. */\n    AnyMemoDBOpenHelper(Context context, String dbpath) {\n        // R.raw.ormlite_config is used to accelerate the DAO creation.\n        super(context, dbpath, null, 5);\n        this.dbPath = dbpath;\n    }\n", "refactored_code": "    private static final int CURRENT_VERSION = 5;\n    /* Package private constructor used in Manager. */\n    AnyMemoDBOpenHelper(Context context, String dbpath) {\n        // R.raw.ormlite_config is used to accelerate the DAO creation.\n        super(context, dbpath, null, CURRENT_VERSION);\n        this.dbPath = dbpath;\n    }\n"}
{"magic_number_smell": "\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        if (requestCode == 1 && resultCode == Activity.RESULT_OK) {\n            refreshList();\n        }\n        super.onActivityResult(requestCode, resultCode, data);", "refactored_code": "    private static final int OPEN_UPLOAD_DROPBOX_REQUEST_CODE = 1;\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        if (requestCode == OPEN_UPLOAD_DROPBOX_REQUEST_CODE && resultCode == Activity.RESULT_OK) {\n            refreshList();\n        }\n        super.onActivityResult(requestCode, resultCode, data);"}
{"magic_number_smell": "\n    static {\n        // Get the count of the cards in the db\n        sUriMatcher.addURI(AUTHORITY, \"*/count\", 1);\n\n        // Get a number of random cards\n        sUriMatcher.addURI(AUTHORITY, \"*/random/#\", RANDOM_URI);", "refactored_code": "    private static final int COUNT_URI = 1;\n\n    static {\n        // Get the count of the cards in the db\n        sUriMatcher.addURI(AUTHORITY, \"*/count\", COUNT_URI);\n\n        // Get a number of random cards\n        sUriMatcher.addURI(AUTHORITY, \"*/random/#\", RANDOM_URI);"}
{"magic_number_smell": "    }\n\n    private synchronized void refill(Category category) {\n        newCache.addAll(cardDao.getCardsByCategory(category, false, 500));\n    }\n\n    public int getNewQueueSize() {", "refactored_code": "    private static final int MAX_QUEUE_SIZE = 500;\n    }\n\n    private synchronized void refill(Category category) {\n        newCache.addAll(cardDao.getCardsByCategory(category, false, MAX_QUEUE_SIZE));\n    }\n\n    public int getNewQueueSize() {"}
{"magic_number_smell": "        int alarmReq = extras.getInt(\"request_code\", 0);\n\n        Log.v(TAG, \"Receive req: \" + Integer.toString(alarmReq));\n        if ((alarmReq & 1) != 0) {\n            Log.v(TAG, \"ALARM NOTIFICATION_ALARM\");\n\n            notificationUtil.showNotification();", "refactored_code": "    public static final int ALARM_SHOW_NOTIFICATION = 1;\n        int alarmReq = extras.getInt(\"request_code\", 0);\n\n        Log.v(TAG, \"Receive req: \" + Integer.toString(alarmReq));\n        if ((alarmReq & ALARM_SHOW_NOTIFICATION) != 0) {\n            Log.v(TAG, \"ALARM NOTIFICATION_ALARM\");\n\n            notificationUtil.showNotification();"}
{"magic_number_smell": "\n        // Basically make the service foreground so a notification is shown\n        // And the service is less susceptible to be kill by Android system.\n        startForeground(9283372, mBuilder.build());\n    }\n\n    /*", "refactored_code": "    private static final int NOTIFICATION_ID = 9283372;\n\n        // Basically make the service foreground so a notification is shown\n        // And the service is less susceptible to be kill by Android system.\n        startForeground(NOTIFICATION_ID, mBuilder.build());\n    }\n\n    /*"}
{"magic_number_smell": "\n        String conversionFileInfo = \"\" + FilenameUtils.getName(inputFilePath) + \" -> \" + FilenameUtils.getName(outputFilePath);\n\n        int notificationId = 294 + inputFilePath.hashCode();\n\n        showInProgressNotification(notificationId, conversionFileInfo);\n        try {", "refactored_code": "    private static final int CONVERSION_PROGRESS_NOTIFICATION_ID_BASE = 294;\n\n        String conversionFileInfo = \"\" + FilenameUtils.getName(inputFilePath) + \" -> \" + FilenameUtils.getName(outputFilePath);\n\n        int notificationId = CONVERSION_PROGRESS_NOTIFICATION_ID_BASE + inputFilePath.hashCode();\n\n        showInProgressNotification(notificationId, conversionFileInfo);\n        try {"}
{"magic_number_smell": "\n    public void onInit(int status){\n        try {\n            if (initLock.tryLock() || initLock.tryLock(10L, TimeUnit.SECONDS)) {\n                initLock.unlock();\n\n", "refactored_code": "    private static final long INIT_LOCK_TIMEOUT = 10L;\n\n    public void onInit(int status){\n        try {\n            if (initLock.tryLock() || initLock.tryLock(INIT_LOCK_TIMEOUT, TimeUnit.SECONDS)) {\n                initLock.unlock();\n\n"}
{"magic_number_smell": "                != PackageManager.PERMISSION_GRANTED) {\n            ActivityCompat.requestPermissions(this,\n                    new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},\n                    1);\n        } else {\n            loadUiComponents();\n        }", "refactored_code": "    private static final int PERMISSION_REQUEST_EXTERNAL_STORAGE = 1;\n                != PackageManager.PERMISSION_GRANTED) {\n            ActivityCompat.requestPermissions(this,\n                    new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},\n                    PERMISSION_REQUEST_EXTERNAL_STORAGE);\n        } else {\n            loadUiComponents();\n        }"}
{"magic_number_smell": "                if(focusView == questionEdit || focusView ==answerEdit || focusView == noteEdit){\n                    Intent myIntent = new Intent(this, FileBrowserActivity.class);\n                    myIntent.putExtra(FileBrowserActivity.EXTRA_FILE_EXTENSIONS, \".png,.jpg,.tif,.bmp\");\n                    startActivityForResult(myIntent, 1);\n                }\n                return true;\n", "refactored_code": "    private static final int ACTIVITY_IMAGE_FILE = 1;\n                if(focusView == questionEdit || focusView ==answerEdit || focusView == noteEdit){\n                    Intent myIntent = new Intent(this, FileBrowserActivity.class);\n                    myIntent.putExtra(FileBrowserActivity.EXTRA_FILE_EXTENSIONS, \".png,.jpg,.tif,.bmp\");\n                    startActivityForResult(myIntent, ACTIVITY_IMAGE_FILE);\n                }\n                return true;\n"}
{"magic_number_smell": "        cardTextUtil = new CardTextUtil(getApplicationContext(), amFileUtil, imageSearchPaths);\n\n        // Use loader to load the cards.\n        multipleLoaderManager.registerLoaderCallbacks(0, new CardWrapperLoaderCallbacks(), false);\n        multipleLoaderManager.setOnAllLoaderCompletedRunnable(onPostInitRunnable);\n        multipleLoaderManager.startLoading();\n    }", "refactored_code": "    private static final int CARD_WRAPPER_LOADER_ID = 0;\n        cardTextUtil = new CardTextUtil(getApplicationContext(), amFileUtil, imageSearchPaths);\n\n        // Use loader to load the cards.\n        multipleLoaderManager.registerLoaderCallbacks(CARD_WRAPPER_LOADER_ID, new CardWrapperLoaderCallbacks(), false);\n        multipleLoaderManager.setOnAllLoaderCompletedRunnable(onPostInitRunnable);\n        multipleLoaderManager.startLoading();\n    }"}
{"magic_number_smell": "\n        textViewQA = (TextView) v.findViewById(R.id.card_player_qa_sleep_interval_text);\n        seekBarQA = (SeekBar) v.findViewById(R.id.card_player_qa_sleep_interval_seekbar);\n        qaSleepTime = settings.getInt(AMPrefKeys.CARD_PLAYER_QA_SLEEP_INTERVAL_KEY, 1);\n        textViewQA.setText(String.format(getString(R.string.card_player_qa_sleep_interval_text), qaSleepTime));\n\n        seekBarQA.setProgress(qaSleepTime);", "refactored_code": "    private static final int DEFAULT_QA_SLEEP_TIME_IN_SEC = 1;\n\n        textViewQA = (TextView) v.findViewById(R.id.card_player_qa_sleep_interval_text);\n        seekBarQA = (SeekBar) v.findViewById(R.id.card_player_qa_sleep_interval_seekbar);\n        qaSleepTime = settings.getInt(AMPrefKeys.CARD_PLAYER_QA_SLEEP_INTERVAL_KEY, DEFAULT_QA_SLEEP_TIME_IN_SEC);\n        textViewQA.setText(String.format(getString(R.string.card_player_qa_sleep_interval_text), qaSleepTime));\n\n        seekBarQA.setProgress(qaSleepTime);"}
{"magic_number_smell": "        Log.v(TAG, \"Return activity NOT CANCELLED\");\n        /* Refresh the activity according to activities */\n        switch(requestCode){\n            case 1:\n            {\n                String dbPath = data.getStringExtra(FileBrowserActivity.EXTRA_RESULT_PATH);\n                targetEdit.setText(dbPath);", "refactored_code": "    private static final int ACTIVITY_FB_TARGET = 1;\n        Log.v(TAG, \"Return activity NOT CANCELLED\");\n        /* Refresh the activity according to activities */\n        switch(requestCode){\n            case ACTIVITY_FB_TARGET:\n            {\n                String dbPath = data.getStringExtra(FileBrowserActivity.EXTRA_RESULT_PATH);\n                targetEdit.setText(dbPath);"}
{"magic_number_smell": "\n        /* Refresh the activity according to activities */\n        switch(requestCode){\n            case 11:\n            {\n                Bundle extras = data.getExtras();\n                int cardId = extras.getInt(CardEditor.EXTRA_RESULT_CARD_ID, 1);", "refactored_code": "    private static final int ACTIVITY_EDIT = 11;\n\n        /* Refresh the activity according to activities */\n        switch(requestCode){\n            case ACTIVITY_EDIT:\n            {\n                Bundle extras = data.getExtras();\n                int cardId = extras.getInt(CardEditor.EXTRA_RESULT_CARD_ID, 1);"}
{"magic_number_smell": "        // Load gestures\n        loadGestures();\n\n        multipleLoaderManager.registerLoaderCallbacks(0,\n                new SettingLoaderCallbacks(), false);\n        multipleLoaderManager.registerLoaderCallbacks(CARD_TTS_UTIL_LOADER_ID,\n                new CardTTSUtilLoaderCallbacks(), true);", "refactored_code": "    private static final int SETTING_LOADER_ID = 0;\n        // Load gestures\n        loadGestures();\n\n        multipleLoaderManager.registerLoaderCallbacks(SETTING_LOADER_ID,\n                new SettingLoaderCallbacks(), false);\n        multipleLoaderManager.registerLoaderCallbacks(CARD_TTS_UTIL_LOADER_ID,\n                new CardTTSUtilLoaderCallbacks(), true);"}
{"magic_number_smell": "        if (totalCardNumber < groupSize) {\n            groupSize = totalCardNumber;\n        }\n        int maxGroupSize = Math.min(totalCardNumber, 100);\n\n        //  If maxGroupNumberis 0, Math.min(maxGroupSize, 1) will display 0\n        quizGroupSizeTitle.setText(getString(R.string.quiz_group_size_text)", "refactored_code": "    private static final int MAX_GROUP_SIZE = 100;\n        if (totalCardNumber < groupSize) {\n            groupSize = totalCardNumber;\n        }\n        int maxGroupSize = Math.min(totalCardNumber, MAX_GROUP_SIZE);\n\n        //  If maxGroupNumberis 0, Math.min(maxGroupSize, 1) will display 0\n        quizGroupSizeTitle.setText(getString(R.string.quiz_group_size_text)"}
{"magic_number_smell": "\n        if (currentColor != null) {\n            colorPickerView.setColor(currentColor);\n        } else if (spinnerPos == 0 || spinnerPos == ANSWER_TEXT_SPINNER_POS) {\n            colorPickerView.setColor(defaultTextColor);\n        } else if (spinnerPos == QUESTION_BACKGROUND_SPINNER_POS|| spinnerPos == ANSWER_BACKGROUND_SPINNER_POS) {\n            colorPickerView.setColor(defaultBackgroundColor);", "refactored_code": "    private static final int QUESTION_TEXT_SPINNER_POS = 0;\n\n        if (currentColor != null) {\n            colorPickerView.setColor(currentColor);\n        } else if (spinnerPos == QUESTION_TEXT_SPINNER_POS || spinnerPos == ANSWER_TEXT_SPINNER_POS) {\n            colorPickerView.setColor(defaultTextColor);\n        } else if (spinnerPos == QUESTION_BACKGROUND_SPINNER_POS|| spinnerPos == ANSWER_BACKGROUND_SPINNER_POS) {\n            colorPickerView.setColor(defaultBackgroundColor);"}
{"magic_number_smell": "            else if(v == dbnameView){\n                Intent myIntent = new Intent(this, FileBrowserActivity.class);\n                myIntent.putExtra(FileBrowserActivity.EXTRA_FILE_EXTENSIONS, \".db\");\n                startActivityForResult(myIntent, 1);\n            }\n        }\n        catch (Exception e){", "refactored_code": "    private static final int ACTIVITY_FB = 1;\n            else if(v == dbnameView){\n                Intent myIntent = new Intent(this, FileBrowserActivity.class);\n                myIntent.putExtra(FileBrowserActivity.EXTRA_FILE_EXTENSIONS, \".db\");\n                startActivityForResult(myIntent, ACTIVITY_FB);\n            }\n        }\n        catch (Exception e){"}
{"magic_number_smell": "        @Override\n        public BarData doInBackground(Void... params) {\n            cardDao = dbOpenHelper.getCardDao();\n            List<String> xVals = new ArrayList<String>(30);\n            List<BarEntry> yVals = new ArrayList<BarEntry>(30);\n            Date now = new Date();\n            for (int i = -30; i < 1; i++) {", "refactored_code": "        private static final int INITIAL_CAPACITY = 30;\n        @Override\n        public BarData doInBackground(Void... params) {\n            cardDao = dbOpenHelper.getCardDao();\n            List<String> xVals = new ArrayList<String>(INITIAL_CAPACITY);\n            List<BarEntry> yVals = new ArrayList<BarEntry>(INITIAL_CAPACITY);\n            Date now = new Date();\n            for (int i = -INITIAL_CAPACITY; i < 1; i++) {"}
{"magic_number_smell": "            startCardId = savedInstanceState.getInt(EXTRA_START_CARD_ID, -1);\n        }\n\n        getMultipleLoaderManager().registerLoaderCallbacks(10, new LearnQueueManagerLoaderCallbacks(), false);\n\n        startInit();\n    }", "refactored_code": "    private static final int LEARN_QUEUE_MANAGER_LOADER_ID = 10;\n            startCardId = savedInstanceState.getInt(EXTRA_START_CARD_ID, -1);\n        }\n\n        getMultipleLoaderManager().registerLoaderCallbacks(LEARN_QUEUE_MANAGER_LOADER_ID, new LearnQueueManagerLoaderCallbacks(), false);\n\n        startInit();\n    }"}
{"magic_number_smell": "\n    private String textOnFirstClick = \"\";\n\n    private int effectiveDurationMillis = 5000;\n\n    private long lastClickedTime = -1;\n", "refactored_code": "    private static final int DEFAULT_EFFECTIVE_DURATION_MILLIS = 5000;\n\n    private String textOnFirstClick = \"\";\n\n    private int effectiveDurationMillis = DEFAULT_EFFECTIVE_DURATION_MILLIS;\n\n    private long lastClickedTime = -1;\n"}
{"magic_number_smell": "                    FileUtils.forceMkdir(new File(outputPath.getAbsolutePath() + \"/\" + entry.getName()));\n                } else {\n                    ins = new BufferedInputStream\n                            (zipfile.getInputStream(entry), 8192);\n                    int count;\n                    byte data[] = new byte[8192];\n", "refactored_code": "    private static final int BUFFER_SIZE = 8192;\n                    FileUtils.forceMkdir(new File(outputPath.getAbsolutePath() + \"/\" + entry.getName()));\n                } else {\n                    ins = new BufferedInputStream\n                            (zipfile.getInputStream(entry), BUFFER_SIZE);\n                    int count;\n                    byte data[] = new byte[BUFFER_SIZE];\n"}
{"magic_number_smell": "                    .setAutoCancel(true)\n                    .build();\n\n            notificationManager.notify(4829352, notification);\n            Log.v(TAG, \"Notification Invoked!\");\n        }\n        catch(Exception e){", "refactored_code": "    private static final int NOTIFICATION_ID = 4829352;\n                    .setAutoCancel(true)\n                    .build();\n\n            notificationManager.notify(NOTIFICATION_ID, notification);\n            Log.v(TAG, \"Notification Invoked!\");\n        }\n        catch(Exception e){"}
{"magic_number_smell": "            RemoteViews rv = new RemoteViews(context.getPackageName(), R.layout.widget);\n\n            Intent widgetIntent = new Intent(context, StudyActivity.class);\n            PendingIntent pendingIntent = PendingIntent.getActivity(context,23452435 + i,widgetIntent,PendingIntent.FLAG_CANCEL_CURRENT);\n            rv.setPendingIntentTemplate(R.id.widget_list, pendingIntent);\n            rv.setRemoteAdapter(appWidgetIds[i], R.id.widget_list, intent);\n", "refactored_code": "    private static final int WIDGET_REQUEST_ID = 23452435;\n            RemoteViews rv = new RemoteViews(context.getPackageName(), R.layout.widget);\n\n            Intent widgetIntent = new Intent(context, StudyActivity.class);\n            PendingIntent pendingIntent = PendingIntent.getActivity(context,WIDGET_REQUEST_ID + i,widgetIntent,PendingIntent.FLAG_CANCEL_CURRENT);\n            rv.setPendingIntentTemplate(R.id.widget_list, pendingIntent);\n            rv.setRemoteAdapter(appWidgetIds[i], R.id.widget_list, intent);\n"}
{"magic_number_smell": "   * the parent.\n   */\n  protected static class GLOverlayLayout implements LayoutManager2, Serializable {\n    private static final long -471481443599019888L = -8248213786715565045L;\n\n    @Override\n    public Dimension preferredLayoutSize(Container parent) {", "refactored_code": "  private static final long serialVersionUID = -471481443599019888L;\n   * the parent.\n   */\n  protected static class GLOverlayLayout implements LayoutManager2, Serializable {\n    private static final long serialVersionUID = -8248213786715565045L;\n\n    @Override\n    public Dimension preferredLayoutSize(Container parent) {"}
{"magic_number_smell": "   */\n  public static final int 30 = 30;\n\n  protected int steps = 30;\n\n  /**\n   * Sets the number of steps to take in a quadratic or cubic curve spline.", "refactored_code": "  public static final int CURVE_STEPS = 30;\n   */\n  public static final int CURVE_STEPS = 30;\n\n  protected int steps = CURVE_STEPS;\n\n  /**\n   * Sets the number of steps to take in a quadratic or cubic curve spline."}
{"magic_number_smell": "    bindBuffer(gl, vBuffer);\n\n    if (close) {\n      setDrawEnd(gl, 0);\n      gl.glDrawArrays(GL.GL_LINES, 0, numPts + 1);\n      gl.glDrawArrays(GL.GL_LINES, 1, numPts);\n    } else if (numPts == 2) {", "refactored_code": "  public static final int DRAW_END_NONE = 0;\n    bindBuffer(gl, vBuffer);\n\n    if (close) {\n      setDrawEnd(gl, DRAW_END_NONE);\n      gl.glDrawArrays(GL.GL_LINES, 0, numPts + 1);\n      gl.glDrawArrays(GL.GL_LINES, 1, numPts);\n    } else if (numPts == 2) {"}
{"magic_number_smell": "    sameButton.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        result = 0;\n      }\n    });\n", "refactored_code": "  public static final int SAME = 0;\n    sameButton.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        result = SAME;\n      }\n    });\n"}
{"magic_number_smell": "  public static final byte 0 = 0;\n  public static final byte FLASH = 1;\n\n  public static final String[] names = { \"0\", \"FLASH\", };\n\n  public static String name(int e) { return names[e]; }\n}", "refactored_code": "  public static final byte JAVA = 0;\n  public static final byte JAVA = 0;\n  public static final byte FLASH = 1;\n\n  public static final String[] names = { \"JAVA\", \"FLASH\", };\n\n  public static String name(int e) { return names[e]; }\n}"}
{"magic_number_smell": "  public static final byte 0 = 0;\n  public static final byte LARGE = 1;\n\n  public static final String[] names = { \"0\", \"LARGE\", };\n\n  public static String name(int e) { return names[e]; }\n}", "refactored_code": "  public static final byte SMALL = 0;\n  public static final byte SMALL = 0;\n  public static final byte LARGE = 1;\n\n  public static final String[] names = { \"SMALL\", \"LARGE\", };\n\n  public static String name(int e) { return names[e]; }\n}"}
{"magic_number_smell": "      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:serializers.protobuf.media.Media)\n      MediaOrBuilder {\n  private static final long 0L = 0L;\n    // Use Media.newBuilder() to construct.\n    private Media(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);", "refactored_code": "  private static final long serialVersionUID = 0L;\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:serializers.protobuf.media.Media)\n      MediaOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use Media.newBuilder() to construct.\n    private Media(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);"}
{"magic_number_smell": "  }\n\n  public void unsetWidth() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field width is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __WIDTH_ISSET_ID = 0;\n  }\n\n  public void unsetWidth() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __WIDTH_ISSET_ID);\n  }\n\n  /** Returns true if field width is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetWidth() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field width is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __WIDTH_ISSET_ID = 0;\n  }\n\n  public void unsetWidth() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __WIDTH_ISSET_ID);\n  }\n\n  /** Returns true if field width is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "    // overhead is worthwhile\n    private static StringBuilder toStringBuilder(Readable input) throws IOException {\n        StringBuilder text = new StringBuilder();\n        CharBuffer buffer = CharBuffer.allocate(4096);\n        while (true) {\n            int n = input.read(buffer);\n            if (n == -1) {", "refactored_code": "    private static final int BUFFER_SIZE = 4096;\n    // overhead is worthwhile\n    private static StringBuilder toStringBuilder(Readable input) throws IOException {\n        StringBuilder text = new StringBuilder();\n        CharBuffer buffer = CharBuffer.allocate(BUFFER_SIZE);\n        while (true) {\n            int n = input.read(buffer);\n            if (n == -1) {"}
{"magic_number_smell": "\t\tprivate static final class MediaContentExternalizer\n\t\t\timplements Externalizer {\n\n\t\t\tprivate static final long 1L = 1L;\n\n\t\t\t@Override\n\t\t\tpublic void writeExternal(", "refactored_code": "\t\t\tprivate static final long serialVersionUID = 1L;\n\t\tprivate static final class MediaContentExternalizer\n\t\t\timplements Externalizer {\n\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tpublic void writeExternal("}
{"magic_number_smell": "    }\n\n    public String generateChart(List<TestCaseResult> resultList, String title, String lowerValueName, String higherValueName) {\n        int chartSize = Math.min(18, resultList.size() ); // more bars aren't possible with gcharts\n        int max = max(resultList, higherValueName, 18);\n        String res = \"https://chart.googleapis.com/chart?cht=bhs&chs=600x\"+(chartSize *20+14); // html: finally a device independent technology\n//        res+=\"&chtt=\"+URLEncoder.encode(title);", "refactored_code": "    public static final int MAX_CHART_BARS = 18;\n    }\n\n    public String generateChart(List<TestCaseResult> resultList, String title, String lowerValueName, String higherValueName) {\n        int chartSize = Math.min(MAX_CHART_BARS, resultList.size() ); // more bars aren't possible with gcharts\n        int max = max(resultList, higherValueName, MAX_CHART_BARS);\n        String res = \"https://chart.googleapis.com/chart?cht=bhs&chs=600x\"+(chartSize *20+14); // html: finally a device independent technology\n//        res+=\"&chtt=\"+URLEncoder.encode(title);"}
{"magic_number_smell": "        int[] times = new int[entries.size()];\n        int i = 0;\n        for (Entry e : entries) {\n            times[i++] = e.results.get(3);\n        }\n        Arrays.sort(times);\n", "refactored_code": "    public static final int roundTripColumnIndex = 3;\n        int[] times = new int[entries.size()];\n        int i = 0;\n        for (Entry e : entries) {\n            times[i++] = e.results.get(roundTripColumnIndex);\n        }\n        Arrays.sort(times);\n"}
{"magic_number_smell": "     * Creates a new processor instance without any enabled extensions and the default parsing timeout.\n     */\n    public PegDownProcessor() {\n        this(2000);\n    }\n\n    /**", "refactored_code": "    public static final long DEFAULT_MAX_PARSING_TIME = 2000;\n     * Creates a new processor instance without any enabled extensions and the default parsing timeout.\n     */\n    public PegDownProcessor() {\n        this(DEFAULT_MAX_PARSING_TIME);\n    }\n\n    /**"}
{"magic_number_smell": "\tprotected void addEdgeCallback(AbstractEdge edge) {\n\t\tedgeMap.put(edge.getId(), edge);\n\t\tif (edgeCount == edgeArray.length) {\n\t\t\tAbstractEdge[] tmp = new AbstractEdge[(int) (edgeArray.length * 1.1) + 1];\n\t\t\tSystem.arraycopy(edgeArray, 0, tmp, 0, edgeArray.length);\n\t\t\tArrays.fill(edgeArray, null);\n\t\t\tedgeArray = tmp;", "refactored_code": "\tpublic static final double GROW_FACTOR = 1.1;\n\tprotected void addEdgeCallback(AbstractEdge edge) {\n\t\tedgeMap.put(edge.getId(), edge);\n\t\tif (edgeCount == edgeArray.length) {\n\t\t\tAbstractEdge[] tmp = new AbstractEdge[(int) (edgeArray.length * GROW_FACTOR) + 1];\n\t\t\tSystem.arraycopy(edgeArray, 0, tmp, 0, edgeArray.length);\n\t\t\tArrays.fill(edgeArray, null);\n\t\t\tedgeArray = tmp;"}
{"magic_number_smell": "\tprotected boolean addEdgeCallback(AbstractEdge edge) {\n\t\t// resize edges if necessary\n\t\tif (edges.length == degree) {\n\t\t\tAbstractEdge[] tmp = new AbstractEdge[(int) (1.1 * edges.length) + 1];\n\t\t\tSystem.arraycopy(edges, 0, tmp, 0, edges.length);\n\t\t\tArrays.fill(edges, null);\n\t\t\tedges = tmp;", "refactored_code": "\tprotected static final double GROWTH_FACTOR = 1.1;\n\tprotected boolean addEdgeCallback(AbstractEdge edge) {\n\t\t// resize edges if necessary\n\t\tif (edges.length == degree) {\n\t\t\tAbstractEdge[] tmp = new AbstractEdge[(int) (GROWTH_FACTOR * edges.length) + 1];\n\t\t\tSystem.arraycopy(edges, 0, tmp, 0, edges.length);\n\t\t\tArrays.fill(edges, null);\n\t\t\tedges = tmp;"}
{"magic_number_smell": "\t\tSocketChannel socket = (SocketChannel) key.channel();\n\n\t\tif (buffer == null) {\n\t\t\tbuffer = ByteBuffer.allocate(8192);\n\t\t\tkey.attach(buffer);\n\n\t\t\tLOGGER.info(String.format(\"creating buffer for new connection from %s:%d\", socket.socket().getInetAddress(),", "refactored_code": "\tprotected static final int BUFFER_INITIAL_SIZE = 8192;\n\t\tSocketChannel socket = (SocketChannel) key.channel();\n\n\t\tif (buffer == null) {\n\t\t\tbuffer = ByteBuffer.allocate(BUFFER_INITIAL_SIZE);\n\t\t\tkey.attach(buffer);\n\n\t\t\tLOGGER.info(String.format(\"creating buffer for new connection from %s:%d\", socket.socket().getInetAddress(),"}
{"magic_number_smell": "\t\t\tif (buffer.hasNumber(WIDTH_ATTR))\n\t\t\t\twidth = buffer.getNumber(WIDTH_ATTR);\n\t\t\telse\n\t\t\t\twidth = 10;\n\t\t}\n\n\t\tif (Double.isNaN(height)) {", "refactored_code": "\tpublic static final double DEFAULT_WIDTH = 10;\n\t\t\tif (buffer.hasNumber(WIDTH_ATTR))\n\t\t\t\twidth = buffer.getNumber(WIDTH_ATTR);\n\t\t\telse\n\t\t\t\twidth = DEFAULT_WIDTH;\n\t\t}\n\n\t\tif (Double.isNaN(height)) {"}
{"magic_number_smell": "\t\tthis.dgs = dgs;\n\t\tthis.reader = reader;\n\t\tbufferCapacity = 0;\n\t\tbuffer = new char[4096];\n\t\tpushback = new int[10];\n\t\tpushbackOffset = -1;\n\t\tthis.sourceId = String.format(\"<DGS stream %x>\", System.nanoTime());", "refactored_code": "\tprotected static final int BUFFER_SIZE = 4096;\n\t\tthis.dgs = dgs;\n\t\tthis.reader = reader;\n\t\tbufferCapacity = 0;\n\t\tbuffer = new char[BUFFER_SIZE];\n\t\tpushback = new int[10];\n\t\tpushbackOffset = -1;\n\t\tthis.sourceId = String.format(\"<DGS stream %x>\", System.nanoTime());"}
{"magic_number_smell": "        } else if (!Utils.isEmpty(url))\n            d += url;\n        if (optionShorten) {\n            if (d.length() > 140) d = d.substring(0, 140-1) + \"...\";\n        }\n        return d;\n    }", "refactored_code": "    private static final int MAXLEN = 140;\n        } else if (!Utils.isEmpty(url))\n            d += url;\n        if (optionShorten) {\n            if (d.length() > MAXLEN) d = d.substring(0, MAXLEN-1) + \"...\";\n        }\n        return d;\n    }"}
{"magic_number_smell": "                        .filteredCollection(DownloadSelectedIncompleteMembersAction.buildSetOfIncompleteMembers(\n                                Collections.singleton(multipolygonRelation)), OsmPrimitive.class);\n\n                if (incompleteMembers.size() <= 100) {\n                    MainApplication.worker\n                            .submit(new DownloadRelationMemberTask(multipolygonRelation, incompleteMembers, editLayer));\n                } else {", "refactored_code": "    private static final int MAX_MEMBERS_TO_DOWNLOAD = 100;\n                        .filteredCollection(DownloadSelectedIncompleteMembersAction.buildSetOfIncompleteMembers(\n                                Collections.singleton(multipolygonRelation)), OsmPrimitive.class);\n\n                if (incompleteMembers.size() <= MAX_MEMBERS_TO_DOWNLOAD) {\n                    MainApplication.worker\n                            .submit(new DownloadRelationMemberTask(multipolygonRelation, incompleteMembers, editLayer));\n                } else {"}
{"magic_number_smell": "            final double dx = tmp.east() - n.getEastNorth().east();\n            final double dy = tmp.north() - n.getEastNorth().north();\n            if (headingNodes.contains(n)) { // The heading nodes should not have changed\n                if (Math.abs(dx) > Math.abs(1E-6 * tmp.east()) ||\n                    Math.abs(dy) > Math.abs(1E-6 * tmp.east()))\n                    throw new AssertionError(\"heading node has changed\");\n            } else {", "refactored_code": "    private static final double EPSILON = 1E-6;\n            final double dx = tmp.east() - n.getEastNorth().east();\n            final double dy = tmp.north() - n.getEastNorth().north();\n            if (headingNodes.contains(n)) { // The heading nodes should not have changed\n                if (Math.abs(dx) > Math.abs(EPSILON * tmp.east()) ||\n                    Math.abs(dy) > Math.abs(EPSILON * tmp.east()))\n                    throw new AssertionError(\"heading node has changed\");\n            } else {"}
{"magic_number_smell": "                }\n            }\n        });\n        model.setSize(Config.getPref().getInt(\"search.history-size\", 15));\n    }\n\n    /**", "refactored_code": "    public static final int DEFAULT_SEARCH_HISTORY_SIZE = 15;\n                }\n            }\n        });\n        model.setSize(Config.getPref().getInt(\"search.history-size\", DEFAULT_SEARCH_HISTORY_SIZE));\n    }\n\n    /**"}
{"magic_number_smell": "    /**\n     * Loads default preferences from default settings cache file.\n     *\n     * Discards entries older than {@link #TimeUnit.DAYS.toSeconds(50)}.\n     *\n     * @throws IOException if any I/O error occurs while reading the file\n     * @throws SAXException if the settings file does not contain valid XML", "refactored_code": "    private static final long MAX_AGE_DEFAULT_PREFERENCES = TimeUnit.DAYS.toSeconds(50);\n    /**\n     * Loads default preferences from default settings cache file.\n     *\n     * Discards entries older than {@link #MAX_AGE_DEFAULT_PREFERENCES}.\n     *\n     * @throws IOException if any I/O error occurs while reading the file\n     * @throws SAXException if the settings file does not contain valid XML"}
{"magic_number_smell": "     */\n    public static final class CommandQueueCleanedEvent extends CommandQueueEvent {\n\n        private static final long 1L = 1L;\n        private final DataSet ds;\n\n        private CommandQueueCleanedEvent(UndoRedoHandler source, DataSet ds) {", "refactored_code": "        private static final long serialVersionUID = 1L;\n     */\n    public static final class CommandQueueCleanedEvent extends CommandQueueEvent {\n\n        private static final long serialVersionUID = 1L;\n        private final DataSet ds;\n\n        private CommandQueueCleanedEvent(UndoRedoHandler source, DataSet ds) {"}
{"magic_number_smell": "    protected void initFromRevisionInfo(InputStream revisionInfo) {\n        if (revisionInfo == null) {\n            this.releaseDescription = tr(\"UNKNOWN\");\n            this.version = 0;\n            this.time = null;\n            return;\n        }", "refactored_code": "    public static final int JOSM_UNKNOWN_VERSION = 0;\n    protected void initFromRevisionInfo(InputStream revisionInfo) {\n        if (revisionInfo == null) {\n            this.releaseDescription = tr(\"UNKNOWN\");\n            this.version = JOSM_UNKNOWN_VERSION;\n            this.time = null;\n            return;\n        }"}
{"magic_number_smell": "                return false;\n            }\n        } else if (attributes.getLastModification() > 0 &&\n                now - attributes.getLastModification() > Math.max(TimeUnit.DAYS.toMillis(7), minimumExpiryTime)) {\n            // check by file modification date\n            Logging.debug(\"JCS - Object has expired, maximum file age reached {0}\", getUrlNoException());\n            return false;", "refactored_code": "    protected static final long DEFAULT_EXPIRE_TIME = TimeUnit.DAYS.toMillis(7);\n                return false;\n            }\n        } else if (attributes.getLastModification() > 0 &&\n                now - attributes.getLastModification() > Math.max(DEFAULT_EXPIRE_TIME, minimumExpiryTime)) {\n            // check by file modification date\n            Logging.debug(\"JCS - Object has expired, maximum file age reached {0}\", getUrlNoException());\n            return false;"}
{"magic_number_smell": "        props.setProperty(\"jcs.default.cacheattributes.DiskUsagePatternName\", \"UPDATE\"); // store elements on disk on put\n        props.setProperty(\"jcs.default.elementattributes\",                    CacheEntryAttributes.class.getCanonicalName());\n        props.setProperty(\"jcs.default.elementattributes.IsEternal\",          \"false\");\n        props.setProperty(\"jcs.default.elementattributes.MaxLife\",            Long.toString(-1));\n        props.setProperty(\"jcs.default.elementattributes.IdleTime\",           Long.toString(-1));\n        props.setProperty(\"jcs.default.elementattributes.IsSpool\",            \"true\");\n        // CHECKSTYLE.ON: SingleSpaceSeparator", "refactored_code": "    private static final long MAX_OBJECT_TTL = -1;\n        props.setProperty(\"jcs.default.cacheattributes.DiskUsagePatternName\", \"UPDATE\"); // store elements on disk on put\n        props.setProperty(\"jcs.default.elementattributes\",                    CacheEntryAttributes.class.getCanonicalName());\n        props.setProperty(\"jcs.default.elementattributes.IsEternal\",          \"false\");\n        props.setProperty(\"jcs.default.elementattributes.MaxLife\",            Long.toString(MAX_OBJECT_TTL));\n        props.setProperty(\"jcs.default.elementattributes.IdleTime\",           Long.toString(MAX_OBJECT_TTL));\n        props.setProperty(\"jcs.default.elementattributes.IsSpool\",            \"true\");\n        // CHECKSTYLE.ON: SingleSpaceSeparator"}
{"magic_number_smell": "    /**\n     * The number of parts the world is split into in each direction\n     */\n    public static final double WORLD_PARTS = 1 << 24;\n\n    /**\n     * The log(2) of how many tiles there are per level", "refactored_code": "    public static final int NR_LEVELS = 24;\n    /**\n     * The number of parts the world is split into in each direction\n     */\n    public static final double WORLD_PARTS = 1 << NR_LEVELS;\n\n    /**\n     * The log(2) of how many tiles there are per level"}
{"magic_number_smell": "        for (int zoom = 1; zoom <= getMaxZoom(); zoom++) {\n            // use well known scale set \"GoogleCompatible\" from OGC WMTS spec to calculate number of tiles per zoom level\n            // this makes the zoom levels \"glued\" to standard TMS zoom levels\n            degreesPerTile[zoom] = (5.59082264028718e08 / Math.pow(2d, zoom - 1d)) * crsScale;\n            TileXY minTileIndex = eastNorthToTileXY(topLeft, zoom);\n            tileXMin[zoom] = minTileIndex.getXIndex();\n            tileYMin[zoom] = minTileIndex.getYIndex();", "refactored_code": "    private static final double SCALE_DENOMINATOR_ZOOM_LEVEL_1 = 5.59082264028718e08;\n        for (int zoom = 1; zoom <= getMaxZoom(); zoom++) {\n            // use well known scale set \"GoogleCompatible\" from OGC WMTS spec to calculate number of tiles per zoom level\n            // this makes the zoom levels \"glued\" to standard TMS zoom levels\n            degreesPerTile[zoom] = (SCALE_DENOMINATOR_ZOOM_LEVEL_1 / Math.pow(2d, zoom - 1d)) * crsScale;\n            TileXY minTileIndex = eastNorthToTileXY(topLeft, zoom);\n            tileXMin[zoom] = minTileIndex.getXIndex();\n            tileYMin[zoom] = minTileIndex.getYIndex();"}
{"magic_number_smell": "                    } else if (next.getField() == GEOMETRY_TYPE_FIELD) {\n                        // by using getAllValues, we avoid 12.4 MB allocations\n                        geometryTypeTemp = GeometryTypes.getAllValues()[next.asUnsignedVarInt().intValue()];\n                    } else if (next.getField() == 1) {\n                        tId = next.asUnsignedVarInt().longValue();\n                    }\n                }", "refactored_code": "    private static final byte ID_FIELD = 1;\n                    } else if (next.getField() == GEOMETRY_TYPE_FIELD) {\n                        // by using getAllValues, we avoid 12.4 MB allocations\n                        geometryTypeTemp = GeometryTypes.getAllValues()[next.asUnsignedVarInt().intValue()];\n                    } else if (next.getField() == ID_FIELD) {\n                        tId = next.asUnsignedVarInt().longValue();\n                    }\n                }"}
{"magic_number_smell": "\n    @Override\n    public void setModified(boolean modified) {\n        updateFlags(1 << 0, modified);\n    }\n\n    @Override", "refactored_code": "    protected static final short FLAG_MODIFIED = 1 << 0;\n\n    @Override\n    public void setModified(boolean modified) {\n        updateFlags(FLAG_MODIFIED, modified);\n    }\n\n    @Override"}
{"magic_number_smell": "    public void setKeys(Map<String, String> keys) {\n        CheckParameterUtil.ensureParameterNotNull(keys, \"keys\");\n        keys.values().stream()\n                .filter(value -> value != null && value.length() > MAX_TAG_LENGTH)\n                .findFirst()\n                .ifPresent(value -> {\n                throw new IllegalArgumentException(\"Changeset tag value is too long: \"+value);", "refactored_code": "    public static final int MAX_CHANGESET_TAG_LENGTH = MAX_TAG_LENGTH;\n    public void setKeys(Map<String, String> keys) {\n        CheckParameterUtil.ensureParameterNotNull(keys, \"keys\");\n        keys.values().stream()\n                .filter(value -> value != null && value.length() > MAX_CHANGESET_TAG_LENGTH)\n                .findFirst()\n                .ifPresent(value -> {\n                throw new IllegalArgumentException(\"Changeset tag value is too long: \"+value);"}
{"magic_number_smell": "                lock.readLock().lock();\n                try {\n                    lock.writeLock().unlock();\n                    if (eventsToFire.size() < 30) {\n                        for (AbstractDatasetChangedEvent event : eventsToFire) {\n                            fireEventToListeners(event);\n                        }", "refactored_code": "    private static final int MAX_SINGLE_EVENTS = 30;\n                lock.readLock().lock();\n                try {\n                    lock.writeLock().unlock();\n                    if (eventsToFire.size() < MAX_SINGLE_EVENTS) {\n                        for (AbstractDatasetChangedEvent event : eventsToFire) {\n                            fireEventToListeners(event);\n                        }"}
{"magic_number_smell": "\n    private void printError(String type, String message, Object... args) {\n        errorCount++;\n        if (errorCount <= 100) {\n            writer.println('[' + type + \"] \" + String.format(message, args));\n        }\n    }", "refactored_code": "    private static final int MAX_ERRORS = 100;\n\n    private void printError(String type, String message, Object... args) {\n        errorCount++;\n        if (errorCount <= MAX_ERRORS) {\n            writer.println('[' + type + \"] \" + String.format(message, args));\n        }\n    }"}
{"magic_number_smell": "                    ne = new QBLevel<>(this, index);\n                }\n                return ne;\n            case 1:\n                if (nw == null) {\n                    nw = new QBLevel<>(this, index);\n                }", "refactored_code": "    private static final byte NW_INDEX = 1;\n                    ne = new QBLevel<>(this, index);\n                }\n                return ne;\n            case NW_INDEX:\n                if (nw == null) {\n                    nw = new QBLevel<>(this, index);\n                }"}
{"magic_number_smell": "     */\n    public Storage(Hash<? super T, ? super T> ha, int capacity, boolean safeIterator) {\n        this.hash = ha;\n        int cap = 1 << (int) Math.ceil(Math.log(capacity/0.6d) / Math.log(2));\n        @SuppressWarnings(\"unchecked\")\n        T[] newData = (T[]) new Object[cap];\n        data = newData;", "refactored_code": "    private static final double LOAD_FACTOR = 0.6d;\n     */\n    public Storage(Hash<? super T, ? super T> ha, int capacity, boolean safeIterator) {\n        this.hash = ha;\n        int cap = 1 << (int) Math.ceil(Math.log(capacity/LOAD_FACTOR) / Math.log(2));\n        @SuppressWarnings(\"unchecked\")\n        T[] newData = (T[]) new Object[cap];\n        data = newData;"}
{"magic_number_smell": "     * equal <code>null</code>) this method does not do anything.\n     */\n    public void enlargeBoundingBox() {\n        final double enlarge = Config.getPref().getDouble(\"edit.zoom-enlarge-bbox\", 0.0002);\n        enlargeBoundingBox(enlarge, enlarge);\n    }\n", "refactored_code": "    private static final double ENLARGE_DEFAULT = 0.0002;\n     * equal <code>null</code>) this method does not do anything.\n     */\n    public void enlargeBoundingBox() {\n        final double enlarge = Config.getPref().getDouble(\"edit.zoom-enlarge-bbox\", ENLARGE_DEFAULT);\n        enlargeBoundingBox(enlarge, enlarge);\n    }\n"}
{"magic_number_smell": "    static final int FLAG_OUTERMEMBER_OF_SELECTED = 8;\n\n    private static final double Utils.toRadians(20) = Utils.toRadians(20);\n    private static final double cosPHI = Math.cos(Utils.toRadians(20));\n    private static final double sinPHI = Math.sin(Utils.toRadians(20));\n    /**\n     * If we should use left hand traffic.", "refactored_code": "    private static final double PHI = Utils.toRadians(20);\n    static final int FLAG_OUTERMEMBER_OF_SELECTED = 8;\n\n    private static final double PHI = Utils.toRadians(20);\n    private static final double cosPHI = Math.cos(PHI);\n    private static final double sinPHI = Math.sin(PHI);\n    /**\n     * If we should use left hand traffic."}
{"magic_number_smell": "            }\n            if (defaultUnits) {\n                this.toMeter = 1;\n                this.metersPerUnitWMTS = proj.isGeographic() ? 2 * Math.PI * 6378137.0 / 360 : 1;\n            }\n            s = parameters.get(Param.axis.key);\n            if (s != null) {", "refactored_code": "    private static final double METER_PER_UNIT_DEGREE = 2 * Math.PI * 6378137.0 / 360;\n            }\n            if (defaultUnits) {\n                this.toMeter = 1;\n                this.metersPerUnitWMTS = proj.isGeographic() ? METER_PER_UNIT_DEGREE : 1;\n            }\n            s = parameters.get(Param.axis.key);\n            if (s != null) {"}
{"magic_number_smell": "    /**\n     * Register a source for NTV2 grid files.\n     * @param priority the priority, sources with higher priority are checked first;\n     * use {@link #10f} for local files and\n     * {@link #NTV2_SOURCE_PRIORITY_DOWNLOAD} for remote downloads\n     * @param source the NTV2 grid file source\n     * @since 12777", "refactored_code": "    public static final float NTV2_SOURCE_PRIORITY_LOCAL = 10f;\n    /**\n     * Register a source for NTV2 grid files.\n     * @param priority the priority, sources with higher priority are checked first;\n     * use {@link #NTV2_SOURCE_PRIORITY_LOCAL} for local files and\n     * {@link #NTV2_SOURCE_PRIORITY_DOWNLOAD} for remote downloads\n     * @param source the NTV2 grid file source\n     * @since 12777"}
{"magic_number_smell": "        double s, t, phi, k = 1.0/(1.0 - e2);\n        int i;\n        phi = arg;\n        for (i = 15; true;) { // rarely goes over 5 iterations\n            if (--i < 0) {\n                throw new IllegalStateException(\"Too many iterations\");\n            }", "refactored_code": "    private static final int MAXIMUM_ITERATIONS = 15;\n        double s, t, phi, k = 1.0/(1.0 - e2);\n        int i;\n        phi = arg;\n        for (i = MAXIMUM_ITERATIONS; true;) { // rarely goes over 5 iterations\n            if (--i < 0) {\n                throw new IllegalStateException(\"Too many iterations\");\n            }"}
{"magic_number_smell": "        if (e < EPSILON) {\n            return phi;\n        }\n        for (int i = 0; i < 15; i++) {\n            final double sinpi = Math.sin(phi);\n            final double cospi = Math.cos(phi);\n            final double con = e * sinpi;", "refactored_code": "    private static final int MAXIMUM_ITERATIONS = 15;\n        if (e < EPSILON) {\n            return phi;\n        }\n        for (int i = 0; i < MAXIMUM_ITERATIONS; i++) {\n            final double sinpi = Math.sin(phi);\n            final double cospi = Math.cos(phi);\n            final double con = e * sinpi;"}
{"magic_number_smell": "        latitudeOfOrigin = Math.toRadians(params.lat0);\n        semiMajor = params.ellps.a;\n        semiMinor = params.ellps.b;\n        if (Math.abs(latitudeOfOrigin - HALF_PI) < 1.e-10) {\n            mode = Mode.NORTH_POLAR;\n            mp = mlfn(HALF_PI, 1, 0);\n            sinph0 = 1;", "refactored_code": "    public static final double EPS10 = 1.e-10;\n        latitudeOfOrigin = Math.toRadians(params.lat0);\n        semiMajor = params.ellps.a;\n        semiMinor = params.ellps.b;\n        if (Math.abs(latitudeOfOrigin - HALF_PI) < EPS10) {\n            mode = Mode.NORTH_POLAR;\n            mp = mlfn(HALF_PI, 1, 0);\n            sinph0 = 1;"}
{"magic_number_smell": "            double c = cosphi * cosphi * e2 / (1 - e2);\n            double a2 = a1 * a1;\n\n            double x = n * a1 * (1.0 - a2 * t * (1. / 6 - (8.0 - t + 8.0 * c) * a2 * C2));\n            double y = mlfn(phi, sinphi, cosphi) - ml0 + n * tn * a2 * (0.5 + (5.0 - t + 6.0 * c) * a2 * C3);\n            return new double[] {x, y};\n        }", "refactored_code": "    private static final double C1 = 1. / 6;\n            double c = cosphi * cosphi * e2 / (1 - e2);\n            double a2 = a1 * a1;\n\n            double x = n * a1 * (1.0 - a2 * t * (C1 - (8.0 - t + 8.0 * c) * a2 * C2));\n            double y = mlfn(phi, sinphi, cosphi) - ml0 + n * tn * a2 * (0.5 + (5.0 - t + 6.0 * c) * a2 * C3);\n            return new double[] {x, y};\n        }"}
{"magic_number_smell": "        double phiprev = -1000;\n        int iteration = 0;\n        double phi = 2 * atan(exp(psi)) - PI/2;\n        while (abs(phi - phiprev) > 1e-12) {\n            if (++iteration > 10)\n                throw new IllegalStateException(\"Too many iterations\");\n            phiprev = phi;", "refactored_code": "    private static final double EPSILON = 1e-12;\n        double phiprev = -1000;\n        int iteration = 0;\n        double phi = 2 * atan(exp(psi)) - PI/2;\n        while (abs(phi - phiprev) > EPSILON) {\n            if (++iteration > 10)\n                throw new IllegalStateException(\"Too many iterations\");\n            phiprev = phi;"}
{"magic_number_smell": "     * @return <var>q</var> from Snyder equation (3-12).\n     */\n    private double qsfn(final double sinphi) {\n        if (e >= 1E-7) {\n            final double con = e * sinphi;\n            return (1.0 - e2) * (sinphi / (1.0 - con*con) -\n                    (0.5 / e) * Math.log((1.0 - con) / (1.0 + con)));", "refactored_code": "    private static final double EPSILON = 1E-7;\n     * @return <var>q</var> from Snyder equation (3-12).\n     */\n    private double qsfn(final double sinphi) {\n        if (e >= EPSILON) {\n            final double con = e * sinphi;\n            return (1.0 - e2) * (sinphi / (1.0 - con*con) -\n                    (0.5 / e) * Math.log((1.0 - con) / (1.0 + con)));"}
{"magic_number_smell": "        double gamma = atan(east / (r0-north));\n        double lambda = gamma/n;\n        double latIso = (-1/n) * log(abs(r/f));\n        double phi = ellps.latitude(latIso, e, 1e-12);\n        return new double[] {phi, lambda};\n    }\n", "refactored_code": "    protected static final double epsilon = 1e-12;\n        double gamma = atan(east / (r0-north));\n        double lambda = gamma/n;\n        double latIso = (-1/n) * log(abs(r/f));\n        double phi = ellps.latitude(latIso, e, epsilon);\n        return new double[] {phi, lambda};\n    }\n"}
{"magic_number_smell": "\n    @Override\n    public double[] project(double y, double x) {\n        if (Math.abs(y) > (Math.PI/2 - 1E-6)) {\n            return new double[] {0, 0}; // this is an error and should be handled somehow\n        }\n        if (spherical) {", "refactored_code": "    private static final double EPSILON = 1E-6;\n\n    @Override\n    public double[] project(double y, double x) {\n        if (Math.abs(y) > (Math.PI/2 - EPSILON)) {\n            return new double[] {0, 0}; // this is an error and should be handled somehow\n        }\n        if (spherical) {"}
{"magic_number_smell": "            double lon2 = Utils.toRadians(params.lon2);\n            double lat2 = Utils.toRadians(params.lat2);\n\n            if (Math.abs(lat1 - lat2) <= 1E-6 ||\n                Math.abs(lat1) <= 1E-6 ||\n                Math.abs(Math.abs(lat1) - Math.PI / 2) <= 1E-6 ||\n                Math.abs(Math.abs(latCenter) - Math.PI / 2) <= 1E-6 ||", "refactored_code": "    private static final double EPSILON = 1E-6;\n            double lon2 = Utils.toRadians(params.lon2);\n            double lat2 = Utils.toRadians(params.lat2);\n\n            if (Math.abs(lat1 - lat2) <= EPSILON ||\n                Math.abs(lat1) <= EPSILON ||\n                Math.abs(Math.abs(lat1) - Math.PI / 2) <= EPSILON ||\n                Math.abs(Math.abs(latCenter) - Math.PI / 2) <= EPSILON ||"}
{"magic_number_smell": "        final double t = rho/k0;\n        final double halfe = e/2.0;\n        double phi0 = 0;\n        for (int i = 15;;) {\n            final double esinphi = e * Math.sin(phi0);\n            final double phi = (Math.PI/2) - 2.0*Math.atan(t*Math.pow((1-esinphi)/(1+esinphi), halfe));\n            if (Math.abs(phi-phi0) < ITERATION_TOLERANCE) {", "refactored_code": "    private static final int MAXIMUM_ITERATIONS = 15;\n        final double t = rho/k0;\n        final double halfe = e/2.0;\n        double phi0 = 0;\n        for (int i = MAXIMUM_ITERATIONS;;) {\n            final double esinphi = e * Math.sin(phi0);\n            final double phi = (Math.PI/2) - 2.0*Math.atan(t*Math.pow((1-esinphi)/(1+esinphi), halfe));\n            if (Math.abs(phi-phi0) < ITERATION_TOLERANCE) {"}
{"magic_number_smell": "        double prevPhi = -1000;\n        int iteration = 0;\n        // iteration to finds S and phi\n        while (abs(phi - prevPhi) > 1e-11) {\n            if (++iteration > 30)\n                throw new JosmRuntimeException(\"Too many iterations\");\n            prevPhi = phi;", "refactored_code": "    private static final double EPSILON = 1e-11;\n        double prevPhi = -1000;\n        int iteration = 0;\n        // iteration to finds S and phi\n        while (abs(phi - prevPhi) > EPSILON) {\n            if (++iteration > 30)\n                throw new JosmRuntimeException(\"Too many iterations\");\n            prevPhi = phi;"}
{"magic_number_smell": "            FC6 * als * (61.0 + t * (t - 58.0) + n*(270.0 - 330.0*t) +\n            FC8 * als * (1385.0 + t * (t*(543.0 - t) - 3111.0)))));\n\n        x = al*(1. / 1 + FC3 * als*(1.0 - t + n +\n            FC5 * als * (5.0 + t*(t - 18.0) + n*(14.0 - 58.0*t) +\n            FC7 * als * (61.0+ t*(t*(179.0 - t) - 479.0)))));\n", "refactored_code": "    private static final double FC1 = 1. / 1;\n            FC6 * als * (61.0 + t * (t - 58.0) + n*(270.0 - 330.0*t) +\n            FC8 * als * (1385.0 + t * (t*(543.0 - t) - 3111.0)))));\n\n        x = al*(FC1 + FC3 * als*(1.0 - t + n +\n            FC5 * als * (5.0 + t*(t - 18.0) + n*(14.0 - 58.0*t) +\n            FC7 * als * (61.0+ t*(t*(179.0 - t) - 479.0)))));\n"}
{"magic_number_smell": "    /**\n     * The byte size for var ints (since the first byte is just an indicator for if the var int is done)\n     */\n    public static final byte VAR_INT_BYTE_SIZE = 8 - 1;\n    /**\n     * Used to get the most significant byte\n     */", "refactored_code": "    public static final byte BYTE_SIZE = 8;\n    /**\n     * The byte size for var ints (since the first byte is just an indicator for if the var int is done)\n     */\n    public static final byte VAR_INT_BYTE_SIZE = BYTE_SIZE - 1;\n    /**\n     * Used to get the most significant byte\n     */"}
{"magic_number_smell": "        this.inDataSet = inDataSet;\n        this.inStandard = inStandard;\n        this.selected = selected;\n        this.userInput = userInput == null ? Integer.MAX_VALUE : userInput;\n    }\n\n    /**", "refactored_code": "    private static final int NO_USER_INPUT = Integer.MAX_VALUE;\n        this.inDataSet = inDataSet;\n        this.inStandard = inStandard;\n        this.selected = selected;\n        this.userInput = userInput == null ? NO_USER_INPUT : userInput;\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    protected boolean isValidUser(String user) {\n\n        if (user == null || user.length() > 64) {\n            return false;\n        }\n", "refactored_code": "    private static final int MAX_USERNAME_LEN = 64;\n     */\n    protected boolean isValidUser(String user) {\n\n        if (user == null || user.length() > MAX_USERNAME_LEN) {\n            return false;\n        }\n"}
{"magic_number_smell": "                return false;\n            }\n\n            if (iIpSegment > 255) {\n                return false;\n            }\n", "refactored_code": "    private static final int IPV4_MAX_OCTET_VALUE = 255;\n                return false;\n            }\n\n            if (iIpSegment > IPV4_MAX_OCTET_VALUE) {\n                return false;\n            }\n"}
{"magic_number_smell": "     * @param schemes Pass in one or more url schemes to consider valid, passing in\n     *        a null will default to \"http,https,ftp\" being valid.\n     *        If a non-null schemes is specified then all valid schemes must\n     *        be specified. Setting the 1 << 0 option will\n     *        ignore the contents of schemes.\n     */\n    public UrlValidator(String... schemes) {", "refactored_code": "    public static final long ALLOW_ALL_SCHEMES = 1 << 0;\n     * @param schemes Pass in one or more url schemes to consider valid, passing in\n     *        a null will default to \"http,https,ftp\" being valid.\n     *        If a non-null schemes is specified then all valid schemes must\n     *        be specified. Setting the ALLOW_ALL_SCHEMES option will\n     *        ignore the contents of schemes.\n     */\n    public UrlValidator(String... schemes) {"}
{"magic_number_smell": "            && getAndCheckAssociatedStreets(p).isEmpty()\n            && p.referrers(Way.class).noneMatch(w -> w.hasKey(ADDR_INTERPOLATION) && w.hasKey(ADDR_STREET))) {\n            // no street found\n            TestError e = TestError.builder(this, Severity.WARNING, 2601)\n                .message(tr(\"House number without street\"))\n                .primitives(p)\n                .build();", "refactored_code": "    protected static final int HOUSE_NUMBER_WITHOUT_STREET = 2601;\n            && getAndCheckAssociatedStreets(p).isEmpty()\n            && p.referrers(Way.class).noneMatch(w -> w.hasKey(ADDR_INTERPOLATION) && w.hasKey(ADDR_STREET))) {\n            // no street found\n            TestError e = TestError.builder(this, Severity.WARNING, HOUSE_NUMBER_WITHOUT_STREET)\n                .message(tr(\"House number without street\"))\n                .primitives(p)\n                .build();"}
{"magic_number_smell": "            } else {\n                message = tr(\"Way contains more than {0} nodes. It should be split or simplified\", maxNodes);\n            }\n            errors.add(TestError.builder(this, Severity.ERROR, 3401)\n                    .message(message)\n                    .primitives(w)\n                    .build());", "refactored_code": "    private static final int MAX_WAY_NODES_ERROR = 3401;\n            } else {\n                message = tr(\"Way contains more than {0} nodes. It should be split or simplified\", maxNodes);\n            }\n            errors.add(TestError.builder(this, Severity.ERROR, MAX_WAY_NODES_ERROR)\n                    .message(message)\n                    .primitives(w)\n                    .build());"}
{"magic_number_smell": "                }\n            }\n            errors.add(TestError\n                    .builder(this, Severity.WARNING, 2801)\n                    .message(tr(\"Barrier entrance not set on a barrier\"))\n                    .primitives(n)\n                    .build());", "refactored_code": "    protected static final int BARRIER_ENTRANCE_WITHOUT_BARRIER = 2801;\n                }\n            }\n            errors.add(TestError\n                    .builder(this, Severity.WARNING, BARRIER_ENTRANCE_WITHOUT_BARRIER)\n                    .message(tr(\"Barrier entrance not set on a barrier\"))\n                    .primitives(n)\n                    .build());"}
{"magic_number_smell": "                        checkIfReversed(w, connectedWays.iterator().next(), n);\n                    }\n                    if (connectedWays.size() == 1 && w.isClosed() && connectedWays.iterator().next().isClosed()) {\n                        addError(901, w, connectedWays, n);\n                    }\n                } else if (i == numNodes - 1) {\n                    if (connectedWays.isEmpty() && n != w.firstNode() && n.getCoor().isIn(downloadedArea)) {", "refactored_code": "    protected static final int UNORDERED_COASTLINE = 901;\n                        checkIfReversed(w, connectedWays.iterator().next(), n);\n                    }\n                    if (connectedWays.size() == 1 && w.isClosed() && connectedWays.iterator().next().isClosed()) {\n                        addError(UNORDERED_COASTLINE, w, connectedWays, n);\n                    }\n                } else if (i == numNodes - 1) {\n                    if (connectedWays.isEmpty() && n != w.firstNode() && n.getCoor().isIn(downloadedArea)) {"}
{"magic_number_smell": "                }\n            }\n            if (fromCheck || toCheck) {\n                errors.add(TestError.builder(this, Severity.WARNING, 3900)\n                        .message(tr(\"Inconsistent lane numbering between relation and member tags\")).primitives(relation)\n                        .build());\n            }", "refactored_code": "    protected static final int INCONSISTENT_LANE_COUNT = 3900;\n                }\n            }\n            if (fromCheck || toCheck) {\n                errors.add(TestError.builder(this, Severity.WARNING, INCONSISTENT_LANE_COUNT)\n                        .message(tr(\"Inconsistent lane numbering between relation and member tags\")).primitives(relation)\n                        .build());\n            }"}
{"magic_number_smell": "         * Constructs a new crossing {@code Ways} test.\n         */\n        public Ways() {\n            super(tr(\"Crossing ways\"), 601);\n        }\n\n        @Override", "refactored_code": "        protected static final int CROSSING_WAYS = 601;\n         * Constructs a new crossing {@code Ways} test.\n         */\n        public Ways() {\n            super(tr(\"Crossing ways\"), CROSSING_WAYS);\n        }\n\n        @Override"}
{"magic_number_smell": "                        marktr(\"Node with {0} on end of way\"), tag);\n            }\n        } else if (ways.size() > 1) {\n            builder = TestError.builder(this, Severity.OTHER, 4000).message(DISPUTED_USE_MSG,\n                    marktr(\"Node with {0} on a connection of multiple ways\"), tag);\n        }\n        if (builder != null) {", "refactored_code": "    private static final int MULTIPLE_WAYS_CODE = 4000;\n                        marktr(\"Node with {0} on end of way\"), tag);\n            }\n        } else if (ways.size() > 1) {\n            builder = TestError.builder(this, Severity.OTHER, MULTIPLE_WAYS_CODE).message(DISPUTED_USE_MSG,\n                    marktr(\"Node with {0} on a connection of multiple ways\"), tag);\n        }\n        if (builder != null) {"}
{"magic_number_smell": "                continue;\n            }\n            if (lastN == n) {\n                errors.add(TestError.builder(this, Severity.ERROR, 501)\n                        .message(tr(\"Duplicated way nodes\"))\n                        .primitives(w)\n                        .highlight(n)", "refactored_code": "    protected static final int DUPLICATE_WAY_NODE = 501;\n                continue;\n            }\n            if (lastN == n) {\n                errors.add(TestError.builder(this, Severity.ERROR, DUPLICATE_WAY_NODE)\n                        .message(tr(\"Duplicated way nodes\"))\n                        .primitives(w)\n                        .highlight(n)"}
{"magic_number_smell": "        private final double Config.getPref().getDouble(\"validator.duplicatenodes.precision\", 0.) = Config.getPref().getDouble(\"validator.duplicatenodes.Config.getPref().getDouble(\"validator.duplicatenodes.precision\", 0.)\", 0.);\n\n        /**\n         * Returns the rounded coordinated according to {@link #Config.getPref().getDouble(\"validator.duplicatenodes.precision\", 0.)}\n         * @see LatLon#roundToOsmPrecision\n         */\n        private LatLon roundCoord(LatLon coor) {", "refactored_code": "        private final double precision = Config.getPref().getDouble(\"validator.duplicatenodes.precision\", 0.);\n        private final double precision = Config.getPref().getDouble(\"validator.duplicatenodes.precision\", 0.);\n\n        /**\n         * Returns the rounded coordinated according to {@link #precision}\n         * @see LatLon#roundToOsmPrecision\n         */\n        private LatLon roundCoord(LatLon coor) {"}
{"magic_number_smell": "        // this test is rather speculative and works only with complete members\n        for (Set<Relation> duplicated : relations.values()) {\n            if (duplicated.size() > 1) {\n                TestError testError = TestError.builder(this, Severity.ERROR, 1901)\n                        .message(tr(DUPLICATED_RELATIONS))\n                        .primitives(duplicated)\n                        .build();", "refactored_code": "    protected static final int DUPLICATE_RELATION = 1901;\n        // this test is rather speculative and works only with complete members\n        for (Set<Relation> duplicated : relations.values()) {\n            if (duplicated.size() > 1) {\n                TestError testError = TestError.builder(this, Severity.ERROR, DUPLICATE_RELATION)\n                        .message(tr(DUPLICATED_RELATIONS))\n                        .primitives(duplicated)\n                        .build();"}
{"magic_number_smell": "\n        for (Set<OsmPrimitive> duplicated : ways.values()) {\n            if (duplicated.size() > 1) {\n                TestError testError = TestError.builder(this, Severity.ERROR, 1401)\n                        .message(tr(\"Duplicated ways\"))\n                        .primitives(duplicated)\n                        .build();", "refactored_code": "    protected static final int DUPLICATE_WAY = 1401;\n\n        for (Set<OsmPrimitive> duplicated : ways.values()) {\n            if (duplicated.size() > 1) {\n                TestError testError = TestError.builder(this, Severity.ERROR, DUPLICATE_WAY)\n                        .message(tr(\"Duplicated ways\"))\n                        .primitives(duplicated)\n                        .build();"}
{"magic_number_smell": "                    // Error when the highway tags do not match\n                    String value = w.get(HIGHWAY);\n                    if (!value.equals(s)) {\n                        errors.add(TestError.builder(this, Severity.WARNING, 2701)\n                                .message(tr(\"Incorrect roundabout (highway: {0} instead of {1})\", value, s))\n                                .primitives(w)\n                                .fix(() -> new ChangePropertyCommand(w, HIGHWAY, s))", "refactored_code": "    protected static final int WRONG_ROUNDABOUT_HIGHWAY = 2701;\n                    // Error when the highway tags do not match\n                    String value = w.get(HIGHWAY);\n                    if (!value.equals(s)) {\n                        errors.add(TestError.builder(this, Severity.WARNING, WRONG_ROUNDABOUT_HIGHWAY)\n                                .message(tr(\"Incorrect roundabout (highway: {0} instead of {1})\", value, s))\n                                .primitives(w)\n                                .fix(() -> new ChangePropertyCommand(w, HIGHWAY, s))"}
{"magic_number_smell": "    public void check(OsmPrimitive p) {\n        p.visitKeys((primitive, k, value) -> {\n            // Test key against URL validator\n            if (!doTest(p, k, URL_KEYS, UrlValidator.getInstance(), 3301)) {\n                // Test key against e-mail validator only if the URL validator did not fail\n                doTest(p, k, EMAIL_KEYS, EmailValidator.getInstance(), INVALID_EMAIL);\n            }", "refactored_code": "    public static final int INVALID_URL = 3301;\n    public void check(OsmPrimitive p) {\n        p.visitKeys((primitive, k, value) -> {\n            // Test key against URL validator\n            if (!doTest(p, k, URL_KEYS, UrlValidator.getInstance(), INVALID_URL)) {\n                // Test key against e-mail validator only if the URL validator did not fail\n                doTest(p, k, EMAIL_KEYS, EmailValidator.getInstance(), INVALID_EMAIL);\n            }"}
{"magic_number_smell": "\n    private void addErrorForSegment(WaySegment waySegment, Double length) {\n        if (reported.add(waySegment)) {\n            errors.add(TestError.builder(this, Severity.WARNING, 3501)\n                    .message(tr(\"Long segments\"), marktr(\"Very long segment of {0} kilometers\"), length.intValue())\n                    .primitives(waySegment.getWay())\n                    .highlightWaySegments(Collections.singleton(waySegment))", "refactored_code": "    protected static final int LONG_SEGMENT = 3501;\n\n    private void addErrorForSegment(WaySegment waySegment, Double length) {\n        if (reported.add(waySegment)) {\n            errors.add(TestError.builder(this, Severity.WARNING, LONG_SEGMENT)\n                    .message(tr(\"Long segments\"), marktr(\"Very long segment of {0} kilometers\"), length.intValue())\n                    .primitives(waySegment.getWay())\n                    .highlightWaySegments(Collections.singleton(waySegment))"}
{"magic_number_smell": "    /**\n     * Check for:<ul>\n     * <li>{@link #WRONG_MEMBER_ROLE}: No useful role for multipolygon member</li>\n     * <li>{@link #1601}: Non-Way in multipolygon</li>\n     * </ul>\n     * @param r relation\n     * @param tmpErrors list that will contain found errors", "refactored_code": "    public static final int WRONG_MEMBER_TYPE = 1601;\n    /**\n     * Check for:<ul>\n     * <li>{@link #WRONG_MEMBER_ROLE}: No useful role for multipolygon member</li>\n     * <li>{@link #WRONG_MEMBER_TYPE}: Non-Way in multipolygon</li>\n     * </ul>\n     * @param r relation\n     * @param tmpErrors list that will contain found errors"}
{"magic_number_smell": "        String name = p.get(\"name\");\n\n        if (name == null) {\n            errors.add(TestError.builder(this, Severity.OTHER, 1501)\n                    .message(tr(\"A name is missing, even though name:* exists.\"))\n                    .primitives(p)\n                    .build());", "refactored_code": "    protected static final int NAME_MISSING = 1501;\n        String name = p.get(\"name\");\n\n        if (name == null) {\n            errors.add(TestError.builder(this, Severity.OTHER, NAME_MISSING)\n                    .message(tr(\"A name is missing, even though name:* exists.\"))\n                    .primitives(p)\n                    .build());"}
{"magic_number_smell": "            final Severity severity;\n            if (countHighway > 1) {\n                errortype = tr(\"Overlapping highways\");\n                type = 101;\n                severity = Severity.ERROR;\n            } else if (countRailway > 1) {\n                errortype = tr(\"Overlapping railways\");", "refactored_code": "    protected static final int OVERLAPPING_HIGHWAY = 101;\n            final Severity severity;\n            if (countHighway > 1) {\n                errortype = tr(\"Overlapping highways\");\n                type = OVERLAPPING_HIGHWAY;\n                severity = Severity.ERROR;\n            } else if (countRailway > 1) {\n                errortype = tr(\"Overlapping railways\");"}
{"magic_number_smell": "        // Then return the errors\n        for (Node n : missingTags) {\n            if (!isInPowerStation(n)) {\n                errors.add(TestError.builder(this, Severity.WARNING, 2501)\n                        // the \"missing tag\" grouping can become broken if the MapCSS message get reworded\n                        .message(tr(\"missing tag\"), tr(\"node without power=*\"))\n                        .primitives(n)", "refactored_code": "    protected static final int POWER_SUPPORT = 2501;\n        // Then return the errors\n        for (Node n : missingTags) {\n            if (!isInPowerStation(n)) {\n                errors.add(TestError.builder(this, Severity.WARNING, POWER_SUPPORT)\n                        // the \"missing tag\" grouping can become broken if the MapCSS message get reworded\n                        .message(tr(\"missing tag\"), tr(\"node without power=*\"))\n                        .primitives(n)"}
{"magic_number_smell": "                primitives.add(0, n);\n\n                if (!key.isEmpty()) {\n                    errors.add(TestError.builder(this, Severity.WARNING, 1701)\n                            .message(ROLE_VERIF_PROBLEM_MSG, marktr(\"Role ''{0}'' is not among expected values ''{1}''\"), key, templates)\n                            .primitives(primitives)\n                            .build());", "refactored_code": "    public static final int ROLE_UNKNOWN     = 1701;\n                primitives.add(0, n);\n\n                if (!key.isEmpty()) {\n                    errors.add(TestError.builder(this, Severity.WARNING, ROLE_UNKNOWN)\n                            .message(ROLE_VERIF_PROBLEM_MSG, marktr(\"Role ''{0}'' is not among expected values ''{1}''\"), key, templates)\n                            .primitives(primitives)\n                            .build());"}
{"magic_number_smell": "                        ok = true;\n                }\n                if (!ok || countFirst + countLast > 1) {\n                    errors.add(TestError.builder(this, Severity.WARNING, 401)\n                            .message(tr(\"Self-intersecting ways\"))\n                            .primitives(w)\n                            .highlight(n)", "refactored_code": "    protected static final int SELF_INTERSECT = 401;\n                        ok = true;\n                }\n                if (!ok || countFirst + countLast > 1) {\n                    errors.add(TestError.builder(this, Severity.WARNING, SELF_INTERSECT)\n                            .message(tr(\"Self-intersecting ways\"))\n                            .primitives(w)\n                            .highlight(n)"}
{"magic_number_smell": "public class SharpAngles extends Test {\n    private static final int 3800 = 3800;\n    /** The code for a sharp angle */\n    private static final int SHARP_ANGLES = 3800 + 0;\n    /** The maximum angle for sharp angles */\n    private double maxAngle = 45.0; // degrees\n    /** The length that at least one way segment must be shorter than */", "refactored_code": "    private static final int SHARPANGLESCODE = 3800;\npublic class SharpAngles extends Test {\n    private static final int SHARPANGLESCODE = 3800;\n    /** The code for a sharp angle */\n    private static final int SHARP_ANGLES = SHARPANGLESCODE + 0;\n    /** The maximum angle for sharp angles */\n    private double maxAngle = 45.0; // degrees\n    /** The length that at least one way segment must be shorter than */"}
{"magic_number_smell": "                    List<OsmPrimitive> primitives = new ArrayList<>(2);\n                    primitives.add(w);\n                    primitives.add(w2);\n                    errors.add(TestError.builder(this, Severity.WARNING, 701)\n                            .message(tr(\"Similarly named ways\"))\n                            .primitives(primitives)\n                            .build());", "refactored_code": "    protected static final int SIMILAR_NAMED = 701;\n                    List<OsmPrimitive> primitives = new ArrayList<>(2);\n                    primitives.add(w);\n                    primitives.add(w2);\n                    errors.add(TestError.builder(this, Severity.WARNING, SIMILAR_NAMED)\n                            .message(tr(\"Similarly named ways\"))\n                            .primitives(primitives)\n                            .build());"}
{"magic_number_smell": "                    .build());\n        }\n        if (via.isEmpty()) {\n            errors.add(TestError.builder(this, Severity.ERROR, 1801)\n                    .message(tr(\"No \\\"via\\\" node or way found\"))\n                    .primitives(r)\n                    .build());", "refactored_code": "    protected static final int NO_VIA = 1801;\n                    .build());\n        }\n        if (via.isEmpty()) {\n            errors.add(TestError.builder(this, Severity.ERROR, NO_VIA)\n                    .message(tr(\"No \\\"via\\\" node or way found\"))\n                    .primitives(r)\n                    .build());"}
{"magic_number_smell": "     * @since 6691\n     */\n    protected UnconnectedWays(String title) {\n        this(title, 1301, false);\n    }\n\n    /**", "refactored_code": "    protected static final int UNCONNECTED_WAYS = 1301;\n     * @since 6691\n     */\n    protected UnconnectedWays(String title) {\n        this(title, UNCONNECTED_WAYS, false);\n    }\n\n    /**"}
{"magic_number_smell": "        if (n.isUsable() && !n.isTagged() && n.getReferrers().isEmpty()) {\n\n            if (!n.hasKeys() && IN_DOWNLOADED_AREA.test(n)) {\n                errors.add(TestError.builder(this, Severity.WARNING, 201)\n                        .message(ERROR_MESSAGE, marktr(\"No tags\"))\n                        .primitives(n)\n                        .build());", "refactored_code": "    protected static final int UNTAGGED_NODE_BLANK = 201;\n        if (n.isUsable() && !n.isTagged() && n.getReferrers().isEmpty()) {\n\n            if (!n.hasKeys() && IN_DOWNLOADED_AREA.test(n)) {\n                errors.add(TestError.builder(this, Severity.WARNING, UNTAGGED_NODE_BLANK)\n                        .message(ERROR_MESSAGE, marktr(\"No tags\"))\n                        .primitives(n)\n                        .build());"}
{"magic_number_smell": "        }\n\n        if (w.isEmpty()) {\n            errors.add(TestError.builder(this, Severity.ERROR, 301)\n                    .message(tr(\"Empty ways\"))\n                    .primitives(w)\n                    .build());", "refactored_code": "    protected static final int EMPTY_WAY        = 301;\n        }\n\n        if (w.isEmpty()) {\n            errors.add(TestError.builder(this, Severity.ERROR, EMPTY_WAY)\n                    .message(tr(\"Empty ways\"))\n                    .primitives(w)\n                    .build());"}
{"magic_number_smell": "        if (natural == null) {\n            return;\n        } else if (\"coastline\".equals(natural) && Geometry.isClockwise(w)) {\n            reportError(w, tr(\"Reversed coastline: land not on left side\"), 1001);\n        } else if (\"land\".equals(natural) && Geometry.isClockwise(w)) {\n            reportError(w, tr(\"Reversed land: land not on left side\"), WRONGLY_ORDERED_LAND);\n        }", "refactored_code": "    protected static final int WRONGLY_ORDERED_COAST = 1001;\n        if (natural == null) {\n            return;\n        } else if (\"coastline\".equals(natural) && Geometry.isClockwise(w)) {\n            reportError(w, tr(\"Reversed coastline: land not on left side\"), WRONGLY_ORDERED_COAST);\n        } else if (\"land\".equals(natural) && Geometry.isClockwise(w)) {\n            reportError(w, tr(\"Reversed land: land not on left side\"), WRONGLY_ORDERED_LAND);\n        }"}
{"magic_number_smell": "                // 0 means that the dialog has been closed otherwise.\n                // We need to set it to zero again, in case the dialog has been re-used\n                // and the result differs from its default value\n                result = ExtendedDialog.0;\n                if (Logging.isDebugEnabled()) {\n                    Logging.debug(\"{0} ESC action performed ({1}) from {2}\",\n                            getClass().getName(), actionEvent, new Exception().getStackTrace()[1]);", "refactored_code": "    public static final int DialogClosedOtherwise = 0;\n                // 0 means that the dialog has been closed otherwise.\n                // We need to set it to zero again, in case the dialog has been re-used\n                // and the result differs from its default value\n                result = ExtendedDialog.DialogClosedOtherwise;\n                if (Logging.isDebugEnabled()) {\n                    Logging.debug(\"{0} ESC action performed ({1}) from {2}\",\n                            getClass().getName(), actionEvent, new Exception().getStackTrace()[1]);"}
{"magic_number_smell": "        protected byte[] updateData() throws IOException {\n            String motd = new WikiReader().readLang(\"StartupPage\");\n            // Save this to prefs in case JOSM is updated so MOTD can be refreshed\n            Config.getPref().putInt(\"cache.motd.html.version\", Version.getInstance().getVersion());\n            Config.getPref().put(\"cache.motd.html.java\", myJava);\n            Config.getPref().put(\"cache.motd.html.lang\", myLang);\n            return motd.getBytes(StandardCharsets.UTF_8);", "refactored_code": "        private final int myVersion = Version.getInstance().getVersion();\n        protected byte[] updateData() throws IOException {\n            String motd = new WikiReader().readLang(\"StartupPage\");\n            // Save this to prefs in case JOSM is updated so MOTD can be refreshed\n            Config.getPref().putInt(\"cache.motd.html.version\", myVersion);\n            Config.getPref().put(\"cache.motd.html.java\", myJava);\n            Config.getPref().put(\"cache.motd.html.lang\", myLang);\n            return motd.getBytes(StandardCharsets.UTF_8);"}
{"magic_number_smell": "     * @since 6088\n     */\n    public int getDefaultMenuPos() {\n         return 12;\n    }\n\n    /**", "refactored_code": "    private static final int defaultMenuPos = 12;\n     * @since 6088\n     */\n    public int getDefaultMenuPos() {\n         return defaultMenuPos;\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    public static final int 330 = 330;\n\n    private static final IntegerProperty TOGGLE_DIALOGS_WIDTH = new IntegerProperty(\"toggleDialogs.width\", 330);\n    /**\n     * Do not require to switch modes (potlatch style workflow) for drawing/selecting map modes.\n     * @since 12347", "refactored_code": "    public static final int DEF_TOGGLE_DLG_WIDTH = 330;\n     */\n    public static final int DEF_TOGGLE_DLG_WIDTH = 330;\n\n    private static final IntegerProperty TOGGLE_DIALOGS_WIDTH = new IntegerProperty(\"toggleDialogs.width\", DEF_TOGGLE_DLG_WIDTH);\n    /**\n     * Do not require to switch modes (potlatch style workflow) for drawing/selecting map modes.\n     * @since 12347"}
{"magic_number_smell": "     * @param pixel The length.\n     */\n    public void setPreferredLineLength(int pixel) {\n        setPreferredSize(new Dimension(pixel + 5 + PADDING_RIGHT, 30));\n    }\n\n    @Override", "refactored_code": "    private static final int PADDING_LEFT = 5;\n     * @param pixel The length.\n     */\n    public void setPreferredLineLength(int pixel) {\n        setPreferredSize(new Dimension(pixel + PADDING_LEFT + PADDING_RIGHT, 30));\n    }\n\n    @Override"}
{"magic_number_smell": "    @Override\n    public void zoomChanged() {\n        double maxScale = this.mv.getMaxScale();\n        int zoom = (int) Math.round(Math.log(maxScale/mv.getScale())/Math.log(1.1));\n        preventChange = true;\n        setValue(zoom);\n        lastValue = zoom;", "refactored_code": "    private static final double ZOOM_STEP = 1.1;\n    @Override\n    public void zoomChanged() {\n        double maxScale = this.mv.getMaxScale();\n        int zoom = (int) Math.round(Math.log(maxScale/mv.getScale())/Math.log(ZOOM_STEP));\n        preventChange = true;\n        setValue(zoom);\n        lastValue = zoom;"}
{"magic_number_smell": "\n        @Override\n        public int getIconHeight() {\n            return 10;\n        }\n    }\n", "refactored_code": "    private static final int ARROW_ICON_HEIGHT = 10;\n\n        @Override\n        public int getIconHeight() {\n            return ARROW_ICON_HEIGHT;\n        }\n    }\n"}
{"magic_number_smell": "        // as a result of the alignment, it is common to round \"half integer\" values\n        // like 1.49999, which is numerically unstable; add small epsilon to resolve this\n        Point2D enOriginAligned = new Point2D.Double(\n                Math.round(enOrigin.getX()) + 1e-3,\n                Math.round(enOrigin.getY()) + 1e-3);\n        EastNorth enShift = mvs.getForView(enOriginAligned.getX(), enOriginAligned.getY()).getEastNorth();\n        newCenter = newCenter.subtract(enShift);", "refactored_code": "    private static final double ALIGNMENT_EPSILON = 1e-3;\n        // as a result of the alignment, it is common to round \"half integer\" values\n        // like 1.49999, which is numerically unstable; add small epsilon to resolve this\n        Point2D enOriginAligned = new Point2D.Double(\n                Math.round(enOrigin.getX()) + ALIGNMENT_EPSILON,\n                Math.round(enOrigin.getY()) + ALIGNMENT_EPSILON);\n        EastNorth enShift = mvs.getForView(enOriginAligned.getX(), enOriginAligned.getY()).getEastNorth();\n        newCenter = newCenter.subtract(enShift);"}
{"magic_number_smell": "     */\n    public Notification setContent(String msg) {\n        JMultilineLabel lbl = new JMultilineLabel(msg);\n        lbl.setMaxWidth(350);\n        lbl.putClientProperty(JEditorPane.HONOR_DISPLAY_PROPERTIES, Boolean.TRUE);\n        lbl.setForeground(Color.BLACK);\n        content = lbl;", "refactored_code": "    public static final int DEFAULT_CONTENT_WIDTH = 350;\n     */\n    public Notification setContent(String msg) {\n        JMultilineLabel lbl = new JMultilineLabel(msg);\n        lbl.setMaxWidth(DEFAULT_CONTENT_WIDTH);\n        lbl.putClientProperty(JEditorPane.HONOR_DISPLAY_PROPERTIES, Boolean.TRUE);\n        lbl.setForeground(Color.BLACK);\n        content = lbl;"}
{"magic_number_smell": "\n        @Override\n        public void mouseReleased(MouseEvent e) {\n            ScrollViewport.this.scrollDirection = 0;\n            timer.stop();\n        }\n", "refactored_code": "    private static final int NO_SCROLL = 0;\n\n        @Override\n        public void mouseReleased(MouseEvent e) {\n            ScrollViewport.this.scrollDirection = NO_SCROLL;\n            timer.stop();\n        }\n"}
{"magic_number_smell": "            if (newMoveTaskState != scheduled) {\n                scheduled = newMoveTaskState;\n                if (newMoveTaskState) {\n                    TIMER.schedule(this, 0, 20);\n                } else {\n                    // We have to create a new instance because rescheduling a\n                    // once canceled TimerTask is not possible", "refactored_code": "    private static final long timerInterval = 20;\n            if (newMoveTaskState != scheduled) {\n                scheduled = newMoveTaskState;\n                if (newMoveTaskState) {\n                    TIMER.schedule(this, 0, timerInterval);\n                } else {\n                    // We have to create a new instance because rescheduling a\n                    // once canceled TimerTask is not possible"}
{"magic_number_smell": "\n        panel.add(new JLabel(icon), GBC.std().insets(0, 0, 10, 0));\n        JMultilineLabel messageLabel = new JMultilineLabel(message);\n        messageLabel.setMaxWidth(500);\n        panel.add(messageLabel, GBC.eol().fill());\n        content.add(panel, GBC.eop().fill(GBC.HORIZONTAL).insets(20, 10, 10, 10));\n    }", "refactored_code": "    private static final int MAX_MESSAGE_SIZE = 500;\n\n        panel.add(new JLabel(icon), GBC.std().insets(0, 0, 10, 0));\n        JMultilineLabel messageLabel = new JMultilineLabel(message);\n        messageLabel.setMaxWidth(MAX_MESSAGE_SIZE);\n        panel.add(messageLabel, GBC.eol().fill());\n        content.add(panel, GBC.eop().fill(GBC.HORIZONTAL).insets(20, 10, 10, 10));\n    }"}
{"magic_number_smell": "    }\n\n    protected void alertCopyFailedForDeletedPrimitives(List<PrimitiveId> deletedIds) {\n        List<String> items = deletedIds.stream().limit(5).map(Object::toString).collect(Collectors.toList());\n        if (deletedIds.size() > 5) {\n            items.add(tr(\"{0} more...\", deletedIds.size() - 5));\n        }", "refactored_code": "    private static final int MAX_DELETED_PRIMITIVE_IN_DIALOG = 5;\n    }\n\n    protected void alertCopyFailedForDeletedPrimitives(List<PrimitiveId> deletedIds) {\n        List<String> items = deletedIds.stream().limit(MAX_DELETED_PRIMITIVE_IN_DIALOG).map(Object::toString).collect(Collectors.toList());\n        if (deletedIds.size() > MAX_DELETED_PRIMITIVE_IN_DIALOG) {\n            items.add(tr(\"{0} more...\", deletedIds.size() - MAX_DELETED_PRIMITIVE_IN_DIALOG));\n        }"}
{"magic_number_smell": "        super(correctionTableModel);\n\n        final int correctionsSize = correctionTableModel.getCorrections().size();\n        final int lines = Math.min(correctionsSize, 10);\n        setPreferredScrollableViewportSize(new Dimension(400, lines * getRowHeight()));\n        getColumnModel().getColumn(correctionTableModel.getApplyColumn()).setPreferredWidth(40);\n        setRowSelectionAllowed(false);", "refactored_code": "    private static final int MAX_VISIBLE_LINES = 10;\n        super(correctionTableModel);\n\n        final int correctionsSize = correctionTableModel.getCorrections().size();\n        final int lines = Math.min(correctionsSize, MAX_VISIBLE_LINES);\n        setPreferredScrollableViewportSize(new Dimension(400, lines * getRowHeight()));\n        getColumnModel().getColumn(correctionTableModel.getApplyColumn()).setPreferredWidth(40);\n        setRowSelectionAllowed(false);"}
{"magic_number_smell": "            final int h = mSpltPane.getMultiSplitLayout().getModel().getBounds().getSize().height;\n\n            /* space, that is available for dialogs in default view (after the reconfiguration) */\n            final int s2 = h - (numPanels - 1) * 5 - sumC;\n\n            final int hpTrig = triggeredBy.getPreferredHeight();\n            if (hpTrig <= 0) throw new IllegalStateException(); // Must be positive", "refactored_code": "    private static final int DIVIDER_SIZE = 5;\n            final int h = mSpltPane.getMultiSplitLayout().getModel().getBounds().getSize().height;\n\n            /* space, that is available for dialogs in default view (after the reconfiguration) */\n            final int s2 = h - (numPanels - 1) * DIVIDER_SIZE - sumC;\n\n            final int hpTrig = triggeredBy.getPreferredHeight();\n            if (hpTrig <= 0) throw new IllegalStateException(); // Must be positive"}
{"magic_number_smell": "        }\n        Filter f = model.getValue(row);\n        switch (column) {\n        case 0:\n            f.enable = (Boolean) aValue;\n            break;\n        case COL_HIDING:", "refactored_code": "    public static final int COL_ENABLED = 0;\n        }\n        Filter f = model.getValue(row);\n        switch (column) {\n        case COL_ENABLED:\n            f.enable = (Boolean) aValue;\n            break;\n        case COL_HIDING:"}
{"magic_number_smell": "                    .filter(i -> history.get(i).equals(selection))\n                    .findFirst()\n                    .ifPresent(i -> history.remove(i));\n            int maxsize = Config.getPref().getInt(\"select.history-size\", 10);\n            while (history.size() > maxsize) {\n                history.removeLast();\n            }", "refactored_code": "        private static final int SELECTION_HISTORY_SIZE = 10;\n                    .filter(i -> history.get(i).equals(selection))\n                    .findFirst()\n                    .ifPresent(i -> history.remove(i));\n            int maxsize = Config.getPref().getInt(\"select.history-size\", SELECTION_HISTORY_SIZE);\n            while (history.size() > maxsize) {\n                history.removeLast();\n            }"}
{"magic_number_smell": "            add(slider, GBC.eol());\n            addMouseWheelListener(this::mouseWheelMoved);\n\n            slider.setMaximum(100);\n            int tick = convertFromRealValue(1);\n            slider.setMinorTickSpacing(tick);\n            slider.setMajorTickSpacing(tick);", "refactored_code": "    private static final int SLIDER_STEPS = 100;\n            add(slider, GBC.eol());\n            addMouseWheelListener(this::mouseWheelMoved);\n\n            slider.setMaximum(SLIDER_STEPS);\n            int tick = convertFromRealValue(1);\n            slider.setMinorTickSpacing(tick);\n            slider.setMajorTickSpacing(tick);"}
{"magic_number_smell": "    public static final BooleanProperty PROPERTY_REMEMBER_TAGS = new BooleanProperty(\"properties.remember-recently-added-tags\", true);\n    /** Number of recent tags */\n    public static final IntegerProperty PROPERTY_RECENT_TAGS_NUMBER = new IntegerProperty(\"properties.recently-added-tags\",\n            5);\n    /** The preference storage of recent tags */\n    public static final ListProperty PROPERTY_RECENT_TAGS = new ListProperty(\"properties.recent-tags\",\n            Collections.<String>emptyList());", "refactored_code": "    public static final int DEFAULT_LRU_TAGS_NUMBER = 5;\n    public static final BooleanProperty PROPERTY_REMEMBER_TAGS = new BooleanProperty(\"properties.remember-recently-added-tags\", true);\n    /** Number of recent tags */\n    public static final IntegerProperty PROPERTY_RECENT_TAGS_NUMBER = new IntegerProperty(\"properties.recently-added-tags\",\n            DEFAULT_LRU_TAGS_NUMBER);\n    /** The preference storage of recent tags */\n    public static final ListProperty PROPERTY_RECENT_TAGS = new ListProperty(\"properties.recent-tags\",\n            Collections.<String>emptyList());"}
{"magic_number_smell": "     * The toolbar with the buttons on the left\n     */\n    static class LeftButtonToolbar extends JToolBar {\n        private static final long 1L = 1L;\n\n        /**\n         * Constructs a new {@code LeftButtonToolbar}.", "refactored_code": "                private static final long serialVersionUID = 1L;\n     * The toolbar with the buttons on the left\n     */\n    static class LeftButtonToolbar extends JToolBar {\n        private static final long serialVersionUID = 1L;\n\n        /**\n         * Constructs a new {@code LeftButtonToolbar}."}
{"magic_number_smell": "\n        firstGroupIdx = 0;\n\n        lastForwardWay = Integer.MIN_VALUE;\n        lastBackwardWay = Integer.MIN_VALUE;\n        onewayBeginning = false;\n        WayConnectionType lastWct = null;", "refactored_code": "    private static final int UNCONNECTED = Integer.MIN_VALUE;\n\n        firstGroupIdx = 0;\n\n        lastForwardWay = UNCONNECTED;\n        lastBackwardWay = UNCONNECTED;\n        onewayBeginning = false;\n        WayConnectionType lastWct = null;"}
{"magic_number_smell": "    @Override\n    public void buttonAction(int buttonIndex, ActionEvent evt) {\n        switch (buttonIndex) {\n            case 0:\n                if (this.buildQueryAction()) {\n                    this.saveHistory();\n                    super.buttonAction(0, evt);", "refactored_code": "    private static final int BUILD_QUERY = 0;\n    @Override\n    public void buttonAction(int buttonIndex, ActionEvent evt) {\n        switch (buttonIndex) {\n            case BUILD_QUERY:\n                if (this.buildQueryAction()) {\n                    this.saveHistory();\n                    super.buttonAction(BUILD_QUERY, evt);"}
{"magic_number_smell": "            panel.add(this.name, GBC.eol().insets(5).anchor(GBC.SOUTHEAST).fill(GBC.HORIZONTAL));\n            panel.add(queryScrollPane, constraint);\n\n            setDefaultButton(0 + 1);\n            setCancelButton(CANCEL_BTN + 1);\n            setPreferredSize(new Dimension(400, 400));\n            setContent(panel, false);", "refactored_code": "        private static final int SUCCESS_BTN = 0;\n            panel.add(this.name, GBC.eol().insets(5).anchor(GBC.SOUTHEAST).fill(GBC.HORIZONTAL));\n            panel.add(queryScrollPane, constraint);\n\n            setDefaultButton(SUCCESS_BTN + 1);\n            setCancelButton(CANCEL_BTN + 1);\n            setPreferredSize(new Dimension(400, 400));\n            setContent(panel, false);"}
{"magic_number_smell": "    protected void createColumns() {\n        TagTableCellRenderer renderer = new TagTableCellRenderer();\n\n        TableColumn col = new TableColumn(0);\n        col.setHeaderValue(tr(\"Key\"));\n        col.setCellRenderer(renderer);\n        col.setPreferredWidth(100);", "refactored_code": "    protected static final int COLUMN_KEY = 0;\n    protected void createColumns() {\n        TagTableCellRenderer renderer = new TagTableCellRenderer();\n\n        TableColumn col = new TableColumn(COLUMN_KEY);\n        col.setHeaderValue(tr(\"Key\"));\n        col.setCellRenderer(renderer);\n        col.setPreferredWidth(100);"}
{"magic_number_smell": "        VersionTable.RadioButtonRenderer bRenderer = new VersionTable.RadioButtonRenderer();\n\n        // column 0 - Version\n        TableColumn col = new TableColumn(0);\n        /* translation note: 3 letter abbr. for \"Version\" */\n        col.setHeaderValue(tr(\"Ver\"));\n        col.setCellRenderer(new VersionTableCellRenderer());", "refactored_code": "    public static final int COL_VERSION = 0;\n        VersionTable.RadioButtonRenderer bRenderer = new VersionTable.RadioButtonRenderer();\n\n        // column 0 - Version\n        TableColumn col = new TableColumn(COL_VERSION);\n        /* translation note: 3 letter abbr. for \"Version\" */\n        col.setHeaderValue(tr(\"Ver\"));\n        col.setCellRenderer(new VersionTableCellRenderer());"}
{"magic_number_smell": "\n    @Override\n    public boolean isCellEditable(int row, int column) {\n        return column == 0 || column == columnActions;\n    }\n\n    @Override", "refactored_code": "    private static final int columnFilename = 0;\n\n    @Override\n    public boolean isCellEditable(int row, int column) {\n        return column == columnFilename || column == columnActions;\n    }\n\n    @Override"}
{"magic_number_smell": "\n        if (layer instanceof AbstractTileSourceLayer) {\n            try (ObjectOutputStream oos = new ObjectOutputStream(Files.newOutputStream(file.toPath()))) {\n                oos.writeInt(6); // file version\n                oos.writeObject(MainApplication.getMap().mapView.getCenter());\n                ImageryPreferenceEntry entry = new ImageryPreferenceEntry(((AbstractTileSourceLayer<?>) layer).getInfo());\n                oos.writeObject(StructUtils.serializeStruct(entry, ImageryPreferenceEntry.class));", "refactored_code": "    public static final int CURRENT_FILE_VERSION = 6;\n\n        if (layer instanceof AbstractTileSourceLayer) {\n            try (ObjectOutputStream oos = new ObjectOutputStream(Files.newOutputStream(file.toPath()))) {\n                oos.writeInt(CURRENT_FILE_VERSION); // file version\n                oos.writeObject(MainApplication.getMap().mapView.getCenter());\n                ImageryPreferenceEntry entry = new ImageryPreferenceEntry(((AbstractTileSourceLayer<?>) layer).getInfo());\n                oos.writeObject(StructUtils.serializeStruct(entry, ImageryPreferenceEntry.class));"}
{"magic_number_smell": "            }\n            if (tooLarge()) {\n                // Too many tiles... refuse to download\n                Logging.warn(\"Not downloading all tiles because there is more than {0} tiles on an axis!\", 40);\n                return;\n            }\n            List<Tile> allTiles = allTilesCreate();", "refactored_code": "    private static final int MAX_TILES_SPANNED = 40;\n            }\n            if (tooLarge()) {\n                // Too many tiles... refuse to download\n                Logging.warn(\"Not downloading all tiles because there is more than {0} tiles on an axis!\", MAX_TILES_SPANNED);\n                return;\n            }\n            List<Tile> allTiles = allTilesCreate();"}
{"magic_number_smell": "     * Initialize the hatch pattern used to paint the non-downloaded area\n     */\n    public static void createHatchTexture() {\n        BufferedImage bi = new BufferedImage(15, 15, BufferedImage.TYPE_INT_ARGB);\n        Graphics2D big = bi.createGraphics();\n        big.setColor(getBackgroundColor());\n        Composite comp = AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.3f);", "refactored_code": "    private static final int HATCHED_SIZE = 15;\n     * Initialize the hatch pattern used to paint the non-downloaded area\n     */\n    public static void createHatchTexture() {\n        BufferedImage bi = new BufferedImage(HATCHED_SIZE, HATCHED_SIZE, BufferedImage.TYPE_INT_ARGB);\n        Graphics2D big = bi.createGraphics();\n        big.setColor(getBackgroundColor());\n        Composite comp = AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.3f);"}
{"magic_number_smell": "    }\n\n    private static ScaleList initNativeScaleList() {\n        Collection<Double> scales = IntStream.rangeClosed(AbstractTileSourceLayer.MIN_ZOOM, AbstractTileSourceLayer.JMapViewer.MAX_ZOOM)\n                .mapToDouble(zoom -> OsmMercator.EARTH_RADIUS * Math.PI * 2 / Math.pow(2, zoom) / OsmMercator.DEFAUL_TILE_SIZE)\n                .boxed()\n                .collect(Collectors.toList());", "refactored_code": "    public static final int MAX_ZOOM = JMapViewer.MAX_ZOOM;\n    }\n\n    private static ScaleList initNativeScaleList() {\n        Collection<Double> scales = IntStream.rangeClosed(AbstractTileSourceLayer.MIN_ZOOM, AbstractTileSourceLayer.MAX_ZOOM)\n                .mapToDouble(zoom -> OsmMercator.EARTH_RADIUS * Math.PI * 2 / Math.pow(2, zoom) / OsmMercator.DEFAUL_TILE_SIZE)\n                .boxed()\n                .collect(Collectors.toList());"}
{"magic_number_smell": "                return NOTHING;\n            int answer = syncDialog.getValue();\n            if (answer != 1)\n                return -1;\n\n            // Parse values again, to display an error if the format is not recognized\n            try {", "refactored_code": "        private static final int CANCEL = -1;\n                return NOTHING;\n            int answer = syncDialog.getValue();\n            if (answer != 1)\n                return CANCEL;\n\n            // Parse values again, to display an error if the format is not recognized\n            try {"}
{"magic_number_smell": "    }\n\n    private BufferedImage loadThumb(ImageEntry entry) {\n        final String cacheIdent = entry.getFile().toString() + ICache.NAME_COMPONENT_DELIMITER + 120;\n\n        if (!cacheOff && cache != null) {\n            try {", "refactored_code": "    public static final int maxSize = 120;\n    }\n\n    private BufferedImage loadThumb(ImageEntry entry) {\n        final String cacheIdent = entry.getFile().toString() + ICache.NAME_COMPONENT_DELIMITER + maxSize;\n\n        if (!cacheOff && cache != null) {\n            try {"}
{"magic_number_smell": "\n        // Convert the GPX data into a Path2D.\n        Path2D gpxPath = new Path2D.Double();\n        if (near == 0 || near == NEAR_BOTH) {\n            data.stream().flatMap(GpxData::getTrackSegmentsStream).forEach(segment -> {\n                boolean first = true;\n                for (WayPoint p : segment.getWayPoints()) {", "refactored_code": "    private static final int NEAR_TRACK = 0;\n\n        // Convert the GPX data into a Path2D.\n        Path2D gpxPath = new Path2D.Double();\n        if (near == NEAR_TRACK || near == NEAR_BOTH) {\n            data.stream().flatMap(GpxData::getTrackSegmentsStream).forEach(segment -> {\n                boolean first = true;\n                for (WayPoint p : segment.getWayPoints()) {"}
{"magic_number_smell": "            int r = red[i] & 0xff;\n            int g = green[i] & 0xff;\n            int b = blue[i] & 0xff;\n            double luminosity = r * .21d + g * LUMINOSITY_GREEN + b * LUMINOSITY_BLUE;\n            red[i] = mix(r, luminosity);\n            green[i] = mix(g, luminosity);\n            blue[i] = mix(b, luminosity);", "refactored_code": "    private static final double LUMINOSITY_RED = .21d;\n            int r = red[i] & 0xff;\n            int g = green[i] & 0xff;\n            int b = blue[i] & 0xff;\n            double luminosity = r * LUMINOSITY_RED + g * LUMINOSITY_GREEN + b * LUMINOSITY_BLUE;\n            red[i] = mix(r, luminosity);\n            green[i] = mix(g, luminosity);\n            blue[i] = mix(b, luminosity);"}
{"magic_number_smell": "                if (scale == null) {\n                    if (argScale != null) {\n                        enPerMeter = getEnPerMeter.getAsDouble();\n                        scale = argScale * enPerMeter / 96 / 2.54 * 100;\n                    } else if (argWidthM != null && argWidthPx != null) {\n                        enPerMeter = getEnPerMeter.getAsDouble();\n                        scale = argWidthM / argWidthPx * enPerMeter;", "refactored_code": "    private static final double PIXEL_PER_METER = 96 / 2.54 * 100; // standard value of 96 dpi display resolution\n                if (scale == null) {\n                    if (argScale != null) {\n                        enPerMeter = getEnPerMeter.getAsDouble();\n                        scale = argScale * enPerMeter / PIXEL_PER_METER;\n                    } else if (argWidthM != null && argWidthPx != null) {\n                        enPerMeter = getEnPerMeter.getAsDouble();\n                        scale = argWidthM / argWidthPx * enPerMeter;"}
{"magic_number_smell": "    }\n\n    private boolean mustRescale(Image image) {\n        return autoRescale && width == -1 && image.getWidth(null) > 48\n             && height == -1 && image.getHeight(null) > 48;\n    }\n", "refactored_code": "    private static final int MAX_SIZE = 48;\n    }\n\n    private boolean mustRescale(Image image) {\n        return autoRescale && width == -1 && image.getWidth(null) > MAX_SIZE\n             && height == -1 && image.getHeight(null) > MAX_SIZE;\n    }\n"}
{"magic_number_smell": "            }\n        }\n        if (!found) {\n            cb.setSelectedIndex(6);\n            tf.setEnabled(true);\n            tf.setText(labelPattern);\n        }", "refactored_code": "    private static final int WAYPOINT_LABEL_CUSTOM = 6;\n            }\n        }\n        if (!found) {\n            cb.setSelectedIndex(WAYPOINT_LABEL_CUSTOM);\n            tf.setEnabled(true);\n            tf.setText(labelPattern);\n        }"}
{"magic_number_smell": "\n        // Tile size\n        JLabel labelTileSize = new JLabel(tr(\"Tile size:\"));\n        int tileSizeValue = Utils.clamp(WMSLayer.PROP_IMAGE_SIZE.get(), 1, IMAGE_SIZE_MAX);\n        tileSize = new JSpinner(new SpinnerNumberModel(tileSizeValue, 1, IMAGE_SIZE_MAX, 128));\n        labelTileSize.setLabelFor(tileSize);\n        add(labelTileSize, GBC.std());", "refactored_code": "    private static final int IMAGE_SIZE_MIN = 1;\n\n        // Tile size\n        JLabel labelTileSize = new JLabel(tr(\"Tile size:\"));\n        int tileSizeValue = Utils.clamp(WMSLayer.PROP_IMAGE_SIZE.get(), IMAGE_SIZE_MIN, IMAGE_SIZE_MAX);\n        tileSize = new JSpinner(new SpinnerNumberModel(tileSizeValue, IMAGE_SIZE_MIN, IMAGE_SIZE_MAX, 128));\n        labelTileSize.setLabelFor(tileSize);\n        add(labelTileSize, GBC.std());"}
{"magic_number_smell": "    private static final long -2479852374189976764L = -2479852374189976764L;\n\n    static final class AutoSizePanel extends JPanel {\n        private static final long -2479852374189976764L = 7469560761925020366L;\n\n        AutoSizePanel() {\n            super(new GridBagLayout());", "refactored_code": "    private static final long serialVersionUID = -2479852374189976764L;\n    private static final long serialVersionUID = -2479852374189976764L;\n\n    static final class AutoSizePanel extends JPanel {\n        private static final long serialVersionUID = 7469560761925020366L;\n\n        AutoSizePanel() {\n            super(new GridBagLayout());"}
{"magic_number_smell": "            dialog.setInBackgroundCallback(inBackgroundListener);\n            dialog.setCustomText(\"\");\n            dialog.addWindowListener(windowListener);\n            dialog.setMaximumProgress(10_000);\n            dialog.setVisible(true);\n        });\n    }", "refactored_code": "    public static final int PROGRESS_BAR_MAX = 10_000;\n            dialog.setInBackgroundCallback(inBackgroundListener);\n            dialog.setCustomText(\"\");\n            dialog.addWindowListener(windowListener);\n            dialog.setMaximumProgress(PROGRESS_BAR_MAX);\n            dialog.setVisible(true);\n        });\n    }"}
{"magic_number_smell": "    public void doBeginTask() {\n        GuiHelper.runInEDT(() -> {\n            delegate.setCustomText(\"\");\n            delegate.setMaximum(100);\n        });\n    }\n", "refactored_code": "    private static final int PROGRESS_BAR_MAX = 100;\n    public void doBeginTask() {\n        GuiHelper.runInEDT(() -> {\n            delegate.setCustomText(\"\");\n            delegate.setMaximum(PROGRESS_BAR_MAX);\n        });\n    }\n"}
{"magic_number_smell": "    /**\n     * This event id indicates that an autocomp is about to start.\n     */\n    public static final int AUTOCOMP_BEFORE = 5900;\n\n    /**\n     * This event id indicates that an autocomp completed.", "refactored_code": "    public static final int AUTOCOMP_FIRST = 5900;\n    /**\n     * This event id indicates that an autocomp is about to start.\n     */\n    public static final int AUTOCOMP_BEFORE = AUTOCOMP_FIRST;\n\n    /**\n     * This event id indicates that an autocomp completed."}
{"magic_number_smell": "        Collection<OsmPrimitive> sel = createSelection(primitives);\n        int answer = showDialog(sel, supportsRelation());\n\n        if (!sel.isEmpty() && answer == 1) {\n            Command cmd = createCommand(sel, getChangedTags());\n            if (cmd != null) {\n                UndoRedoHandler.getInstance().add(cmd);", "refactored_code": "    public static final int DIALOG_ANSWER_APPLY = 1;\n        Collection<OsmPrimitive> sel = createSelection(primitives);\n        int answer = showDialog(sel, supportsRelation());\n\n        if (!sel.isEmpty() && answer == DIALOG_ANSWER_APPLY) {\n            Command cmd = createCommand(sel, getChangedTags());\n            if (cmd != null) {\n                UndoRedoHandler.getInstance().add(cmd);"}
{"magic_number_smell": "        public final TaggingPreset preset;\n        /**\n         * The classification for the preset (see {@link #CLASSIFICATION_TAGS_MATCH}, {@link #CLASSIFICATION_GROUP_MATCH},\n         * {@link #CLASSIFICATION_NAME_MATCH}, and {@link #300}). Higher numbers are better.\n         */\n        public int classification;\n        /**", "refactored_code": "    private static final int CLASSIFICATION_IN_FAVORITES = 300;\n        public final TaggingPreset preset;\n        /**\n         * The classification for the preset (see {@link #CLASSIFICATION_TAGS_MATCH}, {@link #CLASSIFICATION_GROUP_MATCH},\n         * {@link #CLASSIFICATION_NAME_MATCH}, and {@link #CLASSIFICATION_IN_FAVORITES}). Higher numbers are better.\n         */\n        public int classification;\n        /**"}
{"magic_number_smell": "        public void actionPerformed(ActionEvent e) {\n            lastTimestamp = e.getWhen();\n            lastAction = this;\n            timer.schedule(new MyTimerTask(lastTimestamp, lastAction), 1000);\n            MainApplication.getMap().statusLine.setHelpText(STATUS_BAR_ID,\n                    tr(\"{0}... [please type its number]\", (String) action.getValue(SHORT_DESCRIPTION)));\n        }", "refactored_code": "    private static final long DIALOG_DELAY = 1000;\n        public void actionPerformed(ActionEvent e) {\n            lastTimestamp = e.getWhen();\n            lastAction = this;\n            timer.schedule(new MyTimerTask(lastTimestamp, lastAction), DIALOG_DELAY);\n            MainApplication.getMap().statusLine.setHelpText(STATUS_BAR_ID,\n                    tr(\"{0}... [please type its number]\", (String) action.getValue(SHORT_DESCRIPTION)));\n        }"}
{"magic_number_smell": "                            AWTEvent.MOUSE_EVENT_MASK |\n                            AWTEvent.MOUSE_MOTION_EVENT_MASK |\n                            AWTEvent.MOUSE_WHEEL_EVENT_MASK |\n                            AWTEvent.WINDOW_EVENT_MASK | (b ? 0 : 0x80000000));\n                    return null;\n                });\n            } catch (ReflectiveOperationException | RuntimeException e) {", "refactored_code": "    private static final int GRAB_EVENT_MASK = 0x80000000;\n                            AWTEvent.MOUSE_EVENT_MASK |\n                            AWTEvent.MOUSE_MOTION_EVENT_MASK |\n                            AWTEvent.MOUSE_WHEEL_EVENT_MASK |\n                            AWTEvent.WINDOW_EVENT_MASK | (b ? 0 : GRAB_EVENT_MASK));\n                    return null;\n                });\n            } catch (ReflectiveOperationException | RuntimeException e) {"}
{"magic_number_smell": "        final double cosBeta = this.rotation.getPolarAngleCos();\n        final double sinBeta = this.rotation.getPolarAngleSin();\n        final double x = vec.getX();\n        final double y = -1 * vec.getY();\n        final double z = vec.getZ();\n        vecX = y * (cosAlpha * sinBeta * sinGamma - sinAlpha * cosGamma)\n                + z * (cosAlpha * sinBeta * cosGamma + sinAlpha * sinGamma) + x * cosAlpha * cosBeta;", "refactored_code": "    private static final byte YAW_DIRECTION = -1;\n        final double cosBeta = this.rotation.getPolarAngleCos();\n        final double sinBeta = this.rotation.getPolarAngleSin();\n        final double x = vec.getX();\n        final double y = YAW_DIRECTION * vec.getY();\n        final double z = vec.getZ();\n        vecX = y * (cosAlpha * sinBeta * sinGamma - sinAlpha * cosGamma)\n                + z * (cosAlpha * sinBeta * cosGamma + sinAlpha * sinGamma) + x * cosAlpha * cosBeta;"}
{"magic_number_smell": "     * @return a point on the texture image somewhere in the rectangle between (0, 0) and (1, 1)\n     */\n    public static Point2D.Double getTextureCoordinate(final Vector3D vector) {\n        final double u = 0.5 + (Math.atan2(vector.getX(), vector.getZ()) / 2 * Math.PI);\n        final double v = 0.5 + (Math.asin(vector.getY()) / Math.PI);\n        return new Point2D.Double(u, v);\n    }", "refactored_code": "    private static final double TWO_PI = 2 * Math.PI;\n     * @return a point on the texture image somewhere in the rectangle between (0, 0) and (1, 1)\n     */\n    public static Point2D.Double getTextureCoordinate(final Vector3D vector) {\n        final double u = 0.5 + (Math.atan2(vector.getX(), vector.getZ()) / TWO_PI);\n        final double v = 0.5 + (Math.asin(vector.getY()) / Math.PI);\n        return new Point2D.Double(u, v);\n    }"}
{"magic_number_smell": "        spinner.setPreferredSize(new Dimension(spinner.getPreferredSize().width+5,\n        spinner.getPreferredSize().height));\n\n        slider = new JSlider(0, 300);\n        spinner.addChangeListener(e -> {\n            int i = slider.getValue();\n            Date d = (Date) spinner.getValue();", "refactored_code": "    private static final int MAX_SLIDER = 300;\n        spinner.setPreferredSize(new Dimension(spinner.getPreferredSize().width+5,\n        spinner.getPreferredSize().height));\n\n        slider = new JSlider(0, MAX_SLIDER);\n        spinner.addChangeListener(e -> {\n            int i = slider.getValue();\n            Date d = (Date) spinner.getValue();"}
{"magic_number_smell": "    private void doRefreshImage() throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {\n        synchronized (this) {\n            // clear out width/height/reloadimage flag and set loading flag\n            stateField.set(this, ((int) stateField.get(this) | 1 | RELOAD_IMAGE_FLAG | WIDTH_FLAG |\n                     HEIGHT_FLAG) ^ (WIDTH_FLAG | HEIGHT_FLAG |\n                                     RELOAD_IMAGE_FLAG));\n            imageField.set(this, null);", "refactored_code": "    private static final int LOADING_FLAG = 1;\n    private void doRefreshImage() throws IllegalAccessException, InvocationTargetException, NoSuchMethodException {\n        synchronized (this) {\n            // clear out width/height/reloadimage flag and set loading flag\n            stateField.set(this, ((int) stateField.get(this) | LOADING_FLAG | RELOAD_IMAGE_FLAG | WIDTH_FLAG |\n                     HEIGHT_FLAG) ^ (WIDTH_FLAG | HEIGHT_FLAG |\n                                     RELOAD_IMAGE_FLAG));\n            imageField.set(this, null);"}
{"magic_number_smell": "            if (!localFile.exists()) {\n                localFile = null;\n            } else {\n                if (maxAge == -1L\n                        || maxAge <= 0 // arbitrary value <= 0 is deprecated\n                ) {\n                    maxAgeMillis = TimeUnit.SECONDS.toMillis(Config.getPref().getLong(\"mirror.maxtime\", TimeUnit.DAYS.toSeconds(7)));", "refactored_code": "    public static final long DEFAULT_MAXTIME = -1L;\n            if (!localFile.exists()) {\n                localFile = null;\n            } else {\n                if (maxAge == DEFAULT_MAXTIME\n                        || maxAge <= 0 // arbitrary value <= 0 is deprecated\n                ) {\n                    maxAgeMillis = TimeUnit.SECONDS.toMillis(Config.getPref().getLong(\"mirror.maxtime\", TimeUnit.DAYS.toSeconds(7)));"}
{"magic_number_smell": "     */\n    public ChangesetQuery forChangesetIds(Collection<Long> changesetIds) {\n        CheckParameterUtil.ensureParameterNotNull(changesetIds, \"changesetIds\");\n        if (changesetIds.size() > 100) {\n            Logging.warn(\"Changeset query built with more than \" + 100 + \" changeset ids (\" + changesetIds.size() + ')');\n        }\n        this.changesetIds = changesetIds;", "refactored_code": "    public static final int MAX_CHANGESETS_NUMBER = 100;\n     */\n    public ChangesetQuery forChangesetIds(Collection<Long> changesetIds) {\n        CheckParameterUtil.ensureParameterNotNull(changesetIds, \"changesetIds\");\n        if (changesetIds.size() > MAX_CHANGESETS_NUMBER) {\n            Logging.warn(\"Changeset query built with more than \" + MAX_CHANGESETS_NUMBER + \" changeset ids (\" + changesetIds.size() + ')');\n        }\n        this.changesetIds = changesetIds;"}
{"magic_number_smell": "    /**\n     * Check if the inputstream follows RFC 7464\n     * @param source The source to check (should be at the beginning)\n     * @return {@code true} if the initial character is {@link GeoJSONReader#0x1E}.\n     */\n    private static boolean isLineDelimited(InputStream source) {\n        source.mark(2);", "refactored_code": "    private static final byte RECORD_SEPARATOR_BYTE = 0x1E;\n    /**\n     * Check if the inputstream follows RFC 7464\n     * @param source The source to check (should be at the beginning)\n     * @return {@code true} if the initial character is {@link GeoJSONReader#RECORD_SEPARATOR_BYTE}.\n     */\n    private static boolean isLineDelimited(InputStream source) {\n        source.mark(2);"}
{"magic_number_smell": "\n    private void writeWayPoints() {\n        for (WayPoint pnt : data.getWaypoints()) {\n            wayPoint(pnt, 0);\n        }\n    }\n", "refactored_code": "    private static final int WAY_POINT = 0;\n\n    private void writeWayPoints() {\n        for (WayPoint pnt : data.getWaypoints()) {\n            wayPoint(pnt, WAY_POINT);\n        }\n    }\n"}
{"magic_number_smell": "    }\n\n    /**\n     * extracts a subset of max {@link #170} ids from <code>ids</code> and\n     * replies the subset. The extracted subset is removed from <code>ids</code>.\n     *\n     * @param ids a set of ids", "refactored_code": "    private static final int MAX_IDS_PER_REQUEST = 170;\n    }\n\n    /**\n     * extracts a subset of max {@link #MAX_IDS_PER_REQUEST} ids from <code>ids</code> and\n     * replies the subset. The extracted subset is removed from <code>ids</code>.\n     *\n     * @param ids a set of ids"}
{"magic_number_smell": "     * @return the max number of retries\n     */\n    protected int getMaxRetries() {\n        int ret = Config.getPref().getInt(\"osm-server.max-num-retries\", 5);\n        return Math.max(ret, 0);\n    }\n", "refactored_code": "    public static final int DEFAULT_MAX_NUM_RETRIES = 5;\n     * @return the max number of retries\n     */\n    protected int getMaxRetries() {\n        int ret = Config.getPref().getInt(\"osm-server.max-num-retries\", DEFAULT_MAX_NUM_RETRIES);\n        return Math.max(ret, 0);\n    }\n"}
{"magic_number_smell": "            while (bboxParser.hasNext()) {\n                ProtobufRecord protobufRecord = new ProtobufRecord(baos, bboxParser);\n                if (protobufRecord.getType() == WireType.VARINT) {\n                    double value = protobufRecord.asSignedVarInt().longValue() * 1e-9;\n                    switch (protobufRecord.getField()) {\n                        case 1:\n                            left = value;", "refactored_code": "    private static final double NANO_DEGREES = 1e-9;\n            while (bboxParser.hasNext()) {\n                ProtobufRecord protobufRecord = new ProtobufRecord(baos, bboxParser);\n                if (protobufRecord.getType() == WireType.VARINT) {\n                    double value = protobufRecord.asSignedVarInt().longValue() * NANO_DEGREES;\n                    switch (protobufRecord.getField()) {\n                        case 1:\n                            left = value;"}
{"magic_number_smell": "     */\n    public UploadStrategySpecification() {\n        this.strategy = UploadStrategy.DEFAULT_UPLOAD_STRATEGY;\n        this.chunkSize = -1;\n        this.policy = null;\n        this.closeChangesetAfterUpload = true;\n    }", "refactored_code": "    public static final int UNSPECIFIED_CHUNK_SIZE = -1;\n     */\n    public UploadStrategySpecification() {\n        this.strategy = UploadStrategy.DEFAULT_UPLOAD_STRATEGY;\n        this.chunkSize = UNSPECIFIED_CHUNK_SIZE;\n        this.policy = null;\n        this.closeChangesetAfterUpload = true;\n    }"}
{"magic_number_smell": "    private final double calibration; // ratio of purported duration of samples to true duration\n\n    private double bytesPerSecond;\n    private final byte[] abData = new byte[4000];\n\n    private double position; // seconds\n    private double speed = 1.0;", "refactored_code": "    private static final int chunk = 4000; /* bytes */\n    private final double calibration; // ratio of purported duration of samples to true duration\n\n    private double bytesPerSecond;\n    private final byte[] abData = new byte[chunk];\n\n    private double position; // seconds\n    private double speed = 1.0;"}
{"magic_number_smell": "                            WayPoint currentwp = new WayPoint(new LatLon(\n                                    Double.parseDouble(fields[IDX_LAT]),\n                                    Double.parseDouble(fields[IDX_LON])));\n                            currentwp.put(GpxConstants.GPX_NAME, fields[1]);\n                            currentwp.put(GpxConstants.GPX_DESC, fields[IDX_DESC]);\n                            String ele = fields[IDX_ELE];\n                            if (!ele.isEmpty()) {", "refactored_code": "    private static final int IDX_NAME = 1;\n                            WayPoint currentwp = new WayPoint(new LatLon(\n                                    Double.parseDouble(fields[IDX_LAT]),\n                                    Double.parseDouble(fields[IDX_LON])));\n                            currentwp.put(GpxConstants.GPX_NAME, fields[IDX_NAME]);\n                            currentwp.put(GpxConstants.GPX_DESC, fields[IDX_DESC]);\n                            String ele = fields[IDX_ELE];\n                            if (!ele.isEmpty()) {"}
{"magic_number_smell": "                                    Double.parseDouble(fields[IDX_LAT]),\n                                    Double.parseDouble(fields[IDX_LON])));\n                            currentwp.put(GpxConstants.PT_ELE, fields[IDX_HEIGHT]);\n                            currentwp.setInstant(DateUtils.parseInstant(fields[0]+\" \"+fields[IDX_TIME]));\n                            currentwp.put(GpxConstants.RTKLIB_Q, Integer.parseInt(fields[IDX_Q]));\n                            currentwp.put(GpxConstants.PT_SAT, fields[IDX_NS]);\n                            currentwp.put(GpxConstants.RTKLIB_SDN, fields[IDX_SDN]);", "refactored_code": "    private static final int IDX_DATE = 0;\n                                    Double.parseDouble(fields[IDX_LAT]),\n                                    Double.parseDouble(fields[IDX_LON])));\n                            currentwp.put(GpxConstants.PT_ELE, fields[IDX_HEIGHT]);\n                            currentwp.setInstant(DateUtils.parseInstant(fields[IDX_DATE]+\" \"+fields[IDX_TIME]));\n                            currentwp.put(GpxConstants.RTKLIB_Q, Integer.parseInt(fields[IDX_Q]));\n                            currentwp.put(GpxConstants.PT_SAT, fields[IDX_NS]);\n                            currentwp.put(GpxConstants.RTKLIB_SDN, fields[IDX_SDN]);"}
{"magic_number_smell": "        } else {\n            long tim = System.currentTimeMillis();\n            long last = Config.getPref().getLong(\"pluginmanager.lastupdate\", 0);\n            int maxTime = Config.getPref().getInt(\"pluginmanager.time-based-update.interval\", 30);\n            long d = TimeUnit.MILLISECONDS.toDays(tim - last);\n            if ((last <= 0) || (maxTime <= 0)) {\n                Config.getPref().put(\"pluginmanager.lastupdate\", Long.toString(tim));", "refactored_code": "    public static final int DEFAULT_TIME_BASED_UPDATE_INTERVAL = 30;\n        } else {\n            long tim = System.currentTimeMillis();\n            long last = Config.getPref().getLong(\"pluginmanager.lastupdate\", 0);\n            int maxTime = Config.getPref().getInt(\"pluginmanager.time-based-update.interval\", DEFAULT_TIME_BASED_UPDATE_INTERVAL);\n            long d = TimeUnit.MILLISECONDS.toDays(tim - last);\n            if ((last <= 0) || (maxTime <= 0)) {\n                Config.getPref().put(\"pluginmanager.lastupdate\", Long.toString(tim));"}
{"magic_number_smell": "    public static PolygonIntersection polygonIntersection(List<? extends INode> first, List<? extends INode> second) {\n        Area a1 = getArea(first);\n        Area a2 = getArea(second);\n        return polygonIntersection(a1, a2, 1e-4);\n    }\n\n    /**", "refactored_code": "    public static final double INTERSECTION_EPS_EAST_NORTH = 1e-4;\n    public static PolygonIntersection polygonIntersection(List<? extends INode> first, List<? extends INode> second) {\n        Area a1 = getArea(first);\n        Area a2 = getArea(second);\n        return polygonIntersection(a1, a2, INTERSECTION_EPS_EAST_NORTH);\n    }\n\n    /**"}
{"magic_number_smell": "        }\n\n        hotSpot.setLocation(\"crosshair\".equals(name) ? CROSSHAIR_HOTSPOT : DEFAULT_HOTSPOT);\n        hotSpot.x = hotSpot.x * image.getWidth(null) / 32;\n        hotSpot.y = hotSpot.y * image.getHeight(null) / 32;\n\n        return image;", "refactored_code": "    protected static final int CURSOR_SIZE_HOTSPOT_IS_RELATIVE_TO = 32;\n        }\n\n        hotSpot.setLocation(\"crosshair\".equals(name) ? CROSSHAIR_HOTSPOT : DEFAULT_HOTSPOT);\n        hotSpot.x = hotSpot.x * image.getWidth(null) / CURSOR_SIZE_HOTSPOT_IS_RELATIVE_TO;\n        hotSpot.y = hotSpot.y * image.getHeight(null) / CURSOR_SIZE_HOTSPOT_IS_RELATIVE_TO;\n\n        return image;"}
{"magic_number_smell": "     * @return The maximum amount of memory.\n     */\n    public synchronized long getMaxMemory() {\n        return Runtime.getRuntime().maxMemory() - 50L * 1024L * 1024L;\n    }\n\n    /**", "refactored_code": "    private static final long JOSM_CORE_FOOTPRINT = 50L * 1024L * 1024L;\n     * @return The maximum amount of memory.\n     */\n    public synchronized long getMaxMemory() {\n        return Runtime.getRuntime().maxMemory() - JOSM_CORE_FOOTPRINT;\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    public static Bounds positionToBounds(final double lat, final double lon, final int zoom) {\n        final Dimension screenSize = mapSize.get();\n        double scale = (1L << zoom) * 256 / (2.0 * Math.PI * Ellipsoid.WGS84.a);\n        double deltaX = screenSize.getWidth() / 2.0 / scale;\n        double deltaY = screenSize.getHeight() / 2.0 / scale;\n        final Projection mercator = Projections.getProjectionByCode(\"EPSG:3857\");", "refactored_code": "    private static final int TILE_SIZE_IN_PIXELS = 256;\n     */\n    public static Bounds positionToBounds(final double lat, final double lon, final int zoom) {\n        final Dimension screenSize = mapSize.get();\n        double scale = (1L << zoom) * TILE_SIZE_IN_PIXELS / (2.0 * Math.PI * Ellipsoid.WGS84.a);\n        double deltaX = screenSize.getWidth() / 2.0 / scale;\n        double deltaY = screenSize.getHeight() / 2.0 / scale;\n        final Projection mercator = Projections.getProjectionByCode(\"EPSG:3857\");"}
{"magic_number_smell": "        double lowerY = clippingRect.getMinY();\n        double upperY = clippingRect.getMaxY();\n        boolean eIsIn = false, sIsIn = false;\n        for (int side = 0; side <= BOTTOM; side++) {\n            if (countVals < 6)\n                return null; // ignore point or line\n", "refactored_code": "    private static final int LEFT = 0;\n        double lowerY = clippingRect.getMinY();\n        double upperY = clippingRect.getMaxY();\n        boolean eIsIn = false, sIsIn = false;\n        for (int side = LEFT; side <= BOTTOM; side++) {\n            if (countVals < 6)\n                return null; // ignore point or line\n"}
{"magic_number_smell": "        for (Entry<String, String> entry : tags.entrySet()) {\n            String key = entry.getKey();\n            String value = entry.getValue();\n            if (key.length() > Config.getPref().getInt(\"tags.paste.max-key-length\", 50)) {\n                r = callback.warning(tr(\"Key is too long (max {0} characters):\", Config.getPref().getInt(\"tags.paste.max-key-length\", 50)), key+'='+value, \"tags.paste.keytoolong\");\n                if (r == 2 || r == 3) return false; if (r == 4) return true;\n            }", "refactored_code": "    private static final int MAX_KEY_LENGTH = Config.getPref().getInt(\"tags.paste.max-key-length\", 50);\n        for (Entry<String, String> entry : tags.entrySet()) {\n            String key = entry.getKey();\n            String value = entry.getValue();\n            if (key.length() > MAX_KEY_LENGTH) {\n                r = callback.warning(tr(\"Key is too long (max {0} characters):\", MAX_KEY_LENGTH), key+'='+value, \"tags.paste.keytoolong\");\n                if (r == 2 || r == 3) return false; if (r == 4) return true;\n            }"}
{"magic_number_smell": "            throw new IllegalArgumentException(\"elapsedTime must be >= 0\");\n        }\n        // Is it less than 1 second ?\n        if (elapsedTime < TimeUnit.SECONDS.toMillis(1)) {\n            return String.format(\"%d %s\", elapsedTime, tr(\"ms\"));\n        }\n        // Is it less than 1 minute ?", "refactored_code": "    private static final long MILLIS_OF_SECOND = TimeUnit.SECONDS.toMillis(1);\n            throw new IllegalArgumentException(\"elapsedTime must be >= 0\");\n        }\n        // Is it less than 1 second ?\n        if (elapsedTime < MILLIS_OF_SECOND) {\n            return String.format(\"%d %s\", elapsedTime, tr(\"ms\"));\n        }\n        // Is it less than 1 minute ?"}
{"magic_number_smell": "\n    /**\n     * Read a value from key and value name\n     * @param hkey  0x80000001/HKEY_LOCAL_MACHINE\n     * @param key  key name\n     * @param valueName  value name\n     * @return the value", "refactored_code": "    public static final int HKEY_CURRENT_USER = 0x80000001;\n\n    /**\n     * Read a value from key and value name\n     * @param hkey  HKEY_CURRENT_USER/HKEY_LOCAL_MACHINE\n     * @param key  key name\n     * @param valueName  value name\n     * @return the value"}
{"magic_number_smell": "        StringBuilder str = new StringBuilder(32);\n        for (Object e : value) {\n            str.append(\"\\n    - \");\n            if (lines <= 30) {\n                ++lines;\n                str.append(e);\n            } else {", "refactored_code": "    private static final int MAX_COLLECTION_ENTRIES = 30;\n        StringBuilder str = new StringBuilder(32);\n        for (Object e : value) {\n            str.append(\"\\n    - \");\n            if (lines <= MAX_COLLECTION_ENTRIES) {\n                ++lines;\n                str.append(e);\n            } else {"}
{"magic_number_smell": "        private Bounds testArea;\n        private final ArrayList<String> fonts = new ArrayList<>();\n        private DataSet ds;\n        private int imageWidth = 256;\n        private int thresholdPixels;\n        private int thresholdTotalColorDiff;\n", "refactored_code": "    private static final int IMAGE_SIZE = 256;\n        private Bounds testArea;\n        private final ArrayList<String> fonts = new ArrayList<>();\n        private DataSet ds;\n        private int imageWidth = IMAGE_SIZE;\n        private int thresholdPixels;\n        private int thresholdTotalColorDiff;\n"}
{"magic_number_smell": "     */\n    @BeforeEach\n    public void load() throws Exception {\n        img = new BufferedImage(1400, IMG_HEIGHT, BufferedImage.TYPE_INT_ARGB);\n    }\n\n    /**", "refactored_code": "    private static final int IMG_WIDTH = 1400;\n     */\n    @BeforeEach\n    public void load() throws Exception {\n        img = new BufferedImage(IMG_WIDTH, IMG_HEIGHT, BufferedImage.TYPE_INT_ARGB);\n    }\n\n    /**"}
{"magic_number_smell": "     * @param testRunner The test to run\n     */\n    public static void runPerformanceTest(String name, Runnable testRunner) {\n        for (int i = 0; i < 2; i++) {\n            cleanSystem();\n            Stopwatch capture = Stopwatch.createStarted();\n            testRunner.run();", "refactored_code": "    private static final int TIMES_WARMUP = 2;\n     * @param testRunner The test to run\n     */\n    public static void runPerformanceTest(String name, Runnable testRunner) {\n        for (int i = 0; i < TIMES_WARMUP; i++) {\n            cleanSystem();\n            Stopwatch capture = Stopwatch.createStarted();\n            testRunner.run();"}
{"magic_number_smell": "    @Test\n    void testKeyValuePut() {\n        for (double tagNodeRatio : TAG_NODE_RATIOS) {\n            int nodeCount = (int) (10000 / tagNodeRatio);\n            KeyValueDataGenerator generator = OsmDataGenerator.getKeyValue(nodeCount, 0);\n            generator.generateDataSet();\n", "refactored_code": "    private static final int PUT_RUNS = 10000;\n    @Test\n    void testKeyValuePut() {\n        for (double tagNodeRatio : TAG_NODE_RATIOS) {\n            int nodeCount = (int) (PUT_RUNS / tagNodeRatio);\n            KeyValueDataGenerator generator = OsmDataGenerator.getKeyValue(nodeCount, 0);\n            generator.generateDataSet();\n"}
{"magic_number_smell": "     * @return The generator\n     */\n    public static KeyValueDataGenerator getKeyValue() {\n        return getKeyValue(3);\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_KEY_VALUE_RATIO = 3;\n     * @return The generator\n     */\n    public static KeyValueDataGenerator getKeyValue() {\n        return getKeyValue(DEFAULT_KEY_VALUE_RATIO);\n    }\n\n    /**"}
{"magic_number_smell": "    private static DataSet dsCity;\n\n    protected static void load() throws Exception {\n        img = new BufferedImage(1400, IMG_HEIGHT, BufferedImage.TYPE_INT_ARGB);\n        g = (Graphics2D) img.getGraphics();\n        g.setClip(0, 0, 1400, IMG_HEIGHT);\n        g.setColor(Color.BLACK);", "refactored_code": "    private static final int IMG_WIDTH = 1400;\n    private static DataSet dsCity;\n\n    protected static void load() throws Exception {\n        img = new BufferedImage(IMG_WIDTH, IMG_HEIGHT, BufferedImage.TYPE_INT_ARGB);\n        g = (Graphics2D) img.getGraphics();\n        g.setClip(0, 0, IMG_WIDTH, IMG_HEIGHT);\n        g.setColor(Color.BLACK);"}
{"magic_number_smell": "     */\n    @BeforeAll\n    public static void load() throws Exception {\n        img = new BufferedImage(2048, IMG_HEIGHT, BufferedImage.TYPE_INT_ARGB);\n        g = (Graphics2D) img.getGraphics();\n        g.setClip(0, 0, 2048, IMG_HEIGHT);\n        g.setColor(Color.BLACK);", "refactored_code": "    private static final int IMG_WIDTH = 2048;\n     */\n    @BeforeAll\n    public static void load() throws Exception {\n        img = new BufferedImage(IMG_WIDTH, IMG_HEIGHT, BufferedImage.TYPE_INT_ARGB);\n        g = (Graphics2D) img.getGraphics();\n        g.setClip(0, 0, IMG_WIDTH, IMG_HEIGHT);\n        g.setColor(Color.BLACK);"}
{"magic_number_smell": "    void testKeyValueRules() {\n        KeyValueDataGenerator data = OsmDataGenerator.getKeyValue();\n        data.generateDataSet();\n        CssGenerator css = new CssGenerator(data).addKeyValueRules(10000);\n        runTest(data, css, \"only key=value rules\");\n    }\n", "refactored_code": "    private static final int TEST_RULE_COUNT = 10000;\n    void testKeyValueRules() {\n        KeyValueDataGenerator data = OsmDataGenerator.getKeyValue();\n        data.generateDataSet();\n        CssGenerator css = new CssGenerator(data).addKeyValueRules(TEST_RULE_COUNT);\n        runTest(data, css, \"only key=value rules\");\n    }\n"}
{"magic_number_smell": "\n    private void runTest(String what, boolean decompressBeforeRead) throws IllegalDataException, IOException {\n        InputStream is = loadFile(decompressBeforeRead);\n        PerformanceTestTimer timer = PerformanceTestUtils.startTimer(\"load \" + what + \" \" + 4 + \" times\");\n        DataSet ds = null;\n        for (int i = 0; i < 4; i++) {\n            is.reset();", "refactored_code": "    private static final int TIMES = 4;\n\n    private void runTest(String what, boolean decompressBeforeRead) throws IllegalDataException, IOException {\n        InputStream is = loadFile(decompressBeforeRead);\n        PerformanceTestTimer timer = PerformanceTestUtils.startTimer(\"load \" + what + \" \" + TIMES + \" times\");\n        DataSet ds = null;\n        for (int i = 0; i < TIMES; i++) {\n            is.reset();"}
{"magic_number_smell": "     */\n    @Test\n    void testWriter() throws Exception {\n        PerformanceTestTimer timer = PerformanceTestUtils.startTimer(\"write .osm-file \" + 4 + \" times\");\n        for (int i = 0; i < 4; i++) {\n            try (StringWriter stringWriter = new StringWriter();\n                 OsmWriter osmWriter = OsmWriterFactory.createOsmWriter(new PrintWriter(stringWriter), true, OsmWriter.DEFAULT_API_VERSION)) {", "refactored_code": "    private static final int TIMES = 4;\n     */\n    @Test\n    void testWriter() throws Exception {\n        PerformanceTestTimer timer = PerformanceTestUtils.startTimer(\"write .osm-file \" + TIMES + \" times\");\n        for (int i = 0; i < TIMES; i++) {\n            try (StringWriter stringWriter = new StringWriter();\n                 OsmWriter osmWriter = OsmWriterFactory.createOsmWriter(new PrintWriter(stringWriter), true, OsmWriter.DEFAULT_API_VERSION)) {"}
{"magic_number_smell": "\n    private static void setupMapView(DataSet ds) {\n        // setup a reasonable size for the edit window\n        MainApplication.getMap().mapView.setBounds(new Rectangle(800, HEIGHT));\n        if (ds.getDataSourceBoundingBox() != null) {\n            MainApplication.getMap().mapView.zoomTo(ds.getDataSourceBoundingBox());\n        } else {", "refactored_code": "    private static final int WIDTH = 800;\n\n    private static void setupMapView(DataSet ds) {\n        // setup a reasonable size for the edit window\n        MainApplication.getMap().mapView.setBounds(new Rectangle(WIDTH, HEIGHT));\n        if (ds.getDataSourceBoundingBox() != null) {\n            MainApplication.getMap().mapView.zoomTo(ds.getDataSourceBoundingBox());\n        } else {"}
{"magic_number_smell": "        ILatLon c = new LatLon(47.000000, 19.000000);\n        ILatLon e = new LatLon(47.000000, 19.000001);\n        ILatLon n = new LatLon(47.000001, 19.000000);\n        assertEquals(0, Math.toDegrees(c.bearing(n)), 1e-6);\n        assertEquals(90, Math.toDegrees(c.bearing(e)), 1e-6);\n        assertEquals(180, Math.toDegrees(n.bearing(c)), 1e-6);\n        assertEquals(270, Math.toDegrees(e.bearing(c)), 1e-6);", "refactored_code": "    private static final double EPSILON = 1e-6;\n        ILatLon c = new LatLon(47.000000, 19.000000);\n        ILatLon e = new LatLon(47.000000, 19.000001);\n        ILatLon n = new LatLon(47.000001, 19.000000);\n        assertEquals(0, Math.toDegrees(c.bearing(n)), EPSILON);\n        assertEquals(90, Math.toDegrees(c.bearing(e)), EPSILON);\n        assertEquals(180, Math.toDegrees(n.bearing(c)), EPSILON);\n        assertEquals(270, Math.toDegrees(e.bearing(c)), EPSILON);"}
{"magic_number_smell": "                double[] cart = ellips.latLon2Cart(ll);\n                ll = ellips.cart2LatLon(cart);\n\n                if (!(Math.abs(lat - ll.lat()) < 1.5e-8 && Math.abs(lon - ll.lon()) < 1.5e-8)) {\n                    String error = String.format(\"point: %s iterations: %s current: %s errorLat: %s errorLon %s\",\n                            new LatLon(lat, lon), i, ll, Math.abs(lat - ll.lat()), Math.abs(lon - ll.lon()));\n                    fail(error);", "refactored_code": "    private static final double EPSILON = 1.5e-8;\n                double[] cart = ellips.latLon2Cart(ll);\n                ll = ellips.cart2LatLon(cart);\n\n                if (!(Math.abs(lat - ll.lat()) < EPSILON && Math.abs(lon - ll.lon()) < EPSILON)) {\n                    String error = String.format(\"point: %s iterations: %s current: %s errorLat: %s errorLon %s\",\n                            new LatLon(lat, lon), i, ll, Math.abs(lat - ll.lat()), Math.abs(lon - ll.lon()));\n                    fail(error);"}
{"magic_number_smell": "     */\n    @Test\n    void testProjReferenceTestAccurate() {\n        projReferenceTest(0.05);\n    }\n\n    /**", "refactored_code": "    private static final double EPSILON_ACCURATE = 0.05;\n     */\n    @Test\n    void testProjReferenceTestAccurate() {\n        projReferenceTest(EPSILON_ACCURATE);\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @BeforeEach\n    public void setUp() {\n        state = MapViewState.createDefaultState(301, HEIGHT);\n    }\n\n    private void doTestGetCenter(Function<MapViewState, MapViewPoint> getter, Function<Integer, Double> divider) {", "refactored_code": "    private static final int WIDTH = 301;\n     */\n    @BeforeEach\n    public void setUp() {\n        state = MapViewState.createDefaultState(WIDTH, HEIGHT);\n    }\n\n    private void doTestGetCenter(Function<MapViewState, MapViewPoint> getter, Function<Integer, Double> divider) {"}
{"magic_number_smell": "    @BeforeEach\n    public void setUp() {\n        component = new NavigatableComponentMock();\n        component.setBounds(new Rectangle(WIDTH, 200));\n        // wait for the event to be propagated.\n        GuiHelper.runInEDTAndWait(() -> { /* Do nothing */ });\n        component.setVisible(true);", "refactored_code": "    private static final int HEIGHT = 200;\n    @BeforeEach\n    public void setUp() {\n        component = new NavigatableComponentMock();\n        component.setBounds(new Rectangle(WIDTH, HEIGHT));\n        // wait for the event to be propagated.\n        GuiHelper.runInEDTAndWait(() -> { /* Do nothing */ });\n        component.setVisible(true);"}
{"magic_number_smell": "        processor.setColorfulness(data.getFactor());\n        image = processor.process(image);\n\n        for (int x = 0; x < 5; x++) {\n            for (int y = 0; y < 5; y++) {\n                Color color = new Color(image.getRGB(x, y));\n                assertEquals(data.getExpectedColor().getRed(), color.getRed(), 1.05, data + \":\" + type + \": red\");", "refactored_code": "    private static final int TEST_IMAGE_SIZE = 5;\n        processor.setColorfulness(data.getFactor());\n        image = processor.process(image);\n\n        for (int x = 0; x < TEST_IMAGE_SIZE; x++) {\n            for (int y = 0; y < TEST_IMAGE_SIZE; y++) {\n                Color color = new Color(image.getRGB(x, y));\n                assertEquals(data.getExpectedColor().getRed(), color.getRed(), 1.05, data + \":\" + type + \": red\");"}
{"magic_number_smell": "            ICoordinate center = CoordinateConversion.llToCoor(bounds != null ? getCenter(bounds) : GREENWICH);\n            List<AbstractTileSource> tileSources = getTileSources(info);\n            // test min zoom and try to detect the correct value in case of error\n            int maxZoom = info.getMaxZoom() > 0 ? Math.min(12, info.getMaxZoom()) : 12;\n            for (int zoom = info.getMinZoom(); zoom < maxZoom; zoom++) {\n                if (!isZoomError(checkTileUrls(info, tileSources, center, zoom))) {\n                    break;", "refactored_code": "    private static final int DEFAULT_ZOOM = 12;\n            ICoordinate center = CoordinateConversion.llToCoor(bounds != null ? getCenter(bounds) : GREENWICH);\n            List<AbstractTileSource> tileSources = getTileSources(info);\n            // test min zoom and try to detect the correct value in case of error\n            int maxZoom = info.getMaxZoom() > 0 ? Math.min(DEFAULT_ZOOM, info.getMaxZoom()) : DEFAULT_ZOOM;\n            for (int zoom = info.getMinZoom(); zoom < maxZoom; zoom++) {\n                if (!isZoomError(checkTileUrls(info, tileSources, center, zoom))) {\n                    break;"}
{"magic_number_smell": "    @BeforeEach\n    public void setUp() {\n        JPanel parent = new JPanel();\n        parent.setBounds(0, 0, 500, 500);\n\n        container = new JPanel(new MultiLineFlowLayout(FlowLayout.CENTER, 0, 0));\n        parent.add(container);", "refactored_code": "    private static final int TEST_WIDHT = 500;\n    @BeforeEach\n    public void setUp() {\n        JPanel parent = new JPanel();\n        parent.setBounds(0, 0, TEST_WIDHT, 500);\n\n        container = new JPanel(new MultiLineFlowLayout(FlowLayout.CENTER, 0, 0));\n        parent.add(container);"}
{"magic_number_smell": "\n    @BeforeEach\n    void setUp() {\n        this.cameraPlane = new CameraPlane(800, CAMERA_PLANE_HEIGHT);\n    }\n\n    @Test", "refactored_code": "    private static final int CAMERA_PLANE_WIDTH = 800;\n\n    @BeforeEach\n    void setUp() {\n        this.cameraPlane = new CameraPlane(CAMERA_PLANE_WIDTH, CAMERA_PLANE_HEIGHT);\n    }\n\n    @Test"}
{"magic_number_smell": "    private static void assertVectorEquals(final Vector3D expected, final Vector3D actual) {\n        final String message = String.format(\"Expected (%f %f %f), but was (%f %f %f)\", expected.getX(),\n                expected.getY(), expected.getZ(), actual.getX(), actual.getY(), actual.getZ());\n        assertEquals(expected.getX(), actual.getX(), 1e-5, message);\n        assertEquals(expected.getY(), actual.getY(), 1e-5, message);\n        assertEquals(expected.getZ(), actual.getZ(), 1e-5, message);\n    }", "refactored_code": "    private static final double DEFAULT_DELTA = 1e-5;\n    private static void assertVectorEquals(final Vector3D expected, final Vector3D actual) {\n        final String message = String.format(\"Expected (%f %f %f), but was (%f %f %f)\", expected.getX(),\n                expected.getY(), expected.getZ(), actual.getX(), actual.getY(), actual.getZ());\n        assertEquals(expected.getX(), actual.getX(), DEFAULT_DELTA, message);\n        assertEquals(expected.getY(), actual.getY(), DEFAULT_DELTA, message);\n        assertEquals(expected.getZ(), actual.getZ(), DEFAULT_DELTA, message);\n    }"}
{"magic_number_smell": "     */\n    @Test\n    void testPlay() {\n        assertTimeout(Duration.ofMillis(4*16000), () -> {\n            File wav1 = new File(TestUtils.getRegressionDataFile(6851, \"20111003_121226.wav\"));\n            File wav2 = new File(TestUtils.getRegressionDataFile(6851, \"20111003_121557.wav\"));\n", "refactored_code": "    private static final long MAX_DURATION = 16000;\n     */\n    @Test\n    void testPlay() {\n        assertTimeout(Duration.ofMillis(4*MAX_DURATION), () -> {\n            File wav1 = new File(TestUtils.getRegressionDataFile(6851, \"20111003_121226.wav\"));\n            File wav2 = new File(TestUtils.getRegressionDataFile(6851, \"20111003_121557.wav\"));\n"}
{"magic_number_smell": "     */\n    @Test\n    void testGetCalibratedDuration() {\n        assertEquals(0.0, AudioUtil.getCalibratedDuration(new File(\"invalid_file\")), 1e-11);\n        File wav1 = new File(TestUtils.getRegressionDataFile(6851, \"20111003_121226.wav\"));\n        assertEquals(4.8317006802721085, AudioUtil.getCalibratedDuration(wav1), 1e-11);\n        File wav2 = new File(TestUtils.getRegressionDataFile(6851, \"20111003_121557.wav\"));", "refactored_code": "    private static final double EPSILON = 1e-11;\n     */\n    @Test\n    void testGetCalibratedDuration() {\n        assertEquals(0.0, AudioUtil.getCalibratedDuration(new File(\"invalid_file\")), EPSILON);\n        File wav1 = new File(TestUtils.getRegressionDataFile(6851, \"20111003_121226.wav\"));\n        assertEquals(4.8317006802721085, AudioUtil.getCalibratedDuration(wav1), EPSILON);\n        File wav2 = new File(TestUtils.getRegressionDataFile(6851, \"20111003_121557.wav\"));"}
{"magic_number_smell": "            if (PERFORM_MEMORY_CLEANUP) {\n                System.gc();\n                // Finalization was deprecated in Java 18\n                if (Utils.getJavaVersion() <= 17) {\n                    System.runFinalization();\n                }\n            }", "refactored_code": "        private static final int JAVA_VERSION = Utils.getJavaVersion();\n            if (PERFORM_MEMORY_CLEANUP) {\n                System.gc();\n                // Finalization was deprecated in Java 18\n                if (JAVA_VERSION <= 17) {\n                    System.runFinalization();\n                }\n            }"}
{"magic_number_smell": "     */\n    @Test\n    void testParseCardinal() {\n        assertEquals(Math.PI, RotationAngle.buildStaticRotation(\"south\").getRotationAngle(null), 1e-11);\n        assertEquals(Math.PI, RotationAngle.buildStaticRotation(\"s\").getRotationAngle(null), 1e-11);\n        assertEquals(Math.toRadians(315), RotationAngle.buildStaticRotation(\"northwest\").getRotationAngle(null), 1e-11);\n    }", "refactored_code": "    private static final double EPSILON = 1e-11;\n     */\n    @Test\n    void testParseCardinal() {\n        assertEquals(Math.PI, RotationAngle.buildStaticRotation(\"south\").getRotationAngle(null), EPSILON);\n        assertEquals(Math.PI, RotationAngle.buildStaticRotation(\"s\").getRotationAngle(null), EPSILON);\n        assertEquals(Math.toRadians(315), RotationAngle.buildStaticRotation(\"northwest\").getRotationAngle(null), EPSILON);\n    }"}
{"magic_number_smell": "        List<IAtomContainer> frags = new ArrayList<>();\n\n        for (IBond cut : cuts) {\n            if (frags.size() >= 50)\n                break;\n            frags.addAll(makeCut(cut, mol, atmidx, adjlist));\n        }", "refactored_code": "    private static final int MAX_FRAG = 50;\n        List<IAtomContainer> frags = new ArrayList<>();\n\n        for (IBond cut : cuts) {\n            if (frags.size() >= MAX_FRAG)\n                break;\n            frags.addAll(makeCut(cut, mol, atmidx, adjlist));\n        }"}
{"magic_number_smell": "    /**\n     * The dimensions (width x height) of the depiction.\n     */\n    private Dimensions dimensions = Dimensions.-1;\n\n    /**\n     * Storage of rendering parameters.", "refactored_code": "    public static final double AUTOMATIC = -1;\n    /**\n     * The dimensions (width x height) of the depiction.\n     */\n    private Dimensions dimensions = Dimensions.AUTOMATIC;\n\n    /**\n     * Storage of rendering parameters."}
{"magic_number_smell": "    @Override\n    public void startDocument() {\n        atomTypes = new ArrayList<>();\n        scalarType = 0;\n        atomType = null;\n    }\n", "refactored_code": "    private final int                 SCALAR_UNSET                 = 0;\n    @Override\n    public void startDocument() {\n        atomTypes = new ArrayList<>();\n        scalarType = SCALAR_UNSET;\n        atomType = null;\n    }\n"}
{"magic_number_smell": "    }\n\n    private static void numberOfCyclesCheck(RelevantCycles rc) throws Intractable {\n        if (rc.size() > getSystemInteger(CDK_MAX_RELEVANT_CYCLES_KEY, 512000))\n            throw new Intractable(\"Too many relevant cycles cycles! max=\" + getSystemInteger(CDK_MAX_RELEVANT_CYCLES_KEY, 512000) + \" was=\" + rc.size() + \".\" +\n                                  \" Increase this limit with System property -D\" + CDK_MAX_RELEVANT_CYCLES_KEY + \"=<num>\");\n    }", "refactored_code": "    private static final long MAX_RELEVANT_CYCLES = getSystemInteger(CDK_MAX_RELEVANT_CYCLES_KEY, 512000);\n    }\n\n    private static void numberOfCyclesCheck(RelevantCycles rc) throws Intractable {\n        if (rc.size() > MAX_RELEVANT_CYCLES)\n            throw new Intractable(\"Too many relevant cycles cycles! max=\" + MAX_RELEVANT_CYCLES + \" was=\" + rc.size() + \".\" +\n                                  \" Increase this limit with System property -D\" + CDK_MAX_RELEVANT_CYCLES_KEY + \"=<num>\");\n    }"}
{"magic_number_smell": "\n        int n = container.getAtomCount();\n\n        int[][] graph = new int[n][4];\n        int[] degree = new int[n];\n\n        for (IBond bond : container.bonds()) {", "refactored_code": "    private static final int DEFAULT_DEGREE = 4;\n\n        int n = container.getAtomCount();\n\n        int[][] graph = new int[n][DEFAULT_DEGREE];\n        int[] degree = new int[n];\n\n        for (IBond bond : container.bonds()) {"}
{"magic_number_smell": "         * @return the edges reduced vertices are disjoint.\n         */\n        final boolean disjoint(final PathEdge other) {\n            return (this.xs & other.xs) == 0;\n        }\n\n        /**", "refactored_code": "    private static final long EMPTY_SET = 0;\n         * @return the edges reduced vertices are disjoint.\n         */\n        final boolean disjoint(final PathEdge other) {\n            return (this.xs & other.xs) == EMPTY_SET;\n        }\n\n        /**"}
{"magic_number_smell": "            return;\n        }\n        try (FileWriter out = new FileWriter(file)) {\n            out.write(Integer.toString(1));\n            out.write('\\n');\n            out.write(filename);\n            out.write('\\n');", "refactored_code": "    protected final int                     indexVersion  = 1;\n            return;\n        }\n        try (FileWriter out = new FileWriter(file)) {\n            out.write(Integer.toString(indexVersion));\n            out.write('\\n');\n            out.write(filename);\n            out.write('\\n');"}
{"magic_number_smell": "    }\n\n    private <T> T[] grow(T[] arr, int required) {\n        int grow = arr.length == 0 ? 20 :\n                   arr.length + (arr.length >> 1);\n        if (grow < required)\n            grow = required;", "refactored_code": "    private static final int DEFAULT_CAPACITY = 20;\n    }\n\n    private <T> T[] grow(T[] arr, int required) {\n        int grow = arr.length == 0 ? DEFAULT_CAPACITY :\n                   arr.length + (arr.length >> 1);\n        if (grow < required)\n            grow = required;"}
{"magic_number_smell": "    private static <T> T[] grow(T[] array, int required) {\n        int oldCapacity = array.length;\n        // x1.5: 20, 30, 45, 67, 100, 150, 225, 337, 505, etc\n        int newCapacity = oldCapacity == 0 ? 20\n                                           : oldCapacity + (oldCapacity >> 1);\n        if (newCapacity < required)\n            newCapacity = required;", "refactored_code": "    private static final int DEFAULT_CAPACITY = 20;\n    private static <T> T[] grow(T[] array, int required) {\n        int oldCapacity = array.length;\n        // x1.5: 20, 30, 45, 67, 100, 150, 225, 337, 505, etc\n        int newCapacity = oldCapacity == 0 ? DEFAULT_CAPACITY\n                                           : oldCapacity + (oldCapacity >> 1);\n        if (newCapacity < required)\n            newCapacity = required;"}
{"magic_number_smell": "\n    private static final Random    rnd    = new Random();\n\n    private static IAtomContainer getBaseAtomContainer(int 10, String title) {\n        IAtomContainer container = DefaultChemObjectBuilder.getInstance().newInstance(IAtomContainer.class);\n        container.setTitle(title);\n        for (int i = 0; i < 10; i++) {", "refactored_code": "    private static final int       natom  = 10;\n\n    private static final Random    rnd    = new Random();\n\n    private static IAtomContainer getBaseAtomContainer(int natom, String title) {\n        IAtomContainer container = DefaultChemObjectBuilder.getInstance().newInstance(IAtomContainer.class);\n        container.setTitle(title);\n        for (int i = 0; i < natom; i++) {"}
{"magic_number_smell": "        this.t1 = new int[g1.length];\n        this.t2 = new int[g2.length];\n        size = 0;\n        Arrays.fill(m1, -1);\n        Arrays.fill(m2, -1);\n    }\n", "refactored_code": "    protected static final int UNMAPPED = -1;\n        this.t1 = new int[g1.length];\n        this.t2 = new int[g2.length];\n        size = 0;\n        Arrays.fill(m1, UNMAPPED);\n        Arrays.fill(m2, UNMAPPED);\n    }\n"}
{"magic_number_smell": "        if (qatom != null) {\n            --numMapped;\n            avisit[amap[qatom.getIndex()]] = false;\n            amap[qatom.getIndex()] = -1;\n        } else if (sptr != 0) {\n            backtrack();\n        }", "refactored_code": "    private static final int UNMAPPED = -1;\n        if (qatom != null) {\n            --numMapped;\n            avisit[amap[qatom.getIndex()]] = false;\n            amap[qatom.getIndex()] = UNMAPPED;\n        } else if (sptr != 0) {\n            backtrack();\n        }"}
{"magic_number_smell": "        this.bonds2 = bonds2;\n        this.m1 = new int[g1.length];\n        this.m2 = new int[g2.length];\n        Arrays.fill(m1, -1);\n        Arrays.fill(m2, -1);\n\n        // build up compatibility matrix", "refactored_code": "    private static final int          UNMAPPED = -1;\n        this.bonds2 = bonds2;\n        this.m1 = new int[g1.length];\n        this.m2 = new int[g2.length];\n        Arrays.fill(m1, UNMAPPED);\n        Arrays.fill(m2, UNMAPPED);\n\n        // build up compatibility matrix"}
{"magic_number_smell": "        private boolean validate(IAtomContainer mol) {\n            return mol.getAtomCount() == numAtoms &&\n                   mol.getBondCount() == numBonds &&\n                   (System.nanoTime() - tInit) < TimeUnit.MILLISECONDS.toNanos(100);\n        }\n    }\n}", "refactored_code": "        private static final long MAX_AGE = TimeUnit.MILLISECONDS.toNanos(100);\n        private boolean validate(IAtomContainer mol) {\n            return mol.getAtomCount() == numAtoms &&\n                   mol.getBondCount() == numBonds &&\n                   (System.nanoTime() - tInit) < MAX_AGE;\n        }\n    }\n}"}
{"magic_number_smell": "                return atom.getAtomicNumber() != null &&\n                       Elements.ofNumber(atom.getAtomicNumber()).group() == value;\n            case STEREOCHEMISTRY:\n                return stereo == -1 || stereo == value;\n            case REACTION_ROLE:\n                ReactionRole role = atom.getProperty(CDKConstants.REACTION_ROLE);\n                return role != null && role.ordinal() == value;", "refactored_code": "    public static final int UNKNOWN_STEREO = -1;\n                return atom.getAtomicNumber() != null &&\n                       Elements.ofNumber(atom.getAtomicNumber()).group() == value;\n            case STEREOCHEMISTRY:\n                return stereo == UNKNOWN_STEREO || stereo == value;\n            case REACTION_ROLE:\n                ReactionRole role = atom.getProperty(CDKConstants.REACTION_ROLE);\n                return role != null && role.ordinal() == value;"}
{"magic_number_smell": "    }\n\n    private <T> T[] grow(T[] arr, int required) {\n        int grow = arr.length == 0 ? 20 :\n                   arr.length + (arr.length >> 1);\n        if (grow < required)\n            grow = required;", "refactored_code": "    private static final int DEFAULT_CAPACITY = 20;\n    }\n\n    private <T> T[] grow(T[] arr, int required) {\n        int grow = arr.length == 0 ? DEFAULT_CAPACITY :\n                   arr.length + (arr.length >> 1);\n        if (grow < required)\n            grow = required;"}
{"magic_number_smell": "    private static <T> T[] grow(T[] array, int required) {\n        int oldCapacity = array.length;\n        // x1.5: 20, 30, 45, 67, 100, 150, 225, 337, 505, etc\n        int newCapacity = oldCapacity == 0 ? 20\n                                           : oldCapacity + (oldCapacity >> 1);\n        if (newCapacity < required)\n            newCapacity = required;", "refactored_code": "    private static final int DEFAULT_CAPACITY = 20;\n    private static <T> T[] grow(T[] array, int required) {\n        int oldCapacity = array.length;\n        // x1.5: 20, 30, 45, 67, 100, 150, 225, 337, 505, etc\n        int newCapacity = oldCapacity == 0 ? DEFAULT_CAPACITY\n                                           : oldCapacity + (oldCapacity >> 1);\n        if (newCapacity < required)\n            newCapacity = required;"}
{"magic_number_smell": "            // here is we count the number free valence electrons but also\n            // check if the bonded valence is okay (i.e. not a radical)\n            else if (charge <= 0 && charge > -3) {\n                if (element == 0)\n                    electrons[i] = 2;\n                else if (valence(element, charge) - valence[i] >= 2)\n                    electrons[i] = 2;", "refactored_code": "    private static final int WILDCARD   = 0;\n            // here is we count the number free valence electrons but also\n            // check if the bonded valence is okay (i.e. not a radical)\n            else if (charge <= 0 && charge > -3) {\n                if (element == WILDCARD)\n                    electrons[i] = 2;\n                else if (valence(element, charge) - valence[i] >= 2)\n                    electrons[i] = 2;"}
{"magic_number_smell": "    private boolean augment() {\n\n        // reset data structures\n        Arrays.fill(even, -1);\n        Arrays.fill(odd, -1);\n        dsf = new DisjointSetForest(graph.length);\n        bridges.clear();", "refactored_code": "    private static final int          NIL     = -1;\n    private boolean augment() {\n\n        // reset data structures\n        Arrays.fill(even, NIL);\n        Arrays.fill(odd, NIL);\n        dsf = new DisjointSetForest(graph.length);\n        bridges.clear();"}
{"magic_number_smell": "     */\n    private Matching(final int n) {\n        this.match = new int[n];\n        Arrays.fill(match, -1);\n    }\n\n    /**", "refactored_code": "    private static final int NIL = -1;\n     */\n    private Matching(final int n) {\n        this.match = new int[n];\n        Arrays.fill(match, NIL);\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    void sortBy(int[] vs, int lo, int len, long[] curr, long[] prev) {\n\n        if (len < 42) {\n            insertionSortBy(vs, lo, len, curr, prev);\n            return;\n        }", "refactored_code": "    private static final int INSERTION_SORT_THRESHOLD = 42;\n     */\n    void sortBy(int[] vs, int lo, int len, long[] curr, long[] prev) {\n\n        if (len < INSERTION_SORT_THRESHOLD) {\n            insertionSortBy(vs, lo, len, curr, prev);\n            return;\n        }"}
{"magic_number_smell": "        long[] currentInvariants = new long[order];\n        long[] previousInvariants = new long[order];\n\n        int[][] graph = new int[order][4];\n        int[] degree = new int[order];\n\n        // which atoms are the non-hydrogens.", "refactored_code": "    private static final int INITIAL_DEGREE = 4;\n        long[] currentInvariants = new long[order];\n        long[] previousInvariants = new long[order];\n\n        int[][] graph = new int[order][INITIAL_DEGREE];\n        int[] degree = new int[order];\n\n        // which atoms are the non-hydrogens."}
{"magic_number_smell": "     */\n    public static final double Math.toRadians(5) = Math.toRadians(5);\n    \n    public static final double QUART_CARDINALITY_THRESHOLD = Math.toRadians(5) / 4;\n    \n    private final IAtomContainer container;\n    private final int[][]        graph;", "refactored_code": "    public static final double CARDINALITY_THRESHOLD = Math.toRadians(5);\n     */\n    public static final double CARDINALITY_THRESHOLD = Math.toRadians(5);\n    \n    public static final double QUART_CARDINALITY_THRESHOLD = CARDINALITY_THRESHOLD / 4;\n    \n    private final IAtomContainer container;\n    private final int[][]        graph;"}
{"magic_number_smell": "            double absDeltaY = Math.abs(deltaY);\n\n            // assign the bond to the cardinal direction\n            if (absDeltaX < Math.toRadians(5)\n                    && absDeltaY > Math.toRadians(5)) {\n                cardinal[deltaY > 0 ? NORTH : SOUTH] = bond;\n            }", "refactored_code": "    public static final double CARDINALITY_THRESHOLD = Math.toRadians(5);\n            double absDeltaY = Math.abs(deltaY);\n\n            // assign the bond to the cardinal direction\n            if (absDeltaX < CARDINALITY_THRESHOLD\n                    && absDeltaY > CARDINALITY_THRESHOLD) {\n                cardinal[deltaY > 0 ? NORTH : SOUTH] = bond;\n            }"}
{"magic_number_smell": "            double det = det(a.x, a.y, b.x, b.y, c.x, c.y);\n\n            // unspecified by coordinates\n            if (Math.abs(det) < 0.1) return 0;\n\n            return (int) Math.signum(det);\n        }", "refactored_code": "        private static final double THRESHOLD = 0.1;\n            double det = det(a.x, a.y, b.x, b.y, c.x, c.y);\n\n            // unspecified by coordinates\n            if (Math.abs(det) < THRESHOLD) return 0;\n\n            return (int) Math.signum(det);\n        }"}
{"magic_number_smell": "                        fmt.flags |= SPECIAL;\n                        break;\n                    case '0':\n                        fmt.flags |= 1;\n                        break;\n                    case '\\'':\n                        fmt.flags |= GROUPING;", "refactored_code": "    private static final int ZEROPAD  = 1;\n                        fmt.flags |= SPECIAL;\n                        break;\n                    case '0':\n                        fmt.flags |= ZEROPAD;\n                        break;\n                    case '\\'':\n                        fmt.flags |= GROUPING;"}
{"magic_number_smell": "     * The new policy is to keep the singularity of IDs only within a single\n     * molecule, i.e. in a set of two molecules first atoms of each will be \"a1\".\n     */\n    private static int          policy                  = 0;\n\n    /**\n     * Alters the policy of ID generation. The IDCreator should in any case", "refactored_code": "    public static final int     SET_UNIQUE_POLICY       = 0;\n     * The new policy is to keep the singularity of IDs only within a single\n     * molecule, i.e. in a set of two molecules first atoms of each will be \"a1\".\n     */\n    private static int          policy                  = SET_UNIQUE_POLICY;\n\n    /**\n     * Alters the policy of ID generation. The IDCreator should in any case"}
{"magic_number_smell": "     * The flavours are:\n     * <br>\n     * <ul>\n     *     <li>{@link #0x1} (default) - uses the exact mass of each\n     *     atom when an isotope is specified, if not specified the average mass\n     *     of the element is used.</li>\n     *     <li>{@link #MolWeightIgnoreSpecified} - uses the average mass of each", "refactored_code": "    public static final int MolWeight                = 0x1;\n     * The flavours are:\n     * <br>\n     * <ul>\n     *     <li>{@link #MolWeight} (default) - uses the exact mass of each\n     *     atom when an isotope is specified, if not specified the average mass\n     *     of the element is used.</li>\n     *     <li>{@link #MolWeightIgnoreSpecified} - uses the average mass of each"}
{"magic_number_smell": "    /**\n     * Creates a ligancy for chirality around a single chiral atom, where the involved\n     * atoms are identified by there index in the {@link IAtomContainer}. For the four ligand\n     * atoms, {@link #-1} can be passed as index, which will indicate the presence of\n     * an implicit hydrogen, not explicitly present in the chemical graph of the\n     * given <code>container</code>.\n     *", "refactored_code": "    public static final int      HYDROGEN = -1;\n    /**\n     * Creates a ligancy for chirality around a single chiral atom, where the involved\n     * atoms are identified by there index in the {@link IAtomContainer}. For the four ligand\n     * atoms, {@link #HYDROGEN} can be passed as index, which will indicate the presence of\n     * an implicit hydrogen, not explicitly present in the chemical graph of the\n     * given <code>container</code>.\n     *"}
{"magic_number_smell": "    private final Map<Integer, String> bitToPath = new HashMap<>();\n\n    public AtomPairs2DFingerprinter() {\n        for (int dist = 1; dist <= 10; dist++) {\n            for (int i = 0; i < atypes.length; i++) {\n                for (int j = i; j < atypes.length; j++) {\n                    final String key_name = dist + \"_\" + atypes[i] + \"_\" + atypes[j];", "refactored_code": "    private static final int      MAX_DISTANCE = 10;\n    private final Map<Integer, String> bitToPath = new HashMap<>();\n\n    public AtomPairs2DFingerprinter() {\n        for (int dist = 1; dist <= MAX_DISTANCE; dist++) {\n            for (int i = 0; i < atypes.length; i++) {\n                for (int j = i; j < atypes.length; j++) {\n                    final String key_name = dist + \"_\" + atypes[i] + \"_\" + atypes[j];"}
{"magic_number_smell": "    protected List<Map.Entry<String, String>> getParameters() {\n        String type = null;\n        switch (classType) {\n            case 1: type = \"ECFP0\"; break;\n            case CLASS_ECFP2: type = \"ECFP2\"; break;\n            case CLASS_ECFP4: type = \"ECFP4\"; break;\n            case CLASS_ECFP6: type = \"ECFP6\"; break;", "refactored_code": "    public static final int CLASS_ECFP0 = 1;\n    protected List<Map.Entry<String, String>> getParameters() {\n        String type = null;\n        switch (classType) {\n            case CLASS_ECFP0: type = \"ECFP0\"; break;\n            case CLASS_ECFP2: type = \"ECFP2\"; break;\n            case CLASS_ECFP4: type = \"ECFP4\"; break;\n            case CLASS_ECFP6: type = \"ECFP6\"; break;"}
{"magic_number_smell": "     * @param searchDepth The desired depth of search\n     */\n    public ExtendedFingerprinter(int size, int searchDepth) {\n        this.fingerprinter = new Fingerprinter(size - 25, searchDepth);\n    }\n\n    /**", "refactored_code": "    private final int RESERVED_BITS = 25;\n     * @param searchDepth The desired depth of search\n     */\n    public ExtendedFingerprinter(int size, int searchDepth) {\n        this.fingerprinter = new Fingerprinter(size - RESERVED_BITS, searchDepth);\n    }\n\n    /**"}
{"magic_number_smell": "    private final boolean esssr;\n\n    public PubchemFingerprinter(IChemObjectBuilder builder, boolean esssr) {\n        this.m_bits = new byte[(881 + 7) >> 3];\n        this.esssr = esssr;\n    }\n", "refactored_code": "    public static final int FP_SIZE = 881;\n    private final boolean esssr;\n\n    public PubchemFingerprinter(IChemObjectBuilder builder, boolean esssr) {\n        this.m_bits = new byte[(FP_SIZE + 7) >> 3];\n        this.esssr = esssr;\n    }\n"}
{"magic_number_smell": "                int nPaths = apsp.from(i).nPathsTo(j);\n\n                // only encode when there is a manageable number of paths\n                if (nPaths > 0 && nPaths < 5) {\n\n                    for (int[] path : apsp.from(i).pathsTo(j)) {\n                        paths.add(encode(path));", "refactored_code": "    private static final int     MAX_SHORTEST_PATHS = 5;\n                int nPaths = apsp.from(i).nPathsTo(j);\n\n                // only encode when there is a manageable number of paths\n                if (nPaths > 0 && nPaths < MAX_SHORTEST_PATHS) {\n\n                    for (int[] path : apsp.from(i).pathsTo(j)) {\n                        paths.add(encode(path));"}
{"magic_number_smell": "\n    @Override\n    public String[] getDescriptorNames() {\n        String[] labels = new String[5];\n        for (int i = 0; i < 5; i++) {\n            labels[i] = \"protonTotalPartialCharge\" + (i + 1);\n        }", "refactored_code": "    private final int                      MAX_PROTON_COUNT = 5;\n\n    @Override\n    public String[] getDescriptorNames() {\n        String[] labels = new String[MAX_PROTON_COUNT];\n        for (int i = 0; i < MAX_PROTON_COUNT; i++) {\n            labels[i] = \"protonTotalPartialCharge\" + (i + 1);\n        }"}
{"magic_number_smell": "     * Constructor for the RDFProtonDescriptor object\n     */\n    public RDFProtonDescriptor_G3R() {\n        names = new String[13];\n        for (int i = 0; i < 13; i++) {\n\n            names[i] = \"g3r_\" + (i + 1);", "refactored_code": "    private static final int G3R_DESC_LENGTH = 13;\n     * Constructor for the RDFProtonDescriptor object\n     */\n    public RDFProtonDescriptor_G3R() {\n        names = new String[G3R_DESC_LENGTH];\n        for (int i = 0; i < G3R_DESC_LENGTH; i++) {\n\n            names[i] = \"g3r_\" + (i + 1);"}
{"magic_number_smell": "     * Constructor for the RDFProtonDescriptor object\n     */\n    public RDFProtonDescriptor_GDR() {\n        descriptorNames = new String[7];\n        for (int i = 0; i < 7; i++) {\n            descriptorNames[i] = \"gDr_\" + (i + 1);\n        }", "refactored_code": "    private final        int          gdr_desc_length = 7;\n     * Constructor for the RDFProtonDescriptor object\n     */\n    public RDFProtonDescriptor_GDR() {\n        descriptorNames = new String[gdr_desc_length];\n        for (int i = 0; i < gdr_desc_length; i++) {\n            descriptorNames[i] = \"gDr_\" + (i + 1);\n        }"}
{"magic_number_smell": "     * Constructor for the RDFProtonDescriptor object\n     */\n    public RDFProtonDescriptor_GHR() {\n        descriptorNames = new String[15];\n        for (int i = 0; i < 15; i++) {\n            descriptorNames[i] = \"RDF_GHR_\" + i;\n        }", "refactored_code": "    private final int                 ghr_desc_length     = 15;\n     * Constructor for the RDFProtonDescriptor object\n     */\n    public RDFProtonDescriptor_GHR() {\n        descriptorNames = new String[ghr_desc_length];\n        for (int i = 0; i < ghr_desc_length; i++) {\n            descriptorNames[i] = \"RDF_GHR_\" + i;\n        }"}
{"magic_number_smell": "\n    @Override\n    public String[] getDescriptorNames() {\n        String[] descriptorNames = new String[15];\n        for (int i = 0; i < 15; i++) {\n            descriptorNames[i] = \"gHrTop_\" + (i + 1);\n        }", "refactored_code": "    private final int                 ghr_topol_desc_length = 15;\n\n    @Override\n    public String[] getDescriptorNames() {\n        String[] descriptorNames = new String[ghr_topol_desc_length];\n        for (int i = 0; i < ghr_topol_desc_length; i++) {\n            descriptorNames[i] = \"gHrTop_\" + (i + 1);\n        }"}
{"magic_number_smell": "\n    @Override\n    public String[] getDescriptorNames() {\n        String[] descriptorNames = new String[7];\n        for (int i = 0; i < 7; i++) {\n            descriptorNames[i] = \"gSr_\" + (i + 1);\n        }", "refactored_code": "    private final int                 gsr_desc_length     = 7;\n\n    @Override\n    public String[] getDescriptorNames() {\n        String[] descriptorNames = new String[gsr_desc_length];\n        for (int i = 0; i < gsr_desc_length; i++) {\n            descriptorNames[i] = \"gSr_\" + (i + 1);\n        }"}
{"magic_number_smell": "        int[][] atypes = null;\n\n        switch (which) {\n            case 0:\n            case MDEC12:\n            case MDEC13:\n            case MDEC14:", "refactored_code": "    public static final int       MDEC11 = 0;\n        int[][] atypes = null;\n\n        switch (which) {\n            case MDEC11:\n            case MDEC12:\n            case MDEC13:\n            case MDEC14:"}
{"magic_number_smell": "            for (int i = 0; i < 60; i++) {\n                String line = breader.readLine();\n                String[] components = line.split(\",\");\n                if (components.length != (147 + 1))\n                    throw new CDKException(\"TAE peptide data table seems to be corrupt\");\n                String key = components[0].toLowerCase().trim();\n", "refactored_code": "    private final int                   ndesc     = 147;\n            for (int i = 0; i < 60; i++) {\n                String line = breader.readLine();\n                String[] components = line.split(\",\");\n                if (components.length != (ndesc + 1))\n                    throw new CDKException(\"TAE peptide data table seems to be corrupt\");\n                String key = components[0].toLowerCase().trim();\n"}
{"magic_number_smell": "    @Override\n    public double calculateScaleForBondLength(double modelBondLength) {\n        if (Double.isNaN(modelBondLength) || modelBondLength == 0) {\n            return 30.0;\n        } else {\n            return rendererModel.getParameter(BondLength.class).getValue() / modelBondLength;\n        }", "refactored_code": "    public static final double DEFAULT_SCALE = 30.0;\n    @Override\n    public double calculateScaleForBondLength(double modelBondLength) {\n        if (Double.isNaN(modelBondLength) || modelBondLength == 0) {\n            return DEFAULT_SCALE;\n        } else {\n            return rendererModel.getParameter(BondLength.class).getValue() / modelBondLength;\n        }"}
{"magic_number_smell": "     * @param color the color of the path\n     */\n    public GeneralPath(List<PathElement> elements, Color color) {\n        this(elements, color, 0, 1, true);\n\n    }\n", "refactored_code": "    public static final int        WIND_EVEN_ODD = 0;\n     * @param color the color of the path\n     */\n    public GeneralPath(List<PathElement> elements, Color color) {\n        this(elements, color, WIND_EVEN_ODD, 1, true);\n\n    }\n"}
{"magic_number_smell": "\n        // the proportion to move in towards the ring center\n        double distanceFactor = model.getParameter(TowardsRingCenterProportion.class).getValue();\n        double ringDistance = distanceFactor * 6 / ring.getAtomCount();\n        if (ringDistance < distanceFactor / MIN_RINGSIZE_FACTOR) ringDistance = distanceFactor / MIN_RINGSIZE_FACTOR;\n\n        Point2d w = new Point2d();", "refactored_code": "    private final int                         IDEAL_RINGSIZE       = 6;\n\n        // the proportion to move in towards the ring center\n        double distanceFactor = model.getParameter(TowardsRingCenterProportion.class).getValue();\n        double ringDistance = distanceFactor * IDEAL_RINGSIZE / ring.getAtomCount();\n        if (ringDistance < distanceFactor / MIN_RINGSIZE_FACTOR) ringDistance = distanceFactor / MIN_RINGSIZE_FACTOR;\n\n        Point2d w = new Point2d();"}
{"magic_number_smell": "        } else if (neighbors.size() > 1) {\n            return usingCardinalDirection(average(vectors));\n        } else if (neighbors.size() == 1) {\n            return vectors.get(0).x > 0.1 ? Left : Right;\n        } else {\n            return usingDefaultPlacement(atom);\n        }", "refactored_code": "    private static final double        VERTICAL_THRESHOLD = 0.1;\n        } else if (neighbors.size() > 1) {\n            return usingCardinalDirection(average(vectors));\n        } else if (neighbors.size() == 1) {\n            return vectors.get(0).x > VERTICAL_THRESHOLD ? Left : Right;\n        } else {\n            return usingDefaultPlacement(atom);\n        }"}
{"magic_number_smell": "                    // choose the most eastern or.. the most southern\n                    double xDiff = thisMaxX - bestMaxX;\n                    double yDiff = thisMaxY - bestMaxY;\n                    if (xDiff > 0.1 || (xDiff > -0.1 && yDiff < -0.1)) {\n                        suffixBracket = bracket;\n                        suffixBracketPerp = perp;\n                    }", "refactored_code": "    public static final double          EQUIV_THRESHOLD = 0.1;\n                    // choose the most eastern or.. the most southern\n                    double xDiff = thisMaxX - bestMaxX;\n                    double yDiff = thisMaxY - bestMaxY;\n                    if (xDiff > EQUIV_THRESHOLD || (xDiff > -EQUIV_THRESHOLD && yDiff < -EQUIV_THRESHOLD)) {\n                        suffixBracket = bracket;\n                        suffixBracketPerp = perp;\n                    }"}
{"magic_number_smell": "        private void fill(Color[] colors, int from, int to) {\n            if (alpha < 255) {\n                for (int i = from; i <= to; i++) {\n                    Color c = Color.getHSBColor((offset + i) * 0.618033988749895f, saturation, brightness);\n                    colors[i] = new Color(c.getRed(), c.getGreen(), c.getBlue(), alpha);\n                }\n            } else {", "refactored_code": "        private static final float PHI    = 0.618033988749895f;\n        private void fill(Color[] colors, int from, int to) {\n            if (alpha < 255) {\n                for (int i = from; i <= to; i++) {\n                    Color c = Color.getHSBColor((offset + i) * PHI, saturation, brightness);\n                    colors[i] = new Color(c.getRed(), c.getGreen(), c.getBlue(), alpha);\n                }\n            } else {"}
{"magic_number_smell": "    public static final int 0x1 = 0x1;\n    public static final int ROLE_AGENT    = 0x2;\n    public static final int ROLE_PRODUCT  = 0x4;\n    public static final int ROLE_ANY      = 0x1 | ROLE_PRODUCT | ROLE_AGENT;\n\n    private final int role;\n", "refactored_code": "    public static final int ROLE_REACTANT = 0x1;\n    public static final int ROLE_REACTANT = 0x1;\n    public static final int ROLE_AGENT    = 0x2;\n    public static final int ROLE_PRODUCT  = 0x4;\n    public static final int ROLE_ANY      = ROLE_REACTANT | ROLE_PRODUCT | ROLE_AGENT;\n\n    private final int role;\n"}
{"magic_number_smell": "        log.debug(\"Time = \" + time + \" ms\");\n        time = System.currentTimeMillis();\n\n        if (0 > 0)\n            matrixI = calculateI(basis);\n        else\n            matrixI = null;", "refactored_code": "    private final int                 iterations = 0;\n        log.debug(\"Time = \" + time + \" ms\");\n        time = System.currentTimeMillis();\n\n        if (iterations > 0)\n            matrixI = calculateI(basis);\n        else\n            matrixI = null;"}
{"magic_number_smell": "\n    private class AuxiliaryGraph2 extends SimpleGraph {\n\n        private static final long 857337988734567429L = 5930876716644738726L;\n\n        // graph to aux. graph\n        private final HashMap           vertexMap00      = new HashMap();", "refactored_code": "        private static final long serialVersionUID = 857337988734567429L;\n\n    private class AuxiliaryGraph2 extends SimpleGraph {\n\n        private static final long serialVersionUID = 5930876716644738726L;\n\n        // graph to aux. graph\n        private final HashMap           vertexMap00      = new HashMap();"}
{"magic_number_smell": "            for (j = 1; j <= count; j++) {\n                t = weight[i] - category[j];\n                if (t < 0.0) t = -t;\n                if (t < 0.000000000001) break;\n            }\n            if (j > count) {\n                count += 1;", "refactored_code": "    private static final double       LOST   = 0.000000000001;\n            for (j = 1; j <= count; j++) {\n                t = weight[i] - category[j];\n                if (t < 0.0) t = -t;\n                if (t < LOST) break;\n            }\n            if (j > count) {\n                count += 1;"}
{"magic_number_smell": "     * @param\tcoordinatesUnits\t<code>BOHR_UNIT</code> if coordinates are given in Bohr unit and <code>ANGSTROM_UNIT</code>\n     *                              if they are given in &Aring;ngstr&ouml;m unit.\n     *\n     * @return\tThe scaling conversion factor: 1 if no scaling is needed and <code>0.529177249</code> if scaling has to be performed.\n     *\n     * @see org.openscience.cdk.PhysicalConstants#0.529177249\n     * @see org.openscience.cdk.io.GamessReader#BOHR_UNIT", "refactored_code": "    public static final double  BOHR_TO_ANGSTROM = 0.529177249;\n     * @param\tcoordinatesUnits\t<code>BOHR_UNIT</code> if coordinates are given in Bohr unit and <code>ANGSTROM_UNIT</code>\n     *                              if they are given in &Aring;ngstr&ouml;m unit.\n     *\n     * @return\tThe scaling conversion factor: 1 if no scaling is needed and <code>BOHR_TO_ANGSTROM</code> if scaling has to be performed.\n     *\n     * @see org.openscience.cdk.PhysicalConstants#BOHR_TO_ANGSTROM\n     * @see org.openscience.cdk.io.GamessReader#BOHR_UNIT"}
{"magic_number_smell": "        }\n\n        if (smile.equals(PYRROLE_SMI))\n            return 4;\n        else if (smile.equals(FURAN_SMI))\n            return FURAN_RING;\n        else if (smile.equals(THIOPHENE_SMI))", "refactored_code": "    public static final int PYROLE_RING     = 4;\n        }\n\n        if (smile.equals(PYRROLE_SMI))\n            return PYROLE_RING;\n        else if (smile.equals(FURAN_SMI))\n            return FURAN_RING;\n        else if (smile.equals(THIOPHENE_SMI))"}
{"magic_number_smell": "\n    class HOSECodeShiftRange implements java.io.Serializable {\n\n        private static final long 4382025930031432321L = 1649047314594679297L;\n\n        final String                    code;\n        final double                    shift;", "refactored_code": "    private static final long             serialVersionUID = 4382025930031432321L;\n\n    class HOSECodeShiftRange implements java.io.Serializable {\n\n        private static final long serialVersionUID = 1649047314594679297L;\n\n        final String                    code;\n        final double                    shift;"}
{"magic_number_smell": "     * @param classInst Class from which the log messages originate\n     */\n    public Log4jLoggingTool(Class<?> classInst) {\n        stackLength = 5;\n        log4jLogger = LogManager.getLogger(classInst);\n    }\n", "refactored_code": "    public final int DEFAULT_STACK_LENGTH = 5;\n     * @param classInst Class from which the log messages originate\n     */\n    public Log4jLoggingTool(Class<?> classInst) {\n        stackLength = DEFAULT_STACK_LENGTH;\n        log4jLogger = LogManager.getLogger(classInst);\n    }\n"}
{"magic_number_smell": "     * @param classInst Class from which the log messages originate\n     */\n    public Slf4jLoggingTool(Class<?> classInst) {\n        stackLength = 5;\n        slf4jlogger = LoggerFactory.getLogger(classInst);\n    }\n", "refactored_code": "    public final int DEFAULT_STACK_LENGTH = 5;\n     * @param classInst Class from which the log messages originate\n     */\n    public Slf4jLoggingTool(Class<?> classInst) {\n        stackLength = DEFAULT_STACK_LENGTH;\n        slf4jlogger = LoggerFactory.getLogger(classInst);\n    }\n"}
{"magic_number_smell": "                }\n            }\n            Iterator<Map.Entry<Integer, SPIN_MULTIPLICITY>> iterator = atomIndexSpinMap.entrySet().iterator();\n            for (int i = 0; i < atomIndexSpinMap.size(); i += 8) {\n                if (atomIndexSpinMap.size() - i <= 8) {\n                    writer.write(\"M  RAD\" + formatMDLInt(atomIndexSpinMap.size() - i, WIDTH));\n                    writeRadicalPattern(iterator, 0);", "refactored_code": "    private static final int NN8   = 8;\n                }\n            }\n            Iterator<Map.Entry<Integer, SPIN_MULTIPLICITY>> iterator = atomIndexSpinMap.entrySet().iterator();\n            for (int i = 0; i < atomIndexSpinMap.size(); i += NN8) {\n                if (atomIndexSpinMap.size() - i <= NN8) {\n                    writer.write(\"M  RAD\" + formatMDLInt(atomIndexSpinMap.size() - i, WIDTH));\n                    writeRadicalPattern(iterator, 0);"}
{"magic_number_smell": "            newLineIfNeeded();\n            writePrefixIfNeeded();\n            final int len = str.length();\n            if (currLength + len < 78) {\n                this.writer.write(str);\n                currLength += len;\n            } else {", "refactored_code": "        public static final int     LIMIT      = 78; // -\\n takes two chars (80 total)\n            newLineIfNeeded();\n            writePrefixIfNeeded();\n            final int len = str.length();\n            if (currLength + len < LIMIT) {\n                this.writer.write(str);\n                currLength += len;\n            } else {"}
{"magic_number_smell": "    // magic number - indicates isotope mass is relative\n    private static final int          10000 = 10000;\n    /**\n     * JNI-Inchi uses the magic number {#link 10000} plus the\n     * (possibly negative) relative mass. So any isotope value\n     * coming back from jni-inchi greater than this threshold value\n     * should be treated as a relative mass.", "refactored_code": "    private static final int          ISOTOPIC_SHIFT_FLAG = 10000;\n    // magic number - indicates isotope mass is relative\n    private static final int          ISOTOPIC_SHIFT_FLAG = 10000;\n    /**\n     * JNI-Inchi uses the magic number {#link ISOTOPIC_SHIFT_FLAG} plus the\n     * (possibly negative) relative mass. So any isotope value\n     * coming back from jni-inchi greater than this threshold value\n     * should be treated as a relative mass."}
{"magic_number_smell": "\n    public JMOLANIMATIONConvention(IChemFile chemFile) {\n        super(chemFile);\n        current = -1;\n    }\n\n    public JMOLANIMATIONConvention(ICMLModule conv) {", "refactored_code": "    private final int           UNKNOWN = -1;\n\n    public JMOLANIMATIONConvention(IChemFile chemFile) {\n        super(chemFile);\n        current = UNKNOWN;\n    }\n\n    public JMOLANIMATIONConvention(ICMLModule conv) {"}
{"magic_number_smell": "\n    private final static Map<Resource, Hybridization> RESOURCE_TO_HYBRID = new HashMap<Resource, Hybridization>(10) {\n\n                                                                             private static final long 1027415392461000485L = -351285511820100853L;\n                                                                             {\n                                                                                 put(CDK.HYBRID_S, Hybridization.S);\n                                                                                 put(CDK.HYBRID_SP1, Hybridization.SP1);", "refactored_code": "                                                                             private static final long serialVersionUID = 1027415392461000485L;\n\n    private final static Map<Resource, Hybridization> RESOURCE_TO_HYBRID = new HashMap<Resource, Hybridization>(10) {\n\n                                                                             private static final long serialVersionUID = -351285511820100853L;\n                                                                             {\n                                                                                 put(CDK.HYBRID_S, Hybridization.S);\n                                                                                 put(CDK.HYBRID_SP1, Hybridization.SP1);"}
{"magic_number_smell": "    private BooleanIOSetting titleSetting;\n    private IntegerIOSetting flavorSetting;\n    private final int SmiFlavor.Default = SmiFlavor.Default;\n    private SmilesGenerator smigen = new SmilesGenerator(SmiFlavor.Default);\n    private final StringBuilder buffer = new StringBuilder();\n\n    /**", "refactored_code": "    private final int flav = SmiFlavor.Default;\n    private BooleanIOSetting titleSetting;\n    private IntegerIOSetting flavorSetting;\n    private final int flav = SmiFlavor.Default;\n    private SmilesGenerator smigen = new SmilesGenerator(flav);\n    private final StringBuilder buffer = new StringBuilder();\n\n    /**"}
{"magic_number_smell": "    /**\n     * Renumber AtomAtomMaps during canonical generation\n     */\n    public static final int AtomAtomMapRenumber = 0x001 | AtomAtomMap | 0x2000000;\n\n    /**\n     * Output data Sgroups.", "refactored_code": "    public static final int Canonical          = 0x001;\n    /**\n     * Renumber AtomAtomMaps during canonical generation\n     */\n    public static final int AtomAtomMapRenumber = Canonical | AtomAtomMap | 0x2000000;\n\n    /**\n     * Output data Sgroups."}
{"magic_number_smell": "        /* 0: remove charge, and possible flag ac */\n        for (int j = 0; j < ac.getAtomCount(); j++) {\n            ac.getAtom(j).setCharge(0.0);\n            ac.getAtom(j).setFlag(0x1, false);\n        }\n        for (int j = 0; j < ac.getBondCount(); j++) {\n            ac.getBond(j).setFlag(0x1, false);", "refactored_code": "    private static final int          ISCHANGEDFC   = 0x1;\n        /* 0: remove charge, and possible flag ac */\n        for (int j = 0; j < ac.getAtomCount(); j++) {\n            ac.getAtom(j).setCharge(0.0);\n            ac.getAtom(j).setFlag(ISCHANGEDFC, false);\n        }\n        for (int j = 0; j < ac.getBondCount(); j++) {\n            ac.getBond(j).setFlag(ISCHANGEDFC, false);"}
{"magic_number_smell": "                    }\n\n                    // Filter isotopes too small\n                    if (abundance > 1E-10) {\n                        IsotopeContainer newcontainer = new IsotopeContainer(mass, abundance);\n                        if (storeFormula) {\n                            for (IMolecularFormula mf : container.getFormulas())", "refactored_code": "    private final double  minAbundance = 1E-10; // n.b. not actually abundance\n                    }\n\n                    // Filter isotopes too small\n                    if (abundance > minAbundance) {\n                        IsotopeContainer newcontainer = new IsotopeContainer(mass, abundance);\n                        if (storeFormula) {\n                            for (IMolecularFormula mf : container.getFormulas())"}
{"magic_number_smell": "\n        /* charge to add */\n        if (isoto1.getCharge() == 1)\n            chargeToAdd = 0.0005485;\n        else if (isoto1.getCharge() == -1)\n            chargeToAdd = -0.0005485;\n        else", "refactored_code": "    private static final double massE         = 0.0005485;\n\n        /* charge to add */\n        if (isoto1.getCharge() == 1)\n            chargeToAdd = massE;\n        else if (isoto1.getCharge() == -1)\n            chargeToAdd = -massE;\n        else"}
{"magic_number_smell": "    private final List<RangeMassDecomposer> decomposerCache;\n\n    private DecomposerFactory() {\n        this.decomposerCache = new ArrayList<>(10);\n    }\n\n    public static DecomposerFactory getInstance() {", "refactored_code": "    private static final int maximalNumberOfCachedDecomposers = 10;\n    private final List<RangeMassDecomposer> decomposerCache;\n\n    private DecomposerFactory() {\n        this.decomposerCache = new ArrayList<>(maximalNumberOfCachedDecomposers);\n    }\n\n    public static DecomposerFactory getInstance() {"}
{"magic_number_smell": "    public IsotopePatternRule() {\n        isotopeGe = new IsotopePatternGenerator(0.01);\n        is = new IsotopePatternSimilarity();\n        is.seTolerance(0.001);\n    }\n\n    /**", "refactored_code": "    private final double                   toleranceMass = 0.001;\n    public IsotopePatternRule() {\n        isotopeGe = new IsotopePatternGenerator(0.01);\n        is = new IsotopePatternSimilarity();\n        is.seTolerance(toleranceMass);\n    }\n\n    /**"}
{"magic_number_smell": "     * The flavours are:\n     * <br>\n     * <ul>\n     *     <li>{@link #AtomContainerManipulator.MolWeight} (default) - uses the exact mass of each\n     *     atom when an isotope is specified, if not specified the average mass\n     *     of the element is used.</li>\n     *     <li>{@link #MolWeightIgnoreSpecified} - uses the average mass of each", "refactored_code": "    public static final int MolWeight                = AtomContainerManipulator.MolWeight;\n     * The flavours are:\n     * <br>\n     * <ul>\n     *     <li>{@link #MolWeight} (default) - uses the exact mass of each\n     *     atom when an isotope is specified, if not specified the average mass\n     *     of the element is used.</li>\n     *     <li>{@link #MolWeightIgnoreSpecified} - uses the average mass of each"}
{"magic_number_smell": "     * Instantiate fragmenter with default minimum fragment size.\n     */\n    public ExhaustiveFragmenter() {\n        this(6);\n    }\n\n    /**", "refactored_code": "    private static final int    DEFAULT_MIN_FRAG_SIZE = 6;\n     * Instantiate fragmenter with default minimum fragment size.\n     */\n    public ExhaustiveFragmenter() {\n        this(DEFAULT_MIN_FRAG_SIZE);\n    }\n\n    /**"}
{"magic_number_smell": "\n        double det = (a.x - c.x) * (b.y - c.y) - (a.y - c.y) * (b.x - c.x);\n\n        return Math.abs(det) < 0.1 ? 0 : (int) Math.signum(det);\n    }\n\n}", "refactored_code": "    private static final double THRESHOLD = 0.1;\n\n        double det = (a.x - c.x) * (b.y - c.y) - (a.y - c.y) * (b.x - c.x);\n\n        return Math.abs(det) < THRESHOLD ? 0 : (int) Math.signum(det);\n    }\n\n}"}
{"magic_number_smell": "                }\n            } else if (q < 0) {\n                for (int i : centres) {\n                    next[i] = current[i] * 15543053;\n                }\n            }\n", "refactored_code": "    private static final long       CLOCKWISE     = 15543053;\n                }\n            } else if (q < 0) {\n                for (int i : centres) {\n                    next[i] = current[i] * CLOCKWISE;\n                }\n            }\n"}
{"magic_number_smell": "    void unspecified() throws Exception {\n        GeometricParity geometric = new DoubleBond2DParity(new Point2d(-2.6518, 0.1473), new Point2d(-1.8268, 0.1473),\n                new Point2d(-3.0643, 0.8618), new Point2d(-1.4143, 0.1473));\n        Assertions.assertEquals(0, geometric.parity());\n    }\n\n    @Test", "refactored_code": "    private static final int UNSPECIFIED = 0;\n    void unspecified() throws Exception {\n        GeometricParity geometric = new DoubleBond2DParity(new Point2d(-2.6518, 0.1473), new Point2d(-1.8268, 0.1473),\n                new Point2d(-3.0643, 0.8618), new Point2d(-1.4143, 0.1473));\n        Assertions.assertEquals(UNSPECIFIED, geometric.parity());\n    }\n\n    @Test"}
{"magic_number_smell": "    void opposite() throws Exception {\n        GeometricParity geometric = new DoubleBond3DParity(new Point3d(-4.6440, 0.4411, 0.5917), new Point3d(-3.7159,\n                0.1090, -0.5916), new Point3d(-5.3207, -0.6945, 1.3818), new Point3d(-3.0392, 1.2445, -1.3818));\n        Assertions.assertEquals(+1, geometric.parity());\n    }\n\n    @Test", "refactored_code": "    private static final int OPPOSITE = +1;\n    void opposite() throws Exception {\n        GeometricParity geometric = new DoubleBond3DParity(new Point3d(-4.6440, 0.4411, 0.5917), new Point3d(-3.7159,\n                0.1090, -0.5916), new Point3d(-5.3207, -0.6945, 1.3818), new Point3d(-3.0392, 1.2445, -1.3818));\n        Assertions.assertEquals(OPPOSITE, geometric.parity());\n    }\n\n    @Test"}
{"magic_number_smell": "        };\n        int[] elev = new int[]{0, 0, 0, -1};\n        GeometricParity parity = new Tetrahedral2DParity(coords, elev);\n        org.hamcrest.MatcherAssert.assertThat(parity.parity(), is(-1));\n    }\n\n    /**", "refactored_code": "    private static final int CLOCKWISE     = -1;\n        };\n        int[] elev = new int[]{0, 0, 0, -1};\n        GeometricParity parity = new Tetrahedral2DParity(coords, elev);\n        org.hamcrest.MatcherAssert.assertThat(parity.parity(), is(CLOCKWISE));\n    }\n\n    /**"}
{"magic_number_smell": "                new Point3d(0.26, -0.33, 0.95), // -C\n                new Point3d(1.44, -0.33, -0.03), // C (centre)\n        };\n        assertThat(new Tetrahedral3DParity(coords).parity(), is(-1));\n    }\n\n    @Test", "refactored_code": "    private static final int CLOCKWISE     = -1;\n                new Point3d(0.26, -0.33, 0.95), // -C\n                new Point3d(1.44, -0.33, -0.03), // C (centre)\n        };\n        assertThat(new Tetrahedral3DParity(coords).parity(), is(CLOCKWISE));\n    }\n\n    @Test"}
{"magic_number_smell": "        Vector2d v1 = newVector(p2, p1);\n        Vector2d v2 = newVector(p3, p1);\n\n        return Math.abs(v2.angle(v1) - Math.toRadians(120)) < 0.01;\n    }\n\n    /**", "refactored_code": "    private static final double ANGLE_120 = Math.toRadians(120);\n        Vector2d v1 = newVector(p2, p1);\n        Vector2d v2 = newVector(p3, p1);\n\n        return Math.abs(v2.angle(v1) - ANGLE_120) < 0.01;\n    }\n\n    /**"}
{"magic_number_smell": "                final double x = p1.x - p2.x;\n                final double y = p1.y - p2.y;\n                final double dist2 = x * x + y * y;\n                final double contrib = dist2 > 0.00001 ? 1 / dist2 : MAX_SCORE;\n                score += contribution[j][i] = contribution[i][j] = contrib;\n            }\n        }", "refactored_code": "    private static final double MIN_DIST  = 0.00001;\n                final double x = p1.x - p2.x;\n                final double y = p1.y - p2.y;\n                final double dist2 = x * x + y * y;\n                final double contrib = dist2 > MIN_DIST ? 1 / dist2 : MAX_SCORE;\n                score += contribution[j][i] = contribution[i][j] = contrib;\n            }\n        }"}
{"magic_number_smell": "\n    // Min dist between un-bonded atoms, making the denominator smaller means\n    // we want to spread atoms out more\n    private static final double MIN_DIST = 1.5 / 2;\n\n    // Min score is derived from the min distance\n    private static final double MIN_SCORE = 1 / (MIN_DIST * MIN_DIST);", "refactored_code": "    private static final double BOND_LENGTH = 1.5;\n\n    // Min dist between un-bonded atoms, making the denominator smaller means\n    // we want to spread atoms out more\n    private static final double MIN_DIST = BOND_LENGTH / 2;\n\n    // Min score is derived from the min distance\n    private static final double MIN_SCORE = 1 / (MIN_DIST * MIN_DIST);"}
{"magic_number_smell": "     *\n     * @param macrocycle macrocycle\n     * @param ringset entire ring system\n     * @param wind winding of ring -1/CCW\n     * @param winding winding of each turn in the ring\n     * @return the best scoring configuration\n     */", "refactored_code": "    private static final int CW  = -1;\n     *\n     * @param macrocycle macrocycle\n     * @param ringset entire ring system\n     * @param wind winding of ring CW/CCW\n     * @param winding winding of each turn in the ring\n     * @return the best scoring configuration\n     */"}
{"magic_number_smell": "    private int checkAndHandleRingSystems(List<IBond> bonds, List<Integer> rnums) {\n\n        if (!isSpiro(rnums))\n            return 0;\n\n        // square planar\n        if (bonds.size() == 4) {", "refactored_code": "    private static final int SPIRO_REJECT = 0;\n    private int checkAndHandleRingSystems(List<IBond> bonds, List<Integer> rnums) {\n\n        if (!isSpiro(rnums))\n            return SPIRO_REJECT;\n\n        // square planar\n        if (bonds.size() == 4) {"}
{"magic_number_smell": "                                    bestLen = len;\n                                    newRingCenterVector.set(vec);\n                                }\n                                rotate(vec, Math.toRadians(-30));\n                            }\n                        }\n", "refactored_code": "    public static final double RAD_30 = Math.toRadians(-30);\n                                    bestLen = len;\n                                    newRingCenterVector.set(vec);\n                                }\n                                rotate(vec, RAD_30);\n                            }\n                        }\n"}
{"magic_number_smell": "            if (firstBondVector != null && firstBondVector != DEFAULT_BOND_VECTOR)\n                atomPlacer.placeLinearChain(longestChain, firstBondVector, bondLength);\n            else\n                atomPlacer.placeLinearChain(longestChain, new Vector2d(Math.cos(Math.toRadians(-30)), Math.sin(Math.toRadians(-30))), bondLength);\n            logger.debug(\"Placed longest aliphatic chain\");\n        }\n    }", "refactored_code": "    private static final double                     RAD_30                   = Math.toRadians(-30);\n            if (firstBondVector != null && firstBondVector != DEFAULT_BOND_VECTOR)\n                atomPlacer.placeLinearChain(longestChain, firstBondVector, bondLength);\n            else\n                atomPlacer.placeLinearChain(longestChain, new Vector2d(Math.cos(RAD_30), Math.sin(RAD_30)), bondLength);\n            logger.debug(\"Placed longest aliphatic chain\");\n        }\n    }"}
{"magic_number_smell": "    public static final int FLAVOR_CACTVS     = 0x04;\n    public static final int FLAVOR_MOE        = 0x08;\n    public static final int FLAVOR_OECHEM     = 0x10;\n    public static final int FLAVOR_CDK        = 0x01;\n    public static final int FLAVOR_CDK_LEGACY = 0x40;\n\n    // input flags", "refactored_code": "    public static final int FLAVOR_LOOSE      = 0x01;\n    public static final int FLAVOR_CACTVS     = 0x04;\n    public static final int FLAVOR_MOE        = 0x08;\n    public static final int FLAVOR_OECHEM     = 0x10;\n    public static final int FLAVOR_CDK        = FLAVOR_LOOSE;\n    public static final int FLAVOR_CDK_LEGACY = 0x40;\n\n    // input flags"}
{"magic_number_smell": "        // check arg\n        switch (mode) {\n            case MODE_EXACT:\n            case 1:\n                break;\n            default:\n                throw new IllegalArgumentException(\"Invalid mode specified!\");", "refactored_code": "    public static final int MODE_JCOMPOUNDMAPPER = 1;\n        // check arg\n        switch (mode) {\n            case MODE_EXACT:\n            case MODE_JCOMPOUNDMAPPER:\n                break;\n            default:\n                throw new IllegalArgumentException(\"Invalid mode specified!\");"}
{"magic_number_smell": "            List<Integer> blueAtoms = new ArrayList<>();\n\n            /* *randomly divide atoms into two parts: redAtoms and blueAtoms.** */\n            if (splitMode == 0) {\n                /*\n                 * better way to randomly divide atoms into two parts: redAtoms\n                 * and blueAtoms.", "refactored_code": "    public static final int      SPLIT_MODE_RADNDOM       = 0;\n            List<Integer> blueAtoms = new ArrayList<>();\n\n            /* *randomly divide atoms into two parts: redAtoms and blueAtoms.** */\n            if (splitMode == SPLIT_MODE_RADNDOM) {\n                /*\n                 * better way to randomly divide atoms into two parts: redAtoms\n                 * and blueAtoms."}
{"magic_number_smell": "     *\n     * <pre>{@code\n     * // enabled -KET option\n     * InChITautomerGenerator tautgen = new InChITautomerGenerator(InChITautomerGenerator.0x1);\n     * // enabled both -KET and -15T\n     * InChITautomerGenerator tautgen = new InChITautomerGenerator(InChITautomerGenerator.0x1 | InChITautomerGenerator.ONE_FIVE_SHIFT);\n     * }</pre>", "refactored_code": "    public static final int KETO_ENOL      = 0x1;\n     *\n     * <pre>{@code\n     * // enabled -KET option\n     * InChITautomerGenerator tautgen = new InChITautomerGenerator(InChITautomerGenerator.KETO_ENOL);\n     * // enabled both -KET and -15T\n     * InChITautomerGenerator tautgen = new InChITautomerGenerator(InChITautomerGenerator.KETO_ENOL | InChITautomerGenerator.ONE_FIVE_SHIFT);\n     * }</pre>"}
{"magic_number_smell": "            } else {\n                if (v > 1.0F) v = 1.0F;\n\n                rgbvalue[i] = (float)(1.055 * Math.pow(v, 1.0 / 2.4) - 0.055);\n            }\n        }\n", "refactored_code": "    private static final double power1 = 1.0 / 2.4;\n            } else {\n                if (v > 1.0F) v = 1.0F;\n\n                rgbvalue[i] = (float)(1.055 * Math.pow(v, power1) - 0.055);\n            }\n        }\n"}
{"magic_number_smell": "    }\n\n    protected void buildPalette() {\n        reduceList = new ColorNode[8 + 1];\n\tfor (int i = 0; i < reduceList.length; i++) {\n\t    reduceList[i] = null;\n\t}", "refactored_code": "    protected static final int MAXLEVEL = 8;\n    }\n\n    protected void buildPalette() {\n        reduceList = new ColorNode[MAXLEVEL + 1];\n\tfor (int i = 0; i < reduceList.length; i++) {\n\t    reduceList[i] = null;\n\t}"}
{"magic_number_smell": "            } else {\n                if (v > 1.0F) v = 1.0F;\n\n                rgbvalue[i] = (float)(1.055 * Math.pow(v, 1.0 / 2.4) - 0.055);\n            }\n        }\n", "refactored_code": "    private static final double power1 = 1.0 / 2.4;\n            } else {\n                if (v > 1.0F) v = 1.0F;\n\n                rgbvalue[i] = (float)(1.055 * Math.pow(v, power1) - 0.055);\n            }\n        }\n"}
{"magic_number_smell": "\n            // Classify the image type\n            if (bitsPerPixel == 1) {\n                imageType = 0;\n            } else if (bitsPerPixel == 4) {\n                imageType = VERSION_2_4_BIT;\n            } else if (bitsPerPixel == 8) {", "refactored_code": "    private static final int VERSION_2_1_BIT = 0;\n\n            // Classify the image type\n            if (bitsPerPixel == 1) {\n                imageType = VERSION_2_1_BIT;\n            } else if (bitsPerPixel == 4) {\n                imageType = VERSION_2_4_BIT;\n            } else if (bitsPerPixel == 8) {"}
{"magic_number_smell": "        QTable(ImageInputStream stream) throws IOException {\n            elementPrecision = (int)stream.readBits(4);\n            tableID = (int)stream.readBits(4);\n            byte[] tmp = new byte[64];\n            stream.readFully(tmp);\n            int[] data = new int[64];\n            for (int i = 0; i < 64; i++) {", "refactored_code": "        private static final int QTABLE_SIZE = 64;\n        QTable(ImageInputStream stream) throws IOException {\n            elementPrecision = (int)stream.readBits(4);\n            tableID = (int)stream.readBits(4);\n            byte[] tmp = new byte[QTABLE_SIZE];\n            stream.readFully(tmp);\n            int[] data = new int[QTABLE_SIZE];\n            for (int i = 0; i < QTABLE_SIZE; i++) {"}
{"magic_number_smell": "            }\n\n            variant = iis.readByte();\t// file variant\n            if ((variant < '1') || (variant > PPM_RAW)) {\n                throw new RuntimeException(I18N.getString(\"PNMImageReader0\"));\n            }\n", "refactored_code": "    private static final int PBM_ASCII  = '1';\n            }\n\n            variant = iis.readByte();\t// file variant\n            if ((variant < PBM_ASCII) || (variant > PPM_RAW)) {\n                throw new RuntimeException(I18N.getString(\"PNMImageReader0\"));\n            }\n"}
{"magic_number_smell": "        writeInteger(stream, h);\t\t// height\n\n        // Write sample max value for non-binary images\n        if ((variant != PBM_RAW) && (variant != '1')) {\n            stream.write(lineSeparator);\n            writeInteger(stream, maxValue);\n        }", "refactored_code": "    private static final int PBM_ASCII  = '1';\n        writeInteger(stream, h);\t\t// height\n\n        // Write sample max value for non-binary images\n        if ((variant != PBM_RAW) && (variant != PBM_ASCII)) {\n            stream.write(lineSeparator);\n            writeInteger(stream, maxValue);\n        }"}
{"magic_number_smell": "        float Z =  0.019334f*r + 0.119193f*g + 0.950227f*b;\n\n        float YYn = Y/Yn;\n        float XXn = X/95.047f;\n        float ZZn = Z/Zn;\n\n        if (YYn < 0.008856f) {", "refactored_code": "    private static final float Xn = 95.047f;\n        float Z =  0.019334f*r + 0.119193f*g + 0.950227f*b;\n\n        float YYn = Y/Yn;\n        float XXn = X/Xn;\n        float ZZn = Z/Zn;\n\n        if (YYn < 0.008856f) {"}
{"magic_number_smell": "             (7-(bitIndex & 0x7))) & 0x1;\n        int currentColor = BLACK;\n        if (testbit != 0) {\n            outIndex += add1DBits(compData, outIndex, 0, 0);\n        } else {\n            currentColor = 0;\n        }", "refactored_code": "    public static final int WHITE = 0;\n             (7-(bitIndex & 0x7))) & 0x1;\n        int currentColor = BLACK;\n        if (testbit != 0) {\n            outIndex += add1DBits(compData, outIndex, 0, WHITE);\n        } else {\n            currentColor = WHITE;\n        }"}
{"magic_number_smell": "            int bitsPerPixel = bitDepth*(numBands + numExtraSamples);\n            int bytesPerRow = (bitsPerPixel*width + 7)/8;\n            rowsPerStrip =\n                Math.max(Math.max(8192/bytesPerRow, 1), 8);\n        }\n        rowsPerStrip = Math.min(rowsPerStrip, height);\n", "refactored_code": "    public static final int DEFAULT_BYTES_PER_STRIP = 8192;\n            int bitsPerPixel = bitDepth*(numBands + numExtraSamples);\n            int bytesPerRow = (bitsPerPixel*width + 7)/8;\n            rowsPerStrip =\n                Math.max(Math.max(DEFAULT_BYTES_PER_STRIP/bytesPerRow, 1), 8);\n        }\n        rowsPerStrip = Math.min(rowsPerStrip, height);\n"}
{"magic_number_smell": "            }\n            System.arraycopy(tables, 0, data, 0, dataOffset);\n\n            // Check for 0xD8 and skip it if present.\n            byte byte1 = (byte)stream.read();\n            byte byte2 = (byte)stream.read();\n            if(!((byte1 & 0xff) == 0xff && (byte2 & 0xff) == 0xD8)) {", "refactored_code": "    protected static final int SOI = 0xD8;\n            }\n            System.arraycopy(tables, 0, data, 0, dataOffset);\n\n            // Check for SOI and skip it if present.\n            byte byte1 = (byte)stream.read();\n            byte byte2 = (byte)stream.read();\n            if(!((byte1 & 0xff) == 0xff && (byte2 & 0xff) == SOI)) {"}
{"magic_number_smell": "\n    // Store constants in S15.16 format \n    private static final int 16 = 16;\n    private static final float FRAC_SCALE = (float)(1 << 16);\n\n    private float LumaRed = 0.299f;\n    private float LumaGreen = 0.587f;", "refactored_code": "    private static final int FRAC_BITS = 16;\n\n    // Store constants in S15.16 format \n    private static final int FRAC_BITS = 16;\n    private static final float FRAC_SCALE = (float)(1 << FRAC_BITS);\n\n    private float LumaRed = 0.299f;\n    private float LumaGreen = 0.587f;"}
{"magic_number_smell": "    /**\n     * A mask to be used with the \"NewSubfileType\" tag.\n     *\n     * @see #254\n     */\n    public static final int NEW_SUBFILE_TYPE_REDUCED_RESOLUTION = 1;\n", "refactored_code": "    public static final int TAG_NEW_SUBFILE_TYPE = 254;\n    /**\n     * A mask to be used with the \"NewSubfileType\" tag.\n     *\n     * @see #TAG_NEW_SUBFILE_TYPE\n     */\n    public static final int NEW_SUBFILE_TYPE_REDUCED_RESOLUTION = 1;\n"}
{"magic_number_smell": "     * '0'}</code> to be used with the \"GPSVersionID\" tag to indicate\n     * GPS version 2.2.\n     *\n     * @see #0\n     */\n    public static byte[] GPS_VERSION_2_2 = { '2', '2', '0', '0' };\n", "refactored_code": "    public static final int TAG_GPS_VERSION_ID = 0;\n     * '0'}</code> to be used with the \"GPSVersionID\" tag to indicate\n     * GPS version 2.2.\n     *\n     * @see #TAG_GPS_VERSION_ID\n     */\n    public static byte[] GPS_VERSION_2_2 = { '2', '2', '0', '0' };\n"}
{"magic_number_smell": "     * Interoperability Rules (ExifR98) or to the DCF basic file stipulated\n     * by the Design Rule for Camera File System (type ASCII).\n     *\n     * @see #1\n     */\n    public static final String INTEROPERABILITY_INDEX_R98 = \"R98\";\n", "refactored_code": "    public static final int TAG_INTEROPERABILITY_INDEX = 1;\n     * Interoperability Rules (ExifR98) or to the DCF basic file stipulated\n     * by the Design Rule for Camera File System (type ASCII).\n     *\n     * @see #TAG_INTEROPERABILITY_INDEX\n     */\n    public static final String INTEROPERABILITY_INDEX_R98 = \"R98\";\n"}
{"magic_number_smell": "        \n        public EXIFIFDPointer() {\n            super(\"EXIFIFDPointer\",\n                  34665,\n                  1 << TIFFTag.TIFF_LONG,\n                  EXIFTIFFTagSet.getInstance());\n        }", "refactored_code": "    public static final int TAG_EXIF_IFD_POINTER = 34665;\n        \n        public EXIFIFDPointer() {\n            super(\"EXIFIFDPointer\",\n                  TAG_EXIF_IFD_POINTER,\n                  1 << TIFFTag.TIFF_LONG,\n                  EXIFTIFFTagSet.getInstance());\n        }"}
{"magic_number_smell": "        \n        public BadFaxLines() {\n            super(\"BadFaxLines\",\n                  326,\n                  1 << TIFF_SHORT |\n                  1 << TIFF_LONG);\n        }", "refactored_code": "    public static final int TAG_BAD_FAX_LINES = 326;\n        \n        public BadFaxLines() {\n            super(\"BadFaxLines\",\n                  TAG_BAD_FAX_LINES,\n                  1 << TIFF_SHORT |\n                  1 << TIFF_LONG);\n        }"}
{"magic_number_smell": "    static class ModelPixelScale extends TIFFTag {\n        public ModelPixelScale() {\n            super(\"ModelPixelScaleTag\",\n                  33550,\n                  1 << TIFFTag.TIFF_DOUBLE);\n        }\n    }", "refactored_code": "    public static final int TAG_MODEL_PIXEL_SCALE = 33550;\n    static class ModelPixelScale extends TIFFTag {\n        public ModelPixelScale() {\n            super(\"ModelPixelScaleTag\",\n                  TAG_MODEL_PIXEL_SCALE,\n                  1 << TIFFTag.TIFF_DOUBLE);\n        }\n    }"}
{"magic_number_smell": "    /**\n     * The numerically smallest constant representing a TIFF data type.\n     */\n    public static final int MIN_DATATYPE = 1;\n\n    /**\n     * The numerically largest constant representing a TIFF data type.", "refactored_code": "    public static final int TIFF_BYTE        =  1;\n    /**\n     * The numerically smallest constant representing a TIFF data type.\n     */\n    public static final int MIN_DATATYPE = TIFF_BYTE;\n\n    /**\n     * The numerically largest constant representing a TIFF data type."}
{"magic_number_smell": "        this.streamPos = this.flushedPos = channel.position();\n\n        // Allocate the write buffer.\n\tbyteBuffer = ByteBuffer.allocateDirect(1048576);\n\n        // Create the read stream (initially zero-sized).\n        readStream = new FileChannelImageInputStream(channel);", "refactored_code": "    private static final int DEFAULT_WRITE_BUFFER_SIZE = 1048576;\n        this.streamPos = this.flushedPos = channel.position();\n\n        // Allocate the write buffer.\n\tbyteBuffer = ByteBuffer.allocateDirect(DEFAULT_WRITE_BUFFER_SIZE);\n\n        // Create the read stream (initially zero-sized).\n        readStream = new FileChannelImageInputStream(channel);"}
{"magic_number_smell": "    /**\n     * TransformType values\n     */\n    public static final TransformType TRANSLATE = new TransformType(0, TRANSLATE_STRING);\n    public static final TransformType ROTATE = new TransformType(TRANSFORM_ROTATE, ROTATE_STRING);\n    public static final TransformType SCALE = new TransformType(TRANSFORM_SCALE, SCALE_STRING);\n    public static final TransformType SHEAR = new TransformType(TRANSFORM_SHEAR, SHEAR_STRING);", "refactored_code": "    public static final int TRANSFORM_TRANSLATE = 0;\n    /**\n     * TransformType values\n     */\n    public static final TransformType TRANSLATE = new TransformType(TRANSFORM_TRANSLATE, TRANSLATE_STRING);\n    public static final TransformType ROTATE = new TransformType(TRANSFORM_ROTATE, ROTATE_STRING);\n    public static final TransformType SCALE = new TransformType(TRANSFORM_SCALE, SCALE_STRING);\n    public static final TransformType SHEAR = new TransformType(TRANSFORM_SHEAR, SHEAR_STRING);"}
{"magic_number_smell": "\t * capacity.\n\t */\n\tpublic WeakIdentityHashMap() {\n\t\tthis(11, DEFAULT_LOAD_FACTOR);\n\t}\n\n\t/**", "refactored_code": "\tprivate static final int DEFAULT_CAPACITY = 11;\n\t * capacity.\n\t */\n\tpublic WeakIdentityHashMap() {\n\t\tthis(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR);\n\t}\n\n\t/**"}
{"magic_number_smell": "\t\tcallCallbacks(callbackNames[type]);\n\t\t// Explicitly initialize all dialogs after startup, as otherwise\n\t\t// funny things will happen on CS3 and above. See comment in initializeAll\n\t\tif (type == 0)\n\t\t\tDialog.initializeAll();\n\t}\n", "refactored_code": "\tpublic static final int EVENT_APP_STARTUP = 0;\n\t\tcallCallbacks(callbackNames[type]);\n\t\t// Explicitly initialize all dialogs after startup, as otherwise\n\t\t// funny things will happen on CS3 and above. See comment in initializeAll\n\t\tif (type == EVENT_APP_STARTUP)\n\t\t\tDialog.initializeAll();\n\t}\n"}
{"magic_number_smell": "\t}\n\n\tpublic double getParameter(Point point) {\n\t\treturn getParameter(point, 10e-5);\n\t}\n\n\tpublic double getParameter(double length) {", "refactored_code": "\tprotected static final double EPSILON = 10e-5;\n\t}\n\n\tpublic double getParameter(Point point) {\n\t\treturn getParameter(point, EPSILON);\n\t}\n\n\tpublic double getParameter(double length) {"}
{"magic_number_smell": "\t}\n\n\tpublic static Item unite(Object[] items) {\n\t\treturn unite(items, 10f, DEFAULT_REMOVE_POINTS,\n\t\t\t\tDEFAULT_EXTRACT_UNPAINTED);\n\t}\n", "refactored_code": "\tprivate static final float DEFAULT_PRECISION = 10f;\n\t}\n\n\tpublic static Item unite(Object[] items) {\n\t\treturn unite(items, DEFAULT_PRECISION, DEFAULT_REMOVE_POINTS,\n\t\t\t\tDEFAULT_EXTRACT_UNPAINTED);\n\t}\n"}
{"magic_number_smell": "\t * @return {@true if it is parallel}\n\t */\n\tpublic boolean isColinear(Point point) {\n\t\treturn this.cross(point) < 10e-6;\n\t}\n\n\t/**", "refactored_code": "\tprivate static final double TOLERANCE = 10e-6;\n\t * @return {@true if it is parallel}\n\t */\n\tpublic boolean isColinear(Point point) {\n\t\treturn this.cross(point) < TOLERANCE;\n\t}\n\n\t/**"}
{"magic_number_smell": "\t\t\t\tint count = end - start;\n\t\t\t\tif (count > 0) {\n\t\t\t\t\tfetchCount -= count;\n\t\t\t\t\tint length =  count * 7;\n\t\t\t\t\tif (values == null || values.length < length)\n\t\t\t\t\t\tvalues = new float[length];\n\t\t\t\t\tnativeGet(path.handle, start, count, values);", "refactored_code": "\tprotected static final int VALUES_PER_SEGMENT = 7;\n\t\t\t\tint count = end - start;\n\t\t\t\tif (count > 0) {\n\t\t\t\t\tfetchCount -= count;\n\t\t\t\t\tint length =  count * VALUES_PER_SEGMENT;\n\t\t\t\t\tif (values == null || values.length < length)\n\t\t\t\t\t\tvalues = new float[length];\n\t\t\t\t\tnativeGet(path.handle, start, count, values);"}
{"magic_number_smell": "\n\n\n/** ROW or 0 -- should the components be aligned in a row or column */\nprotected int orientation;\n\n/** LEFT, TOP, CENTER, FULL, BOTTOM, RIGHT -- how should components of different", "refactored_code": "public static final int COLUMN = 0;\n\n\n\n/** ROW or COLUMN -- should the components be aligned in a row or column */\nprotected int orientation;\n\n/** LEFT, TOP, CENTER, FULL, BOTTOM, RIGHT -- how should components of different"}
{"magic_number_smell": "protected int crSize[][] = {null, null};\n\n/** Offsets of crs in pixels.  The left boarder of column n is at\n crOffset[0][n] and the right boarder is at cr[0][n + 1] for all\n columns including the last one.  crOffset[0].length = crSize[0].length + 1 */\nprotected int crOffset[][] = {null, null};\n", "refactored_code": "protected static final int C = 0;\nprotected int crSize[][] = {null, null};\n\n/** Offsets of crs in pixels.  The left boarder of column n is at\n crOffset[C][n] and the right boarder is at cr[C][n + 1] for all\n columns including the last one.  crOffset[C].length = crSize[C].length + 1 */\nprotected int crOffset[][] = {null, null};\n"}
{"magic_number_smell": "\t\t}\n\t\telse {\n\t\t\tpreSortCB = PRE_SORT_CB_STD;\n\t\t\tlastCB = 6;\n\t\t}\n\n\t\tint PCWs_done = 0;", "refactored_code": "\tprivate static final int NUM_CB = 6;\n\t\t}\n\t\telse {\n\t\t\tpreSortCB = PRE_SORT_CB_STD;\n\t\t\tlastCB = NUM_CB;\n\t\t}\n\n\t\tint PCWs_done = 0;"}
{"magic_number_smell": "\t\tfor(int g = 0; g<windowGroupCount; g++) {\n\t\t\tfor(sfb = 0; sfb<maxSFB; sfb++) {\n\t\t\t\tif(sfbCB[g][sfb]==HCB.NOISE_HCB&&!noiseUsed) noiseUsed = true;\n\t\t\t\telse if(Math.abs(sfbCB[g][sfb])==7) {\n\t\t\t\t\tval = decodeHuffmanEscape(in);\n\t\t\t\t\tif(sfbCB[g][sfb]==-7) scaleFactors[g][sfb] -= val;\n\t\t\t\t\telse scaleFactors[g][sfb] += val;", "refactored_code": "\tprivate static final int ESCAPE_FLAG = 7;\n\t\tfor(int g = 0; g<windowGroupCount; g++) {\n\t\t\tfor(sfb = 0; sfb<maxSFB; sfb++) {\n\t\t\t\tif(sfbCB[g][sfb]==HCB.NOISE_HCB&&!noiseUsed) noiseUsed = true;\n\t\t\t\telse if(Math.abs(sfbCB[g][sfb])==ESCAPE_FLAG) {\n\t\t\t\t\tval = decodeHuffmanEscape(in);\n\t\t\t\t\tif(sfbCB[g][sfb]==-ESCAPE_FLAG) scaleFactors[g][sfb] -= val;\n\t\t\t\t\telse scaleFactors[g][sfb] += val;"}
{"magic_number_smell": "\n\t\t//sign & escape\n\t\tif(cb<11) {\n\t\t\tif(UNSIGNED[cb-1]) signValues(in, data, off, cb<5 ? 4, PAIR_LEN = 2 : PAIR_LEN);\n\t\t}\n\t\telse if(cb==11||cb>15) {\n\t\t\tsignValues(in, data, off, cb<5 ? 4, PAIR_LEN = 2 : PAIR_LEN); //virtual codebooks are always unsigned", "refactored_code": "\tprivate static final int QUAD_LEN = 4, PAIR_LEN = 2;\n\n\t\t//sign & escape\n\t\tif(cb<11) {\n\t\t\tif(UNSIGNED[cb-1]) signValues(in, data, off, cb<5 ? QUAD_LEN : PAIR_LEN);\n\t\t}\n\t\telse if(cb==11||cb>15) {\n\t\t\tsignValues(in, data, off, cb<5 ? QUAD_LEN : PAIR_LEN); //virtual codebooks are always unsigned"}
{"magic_number_smell": "\t\t\tperfomFilter4C(buf[3], out, 24, F34_2_4, 4);\n\t\t\tperfomFilter4C(buf[4], out, 28, F34_2_4, 4);\n\t\t\tfor(i = 0; i<59; i++) {\n\t\t\t\tfor(j = 0; j<32; j++) {\n\t\t\t\t\tout[i+32][j][0] = in[j][i+5][0];\n\t\t\t\t\tout[i+32][j][1] = in[j][i+5][1];\n\t\t\t\t}", "refactored_code": "\tprivate static final int FB_LEN = 32;\n\t\t\tperfomFilter4C(buf[3], out, 24, F34_2_4, 4);\n\t\t\tperfomFilter4C(buf[4], out, 28, F34_2_4, 4);\n\t\t\tfor(i = 0; i<59; i++) {\n\t\t\t\tfor(j = 0; j<FB_LEN; j++) {\n\t\t\t\t\tout[i+32][j][0] = in[j][i+5][0];\n\t\t\t\t\tout[i+32][j][1] = in[j][i+5][1];\n\t\t\t\t}"}
{"magic_number_smell": "\n\t\tfor(int iid = 0; iid<46; iid++) {\n\t\t\tc = IID_DEQUANT[iid];\n\t\t\tc1 = Math.sqrt(2)/Math.sqrt(1.0f+c*c);\n\t\t\tc2 = c*c1;\n\t\t\tfor(icc = 0; icc<8; icc++) {\n\t\t\t\t//filter A", "refactored_code": "\tprivate static final double SQRT2 = Math.sqrt(2);\n\n\t\tfor(int iid = 0; iid<46; iid++) {\n\t\t\tc = IID_DEQUANT[iid];\n\t\t\tc1 = SQRT2/Math.sqrt(1.0f+c*c);\n\t\t\tc2 = c*c1;\n\t\t\tfor(icc = 0; icc<8; icc++) {\n\t\t\t\t//filter A"}
{"magic_number_smell": "\t\t}\n\n\t\t//stage 3\n\t\tfor(i = 0; i<32; i += 8) {\n\t\t\tz = i+4;\n\t\t\tre1 = in[i][0];\n\t\t\tim1 = in[i][1];", "refactored_code": "\tprivate static final int FFT_LENGTH = 32;\n\t\t}\n\n\t\t//stage 3\n\t\tfor(i = 0; i<FFT_LENGTH; i += 8) {\n\t\t\tz = i+4;\n\t\t\tre1 = in[i][0];\n\t\t\tim1 = in[i][1];"}
{"magic_number_smell": "\t\t\t\t}\n\n\t\t\t\t//calculate the maximum gain\n\t\t\t\tgMax = Math.min(MAXIMUM_GAIN, ((1e-12f+acc1)/(1e-12f+acc2))*LIM_GAIN[limiterGains]);\n\n\t\t\t\tfor(k = ml1; k<ml2; k++) {\n\t\t\t\t\t//check if m is on a noise band border", "refactored_code": "\tprivate static final float EPS = 1e-12f;\n\t\t\t\t}\n\n\t\t\t\t//calculate the maximum gain\n\t\t\t\tgMax = Math.min(MAXIMUM_GAIN, ((EPS+acc1)/(EPS+acc2))*LIM_GAIN[limiterGains]);\n\n\t\t\t\tfor(k = ml1; k<ml2; k++) {\n\t\t\t\t\t//check if m is on a noise band border"}
{"magic_number_smell": "\t\t\toff = (cd.bwArray[i]<cd.bwArrayPrev[i]) ? 0 : 2;\n\t\t\tcd.bwArray[i] = (cd.bwArray[i]*CHIRP_COEFS[off])+(cd.bwArrayPrev[i]*CHIRP_COEFS[off+1]);\n\n\t\t\tif(cd.bwArray[i]<0.015625f) cd.bwArray[i] = 0.0f;\n\t\t\tif(cd.bwArray[i]>=BW_MAX) cd.bwArray[i] = BW_MAX;\n\n\t\t\tcd.bwArrayPrev[i] = cd.bwArray[i];", "refactored_code": "\tprivate static final float BW_MIN = 0.015625f;\n\t\t\toff = (cd.bwArray[i]<cd.bwArrayPrev[i]) ? 0 : 2;\n\t\t\tcd.bwArray[i] = (cd.bwArray[i]*CHIRP_COEFS[off])+(cd.bwArrayPrev[i]*CHIRP_COEFS[off+1]);\n\n\t\t\tif(cd.bwArray[i]<BW_MIN) cd.bwArray[i] = 0.0f;\n\t\t\tif(cd.bwArray[i]>=BW_MAX) cd.bwArray[i] = BW_MAX;\n\n\t\t\tcd.bwArrayPrev[i] = cd.bwArray[i];"}
{"magic_number_smell": "\t\t\t\tx[0][k] = (in[l][k][0]*QMF32_PRE_TWIDDLE[k][0])-(in[l][k][1]*QMF32_PRE_TWIDDLE[k][1]);\n\t\t\t\tx[1][k] = (in[l][k][1]*QMF32_PRE_TWIDDLE[k][0])+(in[l][k][0]*QMF32_PRE_TWIDDLE[k][1]);\n\n\t\t\t\tx[0][k] *= 1.0f/64.0f;\n\t\t\t\tx[1][k] *= 1.0f/64.0f;\n\t\t\t}\n", "refactored_code": "\tprivate static final float SCALE = 1.0f/64.0f;\n\t\t\t\tx[0][k] = (in[l][k][0]*QMF32_PRE_TWIDDLE[k][0])-(in[l][k][1]*QMF32_PRE_TWIDDLE[k][1]);\n\t\t\t\tx[1][k] = (in[l][k][1]*QMF32_PRE_TWIDDLE[k][0])+(in[l][k][0]*QMF32_PRE_TWIDDLE[k][1]);\n\n\t\t\t\tx[0][k] *= SCALE;\n\t\t\t\tx[1][k] *= SCALE;\n\t\t\t}\n"}
{"magic_number_smell": "\t\tint usb = kx;\n\t\tpatchCount = 0;\n\n\t\tint goalSb = Math.round(2.048E6f/(float) sampleRate); //TODO: replace with table\n\t\tint k;\n\t\tif(goalSb<kx+m) {\n\t\t\tk = 0;", "refactored_code": "\tprivate static final float GOAL_SB_FACTOR = 2.048E6f;\n\t\tint usb = kx;\n\t\tpatchCount = 0;\n\n\t\tint goalSb = Math.round(GOAL_SB_FACTOR/(float) sampleRate); //TODO: replace with table\n\t\tint k;\n\t\tif(goalSb<kx+m) {\n\t\t\tk = 0;"}
{"magic_number_smell": "\t\t\t\t//TODO: is epsilon==1.0f ???\n\t\t\t\tif(p.sMapped[e][m]) {\n\t\t\t\t\tgain[e][m] = (float) Math.sqrt(p.eMapped[e][m]*p.qMapped[e][m]\n\t\t\t\t\t\t\t/((1.0f+eCurr[e][m])*(1.0f+p.qMapped[e][m])));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgain[e][m] = (float) Math.sqrt(p.eMapped[e][m]", "refactored_code": "\tprivate static final float EPSILON = 1.0f;\n\t\t\t\t//TODO: is epsilon==1.0f ???\n\t\t\t\tif(p.sMapped[e][m]) {\n\t\t\t\t\tgain[e][m] = (float) Math.sqrt(p.eMapped[e][m]*p.qMapped[e][m]\n\t\t\t\t\t\t\t/((EPSILON+eCurr[e][m])*(1.0f+p.qMapped[e][m])));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgain[e][m] = (float) Math.sqrt(p.eMapped[e][m]"}
{"magic_number_smell": "\t\t\tgetCovarianceMatrix(Xlow[k], phi, 2);\n\n\t\t\t//d(k)\n\t\t\td = phi[2][1][0]*phi[1][0][0]-(phi[1][1][0]*phi[1][1][0]+phi[1][1][1]*phi[1][1][1])/1.000001f;\n\n\t\t\t//alpha1\n\t\t\tif(d==0) {", "refactored_code": "\tprivate static final float RELAX_COEF = 1.000001f;\n\t\t\tgetCovarianceMatrix(Xlow[k], phi, 2);\n\n\t\t\t//d(k)\n\t\t\td = phi[2][1][0]*phi[1][0][0]-(phi[1][1][0]*phi[1][1][0]+phi[1][1][1]*phi[1][1][1])/RELAX_COEF;\n\n\t\t\t//alpha1\n\t\t\tif(d==0) {"}
{"magic_number_smell": "\t\t\tfinal int c = cache&maskBits(bitsCached);\n\t\t\tfinal int left = n-bitsCached;\n\t\t\tcache = readCache(false);\n\t\t\tbitsCached = 32-left;\n\t\t\tresult = ((cache>>bitsCached)&maskBits(left))|(c<<left);\n\t\t}\n\t\treturn result;", "refactored_code": "\tprivate static final int WORD_BITS = 32;\n\t\t\tfinal int c = cache&maskBits(bitsCached);\n\t\t\tfinal int left = n-bitsCached;\n\t\t\tcache = readCache(false);\n\t\t\tbitsCached = WORD_BITS-left;\n\t\t\tresult = ((cache>>bitsCached)&maskBits(left))|(c<<left);\n\t\t}\n\t\treturn result;"}
{"magic_number_smell": "\t\tprivate int[] dynRngCtl;\n\n\t\tpublic DynamicRangeInfo() {\n\t\t\texcludeMask = new boolean[7];\n\t\t\tadditionalExcludedChannels = new boolean[7];\n\t\t}\n\t}", "refactored_code": "\t\tprivate static final int MAX_NBR_BANDS = 7;\n\t\tprivate int[] dynRngCtl;\n\n\t\tpublic DynamicRangeInfo() {\n\t\t\texcludeMask = new boolean[MAX_NBR_BANDS];\n\t\t\tadditionalExcludedChannels = new boolean[MAX_NBR_BANDS];\n\t\t}\n\t}"}
{"magic_number_smell": "\t\t\t\t\tcase INTENSITY_HCB:\n\t\t\t\t\tcase INTENSITY_HCB2:\n\t\t\t\t\t\tfor(; sfb<end; sfb++, idx++) {\n\t\t\t\t\t\t\toffset[2] += Huffman.decodeScaleFactor(in)-60;\n\t\t\t\t\t\t\ttmp = Math.min(Math.max(offset[2], -155), 100);\n\t\t\t\t\t\t\tscaleFactors[idx] = SCALEFACTOR_TABLE[-tmp+SF_OFFSET];\n\t\t\t\t\t\t}", "refactored_code": "\tprivate static final int SF_DELTA = 60;\n\t\t\t\t\tcase INTENSITY_HCB:\n\t\t\t\t\tcase INTENSITY_HCB2:\n\t\t\t\t\t\tfor(; sfb<end; sfb++, idx++) {\n\t\t\t\t\t\t\toffset[2] += Huffman.decodeScaleFactor(in)-SF_DELTA;\n\t\t\t\t\t\t\ttmp = Math.min(Math.max(offset[2], -155), 100);\n\t\t\t\t\t\t\tscaleFactors[idx] = SCALEFACTOR_TABLE[-tmp+SF_OFFSET];\n\t\t\t\t\t\t}"}
{"magic_number_smell": "\n\tpublic PCE() {\n\t\tsuper();\n\t\tfrontElements = new TaggedElement[16];\n\t\tsideElements = new TaggedElement[MAX_SIDE_CHANNEL_ELEMENTS];\n\t\tbackElements = new TaggedElement[MAX_BACK_CHANNEL_ELEMENTS];\n\t\tlfeElementTags = new int[MAX_LFE_CHANNEL_ELEMENTS];", "refactored_code": "\tprivate static final int MAX_FRONT_CHANNEL_ELEMENTS = 16;\n\n\tpublic PCE() {\n\t\tsuper();\n\t\tfrontElements = new TaggedElement[MAX_FRONT_CHANNEL_ELEMENTS];\n\t\tsideElements = new TaggedElement[MAX_SIDE_CHANNEL_ELEMENTS];\n\t\tbackElements = new TaggedElement[MAX_BACK_CHANNEL_ELEMENTS];\n\t\tlfeElementTags = new int[MAX_LFE_CHANNEL_ELEMENTS];"}
{"magic_number_smell": "public class ICPrediction {\n\n\tprivate static final float 1.0f/-1024.0f = 1.0f/-1024.0f;\n\tprivate static final float INV_SF_SCALE = 1.0f/1.0f/-1024.0f;\n\tprivate static final int MAX_PREDICTORS = 672;\n\tprivate static final float A = 0.953125f; //61.0 / 64\n\tprivate static final float ALPHA = 0.90625f;  //29.0 / 32", "refactored_code": "\tprivate static final float SF_SCALE = 1.0f/-1024.0f;\npublic class ICPrediction {\n\n\tprivate static final float SF_SCALE = 1.0f/-1024.0f;\n\tprivate static final float INV_SF_SCALE = 1.0f/SF_SCALE;\n\tprivate static final int MAX_PREDICTORS = 672;\n\tprivate static final float A = 0.953125f; //61.0 / 64\n\tprivate static final float ALPHA = 0.90625f;  //29.0 / 32"}
{"magic_number_smell": "\t\tlength = new int[8][4];\n\t\tdirection = new boolean[8][4];\n\t\torder = new int[8][4];\n\t\tcoef = new float[8][4][20];\n\t}\n\n\tpublic void decode(BitStream in, ICSInfo info) throws AACException {", "refactored_code": "\tprivate static final int TNS_MAX_ORDER = 20;\n\t\tlength = new int[8][4];\n\t\tdirection = new boolean[8][4];\n\t\torder = new int[8][4];\n\t\tcoef = new float[8][4][TNS_MAX_ORDER];\n\t}\n\n\tpublic void decode(BitStream in, ICSInfo info) throws AACException {"}
{"magic_number_smell": "\tprivate PCE[] pces;\n\n\tpublic static boolean isPresent(BitStream in) throws AACException {\n\t\treturn in.peekBits(32)==0x41444946;\n\t}\n\n\tprivate ADIFHeader() {", "refactored_code": "\tprivate static final long ADIF_ID = 0x41444946; //'ADIF'\n\tprivate PCE[] pces;\n\n\tpublic static boolean isPresent(BitStream in) throws AACException {\n\t\treturn in.peekBits(32)==ADIF_ID;\n\t}\n\n\tprivate ADIFHeader() {"}
{"magic_number_smell": "\tprivate boolean findNextFrame() throws IOException {\n\t\t//find next ADTS ID\n\t\tboolean found = false;\n\t\tint left = 6144;\n\t\tint i;\n\t\twhile(!found&&left>0) {\n\t\t\ti = in.read();", "refactored_code": "\tprivate static final int MAXIMUM_FRAME_SIZE = 6144;\n\tprivate boolean findNextFrame() throws IOException {\n\t\t//find next ADTS ID\n\t\tboolean found = false;\n\t\tint left = MAXIMUM_FRAME_SIZE;\n\t\tint i;\n\t\twhile(!found&&left>0) {\n\t\t\ti = in.read();"}
{"magic_number_smell": "\t\tflags = in.read();\n\t\tlen = readSynch(in);\n\n\t\tif(tag==4801587&&majorVersion<=SUPPORTED_VERSION) {\n\t\t\tif((flags&0x40)==0x40) {\n\t\t\t\t//extended header; TODO: parse\n\t\t\t\tfinal int extSize = readSynch(in);", "refactored_code": "\tprivate static final int ID3_TAG = 4801587; //'ID3'\n\t\tflags = in.read();\n\t\tlen = readSynch(in);\n\n\t\tif(tag==ID3_TAG&&majorVersion<=SUPPORTED_VERSION) {\n\t\t\tif((flags&0x40)==0x40) {\n\t\t\t\t//extended header; TODO: parse\n\t\t\t\tfinal int extSize = readSynch(in);"}
{"magic_number_smell": "\tprivate static final long 2082850791998l = 2082850791998l;\n\n\tstatic Date getDate(long time) {\n\t\treturn new Date(time*1000-2082850791998l);\n\t}\n}\n", "refactored_code": "\tprivate static final long DATE_OFFSET = 2082850791998l;\n\tprivate static final long DATE_OFFSET = 2082850791998l;\n\n\tstatic Date getDate(long time) {\n\t\treturn new Date(time*1000-DATE_OFFSET);\n\t}\n}\n"}
{"magic_number_smell": "\n\tpublic static long detectUndetermined(long l) {\n\t\tfinal long x;\n\t\tif(l==4294967295l) x = -1;\n\t\telse x = l;\n\t\treturn x;\n\t}", "refactored_code": "\tprivate static final long UNDETERMINED = 4294967295l;\n\n\tpublic static long detectUndetermined(long l) {\n\t\tfinal long x;\n\t\tif(l==UNDETERMINED) x = -1;\n\t\telse x = l;\n\t\treturn x;\n\t}"}
{"magic_number_smell": "\t\tstatic Extension forType(int type) {\n\t\t\tfinal Extension ext;\n\t\t\tswitch(type) {\n\t\t\t\tcase Extension.1717855596:\n\t\t\t\t\text = new FDExtension();\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:", "refactored_code": "\t\tprivate static final int TYPE_FDEL = 1717855596; //fdel\n\t\tstatic Extension forType(int type) {\n\t\t\tfinal Extension ext;\n\t\t\tswitch(type) {\n\t\t\t\tcase Extension.TYPE_FDEL:\n\t\t\t\t\text = new FDExtension();\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:"}
{"magic_number_smell": "\tprivate static Descriptor forTag(int tag) {\n\t\tDescriptor desc;\n\t\tswitch(tag) {\n\t\t\tcase 1:\n\t\t\t\tdesc = new ObjectDescriptor();\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INITIAL_OBJECT_DESCRIPTOR:", "refactored_code": "\tpublic static final int TYPE_OBJECT_DESCRIPTOR = 1;\n\tprivate static Descriptor forTag(int tag) {\n\t\tDescriptor desc;\n\t\tswitch(tag) {\n\t\t\tcase TYPE_OBJECT_DESCRIPTOR:\n\t\t\t\tdesc = new ObjectDescriptor();\n\t\t\t\tbreak;\n\t\t\tcase TYPE_INITIAL_OBJECT_DESCRIPTOR:"}
{"magic_number_smell": "\n\tCircularBuffer(Trigger trigger) {\n\t\tthis.trigger = trigger;\n\t\tdata = new byte[327670];\n\t\treadPos = 0;\n\t\twritePos = 0;\n\t\topen = true;", "refactored_code": "\tprivate static final int BUFFER_SIZE = 327670;\n\n\tCircularBuffer(Trigger trigger) {\n\t\tthis.trigger = trigger;\n\t\tdata = new byte[BUFFER_SIZE];\n\t\treadPos = 0;\n\t\twritePos = 0;\n\t\topen = true;"}
{"magic_number_smell": "\t\tbytesWritten = 0;\n\n\t\tout = new RandomAccessFile(output, \"rw\");\n\t\tout.write(new byte[44]); //space for the header\n\t}\n\n\tpublic void write(byte[] data) throws IOException {", "refactored_code": "\tprivate static final int HEADER_LENGTH = 44;\n\t\tbytesWritten = 0;\n\n\t\tout = new RandomAccessFile(output, \"rw\");\n\t\tout.write(new byte[HEADER_LENGTH]); //space for the header\n\t}\n\n\tpublic void write(byte[] data) throws IOException {"}
{"magic_number_smell": "    }\n\n    private int computeBitrate(float length, long size) {\n        return (int) ((size / KILOBYTES_TO_BYTES_MULTIPLIER) * 8 / length);\n    }\n\n    /**", "refactored_code": "    private static final int NO_OF_BITS_IN_BYTE = 8;\n    }\n\n    private int computeBitrate(float length, long size) {\n        return (int) ((size / KILOBYTES_TO_BYTES_MULTIPLIER) * NO_OF_BITS_IN_BYTE / length);\n    }\n\n    /**"}
{"magic_number_smell": "\n        //Ok maybe there is an ID3v24tag first\n        if (isId3v24Tag()) {\n            startOfFlacInFile = (int) (raf.getFilePointer() - 4);\n            return;\n        }\n", "refactored_code": "    public static final int FLAC_STREAM_IDENTIFIER_LENGTH = 4;\n\n        //Ok maybe there is an ID3v24tag first\n        if (isId3v24Tag()) {\n            startOfFlacInFile = (int) (raf.getFilePointer() - FLAC_STREAM_IDENTIFIER_LENGTH);\n            return;\n        }\n"}
{"magic_number_smell": "     * @throws IOException\n     */\n    public static MetadataBlockHeader readHeader(RandomAccessFile raf) throws IOException {\n        ByteBuffer rawdata = ByteBuffer.allocate(4);\n        int bytesRead = raf.getChannel().read(rawdata);\n        if (bytesRead < 4) {\n            throw new IOException(\"Unable to read required number of databytes read:\" + bytesRead + \":required:\" + 4);", "refactored_code": "    public static final int HEADER_LENGTH = 4;\n     * @throws IOException\n     */\n    public static MetadataBlockHeader readHeader(RandomAccessFile raf) throws IOException {\n        ByteBuffer rawdata = ByteBuffer.allocate(HEADER_LENGTH);\n        int bytesRead = raf.getChannel().read(rawdata);\n        if (bytesRead < HEADER_LENGTH) {\n            throw new IOException(\"Unable to read required number of databytes read:\" + bytesRead + \":required:\" + HEADER_LENGTH);"}
{"magic_number_smell": "            throw new CannotReadException(ErrorMessage.GENERAL_READ_FAILED_FILE_TOO_SMALL.getMsg(f.getAbsolutePath()));\n        }\n\n        if (f.length() <= 150) {\n            throw new CannotReadException(ErrorMessage.GENERAL_READ_FAILED_FILE_TOO_SMALL.getMsg(f.getAbsolutePath()));\n        }\n", "refactored_code": "    private static final int MINIMUM_SIZE_FOR_VALID_AUDIO_FILE = 150;\n            throw new CannotReadException(ErrorMessage.GENERAL_READ_FAILED_FILE_TOO_SMALL.getMsg(f.getAbsolutePath()));\n        }\n\n        if (f.length() <= MINIMUM_SIZE_FOR_VALID_AUDIO_FILE) {\n            throw new CannotReadException(ErrorMessage.GENERAL_READ_FAILED_FILE_TOO_SMALL.getMsg(f.getAbsolutePath()));\n        }\n"}
{"magic_number_smell": "            throw new CannotWriteException(ErrorMessage.GENERAL_DELETE_FAILED.getMsg(af.getFile().getPath()));\n        }\n\n        if (af.getFile().length() <= 150) {\n            throw new CannotWriteException(ErrorMessage.GENERAL_DELETE_FAILED.getMsg(af.getFile().getPath()));\n        }\n", "refactored_code": "    private static final int MINIMUM_FILESIZE = 150;\n            throw new CannotWriteException(ErrorMessage.GENERAL_DELETE_FAILED.getMsg(af.getFile().getPath()));\n        }\n\n        if (af.getFile().length() <= MINIMUM_FILESIZE) {\n            throw new CannotWriteException(ErrorMessage.GENERAL_DELETE_FAILED.getMsg(af.getFile().getPath()));\n        }\n"}
{"magic_number_smell": "\n        if (mp3XingFrame != null && mp3XingFrame.isVbr()) {\n            if (mp3XingFrame.isAudioSizeEnabled() && mp3XingFrame.getAudioSize() > 0) {\n                bitrate = (long) ((mp3XingFrame.getAudioSize() * CONVERTS_BYTE_TO_BITS) / (timePerFrame * getNumberOfFrames() * 1000));\n            } else {\n                bitrate = (long) (((fileSize - startByte) * CONVERTS_BYTE_TO_BITS) / (timePerFrame * getNumberOfFrames() * 1000));\n            }", "refactored_code": "    private static final int CONVERT_TO_KILOBITS = 1000;\n\n        if (mp3XingFrame != null && mp3XingFrame.isVbr()) {\n            if (mp3XingFrame.isAudioSizeEnabled() && mp3XingFrame.getAudioSize() > 0) {\n                bitrate = (long) ((mp3XingFrame.getAudioSize() * CONVERTS_BYTE_TO_BITS) / (timePerFrame * getNumberOfFrames() * CONVERT_TO_KILOBITS));\n            } else {\n                bitrate = (long) (((fileSize - startByte) * CONVERTS_BYTE_TO_BITS) / (timePerFrame * getNumberOfFrames() * CONVERT_TO_KILOBITS));\n            }"}
{"magic_number_smell": "            throw new IOException(ErrorMessage.GENERAL_WRITE_FAILED.getMsg(file.getName()));\n        }\n\n        if (file.length() <= 150) {\n//            //logger.severe(ErrorMessage.GENERAL_WRITE_FAILED_BECAUSE_FILE_IS_TOO_SMALL.getMsg(file.getName()));\n            throw new IOException(ErrorMessage.GENERAL_WRITE_FAILED_BECAUSE_FILE_IS_TOO_SMALL.getMsg(file.getName()));\n        }", "refactored_code": "    private static final int MINIMUM_FILESIZE = 150;\n            throw new IOException(ErrorMessage.GENERAL_WRITE_FAILED.getMsg(file.getName()));\n        }\n\n        if (file.length() <= MINIMUM_FILESIZE) {\n//            //logger.severe(ErrorMessage.GENERAL_WRITE_FAILED_BECAUSE_FILE_IS_TOO_SMALL.getMsg(file.getName()));\n            throw new IOException(ErrorMessage.GENERAL_WRITE_FAILED_BECAUSE_FILE_IS_TOO_SMALL.getMsg(file.getName()));\n        }"}
{"magic_number_smell": "     * @return a string represntation\n     */\n    public String toString() {\n        return \" mpeg frameheader:\" + \" frame length:\" + getFrameLength() + \" version:\" + versionAsString + \" layer:\" + layerAsString + \" channelMode:\" + channelModeAsString + \" noOfSamples:\" + getNoOfSamples() + \" samplingRate:\" + samplingRate + \" isPadding:\" + isPadding + \" isProtected:\" + isProtected + \" isPrivate:\" + isPrivate + \" isCopyrighted:\" + isCopyrighted + \" isOriginal:\" + isCopyrighted + \" isVariableBitRate\" + this.isVariableBitRate() + \" header as binary:\" + AbstractTagDisplayFormatter.displayAsBinary(mpegBytes[0]) + \" \" + AbstractTagDisplayFormatter.displayAsBinary(mpegBytes[BYTE_2]) + \" \" + AbstractTagDisplayFormatter.displayAsBinary(mpegBytes[BYTE_3]) + \" \" + AbstractTagDisplayFormatter.displayAsBinary(mpegBytes[BYTE_4]);\n    }\n}\n", "refactored_code": "    private static final int BYTE_1 = 0;\n     * @return a string represntation\n     */\n    public String toString() {\n        return \" mpeg frameheader:\" + \" frame length:\" + getFrameLength() + \" version:\" + versionAsString + \" layer:\" + layerAsString + \" channelMode:\" + channelModeAsString + \" noOfSamples:\" + getNoOfSamples() + \" samplingRate:\" + samplingRate + \" isPadding:\" + isPadding + \" isProtected:\" + isProtected + \" isPrivate:\" + isPrivate + \" isCopyrighted:\" + isCopyrighted + \" isOriginal:\" + isCopyrighted + \" isVariableBitRate\" + this.isVariableBitRate() + \" header as binary:\" + AbstractTagDisplayFormatter.displayAsBinary(mpegBytes[BYTE_1]) + \" \" + AbstractTagDisplayFormatter.displayAsBinary(mpegBytes[BYTE_2]) + \" \" + AbstractTagDisplayFormatter.displayAsBinary(mpegBytes[BYTE_3]) + \" \" + AbstractTagDisplayFormatter.displayAsBinary(mpegBytes[BYTE_4]);\n    }\n}\n"}
{"magic_number_smell": "    private static final int VBRI_FRAMECOUNT_BUFFER_SIZE = 4;\n    private static final int VBRI_TOC_ENTRY_BUFFER_SIZE = 2;\n\n    public static final int MAX_BUFFER_SIZE_NEEDED_TO_READ_VBRI = MPEGFrameHeader.HEADER_SIZE + 32 + VBRI_HEADER_BUFFER_SIZE;\n\n    private static final int BYTE_1 = 0;\n    private static final int BYTE_2 = 1;", "refactored_code": "    private static final int VBRI_OFFSET = MPEGFrameHeader.HEADER_SIZE + 32;\n    private static final int VBRI_FRAMECOUNT_BUFFER_SIZE = 4;\n    private static final int VBRI_TOC_ENTRY_BUFFER_SIZE = 2;\n\n    public static final int MAX_BUFFER_SIZE_NEEDED_TO_READ_VBRI = VBRI_OFFSET + VBRI_HEADER_BUFFER_SIZE;\n\n    private static final int BYTE_1 = 0;\n    private static final int BYTE_2 = 1;"}
{"magic_number_smell": "        //Get to Start of where Xing Frame Should be ( we dont know if it is one at this point)\n        if (mpegFrameHeader.getVersion() == MPEGFrameHeader.VERSION_1) {\n            if (mpegFrameHeader.getChannelMode() == MPEGFrameHeader.MODE_MONO) {\n                bb.position(startPosition + 21);\n            } else {\n                bb.position(startPosition + MPEG_VERSION_1_MODE_STEREO_OFFSET);\n            }", "refactored_code": "    private static final int MPEG_VERSION_1_MODE_MONO_OFFSET = 21;\n        //Get to Start of where Xing Frame Should be ( we dont know if it is one at this point)\n        if (mpegFrameHeader.getVersion() == MPEGFrameHeader.VERSION_1) {\n            if (mpegFrameHeader.getChannelMode() == MPEGFrameHeader.MODE_MONO) {\n                bb.position(startPosition + MPEG_VERSION_1_MODE_MONO_OFFSET);\n            } else {\n                bb.position(startPosition + MPEG_VERSION_1_MODE_STEREO_OFFSET);\n            }"}
{"magic_number_smell": "\n    public void processData() throws CannotReadException {\n        //Skip version/other flags\n        dataBuffer.position(dataBuffer.position() + 4);\n\n        maxSamplePerFrame = Utils.readUBEInt32(dataBuffer);\n        unknown1 = Utils.readUInt8(dataBuffer);", "refactored_code": "    public static final int OTHER_FLAG_LENGTH = 4;\n\n    public void processData() throws CannotReadException {\n        //Skip version/other flags\n        dataBuffer.position(dataBuffer.position() + OTHER_FLAG_LENGTH);\n\n        maxSamplePerFrame = Utils.readUBEInt32(dataBuffer);\n        unknown1 = Utils.readUInt8(dataBuffer);"}
{"magic_number_smell": "        dataBuffer = ByteBuffer.wrap(b);\n\n        //Calculate box size\n        this.length = Utils.getIntBE(b, 0, OFFSET_LENGTH - 1);\n        //Calculate box id\n        this.id = Utils.getString(b, IDENTIFIER_POS, IDENTIFIER_LENGTH, \"ISO-8859-1\");\n//", "refactored_code": "    public static final int OFFSET_POS = 0;\n        dataBuffer = ByteBuffer.wrap(b);\n\n        //Calculate box size\n        this.length = Utils.getIntBE(b, OFFSET_POS, OFFSET_LENGTH - 1);\n        //Calculate box id\n        this.id = Utils.getString(b, IDENTIFIER_POS, IDENTIFIER_LENGTH, \"ISO-8859-1\");\n//"}
{"magic_number_smell": "\n        //As explained earlier the length of this atom is not fixed so processing is a bit more difficult\n        //Process Flags\n        dataBuffer.position(dataBuffer.position() + 1 + OTHER_FLAG_LENGTH);\n\n        //Process Section 3 if exists\n        if (dataBuffer.get() == SECTION_THREE) {", "refactored_code": "    public static final int VERSION_FLAG_LENGTH = 1;\n\n        //As explained earlier the length of this atom is not fixed so processing is a bit more difficult\n        //Process Flags\n        dataBuffer.position(dataBuffer.position() + VERSION_FLAG_LENGTH + OTHER_FLAG_LENGTH);\n\n        //Process Section 3 if exists\n        if (dataBuffer.get() == SECTION_THREE) {"}
{"magic_number_smell": "    public static final int RESERVED3_LENGTH = 4;\n    public static final int NAME_LENGTH = 2;\n\n    public static final int HANDLER_POS = 1 + OTHER_FLAG_LENGTH + RESERVED_FLAG_LENGTH;\n    public static final int RESERVED1_POS = HANDLER_POS + HANDLER_LENGTH;\n\n    //Size used by iTunes, but other application could use different size because name field is variable", "refactored_code": "    public static final int VERSION_FLAG_LENGTH = 1;\n    public static final int RESERVED3_LENGTH = 4;\n    public static final int NAME_LENGTH = 2;\n\n    public static final int HANDLER_POS = VERSION_FLAG_LENGTH + OTHER_FLAG_LENGTH + RESERVED_FLAG_LENGTH;\n    public static final int RESERVED1_POS = HANDLER_POS + HANDLER_LENGTH;\n\n    //Size used by iTunes, but other application could use different size because name field is variable"}
{"magic_number_smell": "    public Mp4MdhdBox(Mp4BoxHeader header, ByteBuffer dataBuffer) {\n        this.header = header;\n\n        byte version = dataBuffer.get(0);\n\n        long timeLength;\n        if (version == LONG_FORMAT) {", "refactored_code": "    public static final int VERSION_FLAG_POS = 0;\n    public Mp4MdhdBox(Mp4BoxHeader header, ByteBuffer dataBuffer) {\n        this.header = header;\n\n        byte version = dataBuffer.get(VERSION_FLAG_POS);\n\n        long timeLength;\n        if (version == LONG_FORMAT) {"}
{"magic_number_smell": "\n    public void processData() throws CannotReadException {\n        //4-skip the meta flags and check they are the meta flags\n        byte[] b = new byte[4];\n        dataBuffer.get(b);\n        if (b[0] != 0) {\n            throw new CannotReadException(ErrorMessage.MP4_FILE_META_ATOM_CHILD_DATA_NOT_NULL.getMsg());", "refactored_code": "    public static final int FLAGS_LENGTH = 4;\n\n    public void processData() throws CannotReadException {\n        //4-skip the meta flags and check they are the meta flags\n        byte[] b = new byte[FLAGS_LENGTH];\n        dataBuffer.get(b);\n        if (b[0] != 0) {\n            throw new CannotReadException(ErrorMessage.MP4_FILE_META_ATOM_CHILD_DATA_NOT_NULL.getMsg());"}
{"magic_number_smell": "     */\n    public Mp4MvhdBox(Mp4BoxHeader header, ByteBuffer dataBuffer) {\n        this.header = header;\n        byte version = dataBuffer.get(0);\n\n        if (version == LONG_FORMAT) {\n            this.timeScale = Utils.getIntBE(dataBuffer, TIMESCALE_LONG_POS, (TIMESCALE_LONG_POS + TIMESCALE_LENGTH - 1));", "refactored_code": "    public static final int VERSION_FLAG_POS = 0;\n     */\n    public Mp4MvhdBox(Mp4BoxHeader header, ByteBuffer dataBuffer) {\n        this.header = header;\n        byte version = dataBuffer.get(VERSION_FLAG_POS);\n\n        if (version == LONG_FORMAT) {\n            this.timeScale = Utils.getIntBE(dataBuffer, TIMESCALE_LONG_POS, (TIMESCALE_LONG_POS + TIMESCALE_LENGTH - 1));"}
{"magic_number_smell": "    //Creates the ByteBuffer for the ogg tag\n    public ByteBuffer convert(Tag tag) throws UnsupportedEncodingException {\n        ByteBuffer ogg = creator.convert(tag);\n        int tagLength = ogg.capacity() + VorbisHeader.FIELD_PACKET_TYPE_LENGTH + VorbisHeader.FIELD_CAPTURE_PATTERN_LENGTH + OggVorbisCommentTagCreator.1;\n\n        ByteBuffer buf = ByteBuffer.allocate(tagLength);\n", "refactored_code": "    public static final int FIELD_FRAMING_BIT_LENGTH = 1;\n    //Creates the ByteBuffer for the ogg tag\n    public ByteBuffer convert(Tag tag) throws UnsupportedEncodingException {\n        ByteBuffer ogg = creator.convert(tag);\n        int tagLength = ogg.capacity() + VorbisHeader.FIELD_PACKET_TYPE_LENGTH + VorbisHeader.FIELD_CAPTURE_PATTERN_LENGTH + OggVorbisCommentTagCreator.FIELD_FRAMING_BIT_LENGTH;\n\n        ByteBuffer buf = ByteBuffer.allocate(tagLength);\n"}
{"magic_number_smell": "    public static final int MAXIMUM_SEGMENT_SIZE = 255;\n\n    //Maximum size of pageheader (27 + 255 = 282)\n    public static final int MAXIMUM_PAGE_HEADER_SIZE = 27 + MAXIMUM_NO_OF_SEGMENT_SIZE;\n\n    //Maximum size of page data following the page header (255 * 255 = 65025)\n    public static final int MAXIMUM_PAGE_DATA_SIZE = MAXIMUM_NO_OF_SEGMENT_SIZE * MAXIMUM_SEGMENT_SIZE;", "refactored_code": "    public static final int OGG_PAGE_HEADER_FIXED_LENGTH = 27;\n    public static final int MAXIMUM_SEGMENT_SIZE = 255;\n\n    //Maximum size of pageheader (27 + 255 = 282)\n    public static final int MAXIMUM_PAGE_HEADER_SIZE = OGG_PAGE_HEADER_FIXED_LENGTH + MAXIMUM_NO_OF_SEGMENT_SIZE;\n\n    //Maximum size of page data following the page header (255 * 255 = 65025)\n    public static final int MAXIMUM_PAGE_DATA_SIZE = MAXIMUM_NO_OF_SEGMENT_SIZE * MAXIMUM_SEGMENT_SIZE;"}
{"magic_number_smell": "    private static final int 1 = 1;\n    private static final int MAXIMUM_NO_OF_DIGITS = 8;\n\n    int minLength = 1;\n\n\n    /**", "refactored_code": "    private static final int MINIMUM_NO_OF_DIGITS = 1;\n    private static final int MINIMUM_NO_OF_DIGITS = 1;\n    private static final int MAXIMUM_NO_OF_DIGITS = 8;\n\n    int minLength = MINIMUM_NO_OF_DIGITS;\n\n\n    /**"}
{"magic_number_smell": "        //Read into Byte Buffer\n        final FileChannel fc = file.getChannel();\n        fc.position();\n        ByteBuffer byteBuffer = ByteBuffer.allocate(10);\n        fc.read(byteBuffer, 0);\n        byteBuffer.flip();\n        if (seek(byteBuffer)) {", "refactored_code": "    public static final int TAG_HEADER_LENGTH = 10;\n        //Read into Byte Buffer\n        final FileChannel fc = file.getChannel();\n        fc.position();\n        ByteBuffer byteBuffer = ByteBuffer.allocate(TAG_HEADER_LENGTH);\n        fc.read(byteBuffer, 0);\n        byteBuffer.flip();\n        if (seek(byteBuffer)) {"}
{"magic_number_smell": "     * @return decoded int\n     */\n    protected static int bufferToValue(ByteBuffer buffer) {\n        byte byteBuffer[] = new byte[4];\n        buffer.get(byteBuffer, 0, 4);\n        return bufferToValue(byteBuffer);\n    }", "refactored_code": "    public static final int INTEGRAL_SIZE = 4;\n     * @return decoded int\n     */\n    protected static int bufferToValue(ByteBuffer buffer) {\n        byte byteBuffer[] = new byte[INTEGRAL_SIZE];\n        buffer.get(byteBuffer, 0, INTEGRAL_SIZE);\n        return bufferToValue(byteBuffer);\n    }"}
{"magic_number_smell": "    /**\n     * Track is held as a single byte in v1.1\n     */\n    protected byte track = (byte) 0;\n\n    private static final byte RELEASE = 1;\n    private static final byte MAJOR_VERSION = 1;", "refactored_code": "    protected static final int TRACK_UNDEFINED = 0;\n    /**\n     * Track is held as a single byte in v1.1\n     */\n    protected byte track = (byte) TRACK_UNDEFINED;\n\n    private static final byte RELEASE = 1;\n    private static final byte MAJOR_VERSION = 1;"}
{"magic_number_smell": "     */\n    public void remove() {\n        switch (lastIndex) {\n            case 1:\n                id3v1tag.title = \"\";\n\n            case ARTIST:", "refactored_code": "    private static final int TITLE = 1;\n     */\n    public void remove() {\n        switch (lastIndex) {\n            case TITLE:\n                id3v1tag.title = \"\";\n\n            case ARTIST:"}
{"magic_number_smell": "        if (comment == null) {\n            throw new IllegalArgumentException(ErrorMessage.GENERAL_INVALID_NULL_ARGUMENT.getMsg());\n        }\n        this.comment = ID3Tags.truncate(comment, 30);\n    }\n\n    /**", "refactored_code": "    protected static final int FIELD_COMMENT_LENGTH = 30;\n        if (comment == null) {\n            throw new IllegalArgumentException(ErrorMessage.GENERAL_INVALID_NULL_ARGUMENT.getMsg());\n        }\n        this.comment = ID3Tags.truncate(comment, FIELD_COMMENT_LENGTH);\n    }\n\n    /**"}
{"magic_number_smell": "\n    protected static final int 3 = 3;\n    protected static final int FRAME_SIZE_SIZE = 3;\n    protected static final int FRAME_HEADER_SIZE = 3 + FRAME_SIZE_SIZE;\n\n    public ID3v22Frame() {\n", "refactored_code": "    protected static final int FRAME_ID_SIZE = 3;\n\n    protected static final int FRAME_ID_SIZE = 3;\n    protected static final int FRAME_SIZE_SIZE = 3;\n    protected static final int FRAME_HEADER_SIZE = FRAME_ID_SIZE + FRAME_SIZE_SIZE;\n\n    public ID3v22Frame() {\n"}
{"magic_number_smell": "    private void readHeaderFlags(ByteBuffer byteBuffer) throws TagException {\n        //Flags\n        byte flags = byteBuffer.get();\n        unsynchronization = (flags & FileConstants.BIT7) != 0;\n        compression = (flags & MASK_V22_COMPRESSION) != 0;\n\n        if (unsynchronization) {", "refactored_code": "    public static final int MASK_V22_UNSYNCHRONIZATION = FileConstants.BIT7;\n    private void readHeaderFlags(ByteBuffer byteBuffer) throws TagException {\n        //Flags\n        byte flags = byteBuffer.get();\n        unsynchronization = (flags & MASK_V22_UNSYNCHRONIZATION) != 0;\n        compression = (flags & MASK_V22_COMPRESSION) != 0;\n\n        if (unsynchronization) {"}
{"magic_number_smell": "    protected static final int FRAME_ENCRYPTION_INDICATOR_SIZE = 1;\n    protected static final int FRAME_GROUPING_INDICATOR_SIZE = 1;\n\n    protected static final int FRAME_HEADER_SIZE = 4 + FRAME_SIZE_SIZE + FRAME_FLAGS_SIZE;\n\n    /**\n     * If the frame is encrypted then the encryption method is stored in this byte", "refactored_code": "    protected static final int FRAME_ID_SIZE = 4;\n    protected static final int FRAME_ENCRYPTION_INDICATOR_SIZE = 1;\n    protected static final int FRAME_GROUPING_INDICATOR_SIZE = 1;\n\n    protected static final int FRAME_HEADER_SIZE = FRAME_ID_SIZE + FRAME_SIZE_SIZE + FRAME_FLAGS_SIZE;\n\n    /**\n     * If the frame is encrypted then the encryption method is stored in this byte"}
{"magic_number_smell": "    private void readHeaderFlags(ByteBuffer buffer) throws TagException {\n        //Allowable Flags\n        byte flags = buffer.get();\n        unsynchronization = (flags & FileConstants.BIT7) != 0;\n        extended = (flags & MASK_V23_EXTENDED_HEADER) != 0;\n        experimental = (flags & MASK_V23_EXPERIMENTAL) != 0;\n", "refactored_code": "    public static final int MASK_V23_UNSYNCHRONIZATION = FileConstants.BIT7;\n    private void readHeaderFlags(ByteBuffer buffer) throws TagException {\n        //Allowable Flags\n        byte flags = buffer.get();\n        unsynchronization = (flags & MASK_V23_UNSYNCHRONIZATION) != 0;\n        extended = (flags & MASK_V23_EXTENDED_HEADER) != 0;\n        experimental = (flags & MASK_V23_EXPERIMENTAL) != 0;\n"}
{"magic_number_smell": "        if (((EncodingFlags) encodingFlags).isDataLengthIndicator()) {\n            //Read the sync safe size field\n            dataLengthSize = ID3SyncSafeInteger.bufferToValue(byteBuffer);\n            extraHeaderBytesCount += 4;\n            //logger.info(getLoggingFilename() + \":\" + \"Frame Size Is:\" + frameSize + \" Data Length Size:\" + dataLengthSize);\n        }\n", "refactored_code": "    protected static final int FRAME_DATA_LENGTH_SIZE = 4;\n        if (((EncodingFlags) encodingFlags).isDataLengthIndicator()) {\n            //Read the sync safe size field\n            dataLengthSize = ID3SyncSafeInteger.bufferToValue(byteBuffer);\n            extraHeaderBytesCount += FRAME_DATA_LENGTH_SIZE;\n            //logger.info(getLoggingFilename() + \":\" + \"Frame Size Is:\" + frameSize + \" Data Length Size:\" + dataLengthSize);\n        }\n"}
{"magic_number_smell": "    private void readHeaderFlags(ByteBuffer byteBuffer) throws TagException {\n        //Flags\n        byte flags = byteBuffer.get();\n        unsynchronization = (flags & FileConstants.BIT7) != 0;\n        extended = (flags & MASK_V24_EXTENDED_HEADER) != 0;\n        experimental = (flags & MASK_V24_EXPERIMENTAL) != 0;\n        footer = (flags & MASK_V24_FOOTER_PRESENT) != 0;", "refactored_code": "    public static final int MASK_V24_UNSYNCHRONIZATION = FileConstants.BIT7;\n    private void readHeaderFlags(ByteBuffer byteBuffer) throws TagException {\n        //Flags\n        byte flags = byteBuffer.get();\n        unsynchronization = (flags & MASK_V24_UNSYNCHRONIZATION) != 0;\n        extended = (flags & MASK_V24_EXTENDED_HEADER) != 0;\n        experimental = (flags & MASK_V24_EXPERIMENTAL) != 0;\n        footer = (flags & MASK_V24_FOOTER_PRESENT) != 0;"}
{"magic_number_smell": "\n\n    protected void setupObjectList() {\n        objectList.add(new NumberFixedLength(INDEXED_DATA_START, this, 4));\n        objectList.add(new NumberFixedLength(INDEXED_DATA_LENGTH, this, DATA_LENGTH_FIELD_SIZE));\n        objectList.add(new NumberFixedLength(NUMBER_OF_INDEX_POINTS, this, NO_OF_INDEX_POINTS_FIELD_SIZE));\n        objectList.add(new NumberFixedLength(BITS_PER_INDEX_POINT, this, BITS_PER_INDEX_POINTS_FIELD_SIZE));", "refactored_code": "    private static final int DATA_START_FIELD_SIZE = 4;\n\n\n    protected void setupObjectList() {\n        objectList.add(new NumberFixedLength(INDEXED_DATA_START, this, DATA_START_FIELD_SIZE));\n        objectList.add(new NumberFixedLength(INDEXED_DATA_LENGTH, this, DATA_LENGTH_FIELD_SIZE));\n        objectList.add(new NumberFixedLength(NUMBER_OF_INDEX_POINTS, this, NO_OF_INDEX_POINTS_FIELD_SIZE));\n        objectList.add(new NumberFixedLength(BITS_PER_INDEX_POINT, this, BITS_PER_INDEX_POINTS_FIELD_SIZE));"}
{"magic_number_smell": "     *\n     */\n    protected void setupObjectList() {\n        objectList.add(new NumberVariableLength(DataTypes.OBJ_NUMBER, this, 4));\n    }\n}\n", "refactored_code": "    private static final int COUNTER_MINIMUM_FIELD_SIZE = 4;\n     *\n     */\n    protected void setupObjectList() {\n        objectList.add(new NumberVariableLength(DataTypes.OBJ_NUMBER, this, COUNTER_MINIMUM_FIELD_SIZE));\n    }\n}\n"}
{"magic_number_smell": "     */\n    protected void setupObjectList() {\n        objectList.add(new StringNullTerminated(DataTypes.OBJ_EMAIL, this));\n        objectList.add(new NumberFixedLength(DataTypes.OBJ_RATING, this, 1));\n        objectList.add(new NumberVariableLength(DataTypes.OBJ_COUNTER, this, COUNTER_MINIMUM_FIELD_SIZE));\n    }\n}", "refactored_code": "    private static final int RATING_FIELD_SIZE = 1;\n     */\n    protected void setupObjectList() {\n        objectList.add(new StringNullTerminated(DataTypes.OBJ_EMAIL, this));\n        objectList.add(new NumberFixedLength(DataTypes.OBJ_RATING, this, RATING_FIELD_SIZE));\n        objectList.add(new NumberVariableLength(DataTypes.OBJ_COUNTER, this, COUNTER_MINIMUM_FIELD_SIZE));\n    }\n}"}
{"magic_number_smell": "            setTime(formatDateAsTime(d));\n        }\n        //Precision Minute\n        else if (precision == 0) {\n            setYear(formatDateAsYear(d));\n            setDate(formatDateAsDate(d));\n            setTime(formatDateAsTime(d));", "refactored_code": "    private static final int PRECISION_SECOND = 0;\n            setTime(formatDateAsTime(d));\n        }\n        //Precision Minute\n        else if (precision == PRECISION_SECOND) {\n            setYear(formatDateAsYear(d));\n            setDate(formatDateAsDate(d));\n            setTime(formatDateAsTime(d));"}
{"magic_number_smell": "    public FrameBodyTORY(FrameBodyTDOR body) {\n        setObjectValue(DataTypes.OBJ_TEXT_ENCODING, TextEncoding.ISO_8859_1);\n        String year = body.getText();\n        if (body.getText().length() > 4) {\n            year = body.getText().substring(0, 4);\n        }\n        setObjectValue(DataTypes.OBJ_TEXT, year);", "refactored_code": "    private static final int NUMBER_OF_DIGITS_IN_YEAR = 4;\n    public FrameBodyTORY(FrameBodyTDOR body) {\n        setObjectValue(DataTypes.OBJ_TEXT_ENCODING, TextEncoding.ISO_8859_1);\n        String year = body.getText();\n        if (body.getText().length() > NUMBER_OF_DIGITS_IN_YEAR) {\n            year = body.getText().substring(0, NUMBER_OF_DIGITS_IN_YEAR);\n        }\n        setObjectValue(DataTypes.OBJ_TEXT, year);"}
{"magic_number_smell": "    }\n\n    private TextEncoding() {\n        idToValue.put((int) 0, CHARSET_ISO_8859_1);\n        idToValue.put((int) UTF_16, CHARSET_UTF_16);\n        idToValue.put((int) UTF_16BE, CHARSET_UTF_16BE);\n        idToValue.put((int) UTF_8, CHARSET_UTF_8);", "refactored_code": "    public static final byte ISO_8859_1 = 0;\n    }\n\n    private TextEncoding() {\n        idToValue.put((int) ISO_8859_1, CHARSET_ISO_8859_1);\n        idToValue.put((int) UTF_16, CHARSET_UTF_16);\n        idToValue.put((int) UTF_16BE, CHARSET_UTF_16BE);\n        idToValue.put((int) UTF_8, CHARSET_UTF_8);"}
{"magic_number_smell": "    public static final int 1 = 1;\n    public static final int TYPE_LENGTH = 3;\n    public static final int NULL_LENGTH = 4;\n    public static final int PRE_DATA_LENGTH = 1 + TYPE_LENGTH + NULL_LENGTH;\n    public static final int DATA_HEADER_LENGTH = Mp4BoxHeader.HEADER_LENGTH + PRE_DATA_LENGTH;\n\n    public static final int TYPE_POS = 1;", "refactored_code": "    public static final int VERSION_LENGTH = 1;\n    public static final int VERSION_LENGTH = 1;\n    public static final int TYPE_LENGTH = 3;\n    public static final int NULL_LENGTH = 4;\n    public static final int PRE_DATA_LENGTH = VERSION_LENGTH + TYPE_LENGTH + NULL_LENGTH;\n    public static final int DATA_HEADER_LENGTH = Mp4BoxHeader.HEADER_LENGTH + PRE_DATA_LENGTH;\n\n    public static final int TYPE_POS = VERSION_LENGTH;"}
{"magic_number_smell": "    //TODO Are these misnamed, are these version flag bytes or just null bytes\n    public static final int 1 = 1;\n    public static final int FLAGS_LENGTH = 3;\n    public static final int PRE_DATA_LENGTH = 1 + FLAGS_LENGTH;\n\n    /**\n     * @param header     parentHeader info", "refactored_code": "    public static final int VERSION_LENGTH = 1;\n    //TODO Are these misnamed, are these version flag bytes or just null bytes\n    public static final int VERSION_LENGTH = 1;\n    public static final int FLAGS_LENGTH = 3;\n    public static final int PRE_DATA_LENGTH = VERSION_LENGTH + FLAGS_LENGTH;\n\n    /**\n     * @param header     parentHeader info"}
{"magic_number_smell": "    //TODO Are these misnamed, are these version flag bytes or just null bytes\n    public static final int 1 = 1;\n    public static final int FLAGS_LENGTH = 3;\n    public static final int PRE_DATA_LENGTH = 1 + FLAGS_LENGTH;\n\n    /**\n     * @param header     parentHeader info", "refactored_code": "    public static final int VERSION_LENGTH = 1;\n    //TODO Are these misnamed, are these version flag bytes or just null bytes\n    public static final int VERSION_LENGTH = 1;\n    public static final int FLAGS_LENGTH = 3;\n    public static final int PRE_DATA_LENGTH = VERSION_LENGTH + FLAGS_LENGTH;\n\n    /**\n     * @param header     parentHeader info"}
{"magic_number_smell": "    }\n\n    public static boolean isValid(String musicalKey) {\n        if (musicalKey == null || musicalKey.length() > 3 || musicalKey.length() == 0) {\n            return false;\n        }\n", "refactored_code": "    private static final int MAX_KEY_LENGTH = 3;\n    }\n\n    public static boolean isValid(String musicalKey) {\n        if (musicalKey == null || musicalKey.length() > MAX_KEY_LENGTH || musicalKey.length() == 0) {\n            return false;\n        }\n"}
{"magic_number_smell": "        VorbisCommentTag tag = new VorbisCommentTag();\n\n        byte[] b = new byte[FIELD_VENDOR_LENGTH_LENGTH];\n        System.arraycopy(rawdata, 0, b, 0, FIELD_VENDOR_LENGTH_LENGTH);\n        int pos = FIELD_VENDOR_LENGTH_LENGTH;\n        int vendorStringLength = Utils.getIntLE(b);\n", "refactored_code": "    public static final int FIELD_VENDOR_LENGTH_POS = 0;\n        VorbisCommentTag tag = new VorbisCommentTag();\n\n        byte[] b = new byte[FIELD_VENDOR_LENGTH_LENGTH];\n        System.arraycopy(rawdata, FIELD_VENDOR_LENGTH_POS, b, FIELD_VENDOR_LENGTH_POS, FIELD_VENDOR_LENGTH_LENGTH);\n        int pos = FIELD_VENDOR_LENGTH_LENGTH;\n        int vendorStringLength = Utils.getIntLE(b);\n"}
{"magic_number_smell": "   public int getMaxLPCOrder() { return maximumLPCOrder; }\n   /**\n    * Set the minimum LPC order. If order given is out of the valid range(as\n    * defined by {@link EncodingConfiguration#32 32} and\n    * {@link EncodingConfiguration#MIN_LPC_ORDER MIN_LPC_ORDER}), it will be\n    * set to the closest valid value instead.\n    * @param order minimum LPC order to use", "refactored_code": "   public static final int MAX_LPC_ORDER = 32;\n   public int getMaxLPCOrder() { return maximumLPCOrder; }\n   /**\n    * Set the minimum LPC order. If order given is out of the valid range(as\n    * defined by {@link EncodingConfiguration#MAX_LPC_ORDER MAX_LPC_ORDER} and\n    * {@link EncodingConfiguration#MIN_LPC_ORDER MIN_LPC_ORDER}), it will be\n    * set to the closest valid value instead.\n    * @param order minimum LPC order to use"}
{"magic_number_smell": "            }\n            int channels = format.getChannels();\n            boolean bigEndian = format.isBigEndian();\n            byte[] samplesIn = new byte[(int)16384];\n            int samplesRead;\n            int framesRead;\n            int[] sampleData = new int[16384*channels/frameSize];", "refactored_code": "    private static final int MAX_READ = 16384;\n            }\n            int channels = format.getChannels();\n            boolean bigEndian = format.isBigEndian();\n            byte[] samplesIn = new byte[(int)MAX_READ];\n            int samplesRead;\n            int framesRead;\n            int[] sampleData = new int[MAX_READ*channels/frameSize];"}
{"magic_number_smell": "        EncodedElement result = new EncodedElement();\n        boolean useEndBlockSize = false;\n        boolean useEndSampleRate = false;\n        byte[] data = new byte[128];\n        int start = 0;\n        int nextPos = start;\n        //set blocking strategy bits", "refactored_code": "    public static final int MAX_HEADER_SIZE = 128;//in bytes\n        EncodedElement result = new EncodedElement();\n        boolean useEndBlockSize = false;\n        boolean useEndSampleRate = false;\n        byte[] data = new byte[MAX_HEADER_SIZE];\n        int start = 0;\n        int nextPos = start;\n        //set blocking strategy bits"}
{"magic_number_smell": "    * @return actual size set\n    */\n   public int setMaxBlockSize(int size) {\n      maxBlockSize = (size <= 65535) ? size:65535;\n      maxBlockSize = (maxBlockSize >= MIN_BLOCK_SIZE) ? maxBlockSize:MIN_BLOCK_SIZE;\n      return maxBlockSize;\n   }", "refactored_code": "   public static final int MAX_BLOCK_SIZE = 65535;\n    * @return actual size set\n    */\n   public int setMaxBlockSize(int size) {\n      maxBlockSize = (size <= MAX_BLOCK_SIZE) ? size:MAX_BLOCK_SIZE;\n      maxBlockSize = (maxBlockSize >= MIN_BLOCK_SIZE) ? maxBlockSize:MIN_BLOCK_SIZE;\n      return maxBlockSize;\n   }"}
{"magic_number_smell": "            else\n               sumsX = sum4;\n\n            double tempLowOrderBits = Math.log(2)*(sumsX/(count-i));\n            lowOrderBits[i] = (int)(Math.ceil(Math.log(tempLowOrderBits)/Math.log(2)));\n            if(lowOrderBits[i] < 1)\n                lowOrderBits[i] = 1;", "refactored_code": "    private static final double LOG_2 = Math.log(2);\n            else\n               sumsX = sum4;\n\n            double tempLowOrderBits = LOG_2*(sumsX/(count-i));\n            lowOrderBits[i] = (int)(Math.ceil(Math.log(tempLowOrderBits)/LOG_2));\n            if(lowOrderBits[i] < 1)\n                lowOrderBits[i] = 1;"}
{"magic_number_smell": "            sum += temp;\n        }\n        float mean = (float)sum/(float)(end-start);\n        double temp = Math.log(2)*(mean);\n        if(temp < 1)\n           temp = 0;\n        else", "refactored_code": "    private static final double LOGE_2 = Math.log(2);\n            sum += temp;\n        }\n        float mean = (float)sum/(float)(end-start);\n        double temp = LOGE_2*(mean);\n        if(temp < 1)\n           temp = 0;\n        else"}
{"magic_number_smell": "\n    /**\n     * Mask that can be used to quickly implement the\n     * modulus operation on 4096 * 8.\n     */\n    private static final int BUFSIZE_MASK = 4096 * 8 - 1;\n", "refactored_code": "    private static final int BUFSIZE = 4096 * 8;\n\n    /**\n     * Mask that can be used to quickly implement the\n     * modulus operation on BUFSIZE.\n     */\n    private static final int BUFSIZE_MASK = BUFSIZE - 1;\n"}
{"magic_number_smell": "    /**\n     * The frame buffer that holds the data for the current frame.\n     */\n    private final int[] framebuffer = new int[1730];\n\n    /**\n     * Number of valid bytes in the frame buffer.", "refactored_code": "    private static final int BUFFER_INT_SIZE = 1730;\n    /**\n     * The frame buffer that holds the data for the current frame.\n     */\n    private final int[] framebuffer = new int[BUFFER_INT_SIZE];\n\n    /**\n     * Number of valid bytes in the frame buffer."}
{"magic_number_smell": "    }\n\n    private float limit(float eq) {\n        if (eq == Float.NEGATIVE_INFINITY)\n            return eq;\n        if (eq > 1.0f)\n            return 1.0f;", "refactored_code": "    static public final float BAND_NOT_PRESENT = Float.NEGATIVE_INFINITY;\n    }\n\n    private float limit(float eq) {\n        if (eq == BAND_NOT_PRESENT)\n            return eq;\n        if (eq > 1.0f)\n            return 1.0f;"}
{"magic_number_smell": "                h_version = ((headerstring >>> 19) & 1);\n                if (((headerstring >>> 20) & 1) == 0) // SZD: MPEG2.5 detection\n                {\n                    if (h_version == 0) {\n                        h_version = MPEG25_LSF;\n                    } else {\n                        throw stream.newBitstreamException(Bitstream.UNKNOWN_ERROR);", "refactored_code": "    public static final int MPEG2_LSF = 0;\n                h_version = ((headerstring >>> 19) & 1);\n                if (((headerstring >>> 20) & 1) == 0) // SZD: MPEG2.5 detection\n                {\n                    if (h_version == MPEG2_LSF) {\n                        h_version = MPEG25_LSF;\n                    } else {\n                        throw stream.newBitstreamException(Bitstream.UNKNOWN_ERROR);"}
{"magic_number_smell": "           */\n            //if (bits[bitIndex++]!=0)\n            if (br.hget1bit() != 0) {\n                while (h.val[point][1] >= 250) point += h.val[point][1];\n                point += h.val[point][1];\n            } else {\n                while (h.val[point][0] >= 250) point += h.val[point][0];", "refactored_code": "    private static final int MXOFF = 250;\n           */\n            //if (bits[bitIndex++]!=0)\n            if (br.hget1bit() != 0) {\n                while (h.val[point][1] >= MXOFF) point += h.val[point][1];\n                point += h.val[point][1];\n            } else {\n                while (h.val[point][0] >= MXOFF) point += h.val[point][0];"}
{"magic_number_smell": "\n    public static final OutputChannels LEFT = new OutputChannels(LEFT_CHANNEL);\n    public static final OutputChannels RIGHT = new OutputChannels(RIGHT_CHANNEL);\n    public static final OutputChannels BOTH = new OutputChannels(0);\n    public static final OutputChannels DOWNMIX = new OutputChannels(DOWNMIX_CHANNELS);\n\n", "refactored_code": "    public static final int BOTH_CHANNELS = 0;\n\n    public static final OutputChannels LEFT = new OutputChannels(LEFT_CHANNEL);\n    public static final OutputChannels RIGHT = new OutputChannels(RIGHT_CHANNEL);\n    public static final OutputChannels BOTH = new OutputChannels(BOTH_CHANNELS);\n    public static final OutputChannels DOWNMIX = new OutputChannels(DOWNMIX_CHANNELS);\n\n"}
{"magic_number_smell": "        channel = channelnumber;\n        scalefactor = factor;\n        setEQ(eq);\n        //setQuality(1);\n\n        reset();\n    }", "refactored_code": "     public static final int\tHIGH_QUALITY = 1;\n        channel = channelnumber;\n        scalefactor = factor;\n        setEQ(eq);\n        //setQuality(HIGH_QUALITY);\n\n        reset();\n    }"}
{"magic_number_smell": "        // Estimate the expected number of bits per residual signal sample.\n        // 'total_error*' is linearly related to the variance of the residual\n        // signal, so we use it directly to compute E(|x|)\n        residualBitsPerSample[0] = (double) ((totalError0 > 0) ? Math.log(0.69314718055994530942 * (double) totalError0 / (double) dataLen) / 0.69314718055994530942 : 0.0);\n        residualBitsPerSample[1] = (double) ((totalError1 > 0) ? Math.log(0.69314718055994530942 * (double) totalError1 / (double) dataLen) / 0.69314718055994530942 : 0.0);\n        residualBitsPerSample[2] = (double) ((totalError2 > 0) ? Math.log(0.69314718055994530942 * (double) totalError2 / (double) dataLen) / 0.69314718055994530942 : 0.0);\n        residualBitsPerSample[3] = (double) ((totalError3 > 0) ? Math.log(0.69314718055994530942 * (double) totalError3 / (double) dataLen) / 0.69314718055994530942 : 0.0);", "refactored_code": "    private static final double M_LN2 = 0.69314718055994530942;\n        // Estimate the expected number of bits per residual signal sample.\n        // 'total_error*' is linearly related to the variance of the residual\n        // signal, so we use it directly to compute E(|x|)\n        residualBitsPerSample[0] = (double) ((totalError0 > 0) ? Math.log(M_LN2 * (double) totalError0 / (double) dataLen) / M_LN2 : 0.0);\n        residualBitsPerSample[1] = (double) ((totalError1 > 0) ? Math.log(M_LN2 * (double) totalError1 / (double) dataLen) / M_LN2 : 0.0);\n        residualBitsPerSample[2] = (double) ((totalError2 > 0) ? Math.log(M_LN2 * (double) totalError2 / (double) dataLen) / M_LN2 : 0.0);\n        residualBitsPerSample[3] = (double) ((totalError3 > 0) ? Math.log(M_LN2 * (double) totalError3 / (double) dataLen) / M_LN2 : 0.0);"}
{"magic_number_smell": "\n        // Read the frame CRC-16 from the footer and check\n        frameCRC = bitStream.getReadCRC16();\n        frame.setCRC((short) bitStream.readRawUInt(16));\n        if (frameCRC == frame.getCRC()) {\n            /* Undo any special channel coding */\n            switch (frame.header.channelAssignment) {", "refactored_code": "    private static final int FRAME_FOOTER_CRC_LEN = 16; // bits\n\n        // Read the frame CRC-16 from the footer and check\n        frameCRC = bitStream.getReadCRC16();\n        frame.setCRC((short) bitStream.readRawUInt(FRAME_FOOTER_CRC_LEN));\n        if (frameCRC == frame.getCRC()) {\n            /* Undo any special channel coding */\n            switch (frame.header.channelAssignment) {"}
{"magic_number_smell": "\n// write the stream header\nif(encoder->protected_->verify)\nencoder->private_->verify.state_hint = 0;\nif(!bitbuffer_write_raw_uint32(encoder->private_->frame, STREAM_SYNC, STREAM_SYNC_LEN))\nreturn encoder->protected_->state = STREAM_ENCODER_FRAMING_ERROR;\nif(!write_bitbuffer_(0)) {", "refactored_code": "    private static final int ENCODER_IN_MAGIC = 0;\n\n// write the stream header\nif(encoder->protected_->verify)\nencoder->private_->verify.state_hint = ENCODER_IN_MAGIC;\nif(!bitbuffer_write_raw_uint32(encoder->private_->frame, STREAM_SYNC, STREAM_SYNC_LEN))\nreturn encoder->protected_->state = STREAM_ENCODER_FRAMING_ERROR;\nif(!write_bitbuffer_(0)) {"}
{"magic_number_smell": "\n    FLAC__ASSERT(total_samples > 0);\n\n    error_scale = 0.5 * 0.69314718055994530942 * 0.69314718055994530942 / (double)total_samples;\n\n    return FLAC__lpc_compute_expected_bits_per_residual_sample_with_error_scale(lpc_error, error_scale);\n    }", "refactored_code": "    //static private final double M_LN2 = 0.69314718055994530942;\n\n    FLAC__ASSERT(total_samples > 0);\n\n    error_scale = 0.5 * M_LN2 * M_LN2 / (double)total_samples;\n\n    return FLAC__lpc_compute_expected_bits_per_residual_sample_with_error_scale(lpc_error, error_scale);\n    }"}
{"magic_number_smell": "\n    private EntropyCodingMethod entropyCodingMethod; // The residual coding method.\n    private int order; // The polynomial order.\n    private int[] warmup = new int[4]; // Warmup samples to prime the predictor, length == order.\n    private int[] residual; // The residual signal, length == (blocksize minus order) samples.\n\n    /**", "refactored_code": "    private static final int MAX_FIXED_ORDER = 4;\n\n    private EntropyCodingMethod entropyCodingMethod; // The residual coding method.\n    private int order; // The polynomial order.\n    private int[] warmup = new int[MAX_FIXED_ORDER]; // Warmup samples to prime the predictor, length == order.\n    private int[] residual; // The residual signal, length == (blocksize minus order) samples.\n\n    /**"}
{"magic_number_smell": "        //for (int i = 0; i < order; i++) System.out.println(\"Warm \"+i+\" \"+warmup[i]);\n\n        // read qlp coeff precision\n        int u32 = is.readRawUInt(4);\n        if (u32 == (1 << 4) - 1) {\n            throw new IOException(\"STREAM_DECODER_ERROR_STATUS_LOST_SYNC\");\n        }", "refactored_code": "    private static final int SUBFRAME_LPC_QLP_COEFF_PRECISION_LEN = 4; /* bits */\n        //for (int i = 0; i < order; i++) System.out.println(\"Warm \"+i+\" \"+warmup[i]);\n\n        // read qlp coeff precision\n        int u32 = is.readRawUInt(SUBFRAME_LPC_QLP_COEFF_PRECISION_LEN);\n        if (u32 == (1 << SUBFRAME_LPC_QLP_COEFF_PRECISION_LEN) - 1) {\n            throw new IOException(\"STREAM_DECODER_ERROR_STATUS_LOST_SYNC\");\n        }"}
{"magic_number_smell": "        contents.parameters = new int[partitions];\n\n        for (int partition = 0; partition < partitions; partition++) {\n            int riceParameter = is.readRawUInt(4);\n            contents.parameters[partition] = riceParameter;\n            if (riceParameter < ENTROPY_CODING_METHOD_PARTITIONED_RICE_ESCAPE_PARAMETER) {\n                int u = (partitionOrder == 0 || partition > 0) ? partitionSamples : partitionSamples - predictorOrder;", "refactored_code": "    private static final int ENTROPY_CODING_METHOD_PARTITIONED_RICE_PARAMETER_LEN = 4; /* bits */\n        contents.parameters = new int[partitions];\n\n        for (int partition = 0; partition < partitions; partition++) {\n            int riceParameter = is.readRawUInt(ENTROPY_CODING_METHOD_PARTITIONED_RICE_PARAMETER_LEN);\n            contents.parameters[partition] = riceParameter;\n            if (riceParameter < ENTROPY_CODING_METHOD_PARTITIONED_RICE_ESCAPE_PARAMETER) {\n                int u = (partitionOrder == 0 || partition > 0) ? partitionSamples : partitionSamples - predictorOrder;"}
{"magic_number_smell": "            if (availBits > 0) {\n                int val = ((buffer[getByte] & (0x80 >> getBit)) != 0) ? 1 : 0;\n                getBit++;\n                if (getBit == 8) {\n                    readCRC16 = CRC16.update(buffer[getByte], readCRC16);\n                    getByte++;\n                    getBit = 0;", "refactored_code": "    private static final int BITS_PER_BLURB = 8;\n            if (availBits > 0) {\n                int val = ((buffer[getByte] & (0x80 >> getBit)) != 0) ? 1 : 0;\n                getBit++;\n                if (getBit == BITS_PER_BLURB) {\n                    readCRC16 = CRC16.update(buffer[getByte], readCRC16);\n                    getByte++;\n                    getBit = 0;"}
{"magic_number_smell": "    private int outCapacity = 0; // in blurbs\n    private int outBlurbs = 0;\n    private int outBits = 0;\n    private int totalBits = 0; // must always == 8*blurbs+bits\n    private int consumedBlurbs = 0;\n    private int consumedBits = 0;\n    private int totalConsumedBits = 0;", "refactored_code": "    private static final int BITS_PER_BLURB = 8;\n    private int outCapacity = 0; // in blurbs\n    private int outBlurbs = 0;\n    private int outBits = 0;\n    private int totalBits = 0; // must always == BITS_PER_BLURB*blurbs+bits\n    private int consumedBlurbs = 0;\n    private int consumedBits = 0;\n    private int totalConsumedBits = 0;"}
{"magic_number_smell": "     */\n    public Application(BitInputStream is, int length, boolean isLast) throws IOException {\n        super(isLast);\n        is.readByteBlockAlignedNoCRC(id, 32 / 8);\n        length -= 32 / 8;\n\n        if (length > 0) {", "refactored_code": "    private static final int APPLICATION_ID_LEN = 32; // bits\n     */\n    public Application(BitInputStream is, int length, boolean isLast) throws IOException {\n        super(isLast);\n        is.readByteBlockAlignedNoCRC(id, APPLICATION_ID_LEN / 8);\n        length -= APPLICATION_ID_LEN / 8;\n\n        if (length > 0) {"}
{"magic_number_smell": "     * @throws IOException Thrown if error reading from InputBitStream\n     */\n    public CueIndex(BitInputStream is) throws IOException {\n        offset = is.readRawULong(64);\n        number = (byte) is.readRawUInt(CUESHEET_INDEX_NUMBER_LEN);\n        is.skipBitsNoCRC(CUESHEET_INDEX_RESERVED_LEN);\n    }", "refactored_code": "    private static final int CUESHEET_INDEX_OFFSET_LEN = 64; // bits\n     * @throws IOException Thrown if error reading from InputBitStream\n     */\n    public CueIndex(BitInputStream is) throws IOException {\n        offset = is.readRawULong(CUESHEET_INDEX_OFFSET_LEN);\n        number = (byte) is.readRawUInt(CUESHEET_INDEX_NUMBER_LEN);\n        is.skipBitsNoCRC(CUESHEET_INDEX_RESERVED_LEN);\n    }"}
{"magic_number_smell": "     */\n    public CueSheet(BitInputStream is, int length, boolean isLast) throws IOException {\n        super(isLast);\n        is.readByteBlockAlignedNoCRC(mediaCatalogNumber, 128 * 8 / 8);\n        leadIn = is.readRawULong(CUESHEET_LEAD_IN_LEN);\n        isCD = (is.readRawUInt(CUESHEET_IS_CD_LEN) != 0);\n        is.skipBitsNoCRC(CUESHEET_RESERVED_LEN);", "refactored_code": "    private static final int CUESHEET_MEDIA_CATALOG_NUMBER_LEN = 128 * 8; // bits\n     */\n    public CueSheet(BitInputStream is, int length, boolean isLast) throws IOException {\n        super(isLast);\n        is.readByteBlockAlignedNoCRC(mediaCatalogNumber, CUESHEET_MEDIA_CATALOG_NUMBER_LEN / 8);\n        leadIn = is.readRawULong(CUESHEET_LEAD_IN_LEN);\n        isCD = (is.readRawUInt(CUESHEET_IS_CD_LEN) != 0);\n        is.skipBitsNoCRC(CUESHEET_RESERVED_LEN);"}
{"magic_number_smell": "     * @throws IOException Thrown if error reading from InputBitStream\n     */\n    public CueTrack(BitInputStream is) throws IOException {\n        offset = is.readRawULong(64);\n        number = (byte) is.readRawUInt(CUESHEET_TRACK_NUMBER_LEN);\n        is.readByteBlockAlignedNoCRC(isrc, CUESHEET_TRACK_ISRC_LEN / 8);\n        type = is.readRawUInt(CUESHEET_TRACK_TYPE_LEN);", "refactored_code": "    private static final int CUESHEET_TRACK_OFFSET_LEN = 64; // bits\n     * @throws IOException Thrown if error reading from InputBitStream\n     */\n    public CueTrack(BitInputStream is) throws IOException {\n        offset = is.readRawULong(CUESHEET_TRACK_OFFSET_LEN);\n        number = (byte) is.readRawUInt(CUESHEET_TRACK_NUMBER_LEN);\n        is.readByteBlockAlignedNoCRC(isrc, CUESHEET_TRACK_ISRC_LEN / 8);\n        type = is.readRawUInt(CUESHEET_TRACK_TYPE_LEN);"}
{"magic_number_smell": "     * @throws IOException Thrown if error reading from InputBitStream\n     */\n    public SeekPoint(BitInputStream is) throws IOException {\n        sampleNumber = is.readRawULong(64);\n        streamOffset = is.readRawULong(SEEKPOINT_STREAM_OFFSET_LEN);\n        frameSamples = is.readRawUInt(SEEKPOINT_FRAME_SAMPLES_LEN);\n    }", "refactored_code": "    private static final int SEEKPOINT_SAMPLE_NUMBER_LEN = 64; // bits\n     * @throws IOException Thrown if error reading from InputBitStream\n     */\n    public SeekPoint(BitInputStream is) throws IOException {\n        sampleNumber = is.readRawULong(SEEKPOINT_SAMPLE_NUMBER_LEN);\n        streamOffset = is.readRawULong(SEEKPOINT_STREAM_OFFSET_LEN);\n        frameSamples = is.readRawUInt(SEEKPOINT_FRAME_SAMPLES_LEN);\n    }"}
{"magic_number_smell": "     */\n    public SeekTable(BitInputStream is, int length, boolean isLast) throws IOException {\n        super(isLast);\n        int numPoints = length / 18;\n\n        points = new SeekPoint[numPoints];\n        for (int i = 0; i < points.length; i++) {", "refactored_code": "    private static final int SEEKPOINT_LENGTH_BYTES = 18;\n     */\n    public SeekTable(BitInputStream is, int length, boolean isLast) throws IOException {\n        super(isLast);\n        int numPoints = length / SEEKPOINT_LENGTH_BYTES;\n\n        points = new SeekPoint[numPoints];\n        for (int i = 0; i < points.length; i++) {"}
{"magic_number_smell": "        super(isLast);\n        int usedBits = 0;\n\n        minBlockSize = is.readRawUInt(16);\n        usedBits += 16;\n\n        maxBlockSize = is.readRawUInt(STREAMINFO_MAX_BLOCK_SIZE_LEN);", "refactored_code": "    private static final int STREAMINFO_MIN_BLOCK_SIZE_LEN = 16; // bits\n        super(isLast);\n        int usedBits = 0;\n\n        minBlockSize = is.readRawUInt(STREAMINFO_MIN_BLOCK_SIZE_LEN);\n        usedBits += STREAMINFO_MIN_BLOCK_SIZE_LEN;\n\n        maxBlockSize = is.readRawUInt(STREAMINFO_MAX_BLOCK_SIZE_LEN);"}
{"magic_number_smell": "     * @param maxSpace The maximum space in the internal byte array.\n     */\n    public ByteData(int maxSpace) {\n        if (maxSpace <= 0) maxSpace = 256;\n        data = new byte[maxSpace];\n        len = 0;\n    }", "refactored_code": "    private static final int DEFAULT_BUFFER_SIZE = 256;\n     * @param maxSpace The maximum space in the internal byte array.\n     */\n    public ByteData(int maxSpace) {\n        if (maxSpace <= 0) maxSpace = DEFAULT_BUFFER_SIZE;\n        data = new byte[maxSpace];\n        len = 0;\n    }"}
{"magic_number_smell": "     * Constructor.\n     */\n    public RingBuffer() {\n        this(2048);\n    }\n\n    /**", "refactored_code": "    protected static final int DEFAULT_BUFFER_SIZE = 2048;\n     * Constructor.\n     */\n    public RingBuffer() {\n        this(DEFAULT_BUFFER_SIZE);\n    }\n\n    /**"}
{"magic_number_smell": "    private int bps;\n    private int sampleRate;\n\n    private byte[] s8buffer = new byte[65535 * Constants.MAX_CHANNELS * 4]; /* WATCHOUT: can be up to 2 megs */\n    private int samplesProcessed = 0;\n    private int frameCounter = 0;\n", "refactored_code": "    private static final int MAX_BLOCK_SIZE = 65535;\n    private int bps;\n    private int sampleRate;\n\n    private byte[] s8buffer = new byte[MAX_BLOCK_SIZE * Constants.MAX_CHANNELS * 4]; /* WATCHOUT: can be up to 2 megs */\n    private int samplesProcessed = 0;\n    private int frameCounter = 0;\n"}
{"magic_number_smell": "    int storage = 0;\n\n    public void writeinit() {\n        buffer = new byte[256];\n        ptr = 0;\n        buffer[0] = (byte) '\\0';\n        storage = 256;", "refactored_code": "    private static final int BUFFER_INCREMENT = 256;\n    int storage = 0;\n\n    public void writeinit() {\n        buffer = new byte[BUFFER_INCREMENT];\n        ptr = 0;\n        buffer[0] = (byte) '\\0';\n        storage = BUFFER_INCREMENT;"}
{"magic_number_smell": "        opb.writeinit();\n\n        if (pack(opb) != 0)\n            return -130;\n\n        op.packet_base = new byte[opb.bytes()];\n        op.packet = 0;", "refactored_code": "    private static final int OV_EIMPL = -130;\n        opb.writeinit();\n\n        if (pack(opb) != 0)\n            return OV_EIMPL;\n\n        op.packet_base = new byte[opb.bytes()];\n        op.packet = 0;"}
{"magic_number_smell": "            mode = opb.read(modebits);\n        }\n        if (mode == -1)\n            return (-136);\n        return (blocksizes[mode_param[mode].blockflag]);\n    }\n", "refactored_code": "    private static final int OV_EBADPACKET = -136;\n            mode = opb.read(modebits);\n        }\n        if (mode == -1)\n            return (OV_EBADPACKET);\n        return (blocksizes[mode_param[mode].blockflag]);\n    }\n"}
{"magic_number_smell": "\t/**\n\t * One week in milliseconds\n\t */\n\tprotected static final long ONE_WEEK = 1000 * 60 * 60 * 24 * 7;\n\n\t/**\n\t * Contains method names for all requests that should be cached 1 week", "refactored_code": "\tprotected static final long ONE_DAY = 1000 * 60 * 60 * 24;\n\t/**\n\t * One week in milliseconds\n\t */\n\tprotected static final long ONE_WEEK = ONE_DAY * 7;\n\n\t/**\n\t * Contains method names for all requests that should be cached 1 week"}
{"magic_number_smell": "\t}\n\n\t/**\n\t * Returns <code>true</code> if the operation was successful. Same as <code>getStatus() == ResponseStatus.0</code>.\n\t *\n\t * @return <code>true</code> if status is 0\n\t */", "refactored_code": "\tpublic static final int OK = 0;\n\t}\n\n\t/**\n\t * Returns <code>true</code> if the operation was successful. Same as <code>getStatus() == ResponseStatus.OK</code>.\n\t *\n\t * @return <code>true</code> if status is OK\n\t */"}
{"magic_number_smell": " */\npublic class TTA_Decoder {\n    public static final int 3 = 3;\n    public static final int MAX_BPS = (3 * 8);\n    public static final int MIN_BPS = 16;\n    public static final int MAX_NCH = 6;\n", "refactored_code": "    public static final int MAX_DEPTH = 3;\n */\npublic class TTA_Decoder {\n    public static final int MAX_DEPTH = 3;\n    public static final int MAX_BPS = (MAX_DEPTH * 8);\n    public static final int MIN_BPS = 16;\n    public static final int MAX_NCH = 6;\n"}
{"magic_number_smell": "class TTA_fifo {\n    public static final int 5120 = 5120;\n\n    byte[] buffer = new byte[5120];\n    int pos = buffer.length;\n    private int bcount; // count of bits in cache\n    private int bcache; // bit cache", "refactored_code": "    public static final int TTA_FIFO_BUFFER_SIZE = 5120;\nclass TTA_fifo {\n    public static final int TTA_FIFO_BUFFER_SIZE = 5120;\n\n    byte[] buffer = new byte[TTA_FIFO_BUFFER_SIZE];\n    int pos = buffer.length;\n    private int bcount; // count of bits in cache\n    private int bcache; // bit cache"}
{"magic_number_smell": "\n    public int decode(byte[] buf) {\n        try {\n            int blocksDecoded = decoder.GetData(buf, 4096 * 2);\n            track.getTrackData().setBitrate(decoder.getApeInfoDecompressCurrentBitRate());\n            if (blocksDecoded <= 0)\n                return -1;", "refactored_code": "    private static final int BLOCKS_PER_DECODE = 4096 * 2;\n\n    public int decode(byte[] buf) {\n        try {\n            int blocksDecoded = decoder.GetData(buf, BLOCKS_PER_DECODE);\n            track.getTrackData().setBitrate(decoder.getApeInfoDecompressCurrentBitRate());\n            if (blocksDecoded <= 0)\n                return -1;"}
{"magic_number_smell": "    }\n\n    public int getData() {\n        int index = oy.buffer(8500);\n        byte[] buffer = oy.data;\n        int bytes;\n        try {", "refactored_code": "    private static final int CHUNKSIZE = 8500;\n    }\n\n    public int getData() {\n        int index = oy.buffer(CHUNKSIZE);\n        byte[] buffer = oy.data;\n        int bytes;\n        try {"}
{"magic_number_smell": "            int currentFrame = 0;\n            //if we have a point, use it\n            if (seekTable != null) {\n                SeekTable.SeekPoint seekPoint = seekTable.get(targetFrame - 9);\n                fis.skip(seekPoint.offset);\n                currentFrame = seekPoint.frame;\n            }", "refactored_code": "    private static final int DECODE_AFTER_SEEK = 9;\n            int currentFrame = 0;\n            //if we have a point, use it\n            if (seekTable != null) {\n                SeekTable.SeekPoint seekPoint = seekTable.get(targetFrame - DECODE_AFTER_SEEK);\n                fis.skip(seekPoint.offset);\n                currentFrame = seekPoint.frame;\n            }"}
{"magic_number_smell": "            copyHeaderFields(mp3AudioHeader, track);\n\n            long totalSamples = trackData.getTotalSamples();\n            int enc_delay = 529;\n\n            XingFrame xingFrame = mp3AudioHeader.getXingFrame();\n            if (xingFrame != null) {", "refactored_code": "    private static final int GAPLESS_DELAY = 529;\n            copyHeaderFields(mp3AudioHeader, track);\n\n            long totalSamples = trackData.getTotalSamples();\n            int enc_delay = GAPLESS_DELAY;\n\n            XingFrame xingFrame = mp3AudioHeader.getXingFrame();\n            if (xingFrame != null) {"}
{"magic_number_smell": "        try {\n            TrackData trackData = track.getTrackData();\n            if (trackData.isStream()) {\n                in = new BufferedInputStream(IcyInputStream.create(track), 3000);\n                trackData.setCodec(\"AAC Stream\");\n            } else\n                in = new BufferedInputStream(new FileInputStream(trackData.getFile()), 3000);", "refactored_code": "    private static final int BUFFER_SIZE = 3000;\n        try {\n            TrackData trackData = track.getTrackData();\n            if (trackData.isStream()) {\n                in = new BufferedInputStream(IcyInputStream.create(track), BUFFER_SIZE);\n                trackData.setCodec(\"AAC Stream\");\n            } else\n                in = new BufferedInputStream(new FileInputStream(trackData.getFile()), BUFFER_SIZE);"}
{"magic_number_smell": "        int sampleRate = AlacUtils.AlacGetSampleRate(alacContext);\n        int bitps = AlacUtils.AlacGetBitsPerSample(alacContext);\n\n        pDestBuffer = new int[1024 * 24 * 3];\n        audioFormat = new AudioFormat(sampleRate, bitps, channels, true, false);\n        return true;\n    }", "refactored_code": "    public static final int destBufferSize = 1024 * 24 * 3; // 24kb buffer = 4096 frames = 1 alac sample (we support max 24bps)\n        int sampleRate = AlacUtils.AlacGetSampleRate(alacContext);\n        int bitps = AlacUtils.AlacGetBitsPerSample(alacContext);\n\n        pDestBuffer = new int[destBufferSize];\n        audioFormat = new AudioFormat(sampleRate, bitps, channels, true, false);\n        return true;\n    }"}
{"magic_number_smell": "        vorbis_info vi = new vorbis_info();\n        vorbisenc encoder = new vorbisenc();\n\n        float quality = 0.3f;\n        if (options != null) {\n            quality = options.getFloat(\"encoder.vorbis.quality\", 0.3f);\n        }", "refactored_code": "    private static final float DEFAULT_BITRATE = 0.3f;\n        vorbis_info vi = new vorbis_info();\n        vorbisenc encoder = new vorbisenc();\n\n        float quality = DEFAULT_BITRATE;\n        if (options != null) {\n            quality = options.getFloat(\"encoder.vorbis.quality\", DEFAULT_BITRATE);\n        }"}
{"magic_number_smell": "\n    private AudioFormat audioFormat;\n    private WavpackContext wpc;\n    private int[] buffer = new int[Defines.SAMPLE_BUFFER_SIZE];\n    private int channels;\n    private int bps;\n    private RandomAccessFile ras;", "refactored_code": "    private static final int BUFFER_SIZE = Defines.SAMPLE_BUFFER_SIZE;\n\n    private AudioFormat audioFormat;\n    private WavpackContext wpc;\n    private int[] buffer = new int[BUFFER_SIZE];\n    private int channels;\n    private int bps;\n    private RandomAccessFile ras;"}
{"magic_number_smell": "    @SuppressWarnings({\"InfiniteLoopStatement\"})\n    @Override\n    public void run() {\n        byte[] buf = new byte[AudioOutput.BUFFER_SIZE];\n        while (true) {\n            synchronized (lock) {\n                try {", "refactored_code": "    private static final int BUFFER_SIZE = AudioOutput.BUFFER_SIZE;\n    @SuppressWarnings({\"InfiniteLoopStatement\"})\n    @Override\n    public void run() {\n        byte[] buf = new byte[BUFFER_SIZE];\n        while (true) {\n            synchronized (lock) {\n                try {"}
{"magic_number_smell": "     * Constructor.\n     */\n    public RingBuffer() {\n        this(2048);\n    }\n\n    /**", "refactored_code": "    protected static final int DEFAULT_BUFFER_SIZE = 2048;\n     * Constructor.\n     */\n    public RingBuffer() {\n        this(DEFAULT_BUFFER_SIZE);\n    }\n\n    /**"}
{"magic_number_smell": "                                final ImageIcon newImage = new ImageIcon(file.getAbsolutePath());\n                                double iconHeight = newImage.getIconHeight();\n                                double iconWidth = newImage.getIconWidth();\n                                if (iconHeight > 300) {\n                                    double dt = 300 / iconHeight;\n                                    Image instance = newImage.getImage().getScaledInstance(\n                                            (int) (iconWidth * dt), (int) (iconHeight * dt),", "refactored_code": "    private final int MAX_SIZE = 300;\n                                final ImageIcon newImage = new ImageIcon(file.getAbsolutePath());\n                                double iconHeight = newImage.getIconHeight();\n                                double iconWidth = newImage.getIconWidth();\n                                if (iconHeight > MAX_SIZE) {\n                                    double dt = MAX_SIZE / iconHeight;\n                                    Image instance = newImage.getImage().getScaledInstance(\n                                            (int) (iconWidth * dt), (int) (iconHeight * dt),"}
{"magic_number_smell": "    }\n\n    private Color darker(Color c) {\n        return new Color(Math.max((int) (c.getRed() * 0.90), 0),\n                Math.max((int) (c.getGreen() * 0.90), 0),\n                Math.max((int) (c.getBlue() * 0.90), 0));\n    }", "refactored_code": "    private static final double FACTOR = 0.90;\n    }\n\n    private Color darker(Color c) {\n        return new Color(Math.max((int) (c.getRed() * FACTOR), 0),\n                Math.max((int) (c.getGreen() * FACTOR), 0),\n                Math.max((int) (c.getBlue() * FACTOR), 0));\n    }"}
{"magic_number_smell": "            DataOutputStream dos = new DataOutputStream(\n                    new BufferedOutputStream(new FileOutputStream(file)));\n            dos.write(MAGIC);\n            dos.writeInt(3);\n            dos.writeInt(size());\n            List<Pair> meta = new LinkedList<Pair>();\n            TrackData trackData;", "refactored_code": "    private static final int VERSION = 3;\n            DataOutputStream dos = new DataOutputStream(\n                    new BufferedOutputStream(new FileOutputStream(file)));\n            dos.write(MAGIC);\n            dos.writeInt(VERSION);\n            dos.writeInt(size());\n            List<Pair> meta = new LinkedList<Pair>();\n            TrackData trackData;"}
{"magic_number_smell": "                if (track != null) {\n                    long sample = player.getCurrentSample();\n\n                    sample += AudioMath.millisToSamples(3000, track.getTrackData().getSampleRate());\n                    if (track.getTrackData().getTotalSamples() >= sample) {\n                        player.seek(sample);\n                    }", "refactored_code": "    private static final int SEEK_DISTANCE = 3000;\n                if (track != null) {\n                    long sample = player.getCurrentSample();\n\n                    sample += AudioMath.millisToSamples(SEEK_DISTANCE, track.getTrackData().getSampleRate());\n                    if (track.getTrackData().getTotalSamples() >= sample) {\n                        player.seek(sample);\n                    }"}
{"magic_number_smell": "        }\n\n        int version = getInt(PROPERTY_INFO_VERSION, -1);\n        if (version > 1) {\n            logger.warning(String.format(\"Configuration of newer v%d found, but v%d is latest supported.\" +\n                    \" Backward compatibility is not guaranteed.\", version, 1));\n        }", "refactored_code": "    public static final int VERSION = 1;\n        }\n\n        int version = getInt(PROPERTY_INFO_VERSION, -1);\n        if (version > VERSION) {\n            logger.warning(String.format(\"Configuration of newer v%d found, but v%d is latest supported.\" +\n                    \" Backward compatibility is not guaranteed.\", version, VERSION));\n        }"}
{"magic_number_smell": "                totalSamples = ref.currentSample;\n            }\n            SeekTestBuffer test = new SeekTestBuffer();\n            long[] testcase = new long[10];\n            testcase[0] = 0;\n            testcase[1] = 1;\n            testcase[2] = totalSamples;", "refactored_code": "    private static final int CASES_TO_TEST = 10;\n                totalSamples = ref.currentSample;\n            }\n            SeekTestBuffer test = new SeekTestBuffer();\n            long[] testcase = new long[CASES_TO_TEST];\n            testcase[0] = 0;\n            testcase[1] = 1;\n            testcase[2] = totalSamples;"}
{"magic_number_smell": "        entityManager.persist(user);\n\n        memcacheService.put(user.getUsername(), user,\n            Expiration.byDeltaSeconds(3600));\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_EXPIRATION = 3600;\n        entityManager.persist(user);\n\n        memcacheService.put(user.getUsername(), user,\n            Expiration.byDeltaSeconds(DEFAULT_EXPIRATION));\n    }\n\n    /**"}
{"magic_number_smell": "                user = (UserAccount) query.getSingleResult();\n\n                memcacheService.put(username, user,\n                    Expiration.byDeltaSeconds(3600));\n            } catch (NoResultException e) {\n                throw new UsernameNotFoundException(\"Username not found.\", e);\n            }", "refactored_code": "    private static final int DEFAULT_EXPIRATION = 3600;\n                user = (UserAccount) query.getSingleResult();\n\n                memcacheService.put(username, user,\n                    Expiration.byDeltaSeconds(DEFAULT_EXPIRATION));\n            } catch (NoResultException e) {\n                throw new UsernameNotFoundException(\"Username not found.\", e);\n            }"}
{"magic_number_smell": "\t\t\tConnectedComponent old = componentsMap.put(n, this);\n\n\t\t\tif (countAttribute != null) {\n\t\t\t\tn.setAttribute(countAttribute, currentComponentId++);\n\t\t\t}\n\n\t\t\tif (old != this) {", "refactored_code": "\t\tpublic final int id = currentComponentId++;\n\t\t\tConnectedComponent old = componentsMap.put(n, this);\n\n\t\t\tif (countAttribute != null) {\n\t\t\t\tn.setAttribute(countAttribute, id);\n\t\t\t}\n\n\t\t\tif (old != this) {"}
{"magic_number_smell": "\t * default values\n\t */\n\tpublic PageRank() {\n\t\tthis(0.85, DEFAULT_PRECISION, DEFAULT_RANK_ATTRIBUTE);\n\t}\n\n\t/**", "refactored_code": "\tpublic static final double DEFAULT_DAMPING_FACTOR = 0.85;\n\t * default values\n\t */\n\tpublic PageRank() {\n\t\tthis(DEFAULT_DAMPING_FACTOR, DEFAULT_PRECISION, DEFAULT_RANK_ATTRIBUTE);\n\t}\n\n\t/**"}
{"magic_number_smell": "\tpublic ChartSeriesMeasure(String name) {\n\t\tsuper(name);\n\t\tseries = new XYSeries(name);\n\t\tseries.setMaximumItemCount(100);\n\t}\n\n\t/**", "refactored_code": "\tpublic static final int DEFAULT_WINDOW_SIZE = 100;\n\tpublic ChartSeriesMeasure(String name) {\n\t\tsuper(name);\n\t\tseries = new XYSeries(name);\n\t\tseries.setMaximumItemCount(DEFAULT_WINDOW_SIZE);\n\t}\n\n\t/**"}
{"magic_number_smell": "\t}\n\t\n\tpublic EigenvectorCentrality(String attribute, NormalizationMode normalize) {\n\t\tthis(attribute, normalize, 100, \"weight\");\n\t}\n\n\tpublic EigenvectorCentrality(String attribute, NormalizationMode normalize,", "refactored_code": "\tpublic static final int DEFAULT_MAX_ITER = 100;\n\t}\n\t\n\tpublic EigenvectorCentrality(String attribute, NormalizationMode normalize) {\n\t\tthis(attribute, normalize, DEFAULT_MAX_ITER, \"weight\");\n\t}\n\n\tpublic EigenvectorCentrality(String attribute, NormalizationMode normalize,"}
{"magic_number_smell": "\t\t} else if (attribute.equals(capacityName)) {\n\t\t\tdouble v = objectToDouble(value);\n\t\t\tif (Double.isNaN(v) || v < 0)\n\t\t\t\tv = -1;\n\t\t\tNSArc arc = arcs.get(edgeId);\n\t\t\tchangeCapacity(arc, (int) v);\n\t\t\tarc = arcs.get(PREFIX + \"REVERSE_\" + edgeId);", "refactored_code": "\tprotected static final int INFINITE_CAPACITY = -1;\n\t\t} else if (attribute.equals(capacityName)) {\n\t\t\tdouble v = objectToDouble(value);\n\t\t\tif (Double.isNaN(v) || v < 0)\n\t\t\t\tv = INFINITE_CAPACITY;\n\t\t\tNSArc arc = arcs.get(edgeId);\n\t\t\tchangeCapacity(arc, (int) v);\n\t\t\tarc = arcs.get(PREFIX + \"REVERSE_\" + edgeId);"}
{"magic_number_smell": "\tpublic void step() {\n\t\tif (crossing > 0) {\n\t\t\twaitCount++;\n\t\t\tcrossing -= 1000;\n\t\t} else {\n\t\t\tgoCount++;\n\t\t\ttabuStep();", "refactored_code": "\tprotected static final float SPEED = 1000;\n\tpublic void step() {\n\t\tif (crossing > 0) {\n\t\t\twaitCount++;\n\t\t\tcrossing -= SPEED;\n\t\t} else {\n\t\t\tgoCount++;\n\t\t\ttabuStep();"}
{"magic_number_smell": "\t}\n\n\tstatic class LevelBox extends LinkedList<Box> {\n\t\tprivate static final long -1929536876444346726L = -5818919480025868466L;\n\n\t\tint level;\n", "refactored_code": "\t\tprivate static final long serialVersionUID = -1929536876444346726L;\n\t}\n\n\tstatic class LevelBox extends LinkedList<Box> {\n\t\tprivate static final long serialVersionUID = -5818919480025868466L;\n\n\t\tint level;\n"}
{"magic_number_smell": "\t\tgen.addSink(g);\n\t\t\n\t\tgen.begin();\n\t\twhile (g.getNodeCount() < 10000) {\n\t\t\tboolean next = gen.nextEvents();\n\t\t\tassertTrue(next);\n\t\t}", "refactored_code": "\tpublic static final int N = 10000;\n\t\tgen.addSink(g);\n\t\t\n\t\tgen.begin();\n\t\twhile (g.getNodeCount() < N) {\n\t\t\tboolean next = gen.nextEvents();\n\t\t\tassertTrue(next);\n\t\t}"}
{"magic_number_smell": "\t\t\tAssert.assertEquals(\n\t\t\t\t\tdata[i][2],\n\t\t\t\t\tSurpriseMeasure.binomialCoefficient(data[i][0], data[i][1]),\n\t\t\t\t\t0.0001);\n\t}\n\n\t@Test", "refactored_code": "\tprotected static final double DELTA = 0.0001;\n\t\t\tAssert.assertEquals(\n\t\t\t\t\tdata[i][2],\n\t\t\t\t\tSurpriseMeasure.binomialCoefficient(data[i][0], data[i][1]),\n\t\t\t\t\tDELTA);\n\t}\n\n\t@Test"}
{"magic_number_smell": "\tprivate int eIndex;\n\t\n\tprivate int randomLength() {\n\t\treturn 10 + rnd.nextInt(LMAX - 10 + 1);\n\t}\n\t\n\tprivate void addEdge() {", "refactored_code": "\tprivate static final int LMIN = 10;\n\tprivate int eIndex;\n\t\n\tprivate int randomLength() {\n\t\treturn LMIN + rnd.nextInt(LMAX - LMIN + 1);\n\t}\n\t\n\tprivate void addEdge() {"}
{"magic_number_smell": " */\npublic class DemoLinLogLayout {\n//\tpublic static final String \"data/dorogovtsev_mendes6000.dgs\" = \"data/dorogovtsev_mendes6000.dgs\"; public static final double a= 0; public static final double r=-1.3; public static double force = 3;\n\tpublic static final String \"data/dorogovtsev_mendes6000.dgs\" = \"data/karate.gml\";\t\tpublic static double a= 0; public static double r=-1.3; public static double force = 3;\n//\tpublic static final String \"data/dorogovtsev_mendes6000.dgs\" = \"data/dolphins.gml\";\t\tpublic static double a= 0; public static double r=-1.2; public static double force = 8;\n//\tpublic static final String \"data/dorogovtsev_mendes6000.dgs\" = \"data/polbooks.gml\";\t\tpublic static double a= 0; public static double r=-1.9; public static double force = 5;\n//\tpublic static final String \"data/dorogovtsev_mendes6000.dgs\" = \"data/triangles.dgs\";\tpublic static double a= 1; public static double r=-1; public static double force = 0.5;", "refactored_code": "//\tpublic static final String GRAPH = \"data/dorogovtsev_mendes6000.dgs\"; public static final double a= 0; public static final double r=-1.3; public static double force = 3;\n */\npublic class DemoLinLogLayout {\n//\tpublic static final String GRAPH = \"data/dorogovtsev_mendes6000.dgs\"; public static final double a= 0; public static final double r=-1.3; public static double force = 3;\n\tpublic static final String GRAPH = \"data/karate.gml\";\t\tpublic static double a= 0; public static double r=-1.3; public static double force = 3;\n//\tpublic static final String GRAPH = \"data/dolphins.gml\";\t\tpublic static double a= 0; public static double r=-1.2; public static double force = 8;\n//\tpublic static final String GRAPH = \"data/polbooks.gml\";\t\tpublic static double a= 0; public static double r=-1.9; public static double force = 5;\n//\tpublic static final String GRAPH = \"data/triangles.dgs\";\tpublic static double a= 1; public static double r=-1; public static double force = 0.5;"}
{"magic_number_smell": "        // Numeric increment box can be enabled or disabled.\n        addrInterpolationList.addActionListener(e -> {\n            int selectedIndex = addrInterpolationList.getSelectedIndex();\n            incrementTextField.setEnabled(selectedIndex == 4); // Enable or disable numeric field\n        });\n\n        editControlsPane.add(cbConvertToHouseNumbers, c);", "refactored_code": "    private static final int NUMERIC_INDEX = 4;\n        // Numeric increment box can be enabled or disabled.\n        addrInterpolationList.addActionListener(e -> {\n            int selectedIndex = addrInterpolationList.getSelectedIndex();\n            incrementTextField.setEnabled(selectedIndex == NUMERIC_INDEX); // Enable or disable numeric field\n        });\n\n        editControlsPane.add(cbConvertToHouseNumbers, c);"}
{"magic_number_smell": "    }\n\n    public final void addSnap(double snap) {\n        snapSet.add(snap % Math.PI / 2);\n    }\n\n    public final Double addSnap(Node[] nodes) {", "refactored_code": "    private static final double PI_2 = Math.PI / 2;\n    }\n\n    public final void addSnap(double snap) {\n        snapSet.add(snap % PI_2);\n    }\n\n    public final Double addSnap(Node[] nodes) {"}
{"magic_number_smell": "        Node n = mv.getNearestNode(mv.getPoint(eastNorth2latlon(pos)), OsmPrimitive::isSelectable);\n        if (n == null)\n            return null;\n        return n.getEastNorth().distance(pos) <= 1e-6 ? n : null;\n    }\n\n    /**", "refactored_code": "    private static final double EQUAL_NODE_DIST_TOLERANCE = 1e-6;\n        Node n = mv.getNearestNode(mv.getPoint(eastNorth2latlon(pos)), OsmPrimitive::isSelectable);\n        if (n == null)\n            return null;\n        return n.getEastNorth().distance(pos) <= EQUAL_NODE_DIST_TOLERANCE ? n : null;\n    }\n\n    /**"}
{"magic_number_smell": "        p.add(labelDepartement, GBC.std().insets(10, 0, 0, 0));\n        p.add(inputDepartement, GBC.eol().fill(GBC.HORIZONTAL).insets(5, 0, 0, 5));\n        JOptionPane pane = new JOptionPane(p, JOptionPane.INFORMATION_MESSAGE, JOptionPane.OK_CANCEL_OPTION, null) {\n            private static final long 1L = 1L;\n\n            @Override\n            public void selectInitialValue() {", "refactored_code": "    private static final long serialVersionUID = 1L;\n        p.add(labelDepartement, GBC.std().insets(10, 0, 0, 0));\n        p.add(inputDepartement, GBC.eol().fill(GBC.HORIZONTAL).insets(5, 0, 0, 5));\n        JOptionPane pane = new JOptionPane(p, JOptionPane.INFORMATION_MESSAGE, JOptionPane.OK_CANCEL_OPTION, null) {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            public void selectInitialValue() {"}
{"magic_number_smell": "        cadastrewms.add(grabMultiplier2, GBC.std().insets(5, 0, 5, 0));\n        cadastrewms.add(grabMultiplier3, GBC.std().insets(5, 0, 5, 0));\n        cadastrewms.add(grabMultiplier4, GBC.std().insets(5, 0, 5, 0));\n        int squareSize = getNumber(\"cadastrewms.squareSize\", 100);\n        grabMultiplier4Size.setText(String.valueOf(squareSize));\n        grabMultiplier4Size.setToolTipText(tr(\"Fixed size (from 25 to 1000 meters)\"));\n        grabMultiplier4Size.setEnabled(currentScale.equals(Scale.SQUARE_100M.value));", "refactored_code": "    public static final int DEFAULT_SQUARE_SIZE = 100;\n        cadastrewms.add(grabMultiplier2, GBC.std().insets(5, 0, 5, 0));\n        cadastrewms.add(grabMultiplier3, GBC.std().insets(5, 0, 5, 0));\n        cadastrewms.add(grabMultiplier4, GBC.std().insets(5, 0, 5, 0));\n        int squareSize = getNumber(\"cadastrewms.squareSize\", DEFAULT_SQUARE_SIZE);\n        grabMultiplier4Size.setText(String.valueOf(squareSize));\n        grabMultiplier4Size.setToolTipText(tr(\"Fixed size (from 25 to 1000 meters)\"));\n        grabMultiplier4Size.setEnabled(currentScale.equals(Scale.SQUARE_100M.value));"}
{"magic_number_smell": "     * @throws IOException if any I/O error occurs\n     */\n    public void write(ObjectOutputStream oos) throws IOException {\n        currentFormat = this.4;\n        oos.writeInt(this.4);\n        oos.writeObject(this.location);    // String\n        oos.writeObject(this.codeCommune); // String", "refactored_code": "    protected final int serializeFormatVersion = 4;\n     * @throws IOException if any I/O error occurs\n     */\n    public void write(ObjectOutputStream oos) throws IOException {\n        currentFormat = this.serializeFormatVersion;\n        oos.writeInt(this.serializeFormatVersion);\n        oos.writeObject(this.location);    // String\n        oos.writeObject(this.codeCommune); // String"}
{"magic_number_smell": "            // Read File Line By Line until we either exceed the maximum scan\n            // lines or we are sure that we have a columbus file\n            while ((strLine = br.readLine()) != null\n                && (line < 20 || columbusLines > MIN_SCAN_LINES)) {\n                String[] csvFields = getCSVLine(strLine); // Get the columns of\n                                      // the current line\n                ++line;", "refactored_code": "    private static final int MAX_SCAN_LINES = 20;\n            // Read File Line By Line until we either exceed the maximum scan\n            // lines or we are sure that we have a columbus file\n            while ((strLine = br.readLine()) != null\n                && (line < MAX_SCAN_LINES || columbusLines > MIN_SCAN_LINES)) {\n                String[] csvFields = getCSVLine(strLine); // Get the columns of\n                                      // the current line\n                ++line;"}
{"magic_number_smell": "        double lat1 = toRadians(src.lat());\n        double lon1 = toRadians(src.lon());\n        \n        double dlonsin2 = sin(dlon/2 / 6378135);\n        double dlatsin2 = sin(dlat/2 / 6378135);\n        double dlatcos = cos(lon1);\n        ", "refactored_code": "    private static final double R = 6378135;\n        double lat1 = toRadians(src.lat());\n        double lon1 = toRadians(src.lon());\n        \n        double dlonsin2 = sin(dlon/2 / R);\n        double dlatsin2 = sin(dlat/2 / R);\n        double dlatcos = cos(lon1);\n        "}
{"magic_number_smell": "     *\n     * @param wpt\n     *            The way point instance.\n     * @return The x coordinate or <code>Double.NaN</code>, if the given way point is null or contains\n     *         not height attribute.\n     */\n    public static double getElevation(WayPoint wpt) {", "refactored_code": "    public static final double NO_ELEVATION = Double.NaN;\n     *\n     * @param wpt\n     *            The way point instance.\n     * @return The x coordinate or <code>NO_ELEVATION</code>, if the given way point is null or contains\n     *         not height attribute.\n     */\n    public static double getElevation(WayPoint wpt) {"}
{"magic_number_smell": "        final double latDegrees = location.lat();\n        final double lonDegrees = location.lon();\n\n        final float fraction = ((float) 1) / sb.length;\n        final int latitude = (int) Math.floor(latDegrees) + (latDegrees < 0 ? 1 : 0);\n        final int longitude = (int) Math.floor(lonDegrees) + (lonDegrees < 0 ? 1 : 0);\n", "refactored_code": "    private static final int SRTM_EXTENT = 1; // degree\n        final double latDegrees = location.lat();\n        final double lonDegrees = location.lon();\n\n        final float fraction = ((float) SRTM_EXTENT) / sb.length;\n        final int latitude = (int) Math.floor(latDegrees) + (latDegrees < 0 ? 1 : 0);\n        final int longitude = (int) Math.floor(lonDegrees) + (lonDegrees < 0 ? 1 : 0);\n"}
{"magic_number_smell": "     * Sets the very first way point.\n     */\n    protected void setStart(WayPoint wp) {\n        importantWayPoints[0] = wp;\n        if(wp.getInstant() != null)\n            this.start = wp.getInstant();\n    }", "refactored_code": "    public static final int WAYPOINT_START = 0;\n     * Sets the very first way point.\n     */\n    protected void setStart(WayPoint wp) {\n        importantWayPoints[WAYPOINT_START] = wp;\n        if(wp.getInstant() != null)\n            this.start = wp.getInstant();\n    }"}
{"magic_number_smell": "        boolean needsNewTileSet = tileSet == null || (lastBounds == null || !lastBounds.equals(box));\n\n        if (needsNewTileSet) {\n            tileSet = new TileSet(box.getMin(), box.getMax(), 13); // we use a vector format with constant zoom level\n            lastBounds = box;\n        }\n", "refactored_code": "    private static final int ELE_ZOOM_LEVEL = 13;\n        boolean needsNewTileSet = tileSet == null || (lastBounds == null || !lastBounds.equals(box));\n\n        if (needsNewTileSet) {\n            tileSet = new TileSet(box.getMin(), box.getMax(), ELE_ZOOM_LEVEL); // we use a vector format with constant zoom level\n            lastBounds = box;\n        }\n"}
{"magic_number_smell": "\n    private double avrgEle = Double.NaN;\n    private double area = Double.NaN;\n    private final EleCoordinate[] points = new EleCoordinate[3];\n\n    public EleVertex(EleCoordinate p1, EleCoordinate p2, EleCoordinate p3) {\n        points[0] = p1;", "refactored_code": "    private static final int NPOINTS = 3;\n\n    private double avrgEle = Double.NaN;\n    private double area = Double.NaN;\n    private final EleCoordinate[] points = new EleCoordinate[NPOINTS];\n\n    public EleVertex(EleCoordinate p1, EleCoordinate p2, EleCoordinate p3) {\n        points[0] = p1;"}
{"magic_number_smell": "                + (height / 2), secondGradColor, false);\n        g2d.setPaint(gradient);\n\n        g2d.fillRoundRect(r.x, r.y, r.width, r.height, 6,\n                6);\n\n        g2d.setColor(Color.BLACK);", "refactored_code": "    private static final int ROUND_RECT_RADIUS = 6;\n                + (height / 2), secondGradColor, false);\n        g2d.setPaint(gradient);\n\n        g2d.fillRoundRect(r.x, r.y, r.width, r.height, ROUND_RECT_RADIUS,\n                ROUND_RECT_RADIUS);\n\n        g2d.setColor(Color.BLACK);"}
{"magic_number_smell": "        int lastEle = (int) ElevationHelper.getElevation(lastWpt);\n\n        // normalize elevation to levels\n        int actLevel = (int) (actEle / 100.0);\n        int lastLevel = (int) (lastEle / 100.0);\n        double slope = Math.abs(ElevationHelper.computeSlope(lastWpt.getCoor(), actWpt.getCoor()));\n", "refactored_code": "    private static final double Level_Factor = 100.0;\n        int lastEle = (int) ElevationHelper.getElevation(lastWpt);\n\n        // normalize elevation to levels\n        int actLevel = (int) (actEle / Level_Factor);\n        int lastLevel = (int) (lastEle / Level_Factor);\n        double slope = Math.abs(ElevationHelper.computeSlope(lastWpt.getCoor(), actWpt.getCoor()));\n"}
{"magic_number_smell": "\n        // 1st vertex (p1, p2, pN  105m)\n        EleVertex v1 = list.get(0);\n        assertEquals(325 / 3D, v1.getEle(), 1e-10);\n        assertCoorEq(v1, 30D, 30D, 0);\n        assertCoorEq(v1, 30D, 35D, 1);\n        assertCoorEq(v1, 35D, 32.5D, 2);", "refactored_code": "    private static final double EPS = 1e-10;\n\n        // 1st vertex (p1, p2, pN  105m)\n        EleVertex v1 = list.get(0);\n        assertEquals(325 / 3D, v1.getEle(), EPS);\n        assertCoorEq(v1, 30D, 30D, 0);\n        assertCoorEq(v1, 30D, 35D, 1);\n        assertCoorEq(v1, 35D, 32.5D, 2);"}
{"magic_number_smell": "  /** Local Error subclass to check variety of error thrown. */\n  class JudgmentError extends Error {\n\n    private static final long -2500191180248181379L = 634248373797713373L;\n  }\n}\n", "refactored_code": "    private static final long serialVersionUID = -2500191180248181379L;\n  /** Local Error subclass to check variety of error thrown. */\n  class JudgmentError extends Error {\n\n    private static final long serialVersionUID = 634248373797713373L;\n  }\n}\n"}
{"magic_number_smell": "        GridBagLayout layout = new GridBagLayout();\n        all.setLayout(layout);\n        JButton pasteButton = new JButton(new AbstractAction(tr(\"Paste\"), ImageProvider.get(\"apply\")) {\n            private static final long -4894608522010226092L = -8597276971260620654L;\n\n            @Override\n            public void actionPerformed(ActionEvent e) {", "refactored_code": "    private static final long serialVersionUID = -4894608522010226092L;\n        GridBagLayout layout = new GridBagLayout();\n        all.setLayout(layout);\n        JButton pasteButton = new JButton(new AbstractAction(tr(\"Paste\"), ImageProvider.get(\"apply\")) {\n            private static final long serialVersionUID = -8597276971260620654L;\n\n            @Override\n            public void actionPerformed(ActionEvent e) {"}
{"magic_number_smell": "\n    static Instant decodeInstant(short size, boolean littleEndian, InputStream inputStream) throws IOException {\n        final var timestamp = NumberUtils.decodeLong(size, littleEndian, inputStream);\n        return Instant.ofEpochSecond(Instant.parse(\"1989-12-31T00:00:00Z\").getEpochSecond() + timestamp);\n    }\n\n    private static double decodeDegrees(long original) {", "refactored_code": "    private static final long EPOCH_DIFFERENCE = Instant.parse(\"1989-12-31T00:00:00Z\").getEpochSecond();\n\n    static Instant decodeInstant(short size, boolean littleEndian, InputStream inputStream) throws IOException {\n        final var timestamp = NumberUtils.decodeLong(size, littleEndian, inputStream);\n        return Instant.ofEpochSecond(EPOCH_DIFFERENCE + timestamp);\n    }\n\n    private static double decodeDegrees(long original) {"}
{"magic_number_smell": "    protected double minDist;\n    protected String currentValue;\n    private OSMAddress aNode;\n    private double maxDist = 100.0;\n    protected OsmPrimitive srcNode;\n\n    /**", "refactored_code": "    private static final double DEFAULT_MAX_DIST = 100.0;\n    protected double minDist;\n    protected String currentValue;\n    private OSMAddress aNode;\n    private double maxDist = DEFAULT_MAX_DIST;\n    protected OsmPrimitive srcNode;\n\n    /**"}
{"magic_number_smell": "\n    @Override\n    public int getColumnCount() {\n        return 3;\n    }\n\n    @Override", "refactored_code": "    private static final int NUMBER_OF_COLUMNS = 3;\n\n    @Override\n    public int getColumnCount() {\n        return NUMBER_OF_COLUMNS;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getColumnCount() {\n        return 5;\n    }\n\n    @Override", "refactored_code": "    private static final int NUMBER_OF_COLUMNS = 5;\n\n    @Override\n    public int getColumnCount() {\n        return NUMBER_OF_COLUMNS;\n    }\n\n    @Override"}
{"magic_number_smell": "            Document doc = thepane.getDocument();\n            try {\n                SimpleAttributeSet attrs = null;\n                if (messageType != 0) {\n                    attrs = new SimpleAttributeSet();\n                    if (messageType == MESSAGE_TYPE_INFORMATION)\n                        StyleConstants.setItalic(attrs, true);", "refactored_code": "    public static final int MESSAGE_TYPE_DEFAULT = 0;\n            Document doc = thepane.getDocument();\n            try {\n                SimpleAttributeSet attrs = null;\n                if (messageType != MESSAGE_TYPE_DEFAULT) {\n                    attrs = new SimpleAttributeSet();\n                    if (messageType == MESSAGE_TYPE_INFORMATION)\n                        StyleConstants.setItalic(attrs, true);"}
{"magic_number_smell": "\n            final boolean needReset;\n            final boolean needFullReset = lastUserId != userId;\n            if (needFullReset || (lastPosition != null && pos.greatCircleDistance((ILatLon) lastPosition) > 20000)) {\n                // reset messages\n                lastId = 0;\n                //                Config.getPref().put(\"geochat.lastid\", null);", "refactored_code": "        private static final int MAX_JUMP = 20000; // in meters\n\n            final boolean needReset;\n            final boolean needFullReset = lastUserId != userId;\n            if (needFullReset || (lastPosition != null && pos.greatCircleDistance((ILatLon) lastPosition) > MAX_JUMP)) {\n                // reset messages\n                lastId = 0;\n                //                Config.getPref().put(\"geochat.lastid\", null);"}
{"magic_number_smell": "\n    private void connect() throws ConnectionException {\n        try {\n            port = (SerialPort) portIdentifier.open(\"DG100\", 2000);\n            port.setSerialPortParams(115200, SerialPort.DATABITS_8,\n                                     SerialPort.STOPBITS_2, SerialPort.PARITY_NONE);\n            port.notifyOnOutputEmpty(false);", "refactored_code": "    public static final int TIMEOUT = 2000;\n\n    private void connect() throws ConnectionException {\n        try {\n            port = (SerialPort) portIdentifier.open(\"DG100\", TIMEOUT);\n            port.setSerialPortParams(115200, SerialPort.DATABITS_8,\n                                     SerialPort.STOPBITS_2, SerialPort.PARITY_NONE);\n            port.notifyOnOutputEmpty(false);"}
{"magic_number_smell": "        Projection proj = ProjectionRegistry.getProjection();\n        mean = new CachedLatLon(proj.eastNorth2latlon(new EastNorth(meanEast, meanNorth)));\n        hair1Coord1 = new CachedLatLon(proj.eastNorth2latlon(\n                   new EastNorth(meanEast-sigma1East*2.45, meanNorth-sigma1North*2.45)));\n        hair1Coord2 = new CachedLatLon(proj.eastNorth2latlon(\n                   new EastNorth(meanEast+sigma1East*2.45, meanNorth+sigma1North*2.45)));\n        hair2Coord1 = new CachedLatLon(proj.eastNorth2latlon(", "refactored_code": "    private static final double FAC = 2.45; // 2.45 gives 95% CI for 2D\n        Projection proj = ProjectionRegistry.getProjection();\n        mean = new CachedLatLon(proj.eastNorth2latlon(new EastNorth(meanEast, meanNorth)));\n        hair1Coord1 = new CachedLatLon(proj.eastNorth2latlon(\n                   new EastNorth(meanEast-sigma1East*FAC, meanNorth-sigma1North*FAC)));\n        hair1Coord2 = new CachedLatLon(proj.eastNorth2latlon(\n                   new EastNorth(meanEast+sigma1East*FAC, meanNorth+sigma1North*FAC)));\n        hair2Coord1 = new CachedLatLon(proj.eastNorth2latlon("}
{"magic_number_smell": "            String mphString = mphMatcher.group(1);\n            try {\n                int mph = Integer.parseInt(mphString);\n                return 1.609344f * mph;\n            } catch (NumberFormatException nfe) {\n                Logging.trace(nfe);\n            }", "refactored_code": "    private static final float KM_PER_MILE = 1.609344f;\n            String mphString = mphMatcher.group(1);\n            try {\n                int mph = Integer.parseInt(mphString);\n                return KM_PER_MILE * mph;\n            } catch (NumberFormatException nfe) {\n                Logging.trace(nfe);\n            }"}
{"magic_number_smell": "            this.setBorder(BorderFactory.createTitledBorder(tr(\"Access types\")));\n\n            this.setLayout(\n                    new GridLayout(((4-1 + AccessType.values().length) / 4), 4));\n\n            for (AccessType accessType : AccessType.values()) {\n                JCheckBox checkBox = new JCheckBox(accessType.toString());", "refactored_code": "        private static final int COLS = 4;\n            this.setBorder(BorderFactory.createTitledBorder(tr(\"Access types\")));\n\n            this.setLayout(\n                    new GridLayout(((COLS-1 + AccessType.values().length) / COLS), COLS));\n\n            for (AccessType accessType : AccessType.values()) {\n                JCheckBox checkBox = new JCheckBox(accessType.toString());"}
{"magic_number_smell": "    public GraphViewDialog(final GraphViewPlugin plugin) {\n\n        super(tr(\"Graph View Dialog\"), \"graphview\",\n                tr(\"Open the dialog for graph view configuration.\"), (Shortcut) null, 150);\n\n        this.preferences = GraphViewPreferences.getInstance();\n        this.plugin = plugin;", "refactored_code": "    private static final int HEIGHT = 150;\n    public GraphViewDialog(final GraphViewPlugin plugin) {\n\n        super(tr(\"Graph View Dialog\"), \"graphview\",\n                tr(\"Open the dialog for graph view configuration.\"), (Shortcut) null, HEIGHT);\n\n        this.preferences = GraphViewPreferences.getInstance();\n        this.plugin = plugin;"}
{"magic_number_smell": "\n    public static void paintNode(final Graphics g, Point p, Color color) {\n        g.setColor(color);\n        g.fillOval(p.x - 5, p.y - 5, 2 * 5, 2 * 5);\n    }\n\n    private void paintGraphEdge(final GraphEdge e, final Graphics2D g2D, final MapView mv,", "refactored_code": "    private static final int NODE_RADIUS = 5;\n\n    public static void paintNode(final Graphics g, Point p, Color color) {\n        g.setColor(color);\n        g.fillOval(p.x - NODE_RADIUS, p.y - NODE_RADIUS, 2 * NODE_RADIUS, 2 * NODE_RADIUS);\n    }\n\n    private void paintGraphEdge(final GraphEdge e, final Graphics2D g2D, final MapView mv,"}
{"magic_number_smell": "            data.lastDx = displaySettings.getDx();\n            data.lastDy = displaySettings.getDy();\n            boolean r = false;\n            if (Math.abs(data.lastDx) + Math.abs(data.lastDy) > 1e-8) {\n                data.lastChecked = center;\n                r = true;\n            }", "refactored_code": "    private static final double THRESHOLD = 1e-8;\n            data.lastDx = displaySettings.getDx();\n            data.lastDy = displaySettings.getDy();\n            boolean r = false;\n            if (Math.abs(data.lastDx) + Math.abs(data.lastDy) > THRESHOLD) {\n                data.lastChecked = center;\n                r = true;\n            }"}
{"magic_number_smell": "            if (offset instanceof CalibrationObject && !showCalibration)\n                continue;\n            filteredOffsets.add(offset);\n            if (filteredOffsets.size() >= Config.getPref().getInt(\"iodb.max.offsets\", 4))\n                break;\n        }\n        return filteredOffsets;", "refactored_code": "    private static final int MAX_OFFSETS = Config.getPref().getInt(\"iodb.max.offsets\", 4);\n            if (offset instanceof CalibrationObject && !showCalibration)\n                continue;\n            filteredOffsets.add(offset);\n            if (filteredOffsets.size() >= MAX_OFFSETS)\n                break;\n        }\n        return filteredOffsets;"}
{"magic_number_smell": "            } else {\n                // draw an arrow\n                g2.setStroke(new BasicStroke(1));\n                drawArrow(g2, c.x, c.y, 10, direction);\n            }\n        }\n", "refactored_code": "        private static final int SIZE = 10;\n            } else {\n                // draw an arrow\n                g2.setStroke(new BasicStroke(1));\n                drawArrow(g2, c.x, c.y, SIZE, direction);\n            }\n        }\n"}
{"magic_number_smell": "            bounds = null;\n        } else {\n            final Point point = mapView.getPoint(this.getWayPoint().getCoor());\n            bounds = new Rectangle(point.x - ImageEntry.ImageEntry.ICON.getIconWidth(),\n            point.y - ImageEntry.ICON_HEIGHT,\n            ImageEntry.ImageEntry.ICON.getIconWidth(),\n            ImageEntry.ImageEntry.ICON.getIconWidth());", "refactored_code": "    private static final int ICON_WIDTH = ImageEntry.ICON.getIconWidth();\n            bounds = null;\n        } else {\n            final Point point = mapView.getPoint(this.getWayPoint().getCoor());\n            bounds = new Rectangle(point.x - ImageEntry.ICON_WIDTH,\n            point.y - ImageEntry.ICON_HEIGHT,\n            ImageEntry.ICON_WIDTH,\n            ImageEntry.ICON_WIDTH);"}
{"magic_number_smell": "    public void appendNodes(CorridorPart.Type type, CorridorPart.ReachableSide side, String level,\n            ILatLon from, ILatLon to, ModelGeography target) {\n        if (type == CorridorPart.Type.STAIRS_UP || type == CorridorPart.Type.STAIRS_DOWN) {\n            setExtraElements(side, from, to, type == CorridorPart.Type.STAIRS_UP, 10.);\n            target.appendNode(middleNode);\n\n            detachedNode.removeAll();", "refactored_code": "    private static final double MIN_LENGTH = 10.;\n    public void appendNodes(CorridorPart.Type type, CorridorPart.ReachableSide side, String level,\n            ILatLon from, ILatLon to, ModelGeography target) {\n        if (type == CorridorPart.Type.STAIRS_UP || type == CorridorPart.Type.STAIRS_DOWN) {\n            setExtraElements(side, from, to, type == CorridorPart.Type.STAIRS_UP, MIN_LENGTH);\n            target.appendNode(middleNode);\n\n            detachedNode.removeAll();"}
{"magic_number_smell": "    private void paintChannel(final Channel channel, final Graphics2D g, final MapView mv) {\n        Point fromPoint = getCoord(channel.getFromNode(), mv);\n        g.setColor(fromNodeColor);\n        g.fillOval(fromPoint.x - 5, fromPoint.y - 5, 2 * 5, 2 * 5);\n        Point toPoint = getCoord(channel.getToNode(), mv);\n        g.setColor(toNodeColor);\n        g.fillOval(toPoint.x - 5, toPoint.y - 5, 2 * 5, 2 * 5);", "refactored_code": "    private static final int POINTSIZE = 5; //original 3\n    private void paintChannel(final Channel channel, final Graphics2D g, final MapView mv) {\n        Point fromPoint = getCoord(channel.getFromNode(), mv);\n        g.setColor(fromNodeColor);\n        g.fillOval(fromPoint.x - POINTSIZE, fromPoint.y - POINTSIZE, 2 * POINTSIZE, 2 * POINTSIZE);\n        Point toPoint = getCoord(channel.getToNode(), mv);\n        g.setColor(toNodeColor);\n        g.fillOval(toPoint.x - POINTSIZE, toPoint.y - POINTSIZE, 2 * POINTSIZE, 2 * POINTSIZE);"}
{"magic_number_smell": "        panel.add(new JLabel(tr(\"Host address of gpsd\")), GBC.std());\n        panel.add(gpsdHost, GBC.eol().fill(GridBagConstraints.HORIZONTAL).insets(5, 0, 0, 5));\n\n        gpsdPort.setText(String.valueOf(Config.getPref().getInt(C_PORT, 2947)));\n        gpsdPort.setToolTipText(tr(\"Port number of gpsd, default is {0}\", 2947));\n        panel.add(new JLabel(tr(\"Port number gpsd\")), GBC.std());\n        panel.add(gpsdPort, GBC.eol().fill(GridBagConstraints.HORIZONTAL).insets(5, 0, 0, 5));", "refactored_code": "    public static final int DEFAULT_PORT = 2947;\n        panel.add(new JLabel(tr(\"Host address of gpsd\")), GBC.std());\n        panel.add(gpsdHost, GBC.eol().fill(GridBagConstraints.HORIZONTAL).insets(5, 0, 0, 5));\n\n        gpsdPort.setText(String.valueOf(Config.getPref().getInt(C_PORT, DEFAULT_PORT)));\n        gpsdPort.setToolTipText(tr(\"Port number of gpsd, default is {0}\", DEFAULT_PORT));\n        panel.add(new JLabel(tr(\"Port number gpsd\")), GBC.std());\n        panel.add(gpsdPort, GBC.eol().fill(GridBagConstraints.HORIZONTAL).insets(5, 0, 0, 5));"}
{"magic_number_smell": "   * @return true if the object has been modified; false otherwise.\n   */\n  public boolean isModified() {\n    return !getMovingLatLon().equals(latLon) || Math.abs(getMovingHe() - he) > 1e-5f;\n  }\n\n  /**", "refactored_code": "  private static final float EPSILON = 1e-5f;\n   * @return true if the object has been modified; false otherwise.\n   */\n  public boolean isModified() {\n    return !getMovingLatLon().equals(latLon) || Math.abs(getMovingHe() - he) > EPSILON;\n  }\n\n  /**"}
{"magic_number_smell": "        CA_INDICATOR_ANGLE);\n    // Paint image marker\n    g.setColor(markerC);\n    g.fillOval(p.x - 7, p.y - 7, 2 * 7, 2 * 7);\n\n    // Paint highlight for selected or highlighted images\n    if (img.equals(getData().getHighlightedImage()) || getData().getMultiSelectedImages().contains(img)) {", "refactored_code": "  private static final int IMG_MARKER_RADIUS = 7;\n        CA_INDICATOR_ANGLE);\n    // Paint image marker\n    g.setColor(markerC);\n    g.fillOval(p.x - IMG_MARKER_RADIUS, p.y - IMG_MARKER_RADIUS, 2 * IMG_MARKER_RADIUS, 2 * IMG_MARKER_RADIUS);\n\n    // Paint highlight for selected or highlighted images\n    if (img.equals(getData().getHighlightedImage()) || getData().getMultiSelectedImages().contains(img)) {"}
{"magic_number_smell": "   */\n  public class RewriteButtonAction extends AbstractAction {\n\n    private static final long -2746815082016025516L = 1035332841101190301L;\n    private final StreetsideExportDialog dlg;\n    private String lastPath;\n", "refactored_code": "  private static final long serialVersionUID = -2746815082016025516L;\n   */\n  public class RewriteButtonAction extends AbstractAction {\n\n    private static final long serialVersionUID = 1035332841101190301L;\n    private final StreetsideExportDialog dlg;\n    private String lastPath;\n"}
{"magic_number_smell": "   */\n  private static class NextPictureAction extends AbstractAction {\n\n    private static final long 2645654786827812861L = 6333692154558730392L;\n\n    /**\n     * Constructs a normal NextPictureAction", "refactored_code": "  private static final long serialVersionUID = 2645654786827812861L;\n   */\n  private static class NextPictureAction extends AbstractAction {\n\n    private static final long serialVersionUID = 6333692154558730392L;\n\n    /**\n     * Constructs a normal NextPictureAction"}
{"magic_number_smell": "   */\n  private class LogoutAction extends AbstractAction {\n\n    private static final long 8743119160917296506L = -4146587895393766981L;\n\n    private LogoutAction() {\n      super(I18n.tr(\"Logout\"));", "refactored_code": "    private static final long serialVersionUID = 8743119160917296506L;\n   */\n  private class LogoutAction extends AbstractAction {\n\n    private static final long serialVersionUID = -4146587895393766981L;\n\n    private LogoutAction() {\n      super(I18n.tr(\"Logout\"));"}
{"magic_number_smell": "  }\n\n  private static class BasicListModel<T> extends AbstractListModel<T> {\n    private static final long -1793622345412435234L = 3107247955341855290L;\n    private final List<T> list;\n\n    public BasicListModel(List<T> list) {", "refactored_code": "  private static final long serialVersionUID = -1793622345412435234L;\n  }\n\n  private static class BasicListModel<T> extends AbstractListModel<T> {\n    private static final long serialVersionUID = 3107247955341855290L;\n    private final List<T> list;\n\n    public BasicListModel(List<T> list) {"}
{"magic_number_smell": "    bottomBar.add(infoButton);\n    StreetsideButton closeBtn = new StreetsideButton(new AbstractAction() {\n\n      private static final long -1721594904273820586L = 2853315308169651854L;\n\n      @Override\n      public void actionPerformed(ActionEvent e) {", "refactored_code": "  private static final long serialVersionUID = -1721594904273820586L;\n    bottomBar.add(infoButton);\n    StreetsideButton closeBtn = new StreetsideButton(new AbstractAction() {\n\n      private static final long serialVersionUID = 2853315308169651854L;\n\n      @Override\n      public void actionPerformed(ActionEvent e) {"}
{"magic_number_smell": "    infoButton.addActionListener(e -> setVisible(false));\n    bottomBar.add(infoButton);\n    StreetsideButton closeBtn = new StreetsideButton(new AbstractAction() {\n      private static final long -7840242522398163839L = -6193886964751195196L;\n\n      @Override\n      public void actionPerformed(ActionEvent e) {", "refactored_code": "  private static final long serialVersionUID = -7840242522398163839L;\n    infoButton.addActionListener(e -> setVisible(false));\n    bottomBar.add(infoButton);\n    StreetsideButton closeBtn = new StreetsideButton(new AbstractAction() {\n      private static final long serialVersionUID = -6193886964751195196L;\n\n      @Override\n      public void actionPerformed(ActionEvent e) {"}
{"magic_number_smell": "   * @return {@code true} if the area is too big\n   */\n  private static boolean isAreaTooBig(final double area) {\n    final boolean tooBig = area > StreetsideProperties.MAX_DOWNLOAD_AREA.get();\n    if (!stoppedDownload && tooBig) {\n      new Notification(I18n\n          .tr(\"The Streetside layer has stopped downloading images, because the requested area is too big!\")", "refactored_code": "  private static final double MAX_AREA = StreetsideProperties.MAX_DOWNLOAD_AREA.get();\n   * @return {@code true} if the area is too big\n   */\n  private static boolean isAreaTooBig(final double area) {\n    final boolean tooBig = area > MAX_AREA;\n    if (!stoppedDownload && tooBig) {\n      new Notification(I18n\n          .tr(\"The Streetside layer has stopped downloading images, because the requested area is too big!\")"}
{"magic_number_smell": "    @Override\n    public void run() {\n      while (true) {\n        if (this.moved && Calendar.getInstance().getTimeInMillis() - this.lastDownload >= 2000) {\n          this.lastDownload = Calendar.getInstance().getTimeInMillis();\n          StreetsideDownloader.downloadVisibleArea();\n          this.moved = false;", "refactored_code": "  private static final int DOWNLOAD_COOLDOWN = 2000;\n    @Override\n    public void run() {\n      while (true) {\n        if (this.moved && Calendar.getInstance().getTimeInMillis() - this.lastDownload >= DOWNLOAD_COOLDOWN) {\n          this.lastDownload = Calendar.getInstance().getTimeInMillis();\n          StreetsideDownloader.downloadVisibleArea();\n          this.moved = false;"}
{"magic_number_smell": "\n  @Override\n  public void run() {\n    try (ServerSocket serverSocket = new ServerSocket(8763);\n        Socket clientSocket = serverSocket.accept();\n        PrintWriter out = new PrintWriter(\n            new OutputStreamWriter(clientSocket.getOutputStream(), StandardCharsets.UTF_8), true);", "refactored_code": "  public static final int PORT = 8763;\n\n  @Override\n  public void run() {\n    try (ServerSocket serverSocket = new ServerSocket(PORT);\n        Socket clientSocket = serverSocket.accept();\n        PrintWriter out = new PrintWriter(\n            new OutputStreamWriter(clientSocket.getOutputStream(), StandardCharsets.UTF_8), true);"}
{"magic_number_smell": "    if (parts != null) {\n      final List<String> bbox = new ArrayList<>(Arrays.asList(parts.get(\"bbox\").split(\",\")));\n      try {\n        ret.append(URLEncoder.encode(bbox.get(StreetsideURL.3), StandardCharsets.UTF_8.name()))\n            .append(\"&s=\")\n            .append(URLEncoder.encode(bbox.get(StreetsideURL.OSM_BBOX_SOUTH),\n                StandardCharsets.UTF_8.name()))", "refactored_code": "  private static final int OSM_BBOX_NORTH = 3;\n    if (parts != null) {\n      final List<String> bbox = new ArrayList<>(Arrays.asList(parts.get(\"bbox\").split(\",\")));\n      try {\n        ret.append(URLEncoder.encode(bbox.get(StreetsideURL.OSM_BBOX_NORTH), StandardCharsets.UTF_8.name()))\n            .append(\"&s=\")\n            .append(URLEncoder.encode(bbox.get(StreetsideURL.OSM_BBOX_SOUTH),\n                StandardCharsets.UTF_8.name()))"}
{"magic_number_smell": "      }\n\n      // The zoom rectangle must have a minimum size.\n      double latExtent = Math.max(zoomBounds.getMaxLat() - zoomBounds.getMinLat(), 0.002);\n      double lonExtent = Math.max(zoomBounds.getMaxLon() - zoomBounds.getMinLon(), 0.002);\n      zoomBounds = new Bounds(zoomBounds.getCenter(), latExtent, lonExtent);\n", "refactored_code": "  private static final double MIN_ZOOM_SQUARE_SIDE = 0.002;\n      }\n\n      // The zoom rectangle must have a minimum size.\n      double latExtent = Math.max(zoomBounds.getMaxLat() - zoomBounds.getMinLat(), MIN_ZOOM_SQUARE_SIDE);\n      double lonExtent = Math.max(zoomBounds.getMaxLon() - zoomBounds.getMinLon(), MIN_ZOOM_SQUARE_SIDE);\n      zoomBounds = new Bounds(zoomBounds.getCenter(), latExtent, lonExtent);\n"}
{"magic_number_smell": "     * serialVersionUID\n     */\n    private static final long serialVersionUID = 4289136772379693178L;\n    private Dimension dimension = new Dimension(width, 400);\n    private Way selectedWay;\n    private List<Way> waysInsideSelectedArea;\n    private JTabbedPane tabPanel;", "refactored_code": "    private static final int height = 400;\n     * serialVersionUID\n     */\n    private static final long serialVersionUID = 4289136772379693178L;\n    private Dimension dimension = new Dimension(width, height);\n    private Way selectedWay;\n    private List<Way> waysInsideSelectedArea;\n    private JTabbedPane tabPanel;"}
{"magic_number_smell": "        }\n        map['+'] = 62;\n        map['/'] = 63;\n        map['='] = 127;\n\n        return map;\n    }", "refactored_code": "    private static final byte PADDING = 127;\n        }\n        map['+'] = 62;\n        map['/'] = 63;\n        map['='] = PADDING;\n\n        return map;\n    }"}
{"magic_number_smell": "                bytesToRead = (int) size;\n\n                switch(fileType) {\n                case 0x10: \n                case WAY_DATASET: \n                case REL_DATASET: \n                case BBOX_DATASET:", "refactored_code": "    private static final int NODE_DATASET = 0x10;\n                bytesToRead = (int) size;\n\n                switch(fileType) {\n                case NODE_DATASET: \n                case WAY_DATASET: \n                case REL_DATASET: \n                case BBOX_DATASET:"}
{"magic_number_smell": "    public static Date filetimeToDate(final long filetime)\n    {\n        final long ms_since_16010101 = filetime / (1000 * 10);\n        final long ms_since_19700101 = ms_since_16010101 - 11644473600000L;\n        return new Date(ms_since_19700101);\n    }\n", "refactored_code": "    public static final long EPOCH_DIFF = 11644473600000L;\n    public static Date filetimeToDate(final long filetime)\n    {\n        final long ms_since_16010101 = filetime / (1000 * 10);\n        final long ms_since_19700101 = ms_since_16010101 - EPOCH_DIFF;\n        return new Date(ms_since_19700101);\n    }\n"}
{"magic_number_smell": "    {\n        /* Initialize the number-to-name map: */\n        Map<Long, Object> tm1 = new HashMap<>();\n        tm1.put(Long.valueOf(0), \"0\");\n        tm1.put(Long.valueOf(1), \"VT_NULL\");\n        tm1.put(Long.valueOf(2), \"VT_I2\");\n        tm1.put(Long.valueOf(3), \"VT_I4\");", "refactored_code": "    public static final int VT_EMPTY = 0;\n    {\n        /* Initialize the number-to-name map: */\n        Map<Long, Object> tm1 = new HashMap<>();\n        tm1.put(Long.valueOf(0), \"VT_EMPTY\");\n        tm1.put(Long.valueOf(1), \"VT_NULL\");\n        tm1.put(Long.valueOf(2), \"VT_I2\");\n        tm1.put(Long.valueOf(3), \"VT_I4\");"}
{"magic_number_smell": "        if (summaryInformationProperties == null)\n        {\n            PropertyIDMap m = new PropertyIDMap(18, (float) 1.0);\n            m.put(2, \"2\");\n            m.put(PID_SUBJECT, \"PID_SUBJECT\");\n            m.put(PID_AUTHOR, \"PID_AUTHOR\");\n            m.put(PID_KEYWORDS, \"PID_KEYWORDS\");", "refactored_code": "    public static final int PID_TITLE = 2;\n        if (summaryInformationProperties == null)\n        {\n            PropertyIDMap m = new PropertyIDMap(18, (float) 1.0);\n            m.put(PID_TITLE, \"PID_TITLE\");\n            m.put(PID_SUBJECT, \"PID_SUBJECT\");\n            m.put(PID_AUTHOR, \"PID_AUTHOR\");\n            m.put(PID_KEYWORDS, \"PID_KEYWORDS\");"}
{"magic_number_smell": "     * @return Workbook object\n     */\n    public static InternalWorkbook createWorkbook(List<Record> recs) {\n        if (log.check( POILogger.POILogger.DEBUG ))\n            log.log(POILogger.DEBUG, \"Workbook (readfile) created with reclen=\",\n                    Integer.valueOf(recs.size()));\n        InternalWorkbook retval = new InternalWorkbook();", "refactored_code": "    private static final int DEBUG = POILogger.DEBUG;\n     * @return Workbook object\n     */\n    public static InternalWorkbook createWorkbook(List<Record> recs) {\n        if (log.check( POILogger.DEBUG ))\n            log.log(DEBUG, \"Workbook (readfile) created with reclen=\",\n                    Integer.valueOf(recs.size()));\n        InternalWorkbook retval = new InternalWorkbook();"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x007D;\n    }\n\n    public void serialize(LittleEndianOutput out) {", "refactored_code": "    public static final short sid = 0x007D;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    public void serialize(LittleEndianOutput out) {"}
{"magic_number_smell": "\t\tout.writeShort((short)field_2_sheet_table_index);\n\t}\n\tprotected int getDataSize() {\n\t\treturn 4;\n\t}\n\n\t/**", "refactored_code": "\tprivate static final short DATA_SIZE = 4;\n\t\tout.writeShort((short)field_2_sheet_table_index);\n\t}\n\tprotected int getDataSize() {\n\t\treturn DATA_SIZE;\n\t}\n\n\t/**"}
{"magic_number_smell": "\t}\n\n\tpublic short getSid() { // NO_UCD\n\t\treturn 0x0009;\n\t}\n\n\tpublic EmbeddedObjectRefSubRecord(LittleEndianInput in, int size) {", "refactored_code": "\tpublic static final short sid = 0x0009;\n\t}\n\n\tpublic short getSid() { // NO_UCD\n\t\treturn sid;\n\t}\n\n\tpublic EmbeddedObjectRefSubRecord(LittleEndianInput in, int size) {"}
{"magic_number_smell": "     * @param size \n     */\n    public EndSubRecord(LittleEndianInput in, int size) {\n        if ((size & 0xFF) != 0) { // mask out random crap in upper byte\n            throw new RecordFormatException(\"Unexpected size (\" + size + \")\");\n        }\n    }", "refactored_code": "    private static final int ENCODED_SIZE = 0;\n     * @param size \n     */\n    public EndSubRecord(LittleEndianInput in, int size) {\n        if ((size & 0xFF) != ENCODED_SIZE) { // mask out random crap in upper byte\n            throw new RecordFormatException(\"Unexpected size (\" + size + \")\");\n        }\n    }"}
{"magic_number_smell": "    }\n\n    protected int getDataSize() {\n        return 4 - 4;\n    }\n\n    public short getSid()", "refactored_code": "\tpublic static final int ENCODED_SIZE = 4;\n    }\n\n    protected int getDataSize() {\n        return ENCODED_SIZE - 4;\n    }\n\n    public short getSid()"}
{"magic_number_smell": "\t * For OLE and DDE, links can be either 'automatic' or 'manual'\n\t */\n\tpublic boolean isAutomaticLink() {\n\t\treturn (field_1_option_flag & 0x0002) != 0;\n\t}\n\n\t/**", "refactored_code": "\tprivate static final int OPT_AUTOMATIC_LINK        = 0x0002; // m$ doc calls this fWantAdvise\n\t * For OLE and DDE, links can be either 'automatic' or 'manual'\n\t */\n\tpublic boolean isAutomaticLink() {\n\t\treturn (field_1_option_flag & OPT_AUTOMATIC_LINK) != 0;\n\t}\n\n\t/**"}
{"magic_number_smell": "\t}\n\t\n\tprotected int getDataSize() {\n\t\treturn 2 + _list.size() * RefSubRecord.6;\n\t}\n\t\n\tpublic void serialize(LittleEndianOutput out) {", "refactored_code": "\t\tpublic static final int ENCODED_SIZE = 6;\n\t}\n\t\n\tprotected int getDataSize() {\n\t\treturn 2 + _list.size() * RefSubRecord.ENCODED_SIZE;\n\t}\n\t\n\tpublic void serialize(LittleEndianOutput out) {"}
{"magic_number_smell": "\n\n    public ExtSSTRecord() {\n    \t_stringsPerBucket = 8;\n        _sstInfos = new InfoSubRecord[0];\n    }\n", "refactored_code": "    public static final int DEFAULT_BUCKET_SIZE = 8;\n\n\n    public ExtSSTRecord() {\n    \t_stringsPerBucket = DEFAULT_BUCKET_SIZE;\n        _sstInfos = new InfoSubRecord[0];\n    }\n"}
{"magic_number_smell": "\t\t_encryptionType = in.readUShort();\n\n\t\tswitch (_encryptionType) {\n\t\t\tcase 0:\n\t\t\t\tthrow new RecordFormatException(\"HSSF does not currently support XOR obfuscation\");\n\t\t\tcase ENCRYPTION_OTHER:\n\t\t\t\t// handled below", "refactored_code": "\tprivate static final int ENCRYPTION_XOR = 0;\n\t\t_encryptionType = in.readUShort();\n\n\t\tswitch (_encryptionType) {\n\t\t\tcase ENCRYPTION_XOR:\n\t\t\t\tthrow new RecordFormatException(\"HSSF does not currently support XOR obfuscation\");\n\t\t\tcase ENCRYPTION_OTHER:\n\t\t\t\t// handled below"}
{"magic_number_smell": "\t}\n\n\tpublic short getSid() {\n\t\treturn 0x0006;\n\t}\n\n\t@Override", "refactored_code": "\tpublic static final short sid = 0x0006;   // docs say 406...because of a bug Microsoft support site article #Q184647)\n\t}\n\n\tpublic short getSid() {\n\t\treturn sid;\n\t}\n\n\t@Override"}
{"magic_number_smell": "     */\n    public FtCblsSubRecord()\n    {\n        reserved = new byte[20];\n    }\n\n    public FtCblsSubRecord(LittleEndianInput in, int size) {", "refactored_code": "    private static final int ENCODED_SIZE = 20;\n     */\n    public FtCblsSubRecord()\n    {\n        reserved = new byte[ENCODED_SIZE];\n    }\n\n    public FtCblsSubRecord(LittleEndianInput in, int size) {"}
{"magic_number_smell": "\t}\n\n\tpublic short getSid() {\n\t\treturn 0x001B;\n\t}\n\n\tpublic Object clone() {", "refactored_code": "\tpublic static final short sid = 0x001B;\n\t}\n\n\tpublic short getSid() {\n\t\treturn sid;\n\t}\n\n\tpublic Object clone() {"}
{"magic_number_smell": "\t\t */\n\t\tpublic static GUID parse(String rep) {\n\t\t\tchar[] cc = rep.toCharArray();\n\t\t\tif (cc.length != 36) {\n\t\t\t\tthrow new RecordFormatException(\"supplied text is the wrong length for a GUID\");\n\t\t\t}\n\t\t\tint d0 = (parseShort(cc, 0) << 16) + (parseShort(cc, 4) << 0);", "refactored_code": "\t\tprivate static final int TEXT_FORMAT_LENGTH = 36;\n\t\t */\n\t\tpublic static GUID parse(String rep) {\n\t\t\tchar[] cc = rep.toCharArray();\n\t\t\tif (cc.length != TEXT_FORMAT_LENGTH) {\n\t\t\t\tthrow new RecordFormatException(\"supplied text is the wrong length for a GUID\");\n\t\t\t}\n\t\t\tint d0 = (parseShort(cc, 0) << 16) + (parseShort(cc, 4) << 0);"}
{"magic_number_smell": "     *\n     * An unsigned integer that indirectly specifies whether\n     * some of the data in this structure appear in a subsequent Continue record.\n     * If _cbFContinued is 0x00, all of the fields in this structure except 0x0013 and _cbFContinued\n     *  MUST NOT exist. If this entire structure is contained within the same record,\n     * then _cbFContinued MUST be greater than or equal to the size, in bytes,\n     * of this structure, not including the four bytes for the ft and _cbFContinued fields", "refactored_code": "    public static final int sid = 0x0013;\n     *\n     * An unsigned integer that indirectly specifies whether\n     * some of the data in this structure appear in a subsequent Continue record.\n     * If _cbFContinued is 0x00, all of the fields in this structure except sid and _cbFContinued\n     *  MUST NOT exist. If this entire structure is contained within the same record,\n     * then _cbFContinued MUST be greater than or equal to the size, in bytes,\n     * of this structure, not including the four bytes for the ft and _cbFContinued fields"}
{"magic_number_smell": "\t\t}\n\n\t\tpublic static RkRec[] parseRKs(RecordInputStream in) {\n\t\t\tint nItems = (in.remaining()-2) / 6;\n\t\t\tRkRec[] retval = new RkRec[nItems];\n\t\t\tfor (int i=0; i<nItems; i++) {\n\t\t\t\tretval[i] = new RkRec(in);", "refactored_code": "\t\tpublic static final int ENCODED_SIZE = 6;\n\t\t}\n\n\t\tpublic static RkRec[] parseRKs(RecordInputStream in) {\n\t\t\tint nItems = (in.remaining()-2) / ENCODED_SIZE;\n\t\t\tRkRec[] retval = new RkRec[nItems];\n\t\t\tfor (int i=0; i<nItems; i++) {\n\t\t\t\tretval[i] = new RkRec(in);"}
{"magic_number_smell": "\t{\n\t\tthis();\n\t\tfield_12_built_in_code = builtin;\n\t\tsetOptionFlag((short)(field_1_option_flag | Option.0x0020));\n\t\tfield_6_sheetNumber = sheetNumber; //the extern sheets are set through references\n\t}\n", "refactored_code": "\t\tpublic static final int OPT_BUILTIN =       0x0020;\n\t{\n\t\tthis();\n\t\tfield_12_built_in_code = builtin;\n\t\tsetOptionFlag((short)(field_1_option_flag | Option.OPT_BUILTIN));\n\t\tfield_6_sheetNumber = sheetNumber; //the extern sheets are set through references\n\t}\n"}
{"magic_number_smell": "    public NoteStructureSubRecord()\n    {\n        //all we know is that the the length of <code>NoteStructureSubRecord</code> is always 22 bytes\n        reserved = new byte[22];\n    }\n\n    /**", "refactored_code": "    private static final int ENCODED_SIZE = 22;\n    public NoteStructureSubRecord()\n    {\n        //all we know is that the the length of <code>NoteStructureSubRecord</code> is always 22 bytes\n        reserved = new byte[ENCODED_SIZE];\n    }\n\n    /**"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x0203;\n    }\n\n    public Object clone() {", "refactored_code": "    public static final short sid = 0x0203;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    public Object clone() {"}
{"magic_number_smell": "\t\tif (nRemainingBytes > 0) {\n\t\t\t// At present (Oct-2008), most unit test samples have (subRecordData.length % 2 == 0)\n\t\t\t_isPaddedToQuadByteMultiple = subRecordData.length % MAX_PAD_ALIGNMENT == 0;\n\t\t\tif (nRemainingBytes >= (_isPaddedToQuadByteMultiple ? MAX_PAD_ALIGNMENT : 2)) {\n\t\t\t\tif (!canPaddingBeDiscarded(subRecordData, nRemainingBytes)) {\n\t\t\t\t\tString msg = \"Leftover \" + nRemainingBytes \n\t\t\t\t\t\t+ \" bytes in subrecord data \" + HexDump.toHex(subRecordData);", "refactored_code": "\tprivate static final int NORMAL_PAD_ALIGNMENT = 2;\n\t\tif (nRemainingBytes > 0) {\n\t\t\t// At present (Oct-2008), most unit test samples have (subRecordData.length % 2 == 0)\n\t\t\t_isPaddedToQuadByteMultiple = subRecordData.length % MAX_PAD_ALIGNMENT == 0;\n\t\t\tif (nRemainingBytes >= (_isPaddedToQuadByteMultiple ? MAX_PAD_ALIGNMENT : NORMAL_PAD_ALIGNMENT)) {\n\t\t\t\tif (!canPaddingBeDiscarded(subRecordData, nRemainingBytes)) {\n\t\t\t\t\tString msg = \"Leftover \" + nRemainingBytes \n\t\t\t\t\t\t+ \" bytes in subrecord data \" + HexDump.toHex(subRecordData);"}
{"magic_number_smell": "    }\n\n    protected int getDataSize() {\n        return 2 + _breaks.size() * Break.6;\n    }\n\n    public final void serialize(LittleEndianOutput out) {", "refactored_code": "        public static final int ENCODED_SIZE = 6;\n    }\n\n    protected int getDataSize() {\n        return 2 + _breaks.size() * Break.ENCODED_SIZE;\n    }\n\n    public final void serialize(LittleEndianOutput out) {"}
{"magic_number_smell": "\t */\n\tpublic static List<Record> createRecords(InputStream in) throws RecordFormatException {\n\n\t\tList<Record> records = new ArrayList<>(512);\n\n\t\tRecordFactoryInputStream recStream = new RecordFactoryInputStream(in, true);\n", "refactored_code": "\tprivate static final int NUM_RECORDS = 512;\n\t */\n\tpublic static List<Record> createRecords(InputStream in) throws RecordFormatException {\n\n\t\tList<Record> records = new ArrayList<>(NUM_RECORDS);\n\n\t\tRecordFactoryInputStream recStream = new RecordFactoryInputStream(in, true);\n"}
{"magic_number_smell": "\t\tif (_currentDataLength != DATA_LEN_NEEDS_TO_BE_READ) {\n\t\t\t_nextSid = readNextSid();\n\t\t}\n\t\treturn _nextSid != -1;\n\t}\n\n\t/**", "refactored_code": "\tprivate static final int INVALID_SID_VALUE = -1;\n\t\tif (_currentDataLength != DATA_LEN_NEEDS_TO_BE_READ) {\n\t\t\t_nextSid = readNextSid();\n\t\t}\n\t\treturn _nextSid != INVALID_SID_VALUE;\n\t}\n\n\t/**"}
{"magic_number_smell": "    }\n\n    protected int getDataSize() {\n        return 20 - 4;\n    }\n\n    public short getSid() {", "refactored_code": "    public static final int ENCODED_SIZE = 20;\n    }\n\n    protected int getDataSize() {\n        return ENCODED_SIZE - 4;\n    }\n\n    public short getSid() {"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x00FC;\n    }\n\n    /**", "refactored_code": "    public static final short sid = 0x00FC;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    /**"}
{"magic_number_smell": "\n        field_1_number_of_sheets = in.readShort();\n\n        if(recLen > 4) {\n            // 5.38.1 External References\n            _isAddInFunctions = false;\n", "refactored_code": "    private static final short SMALL_RECORD_SIZE = 4;\n\n        field_1_number_of_sheets = in.readShort();\n\n        if(recLen > SMALL_RECORD_SIZE) {\n            // 5.38.1 External References\n            _isAddInFunctions = false;\n"}
{"magic_number_smell": "\t}\n\n\tpublic short getSid() {\n\t\treturn 0x0236;\n\t}\n\tprotected int getExtraDataSize() {\n\t\treturn ", "refactored_code": "\tpublic static final short sid = 0x0236;\n\t}\n\n\tpublic short getSid() {\n\t\treturn sid;\n\t}\n\tprotected int getExtraDataSize() {\n\t\treturn "}
{"magic_number_smell": "\n\tprivate static void processFontRuns(RecordInputStream in, HSSFRichTextString str,\n\t\t\tint formattingRunDataLength) {\n\t\tif (formattingRunDataLength % 8 != 0) {\n\t\t\tthrow new RecordFormatException(\"Bad format run data length \" + formattingRunDataLength\n\t\t\t\t\t+ \")\");\n\t\t}", "refactored_code": "\tprivate static final int FORMAT_RUN_ENCODED_SIZE = 8; // 2 shorts and 4 bytes reserved\n\n\tprivate static void processFontRuns(RecordInputStream in, HSSFRichTextString str,\n\t\t\tint formattingRunDataLength) {\n\t\tif (formattingRunDataLength % FORMAT_RUN_ENCODED_SIZE != 0) {\n\t\t\tthrow new RecordFormatException(\"Bad format run data length \" + formattingRunDataLength\n\t\t\t\t\t+ \")\");\n\t\t}"}
{"magic_number_smell": "\t\t// Make sure you delete the corresponding entry from\n\t\t// this method any time a new Record subclass is created.\n\t\tswitch (sid) {\n\t\t\tcase 0x0033: return \"PRINTSIZE\";\n\t\t\tcase PLS_004D: return \"PLS\";\n\t\t\tcase 0x0050: return \"DCON\"; // Data Consolidation Information\n\t\t\tcase 0x007F: return \"IMDATA\";", "refactored_code": "\tpublic static final int PRINTSIZE_0033       = 0x0033;\n\t\t// Make sure you delete the corresponding entry from\n\t\t// this method any time a new Record subclass is created.\n\t\tswitch (sid) {\n\t\t\tcase PRINTSIZE_0033: return \"PRINTSIZE\";\n\t\t\tcase PLS_004D: return \"PLS\";\n\t\t\tcase 0x0050: return \"DCON\"; // Data Consolidation Information\n\t\t\tcase 0x007F: return \"IMDATA\";"}
{"magic_number_smell": "\t}\n\n\tpublic short getSid() {\n\t\treturn 0x001A;\n\t}\n\n\tpublic Object clone() {", "refactored_code": "\tpublic static final short sid = 0x001A;\n\t}\n\n\tpublic short getSid() {\n\t\treturn sid;\n\t}\n\n\tpublic Object clone() {"}
{"magic_number_smell": "\t}\n\n\tpublic void removeAllCellsValuesForRow(int rowIndex) {\n\t\tif (rowIndex < 0 || rowIndex > 0XFFFF) {\n\t\t\tthrow new IllegalArgumentException(\"Specified rowIndex \" + rowIndex\n\t\t\t\t\t+ \" is outside the allowable range (0..\" +0XFFFF + \")\");\n\t\t}", "refactored_code": "\tprivate static final int MAX_ROW_INDEX = 0XFFFF;\n\t}\n\n\tpublic void removeAllCellsValuesForRow(int rowIndex) {\n\t\tif (rowIndex < 0 || rowIndex > MAX_ROW_INDEX) {\n\t\t\tthrow new IllegalArgumentException(\"Specified rowIndex \" + rowIndex\n\t\t\t\t\t+ \" is outside the allowable range (0..\" +MAX_ROW_INDEX + \")\");\n\t\t}"}
{"magic_number_smell": "\tprivate static Object readAConstantValue(LittleEndianInput in) {\n\t\tbyte grbit = in.readByte();\n\t\tswitch(grbit) {\n\t\t\tcase 0:\n\t\t\t\tin.readLong(); // 8 byte 'not used' field\n\t\t\t\treturn EMPTY_REPRESENTATION; \n\t\t\tcase TYPE_NUMBER:", "refactored_code": "\tprivate static final int TYPE_EMPTY = 0;\n\tprivate static Object readAConstantValue(LittleEndianInput in) {\n\t\tbyte grbit = in.readByte();\n\t\tswitch(grbit) {\n\t\t\tcase TYPE_EMPTY:\n\t\t\t\tin.readLong(); // 8 byte 'not used' field\n\t\t\t\treturn EMPTY_REPRESENTATION; \n\t\t\tcase TYPE_NUMBER:"}
{"magic_number_smell": "\t\tif (_out == null) {\n\t\t\tthrow new IllegalStateException(\"Record already terminated\");\n\t\t}\n\t\treturn RecordInputStream.MAX_RECORD_DATA_SIZE - _size;\n\t}\n\t/**\n\t * Finishes writing the current record and updates 'ushort size' field.<br/>", "refactored_code": "\tprivate static final int MAX_DATA_SIZE = RecordInputStream.MAX_RECORD_DATA_SIZE;\n\t\tif (_out == null) {\n\t\t\tthrow new IllegalStateException(\"Record already terminated\");\n\t\t}\n\t\treturn MAX_DATA_SIZE - _size;\n\t}\n\t/**\n\t * Finishes writing the current record and updates 'ushort size' field.<br/>"}
{"magic_number_smell": "     * @return <code>true</code> if this is an external function\n     */\n    public final boolean isExternalFunction() {\n        return _functionIndex == 255;\n    }\n\n    public final String toFormulaString() {", "refactored_code": "    private static final short FUNCTION_INDEX_EXTERNAL = 255;\n     * @return <code>true</code> if this is an external function\n     */\n    public final boolean isExternalFunction() {\n        return _functionIndex == FUNCTION_INDEX_EXTERNAL;\n    }\n\n    public final String toFormulaString() {"}
{"magic_number_smell": "\t}\n\n\tpublic void write(LittleEndianOutput out) {\n\t\tout.writeByte(0x20 + getPtgClass());\n\t\tout.writeInt(_reserved0Int);\n\t\tout.writeShort(_reserved1Short);\n\t\tout.writeByte(_reserved2Byte);", "refactored_code": "\tpublic static final byte sid  = 0x20;\n\t}\n\n\tpublic void write(LittleEndianOutput out) {\n\t\tout.writeByte(sid + getPtgClass());\n\t\tout.writeInt(_reserved0Int);\n\t\tout.writeShort(_reserved1Short);\n\t\tout.writeByte(_reserved2Byte);"}
{"magic_number_smell": "\t}\n\n\tpublic int getSize() {\n\t\treturn 2;\n\t}\n\n\tpublic String toFormulaString() {", "refactored_code": "\tpublic static final int SIZE = 2;\n\t}\n\n\tpublic int getSize() {\n\t\treturn SIZE;\n\t}\n\n\tpublic String toFormulaString() {"}
{"magic_number_smell": "    }\n\n    public void write(LittleEndianOutput out) {\n        out.writeByte(0x1c + getPtgClass());\n        out.writeByte(field_1_error_code);\n    }\n", "refactored_code": "    public static final short sid  = 0x1c;\n    }\n\n    public void write(LittleEndianOutput out) {\n        out.writeByte(sid + getPtgClass());\n        out.writeByte(field_1_error_code);\n    }\n"}
{"magic_number_smell": "\t * <tt>IntPtg</tt> can represent.\n\t */\n\tpublic static boolean isInRange(int i) {\n\t\treturn i >= 0x0000 && i <= MAX_VALUE;\n\t}\n\n\tpublic final static int SIZE = 3;", "refactored_code": "\tprivate static final int MIN_VALUE = 0x0000;\n\t * <tt>IntPtg</tt> can represent.\n\t */\n\tpublic static boolean isInRange(int i) {\n\t\treturn i >= MIN_VALUE && i <= MAX_VALUE;\n\t}\n\n\tpublic final static int SIZE = 3;"}
{"magic_number_smell": "\tpublic static final byte CLASS_VALUE = 0x20;\n\tpublic static final byte CLASS_ARRAY = 0x40;\n\n\tprivate byte ptgClass = 0x00; //base ptg\n\n\tpublic final void setClass(byte thePtgClass) {\n\t\tif (isBaseToken()) {", "refactored_code": "\tpublic static final byte CLASS_REF = 0x00;\n\tpublic static final byte CLASS_VALUE = 0x20;\n\tpublic static final byte CLASS_ARRAY = 0x40;\n\n\tprivate byte ptgClass = CLASS_REF; //base ptg\n\n\tpublic final void setClass(byte thePtgClass) {\n\t\tif (isBaseToken()) {"}
{"magic_number_smell": "        // value expression that might appear in a formula.  In addition these error strings should\n        // look unlike the standard Excel errors.  Hence tilde ('~') was used.\n        switch(errorCode) {\n            case 0xFFFFFFC4: return \"~CIRCULAR~REF~\";\n            case FUNCTION_NOT_IMPLEMENTED_CODE: return \"~FUNCTION~NOT~IMPLEMENTED~\";\n        }\n        return \"~non~std~err(\" + errorCode + \")~\";", "refactored_code": "    private static final int CIRCULAR_REF_ERROR_CODE = 0xFFFFFFC4;\n        // value expression that might appear in a formula.  In addition these error strings should\n        // look unlike the standard Excel errors.  Hence tilde ('~') was used.\n        switch(errorCode) {\n            case CIRCULAR_REF_ERROR_CODE: return \"~CIRCULAR~REF~\";\n            case FUNCTION_NOT_IMPLEMENTED_CODE: return \"~FUNCTION~NOT~IMPLEMENTED~\";\n        }\n        return \"~non~std~err(\" + errorCode + \")~\";"}
{"magic_number_smell": "     * @throws RuntimeException if the bounds are exceeded.\n     */\n    private static void checkBounds(int cellIndex) {\n        if (cellIndex < 0 || cellIndex > SpreadsheetVersion.EXCEL97.getLastColumnIndex()) {\n            throw new IllegalArgumentException(\"Invalid column index (\" + cellIndex\n                    + \").  Allowable column range for \" + FILE_FORMAT_NAME + \" is (0..\"\n                    + SpreadsheetVersion.EXCEL97.getLastColumnIndex() + \") or ('A'..'\" + LAST_COLUMN_NAME + \"')\");", "refactored_code": "    public static final int LAST_COLUMN_NUMBER  = SpreadsheetVersion.EXCEL97.getLastColumnIndex(); // 2^8 - 1\n     * @throws RuntimeException if the bounds are exceeded.\n     */\n    private static void checkBounds(int cellIndex) {\n        if (cellIndex < 0 || cellIndex > LAST_COLUMN_NUMBER) {\n            throw new IllegalArgumentException(\"Invalid column index (\" + cellIndex\n                    + \").  Allowable column range for \" + FILE_FORMAT_NAME + \" is (0..\"\n                    + LAST_COLUMN_NUMBER + \") or ('A'..'\" + LAST_COLUMN_NAME + \"')\");"}
{"magic_number_smell": "\n        //Need to check what the font is currently, so we can reapply it after\n        //the range is completed\n        short currentFont = 0;\n        if (endIndex != length()) {\n          currentFont = this.getFontAtIndex(endIndex);\n        }", "refactored_code": "    public static final short NO_FONT = 0;\n\n        //Need to check what the font is currently, so we can reapply it after\n        //the range is completed\n        short currentFont = NO_FONT;\n        if (endIndex != length()) {\n          currentFont = this.getFontAtIndex(endIndex);\n        }"}
{"magic_number_smell": "        CellValueRecordInterface[] cvals = sheet.getValueRecords();\n        long timestart = System.currentTimeMillis();\n\n        if (log.check( POILogger.POILogger.DEBUG ))\n            log.log(POILogger.DEBUG, \"Time at start of cell creating in HSSF sheet = \",\n                Long.valueOf(timestart));\n        HSSFRow lastrow = null;", "refactored_code": "    private static final int DEBUG = POILogger.DEBUG;\n        CellValueRecordInterface[] cvals = sheet.getValueRecords();\n        long timestart = System.currentTimeMillis();\n\n        if (log.check( POILogger.DEBUG ))\n            log.log(DEBUG, \"Time at start of cell creating in HSSF sheet = \",\n                Long.valueOf(timestart));\n        HSSFRow lastrow = null;"}
{"magic_number_smell": "\t}\n\t\n\tprivate static int readUShortAndCheck(LittleEndianInput in) {\n\t\tif (in.available() < 6) {\n\t\t\t// Ran out of data\n\t\t\tthrow new RuntimeException(\"Ran out of data reading CellRangeAddress\");\n\t\t}", "refactored_code": "\tpublic static final int ENCODED_SIZE = 6;\n\t}\n\t\n\tprivate static int readUShortAndCheck(LittleEndianInput in) {\n\t\tif (in.available() < ENCODED_SIZE) {\n\t\t\t// Ran out of data\n\t\t\tthrow new RuntimeException(\"Ran out of data reading CellRangeAddress\");\n\t\t}"}
{"magic_number_smell": "    /** Most files use 512 bytes as their big block size */\n    public static final int 0x0200 = 0x0200;\n    public static final POIFSBigBlockSize SMALLER_BIG_BLOCK_SIZE_DETAILS = \n       new POIFSBigBlockSize(0x0200, (short)9);\n    /** Some use 4096 bytes */\n    public static final int LARGER_BIG_BLOCK_SIZE = 0x1000;\n    public static final POIFSBigBlockSize LARGER_BIG_BLOCK_SIZE_DETAILS = ", "refactored_code": "    public static final int SMALLER_BIG_BLOCK_SIZE = 0x0200;\n    /** Most files use 512 bytes as their big block size */\n    public static final int SMALLER_BIG_BLOCK_SIZE = 0x0200;\n    public static final POIFSBigBlockSize SMALLER_BIG_BLOCK_SIZE_DETAILS = \n       new POIFSBigBlockSize(SMALLER_BIG_BLOCK_SIZE, (short)9);\n    /** Some use 4096 bytes */\n    public static final int LARGER_BIG_BLOCK_SIZE = 0x1000;\n    public static final POIFSBigBlockSize LARGER_BIG_BLOCK_SIZE_DETAILS = "}
{"magic_number_smell": "\tpublic int read() throws IOException {\n\t\tdieIfClosed();\n\t\tif (atEOD()) {\n\t\t\treturn -1;\n\t\t}\n\t\tint result = _currentBlock.readUByte();\n\t\t_current_offset++;", "refactored_code": "\tprivate static final int EOF = -1;\n\tpublic int read() throws IOException {\n\t\tdieIfClosed();\n\t\tif (atEOD()) {\n\t\t\treturn EOF;\n\t\t}\n\t\tint result = _currentBlock.readUByte();\n\t\t_current_offset++;"}
{"magic_number_smell": "                + \" instead\");\n        }\n\n        if (block_count > 65535) {\n            throw new IOException(\"Block count \" + block_count \n                    + \" is too high. POI maximum is \" + 65535 + \".\");\n        }", "refactored_code": "    private static final int MAX_BLOCK_COUNT = 65535;\n                + \" instead\");\n        }\n\n        if (block_count > MAX_BLOCK_COUNT) {\n            throw new IOException(\"Block count \" + block_count \n                    + \" is too high. POI maximum is \" + MAX_BLOCK_COUNT + \".\");\n        }"}
{"magic_number_smell": "\n    private byte[]            _data;\n    private static final byte _default_fill         = ( byte ) 0xff;\n    private static final int  _block_size           = 1 << 6;\n    private static final int BLOCK_MASK = _block_size-1;\n\n    //private final int  _blocks_per_big_block;", "refactored_code": "    private static final int BLOCK_SHIFT = 6;\n\n    private byte[]            _data;\n    private static final byte _default_fill         = ( byte ) 0xff;\n    private static final int  _block_size           = 1 << BLOCK_SHIFT;\n    private static final int BLOCK_MASK = _block_size-1;\n\n    //private final int  _blocks_per_big_block;"}
{"magic_number_smell": "    private static final Pattern PERCENTS = Pattern.compile(\"%\");\n\n    private static final double 1.0 / 24.0 = 1.0 / 24.0;\n    private static final double MIN__FACTOR = 1.0 / 24.0 / 60.0;\n    private static final double SEC__FACTOR = MIN__FACTOR / 60.0;\n\n    private static class TimeSpec {", "refactored_code": "    private static final double HOUR__FACTOR = 1.0 / 24.0;\n    private static final Pattern PERCENTS = Pattern.compile(\"%\");\n\n    private static final double HOUR__FACTOR = 1.0 / 24.0;\n    private static final double MIN__FACTOR = HOUR__FACTOR / 60.0;\n    private static final double SEC__FACTOR = MIN__FACTOR / 60.0;\n\n    private static class TimeSpec {"}
{"magic_number_smell": "                        break;\n                    posTweak = 1;\n                    //noinspection fallthrough\n                case StringMod.1:\n                    output.insert(modPos + posTweak, nextChange.toAdd);\n                    break;\n", "refactored_code": "        public static final int BEFORE = 1;\n                        break;\n                    posTweak = 1;\n                    //noinspection fallthrough\n                case StringMod.BEFORE:\n                    output.insert(modPos + posTweak, nextChange.toAdd);\n                    break;\n"}
{"magic_number_smell": "    private static final int 60 = 60;\n    private static final int MINUTES_PER_HOUR = 60;\n    private static final int HOURS_PER_DAY = 24;\n    private static final int SECONDS_PER_DAY = (HOURS_PER_DAY * MINUTES_PER_HOUR * 60);\n\n    private static final long   DAY_MILLISECONDS = SECONDS_PER_DAY * 1000L;\n", "refactored_code": "    private static final int SECONDS_PER_MINUTE = 60;\n    private static final int SECONDS_PER_MINUTE = 60;\n    private static final int MINUTES_PER_HOUR = 60;\n    private static final int HOURS_PER_DAY = 24;\n    private static final int SECONDS_PER_DAY = (HOURS_PER_DAY * MINUTES_PER_HOUR * SECONDS_PER_MINUTE);\n\n    private static final long   DAY_MILLISECONDS = SECONDS_PER_DAY * 1000L;\n"}
{"magic_number_smell": "     */\n    public static final String getText(int errorCode) {\n        switch(errorCode) {\n            case 0x00:  return \"#NULL!\";\n            case ERROR_DIV_0: return \"#DIV/0!\";\n            case ERROR_VALUE: return \"#VALUE!\";\n            case ERROR_REF:   return \"#REF!\";", "refactored_code": "    public static final int ERROR_NULL = 0x00;\n     */\n    public static final String getText(int errorCode) {\n        switch(errorCode) {\n            case ERROR_NULL:  return \"#NULL!\";\n            case ERROR_DIV_0: return \"#DIV/0!\";\n            case ERROR_VALUE: return \"#VALUE!\";\n            case ERROR_REF:   return \"#REF!\";"}
{"magic_number_smell": "\t}\n\n\tprivate static int readUShortAndCheck(RecordInputStream in) {\n\t\tif (in.remaining() < 8) {\n\t\t\t// Ran out of data\n\t\t\tthrow new RuntimeException(\"Ran out of data reading CellRangeAddress\");\n\t\t}", "refactored_code": "\tpublic static final int ENCODED_SIZE = 8;\n\t}\n\n\tprivate static int readUShortAndCheck(RecordInputStream in) {\n\t\tif (in.remaining() < ENCODED_SIZE) {\n\t\t\t// Ran out of data\n\t\t\tthrow new RuntimeException(\"Ran out of data reading CellRangeAddress\");\n\t\t}"}
{"magic_number_smell": "final class IEEEDouble {\n\tprivate static final int  52 = 52;\n\tpublic static final long FRAC_MASK = 0x000FFFFFFFFFFFFFL;\n\tpublic static final long FRAC_ASSUMED_HIGH_BIT = ( 1L<<52 );\n}\n", "refactored_code": "\tprivate static final int  EXPONENT_SHIFT = 52;\nfinal class IEEEDouble {\n\tprivate static final int  EXPONENT_SHIFT = 52;\n\tpublic static final long FRAC_MASK = 0x000FFFFFFFFFFFFFL;\n\tpublic static final long FRAC_ASSUMED_HIGH_BIT = ( 1L<<EXPONENT_SHIFT );\n}\n"}
{"magic_number_smell": "\n\tpublic void normalise64bit() {\n\t\tint oldBitLen = _significand.bitLength();\n\t\tint sc = oldBitLen - 64;\n\t\tif (sc == 0) {\n\t\t\treturn;\n\t\t}", "refactored_code": "\tprivate static final int C_64 = 64;\n\n\tpublic void normalise64bit() {\n\t\tint oldBitLen = _significand.bitLength();\n\t\tint sc = oldBitLen - C_64;\n\t\tif (sc == 0) {\n\t\t\treturn;\n\t\t}"}
{"magic_number_smell": "\t * @return the number of powers of 10 which have been extracted from the significand and binary exponent.\n\t */\n\tpublic int getDecimalExponent() {\n\t\treturn _relativeDecimalExponent+14;\n\t}\n\n\tpublic BigDecimal getFractionalPart() {", "refactored_code": "\tprivate static final int EXPONENT_OFFSET = 14;\n\t * @return the number of powers of 10 which have been extracted from the significand and binary exponent.\n\t */\n\tpublic int getDecimalExponent() {\n\t\treturn _relativeDecimalExponent+EXPONENT_OFFSET;\n\t}\n\n\tpublic BigDecimal getFractionalPart() {"}
{"magic_number_smell": "\t\t\t// Special number NaN /Infinity\n\t\t\t// Normally one would not create HybridDecimal objects from these values\n\t\t\t// except in these cases Excel really tries to render them as if they were normal numbers\n\t\t\tif(rawBits == 0xFFFF0420003C0000L) {\n\t\t\t\treturn \"3.484840871308E+308\";\n\t\t\t}\n\t\t\t// This is where excel really gets it wrong", "refactored_code": "\tprivate static final long EXCEL_NAN_BITS = 0xFFFF0420003C0000L;\n\t\t\t// Special number NaN /Infinity\n\t\t\t// Normally one would not create HybridDecimal objects from these values\n\t\t\t// except in these cases Excel really tries to render them as if they were normal numbers\n\t\t\tif(rawBits == EXCEL_NAN_BITS) {\n\t\t\t\treturn \"3.484840871308E+308\";\n\t\t\t}\n\t\t\t// This is where excel really gets it wrong"}
{"magic_number_smell": "    public ByteField(final int offset)\n        throws ArrayIndexOutOfBoundsException\n    {\n        this(offset, 0);\n    }\n\n    /**", "refactored_code": "    private static final byte _default_value = 0;\n    public ByteField(final int offset)\n        throws ArrayIndexOutOfBoundsException\n    {\n        this(offset, _default_value);\n    }\n\n    /**"}
{"magic_number_smell": "\n    public IntList()\n    {\n        this(128);\n    }\n\n    public IntList(final int initialCapacity)", "refactored_code": "    private static final int _default_size = 128;\n\n    public IntList()\n    {\n        this(_default_size);\n    }\n\n    public IntList(final int initialCapacity)"}
{"magic_number_smell": "\n    public IntMapper()\n    {\n        this(10);\n    }\n\n    public IntMapper(final int initialCapacity)", "refactored_code": "  private static final int _default_size = 10;\n\n    public IntMapper()\n    {\n        this(_default_size);\n    }\n\n    public IntMapper(final int initialCapacity)"}
{"magic_number_smell": "        String ret = \"\";\n        ret += ((Attributes & FILE_ATTRIBUTE_DIRECTORY) != 0 || IsDirectory) ?\n            kDirectoryAttributeChar: kEmptyAttributeChar;\n        ret += ((Attributes & 0x00000001) != 0)?\n            kReadonlyAttributeChar: kEmptyAttributeChar;\n        ret += ((Attributes & FILE_ATTRIBUTE_HIDDEN) != 0) ?\n            kHiddenAttributeChar: kEmptyAttributeChar;", "refactored_code": "    static public final int FILE_ATTRIBUTE_READONLY =            0x00000001  ;\n        String ret = \"\";\n        ret += ((Attributes & FILE_ATTRIBUTE_DIRECTORY) != 0 || IsDirectory) ?\n            kDirectoryAttributeChar: kEmptyAttributeChar;\n        ret += ((Attributes & FILE_ATTRIBUTE_READONLY) != 0)?\n            kReadonlyAttributeChar: kEmptyAttributeChar;\n        ret += ((Attributes & FILE_ATTRIBUTE_HIDDEN) != 0) ?\n            kHiddenAttributeChar: kEmptyAttributeChar;"}
{"magic_number_smell": "    \n    int ReadNum()  throws IOException { // CNum\n        long value64 = ReadNumber();\n        if (value64 > InArchive.0x7FFFFFFF)\n            throw new IOException(\"ReadNum - value > CNum.0x7FFFFFFF\"); // return E_FAIL;\n        \n        return (int)value64;", "refactored_code": "    static public final int kNumMax = 0x7FFFFFFF;\n    \n    int ReadNum()  throws IOException { // CNum\n        long value64 = ReadNumber();\n        if (value64 > InArchive.kNumMax)\n            throw new IOException(\"ReadNum - value > CNum.kNumMax\"); // return E_FAIL;\n        \n        return (int)value64;"}
{"magic_number_smell": "    InBuffer _jumpStream = new InBuffer();\n    \n    org.j7zip.SevenZip.Compression.RangeCoder.BitDecoder _statusE8Decoder[] = new org.j7zip.SevenZip.Compression.RangeCoder.BitDecoder[256];\n    org.j7zip.SevenZip.Compression.RangeCoder.BitDecoder _statusE9Decoder = new org.j7zip.SevenZip.Compression.RangeCoder.BitDecoder(5);\n    org.j7zip.SevenZip.Compression.RangeCoder.BitDecoder _statusJccDecoder = new org.j7zip.SevenZip.Compression.RangeCoder.BitDecoder(5);\n    \n    OutWindow _outStream = new OutWindow();", "refactored_code": "    public static final int kNumMoveBits = 5;\n    InBuffer _jumpStream = new InBuffer();\n    \n    org.j7zip.SevenZip.Compression.RangeCoder.BitDecoder _statusE8Decoder[] = new org.j7zip.SevenZip.Compression.RangeCoder.BitDecoder[256];\n    org.j7zip.SevenZip.Compression.RangeCoder.BitDecoder _statusE9Decoder = new org.j7zip.SevenZip.Compression.RangeCoder.BitDecoder(kNumMoveBits);\n    org.j7zip.SevenZip.Compression.RangeCoder.BitDecoder _statusJccDecoder = new org.j7zip.SevenZip.Compression.RangeCoder.BitDecoder(kNumMoveBits);\n    \n    OutWindow _outStream = new OutWindow();"}
{"magic_number_smell": "                case VIGNES:\n                    p.put(\"landuse\", \"vineyard\");\n                    break;\n                case 0:\n                case BLE_TENDRE:\n                case MAIS_GRAIN_ET_ENSILAGE:\n                case ORGE:", "refactored_code": "    protected static final int PAS_D_INFORMATION = 0;\n                case VIGNES:\n                    p.put(\"landuse\", \"vineyard\");\n                    break;\n                case PAS_D_INFORMATION:\n                case BLE_TENDRE:\n                case MAIS_GRAIN_ET_ENSILAGE:\n                case ORGE:"}
{"magic_number_smell": "        setLicense(new ParisLicense());\n        try {\n            if (documentId > 0) {\n                setLocalPortalURL(PORTAL + \"jsp/site/Portal.jsp?document_id=\"+documentId + \"&portlet_id=\"+106);\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();", "refactored_code": "    private static final int portletId = 106; // FIXME\n        setLicense(new ParisLicense());\n        try {\n            if (documentId > 0) {\n                setLocalPortalURL(PORTAL + \"jsp/site/Portal.jsp?document_id=\"+documentId + \"&portlet_id=\"+portletId);\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();"}
{"magic_number_smell": "        scrollPane.setColumnHeaderView(new JPanel() {\n            @Override\n            public Dimension getPreferredSize() {\n                return new Dimension(contentPanel.getWidth(), 20);\n            }\n\n            @Override", "refactored_code": "    private static final int DAY_AXIS_HEIGHT = 20;\n        scrollPane.setColumnHeaderView(new JPanel() {\n            @Override\n            public Dimension getPreferredSize() {\n                return new Dimension(contentPanel.getWidth(), DAY_AXIS_HEIGHT);\n            }\n\n            @Override"}
{"magic_number_smell": "\n    // Calculate where the Component was clicked and returns the transformtype\n    private int getTransformType(MouseEvent evt) {\n        int tmpClickAreaWidth = Math.min(16, getWidth() / 3);\n        int tmpClickAreaHeight = Math.min(16, getHeight() / 3);\n\n        boolean isInNorthernTransformClickArea = evt.getY() < tmpClickAreaHeight;", "refactored_code": "    private final int clickAreaSize = 16;\n\n    // Calculate where the Component was clicked and returns the transformtype\n    private int getTransformType(MouseEvent evt) {\n        int tmpClickAreaWidth = Math.min(clickAreaSize, getWidth() / 3);\n        int tmpClickAreaHeight = Math.min(clickAreaSize, getHeight() / 3);\n\n        boolean isInNorthernTransformClickArea = evt.getY() < tmpClickAreaHeight;"}
{"magic_number_smell": "\n            Logging.info(\"Osm Inspector Features size: \" + features.size());\n\n            OSMIFeatureTracker tracker = arrFeatures.get(idx - 1);\n            tracker.mergeFeatures(features);\n\n            FeatureIterator<SimpleFeature> it = tracker.getFeatures().features();", "refactored_code": "    private final int layerOffset = 1;\n\n            Logging.info(\"Osm Inspector Features size: \" + features.size());\n\n            OSMIFeatureTracker tracker = arrFeatures.get(idx - layerOffset);\n            tracker.mergeFeatures(features);\n\n            FeatureIterator<SimpleFeature> it = tracker.getFeatures().features();"}
{"magic_number_smell": "            distScale = 10.0 / distMantissa;\n        }\n\n        Font labelFont = new Font(\"Arial\", Font.PLAIN, 8);\n        g2d.setFont(labelFont);\n\n        /* length of scale */", "refactored_code": "    public static final int FONT_SIZE = 8;\n            distScale = 10.0 / distMantissa;\n        }\n\n        Font labelFont = new Font(\"Arial\", Font.PLAIN, FONT_SIZE);\n        g2d.setFont(labelFont);\n\n        /* length of scale */"}
{"magic_number_smell": "    private static final double 2000 = 2000; // ~ 26m\n    private RelationMember getClosestPlatform(List<RelationMember> members, Node stop) {\n        if (stop == null || members.isEmpty()) return null;\n        double maxDist = 2000;\n        RelationMember result = null;\n        for (RelationMember member : members) {\n            if (member.getType() == OsmPrimitiveType.NODE) {", "refactored_code": "    private static final double maxSqrDistBetweenStopAndPlatform = 2000; // ~ 26m\n    private static final double maxSqrDistBetweenStopAndPlatform = 2000; // ~ 26m\n    private RelationMember getClosestPlatform(List<RelationMember> members, Node stop) {\n        if (stop == null || members.isEmpty()) return null;\n        double maxDist = maxSqrDistBetweenStopAndPlatform;\n        RelationMember result = null;\n        for (RelationMember member : members) {\n            if (member.getType() == OsmPrimitiveType.NODE) {"}
{"magic_number_smell": "            return;\n        }\n\n        //double totalWidth = 5 + (colors.size() - 1) * 4;\n        //double width = totalWidth / colors.size();\n        //double shift = -totalWidth / 2 + width / 2;\n        double width = 5;", "refactored_code": "    private static final float LINE_WIDTH = 5;\n            return;\n        }\n\n        //double totalWidth = LINE_WIDTH + (colors.size() - 1) * 4;\n        //double width = totalWidth / colors.size();\n        //double shift = -totalWidth / 2 + width / 2;\n        double width = LINE_WIDTH;"}
{"magic_number_smell": "            return;\n        }\n\n        double totalWidth = 10 + (routes.size() - 1) * 4;\n        double width = totalWidth / routes.cardinality();\n        double shift = -totalWidth / 2 + width / 2;\n", "refactored_code": "    private static final float LINE_WIDTH = 10;\n            return;\n        }\n\n        double totalWidth = LINE_WIDTH + (routes.size() - 1) * 4;\n        double width = totalWidth / routes.cardinality();\n        double shift = -totalWidth / 2 + width / 2;\n"}
{"magic_number_smell": "        g2d.drawLine(from.x, from.y, to.x, to.y);\n        if (showDirection) {\n            double t = Math.atan2(to.y-from.y, to.x-from.x) + Math.PI;\n            g.drawLine(to.x, to.y, (int) (to.x + 10*Math.cos(t-Math.toRadians(20))), (int) (to.y + 10*Math.sin(t-Math.toRadians(20))));\n            g.drawLine(to.x, to.y, (int) (to.x + 10*Math.cos(t+Math.toRadians(20))), (int) (to.y + 10*Math.sin(t+Math.toRadians(20))));\n        }\n        g2d.setStroke(oldStroke);", "refactored_code": "    private static final double ARROW_PHI = Math.toRadians(20);\n        g2d.drawLine(from.x, from.y, to.x, to.y);\n        if (showDirection) {\n            double t = Math.atan2(to.y-from.y, to.x-from.x) + Math.PI;\n            g.drawLine(to.x, to.y, (int) (to.x + 10*Math.cos(t-ARROW_PHI)), (int) (to.y + 10*Math.sin(t-ARROW_PHI)));\n            g.drawLine(to.x, to.y, (int) (to.x + 10*Math.cos(t+ARROW_PHI)), (int) (to.y + 10*Math.sin(t+ARROW_PHI)));\n        }\n        g2d.setStroke(oldStroke);"}
{"magic_number_smell": "            // Search for the nearest node in the list\n            List<Node> nl = routingModel.getSelectedNodes();\n            index = -1;\n            double dmax = 100; // maximum distance, in pixels\n            for (int i = 0; i < nl.size(); i++) {\n                Node node = nl.get(i);\n                double d = MainApplication.getMap().mapView.getPoint(node).distanceSq(e.getPoint());", "refactored_code": "    private static final int DRAG_SQR_RADIUS = 100;\n            // Search for the nearest node in the list\n            List<Node> nl = routingModel.getSelectedNodes();\n            index = -1;\n            double dmax = DRAG_SQR_RADIUS; // maximum distance, in pixels\n            for (int i = 0; i < nl.size(); i++) {\n                Node node = nl.get(i);\n                double d = MainApplication.getMap().mapView.getPoint(node).distanceSq(e.getPoint());"}
{"magic_number_smell": "            // Search for the nearest node in the list\n            List<Node> nl = routingModel.getSelectedNodes();\n            int index = -1;\n            double dmax = 100; // maximum distance, in pixels\n            for (int i = 0; i < nl.size(); i++) {\n                Node node = nl.get(i);\n                double d = MainApplication.getMap().mapView.getPoint(node).distanceSq(e.getPoint());", "refactored_code": "    private static final int REMOVE_SQR_RADIUS = 100;\n            // Search for the nearest node in the list\n            List<Node> nl = routingModel.getSelectedNodes();\n            int index = -1;\n            double dmax = REMOVE_SQR_RADIUS; // maximum distance, in pixels\n            for (int i = 0; i < nl.size(); i++) {\n                Node node = nl.get(i);\n                double d = MainApplication.getMap().mapView.getPoint(node).distanceSq(e.getPoint());"}
{"magic_number_smell": "     * @return the max number of retries\n     */\n    protected int getMaxRetries() {\n        int ret = Config.getPref().getInt(\"osm-server.max-num-retries\", 5);\n        return Math.max(ret, 0);\n    }\n", "refactored_code": "    public static final int DEFAULT_MAX_NUM_RETRIES = 5;\n     * @return the max number of retries\n     */\n    protected int getMaxRetries() {\n        int ret = Config.getPref().getInt(\"osm-server.max-num-retries\", DEFAULT_MAX_NUM_RETRIES);\n        return Math.max(ret, 0);\n    }\n"}
{"magic_number_smell": "//----------------------------------------------------------------------\n/**\n * Returns the next token from the reader. The token's value may be\n * WORD, QUOTED_WORD, -1, EOL, or DELIMITER. In the case or WORD or\n * QUOTED_WORD the actual word can be obtained by the use of the\n * getWord method.\n *", "refactored_code": "  public static final int EOF = -1;\n//----------------------------------------------------------------------\n/**\n * Returns the next token from the reader. The token's value may be\n * WORD, QUOTED_WORD, EOF, EOL, or DELIMITER. In the case or WORD or\n * QUOTED_WORD the actual word can be obtained by the use of the\n * getWord method.\n *"}
{"magic_number_smell": "     * Using the given dialog and the default timeout.\n     */\n    public DialogClosingThread(JDialog dialog) {\n        this(dialog, 5000);\n    }\n\n    public DialogClosingThread(JDialog dialog, long timeout) {", "refactored_code": "    public static final long DEFAULT_TIMEOUT = 5000;\n     * Using the given dialog and the default timeout.\n     */\n    public DialogClosingThread(JDialog dialog) {\n        this(dialog, DEFAULT_TIMEOUT);\n    }\n\n    public DialogClosingThread(JDialog dialog, long timeout) {"}
{"magic_number_smell": "    private double reputation;\n\n    public TrustSignatures() {\n        this.status = 0;\n    }\n\n    public TrustSignatures(PGPSignature signature, String sigtext, byte status) {", "refactored_code": "    public static final byte SIG_UNKNOWN = 0;\n    private double reputation;\n\n    public TrustSignatures() {\n        this.status = SIG_UNKNOWN;\n    }\n\n    public TrustSignatures(PGPSignature signature, String sigtext, byte status) {"}
{"magic_number_smell": "        final double delta = normalize(leftAngle - rightAngle);\n\n        final boolean wide = delta > PI;\n        final double a = wide ? max(0, delta - (PI + 2 * Math.toRadians(30))) : delta;\n\n        final double cpf1 = cpf(a, container.getLaneWidth() / 5 + (wide ? right.roadGui.getWidth(right.roadEnd) : 0));\n        final double cpf2 = cpf(a, container.getLaneWidth() / 5 + (wide ? left.roadGui.getWidth(left.roadEnd) : 0));", "refactored_code": "    private static final double MAX_ANGLE = Math.toRadians(30);\n        final double delta = normalize(leftAngle - rightAngle);\n\n        final boolean wide = delta > PI;\n        final double a = wide ? max(0, delta - (PI + 2 * MAX_ANGLE)) : delta;\n\n        final double cpf1 = cpf(a, container.getLaneWidth() / 5 + (wide ? right.roadGui.getWidth(right.roadEnd) : 0));\n        final double cpf2 = cpf(a, container.getLaneWidth() / 5 + (wide ? left.roadGui.getWidth(left.roadEnd) : 0));"}
{"magic_number_smell": "\n        getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_F5, 0), \"refresh\");\n        getActionMap().put(\"refresh\", new AbstractAction() {\n            private static final long 6917061040674799271L = 1L;\n\n            @Override\n            public void actionPerformed(ActionEvent e) {", "refactored_code": "    private static final long serialVersionUID = 6917061040674799271L;\n\n        getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_F5, 0), \"refresh\");\n        getActionMap().put(\"refresh\", new AbstractAction() {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            public void actionPerformed(ActionEvent e) {"}
{"magic_number_smell": "    }\n\n    private class ValidateAction extends JosmAction {\n        private static final long 4114119073563457706L = 7510740945725851427L;\n\n        ValidateAction() {\n            super(tr(\"Validate\"), \"dialogs/validator\", tr(\"Validate turn- and lane-length-relations for consistency.\"),", "refactored_code": "        private static final long serialVersionUID = 4114119073563457706L;\n    }\n\n    private class ValidateAction extends JosmAction {\n        private static final long serialVersionUID = 7510740945725851427L;\n\n        ValidateAction() {\n            super(tr(\"Validate\"), \"dialogs/validator\", tr(\"Validate turn- and lane-length-relations for consistency.\"),"}
{"magic_number_smell": "\n    private final Action refreshAction = new JosmAction(tr(\"Refresh\"), \"dialogs/refresh\",\n        tr(\"Revalidate all turnlanes-relations.\"), null, false) {\n        private static final long -1585778734201458665L = -8110599654128234810L;\n\n        @Override\n        public void actionPerformed(ActionEvent e) {", "refactored_code": "    private static final long serialVersionUID = -1585778734201458665L;\n\n    private final Action refreshAction = new JosmAction(tr(\"Refresh\"), \"dialogs/refresh\",\n        tr(\"Revalidate all turnlanes-relations.\"), null, false) {\n        private static final long serialVersionUID = -8110599654128234810L;\n\n        @Override\n        public void actionPerformed(ActionEvent e) {"}
{"magic_number_smell": "        // initial matching is empty\n        xy = new int[N];\n        yx = new int[N];\n        for (int i = 0; i < N; i++) xy[i] = -1;\n        for (int j = 0; j < N; j++) yx[j] = -1;\n\n        // add N edges to matching", "refactored_code": "    private static final int UNMATCHED = -1;\n        // initial matching is empty\n        xy = new int[N];\n        yx = new int[N];\n        for (int i = 0; i < N; i++) xy[i] = UNMATCHED;\n        for (int j = 0; j < N; j++) yx[j] = UNMATCHED;\n\n        // add N edges to matching"}
{"magic_number_smell": "            }\n\n            // Add the command to move the node to its new position.\n            if (Math.abs(nx - n.getEastNorth().east()) > 1e-9 && Math.abs(ny - n.getEastNorth().north()) > 1e-9)\n                commands.add(new MoveCommand(n, nx - n.getEastNorth().east(), ny - n.getEastNorth().north()));\n        }\n", "refactored_code": "    private static final double MOVE_THRESHOLD = 1e-9;\n            }\n\n            // Add the command to move the node to its new position.\n            if (Math.abs(nx - n.getEastNorth().east()) > MOVE_THRESHOLD && Math.abs(ny - n.getEastNorth().north()) > MOVE_THRESHOLD)\n                commands.add(new MoveCommand(n, nx - n.getEastNorth().east(), ny - n.getEastNorth().north()));\n        }\n"}
{"magic_number_smell": "\n        if (pattern.matches(\"Ro?,?Ro?\")) {\n            setLatLonObj(latLon,\n                    params[0], 0.0, 0.0, \"N\",\n                    params[1], 0.0, 0.0, \"E\");\n        } else if (pattern.matches(\"xRo?,?xRo?\")) {\n            setLatLonObj(latLon,", "refactored_code": "    private static final double ZERO = 0.0;\n\n        if (pattern.matches(\"Ro?,?Ro?\")) {\n            setLatLonObj(latLon,\n                    params[0], ZERO, ZERO, \"N\",\n                    params[1], ZERO, ZERO, \"E\");\n        } else if (pattern.matches(\"xRo?,?xRo?\")) {\n            setLatLonObj(latLon,"}
{"magic_number_smell": "            /* Build a new buffer */\n            /* double freq = 20 * Math.pow(1.3, rpm * 5.0); */\n            double freq = (rpm - 0.1) * 160.0;\n            int wavelen = (int) (44100 / freq);\n            int bufferlen = MIN_BUFFER - (MIN_BUFFER % wavelen) +\n                    wavelen;\n            int value = (int) (0x7fff * volume);", "refactored_code": "    protected static final int S_RATE = 44100;\n            /* Build a new buffer */\n            /* double freq = 20 * Math.pow(1.3, rpm * 5.0); */\n            double freq = (rpm - 0.1) * 160.0;\n            int wavelen = (int) (S_RATE / freq);\n            int bufferlen = MIN_BUFFER - (MIN_BUFFER % wavelen) +\n                    wavelen;\n            int value = (int) (0x7fff * volume);"}
{"magic_number_smell": "\t}\n\t\n\tprotected void updatePitch() {\n\t\tfloat flatzoomfraction = (400 - zoomFactor) / 400;\n\t\tthis.ModifiedPitchAngle = UserPitchAngle * flatzoomfraction;\n\n\t\tQuaternion pitch = new Quaternion();", "refactored_code": "\tprotected final float flatzoom = 400;\n\t}\n\t\n\tprotected void updatePitch() {\n\t\tfloat flatzoomfraction = (flatzoom - zoomFactor) / flatzoom;\n\t\tthis.ModifiedPitchAngle = UserPitchAngle * flatzoomfraction;\n\n\t\tQuaternion pitch = new Quaternion();"}
{"magic_number_smell": "\n\tpublic class Chebyshev implements Heuristic, Serializable {\n\n\t\tprivate static final long 1 = 1;\n\n\t\tpublic float estimate(MapCoordinate StartCoord, MapCoordinate GoalCoord) {\n\t\t\tfloat max = 0;", "refactored_code": "\t\tprivate static final long serialVersionUID = 1;\n\n\tpublic class Chebyshev implements Heuristic, Serializable {\n\n\t\tprivate static final long serialVersionUID = 1;\n\n\t\tpublic float estimate(MapCoordinate StartCoord, MapCoordinate GoalCoord) {\n\t\t\tfloat max = 0;"}
{"magic_number_smell": "\n\tprotected class Profile implements Serializable { // stores data from profiling\n\n\t\tprivate static final long 1 = 1;\n\t\tProfileResultCode ResultCode = ProfileResultCode.PATH_CODE_NO_DATA;\n\t\tlong PathTimeCost = 0;\n\t\tint PathGraphReads = 0;", "refactored_code": "\tprivate static final long serialVersionUID = 1;\n\n\tprotected class Profile implements Serializable { // stores data from profiling\n\n\t\tprivate static final long serialVersionUID = 1;\n\t\tProfileResultCode ResultCode = ProfileResultCode.PATH_CODE_NO_DATA;\n\t\tlong PathTimeCost = 0;\n\t\tint PathGraphReads = 0;"}
{"magic_number_smell": "  // Limits on the number of bits this algorithm can utilize\n  private static final int 15 = 15;\n\n  private static final int MAXFFTSIZE = 1 << 15;\n  private static final double TWOPI = 2.0 * Math.PI;\n\n  private int[] bitreverse = new int[MAXFFTSIZE];", "refactored_code": "  private static final int LOG2_MAXFFTSIZE = 15;\n  // Limits on the number of bits this algorithm can utilize\n  private static final int LOG2_MAXFFTSIZE = 15;\n\n  private static final int MAXFFTSIZE = 1 << LOG2_MAXFFTSIZE;\n  private static final double TWOPI = 2.0 * Math.PI;\n\n  private int[] bitreverse = new int[MAXFFTSIZE];"}
{"magic_number_smell": "\n    Composite composite = new Composite(dialog, SWT.NONE);\n    composite.setLayout(new GridLayout());\n    composite.setLayoutData(new GridData(MAIN_WIDTH, SWT.DEFAULT));\n\n    // ==============================================================//\n    Composite top = new Composite(composite, SWT.NONE);", "refactored_code": "  private static final int MAIN_HEIGHT = SWT.DEFAULT;\n\n    Composite composite = new Composite(dialog, SWT.NONE);\n    composite.setLayout(new GridLayout());\n    composite.setLayoutData(new GridData(MAIN_WIDTH, MAIN_HEIGHT));\n\n    // ==============================================================//\n    Composite top = new Composite(composite, SWT.NONE);"}
{"magic_number_smell": "    FormData data = new FormData();\n    data.left = new FormAttachment(0, 0);\n    data.right = new FormAttachment(100, 0);\n    data.top = new FormAttachment(getItemManager().getCoolbar(), 5);\n    data.bottom = new FormAttachment(100, 0);\n    this.sashComposite = new Composite(composite, SWT.NONE);\n    this.sashComposite.setLayout(new FormLayout());", "refactored_code": "  public static final int MARGIN_WIDTH = 5;\n    FormData data = new FormData();\n    data.left = new FormAttachment(0, 0);\n    data.right = new FormAttachment(100, 0);\n    data.top = new FormAttachment(getItemManager().getCoolbar(), MARGIN_WIDTH);\n    data.bottom = new FormAttachment(100, 0);\n    this.sashComposite = new Composite(composite, SWT.NONE);\n    this.sashComposite.setLayout(new FormLayout());"}
{"magic_number_smell": "        return;\n      }\n\n      if ((flags & 0x01) != 0) {\n        ActionLock.lock();\n      }\n", "refactored_code": "  protected static final int AUTO_LOCK = 0x01;\n        return;\n      }\n\n      if ((flags & AUTO_LOCK) != 0) {\n        ActionLock.lock();\n      }\n"}
{"magic_number_smell": "\n      Group group = new Group(dialog, SWT.SHADOW_ETCHED_IN);\n      group.setLayout(makeGroupLayout(5));\n      group.setLayoutData(new GridData(GROUP_WIDTH, SWT.DEFAULT));\n      group.setText(TuxGuitar.getProperty(\"composition.properties\"));\n\n      // -------NAME------------------------------------", "refactored_code": "  private static final int GROUP_HEIGHT = SWT.DEFAULT;\n\n      Group group = new Group(dialog, SWT.SHADOW_ETCHED_IN);\n      group.setLayout(makeGroupLayout(5));\n      group.setLayoutData(new GridData(GROUP_WIDTH, GROUP_HEIGHT));\n      group.setText(TuxGuitar.getProperty(\"composition.properties\"));\n\n      // -------NAME------------------------------------"}
{"magic_number_smell": "\n  protected void setTempo(int tempoValue, boolean applyToAllMeasures,\n      boolean applyToEnd) {\n    if (tempoValue >= MIN_TEMPO && 320 <= 320) {\n      TGTempo tempo = new TGTempo();\n      tempo.setValue(tempoValue);\n", "refactored_code": "  private static final int MAX_TEMPO = 320;\n\n  protected void setTempo(int tempoValue, boolean applyToAllMeasures,\n      boolean applyToEnd) {\n    if (tempoValue >= MIN_TEMPO && MAX_TEMPO <= 320) {\n      TGTempo tempo = new TGTempo();\n      tempo.setValue(tempoValue);\n"}
{"magic_number_smell": "    if (beat != null) {\n      TGVoice voice = beat.getVoice(caret.getVoice());\n      TGDuration duration = getSelectedDuration();\n      if (duration.getValue() != TGDuration.EIGHTH\n          || (!voice.isEmpty() && voice.getDuration().getValue() != TGDuration.EIGHTH)) {\n        // comienza el undoable\n        UndoableMeasureGeneric undoable = UndoableMeasureGeneric.startUndo();", "refactored_code": "  public static final int VALUE = TGDuration.EIGHTH;\n    if (beat != null) {\n      TGVoice voice = beat.getVoice(caret.getVoice());\n      TGDuration duration = getSelectedDuration();\n      if (duration.getValue() != VALUE\n          || (!voice.isEmpty() && voice.getDuration().getValue() != VALUE)) {\n        // comienza el undoable\n        UndoableMeasureGeneric undoable = UndoableMeasureGeneric.startUndo();"}
{"magic_number_smell": "    if (beat != null) {\n      TGVoice voice = beat.getVoice(caret.getVoice());\n      TGDuration duration = getSelectedDuration();\n      if (duration.getValue() != TGDuration.HALF\n          || (!voice.isEmpty() && voice.getDuration().getValue() != TGDuration.HALF)) {\n        // comienza el undoable\n        UndoableMeasureGeneric undoable = UndoableMeasureGeneric.startUndo();", "refactored_code": "  public static final int VALUE = TGDuration.HALF;\n    if (beat != null) {\n      TGVoice voice = beat.getVoice(caret.getVoice());\n      TGDuration duration = getSelectedDuration();\n      if (duration.getValue() != VALUE\n          || (!voice.isEmpty() && voice.getDuration().getValue() != VALUE)) {\n        // comienza el undoable\n        UndoableMeasureGeneric undoable = UndoableMeasureGeneric.startUndo();"}
{"magic_number_smell": "    if (beat != null) {\n      TGVoice voice = beat.getVoice(caret.getVoice());\n      TGDuration duration = getSelectedDuration();\n      if (duration.getValue() != TGDuration.QUARTER\n          || (!voice.isEmpty() && voice.getDuration().getValue() != TGDuration.QUARTER)) {\n        // comienza el undoable\n        UndoableMeasureGeneric undoable = UndoableMeasureGeneric.startUndo();", "refactored_code": "  public static final int VALUE = TGDuration.QUARTER;\n    if (beat != null) {\n      TGVoice voice = beat.getVoice(caret.getVoice());\n      TGDuration duration = getSelectedDuration();\n      if (duration.getValue() != VALUE\n          || (!voice.isEmpty() && voice.getDuration().getValue() != VALUE)) {\n        // comienza el undoable\n        UndoableMeasureGeneric undoable = UndoableMeasureGeneric.startUndo();"}
{"magic_number_smell": "    if (beat != null) {\n      TGVoice voice = beat.getVoice(caret.getVoice());\n      TGDuration duration = getSelectedDuration();\n      if (duration.getValue() != TGDuration.SIXTEENTH\n          || (!voice.isEmpty() && voice.getDuration().getValue() != TGDuration.SIXTEENTH)) {\n        // comienza el undoable\n        UndoableMeasureGeneric undoable = UndoableMeasureGeneric.startUndo();", "refactored_code": "  public static final int VALUE = TGDuration.SIXTEENTH;\n    if (beat != null) {\n      TGVoice voice = beat.getVoice(caret.getVoice());\n      TGDuration duration = getSelectedDuration();\n      if (duration.getValue() != VALUE\n          || (!voice.isEmpty() && voice.getDuration().getValue() != VALUE)) {\n        // comienza el undoable\n        UndoableMeasureGeneric undoable = UndoableMeasureGeneric.startUndo();"}
{"magic_number_smell": "    if (beat != null) {\n      TGVoice voice = beat.getVoice(caret.getVoice());\n      TGDuration duration = getSelectedDuration();\n      if (duration.getValue() != TGDuration.SIXTY_FOURTH\n          || (!voice.isEmpty() && voice.getDuration().getValue() != TGDuration.SIXTY_FOURTH)) {\n        // comienza el undoable\n        UndoableMeasureGeneric undoable = UndoableMeasureGeneric.startUndo();", "refactored_code": "  public static final int VALUE = TGDuration.SIXTY_FOURTH;\n    if (beat != null) {\n      TGVoice voice = beat.getVoice(caret.getVoice());\n      TGDuration duration = getSelectedDuration();\n      if (duration.getValue() != VALUE\n          || (!voice.isEmpty() && voice.getDuration().getValue() != VALUE)) {\n        // comienza el undoable\n        UndoableMeasureGeneric undoable = UndoableMeasureGeneric.startUndo();"}
{"magic_number_smell": "    if (beat != null) {\n      TGVoice voice = beat.getVoice(caret.getVoice());\n      TGDuration duration = getSelectedDuration();\n      if (duration.getValue() != TGDuration.THIRTY_SECOND\n          || (!voice.isEmpty() && voice.getDuration().getValue() != TGDuration.THIRTY_SECOND)) {\n        // comienza el undoable\n        UndoableMeasureGeneric undoable = UndoableMeasureGeneric.startUndo();", "refactored_code": "  public static final int VALUE = TGDuration.THIRTY_SECOND;\n    if (beat != null) {\n      TGVoice voice = beat.getVoice(caret.getVoice());\n      TGDuration duration = getSelectedDuration();\n      if (duration.getValue() != VALUE\n          || (!voice.isEmpty() && voice.getDuration().getValue() != VALUE)) {\n        // comienza el undoable\n        UndoableMeasureGeneric undoable = UndoableMeasureGeneric.startUndo();"}
{"magic_number_smell": "    if (beat != null) {\n      TGVoice voice = beat.getVoice(caret.getVoice());\n      TGDuration duration = getSelectedDuration();\n      if (duration.getValue() != TGDuration.WHOLE\n          || (!voice.isEmpty() && voice.getDuration().getValue() != TGDuration.WHOLE)) {\n        // comienza el undoable\n        UndoableMeasureGeneric undoable = UndoableMeasureGeneric.startUndo();", "refactored_code": "  public static final int VALUE = TGDuration.WHOLE;\n    if (beat != null) {\n      TGVoice voice = beat.getVoice(caret.getVoice());\n      TGDuration duration = getSelectedDuration();\n      if (duration.getValue() != VALUE\n          || (!voice.isEmpty() && voice.getDuration().getValue() != VALUE)) {\n        // comienza el undoable\n        UndoableMeasureGeneric undoable = UndoableMeasureGeneric.startUndo();"}
{"magic_number_smell": "\n        if (lastAddedStart == start && lastAddedString == string) {\n          if (lastAddedValue > 0 && lastAddedValue < 10\n              && time < (lastAddedTime + 1000)) {\n            int newValue = ((lastAddedValue * 10) + value);\n            if (newValue < 30 || caret.getTrack().isPercussionTrack()) {\n              value = newValue;", "refactored_code": "  private static final int DELAY = 1000;\n\n        if (lastAddedStart == start && lastAddedString == string) {\n          if (lastAddedValue > 0 && lastAddedValue < 10\n              && time < (lastAddedTime + DELAY)) {\n            int newValue = ((lastAddedValue * 10) + value);\n            if (newValue < 30 || caret.getTrack().isPercussionTrack()) {\n              value = newValue;"}
{"magic_number_smell": "\n    final Table table = new Table(dialog, SWT.BORDER | SWT.SINGLE\n        | SWT.FULL_SELECTION | SWT.CHECK | SWT.H_SCROLL | SWT.V_SCROLL);\n    table.setLayoutData(new GridData(TABLE_WIDTH, 300));\n    table.setHeaderVisible(true);\n\n    final TableColumn columnEnabled = new TableColumn(table, SWT.LEFT);", "refactored_code": "  private static final int TABLE_HEIGHT = 300;\n\n    final Table table = new Table(dialog, SWT.BORDER | SWT.SINGLE\n        | SWT.FULL_SELECTION | SWT.CHECK | SWT.H_SCROLL | SWT.V_SCROLL);\n    table.setLayoutData(new GridData(TABLE_WIDTH, TABLE_HEIGHT));\n    table.setHeaderVisible(true);\n\n    final TableColumn columnEnabled = new TableColumn(table, SWT.LEFT);"}
{"magic_number_smell": "  }\n\n  protected String[] getAllValueNames() {\n    String[] valueNames = new String[12 * MAX_OCTAVES];\n    for (int i = 0; i < valueNames.length; i++) {\n      valueNames[i] = NOTE_NAMES[(i - ((i / 12) * 12))]\n          + (i / 12);", "refactored_code": "  private static final int MAX_NOTES = 12;\n  }\n\n  protected String[] getAllValueNames() {\n    String[] valueNames = new String[MAX_NOTES * MAX_OCTAVES];\n    for (int i = 0; i < valueNames.length; i++) {\n      valueNames[i] = NOTE_NAMES[(i - ((i / MAX_NOTES) * MAX_NOTES))]\n          + (i / MAX_NOTES);"}
{"magic_number_smell": "    this.customFrom = new Spinner(trainerGroup, SWT.BORDER);\n    this.customFrom.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));\n    this.customFrom.setMinimum(MIN_SELECTION);\n    this.customFrom.setMaximum(500);\n    this.customFrom.setSelection(mode.getCustomPercentFrom());\n    customAdapter.addControl(this.customFrom);\n    customAdapter.addControl(makeLabel(trainerGroup, \"%\", SWT.LEFT, 1));", "refactored_code": "  protected static final int MAX_SELECTION = 500;\n    this.customFrom = new Spinner(trainerGroup, SWT.BORDER);\n    this.customFrom.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));\n    this.customFrom.setMinimum(MIN_SELECTION);\n    this.customFrom.setMaximum(MAX_SELECTION);\n    this.customFrom.setSelection(mode.getCustomPercentFrom());\n    customAdapter.addControl(this.customFrom);\n    customAdapter.addControl(makeLabel(trainerGroup, \"%\", SWT.LEFT, 1));"}
{"magic_number_smell": "        this.pasteCount);\n    if (this.transferType == TRANSFER_TYPE_REPLACE) {\n      replaceMeasures(helper, segment);\n    } else if (this.transferType == 2) {\n      insertMeasures(helper, segment);\n    }\n  }", "refactored_code": "  public static final int TRANSFER_TYPE_INSERT = 2;\n        this.pasteCount);\n    if (this.transferType == TRANSFER_TYPE_REPLACE) {\n      replaceMeasures(helper, segment);\n    } else if (this.transferType == TRANSFER_TYPE_INSERT) {\n      insertMeasures(helper, segment);\n    }\n  }"}
{"magic_number_smell": "\n  public void closePath() {\n    if (!this.pathEmpty) {\n      if ((this.style & 0x01) != 0) {\n        this.gc.drawPath(this.path);\n      }\n      if ((this.style & PATH_FILL) != 0) {", "refactored_code": "  public static final int PATH_DRAW = 0x01;\n\n  public void closePath() {\n    if (!this.pathEmpty) {\n      if ((this.style & PATH_DRAW) != 0) {\n        this.gc.drawPath(this.path);\n      }\n      if ((this.style & PATH_FILL) != 0) {"}
{"magic_number_smell": "   * \n   * if the distance between lowest and highest fret is less than\n   * \n   * <i>ChordCreatorUtil.5</i>.\n   * \n   * Also note that this method eliminates or includes the chords with empty\n   * strings,", "refactored_code": "  public static final int MAX_FRET_SPAN = 5;\n   * \n   * if the distance between lowest and highest fret is less than\n   * \n   * <i>ChordCreatorUtil.MAX_FRET_SPAN</i>.\n   * \n   * Also note that this method eliminates or includes the chords with empty\n   * strings,"}
{"magic_number_smell": "    int[] tuning = findCurrentTuning(measure.getTrack());\n\n    // ---------------SELECTOR--------------------------------\n    this.selector = new ChordSelector(this, topComposite, SWT.BORDER, tuning);\n    this.selector.pack();\n\n    // ---------------EDITOR--------------------------------", "refactored_code": "  private static final int DEFAULT_STYLE = SWT.BORDER;\n    int[] tuning = findCurrentTuning(measure.getTrack());\n\n    // ---------------SELECTOR--------------------------------\n    this.selector = new ChordSelector(this, topComposite, DEFAULT_STYLE, tuning);\n    this.selector.pack();\n\n    // ---------------EDITOR--------------------------------"}
{"magic_number_smell": "    int stringIndex = getStringIndex(x);\n    int fretIndex = getFretIndex(y);\n\n    if (y < 30) {\n      this.firstFrets[stringIndex] = !this.firstFrets[stringIndex];\n      this.removePointsAtStringLine(this.strings[stringIndex]);\n    } else if (y < (30 * TGChordImpl.MAX_FRETS)) {", "refactored_code": "  public static final int FRET_SPACING = 30;\n    int stringIndex = getStringIndex(x);\n    int fretIndex = getFretIndex(y);\n\n    if (y < FRET_SPACING) {\n      this.firstFrets[stringIndex] = !this.firstFrets[stringIndex];\n      this.removePointsAtStringLine(this.strings[stringIndex]);\n    } else if (y < (FRET_SPACING * TGChordImpl.MAX_FRETS)) {"}
{"magic_number_smell": "      chord.setColor(color);\n      chord.setNoteColor(color);\n      chord.setTonicColor(getDisplay().getSystemColor(SWT.COLOR_DARK_RED));\n      chord.setFirstFretSpacing(12);\n      chord.setStringSpacing(CHORD_STRING_SPACING);\n      chord.setFretSpacing(CHORD_FRET_SPACING);\n      chord.setNoteSize(CHORD_NOTE_SIZE);", "refactored_code": "  private static final int CHORD_FIRST_FRET_SPACING = 12;\n      chord.setColor(color);\n      chord.setNoteColor(color);\n      chord.setTonicColor(getDisplay().getSystemColor(SWT.COLOR_DARK_RED));\n      chord.setFirstFretSpacing(CHORD_FIRST_FRET_SPACING);\n      chord.setStringSpacing(CHORD_STRING_SPACING);\n      chord.setFretSpacing(CHORD_FRET_SPACING);\n      chord.setNoteSize(CHORD_NOTE_SIZE);"}
{"magic_number_smell": "    current.params[ALTERATION_INDEX] = 0;\n    current.params[I9_INDEX] = plusMinus[0];\n    current.params[I11_INDEX] = plusMinus[1];\n    current.params[5] = 0;\n    current.params[PLUSMINUS_INDEX] = 0;\n\n    if (found[2]) { // -------------- 13", "refactored_code": "  protected static final int ADDCHK_INDEX = 5;\n    current.params[ALTERATION_INDEX] = 0;\n    current.params[I9_INDEX] = plusMinus[0];\n    current.params[I11_INDEX] = plusMinus[1];\n    current.params[ADDCHK_INDEX] = 0;\n    current.params[PLUSMINUS_INDEX] = 0;\n\n    if (found[2]) { // -------------- 13"}
{"magic_number_smell": "  }\n\n  private void init() {\n    this.x = new int[EffectPoint.MAX_POSITION_LENGTH + 1];\n    this.y = new int[Y_LENGTH];\n    this.width = ((X_SPACING * EffectPoint.MAX_POSITION_LENGTH + 1) - X_SPACING);\n    this.height = ((Y_SPACING * Y_LENGTH) - Y_SPACING);", "refactored_code": "  private static final int X_LENGTH = EffectPoint.MAX_POSITION_LENGTH + 1;\n  }\n\n  private void init() {\n    this.x = new int[X_LENGTH];\n    this.y = new int[Y_LENGTH];\n    this.width = ((X_SPACING * X_LENGTH) - X_SPACING);\n    this.height = ((Y_SPACING * Y_LENGTH) - Y_SPACING);"}
{"magic_number_smell": "  }\n\n  private void init() {\n    this.x = new int[EffectPoint.MAX_POSITION_LENGTH + 1];\n    this.y = new int[Y_LENGTH];\n    this.width = ((X_SPACING * EffectPoint.MAX_POSITION_LENGTH + 1) - X_SPACING);\n    this.height = ((Y_SPACING * Y_LENGTH) - Y_SPACING);", "refactored_code": "  private static final int X_LENGTH = EffectPoint.MAX_POSITION_LENGTH + 1;\n  }\n\n  private void init() {\n    this.x = new int[X_LENGTH];\n    this.y = new int[Y_LENGTH];\n    this.width = ((X_SPACING * X_LENGTH) - X_SPACING);\n    this.height = ((Y_SPACING * Y_LENGTH) - Y_SPACING);"}
{"magic_number_smell": "    int borderWidth = (2 * this.fretBoardComposite.getBorderWidth());\n    int toolBarHeight = (this.toolComposite.getBounds().height);\n    int fretBoardHeight = (((STRING_SPACING) * (this.strings.length - 1))\n        + TOP_SPACING + 10);\n    return (borderWidth + toolBarHeight + fretBoardHeight);\n  }\n", "refactored_code": "  public static final int BOTTOM_SPACING = 10;\n    int borderWidth = (2 * this.fretBoardComposite.getBorderWidth());\n    int toolBarHeight = (this.toolComposite.getBounds().height);\n    int fretBoardHeight = (((STRING_SPACING) * (this.strings.length - 1))\n        + TOP_SPACING + BOTTOM_SPACING);\n    return (borderWidth + toolBarHeight + fretBoardHeight);\n  }\n"}
{"magic_number_smell": "        style |= (displayTextScale.getSelection() ? DISPLAY_TEXT_SCALE : 0);\n\n        int direction = directionCombo.getSelectionIndex();\n        if (direction != DIRECTION_RIGHT && direction != 1) {\n          direction = DIRECTION_RIGHT;\n        }\n        // if( direction )", "refactored_code": "  public static final int DIRECTION_LEFT = 1;\n        style |= (displayTextScale.getSelection() ? DISPLAY_TEXT_SCALE : 0);\n\n        int direction = directionCombo.getSelectionIndex();\n        if (direction != DIRECTION_RIGHT && direction != DIRECTION_LEFT) {\n          direction = DIRECTION_RIGHT;\n        }\n        // if( direction )"}
{"magic_number_smell": "  protected GridData getButtonData() {\n    GridData data = new GridData(SWT.FILL, SWT.FILL, true, true);\n    data.minimumWidth = MINIMUM_BUTTON_WIDTH;\n    data.minimumHeight = 25;\n    return data;\n  }\n", "refactored_code": "  private static final int MINIMUM_BUTTON_HEIGHT = 25;\n  protected GridData getButtonData() {\n    GridData data = new GridData(SWT.FILL, SWT.FILL, true, true);\n    data.minimumWidth = MINIMUM_BUTTON_WIDTH;\n    data.minimumHeight = MINIMUM_BUTTON_HEIGHT;\n    return data;\n  }\n"}
{"magic_number_smell": "        this.lineHeight = Math\n            .max(\n                minimumNameHeight,\n                ((this.clientArea.height - (20 * 2.0f)) / (rows + 1.0f)));\n        this.timeWidth = Math.max((10 * (TGDuration.SIXTY_FOURTH / measure\n            .getTimeSignature().getDenominator().getValue())),\n            ((this.clientArea.width - this.leftSpacing) / cols));", "refactored_code": "  private static final int BORDER_HEIGHT = 20;\n        this.lineHeight = Math\n            .max(\n                minimumNameHeight,\n                ((this.clientArea.height - (BORDER_HEIGHT * 2.0f)) / (rows + 1.0f)));\n        this.timeWidth = Math.max((10 * (TGDuration.SIXTY_FOURTH / measure\n            .getTimeSignature().getDenominator().getValue())),\n            ((this.clientArea.width - this.leftSpacing) / cols));"}
{"magic_number_smell": "  private int getSelection(Point point) {\n    int posX = 0;\n\n    for (int i = 0; i < (8 * TYPE_NOTES.length); i++) {\n      int width = 0;\n\n      if (TYPE_NOTES[i % TYPE_NOTES.length]) {", "refactored_code": "  private static final int MAX_OCTAVES = 8;\n  private int getSelection(Point point) {\n    int posX = 0;\n\n    for (int i = 0; i < (MAX_OCTAVES * TYPE_NOTES.length); i++) {\n      int width = 0;\n\n      if (TYPE_NOTES[i % TYPE_NOTES.length]) {"}
{"magic_number_smell": "  protected GridData getButtonData() {\n    GridData data = new GridData(SWT.FILL, SWT.FILL, true, true);\n    data.minimumWidth = MINIMUM_BUTTON_WIDTH;\n    data.minimumHeight = 25;\n    return data;\n  }\n", "refactored_code": "  private static final int MINIMUM_BUTTON_HEIGHT = 25;\n  protected GridData getButtonData() {\n    GridData data = new GridData(SWT.FILL, SWT.FILL, true, true);\n    data.minimumWidth = MINIMUM_BUTTON_WIDTH;\n    data.minimumHeight = MINIMUM_BUTTON_HEIGHT;\n    return data;\n  }\n"}
{"magic_number_smell": "    hBar.setIncrement(SCROLL_INCREMENT);\n    hBar.addListener(SWT.Selection, new Listener() {\n      public void handleEvent(Event e) {\n        if (Tablature.this.lastHScrollTime + 15 < System\n            .currentTimeMillis()) {\n          redraw();\n          Tablature.this.lastHScrollTime = System.currentTimeMillis();", "refactored_code": "  private static final int SCROLL_DELAY = 15;\n    hBar.setIncrement(SCROLL_INCREMENT);\n    hBar.addListener(SWT.Selection, new Listener() {\n      public void handleEvent(Event e) {\n        if (Tablature.this.lastHScrollTime + SCROLL_DELAY < System\n            .currentTimeMillis()) {\n          redraw();\n          Tablature.this.lastHScrollTime = System.currentTimeMillis();"}
{"magic_number_smell": "\n  public static float getDownOffset(ViewLayout layout) {\n    float scale = (layout.getScoreLineSpacing() / 8.0f);\n    return (35 * scale);\n  }\n\n  public static float getUpOffset(ViewLayout layout) {", "refactored_code": "  private static final int DOWN_OFFSET = 35;\n\n  public static float getDownOffset(ViewLayout layout) {\n    float scale = (layout.getScoreLineSpacing() / 8.0f);\n    return (DOWN_OFFSET * scale);\n  }\n\n  public static float getUpOffset(ViewLayout layout) {"}
{"magic_number_smell": "  public static final int POSITION_VIBRATO_EFFEC = 8;\n\n  private static final int[] EFFECT_POSITIONS = new int[] {\n      0, POSITION_HEAVY_ACCENTUATED_EFFECT,\n      POSITION_HARMONIC_EFFEC, POSITION_TAPPING_EFFEC, POSITION_SLAPPING_EFFEC,\n      POSITION_POPPING_EFFEC, POSITION_PALM_MUTE_EFFEC,\n      POSITION_LET_RING_EFFEC, POSITION_VIBRATO_EFFEC, POSITION_TRILL_EFFEC,", "refactored_code": "  public static final int POSITION_ACCENTUATED_EFFECT = 0;\n  public static final int POSITION_VIBRATO_EFFEC = 8;\n\n  private static final int[] EFFECT_POSITIONS = new int[] {\n      POSITION_ACCENTUATED_EFFECT, POSITION_HEAVY_ACCENTUATED_EFFECT,\n      POSITION_HARMONIC_EFFEC, POSITION_TAPPING_EFFEC, POSITION_SLAPPING_EFFEC,\n      POSITION_POPPING_EFFEC, POSITION_PALM_MUTE_EFFEC,\n      POSITION_LET_RING_EFFEC, POSITION_VIBRATO_EFFEC, POSITION_TRILL_EFFEC,"}
{"magic_number_smell": "        maximum = (Math.max(maximum, fretValue));\n      }\n    }\n    int firstFret = (zero && maximum < 6) ? 1 : minimum;\n    setFirstFret(Math.max(firstFret, 1));\n  }\n", "refactored_code": "  public static final int MAX_FRETS = 6;\n        maximum = (Math.max(maximum, fretValue));\n      }\n    }\n    int firstFret = (zero && maximum < MAX_FRETS) ? 1 : minimum;\n    setFirstFret(Math.max(firstFret, 1));\n  }\n"}
{"magic_number_smell": "  }\n\n  public int getLeftSpacing(ViewLayout layout) {\n    return Math.round(15 * layout.getScale());\n  }\n\n  public int getMaxQuarterSpacing() {", "refactored_code": "  private static final int DEFAULT_LEFT_SPACING = 15;\n  }\n\n  public int getLeftSpacing(ViewLayout layout) {\n    return Math.round(DEFAULT_LEFT_SPACING * layout.getScale());\n  }\n\n  public int getMaxQuarterSpacing() {"}
{"magic_number_smell": "      if (this.prevMeasure == null || getClef() != this.prevMeasure.getClef()) {\n        this.paintClef = true;\n        this.getHeaderImpl().notifyClefSpacing(\n            Math.round(40 * layout.getScale()));\n      }\n      if (this.prevMeasure == null\n          || getKeySignature() != this.prevMeasure.getKeySignature()) {", "refactored_code": "  private static final int DEFAULT_CLEF_SPACING = 40;\n      if (this.prevMeasure == null || getClef() != this.prevMeasure.getClef()) {\n        this.paintClef = true;\n        this.getHeaderImpl().notifyClefSpacing(\n            Math.round(DEFAULT_CLEF_SPACING * layout.getScale()));\n      }\n      if (this.prevMeasure == null\n          || getKeySignature() != this.prevMeasure.getKeySignature()) {"}
{"magic_number_smell": "\n  private void initImages() {\n    this.scoreNotes = new Image[4];\n    this.scoreNotes[0] = getScoreNoteImage(\n        getScoreNoteColor(), false);\n    this.scoreNotes[SCORE_NOTE_EMPTY_PLAY_MODE] = getScoreNoteImage(\n        getPlayNoteColor(), false);", "refactored_code": "  private static final int SCORE_NOTE_EMPTY_NORMAL_MODE = 0;\n\n  private void initImages() {\n    this.scoreNotes = new Image[4];\n    this.scoreNotes[SCORE_NOTE_EMPTY_NORMAL_MODE] = getScoreNoteImage(\n        getScoreNoteColor(), false);\n    this.scoreNotes[SCORE_NOTE_EMPTY_PLAY_MODE] = getScoreNoteImage(\n        getPlayNoteColor(), false);"}
{"magic_number_smell": "\n  public TGSpacing(ViewLayout layout, int[][] positions, int len) {\n    this.flags = 0;\n    this.flags |= ((layout.getStyle() & ViewLayout.DISPLAY_SCORE) != 0 ? 0x01\n        : 0);\n    this.flags |= ((layout.getStyle() & ViewLayout.DISPLAY_TABLATURE) != 0 ? TABLATURE\n        : 0);", "refactored_code": "  public static final int SCORE = 0x01;\n\n  public TGSpacing(ViewLayout layout, int[][] positions, int len) {\n    this.flags = 0;\n    this.flags |= ((layout.getStyle() & ViewLayout.DISPLAY_SCORE) != 0 ? SCORE\n        : 0);\n    this.flags |= ((layout.getStyle() & ViewLayout.DISPLAY_TABLATURE) != 0 ? TABLATURE\n        : 0);"}
{"magic_number_smell": "      12, // POSITION_TABLATURE_TOP_SEPARATOR\n      13, // POSITION_TABLATURE\n      14, // POSITION_LYRIC\n      15, // 15\n  },\n\n  /** TABLATURE **/", "refactored_code": "  public static final int POSITION_BOTTOM = 15;\n      12, // POSITION_TABLATURE_TOP_SEPARATOR\n      13, // POSITION_TABLATURE\n      14, // POSITION_LYRIC\n      15, // POSITION_BOTTOM\n  },\n\n  /** TABLATURE **/"}
{"magic_number_smell": "        if (this.previous.getDuration().getValue() >= getDuration().getValue()) {\n          this.setJoin1(this.previous);\n          this.setJoin2(this);\n          this.joinedType = 3;\n          noteJoined = true;\n        }\n        if (this.previous.getDuration().getValue() > TGDuration.QUARTER) {", "refactored_code": "  public static final int JOINED_TYPE_LEFT = 3;\n        if (this.previous.getDuration().getValue() >= getDuration().getValue()) {\n          this.setJoin1(this.previous);\n          this.setJoin2(this);\n          this.joinedType = JOINED_TYPE_LEFT;\n          noteJoined = true;\n        }\n        if (this.previous.getDuration().getValue() > TGDuration.QUARTER) {"}
{"magic_number_smell": "\n  public void mouseExit(MouseEvent e) {\n    if (!this.menuOpen && !TuxGuitar.instance().getPlayer().isRunning()) {\n      if (isScoreEnabled() && getMouseMode() == 2) {\n        this.mouseKit.mouseExit();\n      }\n    }", "refactored_code": "  public static final int MOUSE_MODE_EDITION = 2;\n\n  public void mouseExit(MouseEvent e) {\n    if (!this.menuOpen && !TuxGuitar.instance().getPlayer().isRunning()) {\n      if (isScoreEnabled() && getMouseMode() == MOUSE_MODE_EDITION) {\n        this.mouseKit.mouseExit();\n      }\n    }"}
{"magic_number_smell": "    this.setTrackSpacing(getScaledValue(scale, DEFAULT_TRACK_SPACING));\n    this.setStringSpacing(getScaledValue(scale, DEFAULT_STRING_SPACING, 4));\n    this.setChordFretIndexSpacing(getScaledValue(scale,\n        8, 2));\n    this.setChordStringSpacing(getScaledValue(scale, CHORD_STRING_SPACING, 2));\n    this.setChordFretSpacing(getScaledValue(scale, CHORD_FRET_SPACING, 2));\n    this.setChordNoteSize(getScaledValue(scale, 3, 2));", "refactored_code": "  private static final int CHORD_FRET_INDEX_SPACING = 8;\n    this.setTrackSpacing(getScaledValue(scale, DEFAULT_TRACK_SPACING));\n    this.setStringSpacing(getScaledValue(scale, DEFAULT_STRING_SPACING, 4));\n    this.setChordFretIndexSpacing(getScaledValue(scale,\n        CHORD_FRET_INDEX_SPACING, 2));\n    this.setChordStringSpacing(getScaledValue(scale, CHORD_STRING_SPACING, 2));\n    this.setChordFretSpacing(getScaledValue(scale, CHORD_FRET_SPACING, 2));\n    this.setChordNoteSize(getScaledValue(scale, 3, 2));"}
{"magic_number_smell": "  }\n\n  public static final int 2 = 2;\n  public static final int DEFAULT_MODE = 2;\n  public static final int DISPLAY_CHORD_DIAGRAM = 0x20;\n\n  public static final int DISPLAY_CHORD_NAME = 0x10;", "refactored_code": "  public static final int MODE_LINEAR = 2;\n  }\n\n  public static final int MODE_LINEAR = 2;\n  public static final int DEFAULT_MODE = MODE_LINEAR;\n  public static final int DISPLAY_CHORD_DIAGRAM = 0x20;\n\n  public static final int DISPLAY_CHORD_NAME = 0x10;"}
{"magic_number_smell": "    this.image = TuxGuitar.instance().getIconManager().getAboutDescription();\n\n    this.imageComposite = new Composite(header, SWT.NONE);\n    this.imageComposite.setLayoutData(new GridData(IMAGE_WIDTH, 100));\n    this.imageComposite.addPaintListener(new PaintListener() {\n      public void paintControl(PaintEvent e) {\n        Rectangle bounds = AboutDialog.this.image.getBounds();", "refactored_code": "  private static final int IMAGE_HEIGHT = 100;\n    this.image = TuxGuitar.instance().getIconManager().getAboutDescription();\n\n    this.imageComposite = new Composite(header, SWT.NONE);\n    this.imageComposite.setLayoutData(new GridData(IMAGE_WIDTH, IMAGE_HEIGHT));\n    this.imageComposite.addPaintListener(new PaintListener() {\n      public void paintControl(PaintEvent e) {\n        Rectangle bounds = AboutDialog.this.image.getBounds();"}
{"magic_number_smell": "    if (TuxGuitar.instance().getPlayer().isRunning()) {\n      this.status = STATUS_RUNNING;\n    } else if (TuxGuitar.instance().getPlayer().isPaused()) {\n      this.status = 2;\n    } else {\n      this.status = STATUS_STOPPED;\n    }", "refactored_code": "  private static final int STATUS_PAUSED = 2;\n    if (TuxGuitar.instance().getPlayer().isRunning()) {\n      this.status = STATUS_RUNNING;\n    } else if (TuxGuitar.instance().getPlayer().isPaused()) {\n      this.status = STATUS_PAUSED;\n    } else {\n      this.status = STATUS_STOPPED;\n    }"}
{"magic_number_smell": "    if (TuxGuitar.instance().getPlayer().isRunning()) {\n      this.status = STATUS_RUNNING;\n    } else if (TuxGuitar.instance().getPlayer().isPaused()) {\n      this.status = 2;\n    } else {\n      this.status = STATUS_STOPPED;\n    }", "refactored_code": "  private static final int STATUS_PAUSED = 2;\n    if (TuxGuitar.instance().getPlayer().isRunning()) {\n      this.status = STATUS_RUNNING;\n    } else if (TuxGuitar.instance().getPlayer().isPaused()) {\n      this.status = STATUS_PAUSED;\n    } else {\n      this.status = STATUS_STOPPED;\n    }"}
{"magic_number_smell": "\n    GridData data = new GridData(SWT.FILL, SWT.FILL, true, true);\n    data.minimumWidth = MINIMUM_BUTTON_WIDTH;\n    data.minimumHeight = 25;\n\n    final Button buttonOK = new Button(buttons, SWT.PUSH);\n    buttonOK.setText(TuxGuitar.getProperty(\"ok\"));", "refactored_code": "  private static final int MINIMUM_BUTTON_HEIGHT = 25;\n\n    GridData data = new GridData(SWT.FILL, SWT.FILL, true, true);\n    data.minimumWidth = MINIMUM_BUTTON_WIDTH;\n    data.minimumHeight = MINIMUM_BUTTON_HEIGHT;\n\n    final Button buttonOK = new Button(buttons, SWT.PUSH);\n    buttonOK.setText(TuxGuitar.getProperty(\"ok\"));"}
{"magic_number_smell": "  public static final int SOLO = 0x02;\n  public static final int TREMOLO = 0x80;\n  public static final int VOLUME = 0x04;\n  public static final int CHANGE_ALL = (MUTE | SOLO | VOLUME | 0x08 | CHORUS\n      | REVERB | PHASER | TREMOLO | CHANNEL);\n\n  protected Shell dialog;", "refactored_code": "  public static final int BALANCE = 0x08;\n  public static final int SOLO = 0x02;\n  public static final int TREMOLO = 0x80;\n  public static final int VOLUME = 0x04;\n  public static final int CHANGE_ALL = (MUTE | SOLO | VOLUME | BALANCE | CHORUS\n      | REVERB | PHASER | TREMOLO | CHANNEL);\n\n  protected Shell dialog;"}
{"magic_number_smell": "    pageData.widthHint = (this.bounds.width - this.bounds.x)\n        + (MARGIN_LEFT + MARGIN_RIGHT);\n    pageData.heightHint = (this.bounds.height - this.bounds.y)\n        + (MARGIN_TOP + 40);\n    this.pageComposite.setLayoutData(pageData);\n    this.previewComposite.getVerticalBar().setIncrement(SCROLL_INCREMENT);\n    this.previewComposite.getVerticalBar().addListener(SWT.Selection,", "refactored_code": "  private static final int MARGIN_BOTTOM = 40;\n    pageData.widthHint = (this.bounds.width - this.bounds.x)\n        + (MARGIN_LEFT + MARGIN_RIGHT);\n    pageData.heightHint = (this.bounds.height - this.bounds.y)\n        + (MARGIN_TOP + MARGIN_BOTTOM);\n    this.pageComposite.setLayoutData(pageData);\n    this.previewComposite.getVerticalBar().setIncrement(SCROLL_INCREMENT);\n    this.previewComposite.getVerticalBar().addListener(SWT.Selection,"}
{"magic_number_smell": "  }\n\n  protected GridData getTabbedData() {\n    return getTabbedData(20, SWT.FILL, SWT.CENTER);\n  }\n\n  protected GridData getTabbedData(int horizontalAlignment,", "refactored_code": "  protected static final int DEFAULT_INDENT = 20;\n  }\n\n  protected GridData getTabbedData() {\n    return getTabbedData(DEFAULT_INDENT, SWT.FILL, SWT.CENTER);\n  }\n\n  protected GridData getTabbedData(int horizontalAlignment,"}
{"magic_number_smell": "  public GridData makeButtonData() {\n    GridData data = new GridData(SWT.FILL, SWT.CENTER, true, true);\n    data.minimumWidth = BUTTON_WIDTH;\n    data.minimumHeight = 0;\n    return data;\n  }\n", "refactored_code": "  private static final int BUTTON_HEIGHT = 0;\n  public GridData makeButtonData() {\n    GridData data = new GridData(SWT.FILL, SWT.CENTER, true, true);\n    data.minimumWidth = BUTTON_WIDTH;\n    data.minimumHeight = BUTTON_HEIGHT;\n    return data;\n  }\n"}
{"magic_number_smell": "    this.table = new Table(composite, SWT.BORDER | SWT.SINGLE\n        | SWT.FULL_SELECTION);\n    this.table\n        .setLayoutData(new GridData((400 + SHORTCUT_WIDTH), 250));\n    this.table.setHeaderVisible(true);\n    this.table.addMouseListener(new MouseAdapter() {\n      public void mouseDoubleClick(MouseEvent e) {", "refactored_code": "  private static final int ACTION_WIDTH = 400;\n    this.table = new Table(composite, SWT.BORDER | SWT.SINGLE\n        | SWT.FULL_SELECTION);\n    this.table\n        .setLayoutData(new GridData((ACTION_WIDTH + SHORTCUT_WIDTH), 250));\n    this.table.setHeaderVisible(true);\n    this.table.addMouseListener(new MouseAdapter() {\n      public void mouseDoubleClick(MouseEvent e) {"}
{"magic_number_smell": "        return (DIRECTION_FOLDER * RESULT_GREATER);\n      }\n\n      return (1 * (element1.getName().compareTo(element2.getName())));\n    }\n    return RESULT_EQUAL;\n  }", "refactored_code": "  private static final int DIRECTION = 1;\n        return (DIRECTION_FOLDER * RESULT_GREATER);\n      }\n\n      return (DIRECTION * (element1.getName().compareTo(element2.getName())));\n    }\n    return RESULT_EQUAL;\n  }"}
{"magic_number_smell": "        return (DIRECTION_FOLDER * RESULT_GREATER);\n      }\n\n      return (1 * (element1.getName().compareTo(element2.getName())));\n    }\n    return RESULT_EQUAL;\n  }", "refactored_code": "  private static final int DIRECTION = 1;\n        return (DIRECTION_FOLDER * RESULT_GREATER);\n      }\n\n      return (DIRECTION * (element1.getName().compareTo(element2.getName())));\n    }\n    return RESULT_EQUAL;\n  }"}
{"magic_number_smell": "    this.dialog = DialogUtils.newDialog(TuxGuitar.instance().getShell(),\n        SWT.DIALOG_TRIM);\n    this.dialog.setLayout(new GridLayout());\n    this.dialog.setMinimumSize(500, SWT.DEFAULT);\n    this.dialog.addDisposeListener(new DisposeListener() {\n      public void widgetDisposed(DisposeEvent e) {\n        TuxGuitar.instance().getIconManager().removeLoader(", "refactored_code": "  private static final int SHELL_WIDTH = 500;\n    this.dialog = DialogUtils.newDialog(TuxGuitar.instance().getShell(),\n        SWT.DIALOG_TRIM);\n    this.dialog.setLayout(new GridLayout());\n    this.dialog.setMinimumSize(SHELL_WIDTH, SWT.DEFAULT);\n    this.dialog.addDisposeListener(new DisposeListener() {\n      public void widgetDisposed(DisposeEvent e) {\n        TuxGuitar.instance().getIconManager().removeLoader("}
{"magic_number_smell": "    this.dialog = DialogUtils.newDialog(TuxGuitar.instance().getShell(),\n        SWT.SHELL_TRIM);\n    this.dialog.setLayout(new GridLayout());\n    this.dialog.setSize(SHELL_WIDTH, 350);\n    this.dialog.addDisposeListener(new DisposeListener() {\n      public void widgetDisposed(DisposeEvent e) {\n        TuxGuitar.instance().getIconManager().removeLoader(", "refactored_code": "  private static final int SHELL_HEIGHT = 350;\n    this.dialog = DialogUtils.newDialog(TuxGuitar.instance().getShell(),\n        SWT.SHELL_TRIM);\n    this.dialog.setLayout(new GridLayout());\n    this.dialog.setSize(SHELL_WIDTH, SHELL_HEIGHT);\n    this.dialog.addDisposeListener(new DisposeListener() {\n      public void widgetDisposed(DisposeEvent e) {\n        TuxGuitar.instance().getIconManager().removeLoader("}
{"magic_number_smell": "    this.dialog.setLayout(new GridLayout());\n    this.dialog.setImage(TuxGuitar.instance().getIconManager().getAppIcon());\n    this.dialog.setText(TuxGuitar.getProperty(\"tuner.instrument-tuner\"));\n    this.dialog.setMinimumSize(400, SWT.DEFAULT);\n    this.dialog.setSize(700, 400);\n\n    Group group = new Group(this.dialog, SWT.SHADOW_ETCHED_IN);", "refactored_code": "  private static final int SHELL_WIDTH = 400;\n    this.dialog.setLayout(new GridLayout());\n    this.dialog.setImage(TuxGuitar.instance().getIconManager().getAppIcon());\n    this.dialog.setText(TuxGuitar.getProperty(\"tuner.instrument-tuner\"));\n    this.dialog.setMinimumSize(SHELL_WIDTH, SWT.DEFAULT);\n    this.dialog.setSize(700, 400);\n\n    Group group = new Group(this.dialog, SWT.SHADOW_ETCHED_IN);"}
{"magic_number_smell": "    });\n\n    GridData data = new GridData(SWT.FILL, SWT.FILL, true, true);\n    data.minimumHeight = 60;\n    data.minimumWidth = MIN_WIDTH;\n    data.grabExcessHorizontalSpace = true;\n    data.grabExcessVerticalSpace = true;", "refactored_code": "  private static final int MIN_HEIGHT = 60;\n    });\n\n    GridData data = new GridData(SWT.FILL, SWT.FILL, true, true);\n    data.minimumHeight = MIN_HEIGHT;\n    data.minimumWidth = MIN_WIDTH;\n    data.grabExcessHorizontalSpace = true;\n    data.grabExcessVerticalSpace = true;"}
{"magic_number_smell": "      if (this.queue[i] != -1)\n        for (int j = 0; j < this.QUEUE_SIZE; j++) {\n          // exact frequency with tollerance\n          if (this.queue[i] > (this.queue[j] * this.0.95)\n              && this.queue[i] < (this.queue[j] * this.upperTollerance))\n            this.similars[i] = this.similars[i] + 2;\n", "refactored_code": "  private final double lowerTollerance = 0.95; // -5%\n      if (this.queue[i] != -1)\n        for (int j = 0; j < this.QUEUE_SIZE; j++) {\n          // exact frequency with tollerance\n          if (this.queue[i] > (this.queue[j] * this.lowerTollerance)\n              && this.queue[i] < (this.queue[j] * this.upperTollerance))\n            this.similars[i] = this.similars[i] + 2;\n"}
{"magic_number_smell": "\n    });\n    GridData data = new GridData(SWT.FILL, SWT.FILL, true, true);\n    data.minimumHeight = 25;\n    data.grabExcessHorizontalSpace = true;\n    this.composite.setLayoutData(data);\n", "refactored_code": "  private static final int MIN_HEIGHT = 25;\n\n    });\n    GridData data = new GridData(SWT.FILL, SWT.FILL, true, true);\n    data.minimumHeight = MIN_HEIGHT;\n    data.grabExcessHorizontalSpace = true;\n    this.composite.setLayoutData(data);\n"}
{"magic_number_smell": "    dialog.setLayout(new GridLayout());\n    dialog.setImage(TuxGuitar.instance().getIconManager().getAppIcon());\n    dialog.setText(TuxGuitar.getProperty(\"tuner.settings\"));\n    dialog.setMinimumSize(350, SWT.DEFAULT);\n\n    Group group = new Group(dialog, SWT.SHADOW_ETCHED_IN);\n    group.setLayout(new GridLayout());", "refactored_code": "  private static final int SHELL_WIDTH = 350;\n    dialog.setLayout(new GridLayout());\n    dialog.setImage(TuxGuitar.instance().getIconManager().getAppIcon());\n    dialog.setText(TuxGuitar.getProperty(\"tuner.settings\"));\n    dialog.setMinimumSize(SHELL_WIDTH, SWT.DEFAULT);\n\n    Group group = new Group(dialog, SWT.SHADOW_ETCHED_IN);\n    group.setLayout(new GridLayout());"}
{"magic_number_smell": "    this.scaleListeners = new ArrayList<ScaleListener>();\n    this.scale = new TGScale();\n    this.selectionKey = 0;\n    this.selectionIndex = -1;\n    this.loadScales();\n  }\n", "refactored_code": "  public static final int NONE_SELECTION = -1;\n    this.scaleListeners = new ArrayList<ScaleListener>();\n    this.scale = new TGScale();\n    this.selectionKey = 0;\n    this.selectionIndex = NONE_SELECTION;\n    this.loadScales();\n  }\n"}
{"magic_number_smell": "        if (!isEditingTickScale()\n            && TuxGuitar.instance().getPlayer().isRunning()) {\n          long time = System.currentTimeMillis();\n          if (time > this.redrawTime + 250) {\n            long position = (TuxGuitar.instance().getEditorCache()\n                .getPlayStart() + (TuxGuitar.instance().getPlayer()\n                .getTickPosition() - TuxGuitar.instance().getEditorCache()", "refactored_code": "  private static final int PLAY_MODE_DELAY = 250;\n        if (!isEditingTickScale()\n            && TuxGuitar.instance().getPlayer().isRunning()) {\n          long time = System.currentTimeMillis();\n          if (time > this.redrawTime + PLAY_MODE_DELAY) {\n            long position = (TuxGuitar.instance().getEditorCache()\n                .getPlayStart() + (TuxGuitar.instance().getPlayer()\n                .getTickPosition() - TuxGuitar.instance().getEditorCache()"}
{"magic_number_smell": "  }\n\n  private void checkForLimit() {\n    while (this.edits.size() >= 100) {\n      UndoableEdit edit = (UndoableEdit) this.edits.get(0);\n      remove(edit);\n      this.indexOfNextAdd--;", "refactored_code": "  private static final int LIMIT = 100;\n  }\n\n  private void checkForLimit() {\n    while (this.edits.size() >= LIMIT) {\n      UndoableEdit edit = (UndoableEdit) this.edits.get(0);\n      remove(edit);\n      this.indexOfNextAdd--;"}
{"magic_number_smell": "    }\n    if ((style & OPEN_STYLE_MAXIMIZED) != 0) {\n      dialog.setMaximized(true);\n    } else if ((style & 0x08) != 0) {\n      int x = Math.max(0, parent.getBounds().x\n          + (parent.getBounds().width - dialog.getSize().x) / 2);\n      int y = Math.max(0, parent.getBounds().y", "refactored_code": "  public static final int OPEN_STYLE_CENTER = 0x08;\n    }\n    if ((style & OPEN_STYLE_MAXIMIZED) != 0) {\n      dialog.setMaximized(true);\n    } else if ((style & OPEN_STYLE_CENTER) != 0) {\n      int x = Math.max(0, parent.getBounds().x\n          + (parent.getBounds().width - dialog.getSize().x) / 2);\n      int y = Math.max(0, parent.getBounds().y"}
{"magic_number_smell": "          eof = (this.manager.getTrackManager().isLastMeasure(measure));\n\n          // Si se supero el ancho maximo, bajo de linea\n          if (this.out.getPosX() > 80) {\n            break;\n          }\n        }", "refactored_code": "  private static final int MAX_LINE_LENGTH = 80;\n          eof = (this.manager.getTrackManager().isLastMeasure(measure));\n\n          // Si se supero el ancho maximo, bajo de linea\n          if (this.out.getPosX() > MAX_LINE_LENGTH) {\n            break;\n          }\n        }"}
{"magic_number_smell": "\n    readInt(); // key\n\n    for (int i = 0; i < 8; i++) {\n      TGTrack track = new TGTrackImpl();\n      track.setNumber((i + 1));\n      track.getChannel().setChannel(TRACK_CHANNELS[i][0]);", "refactored_code": "  private static final int TRACK_COUNT = 8;\n\n    readInt(); // key\n\n    for (int i = 0; i < TRACK_COUNT; i++) {\n      TGTrack track = new TGTrackImpl();\n      track.setNumber((i + 1));\n      track.getChannel().setChannel(TRACK_CHANNELS[i][0]);"}
{"magic_number_smell": "      readByte(); // vibrato\n\n      int pointPosition = Math.round(bendPosition\n          * EffectPoint.MAX_POSITION_LENGTH / 60f);\n      int pointValue = Math.round(bendValue * EffectPoint.SEMITONE_LENGTH\n          / GP_BEND_SEMITONE);\n      bend.addPoint(pointPosition, pointValue);", "refactored_code": "  private static final float GP_BEND_POSITION = 60f;\n      readByte(); // vibrato\n\n      int pointPosition = Math.round(bendPosition\n          * EffectPoint.MAX_POSITION_LENGTH / GP_BEND_POSITION);\n      int pointValue = Math.round(bendValue * EffectPoint.SEMITONE_LENGTH\n          / GP_BEND_SEMITONE);\n      bend.addPoint(pointPosition, pointValue);"}
{"magic_number_smell": "    writeInt(0);\n    writeInt(points);\n    for (final EffectPoint point : bend.getPoints()) {\n      writeInt((point.getPosition() * 60 / EffectPoint.MAX_POSITION_LENGTH));\n      writeInt((point.getValue() * GP_BEND_SEMITONE / EffectPoint.SEMITONE_LENGTH));\n      writeByte((byte) 0);\n    }", "refactored_code": "  private static final int GP_BEND_POSITION = 60;\n    writeInt(0);\n    writeInt(points);\n    for (final EffectPoint point : bend.getPoints()) {\n      writeInt((point.getPosition() * GP_BEND_POSITION / EffectPoint.MAX_POSITION_LENGTH));\n      writeInt((point.getValue() * GP_BEND_SEMITONE / EffectPoint.SEMITONE_LENGTH));\n      writeByte((byte) 0);\n    }"}
{"magic_number_smell": "      readByte();\n\n      int pointPosition = Math.round(position * EffectPoint.MAX_POSITION_LENGTH\n          / 60f);\n      int pointValue = Math.round(value * EffectPoint.SEMITONE_LENGTH\n          / GP_BEND_SEMITONE);\n      bend.addPoint(pointPosition, pointValue);", "refactored_code": "  private static final float GP_BEND_POSITION = 60f;\n      readByte();\n\n      int pointPosition = Math.round(position * EffectPoint.MAX_POSITION_LENGTH\n          / GP_BEND_POSITION);\n      int pointValue = Math.round(value * EffectPoint.SEMITONE_LENGTH\n          / GP_BEND_SEMITONE);\n      bend.addPoint(pointPosition, pointValue);"}
{"magic_number_smell": "    writeInt(0);\n    writeInt(points);\n    for (final EffectPoint point : bend.getPoints()) {\n      writeInt((point.getPosition() * 60 / EffectPoint.MAX_POSITION_LENGTH));\n      writeInt((point.getValue() * GP_BEND_SEMITONE / EffectPoint.SEMITONE_LENGTH));\n      writeByte((byte) 0);\n    }", "refactored_code": "  private static final int GP_BEND_POSITION = 60;\n    writeInt(0);\n    writeInt(points);\n    for (final EffectPoint point : bend.getPoints()) {\n      writeInt((point.getPosition() * GP_BEND_POSITION / EffectPoint.MAX_POSITION_LENGTH));\n      writeInt((point.getValue() * GP_BEND_SEMITONE / EffectPoint.SEMITONE_LENGTH));\n      writeByte((byte) 0);\n    }"}
{"magic_number_smell": "      readByte();\n\n      int pointPosition = Math.round(bendPosition\n          * EffectPoint.MAX_POSITION_LENGTH / 60f);\n      int pointValue = Math.round(bendValue * EffectPoint.SEMITONE_LENGTH\n          / GP_BEND_SEMITONE);\n      bend.addPoint(pointPosition, pointValue);", "refactored_code": "  private static final float GP_BEND_POSITION = 60f;\n      readByte();\n\n      int pointPosition = Math.round(bendPosition\n          * EffectPoint.MAX_POSITION_LENGTH / GP_BEND_POSITION);\n      int pointValue = Math.round(bendValue * EffectPoint.SEMITONE_LENGTH\n          / GP_BEND_SEMITONE);\n      bend.addPoint(pointPosition, pointValue);"}
{"magic_number_smell": "    writeInt(0);\n    writeInt(points);\n    for (final EffectPoint point : bend.getPoints()) {\n      writeInt((point.getPosition() * 60 / EffectPoint.MAX_POSITION_LENGTH));\n      writeInt((point.getValue() * GP_BEND_SEMITONE / EffectPoint.SEMITONE_LENGTH));\n      writeByte((byte) 0);\n    }", "refactored_code": "  private static final int GP_BEND_POSITION = 60;\n    writeInt(0);\n    writeInt(points);\n    for (final EffectPoint point : bend.getPoints()) {\n      writeInt((point.getPosition() * GP_BEND_POSITION / EffectPoint.MAX_POSITION_LENGTH));\n      writeInt((point.getValue() * GP_BEND_SEMITONE / EffectPoint.SEMITONE_LENGTH));\n      writeByte((byte) 0);\n    }"}
{"magic_number_smell": "        try {\n          layout.getTablature().updateTablature();\n          layout.makeDocument(new PrintDocumentImpl(layout, new Rectangle(25,\n              25, PAGE_WIDTH, 800), getFormat(), getPath()));\n        } catch (Throwable throwable) {\n          MessageDialog.errorMessage(throwable);\n        }", "refactored_code": "  private static final int PAGE_HEIGHT = 800;\n        try {\n          layout.getTablature().updateTablature();\n          layout.makeDocument(new PrintDocumentImpl(layout, new Rectangle(25,\n              25, PAGE_WIDTH, PAGE_HEIGHT), getFormat(), getPath()));\n        } catch (Throwable throwable) {\n          MessageDialog.errorMessage(throwable);\n        }"}
{"magic_number_smell": "\n  public static LilypondSettings getDefaults() {\n    LilypondSettings settings = new LilypondSettings();\n    settings.setTrack(-1);\n    settings.setMeasureFrom(FIRST_MEASURE);\n    settings.setMeasureTo(LAST_MEASURE);\n    settings.setScoreEnabled(true);", "refactored_code": "  public static final int ALL_TRACKS = -1;\n\n  public static LilypondSettings getDefaults() {\n    LilypondSettings settings = new LilypondSettings();\n    settings.setTrack(ALL_TRACKS);\n    settings.setMeasureFrom(FIRST_MEASURE);\n    settings.setMeasureTo(LAST_MEASURE);\n    settings.setScoreEnabled(true);"}
{"magic_number_smell": "    buttonOK.setLayoutData(getButtonData());\n    buttonOK.addSelectionListener(new SelectionAdapter() {\n      public void widgetSelected(SelectionEvent arg0) {\n        LilypondSettingsDialog.this.status = 2;\n\n        settings\n            .setTrack(trackAllCheck.getSelection() ? LilypondSettings.ALL_TRACKS", "refactored_code": "  private static final int STATUS_ACCEPTED = 2;\n    buttonOK.setLayoutData(getButtonData());\n    buttonOK.addSelectionListener(new SelectionAdapter() {\n      public void widgetSelected(SelectionEvent arg0) {\n        LilypondSettingsDialog.this.status = STATUS_ACCEPTED;\n\n        settings\n            .setTrack(trackAllCheck.getSelection() ? LilypondSettings.ALL_TRACKS"}
{"magic_number_smell": "    } else if (statusByte == 0xf0 || statusByte == 0xf7) {\n      return STATUS_SYSEX;\n    } else if (statusByte == 0xff) {\n      return 4;\n    } else {\n      return STATUS_NONE;\n    }", "refactored_code": "  private static final int STATUS_META = 4;\n    } else if (statusByte == 0xf0 || statusByte == 0xf7) {\n      return STATUS_SYSEX;\n    } else if (statusByte == 0xff) {\n      return STATUS_META;\n    } else {\n      return STATUS_NONE;\n    }"}
{"magic_number_smell": "        | SWT.READ_ONLY);\n    transposeCombo\n        .setLayoutData(new GridData(SWT.FILL, SWT.CENTER, true, true));\n    for (int i = MIN_TRANSPOSE; i <= 24; i++) {\n      transposeCombo.add(Integer.toString(i));\n    }\n    transposeCombo.select(-MIN_TRANSPOSE);", "refactored_code": "  public static final int MAX_TRANSPOSE = 24;\n        | SWT.READ_ONLY);\n    transposeCombo\n        .setLayoutData(new GridData(SWT.FILL, SWT.CENTER, true, true));\n    for (int i = MIN_TRANSPOSE; i <= MAX_TRANSPOSE; i++) {\n      transposeCombo.add(Integer.toString(i));\n    }\n    transposeCombo.select(-MIN_TRANSPOSE);"}
{"magic_number_smell": "      int nValue = (tempNote.getValue() + this.settings.getTranspose());\n      int nVelocity = 64;\n      long nStart = tempNote.getTick();\n      TGDuration minDuration = newDuration(TGDuration.SIXTY_FOURTH);\n      TGDuration nDuration = TGDuration.fromTime(tick - tempNote.getTick(),\n          minDuration);\n", "refactored_code": "  private static final int MIN_DURATION_VALUE = TGDuration.SIXTY_FOURTH;\n      int nValue = (tempNote.getValue() + this.settings.getTranspose());\n      int nVelocity = 64;\n      long nStart = tempNote.getTick();\n      TGDuration minDuration = newDuration(MIN_DURATION_VALUE);\n      TGDuration nDuration = TGDuration.fromTime(tick - tempNote.getTick(),\n          minDuration);\n"}
{"magic_number_smell": "        try {\n          layout.getTablature().updateTablature();\n          layout.makeDocument(new PrintDocumentImpl(layout, new Rectangle(0, 0,\n              PAGE_WIDTH, 800), stream));\n          // new SyncThread(new Runnable() {\n          // public void run() {\n          // layout.makeDocument(new PrintDocumentImpl(layout,new", "refactored_code": "  private static final int PAGE_HEIGHT = 800;\n        try {\n          layout.getTablature().updateTablature();\n          layout.makeDocument(new PrintDocumentImpl(layout, new Rectangle(0, 0,\n              PAGE_WIDTH, PAGE_HEIGHT), stream));\n          // new SyncThread(new Runnable() {\n          // public void run() {\n          // layout.makeDocument(new PrintDocumentImpl(layout,new"}
{"magic_number_smell": "  }\n\n  public static JackEvent systemReset(final long tick) {\n    return new JackEvent(tick, MIDI_SYSTEM_EVENT, -1, null);\n  }\n\n  public static JackEvent tempoInUSQ(final long tick, final int usq) {", "refactored_code": "  public static final int ALL_TRACKS = -1;\n  }\n\n  public static JackEvent systemReset(final long tick) {\n    return new JackEvent(tick, MIDI_SYSTEM_EVENT, ALL_TRACKS, null);\n  }\n\n  public static JackEvent tempoInUSQ(final long tick, final int usq) {"}
{"magic_number_smell": "        synchronized (this.sequencerSync) {\n          while (this.running) {\n            this.sequencer.process();\n            this.sequencerSync.wait(10);\n          }\n        }\n      } catch (Throwable throwable) {", "refactored_code": "    private static final int TIMER_DELAY = 10;\n        synchronized (this.sequencerSync) {\n          while (this.running) {\n            this.sequencer.process();\n            this.sequencerSync.wait(TIMER_DELAY);\n          }\n        }\n      } catch (Throwable throwable) {"}
{"magic_number_smell": "\n    Composite tabControl = new Composite(tabFolder, SWT.NONE);\n    tabControl.setLayout(new GridLayout());\n    tabControl.setLayoutData(new FormData(TAB_WIDTH, 350));\n\n    TabItem tabItem = new TabItem(tabFolder, SWT.None);\n    tabItem.setText(TuxGuitar.getProperty(\"jack.settings.dialog.options\"));", "refactored_code": "  private static final int TAB_HEIGHT = 350;\n\n    Composite tabControl = new Composite(tabFolder, SWT.NONE);\n    tabControl.setLayout(new GridLayout());\n    tabControl.setLayoutData(new FormData(TAB_WIDTH, TAB_HEIGHT));\n\n    TabItem tabItem = new TabItem(tabFolder, SWT.None);\n    tabItem.setText(TuxGuitar.getProperty(\"jack.settings.dialog.options\"));"}
{"magic_number_smell": "    // Initialize default channel values\n    for (int i = 0; i < this.channels.length; i++) {\n      this.channels[i][PORT_INDEX] = i;\n      this.channels[i][1] = i;\n      this.channels[i][PROGRAM_INDEX] = -1;\n    }\n    // Disable program routing", "refactored_code": "  private static final int CHANNEL_INDEX = 1;\n    // Initialize default channel values\n    for (int i = 0; i < this.channels.length; i++) {\n      this.channels[i][PORT_INDEX] = i;\n      this.channels[i][CHANNEL_INDEX] = i;\n      this.channels[i][PROGRAM_INDEX] = -1;\n    }\n    // Disable program routing"}
{"magic_number_smell": "\n    if (track != null) {\n      int stringsCount = track.getStrings().size(), stringIndex = inChannel\n          - (this.f_BaseChannel + (this.6 - stringsCount))\n          + 1;\n\n      if (stringIndex > 0 && stringIndex <= stringsCount)", "refactored_code": "  private final int DEVICE_CHANNELS_COUNT = 6; // number of MIDI channels\n\n    if (track != null) {\n      int stringsCount = track.getStrings().size(), stringIndex = inChannel\n          - (this.f_BaseChannel + (this.DEVICE_CHANNELS_COUNT - stringsCount))\n          + 1;\n\n      if (stringIndex > 0 && stringIndex <= stringsCount)"}
{"magic_number_smell": "\n  private void updateDefaultControllers() {\n    try {\n      for (int channel = 0; channel < 16; channel++) {\n        getOutputTransmitter().sendControlChange(channel,\n            MidiControllers.RPN_MSB, 0);\n        getOutputTransmitter().sendControlChange(channel,", "refactored_code": "  private static final int MAX_CHANNELS = 16;\n\n  private void updateDefaultControllers() {\n    try {\n      for (int channel = 0; channel < MAX_CHANNELS; channel++) {\n        getOutputTransmitter().sendControlChange(channel,\n            MidiControllers.RPN_MSB, 0);\n        getOutputTransmitter().sendControlChange(channel,"}
{"magic_number_smell": "  public void clear() {\n    this.loop = false;\n    this.type = TYPE_SIMPLE;\n    this.simplePercent = 100;\n    this.customPercentFrom = 100;\n    this.customPercentTo = 100;\n    this.customPercentIncrement = 0;", "refactored_code": "  public static final int DEFAULT_TEMPO_PERCENT = 100;\n  public void clear() {\n    this.loop = false;\n    this.type = TYPE_SIMPLE;\n    this.simplePercent = DEFAULT_TEMPO_PERCENT;\n    this.customPercentFrom = DEFAULT_TEMPO_PERCENT;\n    this.customPercentTo = DEFAULT_TEMPO_PERCENT;\n    this.customPercentIncrement = 0;"}
{"magic_number_smell": "\n  private static final int DEFAULT_DURATION_PM = 60;\n  public static final int DEFAULT_EXPORT_FLAGS = (ADD_FIRST_TICK_MOVE\n      | 0x01 | ADD_MIXER_MESSAGES);\n  private static final int DEFAULT_METRONOME_KEY = 37;\n  public static final int DEFAULT_PLAY_FLAGS = (ADD_METRONOME);\n", "refactored_code": "  public static final int ADD_DEFAULT_CONTROLS = 0x01;\n\n  private static final int DEFAULT_DURATION_PM = 60;\n  public static final int DEFAULT_EXPORT_FLAGS = (ADD_FIRST_TICK_MOVE\n      | ADD_DEFAULT_CONTROLS | ADD_MIXER_MESSAGES);\n  private static final int DEFAULT_METRONOME_KEY = 37;\n  public static final int DEFAULT_PLAY_FLAGS = (ADD_METRONOME);\n"}
{"magic_number_smell": "\n  public long getTickPosition() {\n    try {\n      return (getSequencer().getTickPosition() + 1);\n    } catch (Throwable throwable) {\n      LOG.error(throwable);\n    }", "refactored_code": "  private static final int TICK_MOVE = 1;\n\n  public long getTickPosition() {\n    try {\n      return (getSequencer().getTickPosition() + TICK_MOVE);\n    } catch (Throwable throwable) {\n      LOG.error(throwable);\n    }"}
{"magic_number_smell": "\n  protected GridData getTableData() {\n    GridData data = new GridData(SWT.FILL, SWT.FILL, true, true);\n    data.minimumHeight = 200;\n    return data;\n  }\n", "refactored_code": "  private static final int TABLE_HEIGHT = 200;\n\n  protected GridData getTableData() {\n    GridData data = new GridData(SWT.FILL, SWT.FILL, true, true);\n    data.minimumHeight = TABLE_HEIGHT;\n    return data;\n  }\n"}
{"magic_number_smell": "  }\n\n  public static MidiEvent systemReset(final long tick) {\n    return new MidiEvent(tick, MIDI_SYSTEM_EVENT, -1, null);\n  }\n\n  public static MidiEvent tempoInUSQ(final long tick, final int usq) {", "refactored_code": "  public static final int ALL_TRACKS = -1;\n  }\n\n  public static MidiEvent systemReset(final long tick) {\n    return new MidiEvent(tick, MIDI_SYSTEM_EVENT, ALL_TRACKS, null);\n  }\n\n  public static MidiEvent tempoInUSQ(final long tick, final int usq) {"}
{"magic_number_smell": "      try {\n        synchronized (this.sequencer) {\n          while (this.sequencer.process()) {\n            this.sequencer.wait(15);\n          }\n        }\n      } catch (Throwable throwable) {", "refactored_code": "    private static final int TIMER_DELAY = 15;\n      try {\n        synchronized (this.sequencer) {\n          while (this.sequencer.process()) {\n            this.sequencer.wait(TIMER_DELAY);\n          }\n        }\n      } catch (Throwable throwable) {"}
{"magic_number_smell": "    this.time = System.currentTimeMillis();\n    if (!this.tickChanged) {\n      this.tick += (TGDuration.QUARTER_TIME\n          * ((float) getTempo() * (float) (this.time - this.lastTime) / 60f) / 1000);\n    }\n    this.tickChanged = false;\n  }", "refactored_code": "  private static final int SECOND_IN_MILLIS = 1000;\n    this.time = System.currentTimeMillis();\n    if (!this.tickChanged) {\n      this.tick += (TGDuration.QUARTER_TIME\n          * ((float) getTempo() * (float) (this.time - this.lastTime) / 60f) / SECOND_IN_MILLIS);\n    }\n    this.tickChanged = false;\n  }"}
{"magic_number_smell": "\n    boolean[] usedChannels = getUsedChannels();\n    boolean[] usedEffectChannels = getUsedEffectChannels();\n    for (short i = 0; i < 16; i++) {\n      if (!TGChannel.isPercussionChannel(i) && !usedChannels[i]\n          && !usedEffectChannels[i]) {\n        normalChannel = (normalChannel < 0) ? i : normalChannel;", "refactored_code": "  public static final short MAX_CHANNELS = 16;\n\n    boolean[] usedChannels = getUsedChannels();\n    boolean[] usedEffectChannels = getUsedEffectChannels();\n    for (short i = 0; i < MAX_CHANNELS; i++) {\n      if (!TGChannel.isPercussionChannel(i) && !usedChannels[i]\n          && !usedEffectChannels[i]) {\n        normalChannel = (normalChannel < 0) ? i : normalChannel;"}
{"magic_number_smell": "  private long start = TGDuration.QUARTER_TIME;\n  private TGStroke stroke = TGStroke.DEFAULT;\n  private TGText text = null;\n  private TGVoice[] voices = new TGVoice[2];\n\n  public TGBeat() {\n    for (int i = 0; i < 2; i++) {", "refactored_code": "  public static final int MAX_VOICES = 2;\n  private long start = TGDuration.QUARTER_TIME;\n  private TGStroke stroke = TGStroke.DEFAULT;\n  private TGText text = null;\n  private TGVoice[] voices = new TGVoice[MAX_VOICES];\n\n  public TGBeat() {\n    for (int i = 0; i < MAX_VOICES; i++) {"}
{"magic_number_smell": "    channel.setEffectChannel(DEFAULT_PERCUSSION_CHANNEL);\n  }\n\n  private short balance = 64;\n  private short channel = 0;\n  private short chorus = DEFAULT_CHORUS;\n  private short effectChannel = 0;", "refactored_code": "  public static final short DEFAULT_BALANCE = 64;\n    channel.setEffectChannel(DEFAULT_PERCUSSION_CHANNEL);\n  }\n\n  private short balance = DEFAULT_BALANCE;\n  private short channel = 0;\n  private short chorus = DEFAULT_CHORUS;\n  private short effectChannel = 0;"}
{"magic_number_smell": "  private List<TGBeat> beats = new ArrayList<TGBeat>();\n  private Clef clef = DEFAULT_CLEF;\n  private TGMeasureHeader header;\n  private int keySignature = 0;\n\n  private TGTrack track;\n", "refactored_code": "  public static final int DEFAULT_KEY_SIGNATURE = 0;\n  private List<TGBeat> beats = new ArrayList<TGBeat>();\n  private Clef clef = DEFAULT_CLEF;\n  private TGMeasureHeader header;\n  private int keySignature = DEFAULT_KEY_SIGNATURE;\n\n  private TGTrack track;\n"}
{"magic_number_smell": "  }\n\n  public static TGTempo fromUSQ(int usq) {\n    return new TGTempo((int) ((60.00 * 1000) / (usq / 1000.00)));\n  }\n\n  private int value = DEFAULT_VALUE;", "refactored_code": "  private static final int SECOND_IN_MILLIS = 1000;\n  }\n\n  public static TGTempo fromUSQ(int usq) {\n    return new TGTempo((int) ((60.00 * SECOND_IN_MILLIS) / (usq / 1000.00)));\n  }\n\n  private int value = DEFAULT_VALUE;"}
{"magic_number_smell": "\n  public static final int MIN_VELOCITY = 15;\n\n  public static final int FORTE = (MIN_VELOCITY + (16 * 5));\n\n  public static final int DEFAULT = FORTE;\n", "refactored_code": "  public static final int VELOCITY_INCREMENT = 16;\n\n  public static final int MIN_VELOCITY = 15;\n\n  public static final int FORTE = (MIN_VELOCITY + (VELOCITY_INCREMENT * 5));\n\n  public static final int DEFAULT = FORTE;\n"}
{"magic_number_smell": "  }\n\n  public long getTime(long duration) {\n    return (duration * this.getPosition() / 12);\n  }\n\n  public int getValue() {", "refactored_code": "  public static final int MAX_POSITION_LENGTH = 12;\n  }\n\n  public long getTime(long duration) {\n    return (duration * this.getPosition() / MAX_POSITION_LENGTH);\n  }\n\n  public int getValue() {"}
{"magic_number_smell": "      ByteArrayInputStream in = new ByteArrayInputStream(bytes);\n      ByteArrayOutputStream out = new ByteArrayOutputStream();\n\n      byte buffer[] = new byte[1024];\n      byte chunk[] = new byte[4];\n      int got = -1;\n      int ready = 0;", "refactored_code": "  private static final int BUFFER_SIZE = 1024;\n      ByteArrayInputStream in = new ByteArrayInputStream(bytes);\n      ByteArrayOutputStream out = new ByteArrayOutputStream();\n\n      byte buffer[] = new byte[BUFFER_SIZE];\n      byte chunk[] = new byte[4];\n      int got = -1;\n      int ready = 0;"}
{"magic_number_smell": "      ByteArrayInputStream in = new ByteArrayInputStream(bytes);\n      ByteArrayOutputStream out = new ByteArrayOutputStream();\n\n      byte buffer[] = new byte[1024];\n      int got = -1;\n      int off = 0;\n      int count = 0;", "refactored_code": "  private static final int BUFFER_SIZE = 1024;\n      ByteArrayInputStream in = new ByteArrayInputStream(bytes);\n      ByteArrayOutputStream out = new ByteArrayOutputStream();\n\n      byte buffer[] = new byte[BUFFER_SIZE];\n      int got = -1;\n      int off = 0;\n      int count = 0;"}
{"magic_number_smell": "\t\t\t\tmenuItem.setEnabled( true );\n\t\t\t\tTGCocoa.setControlAction(menuItem, sel_preferencesMenuItemSelected_);\n\t\t\t}\n\t\t\tif( itemCount > 0 ) {\n\t\t\t\tNSMenuItem menuItem = TGCocoa.getMenuItemAtIndex( appMenu , 0 );\n\t\t\t\tmenuItem.setEnabled( true );\n\t\t\t\tTGCocoa.setControlAction(menuItem, sel_aboutMenuItemSelected_);", "refactored_code": "\tprivate static final long kAboutMenuItem = 0;\n\t\t\t\tmenuItem.setEnabled( true );\n\t\t\t\tTGCocoa.setControlAction(menuItem, sel_preferencesMenuItemSelected_);\n\t\t\t}\n\t\t\tif( itemCount > kAboutMenuItem ) {\n\t\t\t\tNSMenuItem menuItem = TGCocoa.getMenuItemAtIndex( appMenu , kAboutMenuItem );\n\t\t\t\tmenuItem.setEnabled( true );\n\t\t\t\tTGCocoa.setControlAction(menuItem, sel_aboutMenuItemSelected_);"}
{"magic_number_smell": "\t\t\t\n\t\t\tlong callbackProc = TGCocoa.getCallbackAddress( callback );\n\t\t\tif( callbackProc != 0 ){\n\t\t\t\tTGCocoa.class_addMethod(cls, TGCocoa.sel_registerName(\"application:openFile:\"), callbackProc , \"B:@@\");\n\t\t\t}\n\t\t}\n\t}", "refactored_code": "\tpublic static final long sel_application_openFile_ = TGCocoa.sel_registerName(\"application:openFile:\");\n\t\t\t\n\t\t\tlong callbackProc = TGCocoa.getCallbackAddress( callback );\n\t\t\tif( callbackProc != 0 ){\n\t\t\t\tTGCocoa.class_addMethod(cls, sel_application_openFile_, callbackProc , \"B:@@\");\n\t\t\t}\n\t\t}\n\t}"}
{"magic_number_smell": "\t\t\tdummyBar.release();\n\t\t\tnsWindow.setShowsToolbarButton(true);\n\t\t\t\n\t\t\tNSButton toolbarButton = TGCocoa.getStandardWindowButton(nsWindow, 3);\n\t\t\tif (toolbarButton != null) {\n\t\t\t\ttoolbarButton.setTarget( delegate );\n\t\t\t\tTGCocoa.setControlAction( toolbarButton , sel_toolbarButtonClicked_ );", "refactored_code": "\tprivate static final long NSWindowToolbarButton = 3;\n\t\t\tdummyBar.release();\n\t\t\tnsWindow.setShowsToolbarButton(true);\n\t\t\t\n\t\t\tNSButton toolbarButton = TGCocoa.getStandardWindowButton(nsWindow, NSWindowToolbarButton);\n\t\t\tif (toolbarButton != null) {\n\t\t\t\ttoolbarButton.setTarget( delegate );\n\t\t\t\tTGCocoa.setControlAction( toolbarButton , sel_toolbarButtonClicked_ );"}
{"magic_number_smell": "\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif ((flags & 0x01) != 0) {\n\t\t\t\tActionLock.lock();\n\t\t\t}\n\t\t\t", "refactored_code": "\tprotected static final int AUTO_LOCK = 0x01;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif ((flags & AUTO_LOCK) != 0) {\n\t\t\t\tActionLock.lock();\n\t\t\t}\n\t\t\t"}
{"magic_number_smell": "\t}\n\t\n\tprotected GridBagConstraints getConstraints(int column, int row, float weightx, float weighty, int fill , int colspan, int rowspan){\n\t\treturn getConstraints(column, row, weightx, weighty, fill, colspan, rowspan, 2);\n\t}\n\t\n\tprotected GridBagConstraints getConstraints(int column, int row, float weightx, float weighty, int fill , int colspan, int rowspan, int margin){", "refactored_code": "\tpublic static final int DEFAULT_MARGIN = 2;\n\t}\n\t\n\tprotected GridBagConstraints getConstraints(int column, int row, float weightx, float weighty, int fill , int colspan, int rowspan){\n\t\treturn getConstraints(column, row, weightx, weighty, fill, colspan, rowspan, DEFAULT_MARGIN);\n\t}\n\t\n\tprotected GridBagConstraints getConstraints(int column, int row, float weightx, float weighty, int fill , int colspan, int rowspan, int margin){"}
{"magic_number_smell": "\tpublic static final int SOLO = 0x02;\n\tpublic static final int VOLUME = 0x04;\n\tpublic static final int BALANCE = 0x08;\n\tpublic static final int CHANGE_ALL = (0x01 | SOLO | VOLUME | BALANCE );\n\t\n\tprivate boolean locked;\n\t", "refactored_code": "\tpublic static final int MUTE = 0x01;\n\tpublic static final int SOLO = 0x02;\n\tpublic static final int VOLUME = 0x04;\n\tpublic static final int BALANCE = 0x08;\n\tpublic static final int CHANGE_ALL = (MUTE | SOLO | VOLUME | BALANCE );\n\t\n\tprivate boolean locked;\n\t"}
{"magic_number_smell": "\t}\n\t\n\tpublic void initPath(){\n\t\tthis.initPath( 0x01 );\n\t}\n\t /** The Logger for this class. */\n  public static final transient Logger LOG = Logger.getLogger(TGPainter.class);", "refactored_code": "\tpublic static final int PATH_DRAW = 0x01;\n\t}\n\t\n\tpublic void initPath(){\n\t\tthis.initPath( PATH_DRAW );\n\t}\n\t /** The Logger for this class. */\n  public static final transient Logger LOG = Logger.getLogger(TGPainter.class);"}
{"magic_number_smell": "\t\t\n\t\tpublic void process() {\n\t\t\tif( TuxGuitar.instance().getTablatureEditor().isStarted() ){\n\t\t\t\tthis.scrollBar.setValue( this.scrollBar.getValue() + ( this.direction * 50 ) );\n\t\t\t\tTuxGuitar.instance().getTablatureEditor().repaint();\n\t\t\t}\n\t\t}", "refactored_code": "\tpublic static final int DEFAULT_INCREMENT = 50;\n\t\t\n\t\tpublic void process() {\n\t\t\tif( TuxGuitar.instance().getTablatureEditor().isStarted() ){\n\t\t\t\tthis.scrollBar.setValue( this.scrollBar.getValue() + ( this.direction * DEFAULT_INCREMENT ) );\n\t\t\t\tTuxGuitar.instance().getTablatureEditor().repaint();\n\t\t\t}\n\t\t}"}
{"magic_number_smell": "\tpublic TGBeatGroup(int voice){\n\t\tthis.voice = voice;\n\t\tthis.voices = new ArrayList();\n\t\tthis.direction = 0;\n\t\tthis.firstMinNote = null;\n\t\tthis.firstMaxNote = null;\n\t\tthis.lastMinNote = null;", "refactored_code": "\tpublic static final int DIRECTION_NOT_SETTED = 0;\n\tpublic TGBeatGroup(int voice){\n\t\tthis.voice = voice;\n\t\tthis.voices = new ArrayList();\n\t\tthis.direction = DIRECTION_NOT_SETTED;\n\t\tthis.firstMinNote = null;\n\t\tthis.firstMaxNote = null;\n\t\tthis.lastMinNote = null;"}
{"magic_number_smell": "\tpublic static final int POSITION_FADE_IN = 9;\n\t\n\tprivate static final int[] EFFECT_POSITIONS = new int[]{\n\t\t0,\n\t\tPOSITION_HEAVY_ACCENTUATED_EFFECT,\n\t\tPOSITION_HARMONIC_EFFEC,\n\t\tPOSITION_TAPPING_EFFEC,", "refactored_code": "\tpublic static final int POSITION_ACCENTUATED_EFFECT = 0;\n\tpublic static final int POSITION_FADE_IN = 9;\n\t\n\tprivate static final int[] EFFECT_POSITIONS = new int[]{\n\t\tPOSITION_ACCENTUATED_EFFECT,\n\t\tPOSITION_HEAVY_ACCENTUATED_EFFECT,\n\t\tPOSITION_HARMONIC_EFFEC,\n\t\tPOSITION_TAPPING_EFFEC,"}
{"magic_number_smell": "\tprotected void updateDiagram(boolean makeBuffer){\n\t\tFont font = getFirstFretFont();\n\t\tthis.diagramWidth = getStringSpacing() + (getStringSpacing() * countStrings()) + ((font != null)?getFirstFretSpacing():0);\n\t\tthis.diagramHeight = getFretSpacing() + (getFretSpacing() * 6);\n\t\tif(this.diagram == null && makeBuffer){\n\t\t\tthis.diagram = new BufferedImage(this.diagramWidth,this.diagramHeight,BufferedImage.TYPE_INT_RGB);\n\t\t\tTGPainter painter = new TGPainter(this.diagram);", "refactored_code": "\tpublic static final int MAX_FRETS = 6;\n\tprotected void updateDiagram(boolean makeBuffer){\n\t\tFont font = getFirstFretFont();\n\t\tthis.diagramWidth = getStringSpacing() + (getStringSpacing() * countStrings()) + ((font != null)?getFirstFretSpacing():0);\n\t\tthis.diagramHeight = getFretSpacing() + (getFretSpacing() * MAX_FRETS);\n\t\tif(this.diagram == null && makeBuffer){\n\t\t\tthis.diagram = new BufferedImage(this.diagramWidth,this.diagramHeight,BufferedImage.TYPE_INT_RGB);\n\t\t\tTGPainter painter = new TGPainter(this.diagram);"}
{"magic_number_smell": "\t}\n\t\n\tpublic int getTimeSignatureSpacing(ViewLayout layout){\n\t\treturn (shouldPaintTimeSignature()? Math.round( 30 * layout.getScale() ):0);\n\t}\n\t\n\tpublic int getLeftSpacing(ViewLayout layout){", "refactored_code": "\tprivate static final int DEFAULT_TIME_SIGNATURE_SPACING = 30;\n\t}\n\t\n\tpublic int getTimeSignatureSpacing(ViewLayout layout){\n\t\treturn (shouldPaintTimeSignature()? Math.round( DEFAULT_TIME_SIGNATURE_SPACING * layout.getScale() ):0);\n\t}\n\t\n\tpublic int getLeftSpacing(ViewLayout layout){"}
{"magic_number_smell": "\tpublic static final int FLAT = 3;\n\t\n\tpublic static final int KEY_SIGNATURES[][] = new int[][]{\n\t\t//------------1------------------------------------\n\t\t{1,1,1,1,1,1,1}, // 1\n\t\t//------------SHARPS------------------------------------\n\t\t{1,1,1,SHARP,1,1,1},   // 1 SHARP", "refactored_code": "\tpublic static final int NATURAL = 1;\n\tpublic static final int FLAT = 3;\n\t\n\tpublic static final int KEY_SIGNATURES[][] = new int[][]{\n\t\t//------------NATURAL------------------------------------\n\t\t{NATURAL,NATURAL,NATURAL,NATURAL,NATURAL,NATURAL,NATURAL}, // NATURAL\n\t\t//------------SHARPS------------------------------------\n\t\t{NATURAL,NATURAL,NATURAL,SHARP,NATURAL,NATURAL,NATURAL},   // 1 SHARP"}
{"magic_number_smell": "\t\n\tprivate void initImages(){\n\t\tthis.scoreNotes = new Image[4];\n\t\tthis.scoreNotes[0] = getScoreNoteImage( getScoreNoteColor(),false);\n\t\tthis.scoreNotes[SCORE_NOTE_EMPTY_PLAY_MODE] = getScoreNoteImage( getPlayNoteColor(),false);\n\t\tthis.scoreNotes[SCORE_NOTE_FULL_NORMAL_MODE] = getScoreNoteImage( getScoreNoteColor(),true);\n\t\tthis.scoreNotes[SCORE_NOTE_FULL_PLAY_MODE] = getScoreNoteImage( getPlayNoteColor(),true);", "refactored_code": "\tprivate static final int SCORE_NOTE_EMPTY_NORMAL_MODE = 0;\n\t\n\tprivate void initImages(){\n\t\tthis.scoreNotes = new Image[4];\n\t\tthis.scoreNotes[SCORE_NOTE_EMPTY_NORMAL_MODE] = getScoreNoteImage( getScoreNoteColor(),false);\n\t\tthis.scoreNotes[SCORE_NOTE_EMPTY_PLAY_MODE] = getScoreNoteImage( getPlayNoteColor(),false);\n\t\tthis.scoreNotes[SCORE_NOTE_FULL_NORMAL_MODE] = getScoreNoteImage( getScoreNoteColor(),true);\n\t\tthis.scoreNotes[SCORE_NOTE_FULL_PLAY_MODE] = getScoreNoteImage( getPlayNoteColor(),true);"}
{"magic_number_smell": "\t\n\tpublic TGSpacing(ViewLayout layout, int[][] positions, int len){\n\t\tthis.flags = 0;\n\t\tthis.flags |= ((layout.getStyle() & ViewLayout.DISPLAY_SCORE) != 0 ? 0x01 : 0 );\n\t\tthis.flags |= ((layout.getStyle() & ViewLayout.DISPLAY_TABLATURE) != 0 ? TABLATURE : 0 );\n\t\tthis.positions = positions;\n\t\tthis.spacing = new int[len];", "refactored_code": "\tpublic static final int SCORE = 0x01;\n\t\n\tpublic TGSpacing(ViewLayout layout, int[][] positions, int len){\n\t\tthis.flags = 0;\n\t\tthis.flags |= ((layout.getStyle() & ViewLayout.DISPLAY_SCORE) != 0 ? SCORE : 0 );\n\t\tthis.flags |= ((layout.getStyle() & ViewLayout.DISPLAY_TABLATURE) != 0 ? TABLATURE : 0 );\n\t\tthis.positions = positions;\n\t\tthis.spacing = new int[len];"}
{"magic_number_smell": "\tprivate static final int[][] POSITIONS = new int[][]{\n\t\t/** SCORE **/\n\t\tnew int[]{\n\t\t\t\t0,  //0\n\t\t\t\t1,  //POSITION_LOOP_MARKER\n\t\t\t\t2,  //POSITION_MARKER\n\t\t\t\t3,  //POSITION_TEXT", "refactored_code": "\tpublic static final int POSITION_TOP = 0;\n\tprivate static final int[][] POSITIONS = new int[][]{\n\t\t/** SCORE **/\n\t\tnew int[]{\n\t\t\t\t0,  //POSITION_TOP\n\t\t\t\t1,  //POSITION_LOOP_MARKER\n\t\t\t\t2,  //POSITION_MARKER\n\t\t\t\t3,  //POSITION_TEXT"}
{"magic_number_smell": "\t\t\n\t\t//si no hubo union decido para que lado girar la figura\n\t\tif (!noteJoined && withPrev) {\n\t\t\tthis.joinedType = 1;\n\t\t}\n\t\t\n\t\tif( (layout.getStyle() & ViewLayout.DISPLAY_TABLATURE) != 0 && (layout.getStyle() & ViewLayout.DISPLAY_SCORE) == 0){", "refactored_code": "\tpublic static final int JOINED_TYPE_NONE_LEFT = 1;\n\t\t\n\t\t//si no hubo union decido para que lado girar la figura\n\t\tif (!noteJoined && withPrev) {\n\t\t\tthis.joinedType = JOINED_TYPE_NONE_LEFT;\n\t\t}\n\t\t\n\t\tif( (layout.getStyle() & ViewLayout.DISPLAY_TABLATURE) != 0 && (layout.getStyle() & ViewLayout.DISPLAY_SCORE) == 0){"}
{"magic_number_smell": "\t\n\tprivate void updateDefaultControllers(){\n\t\ttry{\n\t\t\tfor(int channel = 0; channel < 16;channel ++){\n\t\t\t\tgetOutputTransmitter().sendControlChange(channel,MidiControllers.RPN_MSB,0);\n\t\t\t\tgetOutputTransmitter().sendControlChange(channel,MidiControllers.RPN_LSB,0);\n\t\t\t\tgetOutputTransmitter().sendControlChange(channel,MidiControllers.DATA_ENTRY_MSB,12);", "refactored_code": "\tprivate static final int MAX_CHANNELS = 16;\n\t\n\tprivate void updateDefaultControllers(){\n\t\ttry{\n\t\t\tfor(int channel = 0; channel < MAX_CHANNELS;channel ++){\n\t\t\t\tgetOutputTransmitter().sendControlChange(channel,MidiControllers.RPN_MSB,0);\n\t\t\t\tgetOutputTransmitter().sendControlChange(channel,MidiControllers.RPN_LSB,0);\n\t\t\t\tgetOutputTransmitter().sendControlChange(channel,MidiControllers.DATA_ENTRY_MSB,12);"}
{"magic_number_smell": "\tpublic void clear(){\n\t\tthis.loop = false;\n\t\tthis.type = TYPE_SIMPLE;\n\t\tthis.simplePercent = 100;\n\t\tthis.customPercentFrom = 100;\n\t\tthis.customPercentTo = 100;\n\t\tthis.customPercentIncrement = 0;", "refactored_code": "\tpublic static final int DEFAULT_TEMPO_PERCENT = 100;\n\tpublic void clear(){\n\t\tthis.loop = false;\n\t\tthis.type = TYPE_SIMPLE;\n\t\tthis.simplePercent = DEFAULT_TEMPO_PERCENT;\n\t\tthis.customPercentFrom = DEFAULT_TEMPO_PERCENT;\n\t\tthis.customPercentTo = DEFAULT_TEMPO_PERCENT;\n\t\tthis.customPercentIncrement = 0;"}
{"magic_number_smell": "\t\t\tlong start = (startMove + header.getStart());\n\t\t\tlong length = header.getTimeSignature().getDenominator().getTime();\n\t\t\tfor(int i = 1; i <= header.getTimeSignature().getNumerator();i ++){\n\t\t\t\tmakeNote(sequence,metronomeIndex(),37,start,length,TGVelocities.DEFAULT,9);\n\t\t\t\tstart += length;\n\t\t\t}\n\t\t}", "refactored_code": "\tprivate static final int DEFAULT_METRONOME_KEY = 37;\n\t\t\tlong start = (startMove + header.getStart());\n\t\t\tlong length = header.getTimeSignature().getDenominator().getTime();\n\t\t\tfor(int i = 1; i <= header.getTimeSignature().getNumerator();i ++){\n\t\t\t\tmakeNote(sequence,metronomeIndex(),DEFAULT_METRONOME_KEY,start,length,TGVelocities.DEFAULT,9);\n\t\t\t\tstart += length;\n\t\t\t}\n\t\t}"}
{"magic_number_smell": "\t\n\tpublic long getTickPosition() {\n\t\ttry {\n\t\t\treturn (getSequencer().getTickPosition() + 1);\n\t\t} catch (Throwable throwable) {\n\t\t\tthrowable.printStackTrace();\n\t\t}", "refactored_code": "\tprivate static final int TICK_MOVE = 1;\n\t\n\tpublic long getTickPosition() {\n\t\ttry {\n\t\t\treturn (getSequencer().getTickPosition() + TICK_MOVE);\n\t\t} catch (Throwable throwable) {\n\t\t\tthrowable.printStackTrace();\n\t\t}"}
{"magic_number_smell": "\tprivate byte[] data;\n\t\n\tpublic MidiEvent(long tick,int type,byte[] data){\n\t\tthis(tick,type,-1,data);\n\t}\n\t\n\tpublic MidiEvent(long tick,int type,int track,byte[] data){", "refactored_code": "\tpublic static final int ALL_TRACKS = -1;\n\tprivate byte[] data;\n\t\n\tpublic MidiEvent(long tick,int type,byte[] data){\n\t\tthis(tick,type,ALL_TRACKS,data);\n\t}\n\t\n\tpublic MidiEvent(long tick,int type,int track,byte[] data){"}
{"magic_number_smell": "\t\t\ttry {\n\t\t\t\tsynchronized(this.sequencer) {\n\t\t\t\t\twhile( this.sequencer.process() ){\n\t\t\t\t\t\tthis.sequencer.wait( 15 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (Throwable throwable) {", "refactored_code": "\t\tprivate static final int TIMER_DELAY = 15;\n\t\t\ttry {\n\t\t\t\tsynchronized(this.sequencer) {\n\t\t\t\t\twhile( this.sequencer.process() ){\n\t\t\t\t\t\tthis.sequencer.wait( TIMER_DELAY );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (Throwable throwable) {"}
{"magic_number_smell": "\t\tthis.lastTime = this.time;\n\t\tthis.time = System.currentTimeMillis();\n\t\tif(!this.tickChanged){\n\t\t\tthis.tick += (TGDuration.QUARTER_TIME * ((float)getTempo() * (float)(this.time - this.lastTime) / 60f) / 1000);\n\t\t}\n\t\tthis.tickChanged = false;\n\t}", "refactored_code": "\tprivate static final int SECOND_IN_MILLIS = 1000;\n\t\tthis.lastTime = this.time;\n\t\tthis.time = System.currentTimeMillis();\n\t\tif(!this.tickChanged){\n\t\t\tthis.tick += (TGDuration.QUARTER_TIME * ((float)getTempo() * (float)(this.time - this.lastTime) / 60f) / SECOND_IN_MILLIS);\n\t\t}\n\t\tthis.tickChanged = false;\n\t}"}
{"magic_number_smell": "\t\t\n\t\tboolean[] usedChannels = getUsedChannels();\n\t\tboolean[] usedEffectChannels = getUsedEffectChannels();\n\t\tfor(short i = 0;i < 16;i++){\n\t\t\tif(!TGChannel.isPercussionChannel(i) && !usedChannels[i] && !usedEffectChannels[i]){\n\t\t\t\tnormalChannel = (normalChannel < 0)?i:normalChannel;\n\t\t\t\teffectChannel = (effectChannel < 0 && i != normalChannel)?i:effectChannel;", "refactored_code": "\tpublic static final short MAX_CHANNELS = 16;\n\t\t\n\t\tboolean[] usedChannels = getUsedChannels();\n\t\tboolean[] usedEffectChannels = getUsedEffectChannels();\n\t\tfor(short i = 0;i < MAX_CHANNELS;i++){\n\t\t\tif(!TGChannel.isPercussionChannel(i) && !usedChannels[i] && !usedEffectChannels[i]){\n\t\t\t\tnormalChannel = (normalChannel < 0)?i:normalChannel;\n\t\t\t\teffectChannel = (effectChannel < 0 && i != normalChannel)?i:effectChannel;"}
{"magic_number_smell": "\tpublic TGBeat(TGFactory factory) {\n\t\tthis.start = TGDuration.QUARTER_TIME;\n\t\tthis.stroke = factory.newStroke();\n\t\tthis.voices = new TGVoice[ 2 ];\n\t\tfor( int i = 0 ; i < 2 ; i ++ ){\n\t\t\tthis.setVoice(i, factory.newVoice(i));\n\t\t}", "refactored_code": "\tpublic static final int MAX_VOICES = 2;\n\tpublic TGBeat(TGFactory factory) {\n\t\tthis.start = TGDuration.QUARTER_TIME;\n\t\tthis.stroke = factory.newStroke();\n\t\tthis.voices = new TGVoice[ MAX_VOICES ];\n\t\tfor( int i = 0 ; i < MAX_VOICES ; i ++ ){\n\t\t\tthis.setVoice(i, factory.newVoice(i));\n\t\t}"}
{"magic_number_smell": "\t}\n\t\n\tpublic static boolean isPercussionChannel(int channel){\n\t\treturn (channel == 9);\n\t}\n\t\n\tpublic static void setPercussionChannel(TGChannel channel){", "refactored_code": "\tpublic static final short DEFAULT_PERCUSSION_CHANNEL = 9;\n\t}\n\t\n\tpublic static boolean isPercussionChannel(int channel){\n\t\treturn (channel == DEFAULT_PERCUSSION_CHANNEL);\n\t}\n\t\n\tpublic static void setPercussionChannel(TGChannel channel){"}
{"magic_number_smell": "\t}\n\t\n\tpublic long getTime(){\n\t\tlong time = (long)( 960 * ( 4.0f / this.value ) ) ;\n\t\tif(this.dotted){\n\t\t\ttime += time / 2;\n\t\t}else if(this.doubleDotted){", "refactored_code": "\tpublic static final long QUARTER_TIME = 960;\n\t}\n\t\n\tpublic long getTime(){\n\t\tlong time = (long)( QUARTER_TIME * ( 4.0f / this.value ) ) ;\n\t\tif(this.dotted){\n\t\t\ttime += time / 2;\n\t\t}else if(this.doubleDotted){"}
{"magic_number_smell": "\tpublic static final int CLEF_TENOR = 3;\n\tpublic static final int CLEF_ALTO = 4;\n\t\n\tpublic static final int DEFAULT_CLEF = 1;\n\tpublic static final int DEFAULT_KEY_SIGNATURE= 0;\n\t\n\tprivate TGMeasureHeader header;", "refactored_code": "\tpublic static final int CLEF_TREBLE = 1;\n\tpublic static final int CLEF_TENOR = 3;\n\tpublic static final int CLEF_ALTO = 4;\n\t\n\tpublic static final int DEFAULT_CLEF = CLEF_TREBLE;\n\tpublic static final int DEFAULT_KEY_SIGNATURE= 0;\n\t\n\tprivate TGMeasureHeader header;"}
{"magic_number_smell": "\t\tthis.timeSignature = factory.newTimeSignature();\n\t\tthis.tempo = factory.newTempo();\n\t\tthis.marker = null;\n\t\tthis.tripletFeel = 1;\n\t\tthis.repeatOpen = false;\n\t\tthis.repeatClose = 0;\n\t\tthis.repeatAlternative = 0;", "refactored_code": "\tpublic static final int TRIPLET_FEEL_NONE = 1;\n\t\tthis.timeSignature = factory.newTimeSignature();\n\t\tthis.tempo = factory.newTempo();\n\t\tthis.marker = null;\n\t\tthis.tripletFeel = TRIPLET_FEEL_NONE;\n\t\tthis.repeatOpen = false;\n\t\tthis.repeatClose = 0;\n\t\tthis.repeatAlternative = 0;"}
{"magic_number_smell": "\tprivate int value;\n\t\n\tpublic TGStroke(){\n\t\tthis.direction = 0;\n\t}\n\n\tpublic int getDirection() {", "refactored_code": "\tpublic static final int STROKE_NONE = 0;\n\tprivate int value;\n\t\n\tpublic TGStroke(){\n\t\tthis.direction = STROKE_NONE;\n\t}\n\n\tpublic int getDirection() {"}
{"magic_number_smell": "\t}\n\t\n\tpublic long getInMillis(){\n\t\tdouble millis = (60.00 / getValue() * 1000);\n\t\treturn (long)millis;\n\t}\n\t", "refactored_code": "\tprivate static final int SECOND_IN_MILLIS = 1000;\n\t}\n\t\n\tpublic long getInMillis(){\n\t\tdouble millis = (60.00 / getValue() * SECOND_IN_MILLIS);\n\t\treturn (long)millis;\n\t}\n\t"}
{"magic_number_smell": "\t\n\tpublic static final int VELOCITY_INCREMENT = 16;\n\t\n\tpublic static final int PIANO_PIANISSIMO = (15);\n\t\n\tpublic static final int PIANISSIMO = (15 + VELOCITY_INCREMENT);\n\t", "refactored_code": "\tpublic static final int MIN_VELOCITY = 15;\n\t\n\tpublic static final int VELOCITY_INCREMENT = 16;\n\t\n\tpublic static final int PIANO_PIANISSIMO = (MIN_VELOCITY);\n\t\n\tpublic static final int PIANISSIMO = (MIN_VELOCITY + VELOCITY_INCREMENT);\n\t"}
{"magic_number_smell": "\t\tthis.notes = new ArrayList();\n\t\tthis.index = index;\n\t\tthis.empty = true;\n\t\tthis.direction = 0;\n\t}\n\t\n\tpublic int getIndex() {", "refactored_code": "\tpublic static final int DIRECTION_NONE = 0;\n\t\tthis.notes = new ArrayList();\n\t\tthis.index = index;\n\t\tthis.empty = true;\n\t\tthis.direction = DIRECTION_NONE;\n\t}\n\t\n\tpublic int getIndex() {"}
{"magic_number_smell": "public abstract class TGEffectBend {\n\tpublic static final int 1 = 1;\n\tpublic static final int MAX_POSITION_LENGTH = 12;\n\tpublic static final int MAX_VALUE_LENGTH = (1 * 12);\n\t\n\tprivate List points;\n\t", "refactored_code": "\tpublic static final int SEMITONE_LENGTH = 1;\npublic abstract class TGEffectBend {\n\tpublic static final int SEMITONE_LENGTH = 1;\n\tpublic static final int MAX_POSITION_LENGTH = 12;\n\tpublic static final int MAX_VALUE_LENGTH = (SEMITONE_LENGTH * 12);\n\t\n\tprivate List points;\n\t"}
{"magic_number_smell": "\t\tthis.fret = 0;\n\t\tthis.duration = 1;\n\t\tthis.dynamic = TGVelocities.DEFAULT;\n\t\tthis.transition = 0;\n\t\tthis.onBeat = false;\n\t\tthis.dead = false;\n\t}", "refactored_code": "\tpublic static final int TRANSITION_NONE = 0;\n\t\tthis.fret = 0;\n\t\tthis.duration = 1;\n\t\tthis.dynamic = TGVelocities.DEFAULT;\n\t\tthis.transition = TRANSITION_NONE;\n\t\tthis.onBeat = false;\n\t\tthis.dead = false;\n\t}"}
{"magic_number_smell": "\t}\n\t\n\tpublic boolean isNatural(){\n\t\treturn (this.type == 1);\n\t}\n\t\n\tpublic boolean isArtificial(){", "refactored_code": "\tpublic static final int TYPE_NATURAL = 1;\n\t}\n\t\n\tpublic boolean isNatural(){\n\t\treturn (this.type == TYPE_NATURAL);\n\t}\n\t\n\tpublic boolean isArtificial(){"}
{"magic_number_smell": "\t\t}\n\t\t\n\t\tpublic long getTime(long duration){\n\t\t\treturn (duration * getPosition() / 12);\n\t\t}\n\t\t\n\t\tpublic Object clone(){", "refactored_code": "\tpublic static final int MAX_POSITION_LENGTH = 12;\n\t\t}\n\t\t\n\t\tpublic long getTime(long duration){\n\t\t\treturn (duration * getPosition() / MAX_POSITION_LENGTH);\n\t\t}\n\t\t\n\t\tpublic Object clone(){"}
{"magic_number_smell": "    private String bindAddress = DEFAULT_BIND_ADDRESS;\n\n    @Parameter(value = \"datanode_http_port\", required = true)\n    private int datanodeHttpPort = 8999;\n\n    @Parameter(value = \"hostname\")\n    private String hostname = null;", "refactored_code": "    public static final int DATANODE_DEFAULT_PORT = 8999;\n    private String bindAddress = DEFAULT_BIND_ADDRESS;\n\n    @Parameter(value = \"datanode_http_port\", required = true)\n    private int datanodeHttpPort = DATANODE_DEFAULT_PORT;\n\n    @Parameter(value = \"hostname\")\n    private String hostname = null;"}
{"magic_number_smell": "    @Override\n    protected void configure() {\n        // TODO Add instrumentation to ExecutorService and ThreadFactory\n        final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(30,\n                new ThreadFactoryBuilder()\n                        .setNameFormat(\"scheduled-%d\")\n                        .setDaemon(false)", "refactored_code": "    private static final int SCHEDULED_THREADS_POOL_SIZE = 30;\n    @Override\n    protected void configure() {\n        // TODO Add instrumentation to ExecutorService and ThreadFactory\n        final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(SCHEDULED_THREADS_POOL_SIZE,\n                new ThreadFactoryBuilder()\n                        .setNameFormat(\"scheduled-%d\")\n                        .setDaemon(false)"}
{"magic_number_smell": "\n        if (vmMaxMapCount == 0) {\n            LOG.warn(\"Couldn't read value from {}\", PROC_SYS_VM_MAX_MAP_COUNT_PATH);\n        } else if (vmMaxMapCount < 262144L) {\n            throw new PreflightCheckException(f(\"%s value should be at least %d but is %d (set via \\\"vm.max_map_count\\\" sysctl)\",\n                    PROC_SYS_VM_MAX_MAP_COUNT_PATH, 262144L, vmMaxMapCount));\n        }", "refactored_code": "    private static final long MAX_MAP_COUNT_MIN = 262144L;\n\n        if (vmMaxMapCount == 0) {\n            LOG.warn(\"Couldn't read value from {}\", PROC_SYS_VM_MAX_MAP_COUNT_PATH);\n        } else if (vmMaxMapCount < MAX_MAP_COUNT_MIN) {\n            throw new PreflightCheckException(f(\"%s value should be at least %d but is %d (set via \\\"vm.max_map_count\\\" sysctl)\",\n                    PROC_SYS_VM_MAX_MAP_COUNT_PATH, MAX_MAP_COUNT_MIN, vmMaxMapCount));\n        }"}
{"magic_number_smell": "        IndexInput indexInput = EndiannessReverserUtil.openInput(directory, filename, IOContext.DEFAULT);\n        // We checksum the entire file before we even go and parse it. If it's corrupted we barf right here.\n        CodecUtil.checksumEntireFile(indexInput);\n        CodecUtil.checkHeader(indexInput, STATE_FILE_CODEC, 1, STATE_FILE_VERSION);\n        final int xcontentTypeValue = indexInput.readInt();\n        long filePointer = indexInput.getFilePointer();\n        long contentSize = indexInput.length() - CodecUtil.footerLength() - filePointer;", "refactored_code": "    private static final int MIN_COMPATIBLE_STATE_FILE_VERSION = 1;\n        IndexInput indexInput = EndiannessReverserUtil.openInput(directory, filename, IOContext.DEFAULT);\n        // We checksum the entire file before we even go and parse it. If it's corrupted we barf right here.\n        CodecUtil.checksumEntireFile(indexInput);\n        CodecUtil.checkHeader(indexInput, STATE_FILE_CODEC, MIN_COMPATIBLE_STATE_FILE_VERSION, STATE_FILE_VERSION);\n        final int xcontentTypeValue = indexInput.readInt();\n        long filePointer = indexInput.getFilePointer();\n        long contentSize = indexInput.length() - CodecUtil.footerLength() - filePointer;"}
{"magic_number_smell": "    private OpensearchProcess createOpensearchProcess(final DatanodeConfiguration datanodeConfiguration, final CustomCAX509TrustManager trustManager, final Configuration configuration,\n                                                      final NodeService<DataNodeDto> nodeService, final ObjectMapper objectMapper, final ProcessStateMachine processStateMachine) {\n        final OpensearchProcessImpl process = new OpensearchProcessImpl(datanodeConfiguration, datanodeConfiguration.processLogsBufferSize(), trustManager, configuration, nodeService, objectMapper, processStateMachine);\n        final ProcessWatchdog watchdog = new ProcessWatchdog(process, 3);\n        process.addStateMachineTracer(watchdog);\n        process.addStateMachineTracer(new StateMachineTransitionLogger());\n        process.addStateMachineTracer(new OpensearchRemovalTracer(process, configuration.getDatanodeNodeName(), nodeId, clusterEventBus));", "refactored_code": "    private static final int WATCHDOG_RESTART_ATTEMPTS = 3;\n    private OpensearchProcess createOpensearchProcess(final DatanodeConfiguration datanodeConfiguration, final CustomCAX509TrustManager trustManager, final Configuration configuration,\n                                                      final NodeService<DataNodeDto> nodeService, final ObjectMapper objectMapper, final ProcessStateMachine processStateMachine) {\n        final OpensearchProcessImpl process = new OpensearchProcessImpl(datanodeConfiguration, datanodeConfiguration.processLogsBufferSize(), trustManager, configuration, nodeService, objectMapper, processStateMachine);\n        final ProcessWatchdog watchdog = new ProcessWatchdog(process, WATCHDOG_RESTART_ATTEMPTS);\n        process.addStateMachineTracer(watchdog);\n        process.addStateMachineTracer(new StateMachineTransitionLogger());\n        process.addStateMachineTracer(new OpensearchRemovalTracer(process, configuration.getDatanodeNodeName(), nodeId, clusterEventBus));"}
{"magic_number_smell": "\n    public static ProcessStateMachine createNew() {\n\n        final FailuresCounter restFailureCounter = FailuresCounter.oneBased(3);\n        final FailuresCounter startupFailuresCounter = FailuresCounter.oneBased(MAX_REST_STARTUP_FAILURES);\n        final FailuresCounter rebootCounter = FailuresCounter.oneBased(MAX_REBOOT_FAILURES);\n", "refactored_code": "    public static final int MAX_REST_TEMPORARY_FAILURES = 3;\n\n    public static ProcessStateMachine createNew() {\n\n        final FailuresCounter restFailureCounter = FailuresCounter.oneBased(MAX_REST_TEMPORARY_FAILURES);\n        final FailuresCounter startupFailuresCounter = FailuresCounter.oneBased(MAX_REST_STARTUP_FAILURES);\n        final FailuresCounter rebootCounter = FailuresCounter.oneBased(MAX_REBOOT_FAILURES);\n"}
{"magic_number_smell": "\n    public static Builder builder() {\n        return new AutoValue_RestOperationParameters.Builder()\n                .attempts_count(160);\n    }\n\n    abstract Builder toBuilder();", "refactored_code": "    private static final int DEFAULT_ATTEMPTS_COUNT = 160;\n\n    public static Builder builder() {\n        return new AutoValue_RestOperationParameters.Builder()\n                .attempts_count(DEFAULT_ATTEMPTS_COUNT);\n    }\n\n    abstract Builder toBuilder();"}
{"magic_number_smell": "        MavenPackager.packageJarIfNecessary(new DefaultMavenProjectDirProvider());\n\n        return new DatanodeDevContainerBuilder()\n                .restPort(8999)\n                .openSearchHttpPort(DATANODE_OPENSEARCH_HTTP_PORT)\n                .openSearchTransportPort(DATANODE_OPENSEARCH_TRANSPORT_PORT)\n                .mongoDbUri(mongoDBTestService.internalUri())", "refactored_code": "    public static final int DATANODE_REST_PORT = 8999;\n        MavenPackager.packageJarIfNecessary(new DefaultMavenProjectDirProvider());\n\n        return new DatanodeDevContainerBuilder()\n                .restPort(DATANODE_REST_PORT)\n                .openSearchHttpPort(DATANODE_OPENSEARCH_HTTP_PORT)\n                .openSearchTransportPort(DATANODE_OPENSEARCH_TRANSPORT_PORT)\n                .mongoDbUri(mongoDBTestService.internalUri())"}
{"magic_number_smell": "    }\n\n    public static <T> T waitForObject(Producer<Optional<T>> predicate, String timeoutErrorMessage) {\n        return waitForObject(predicate, timeoutErrorMessage, Duration.of(10000, ChronoUnit.MILLIS));\n    }\n\n    public static <T> T waitForObject(Producer<Optional<T>> predicate, String timeoutErrorMessage, Duration timeout) {", "refactored_code": "    private static final int TIMEOUT_MS = 10000;\n    }\n\n    public static <T> T waitForObject(Producer<Optional<T>> predicate, String timeoutErrorMessage) {\n        return waitForObject(predicate, timeoutErrorMessage, Duration.of(TIMEOUT_MS, ChronoUnit.MILLIS));\n    }\n\n    public static <T> T waitForObject(Producer<Optional<T>> predicate, String timeoutErrorMessage, Duration timeout) {"}
{"magic_number_smell": "        searchSourceBuilder.aggregation(AggregationBuilders\n                .terms(Message.FIELD_STREAMS)\n                .field(Message.FIELD_STREAMS)\n                .size(10_000));\n        return searchSourceBuilder;\n    }\n", "refactored_code": "    private static final int SEARCH_MAX_BUCKETS_ES = 10_000;\n        searchSourceBuilder.aggregation(AggregationBuilders\n                .terms(Message.FIELD_STREAMS)\n                .field(Message.FIELD_STREAMS)\n                .size(SEARCH_MAX_BUCKETS_ES));\n        return searchSourceBuilder;\n    }\n"}
{"magic_number_smell": "            for (String timeField : timeSpec.fields()) {\n                final AutoDateHistogramAggregationBuilder builder = new AutoDateHistogramAggregationBuilder(name)\n                        .field(timeField)\n                        .setNumBuckets((int) (25 / autoInterval.scaling()))\n                        .format(DATE_TIME_FORMAT);\n\n                if (root == null && leaf == null) {", "refactored_code": "    private static final int BASE_NUM_BUCKETS = 25;\n            for (String timeField : timeSpec.fields()) {\n                final AutoDateHistogramAggregationBuilder builder = new AutoDateHistogramAggregationBuilder(name)\n                        .field(timeField)\n                        .setNumBuckets((int) (BASE_NUM_BUCKETS / autoInterval.scaling()))\n                        .format(DATE_TIME_FORMAT);\n\n                if (root == null && leaf == null) {"}
{"magic_number_smell": "        final SearchSourceBuilder search = this.searchRequestFactory.create(ChunkCommand.builder()\n                .indices(Collections.singleton(\"graylog_0\"))\n                .range(RANGE)\n                .batchSize(42)\n                .build());\n\n        assertThat(search.toString()).contains(\"\\\"size\\\":42\");", "refactored_code": "    private static final int BATCH_SIZE = 42;\n        final SearchSourceBuilder search = this.searchRequestFactory.create(ChunkCommand.builder()\n                .indices(Collections.singleton(\"graylog_0\"))\n                .range(RANGE)\n                .batchSize(BATCH_SIZE)\n                .build());\n\n        assertThat(search.toString()).contains(\"\\\"size\\\":42\");"}
{"magic_number_smell": "                .withEnv(\"DISABLE_INSTALL_DEMO_CONFIG\", \"true\")\n                .withNetwork(network)\n                .withNetworkAliases(hostname)\n                .waitingFor(Wait.forHttp(\"/\").forPort(9200));\n    }\n\n    @Override", "refactored_code": "    private static final int ES_PORT = 9200;\n                .withEnv(\"DISABLE_INSTALL_DEMO_CONFIG\", \"true\")\n                .withNetwork(network)\n                .withNetworkAliases(hostname)\n                .waitingFor(Wait.forHttp(\"/\").forPort(ES_PORT));\n    }\n\n    @Override"}
{"magic_number_smell": "\n        final var retryer = RetryerBuilder.<Boolean>newBuilder()\n                .withWaitStrategy(WaitStrategies.fixedWait(WAIT_BETWEEN_CONNECTION_ATTEMPTS, TimeUnit.SECONDS))\n                .withStopStrategy(StopStrategies.stopAfterAttempt(40))\n                .retryIfResult(response -> !response)\n                .retryIfException()\n                .build();", "refactored_code": "    private static final int CONNECTION_ATTEMPTS = 40;\n\n        final var retryer = RetryerBuilder.<Boolean>newBuilder()\n                .withWaitStrategy(WaitStrategies.fixedWait(WAIT_BETWEEN_CONNECTION_ATTEMPTS, TimeUnit.SECONDS))\n                .withStopStrategy(StopStrategies.stopAfterAttempt(CONNECTION_ATTEMPTS))\n                .retryIfResult(response -> !response)\n                .retryIfException()\n                .build();"}
{"magic_number_smell": "        searchSourceBuilder.aggregation(AggregationBuilders\n                .terms(Message.FIELD_STREAMS)\n                .field(Message.FIELD_STREAMS)\n                .size(65_535));\n        return searchSourceBuilder;\n    }\n}", "refactored_code": "    private static final int SEARCH_MAX_BUCKETS_OS = 65_535;\n        searchSourceBuilder.aggregation(AggregationBuilders\n                .terms(Message.FIELD_STREAMS)\n                .field(Message.FIELD_STREAMS)\n                .size(SEARCH_MAX_BUCKETS_OS));\n        return searchSourceBuilder;\n    }\n}"}
{"magic_number_smell": "            for (String timeField : timeSpec.fields()) {\n                final AutoDateHistogramAggregationBuilder builder = new AutoDateHistogramAggregationBuilder(name)\n                        .field(timeField)\n                        .setNumBuckets((int) (25 / autoInterval.scaling()))\n                        .format(DATE_TIME_FORMAT);\n\n                if (root == null && leaf == null) {", "refactored_code": "    private static final int BASE_NUM_BUCKETS = 25;\n            for (String timeField : timeSpec.fields()) {\n                final AutoDateHistogramAggregationBuilder builder = new AutoDateHistogramAggregationBuilder(name)\n                        .field(timeField)\n                        .setNumBuckets((int) (BASE_NUM_BUCKETS / autoInterval.scaling()))\n                        .format(DATE_TIME_FORMAT);\n\n                if (root == null && leaf == null) {"}
{"magic_number_smell": "        final SearchSourceBuilder search = this.searchRequestFactory.create(ChunkCommand.builder()\n                .indices(Collections.singleton(\"graylog_0\"))\n                .range(RANGE)\n                .batchSize(42)\n                .build());\n\n        assertThat(search.toString()).contains(\"\\\"size\\\":42\");", "refactored_code": "    private static final int BATCH_SIZE = 42;\n        final SearchSourceBuilder search = this.searchRequestFactory.create(ChunkCommand.builder()\n                .indices(Collections.singleton(\"graylog_0\"))\n                .range(RANGE)\n                .batchSize(BATCH_SIZE)\n                .build());\n\n        assertThat(search.toString()).contains(\"\\\"size\\\":42\");"}
{"magic_number_smell": "            }\n\n            if (!stopped) {\n                LOG.debug(\"Waiting {} seconds until next CloudTrail SQS check.\", 5);\n                Uninterruptibles.sleepUninterruptibly(5, TimeUnit.SECONDS);\n            }\n        }", "refactored_code": "    public static final int SLEEP_INTERVAL_SECS = 5;\n            }\n\n            if (!stopped) {\n                LOG.debug(\"Waiting {} seconds until next CloudTrail SQS check.\", SLEEP_INTERVAL_SECS);\n                Uninterruptibles.sleepUninterruptibly(SLEEP_INTERVAL_SECS, TimeUnit.SECONDS);\n            }\n        }"}
{"magic_number_smell": "        @JsonCreator\n        public static Builder create() {\n            return new AutoValue_EventsConfiguration.Builder()\n                    .eventsSearchTimeout(60000)\n                    .eventNotificationsRetry(DEFAULT_NOTIFICATIONS_RETRY_MS)\n                    .eventNotificationsBacklog(DEFAULT_NOTIFICATIONS_BACKLOG)\n                    .eventCatchupWindow(DEFAULT_CATCH_UP_WINDOW_MS)", "refactored_code": "    private static final long DEFAULT_SEARCH_TIMEOUT_MS = 60000;\n        @JsonCreator\n        public static Builder create() {\n            return new AutoValue_EventsConfiguration.Builder()\n                    .eventsSearchTimeout(DEFAULT_SEARCH_TIMEOUT_MS)\n                    .eventNotificationsRetry(DEFAULT_NOTIFICATIONS_RETRY_MS)\n                    .eventNotificationsBacklog(DEFAULT_NOTIFICATIONS_BACKLOG)\n                    .eventCatchupWindow(DEFAULT_CATCH_UP_WINDOW_MS)"}
{"magic_number_smell": "        for (EventNotificationStatus status : eventNotificationStatuses) {\n            if (status.triggeredAt().isPresent()) {\n                DateTime triggeredAt = status.triggeredAt().get();\n                if (triggeredAt.isBefore(clock.nowUTC().minusMillis((int) 86400000)) && status.gracePeriodMs() < 86400000) {\n                    deleted = deleted + dbNotificationGracePeriodService.deleteStatus(status.id());\n                }\n            }", "refactored_code": "    private static final long OUTOFDATE_IN_MS = 86400000;\n        for (EventNotificationStatus status : eventNotificationStatuses) {\n            if (status.triggeredAt().isPresent()) {\n                DateTime triggeredAt = status.triggeredAt().get();\n                if (triggeredAt.isBefore(clock.nowUTC().minusMillis((int) OUTOFDATE_IN_MS)) && status.gracePeriodMs() < OUTOFDATE_IN_MS) {\n                    deleted = deleted + dbNotificationGracePeriodService.deleteStatus(status.id());\n                }\n            }"}
{"magic_number_smell": "            // A precondition for the event processor is not ready yet. This job must be retried.\n            if (e.getEventDefinition().isPresent()) {\n                LOG.debug(\"Event processor <{}/{}> couldn't be executed because of a failed precondition (retry in {} ms)\",\n                        e.getEventDefinition().get().title(), e.getEventDefinitionId(), 5000);\n            } else {\n                LOG.debug(\"Event processor <{}> couldn't be executed because of a failed precondition (retry in {} ms)\",\n                        e.getEventDefinitionId(), 5000);", "refactored_code": "    private static final long RETRY_INTERVAL = 5000;\n            // A precondition for the event processor is not ready yet. This job must be retried.\n            if (e.getEventDefinition().isPresent()) {\n                LOG.debug(\"Event processor <{}/{}> couldn't be executed because of a failed precondition (retry in {} ms)\",\n                        e.getEventDefinition().get().title(), e.getEventDefinitionId(), RETRY_INTERVAL);\n            } else {\n                LOG.debug(\"Event processor <{}> couldn't be executed because of a failed precondition (retry in {} ms)\",\n                        e.getEventDefinitionId(), RETRY_INTERVAL);"}
{"magic_number_smell": "        try {\n            final Retryer<Void> retryer = RetryerBuilder.<Void>newBuilder()\n                    .retryIfExceptionOfType(InvalidParameterException.class)\n                    .withWaitStrategy(WaitStrategies.fixedWait(1000, SUBSCRIPTION_RETRY_DELAY_UNIT))\n                    .withStopStrategy(StopStrategies.stopAfterAttempt(SUBSCRIPTION_RETRY_MAX_ATTEMPTS))\n                    .withRetryListener(new RetryListener() {\n                        @Override", "refactored_code": "    private static final int SUBSCRIPTION_RETRY_DELAY = 1000;\n        try {\n            final Retryer<Void> retryer = RetryerBuilder.<Void>newBuilder()\n                    .retryIfExceptionOfType(InvalidParameterException.class)\n                    .withWaitStrategy(WaitStrategies.fixedWait(SUBSCRIPTION_RETRY_DELAY, SUBSCRIPTION_RETRY_DELAY_UNIT))\n                    .withStopStrategy(StopStrategies.stopAfterAttempt(SUBSCRIPTION_RETRY_MAX_ATTEMPTS))\n                    .withRetryListener(new RetryListener() {\n                        @Override"}
{"magic_number_smell": "            // If the byte array is GZipped, then the first or second byte will be the GZip magic number.\n            final boolean firstByteIsMagicNumber = bytes[0] == (byte) (GZIPInputStream.GZIP_MAGIC);\n            // The >> operator shifts the GZIP magic number to the second byte.\n            final boolean secondByteIsMagicNumber = bytes[1] == (byte) (GZIPInputStream.GZIP_MAGIC >> 8);\n            return firstByteIsMagicNumber && secondByteIsMagicNumber;\n        }\n    }", "refactored_code": "    private static final int EIGHT_BITS = 8;\n            // If the byte array is GZipped, then the first or second byte will be the GZip magic number.\n            final boolean firstByteIsMagicNumber = bytes[0] == (byte) (GZIPInputStream.GZIP_MAGIC);\n            // The >> operator shifts the GZIP magic number to the second byte.\n            final boolean secondByteIsMagicNumber = bytes[1] == (byte) (GZIPInputStream.GZIP_MAGIC >> EIGHT_BITS);\n            return firstByteIsMagicNumber && secondByteIsMagicNumber;\n        }\n    }"}
{"magic_number_smell": "            Future<Boolean> gracefulShutdownFuture = kinesisScheduler.startGracefulShutdown();\n            LOG.info(\"Waiting up to 20 seconds for Kinesis Consumer shutdown to complete.\");\n            try {\n                gracefulShutdownFuture.get(20, GRACEFUL_SHUTDOWN_TIMEOUT_UNIT);\n            } catch (InterruptedException e) {\n                LOG.info(\"Interrupted while waiting for graceful shutdown. Continuing.\");\n            } catch (ExecutionException e) {", "refactored_code": "    private static final int GRACEFUL_SHUTDOWN_TIMEOUT = 20;\n            Future<Boolean> gracefulShutdownFuture = kinesisScheduler.startGracefulShutdown();\n            LOG.info(\"Waiting up to 20 seconds for Kinesis Consumer shutdown to complete.\");\n            try {\n                gracefulShutdownFuture.get(GRACEFUL_SHUTDOWN_TIMEOUT, GRACEFUL_SHUTDOWN_TIMEOUT_UNIT);\n            } catch (InterruptedException e) {\n                LOG.info(\"Interrupted while waiting for graceful shutdown. Continuing.\");\n            } catch (ExecutionException e) {"}
{"magic_number_smell": "                .iamEndpoint(iamEndpoint)\n                .kinesisEndpoint(kinesisEndpoint).build();\n\n        final int batchSize = configuration.getInt(CK_KINESIS_RECORD_BATCH_SIZE, 10000);\n        final String streamName = configuration.getString(CK_KINESIS_STREAM_NAME);\n        final AWSMessageType awsMessageType = AWSMessageType.valueOf(configuration.getString(AWSCodec.CK_AWS_MESSAGE_TYPE));\n", "refactored_code": "    public static final int DEFAULT_BATCH_SIZE = 10000;\n                .iamEndpoint(iamEndpoint)\n                .kinesisEndpoint(kinesisEndpoint).build();\n\n        final int batchSize = configuration.getInt(CK_KINESIS_RECORD_BATCH_SIZE, DEFAULT_BATCH_SIZE);\n        final String streamName = configuration.getString(CK_KINESIS_STREAM_NAME);\n        final AWSMessageType awsMessageType = AWSMessageType.valueOf(configuration.getString(AWSCodec.CK_AWS_MESSAGE_TYPE));\n"}
{"magic_number_smell": "            int hash = 41;\n            hash = (19 * hash) + getDescriptorForType().hashCode();\n            if (!internalGetTemplates().getMap().isEmpty()) {\n                hash = (37 * hash) + 1;\n                hash = (53 * hash) + internalGetTemplates().hashCode();\n            }\n            if (!internalGetOptionTemplates().getMap().isEmpty()) {", "refactored_code": "        public static final int TEMPLATES_FIELD_NUMBER = 1;\n            int hash = 41;\n            hash = (19 * hash) + getDescriptorForType().hashCode();\n            if (!internalGetTemplates().getMap().isEmpty()) {\n                hash = (37 * hash) + TEMPLATES_FIELD_NUMBER;\n                hash = (53 * hash) + internalGetTemplates().hashCode();\n            }\n            if (!internalGetOptionTemplates().getMap().isEmpty()) {"}
{"magic_number_smell": "            // the buffer limited to the declared length of the set.\n            final ByteBuf setContent = packet.readSlice(setLength - 4);\n            switch (setId) {\n                case 0:\n                case SETID_RESERVED1:\n                    throw new IpfixException(\"Invalid set id in IPFIX message: \" + setId);\n                case SETID_TEMPLATE:", "refactored_code": "    private static final int SETID_RESERVED0 = 0;\n            // the buffer limited to the declared length of the set.\n            final ByteBuf setContent = packet.readSlice(setLength - 4);\n            switch (setId) {\n                case SETID_RESERVED0:\n                case SETID_RESERVED1:\n                    throw new IpfixException(\"Invalid set id in IPFIX message: \" + setId);\n                case SETID_TEMPLATE:"}
{"magic_number_smell": "                    .customMessage(DEFAULT_CUSTOM_MESSAGE)\n                    .notifyChannel(false)\n                    .notifyHere(false)\n                    .backlogSize(0)\n                    .linkNames(false)\n                    .timeZone(DEFAULT_TIME_ZONE)\n                    .includeTitle(true);", "refactored_code": "    private static final long DEFAULT_BACKLOG_SIZE = 0;\n                    .customMessage(DEFAULT_CUSTOM_MESSAGE)\n                    .notifyChannel(false)\n                    .notifyHere(false)\n                    .backlogSize(DEFAULT_BACKLOG_SIZE)\n                    .linkNames(false)\n                    .timeZone(DEFAULT_TIME_ZONE)\n                    .includeTitle(true);"}
{"magic_number_smell": "                    .color(DEFAULT_HEX_COLOR)\n                    .webhookUrl(WEB_HOOK_URL)\n                    .customMessage(DEFAULT_CUSTOM_MESSAGE)\n                    .backlogSize(0)\n                    .timeZone(DEFAULT_TIME_ZONE);\n        }\n", "refactored_code": "    private static final long DEFAULT_BACKLOG_SIZE = 0;\n                    .color(DEFAULT_HEX_COLOR)\n                    .webhookUrl(WEB_HOOK_URL)\n                    .customMessage(DEFAULT_CUSTOM_MESSAGE)\n                    .backlogSize(DEFAULT_BACKLOG_SIZE)\n                    .timeZone(DEFAULT_TIME_ZONE);\n        }\n"}
{"magic_number_smell": "    public void start() {\n        try {\n            final InetSocketAddress addr = new InetSocketAddress(bindAddress.getHost(), bindAddress.getPort());\n            final HttpServer httpServer = HttpServer.create(addr, 3);\n            final ReplaceableCollectorRegistry replaceableRegistry = new ReplaceableCollectorRegistry(registryRef);\n\n            this.server = new HTTPServer(httpServer, replaceableRegistry, true);", "refactored_code": "    private static final int DEFAULT_HTTP_SERVER_BACKLOG = 3;\n    public void start() {\n        try {\n            final InetSocketAddress addr = new InetSocketAddress(bindAddress.getHost(), bindAddress.getPort());\n            final HttpServer httpServer = HttpServer.create(addr, DEFAULT_HTTP_SERVER_BACKLOG);\n            final ReplaceableCollectorRegistry replaceableRegistry = new ReplaceableCollectorRegistry(registryRef);\n\n            this.server = new HTTPServer(httpServer, replaceableRegistry, true);"}
{"magic_number_smell": "    private static final byte FRAME_WINDOW_SIZE = 'W';\n\n    enum DecodingState {\n        '2',\n        FRAME_TYPE,\n        FRAME_COMPRESSED,\n        FRAME_DATA,", "refactored_code": "    private static final byte PROTOCOL_VERSION = '2';\n    private static final byte FRAME_WINDOW_SIZE = 'W';\n\n    enum DecodingState {\n        PROTOCOL_VERSION,\n        FRAME_TYPE,\n        FRAME_COMPRESSED,\n        FRAME_DATA,"}
{"magic_number_smell": "\n            final ByteBuf buffer = Unpooled.wrappedBuffer(payload);\n            switch (buffer.readByte()) {\n                case 0x00:\n                    final NetFlowV5Packet netFlowV5Packet = NetFlowV5Parser.parsePacket(buffer);\n\n                    return netFlowV5Packet.records().stream()", "refactored_code": "    public static final byte PASSTHROUGH_MARKER = 0x00;\n\n            final ByteBuf buffer = Unpooled.wrappedBuffer(payload);\n            switch (buffer.readByte()) {\n                case PASSTHROUGH_MARKER:\n                    final NetFlowV5Packet netFlowV5Packet = NetFlowV5Parser.parsePacket(buffer);\n\n                    return netFlowV5Packet.records().stream()"}
{"magic_number_smell": "    public static NetFlowV5Packet parsePacket(ByteBuf bb) {\n        final int readableBytes = bb.readableBytes();\n\n        final NetFlowV5Header header = parseHeader(bb.slice(bb.readerIndex(), 24));\n        final int packetLength = 24 + header.count() * RECORD_LENGTH;\n        if (header.count() <= 0 || readableBytes < packetLength) {\n            throw new CorruptFlowPacketException(\"Insufficient data (expected: \" + packetLength + \" bytes, actual: \" + readableBytes + \" bytes)\");", "refactored_code": "    private static final int HEADER_LENGTH = 24;\n    public static NetFlowV5Packet parsePacket(ByteBuf bb) {\n        final int readableBytes = bb.readableBytes();\n\n        final NetFlowV5Header header = parseHeader(bb.slice(bb.readerIndex(), HEADER_LENGTH));\n        final int packetLength = HEADER_LENGTH + header.count() * RECORD_LENGTH;\n        if (header.count() <= 0 || readableBytes < packetLength) {\n            throw new CorruptFlowPacketException(\"Insufficient data (expected: \" + packetLength + \" bytes, actual: \" + readableBytes + \" bytes)\");"}
{"magic_number_smell": "      int hash = 41;\n      hash = (19 * hash) + getDescriptorForType().hashCode();\n      if (!internalGetTemplates().getMap().isEmpty()) {\n        hash = (37 * hash) + 1;\n        hash = (53 * hash) + internalGetTemplates().hashCode();\n      }\n      if (!internalGetOptionTemplate().getMap().isEmpty()) {", "refactored_code": "    public static final int TEMPLATES_FIELD_NUMBER = 1;\n      int hash = 41;\n      hash = (19 * hash) + getDescriptorForType().hashCode();\n      if (!internalGetTemplates().getMap().isEmpty()) {\n        hash = (37 * hash) + TEMPLATES_FIELD_NUMBER;\n        hash = (53 * hash) + internalGetTemplates().hashCode();\n      }\n      if (!internalGetOptionTemplate().getMap().isEmpty()) {"}
{"magic_number_smell": "        public Config defaultConfiguration() {\n            return Config.builder()\n                    .type(NAME)\n                    .refreshInterval(Period.minutes(5).toStandardSeconds().getSeconds() / 2)\n                    .blocklistType(BlocklistType.DOMAINS)\n                    .build();\n        }", "refactored_code": "    private static final int REFRESH_INTERVAL = Period.minutes(5).toStandardSeconds().getSeconds() / 2;\n        public Config defaultConfiguration() {\n            return Config.builder()\n                    .type(NAME)\n                    .refreshInterval(REFRESH_INTERVAL)\n                    .blocklistType(BlocklistType.DOMAINS)\n                    .build();\n        }"}
{"magic_number_smell": "\n        final WhoisClient whoisClient = new WhoisClient();\n        try {\n            whoisClient.setDefaultPort(43);\n            whoisClient.setConnectTimeout(connectTimeout);\n            whoisClient.setDefaultTimeout(readTimeout);\n            String query = parser.buildQueryForIp(ip);", "refactored_code": "    private static final int PORT = 43;\n\n        final WhoisClient whoisClient = new WhoisClient();\n        try {\n            whoisClient.setDefaultPort(PORT);\n            whoisClient.setConnectTimeout(connectTimeout);\n            whoisClient.setDefaultTimeout(readTimeout);\n            String query = parser.buildQueryForIp(ip);"}
{"magic_number_smell": "    }\n\n    private Pivot piePivot() {\n        return valuesPivotForField(field(), limit().orElse(15));\n    }\n\n    private Pivot dataTablePivot() {", "refactored_code": "    private static final int DEFAULT_LIMIT = 15;\n    }\n\n    private Pivot piePivot() {\n        return valuesPivotForField(field(), limit().orElse(DEFAULT_LIMIT));\n    }\n\n    private Pivot dataTablePivot() {"}
{"magic_number_smell": "\n        Throwable possibleResultWindowException = ex;\n        int attempt = 0;\n        while (possibleResultWindowException != null && attempt < 10) {\n            final Integer resultWindowLimit = parseResultLimit(possibleResultWindowException);\n            if (resultWindowLimit != null) {\n                return new ResultWindowLimitError(query, searchTypeId, resultWindowLimit);", "refactored_code": "    private static final int MAX_DEPTH_OF_EXCEPTION_CAUSE_ANALYSIS = 10;\n\n        Throwable possibleResultWindowException = ex;\n        int attempt = 0;\n        while (possibleResultWindowException != null && attempt < MAX_DEPTH_OF_EXCEPTION_CAUSE_ANALYSIS) {\n            final Integer resultWindowLimit = parseResultLimit(possibleResultWindowException);\n            if (resultWindowLimit != null) {\n                return new ResultWindowLimitError(query, searchTypeId, resultWindowLimit);"}
{"magic_number_smell": "                    .usedSearchFilters(List.of())\n                    .fieldsInOrder(DEFAULT_FIELDS)\n                    .decorators(Collections.emptyList())\n                    .chunkSize(1000)\n                    .timeZone(DEFAULT_TIME_ZONE);\n        }\n    }", "refactored_code": "    public static final int DEFAULT_CHUNK_SIZE = 1000;\n                    .usedSearchFilters(List.of())\n                    .fieldsInOrder(DEFAULT_FIELDS)\n                    .decorators(Collections.emptyList())\n                    .chunkSize(DEFAULT_CHUNK_SIZE)\n                    .timeZone(DEFAULT_TIME_ZONE);\n        }\n    }"}
{"magic_number_smell": "                .fieldType(suggestionFieldType)\n                .input(suggestionsRequest.input())\n                .streams(streams)\n                .size(Math.min(suggestionsRequest.size(), 100))\n                .timerange(timerange)\n                .build();\n", "refactored_code": "    public static final int SUGGESTIONS_COUNT_MAX = 100;\n                .fieldType(suggestionFieldType)\n                .input(suggestionsRequest.input())\n                .streams(streams)\n                .size(Math.min(suggestionsRequest.size(), SUGGESTIONS_COUNT_MAX))\n                .timerange(timerange)\n                .build();\n"}
{"magic_number_smell": "            from = DEFAULT_FROM;\n        }\n        if (size <= 0) {\n            size = 10;\n        }\n        if (fields == null || fields.isEmpty()) {\n            fields = DEFAULT_FIELDS;", "refactored_code": "    public static final int DEFAULT_SIZE = 10;\n            from = DEFAULT_FROM;\n        }\n        if (size <= 0) {\n            size = DEFAULT_SIZE;\n        }\n        if (fields == null || fields.isEmpty()) {\n            fields = DEFAULT_FIELDS;"}
{"magic_number_smell": "        @JsonCreator\n        public static SuggestionsRequestDTO.Builder builder() {\n            return new AutoValue_SuggestionsRequestDTO.Builder()\n                    .size(10);\n        }\n    }\n}", "refactored_code": "    public static final int DEFAULT_SUGGESTIONS_COUNT = 10;\n        @JsonCreator\n        public static SuggestionsRequestDTO.Builder builder() {\n            return new AutoValue_SuggestionsRequestDTO.Builder()\n                    .size(DEFAULT_SUGGESTIONS_COUNT);\n        }\n    }\n}"}
{"magic_number_smell": "    }\n\n    public static AutoInterval create() {\n        return create(type, 1.0);\n    }\n\n    public static AutoInterval create(double scalingFactor) {", "refactored_code": "    private static final double CK_DEFAULT_SCALINGFACTOR = 1.0;\n    }\n\n    public static AutoInterval create() {\n        return create(type, CK_DEFAULT_SCALINGFACTOR);\n    }\n\n    public static AutoInterval create(double scalingFactor) {"}
{"magic_number_smell": "    public static Values.Builder builder() {\n        return new AutoValue_Values.Builder()\n                .type(NAME)\n                .limit(15)\n                .skipEmptyValues(false);\n    }\n", "refactored_code": "    public static final int DEFAULT_LIMIT = 15;\n    public static Values.Builder builder() {\n        return new AutoValue_Values.Builder()\n                .type(NAME)\n                .limit(DEFAULT_LIMIT)\n                .skipEmptyValues(false);\n    }\n"}
{"magic_number_smell": "        final var item = new LastOpenedDTO(grnRegistry.newGRN(type, view.id()), DateTime.now(DateTimeZone.UTC));\n        if (lastOpenedItems.isPresent()) {\n            var loi = lastOpenedItems.get();\n            var items = filterForExistingIdAndCapAtMaximum(loi, item.grn(), 100);\n            loi.items().clear();\n            loi.items().add(item);\n            loi.items().addAll(items);", "refactored_code": "    private final long MAXIMUM_LAST_OPENED_PER_USER = 100;\n        final var item = new LastOpenedDTO(grnRegistry.newGRN(type, view.id()), DateTime.now(DateTimeZone.UTC));\n        if (lastOpenedItems.isPresent()) {\n            var loi = lastOpenedItems.get();\n            var items = filterForExistingIdAndCapAtMaximum(loi, item.grn(), MAXIMUM_LAST_OPENED_PER_USER);\n            loi.items().clear();\n            loi.items().add(item);\n            loi.items().addAll(items);"}
{"magic_number_smell": "                                 final EventBus eventBus,\n                                 final GRNRegistry grnRegistry,\n                                 final PermissionAndRoleResolver permissionAndRoleResolver) {\n        this(mongoConnection, mapper, eventBus, grnRegistry, permissionAndRoleResolver, 10000);\n    }\n\n    /*", "refactored_code": "    private static final long MAXIMUM_RECENT_ACTIVITIES = 10000;\n                                 final EventBus eventBus,\n                                 final GRNRegistry grnRegistry,\n                                 final PermissionAndRoleResolver permissionAndRoleResolver) {\n        this(mongoConnection, mapper, eventBus, grnRegistry, permissionAndRoleResolver, MAXIMUM_RECENT_ACTIVITIES);\n    }\n\n    /*"}
{"magic_number_smell": "                              JobSchedulerConfig schedulerConfig,\n                              MetricRegistry metricRegistry) {\n        this(jobTriggerService, jobDefinitionService, eventBus, scheduleStrategies, jobTriggerUpdatesFactory,\n                refreshingLockServiceFactory, jobFactory, workerPool, schedulerConfig, metricRegistry, 5000L);\n    }\n\n    @VisibleForTesting", "refactored_code": "    private static final long DEFAULT_BACKOFF = 5000L;\n                              JobSchedulerConfig schedulerConfig,\n                              MetricRegistry metricRegistry) {\n        this(jobTriggerService, jobDefinitionService, eventBus, scheduleStrategies, jobTriggerUpdatesFactory,\n                refreshingLockServiceFactory, jobFactory, workerPool, schedulerConfig, metricRegistry, DEFAULT_BACKOFF);\n    }\n\n    @VisibleForTesting"}
{"magic_number_smell": "    // The maximum number of times to check if buffers have drained during Illuminate restarts on all\n    // nodes before giving up\n    @Parameter(value = INSTALL_OUTPUT_BUFFER_DRAINING_MAX_RETRIES, validators = PositiveIntegerValidator.class)\n    private int installOutputBufferDrainingMaxRetries = 150;\n\n    public boolean maintainsStreamAwareFieldTypes() {\n        return streamAwareFieldTypes;", "refactored_code": "    private static final int DEFAULT_INSTALL_RETRIES = 150;\n    // The maximum number of times to check if buffers have drained during Illuminate restarts on all\n    // nodes before giving up\n    @Parameter(value = INSTALL_OUTPUT_BUFFER_DRAINING_MAX_RETRIES, validators = PositiveIntegerValidator.class)\n    private int installOutputBufferDrainingMaxRetries = DEFAULT_INSTALL_RETRIES;\n\n    public boolean maintainsStreamAwareFieldTypes() {\n        return streamAwareFieldTypes;"}
{"magic_number_smell": "        this.preflightConfigService = preflightConfigService;\n        this.indexerJwtAuthTokenProvider = indexerJwtAuthTokenProvider;\n        this.notificationService = notificationService;\n        this.executor = Executors.newFixedThreadPool(5, new ThreadFactoryBuilder().setNameFormat(\"provisioning-connectivity-check-task\").build());\n        this.okHttpClient = Suppliers.memoize(() -> buildConnectivityCheckOkHttpClient(trustManager));\n    }\n", "refactored_code": "    private static final int THREADPOOL_THREADS = 5;\n        this.preflightConfigService = preflightConfigService;\n        this.indexerJwtAuthTokenProvider = indexerJwtAuthTokenProvider;\n        this.notificationService = notificationService;\n        this.executor = Executors.newFixedThreadPool(THREADPOOL_THREADS, new ThreadFactoryBuilder().setNameFormat(\"provisioning-connectivity-check-task\").build());\n        this.okHttpClient = Suppliers.memoize(() -> buildConnectivityCheckOkHttpClient(trustManager));\n    }\n"}
{"magic_number_smell": "     * Wait until the buffers of the given types have been drained or abort after 30 seconds\n     */\n    public void waitForEmptyBuffers(EnumSet<Type> bufferTypes) {\n        waitForEmptyBuffers(bufferTypes, 30L, TimeUnit.SECONDS);\n    }\n\n    /**", "refactored_code": "    private static final long DEFAULT_MAX_WAIT = 30L;\n     * Wait until the buffers of the given types have been drained or abort after 30 seconds\n     */\n    public void waitForEmptyBuffers(EnumSet<Type> bufferTypes) {\n        waitForEmptyBuffers(bufferTypes, DEFAULT_MAX_WAIT, TimeUnit.SECONDS);\n    }\n\n    /**"}
{"magic_number_smell": "    public static final String PATH_API = \"api/\";\n\n    @Parameter(value = \"http_bind_address\", required = true)\n    private HostAndPort httpBindAddress = HostAndPort.fromParts(\"127.0.0.1\", 9000);\n\n    @Parameter(value = \"http_publish_uri\", validator = URIAbsoluteValidator.class)\n    private URI httpPublishUri;", "refactored_code": "    private static final int GRAYLOG_DEFAULT_PORT = 9000;\n    public static final String PATH_API = \"api/\";\n\n    @Parameter(value = \"http_bind_address\", required = true)\n    private HostAndPort httpBindAddress = HostAndPort.fromParts(\"127.0.0.1\", GRAYLOG_DEFAULT_PORT);\n\n    @Parameter(value = \"http_publish_uri\", validator = URIAbsoluteValidator.class)\n    private URI httpPublishUri;"}
{"magic_number_smell": "                    .build();\n\n            version(VERSION);\n            revision(0);\n            summary(\"[auto-generated]\");\n            vendor(\"[auto-generated]\");\n            url(URI.create(\"https://www.graylog.org/\"));", "refactored_code": "    private static final int DEFAULT_REVISION = 0;\n                    .build();\n\n            version(VERSION);\n            revision(DEFAULT_REVISION);\n            summary(\"[auto-generated]\");\n            vendor(\"[auto-generated]\");\n            url(URI.create(\"https://www.graylog.org/\"));"}
{"magic_number_smell": "            final Sets.SetView<String> conflictingNames\n                    = Sets.intersection(newPatternsByName.keySet(), existingPatternsByName.keySet());\n            if (!conflictingNames.isEmpty()) {\n                final Iterable<String> limited = Iterables.limit(conflictingNames, 10);\n                throw new ValidationException(\"The following Grok patterns already exist: \"\n                        + StringUtils.join(limited, \", \")\n                        + (conflictingNames.size() > 10 ? \" (+ \" + (conflictingNames.size() - 10) + \" more)\" : \"\")", "refactored_code": "    public static final int MAX_DISPLAYED_CONFLICTS = 10;\n            final Sets.SetView<String> conflictingNames\n                    = Sets.intersection(newPatternsByName.keySet(), existingPatternsByName.keySet());\n            if (!conflictingNames.isEmpty()) {\n                final Iterable<String> limited = Iterables.limit(conflictingNames, MAX_DISPLAYED_CONFLICTS);\n                throw new ValidationException(\"The following Grok patterns already exist: \"\n                        + StringUtils.join(limited, \", \")\n                        + (conflictingNames.size() > MAX_DISPLAYED_CONFLICTS ? \" (+ \" + (conflictingNames.size() - MAX_DISPLAYED_CONFLICTS) + \" more)\" : \"\")"}
{"magic_number_smell": "\npublic class SIUnitParser {\n    private static final long 1L = 1L;\n    private static final long C1 = 1L * 1024L;\n    private static final long C2 = C1 * 1024L;\n    private static final long C3 = C2 * 1024L;\n    private static final long C4 = C3 * 1024L;", "refactored_code": "    private static final long C0 = 1L;\n\npublic class SIUnitParser {\n    private static final long C0 = 1L;\n    private static final long C1 = C0 * 1024L;\n    private static final long C2 = C1 * 1024L;\n    private static final long C3 = C2 * 1024L;\n    private static final long C4 = C3 * 1024L;"}
{"magic_number_smell": "\n    @Override\n    public int maxConcurrency() {\n        return 1;\n    }\n\n    @Override", "refactored_code": "    public static final int MAX_CONCURRENCY = 1;\n\n    @Override\n    public int maxConcurrency() {\n        return MAX_CONCURRENCY;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int maxConcurrency() {\n        return 1;\n    }\n\n    @Override", "refactored_code": "    public static final int MAX_CONCURRENCY = 1;\n\n    @Override\n    public int maxConcurrency() {\n        return MAX_CONCURRENCY;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int maxConcurrency() {\n        return 1_000;\n    }\n\n    @Override", "refactored_code": "    private static final int MAX_CONCURRENCY = 1_000;\n\n    @Override\n    public int maxConcurrency() {\n        return MAX_CONCURRENCY;\n    }\n\n    @Override"}
{"magic_number_smell": "    private static final int 500 = 500;\n\n    @VisibleForTesting\n    static final WaitStrategy exponentialWaitSeconds = WaitStrategies.exponentialWait(500, MAX_WAIT_TIME.getQuantity(), MAX_WAIT_TIME.getUnit());\n\n    @VisibleForTesting\n    static final WaitStrategy exponentialWaitMilliseconds = WaitStrategies.exponentialWait(MAX_WAIT_TIME.getQuantity(), MAX_WAIT_TIME.getUnit());", "refactored_code": "    private static final int retrySecondsMultiplier = 500;\n    private static final int retrySecondsMultiplier = 500;\n\n    @VisibleForTesting\n    static final WaitStrategy exponentialWaitSeconds = WaitStrategies.exponentialWait(retrySecondsMultiplier, MAX_WAIT_TIME.getQuantity(), MAX_WAIT_TIME.getUnit());\n\n    @VisibleForTesting\n    static final WaitStrategy exponentialWaitMilliseconds = WaitStrategies.exponentialWait(MAX_WAIT_TIME.getQuantity(), MAX_WAIT_TIME.getUnit());"}
{"magic_number_smell": "\n    @Override\n    public int maxConcurrency() {\n        return 1;\n    }\n\n    @Override", "refactored_code": "    private static final int MAX_CONCURRENCY = 1;\n\n    @Override\n    public int maxConcurrency() {\n        return MAX_CONCURRENCY;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public static ClosingRetentionStrategyConfig createDefault() {\n        return create(20);\n    }\n\n    @Override", "refactored_code": "    private static final int DEFAULT_MAX_NUMBER_OF_INDICES = 20;\n    }\n\n    public static ClosingRetentionStrategyConfig createDefault() {\n        return create(DEFAULT_MAX_NUMBER_OF_INDICES);\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public static DeletionRetentionStrategyConfig createDefault() {\n        return create(20);\n    }\n\n    @Override", "refactored_code": "    private static final int DEFAULT_MAX_NUMBER_OF_INDICES = 20;\n    }\n\n    public static DeletionRetentionStrategyConfig createDefault() {\n        return create(DEFAULT_MAX_NUMBER_OF_INDICES);\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public static NoopRetentionStrategyConfig createDefault() {\n        return create(Integer.MAX_VALUE);\n    }\n\n    @Override", "refactored_code": "    private static final int DEFAULT_MAX_NUMBER_OF_INDICES = Integer.MAX_VALUE;\n    }\n\n    public static NoopRetentionStrategyConfig createDefault() {\n        return create(DEFAULT_MAX_NUMBER_OF_INDICES);\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public static MessageCountRotationStrategyConfig createDefault() {\n        return create(20_000_000);\n    }\n}\n", "refactored_code": "    private static final int DEFAULT_MAX_DOCS_PER_INDEX = 20_000_000;\n    }\n\n    public static MessageCountRotationStrategyConfig createDefault() {\n        return create(DEFAULT_MAX_DOCS_PER_INDEX);\n    }\n}\n"}
{"magic_number_smell": "    }\n\n    public static SizeBasedRotationStrategyConfig createDefault() {\n        return create(Size.gigabytes(1L).toBytes());\n    }\n}\n", "refactored_code": "    private static final long DEFAULT_MAX_SIZE = Size.gigabytes(1L).toBytes();\n    }\n\n    public static SizeBasedRotationStrategyConfig createDefault() {\n        return create(DEFAULT_MAX_SIZE);\n    }\n}\n"}
{"magic_number_smell": "\n        final int chunkWatermark = entry.chunkSlotsWritten.incrementAndGet();\n\n        if (chunkWatermark > 128) {\n            getAndCleanupEntry(messageId);\n            throw new IllegalStateException(\"Maximum number of chunks reached, discarding message\");\n        }", "refactored_code": "    private static final int MAX_CHUNKS = 128;\n\n        final int chunkWatermark = entry.chunkSlotsWritten.incrementAndGet();\n\n        if (chunkWatermark > MAX_CHUNKS) {\n            getAndCleanupEntry(messageId);\n            throw new IllegalStateException(\"Maximum number of chunks reached, discarding message\");\n        }"}
{"magic_number_smell": "        this.objectMapper = new ObjectMapper().enable(\n                JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS,\n                JsonParser.Feature.ALLOW_TRAILING_COMMA);\n        this.decompressSizeLimit = configuration.getInt(CK_DECOMPRESS_SIZE_LIMIT, 8388608);\n    }\n\n    private static String stringValue(final JsonNode json, final String fieldName) {", "refactored_code": "    private static final int DEFAULT_DECOMPRESS_SIZE_LIMIT = 8388608;\n        this.objectMapper = new ObjectMapper().enable(\n                JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS,\n                JsonParser.Feature.ALLOW_TRAILING_COMMA);\n        this.decompressSizeLimit = configuration.getInt(CK_DECOMPRESS_SIZE_LIMIT, DEFAULT_DECOMPRESS_SIZE_LIMIT);\n    }\n\n    private static String stringValue(final JsonNode json, final String fieldName) {"}
{"magic_number_smell": "    // lol duplication\n    private void extractSequenceNumber() {\n        if (this.sequenceNumber == -1) {\n            final int seqNum = payload.getUnsignedByte(10);\n            if (seqNum >= 0) {\n                this.sequenceNumber = seqNum;\n            } else {", "refactored_code": "    public static final int HEADER_PART_SEQNUM_START = 10;\n    // lol duplication\n    private void extractSequenceNumber() {\n        if (this.sequenceNumber == -1) {\n            final int seqNum = payload.getUnsignedByte(HEADER_PART_SEQNUM_START);\n            if (seqNum >= 0) {\n                this.sequenceNumber = seqNum;\n            } else {"}
{"magic_number_smell": "\n    private Weighted getWeighted(List<? extends Weighted> list) {\n        while (true) {\n            int x = RANDOM.nextInt(50);\n            Weighted obj = list.get(RANDOM.nextInt(list.size()));\n\n            if (obj.getWeight() >= x) {", "refactored_code": "    private static final int MAX_WEIGHT = 50;\n\n    private Weighted getWeighted(List<? extends Weighted> list) {\n        while (true) {\n            int x = RANDOM.nextInt(MAX_WEIGHT);\n            Weighted obj = list.get(RANDOM.nextInt(list.size()));\n\n            if (obj.getWeight() >= x) {"}
{"magic_number_smell": "    }\n\n    private Duration connectionRecoveryInterval() {\n        return Duration.ofSeconds(configuration.getInt(CK_CONNECTION_RECOVERY_INTERVAL, 5));\n    }\n\n    @Override", "refactored_code": "    private static final int DEFAULT_CONNECTION_RECOVERY_INTERVAL_VALUE = 5;\n    }\n\n    private Duration connectionRecoveryInterval() {\n        return Duration.ofSeconds(configuration.getInt(CK_CONNECTION_RECOVERY_INTERVAL, DEFAULT_CONNECTION_RECOVERY_INTERVAL_VALUE));\n    }\n\n    @Override"}
{"magic_number_smell": "            handlers.put(\"read-timeout-handler\", () -> new ReadTimeoutHandler(idleWriterTimeout, TimeUnit.SECONDS));\n        }\n\n        handlers.put(\"decoder\", () -> new HttpRequestDecoder(4096, DEFAULT_MAX_HEADER_SIZE, maxChunkSize));\n        handlers.put(\"decompressor\", HttpContentDecompressor::new);\n        handlers.put(\"encoder\", HttpResponseEncoder::new);\n        handlers.put(\"aggregator\", () -> new HttpObjectAggregator(maxChunkSize));", "refactored_code": "    private static final int DEFAULT_MAX_INITIAL_LINE_LENGTH = 4096;\n            handlers.put(\"read-timeout-handler\", () -> new ReadTimeoutHandler(idleWriterTimeout, TimeUnit.SECONDS));\n        }\n\n        handlers.put(\"decoder\", () -> new HttpRequestDecoder(DEFAULT_MAX_INITIAL_LINE_LENGTH, DEFAULT_MAX_HEADER_SIZE, maxChunkSize));\n        handlers.put(\"decompressor\", HttpContentDecompressor::new);\n        handlers.put(\"encoder\", HttpResponseEncoder::new);\n        handlers.put(\"aggregator\", () -> new HttpObjectAggregator(maxChunkSize));"}
{"magic_number_smell": "\n        final boolean nulDelimiter = configuration.getBoolean(CK_USE_NULL_DELIMITER);\n        this.delimiter = nulDelimiter ? nulDelimiter() : lineDelimiter();\n        this.maxFrameLength = configuration.getInt(CK_MAX_MESSAGE_SIZE, 2 * 1024 * 1024);\n    }\n\n    @Override", "refactored_code": "    private static final int DEFAULT_MAX_FRAME_LENGTH = 2 * 1024 * 1024;\n\n        final boolean nulDelimiter = configuration.getBoolean(CK_USE_NULL_DELIMITER);\n        this.delimiter = nulDelimiter ? nulDelimiter() : lineDelimiter();\n        this.maxFrameLength = configuration.getInt(CK_MAX_MESSAGE_SIZE, DEFAULT_MAX_FRAME_LENGTH);\n    }\n\n    @Override"}
{"magic_number_smell": "        if (bufSizeLegacy != null) {\n            LOGGER.error(\"Deprecated log4j.xml setting detected <{}=\\\"{}\\\"> Using default <bufferSizeBytes={}> instead\", \"bufferSize\", bufSizeLegacy, bufferSizeBytes);\n        }\n        final long bufferSize = bufferSizeBytes == null ? 50 * 1024 * 1024 : FileSize.parse(bufferSizeBytes, 50 * 1024 * 1024);\n\n        if (layout == null) {\n            layout = PatternLayout.createDefaultLayout();", "refactored_code": "    private static final long DEFAULT_BUFFER_SIZE = 50 * 1024 * 1024;\n        if (bufSizeLegacy != null) {\n            LOGGER.error(\"Deprecated log4j.xml setting detected <{}=\\\"{}\\\"> Using default <bufferSizeBytes={}> instead\", \"bufferSize\", bufSizeLegacy, bufferSizeBytes);\n        }\n        final long bufferSize = bufferSizeBytes == null ? DEFAULT_BUFFER_SIZE : FileSize.parse(bufferSizeBytes, DEFAULT_BUFFER_SIZE);\n\n        if (layout == null) {\n            layout = PatternLayout.createDefaultLayout();"}
{"magic_number_smell": "\n    /**\n     * Construct a new MemoryLimitedCompressingFifoRingBuffer with the\n     * default Zstd compression level of {@link MemoryLimitedCompressingFifoRingBuffer#1}\n     * @param memLimit    the memory limit of the Buffer in bytes\n     */\n    public MemoryLimitedCompressingFifoRingBuffer(long memLimit) {", "refactored_code": "    public static final int DEFAULT_ZSTD_COMPRESSION_LEVEL = 1;\n\n    /**\n     * Construct a new MemoryLimitedCompressingFifoRingBuffer with the\n     * default Zstd compression level of {@link MemoryLimitedCompressingFifoRingBuffer#DEFAULT_ZSTD_COMPRESSION_LEVEL}\n     * @param memLimit    the memory limit of the Buffer in bytes\n     */\n    public MemoryLimitedCompressingFifoRingBuffer(long memLimit) {"}
{"magic_number_smell": "                        .serverIps(DEFAULT_SERVER_IP)\n                        .lookupType(DnsLookupType.A)\n                        .cacheTTLOverrideEnabled(DEFAULT_CACHE_TTL_OVERRIDE)\n                        .requestTimeout(10000);\n            }\n\n            @JsonProperty(TYPE_FIELD)", "refactored_code": "        private static final int DEFAULT_TIMEOUT_MILLIS = 10000;\n                        .serverIps(DEFAULT_SERVER_IP)\n                        .lookupType(DnsLookupType.A)\n                        .cacheTTLOverrideEnabled(DEFAULT_CACHE_TTL_OVERRIDE)\n                        .requestTimeout(DEFAULT_TIMEOUT_MILLIS);\n            }\n\n            @JsonProperty(TYPE_FIELD)"}
{"magic_number_smell": "                                              .trimResults()\n                                              .omitEmptyStrings()\n                                              .split(ipAddresses)).stream()\n                        .map(hostAndPort -> HostAndPort.fromString(hostAndPort).withDefaultPort(DnsClient.53))\n                        .allMatch(hostAndPort -> isValidIpAddress(hostAndPort.getHost()));\n        }\n", "refactored_code": "    private static final int DEFAULT_DNS_PORT = 53;\n                                              .trimResults()\n                                              .omitEmptyStrings()\n                                              .split(ipAddresses)).stream()\n                        .map(hostAndPort -> HostAndPort.fromString(hostAndPort).withDefaultPort(DnsClient.DEFAULT_DNS_PORT))\n                        .allMatch(hostAndPort -> isValidIpAddress(hostAndPort.getHost()));\n        }\n"}
{"magic_number_smell": "    protected static final int DEFAULT_REFRESH_INTERVAL_SECONDS = 300;\n\n    @Parameter(value = RESOLVER_POOL_SIZE, validators = PositiveIntegerValidator.class)\n    private int poolSize = 10;\n\n    @Parameter(value = RESOLVER_POOL_REFRESH_INTERVAL, validators = PositiveDurationValidator.class)\n    private Duration poolRefreshInterval = Duration.seconds(DEFAULT_REFRESH_INTERVAL_SECONDS);", "refactored_code": "    protected static final int DEFAULT_POOL_SIZE = 10;\n    protected static final int DEFAULT_REFRESH_INTERVAL_SECONDS = 300;\n\n    @Parameter(value = RESOLVER_POOL_SIZE, validators = PositiveIntegerValidator.class)\n    private int poolSize = DEFAULT_POOL_SIZE;\n\n    @Parameter(value = RESOLVER_POOL_REFRESH_INTERVAL, validators = PositiveDurationValidator.class)\n    private Duration poolRefreshInterval = Duration.seconds(DEFAULT_REFRESH_INTERVAL_SECONDS);"}
{"magic_number_smell": "        // Specify custom DNS servers if provided. If not, use those specified in local network adapter settings.\n        if (CollectionUtils.isNotEmpty(iNetDnsServerIps)) {\n            LOG.debug(\"Attempting to start DNS client with server IPs [{}] on port [{}].\",\n                    dnsServerIps, 53);\n\n            final DnsServerAddressStreamProvider dnsServer = new SequentialDnsServerAddressStreamProvider(iNetDnsServerIps);\n            dnsNameResolverBuilder.nameServerProvider(dnsServer);", "refactored_code": "    private static final int DEFAULT_DNS_PORT = 53;\n        // Specify custom DNS servers if provided. If not, use those specified in local network adapter settings.\n        if (CollectionUtils.isNotEmpty(iNetDnsServerIps)) {\n            LOG.debug(\"Attempting to start DNS client with server IPs [{}] on port [{}].\",\n                    dnsServerIps, DEFAULT_DNS_PORT);\n\n            final DnsServerAddressStreamProvider dnsServer = new SequentialDnsServerAddressStreamProvider(iNetDnsServerIps);\n            dnsNameResolverBuilder.nameServerProvider(dnsServer);"}
{"magic_number_smell": "                    builder.add(\n                            updateView(\n                                    widgetMigration.viewId,\n                                    doc(\"$set\", doc(widgetConfigPath(widgetMigration) + \".row_pivots.$[config].config.limit\", widgetMigration.rowLimit.orElse(15))),\n                                    matchValuePivots\n                            )\n                    );", "refactored_code": "    private static final int DEFAULT_LIMIT = 15;\n                    builder.add(\n                            updateView(\n                                    widgetMigration.viewId,\n                                    doc(\"$set\", doc(widgetConfigPath(widgetMigration) + \".row_pivots.$[config].config.limit\", widgetMigration.rowLimit.orElse(DEFAULT_LIMIT))),\n                                    matchValuePivots\n                            )\n                    );"}
{"magic_number_smell": "                    builder.add(\n                            updateSearch(\n                                    pivotMigration.searchId(),\n                                    doc(\"$set\", doc(pivotPath(pivotMigration) + \".row_groups.$[pivot].limit\", pivotMigration.rowLimit.orElse(15))),\n                                    matchValuePivots\n                            )\n                    );", "refactored_code": "    private static final int DEFAULT_LIMIT = 15;\n                    builder.add(\n                            updateSearch(\n                                    pivotMigration.searchId(),\n                                    doc(\"$set\", doc(pivotPath(pivotMigration) + \".row_groups.$[pivot].limit\", pivotMigration.rowLimit.orElse(DEFAULT_LIMIT))),\n                                    matchValuePivots\n                            )\n                    );"}
{"magic_number_smell": "        this.systemNotificationRenderService = systemNotificationRenderService;\n        this.eventProcessorEngine = eventProcessorEngine;\n        this.scheduler = scheduler;\n        this.queuedNotifications = new LinkedBlockingQueue<>(10_000);\n\n        this.shutdownTimeout = Duration.ofMillis(shutDownTimeoutMs);\n    }", "refactored_code": "    private static final int MAX_QUEUED_NOTIFICATIONS = 10_000;\n        this.systemNotificationRenderService = systemNotificationRenderService;\n        this.eventProcessorEngine = eventProcessorEngine;\n        this.scheduler = scheduler;\n        this.queuedNotifications = new LinkedBlockingQueue<>(MAX_QUEUED_NOTIFICATIONS);\n\n        this.shutdownTimeout = Duration.ofMillis(shutDownTimeoutMs);\n    }"}
{"magic_number_smell": "            final String host = nodeFileDescriptorStats.host();\n            final long maxFileDescriptors = nodeFileDescriptorStats.fileDescriptorMax().orElse(-1L);\n\n            if (maxFileDescriptors != -1L && maxFileDescriptors < 64000) {\n                // Write notification.\n                final String ipOrHostName = firstNonNull(host, ip);\n                final Notification notification = notificationService.buildNow()", "refactored_code": "    private static final int MINIMUM_OPEN_FILES_LIMIT = 64000;\n            final String host = nodeFileDescriptorStats.host();\n            final long maxFileDescriptors = nodeFileDescriptorStats.fileDescriptorMax().orElse(-1L);\n\n            if (maxFileDescriptors != -1L && maxFileDescriptors < MINIMUM_OPEN_FILES_LIMIT) {\n                // Write notification.\n                final String ipOrHostName = firstNonNull(host, ip);\n                final Notification notification = notificationService.buildNow()"}
{"magic_number_smell": "    }\n\n    public static int availableProcessors() {\n        return Runtime.getRuntime().availableProcessors();\n    }\n}\n", "refactored_code": "    private static final int AVAILABLE_PROCESSORS = Runtime.getRuntime().availableProcessors();\n    }\n\n    public static int availableProcessors() {\n        return AVAILABLE_PROCESSORS;\n    }\n}\n"}
{"magic_number_smell": "        private static String buildTimeZoneDisplayName(DateTimeZone dtz) {\n            Instant now = new DateTime(DateTimeZone.getDefault()).toInstant();\n            int offset = dtz.getOffset(now);\n            int offsetHours = offset / 3600000;\n            int remainderOffset = offset % 3600000;\n            if (remainderOffset < 0) {\n                remainderOffset *= -1;", "refactored_code": "    private static final int MILLIS_PER_HOUR = 3600000;\n        private static String buildTimeZoneDisplayName(DateTimeZone dtz) {\n            Instant now = new DateTime(DateTimeZone.getDefault()).toInstant();\n            int offset = dtz.getOffset(now);\n            int offsetHours = offset / MILLIS_PER_HOUR;\n            int remainderOffset = offset % MILLIS_PER_HOUR;\n            if (remainderOffset < 0) {\n                remainderOffset *= -1;"}
{"magic_number_smell": "\n        this.eventLoopGroupFactory = eventLoopGroupFactory;\n\n        this.workerThreads = configuration.getInt(CK_NUMBER_WORKER_THREADS, Runtime.getRuntime().availableProcessors());\n\n        this.localRegistry = localRegistry;\n        localRegistry.registerAll(MetricSets.of(throughputCounter.gauges()));", "refactored_code": "    private static final int DEFAULT_NUMBER_WORKER_THREADS = Runtime.getRuntime().availableProcessors();\n\n        this.eventLoopGroupFactory = eventLoopGroupFactory;\n\n        this.workerThreads = configuration.getInt(CK_NUMBER_WORKER_THREADS, DEFAULT_NUMBER_WORKER_THREADS);\n\n        this.localRegistry = localRegistry;\n        localRegistry.registerAll(MetricSets.of(throughputCounter.gauges()));"}
{"magic_number_smell": "        msgBuilder = JournalMessage.newBuilder();\n\n        this.messageQueueId = journalOffset;\n        msgBuilder.setVersion(1);\n\n        this.id = id;\n        msgBuilder.setUuidTime(id.time);", "refactored_code": "    public static final byte CURRENT_VERSION = 1;\n        msgBuilder = JournalMessage.newBuilder();\n\n        this.messageQueueId = journalOffset;\n        msgBuilder.setVersion(CURRENT_VERSION);\n\n        this.id = id;\n        msgBuilder.setUuidTime(id.time);"}
{"magic_number_smell": "    private static final long ERROR_CACHE_TTL = Duration.ofSeconds(5).toMillis();\n\n    private static final LookupResult EMPTY_LOOKUP_RESULT = builder()\n            .cacheTTL(Long.MAX_VALUE)\n            .build();\n\n    private static final LookupResult DEFAULT_ERROR_LOOKUP_RESULT = builder()", "refactored_code": "    private static final long NO_TTL = Long.MAX_VALUE;\n    private static final long ERROR_CACHE_TTL = Duration.ofSeconds(5).toMillis();\n\n    private static final LookupResult EMPTY_LOOKUP_RESULT = builder()\n            .cacheTTL(NO_TTL)\n            .build();\n\n    private static final LookupResult DEFAULT_ERROR_LOOKUP_RESULT = builder()"}
{"magic_number_smell": "        var regex = f(\"^%s\\\\.%%i\\\\.gz\", baseFileName);\n        if (filePattern.matches(regex)) {\n            final String formatString = filePattern.replace(\"%i\", \"%d\");\n            IntStream.range(1, 5).forEach(i -> {\n                var file = f(formatString, i);\n                buildLogFile(String.valueOf(i), file).ifPresent(logFiles::add);\n            });", "refactored_code": "    public static final int LOGFILE_ENUMERATION_RANGE = 5; // how many rotated logs should we look for\n        var regex = f(\"^%s\\\\.%%i\\\\.gz\", baseFileName);\n        if (filePattern.matches(regex)) {\n            final String formatString = filePattern.replace(\"%i\", \"%d\");\n            IntStream.range(1, LOGFILE_ENUMERATION_RANGE).forEach(i -> {\n                var file = f(formatString, i);\n                buildLogFile(String.valueOf(i), file).ifPresent(logFiles::add);\n            });"}
{"magic_number_smell": "        }\n\n        public static GlobalTerminationRevisionConfig withCurrentRevision() {\n            return create(1);\n        }\n\n        @JsonIgnore", "refactored_code": "    private static final long TERMINATION_REVISION = 1;\n        }\n\n        public static GlobalTerminationRevisionConfig withCurrentRevision() {\n            return create(TERMINATION_REVISION);\n        }\n\n        @JsonIgnore"}
{"magic_number_smell": "    @Override\n    protected void configure() {\n        // TODO Add instrumentation to ExecutorService and ThreadFactory\n        final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(30,\n                new ThreadFactoryBuilder()\n                        .setNameFormat(\"scheduled-%d\")\n                        .setDaemon(false)", "refactored_code": "    private static final int SCHEDULED_THREADS_POOL_SIZE = 30;\n    @Override\n    protected void configure() {\n        // TODO Add instrumentation to ExecutorService and ThreadFactory\n        final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(SCHEDULED_THREADS_POOL_SIZE,\n                new ThreadFactoryBuilder()\n                        .setNameFormat(\"scheduled-%d\")\n                        .setDaemon(false)"}
{"magic_number_smell": "                    Map$.MODULE$.<String, LogConfig>empty(),\n                    defaultConfig,\n                    cleanerConfig,\n                    1,\n                    SECONDS.toMillis(60L),\n                    SECONDS.toMillis(60L),\n                    SECONDS.toMillis(60L),", "refactored_code": "    private static final int NUM_IO_THREADS = 1;\n                    Map$.MODULE$.<String, LogConfig>empty(),\n                    defaultConfig,\n                    cleanerConfig,\n                    NUM_IO_THREADS,\n                    SECONDS.toMillis(60L),\n                    SECONDS.toMillis(60L),\n                    SECONDS.toMillis(60L),"}
{"magic_number_smell": "\n    @Override\n    public ProcessStats processStats() {\n        return ProcessStats.create(findPid(), getOpenFileDescriptorCount(), getMaxFileDescriptorCount());\n    }\n}\n", "refactored_code": "    private static final long pid = findPid();\n\n    @Override\n    public ProcessStats processStats() {\n        return ProcessStats.create(pid, getOpenFileDescriptorCount(), getMaxFileDescriptorCount());\n    }\n}\n"}
{"magic_number_smell": "    private static final Logger LOG = LoggerFactory.getLogger(RegexMatcher.class);\n\n    private static final long 1000 = 1000;\n    private static final LoadingCache<String, Pattern> patternCache = CacheBuilder.newBuilder().maximumSize(1000).build(new CacheLoader<String, Pattern>() {\n        @Override\n        public Pattern load(String key) throws Exception {\n            return Pattern.compile(key, Pattern.DOTALL);", "refactored_code": "    private static final long CACHESIZE = 1000;\n    private static final Logger LOG = LoggerFactory.getLogger(RegexMatcher.class);\n\n    private static final long CACHESIZE = 1000;\n    private static final LoadingCache<String, Pattern> patternCache = CacheBuilder.newBuilder().maximumSize(CACHESIZE).build(new CacheLoader<String, Pattern>() {\n        @Override\n        public Pattern load(String key) throws Exception {\n            return Pattern.compile(key, Pattern.DOTALL);"}
{"magic_number_smell": "        if (!mongoConnection.getDatabase().collectionExists(collectionName)) {\n            final DBObject options = BasicDBObjectBuilder.start()\n                    .add(\"capped\", true)\n                    .add(\"size\", 50 * 1024 * 1024)\n                    .get();\n            final DBCollection collection = mongoConnection.getDatabase().createCollection(collectionName, options);\n            collection.createIndex(DBSort.desc(\"timestamp\"));", "refactored_code": "    private static final int MAX_COLLECTION_BYTES = 50 * 1024 * 1024;\n        if (!mongoConnection.getDatabase().collectionExists(collectionName)) {\n            final DBObject options = BasicDBObjectBuilder.start()\n                    .add(\"capped\", true)\n                    .add(\"size\", MAX_COLLECTION_BYTES)\n                    .get();\n            final DBCollection collection = mongoConnection.getDatabase().createCollection(collectionName, options);\n            collection.createIndex(DBSort.desc(\"timestamp\"));"}
{"magic_number_smell": "    private ScheduledExecutorService executorService(final MetricRegistry metricRegistry) {\n        final ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat(\"systemjob-executor-%d\").build();\n        return new InstrumentedScheduledExecutorService(\n                Executors.newScheduledThreadPool(15, threadFactory),\n                metricRegistry,\n                name(this.getClass(), \"executor-service\"));\n    }", "refactored_code": "    private static final int THREAD_POOL_SIZE = 15;\n    private ScheduledExecutorService executorService(final MetricRegistry metricRegistry) {\n        final ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat(\"systemjob-executor-%d\").build();\n        return new InstrumentedScheduledExecutorService(\n                Executors.newScheduledThreadPool(THREAD_POOL_SIZE, threadFactory),\n                metricRegistry,\n                name(this.getClass(), \"executor-service\"));\n    }"}
{"magic_number_smell": "    @Override\n    public Map<String, Validator> getValidations() {\n        return ImmutableMap.<String, Validator>builder()\n                .put(USERNAME, new LimitedStringValidator(1, 100))\n                .put(PASSWORD, new FilledStringValidator())\n                .put(EMAIL, new LimitedStringValidator(1, MAX_EMAIL_LENGTH))\n                .put(FIRST_NAME, new LimitedOptionalStringValidator(MAX_FIRST_LAST_NAME_LENGTH))", "refactored_code": "    public static final int MAX_USERNAME_LENGTH = 100;\n    @Override\n    public Map<String, Validator> getValidations() {\n        return ImmutableMap.<String, Validator>builder()\n                .put(USERNAME, new LimitedStringValidator(1, MAX_USERNAME_LENGTH))\n                .put(PASSWORD, new FilledStringValidator())\n                .put(EMAIL, new LimitedStringValidator(1, MAX_EMAIL_LENGTH))\n                .put(FIRST_NAME, new LimitedOptionalStringValidator(MAX_FIRST_LAST_NAME_LENGTH))"}
{"magic_number_smell": "        this.userService = mock(UserService.class);\n        when(userService.getRootUser()).thenReturn(Optional.empty());\n\n        this.migrator = new LegacyAlertConditionMigrator(mongoConnection, eventDefinitionHandler, notificationResourceHandler, notificationService, userService, 60);\n    }\n\n    @Test", "refactored_code": "    private static final int CHECK_INTERVAL = 60;\n        this.userService = mock(UserService.class);\n        when(userService.getRootUser()).thenReturn(Optional.empty());\n\n        this.migrator = new LegacyAlertConditionMigrator(mongoConnection, eventDefinitionHandler, notificationResourceHandler, notificationService, userService, CHECK_INTERVAL);\n    }\n\n    @Test"}
{"magic_number_smell": "    public void testEventLimitValidation() {\n        var eventLimitZero = configWithEventLimit(0);\n        var eventLimitOne = configWithEventLimit(1);\n        var eventLimitGreaterMax = configWithEventLimit(EVENT_DEFINITION_CONFIGURATION.getMaxEventLimit() + 1);\n\n        assertValidationError(\"greater than 0\", eventLimitZero, null);\n        assertValidationError(\"greater than 0\", configWithEventLimit(-1), null);", "refactored_code": "    public static final int MAX_EVENT_LIMIT = EVENT_DEFINITION_CONFIGURATION.getMaxEventLimit();\n    public void testEventLimitValidation() {\n        var eventLimitZero = configWithEventLimit(0);\n        var eventLimitOne = configWithEventLimit(1);\n        var eventLimitGreaterMax = configWithEventLimit(MAX_EVENT_LIMIT + 1);\n\n        assertValidationError(\"greater than 0\", eventLimitZero, null);\n        assertValidationError(\"greater than 0\", configWithEventLimit(-1), null);"}
{"magic_number_smell": "    @Test\n    public void testEventsFromAggregationResult() throws EventProcessorException {\n        final DateTime now = DateTime.now(DateTimeZone.UTC);\n        final AbsoluteRange timerange = AbsoluteRange.create(now.minusHours(1), now.minusHours(1).plusMillis(30000));\n\n        // We expect to get the end of the aggregation timerange as event time\n        final TestEvent event1 = new TestEvent(timerange.to());", "refactored_code": "    public static final int SEARCH_WINDOW_MS = 30000;\n    @Test\n    public void testEventsFromAggregationResult() throws EventProcessorException {\n        final DateTime now = DateTime.now(DateTimeZone.UTC);\n        final AbsoluteRange timerange = AbsoluteRange.create(now.minusHours(1), now.minusHours(1).plusMillis(SEARCH_WINDOW_MS));\n\n        // We expect to get the end of the aggregation timerange as event time\n        final TestEvent event1 = new TestEvent(timerange.to());"}
{"magic_number_smell": "        // Check the values are whats expected.\n        final String expectedResponse = \"Success. The new stream [\" + TEST_STREAM_1 + \"/\" + STREAM_ARN + \"] was created with [1] shard.\";\n        assertEquals(expectedResponse, response.result());\n        assertEquals(1, 1);\n    }\n}\n", "refactored_code": "    private static final int SHARD_COUNT = 1;\n        // Check the values are whats expected.\n        final String expectedResponse = \"Success. The new stream [\" + TEST_STREAM_1 + \"/\" + STREAM_ARN + \"] was created with [1] shard.\";\n        assertEquals(expectedResponse, response.result());\n        assertEquals(SHARD_COUNT, 1);\n    }\n}\n"}
{"magic_number_smell": "\n        LastOpenedForUserDTO dto = new LastOpenedForUserDTO(\"userId\", List.of(new LastOpenedDTO(_1, DateTime.now(DateTimeZone.UTC))));\n\n        var result = StartPageService.filterForExistingIdAndCapAtMaximum(dto, _1, 10);\n        assertThat(result.isEmpty()).isTrue();\n    }\n", "refactored_code": "    private static final long MAX = 10;\n\n        LastOpenedForUserDTO dto = new LastOpenedForUserDTO(\"userId\", List.of(new LastOpenedDTO(_1, DateTime.now(DateTimeZone.UTC))));\n\n        var result = StartPageService.filterForExistingIdAndCapAtMaximum(dto, _1, MAX);\n        assertThat(result.isEmpty()).isTrue();\n    }\n"}
{"magic_number_smell": "\n        @Override\n        public int numberOfWorkerThreads() {\n            return 10;\n        }\n\n        @Override", "refactored_code": "        public static final int WORKER_THREADS = 10;\n\n        @Override\n        public int numberOfWorkerThreads() {\n            return WORKER_THREADS;\n        }\n\n        @Override"}
{"magic_number_smell": "\n        mockTrustManagerWithSystemKeystore();\n\n        this.ldapConnector = new UnboundLDAPConnector(60 * 1000, new TLSProtocolsConfiguration(), trustManagerProvider, encryptedValueService);\n    }\n\n    @Test", "refactored_code": "    private static final int DEFAULT_TIMEOUT = 60 * 1000;\n\n        mockTrustManagerWithSystemKeystore();\n\n        this.ldapConnector = new UnboundLDAPConnector(DEFAULT_TIMEOUT, new TLSProtocolsConfiguration(), trustManagerProvider, encryptedValueService);\n    }\n\n    @Test"}
{"magic_number_smell": "        final GenericContainer<?> genericContainer = new GenericContainer<>(DockerImageName.parse(\"mailhog/mailhog:v1.0.1\"));\n        genericContainer.withNetwork(network);\n        genericContainer.withNetworkAliases(\"mailserver\");\n        genericContainer.addExposedPorts(1025, 8025);\n        genericContainer.start();\n        genericContainer.waitingFor(new HttpWaitStrategy().forPath(\"/api/v2/messages\").forPort(8025).withStartupTimeout(Duration.ofSeconds(10)));\n        LOG.debug(\"Mailhog mailserver started\");", "refactored_code": "    public static final int API_PORT = 8025;\n        final GenericContainer<?> genericContainer = new GenericContainer<>(DockerImageName.parse(\"mailhog/mailhog:v1.0.1\"));\n        genericContainer.withNetwork(network);\n        genericContainer.withNetworkAliases(\"mailserver\");\n        genericContainer.addExposedPorts(1025, API_PORT);\n        genericContainer.start();\n        genericContainer.waitingFor(new HttpWaitStrategy().forPath(\"/api/v2/messages\").forPort(API_PORT).withStartupTimeout(Duration.ofSeconds(10)));\n        LOG.debug(\"Mailhog mailserver started\");"}
{"magic_number_smell": "        withCommand(\"server /data\");\n        withNetwork(network);\n        withNetworkAliases(\"minio\");\n        withExposedPorts(9000);\n        // Try to support virtual-host-style requests.\n        withEnv(\"MINIO_DOMAIN\", \"localhost,\" + String.join(\",\", getNetworkAliases()));\n        withEnv(\"MINIO_ACCESS_KEY\", accessKey);", "refactored_code": "    private static final int PORT = 9000;\n        withCommand(\"server /data\");\n        withNetwork(network);\n        withNetworkAliases(\"minio\");\n        withExposedPorts(PORT);\n        // Try to support virtual-host-style requests.\n        withEnv(\"MINIO_DOMAIN\", \"localhost,\" + String.join(\",\", getNetworkAliases()));\n        withEnv(\"MINIO_ACCESS_KEY\", accessKey);"}
{"magic_number_smell": "                    try {\n                        return Double.parseDouble(timeoutMultiplier);\n                    } catch (NumberFormatException e) {\n                        return 1.0;\n                    }\n                }).orElse(1.0);\n    }", "refactored_code": "    private static final double DEFAULT_MULTIPLIER = 1.0;\n                    try {\n                        return Double.parseDouble(timeoutMultiplier);\n                    } catch (NumberFormatException e) {\n                        return DEFAULT_MULTIPLIER;\n                    }\n                }).orElse(DEFAULT_MULTIPLIER);\n    }"}
{"magic_number_smell": "        final GenericContainer<?> genericContainer = new GenericContainer<>(DockerImageName.parse(\"node:alpine\"));\n        genericContainer.withNetwork(network);\n        genericContainer.withNetworkAliases(CONTAINER_ALIAS);\n        genericContainer.addExposedPorts(8000, API_PORT);\n        genericContainer.withCopyFileToContainer(MountableFile.forClasspathResource(\"webhook.js\"), IMAGE_WORKING_DIR + \"webhook.js\");\n        genericContainer.withCommand(\"node \" + IMAGE_WORKING_DIR + \"webhook.js\");\n        genericContainer.withLogConsumer(outputFrame -> System.out.println(outputFrame.getUtf8String()));", "refactored_code": "    public static final int REQUEST_ACCEPT_PORT = 8000;\n        final GenericContainer<?> genericContainer = new GenericContainer<>(DockerImageName.parse(\"node:alpine\"));\n        genericContainer.withNetwork(network);\n        genericContainer.withNetworkAliases(CONTAINER_ALIAS);\n        genericContainer.addExposedPorts(REQUEST_ACCEPT_PORT, API_PORT);\n        genericContainer.withCopyFileToContainer(MountableFile.forClasspathResource(\"webhook.js\"), IMAGE_WORKING_DIR + \"webhook.js\");\n        genericContainer.withCommand(\"node \" + IMAGE_WORKING_DIR + \"webhook.js\");\n        genericContainer.withLogConsumer(outputFrame -> System.out.println(outputFrame.getUtf8String()));"}
{"magic_number_smell": "    }\n\n    public PortBoundGelfInputApi createGelfHttpInput() {\n        return createGelfHttpInput(12201);\n    }\n\n    public PortBoundGelfInputApi createGelfHttpInput(int gelfHttpPort) {", "refactored_code": "    private static final int DEFAULT_GELF_HTTP_PORT = 12201;\n    }\n\n    public PortBoundGelfInputApi createGelfHttpInput() {\n        return createGelfHttpInput(DEFAULT_GELF_HTTP_PORT);\n    }\n\n    public PortBoundGelfInputApi createGelfHttpInput(int gelfHttpPort) {"}
{"magic_number_smell": "\n    @Override\n    public String internalUri() {\n        return String.format(Locale.US, \"http://%s:%d\", hostname, 9200);\n    }\n\n    @Override", "refactored_code": "    protected static final int OPENSEARCH_PORT = 9200;\n\n    @Override\n    public String internalUri() {\n        return String.format(Locale.US, \"http://%s:%d\", hostname, OPENSEARCH_PORT);\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public Integer[] portsToExpose() {\n        int[] allPorts = new int[] {12201};\n        allPorts = ArrayUtils.add(allPorts, 0, API_PORT);\n\n        if (enableDebugging) {", "refactored_code": "    public static final int GELF_HTTP_PORT = 12201;\n    }\n\n    public Integer[] portsToExpose() {\n        int[] allPorts = new int[] {GELF_HTTP_PORT};\n        allPorts = ArrayUtils.add(allPorts, 0, API_PORT);\n\n        if (enableDebugging) {"}
{"magic_number_smell": "        ImageFromDockerfile image = new ImageFromDockerfile(\"local/graylog-full-backend-test-server:latest\", false)\n                .withFileFromClasspath(\"Dockerfile\", \"org/graylog/testing/graylognode/Dockerfile\")\n                // set mode here explicitly, because file system permissions can get lost when executing from maven\n                .withFileFromFile(\"docker-entrypoint.sh\", entrypointScript, 0100755)\n                .withFileFromPath(\"graylog.conf\", pathTo(\"graylog_config\"))\n                .withFileFromClasspath(\"log4j2.xml\", \"log4j2.xml\");\n", "refactored_code": "    private static final int EXECUTABLE_MODE = 0100755;\n        ImageFromDockerfile image = new ImageFromDockerfile(\"local/graylog-full-backend-test-server:latest\", false)\n                .withFileFromClasspath(\"Dockerfile\", \"org/graylog/testing/graylognode/Dockerfile\")\n                // set mode here explicitly, because file system permissions can get lost when executing from maven\n                .withFileFromFile(\"docker-entrypoint.sh\", entrypointScript, EXECUTABLE_MODE)\n                .withFileFromPath(\"graylog.conf\", pathTo(\"graylog_config\"))\n                .withFileFromClasspath(\"log4j2.xml\", \"log4j2.xml\");\n"}
{"magic_number_smell": "                .withFileSystemBind(LDAPTestUtils.testTLSCertsPath(\"server-key.pem\"), CONTAINER_CERTS_PATH + \"/server-key.pem\", BindMode.READ_ONLY)\n                .withFileSystemBind(LDAPTestUtils.testTLSCertsPath(\"CA-cert.pem\"), CONTAINER_CERTS_PATH + \"/CA-cert.pem\", BindMode.READ_ONLY)\n                .withFileSystemBind(LDAPTestUtils.testTLSCertsPath(\"dhparam.pem\"), CONTAINER_CERTS_PATH + \"/dhparam.pem\", BindMode.READ_ONLY)\n                .withExposedPorts(389, TLS_PORT);\n    }\n\n    public OpenLDAPContainer(String customLdifPath) {", "refactored_code": "    private static final int PORT = 389;\n                .withFileSystemBind(LDAPTestUtils.testTLSCertsPath(\"server-key.pem\"), CONTAINER_CERTS_PATH + \"/server-key.pem\", BindMode.READ_ONLY)\n                .withFileSystemBind(LDAPTestUtils.testTLSCertsPath(\"CA-cert.pem\"), CONTAINER_CERTS_PATH + \"/CA-cert.pem\", BindMode.READ_ONLY)\n                .withFileSystemBind(LDAPTestUtils.testTLSCertsPath(\"dhparam.pem\"), CONTAINER_CERTS_PATH + \"/dhparam.pem\", BindMode.READ_ONLY)\n                .withExposedPorts(PORT, TLS_PORT);\n    }\n\n    public OpenLDAPContainer(String customLdifPath) {"}
{"magic_number_smell": "\n    private MongoDBContainer(String dockerImageName, Network network) {\n        super(requireNonNull(dockerImageName, \"dockerImageName cannot be null\"));\n        withExposedPorts(27017);\n        withNetwork(requireNonNull(network, \"network cannot be null\"));\n        withNetworkAliases(NETWORK_ALIAS);\n        waitingFor(Wait.forListeningPort());", "refactored_code": "    public static final int MONGODB_PORT = 27017;\n\n    private MongoDBContainer(String dockerImageName, Network network) {\n        super(requireNonNull(dockerImageName, \"dockerImageName cannot be null\"));\n        withExposedPorts(MONGODB_PORT);\n        withNetwork(requireNonNull(network, \"network cannot be null\"));\n        withNetworkAliases(NETWORK_ALIAS);\n        waitingFor(Wait.forListeningPort());"}
{"magic_number_smell": "    public void testRunCheckMorePositive() throws Exception {\n        final MessageCountAlertCondition.ThresholdType type = MessageCountAlertCondition.ThresholdType.MORE;\n\n        final MessageCountAlertCondition messageCountAlertCondition = getConditionWithParameters(type, 100);\n\n        searchCountShouldReturn(100 + 1);\n        // AlertCondition was never triggered before", "refactored_code": "    private final int threshold = 100;\n    public void testRunCheckMorePositive() throws Exception {\n        final MessageCountAlertCondition.ThresholdType type = MessageCountAlertCondition.ThresholdType.MORE;\n\n        final MessageCountAlertCondition messageCountAlertCondition = getConditionWithParameters(type, threshold);\n\n        searchCountShouldReturn(threshold + 1);\n        // AlertCondition was never triggered before"}
{"magic_number_smell": "\n    @Before\n    public void setUp() throws Exception {\n        Mockito.when(configuration.getStaleLeaderTimeout()).thenReturn(2000);\n        this.nodeService = new NodeServiceImpl(\n                new ServerNodeClusterService(mongodb.mongoConnection(), configuration));\n    }", "refactored_code": "    public static final int STALE_LEADER_TIMEOUT_MS = 2000;\n\n    @Before\n    public void setUp() throws Exception {\n        Mockito.when(configuration.getStaleLeaderTimeout()).thenReturn(STALE_LEADER_TIMEOUT_MS);\n        this.nodeService = new NodeServiceImpl(\n                new ServerNodeClusterService(mongodb.mongoConnection(), configuration));\n    }"}
{"magic_number_smell": "\n    @Before\n    public void setUp() throws Exception {\n        Mockito.when(configuration.getStaleLeaderTimeout()).thenReturn(2000);\n        this.nodeService =\n                new DataNodeClusterService(mongodb.mongoConnection(), configuration);\n    }", "refactored_code": "    public static final int STALE_LEADER_TIMEOUT_MS = 2000;\n\n    @Before\n    public void setUp() throws Exception {\n        Mockito.when(configuration.getStaleLeaderTimeout()).thenReturn(STALE_LEADER_TIMEOUT_MS);\n        this.nodeService =\n                new DataNodeClusterService(mongodb.mongoConnection(), configuration);\n    }"}
{"magic_number_smell": "\n    @Before\n    public void setUp() throws Exception {\n        Mockito.when(configuration.getStaleLeaderTimeout()).thenReturn(2000);\n        this.nodeService =\n                new ServerNodeClusterService(mongodb.mongoConnection(), configuration);\n    }", "refactored_code": "    public static final int STALE_LEADER_TIMEOUT_MS = 2000;\n\n    @Before\n    public void setUp() throws Exception {\n        Mockito.when(configuration.getStaleLeaderTimeout()).thenReturn(STALE_LEADER_TIMEOUT_MS);\n        this.nodeService =\n                new ServerNodeClusterService(mongodb.mongoConnection(), configuration);\n    }"}
{"magic_number_smell": "\n        assertNotNull(message);\n        assertEquals(\"c4dc57ba1ebb syslog-ng[7208]: syslog-ng starting up; version='3.5.3'\", message.getMessage());\n        assertEquals(new DateTime(Tools.nowUTC().getYear() + \"-10-21T12:09:37\"), message.getField(\"timestamp\"));\n        assertEquals(\"c4dc57ba1ebb\", message.getField(\"source\"));\n        assertEquals(5, message.getField(\"level\"));\n        assertEquals(\"syslogd\", message.getField(\"facility\"));", "refactored_code": "    private static final int YEAR = Tools.nowUTC().getYear();\n\n        assertNotNull(message);\n        assertEquals(\"c4dc57ba1ebb syslog-ng[7208]: syslog-ng starting up; version='3.5.3'\", message.getMessage());\n        assertEquals(new DateTime(YEAR + \"-10-21T12:09:37\"), message.getField(\"timestamp\"));\n        assertEquals(\"c4dc57ba1ebb\", message.getField(\"source\"));\n        assertEquals(5, message.getField(\"level\"));\n        assertEquals(\"syslogd\", message.getField(\"facility\"));"}
{"magic_number_smell": "    private static final int RECV_BUFFER_SIZE = 1024;\n    private static final ImmutableMap<String, Object> CONFIG_SOURCE = ImmutableMap.of(\n            NettyTransport.CK_BIND_ADDRESS, BIND_ADDRESS,\n            NettyTransport.CK_PORT, 0,\n            NettyTransport.CK_RECV_BUFFER_SIZE, RECV_BUFFER_SIZE,\n            NettyTransport.CK_NUMBER_WORKER_THREADS, 1);\n    private static final Configuration CONFIGURATION = new Configuration(CONFIG_SOURCE);", "refactored_code": "    private static final int PORT = 0;\n    private static final int RECV_BUFFER_SIZE = 1024;\n    private static final ImmutableMap<String, Object> CONFIG_SOURCE = ImmutableMap.of(\n            NettyTransport.CK_BIND_ADDRESS, BIND_ADDRESS,\n            NettyTransport.CK_PORT, PORT,\n            NettyTransport.CK_RECV_BUFFER_SIZE, RECV_BUFFER_SIZE,\n            NettyTransport.CK_NUMBER_WORKER_THREADS, 1);\n    private static final Configuration CONFIGURATION = new Configuration(CONFIG_SOURCE);"}
{"magic_number_smell": "\n    @Test\n    public void testResolverIndex() {\n        final DnsResolverPool dnsResolverPool = new DnsResolverPool(\"\", 100, 10, 300);\n        dnsResolverPool.initialize();\n        assertEquals(10, dnsResolverPool.poolSize());\n        final int randomResolverIndex = dnsResolverPool.randomResolverIndex();", "refactored_code": "    private static final int POOL_SIZE = 10;\n\n    @Test\n    public void testResolverIndex() {\n        final DnsResolverPool dnsResolverPool = new DnsResolverPool(\"\", 100, POOL_SIZE, 300);\n        dnsResolverPool.initialize();\n        assertEquals(POOL_SIZE, dnsResolverPool.poolSize());\n        final int randomResolverIndex = dnsResolverPool.randomResolverIndex();"}
{"magic_number_smell": "    @Before\n    public void setUp() throws Exception {\n        registry = new OutputRegistry(messageOutput, outputService, messageOutputFactory, null,\n                null, eventBus, streamService, 5, FAULT_PENALTY_SECONDS);\n    }\n\n    @Test", "refactored_code": "    private static final long FAULT_COUNT_THRESHOLD = 5;\n    @Before\n    public void setUp() throws Exception {\n        registry = new OutputRegistry(messageOutput, outputService, messageOutputFactory, null,\n                null, eventBus, streamService, FAULT_COUNT_THRESHOLD, FAULT_PENALTY_SECONDS);\n    }\n\n    @Test"}
{"magic_number_smell": "    private CreateUserRequest buildCreateUserRequest() {\n        return CreateUserRequest.create(USERNAME, PASSWORD, EMAIL,\n                FIRST_NAME, LAST_NAME, Collections.singletonList(\"\"),\n                TIMEZONE, 0L,\n                startPage, Collections.emptyList(), false);\n    }\n", "refactored_code": "    public static final long SESSION_TIMEOUT = 0L;\n    private CreateUserRequest buildCreateUserRequest() {\n        return CreateUserRequest.create(USERNAME, PASSWORD, EMAIL,\n                FIRST_NAME, LAST_NAME, Collections.singletonList(\"\"),\n                TIMEZONE, SESSION_TIMEOUT,\n                startPage, Collections.emptyList(), false);\n    }\n"}
{"magic_number_smell": "        assertFalse(SecurityUtils.getSubject().isAuthenticated());\n        Optional<Session> session = sessionCreator.login(null, \"host\", validToken);\n        assertTrue(session.isPresent());\n        assertEquals(Long.MAX_VALUE, session.get().getTimeout());\n        assertTrue(SecurityUtils.getSubject().isAuthenticated());\n        verify(auditEventSender).success(eq(AuditActor.user(\"username\")), anyString(), anyMap());\n    }", "refactored_code": "    private static final long SESSION_TIMEOUT = Long.MAX_VALUE;\n        assertFalse(SecurityUtils.getSubject().isAuthenticated());\n        Optional<Session> session = sessionCreator.login(null, \"host\", validToken);\n        assertTrue(session.isPresent());\n        assertEquals(SESSION_TIMEOUT, session.get().getTimeout());\n        assertTrue(SecurityUtils.getSubject().isAuthenticated());\n        verify(auditEventSender).success(eq(AuditActor.user(\"username\")), anyString(), anyMap());\n    }"}
{"magic_number_smell": "    private static final int 3 = 3;\n\n    public static void main(String [] args) throws Exception{\n        if (args.length < 3){\n            System.out.println(\"Please provide \"+3+\" or more arguments:\");\n            System.out.println(\"serverhost serverport filename [arg1 arg2 ...]\");\n            System.out.println(\"e.g. \");", "refactored_code": "    private static final int MINARGS = 3;\n    private static final int MINARGS = 3;\n\n    public static void main(String [] args) throws Exception{\n        if (args.length < MINARGS){\n            System.out.println(\"Please provide \"+MINARGS+\" or more arguments:\");\n            System.out.println(\"serverhost serverport filename [arg1 arg2 ...]\");\n            System.out.println(\"e.g. \");"}
{"magic_number_smell": "        // this custom TreeSelectionModel forbid the selection of some test elements (test plan, thread group, etc..)\n        TreeSelectionModel tsm =  new DefaultTreeSelectionModel() {\n\n            private static final long -4195441608252523573L = 4062816201792954617L;\n\n            private boolean isSelectedPathAllowed(DefaultMutableTreeNode lastSelected) {\n                JMeterTreeNode tn = null;", "refactored_code": "    private static final long serialVersionUID = -4195441608252523573L;\n        // this custom TreeSelectionModel forbid the selection of some test elements (test plan, thread group, etc..)\n        TreeSelectionModel tsm =  new DefaultTreeSelectionModel() {\n\n            private static final long serialVersionUID = 4062816201792954617L;\n\n            private boolean isSelectedPathAllowed(DefaultMutableTreeNode lastSelected) {\n                JMeterTreeNode tn = null;"}
{"magic_number_smell": "        initTableModel();\n        paramTable.setModel(tableModel);\n        HeaderAsPropertyRenderer defaultRenderer = new HeaderAsPropertyRenderer(){\n            private static final long 241L = 240L;\n\n            @Override\n            protected String getText(Object value, int row, int column) {", "refactored_code": "    private static final long serialVersionUID = 241L;\n        initTableModel();\n        paramTable.setModel(tableModel);\n        HeaderAsPropertyRenderer defaultRenderer = new HeaderAsPropertyRenderer(){\n            private static final long serialVersionUID = 240L;\n\n            @Override\n            protected String getText(Object value, int row, int column) {"}
{"magic_number_smell": "    }\n\n    private static boolean valuesAreEqualWithPrecision(double throughput, double lastThroughput) {\n        return Math.abs(throughput - lastThroughput) < 0.00001;\n    }\n}\n", "refactored_code": "    private static final double PRECISION = 0.00001;\n    }\n\n    private static boolean valuesAreEqualWithPrecision(double throughput, double lastThroughput) {\n        return Math.abs(throughput - lastThroughput) < PRECISION;\n    }\n}\n"}
{"magic_number_smell": "     */\n    private static class DOMTreePanel extends JPanel implements MouseListener {\n\n        private static final long 1L = 6871690021183779153L;\n\n        private JTree domJTree;\n        private ExpandPopupMenu popupMenu;", "refactored_code": "        private static final long serialVersionUID = 1L;\n     */\n    private static class DOMTreePanel extends JPanel implements MouseListener {\n\n        private static final long serialVersionUID = 6871690021183779153L;\n\n        private JTree domJTree;\n        private ExpandPopupMenu popupMenu;"}
{"magic_number_smell": "    }\n\n    private class EnterAction extends AbstractAction {\n        private static final long 1L = 2L;\n        @Override\n        public void actionPerformed(ActionEvent ev) {\n            boolean found = doSearch();", "refactored_code": "    private static final long serialVersionUID = 1L;\n    }\n\n    private class EnterAction extends AbstractAction {\n        private static final long serialVersionUID = 2L;\n        @Override\n        public void actionPerformed(ActionEvent ev) {\n            boolean found = doSearch();"}
{"magic_number_smell": "\n\n    private static class ResultsNodeRenderer extends DefaultTreeCellRenderer {\n        private static final long 2L = 4159626601097711565L;\n\n        @Override\n        public Component getTreeCellRendererComponent(JTree tree, Object value,", "refactored_code": "    private static final long serialVersionUID = 2L;\n\n\n    private static class ResultsNodeRenderer extends DefaultTreeCellRenderer {\n        private static final long serialVersionUID = 4159626601097711565L;\n\n        @Override\n        public Component getTreeCellRendererComponent(JTree tree, Object value,"}
{"magic_number_smell": "    /**\n     * Timeboxed percentiles don't makes sense\n     */\n    private final DescriptiveStatistics pctResponseStats = DescriptiveStatisticsFactory.createDescriptiveStatistics(JMeterUtils.getPropDefault(\"backend_metrics_window\", 100));\n    private int successes;\n    private int failures;\n    private int hits;", "refactored_code": "    private static final int SLIDING_WINDOW_SIZE = JMeterUtils.getPropDefault(\"backend_metrics_window\", 100);\n    /**\n     * Timeboxed percentiles don't makes sense\n     */\n    private final DescriptiveStatistics pctResponseStats = DescriptiveStatisticsFactory.createDescriptiveStatistics(SLIDING_WINDOW_SIZE);\n    private int successes;\n    private int failures;\n    private int hits;"}
{"magic_number_smell": "\n    private static final int JMeterUtils.getPropDefault(\"backend_metrics_window\", 100) = JMeterUtils.getPropDefault(\"backend_metrics_window\", 100); //$NON-NLS-1$\n\n    // Limit to sliding window of JMeterUtils.getPropDefault(\"backend_metrics_window\", 100) values\n    private final DescriptiveStatistics usersStats = DescriptiveStatisticsFactory.createDescriptiveStatistics(JMeterUtils.getPropDefault(\"backend_metrics_window\", 100));\n\n    /**", "refactored_code": "    private static final int SLIDING_WINDOW_SIZE = JMeterUtils.getPropDefault(\"backend_metrics_window\", 100); //$NON-NLS-1$\n\n    private static final int SLIDING_WINDOW_SIZE = JMeterUtils.getPropDefault(\"backend_metrics_window\", 100); //$NON-NLS-1$\n\n    // Limit to sliding window of SLIDING_WINDOW_SIZE values\n    private final DescriptiveStatistics usersStats = DescriptiveStatisticsFactory.createDescriptiveStatistics(SLIDING_WINDOW_SIZE);\n\n    /**"}
{"magic_number_smell": "        String graphiteMetricsSenderClass = context.getParameter(GRAPHITE_METRICS_SENDER);\n\n        String graphiteHost = context.getParameter(GRAPHITE_HOST);\n        int graphitePort = context.getIntParameter(GRAPHITE_PORT, 2003);\n        summaryOnly = context.getBooleanParameter(SUMMARY_ONLY, true);\n        samplersList = context.getParameter(SAMPLERS_LIST, \"\");\n        useRegexpForSamplersList = context.getBooleanParameter(USE_REGEXP_FOR_SAMPLERS_LIST, false);", "refactored_code": "    private static final int DEFAULT_PLAINTEXT_PROTOCOL_PORT = 2003;\n        String graphiteMetricsSenderClass = context.getParameter(GRAPHITE_METRICS_SENDER);\n\n        String graphiteHost = context.getParameter(GRAPHITE_HOST);\n        int graphitePort = context.getIntParameter(GRAPHITE_PORT, DEFAULT_PLAINTEXT_PROTOCOL_PORT);\n        summaryOnly = context.getBooleanParameter(SUMMARY_ONLY, true);\n        samplersList = context.getParameter(SAMPLERS_LIST, \"\");\n        useRegexpForSamplersList = context.getBooleanParameter(USE_REGEXP_FOR_SAMPLERS_LIST, false);"}
{"magic_number_smell": "\n        scheduler = Executors.newScheduledThreadPool(MAX_POOL_SIZE);\n        // Start immediately the scheduler and put the pooling ( 5 seconds by default )\n        this.timerHandle = scheduler.scheduleAtFixedRate(this, 0, JMeterUtils.getPropDefault(\"backend_influxdb.send_interval\", 5), TimeUnit.SECONDS);\n    }\n\n    private void initInfluxdbMetricsManager(BackendListenerContext context) throws Exception {", "refactored_code": "    private static final long SEND_INTERVAL = JMeterUtils.getPropDefault(\"backend_influxdb.send_interval\", 5);\n\n        scheduler = Executors.newScheduledThreadPool(MAX_POOL_SIZE);\n        // Start immediately the scheduler and put the pooling ( 5 seconds by default )\n        this.timerHandle = scheduler.scheduleAtFixedRate(this, 0, SEND_INTERVAL, TimeUnit.SECONDS);\n    }\n\n    private void initInfluxdbMetricsManager(BackendListenerContext context) throws Exception {"}
{"magic_number_smell": "        result = assertion.getResult(sample0);\n        assertPassed();\n\n        assertion.setAllowedSize(data1.length());\n        result = assertion.getResult(sample1);\n        assertPassed();\n", "refactored_code": "    private final int data1Len = data1.length();\n        result = assertion.getResult(sample0);\n        assertPassed();\n\n        assertion.setAllowedSize(data1Len);\n        result = assertion.getResult(sample1);\n        assertPassed();\n"}
{"magic_number_smell": "    public void checkResetOkAndAllStats() throws Exception {\n        SamplerMetric metric = new SamplerMetric();\n        metric.add(createSampleResult(true));\n        assertEquals(1_000, metric.getOkMaxTime(), 0.001, \"Before reset  ok.max\");\n        assertEquals(1_000, metric.getAllMaxTime(), 0.001, \"Before reset all.max\");\n        assertEquals(1, metric.getHits(), 0.0, \"Before reset failure\");\n        assertEquals(1000, metric.getSentBytes(), 0.0, \"Before reset sent bytes\");", "refactored_code": "    private static final int DEFAULT_ELAPSED_TIME = 1_000;\n    public void checkResetOkAndAllStats() throws Exception {\n        SamplerMetric metric = new SamplerMetric();\n        metric.add(createSampleResult(true));\n        assertEquals(DEFAULT_ELAPSED_TIME, metric.getOkMaxTime(), 0.001, \"Before reset  ok.max\");\n        assertEquals(DEFAULT_ELAPSED_TIME, metric.getAllMaxTime(), 0.001, \"Before reset all.max\");\n        assertEquals(1, metric.getHits(), 0.0, \"Before reset failure\");\n        assertEquals(1000, metric.getSentBytes(), 0.0, \"Before reset sent bytes\");"}
{"magic_number_smell": "        SamplerMetric metric = new SamplerMetric();\n\n        metric.add(createSampleResult(true));\n        assertEquals(1_000, metric.getOkMaxTime(), 0.001, \"Before reset  ok.max\");\n        assertEquals(1_000, metric.getAllMaxTime(), 0.001, \"Before reset all.max\");\n        assertEquals(1, metric.getHits(), 0.0, \"Before reset hits\");\n        assertEquals(1000, metric.getSentBytes(), 0.0, \"Before reset sent bytes\");", "refactored_code": "    private static final int DEFAULT_ELAPSED_TIME = 1_000;\n        SamplerMetric metric = new SamplerMetric();\n\n        metric.add(createSampleResult(true));\n        assertEquals(DEFAULT_ELAPSED_TIME, metric.getOkMaxTime(), 0.001, \"Before reset  ok.max\");\n        assertEquals(DEFAULT_ELAPSED_TIME, metric.getAllMaxTime(), 0.001, \"Before reset all.max\");\n        assertEquals(1, metric.getHits(), 0.0, \"Before reset hits\");\n        assertEquals(1000, metric.getSentBytes(), 0.0, \"Before reset sent bytes\");"}
{"magic_number_smell": "    }\n\n    private static void startUdpDdaemon(final List<? extends JMeterEngine> engines) {\n        int port = JMeterUtils.getPropDefault(\"jmeterengine.nongui.port\", ShutdownClient.UDP_PORT_DEFAULT); // $NON-NLS-1$\n        int maxPort = JMeterUtils.getPropDefault(\"jmeterengine.nongui.maxport\", 4455); // $NON-NLS-1$\n        if (port > 1000){\n            final DatagramSocket socket = getSocket(port, maxPort);", "refactored_code": "    public static final int UDP_PORT_DEFAULT = ShutdownClient.UDP_PORT_DEFAULT;\n    }\n\n    private static void startUdpDdaemon(final List<? extends JMeterEngine> engines) {\n        int port = JMeterUtils.getPropDefault(\"jmeterengine.nongui.port\", UDP_PORT_DEFAULT); // $NON-NLS-1$\n        int maxPort = JMeterUtils.getPropDefault(\"jmeterengine.nongui.maxport\", 4455); // $NON-NLS-1$\n        if (port > 1000){\n            final DatagramSocket socket = getSocket(port, maxPort);"}
{"magic_number_smell": "\n    private static class ResultHolder implements Serializable\n    {\n        private static final long 1 = 1L;\n        private String baseResult;\n        private String secondaryResult;\n", "refactored_code": "    private static final long serialVersionUID = 1;\n\n    private static class ResultHolder implements Serializable\n    {\n        private static final long serialVersionUID = 1L;\n        private String baseResult;\n        private String secondaryResult;\n"}
{"magic_number_smell": "        // Hide Window on ESC\n        Action escapeAction = new AbstractAction(\"ESCAPE\") {\n\n            private static final long 6578889215615435475L = -8699034338969407625L;\n\n            @Override\n            public void actionPerformed(ActionEvent actionEvent) {", "refactored_code": "    private static final long serialVersionUID = 6578889215615435475L;\n        // Hide Window on ESC\n        Action escapeAction = new AbstractAction(\"ESCAPE\") {\n\n            private static final long serialVersionUID = -8699034338969407625L;\n\n            @Override\n            public void actionPerformed(ActionEvent actionEvent) {"}
{"magic_number_smell": "\n    public int getLoops() {\n        // Evaluation occurs when nbLoops is not yet evaluated\n        // or when nbLoops is equal to special value -1\n        if (nbLoops==null || // No evaluated yet\n                nbLoops ==0 || // Last iteration led to nbLoops == 0,\n                                         // in this case as resetLoopCount will not be called,", "refactored_code": "    public static final int INFINITE_LOOP_COUNT = -1; // $NON-NLS-1$\n\n    public int getLoops() {\n        // Evaluation occurs when nbLoops is not yet evaluated\n        // or when nbLoops is equal to special value INFINITE_LOOP_COUNT\n        if (nbLoops==null || // No evaluated yet\n                nbLoops ==0 || // Last iteration led to nbLoops == 0,\n                                         // in this case as resetLoopCount will not be called,"}
{"magic_number_smell": "        JRootPane rootPane = new JRootPane();\n        javax.swing.Action escapeAction = new AbstractAction(\"ESCAPE\") {\n\n            private static final long 240L = -4036804004190858925L;\n\n            @Override\n            public void actionPerformed(ActionEvent actionEvent) {", "refactored_code": "    private static final long serialVersionUID = 240L;\n        JRootPane rootPane = new JRootPane();\n        javax.swing.Action escapeAction = new AbstractAction(\"ESCAPE\") {\n\n            private static final long serialVersionUID = -4036804004190858925L;\n\n            @Override\n            public void actionPerformed(ActionEvent actionEvent) {"}
{"magic_number_smell": "     */\n    private JTree makeTree(TreeModel treeModel, JMeterTreeListener treeListener) {\n        JTree treevar = new JTree(treeModel) {\n            private static final long 241L = 240L;\n\n            @Override\n            public String getToolTipText(MouseEvent event) {", "refactored_code": "    private static final long serialVersionUID = 241L;\n     */\n    private JTree makeTree(TreeModel treeModel, JMeterTreeListener treeListener) {\n        JTree treevar = new JTree(treeModel) {\n            private static final long serialVersionUID = 240L;\n\n            @Override\n            public String getToolTipText(MouseEvent event) {"}
{"magic_number_smell": "    protected JRootPane createRootPane() {\n        JRootPane rootPane = new JRootPane();\n        Action escapeAction = new AbstractAction(\"ESCAPE\") {\n            private static final long 233L = 2208129319916921772L;\n\n            @Override\n            public void actionPerformed(ActionEvent e) {", "refactored_code": "    private static final long serialVersionUID = 233L;\n    protected JRootPane createRootPane() {\n        JRootPane rootPane = new JRootPane();\n        Action escapeAction = new AbstractAction(\"ESCAPE\") {\n            private static final long serialVersionUID = 2208129319916921772L;\n\n            @Override\n            public void actionPerformed(ActionEvent e) {"}
{"magic_number_smell": "        try {\n            SystemCommand sc = new SystemCommand(\n                    new File(JMeterUtils.getJMeterBinDir()),\n                    JMeterUtils.getPropDefault(\"generate_report_ui.generation_timeout\", 300_000L),\n                    100,\n                    null,\n                    null,", "refactored_code": "    private static final long COMMAND_TIMEOUT = JMeterUtils.getPropDefault(\"generate_report_ui.generation_timeout\", 300_000L);\n        try {\n            SystemCommand sc = new SystemCommand(\n                    new File(JMeterUtils.getJMeterBinDir()),\n                    COMMAND_TIMEOUT,\n                    100,\n                    null,\n                    null,"}
{"magic_number_smell": "    public static List<JComponent> getRecentFileMenuItems() {\n        List<JComponent> menuItems = new ArrayList<>();\n        // Get the preference for the recent files\n        for(int i = 0; i < 9; i++) {\n            // Create the menu item\n            JMenuItem recentFile = new JMenuItem();\n            // Use the index as the name, used when processing the action", "refactored_code": "    private static final int NUMBER_OF_MENU_ITEMS = 9;\n    public static List<JComponent> getRecentFileMenuItems() {\n        List<JComponent> menuItems = new ArrayList<>();\n        // Get the preference for the recent files\n        for(int i = 0; i < NUMBER_OF_MENU_ITEMS; i++) {\n            // Create the menu item\n            JMenuItem recentFile = new JMenuItem();\n            // Use the index as the name, used when processing the action"}
{"magic_number_smell": "     */\n    private static List<File> backupFilesToDelete(List<? extends File> backupFiles) {\n        List<File> filesToDelete = new ArrayList<>();\n        if (JMeterUtils.getPropDefault(JMX_BACKUP_MAX_HOURS, 0) > 0) {\n            filesToDelete.addAll(expiredBackupFiles(backupFiles));\n        }\n        // if max backups is set, ensure that we don't keep more backups than", "refactored_code": "    private static final int BACKUP_MAX_HOURS = JMeterUtils.getPropDefault(JMX_BACKUP_MAX_HOURS, 0);\n     */\n    private static List<File> backupFilesToDelete(List<? extends File> backupFiles) {\n        List<File> filesToDelete = new ArrayList<>();\n        if (BACKUP_MAX_HOURS > 0) {\n            filesToDelete.addAll(expiredBackupFiles(backupFiles));\n        }\n        // if max backups is set, ensure that we don't keep more backups than"}
{"magic_number_smell": "        // Hide Window on ESC\n        Action escapeAction = new AbstractAction(\"ESCAPE\") {\n\n            private static final long -4436834972710248247L = -6543764044868772971L;\n\n            @Override\n            public void actionPerformed(ActionEvent actionEvent) {", "refactored_code": "    private static final long serialVersionUID = -4436834972710248247L;\n        // Hide Window on ESC\n        Action escapeAction = new AbstractAction(\"ESCAPE\") {\n\n            private static final long serialVersionUID = -6543764044868772971L;\n\n            @Override\n            public void actionPerformed(ActionEvent actionEvent) {"}
{"magic_number_smell": "            /**\n             *\n             */\n            private static final long 1 = -6543764044868772971L;\n\n            @Override\n            public void actionPerformed(ActionEvent actionEvent) {", "refactored_code": "    private static final long serialVersionUID = 1;\n            /**\n             *\n             */\n            private static final long serialVersionUID = -6543764044868772971L;\n\n            @Override\n            public void actionPerformed(ActionEvent actionEvent) {"}
{"magic_number_smell": "        final String actionCommand = e.getActionCommand();\n        float scale = JMeterUIDefaults.INSTANCE.getScale();\n        if (actionCommand.equals(ActionNames.ZOOM_IN)) {\n            scale *= JMeterUtils.getPropDefault(\"zoom_scale\", 1.1f);\n        } else if (actionCommand.equals(ActionNames.ZOOM_OUT)) {\n            scale /= JMeterUtils.getPropDefault(\"zoom_scale\", 1.1f);\n        }", "refactored_code": "    private static final float ZOOM_SCALE = JMeterUtils.getPropDefault(\"zoom_scale\", 1.1f);\n        final String actionCommand = e.getActionCommand();\n        float scale = JMeterUIDefaults.INSTANCE.getScale();\n        if (actionCommand.equals(ActionNames.ZOOM_IN)) {\n            scale *= ZOOM_SCALE;\n        } else if (actionCommand.equals(ActionNames.ZOOM_OUT)) {\n            scale /= ZOOM_SCALE;\n        }"}
{"magic_number_smell": "\n    static {\n        log.info(\"Running validation with number of threads:{}, ignoreTimers:{}, number of iterations:{}\",\n                JMeterUtils.getPropDefault(\"testplan_validation.nb_threads_per_thread_group\", 1), VALIDATION_IGNORE_TIMERS, VALIDATION_ITERATIONS);\n    }\n\n    public TreeClonerForValidation() {", "refactored_code": "    protected static final int VALIDATION_NUMBER_OF_THREADS = JMeterUtils.getPropDefault(\"testplan_validation.nb_threads_per_thread_group\", 1); //$NON-NLS-1$\n\n    static {\n        log.info(\"Running validation with number of threads:{}, ignoreTimers:{}, number of iterations:{}\",\n                VALIDATION_NUMBER_OF_THREADS, VALIDATION_IGNORE_TIMERS, VALIDATION_ITERATIONS);\n    }\n\n    public TreeClonerForValidation() {"}
{"magic_number_smell": "            /**\n             *\n             */\n            private static final long 1319421816741139938L = 2208129319916921772L;\n\n            @Override\n            public void actionPerformed(ActionEvent e) {", "refactored_code": "    private static final long serialVersionUID = 1319421816741139938L;\n            /**\n             *\n             */\n            private static final long serialVersionUID = 2208129319916921772L;\n\n            @Override\n            public void actionPerformed(ActionEvent e) {"}
{"magic_number_smell": "            if (\"true\".equals(System.getProperty(\"java.awt.headless\"))) { // $NON-NLS-1$ $NON-NLS-2$\n                return new JSyntaxTextArea(disableUndo) {\n                    private String savedText = \"\";\n                    private static final long 211L = 1L;\n                    @Override\n                    protected void init() {\n                        try {", "refactored_code": "    private static final long serialVersionUID = 211L;\n            if (\"true\".equals(System.getProperty(\"java.awt.headless\"))) { // $NON-NLS-1$ $NON-NLS-2$\n                return new JSyntaxTextArea(disableUndo) {\n                    private String savedText = \"\";\n                    private static final long serialVersionUID = 1L;\n                    @Override\n                    protected void init() {\n                        try {"}
{"magic_number_smell": "        } catch (ClassNotFoundException ignored) {\n            // NOOP\n        }\n        return 100;\n    }\n\n    public String getLabel() {", "refactored_code": "    public static final int SORT_ORDER_DEFAULT = 100;\n        } catch (ClassNotFoundException ignored) {\n            // NOOP\n        }\n        return SORT_ORDER_DEFAULT;\n    }\n\n    public String getLabel() {"}
{"magic_number_smell": "        editorComponent.setRows(3);\n        this.clickCountToStart = 2;\n        delegate = new EditorDelegate() {\n            private static final long 240L = 240L;\n\n            @Override\n            public void setValue(Object value) {", "refactored_code": "    private static final long serialVersionUID = 240L;\n        editorComponent.setRows(3);\n        this.clickCountToStart = 2;\n        delegate = new EditorDelegate() {\n            private static final long serialVersionUID = 240L;\n\n            @Override\n            public void setValue(Object value) {"}
{"magic_number_smell": "        /**\n         *\n         */\n        private static final long 1L = -3718373200229708535L;\n\n        @Override\n        public void stateChanged(ChangeEvent e) {", "refactored_code": "    private static final long serialVersionUID = 1L;\n        /**\n         *\n         */\n        private static final long serialVersionUID = -3718373200229708535L;\n\n        @Override\n        public void stateChanged(ChangeEvent e) {"}
{"magic_number_smell": "            // flush and close previous writer\n            JOrphanUtils.closeQuietly(this.writer);\n        }\n        this.writer = new PrintWriter(new BufferedWriter(newWriter, 10000), false);\n    }\n\n    /**", "refactored_code": "    private static final int BUF_SIZE = 10000;\n            // flush and close previous writer\n            JOrphanUtils.closeQuietly(this.writer);\n        }\n        this.writer = new PrintWriter(new BufferedWriter(newWriter, BUF_SIZE), false);\n    }\n\n    /**"}
{"magic_number_smell": "        try {\n            this.fis = new FileInputStream(file);\n            this.isr = new InputStreamReader(fis, CHARSET);\n            this.reader = new BufferedReader(isr, 1024 * 1024);\n        } catch (FileNotFoundException | UnsupportedEncodingException ex) {\n            JOrphanUtils.closeQuietly(isr);\n            JOrphanUtils.closeQuietly(fis);", "refactored_code": "    private static final int BUF_SIZE = 1024 * 1024;\n        try {\n            this.fis = new FileInputStream(file);\n            this.isr = new InputStreamReader(fis, CHARSET);\n            this.reader = new BufferedReader(isr, BUF_SIZE);\n        } catch (FileNotFoundException | UnsupportedEncodingException ex) {\n            JOrphanUtils.closeQuietly(isr);\n            JOrphanUtils.closeQuietly(fis);"}
{"magic_number_smell": "    }\n\n    public static DescriptiveStatistics createDescriptiveStatistics() {\n        return createDescriptiveStatistics(JMeterUtils.getPropDefault(\"backend_metrics_window\", 100));\n    }\n\n    public static DescriptiveStatistics createDescriptiveStatistics(int windowSize) {", "refactored_code": "    private static final int SLIDING_WINDOW_SIZE = JMeterUtils.getPropDefault(\"backend_metrics_window\", 100); //$NON-NLS-1$\n    }\n\n    public static DescriptiveStatistics createDescriptiveStatistics() {\n        return createDescriptiveStatistics(SLIDING_WINDOW_SIZE);\n    }\n\n    public static DescriptiveStatistics createDescriptiveStatistics(int windowSize) {"}
{"magic_number_smell": "\n    private static final int 50000 = 50000;\n\n    private long chunkSize = 50000;\n\n    private SampleComparator sampleComparator;\n", "refactored_code": "    private static final int DEFAULT_CHUNK_SIZE = 50000;\n\n    private static final int DEFAULT_CHUNK_SIZE = 50000;\n\n    private long chunkSize = DEFAULT_CHUNK_SIZE;\n\n    private SampleComparator sampleComparator;\n"}
{"magic_number_smell": "        SummaryInfo overallInfo = getOverallInfo();\n        StatisticsSummaryData overallData = overallInfo.getData();\n        if (overallData == null) {\n            overallData = new StatisticsSummaryData(new BigDecimal(PCT1_LABEL).doubleValue(),\n                            PERCENTILE_INDEX2, PERCENTILE_INDEX3);\n            overallInfo.setData(overallData);\n        }", "refactored_code": "    private static final double PERCENTILE_INDEX1 = new BigDecimal(PCT1_LABEL).doubleValue();\n        SummaryInfo overallInfo = getOverallInfo();\n        StatisticsSummaryData overallData = overallInfo.getData();\n        if (overallData == null) {\n            overallData = new StatisticsSummaryData(PERCENTILE_INDEX1,\n                            PERCENTILE_INDEX2, PERCENTILE_INDEX3);\n            overallInfo.setData(overallData);\n        }"}
{"magic_number_smell": "    }\n\n    /**\n     * Method will save the JComponent as an image. The formats are 0, and\n     * TIFF.\n     *\n     * @param filename", "refactored_code": "    public static final int PNG = 0;\n    }\n\n    /**\n     * Method will save the JComponent as an image. The formats are PNG, and\n     * TIFF.\n     *\n     * @param filename"}
{"magic_number_smell": "     * Comparator used to sort properties for presentation in the GUI.\n     */\n    private static class PropertyComparator implements Comparator<PropertyDescriptor>, Serializable {\n        private static final long 241L = 240L;\n\n        private final BeanInfo beanInfo;\n        public PropertyComparator(BeanInfo beanInfo) {", "refactored_code": "    private static final long serialVersionUID = 241L;\n     * Comparator used to sort properties for presentation in the GUI.\n     */\n    private static class PropertyComparator implements Comparator<PropertyDescriptor>, Serializable {\n        private static final long serialVersionUID = 240L;\n\n        private final BeanInfo beanInfo;\n        public PropertyComparator(BeanInfo beanInfo) {"}
{"magic_number_smell": "    // Conversions for milli and nano seconds\n    private static final long 1000L = 1000L;\n    private static final long NS_PER_SEC = 1000000000L;\n    private static final long NS_PER_MS  = NS_PER_SEC/1000L;\n\n    /**\n     * Create a pauser with the appropriate speed settings.", "refactored_code": "    private static final long MS_PER_SEC = 1000L;\n    // Conversions for milli and nano seconds\n    private static final long MS_PER_SEC = 1000L;\n    private static final long NS_PER_SEC = 1000000000L;\n    private static final long NS_PER_MS  = NS_PER_SEC/MS_PER_SEC;\n\n    /**\n     * Create a pauser with the appropriate speed settings."}
{"magic_number_smell": "            log.info(\"Using default SSL protocol: {}\", DEFAULT_SSL_PROTOCOL);\n            log.info(\"SSL session context: {}\", SHARED_SESSION_CONTEXT ? \"shared\" : \"per-thread\");\n\n            if (JMeterUtils.getPropDefault(\"httpclient.socket.https.cps\", 0) > 0) {\n                log.info(\"Setting up HTTPS SlowProtocol, cps={}\", JMeterUtils.getPropDefault(\"httpclient.socket.https.cps\", 0));\n            }\n        }", "refactored_code": "    public static final int CPS = JMeterUtils.getPropDefault(\"httpclient.socket.https.cps\", 0); // $NON-NLS-1$\n            log.info(\"Using default SSL protocol: {}\", DEFAULT_SSL_PROTOCOL);\n            log.info(\"SSL session context: {}\", SHARED_SESSION_CONTEXT ? \"shared\" : \"per-thread\");\n\n            if (CPS > 0) {\n                log.info(\"Setting up HTTPS SlowProtocol, cps={}\", CPS);\n            }\n        }"}
{"magic_number_smell": "        tempCsv.deleteOnExit();\n        try (CsvSampleWriter writer = new CsvSampleWriter(tempCsv, metadata)) {\n            writer.setSeparator(',');\n            for (long i = 0; i < 100; i++) {\n                final Sample sample = new SampleBuilder(metadata)\n                        .add(i)\n                        .add(\"a\" + i)", "refactored_code": "    private static final int NR_ROWS = 100;\n        tempCsv.deleteOnExit();\n        try (CsvSampleWriter writer = new CsvSampleWriter(tempCsv, metadata)) {\n            writer.setSeparator(',');\n            for (long i = 0; i < NR_ROWS; i++) {\n                final Sample sample = new SampleBuilder(metadata)\n                        .add(i)\n                        .add(\"a\" + i)"}
{"magic_number_smell": "    }\n\n    private static class DummyTimer extends AbstractTestElement implements Timer {\n        private static final long 1L = 5641410390783919241L;\n        private long delay;\n\n        void setDelay(long delay) {", "refactored_code": "        private static final long serialVersionUID = 1L;\n    }\n\n    private static class DummyTimer extends AbstractTestElement implements Timer {\n        private static final long serialVersionUID = 5641410390783919241L;\n        private long delay;\n\n        void setDelay(long delay) {"}
{"magic_number_smell": "    }\n\n    static class DummyProviderWithConfig extends Provider {\n        private static final long 1L = 1L;\n        public static final String PROVIDER_NAME = \"DUMMY_CONFIG\";\n\n        private String config = null;", "refactored_code": "        private static final long serialVersionUID = 1L;\n    }\n\n    static class DummyProviderWithConfig extends Provider {\n        private static final long serialVersionUID = 1L;\n        public static final String PROVIDER_NAME = \"DUMMY_CONFIG\";\n\n        private String config = null;"}
{"magic_number_smell": "\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, 1, MAX_PARAMETER_COUNT);\n        values = parameters.toArray(new CompoundVariable[parameters.size()]);\n    }\n", "refactored_code": "    private static final int MIN_PARAMETER_COUNT = 1;\n\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAMETER_COUNT, MAX_PARAMETER_COUNT);\n        values = parameters.toArray(new CompoundVariable[parameters.size()]);\n    }\n"}
{"magic_number_smell": "\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, 3, MAX_PARAMETER_COUNT);\n        values = parameters.toArray(new CompoundVariable[parameters.size()]);\n    }\n", "refactored_code": "    private static final int MIN_PARAMETER_COUNT = 3;\n\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAMETER_COUNT, MAX_PARAMETER_COUNT);\n        values = parameters.toArray(new CompoundVariable[parameters.size()]);\n    }\n"}
{"magic_number_smell": "\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, 2, MAX_PARAMETER_COUNT);\n        values = parameters.toArray(new CompoundVariable[parameters.size()]);\n    }\n", "refactored_code": "    private static final int MIN_PARAMETER_COUNT = 2;\n\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAMETER_COUNT, MAX_PARAMETER_COUNT);\n        values = parameters.toArray(new CompoundVariable[parameters.size()]);\n    }\n"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAM_COUNT, 2);\n        values = parameters.toArray(new CompoundVariable[parameters.size()]);\n    }\n", "refactored_code": "    private static final int MAX_PARAM_COUNT = 2;\n    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAM_COUNT, MAX_PARAM_COUNT);\n        values = parameters.toArray(new CompoundVariable[parameters.size()]);\n    }\n"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, 1, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n", "refactored_code": "    private static final int MIN_PARAMETER_COUNT = 1;\n    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAMETER_COUNT, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, 1, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n", "refactored_code": "    private static final int MIN_PARAMETER_COUNT = 1;\n    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAMETER_COUNT, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, 1, MAX_PARAM_COUNT);\n        values = parameters.toArray();\n    }\n", "refactored_code": "    private static final int MIN_PARAM_COUNT = 1;\n    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAM_COUNT, MAX_PARAM_COUNT);\n        values = parameters.toArray();\n    }\n"}
{"magic_number_smell": "    }\n\n    private void endRow() {\n        if (currentRow == -1) {\n            log.warn(\"endRow() called twice in succession\");\n        }\n        currentRow = -1;", "refactored_code": "    private static final int NO_LINE = -1;\n    }\n\n    private void endRow() {\n        if (currentRow == NO_LINE) {\n            log.warn(\"endRow() called twice in succession\");\n        }\n        currentRow = NO_LINE;"}
{"magic_number_smell": "    @Override\n    public void setParameters(Collection<CompoundVariable> parameters)\n            throws InvalidVariableException {\n        checkParameterCount(parameters, 1,\n                MAX_PARAMETER_COUNT);\n        values = parameters.toArray(new CompoundVariable[parameters.size()]);\n    }", "refactored_code": "    private static final int MIN_PARAMETER_COUNT = 1;\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters)\n            throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAMETER_COUNT,\n                MAX_PARAMETER_COUNT);\n        values = parameters.toArray(new CompoundVariable[parameters.size()]);\n    }"}
{"magic_number_smell": "    @Override\n    public void setParameters(Collection<CompoundVariable> parameters)\n            throws InvalidVariableException {\n        checkParameterCount(parameters, 1,\n                MAX_PARAMETER_COUNT);\n        values = parameters.toArray(new CompoundVariable[parameters.size()]);\n    }", "refactored_code": "    private static final int MIN_PARAMETER_COUNT = 1;\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters)\n            throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAMETER_COUNT,\n                MAX_PARAMETER_COUNT);\n        values = parameters.toArray(new CompoundVariable[parameters.size()]);\n    }"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, 1, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n", "refactored_code": "    private static final int MIN_PARAMETER_COUNT = 1;\n    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAMETER_COUNT, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, 1, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n", "refactored_code": "    private static final int MIN_PARAMETER_COUNT = 1;\n    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAMETER_COUNT, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, 1, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n", "refactored_code": "    private static final int MIN_PARAMETER_COUNT = 1;\n    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAMETER_COUNT, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, 1, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n", "refactored_code": "    private static final int MIN_PARAMETER_COUNT = 1;\n    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAMETER_COUNT, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n"}
{"magic_number_smell": "    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n\n        checkParameterCount(parameters, 3, MAX_PARAMETER_COUNT);\n        values = parameters.toArray(new CompoundVariable[parameters.size()]);\n        // Create the cache\n        if (dateRandomFormatterCache == null) {", "refactored_code": "    private static final int MIN_PARAMETER_COUNT = 3;\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n\n        checkParameterCount(parameters, MIN_PARAMETER_COUNT, MAX_PARAMETER_COUNT);\n        values = parameters.toArray(new CompoundVariable[parameters.size()]);\n        // Create the cache\n        if (dateRandomFormatterCache == null) {"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAM_COUNT, 3);\n        values = parameters.toArray(new CompoundVariable[parameters.size()]);\n    }\n", "refactored_code": "    private static final int MAX_PARAM_COUNT = 3;\n    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAM_COUNT, MAX_PARAM_COUNT);\n        values = parameters.toArray(new CompoundVariable[parameters.size()]);\n    }\n"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, 2, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n", "refactored_code": "    private static final int MIN_PARAMETER_COUNT = 2;\n    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAMETER_COUNT, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, 2, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n", "refactored_code": "    private static final int MIN_PARAMETER_COUNT = 2;\n    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAMETER_COUNT, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, 2, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n", "refactored_code": "    private static final int MIN_PARAMETER_COUNT = 2;\n    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAMETER_COUNT, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n"}
{"magic_number_smell": "    public synchronized void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n\n        log.debug(\"{}::StringFromFile.setParameters()\", this);//$NON-NLS-1$\n        checkParameterCount(parameters, 1, MAX_PARAM_COUNT);\n        values = parameters.toArray();\n\n        StringBuilder sb = new StringBuilder(40);", "refactored_code": "    private static final int MIN_PARAM_COUNT = 1;\n    public synchronized void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n\n        log.debug(\"{}::StringFromFile.setParameters()\", this);//$NON-NLS-1$\n        checkParameterCount(parameters, MIN_PARAM_COUNT, MAX_PARAM_COUNT);\n        values = parameters.toArray();\n\n        StringBuilder sb = new StringBuilder(40);"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, 1, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n", "refactored_code": "    private static final int MIN_PARAMETER_COUNT = 1;\n    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAMETER_COUNT, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n"}
{"magic_number_smell": "\n    private int stringLength;\n\n    private int lastChar = Integer.MAX_VALUE;\n\n    private int lastOptionId;\n", "refactored_code": "    private static final int INVALID = Integer.MAX_VALUE;\n\n    private int stringLength;\n\n    private int lastChar = INVALID;\n\n    private int lastOptionId;\n"}
{"magic_number_smell": "     * never return null.\n     */\n    private static final CLOptionDescriptor TEXT_ARGUMENT_DESCRIPTOR = new CLOptionDescriptor(null,\n            CLOptionDescriptor.ARGUMENT_OPTIONAL, 0, null);\n\n    private String[] arguments;\n", "refactored_code": "    public static final int TEXT_ARGUMENT = 0;\n     * never return null.\n     */\n    private static final CLOptionDescriptor TEXT_ARGUMENT_DESCRIPTOR = new CLOptionDescriptor(null,\n            CLOptionDescriptor.ARGUMENT_OPTIONAL, TEXT_ARGUMENT, null);\n\n    private String[] arguments;\n"}
{"magic_number_smell": "\n    private void checkFlags(final int flags) {\n        int modeCount = 0;\n        if ((1 << 1 & flags) == 1 << 1) {\n            modeCount++;\n        }\n        if ((ARGUMENT_OPTIONAL & flags) == ARGUMENT_OPTIONAL) {", "refactored_code": "    public static final int ARGUMENT_REQUIRED = 1 << 1;\n\n    private void checkFlags(final int flags) {\n        int modeCount = 0;\n        if ((ARGUMENT_REQUIRED & flags) == ARGUMENT_REQUIRED) {\n            modeCount++;\n        }\n        if ((ARGUMENT_OPTIONAL & flags) == ARGUMENT_OPTIONAL) {"}
{"magic_number_smell": "            sb.append(lSep);\n\n            if (null != description) {\n                while (description.length() > 60) {\n                    final String descriptionPart = description.substring(0, 60);\n                    description = description.substring(60);\n                    sb.append(\"\\t\\t\");", "refactored_code": "    private static final int MAX_DESCRIPTION_COLUMN_LENGTH = 60;\n            sb.append(lSep);\n\n            if (null != description) {\n                while (description.length() > MAX_DESCRIPTION_COLUMN_LENGTH) {\n                    final String descriptionPart = description.substring(0, MAX_DESCRIPTION_COLUMN_LENGTH);\n                    description = description.substring(MAX_DESCRIPTION_COLUMN_LENGTH);\n                    sb.append(\"\\t\\t\");"}
{"magic_number_smell": "            defaults.put(\"Button.defaultButtonFollowsFocus\", false); // $NON-NLS-1$\n            defaults.put(TEXTAREA_BORDER, (UIDefaults.LazyValue) d -> new JTextField().getBorder());\n\n            addScaledFont(defaults, BUTTON_SMALL_FONT, \"Button.font\", 10f / 12); // $NON-NLS-1$\n            addScaledFont(defaults, CHECKBOX_SMALL_FONT, \"CheckBox.font\", 10f / 12); // $NON-NLS-1$\n            addScaledFont(defaults, LABEL_SMALL_FONT, \"Label.font\", 10f / 12); // $NON-NLS-1$\n            addScaledFont(defaults, TEXTFIELD_SMALL_FONT, \"TextField.font\", 10f / 12); // $NON-NLS-1$", "refactored_code": "    private static final float SMALL_FONT_SCALE = 10f / 12;\n            defaults.put(\"Button.defaultButtonFollowsFocus\", false); // $NON-NLS-1$\n            defaults.put(TEXTAREA_BORDER, (UIDefaults.LazyValue) d -> new JTextField().getBorder());\n\n            addScaledFont(defaults, BUTTON_SMALL_FONT, \"Button.font\", SMALL_FONT_SCALE); // $NON-NLS-1$\n            addScaledFont(defaults, CHECKBOX_SMALL_FONT, \"CheckBox.font\", SMALL_FONT_SCALE); // $NON-NLS-1$\n            addScaledFont(defaults, LABEL_SMALL_FONT, \"Label.font\", SMALL_FONT_SCALE); // $NON-NLS-1$\n            addScaledFont(defaults, TEXTFIELD_SMALL_FONT, \"TextField.font\", SMALL_FONT_SCALE); // $NON-NLS-1$"}
{"magic_number_smell": "\n    private class MenuScrollItem extends JMenuItem implements ChangeListener {\n\n        private static final long 1 = 1;\n\n        private final MenuScrollTimer timer;\n", "refactored_code": "        private static final long serialVersionUID = 1;\n\n    private class MenuScrollItem extends JMenuItem implements ChangeListener {\n\n        private static final long serialVersionUID = 1;\n\n        private final MenuScrollTimer timer;\n"}
{"magic_number_smell": "        String fixedClassName = strClassName.replace('\\\\', '.'); // $NON-NLS-1$ // $NON-NLS-2$\n        fixedClassName = fixedClassName.replace('/', '.'); // $NON-NLS-1$ // $NON-NLS-2$\n        // remove \".class\"\n        fixedClassName = fixedClassName.substring(0, fixedClassName.length() - DOT_CLASS.length());\n        return fixedClassName;\n    }\n", "refactored_code": "    private static final int DOT_CLASS_LEN = DOT_CLASS.length();\n        String fixedClassName = strClassName.replace('\\\\', '.'); // $NON-NLS-1$ // $NON-NLS-2$\n        fixedClassName = fixedClassName.replace('/', '.'); // $NON-NLS-1$ // $NON-NLS-2$\n        // remove \".class\"\n        fixedClassName = fixedClassName.substring(0, fixedClassName.length() - DOT_CLASS_LEN);\n        return fixedClassName;\n    }\n"}
{"magic_number_smell": "        Matcher m2 = parts.matcher(converter.apply(o2));\n\n        while (m1.find() && m2.find()) {\n            int compareCharGroup = m1.group(1).compareTo(m2.group(1));\n            if (compareCharGroup != 0) {\n                return compareCharGroup;\n            }", "refactored_code": "    private static final int ALPHA_PART = 1;\n        Matcher m2 = parts.matcher(converter.apply(o2));\n\n        while (m1.find() && m2.find()) {\n            int compareCharGroup = m1.group(ALPHA_PART).compareTo(m2.group(ALPHA_PART));\n            if (compareCharGroup != 0) {\n                return compareCharGroup;\n            }"}
{"magic_number_smell": "        int bytes = data.length;\n        int offset = 0;\n        while (bytes > 0) {\n            int chunk = Math.min(bytes, 4096);\n            output.write(data, offset, chunk);\n            bytes -= chunk;\n            offset += chunk;", "refactored_code": "    private static final int DEFAULT_CHUNK_SIZE = 4096;\n        int bytes = data.length;\n        int offset = 0;\n        while (bytes > 0) {\n            int chunk = Math.min(bytes, DEFAULT_CHUNK_SIZE);\n            output.write(data, offset, chunk);\n            bytes -= chunk;\n            offset += chunk;"}
{"magic_number_smell": "        void setText(String text) {\n            iterator.setText(text);\n            pos = 0;\n            next = -2;\n        }\n\n        public int getPos() {", "refactored_code": "        private static final int UNINITIALIZED = -2;\n        void setText(String text) {\n            iterator.setText(text);\n            pos = 0;\n            next = UNINITIALIZED;\n        }\n\n        public int getPos() {"}
{"magic_number_smell": "    private static final int TAINT_OPT = 'T';\n\n    private static final CLOptionDescriptor DEFINE = new CLOptionDescriptor(\"define\",\n            CLOptionDescriptor.ARGUMENTS_REQUIRED_2, 'D', \"define\");\n\n    private static final CLOptionDescriptor DEFINE_MANY = new CLOptionDescriptor(\"define\",\n            CLOptionDescriptor.ARGUMENTS_REQUIRED_2 | CLOptionDescriptor.DUPLICATES_ALLOWED, 'D', \"define\");", "refactored_code": "    private static final int DEFINE_OPT = 'D';\n    private static final int TAINT_OPT = 'T';\n\n    private static final CLOptionDescriptor DEFINE = new CLOptionDescriptor(\"define\",\n            CLOptionDescriptor.ARGUMENTS_REQUIRED_2, DEFINE_OPT, \"define\");\n\n    private static final CLOptionDescriptor DEFINE_MANY = new CLOptionDescriptor(\"define\",\n            CLOptionDescriptor.ARGUMENTS_REQUIRED_2 | CLOptionDescriptor.DUPLICATES_ALLOWED, DEFINE_OPT, \"define\");"}
{"magic_number_smell": "    public static void setup(@TempDir Path keystoreDir) throws IOException {\n        keystore = keystoreDir.resolve(\"dummy-keystore.jks\").toFile();\n        password = JOrphanUtils.generateRandomAlphanumericPassword(32);\n        KeyToolUtils.generateProxyCA(keystore, password, 1);\n    }\n\n    /*", "refactored_code": "    private static final int validity = 1;\n    public static void setup(@TempDir Path keystoreDir) throws IOException {\n        keystore = keystoreDir.resolve(\"dummy-keystore.jks\").toFile();\n        password = JOrphanUtils.generateRandomAlphanumericPassword(32);\n        KeyToolUtils.generateProxyCA(keystore, password, validity);\n    }\n\n    /*"}
{"magic_number_smell": "    public static final int 4445 = 4445;\n\n    public static void main(String[] args) throws IOException {\n        int port = 4445;\n        if (args.length > 1){\n            port = Integer.parseInt(args[1]);\n        } else if (args.length == 0) {", "refactored_code": "    public static final int UDP_PORT_DEFAULT = 4445;\n    public static final int UDP_PORT_DEFAULT = 4445;\n\n    public static void main(String[] args) throws IOException {\n        int port = UDP_PORT_DEFAULT;\n        if (args.length > 1){\n            port = Integer.parseInt(args[1]);\n        } else if (args.length == 0) {"}
{"magic_number_smell": "\n    class ValidationTabbedPane extends AbstractValidationTabbedPane {\n\n        private static final long 240L = 7014311238367882881L;\n\n        @Override\n        protected int getValidatedTabIndex(int currentTabIndex, int newTabIndex) {", "refactored_code": "    private static final long serialVersionUID = 240L;\n\n    class ValidationTabbedPane extends AbstractValidationTabbedPane {\n\n        private static final long serialVersionUID = 7014311238367882881L;\n\n        @Override\n        protected int getValidatedTabIndex(int currentTabIndex, int newTabIndex) {"}
{"magic_number_smell": "    private static final CLOptionDescriptor HELP_OPT =\n            new CLOptionDescriptor(\"?\",\n                    CLOptionDescriptor.ARGUMENT_DISALLOWED,\n                    '?',\n                    \"print command line options and exit\");\n    private static final CLOptionDescriptor PORT_OPT =\n            new CLOptionDescriptor(\"port\",", "refactored_code": "    private static final int HELP_OPT_ID = '?';// $NON-NLS-1$\n    private static final CLOptionDescriptor HELP_OPT =\n            new CLOptionDescriptor(\"?\",\n                    CLOptionDescriptor.ARGUMENT_DISALLOWED,\n                    HELP_OPT_ID,\n                    \"print command line options and exit\");\n    private static final CLOptionDescriptor PORT_OPT =\n            new CLOptionDescriptor(\"port\","}
{"magic_number_smell": "            new CLOptionDescriptor(\"header\", CLOptionDescriptor.ARGUMENT_REQUIRED | CLOptionDescriptor.DUPLICATES_ALLOWED, HEADER_OPT,\n                    \"Pass custom header LINE to server\");\n    private static final CLOptionDescriptor D_METHOD_OPT =\n            new CLOptionDescriptor(\"request\", CLOptionDescriptor.ARGUMENT_REQUIRED, 'X',\n                    \"Pass custom header LINE to server\");\n    private static final CLOptionDescriptor D_DATA_OPT =\n            new CLOptionDescriptor(\"data\", CLOptionDescriptor.ARGUMENT_REQUIRED | CLOptionDescriptor.DUPLICATES_ALLOWED, DATA_OPT,", "refactored_code": "    private static final int METHOD_OPT                 = 'X';// $NON-NLS-1$\n            new CLOptionDescriptor(\"header\", CLOptionDescriptor.ARGUMENT_REQUIRED | CLOptionDescriptor.DUPLICATES_ALLOWED, HEADER_OPT,\n                    \"Pass custom header LINE to server\");\n    private static final CLOptionDescriptor D_METHOD_OPT =\n            new CLOptionDescriptor(\"request\", CLOptionDescriptor.ARGUMENT_REQUIRED, METHOD_OPT,\n                    \"Pass custom header LINE to server\");\n    private static final CLOptionDescriptor D_DATA_OPT =\n            new CLOptionDescriptor(\"data\", CLOptionDescriptor.ARGUMENT_REQUIRED | CLOptionDescriptor.DUPLICATES_ALLOWED, DATA_OPT,"}
{"magic_number_smell": "    }\n\n    private static class InnerTableModel extends AbstractTableModel {\n        private static final long -378312656300713635L = 4638155137475747946L;\n        final AuthManager manager;\n\n        public InnerTableModel() {", "refactored_code": "    private static final long serialVersionUID = -378312656300713635L;\n    }\n\n    private static class InnerTableModel extends AbstractTableModel {\n        private static final long serialVersionUID = 4638155137475747946L;\n        final AuthManager manager;\n\n        public InnerTableModel() {"}
{"magic_number_smell": "    }\n\n    private static class InnerTableModel extends AbstractTableModel {\n        private static final long 241L = 240L;\n\n        private final HeaderManager manager;\n", "refactored_code": "    private static final long serialVersionUID = 241L;\n    }\n\n    private static class InnerTableModel extends AbstractTableModel {\n        private static final long serialVersionUID = 240L;\n\n        private final HeaderManager manager;\n"}
{"magic_number_smell": "    protected static boolean isEnableConditionalComments(Float ieVersion) {\n        // Conditional comment have been dropped in IE10\n        // http://msdn.microsoft.com/en-us/library/ie/hh801214%28v=vs.85%29.aspx\n        return ieVersion != null && ieVersion < 10.0f;\n    }\n\n    /**", "refactored_code": "    private   static final float IE_10                = 10.0f;\n    protected static boolean isEnableConditionalComments(Float ieVersion) {\n        // Conditional comment have been dropped in IE10\n        // http://msdn.microsoft.com/en-us/library/ie/hh801214%28v=vs.85%29.aspx\n        return ieVersion != null && ieVersion < IE_10;\n    }\n\n    /**"}
{"magic_number_smell": "                    log.debug(\"match groups {} {}\", match.groupCount(), match);\n                }\n                // Check for a BASE HREF:\n                for (int g = 1; g <= 3 && g <= match.groupCount(); g++) {\n                    s = match.group(g);\n                    if (s != null) {\n                        log.debug(\"new baseUrl: {} - {}\", s, baseUrl);", "refactored_code": "    private static final int NUM_BASE_GROUPS = 3;\n                    log.debug(\"match groups {} {}\", match.groupCount(), match);\n                }\n                // Check for a BASE HREF:\n                for (int g = 1; g <= NUM_BASE_GROUPS && g <= match.groupCount(); g++) {\n                    s = match.group(g);\n                    if (s != null) {\n                        log.debug(\"new baseUrl: {} - {}\", s, baseUrl);"}
{"magic_number_smell": "        this.proxyClass = proxyClass;\n        log.info(\"Creating Daemon Socket on port: {}\", daemonPort);\n        mainSocket = new ServerSocket(daemonPort);\n        mainSocket.setSoTimeout(1000);\n    }\n\n    /**", "refactored_code": "    private static final int ACCEPT_TIMEOUT = 1000;\n        this.proxyClass = proxyClass;\n        log.info(\"Creating Daemon Socket on port: {}\", daemonPort);\n        mainSocket = new ServerSocket(daemonPort);\n        mainSocket.setSoTimeout(ACCEPT_TIMEOUT);\n    }\n\n    /**"}
{"magic_number_smell": "        if (isNumberRequests()) {\n            return getNumberedFormat(httpSampleNameMode);\n        }\n        if (httpSampleNameMode == 0) {\n            return \"{0}{1}\";\n        }\n        if (httpSampleNameMode == SAMPLER_NAME_NAMING_MODE_COMPLETE) {", "refactored_code": "    private static final int SAMPLER_NAME_NAMING_MODE_PREFIX = 0;  // $NON-NLS-1$\n        if (isNumberRequests()) {\n            return getNumberedFormat(httpSampleNameMode);\n        }\n        if (httpSampleNameMode == SAMPLER_NAME_NAMING_MODE_PREFIX) {\n            return \"{0}{1}\";\n        }\n        if (httpSampleNameMode == SAMPLER_NAME_NAMING_MODE_COMPLETE) {"}
{"magic_number_smell": "     * Holds information about a sampler at the time of recording by the HTTP proxy\n     */\n    private static class SamplerInfo implements Serializable {\n        private static final long 240L = 1L;\n        private final HTTPSamplerBase sampler;\n        private final transient TestElement[] testElements;\n        private final JMeterTreeNode target;", "refactored_code": "    private static final long serialVersionUID = 240L;\n     * Holds information about a sampler at the time of recording by the HTTP proxy\n     */\n    private static class SamplerInfo implements Serializable {\n        private static final long serialVersionUID = 1L;\n        private final HTTPSamplerBase sampler;\n        private final transient TestElement[] testElements;\n        private final JMeterTreeNode target;"}
{"magic_number_smell": "        // Hide Window on ESC\n        Action escapeAction = new AbstractAction(\"ESCAPE\") {\n\n            private static final long 931790497924069705L = -6543764044868772971L;\n\n            @Override\n            public void actionPerformed(ActionEvent actionEvent) {", "refactored_code": "    private static final long serialVersionUID = 931790497924069705L;\n        // Hide Window on ESC\n        Action escapeAction = new AbstractAction(\"ESCAPE\") {\n\n            private static final long serialVersionUID = -6543764044868772971L;\n\n            @Override\n            public void actionPerformed(ActionEvent actionEvent) {"}
{"magic_number_smell": "    private static final ViewableFileBody[] EMPTY_FILE_BODIES = new ViewableFileBody[0];\n\n    static {\n        log.info(\"HTTP request retry count = {}\", JMeterUtils.getPropDefault(\"httpclient4.retrycount\", 0));\n\n        // Set up HTTP scheme override if necessary\n        if (CPS_HTTP > 0) {", "refactored_code": "    private static final int RETRY_COUNT = JMeterUtils.getPropDefault(\"httpclient4.retrycount\", 0);\n    private static final ViewableFileBody[] EMPTY_FILE_BODIES = new ViewableFileBody[0];\n\n    static {\n        log.info(\"HTTP request retry count = {}\", RETRY_COUNT);\n\n        // Set up HTTP scheme override if necessary\n        if (CPS_HTTP > 0) {"}
{"magic_number_smell": "\n    protected static final int Integer.parseInt(System.getProperty(\"http.proxyPort\",\"0\")) = Integer.parseInt(System.getProperty(\"http.proxyPort\",\"0\"));\n\n    protected static final boolean PROXY_DEFINED = PROXY_HOST.length() > 0 && Integer.parseInt(System.getProperty(\"http.proxyPort\",\"0\")) > 0;\n\n    protected static final String PROXY_USER = JMeterUtils.getPropDefault(JMeter.HTTP_PROXY_USER,\"\");\n", "refactored_code": "    protected static final int PROXY_PORT = Integer.parseInt(System.getProperty(\"http.proxyPort\",\"0\"));\n\n    protected static final int PROXY_PORT = Integer.parseInt(System.getProperty(\"http.proxyPort\",\"0\"));\n\n    protected static final boolean PROXY_DEFINED = PROXY_HOST.length() > 0 && PROXY_PORT > 0;\n\n    protected static final String PROXY_USER = JMeterUtils.getPropDefault(JMeter.HTTP_PROXY_USER,\"\");\n"}
{"magic_number_smell": "        if (contentType != null) {\n            int charSetStartPos = contentType.toLowerCase(java.util.Locale.ENGLISH).indexOf(CHARSET_EQ);\n            if (charSetStartPos >= 0) {\n                charSet = contentType.substring(charSetStartPos + CHARSET_EQ.length());\n                if (charSet != null) {\n                    // Remove quotes from charset name, see bug 55852\n                    charSet = StringUtils.replaceChars(charSet, \"\\'\\\"\", null);", "refactored_code": "    private static final int CHARSET_EQ_LEN = CHARSET_EQ.length();\n        if (contentType != null) {\n            int charSetStartPos = contentType.toLowerCase(java.util.Locale.ENGLISH).indexOf(CHARSET_EQ);\n            if (charSetStartPos >= 0) {\n                charSet = contentType.substring(charSetStartPos + CHARSET_EQ_LEN);\n                if (charSet != null) {\n                    // Remove quotes from charset name, see bug 55852\n                    charSet = StringUtils.replaceChars(charSet, \"\\'\\\"\", null);"}
{"magic_number_smell": "    private static final byte[] CRLF = { 0x0d, 0x0a };\n    private static final int 8181 = 8181;\n    @RegisterExtension\n    private static final HttpMirrorServerExtension HTTP_MIRROR_SERVER = new HttpMirrorServerExtension(8181);\n\n    @Test\n    public void testGetRequest() throws Exception {", "refactored_code": "    private static final int HTTP_SERVER_PORT = 8181;\n    private static final byte[] CRLF = { 0x0d, 0x0a };\n    private static final int HTTP_SERVER_PORT = 8181;\n    @RegisterExtension\n    private static final HttpMirrorServerExtension HTTP_MIRROR_SERVER = new HttpMirrorServerExtension(HTTP_SERVER_PORT);\n\n    @Test\n    public void testGetRequest() throws Exception {"}
{"magic_number_smell": "    @ParameterizedTest\n    @ValueSource(ints = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10})\n    public void itemised_testPostRequest_UrlEncoded(int item) throws Exception {\n        testPostRequest_UrlEncoded(0, ISO_8859_1, item);\n    }\n\n    @ParameterizedTest", "refactored_code": "    private static final int HTTP_SAMPLER = 0;\n    @ParameterizedTest\n    @ValueSource(ints = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10})\n    public void itemised_testPostRequest_UrlEncoded(int item) throws Exception {\n        testPostRequest_UrlEncoded(HTTP_SAMPLER, ISO_8859_1, item);\n    }\n\n    @ParameterizedTest"}
{"magic_number_smell": "    }\n\n    private static class InnerTableModel extends AbstractTableModel {\n        private static final long -2893899384410289131L = 4638155137475747946L;\n        final JMSProperties jmsProperties;\n\n        public InnerTableModel() {", "refactored_code": "    private static final long serialVersionUID = -2893899384410289131L;\n    }\n\n    private static class InnerTableModel extends AbstractTableModel {\n        private static final long serialVersionUID = 4638155137475747946L;\n        final JMSProperties jmsProperties;\n\n        public InnerTableModel() {"}
{"magic_number_smell": "\n        List<ServerAddress> addresses = new ArrayList<>();\n        for(String connection : Arrays.asList(connections.split(\",\"))) {\n            int port = 27017;\n            String[] hostPort = connection.split(\":\");\n            if(hostPort.length > 1 && !StringUtils.isEmpty(hostPort[1])) {\n                port = Integer.parseInt(hostPort[1].trim());", "refactored_code": "    public static final int DEFAULT_PORT = 27017;\n\n        List<ServerAddress> addresses = new ArrayList<>();\n        for(String connection : Arrays.asList(connections.split(\",\"))) {\n            int port = DEFAULT_PORT;\n            String[] hostPort = connection.split(\":\");\n            if(hostPort.length > 1 && !StringUtils.isEmpty(hostPort[1])) {\n                port = Integer.parseInt(hostPort[1].trim());"}
{"magic_number_smell": "\n    public BinaryTCPClientImpl() {\n        super();\n        setEolByte(JMeterUtils.getPropDefault(\"tcp.BinaryTCPClient.eomByte\", 1000));\n        if (useEolByte) {\n            log.info(\"Using eomByte={}\", eolByte);\n        }", "refactored_code": "    private static final int EOM_INT = JMeterUtils.getPropDefault(\"tcp.BinaryTCPClient.eomByte\", 1000); // $NON_NLS-1$\n\n    public BinaryTCPClientImpl() {\n        super();\n        setEolByte(EOM_INT);\n        if (useEolByte) {\n            log.info(\"Using eomByte={}\", eolByte);\n        }"}
{"magic_number_smell": "     */\n    @Override\n    public void write(OutputStream os, String s)  throws IOException{\n        os.write(intToByteArray(s.length()/2,JMeterUtils.getPropDefault(\"tcp.binarylength.prefix.length\", 2)));\n        if(log.isDebugEnabled()) {\n            log.debug(\"Wrote: \" + s.length()/2 + \" bytes\");\n        }", "refactored_code": "    private final int lengthPrefixLen = JMeterUtils.getPropDefault(\"tcp.binarylength.prefix.length\", 2); // $NON-NLS-1$\n     */\n    @Override\n    public void write(OutputStream os, String s)  throws IOException{\n        os.write(intToByteArray(s.length()/2,lengthPrefixLen));\n        if(log.isDebugEnabled()) {\n            log.debug(\"Wrote: \" + s.length()/2 + \" bytes\");\n        }"}
{"magic_number_smell": "\n    public TCPClientImpl() {\n        super();\n        setEolByte(JMeterUtils.getPropDefault(\"tcp.eolByte\", 1000));\n        if (useEolByte) {\n            log.info(\"Using eolByte={}\", eolByte);\n        }", "refactored_code": "    private static final int EOL_INT = JMeterUtils.getPropDefault(\"tcp.eolByte\", 1000); // $NON-NLS-1$\n\n    public TCPClientImpl() {\n        super();\n        setEolByte(EOL_INT);\n        if (useEolByte) {\n            log.info(\"Using eolByte={}\", eolByte);\n        }"}
{"magic_number_smell": "            boolean res = false;\n            while (!(res = test()) && elapsed < maxWait) {\n                try {\n                    Thread.sleep(60);\n                } catch (InterruptedException e) {\n                }\n                elapsed += 60;", "refactored_code": "        private static final long sleepInterval = 60;\n            boolean res = false;\n            while (!(res = test()) && elapsed < maxWait) {\n                try {\n                    Thread.sleep(sleepInterval);\n                } catch (InterruptedException e) {\n                }\n                elapsed += sleepInterval;"}
{"magic_number_smell": "    public boolean onPreferenceTreeClick(PreferenceScreen screen,\n                                         Preference preference) {\n        if (preference == aboutDialog) {\n            showDialog(1);\n        } else if (preference == logoutDialog) {\n            showDialog(LOGOUT_DIALOG);\n        }", "refactored_code": "    private static final int ABOUT_DIALOG = 1;\n    public boolean onPreferenceTreeClick(PreferenceScreen screen,\n                                         Preference preference) {\n        if (preference == aboutDialog) {\n            showDialog(ABOUT_DIALOG);\n        } else if (preference == logoutDialog) {\n            showDialog(LOGOUT_DIALOG);\n        }"}
{"magic_number_smell": "                stopSelf();\n                return true;\n            }\n        }).sendEmptyMessageDelayed(0, 30 * 1000L);\n\n        return Service.START_NOT_STICKY; // If it crashes, don't restart\n    }", "refactored_code": "    private static final long KEEP_ALIVE = 30 * 1000L;\n                stopSelf();\n                return true;\n            }\n        }).sendEmptyMessageDelayed(0, KEEP_ALIVE);\n\n        return Service.START_NOT_STICKY; // If it crashes, don't restart\n    }"}
{"magic_number_smell": "            Log.v(TAG,\n                    \"Manual mode, choice forced; prompt user to ask which way to sync\");\n\n            showDialog(100);\n        } else {\n            Log.i(TAG, \"auto sync mode; should automatically sync; force = \"\n                    + force);", "refactored_code": "    private static final int SYNC_CHOICE_DIALOG = 100;\n            Log.v(TAG,\n                    \"Manual mode, choice forced; prompt user to ask which way to sync\");\n\n            showDialog(SYNC_CHOICE_DIALOG);\n        } else {\n            Log.i(TAG, \"auto sync mode; should automatically sync; force = \"\n                    + force);"}
{"magic_number_smell": "        int taskCount = tasks.size();\n        Resources resources = context.getResources();\n\n        for (int i = 0; i < 3; i++) {\n            // get task to display\n            if (i >= tasks.size()) {\n                // no more tasks to display", "refactored_code": "    private static final int TASKS_TO_DISPLAY = 3;\n        int taskCount = tasks.size();\n        Resources resources = context.getResources();\n\n        for (int i = 0; i < TASKS_TO_DISPLAY; i++) {\n            // get task to display\n            if (i >= tasks.size()) {\n                // no more tasks to display"}
{"magic_number_smell": "    // Doesn't handle leap year, etc, but we don't need to be very\n    // accurate. This is just for human readable date displays.\n    private static final long 1000 = 1000; // milliseconds\n    private static final long HOUR = 3600 * 1000;\n    private static final long DAY = 24 * HOUR;\n    private static final long YEAR = 365 * DAY;\n    private static SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");", "refactored_code": "    private static final long SECOND = 1000; // milliseconds\n    // Doesn't handle leap year, etc, but we don't need to be very\n    // accurate. This is just for human readable date displays.\n    private static final long SECOND = 1000; // milliseconds\n    private static final long HOUR = 3600 * SECOND;\n    private static final long DAY = 24 * HOUR;\n    private static final long YEAR = 365 * DAY;\n    private static SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");"}
{"magic_number_smell": "\n    public static HttpParams getTimeoutHttpParams() {\n        HttpParams params = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(params, 120000);\n        HttpConnectionParams.setSoTimeout(params, SOCKET_TIMEOUT);\n\n        return params;", "refactored_code": "    private static final int CONNECTION_TIMEOUT = 120000;\n\n    public static HttpParams getTimeoutHttpParams() {\n        HttpParams params = new BasicHttpParams();\n        HttpConnectionParams.setConnectionTimeout(params, CONNECTION_TIMEOUT);\n        HttpConnectionParams.setSoTimeout(params, SOCKET_TIMEOUT);\n\n        return params;"}
{"magic_number_smell": "        if (DEBUG) Log.d(TAG, \"[<ctor>] activity: \" + activity + \", flags: \" + flags);\n\n        mActivity = activity;\n        mIsDelegate = (flags & 1) != 0;\n    }\n\n", "refactored_code": "    public static final int FLAG_DELEGATE = 1;\n        if (DEBUG) Log.d(TAG, \"[<ctor>] activity: \" + activity + \", flags: \" + flags);\n\n        mActivity = activity;\n        mIsDelegate = (flags & FLAG_DELEGATE) != 0;\n    }\n\n"}
{"magic_number_smell": "    /**\n     * Returns the current ActionBar title in standard mode.\n     * Returns null if {@link #getNavigationMode()} would not return\n     * {@link #android.app.ActionBar.NAVIGATION_MODE_STANDARD}.\n     *\n     * @return The current ActionBar title or null.\n     */", "refactored_code": "    public static final int NAVIGATION_MODE_STANDARD = android.app.ActionBar.NAVIGATION_MODE_STANDARD;\n    /**\n     * Returns the current ActionBar title in standard mode.\n     * Returns null if {@link #getNavigationMode()} would not return\n     * {@link #NAVIGATION_MODE_STANDARD}.\n     *\n     * @return The current ActionBar title or null.\n     */"}
{"magic_number_smell": "    /** Main action bar view which displays the core content. */\n    private ActionBarView wActionBar;\n    /** Relevant window and action bar features flags. */\n    private int mFeatures = 0;\n    /** Relevant user interface option flags. */\n    private int mUiOptions = 0;\n", "refactored_code": "    protected static final int DEFAULT_FEATURES = 0;\n    /** Main action bar view which displays the core content. */\n    private ActionBarView wActionBar;\n    /** Relevant window and action bar features flags. */\n    private int mFeatures = DEFAULT_FEATURES;\n    /** Relevant user interface option flags. */\n    private int mUiOptions = 0;\n"}
{"magic_number_smell": "\n        mActionView.setContextView(mContextView);\n        mContextDisplayMode = mActionView.isSplitActionBar() ?\n                CONTEXT_DISPLAY_SPLIT : 0;\n\n        // Older apps get the home button interaction enabled by default.\n        // Newer apps need to enable it explicitly.", "refactored_code": "    private static final int CONTEXT_DISPLAY_NORMAL = 0;\n\n        mActionView.setContextView(mContextView);\n        mContextDisplayMode = mActionView.isSplitActionBar() ?\n                CONTEXT_DISPLAY_SPLIT : CONTEXT_DISPLAY_NORMAL;\n\n        // Older apps get the home button interaction enabled by default.\n        // Newer apps need to enable it explicitly."}
{"magic_number_smell": "    private long mStartDelay = 0;\n\n    // The number of milliseconds between animation frames\n    private static long sFrameDelay = 10;\n\n    // The number of times the animation will repeat. The default is 0, which means the animation\n    // will play only once", "refactored_code": "    private static final long DEFAULT_FRAME_DELAY = 10;\n    private long mStartDelay = 0;\n\n    // The number of milliseconds between animation frames\n    private static long sFrameDelay = DEFAULT_FRAME_DELAY;\n\n    // The number of times the animation will repeat. The default is 0, which means the animation\n    // will play only once"}
{"magic_number_smell": "\n    public MenuItem setIcon(Drawable icon) {\n        mIconDrawable = icon;\n        //UNUSED mIconResId = 0;\n        return this;\n    }\n", "refactored_code": "    //UNUSED private static final int NO_ICON = 0;\n\n    public MenuItem setIcon(Drawable icon) {\n        mIconDrawable = icon;\n        //UNUSED mIconResId = NO_ICON;\n        return this;\n    }\n"}
{"magic_number_smell": "                }\n            }\n            ObjectAnimator anim = ObjectAnimator.ofFloat(this, \"alpha\", 1);\n            anim.setDuration(200);\n            anim.setInterpolator(sAlphaInterpolator);\n            if (mSplitView != null && mMenuView != null) {\n                AnimatorSet set = new AnimatorSet();", "refactored_code": "    private static final int FADE_DURATION = 200;\n                }\n            }\n            ObjectAnimator anim = ObjectAnimator.ofFloat(this, \"alpha\", 1);\n            anim.setDuration(FADE_DURATION);\n            anim.setInterpolator(sAlphaInterpolator);\n            if (mSplitView != null && mMenuView != null) {\n                AnimatorSet set = new AnimatorSet();"}
{"magic_number_smell": "        if (mAnimationMode == ANIMATE_OUT) {\n            killMode();\n        }\n        mAnimationMode = 0;\n    }\n\n    @Override", "refactored_code": "    private static final int ANIMATE_IDLE = 0;\n        if (mAnimationMode == ANIMATE_OUT) {\n            killMode();\n        }\n        mAnimationMode = ANIMATE_IDLE;\n    }\n\n    @Override"}
{"magic_number_smell": "        mProgressBarPadding = a.getDimensionPixelOffset(R.styleable.SherlockActionBar_progressBarPadding, 0);\n        mItemPadding = a.getDimensionPixelOffset(R.styleable.SherlockActionBar_itemPadding, 0);\n\n        setDisplayOptions(a.getInt(R.styleable.SherlockActionBar_displayOptions, 0));\n\n        final int customNavId = a.getResourceId(R.styleable.SherlockActionBar_customNavigationLayout, 0);\n        if (customNavId != 0) {", "refactored_code": "    public static final int DISPLAY_DEFAULT = 0;\n        mProgressBarPadding = a.getDimensionPixelOffset(R.styleable.SherlockActionBar_progressBarPadding, 0);\n        mItemPadding = a.getDimensionPixelOffset(R.styleable.SherlockActionBar_itemPadding, 0);\n\n        setDisplayOptions(a.getInt(R.styleable.SherlockActionBar_displayOptions, DISPLAY_DEFAULT));\n\n        final int customNavId = a.getResourceId(R.styleable.SherlockActionBar_customNavigationLayout, 0);\n        if (customNavId != 0) {"}
{"magic_number_smell": "        super(context, attrs);\n\n        TypedArray a = context.obtainStyledAttributes(attrs, R_styleable_Button);\n        mAllCaps = a.getBoolean(0, true);\n        a.recycle();\n    }\n", "refactored_code": "    private static final int R_styleable_Button_textAllCaps = 0;\n        super(context, attrs);\n\n        TypedArray a = context.obtainStyledAttributes(attrs, R_styleable_Button);\n        mAllCaps = a.getBoolean(R_styleable_Button_textAllCaps, true);\n        a.recycle();\n    }\n"}
{"magic_number_smell": "        super(context, attrs, defStyle);\n\n        TypedArray a = context.obtainStyledAttributes(attrs, R_styleable_TextView, defStyle, 0);\n        mAllCaps = a.getBoolean(0, true);\n        a.recycle();\n    }\n", "refactored_code": "    private static final int R_styleable_TextView_textAllCaps = 0;\n        super(context, attrs, defStyle);\n\n        TypedArray a = context.obtainStyledAttributes(attrs, R_styleable_TextView, defStyle, 0);\n        mAllCaps = a.getBoolean(R_styleable_TextView_textAllCaps, true);\n        a.recycle();\n    }\n"}
{"magic_number_smell": "\n        TypedArray a = context.obtainStyledAttributes(attrs, /*com.android.internal.R.styleable.*/R_styleable_LinearLayout);\n\n        setDividerDrawable(a.getDrawable(/*com.android.internal.R.styleable.*/0));\n        mShowDividers = a.getInt(/*com.android.internal.R.styleable.*/LinearLayout_showDividers, SHOW_DIVIDER_NONE);\n        mDividerPadding = a.getDimensionPixelSize(/*com.android.internal.R.styleable.*/LinearLayout_dividerPadding, 0);\n        mUseLargestChild = a.getBoolean(/*com.android.internal.R.styleable.*/LinearLayout_measureWithLargestChild, false);", "refactored_code": "    private static final int LinearLayout_divider = 0;\n\n        TypedArray a = context.obtainStyledAttributes(attrs, /*com.android.internal.R.styleable.*/R_styleable_LinearLayout);\n\n        setDividerDrawable(a.getDrawable(/*com.android.internal.R.styleable.*/LinearLayout_divider));\n        mShowDividers = a.getInt(/*com.android.internal.R.styleable.*/LinearLayout_showDividers, SHOW_DIVIDER_NONE);\n        mDividerPadding = a.getDimensionPixelSize(/*com.android.internal.R.styleable.*/LinearLayout_dividerPadding, 0);\n        mUseLargestChild = a.getBoolean(/*com.android.internal.R.styleable.*/LinearLayout_measureWithLargestChild, false);"}
{"magic_number_smell": "            if (action == MotionEvent.ACTION_DOWN &&\n                    mPopup != null && mPopup.isShowing() &&\n                    (x >= 0 && x < mPopup.getWidth() && y >= 0 && y < mPopup.getHeight())) {\n                mHandler.postDelayed(mResizePopupRunnable, 250);\n            } else if (action == MotionEvent.ACTION_UP) {\n                mHandler.removeCallbacks(mResizePopupRunnable);\n            }", "refactored_code": "    private static final int EXPAND_LIST_TIMEOUT = 250;\n            if (action == MotionEvent.ACTION_DOWN &&\n                    mPopup != null && mPopup.isShowing() &&\n                    (x >= 0 && x < mPopup.getWidth() && y >= 0 && y < mPopup.getHeight())) {\n                mHandler.postDelayed(mResizePopupRunnable, EXPAND_LIST_TIMEOUT);\n            } else if (action == MotionEvent.ACTION_UP) {\n                mHandler.removeCallbacks(mResizePopupRunnable);\n            }"}
{"magic_number_smell": "        // Make sure the number of items we'll measure is capped. If it's a huge data set\n        // with wildly varying sizes, oh well.\n        int start = Math.max(0, getSelectedItemPosition());\n        final int end = Math.min(adapter.getCount(), start + 15);\n        final int count = end - start;\n        start = Math.max(0, start - (15 - count));\n        for (int i = start; i < end; i++) {", "refactored_code": "    private static final int MAX_ITEMS_MEASURED = 15;\n        // Make sure the number of items we'll measure is capped. If it's a huge data set\n        // with wildly varying sizes, oh well.\n        int start = Math.max(0, getSelectedItemPosition());\n        final int end = Math.min(adapter.getCount(), start + MAX_ITEMS_MEASURED);\n        final int count = end - start;\n        start = Math.max(0, start - (MAX_ITEMS_MEASURED - count));\n        for (int i = start; i < end; i++) {"}
{"magic_number_smell": "                setAlpha(0);\n            }\n            ObjectAnimator anim = ObjectAnimator.ofFloat(this, \"alpha\", 1);\n            anim.setDuration(200);\n            anim.setInterpolator(sAlphaInterpolator);\n\n            anim.addListener(mVisAnimListener.withFinalVisibility(visibility));", "refactored_code": "    private static final int FADE_DURATION = 200;\n                setAlpha(0);\n            }\n            ObjectAnimator anim = ObjectAnimator.ofFloat(this, \"alpha\", 1);\n            anim.setDuration(FADE_DURATION);\n            anim.setInterpolator(sAlphaInterpolator);\n\n            anim.addListener(mVisAnimListener.withFinalVisibility(visibility));"}
{"magic_number_smell": "\n        private ActionProvider itemActionProvider;\n\n        private static final int defaultGroupId = 0;\n        private static final int defaultItemId = 0;\n        private static final int defaultItemCategory = 0;\n        private static final int defaultItemOrder = 0;", "refactored_code": "    private static final int NO_ID = 0;\n\n        private ActionProvider itemActionProvider;\n\n        private static final int defaultGroupId = NO_ID;\n        private static final int defaultItemId = NO_ID;\n        private static final int defaultItemCategory = 0;\n        private static final int defaultItemOrder = 0;"}
{"magic_number_smell": "    /**\n     * Sets how this item should display in the presence of an Action Bar.\n     * The parameter actionEnum is a flag set. One of {@link #SHOW_AS_ACTION_ALWAYS},\n     * {@link #SHOW_AS_ACTION_IF_ROOM}, or {@link #android.view.MenuItem.SHOW_AS_ACTION_NEVER} should\n     * be used, and you may optionally OR the value with {@link #SHOW_AS_ACTION_WITH_TEXT}.\n     * SHOW_AS_ACTION_WITH_TEXT requests that when the item is shown as an action,\n     * it should be shown with a text label.", "refactored_code": "    public static final int SHOW_AS_ACTION_NEVER = android.view.MenuItem.SHOW_AS_ACTION_NEVER;\n    /**\n     * Sets how this item should display in the presence of an Action Bar.\n     * The parameter actionEnum is a flag set. One of {@link #SHOW_AS_ACTION_ALWAYS},\n     * {@link #SHOW_AS_ACTION_IF_ROOM}, or {@link #SHOW_AS_ACTION_NEVER} should\n     * be used, and you may optionally OR the value with {@link #SHOW_AS_ACTION_WITH_TEXT}.\n     * SHOW_AS_ACTION_WITH_TEXT requests that when the item is shown as an action,\n     * it should be shown with a text label."}
{"magic_number_smell": "    /**\n     * The maximal length of the choice history.\n     */\n    private int mHistoryMaxSize = 50;\n\n    /**\n     * Flag whether choice history can be read. In general many clients can", "refactored_code": "    public static final int DEFAULT_HISTORY_MAX_LENGTH = 50;\n    /**\n     * The maximal length of the choice history.\n     */\n    private int mHistoryMaxSize = DEFAULT_HISTORY_MAX_LENGTH;\n\n    /**\n     * Flag whether choice history can be read. In general many clients can"}
{"magic_number_smell": "            // The user may have specified some of the target not to be shown but we\n            // want to measure all of them since after expansion they should fit.\n            final int oldMaxActivityCount = mMaxActivityCount;\n            mMaxActivityCount = Integer.MAX_VALUE;\n\n            int contentWidth = 0;\n            View itemView = null;", "refactored_code": "        public static final int MAX_ACTIVITY_COUNT_UNLIMITED = Integer.MAX_VALUE;\n            // The user may have specified some of the target not to be shown but we\n            // want to measure all of them since after expansion they should fit.\n            final int oldMaxActivityCount = mMaxActivityCount;\n            mMaxActivityCount = MAX_ACTIVITY_COUNT_UNLIMITED;\n\n            int contentWidth = 0;\n            View itemView = null;"}
{"magic_number_smell": "    /**\n     * The the maximum number activities shown in the sub-menu.\n     */\n    private int mMaxShownActivityCount = 4;\n\n    /**\n     * Listener for handling menu item clicks.", "refactored_code": "    private static final int DEFAULT_INITIAL_ACTIVITY_COUNT = 4;\n    /**\n     * The the maximum number activities shown in the sub-menu.\n     */\n    private int mMaxShownActivityCount = DEFAULT_INITIAL_ACTIVITY_COUNT;\n\n    /**\n     * Listener for handling menu item clicks."}
{"magic_number_smell": "        }\n        //mSearchView.getWindow().getDecorView().post(mStartSpinnerRunnable); // TODO:\n        try {\n            cursor = getSuggestions(query, 50);\n            // trigger fill window so the spinner stays up until the results are copied over and\n            // closer to being ready\n            if (cursor != null) {", "refactored_code": "    private static final int QUERY_LIMIT = 50;\n        }\n        //mSearchView.getWindow().getDecorView().post(mStartSpinnerRunnable); // TODO:\n        try {\n            cursor = getSuggestions(query, QUERY_LIMIT);\n            // trigger fill window so the spinner stays up until the results are copied over and\n            // closer to being ready\n            if (cursor != null) {"}
{"magic_number_smell": "        if (fname == null) {\n            fname = a.getString(FragmentTag.Fragment_name);\n        }\n        int id = a.getResourceId(FragmentTag.1, View.NO_ID);\n        String tag = a.getString(FragmentTag.Fragment_tag);\n        a.recycle();\n", "refactored_code": "        public static final int Fragment_id = 1;\n        if (fname == null) {\n            fname = a.getString(FragmentTag.Fragment_name);\n        }\n        int id = a.getResourceId(FragmentTag.Fragment_id, View.NO_ID);\n        String tag = a.getString(FragmentTag.Fragment_tag);\n        a.recycle();\n"}
{"magic_number_smell": "        if (fname == null) {\n            fname = a.getString(FragmentTag.Fragment_name);\n        }\n        int id = a.getResourceId(FragmentTag.1, View.NO_ID);\n        String tag = a.getString(FragmentTag.Fragment_tag);\n        a.recycle();\n", "refactored_code": "        public static final int Fragment_id = 1;\n        if (fname == null) {\n            fname = a.getString(FragmentTag.Fragment_name);\n        }\n        int id = a.getResourceId(FragmentTag.Fragment_id, View.NO_ID);\n        String tag = a.getString(FragmentTag.Fragment_tag);\n        a.recycle();\n"}
{"magic_number_smell": "       DatabaseHelper(Context context) {\n\n           // calls the super constructor, requesting the default cursor factory.\n           super(context, DATABASE_NAME, null, 2);\n       }\n\n       /**", "refactored_code": "       private static final int DATABASE_VERSION = 2;\n       DatabaseHelper(Context context) {\n\n           // calls the super constructor, requesting the default cursor factory.\n           super(context, DATABASE_NAME, null, DATABASE_VERSION);\n       }\n\n       /**"}
{"magic_number_smell": "\n        ActionBar ab = getSupportActionBar();\n        ab.setNavigationMode(NAVIGATION_MODE_TABS);\n        for (int i = 1; i <= 10; i++) {\n            ab.addTab(ab.newTab().setText(\"Tab \" + i).setTabListener(this));\n        }\n    }", "refactored_code": "    private static final int COUNT = 10;\n\n        ActionBar ab = getSupportActionBar();\n        ab.setNavigationMode(NAVIGATION_MODE_TABS);\n        for (int i = 1; i <= COUNT; i++) {\n            ab.addTab(ab.newTab().setText(\"Tab \" + i).setTabListener(this));\n        }\n    }"}
{"magic_number_smell": "\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        menuItemNativeVisible = menu.add(0, 1, 0, TEXT_VISIBLE);\n        menuItemNativeVisible.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);\n\n        menuItemActionVisible = menu.add(0, 0, 0, TEXT_VISIBLE);", "refactored_code": "    public static final int ID_VISIBLE = 1;\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        menuItemNativeVisible = menu.add(0, ID_VISIBLE, 0, TEXT_VISIBLE);\n        menuItemNativeVisible.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);\n\n        menuItemActionVisible = menu.add(0, 0, 0, TEXT_VISIBLE);"}
{"magic_number_smell": "    }\n    \n    private static void addMenuItems(Menu target) { \n        target.add(Menu.CATEGORY_SECONDARY, 1, 0, \"A\");\n        target.add(Menu.NONE              , ITEM_B_ID, 0, \"B\");\n        target.add(Menu.NONE              , ITEM_C_ID, 0, \"C\");\n        target.add(Menu.CATEGORY_SECONDARY, ITEM_D_ID, 1, \"D\");", "refactored_code": "    private static final int ITEM_A_ID = 1;\n    }\n    \n    private static void addMenuItems(Menu target) { \n        target.add(Menu.CATEGORY_SECONDARY, ITEM_A_ID, 0, \"A\");\n        target.add(Menu.NONE              , ITEM_B_ID, 0, \"B\");\n        target.add(Menu.NONE              , ITEM_C_ID, 0, \"C\");\n        target.add(Menu.CATEGORY_SECONDARY, ITEM_D_ID, 1, \"D\");"}
{"magic_number_smell": "\t\n\tprivate static final int 8000 = 8000;\n\tprivate static final int NOTIFICATION_PERIOD = 160;\n\tprivate static final int MIN_BUFFER_SIZE = AudioRecord.getMinBufferSize(8000, \n\t\t\tAudioFormat.CHANNEL_CONFIGURATION_MONO, AudioFormat.ENCODING_PCM_16BIT) * 10;\n\t\n\tpublic interface AACRecorderCallbacks {", "refactored_code": "\tprivate static final int SAMPLE_RATE = 8000;\n\t\n\tprivate static final int SAMPLE_RATE = 8000;\n\tprivate static final int NOTIFICATION_PERIOD = 160;\n\tprivate static final int MIN_BUFFER_SIZE = AudioRecord.getMinBufferSize(SAMPLE_RATE, \n\t\t\tAudioFormat.CHANNEL_CONFIGURATION_MONO, AudioFormat.ENCODING_PCM_16BIT) * 10;\n\t\n\tpublic interface AACRecorderCallbacks {"}
{"magic_number_smell": "    /**\n     * Utility method to get the identifier of the model, if it exists.\n     *\n     * @return {@value #0} if this model was not added to the database\n     */\n    abstract public long getId();\n", "refactored_code": "    public static final long NO_ID = 0;\n    /**\n     * Utility method to get the identifier of the model, if it exists.\n     *\n     * @return {@value #NO_ID} if this model was not added to the database\n     */\n    abstract public long getId();\n"}
{"magic_number_smell": "\n    private String processHttpResponse(HttpResponse response) throws IOException {\n        int statusCode = response.getStatusLine().getStatusCode();\n        if(statusCode >= HTTP_UNAVAILABLE_START && statusCode <= 599) {\n            throw new HttpUnavailableException();\n        }\n", "refactored_code": "    private static final int HTTP_UNAVAILABLE_END = 599;\n\n    private String processHttpResponse(HttpResponse response) throws IOException {\n        int statusCode = response.getStatusLine().getStatusCode();\n        if(statusCode >= HTTP_UNAVAILABLE_START && statusCode <= HTTP_UNAVAILABLE_END) {\n            throw new HttpUnavailableException();\n        }\n"}
{"magic_number_smell": "        Bitmap bitmap = null;\n        int tries = 0;\n        BitmapFactory.Options opts = new BitmapFactory.Options();\n        while((bitmap == null || (bitmap.getWidth() > 1024 || bitmap.getHeight() > 1024)) && tries < SAMPLE_SIZES.length) {\n            opts.inSampleSize = SAMPLE_SIZES[tries];\n            try {\n                bitmap = BitmapFactory.decodeFile(file, opts);", "refactored_code": "    private static final int MAX_DIM = 1024;\n        Bitmap bitmap = null;\n        int tries = 0;\n        BitmapFactory.Options opts = new BitmapFactory.Options();\n        while((bitmap == null || (bitmap.getWidth() > MAX_DIM || bitmap.getHeight() > MAX_DIM)) && tries < SAMPLE_SIZES.length) {\n            opts.inSampleSize = SAMPLE_SIZES[tries];\n            try {\n                bitmap = BitmapFactory.decodeFile(file, opts);"}
{"magic_number_smell": "    public static final long 3600000L = 3600000L;\n\n    /** Represents a single day */\n    public static final long ONE_DAY = 24 * 3600000L;\n\n    /** Represents a single week */\n    public static final long ONE_WEEK = 7 * ONE_DAY;", "refactored_code": "    public static final long ONE_HOUR = 3600000L;\n    public static final long ONE_HOUR = 3600000L;\n\n    /** Represents a single day */\n    public static final long ONE_DAY = 24 * ONE_HOUR;\n\n    /** Represents a single week */\n    public static final long ONE_WEEK = 7 * ONE_DAY;"}
{"magic_number_smell": "    /**\n     * Decoration position\n     */\n    public int position = 0;\n\n    /**\n     * Decorated task background color. 0 is default", "refactored_code": "    public static final int POSITION_LEFT = 0;\n    /**\n     * Decoration position\n     */\n    public int position = POSITION_LEFT;\n\n    /**\n     * Decorated task background color. 0 is default"}
{"magic_number_smell": "        if(!originalSql.toUpperCase().contains(\"ORDER BY\")) {\n            Order order = orderForSortType(sort);\n\n            if((flags & 1 << 0) > 0)\n                order = order.reverse();\n            originalSql += \" ORDER BY \" + order;\n        }", "refactored_code": "    public static final int FLAG_REVERSE_SORT = 1 << 0;\n        if(!originalSql.toUpperCase().contains(\"ORDER BY\")) {\n            Order order = orderForSortType(sort);\n\n            if((flags & FLAG_REVERSE_SORT) > 0)\n                order = order.reverse();\n            originalSql += \" ORDER BY \" + order;\n        }"}
{"magic_number_smell": "        long offset = computeNextSyncOffset(interval);\n\n        // give a little padding\n        offset = Math.max(offset, 5*60*1000L);\n\n        AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n        PendingIntent pendingIntent = PendingIntent.getService(context, getSyncUtilities().getSyncIntervalKey(),", "refactored_code": "\tprivate static final long AUTO_SYNC_MIN_OFFSET = 5*60*1000L;\n        long offset = computeNextSyncOffset(interval);\n\n        // give a little padding\n        offset = Math.max(offset, AUTO_SYNC_MIN_OFFSET);\n\n        AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n        PendingIntent pendingIntent = PendingIntent.getService(context, getSyncUtilities().getSyncIntervalKey(),"}
{"magic_number_smell": "                    return -1;\n                else if(o2Property != 0)\n                    return 1;\n                return -2;\n            }\n            public int compare(TYPE o1, TYPE o2) {\n                int comparison = check(o1, o2, Task.DELETION_DATE);", "refactored_code": "            private static final int SENTINEL = -2;\n                    return -1;\n                else if(o2Property != 0)\n                    return 1;\n                return SENTINEL;\n            }\n            public int compare(TYPE o1, TYPE o2) {\n                int comparison = check(o1, o2, Task.DELETION_DATE);"}
{"magic_number_smell": "    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        if (requestCode == REQUEST_LOGIN && resultCode == RESULT_OK) {\n            setResult(2);\n            finish();\n        } else {\n            super.onActivityResult(requestCode, resultCode, data);", "refactored_code": "    public static final int RESULT_CODE_SYNCHRONIZE = 2;\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        if (requestCode == REQUEST_LOGIN && resultCode == RESULT_OK) {\n            setResult(RESULT_CODE_SYNCHRONIZE);\n            finish();\n        } else {\n            super.onActivityResult(requestCode, resultCode, data);"}
{"magic_number_smell": "        long offset = computeNextSyncOffset(interval);\n\n        // give a little padding\n        offset = Math.max(offset, 5*60*1000L);\n\n        AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n        PendingIntent pendingIntent = PendingIntent.getService(context, getSyncUtilities().getSyncIntervalKey(),", "refactored_code": "\tprivate static final long AUTO_SYNC_MIN_OFFSET = 5*60*1000L;\n        long offset = computeNextSyncOffset(interval);\n\n        // give a little padding\n        offset = Math.max(offset, AUTO_SYNC_MIN_OFFSET);\n\n        AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n        PendingIntent pendingIntent = PendingIntent.getService(context, getSyncUtilities().getSyncIntervalKey(),"}
{"magic_number_smell": "         * multiple keys may have 2 or 3, so the risk of a collision there is also very low.\n         */\n\n        mDb = new DatabaseHelper(context, String.format(DATABASE_FILE, DatapointHelper.getSha256(apiKey)), 2).getWritableDatabase();\n    }\n\n    /**", "refactored_code": "    private static final int DATABASE_VERSION = 2;\n         * multiple keys may have 2 or 3, so the risk of a collision there is also very low.\n         */\n\n        mDb = new DatabaseHelper(context, String.format(DATABASE_FILE, DatapointHelper.getSha256(apiKey)), DATABASE_VERSION).getWritableDatabase();\n    }\n\n    /**"}
{"magic_number_smell": "        {\n            switch (msg.what)\n            {\n                case 0:\n                {\n                    if (Constants.IS_LOGGABLE)\n                    {", "refactored_code": "        public static final int MESSAGE_INIT = 0;\n        {\n            switch (msg.what)\n            {\n                case MESSAGE_INIT:\n                {\n                    if (Constants.IS_LOGGABLE)\n                    {"}
{"magic_number_smell": "\n    // /////////////////////////////////////////////\n\n    private long mMaxDiskUsage = 0;\n\n    private MessageDigest hash;\n", "refactored_code": "    public static final int AUTO_MAX_CACHE_SIZE = 0;\n\n    // /////////////////////////////////////////////\n\n    private long mMaxDiskUsage = AUTO_MAX_CACHE_SIZE;\n\n    private MessageDigest hash;\n"}
{"magic_number_smell": "\n    // this is a custom Executor, as we want to have the tasks loaded in FILO order. FILO works\n    // particularly well when scrolling with a ListView.\n    private final ThreadPoolExecutor mExecutor = new ThreadPoolExecutor(5,\n            MAXIMUM_POOL_SIZE, KEEP_ALIVE_TIME, TimeUnit.SECONDS,\n            new PriorityBlockingQueue<Runnable>());\n", "refactored_code": "    private static final int CORE_POOL_SIZE = 5; // thread\n\n    // this is a custom Executor, as we want to have the tasks loaded in FILO order. FILO works\n    // particularly well when scrolling with a ListView.\n    private final ThreadPoolExecutor mExecutor = new ThreadPoolExecutor(CORE_POOL_SIZE,\n            MAXIMUM_POOL_SIZE, KEEP_ALIVE_TIME, TimeUnit.SECONDS,\n            new PriorityBlockingQueue<Runnable>());\n"}
{"magic_number_smell": "    protected void onMessage(Context context, Intent intent) {\n        if (actFmPreferenceService.isLoggedIn()) {\n            if(intent.hasExtra(\"web_update\"))\n                if (DateUtilities.now() - actFmPreferenceService.getLastSyncDate() > DateUtilities.ONE_HOUR && !actFmPreferenceService.isOngoing())\n                    new ActFmSyncV2Provider().synchronizeActiveTasks(false, refreshOnlyCallback);\n                else\n                    handleWebUpdate(intent);", "refactored_code": "    private static final long MIN_MILLIS_BETWEEN_FULL_SYNCS = DateUtilities.ONE_HOUR;\n    protected void onMessage(Context context, Intent intent) {\n        if (actFmPreferenceService.isLoggedIn()) {\n            if(intent.hasExtra(\"web_update\"))\n                if (DateUtilities.now() - actFmPreferenceService.getLastSyncDate() > MIN_MILLIS_BETWEEN_FULL_SYNCS && !actFmPreferenceService.isOngoing())\n                    new ActFmSyncV2Provider().synchronizeActiveTasks(false, refreshOnlyCallback);\n                else\n                    handleWebUpdate(intent);"}
{"magic_number_smell": "                    if (lastTempFile != null) {\n                        intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(lastTempFile));\n                    }\n                    activity.startActivityForResult(intent, 1);\n                } else if ((which == 1 && cameraAvailable) || (which == 0 && !cameraAvailable)) {\n                    Intent intent = new Intent(Intent.ACTION_GET_CONTENT);\n                    intent.setType(\"image/*\");", "refactored_code": "    protected static final int REQUEST_CODE_CAMERA = 1;\n                    if (lastTempFile != null) {\n                        intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(lastTempFile));\n                    }\n                    activity.startActivityForResult(intent, REQUEST_CODE_CAMERA);\n                } else if ((which == 1 && cameraAvailable) || (which == 0 && !cameraAvailable)) {\n                    Intent intent = new Intent(Intent.ACTION_GET_CONTENT);\n                    intent.setType(\"image/*\");"}
{"magic_number_smell": "    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n        if(requestCode == 0 && resultCode == RESULT_OK){\n            final ProgressDialog pd = DialogUtilities.progressDialog(this, this.getString(R.string.gtasks_GLA_authenticating));\n            pd.show();\n            final Account a = accountManager.getAccountByName(accountName);", "refactored_code": "    private static final int REQUEST_AUTHENTICATE = 0;\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n        if(requestCode == REQUEST_AUTHENTICATE && resultCode == RESULT_OK){\n            final ProgressDialog pd = DialogUtilities.progressDialog(this, this.getString(R.string.gtasks_GLA_authenticating));\n            pd.show();\n            final Account a = accountManager.getAccountByName(accountName);"}
{"magic_number_smell": "        if (resultCode == RESULT_CANCELED)\n            return;\n\n        if (requestCode == 1 && data != null && credentialsListener != null) {\n            String accounts[] = data.getStringArrayExtra(\n                    GoogleLoginServiceConstants.ACCOUNTS_KEY);\n            credentialsListener.getCredentials(accounts);", "refactored_code": "    private static final int REQUEST_CODE_GOOGLE_ACCOUNTS = 1;\n        if (resultCode == RESULT_CANCELED)\n            return;\n\n        if (requestCode == REQUEST_CODE_GOOGLE_ACCOUNTS && data != null && credentialsListener != null) {\n            String accounts[] = data.getStringArrayExtra(\n                    GoogleLoginServiceConstants.ACCOUNTS_KEY);\n            credentialsListener.getCredentials(accounts);"}
{"magic_number_smell": "            }\n        }\n        if(showCommentsRefresh) {\n            item = menu.add(Menu.NONE, Menu.FIRST, Menu.NONE,\n                    R.string.ENA_refresh_comments);\n            item.setIcon(R.drawable.icn_menu_refresh_dark);\n        }", "refactored_code": "    protected static final int MENU_REFRESH_ID = Menu.FIRST;\n            }\n        }\n        if(showCommentsRefresh) {\n            item = menu.add(Menu.NONE, MENU_REFRESH_ID, Menu.NONE,\n                    R.string.ENA_refresh_comments);\n            item.setIcon(R.drawable.icn_menu_refresh_dark);\n        }"}
{"magic_number_smell": "        }\n\n        if (isDialog) {\n            item = menu.add(Menu.NONE, R.string.TEA_menu_save, 0, R.string.TEA_menu_save);\n            item.setIcon(ThemeService.getDrawable(R.drawable.ic_menu_save));\n            item.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);\n        }", "refactored_code": "    private static final int MENU_SAVE_ID = R.string.TEA_menu_save;\n        }\n\n        if (isDialog) {\n            item = menu.add(Menu.NONE, MENU_SAVE_ID, 0, R.string.TEA_menu_save);\n            item.setIcon(ThemeService.getDrawable(R.drawable.ic_menu_save));\n            item.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);\n        }"}
{"magic_number_smell": "    protected void addSyncRefreshMenuItem(Menu menu, int themeFlags) {\n        if(actFmPreferenceService.isLoggedIn()) {\n            addMenuItem(menu, R.string.actfm_TVA_menu_refresh,\n                    ThemeService.getDrawable(R.drawable.icn_menu_refresh, themeFlags), MENU_SUPPORT_ID + 1, true);\n        } else {\n            super.addSyncRefreshMenuItem(menu, themeFlags);\n        }", "refactored_code": "    protected static final int MENU_REFRESH_ID = MENU_SUPPORT_ID + 1;\n    protected void addSyncRefreshMenuItem(Menu menu, int themeFlags) {\n        if(actFmPreferenceService.isLoggedIn()) {\n            addMenuItem(menu, R.string.actfm_TVA_menu_refresh,\n                    ThemeService.getDrawable(R.drawable.icn_menu_refresh, themeFlags), MENU_REFRESH_ID, true);\n        } else {\n            super.addSyncRefreshMenuItem(menu, themeFlags);\n        }"}
{"magic_number_smell": "                }\n            }\n\n            String request = createFetchUrl(\"api/\" + 7, \"synchronize\", params);\n            if (SYNC_DEBUG)\n                Log.e(\"act-fm-post\", request);\n            Charset chars;", "refactored_code": "    private static final int API_VERSION = 7;\n                }\n            }\n\n            String request = createFetchUrl(\"api/\" + API_VERSION, \"synchronize\", params);\n            if (SYNC_DEBUG)\n                Log.e(\"act-fm-post\", request);\n            Charset chars;"}
{"magic_number_smell": "        public void run() {\n            if (pendingMessages.isEmpty())\n                return;\n            AndroidUtilities.sleepDeep(15 * 1000L);\n            while (!pendingMessages.isEmpty()) {\n                ActFmSyncThread.getInstance().enqueueMessage(pendingMessages.remove(0), ActFmSyncThread.DEFAULT_REFRESH_RUNNABLE);\n            }", "refactored_code": "    private static final long WAIT_TIME = 15 * 1000L;\n        public void run() {\n            if (pendingMessages.isEmpty())\n                return;\n            AndroidUtilities.sleepDeep(WAIT_TIME);\n            while (!pendingMessages.isEmpty()) {\n                ActFmSyncThread.getInstance().enqueueMessage(pendingMessages.remove(0), ActFmSyncThread.DEFAULT_REFRESH_RUNNABLE);\n            }"}
{"magic_number_smell": "\n                @Override\n                public boolean shouldCreateOutstandingEntries(TagData instance) {\n                    boolean result = Preferences.getInt(LAST_TAG_FETCH_TIME, 0) * 1000L == 0 || (instance.containsNonNullValue(TagData.MODIFICATION_DATE) && instance.getValue(TagData.MODIFICATION_DATE) > Preferences.getInt(LAST_TAG_FETCH_TIME, 0) * 1000L);\n                    return result && RemoteModelDao.getOutstandingEntryFlag(RemoteModelDao.OUTSTANDING_ENTRY_FLAG_RECORD_OUTSTANDING);\n                }\n", "refactored_code": "                private final long lastFetchTime = Preferences.getInt(LAST_TAG_FETCH_TIME, 0) * 1000L;\n\n                @Override\n                public boolean shouldCreateOutstandingEntries(TagData instance) {\n                    boolean result = lastFetchTime == 0 || (instance.containsNonNullValue(TagData.MODIFICATION_DATE) && instance.getValue(TagData.MODIFICATION_DATE) > lastFetchTime);\n                    return result && RemoteModelDao.getOutstandingEntryFlag(RemoteModelDao.OUTSTANDING_ENTRY_FLAG_RECORD_OUTSTANDING);\n                }\n"}
{"magic_number_smell": "        PendingIntent pendingIntent = pendingIntentForAlarm(alarm, taskId);\n\n        long time = alarm.getValue(AlarmFields.TIME);\n        if(time == 0 || time == Long.MAX_VALUE)\n            am.cancel(pendingIntent);\n        else if(time > DateUtilities.now()) {\n            if(Constants.DEBUG)", "refactored_code": "    private static final long NO_ALARM = Long.MAX_VALUE;\n        PendingIntent pendingIntent = pendingIntentForAlarm(alarm, taskId);\n\n        long time = alarm.getValue(AlarmFields.TIME);\n        if(time == 0 || time == NO_ALARM)\n            am.cancel(pendingIntent);\n        else if(time > DateUtilities.now()) {\n            if(Constants.DEBUG)"}
{"magic_number_smell": "        if (!Preferences.getBoolean(R.string.backup_BPr_auto_key, true)) {\n            return;\n        }\n        am.setInexactRepeating(AlarmManager.RTC, DateUtilities.now() + 5 * 60 * 1000L,\n                BACKUP_INTERVAL, pendingIntent);\n    }\n", "refactored_code": "    private static final long BACKUP_OFFSET = 5 * 60 * 1000L;\n        if (!Preferences.getBoolean(R.string.backup_BPr_auto_key, true)) {\n            return;\n        }\n        am.setInexactRepeating(AlarmManager.RTC, DateUtilities.now() + BACKUP_OFFSET,\n                BACKUP_INTERVAL, pendingIntent);\n    }\n"}
{"magic_number_smell": "        xml.attribute(null, BackupConstants.ASTRID_ATTR_VERSION,\n                Integer.toString(AstridPreferences.getCurrentVersion()));\n        xml.attribute(null, BackupConstants.ASTRID_ATTR_FORMAT,\n                Integer.toString(2));\n\n        serializeTasks();\n", "refactored_code": "    private static final int FORMAT = 2;\n        xml.attribute(null, BackupConstants.ASTRID_ATTR_VERSION,\n                Integer.toString(AstridPreferences.getCurrentVersion()));\n        xml.attribute(null, BackupConstants.ASTRID_ATTR_FORMAT,\n                Integer.toString(FORMAT));\n\n        serializeTasks();\n"}
{"magic_number_smell": "            // Check for number of ignore presses\n            int ignorePresses = Preferences.getInt(PREF_IGNORE_PRESSES, 0);\n            ignorePresses++;\n            if (ignorePresses == 3) {\n                DialogUtilities.okCancelCustomDialog(MissedCallActivity.this,\n                        getString(R.string.MCA_ignore_title),\n                        getString(R.string.MCA_ignore_body),", "refactored_code": "    private static final int IGNORE_PROMPT_COUNT = 3;\n            // Check for number of ignore presses\n            int ignorePresses = Preferences.getInt(PREF_IGNORE_PRESSES, 0);\n            ignorePresses++;\n            if (ignorePresses == IGNORE_PROMPT_COUNT) {\n                DialogUtilities.okCancelCustomDialog(MissedCallActivity.this,\n                        getString(R.string.MCA_ignore_title),\n                        getString(R.string.MCA_ignore_body),"}
{"magic_number_smell": "            new Thread() {\n                @Override\n                public void run() {\n                    AndroidUtilities.sleepDeep(3000L);\n                    Cursor calls;\n                    try {\n                        calls = context.getContentResolver().query(", "refactored_code": "    private static final long WAIT_BEFORE_READ_LOG = 3000L;\n            new Thread() {\n                @Override\n                public void run() {\n                    AndroidUtilities.sleepDeep(WAIT_BEFORE_READ_LOG);\n                    Cursor calls;\n                    try {\n                        calls = context.getContentResolver().query("}
{"magic_number_smell": "            String title = instance.getTitleFromCriterion();\n\n            switch(instance.type) {\n            case CriterionInstance.0:\n                sql.append(\"OR \");\n                suggestedTitle.append(getString(R.string.CFA_type_add)).append(' ').\n                    append(title).append(' ');", "refactored_code": "        public static final int TYPE_ADD = 0;\n            String title = instance.getTitleFromCriterion();\n\n            switch(instance.type) {\n            case CriterionInstance.TYPE_ADD:\n                sql.append(\"OR \");\n                suggestedTitle.append(getString(R.string.CFA_type_add)).append(' ').\n                    append(title).append(' ');"}
{"magic_number_smell": "        paint.setStyle(Paint.Style.FILL);\n        canvas.drawRect(0, 0, getWidth(), getHeight(), paint);\n\n        paint.setColor(Color.rgb(0x1f, 0x78, 0xb4));\n        Path path = new Path();\n        path.moveTo(getWidth() * (0.5f - 0.5f * start / max), 0);\n        path.lineTo(getWidth() * (0.5f + 0.5f * start / max), 0);", "refactored_code": "    private static final int FILTER_COLOR = Color.rgb(0x1f, 0x78, 0xb4);\n        paint.setStyle(Paint.Style.FILL);\n        canvas.drawRect(0, 0, getWidth(), getHeight(), paint);\n\n        paint.setColor(FILTER_COLOR);\n        Path path = new Path();\n        path.moveTo(getWidth() * (0.5f - 0.5f * start / max), 0);\n        path.lineTo(getWidth() * (0.5f + 0.5f * start / max), 0);"}
{"magic_number_smell": "\n\t\tdirectoryMode = getIntent().getBooleanExtra(EXTRA_DIRECTORIES_SELECTABLE, false);\n\n\t\tshowDialog(1000);\n\t\tupString = getString(R.string.file_browser_up);\n\t\tLog.d(TAG, path.getAbsolutePath());\n", "refactored_code": "\tprivate static final int DIALOG_LOAD_FILE = 1000;\n\n\t\tdirectoryMode = getIntent().getBooleanExtra(EXTRA_DIRECTORIES_SELECTABLE, false);\n\n\t\tshowDialog(DIALOG_LOAD_FILE);\n\t\tupString = getString(R.string.file_browser_up);\n\t\tLog.d(TAG, path.getAbsolutePath());\n"}
{"magic_number_smell": "            // Check for number of ignore presses\n            int ignorePresses = Preferences.getInt(PREF_IGNORE_PRESSES, 0);\n            ignorePresses++;\n            if (ignorePresses == 3) {\n                DialogUtilities.okCancelCustomDialog(CalendarReminderActivity.this,\n                        getString(R.string.CRA_ignore_title),\n                        getString(R.string.CRA_ignore_body),", "refactored_code": "    private static final int IGNORE_PROMPT_COUNT = 3;\n            // Check for number of ignore presses\n            int ignorePresses = Preferences.getInt(PREF_IGNORE_PRESSES, 0);\n            ignorePresses++;\n            if (ignorePresses == IGNORE_PROMPT_COUNT) {\n                DialogUtilities.okCancelCustomDialog(CalendarReminderActivity.this,\n                        getString(R.string.CRA_ignore_title),\n                        getString(R.string.CRA_ignore_body),"}
{"magic_number_smell": "            if(task.hasDueTime()) {\n                long estimatedTime = task.getValue(Task.ESTIMATED_SECONDS)  * 1000;\n                if(estimatedTime <= 0)\n                    estimatedTime = DateUtilities.ONE_HOUR;\n                if (Preferences.getBoolean(R.string.p_end_at_deadline, true)) {\n                    values.put(\"dtstart\", dueDate);\n                    values.put(\"dtend\", dueDate + estimatedTime);", "refactored_code": "    private static final long DEFAULT_CAL_TIME = DateUtilities.ONE_HOUR;\n            if(task.hasDueTime()) {\n                long estimatedTime = task.getValue(Task.ESTIMATED_SECONDS)  * 1000;\n                if(estimatedTime <= 0)\n                    estimatedTime = DEFAULT_CAL_TIME;\n                if (Preferences.getBoolean(R.string.p_end_at_deadline, true)) {\n                    values.put(\"dtstart\", dueDate);\n                    values.put(\"dtend\", dueDate + estimatedTime);"}
{"magic_number_smell": "    @Override\n    protected void addMenuItems(Menu menu, Activity activity) {\n        super.addMenuItems(menu, activity);\n        addMenuItem(menu, R.string.gtasks_GTA_clear_completed, android.R.drawable.ic_input_delete, MENU_ADDON_INTENT_ID + 1, false);\n    }\n\n    @Override", "refactored_code": "    protected static final int MENU_CLEAR_COMPLETED_ID = MENU_ADDON_INTENT_ID + 1;\n    @Override\n    protected void addMenuItems(Menu menu, Activity activity) {\n        super.addMenuItems(menu, activity);\n        addMenuItem(menu, R.string.gtasks_GTA_clear_completed, android.R.drawable.ic_input_delete, MENU_CLEAR_COMPLETED_ID, false);\n    }\n\n    @Override"}
{"magic_number_smell": "    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n        if(requestCode == 0 && resultCode == RESULT_OK){\n            final ProgressDialog pd = DialogUtilities.progressDialog(this, this.getString(R.string.gtasks_GLA_authenticating));\n            pd.show();\n            final Account a = accountManager.getAccountByName(accountName);", "refactored_code": "    private static final int REQUEST_AUTHENTICATE = 0;\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n        if(requestCode == REQUEST_AUTHENTICATE && resultCode == RESULT_OK){\n            final ProgressDialog pd = DialogUtilities.progressDialog(this, this.getString(R.string.gtasks_GLA_authenticating));\n            pd.show();\n            final Account a = accountManager.getAccountByName(accountName);"}
{"magic_number_smell": "            throw new GoogleTasksException(c.getString(R.string.gtasks_error_accountNotFound, accountName), \"account-not-found\");\n        }\n\n        for (int i = 0; i < 4; i++) {\n            accountManager.invalidateAuthToken(token);\n\n            // try with notify-auth-failure = false", "refactored_code": "    private static final int REVALIDATION_TRIES = 4;\n            throw new GoogleTasksException(c.getString(R.string.gtasks_error_accountNotFound, accountName), \"account-not-found\");\n        }\n\n        for (int i = 0; i < REVALIDATION_TRIES; i++) {\n            accountManager.invalidateAuthToken(token);\n\n            // try with notify-auth-failure = false"}
{"magic_number_smell": "            if (result.containsKey(AccountManager.KEY_INTENT)) {\n              Intent intent = (Intent) result.get(AccountManager.KEY_INTENT);\n              clearNewTaskFlag(intent);\n              activity.startActivityForResult(intent, 1);\n              return;\n            }\n", "refactored_code": "  protected static final int GET_LOGIN_REQUEST = 1;\n            if (result.containsKey(AccountManager.KEY_INTENT)) {\n              Intent intent = (Intent) result.get(AccountManager.KEY_INTENT);\n              clearNewTaskFlag(intent);\n              activity.startActivityForResult(intent, GET_LOGIN_REQUEST);\n              return;\n            }\n"}
{"magic_number_smell": "\n        String notes = task.getValue(Task.NOTES);\n        if(!TextUtils.isEmpty(notes)) {\n            if(notes.length() > 200) {\n                int lastSpace = notes.lastIndexOf(' ', 200);\n                notes = notes.substring(0, Math.max(lastSpace, 200 - 20)) + \"...\";\n            }", "refactored_code": "    private static final int NOTE_MAX = 200;\n\n        String notes = task.getValue(Task.NOTES);\n        if(!TextUtils.isEmpty(notes)) {\n            if(notes.length() > NOTE_MAX) {\n                int lastSpace = notes.lastIndexOf(' ', NOTE_MAX);\n                notes = notes.substring(0, Math.max(lastSpace, NOTE_MAX - 20)) + \"...\";\n            }"}
{"magic_number_smell": "\n    /**\n     * Gets default creator from setting\n     * @return -1 if should not sync, otherwise remote id\n     */\n    public long getDefaultCreator() {\n        long defaultCreatorId = -1 ;", "refactored_code": "    public static final long CREATOR_NO_SYNC = -1;\n\n    /**\n     * Gets default creator from setting\n     * @return CREATOR_NO_SYNC if should not sync, otherwise remote id\n     */\n    public long getDefaultCreator() {\n        long defaultCreatorId = CREATOR_NO_SYNC ;"}
{"magic_number_smell": "    protected void addSyncRefreshMenuItem(Menu menu, int themeFlags) {\n        if(actFmPreferenceService.isLoggedIn()) {\n            addMenuItem(menu, R.string.actfm_TVA_menu_refresh,\n                    ThemeService.getDrawable(R.drawable.icn_menu_refresh, themeFlags), MENU_SUPPORT_ID + 1, true);\n        } else {\n            super.addSyncRefreshMenuItem(menu, themeFlags);\n        }", "refactored_code": "    protected static final int MENU_REFRESH_ID = MENU_SUPPORT_ID + 1;\n    protected void addSyncRefreshMenuItem(Menu menu, int themeFlags) {\n        if(actFmPreferenceService.isLoggedIn()) {\n            addMenuItem(menu, R.string.actfm_TVA_menu_refresh,\n                    ThemeService.getDrawable(R.drawable.icn_menu_refresh, themeFlags), MENU_REFRESH_ID, true);\n        } else {\n            super.addSyncRefreshMenuItem(menu, themeFlags);\n        }"}
{"magic_number_smell": "        int icon;\n        switch(Preferences.getIntegerFromString(R.string.p_rmd_icon,\n                ICON_SET_ASTRID)) {\n        case 0:\n            icon = R.drawable.notif_pink_alarm;\n            break;\n        case ICON_SET_BORING:", "refactored_code": "    public static final int ICON_SET_PINK = 0;\n        int icon;\n        switch(Preferences.getIntegerFromString(R.string.p_rmd_icon,\n                ICON_SET_ASTRID)) {\n        case ICON_SET_PINK:\n            icon = R.drawable.notif_pink_alarm;\n            break;\n        case ICON_SET_BORING:"}
{"magic_number_smell": "        Intent notifIntent = new Intent(context, TaskListActivity.class);\n\n        QueryTemplate template = new QueryTemplate().where(TaskCriteria.activeVisibleMine());\n        String sql = SortHelper.adjustQueryForFlagsAndSort(template.toString(), 0, SortHelper.SORT_AUTO) + \" LIMIT \" + 3; //$NON-NLS-1$\n\n        boolean hasTasks = false;\n        TodorooCursor<Task> tasks = taskService.query(Query.select(Task.ID).where(TaskCriteria.activeVisibleMine()).limit(3));", "refactored_code": "    private static final int TASK_LIMIT = 3;\n        Intent notifIntent = new Intent(context, TaskListActivity.class);\n\n        QueryTemplate template = new QueryTemplate().where(TaskCriteria.activeVisibleMine());\n        String sql = SortHelper.adjustQueryForFlagsAndSort(template.toString(), 0, SortHelper.SORT_AUTO) + \" LIMIT \" + TASK_LIMIT; //$NON-NLS-1$\n\n        boolean hasTasks = false;\n        TodorooCursor<Task> tasks = taskService.query(Query.select(Task.ID).where(TaskCriteria.activeVisibleMine()).limit(TASK_LIMIT));"}
{"magic_number_smell": "    public static void scheduleReengagementAlarm(Context context) {\n        AlarmManager am = (AlarmManager)context.getSystemService(Context.ALARM_SERVICE);\n        Intent intent = new Intent(BROADCAST_SHOW_REENGAGEMENT);\n        PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 10, intent, 0);\n        am.cancel(pendingIntent);\n\n        long time = getNextReminderTime();", "refactored_code": "    private static final int REQUEST_CODE = 10;\n    public static void scheduleReengagementAlarm(Context context) {\n        AlarmManager am = (AlarmManager)context.getSystemService(Context.ALARM_SERVICE);\n        Intent intent = new Intent(BROADCAST_SHOW_REENGAGEMENT);\n        PendingIntent pendingIntent = PendingIntent.getBroadcast(context, REQUEST_CODE, intent, 0);\n        am.cancel(pendingIntent);\n\n        long time = getNextReminderTime();"}
{"magic_number_smell": "        List<String> names = new ArrayList<String>();\n        AtomicBoolean isSharedTask = new AtomicBoolean(false);\n\n        if (pictureUrls.size() < 4) {\n            addTagFaces(task.getId(), pictureUrls, names, isSharedTask);\n        }\n", "refactored_code": "    private static final int MAX_FACES = 4;\n        List<String> names = new ArrayList<String>();\n        AtomicBoolean isSharedTask = new AtomicBoolean(false);\n\n        if (pictureUrls.size() < MAX_FACES) {\n            addTagFaces(task.getId(), pictureUrls, names, isSharedTask);\n        }\n"}
{"magic_number_smell": "    public void clearAllAlarms(Task task) {\n        scheduler.createAlarm(task, NO_ALARM, TYPE_SNOOZE);\n        scheduler.createAlarm(task, NO_ALARM, TYPE_RANDOM);\n        scheduler.createAlarm(task, NO_ALARM, 0);\n        scheduler.createAlarm(task, NO_ALARM, TYPE_OVERDUE);\n    }\n", "refactored_code": "    public static final int TYPE_DUE = 0;\n    public void clearAllAlarms(Task task) {\n        scheduler.createAlarm(task, NO_ALARM, TYPE_SNOOZE);\n        scheduler.createAlarm(task, NO_ALARM, TYPE_RANDOM);\n        scheduler.createAlarm(task, NO_ALARM, TYPE_DUE);\n        scheduler.createAlarm(task, NO_ALARM, TYPE_OVERDUE);\n    }\n"}
{"magic_number_smell": "                repeatValue = rrule.getInterval();\n                switch(rrule.getFreq()) {\n                case DAILY:\n                    intervalValue = 0;\n                    break;\n                case WEEKLY: {\n                    intervalValue = INTERVAL_WEEKS;", "refactored_code": "    public static final int INTERVAL_DAYS = 0;\n                repeatValue = rrule.getInterval();\n                switch(rrule.getFreq()) {\n                case DAILY:\n                    intervalValue = INTERVAL_DAYS;\n                    break;\n                case WEEKLY: {\n                    intervalValue = INTERVAL_WEEKS;"}
{"magic_number_smell": "    @Override\n    protected void addMenuItems(Menu menu, Activity activity) {\n        super.addMenuItems(menu, activity);\n        MenuItem item = menu.add(Menu.NONE, R.string.actfm_feat_list_clone, 0, R.string.actfm_feat_list_clone);\n        item.setIcon(R.drawable.ic_menu_list_copy);\n        item.setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS);\n    }", "refactored_code": "    private static final int MENU_CLONE_LIST = R.string.actfm_feat_list_clone;\n    @Override\n    protected void addMenuItems(Menu menu, Activity activity) {\n        super.addMenuItems(menu, activity);\n        MenuItem item = menu.add(Menu.NONE, MENU_CLONE_LIST, 0, R.string.actfm_feat_list_clone);\n        item.setIcon(R.drawable.ic_menu_list_copy);\n        item.setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS);\n    }"}
{"magic_number_smell": "\n        long elapsed = task.getValue(Task.ELAPSED_SECONDS) * 1000L;\n        if(task.getValue(Task.TIMER_START) != 0) {\n            decoration.color = Color.argb(200, 220, 50, 0);\n            elapsed += DateUtilities.now() - task.getValue(Task.TIMER_START);\n            decoration.decoration.setChronometer(R.id.timer, SystemClock.elapsedRealtime() -\n                    elapsed, null, true);", "refactored_code": "    private static final int TIMING_BG_COLOR = Color.argb(200, 220, 50, 0);\n\n        long elapsed = task.getValue(Task.ELAPSED_SECONDS) * 1000L;\n        if(task.getValue(Task.TIMER_START) != 0) {\n            decoration.color = TIMING_BG_COLOR;\n            elapsed += DateUtilities.now() - task.getValue(Task.TIMER_START);\n            decoration.decoration.setChronometer(R.id.timer, SystemClock.elapsedRealtime() -\n                    elapsed, null, true);"}
{"magic_number_smell": "\n    public static final int RESULT_RESTART_ACTIVITY = 50;\n\n    protected int fragmentLayout = 0;\n\n    private final RepeatConfirmationReceiver repeatConfirmationReceiver = new RepeatConfirmationReceiver();\n", "refactored_code": "    public static final int LAYOUT_SINGLE = 0;\n\n    public static final int RESULT_RESTART_ACTIVITY = 50;\n\n    protected int fragmentLayout = LAYOUT_SINGLE;\n\n    private final RepeatConfirmationReceiver repeatConfirmationReceiver = new RepeatConfirmationReceiver();\n"}
{"magic_number_smell": "\n        disablePremiumPrefs();\n\n        PreferenceScreen appearance = (PreferenceScreen) screen.getPreference(4);\n        if (!AndroidUtilities.isTabletSized(this)) {\n            appearance.removePreference(screen.findPreference(getString(R.string.p_force_phone_layout)));\n        } else {", "refactored_code": "    private static final int APPEARANCE_PREFERENCE = 4;\n\n        disablePremiumPrefs();\n\n        PreferenceScreen appearance = (PreferenceScreen) screen.getPreference(APPEARANCE_PREFERENCE);\n        if (!AndroidUtilities.isTabletSized(this)) {\n            appearance.removePreference(screen.findPreference(getString(R.string.p_force_phone_layout)));\n        } else {"}
{"magic_number_smell": "\n        if(item instanceof Filter) {\n            Filter filter = (Filter) item;\n            menuItem = menu.add(0, R.string.FLA_context_shortcut, 0, R.string.FLA_context_shortcut);\n            menuItem.setIntent(ShortcutActivity.createIntent(filter));\n        }\n", "refactored_code": "    private static final int CONTEXT_MENU_SHORTCUT = R.string.FLA_context_shortcut;\n\n        if(item instanceof Filter) {\n            Filter filter = (Filter) item;\n            menuItem = menu.add(0, CONTEXT_MENU_SHORTCUT, 0, R.string.FLA_context_shortcut);\n            menuItem.setIntent(ShortcutActivity.createIntent(filter));\n        }\n"}
{"magic_number_smell": "        peopleControlSet = new EditPeopleControlSet(getActivity(), this,\n                R.layout.control_set_assigned,\n                R.layout.control_set_default_display,\n                R.string.actfm_EPA_assign_label_long, 0);\n        controls.add(peopleControlSet);\n        controlSetMap.put(getString(R.string.TEA_ctrl_who_pref),\n                peopleControlSet);", "refactored_code": "    public static final int REQUEST_LOG_IN = 0;\n        peopleControlSet = new EditPeopleControlSet(getActivity(), this,\n                R.layout.control_set_assigned,\n                R.layout.control_set_default_display,\n                R.string.actfm_EPA_assign_label_long, REQUEST_LOG_IN);\n        controls.add(peopleControlSet);\n        controlSetMap.put(getString(R.string.TEA_ctrl_who_pref),\n                peopleControlSet);"}
{"magic_number_smell": "\n    public TaskEditViewPager(Context context, int tabStyleMask) {\n        ArrayList<String> titleList = new ArrayList<String>();\n        if ((tabStyleMask & 1 << 0) > 0)\n            titleList.add(context.getString(R.string.TEA_tab_activity));\n        if ((tabStyleMask & TAB_SHOW_MORE) > 0)\n            titleList.add(context.getString(R.string.TEA_tab_more));", "refactored_code": "    public static final int TAB_SHOW_ACTIVITY = 1 << 0;\n\n    public TaskEditViewPager(Context context, int tabStyleMask) {\n        ArrayList<String> titleList = new ArrayList<String>();\n        if ((tabStyleMask & TAB_SHOW_ACTIVITY) > 0)\n            titleList.add(context.getString(R.string.TEA_tab_activity));\n        if ((tabStyleMask & TAB_SHOW_MORE) > 0)\n            titleList.add(context.getString(R.string.TEA_tab_more));"}
{"magic_number_smell": "    protected void initializeFragments(ActionBar actionBar) {\n        View filterFragment = findViewById(R.id.filterlist_fragment_container);\n        View editFragment = findViewById(R.id.taskedit_fragment_container);\n        filterMode = getIntent().getIntExtra(FILTER_MODE, 0);\n        updateFilterModeSpec(filterMode);\n\n        if (filterFragment != null) {", "refactored_code": "    public static final int FILTER_MODE_NORMAL = 0;\n    protected void initializeFragments(ActionBar actionBar) {\n        View filterFragment = findViewById(R.id.filterlist_fragment_container);\n        View editFragment = findViewById(R.id.taskedit_fragment_container);\n        filterMode = getIntent().getIntExtra(FILTER_MODE, FILTER_MODE_NORMAL);\n        updateFilterModeSpec(filterMode);\n\n        if (filterFragment != null) {"}
{"magic_number_smell": "\n    private void showFeedbackPrompt() {\n        if (!(this instanceof TagViewFragment) &&\n                (DateUtilities.now() - Preferences.getLong(PREF_LAST_FEEDBACK_TIME, 0)) > DateUtilities.ONE_WEEK * 12 &&\n                taskService.getUserActivationStatus()) {\n            final LinearLayout root = (LinearLayout) getView().findViewById(R.id.taskListParent);\n            if (root.findViewById(R.id.feedback_banner) == null) {", "refactored_code": "    private static final long FEEDBACK_TIME_INTERVAL = DateUtilities.ONE_WEEK * 12;\n\n    private void showFeedbackPrompt() {\n        if (!(this instanceof TagViewFragment) &&\n                (DateUtilities.now() - Preferences.getLong(PREF_LAST_FEEDBACK_TIME, 0)) > FEEDBACK_TIME_INTERVAL &&\n                taskService.getUserActivationStatus()) {\n            final LinearLayout root = (LinearLayout) getView().findViewById(R.id.taskListParent);\n            if (root.findViewById(R.id.feedback_banner) == null) {"}
{"magic_number_smell": "        TodorooCursor<UserActivity> cursor = (TodorooCursor<UserActivity>)c;\n        ModelHolder mh = ((ModelHolder) view.getTag());\n\n        String type = cursor.getString(USER_ACTIVITY_PROPERTIES.length - 1);\n\n        UserActivity update = mh.activity;\n        update.clear();", "refactored_code": "    public static final int TYPE_PROPERTY_INDEX = USER_ACTIVITY_PROPERTIES.length - 1;\n        TodorooCursor<UserActivity> cursor = (TodorooCursor<UserActivity>)c;\n        ModelHolder mh = ((ModelHolder) view.getTag());\n\n        String type = cursor.getString(TYPE_PROPERTY_INDEX);\n\n        UserActivity update = mh.activity;\n        update.clear();"}
{"magic_number_smell": "    @Override\n    protected Dialog onCreateDialog(int id) {\n        switch (id) {\n        case 1:\n            return createDialog(R.string.cannot_connect_title,\n                    R.string.cannot_connect_message);\n        case DIALOG_BILLING_NOT_SUPPORTED_ID:", "refactored_code": "    private static final int DIALOG_CANNOT_CONNECT_ID = 1;\n    @Override\n    protected Dialog onCreateDialog(int id) {\n        switch (id) {\n        case DIALOG_CANNOT_CONNECT_ID:\n            return createDialog(R.string.cannot_connect_title,\n                    R.string.cannot_connect_message);\n        case DIALOG_BILLING_NOT_SUPPORTED_ID:"}
{"magic_number_smell": "\n    @Override\n    protected int getVersion() {\n        return 35;\n    }\n\n    @Override", "refactored_code": "    public static final int VERSION = 35;\n\n    @Override\n    protected int getVersion() {\n        return VERSION;\n    }\n\n    @Override"}
{"magic_number_smell": "        long uuid = 0;\n        do {\n            uuid = UUID.randomUUID().getLeastSignificantBits() & 0x7fffffffffffffffL;;\n        } while (uuid < 100000000);\n        return Long.toString(uuid);\n    }\n}", "refactored_code": "    private static final long MIN_UUID = 100000000;\n        long uuid = 0;\n        do {\n            uuid = UUID.randomUUID().getLeastSignificantBits() & 0x7fffffffffffffffL;;\n        } while (uuid < MIN_UUID);\n        return Long.toString(uuid);\n    }\n}"}
{"magic_number_smell": "\n    @Override\n    protected int getVersion() {\n        return 1;\n    }\n\n    @Override", "refactored_code": "    public static final int VERSION = 1;\n\n    @Override\n    protected int getVersion() {\n        return VERSION;\n    }\n\n    @Override"}
{"magic_number_smell": "    public static LegacyRepeatInfo fromSingleField(int repeat) {\n        if(repeat == 0)\n            return null;\n        int value = repeat >> 3;\n        LegacyRepeatInterval interval = LegacyRepeatInterval.values()\n        [repeat - (value << 3)];\n", "refactored_code": "    public static final int REPEAT_VALUE_OFFSET    = 3;\n    public static LegacyRepeatInfo fromSingleField(int repeat) {\n        if(repeat == 0)\n            return null;\n        int value = repeat >> REPEAT_VALUE_OFFSET;\n        LegacyRepeatInterval interval = LegacyRepeatInterval.values()\n        [repeat - (value << REPEAT_VALUE_OFFSET)];\n"}
{"magic_number_smell": "\t\tTodorooCursor<Task> cursor = taskService.query(Query.select(Task.ID, Task.TITLE,\n\t\t        Task.IMPORTANCE, Task.DUE_DATE).where(Criterion.and(TaskCriteria.isActive(),\n                        TaskCriteria.isVisible())).\n\t\t        orderBy(SortHelper.defaultTaskOrder()).limit(100));\n\t\ttry {\n    \t\tint[] importanceColors = Task.getImportanceColors(ctx.getResources());\n    \t\tTask task = new Task();", "refactored_code": "\tprivate static final int MAX_NUMBER_OF_TASKS = 100;\n\t\tTodorooCursor<Task> cursor = taskService.query(Query.select(Task.ID, Task.TITLE,\n\t\t        Task.IMPORTANCE, Task.DUE_DATE).where(Criterion.and(TaskCriteria.isActive(),\n                        TaskCriteria.isVisible())).\n\t\t        orderBy(SortHelper.defaultTaskOrder()).limit(MAX_NUMBER_OF_TASKS));\n\t\ttry {\n    \t\tint[] importanceColors = Task.getImportanceColors(ctx.getResources());\n    \t\tTask task = new Task();"}
{"magic_number_smell": "            String table = uri.toString();\n            table = table.substring(table.indexOf('/', 11) + 1);\n\n            uriMatcher.addURI(authority, table, 1);\n            uriMatcher.addURI(authority, table + \"/#\", URI_ITEM);\n            uriMatcher.addURI(authority, table +\n                    AstridApiConstants.GROUP_BY_URI + \"*\", URI_GROUP);", "refactored_code": "    private static final int URI_DIR = 1;\n            String table = uri.toString();\n            table = table.substring(table.indexOf('/', 11) + 1);\n\n            uriMatcher.addURI(authority, table, URI_DIR);\n            uriMatcher.addURI(authority, table + \"/#\", URI_ITEM);\n            uriMatcher.addURI(authority, table +\n                    AstridApiConstants.GROUP_BY_URI + \"*\", URI_GROUP);"}
{"magic_number_smell": "        if (Preferences.getBoolean(PREF_USER_ACTVATED, false))\n            return true;\n\n        TodorooCursor<Task> all = query(Query.select(Task.ID).limit(3));\n        try {\n            if (all.getCount() < 3)\n                return false;", "refactored_code": "    private static final int TOTAL_TASKS_FOR_ACTIVATION = 3;\n        if (Preferences.getBoolean(PREF_USER_ACTVATED, false))\n            return true;\n\n        TodorooCursor<Task> all = query(Query.select(Task.ID).limit(TOTAL_TASKS_FOR_ACTIVATION));\n        try {\n            if (all.getCount() < TOTAL_TASKS_FOR_ACTIVATION)\n                return false;"}
{"magic_number_smell": "        int theme = getTheme();\n        boolean darkTheme = theme == R.style.Theme || theme == R.style.Theme_Transparent;\n        switch(alter) {\n        case 1:\n            darkTheme = true;\n            break;\n        case FLAG_FORCE_LIGHT:", "refactored_code": "    public static final int FLAG_FORCE_DARK = 1;\n        int theme = getTheme();\n        boolean darkTheme = theme == R.style.Theme || theme == R.style.Theme_Transparent;\n        switch(alter) {\n        case FLAG_FORCE_DARK:\n            darkTheme = true;\n            break;\n        case FLAG_FORCE_LIGHT:"}
{"magic_number_smell": "    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n        if (requestCode == 5 && resultCode == RESULT_OK) {\n            currIndex++;\n            if (currIndex < screens.size()) {\n                String next = screens.get(currIndex);", "refactored_code": "    private static final int REQUEST_CODE_SCREEN_FLOW = 5;\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n        if (requestCode == REQUEST_CODE_SCREEN_FLOW && resultCode == RESULT_OK) {\n            currIndex++;\n            if (currIndex < screens.size()) {\n                String next = screens.get(currIndex);"}
{"magic_number_smell": "     */\n    private void makeChoiceForTest(String testKey, boolean newUser, boolean activatedUser) {\n        int pref = readChoiceForTest(testKey);\n        if (pref > -1) return;\n\n        int chosen = -1;\n        if (abTests.isValidTestKey(testKey)) {", "refactored_code": "    public static final int NO_OPTION = -1;\n     */\n    private void makeChoiceForTest(String testKey, boolean newUser, boolean activatedUser) {\n        int pref = readChoiceForTest(testKey);\n        if (pref > NO_OPTION) return;\n\n        int chosen = NO_OPTION;\n        if (abTests.isValidTestKey(testKey)) {"}
{"magic_number_smell": "    \tbackgroundColorPaint.setAntiAlias(true);\n    \tbackgroundColorPaint.setColor(Color.TRANSPARENT);\n\n        setPadding(0, 0, 0, 0);\n\n        final GestureDetector swipeCalendarListener = new GestureDetector(new SimpleOnGestureListener() {\n", "refactored_code": "\tprivate static final int PADDING = 0;\n    \tbackgroundColorPaint.setAntiAlias(true);\n    \tbackgroundColorPaint.setColor(Color.TRANSPARENT);\n\n        setPadding(PADDING, PADDING, PADDING, PADDING);\n\n        final GestureDetector swipeCalendarListener = new GestureDetector(new SimpleOnGestureListener() {\n"}
{"magic_number_smell": "                lp.topMargin = (int) (-1 * metrics.density);\n                tb.setBackgroundDrawable(CustomBorderDrawable.customButton(cornerRadius, cornerRadius, cornerRadius, cornerRadius, onColorValue, offColorValue, borderColorValue, strokeWidth));\n            }\n            int verticalPadding = (int) (8 * metrics.density);\n            tb.setPadding(0, verticalPadding, 0, verticalPadding);\n            tb.setLayoutParams(lp);\n            tb.setGravity(Gravity.CENTER);", "refactored_code": "    private static final int SHORTCUT_PADDING = 8;\n                lp.topMargin = (int) (-1 * metrics.density);\n                tb.setBackgroundDrawable(CustomBorderDrawable.customButton(cornerRadius, cornerRadius, cornerRadius, cornerRadius, onColorValue, offColorValue, borderColorValue, strokeWidth));\n            }\n            int verticalPadding = (int) (SHORTCUT_PADDING * metrics.density);\n            tb.setPadding(0, verticalPadding, 0, verticalPadding);\n            tb.setLayoutParams(lp);\n            tb.setGravity(Gravity.CENTER);"}
{"magic_number_smell": "\n\n    public static void showQuickAddMarkupDialog(final AstridActivity activity, Task task, String originalText) {\n        if (!Preferences.getBoolean(R.string.p_showSmartConfirmation_key, true))\n            return;\n\n        final Dialog d = new Dialog(activity, R.style.ReminderDialog);", "refactored_code": "    public static final int PREF_SHOW_HELPERS = R.string.p_showSmartConfirmation_key;\n\n\n    public static void showQuickAddMarkupDialog(final AstridActivity activity, Task task, String originalText) {\n        if (!Preferences.getBoolean(PREF_SHOW_HELPERS, true))\n            return;\n\n        final Dialog d = new Dialog(activity, R.style.ReminderDialog);"}
{"magic_number_smell": "                else if (mSwipeListener != null &&\n                            Math.abs(mTouchCurrentY - mTouchStartY) < MOVEMENT_THRESHOLD) {\n                    int dragPos = pointToPosition((int)mTouchCurrentX, (int)mTouchCurrentY);\n                    if (mTouchCurrentX > mTouchStartX + 40)\n                        mSwipeListener.swipeRight(dragPos);\n                    else if (mTouchCurrentX < mTouchStartX - 40)\n                        mSwipeListener.swipeLeft(dragPos);", "refactored_code": "    private static final int SWIPE_THRESHOLD = 40;\n                else if (mSwipeListener != null &&\n                            Math.abs(mTouchCurrentY - mTouchStartY) < MOVEMENT_THRESHOLD) {\n                    int dragPos = pointToPosition((int)mTouchCurrentX, (int)mTouchCurrentY);\n                    if (mTouchCurrentX > mTouchStartX + SWIPE_THRESHOLD)\n                        mSwipeListener.swipeRight(dragPos);\n                    else if (mTouchCurrentX < mTouchStartX - SWIPE_THRESHOLD)\n                        mSwipeListener.swipeLeft(dragPos);"}
{"magic_number_smell": "        // if specific date selected, show dialog\n        // ... at conclusion of dialog, update our list\n        HideUntilValue item = adapter.getItem(position);\n        if(item.date == -1) {\n            customDate = new Date(existingDate == EXISTING_TIME_UNSET ? DateUtilities.now() : existingDate);\n            customDate.setSeconds(0);\n", "refactored_code": "    private static final int SPECIFIC_DATE = -1;\n        // if specific date selected, show dialog\n        // ... at conclusion of dialog, update our list\n        HideUntilValue item = adapter.getItem(position);\n        if(item.date == SPECIFIC_DATE) {\n            customDate = new Date(existingDate == EXISTING_TIME_UNSET ? DateUtilities.now() : existingDate);\n            customDate.setSeconds(0);\n"}
{"magic_number_smell": "                }\n            });\n            button.setTag(i);\n            button.setTextSize(18);\n\n            buttons.add(button);\n", "refactored_code": "    private static final int TEXT_SIZE = 18;\n                }\n            });\n            button.setTag(i);\n            button.setTextSize(TEXT_SIZE);\n\n            buttons.add(button);\n"}
{"magic_number_smell": "\n        addMenuItem(R.string.TLA_menu_lists,\n                ThemeService.getDrawable(R.drawable.icn_menu_lists, themeFlags),\n                R.string.TLA_menu_lists, null, topFixed); // Lists item\n\n        if (Preferences.getBoolean(R.string.p_show_friends_view, false) && Preferences.getBoolean(R.string.p_show_menu_friends, true))\n            addMenuItem(R.string.TLA_menu_friends,", "refactored_code": "    public static final int MAIN_MENU_ITEM_LISTS = R.string.TLA_menu_lists;\n\n        addMenuItem(R.string.TLA_menu_lists,\n                ThemeService.getDrawable(R.drawable.icn_menu_lists, themeFlags),\n                MAIN_MENU_ITEM_LISTS, null, topFixed); // Lists item\n\n        if (Preferences.getBoolean(R.string.p_show_friends_view, false) && Preferences.getBoolean(R.string.p_show_menu_friends, true))\n            addMenuItem(R.string.TLA_menu_friends,"}
{"magic_number_smell": "            if (listAdapter != null && !listAdapter.isEmpty()) {\n                int listPosition = 0;\n                for (listPosition = 0; listPosition < listAdapter.getCount()\n                        && listPosition < 2; listPosition++) {\n                    View listItem = listAdapter.getView(listPosition, null,\n                            this);\n                    listItem.measure(widthMeasureSpec, heightMeasureSpec);", "refactored_code": "    private static final int MAXIMUM_LIST_ITEMS_VIEWABLE = 2;\n            if (listAdapter != null && !listAdapter.isEmpty()) {\n                int listPosition = 0;\n                for (listPosition = 0; listPosition < listAdapter.getCount()\n                        && listPosition < MAXIMUM_LIST_ITEMS_VIEWABLE; listPosition++) {\n                    View listItem = listAdapter.getView(listPosition, null,\n                            this);\n                    listItem.measure(widthMeasureSpec, heightMeasureSpec);"}
{"magic_number_smell": "\n        boolean enabled = time > 0;\n        if(time <= 0) {\n            time = DateUtilities.ONE_WEEK * 2;\n        }\n\n        int i;", "refactored_code": "    private final long DEFAULT_INTERVAL = DateUtilities.ONE_WEEK * 2;\n\n        boolean enabled = time > 0;\n        if(time <= 0) {\n            time = DEFAULT_INTERVAL;\n        }\n\n        int i;"}
{"magic_number_smell": "    /** If true, can show a help popover. If false, another one was recently shown */\n    public static boolean canShowPopover() {\n        long last = Preferences.getLong(P_LAST_POPOVER, 0);\n        if(System.currentTimeMillis() - last < 3 * 1000L)\n            return false;\n        Preferences.setLong(P_LAST_POPOVER, System.currentTimeMillis());\n        return true;", "refactored_code": "    private static final long MIN_POPOVER_TIME = 3 * 1000L;\n    /** If true, can show a help popover. If false, another one was recently shown */\n    public static boolean canShowPopover() {\n        long last = Preferences.getLong(P_LAST_POPOVER, 0);\n        if(System.currentTimeMillis() - last < MIN_POPOVER_TIME)\n            return false;\n        Preferences.setLong(P_LAST_POPOVER, System.currentTimeMillis());\n        return true;"}
{"magic_number_smell": "         */\n        @Override\n        public String name(int value) {\n            if (value < 256) {\n                return lookupTable()[value];\n            }\n            return super.name(value);", "refactored_code": "        private final int LOOKUP_TABLE_SIZE = 256;\n         */\n        @Override\n        public String name(int value) {\n            if (value < LOOKUP_TABLE_SIZE) {\n                return lookupTable()[value];\n            }\n            return super.name(value);"}
{"magic_number_smell": "            Intent checkIntent = new Intent();\n            checkIntent.setAction(TextToSpeech.Engine.ACTION_CHECK_TTS_DATA);\n            ((Activity) context).startActivityForResult(checkIntent,\n                    2534);\n        }\n    }\n", "refactored_code": "    private static final int MY_DATA_CHECK_CODE = 2534;\n            Intent checkIntent = new Intent();\n            checkIntent.setAction(TextToSpeech.Engine.ACTION_CHECK_TTS_DATA);\n            ((Activity) context).startActivityForResult(checkIntent,\n                    MY_DATA_CHECK_CODE);\n        }\n    }\n"}
{"magic_number_smell": "    /**\n     * This requestcode is used to differentiate between multiple microphone-buttons on a single fragment.\n     * Use the mightier constructor to specify your own requestCode in this case for every additional use on an fragment.\n     * If you only use one microphone-button on an fragment, you can leave it to its default, 1234.\n     */\n    private int requestCode = 1234;\n    private Activity activity;", "refactored_code": "    public static final int VOICE_RECOGNITION_REQUEST_CODE = 1234;\n    /**\n     * This requestcode is used to differentiate between multiple microphone-buttons on a single fragment.\n     * Use the mightier constructor to specify your own requestCode in this case for every additional use on an fragment.\n     * If you only use one microphone-button on an fragment, you can leave it to its default, VOICE_RECOGNITION_REQUEST_CODE.\n     */\n    private int requestCode = VOICE_RECOGNITION_REQUEST_CODE;\n    private Activity activity;"}
{"magic_number_smell": "    }\n\n    public static VoiceOutputAssistant getVoiceOutputInstance() {\n        if(AndroidUtilities.getSdkVersion() >= 6) {\n            if (outputAssistant == null)\n                outputAssistant = new Api6VoiceOutputAssistant();\n        } else {", "refactored_code": "    private static final int MIN_TTS_VERSION = 6;\n    }\n\n    public static VoiceOutputAssistant getVoiceOutputInstance() {\n        if(AndroidUtilities.getSdkVersion() >= MIN_TTS_VERSION) {\n            if (outputAssistant == null)\n                outputAssistant = new Api6VoiceOutputAssistant();\n        } else {"}
{"magic_number_smell": "\n        private boolean isLegacyTheme() {\n            int theme = ThemeService.getWidgetTheme();\n            return theme == -1;\n        }\n\n", "refactored_code": "    public static final int THEME_LEGACY = -1;\n\n        private boolean isLegacyTheme() {\n            int theme = ThemeService.getWidgetTheme();\n            return theme == THEME_LEGACY;\n        }\n\n"}
{"magic_number_smell": "\n    /** Checks whether task is done. Requires progressPercentage */\n    protected boolean isTaskCompleted() {\n        return getProgressPercentage() >= 100;\n    }\n\n    /** Stops the timer & increments elapsed time. Requires timerStart and", "refactored_code": "    public static final int COMPLETE_PERCENTAGE    = 100;\n\n    /** Checks whether task is done. Requires progressPercentage */\n    protected boolean isTaskCompleted() {\n        return getProgressPercentage() >= COMPLETE_PERCENTAGE;\n    }\n\n    /** Stops the timer & increments elapsed time. Requires timerStart and"}
{"magic_number_smell": "    }\n\n    private static class SerializationProxyV1 implements Serializable {\n        private static final long 1L = -2488473066578201069L;\n        private final Date expires;\n        private final List<String> permissions;\n        private final String token;", "refactored_code": "    private static final long serialVersionUID = 1L;\n    }\n\n    private static class SerializationProxyV1 implements Serializable {\n        private static final long serialVersionUID = -2488473066578201069L;\n        private final Date expires;\n        private final List<String> permissions;\n        private final String token;"}
{"magic_number_smell": "    }\n\n    abstract class AuthHandler implements Serializable {\n        private static final long 1L = 1L;\n\n        abstract boolean tryAuthorize(AuthorizationRequest request);\n", "refactored_code": "    private static final long serialVersionUID = 1L;\n    }\n\n    abstract class AuthHandler implements Serializable {\n        private static final long serialVersionUID = 1L;\n\n        abstract boolean tryAuthorize(AuthorizationRequest request);\n"}
{"magic_number_smell": "    }\n\n    FacebookRequestError(HttpURLConnection connection, Exception exception) {\n        this(INVALID_HTTP_STATUS_CODE, -1, -1,\n                null, null, null, null, null, connection,\n                (exception instanceof FacebookException) ?\n                        (FacebookException) exception : new FacebookException(exception));", "refactored_code": "    public static final int INVALID_ERROR_CODE = -1;\n    }\n\n    FacebookRequestError(HttpURLConnection connection, Exception exception) {\n        this(INVALID_HTTP_STATUS_CODE, INVALID_ERROR_CODE, INVALID_ERROR_CODE,\n                null, null, null, null, null, connection,\n                (exception instanceof FacebookException) ?\n                        (FacebookException) exception : new FacebookException(exception));"}
{"magic_number_smell": "            FacebookRequestError error =\n                    FacebookRequestError.checkResponseAndCreateError(jsonObject, originalResult, connection);\n            if (error != null) {\n                if (error.getErrorCode() == 190) {\n                    Session session = request.getSession();\n                    if (session != null) {\n                        session.closeAndClearTokenInformation();", "refactored_code": "    private static final int INVALID_SESSION_FACEBOOK_ERROR_CODE = 190;\n            FacebookRequestError error =\n                    FacebookRequestError.checkResponseAndCreateError(jsonObject, originalResult, connection);\n            if (error != null) {\n                if (error.getErrorCode() == INVALID_SESSION_FACEBOOK_ERROR_CODE) {\n                    Session session = request.getSession();\n                    if (session != null) {\n                        session.closeAndClearTokenInformation();"}
{"magic_number_smell": "     * create a new class SerializationProxyVx.\n     */\n    private static class SerializationProxyV1 implements Serializable {\n        private static final long 1L = 7663436173185080063L;\n        private final String applicationId;\n        private final SessionState state;\n        private final AccessToken tokenInfo;", "refactored_code": "    private static final long serialVersionUID = 1L;\n     * create a new class SerializationProxyVx.\n     */\n    private static class SerializationProxyV1 implements Serializable {\n        private static final long serialVersionUID = 7663436173185080063L;\n        private final String applicationId;\n        private final SessionState state;\n        private final AccessToken tokenInfo;"}
{"magic_number_smell": "            if (Settings.executor == null) {\n                Executor executor = getAsyncTaskExecutor();\n                if (executor == null) {\n                    executor = new ThreadPoolExecutor(5, DEFAULT_MAXIMUM_POOL_SIZE,\n                            DEFAULT_KEEP_ALIVE, TimeUnit.SECONDS, DEFAULT_WORK_QUEUE, DEFAULT_THREAD_FACTORY);\n                }\n                Settings.executor = executor;", "refactored_code": "    private static final int DEFAULT_CORE_POOL_SIZE = 5;\n            if (Settings.executor == null) {\n                Executor executor = getAsyncTaskExecutor();\n                if (executor == null) {\n                    executor = new ThreadPoolExecutor(DEFAULT_CORE_POOL_SIZE, DEFAULT_MAXIMUM_POOL_SIZE,\n                            DEFAULT_KEEP_ALIVE, TimeUnit.SECONDS, DEFAULT_WORK_QUEUE, DEFAULT_THREAD_FACTORY);\n                }\n                Settings.executor = executor;"}
{"magic_number_smell": "            return null;\n        }\n\n        long n = bundle.getLong(key, Long.MIN_VALUE);\n        if (n == Long.MIN_VALUE) {\n            return null;\n        }", "refactored_code": "    private static final long INVALID_BUNDLE_MILLISECONDS = Long.MIN_VALUE;\n            return null;\n        }\n\n        long n = bundle.getLong(key, INVALID_BUNDLE_MILLISECONDS);\n        if (n == INVALID_BUNDLE_MILLISECONDS) {\n            return null;\n        }"}
{"magic_number_smell": "     * IMPORTANT: Note that single sign-on authentication will not function\n     * correctly if you do not include a call to the authorizeCallback() method\n     * in your onActivityResult() function! Please see below for more\n     * information. single sign-on may be disabled by passing -1\n     * as the activityCode parameter in your call to authorize().\n     * <p/>\n     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info.", "refactored_code": "    public static final int FORCE_DIALOG_AUTH = -1;\n     * IMPORTANT: Note that single sign-on authentication will not function\n     * correctly if you do not include a call to the authorizeCallback() method\n     * in your onActivityResult() function! Please see below for more\n     * information. single sign-on may be disabled by passing FORCE_DIALOG_AUTH\n     * as the activityCode parameter in your call to authorize().\n     * <p/>\n     * This method is deprecated.  See {@link Facebook} and {@link Session} for more info."}
{"magic_number_smell": "            byte[] headerBytes = headerString.getBytes();\n\n            // Write version number and big-endian header size\n            stream.write(0);\n            stream.write((headerBytes.length >> 16) & 0xff);\n            stream.write((headerBytes.length >> 8) & 0xff);\n            stream.write((headerBytes.length >> 0) & 0xff);", "refactored_code": "        private static final int HEADER_VERSION = 0;\n            byte[] headerBytes = headerString.getBytes();\n\n            // Write version number and big-endian header size\n            stream.write(HEADER_VERSION);\n            stream.write((headerBytes.length >> 16) & 0xff);\n            stream.write((headerBytes.length >> 8) & 0xff);\n            stream.write((headerBytes.length >> 0) & 0xff);"}
{"magic_number_smell": "\n        Collections.sort(sectionKeys, Collator.getInstance());\n\n        displaySections = sectionKeys.size() > 1 && objectsAdded > 1;\n    }\n\n    SectionAndItem<T> getSectionAndItem(int position) {", "refactored_code": "    private static final int DISPLAY_SECTIONS_THRESHOLD = 1;\n\n        Collections.sort(sectionKeys, Collator.getInstance());\n\n        displaySections = sectionKeys.size() > 1 && objectsAdded > DISPLAY_SECTIONS_THRESHOLD;\n    }\n\n    SectionAndItem<T> getSectionAndItem(int position) {"}
{"magic_number_smell": "    private static final int WorkQueue.DEFAULT_MAX_CONCURRENT = WorkQueue.DEFAULT_MAX_CONCURRENT;\n    private static final int CACHE_READ_QUEUE_MAX_CONCURRENT = 2;\n    private static final Handler handler = new Handler();\n    private static WorkQueue downloadQueue = new WorkQueue(WorkQueue.DEFAULT_MAX_CONCURRENT);\n    private static WorkQueue cacheReadQueue = new WorkQueue(CACHE_READ_QUEUE_MAX_CONCURRENT);\n\n    private static final Map<RequestKey, DownloaderContext> pendingRequests = new HashMap<RequestKey, DownloaderContext>();", "refactored_code": "    private static final int DOWNLOAD_QUEUE_MAX_CONCURRENT = WorkQueue.DEFAULT_MAX_CONCURRENT;\n    private static final int DOWNLOAD_QUEUE_MAX_CONCURRENT = WorkQueue.DEFAULT_MAX_CONCURRENT;\n    private static final int CACHE_READ_QUEUE_MAX_CONCURRENT = 2;\n    private static final Handler handler = new Handler();\n    private static WorkQueue downloadQueue = new WorkQueue(DOWNLOAD_QUEUE_MAX_CONCURRENT);\n    private static WorkQueue cacheReadQueue = new WorkQueue(CACHE_READ_QUEUE_MAX_CONCURRENT);\n\n    private static final Map<RequestKey, DownloaderContext> pendingRequests = new HashMap<RequestKey, DownloaderContext>();"}
{"magic_number_smell": "        int lastVisibleItem = listView.getLastVisiblePosition();\n        if (lastVisibleItem >= 0) {\n            int firstVisibleItem = listView.getFirstVisiblePosition();\n            adapter.prioritizeViewRange(firstVisibleItem, lastVisibleItem, 5);\n        }\n    }\n", "refactored_code": "    private static final int PROFILE_PICTURE_PREFETCH_BUFFER = 5;\n        int lastVisibleItem = listView.getLastVisiblePosition();\n        if (lastVisibleItem >= 0) {\n            int firstVisibleItem = listView.getFirstVisiblePosition();\n            adapter.prioritizeViewRange(firstVisibleItem, lastVisibleItem, PROFILE_PICTURE_PREFETCH_BUFFER);\n        }\n    }\n"}
{"magic_number_smell": "    private static final String TAG = \"PlacePickerFragment\";\n\n    private Location location;\n    private int radiusInMeters = 1000;\n    private int resultsLimit = DEFAULT_RESULTS_LIMIT;\n    private String searchText;\n    private Timer searchTextTimer;", "refactored_code": "    public static final int DEFAULT_RADIUS_IN_METERS = 1000;\n    private static final String TAG = \"PlacePickerFragment\";\n\n    private Location location;\n    private int radiusInMeters = DEFAULT_RADIUS_IN_METERS;\n    private int resultsLimit = DEFAULT_RESULTS_LIMIT;\n    private String searchText;\n    private Timer searchTextTimer;"}
{"magic_number_smell": "    private boolean isCropped = IS_CROPPED_DEFAULT_VALUE;\n    private Bitmap imageContents;\n    private ImageView image;\n    private int presetSizeType = -1;\n    private ImageRequest lastRequest;\n    private OnErrorListener onErrorListener;\n", "refactored_code": "    public static final int CUSTOM = -1;\n    private boolean isCropped = IS_CROPPED_DEFAULT_VALUE;\n    private Bitmap imageContents;\n    private ImageView image;\n    private int presetSizeType = CUSTOM;\n    private ImageRequest lastRequest;\n    private OnErrorListener onErrorListener;\n"}
{"magic_number_smell": "     *                be a valid URL pointing to a Facebook Web Dialog\n     */\n    public WebDialog(Context context, String url) {\n        this(context, url, android.R.style.Theme_Translucent_NoTitleBar);\n    }\n\n    /**", "refactored_code": "    public static final int DEFAULT_THEME = android.R.style.Theme_Translucent_NoTitleBar;\n     *                be a valid URL pointing to a Facebook Web Dialog\n     */\n    public WebDialog(Context context, String url) {\n        this(context, url, DEFAULT_THEME);\n    }\n\n    /**"}
{"magic_number_smell": "    private int runningCount = 0;\n\n    WorkQueue() {\n        this(8);\n    }\n\n    WorkQueue(int maxConcurrent) {", "refactored_code": "    public static final int DEFAULT_MAX_CONCURRENT = 8;\n    private int runningCount = 0;\n\n    WorkQueue() {\n        this(DEFAULT_MAX_CONCURRENT);\n    }\n\n    WorkQueue(int maxConcurrent) {"}
{"magic_number_smell": "    public void testWebViewHandlesSuccess() {\n        Bundle bundle = new Bundle();\n        bundle.putString(\"access_token\", ACCESS_TOKEN);\n        bundle.putString(\"expires_in\", String.format(\"%d\", 3600 * 24 * 60));\n        bundle.putString(\"code\", \"Something else\");\n\n        MockAuthorizationClient client = new MockAuthorizationClient();", "refactored_code": "    private static final long EXPIRES_IN_DELTA = 3600 * 24 * 60;\n    public void testWebViewHandlesSuccess() {\n        Bundle bundle = new Bundle();\n        bundle.putString(\"access_token\", ACCESS_TOKEN);\n        bundle.putString(\"expires_in\", String.format(\"%d\", EXPIRES_IN_DELTA));\n        bundle.putString(\"code\", \"Something else\");\n\n        MockAuthorizationClient client = new MockAuthorizationClient();"}
{"magic_number_smell": "            Call call = null;\n\n            try {\n                call = calls.poll(10 * 1000, TimeUnit.MILLISECONDS);\n                if (call == null) {\n                    fail(\"Did not get a status callback within timeout.\");\n                }", "refactored_code": "    public static final int DEFAULT_TIMEOUT_MILLISECONDS = 10 * 1000;\n            Call call = null;\n\n            try {\n                call = calls.poll(DEFAULT_TIMEOUT_MILLISECONDS, TimeUnit.MILLISECONDS);\n                if (call == null) {\n                    fail(\"Did not get a status callback within timeout.\");\n                }"}
{"magic_number_smell": "            layout.setOrientation(LinearLayout.VERTICAL);\n            layout.setLayoutParams(new LinearLayout.LayoutParams(LinearLayout.LayoutParams.FILL_PARENT,\n                    LinearLayout.LayoutParams.FILL_PARENT));\n            layout.setId(0xFACE);\n\n            getSupportFragmentManager().beginTransaction()\n                    .add(0xFACE, fragment)", "refactored_code": "        public static final int FRAGMENT_ID = 0xFACE;\n            layout.setOrientation(LinearLayout.VERTICAL);\n            layout.setLayoutParams(new LinearLayout.LayoutParams(LinearLayout.LayoutParams.FILL_PARENT,\n                    LinearLayout.LayoutParams.FILL_PARENT));\n            layout.setId(FRAGMENT_ID);\n\n            getSupportFragmentManager().beginTransaction()\n                    .add(FRAGMENT_ID, fragment)"}
{"magic_number_smell": "\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        switch (requestCode) {\n            case 1:\n                displaySelectedFriends(resultCode);\n                break;\n            default:", "refactored_code": "    private static final int PICK_FRIENDS_ACTIVITY = 1;\n\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        switch (requestCode) {\n            case PICK_FRIENDS_ACTIVITY:\n                displaySelectedFriends(resultCode);\n                break;\n            default:"}
{"magic_number_smell": "\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        switch (requestCode) {\n            case 1:\n                displaySelectedPlace(resultCode);\n                break;\n            default:", "refactored_code": "    private static final int PLACE_ACTIVITY = 1;\n\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        switch (requestCode) {\n            case PLACE_ACTIVITY:\n                displaySelectedPlace(resultCode);\n                break;\n            default:"}
{"magic_number_smell": "\n    // Keeping the number of custom sizes low to prevent excessive network chatter.\n    private static final int 6 = 6;\n    private static final int DEFAULT_SIZE_INCREMENT = 6 / 2;\n    private static final String PICTURE_SIZE_TYPE_KEY = \"PictureSizeType\";\n\n    private static final String[] INTERESTING_IDS = {", "refactored_code": "    private static final int MAX_CUSTOM_SIZES = 6;\n\n    // Keeping the number of custom sizes low to prevent excessive network chatter.\n    private static final int MAX_CUSTOM_SIZES = 6;\n    private static final int DEFAULT_SIZE_INCREMENT = MAX_CUSTOM_SIZES / 2;\n    private static final String PICTURE_SIZE_TYPE_KEY = \"PictureSizeType\";\n\n    private static final String[] INTERESTING_IDS = {"}
{"magic_number_smell": "        setContentView(R.layout.main);\n\n        FragmentManager fm = getSupportFragmentManager();\n        fragments[0] = fm.findFragmentById(R.id.splashFragment);\n        fragments[SELECTION] = fm.findFragmentById(R.id.selectionFragment);\n        fragments[SETTINGS] = fm.findFragmentById(R.id.userSettingsFragment);\n", "refactored_code": "    private static final int SPLASH = 0;\n        setContentView(R.layout.main);\n\n        FragmentManager fm = getSupportFragmentManager();\n        fragments[SPLASH] = fm.findFragmentById(R.id.splashFragment);\n        fragments[SELECTION] = fm.findFragmentById(R.id.selectionFragment);\n        fragments[SETTINGS] = fm.findFragmentById(R.id.userSettingsFragment);\n"}
{"magic_number_smell": "                }\n                if (location != null) {\n                    placePickerFragment.setLocation(location);\n                    placePickerFragment.setRadiusInMeters(1000);\n                    placePickerFragment.setSearchText(SEARCH_TEXT);\n                    placePickerFragment.setResultsLimit(SEARCH_RESULT_LIMIT);\n                    placePickerFragment.loadData(false);", "refactored_code": "    private static final int SEARCH_RADIUS_METERS = 1000;\n                }\n                if (location != null) {\n                    placePickerFragment.setLocation(location);\n                    placePickerFragment.setRadiusInMeters(SEARCH_RADIUS_METERS);\n                    placePickerFragment.setSearchText(SEARCH_TEXT);\n                    placePickerFragment.setResultsLimit(SEARCH_RESULT_LIMIT);\n                    placePickerFragment.loadData(false);"}
{"magic_number_smell": "    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n        if (requestCode == 100) {\n            uiHelper.onActivityResult(requestCode, resultCode, data);\n        } else if (resultCode == Activity.RESULT_OK && requestCode >= 0 && requestCode < listElements.size()) {\n            listElements.get(requestCode).onActivityResult(data);", "refactored_code": "    private static final int REAUTH_ACTIVITY_CODE = 100;\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n        if (requestCode == REAUTH_ACTIVITY_CODE) {\n            uiHelper.onActivityResult(requestCode, resultCode, data);\n        } else if (resultCode == Activity.RESULT_OK && requestCode >= 0 && requestCode < listElements.size()) {\n            listElements.get(requestCode).onActivityResult(data);"}
{"magic_number_smell": "    \n    public ExecutorService getExecutor() {\n        if (mExecutorService == null) {\n            mExecutorService = Executors.newFixedThreadPool(5, sThreadFactory);\n        }\n        return mExecutorService;\n    }", "refactored_code": "    private static final int CORE_POOL_SIZE = 5;\n    \n    public ExecutorService getExecutor() {\n        if (mExecutorService == null) {\n            mExecutorService = Executors.newFixedThreadPool(CORE_POOL_SIZE, sThreadFactory);\n        }\n        return mExecutorService;\n    }"}
{"magic_number_smell": "            Bitmap bitmap = null;\n            Throwable throwable = null;\n\n            h.sendMessage(Message.obtain(h, 0x100));\n\n            try {\n", "refactored_code": "    private static final int ON_START = 0x100;\n            Bitmap bitmap = null;\n            Throwable throwable = null;\n\n            h.sendMessage(Message.obtain(h, ON_START));\n\n            try {\n"}
{"magic_number_smell": "     */\n    private static final int GD_LOG_LEVEL = GD_LOG_LEVEL_NONE;\n\n    public static final boolean GD_INFO_LOGS_ENABLED = (GD_LOG_LEVEL == 3);\n    public static final boolean GD_WARNING_LOGS_ENABLED = GD_INFO_LOGS_ENABLED\n            || (GD_LOG_LEVEL == GD_LOG_LEVEL_WARNING);\n    public static final boolean GD_ERROR_LOGS_ENABLED = GD_WARNING_LOGS_ENABLED || (GD_LOG_LEVEL == GD_LOG_LEVEL_ERROR);", "refactored_code": "    private static final int GD_LOG_LEVEL_INFO = 3;\n     */\n    private static final int GD_LOG_LEVEL = GD_LOG_LEVEL_NONE;\n\n    public static final boolean GD_INFO_LOGS_ENABLED = (GD_LOG_LEVEL == GD_LOG_LEVEL_INFO);\n    public static final boolean GD_WARNING_LOGS_ENABLED = GD_INFO_LOGS_ENABLED\n            || (GD_LOG_LEVEL == GD_LOG_LEVEL_WARNING);\n    public static final boolean GD_ERROR_LOGS_ENABLED = GD_WARNING_LOGS_ENABLED || (GD_LOG_LEVEL == GD_LOG_LEVEL_ERROR);"}
{"magic_number_smell": "\t/**\n\t * The number of milliseconds in a minute.\n\t */\n\tpublic static final int GD_MINUTE = 1000 * 60;\n\n\t/**\n\t * The number of milliseconds in an hour.", "refactored_code": "\tpublic static final int GD_SECOND = 1000;\n\t/**\n\t * The number of milliseconds in a minute.\n\t */\n\tpublic static final int GD_MINUTE = GD_SECOND * 60;\n\n\t/**\n\t * The number of milliseconds in an hour."}
{"magic_number_smell": "\t}\n\n\tprivate void initializeDefaultValues() {\n\t\tmImageSource = -1;\n\t\tmPaused = false;\n\t}\n", "refactored_code": "\tprivate static final int IMAGE_SOURCE_UNKNOWN = -1;\n\t}\n\n\tprivate void initializeDefaultValues() {\n\t\tmImageSource = IMAGE_SOURCE_UNKNOWN;\n\t\tmPaused = false;\n\t}\n"}
{"magic_number_smell": "    }\n\n    public ActionBarItem addItem(ActionBarItem.Type actionBarItemType) {\n        return addItem(ActionBarItem.createWithType(this, actionBarItemType), 0);\n    }\n\n    public ActionBarItem addItem(ActionBarItem.Type actionBarItemType, int itemId) {", "refactored_code": "    public static final int NONE = 0;\n    }\n\n    public ActionBarItem addItem(ActionBarItem.Type actionBarItemType) {\n        return addItem(ActionBarItem.createWithType(this, actionBarItemType), NONE);\n    }\n\n    public ActionBarItem addItem(ActionBarItem.Type actionBarItemType, int itemId) {"}
{"magic_number_smell": "     *            ItemAdapter\n     */\n    public ItemAdapter(Context context, Item[] items) {\n        this(context, Arrays.asList(items), 10);\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_MAX_VIEW_TYPE_COUNT = 10;\n     *            ItemAdapter\n     */\n    public ItemAdapter(Context context, Item[] items) {\n        this(context, Arrays.asList(items), DEFAULT_MAX_VIEW_TYPE_COUNT);\n    }\n\n    /**"}
{"magic_number_smell": "\n        onMeasureAndLayout(mRect, contentView);\n\n        if ((mPrivateFlags & 1 << 1) != 1 << 1) {\n            throw new IllegalStateException(\"onMeasureAndLayout() did not set the widget specification by calling\"\n                    + \" setWidgetSpecs()\");\n        }", "refactored_code": "    private static final int MEASURE_AND_LAYOUT_DONE = 1 << 1;\n\n        onMeasureAndLayout(mRect, contentView);\n\n        if ((mPrivateFlags & MEASURE_AND_LAYOUT_DONE) != MEASURE_AND_LAYOUT_DONE) {\n            throw new IllegalStateException(\"onMeasureAndLayout() did not set the widget specification by calling\"\n                    + \" setWidgetSpecs()\");\n        }"}
{"magic_number_smell": "    /**\n     * Decoration position\n     */\n    public int position = 0;\n\n    /**\n     * Decorated task background color. 0 is default", "refactored_code": "    public static final int POSITION_LEFT = 0;\n    /**\n     * Decoration position\n     */\n    public int position = POSITION_LEFT;\n\n    /**\n     * Decorated task background color. 0 is default"}
{"magic_number_smell": "    /**\n     * Utility method to get the identifier of the model, if it exists.\n     *\n     * @return {@value #0} if this model was not added to the database\n     */\n    abstract public long getId();\n", "refactored_code": "    public static final long NO_ID = 0;\n    /**\n     * Utility method to get the identifier of the model, if it exists.\n     *\n     * @return {@value #NO_ID} if this model was not added to the database\n     */\n    abstract public long getId();\n"}
{"magic_number_smell": "            service.setBackupDirectorySetting(setting);\n            service.testBackup(getContext());\n\n            AndroidUtilities.sleepDeep(500L);\n\n            // assert file created\n            File[] files = temporaryDirectory.listFiles();", "refactored_code": "    private static final long BACKUP_WAIT_TIME = 500L;\n            service.setBackupDirectorySetting(setting);\n            service.testBackup(getContext());\n\n            AndroidUtilities.sleepDeep(BACKUP_WAIT_TIME);\n\n            // assert file created\n            File[] files = temporaryDirectory.listFiles();"}
{"magic_number_smell": "\n        buildRRule(1, Frequency.WEEKLY, Weekday.MO);\n\n        setTaskDueDate(-2, Calendar.MONDAY);\n        computeNextDueDate(false);\n        assertDueDate(nextDueDate, NEXT, Calendar.MONDAY);\n", "refactored_code": "    private static final int PREV_PREV = -2;\n\n        buildRRule(1, Frequency.WEEKLY, Weekday.MO);\n\n        setTaskDueDate(PREV_PREV, Calendar.MONDAY);\n        computeNextDueDate(false);\n        assertDueDate(nextDueDate, NEXT, Calendar.MONDAY);\n"}
{"magic_number_smell": "        whenInvokeSync();\n\n        com.google.api.services.tasks.model.Task remoteTask = assertTaskExistsRemotely(localTask, title);\n        AndroidUtilities.sleepDeep(3000l);\n\n        //Set new title on local task\n        String newTitle = \"Astrid task 2 edited\";", "refactored_code": "    private static final long TIME_BETWEEN_SYNCS = 3000l;\n        whenInvokeSync();\n\n        com.google.api.services.tasks.model.Task remoteTask = assertTaskExistsRemotely(localTask, title);\n        AndroidUtilities.sleepDeep(TIME_BETWEEN_SYNCS);\n\n        //Set new title on local task\n        String newTitle = \"Astrid task 2 edited\";"}
{"magic_number_smell": "        Task localTask = setupLocalTaskModel(title);\n        taskService.save(localTask);\n\n        AndroidUtilities.sleepDeep(8000L);\n\n        com.google.api.services.tasks.model.Task remoteTask = getRemoteTaskForLocalId(localTask.getId());\n        assertEquals(title, remoteTask.getTitle());", "refactored_code": "    private static final long TIME_TO_WAIT = 8000L;\n        Task localTask = setupLocalTaskModel(title);\n        taskService.save(localTask);\n\n        AndroidUtilities.sleepDeep(TIME_TO_WAIT);\n\n        com.google.api.services.tasks.model.Task remoteTask = getRemoteTaskForLocalId(localTask.getId());\n        assertEquals(title, remoteTask.getTitle());"}
{"magic_number_smell": "\n    public void setOrientation(int orientation) {\n        switch (orientation) {\n            case 0:\n            case VERTICAL:\n                mOrientation = orientation;\n                updatePageSize();", "refactored_code": "    public static final int HORIZONTAL = 0;\n\n    public void setOrientation(int orientation) {\n        switch (orientation) {\n            case HORIZONTAL:\n            case VERTICAL:\n                mOrientation = orientation;\n                updatePageSize();"}
{"magic_number_smell": "            page += 1;\n            offsetPercent = 1.0f * (width - mCurrentOffset) / width;\n        }\n        final boolean currentSelected = (offsetPercent <= 0.25f);\n        final boolean currentBold = (offsetPercent <= BOLD_FADE_PERCENTAGE);\n        final float selectedPercent = (0.25f - offsetPercent) / 0.25f;\n", "refactored_code": "    private static final float SELECTION_FADE_PERCENTAGE = 0.25f;\n            page += 1;\n            offsetPercent = 1.0f * (width - mCurrentOffset) / width;\n        }\n        final boolean currentSelected = (offsetPercent <= SELECTION_FADE_PERCENTAGE);\n        final boolean currentBold = (offsetPercent <= BOLD_FADE_PERCENTAGE);\n        final float selectedPercent = (SELECTION_FADE_PERCENTAGE - offsetPercent) / SELECTION_FADE_PERCENTAGE;\n"}
{"magic_number_smell": "     * IMPORTANT: Note that single sign-on authentication will not function\n     * correctly if you do not include a call to the authorizeCallback() method\n     * in your onActivityResult() function! Please see below for more\n     * information. single sign-on may be disabled by passing -1\n     * as the activityCode parameter in your call to authorize().\n     *\n     * @param activity", "refactored_code": "    public static final int FORCE_DIALOG_AUTH = -1;\n     * IMPORTANT: Note that single sign-on authentication will not function\n     * correctly if you do not include a call to the authorizeCallback() method\n     * in your onActivityResult() function! Please see below for more\n     * information. single sign-on may be disabled by passing FORCE_DIALOG_AUTH\n     * as the activityCode parameter in your call to authorize().\n     *\n     * @param activity"}
{"magic_number_smell": "        Intent installIntent = new Intent(Intent.ACTION_VIEW);\n        installIntent.setDataAndType(uri, \"application/vnd.android.package-archive\");\n        installIntent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_READ_URI_PERMISSION);\n        startActivityForResult(installIntent, 4242);\n    }\n    // EMXIF\n", "refactored_code": "    private static final int INSTALL_REQUEST_CODE = 4242;\n        Intent installIntent = new Intent(Intent.ACTION_VIEW);\n        installIntent.setDataAndType(uri, \"application/vnd.android.package-archive\");\n        installIntent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_READ_URI_PERMISSION);\n        startActivityForResult(installIntent, INSTALL_REQUEST_CODE);\n    }\n    // EMXIF\n"}
{"magic_number_smell": "\t\t\treturn true;\n\t\tcase IMPORT_MENU:\n\t\t\tloadFileList();\n\t\t\tshowDialog(1000);\n\t\t\tLog.d(TAG, path.getAbsolutePath());\n\t\t    return true; \n\t\t     ", "refactored_code": "\tprivate static final int DIALOG_LOAD_FILE = 1000;\n\t\t\treturn true;\n\t\tcase IMPORT_MENU:\n\t\t\tloadFileList();\n\t\t\tshowDialog(DIALOG_LOAD_FILE);\n\t\t\tLog.d(TAG, path.getAbsolutePath());\n\t\t    return true; \n\t\t     "}
{"magic_number_smell": "        }\n\n        if (scanner.getTimeout() <= 0L) {\n            scanner.setTimeout(TimeUnit.SECONDS.toMillis(5L));\n        }\n\n        if (GenericUtils.isEmpty(scanner.getKeyTypes())) {", "refactored_code": "    public static final long DEFAULT_TIMEOUT = TimeUnit.SECONDS.toMillis(5L);\n        }\n\n        if (scanner.getTimeout() <= 0L) {\n            scanner.setTimeout(DEFAULT_TIMEOUT);\n        }\n\n        if (GenericUtils.isEmpty(scanner.getKeyTypes())) {"}
{"magic_number_smell": "    private int curMarkersInLine;\n\n    public SftpFileTransferProgressOutputStream(OutputStream out, Appendable stdout) {\n        this(out, DEFAULT_MARKER_SIZE, DEFAULT_PROGRESS_CHAR, 72, stdout);\n    }\n\n    public SftpFileTransferProgressOutputStream(OutputStream out, int markerSize, char markerChar, int markersPerLine,", "refactored_code": "    public static final int DEFAULT_MARKS_PER_LINE = 72;\n    private int curMarkersInLine;\n\n    public SftpFileTransferProgressOutputStream(OutputStream out, Appendable stdout) {\n        this(out, DEFAULT_MARKER_SIZE, DEFAULT_PROGRESS_CHAR, DEFAULT_MARKS_PER_LINE, stdout);\n    }\n\n    public SftpFileTransferProgressOutputStream(OutputStream out, int markerSize, char markerChar, int markersPerLine,"}
{"magic_number_smell": "public final class SshConstants {\n    public static final int 22 = 22;\n\n    /** Converts non-positive port value to {@value #22} */\n    public static final IntUnaryOperator TO_EFFECTIVE_PORT = port -> (port > 0) ? port : 22;\n\n    //", "refactored_code": "    public static final int DEFAULT_PORT = 22;\npublic final class SshConstants {\n    public static final int DEFAULT_PORT = 22;\n\n    /** Converts non-positive port value to {@value #DEFAULT_PORT} */\n    public static final IntUnaryOperator TO_EFFECTIVE_PORT = port -> (port > 0) ? port : DEFAULT_PORT;\n\n    //"}
{"magic_number_smell": "        try {\n            int val = getTerminalProperty(\"columns\");\n            if (val == -1) {\n                val = 80;\n            }\n\n            return val;", "refactored_code": "    public static final int DEFAULT_TERMINAL_WIDTH = 80;\n        try {\n            int val = getTerminalProperty(\"columns\");\n            if (val == -1) {\n                val = DEFAULT_TERMINAL_WIDTH;\n            }\n\n            return val;"}
{"magic_number_smell": "                new SecretKeySpec(key, getAlgorithm()));\n\n        byte[] foo = new byte[1];\n        for (int i = 0; i < 1536; i++) {\n            instance.update(foo, 0, 1, foo, 0);\n        }\n", "refactored_code": "    public static final int SKIP_SIZE = 1536;\n                new SecretKeySpec(key, getAlgorithm()));\n\n        byte[] foo = new byte[1];\n        for (int i = 0; i < SKIP_SIZE; i++) {\n            instance.update(foo, 0, 1, foo, 0);\n        }\n"}
{"magic_number_smell": "\n    protected static class ChaChaEngine {\n        private static final int 64 = 64;\n        private static final int BLOCK_INTS = 64 / Integer.BYTES;\n        private static final int KEY_OFFSET = 4;\n        private static final int KEY_BYTES = 32;\n        private static final int KEY_INTS = KEY_BYTES / Integer.BYTES;", "refactored_code": "        private static final int BLOCK_BYTES = 64;\n\n    protected static class ChaChaEngine {\n        private static final int BLOCK_BYTES = 64;\n        private static final int BLOCK_INTS = BLOCK_BYTES / Integer.BYTES;\n        private static final int KEY_OFFSET = 4;\n        private static final int KEY_BYTES = 32;\n        private static final int KEY_INTS = KEY_BYTES / Integer.BYTES;"}
{"magic_number_smell": "\n    private static final int 4096 = 4096;\n\n    private byte[] tmpbuf = new byte[4096];\n    private Deflater compresser;\n    private Inflater decompresser;\n", "refactored_code": "    private static final int BUF_SIZE = 4096;\n\n    private static final int BUF_SIZE = 4096;\n\n    private byte[] tmpbuf = new byte[BUF_SIZE];\n    private Deflater compresser;\n    private Inflater decompresser;\n"}
{"magic_number_smell": " */\npublic class KeyRandomArt implements AlgorithmNameProvider, KeySizeIndicator {\n    public static final int 8 = 8;\n    public static final int FLDSIZE_Y = 8 + 1;\n    public static final int FLDSIZE_X = 8 * 2 + 1;\n    public static final String AUGMENTATION_STRING = \" .o+=*BOX@%&#/^SE\";\n", "refactored_code": "    public static final int FLDBASE = 8;\n */\npublic class KeyRandomArt implements AlgorithmNameProvider, KeySizeIndicator {\n    public static final int FLDBASE = 8;\n    public static final int FLDSIZE_Y = FLDBASE + 1;\n    public static final int FLDSIZE_X = FLDBASE * 2 + 1;\n    public static final String AUGMENTATION_STRING = \" .o+=*BOX@%&#/^SE\";\n"}
{"magic_number_smell": "                    \"Mismatched key curve name (\" + keyCurveName + \") vs. encoded one (\" + encCurveName + \")\");\n        }\n\n        byte[] octets = KeyEntryResolver.readRLEBytes(keyData, IdentityResourceLoader.MAX_BIGINT_OCTETS_COUNT);\n        ECPoint w;\n        try {\n            w = ECCurves.octetStringToEcPoint(octets);", "refactored_code": "    public static final int MAX_ALLOWED_POINT_SIZE = IdentityResourceLoader.MAX_BIGINT_OCTETS_COUNT;\n                    \"Mismatched key curve name (\" + keyCurveName + \") vs. encoded one (\" + encCurveName + \")\");\n        }\n\n        byte[] octets = KeyEntryResolver.readRLEBytes(keyData, MAX_ALLOWED_POINT_SIZE);\n        ECPoint w;\n        try {\n            w = ECCurves.octetStringToEcPoint(octets);"}
{"magic_number_smell": "\n        boolean noTouchRequired = parseBooleanHeader(headers, NO_TOUCH_REQUIRED_HEADER, false);\n        ECPublicKey ecPublicKey = ECDSAPublicKeyEntryDecoder.INSTANCE.decodePublicKey(ECCurves.nistp256, keyData);\n        String appName = KeyEntryResolver.decodeString(keyData, 1024);\n        return new SkEcdsaPublicKey(appName, noTouchRequired, ecPublicKey);\n    }\n", "refactored_code": "    public static final int MAX_APP_NAME_LENGTH = 1024;\n\n        boolean noTouchRequired = parseBooleanHeader(headers, NO_TOUCH_REQUIRED_HEADER, false);\n        ECPublicKey ecPublicKey = ECDSAPublicKeyEntryDecoder.INSTANCE.decodePublicKey(ECCurves.nistp256, keyData);\n        String appName = KeyEntryResolver.decodeString(keyData, MAX_APP_NAME_LENGTH);\n        return new SkEcdsaPublicKey(appName, noTouchRequired, ecPublicKey);\n    }\n"}
{"magic_number_smell": "        boolean noTouchRequired = parseBooleanHeader(headers, NO_TOUCH_REQUIRED_HEADER, false);\n        EdDSAPublicKey edDSAPublicKey\n                = Ed25519PublicKeyDecoder.INSTANCE.decodePublicKey(session, KeyPairProvider.SSH_ED25519, keyData, headers);\n        String appName = KeyEntryResolver.decodeString(keyData, 1024);\n        return new SkED25519PublicKey(appName, noTouchRequired, edDSAPublicKey);\n    }\n", "refactored_code": "    public static final int MAX_APP_NAME_LENGTH = 1024;\n        boolean noTouchRequired = parseBooleanHeader(headers, NO_TOUCH_REQUIRED_HEADER, false);\n        EdDSAPublicKey edDSAPublicKey\n                = Ed25519PublicKeyDecoder.INSTANCE.decodePublicKey(session, KeyPairProvider.SSH_ED25519, keyData, headers);\n        String appName = KeyEntryResolver.decodeString(keyData, MAX_APP_NAME_LENGTH);\n        return new SkED25519PublicKey(appName, noTouchRequired, edDSAPublicKey);\n    }\n"}
{"magic_number_smell": "    public static final int 24 /* hardwired size for 3DES */ = 24 /* hardwired size for 3DES */;\n    public static final List<Integer> AVAILABLE_KEY_LENGTHS = Collections.unmodifiableList(\n            Collections.singletonList(\n                    Integer.valueOf(24 /* hardwired size for 3DES */)));\n    public static final DESPrivateKeyObfuscator INSTANCE = new DESPrivateKeyObfuscator();\n\n    public DESPrivateKeyObfuscator() {", "refactored_code": "    public static final int DEFAULT_KEY_LENGTH = 24 /* hardwired size for 3DES */;\n    public static final int DEFAULT_KEY_LENGTH = 24 /* hardwired size for 3DES */;\n    public static final List<Integer> AVAILABLE_KEY_LENGTHS = Collections.unmodifiableList(\n            Collections.singletonList(\n                    Integer.valueOf(DEFAULT_KEY_LENGTH)));\n    public static final DESPrivateKeyObfuscator INSTANCE = new DESPrivateKeyObfuscator();\n\n    public DESPrivateKeyObfuscator() {"}
{"magic_number_smell": "   * @return  an encoded salt value\n   */\n  public static String gensalt() {\n      return gensalt(10);\n  }\n\n  /**", "refactored_code": "  private static final int GENSALT_DEFAULT_LOG2_ROUNDS = 10;\n   * @return  an encoded salt value\n   */\n  public static String gensalt() {\n      return gensalt(GENSALT_DEFAULT_LOG2_ROUNDS);\n  }\n\n  /**"}
{"magic_number_smell": "     * the {@code ssh-keygen} command) is usually 16.\n     */\n    public static final int 0xFF = 0xFF;\n    private static final AtomicInteger MAX_ROUNDS_HOLDER = new AtomicInteger(0xFF);\n\n    private byte[] salt;\n    private int numRounds;", "refactored_code": "    public static final int DEFAULT_MAX_ROUNDS = 0xFF;\n     * the {@code ssh-keygen} command) is usually 16.\n     */\n    public static final int DEFAULT_MAX_ROUNDS = 0xFF;\n    private static final AtomicInteger MAX_ROUNDS_HOLDER = new AtomicInteger(DEFAULT_MAX_ROUNDS);\n\n    private byte[] salt;\n    private int numRounds;"}
{"magic_number_smell": "\n    public static final String AES = \"AES\";\n\n    private int kdfRounds = 16;\n\n    public OpenSSHKeyEncryptionContext() {\n        setCipherMode(\"CTR\"); // Set default to CTR, as in OpenSSH", "refactored_code": "    public static final int DEFAULT_KDF_ROUNDS = 16;\n\n    public static final String AES = \"AES\";\n\n    private int kdfRounds = DEFAULT_KDF_ROUNDS;\n\n    public OpenSSHKeyEncryptionContext() {\n        setCipherMode(\"CTR\"); // Set default to CTR, as in OpenSSH"}
{"magic_number_smell": "            KeyEntryResolver.encodeInt(bytes, 1); // 1 key only.\n            KeyEntryResolver.writeRLEBytes(bytes, encodePublicKey(key.getPublic(), keyType));\n            KeyEntryResolver.writeRLEBytes(bytes, privateBytes);\n            write(out, bytes.toByteArray(), 70);\n        } finally {\n            Arrays.fill(privateBytes, (byte) 0);\n        }", "refactored_code": "    public static final int LINE_LENGTH = 70;\n            KeyEntryResolver.encodeInt(bytes, 1); // 1 key only.\n            KeyEntryResolver.writeRLEBytes(bytes, encodePublicKey(key.getPublic(), keyType));\n            KeyEntryResolver.writeRLEBytes(bytes, privateBytes);\n            write(out, bytes.toByteArray(), LINE_LENGTH);\n        } finally {\n            Arrays.fill(privateBytes, (byte) 0);\n        }"}
{"magic_number_smell": "    }\n\n    /**\n     * Attempts to parse an {@code 7} message\n     *\n     * @param  buffer      The {@link Buffer} containing the message\n     * @return             A {@link List} of key/value &quot;pairs&quot; where key=the extension name, value=the parsed", "refactored_code": "    public static final byte SSH_MSG_EXT_INFO = 7;\n    }\n\n    /**\n     * Attempts to parse an {@code SSH_MSG_EXT_INFO} message\n     *\n     * @param  buffer      The {@link Buffer} containing the message\n     * @return             A {@link List} of key/value &quot;pairs&quot; where key=the extension name, value=the parsed"}
{"magic_number_smell": "\n    @Override\n    public void init(byte[] key) throws Exception {\n        if (NumberUtils.length(key) != 32) {\n            throw new InvalidKeyException(\"Poly1305 key must be 32 bytes\");\n        }\n", "refactored_code": "    public static final int KEY_BYTES = 32;\n\n    @Override\n    public void init(byte[] key) throws Exception {\n        if (NumberUtils.length(key) != KEY_BYTES) {\n            throw new InvalidKeyException(\"Poly1305 key must be 32 bytes\");\n        }\n"}
{"magic_number_smell": "        long counter = data.getUInt();\n\n        // Return false if we don't understand the flags\n        if ((flags & ~0x01) != 0) {\n            return false;\n        }\n        // Check user-presence flag is present if required by the public key", "refactored_code": "    private static final int FLAG_USER_PRESENCE = 0x01;\n        long counter = data.getUInt();\n\n        // Return false if we don't understand the flags\n        if ((flags & ~FLAG_USER_PRESENCE) != 0) {\n            return false;\n        }\n        // Check user-presence flag is present if required by the public key"}
{"magic_number_smell": "\n    public static final int 40 = 40;\n    // result must be 40 bytes, but length of r and s may not exceed 20 bytes\n    public static final int MAX_SIGNATURE_VALUE_LENGTH = 40 / 2;\n\n    public SignatureDSA() {\n        this(DEFAULT_ALGORITHM);", "refactored_code": "    public static final int DSA_SIGNATURE_LENGTH = 40;\n\n    public static final int DSA_SIGNATURE_LENGTH = 40;\n    // result must be 40 bytes, but length of r and s may not exceed 20 bytes\n    public static final int MAX_SIGNATURE_VALUE_LENGTH = DSA_SIGNATURE_LENGTH / 2;\n\n    public SignatureDSA() {\n        this(DEFAULT_ALGORITHM);"}
{"magic_number_smell": "    }\n\n    public static boolean isValidUint32Value(long value) {\n        return (value >= 0L) && (value <= 0x0FFFFFFFFL);\n    }\n}\n", "refactored_code": "    public static final long MAX_UINT32_VALUE = 0x0FFFFFFFFL;\n    }\n\n    public static boolean isValidUint32Value(long value) {\n        return (value >= 0L) && (value <= MAX_UINT32_VALUE);\n    }\n}\n"}
{"magic_number_smell": "    private int wpos;\n\n    /**\n     * Allocates a buffer for writing purposes with {@value #256} bytes\n     */\n    public ByteArrayBuffer() {\n        this(256, false);", "refactored_code": "    public static final int DEFAULT_SIZE = 256;\n    private int wpos;\n\n    /**\n     * Allocates a buffer for writing purposes with {@value #DEFAULT_SIZE} bytes\n     */\n    public ByteArrayBuffer() {\n        this(DEFAULT_SIZE, false);"}
{"magic_number_smell": "    /**\n     * A {@link FileSnapshot} describing a non-existing file.\n     */\n    public static final FileSnapshot NO_FILE = new FileSnapshot(Instant.now(), null, -1L, null);\n\n    // FAT has a truly crude timestamp resolution.\n    private static final Duration WORST_CASE_TIMESTAMP_RESOLUTION = Duration.ofMillis(2000);", "refactored_code": "    public static final long UNKNOWN_SIZE = -1L;\n    /**\n     * A {@link FileSnapshot} describing a non-existing file.\n     */\n    public static final FileSnapshot NO_FILE = new FileSnapshot(Instant.now(), null, UNKNOWN_SIZE, null);\n\n    // FAT has a truly crude timestamp resolution.\n    private static final Duration WORST_CASE_TIMESTAMP_RESOLUTION = Duration.ofMillis(2000);"}
{"magic_number_smell": "    }\n\n    public static long copy(InputStream source, OutputStream sink) throws IOException {\n        return copy(source, sink, 8192);\n    }\n\n    public static long copy(InputStream source, OutputStream sink, int bufferSize) throws IOException {", "refactored_code": "    public static final int DEFAULT_COPY_SIZE = 8192;\n    }\n\n    public static long copy(InputStream source, OutputStream sink) throws IOException {\n        return copy(source, sink, DEFAULT_COPY_SIZE);\n    }\n\n    public static long copy(InputStream source, OutputStream sink, int bufferSize) throws IOException {"}
{"magic_number_smell": "     * ------------------------------------------------- </pre>\n     */\n    public ASN1Object(byte tag, int len, byte... data) {\n        this(ASN1Class.fromDERValue(tag), ASN1Type.fromDERValue(tag), (tag & 0x20) == 0x20, len, data);\n    }\n\n    public ASN1Object(ASN1Class c, ASN1Type t, boolean ctored, int len, byte... data) {", "refactored_code": "    public static final byte CONSTRUCTED = 0x20;\n     * ------------------------------------------------- </pre>\n     */\n    public ASN1Object(byte tag, int len, byte... data) {\n        this(ASN1Class.fromDERValue(tag), ASN1Type.fromDERValue(tag), (tag & CONSTRUCTED) == CONSTRUCTED, len, data);\n    }\n\n    public ASN1Object(ASN1Class c, ASN1Type t, boolean ctored, int len, byte... data) {"}
{"magic_number_smell": "            throw new StreamCorruptedException(\"Invalid DER: length not in shortest form: \" + len);\n        }\n\n        if (len > 2 * Short.MAX_VALUE) {\n            throw new StreamCorruptedException(\n                    \"Invalid DER: data length too big: \" + len + \" (max=\" + 2 * Short.MAX_VALUE + \")\");\n        }", "refactored_code": "    public static final int MAX_DER_VALUE_LENGTH = 2 * Short.MAX_VALUE;\n            throw new StreamCorruptedException(\"Invalid DER: length not in shortest form: \" + len);\n        }\n\n        if (len > MAX_DER_VALUE_LENGTH) {\n            throw new StreamCorruptedException(\n                    \"Invalid DER: data length too big: \" + len + \" (max=\" + MAX_DER_VALUE_LENGTH + \")\");\n        }"}
{"magic_number_smell": "\n    };\n\n    private static final long 1L = 9207771015837755402L;\n\n    protected SimplifiedLoggerSkeleton(String name) {\n        super(name);", "refactored_code": "        private static final long serialVersionUID = 1L;\n\n    };\n\n    private static final long serialVersionUID = 9207771015837755402L;\n\n    protected SimplifiedLoggerSkeleton(String name) {\n        super(name);"}
{"magic_number_smell": "    private String protocol;\n    private String host = DEFAULT_HOST;\n    private int port;\n    private long connectTimeout = TimeUnit.SECONDS.toMillis(5L);\n    private long readTimeout = DEFAULT_READ_TIMEOUT;\n\n    public NetworkConnector() {", "refactored_code": "    public static final long DEFAULT_CONNECT_TIMEOUT = TimeUnit.SECONDS.toMillis(5L);\n    private String protocol;\n    private String host = DEFAULT_HOST;\n    private int port;\n    private long connectTimeout = DEFAULT_CONNECT_TIMEOUT;\n    private long readTimeout = DEFAULT_READ_TIMEOUT;\n\n    public NetworkConnector() {"}
{"magic_number_smell": "        }\n\n        int numOctests = octetList.size();\n        if (numOctests > 8) {\n            return false;\n        }\n", "refactored_code": "    public static final int IPV6_MAX_HEX_GROUPS = 8;\n        }\n\n        int numOctests = octetList.size();\n        if (numOctests > IPV6_MAX_HEX_GROUPS) {\n            return false;\n        }\n"}
{"magic_number_smell": "     * @return The minimum supported Diffie-Hellman Group Exchange key size, or non-positive if not supported\n     */\n    public static int getMinDHGroupExchangeKeySize() {\n        return resolveDHGEXKeySizeValue(MIN_DHG_KEY_SIZE_HOLDER, MIN_DHGEX_KEY_SIZE_PROP, 2048);\n    }\n\n    /**", "refactored_code": "    public static final int MIN_DHGEX_KEY_SIZE = 2048;\n     * @return The minimum supported Diffie-Hellman Group Exchange key size, or non-positive if not supported\n     */\n    public static int getMinDHGroupExchangeKeySize() {\n        return resolveDHGEXKeySizeValue(MIN_DHG_KEY_SIZE_HOLDER, MIN_DHGEX_KEY_SIZE_PROP, MIN_DHGEX_KEY_SIZE);\n    }\n\n    /**"}
{"magic_number_smell": "    public EdDSAPublicKey decodePublicKey(\n            SessionContext session, String keyType, InputStream keyData, Map<String, String> headers)\n            throws IOException, GeneralSecurityException {\n        byte[] seed = KeyEntryResolver.readRLEBytes(keyData, 1024);\n        return EdDSAPublicKey.class.cast(SecurityUtils.generateEDDSAPublicKey(keyType, seed));\n    }\n", "refactored_code": "    public static final int MAX_ALLOWED_SEED_LEN = 1024; // in reality it is much less than this\n    public EdDSAPublicKey decodePublicKey(\n            SessionContext session, String keyType, InputStream keyData, Map<String, String> headers)\n            throws IOException, GeneralSecurityException {\n        byte[] seed = KeyEntryResolver.readRLEBytes(keyData, MAX_ALLOWED_SEED_LEN);\n        return EdDSAPublicKey.class.cast(SecurityUtils.generateEDDSAPublicKey(keyType, seed));\n    }\n"}
{"magic_number_smell": "    }\n\n    public static boolean isEDDSAKey(Key key) {\n        return getEDDSAKeySize(key) == 256;\n    }\n\n    public static int getEDDSAKeySize(Key key) {", "refactored_code": "    public static final int KEY_SIZE = 256;\n    }\n\n    public static boolean isEDDSAKey(Key key) {\n        return getEDDSAKeySize(key) == KEY_SIZE;\n    }\n\n    public static int getEDDSAKeySize(Key key) {"}
{"magic_number_smell": "    public static final OpenSSHEd25519PrivateKeyEntryDecoder INSTANCE = new OpenSSHEd25519PrivateKeyEntryDecoder();\n    private static final int 32 = 32;\n    private static final int SK_SIZE = 32;\n    private static final int KEYPAIR_SIZE = 32 + SK_SIZE;\n\n    public OpenSSHEd25519PrivateKeyEntryDecoder() {\n        super(EdDSAPublicKey.class, EdDSAPrivateKey.class,", "refactored_code": "    private static final int PK_SIZE = 32;\n    public static final OpenSSHEd25519PrivateKeyEntryDecoder INSTANCE = new OpenSSHEd25519PrivateKeyEntryDecoder();\n    private static final int PK_SIZE = 32;\n    private static final int SK_SIZE = 32;\n    private static final int KEYPAIR_SIZE = PK_SIZE + SK_SIZE;\n\n    public OpenSSHEd25519PrivateKeyEntryDecoder() {\n        super(EdDSAPublicKey.class, EdDSAPrivateKey.class,"}
{"magic_number_smell": "                    throws IOException {\n                switch (reportedResult) {\n                    case RETRY:\n                        if (retryIndex >= 3) {\n                            return PASSWORD;\n                        }\n                        // fall through ...", "refactored_code": "    private static final int MAX_RETRIES = 3;\n                    throws IOException {\n                switch (reportedResult) {\n                    case RETRY:\n                        if (retryIndex >= MAX_RETRIES) {\n                            return PASSWORD;\n                        }\n                        // fall through ..."}
{"magic_number_smell": "\n    public static final String DEFAULT_TEST_HOST_KEY_PROVIDER_ALGORITHM = KeyUtils.EC_ALGORITHM;\n    public static final int 256 = 256;\n    public static final String DEFAULT_TEST_HOST_KEY_TYPE = ECCurves.fromCurveSize(256).getKeyType();\n\n    // uses a cached instance to avoid re-creating the keys as it is a time-consuming effort\n    private static final AtomicReference<KeyPairProvider> KEYPAIR_PROVIDER_HOLDER = new AtomicReference<>();", "refactored_code": "    public static final int DEFAULT_TEST_HOST_KEY_SIZE = 256;\n\n    public static final String DEFAULT_TEST_HOST_KEY_PROVIDER_ALGORITHM = KeyUtils.EC_ALGORITHM;\n    public static final int DEFAULT_TEST_HOST_KEY_SIZE = 256;\n    public static final String DEFAULT_TEST_HOST_KEY_TYPE = ECCurves.fromCurveSize(DEFAULT_TEST_HOST_KEY_SIZE).getKeyType();\n\n    // uses a cached instance to avoid re-creating the keys as it is a time-consuming effort\n    private static final AtomicReference<KeyPairProvider> KEYPAIR_PROVIDER_HOLDER = new AtomicReference<>();"}
{"magic_number_smell": "            return true;\n        }\n\n        StringBuilder proxyPayload = new StringBuilder(Byte.MAX_VALUE);\n        while ((proxyPayload.length() < Byte.MAX_VALUE) && (buffer.available() > 0)) {\n            char ch = (char) buffer.getUByte();\n            if (ch != '\\n') {", "refactored_code": "    public static final int MAX_PROXY_HEADER_LENGTH = Byte.MAX_VALUE;\n            return true;\n        }\n\n        StringBuilder proxyPayload = new StringBuilder(MAX_PROXY_HEADER_LENGTH);\n        while ((proxyPayload.length() < MAX_PROXY_HEADER_LENGTH) && (buffer.available() > 0)) {\n            char ch = (char) buffer.getUByte();\n            if (ch != '\\n') {"}
{"magic_number_smell": "    public static ProxyProtocolException buildVersionOrCommand(Logger log, ServerSession session, byte value) {\n        byte valueLow = (byte) (value & 0x0F);\n        byte valueHeight = (byte) (value >> 4);\n        if (valueHeight != 2) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"readProxyV2Header(session={}) mismatched version in proxy header: expected={}, actual={}\",\n                        session,", "refactored_code": "    public static final int PROXY_PROTOCOL_VERSION_2 = 2;\n    public static ProxyProtocolException buildVersionOrCommand(Logger log, ServerSession session, byte value) {\n        byte valueLow = (byte) (value & 0x0F);\n        byte valueHeight = (byte) (value >> 4);\n        if (valueHeight != PROXY_PROTOCOL_VERSION_2) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"readProxyV2Header(session={}) mismatched version in proxy header: expected={}, actual={}\",\n                        session,"}
{"magic_number_smell": "    protected Buffer waitForMessageBuffer() throws IOException {\n        Session session = getSession();\n        long idleTimeout = PropertyResolverUtils.getLongProperty(\n                session, MESSAGE_POLL_FREQUENCY, TimeUnit.MINUTES.toMillis(2L));\n        if (idleTimeout <= 0L) {\n            idleTimeout = TimeUnit.MINUTES.toMillis(2L);\n        }", "refactored_code": "    public static final long DEFAULT_MESSAGE_POLL_FREQUENCY = TimeUnit.MINUTES.toMillis(2L);\n    protected Buffer waitForMessageBuffer() throws IOException {\n        Session session = getSession();\n        long idleTimeout = PropertyResolverUtils.getLongProperty(\n                session, MESSAGE_POLL_FREQUENCY, DEFAULT_MESSAGE_POLL_FREQUENCY);\n        if (idleTimeout <= 0L) {\n            idleTimeout = DEFAULT_MESSAGE_POLL_FREQUENCY;\n        }"}
{"magic_number_smell": "    protected Buffer waitForMessageBuffer() throws IOException {\n        FactoryManager mgr = getFactoryManager();\n        long idleTimeout = PropertyResolverUtils.getLongProperty(\n                mgr, MESSAGE_POLL_FREQUENCY, TimeUnit.MINUTES.toMillis(2L));\n        if (idleTimeout <= 0L) {\n            idleTimeout = TimeUnit.MINUTES.toMillis(2L);\n        }", "refactored_code": "    public static final long DEFAULT_MESSAGE_POLL_FREQUENCY = TimeUnit.MINUTES.toMillis(2L);\n    protected Buffer waitForMessageBuffer() throws IOException {\n        FactoryManager mgr = getFactoryManager();\n        long idleTimeout = PropertyResolverUtils.getLongProperty(\n                mgr, MESSAGE_POLL_FREQUENCY, DEFAULT_MESSAGE_POLL_FREQUENCY);\n        if (idleTimeout <= 0L) {\n            idleTimeout = DEFAULT_MESSAGE_POLL_FREQUENCY;\n        }"}
{"magic_number_smell": "     *\n     * @see #MIN_FORWARDER_BUF_SIZE\n     * @see #MAX_FORWARDER_BUF_SIZE\n     * @see #1024\n     */\n    public static final Property<Integer> FORWARDER_BUFFER_SIZE\n            = Property.integer(\"channel-agent-fwd-buf-size\", 1024);", "refactored_code": "    public static final int DEFAULT_FORWARDER_BUF_SIZE = 1024;\n     *\n     * @see #MIN_FORWARDER_BUF_SIZE\n     * @see #MAX_FORWARDER_BUF_SIZE\n     * @see #DEFAULT_FORWARDER_BUF_SIZE\n     */\n    public static final Property<Integer> FORWARDER_BUFFER_SIZE\n            = Property.integer(\"channel-agent-fwd-buf-size\", DEFAULT_FORWARDER_BUF_SIZE);"}
{"magic_number_smell": "\n            // Discard moduli types which are not safe\n            int type = Integer.parseInt(parts[1]);\n            if (type != 2) {\n                continue;\n            }\n", "refactored_code": "    public static final int MODULI_TYPE_SAFE = 2;\n\n            // Discard moduli types which are not safe\n            int type = Integer.parseInt(parts[1]);\n            if (type != MODULI_TYPE_SAFE) {\n                continue;\n            }\n"}
{"magic_number_smell": "\n        byte[] msg = IoUtils.toByteArray(getClass().getResourceAsStream(\"/big-msg.txt\"));\n        sshServer.setShellFactory(\n                channel -> new FloodingAsyncCommand(msg, BIG_MSG_SEND_COUNT, '#'));\n\n        sshServer.setKeyPairProvider(new SimpleGeneratorHostKeyProvider());\n        sshServer.start();", "refactored_code": "    public static final byte END_FILE = '#';\n\n        byte[] msg = IoUtils.toByteArray(getClass().getResourceAsStream(\"/big-msg.txt\"));\n        sshServer.setShellFactory(\n                channel -> new FloodingAsyncCommand(msg, BIG_MSG_SEND_COUNT, END_FILE));\n\n        sshServer.setKeyPairProvider(new SimpleGeneratorHostKeyProvider());\n        sshServer.start();"}
{"magic_number_smell": "\n    @AfterClass\n    public static void stopServer() throws IOException {\n        if (!server.close(true).await(TimeUnit.SECONDS.toMillis(10L))) {\n            LOG.warn(\"Failed to close server within {} sec.\", TimeUnit.MILLISECONDS.toSeconds(TimeUnit.SECONDS.toMillis(10L)));\n        }\n    }", "refactored_code": "    private static final long TIMEOUT = TimeUnit.SECONDS.toMillis(10L);\n\n    @AfterClass\n    public static void stopServer() throws IOException {\n        if (!server.close(true).await(TIMEOUT)) {\n            LOG.warn(\"Failed to close server within {} sec.\", TimeUnit.MILLISECONDS.toSeconds(TIMEOUT));\n        }\n    }"}
{"magic_number_smell": "        server = SshServer.setUpDefaultServer();\n        server.setPasswordAuthenticator((u, p, s) -> true);\n        server.setKeyPairProvider(new SimpleGeneratorHostKeyProvider());\n        server.setNioWorkers(8);\n        server.setForwardingFilter(AcceptAllForwardingFilter.INSTANCE);\n        server.start();\n        sshServerPort = server.getPort();", "refactored_code": "    private static final int SSHD_NIO_WORKERS = 8;\n        server = SshServer.setUpDefaultServer();\n        server.setPasswordAuthenticator((u, p, s) -> true);\n        server.setKeyPairProvider(new SimpleGeneratorHostKeyProvider());\n        server.setNioWorkers(SSHD_NIO_WORKERS);\n        server.setForwardingFilter(AcceptAllForwardingFilter.INSTANCE);\n        server.start();\n        sshServerPort = server.getPort();"}
{"magic_number_smell": "\n        List<String> list = new ArrayList<>();\n        StringBuilder sb = new StringBuilder();\n        int expecting = 0x001 | DELIMITER | STARTQUOTE;\n        boolean isEscaped = false;\n        for (int i = 0; i < value.length(); i++) {\n            char c = value.charAt(i);", "refactored_code": "    public static final int CHAR = 0x001;\n\n        List<String> list = new ArrayList<>();\n        StringBuilder sb = new StringBuilder();\n        int expecting = CHAR | DELIMITER | STARTQUOTE;\n        boolean isEscaped = false;\n        for (int i = 0; i < value.length(); i++) {\n            char c = value.charAt(i);"}
{"magic_number_smell": "\n    public LdapNetworkConnector() {\n        setProtocol(DEFAULT_LDAP_PROTOCOL);\n        setPort(389);\n        setSearchScope(DEFAULT_LDAP_SEARCH_SCOPE);\n        setLdapFactory(DEFAULT_LDAP_FACTORY_PROPVAL);\n        setTimeLimit(DEFAULT_LDAP_TIME_LIMIT);", "refactored_code": "    public static final int DEFAULT_LDAP_PORT = 389;\n\n    public LdapNetworkConnector() {\n        setProtocol(DEFAULT_LDAP_PROTOCOL);\n        setPort(DEFAULT_LDAP_PORT);\n        setSearchScope(DEFAULT_LDAP_SEARCH_SCOPE);\n        setLdapFactory(DEFAULT_LDAP_FACTORY_PROPVAL);\n        setTimeLimit(DEFAULT_LDAP_TIME_LIMIT);"}
{"magic_number_smell": "                    case RETRY: {\n                        int count = retriesCount.incrementAndGet();\n                        assertEquals(\"Mismatched retries count\", count, retryIndex + 1);\n                        if (count == 3) {\n                            return PASSWORD;\n                        } else {\n                            return \"retry #\" + count;", "refactored_code": "    private final int maxRetries = 3;\n                    case RETRY: {\n                        int count = retriesCount.incrementAndGet();\n                        assertEquals(\"Mismatched retries count\", count, retryIndex + 1);\n                        if (count == maxRetries) {\n                            return PASSWORD;\n                        } else {\n                            return \"retry #\" + count;"}
{"magic_number_smell": "     * Default size (in bytes) of send / receive buffer size\n     */\n    public static final int IoUtils.DEFAULT_COPY_SIZE = IoUtils.DEFAULT_COPY_SIZE;\n    public static final int DEFAULT_RECEIVE_BUFFER_SIZE = IoUtils.DEFAULT_COPY_SIZE;\n    public static final int DEFAULT_SEND_BUFFER_SIZE = IoUtils.DEFAULT_COPY_SIZE;\n\n    /**", "refactored_code": "    public static final int DEFAULT_COPY_BUFFER_SIZE = IoUtils.DEFAULT_COPY_SIZE;\n     * Default size (in bytes) of send / receive buffer size\n     */\n    public static final int DEFAULT_COPY_BUFFER_SIZE = IoUtils.DEFAULT_COPY_SIZE;\n    public static final int DEFAULT_RECEIVE_BUFFER_SIZE = DEFAULT_COPY_BUFFER_SIZE;\n    public static final int DEFAULT_SEND_BUFFER_SIZE = DEFAULT_COPY_BUFFER_SIZE;\n\n    /**"}
{"magic_number_smell": "    public static final int WARNING = 1;\n    public static final int ERROR = 2;\n\n    public static final ScpAckInfo OK_ACK_INFO = new ScpAckInfo(0, null);\n\n    private final int statusCode;\n    private final String line;", "refactored_code": "    public static final int OK = 0;\n    public static final int WARNING = 1;\n    public static final int ERROR = 2;\n\n    public static final ScpAckInfo OK_ACK_INFO = new ScpAckInfo(OK, null);\n\n    private final int statusCode;\n    private final String line;"}
{"magic_number_smell": "        for (PosixFilePermission p : perms) {\n            switch (p) {\n                case OWNER_READ:\n                    pf |= 0000400;\n                    break;\n                case OWNER_WRITE:\n                    pf |= S_IWUSR;", "refactored_code": "    public static final int S_IRUSR = 0000400;\n        for (PosixFilePermission p : perms) {\n            switch (p) {\n                case OWNER_READ:\n                    pf |= S_IRUSR;\n                    break;\n                case OWNER_WRITE:\n                    pf |= S_IWUSR;"}
{"magic_number_smell": "\n    CharsetDecoder decoder;\n\n    ByteBuffer bytes = ByteBuffer.allocate(4);\n\n    char pending = (char) -1;\n", "refactored_code": "    private static final int BUFFER_SIZE = 4;\n\n    CharsetDecoder decoder;\n\n    ByteBuffer bytes = ByteBuffer.allocate(BUFFER_SIZE);\n\n    char pending = (char) -1;\n"}
{"magic_number_smell": "     */\n    public static final Property<Integer> MAX_READDATA_PACKET_LENGTH\n            = Property.validating(Property.integer(\"sftp-max-readdata-packet-length\", 63 * 1024),\n                    l -> ValidateUtils.checkTrue(l >= 32768, \"Length is below min.: %d\", l));\n\n    public static final int MIN_WRITEDATA_PACKET_LENGTH = 32768;\n    /**", "refactored_code": "    public static final int MIN_READDATA_PACKET_LENGTH = 32768;\n     */\n    public static final Property<Integer> MAX_READDATA_PACKET_LENGTH\n            = Property.validating(Property.integer(\"sftp-max-readdata-packet-length\", 63 * 1024),\n                    l -> ValidateUtils.checkTrue(l >= MIN_READDATA_PACKET_LENGTH, \"Length is below min.: %d\", l));\n\n    public static final int MIN_WRITEDATA_PACKET_LENGTH = 32768;\n    /**"}
{"magic_number_smell": "        sb.append(' ');\n\n        long nowTime = System.currentTimeMillis();\n        if (Math.abs(nowTime - millis) > 183L * 24L * 60L * 60L * 1000L) {\n\n            // year\n            int year = cal.get(Calendar.YEAR);", "refactored_code": "    public static final long SIX_MONTHS = 183L * 24L * 60L * 60L * 1000L;\n        sb.append(' ');\n\n        long nowTime = System.currentTimeMillis();\n        if (Math.abs(nowTime - millis) > SIX_MONTHS) {\n\n            // year\n            int year = cal.get(Calendar.YEAR);"}
{"magic_number_smell": "        if (l1 != l2) {\n            fail(\"Size differ: \" + l1 + \" / \" + l2);\n        }\n        byte[] buffer1 = new byte[8192];\n        byte[] buffer2 = new byte[8192];\n        int index = 0;\n        try (InputStream in1 = Files.newInputStream(path);", "refactored_code": "    private static final int BUFFER_SIZE = 8192;\n        if (l1 != l2) {\n            fail(\"Size differ: \" + l1 + \" / \" + l2);\n        }\n        byte[] buffer1 = new byte[BUFFER_SIZE];\n        byte[] buffer2 = new byte[BUFFER_SIZE];\n        int index = 0;\n        try (InputStream in1 = Files.newInputStream(path);"}
{"magic_number_smell": "                        SshdSocketAddress.LOCALHOST_NAME, SshConstants.DEFAULT_PORT, \"J@ck\", \"d@Ripper\",\n                        new HashMap<String, Object>() {\n                            // not serializing it\n                            private static final long 1L = 1L;\n\n                            {\n                                put(\"param1\", \"1st\");", "refactored_code": "            private static final long serialVersionUID = 1L;\n                        SshdSocketAddress.LOCALHOST_NAME, SshConstants.DEFAULT_PORT, \"J@ck\", \"d@Ripper\",\n                        new HashMap<String, Object>() {\n                            // not serializing it\n                            private static final long serialVersionUID = 1L;\n\n                            {\n                                put(\"param1\", \"1st\");"}
{"magic_number_smell": "    public static final boolean FOUND = true;\n    public static final boolean END_OF_OUTPUT = false;\n    private static final int 1024 = 1024;\n    private CyclicCharBuffer buffer = new CyclicCharBuffer(1024);\n\n    public OutputReader(Reader output) {\n        super(output);", "refactored_code": "    private static final int BUFFER_SIZE = 1024;\n    public static final boolean FOUND = true;\n    public static final boolean END_OF_OUTPUT = false;\n    private static final int BUFFER_SIZE = 1024;\n    private CyclicCharBuffer buffer = new CyclicCharBuffer(BUFFER_SIZE);\n\n    public OutputReader(Reader output) {\n        super(output);"}
{"magic_number_smell": "\n    @Test\n    public void initially_the_buffer_is_empty() {\n        CyclicCharBuffer buffer = new CyclicCharBuffer(100);\n\n        assertHasString(\"\", buffer);\n    }", "refactored_code": "    private static final int UNUSED_CAPACITY = 100;\n\n    @Test\n    public void initially_the_buffer_is_empty() {\n        CyclicCharBuffer buffer = new CyclicCharBuffer(UNUSED_CAPACITY);\n\n        assertHasString(\"\", buffer);\n    }"}
{"magic_number_smell": "    private static final int configureTwoMaxLabelPairs = 2;\n    private static final int noCategoryWideMaxConcurrentPerNode = 0;\n    private static final int someCategoryWideMaxConcurrentPerNode = 1;\n    private static final int greaterCategoryWideMaxConcurrentPerNode = 1 + 1;\n\n    @Rule\n    public JenkinsRule r = new JenkinsRule();", "refactored_code": "    private static final int configureOneMaxLabelPair = 1;\n    private static final int configureTwoMaxLabelPairs = 2;\n    private static final int noCategoryWideMaxConcurrentPerNode = 0;\n    private static final int someCategoryWideMaxConcurrentPerNode = 1;\n    private static final int greaterCategoryWideMaxConcurrentPerNode = configureOneMaxLabelPair + 1;\n\n    @Rule\n    public JenkinsRule r = new JenkinsRule();"}
{"magic_number_smell": "\t\tif (p.isOurPlayer()) {\n\t\t\tif (p.getX() > p.getServerX()) {\n\t\t\t\tm_mapMatrix.getCurrentMap().setXOffset(\n\t\t\t\t\t\t(m_mapMatrix.getCurrentMap().getXOffset() + 4),\n\t\t\t\t\t\ttrue);\n\t\t\t} else if (p.getX() < p.getServerX()) {\n\t\t\t\tm_mapMatrix.getCurrentMap().setXOffset(", "refactored_code": "\tprivate static final int ANIMATION_INCREMENT = 4;\n\t\tif (p.isOurPlayer()) {\n\t\t\tif (p.getX() > p.getServerX()) {\n\t\t\t\tm_mapMatrix.getCurrentMap().setXOffset(\n\t\t\t\t\t\t(m_mapMatrix.getCurrentMap().getXOffset() + ANIMATION_INCREMENT),\n\t\t\t\t\t\ttrue);\n\t\t\t} else if (p.getX() < p.getServerX()) {\n\t\t\t\tm_mapMatrix.getCurrentMap().setXOffset("}
{"magic_number_smell": "    /**\n     * The message digest size (in bytes)\n     */\n    public static final int DIGESTBYTES = 512 >>> 3;\n\n    /**\n     * The number of rounds of the internal dedicated block cipher.", "refactored_code": "    public static final int DIGESTBITS = 512;\n    /**\n     * The message digest size (in bytes)\n     */\n    public static final int DIGESTBYTES = DIGESTBITS >>> 3;\n\n    /**\n     * The number of rounds of the internal dedicated block cipher."}
{"magic_number_smell": "\t\t\thideHUDElements();\n\t\t} else {\n\t\t\thideHUDElements();\n\t\t\tm_requestsForm.setWidth(32*7);\n\t\t\tm_requestsForm.setLocation(m_buttons[4].getX(),  67 - getTitleBar().getHeight());\n\t\t\tm_requestsForm.setDraggable(false);\n\t\t\tgetDisplay().add(m_requestsForm);", "refactored_code": "    private static final int UI_WIDTH = 32*7;\n\t\t\thideHUDElements();\n\t\t} else {\n\t\t\thideHUDElements();\n\t\t\tm_requestsForm.setWidth(UI_WIDTH);\n\t\t\tm_requestsForm.setLocation(m_buttons[4].getX(),  67 - getTitleBar().getHeight());\n\t\t\tm_requestsForm.setDraggable(false);\n\t\t\tgetDisplay().add(m_requestsForm);"}
{"magic_number_smell": "     */\n    public static final int 1 = 1;\n    public static final int GENDER_FEMALE = 2;\n    public static final int GENDER_BOTH = 1 | GENDER_FEMALE;\n    public static final int GENDER_NONE = 0;\n    \n    @ElementArray", "refactored_code": "    public static final int GENDER_MALE = 1;\n     */\n    public static final int GENDER_MALE = 1;\n    public static final int GENDER_FEMALE = 2;\n    public static final int GENDER_BOTH = GENDER_MALE | GENDER_FEMALE;\n    public static final int GENDER_NONE = 0;\n    \n    @ElementArray"}
{"magic_number_smell": "    private final transient Object appletLock = new Object(); \n    protected class AccessibleApplet extends Panel.AccessibleAWTPanel {\n\n        private static final long -5836846270535785031L = 8127374778187708896L;\n        \n        protected AccessibleApplet() {\n            super();", "refactored_code": "    private static final long serialVersionUID = -5836846270535785031L;\n    private final transient Object appletLock = new Object(); \n    protected class AccessibleApplet extends Panel.AccessibleAWTPanel {\n\n        private static final long serialVersionUID = 8127374778187708896L;\n        \n        protected AccessibleApplet() {\n            super();"}
{"magic_number_smell": "        this.status.setText(status);\n    }\n\n    public void appletResize(int 1, int width, int height) {\n        if (1 != this.1) {\n            return;\n        }", "refactored_code": "    private static final int appletId = 1;\n        this.status.setText(status);\n    }\n\n    public void appletResize(int appletId, int width, int height) {\n        if (appletId != this.appletId) {\n            return;\n        }"}
{"magic_number_smell": "     */\n    public Deflater(int level, boolean noHeader) {\n        super();\n        if (level < DEFAULT_COMPRESSION || level > 9) {\n            throw new IllegalArgumentException();\n        }\n        compressLevel = level;", "refactored_code": "    public static final int BEST_COMPRESSION = 9;\n     */\n    public Deflater(int level, boolean noHeader) {\n        super();\n        if (level < DEFAULT_COMPRESSION || level > BEST_COMPRESSION) {\n            throw new IllegalArgumentException();\n        }\n        compressLevel = level;"}
{"magic_number_smell": "        if ((flags & FNAME) != 0) {\n            readZeroTerminated(hcrc);\n        }\n        if ((flags & 16) != 0) {\n            readZeroTerminated(hcrc);\n        }\n        if (hcrc) {", "refactored_code": "    private static final int FCOMMENT = 16;\n        if ((flags & FNAME) != 0) {\n            readZeroTerminated(hcrc);\n        }\n        if ((flags & FCOMMENT) != 0) {\n            readZeroTerminated(hcrc);\n        }\n        if (hcrc) {"}
{"magic_number_smell": "    /**\n     * Gets the compression method for this {@code ZipEntry}.\n     *\n     * @return the compression method, either {@code 8}, {@code STORED}\n     *         or -1 if the compression method has not been set.\n     */\n    public int getMethod() {", "refactored_code": "    public static final int DEFLATED = 8;\n    /**\n     * Gets the compression method for this {@code ZipEntry}.\n     *\n     * @return the compression method, either {@code DEFLATED}, {@code STORED}\n     *         or -1 if the compression method has not been set.\n     */\n    public int getMethod() {"}
{"magic_number_smell": "     *             if an {@code IOException} occurs.\n     */\n    public ZipFile(File file) throws ZipException, IOException {\n        this(file, 1);\n    }\n\n    /**", "refactored_code": "    public static final int OPEN_READ = 1;\n     *             if an {@code IOException} occurs.\n     */\n    public ZipFile(File file) throws ZipException, IOException {\n        this(file, OPEN_READ);\n    }\n\n    /**"}
{"magic_number_smell": "\n    private final Vector<String> entries = new Vector<String>();\n\n    private int compressMethod = 8;\n\n    private int compressLevel = Deflater.DEFAULT_COMPRESSION;\n", "refactored_code": "    public static final int DEFLATED = 8;\n\n    private final Vector<String> entries = new Vector<String>();\n\n    private int compressMethod = DEFLATED;\n\n    private int compressLevel = Deflater.DEFAULT_COMPRESSION;\n"}
{"magic_number_smell": "            count++;\n            try {\n                zipEntry = jin.getNextEntry();\n                if (count == 2 + 1) {\n                    fail(\"Should throw Security Exception\");\n                }\n            } catch (SecurityException e) {", "refactored_code": "    private static final int indexofDSA = 2;\n            count++;\n            try {\n                zipEntry = jin.getNextEntry();\n                if (count == indexofDSA + 1) {\n                    fail(\"Should throw Security Exception\");\n                }\n            } catch (SecurityException e) {"}
{"magic_number_smell": "\n    private static final class CredOwner implements Serializable {\n\n        private static final long 5284372143517237068L = -5607449830436408266L;\n\n        String principalClass;\n", "refactored_code": "    private static final long serialVersionUID = 5284372143517237068L;\n\n    private static final class CredOwner implements Serializable {\n\n        private static final long serialVersionUID = -5607449830436408266L;\n\n        String principalClass;\n"}
{"magic_number_smell": "        /**\n         * Compatibility issue: see comments for setType variable\n         */\n        private static final long -8308522755600156056L = 7911754171111800359L;\n\n        private LinkedList<SST> elements;\n", "refactored_code": "    private static final long serialVersionUID = -8308522755600156056L;\n        /**\n         * Compatibility issue: see comments for setType variable\n         */\n        private static final long serialVersionUID = 7911754171111800359L;\n\n        private LinkedList<SST> elements;\n"}
{"magic_number_smell": "        } else {\n            if (total[REQUIRED] == 0 && total[REQUISITE] == 0) {\n                // neither REQUIRED nor REQUISITE was configured.\n                // must have at least one SUFFICIENT or 0\n                if (logged[0] != 0 || logged[SUFFICIENT] != 0) {\n                    fail = false;\n                }", "refactored_code": "    private static final int OPTIONAL = 0;\n        } else {\n            if (total[REQUIRED] == 0 && total[REQUISITE] == 0) {\n                // neither REQUIRED nor REQUISITE was configured.\n                // must have at least one SUFFICIENT or OPTIONAL\n                if (logged[OPTIONAL] != 0 || logged[SUFFICIENT] != 0) {\n                    fail = false;\n                }"}
{"magic_number_smell": "\n        IvParameterSpec initCipherState;\n        switch (etype) {\n            case 1:\n                offset = 12;// confounder(8)+CRC-32 checksum(4)\n                // copy of original key\n                initCipherState = new IvParameterSpec(key.getEncoded());", "refactored_code": "    public static final int DES_CBC_CRC = 1;\n\n        IvParameterSpec initCipherState;\n        switch (etype) {\n            case DES_CBC_CRC:\n                offset = 12;// confounder(8)+CRC-32 checksum(4)\n                // copy of original key\n                initCipherState = new IvParameterSpec(key.getEncoded());"}
{"magic_number_smell": "     */\n    public static final int TGS_REP = 13;\n\n    // type of a protocol message: 11 or TGS_REP\n    private final int msgType;\n\n    private final PrincipalName cname;", "refactored_code": "    public static final int AS_REP = 11;\n     */\n    public static final int TGS_REP = 13;\n\n    // type of a protocol message: AS_REP or TGS_REP\n    private final int msgType;\n\n    private final PrincipalName cname;"}
{"magic_number_smell": "     */\n    public static final int TGS_REQ = 12;\n\n    // type of a protocol message: 10 or TGS_REQ\n    private final int msgType;\n\n    private final PrincipalName cname;", "refactored_code": "    public static final int AS_REQ = 10;\n     */\n    public static final int TGS_REQ = 12;\n\n    // type of a protocol message: AS_REQ or TGS_REQ\n    private final int msgType;\n\n    private final PrincipalName cname;"}
{"magic_number_smell": "            DatagramSocket socket = request.send(InetAddress.getByName(kdc),\n                    port);\n\n            ByteArrayOutputStream out = new ByteArrayOutputStream(1024);\n\n            byte[] buf = new byte[1024];\n", "refactored_code": "    private static final int BUF_SIZE = 1024;\n            DatagramSocket socket = request.send(InetAddress.getByName(kdc),\n                    port);\n\n            ByteArrayOutputStream out = new ByteArrayOutputStream(BUF_SIZE);\n\n            byte[] buf = new byte[BUF_SIZE];\n"}
{"magic_number_smell": "\n        t.commentChar('#');\n\n        t.ordinaryChar('[');\n        t.ordinaryChar(TT_END_SECTION);\n        t.ordinaryChar(TT_EQAUL);\n", "refactored_code": "    private static final int TT_START_SECTION = '[';\n\n        t.commentChar('#');\n\n        t.ordinaryChar(TT_START_SECTION);\n        t.ordinaryChar(TT_END_SECTION);\n        t.ordinaryChar(TT_EQAUL);\n"}
{"magic_number_smell": "\t\tbyte[] encoded = encodedGSSName;\n\t\tint index = 0;\n\n\t\tif (encoded[index++] != 0x04\n\t\t\t\t|| encoded[index++] != EXPORTED_TOKEN_SECOND_BYTE) {\n\t\t\tthrow new GSSException(GSSUtils.DEFAULT_GSSEXCEPTION_MAJOR_CODE,\n\t\t\t\t\tGSSUtils.DEFAULT_GSSEXCEPTION_MINOR_CODE,", "refactored_code": "private static final byte EXPORTED_TOKEN_FIRST_BYTE = 0x04;\n\t\tbyte[] encoded = encodedGSSName;\n\t\tint index = 0;\n\n\t\tif (encoded[index++] != EXPORTED_TOKEN_FIRST_BYTE\n\t\t\t\t|| encoded[index++] != EXPORTED_TOKEN_SECOND_BYTE) {\n\t\t\tthrow new GSSException(GSSUtils.DEFAULT_GSSEXCEPTION_MAJOR_CODE,\n\t\t\t\t\tGSSUtils.DEFAULT_GSSEXCEPTION_MINOR_CODE,"}
{"magic_number_smell": "\t\ttry {\n\t\t\treturn new String(bytes, DEFAULT_CHARSET_NAME);\n\t\t} catch (UnsupportedEncodingException e) {\n\t\t\tthrow new GSSException(3,\n\t\t\t\t\tDEFAULT_GSSEXCEPTION_MINOR_CODE, e.getMessage());\n\t\t}\n\t}", "refactored_code": "\tpublic static final int DEFAULT_GSSEXCEPTION_MAJOR_CODE = 3;\n\t\ttry {\n\t\t\treturn new String(bytes, DEFAULT_CHARSET_NAME);\n\t\t} catch (UnsupportedEncodingException e) {\n\t\t\tthrow new GSSException(DEFAULT_GSSEXCEPTION_MAJOR_CODE,\n\t\t\t\t\tDEFAULT_GSSEXCEPTION_MINOR_CODE, e.getMessage());\n\t\t}\n\t}"}
{"magic_number_smell": "        Date newAuthTime = new Date(AUTH_TIME);\n\n        KerberosTicket krbTicket = new KerberosTicket(ticket, pClient, pServer,\n                sessionKey, 1, flags, newAuthTime, startTime, endTime,\n                renewTill, addesses);\n\n        // initial value is not copied", "refactored_code": "    private static final int KEY_TYPE = 1;\n        Date newAuthTime = new Date(AUTH_TIME);\n\n        KerberosTicket krbTicket = new KerberosTicket(ticket, pClient, pServer,\n                sessionKey, KEY_TYPE, flags, newAuthTime, startTime, endTime,\n                renewTill, addesses);\n\n        // initial value is not copied"}
{"magic_number_smell": "     */\n    public void testSerializationSelf() throws Exception {\n        SerializationTest.verifySelf(new KerberosKey(PRINCIPAL, KEY_BYTES,\n                22, VERSION_NUM), COMPARATOR);\n    }\n\n    /**", "refactored_code": "    private static final int KEY_TYPE = 22;\n     */\n    public void testSerializationSelf() throws Exception {\n        SerializationTest.verifySelf(new KerberosKey(PRINCIPAL, KEY_BYTES,\n                KEY_TYPE, VERSION_NUM), COMPARATOR);\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    public void testSerializationSelf() throws Exception {\n        SerializationTest.verifySelf(new KerberosTicket(ticket, pClient,\n                pServer, sessionKey, 1, flags, authTime, startTime,\n                endTime, renewTill, addesses), COMPARATOR);\n    }\n", "refactored_code": "    private static final int KEY_TYPE = 1;\n     */\n    public void testSerializationSelf() throws Exception {\n        SerializationTest.verifySelf(new KerberosTicket(ticket, pClient,\n                pServer, sessionKey, KEY_TYPE, flags, authTime, startTime,\n                endTime, renewTill, addesses), COMPARATOR);\n    }\n"}
{"magic_number_smell": "     */\n    private static LoginModuleControlFlag mapControlFlag(int flag) {\n        switch (flag) {\n        case 0:\n            return LoginModuleControlFlag.0;\n        case REQUIRED:\n            return LoginModuleControlFlag.REQUIRED;", "refactored_code": "    private static final int OPTIONAL = 0;\n     */\n    private static LoginModuleControlFlag mapControlFlag(int flag) {\n        switch (flag) {\n        case OPTIONAL:\n            return LoginModuleControlFlag.OPTIONAL;\n        case REQUIRED:\n            return LoginModuleControlFlag.REQUIRED;"}
{"magic_number_smell": "\n                port = socket.getLocalPort();\n\n                byte[] request = new byte[1024];\n                DatagramPacket packet = new DatagramPacket(request,\n                        request.length);\n", "refactored_code": "        private static final int BUF_SIZE = 1024;\n\n                port = socket.getLocalPort();\n\n                byte[] request = new byte[BUF_SIZE];\n                DatagramPacket packet = new DatagramPacket(request,\n                        request.length);\n"}
{"magic_number_smell": "\n    public static final int XOR = 12;\n\n    public static final AlphaComposite Clear = new AlphaComposite(1);\n\n    public static final AlphaComposite Src = new AlphaComposite(SRC);\n", "refactored_code": "    public static final int CLEAR = 1;\n\n    public static final int XOR = 12;\n\n    public static final AlphaComposite Clear = new AlphaComposite(CLEAR);\n\n    public static final AlphaComposite Src = new AlphaComposite(SRC);\n"}
{"magic_number_smell": "            // awt.133=Negative width\n            throw new IllegalArgumentException(Messages.getString(\"awt.133\")); //$NON-NLS-1$\n        }\n        if (cap != 0 && cap != CAP_ROUND && cap != CAP_SQUARE) {\n            // awt.134=Illegal cap\n            throw new IllegalArgumentException(Messages.getString(\"awt.134\")); //$NON-NLS-1$\n        }", "refactored_code": "    public static final int CAP_BUTT = 0;\n            // awt.133=Negative width\n            throw new IllegalArgumentException(Messages.getString(\"awt.133\")); //$NON-NLS-1$\n        }\n        if (cap != CAP_BUTT && cap != CAP_ROUND && cap != CAP_SQUARE) {\n            // awt.134=Illegal cap\n            throw new IllegalArgumentException(Messages.getString(\"awt.134\")); //$NON-NLS-1$\n        }"}
{"magic_number_smell": "\n    protected class AccessibleAWTButton extends AccessibleAWTComponent implements\n            AccessibleAction, AccessibleValue {\n        private static final long -8774683716313001058L = -5932203980244017102L;\n\n        protected AccessibleAWTButton() {\n            super();", "refactored_code": "    private static final long serialVersionUID = -8774683716313001058L;\n\n    protected class AccessibleAWTButton extends AccessibleAWTComponent implements\n            AccessibleAction, AccessibleValue {\n        private static final long serialVersionUID = -5932203980244017102L;\n\n        protected AccessibleAWTButton() {\n            super();"}
{"magic_number_smell": "    private static final long -2284879212465893870L = -2284879212465893870L;\n\n    protected class AccessibleAWTCanvas extends AccessibleAWTComponent {\n        private static final long -2284879212465893870L = -6325592262103146699L;\n\n        @Override\n        public AccessibleRole getAccessibleRole() {", "refactored_code": "    private static final long serialVersionUID = -2284879212465893870L;\n    private static final long serialVersionUID = -2284879212465893870L;\n\n    protected class AccessibleAWTCanvas extends AccessibleAWTComponent {\n        private static final long serialVersionUID = -6325592262103146699L;\n\n        @Override\n        public AccessibleRole getAccessibleRole() {"}
{"magic_number_smell": "\n    protected class AccessibleAWTCheckbox extends Component.AccessibleAWTComponent implements\n            ItemListener, AccessibleAction, AccessibleValue {\n        private static final long 7270714317450821763L = 7881579233144754107L;\n\n        public AccessibleAWTCheckbox() {\n            super();", "refactored_code": "    private static final long serialVersionUID = 7270714317450821763L;\n\n    protected class AccessibleAWTCheckbox extends Component.AccessibleAWTComponent implements\n            ItemListener, AccessibleAction, AccessibleValue {\n        private static final long serialVersionUID = 7881579233144754107L;\n\n        public AccessibleAWTCheckbox() {\n            super();"}
{"magic_number_smell": "\n    protected class AccessibleAWTCheckboxMenuItem extends AccessibleAWTMenuItem implements\n            AccessibleAction, AccessibleValue {\n        private static final long 6190621106981774043L = -1122642964303476L;\n\n        @Override\n        public boolean doAccessibleAction(int i) {", "refactored_code": "    private static final long serialVersionUID = 6190621106981774043L;\n\n    protected class AccessibleAWTCheckboxMenuItem extends AccessibleAWTMenuItem implements\n            AccessibleAction, AccessibleValue {\n        private static final long serialVersionUID = -1122642964303476L;\n\n        @Override\n        public boolean doAccessibleAction(int i) {"}
{"magic_number_smell": "\n    protected class AccessibleAWTChoice extends Component.AccessibleAWTComponent implements\n            AccessibleAction {\n        private static final long -4075310674757313071L = 7175603582428509322L;\n\n        public AccessibleAWTChoice() {\n            // default constructor is public", "refactored_code": "    private static final long serialVersionUID = -4075310674757313071L;\n\n    protected class AccessibleAWTChoice extends Component.AccessibleAWTComponent implements\n            AccessibleAction {\n        private static final long serialVersionUID = 7175603582428509322L;\n\n        public AccessibleAWTChoice() {\n            // default constructor is public"}
{"magic_number_smell": "\n    protected abstract class AccessibleAWTComponent extends AccessibleContext implements\n            Serializable, AccessibleComponent {\n        private static final long -7644114512714619750L = 642321655757800191L;\n\n        protected class AccessibleAWTComponentHandler implements ComponentListener {\n            protected AccessibleAWTComponentHandler() {", "refactored_code": "    private static final long serialVersionUID = -7644114512714619750L;\n\n    protected abstract class AccessibleAWTComponent extends AccessibleContext implements\n            Serializable, AccessibleComponent {\n        private static final long serialVersionUID = 642321655757800191L;\n\n        protected class AccessibleAWTComponentHandler implements ComponentListener {\n            protected AccessibleAWTComponentHandler() {"}
{"magic_number_smell": "    boolean isRemoved; // set to true/false on removeNotify() enter/exit\n\n    protected class AccessibleAWTContainer extends AccessibleAWTComponent {\n        private static final long 4613797578919906343L = 5081320404842566097L;\n\n        protected class AccessibleContainerHandler implements ContainerListener {\n            protected AccessibleContainerHandler() {", "refactored_code": "    private static final long serialVersionUID = 4613797578919906343L;\n    boolean isRemoved; // set to true/false on removeNotify() enter/exit\n\n    protected class AccessibleAWTContainer extends AccessibleAWTComponent {\n        private static final long serialVersionUID = 5081320404842566097L;\n\n        protected class AccessibleContainerHandler implements ContainerListener {\n            protected AccessibleContainerHandler() {"}
{"magic_number_smell": "    }\n\n    protected class AccessibleAWTDialog extends AccessibleAWTWindow {\n        private static final long 5920926903803293709L = 4837230331833941201L;\n\n        @Override\n        public AccessibleStateSet getAccessibleStateSet() {", "refactored_code": "    private static final long serialVersionUID = 5920926903803293709L;\n    }\n\n    protected class AccessibleAWTDialog extends AccessibleAWTWindow {\n        private static final long serialVersionUID = 4837230331833941201L;\n\n        @Override\n        public AccessibleStateSet getAccessibleStateSet() {"}
{"magic_number_smell": "    private Rectangle maximizedBounds;\n\n    protected  class AccessibleAWTFrame extends AccessibleAWTWindow {\n        private static final long 2673458971256075116L = -6172960752956030250L;\n\n        @Override\n        public AccessibleRole getAccessibleRole() {", "refactored_code": "    private static final long serialVersionUID = 2673458971256075116L;\n    private Rectangle maximizedBounds;\n\n    protected  class AccessibleAWTFrame extends AccessibleAWTWindow {\n        private static final long serialVersionUID = -6172960752956030250L;\n\n        @Override\n        public AccessibleRole getAccessibleRole() {"}
{"magic_number_smell": "\n    public static final int DOWN_CYCLE_TRAVERSAL_KEYS = 3;\n\n    final static int[] compTraversalIDs = { 0, BACKWARD_TRAVERSAL_KEYS,\n            UP_CYCLE_TRAVERSAL_KEYS };\n\n    final static int[] contTraversalIDs = { 0, BACKWARD_TRAVERSAL_KEYS,", "refactored_code": "    public static final int FORWARD_TRAVERSAL_KEYS = 0;\n\n    public static final int DOWN_CYCLE_TRAVERSAL_KEYS = 3;\n\n    final static int[] compTraversalIDs = { FORWARD_TRAVERSAL_KEYS, BACKWARD_TRAVERSAL_KEYS,\n            UP_CYCLE_TRAVERSAL_KEYS };\n\n    final static int[] contTraversalIDs = { FORWARD_TRAVERSAL_KEYS, BACKWARD_TRAVERSAL_KEYS,"}
{"magic_number_smell": "    protected class AccessibleAWTLabel\n    extends Component.AccessibleAWTComponent {\n\n        private static final long 3094126758329070636L = -3568967560160480438L;\n\n        public AccessibleAWTLabel() {\n            // define default constructor explicitly just to make it public", "refactored_code": "    private static final long serialVersionUID = 3094126758329070636L;\n    protected class AccessibleAWTLabel\n    extends Component.AccessibleAWTComponent {\n\n        private static final long serialVersionUID = -3568967560160480438L;\n\n        public AccessibleAWTLabel() {\n            // define default constructor explicitly just to make it public"}
{"magic_number_smell": "\n    protected class AccessibleAWTList extends AccessibleAWTComponent implements\n            AccessibleSelection, ItemListener, ActionListener {\n        private static final long -3304312411574666869L = 7924617370136012829L;\n\n        protected class AccessibleAWTListChild extends AccessibleAWTComponent implements\n                Accessible {", "refactored_code": "    private static final long serialVersionUID = -3304312411574666869L;\n\n    protected class AccessibleAWTList extends AccessibleAWTComponent implements\n            AccessibleSelection, ItemListener, ActionListener {\n        private static final long serialVersionUID = 7924617370136012829L;\n\n        protected class AccessibleAWTListChild extends AccessibleAWTComponent implements\n                Accessible {"}
{"magic_number_smell": "    final MenuPopupBox popupBox = new MenuPopupBox();\n\n    protected class AccessibleAWTMenu extends AccessibleAWTMenuItem {\n        private static final long -8809584163345499784L = 5228160894980069094L;\n\n        @Override\n        public AccessibleRole getAccessibleRole() {", "refactored_code": "    private static final long serialVersionUID = -8809584163345499784L;\n    final MenuPopupBox popupBox = new MenuPopupBox();\n\n    protected class AccessibleAWTMenu extends AccessibleAWTMenuItem {\n        private static final long serialVersionUID = 5228160894980069094L;\n\n        @Override\n        public AccessibleRole getAccessibleRole() {"}
{"magic_number_smell": "\n    protected class AccessibleAWTMenuBar extends AccessibleAWTMenuComponent {\n\n        private static final long -4930327919388951260L = -8577604491830083815L;\n\n        @Override\n        public AccessibleRole getAccessibleRole() {", "refactored_code": "    private static final long serialVersionUID = -4930327919388951260L;\n\n    protected class AccessibleAWTMenuBar extends AccessibleAWTMenuComponent {\n\n        private static final long serialVersionUID = -8577604491830083815L;\n\n        @Override\n        public AccessibleRole getAccessibleRole() {"}
{"magic_number_smell": "\n    protected abstract class AccessibleAWTMenuComponent extends AccessibleContext implements\n            Serializable, AccessibleComponent, AccessibleSelection {\n        private static final long -4536902356223894379L = -4269533416223798698L;\n\n        public void addFocusListener(FocusListener listener) {\n        }", "refactored_code": "    private static final long serialVersionUID = -4536902356223894379L;\n\n    protected abstract class AccessibleAWTMenuComponent extends AccessibleContext implements\n            Serializable, AccessibleComponent, AccessibleSelection {\n        private static final long serialVersionUID = -4269533416223798698L;\n\n        public void addFocusListener(FocusListener listener) {\n        }"}
{"magic_number_smell": "\n    protected class AccessibleAWTMenuItem extends AccessibleAWTMenuComponent implements\n            AccessibleAction, AccessibleValue {\n        private static final long -21757335363267194L = -217847831945965825L;\n\n        @Override\n        public String getAccessibleName() {", "refactored_code": "    private static final long serialVersionUID = -21757335363267194L;\n\n    protected class AccessibleAWTMenuItem extends AccessibleAWTMenuComponent implements\n            AccessibleAction, AccessibleValue {\n        private static final long serialVersionUID = -217847831945965825L;\n\n        @Override\n        public String getAccessibleName() {"}
{"magic_number_smell": "        if (lastPos == null) {\n            return true;\n        }\n        return ((Math.abs(lastPos.x - info.position.x) > 5) ||\n                (Math.abs(lastPos.y - info.position.y) > 5));\n    }\n", "refactored_code": "    private static final int clickDelta = 5;\n        if (lastPos == null) {\n            return true;\n        }\n        return ((Math.abs(lastPos.x - info.position.x) > clickDelta) ||\n                (Math.abs(lastPos.y - info.position.y) > clickDelta));\n    }\n"}
{"magic_number_smell": "\n    protected  class AccessibleAWTPanel extends AccessibleAWTContainer {\n\n        private static final long -2728009084054400034L = -6409552226660031050L;\n\n        @Override\n        public AccessibleRole getAccessibleRole() {", "refactored_code": "    private static final long serialVersionUID = -2728009084054400034L;\n\n    protected  class AccessibleAWTPanel extends AccessibleAWTContainer {\n\n        private static final long serialVersionUID = -6409552226660031050L;\n\n        @Override\n        public AccessibleRole getAccessibleRole() {"}
{"magic_number_smell": "\n    protected class AccessibleAWTPopupMenu extends AccessibleAWTMenu {\n\n        private static final long -4620452533522760060L = -4282044795947239955L;\n\n        @Override\n        public AccessibleRole getAccessibleRole() {", "refactored_code": "    private static final long serialVersionUID = -4620452533522760060L;\n\n    protected class AccessibleAWTPopupMenu extends AccessibleAWTMenu {\n\n        private static final long serialVersionUID = -4282044795947239955L;\n\n        @Override\n        public AccessibleRole getAccessibleRole() {"}
{"magic_number_smell": "\n    protected class AccessibleAWTScrollBar extends Component.AccessibleAWTComponent implements\n            AccessibleValue {\n        private static final long 8451667562882310543L = -344337268523697807L;\n\n        @Override\n        public AccessibleRole getAccessibleRole() {", "refactored_code": "    private static final long serialVersionUID = 8451667562882310543L;\n\n    protected class AccessibleAWTScrollBar extends Component.AccessibleAWTComponent implements\n            AccessibleValue {\n        private static final long serialVersionUID = -344337268523697807L;\n\n        @Override\n        public AccessibleRole getAccessibleRole() {"}
{"magic_number_smell": "    private final Scrollable scrollable;\n\n    protected class AccessibleAWTScrollPane extends AccessibleAWTContainer {\n        private static final long 7956609840827222915L = 6100703663886637L;\n\n        protected AccessibleAWTScrollPane() {\n        }", "refactored_code": "    private static final long serialVersionUID = 7956609840827222915L;\n    private final Scrollable scrollable;\n\n    protected class AccessibleAWTScrollPane extends AccessibleAWTContainer {\n        private static final long serialVersionUID = 6100703663886637L;\n\n        protected AccessibleAWTScrollPane() {\n        }"}
{"magic_number_smell": "        }\n    }\n\n    private static final long 3472827823632144419L = 3692302836626095722L;\n\n    public static final int SCROLLBARS_BOTH = 0;\n", "refactored_code": "        private static final long serialVersionUID = 3472827823632144419L;\n        }\n    }\n\n    private static final long serialVersionUID = 3692302836626095722L;\n\n    public static final int SCROLLBARS_BOTH = 0;\n"}
{"magic_number_smell": "\n    protected class AccessibleAWTTextComponent extends AccessibleAWTComponent implements\n            AccessibleText, TextListener {\n        private static final long -2214773872412987419L = 3631432373506317811L;\n\n        public AccessibleAWTTextComponent() {\n            // only add this as listener", "refactored_code": "    private static final long serialVersionUID = -2214773872412987419L;\n\n    protected class AccessibleAWTTextComponent extends AccessibleAWTComponent implements\n            AccessibleText, TextListener {\n        private static final long serialVersionUID = 3631432373506317811L;\n\n        public AccessibleAWTTextComponent() {\n            // only add this as listener"}
{"magic_number_smell": "        }\n    }\n\n    private static final long 6219164359235943158L = -2966288784432217853L;\n\n    private final AWTListenerList<ActionListener> actionListeners = new AWTListenerList<ActionListener>(\n            this);", "refactored_code": "        private static final long serialVersionUID = 6219164359235943158L;\n        }\n    }\n\n    private static final long serialVersionUID = -2966288784432217853L;\n\n    private final AWTListenerList<ActionListener> actionListeners = new AWTListenerList<ActionListener>(\n            this);"}
{"magic_number_smell": "    private transient InputContext inputContext;\n\n    protected class AccessibleAWTWindow extends AccessibleAWTContainer {\n        private static final long 4497834738069338734L = 4215068635060671780L;\n\n        @Override\n        public AccessibleStateSet getAccessibleStateSet() {", "refactored_code": "    private static final long serialVersionUID = 4497834738069338734L;\n    private transient InputContext inputContext;\n\n    protected class AccessibleAWTWindow extends AccessibleAWTContainer {\n        private static final long serialVersionUID = 4215068635060671780L;\n\n        @Override\n        public AccessibleStateSet getAccessibleStateSet() {"}
{"magic_number_smell": "        this.growRightLimit = growRightLimit;\n\n        if ((shrinkPriority < 0) || (shrinkPriority > PRIORITY_NONE)) {\n            // awt.19F=incorrect value for shrinkPriority, more than PRIORITY_NONE or less than 0 value\n            throw new IllegalArgumentException(Messages.getString(\"awt.19F\")); //$NON-NLS-1$\n        }\n        this.shrinkPriority = shrinkPriority;", "refactored_code": "    public static final int PRIORITY_KASHIDA = 0;\n        this.growRightLimit = growRightLimit;\n\n        if ((shrinkPriority < 0) || (shrinkPriority > PRIORITY_NONE)) {\n            // awt.19F=incorrect value for shrinkPriority, more than PRIORITY_NONE or less than PRIORITY_KASHIDA value\n            throw new IllegalArgumentException(Messages.getString(\"awt.19F\")); //$NON-NLS-1$\n        }\n        this.shrinkPriority = shrinkPriority;"}
{"magic_number_smell": "    }\n\n    public boolean isStandard() {\n        return ((this.glyphType & 3) == 0);\n    }\n\n    public boolean isLigature() {", "refactored_code": "    public static final byte STANDARD = 0;\n    }\n\n    public boolean isStandard() {\n        return ((this.glyphType & 3) == STANDARD);\n    }\n\n    public boolean isLigature() {"}
{"magic_number_smell": "        this.flatness = flatness;\n        this.flatness2 = flatness * flatness;\n        this.bufLimit = limit;\n        this.bufSize = Math.min(bufLimit, 16);\n        this.buf = new double[bufSize];\n        this.bufIndex = bufSize;\n    }", "refactored_code": "    private static final int BUFFER_SIZE = 16;\n        this.flatness = flatness;\n        this.flatness2 = flatness * flatness;\n        this.bufLimit = limit;\n        this.bufSize = Math.min(bufLimit, BUFFER_SIZE);\n        this.buf = new double[bufSize];\n        this.bufIndex = bufSize;\n    }"}
{"magic_number_smell": "    }\n\n    public void setWindingRule(int rule) {\n        if (rule != PathIterator.WIND_EVEN_ODD && rule != WIND_NON_ZERO) {\n            // awt.209=Invalid winding rule value\n            throw new java.lang.IllegalArgumentException(Messages.getString(\"awt.209\")); //$NON-NLS-1$\n        }", "refactored_code": "    public static final int WIND_EVEN_ODD = PathIterator.WIND_EVEN_ODD;\n    }\n\n    public void setWindingRule(int rule) {\n        if (rule != WIND_EVEN_ODD && rule != WIND_NON_ZERO) {\n            // awt.209=Invalid winding rule value\n            throw new java.lang.IllegalArgumentException(Messages.getString(\"awt.209\")); //$NON-NLS-1$\n        }"}
{"magic_number_smell": "            int code = 0;\n\n            if (width <= 0.0f) {\n                code |= 1 | OUT_RIGHT;\n            } else\n                if (px < x) {\n                    code |= 1;", "refactored_code": "    public static final int OUT_LEFT   = 1;\n            int code = 0;\n\n            if (width <= 0.0f) {\n                code |= OUT_LEFT | OUT_RIGHT;\n            } else\n                if (px < x) {\n                    code |= OUT_LEFT;"}
{"magic_number_smell": "    public static final int CONVERTED_TEXT = 1;\n\n    public static final InputMethodHighlight\n        UNSELECTED_RAW_TEXT_HIGHLIGHT = new InputMethodHighlight(false, 0);\n\n    public static final InputMethodHighlight\n        SELECTED_RAW_TEXT_HIGHLIGHT = new InputMethodHighlight(true, 0);", "refactored_code": "    public static final int RAW_TEXT = 0;\n    public static final int CONVERTED_TEXT = 1;\n\n    public static final InputMethodHighlight\n        UNSELECTED_RAW_TEXT_HIGHLIGHT = new InputMethodHighlight(false, RAW_TEXT);\n\n    public static final InputMethodHighlight\n        SELECTED_RAW_TEXT_HIGHLIGHT = new InputMethodHighlight(true, RAW_TEXT);"}
{"magic_number_smell": "    }\n\n    public AffineTransformOp(AffineTransform xform, RenderingHints hints) {\n        this(xform, 1);\n        this.hints = hints;\n\n        if (hints != null) {", "refactored_code": "    public static final int TYPE_NEAREST_NEIGHBOR = 1;\n    }\n\n    public AffineTransformOp(AffineTransform xform, RenderingHints hints) {\n        this(xform, TYPE_NEAREST_NEIGHBOR);\n        this.hints = hints;\n\n        if (hints != null) {"}
{"magic_number_smell": "\n            switch (srcDataType) {\n                case DataBuffer.TYPE_BYTE:\n                    type = 0;\n                    break;\n                case DataBuffer.TYPE_USHORT:\n                    type = TYPE_USHORT3C;", "refactored_code": "    private static final int TYPE_BYTE3C = 0;\n\n            switch (srcDataType) {\n                case DataBuffer.TYPE_BYTE:\n                    type = TYPE_BYTE3C;\n                    break;\n                case DataBuffer.TYPE_USHORT:\n                    type = TYPE_USHORT3C;"}
{"magic_number_smell": "\n    public ConvolveOp(Kernel kernel) {\n        this.kernel = kernel;\n        this.edgeCond = 0;\n    }\n\n    public final Kernel getKernel() {", "refactored_code": "    public static final int EDGE_ZERO_FILL = 0;\n\n    public ConvolveOp(Kernel kernel) {\n        this.kernel = kernel;\n        this.edgeCond = EDGE_ZERO_FILL;\n    }\n\n    public final Kernel getKernel() {"}
{"magic_number_smell": "    public static int getDataTypeSize(int type) {\n        switch (type) {\n\n        case 0:\n            return 8;\n\n        case TYPE_USHORT:", "refactored_code": "    public static final int TYPE_BYTE = 0;\n    public static int getDataTypeSize(int type) {\n        switch (type) {\n\n        case TYPE_BYTE:\n            return 8;\n\n        case TYPE_USHORT:"}
{"magic_number_smell": "                                             // improving performance of selection\n                                             // nearest color in Color Map\n\n    private final int cachetable[] = new int[20 * 2]; // Cache table - used for \n                               // storing RGB values and that appropriate indices \n                               // in the Color Map \n                    ", "refactored_code": "    private static final int CACHESIZE = 20; // Cache size. Cache used for \n                                             // improving performance of selection\n                                             // nearest color in Color Map\n\n    private final int cachetable[] = new int[CACHESIZE * 2]; // Cache table - used for \n                               // storing RGB values and that appropriate indices \n                               // in the Color Map \n                    "}
{"magic_number_smell": "\n    public synchronized Object getPixels() {\n        switch(dataType){\n        case 0:\n            return bData;\n        case DATA_TYPE_INT:\n            return iData;", "refactored_code": "    private static final int DATA_TYPE_BYTE = 0;\n\n    public synchronized Object getPixels() {\n        switch(dataType){\n        case DATA_TYPE_BYTE:\n            return bData;\n        case DATA_TYPE_INT:\n            return iData;"}
{"magic_number_smell": "                x = pagePaper.getImageableX();\n                break;\n\n            case 0:\n                x = pagePaper.getHeight()\n                    - (pagePaper.getImageableY()\n                    +  pagePaper.getImageableHeight());", "refactored_code": "    public static final int LANDSCAPE = 0;\n                x = pagePaper.getImageableX();\n                break;\n\n            case LANDSCAPE:\n                x = pagePaper.getHeight()\n                    - (pagePaper.getImageableY()\n                    +  pagePaper.getImageableHeight());"}
{"magic_number_smell": "        super();\n        paperWidth = LETTER_WIDTH;\n        paperHeight = LETTER_HEIGHT;\n        paperImageableArea = new Rectangle2D.Double(72D, 72D,\n                                    paperWidth - INCH2, paperHeight - INCH2);\n    }\n", "refactored_code": "    private static final double INCH = 72D;    // inch in pixels\n        super();\n        paperWidth = LETTER_WIDTH;\n        paperHeight = LETTER_HEIGHT;\n        paperImageableArea = new Rectangle2D.Double(INCH, INCH,\n                                    paperWidth - INCH2, paperHeight - INCH2);\n    }\n"}
{"magic_number_smell": "     * Constructor of new byte buffer.\n     */\n    public ByteVector() {\n        value = new byte[16];\n        count = 0;\n    }\n", "refactored_code": "    private static final int DEF_CAPACITY = 16;\n     * Constructor of new byte buffer.\n     */\n    public ByteVector() {\n        value = new byte[DEF_CAPACITY];\n        count = 0;\n    }\n"}
{"magic_number_smell": "        \n        ScrollTask(int dir) {\n            setDir(dir);\n            timer = new PeriodicTimer(100l, this);\n        }\n\n        public void run() {", "refactored_code": "    private static final long DELAY = 100l; //animation delay in ms\n        \n        ScrollTask(int dir) {\n            setDir(dir);\n            timer = new PeriodicTimer(DELAY, this);\n        }\n\n        public void run() {"}
{"magic_number_smell": "        Insets ins = scrollable.getInsets();\n\n        if (hAdjNeeded) {\n            hRect.height = 16;\n            int vWidth = vAdjNeeded ? VSCROLLBAR_WIDTH : 0;\n            hRect.width = spWidth - vWidth - (ins.left + ins.right);\n            hRect.y = spHeight - hRect.height - ins.bottom;", "refactored_code": "    private static final int HSCROLLBAR_HEIGHT = 16;\n        Insets ins = scrollable.getInsets();\n\n        if (hAdjNeeded) {\n            hRect.height = HSCROLLBAR_HEIGHT;\n            int vWidth = vAdjNeeded ? VSCROLLBAR_WIDTH : 0;\n            hRect.width = spWidth - vWidth - (ins.left + ins.right);\n            hRect.y = spHeight - hRect.height - ins.bottom;"}
{"magic_number_smell": "    \n    public void run() {\n        switch (type) {\n        case 1:\n            context.dragEnter(newDragSourceDragEvent());\n            break;\n        case DRAG_OVER:", "refactored_code": "    public static final int DRAG_ENTER = 1;\n    \n    public void run() {\n        switch (type) {\n        case DRAG_ENTER:\n            context.dragEnter(newDragSourceDragEvent());\n            break;\n        case DRAG_OVER:"}
{"magic_number_smell": "        double dy = y4 - y3;\n        double d = dx * (y2 - y1) - dy * (x2 - x1);\n        // double comparison\n        if (Math.abs(d) < Math.pow(10, -14)) {\n            return 0;\n        }\n", "refactored_code": "    public static final double EPSILON = Math.pow(10, -14);\n        double dy = y4 - y3;\n        double d = dx * (y2 - y1) - dy * (x2 - x1);\n        // double comparison\n        if (Math.abs(d) < EPSILON) {\n            return 0;\n        }\n"}
{"magic_number_smell": "                down++;\n                continue;\n            }\n            return 255;\n        }\n\n        // UP", "refactored_code": "    public static final int CROSSING = 255;\n                down++;\n                continue;\n            }\n            return CROSSING;\n        }\n\n        // UP"}
{"magic_number_smell": "     */\n    public static int[] createBuf(int capacity) {\n        if (capacity == 0) {\n            capacity = 16;\n        }\n        int[] buf = new int[capacity];\n        buf[0] = 1;", "refactored_code": "    public static final int RECT_CAPACITY = 16;\n     */\n    public static int[] createBuf(int capacity) {\n        if (capacity == 0) {\n            capacity = RECT_CAPACITY;\n        }\n        int[] buf = new int[capacity];\n        buf[0] = 1;"}
{"magic_number_smell": "        for (int i=0; i<nColorChannels; i++) {\n            channelMinValues[i] = 0;\n            if (isSignedShort) {\n                channelMulipliers[i] = 0xFFFF / MAX_SIGNED_SHORT;\n                invChannelMulipliers[i] = MAX_SIGNED_SHORT / 0xFFFF;\n            } else {\n                maxVal = ((1 << sm.getSampleSize(i)) - 1);", "refactored_code": "    private static final float MAX_SHORT = 0xFFFF;\n        for (int i=0; i<nColorChannels; i++) {\n            channelMinValues[i] = 0;\n            if (isSignedShort) {\n                channelMulipliers[i] = MAX_SHORT / MAX_SIGNED_SHORT;\n                invChannelMulipliers[i] = MAX_SIGNED_SHORT / MAX_SHORT;\n            } else {\n                maxVal = ((1 << sm.getSampleSize(i)) - 1);"}
{"magic_number_smell": "     * @return derived font\n     */\n    static Font getDefaultSizeFont(int i) {\n        if (fonts[i].getSize() != 12) {\n            fonts[i] = fonts[i].deriveFont(12);\n        }\n", "refactored_code": "    private static final float DEFAULT_FONT_SIZE = 12;\n     * @return derived font\n     */\n    static Font getDefaultSizeFont(int i) {\n        if (fonts[i].getSize() != DEFAULT_FONT_SIZE) {\n            fonts[i] = fonts[i].deriveFont(DEFAULT_FONT_SIZE);\n        }\n"}
{"magic_number_smell": "\n        // Read the signature from the stream and then reset it back\n        try {\n            markable.mark(8);\n\n            byte[] signature = new byte[8];\n            markable.read(signature, 0, 8);", "refactored_code": "    private static final int MAX_BYTES_IN_SIGNATURE = 8;\n\n        // Read the signature from the stream and then reset it back\n        try {\n            markable.mark(MAX_BYTES_IN_SIGNATURE);\n\n            byte[] signature = new byte[MAX_BYTES_IN_SIGNATURE];\n            markable.read(signature, 0, MAX_BYTES_IN_SIGNATURE);"}
{"magic_number_smell": "        static ImageLoadersStorage instance;\n\n        List<DecodingImageSource> queue = new LinkedList<DecodingImageSource>();\n        List<Thread> loaders = new ArrayList<Thread>(5);\n\n        private int freeLoaders;\n", "refactored_code": "        private static final int MAX_THREADS = 5;\n        static ImageLoadersStorage instance;\n\n        List<DecodingImageSource> queue = new LinkedList<DecodingImageSource>();\n        List<Thread> loaders = new ArrayList<Thread>(MAX_THREADS);\n\n        private int freeLoaders;\n"}
{"magic_number_smell": "        setDimensions(imageWidth, imageHeight);\n\n        switch (jpegColorSpace) {\n            case 1: cm = cmGray; break;\n            case JCS_RGB: cm = cmRGB; break;\n            default: \n                // awt.3D=Unknown colorspace", "refactored_code": "    public static final int JCS_GRAYSCALE = 1;\n        setDimensions(imageWidth, imageHeight);\n\n        switch (jpegColorSpace) {\n            case JCS_GRAYSCALE: cm = cmGray; break;\n            case JCS_RGB: cm = cmRGB; break;\n            default: \n                // awt.3D=Unknown colorspace"}
{"magic_number_smell": "        }\n\n        public static final OffscreenBufferObject freeCachedBuffer(OffscreenBufferObject pbuffer) {\n            if (availableBuffers.size() <= 10) {\n                availableBuffers.add(pbuffer);\n                return null;\n            }", "refactored_code": "        private static final int MAX_CACHED_BUFFERS = 10;\n        }\n\n        public static final OffscreenBufferObject freeCachedBuffer(OffscreenBufferObject pbuffer) {\n            if (availableBuffers.size() <= MAX_CACHED_BUFFERS) {\n                availableBuffers.add(pbuffer);\n                return null;\n            }"}
{"magic_number_smell": "    }\n    \n    private static final class GlyphHashtable extends Hashtable<Character, DLInfo> { \n        private static final long 1L = 1L;\n\n        @Override\n        public void finalize() throws Throwable {", "refactored_code": "        private static final long serialVersionUID = 1L;\n    }\n    \n    private static final class GlyphHashtable extends Hashtable<Character, DLInfo> { \n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public void finalize() throws Throwable {"}
{"magic_number_smell": "     */\n    public long getAddress(int index) {\n        if(addr != 0) {\n            checkIndex(index, macc.getPointerSize() == 8 ? 8 : 4);\n            return macc.getPointer(addr + index);\n        }\n        return macc.getPointerSize() == 8", "refactored_code": "    public static final int POINTER_SIZE = macc.getPointerSize();\n     */\n    public long getAddress(int index) {\n        if(addr != 0) {\n            checkIndex(index, POINTER_SIZE == 8 ? 8 : 4);\n            return macc.getPointer(addr + index);\n        }\n        return POINTER_SIZE == 8"}
{"magic_number_smell": "    private static final int ByteBase.CLONG_SIZE = ByteBase.CLONG_SIZE;\n\n    CLongPointer(int size, boolean direct) {\n        super(size * ByteBase.CLONG_SIZE, direct);\n    }\n\n    CLongPointer(VoidPointer p) {", "refactored_code": "    private static final int CLONG_SIZE_FACTOR = ByteBase.CLONG_SIZE;\n    private static final int CLONG_SIZE_FACTOR = ByteBase.CLONG_SIZE;\n\n    CLongPointer(int size, boolean direct) {\n        super(size * CLONG_SIZE_FACTOR, direct);\n    }\n\n    CLongPointer(VoidPointer p) {"}
{"magic_number_smell": "    private static final int 8 = 8;\n\n    DoublePointer(int size, boolean direct) {\n        super(size * 8, direct);\n    }\n\n    DoublePointer(long add) {", "refactored_code": "    private static final int DOUBLE_SIZE_FACTOR = 8;\n    private static final int DOUBLE_SIZE_FACTOR = 8;\n\n    DoublePointer(int size, boolean direct) {\n        super(size * DOUBLE_SIZE_FACTOR, direct);\n    }\n\n    DoublePointer(long add) {"}
{"magic_number_smell": "    private static final int 4 = 4;\n\n    FloatPointer(int size, boolean direct) {\n        super(size * 4, direct);\n    }\n\n    FloatPointer(VoidPointer p) {", "refactored_code": "    private static final int FLOAT_SIZE_FACTOR = 4;\n    private static final int FLOAT_SIZE_FACTOR = 4;\n\n    FloatPointer(int size, boolean direct) {\n        super(size * FLOAT_SIZE_FACTOR, direct);\n    }\n\n    FloatPointer(VoidPointer p) {"}
{"magic_number_smell": "    }\n\n    Int16Pointer(int size, boolean direct) {\n        super(size * 2, direct);\n    }\n\n    Int16Pointer(ByteBase base) {", "refactored_code": "    private static final int INT16_SIZE_FACTOR = 2;\n    }\n\n    Int16Pointer(int size, boolean direct) {\n        super(size * INT16_SIZE_FACTOR, direct);\n    }\n\n    Int16Pointer(ByteBase base) {"}
{"magic_number_smell": "    private static final int 4 = 4;\n\n    Int32Pointer(int size, boolean direct) {\n        super(size * 4, direct);\n    }\n\n    Int32Pointer(VoidPointer p) {", "refactored_code": "    private static final int INT32_SIZE_FACTOR = 4;\n    private static final int INT32_SIZE_FACTOR = 4;\n\n    Int32Pointer(int size, boolean direct) {\n        super(size * INT32_SIZE_FACTOR, direct);\n    }\n\n    Int32Pointer(VoidPointer p) {"}
{"magic_number_smell": "    private static final int 8 = 8;\n\n    Int64Pointer(int size, boolean direct) {\n        super(size * 8, direct);\n    }\n\n    Int64Pointer(VoidPointer p) {", "refactored_code": "    private static final int INT64_SIZE_FACTOR = 8;\n    private static final int INT64_SIZE_FACTOR = 8;\n\n    Int64Pointer(int size, boolean direct) {\n        super(size * INT64_SIZE_FACTOR, direct);\n    }\n\n    Int64Pointer(VoidPointer p) {"}
{"magic_number_smell": "\n    private static final NativeBridge instance = new NativeBridge();\n    public static final int memAccess.getPointerSize() = memAccess.getPointerSize();\n    public static final boolean is64 = (memAccess.getPointerSize() == 8);\n\n\n    /**", "refactored_code": "    public static final int ptrSize = memAccess.getPointerSize();\n\n    private static final NativeBridge instance = new NativeBridge();\n    public static final int ptrSize = memAccess.getPointerSize();\n    public static final boolean is64 = (ptrSize == 8);\n\n\n    /**"}
{"magic_number_smell": "    private static final int ByteBase.POINTER_SIZE = ByteBase.POINTER_SIZE;\n\n    PointerPointer(int size, boolean direct) {\n        super(size * ByteBase.POINTER_SIZE, direct);\n    }\n\n    PointerPointer(ByteBase base) {", "refactored_code": "    private static final int PP_SIZE_FACTOR = ByteBase.POINTER_SIZE;\n    private static final int PP_SIZE_FACTOR = ByteBase.POINTER_SIZE;\n\n    PointerPointer(int size, boolean direct) {\n        super(size * PP_SIZE_FACTOR, direct);\n    }\n\n    PointerPointer(ByteBase base) {"}
{"magic_number_smell": "    public static final int DEFAULT_LOCATION = KeyEvent.KEY_LOCATION_STANDARD;\n\n    public KeyInfo() {\n        vKey = KeyEvent.VK_UNDEFINED;\n        keyLocation = DEFAULT_LOCATION;\n        keyChars = new StringBuffer();\n    }", "refactored_code": "    public static final int DEFAULT_VKEY = KeyEvent.VK_UNDEFINED;\n    public static final int DEFAULT_LOCATION = KeyEvent.KEY_LOCATION_STANDARD;\n\n    public KeyInfo() {\n        vKey = DEFAULT_VKEY;\n        keyLocation = DEFAULT_LOCATION;\n        keyChars = new StringBuffer();\n    }"}
{"magic_number_smell": "                dev.display, dev.screen,\n                info.get_visualid(),\n                info.get_depth(),\n                               27,\n                               X11Defs.False,\n                X11Defs.True\n        );", "refactored_code": "    private static final long XA_RGB_DEFAULT_MAP = 27;\n                dev.display, dev.screen,\n                info.get_visualid(),\n                info.get_depth(),\n                               XA_RGB_DEFAULT_MAP,\n                               X11Defs.False,\n                X11Defs.True\n        );"}
{"magic_number_smell": "        public static final int NativeBridge.is64 ? 136 : 88 = NativeBridge.is64 ? 136 : 88;\n\n        XImage(boolean direct) {\n            super(NativeBridge.is64 ? 136 : 88, direct);\n        }\n        XImage(VoidPointer base) {\n            super(base);", "refactored_code": "        public static final int sizeof = NativeBridge.is64 ? 136 : 88;\n        public static final int sizeof = NativeBridge.is64 ? 136 : 88;\n\n        XImage(boolean direct) {\n            super(sizeof, direct);\n        }\n        XImage(VoidPointer base) {\n            super(base);"}
{"magic_number_smell": "        public static final int NativeBridge.is64 ? 16 : 8 = NativeBridge.is64 ? 16 : 8;\n\n        FT_Vector(boolean direct) {\n            super(NativeBridge.is64 ? 16 : 8, direct);\n        }\n        FT_Vector(VoidPointer base) {\n            super(base);", "refactored_code": "        public static final int sizeof = NativeBridge.is64 ? 16 : 8;\n        public static final int sizeof = NativeBridge.is64 ? 16 : 8;\n\n        FT_Vector(boolean direct) {\n            super(sizeof, direct);\n        }\n        FT_Vector(VoidPointer base) {\n            super(base);"}
{"magic_number_smell": "     * @return root window id\n     */\n    long getRootWindow() {\n        return x11.XRootWindow(xConnection.getDisplay(), screen);\n    }\n\n    public long getDisplay() {", "refactored_code": "    private final long display = xConnection.getDisplay();\n     * @return root window id\n     */\n    long getRootWindow() {\n        return x11.XRootWindow(display, screen);\n    }\n\n    public long getDisplay() {"}
{"magic_number_smell": "                dropAction = DnDConstants.ACTION_NONE;\n                break;\n            }\n            dragState = 0;\n            \n            dropMonitor.notify();\n        }", "refactored_code": "    private static final int DRAG_NONE = 0;\n                dropAction = DnDConstants.ACTION_NONE;\n                break;\n            }\n            dragState = DRAG_NONE;\n            \n            dropMonitor.notify();\n        }"}
{"magic_number_smell": "    }\n\n    public long windowProc(long hwnd, int msg, long wParam, long lParam) {\n        if (hwnd == dataTransferWindow && msg == WindowsDefs.WM_USER + 1) {\n            Task t = (Task)objAccessor.getObjectFromReference(lParam);\n            t.perform();\n            return 0;", "refactored_code": "    private static final int WM_TASK = WindowsDefs.WM_USER + 1;\n    }\n\n    public long windowProc(long hwnd, int msg, long wParam, long lParam) {\n        if (hwnd == dataTransferWindow && msg == WM_TASK) {\n            Task t = (Task)objAccessor.getObjectFromReference(lParam);\n            t.perform();\n            return 0;"}
{"magic_number_smell": "            int count;\n            while (offs < curveOffs){\n\n                offs += 4;\n                count = curve.get_cpfx();\n                coords = getPoints(offs, count);\n                switch (curve.get_wType()){", "refactored_code": "    private static final long TTPOLYCURVE_HEADER_OFFSET = 4;\n            int count;\n            while (offs < curveOffs){\n\n                offs += TTPOLYCURVE_HEADER_OFFSET;\n                count = curve.get_cpfx();\n                coords = getPoints(offs, count);\n                switch (curve.get_wType()){"}
{"magic_number_smell": "            if (oshdc == 0) {\n                int pixelFormat = choosePixelFormatARB(hdc);\n                w32.SetPixelFormat(hdc, pixelFormat, w32.createPIXELFORMATDESCRIPTOR(false));\n                if (formattedDrawables.size() > 255) {\n                    formattedDrawables.clear();\n                }\n                formattedDrawables.add(new Long(drawable));", "refactored_code": "    private static final int FORMATTED_DRAWABLES_CACHE_SIZE = 255;\n            if (oshdc == 0) {\n                int pixelFormat = choosePixelFormatARB(hdc);\n                w32.SetPixelFormat(hdc, pixelFormat, w32.createPIXELFORMATDESCRIPTOR(false));\n                if (formattedDrawables.size() > FORMATTED_DRAWABLES_CACHE_SIZE) {\n                    formattedDrawables.clear();\n                }\n                formattedDrawables.add(new Long(drawable));"}
{"magic_number_smell": "        public static final int 4 = 4;\n\n        HGLRC__(boolean direct) {\n            super(4, direct);\n        }\n        HGLRC__(VoidPointer base) {\n            super(base);", "refactored_code": "        public static final int sizeof = 4;\n        public static final int sizeof = 4;\n\n        HGLRC__(boolean direct) {\n            super(sizeof, direct);\n        }\n        HGLRC__(VoidPointer base) {\n            super(base);"}
{"magic_number_smell": "        public static final int 16 = 16;\n\n        RECT(boolean direct) {\n            super(16, direct);\n        }\n        RECT(VoidPointer base) {\n            super(base);", "refactored_code": "        public static final int sizeof = 16;\n        public static final int sizeof = 16;\n\n        RECT(boolean direct) {\n            super(sizeof, direct);\n        }\n        RECT(VoidPointer base) {\n            super(base);"}
{"magic_number_smell": "    \n    // windows defs from CommDlg.h\n    private static final int -601 = -601;\n    private static final int CDN_INCLUDEITEM = -601 - 0x0007;\n    \n    private static class OFNHookHandler implements Handler {\n        ", "refactored_code": "    private static final int CDN_FIRST = -601;\n    \n    // windows defs from CommDlg.h\n    private static final int CDN_FIRST = -601;\n    private static final int CDN_INCLUDEITEM = CDN_FIRST - 0x0007;\n    \n    private static class OFNHookHandler implements Handler {\n        "}
{"magic_number_smell": "\n        long rawBufferPtr = bufferPtr.lock();\n        for (int i = 0; i < nCount; i++) {\n            Win32.RECT nr = win32.createRECT(rawBufferPtr + i * win32.createRECT(0).size());\n            Rectangle rect = factory.getRectBounds(nr);\n            rect.translate(dx, dy);\n            rgn[i] = rect;", "refactored_code": "    private static final long sizeofRECT = win32.createRECT(0).size();\n\n        long rawBufferPtr = bufferPtr.lock();\n        for (int i = 0; i < nCount; i++) {\n            Win32.RECT nr = win32.createRECT(rawBufferPtr + i * sizeofRECT);\n            Rectangle rect = factory.getRectBounds(nr);\n            rect.translate(dx, dy);\n            rgn[i] = rect;"}
{"magic_number_smell": "     * @return - false if the default Windows handler should be called; \n     */\n    private boolean preProcessMessage(long hwnd, int msg, long wParam, long lParam, long[] result) {\n        if (msg == WindowsDefs.WM_USER + 1 && hwnd == javaWindow) {\n            Task t = (Task)objAccessor.getObjectFromReference(lParam);\n            t.perform();\n            return true;", "refactored_code": "    public static final int WM_PERFORM_TASK = WindowsDefs.WM_USER + 1;\n     * @return - false if the default Windows handler should be called; \n     */\n    private boolean preProcessMessage(long hwnd, int msg, long wParam, long lParam, long[] result) {\n        if (msg == WM_PERFORM_TASK && hwnd == javaWindow) {\n            Task t = (Task)objAccessor.getObjectFromReference(lParam);\n            t.perform();\n            return true;"}
{"magic_number_smell": "    }\n    \n    private void getFontSmoothType(Map<String, Object> props) {\n        getIntSPI(\"win.text.fontSmoothingType\", 0x200A, props); //$NON-NLS-1$\n    }\n    \n    private void getDragSize(boolean cx, Map<String, Object> props) {", "refactored_code": "    private static final int SPI_GETFONTSMOOTHINGTYPE = 0x200A;\n    }\n    \n    private void getFontSmoothType(Map<String, Object> props) {\n        getIntSPI(\"win.text.fontSmoothingType\", SPI_GETFONTSMOOTHINGTYPE, props); //$NON-NLS-1$\n    }\n    \n    private void getDragSize(boolean cx, Map<String, Object> props) {"}
{"magic_number_smell": "\n\tprivate void decodeImage(String name) throws InterruptedException {\n\t\tfinal Image im = createImage(name);\n\t\tfinal BufferedImage bim = new BufferedImage(320, EXP_HEIGHT,\n\t\t\t\tBufferedImage.TYPE_INT_RGB);\n\t\tfinal Frame f = new Frame();\n\t\tfinal MediaTracker t = new MediaTracker(f);", "refactored_code": "\tprivate final int EXP_WIDTH = 320;\n\n\tprivate void decodeImage(String name) throws InterruptedException {\n\t\tfinal Image im = createImage(name);\n\t\tfinal BufferedImage bim = new BufferedImage(EXP_WIDTH, EXP_HEIGHT,\n\t\t\t\tBufferedImage.TYPE_INT_RGB);\n\t\tfinal Frame f = new Frame();\n\t\tfinal MediaTracker t = new MediaTracker(f);"}
{"magic_number_smell": "    }\n\n    public BorderLayoutTest() {\n        Dimension min = new Dimension(50, 50),\n                  pref = new Dimension(PREF_SIZE, PREF_SIZE);\n        n = new TestButton(\"n\", min, pref);\n        s = new TestButton(\"s\", min, pref);", "refactored_code": "    private final int MIN_SIZE = 50;\n    }\n\n    public BorderLayoutTest() {\n        Dimension min = new Dimension(MIN_SIZE, MIN_SIZE),\n                  pref = new Dimension(PREF_SIZE, PREF_SIZE);\n        n = new TestButton(\"n\", min, pref);\n        s = new TestButton(\"s\", min, pref);"}
{"magic_number_smell": "    public CardLayoutTest(String name) {\n        super(name);\n\n        Dimension min = new Dimension(50, 50),\n                pref = new Dimension(PREF_SIZE, PREF_SIZE);\n        b1 = new TestButton(\"1\", min, pref);\n        b2 = new TestButton(\"2\", min, pref);", "refactored_code": "    private final int MIN_SIZE = 50;\n    public CardLayoutTest(String name) {\n        super(name);\n\n        Dimension min = new Dimension(MIN_SIZE, MIN_SIZE),\n                pref = new Dimension(PREF_SIZE, PREF_SIZE);\n        b1 = new TestButton(\"1\", min, pref);\n        b2 = new TestButton(\"2\", min, pref);"}
{"magic_number_smell": "     */\n    private Event waitForEvent(Runnable runnable, int eventId, int waitTime) {\n        int timeout = 100;\n        for (int n = 0; n < 3; n++) {\n            int time = 0;\n            event = null;\n", "refactored_code": "    private final int nRetries = 3; //number of times to repeat [robot] actions\n     */\n    private Event waitForEvent(Runnable runnable, int eventId, int waitTime) {\n        int timeout = 100;\n        for (int n = 0; n < nRetries; n++) {\n            int time = 0;\n            event = null;\n"}
{"magic_number_smell": "    }\n\n    public FlowLayoutTest() {\n        Dimension min = new Dimension(50, 50),\n                  pref = new Dimension(PREF_SIZE, PREF_SIZE);\n        b1 = new TestButton(\"1\", min, pref);\n        b2 = new TestButton(\"2\", min, pref);", "refactored_code": "    private final int MIN_SIZE = 50;\n    }\n\n    public FlowLayoutTest() {\n        Dimension min = new Dimension(MIN_SIZE, MIN_SIZE),\n                  pref = new Dimension(PREF_SIZE, PREF_SIZE);\n        b1 = new TestButton(\"1\", min, pref);\n        b2 = new TestButton(\"2\", min, pref);"}
{"magic_number_smell": "    public GridLayoutTest(String name) {\n        super(name);\n\n        Dimension min = new Dimension(50, 50),\n                pref = new Dimension(PREF_SIZE, PREF_SIZE);\n        b1 = new TestButton(\"1\", min, pref);\n        b2 = new TestButton(\"2\", min, pref);", "refactored_code": "    private final int MIN_SIZE = 50;\n    public GridLayoutTest(String name) {\n        super(name);\n\n        Dimension min = new Dimension(MIN_SIZE, MIN_SIZE),\n                pref = new Dimension(PREF_SIZE, PREF_SIZE);\n        b1 = new TestButton(\"1\", min, pref);\n        b2 = new TestButton(\"2\", min, pref);"}
{"magic_number_smell": "        vAdjustable = (ScrollPaneAdjustable) scrollPane.getVAdjustable();\n        checkAdjustable(vAdjustable, Adjustable.VERTICAL, 0, 0, 0, 0, 1, 1);\n        Button b = new Button();\n        b.setPreferredSize(new Dimension(1500, VSIZE));\n        scrollPane.add(b);\n        f.add(scrollPane);\n        f.show();", "refactored_code": "    private final int HSIZE = 1500;\n        vAdjustable = (ScrollPaneAdjustable) scrollPane.getVAdjustable();\n        checkAdjustable(vAdjustable, Adjustable.VERTICAL, 0, 0, 0, 0, 1, 1);\n        Button b = new Button();\n        b.setPreferredSize(new Dimension(HSIZE, VSIZE));\n        scrollPane.add(b);\n        f.add(scrollPane);\n        f.show();"}
{"magic_number_smell": "\n    private final int 500 = 500;\n    private final int height = 200;\n    private final BufferedImage im = new BufferedImage(500, height, BufferedImage.TYPE_INT_RGB);\n\n    private final String s = \"I TestItalic TestPlain I\";\n    private final Font f = new Font(\"times new roman\", Font.ITALIC, 24);", "refactored_code": "    private final int width = 500;\n\n    private final int width = 500;\n    private final int height = 200;\n    private final BufferedImage im = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\n\n    private final String s = \"I TestItalic TestPlain I\";\n    private final Font f = new Font(\"times new roman\", Font.ITALIC, 24);"}
{"magic_number_smell": "{\n    private final int 500 = 500;\n    private final int height = 200;\n    private final BufferedImage im = new BufferedImage(500, height, BufferedImage.TYPE_INT_RGB);\n    TextLayout tl;\n\n    String strings[] = new String [] {", "refactored_code": "    private final int width = 500;\n{\n    private final int width = 500;\n    private final int height = 200;\n    private final BufferedImage im = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\n    TextLayout tl;\n\n    String strings[] = new String [] {"}
{"magic_number_smell": "\n    private final int 500 = 500;\n    private final int height = 200;\n    private final BufferedImage im = new BufferedImage(500, height, BufferedImage.TYPE_INT_RGB);\n\n    private final String s = \"I TestItalic TestPlain I\";\n    private final Font f = new Font(\"times new roman\", Font.ITALIC, 24);", "refactored_code": "    private final int width = 500;\n\n    private final int width = 500;\n    private final int height = 200;\n    private final BufferedImage im = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\n\n    private final String s = \"I TestItalic TestPlain I\";\n    private final Font f = new Font(\"times new roman\", Font.ITALIC, 24);"}
{"magic_number_smell": "     * Gets the <code>BeanInfo</code> object which contains the information of\n     * the properties, events and methods of the specified bean class.\n     * <ol>\n     * <li>If <code>flag==3</code>, the\n     * <code>Introspector</code> will ignore all <code>BeanInfo</code>\n     * class.</li>\n     * <li>If <code>flag==IGNORE_IMMEDIATE_BEANINFO</code>, the", "refactored_code": "    public static final int IGNORE_ALL_BEANINFO = 3;\n     * Gets the <code>BeanInfo</code> object which contains the information of\n     * the properties, events and methods of the specified bean class.\n     * <ol>\n     * <li>If <code>flag==IGNORE_ALL_BEANINFO</code>, the\n     * <code>Introspector</code> will ignore all <code>BeanInfo</code>\n     * class.</li>\n     * <li>If <code>flag==IGNORE_IMMEDIATE_BEANINFO</code>, the"}
{"magic_number_smell": "            for (Iterator<Object> iter = flushPending.iterator(); iter\n                    .hasNext();) {\n                Object o = iter.next();\n                flushObject(o, 1);\n                // remove flushed obj\n                iter.remove();\n            }", "refactored_code": "    private static final int INDENT_UNIT = 1;\n            for (Iterator<Object> iter = flushPending.iterator(); iter\n                    .hasNext();) {\n                Object o = iter.next();\n                flushObject(o, INDENT_UNIT);\n                // remove flushed obj\n                iter.remove();\n            }"}
{"magic_number_smell": "     */\n    protected static class BCSSServiceProvider implements Serializable {\n\n        private static final long -3263851306889194873L = 861278251667444782L;\n\n        /**\n         * The service provider of the related service.", "refactored_code": "        private static final long serialVersionUID = -3263851306889194873L;\n     */\n    protected static class BCSSServiceProvider implements Serializable {\n\n        private static final long serialVersionUID = 861278251667444782L;\n\n        /**\n         * The service provider of the related service."}
{"magic_number_smell": "        }\n    }\n\n    private static final long -5815286101609939109L = -4879613978649577204L; //J2SE 1.4.2\n\n    /**\n     * A list of registered membership listeners.", "refactored_code": "        private static final long serialVersionUID = -5815286101609939109L;\n        }\n    }\n\n    private static final long serialVersionUID = -4879613978649577204L; //J2SE 1.4.2\n\n    /**\n     * A list of registered membership listeners."}
{"magic_number_smell": "\n    // put command in one of two collections - arguments or operations\n    private int doBeforeRun(Map<String, Command> references) throws Exception {\n        if (status == Command.0) {\n            for (int i = 0; i < commands.size(); ++i) {\n                Command cmd = commands.elementAt(i);\n", "refactored_code": "    private static final int INITIALIZED = 0;\n\n    // put command in one of two collections - arguments or operations\n    private int doBeforeRun(Map<String, Command> references) throws Exception {\n        if (status == Command.INITIALIZED) {\n            for (int i = 0; i < commands.size(); ++i) {\n                Command cmd = commands.elementAt(i);\n"}
{"magic_number_smell": "     */\n    public static class MockTransientBean extends MockFoo {\n\n        private static final long 5528972237047564849L = 6924332068595493238L;\n    }\n\n    /*", "refactored_code": "        private static final long serialVersionUID = 5528972237047564849L;\n     */\n    public static class MockTransientBean extends MockFoo {\n\n        private static final long serialVersionUID = 6924332068595493238L;\n    }\n\n    /*"}
{"magic_number_smell": "    class MockBeanPropertyDesc implements Serializable {\n\n        /**\n         * Comment for <code>3109235561744543400L</code>\n         */\n        private static final long 3109235561744543400L = 1L;\n", "refactored_code": "        private static final long serialVersionUID = 3109235561744543400L;\n    class MockBeanPropertyDesc implements Serializable {\n\n        /**\n         * Comment for <code>serialVersionUID</code>\n         */\n        private static final long serialVersionUID = 1L;\n"}
{"magic_number_smell": "    \n    public static class MockChildBeanContextServicesSupport extends\n            BeanContextServicesSupport {\n        private static final long -5521269152428572350L = 1L;\n\n        public boolean revokeCalled = false;\n", "refactored_code": "        private static final long serialVersionUID = -5521269152428572350L;\n    \n    public static class MockChildBeanContextServicesSupport extends\n            BeanContextServicesSupport {\n        private static final long serialVersionUID = 1L;\n\n        public boolean revokeCalled = false;\n"}
{"magic_number_smell": "        // Regression for HARMONY-1393\n        class TestBeanException extends BeanContextChildSupport implements\n                BeanContextProxy {\n            private static final long -4165267256277214588L = -8544245159647566063L;\n            private final BeanContextChildSupport childSupport = new BeanContextChildSupport();\n\n            public BeanContextChild getBeanContextProxy() {", "refactored_code": "        private static final long serialVersionUID = -4165267256277214588L;\n        // Regression for HARMONY-1393\n        class TestBeanException extends BeanContextChildSupport implements\n                BeanContextProxy {\n            private static final long serialVersionUID = -8544245159647566063L;\n            private final BeanContextChildSupport childSupport = new BeanContextChildSupport();\n\n            public BeanContextChild getBeanContextProxy() {"}
{"magic_number_smell": "        public Short visit(Ancestor o) {\n            calledMethodName = \"visit\";\n            calledmethodArguments = new Object[] { o };\n            calledMethodResult = 2;\n            return null;\n        }\n", "refactored_code": "    public static final short ANCESTOR_SHORT = 2;\n        public Short visit(Ancestor o) {\n            calledMethodName = \"visit\";\n            calledmethodArguments = new Object[] { o };\n            calledMethodResult = ANCESTOR_SHORT;\n            return null;\n        }\n"}
{"magic_number_smell": "         * count field are marked in code comments.\n         */\n\n        private static final long 7249069246763182397L = 2249069246763182397L;\n\n        /**\n         * The number of elements in this segment's region.", "refactored_code": "    private static final long serialVersionUID = 7249069246763182397L;\n         * count field are marked in code comments.\n         */\n\n        private static final long serialVersionUID = 2249069246763182397L;\n\n        /**\n         * The number of elements in this segment's region."}
{"magic_number_smell": "     * otherwise wasted expansion can be avoided.\n     */\n    private static final int FULL =\n        Math.max(0, Math.min(CAPACITY, Runtime.getRuntime().availableProcessors() / 2) - 1);\n\n    /**\n     * The number of times to spin (doing nothing except polling a", "refactored_code": "    private static final int NCPU = Runtime.getRuntime().availableProcessors();\n     * otherwise wasted expansion can be avoided.\n     */\n    private static final int FULL =\n        Math.max(0, Math.min(CAPACITY, NCPU / 2) - 1);\n\n    /**\n     * The number of times to spin (doing nothing except polling a"}
{"magic_number_smell": "\n        private static final int 16 = 16;\n        private ScheduledFutureTask[] queue =\n            new ScheduledFutureTask[16];\n        private final ReentrantLock lock = new ReentrantLock();\n        private int size = 0;\n", "refactored_code": "        private static final int INITIAL_CAPACITY = 16;\n\n        private static final int INITIAL_CAPACITY = 16;\n        private ScheduledFutureTask[] queue =\n            new ScheduledFutureTask[INITIAL_CAPACITY];\n        private final ReentrantLock lock = new ReentrantLock();\n        private int size = 0;\n"}
{"magic_number_smell": " * <pre>\n * class Pool {\n *   private static final int 100 = 100;\n *   private final Semaphore available = new Semaphore(100, true);\n *\n *   public Object getItem() throws InterruptedException {\n *     available.acquire();", "refactored_code": " *   private static final int MAX_AVAILABLE = 100;\n * <pre>\n * class Pool {\n *   private static final int MAX_AVAILABLE = 100;\n *   private final Semaphore available = new Semaphore(MAX_AVAILABLE, true);\n *\n *   public Object getItem() throws InterruptedException {\n *     available.acquire();"}
{"magic_number_smell": "\n    static class WaitQueue implements java.io.Serializable { }\n    static class LifoWaitQueue extends WaitQueue {\n        private static final long -3223113410248163686L = -3633113410248163686L;\n    }\n    static class FifoWaitQueue extends WaitQueue {\n        private static final long -3223113410248163686L = -3623113410248163686L;", "refactored_code": "    private static final long serialVersionUID = -3223113410248163686L;\n\n    static class WaitQueue implements java.io.Serializable { }\n    static class LifoWaitQueue extends WaitQueue {\n        private static final long serialVersionUID = -3633113410248163686L;\n    }\n    static class FifoWaitQueue extends WaitQueue {\n        private static final long serialVersionUID = -3623113410248163686L;"}
{"magic_number_smell": "     */\n    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n    private static final int Integer.SIZE - 3 = Integer.SIZE - 3;\n    private static final int CAPACITY   = (1 << Integer.SIZE - 3) - 1;\n\n    // runState is stored in the high-order bits\n    private static final int RUNNING    = -1 << Integer.SIZE - 3;", "refactored_code": "    private static final int COUNT_BITS = Integer.SIZE - 3;\n     */\n    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n    private static final int COUNT_BITS = Integer.SIZE - 3;\n    private static final int CAPACITY   = (1 << COUNT_BITS) - 1;\n\n    // runState is stored in the high-order bits\n    private static final int RUNNING    = -1 << COUNT_BITS;"}
{"magic_number_smell": "     * so deserialized conditions have no waiters.\n     */\n    public class ConditionObject implements Condition, java.io.Serializable {\n        private static final long 7373984972572414691L = 1173984872572414699L;\n        /** First node of condition queue. */\n        private transient Node firstWaiter;\n        /** Last node of condition queue. */", "refactored_code": "    private static final long serialVersionUID = 7373984972572414691L;\n     * so deserialized conditions have no waiters.\n     */\n    public class ConditionObject implements Condition, java.io.Serializable {\n        private static final long serialVersionUID = 1173984872572414699L;\n        /** First node of condition queue. */\n        private transient Node firstWaiter;\n        /** Last node of condition queue. */"}
{"magic_number_smell": "     * represent the number of holds on the lock.\n     */\n    static abstract class Sync extends AbstractQueuedSynchronizer {\n        private static final long 7373984872572414699L = -5179523762034025860L;\n\n        /**\n         * Performs {@link Lock#lock}. The main reason for subclassing", "refactored_code": "    private static final long serialVersionUID = 7373984872572414699L;\n     * represent the number of holds on the lock.\n     */\n    static abstract class Sync extends AbstractQueuedSynchronizer {\n        private static final long serialVersionUID = -5179523762034025860L;\n\n        /**\n         * Performs {@link Lock#lock}. The main reason for subclassing"}
{"magic_number_smell": "     * Subclassed into fair and nonfair versions.\n     */\n    static abstract class Sync extends AbstractQueuedSynchronizer {\n        private static final long -6992448646407690164L = 6317671515068378041L;\n\n        /*\n         * Read vs write count extraction constants and functions.", "refactored_code": "    private static final long serialVersionUID = -6992448646407690164L;\n     * Subclassed into fair and nonfair versions.\n     */\n    static abstract class Sync extends AbstractQueuedSynchronizer {\n        private static final long serialVersionUID = 6317671515068378041L;\n\n        /*\n         * Read vs write count extraction constants and functions."}
{"magic_number_smell": "\tfor(int i = (n & 1); i < n; i+=2)\n\t    assertTrue(q.offer(new PDelay(i)));\n        assertFalse(q.isEmpty());\n        assertEquals(Integer.MAX_VALUE, q.remainingCapacity());\n\tassertEquals(n, q.size());\n        return q;\n    }", "refactored_code": "    private static final int NOCAP = Integer.MAX_VALUE;\n\tfor(int i = (n & 1); i < n; i+=2)\n\t    assertTrue(q.offer(new PDelay(i)));\n        assertFalse(q.isEmpty());\n        assertEquals(NOCAP, q.remainingCapacity());\n\tassertEquals(n, q.size());\n        return q;\n    }"}
{"magic_number_smell": "\tfor(int i = (n & 1); i < n; i+=2)\n\t    assertTrue(q.offer(new Integer(i)));\n        assertFalse(q.isEmpty());\n        assertEquals(Integer.MAX_VALUE, q.remainingCapacity());\n\tassertEquals(n, q.size());\n        return q;\n    }", "refactored_code": "    private static final int NOCAP = Integer.MAX_VALUE;\n\tfor(int i = (n & 1); i < n; i+=2)\n\t    assertTrue(q.offer(new Integer(i)));\n        assertFalse(q.isEmpty());\n        assertEquals(NOCAP, q.remainingCapacity());\n\tassertEquals(n, q.size());\n        return q;\n    }"}
{"magic_number_smell": "     *\n     * @param opmode\n     *            the operation this cipher instance should be initialized for\n     *            (one of: {@code ENCRYPT_MODE}, {@code 2}, {@code\n     *            WRAP_MODE} or {@code UNWRAP_MODE}).\n     * @param key\n     *            the input key for the operation.", "refactored_code": "    public static final int DECRYPT_MODE = 2;\n     *\n     * @param opmode\n     *            the operation this cipher instance should be initialized for\n     *            (one of: {@code ENCRYPT_MODE}, {@code DECRYPT_MODE}, {@code\n     *            WRAP_MODE} or {@code UNWRAP_MODE}).\n     * @param key\n     *            the input key for the operation."}
{"magic_number_smell": "\n    private final Cipher cipher;\n    private final int 20 = 20;\n    private final byte[] i_buffer = new byte[20];\n    private int index; // index of the bytes to return from o_buffer\n    private byte[] o_buffer;\n    private boolean finished;", "refactored_code": "    private final int I_BUFFER_SIZE = 20;\n\n    private final Cipher cipher;\n    private final int I_BUFFER_SIZE = 20;\n    private final byte[] i_buffer = new byte[I_BUFFER_SIZE];\n    private int index; // index of the bytes to return from o_buffer\n    private byte[] o_buffer;\n    private boolean finished;"}
{"magic_number_smell": "\n    /**\n     * Creates a new <code>DESedeKeySpec</code> instance from the first 24 (\n     * {@link #24}) bytes of the specified key data.\n     *\n     * @param key\n     *            the key data.", "refactored_code": "    public static final int DES_EDE_KEY_LEN = 24;\n\n    /**\n     * Creates a new <code>DESedeKeySpec</code> instance from the first 24 (\n     * {@link #DES_EDE_KEY_LEN}) bytes of the specified key data.\n     *\n     * @param key\n     *            the key data."}
{"magic_number_smell": "        if (key == null) {\n            throw new NullPointerException(Messages.getString(\"crypto.2F\")); //$NON-NLS-1$\n        }\n        if (key.length - offset < 8) {\n            throw new InvalidKeyException(\n                    Messages.getString(\"crypto.40\")); //$NON-NLS-1$\n        }", "refactored_code": "    public static final int DES_KEY_LEN = 8;\n        if (key == null) {\n            throw new NullPointerException(Messages.getString(\"crypto.2F\")); //$NON-NLS-1$\n        }\n        if (key.length - offset < DES_KEY_LEN) {\n            throw new InvalidKeyException(\n                    Messages.getString(\"crypto.40\")); //$NON-NLS-1$\n        }"}
{"magic_number_smell": "    private static final int 5 = 5;\n    \n    public static final int getLength() {\n        return 5;\n    }\n    @Override\n    protected byte[] engineGenExemptionBlob()", "refactored_code": "    private static final int byteArrayLength = 5;\n    private static final int byteArrayLength = 5;\n    \n    public static final int getLength() {\n        return byteArrayLength;\n    }\n    @Override\n    protected byte[] engineGenExemptionBlob()"}
{"magic_number_smell": "\n    public void setProgressiveMode(int mode) {\n        if (canWriteProgressive()) {\n            if (mode < 0 || mode > MODE_COPY_FROM_METADATA || mode == MODE_EXPLICIT) {\n                throw new IllegalArgumentException(Messages.getString(\"imageio.34\"));\n            }\n            this.progressiveMode = mode;", "refactored_code": "    public static final int MODE_DISABLED = 0;\n\n    public void setProgressiveMode(int mode) {\n        if (canWriteProgressive()) {\n            if (mode < MODE_DISABLED || mode > MODE_COPY_FROM_METADATA || mode == MODE_EXPLICIT) {\n                throw new IllegalArgumentException(Messages.getString(\"imageio.34\"));\n            }\n            this.progressiveMode = mode;"}
{"magic_number_smell": "\tprivate static class PositionStack {\n\t\tprivate static final int 10 = 10;\n\n\t\tprivate long[] values = new long[10];\n\t\tprivate int pos = 0;\n\n\t\tvoid push(long v) {", "refactored_code": "\t\tprivate static final int SIZE = 10;\n\tprivate static class PositionStack {\n\t\tprivate static final int SIZE = 10;\n\n\t\tprivate long[] values = new long[SIZE];\n\t\tprivate int pos = 0;\n\n\t\tvoid push(long v) {"}
{"magic_number_smell": "        }// ImageOutputStreamImpl\n\n        int imageWidth, imageHeight;\n        int colorType = 0;\n        int bitDepth;\n        int numBands;\n", "refactored_code": "    private static final int PNG_COLOR_TYPE_GRAY = 0;\n        }// ImageOutputStreamImpl\n\n        int imageWidth, imageHeight;\n        int colorType = PNG_COLOR_TYPE_GRAY;\n        int bitDepth;\n        int numBands;\n"}
{"magic_number_smell": "\npublic final class RandomAccessMemoryCache {\n    private static final int 9 = 9;\n    private static final int BLOCK_SIZE = 1 << 9;\n    private static final int BLOCK_MASK = BLOCK_SIZE - 1;\n    \n    private long length;", "refactored_code": "    private static final int BLOCK_SHIFT = 9;\n\npublic final class RandomAccessMemoryCache {\n    private static final int BLOCK_SHIFT = 9;\n    private static final int BLOCK_SIZE = 1 << BLOCK_SHIFT;\n    private static final int BLOCK_MASK = BLOCK_SIZE - 1;\n    \n    private long length;"}
{"magic_number_smell": "     * Modifies the attributes of <code>name</code>.\n     * <p>\n     * Parameter <code>i</code> is modification operation type and is\n     * constrained to be one of <code>1</code>,\n     * <code>REPLACE_ATTRIBUTE</code>, <code>REMOVE_ATTRIBUTE</code>. The\n     * implementation should try to make the modifications atomic.\n     * </p>", "refactored_code": "    public static final int ADD_ATTRIBUTE = 1;\n     * Modifies the attributes of <code>name</code>.\n     * <p>\n     * Parameter <code>i</code> is modification operation type and is\n     * constrained to be one of <code>ADD_ATTRIBUTE</code>,\n     * <code>REPLACE_ATTRIBUTE</code>, <code>REMOVE_ATTRIBUTE</code>. The\n     * implementation should try to make the modifications atomic.\n     * </p>"}
{"magic_number_smell": "     * Registers <code>namingListener</code> for events concerning\n     * <code>name</code>, with scope <code>i</code>.\n     * <p>\n     * The scope must be one of <code>0</code>,\n     * <code>NELEVEL_SCOPE</code>, or <code>SUBTREE_SCOPE</code>.\n     * </p>\n     * <p>", "refactored_code": "    public static final int OBJECT_SCOPE = 0;\n     * Registers <code>namingListener</code> for events concerning\n     * <code>name</code>, with scope <code>i</code>.\n     * <p>\n     * The scope must be one of <code>OBJECT_SCOPE</code>,\n     * <code>NELEVEL_SCOPE</code>, or <code>SUBTREE_SCOPE</code>.\n     * </p>\n     * <p>"}
{"magic_number_smell": "     */\n    public NamingEnumeration<NameClassPair> list(String name)\n            throws NamingException {\n        return list_common(convertNameFromStringForm(name), 1);\n    }\n\n    /**", "refactored_code": "    private static final int NAME_CLASS_SWT = 1;\n     */\n    public NamingEnumeration<NameClassPair> list(String name)\n            throws NamingException {\n        return list_common(convertNameFromStringForm(name), NAME_CLASS_SWT);\n    }\n\n    /**"}
{"magic_number_smell": "\n        SList slist = SList.getInstance();\n        SList.Server curServer;\n        byte[] outBuf = new byte[512];\n        int outBufLen;\n        byte[] inBuf = new byte[512];\n        Message receivedMes = null;", "refactored_code": "    private static final int MSG_MAX_BYTES = 512;\n\n        SList slist = SList.getInstance();\n        SList.Server curServer;\n        byte[] outBuf = new byte[MSG_MAX_BYTES];\n        int outBufLen;\n        byte[] inBuf = new byte[MSG_MAX_BYTES];\n        Message receivedMes = null;"}
{"magic_number_smell": "                        \"jndi.87\", hash)); //$NON-NLS-1$\n            }\n        } else {\n            if (hash != 2534274963554139942L) {\n                // jndi.88=Interface hash mismatch, expected: {0}, received: {1}\n                throw new java.rmi.server.SkeletonMismatchException(Messages\n                        .getString(\"jndi.88\", 2534274963554139942L, hash)); //$NON-NLS-1$", "refactored_code": "    private static final long interfaceHash = 2534274963554139942L;\n                        \"jndi.87\", hash)); //$NON-NLS-1$\n            }\n        } else {\n            if (hash != interfaceHash) {\n                // jndi.88=Interface hash mismatch, expected: {0}, received: {1}\n                throw new java.rmi.server.SkeletonMismatchException(Messages\n                        .getString(\"jndi.88\", interfaceHash, hash)); //$NON-NLS-1$"}
{"magic_number_smell": "    public void test_negotiate() throws IOException {\n\n        // This serverSocket is never used, just for creating a client socket.\n        ServerSocket server = new ServerSocket(12345);\n\n        Socket socket = new Socket(HOST, 12345);\n        MockSSLSocketFactory factory = new MockSSLSocketFactory();", "refactored_code": "    private final int PORT = 12345;\n    public void test_negotiate() throws IOException {\n\n        // This serverSocket is never used, just for creating a client socket.\n        ServerSocket server = new ServerSocket(PORT);\n\n        Socket socket = new Socket(HOST, PORT);\n        MockSSLSocketFactory factory = new MockSSLSocketFactory();"}
{"magic_number_smell": "\n    public static class MockCompoundName extends CompoundName {\n\n        private static final long 1L = -5947330494555498760L;\n\n        public MockCompoundName(String s) throws InvalidNameException {\n            super(s, new Properties());", "refactored_code": "        private static final long serialVersionUID = 1L;\n\n    public static class MockCompoundName extends CompoundName {\n\n        private static final long serialVersionUID = -5947330494555498760L;\n\n        public MockCompoundName(String s) throws InvalidNameException {\n            super(s, new Properties());"}
{"magic_number_smell": "\t}\n\n\tclass MyExtendedRequest implements ExtendedRequest {\n        private static final long 1L = 1L;\n\n        byte[] encodedValue;\n", "refactored_code": "        private static final long serialVersionUID = 1L;\n\t}\n\n\tclass MyExtendedRequest implements ExtendedRequest {\n        private static final long serialVersionUID = 1L;\n\n        byte[] encodedValue;\n"}
{"magic_number_smell": "\t */\n\tpublic long getIDSerial() {\n\t\t// TODO Auto-generated method stub\n\t\treturn this.1L;\n\t}\n\n\t/**", "refactored_code": "\tprivate static final long serialVersionUID = 1L;\n\t */\n\tpublic long getIDSerial() {\n\t\t// TODO Auto-generated method stub\n\t\treturn this.serialVersionUID;\n\t}\n\n\t/**"}
{"magic_number_smell": "\t\t\t\tnxt = reader.readLine();\n\t\t\t\tif (null != pre) {\n\t\t\t\t\t// filter out exception stack trace\n\t\t\t\t\tif (0 != (flag & 1)) {\n\t\t\t\t\t\tif (junitStartsWith(pre, \"at \")) {\n\t\t\t\t\t\t\tif (nxt == null) {\n\t\t\t\t\t\t\t\tbreak;", "refactored_code": "\tprivate static final int FILTER_EXCEPTION = 1;\n\t\t\t\tnxt = reader.readLine();\n\t\t\t\tif (null != pre) {\n\t\t\t\t\t// filter out exception stack trace\n\t\t\t\t\tif (0 != (flag & FILTER_EXCEPTION)) {\n\t\t\t\t\t\tif (junitStartsWith(pre, \"at \")) {\n\t\t\t\t\t\t\tif (nxt == null) {\n\t\t\t\t\t\t\t\tbreak;"}
{"magic_number_smell": "    @Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        mu = new MemoryUsage(1024, GOOD_MU_USED_VAL,\n                GOOD_MU_COMMITTED_VAL, GOOD_MU_MAX_VAL);\n    }\n", "refactored_code": "    private static final long GOOD_MU_INIT_VAL = 1024;\n    @Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        mu = new MemoryUsage(GOOD_MU_INIT_VAL, GOOD_MU_USED_VAL,\n                GOOD_MU_COMMITTED_VAL, GOOD_MU_MAX_VAL);\n    }\n"}
{"magic_number_smell": "    public static CompositeData[] createGoodStackTraceCompositeData() {\n        // Let's make the array have three elements. Doesn't matter that\n        // they are all identical.\n        CompositeData[] result = new CompositeData[3];\n        CompositeType cType = createGoodStackTraceElementCompositeType();\n        String[] names = { \"className\", \"methodName\", \"fileName\", \"lineNumber\",\n                \"nativeMethod\" };", "refactored_code": "    private static final int GOOD_STACK_SIZE = 3;\n    public static CompositeData[] createGoodStackTraceCompositeData() {\n        // Let's make the array have three elements. Doesn't matter that\n        // they are all identical.\n        CompositeData[] result = new CompositeData[GOOD_STACK_SIZE];\n        CompositeType cType = createGoodStackTraceElementCompositeType();\n        String[] names = { \"className\", \"methodName\", \"fileName\", \"lineNumber\",\n                \"nativeMethod\" };"}
{"magic_number_smell": "    public static final int FORMAT_FAILURE = 5;\n\n    @SuppressWarnings(\"nls\")\n    private static final String[] FAILURES = new String[] { \"0\",\n            \"WRITE_FAILURE\", \"FLUSH_FAILURE\", \"CLOSE_FAILURE\", \"OPEN_FAILURE\",\n            \"FORMAT_FAILURE\" };\n", "refactored_code": "    public static final int GENERIC_FAILURE = 0;\n    public static final int FORMAT_FAILURE = 5;\n\n    @SuppressWarnings(\"nls\")\n    private static final String[] FAILURES = new String[] { \"GENERIC_FAILURE\",\n            \"WRITE_FAILURE\", \"FLUSH_FAILURE\", \"CLOSE_FAILURE\", \"OPEN_FAILURE\",\n            \"FORMAT_FAILURE\" };\n"}
{"magic_number_smell": "        append = (null == a) ? getBooleanProperty(className + \".append\",\n                DEFAULT_APPEND) : a.booleanValue();\n        count = (null == c) ? getIntProperty(className + \".count\",\n                1) : c.intValue();\n        limit = (null == l) ? getIntProperty(className + \".limit\",\n                DEFAULT_LIMIT) : l.intValue();\n        count = count < 1 ? 1 : count;", "refactored_code": "    private static final int DEFAULT_COUNT = 1;\n        append = (null == a) ? getBooleanProperty(className + \".append\",\n                DEFAULT_APPEND) : a.booleanValue();\n        count = (null == c) ? getIntProperty(className + \".count\",\n                DEFAULT_COUNT) : c.intValue();\n        limit = (null == l) ? getIntProperty(className + \".limit\",\n                DEFAULT_LIMIT) : l.intValue();\n        count = count < 1 ? DEFAULT_COUNT : count;"}
{"magic_number_smell": "    private Handler target;\n\n    // buffer size\n    private int size = 1000;\n\n    // push level\n    private Level push = Level.SEVERE;", "refactored_code": "    private static final int DEFAULT_SIZE = 1000;\n    private Handler target;\n\n    // buffer size\n    private int size = DEFAULT_SIZE;\n\n    // push level\n    private Level push = Level.SEVERE;"}
{"magic_number_smell": "\t * levels.\n\t */\n\tstatic class MyLevel extends Level implements Serializable {\n\t\tprivate static final long 1L = 1L;\n\n\t\tpublic MyLevel(String name, int value) {\n\t\t\tsuper(name, value);", "refactored_code": "\tprivate static final long serialVersionUID = 1L;\n\t * levels.\n\t */\n\tstatic class MyLevel extends Level implements Serializable {\n\t\tprivate static final long serialVersionUID = 1L;\n\n\t\tpublic MyLevel(String name, int value) {\n\t\t\tsuper(name, value);"}
{"magic_number_smell": "\n    CharsetDecoder decoder;\n\n    ByteBuffer bytes = ByteBuffer.allocate(8192);\n\n    /**\n     * Constructs a new {@code InputStreamReader} on the {@link InputStream}", "refactored_code": "    private static final int BUFFER_SIZE = 8192;\n\n    CharsetDecoder decoder;\n\n    ByteBuffer bytes = ByteBuffer.allocate(BUFFER_SIZE);\n\n    /**\n     * Constructs a new {@code InputStreamReader} on the {@link InputStream}"}
{"magic_number_smell": "    private static final long -6120832682080437368L = -6120832682080437368L;\n\n    // Name of the field that contains the SUID value (if present)\n    private static final String UID_FIELD_NAME = \"-6120832682080437368L\"; //$NON-NLS-1$\n\n    static final long CONSTRUCTOR_IS_NOT_RESOLVED = -1;\n", "refactored_code": "    private static final long serialVersionUID = -6120832682080437368L;\n    private static final long serialVersionUID = -6120832682080437368L;\n\n    // Name of the field that contains the SUID value (if present)\n    private static final String UID_FIELD_NAME = \"serialVersionUID\"; //$NON-NLS-1$\n\n    static final long CONSTRUCTOR_IS_NOT_RESOLVED = -1;\n"}
{"magic_number_smell": "     * @see PipedWriter\n     */\n    public PipedReader() {\n        data = new char[1024];\n    }\n\n    /**", "refactored_code": "    private static final int PIPE_SIZE = 1024;\n     * @see PipedWriter\n     */\n    public PipedReader() {\n        data = new char[PIPE_SIZE];\n    }\n\n    /**"}
{"magic_number_smell": "     * <li> {@code TT_NUMBER} - the token is a number.</li>\n     * <li> {@code TT_EOL} - the end of line has been reached. Depends on\n     * whether {@code eolIsSignificant} is {@code true}.</li>\n     * <li> {@code -1} - the end of the stream has been reached.</li>\n     * </ul>\n     */\n    public int ttype = TT_UNKNOWN;", "refactored_code": "    public static final int TT_EOF = -1;\n     * <li> {@code TT_NUMBER} - the token is a number.</li>\n     * <li> {@code TT_EOL} - the end of line has been reached. Depends on\n     * whether {@code eolIsSignificant} is {@code true}.</li>\n     * <li> {@code TT_EOF} - the end of the stream has been reached.</li>\n     * </ul>\n     */\n    public int ttype = TT_UNKNOWN;"}
{"magic_number_smell": "     */\n    private static final class CaseInsensitiveComparator implements\n            Comparator<String>, Serializable {\n        private static final long -6849794470754667710L = 8575799808933029326L;\n\n        /**\n         * Compare the two objects to determine the relative ordering.", "refactored_code": "    private static final long serialVersionUID = -6849794470754667710L;\n     */\n    private static final class CaseInsensitiveComparator implements\n            Comparator<String>, Serializable {\n        private static final long serialVersionUID = 8575799808933029326L;\n\n        /**\n         * Compare the two objects to determine the relative ordering."}
{"magic_number_smell": "     */\n    public ReferenceQueue() {\n        super();\n        references = newArray(128);\n        head = 0;\n        tail = 0;\n        empty = true;", "refactored_code": "    private static final int DEFAULT_QUEUE_SIZE = 128;\n     */\n    public ReferenceQueue() {\n        super();\n        references = newArray(DEFAULT_QUEUE_SIZE);\n        head = 0;\n        tail = 0;\n        empty = true;"}
{"magic_number_smell": "     *         public} modifier, {@code false} otherwise\n     */\n    public static boolean isPublic(int modifiers) {\n        return ((modifiers & 0x1) != 0);\n    }\n\n    /**", "refactored_code": "    public static final int PUBLIC = 0x1;\n     *         public} modifier, {@code false} otherwise\n     */\n    public static boolean isPublic(int modifiers) {\n        return ((modifiers & PUBLIC) != 0);\n    }\n\n    /**"}
{"magic_number_smell": "                        hostName = getFullFormOfCompressedIPV6Address(hostName);\n                    }\n                    security.checkConnect(hostName,\n                            -1);\n                    accessibleAddresses.add(element);\n                } catch (SecurityException e) {\n                }", "refactored_code": "    private static final int CHECK_CONNECT_NO_PORT = -1;\n                        hostName = getFullFormOfCompressedIPV6Address(hostName);\n                    }\n                    security.checkConnect(hostName,\n                            CHECK_CONNECT_NO_PORT);\n                    accessibleAddresses.add(element);\n                } catch (SecurityException e) {\n                }"}
{"magic_number_smell": "            // case 1: http.proxyHost is set, use exact http proxy\n            type = Proxy.Type.HTTP;\n            port = getSystemPropertyOrAlternative(\"http.proxyPort\", //$NON-NLS-1$\n                    \"proxyPort\", String.valueOf(80)); //$NON-NLS-1$\n        } else if ((host = getSystemProperty(\"proxyHost\", null)) != null) { //$NON-NLS-1$\n            // case 2: proxyHost is set, use exact http proxy\n            type = Proxy.Type.HTTP;", "refactored_code": "    private static final int HTTP_PROXY_PORT = 80;\n            // case 1: http.proxyHost is set, use exact http proxy\n            type = Proxy.Type.HTTP;\n            port = getSystemPropertyOrAlternative(\"http.proxyPort\", //$NON-NLS-1$\n                    \"proxyPort\", String.valueOf(HTTP_PROXY_PORT)); //$NON-NLS-1$\n        } else if ((host = getSystemProperty(\"proxyHost\", null)) != null) { //$NON-NLS-1$\n            // case 2: proxyHost is set, use exact http proxy\n            type = Proxy.Type.HTTP;"}
{"magic_number_smell": "            int end) {\n        int len = end - start;\n        // use insertion sort for small arrays\n        if (len <= 7) {\n            for (int i = start + 1; i < end; i++) {\n                Comparable<Object> current = (Comparable<Object>) out[i];\n                Object prev = out[i - 1];", "refactored_code": "    private static final int SIMPLE_LENGTH = 7;\n            int end) {\n        int len = end - start;\n        // use insertion sort for small arrays\n        if (len <= SIMPLE_LENGTH) {\n            for (int i = start + 1; i < end; i++) {\n                Comparable<Object> current = (Comparable<Object>) out[i];\n                Object prev = out[i - 1];"}
{"magic_number_smell": "    @SuppressWarnings(\"unchecked\")\n    private static final class EmptyList extends AbstractList implements\n            RandomAccess, Serializable {\n        private static final long 2739099268398711800L = 8842843931221139166L;\n\n        @Override\n        public boolean contains(Object object) {", "refactored_code": "        private static final long serialVersionUID = 2739099268398711800L;\n    @SuppressWarnings(\"unchecked\")\n    private static final class EmptyList extends AbstractList implements\n            RandomAccess, Serializable {\n        private static final long serialVersionUID = 8842843931221139166L;\n\n        @Override\n        public boolean contains(Object object) {"}
{"magic_number_smell": "    private static class SerializationProxy<E extends Enum<E>> implements\n            Serializable {\n\n        private static final long 1009687484059888093L = 362491234563181265L;\n\n        private Class<E> elementType;\n", "refactored_code": "    private static final long serialVersionUID = 1009687484059888093L;\n    private static class SerializationProxy<E extends Enum<E>> implements\n            Serializable {\n\n        private static final long serialVersionUID = 362491234563181265L;\n\n        private Class<E> elementType;\n"}
{"magic_number_smell": "\n        private int precision = UNSET;\n\n        private StringBuilder strFlags = new StringBuilder(6);\n\n        private char dateSuffix;// will be used in new feature.\n", "refactored_code": "        private static final int FLAGT_TYPE_COUNT = 6;\n\n        private int precision = UNSET;\n\n        private StringBuilder strFlags = new StringBuilder(FLAGT_TYPE_COUNT);\n\n        private char dateSuffix;// will be used in new feature.\n"}
{"magic_number_smell": "    HugeEnumSet(Class<E> elementType) {\n        super(elementType);\n        enums = elementType.getEnumConstants();\n        bits = new long[(enums.length + 64 - 1) / 64];\n    }\n    \n    private class HugeEnumSetIterator implements Iterator<E> {", "refactored_code": "    private static final int BIT_IN_LONG = 64;\n    HugeEnumSet(Class<E> elementType) {\n        super(elementType);\n        enums = elementType.getEnumConstants();\n        bits = new long[(enums.length + BIT_IN_LONG - 1) / BIT_IN_LONG];\n    }\n    \n    private class HugeEnumSetIterator implements Iterator<E> {"}
{"magic_number_smell": "    void complement() {\n        if (enums.length != 0) {\n            bits = ~bits;\n            bits &= (-1L >>> (64 - enums.length));\n            size = enums.length - size;\n        }\n    }", "refactored_code": "    private static final int MAX_ELEMENTS = 64;\n    void complement() {\n        if (enums.length != 0) {\n            bits = ~bits;\n            bits &= (-1L >>> (MAX_ELEMENTS - enums.length));\n            size = enums.length - size;\n        }\n    }"}
{"magic_number_smell": "final class TimeZones {\n\n    private static final int 1800000 = 1800000;\n    private static final int ONE_HOUR = 1800000 * 2;\n\n    public static TimeZone[] getTimeZones() {\n        return new TimeZone[] {", "refactored_code": "    private static final int HALF_HOUR = 1800000;\nfinal class TimeZones {\n\n    private static final int HALF_HOUR = 1800000;\n    private static final int ONE_HOUR = HALF_HOUR * 2;\n\n    public static TimeZone[] getTimeZones() {\n        return new TimeZone[] {"}
{"magic_number_smell": "\n    static final class SubMap <K,V> extends AbstractMap<K, V>\n                                 implements SortedMap<K, V>, Serializable {\n        private static final long 919286545866124006L = -6520786458950516097L;\n\n        private TreeMap<K, V> backingMap;\n", "refactored_code": "    private static final long serialVersionUID = 919286545866124006L;\n\n    static final class SubMap <K,V> extends AbstractMap<K, V>\n                                 implements SortedMap<K, V>, Serializable {\n        private static final long serialVersionUID = -6520786458950516097L;\n\n        private TreeMap<K, V> backingMap;\n"}
{"magic_number_smell": "     * Constructs a new empty {@code WeakHashMap} instance.\n     */\n    public WeakHashMap() {\n        this(16);\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_SIZE = 16;\n     * Constructs a new empty {@code WeakHashMap} instance.\n     */\n    public WeakHashMap() {\n        this(DEFAULT_SIZE);\n    }\n\n    /**"}
{"magic_number_smell": "    public static final int 256 = 256;\n\n    private static final HashMap<String, CacheElement> cache = new HashMap<String, CacheElement>(\n            256);\n\n    /**\n     * FIFO queue for tracking age of elements.", "refactored_code": "    public static final int CACHE_SIZE = 256;\n    public static final int CACHE_SIZE = 256;\n\n    private static final HashMap<String, CacheElement> cache = new HashMap<String, CacheElement>(\n            CACHE_SIZE);\n\n    /**\n     * FIFO queue for tracking age of elements."}
{"magic_number_smell": "        int port = url.getPort();\n        int connectTimeout = getConnectTimeout();\n        if (port <= 0) {\n            port = 21;\n        }\n        if (null == currentProxy || Proxy.Type.HTTP == currentProxy.type()) {\n            controlSocket = new Socket();", "refactored_code": "    private static final int FTP_PORT = 21;\n        int port = url.getPort();\n        int connectTimeout = getConnectTimeout();\n        if (port <= 0) {\n            port = FTP_PORT;\n        }\n        if (null == currentProxy || Proxy.Type.HTTP == currentProxy.type()) {\n            controlSocket = new Socket();"}
{"magic_number_smell": "        constantPoolOffset = headerOffset;\n        headerOffset += 2;\n        constantPool = new ProxyConstantPool(this);\n        contents = new byte[1000];\n        // now we continue to generate the bytes inside the contents array\n        int accessFlags = AccPublic | AccFinal | AccSuper;\n        contents[contentsOffset++] = (byte) (accessFlags >> 8);", "refactored_code": "    private static final int INITIAL_CONTENTS_SIZE = 1000;\n        constantPoolOffset = headerOffset;\n        headerOffset += 2;\n        constantPool = new ProxyConstantPool(this);\n        contents = new byte[INITIAL_CONTENTS_SIZE];\n        // now we continue to generate the bytes inside the contents array\n        int accessFlags = AccPublic | AccFinal | AccSuper;\n        contents[contentsOffset++] = (byte) (accessFlags >> 8);"}
{"magic_number_smell": "    int currentOffset;\n\n    ProxyConstantPool(ProxyClassFile classFile) {\n        UTF8Cache = new ProxyCharArrayCache(50);\n        stringCache = new ProxyCharArrayCache(STRING_INITIAL_SIZE);\n        classNameCache = new ProxyCharArrayCache(CLASS_INITIAL_SIZE);\n        fieldCache = new ProxyObjectCache(FIELD_INITIAL_SIZE);", "refactored_code": "    public static final int UTF8_INITIAL_SIZE = 50;\n    int currentOffset;\n\n    ProxyConstantPool(ProxyClassFile classFile) {\n        UTF8Cache = new ProxyCharArrayCache(UTF8_INITIAL_SIZE);\n        stringCache = new ProxyCharArrayCache(STRING_INITIAL_SIZE);\n        classNameCache = new ProxyCharArrayCache(CLASS_INITIAL_SIZE);\n        fieldCache = new ProxyObjectCache(FIELD_INITIAL_SIZE);"}
{"magic_number_smell": "    public Socks4Message() {\n        super();\n        buffer = new byte[BUFFER_LENGTH];\n        setVersionNumber(4);\n    }\n\n    /**", "refactored_code": "    private static final int SOCKS_VERSION = 4;\n    public Socks4Message() {\n        super();\n        buffer = new byte[BUFFER_LENGTH];\n        setVersionNumber(SOCKS_VERSION);\n    }\n\n    /**"}
{"magic_number_smell": "    // Nothing\n    public static final int 0 = 0;\n\n    public static final int SIZEOF_VOID = 0;\n\n    // One byte\n    public static final int SIZEOF_ONE_BYTE = 1;", "refactored_code": "    public static final int SIZEOF_NO_BYTES = 0;\n    // Nothing\n    public static final int SIZEOF_NO_BYTES = 0;\n\n    public static final int SIZEOF_VOID = SIZEOF_NO_BYTES;\n\n    // One byte\n    public static final int SIZEOF_ONE_BYTE = 1;"}
{"magic_number_smell": "     *            the number of bytes that are requested to map.\n     * @param mapMode\n     *            the desired access mode as defined by one of the constants\n     *            {@link IMemorySystem#1},\n     *            {@link IMemorySystem#MMAP_READ_WRITE},\n     *            {@link IMemorySystem#MMAP_WRITE_COPY}\n     * @return the start address of the mapped memory area.", "refactored_code": "    public final int MMAP_READ_ONLY = 1;\n     *            the number of bytes that are requested to map.\n     * @param mapMode\n     *            the desired access mode as defined by one of the constants\n     *            {@link IMemorySystem#MMAP_READ_ONLY},\n     *            {@link IMemorySystem#MMAP_READ_WRITE},\n     *            {@link IMemorySystem#MMAP_WRITE_COPY}\n     * @return the start address of the mapped memory area."}
{"magic_number_smell": "        if (result >= 0) {\n            return true;\n        }\n        if (result == -209 ||\n                result == ERRORCODE_SOCKET_INTERRUPTED) {\n            return false;\n        }", "refactored_code": "    private static final int ERRORCODE_SOCKET_TIMEOUT = -209;\n        if (result >= 0) {\n            return true;\n        }\n        if (result == ERRORCODE_SOCKET_TIMEOUT ||\n                result == ERRORCODE_SOCKET_INTERRUPTED) {\n            return false;\n        }"}
{"magic_number_smell": "        // two kinds of situation will directly return 0.0f\n        // 1. info.s is 0\n        // 2. actual exponent is less than Float.MIN_EXPONENT\n        if (\"0\".equals(info.s) || (info.e + info.s.length() - 1 < -46)) {\n            return info.negative ? -0.0f : 0.0f;\n        }\n        // if actual exponent is larger than Float.MAX_EXPONENT, return infinity", "refactored_code": "    private static final int FLOAT_MIN_EXP = -46;\n        // two kinds of situation will directly return 0.0f\n        // 1. info.s is 0\n        // 2. actual exponent is less than Float.MIN_EXPONENT\n        if (\"0\".equals(info.s) || (info.e + info.s.length() - 1 < FLOAT_MIN_EXP)) {\n            return info.negative ? -0.0f : 0.0f;\n        }\n        // if actual exponent is larger than Float.MAX_EXPONENT, return infinity"}
{"magic_number_smell": "     * Parses the hex string to a double number.\n     */\n    public static double parseDouble(String hexString) {\n        HexStringParser parser = new HexStringParser(11,\n                DOUBLE_MANTISSA_WIDTH);\n        long result = parser.parse(hexString);\n        return Double.longBitsToDouble(result);", "refactored_code": "    private static final int DOUBLE_EXPONENT_WIDTH = 11;\n     * Parses the hex string to a double number.\n     */\n    public static double parseDouble(String hexString) {\n        HexStringParser parser = new HexStringParser(DOUBLE_EXPONENT_WIDTH,\n                DOUBLE_MANTISSA_WIDTH);\n        long result = parser.parse(hexString);\n        return Double.longBitsToDouble(result);"}
{"magic_number_smell": "\t * @see System#getProperty(String)\n\t */\n\tpublic PriviAction(String property) {\n\t\taction = 1;\n\t\targ1 = property;\n\t}\n", "refactored_code": "\tprivate static final int GET_SYSTEM_PROPERTY = 1;\n\t * @see System#getProperty(String)\n\t */\n\tpublic PriviAction(String property) {\n\t\taction = GET_SYSTEM_PROPERTY;\n\t\targ1 = property;\n\t}\n"}
{"magic_number_smell": "\t\t// step d, page 8 of spec\n\t\tfor (t = 0; t <= 19; t++) {\n\t\t\ttemp = (A << 5) | (A >>> (32 - 5)); // A , Circular Shift Left by 5\n\t\t\ttemp = temp + E + WArray[t] + 0x5a827999;\n\t\t\ttemp = temp + ((B & C) | (~B & D));\n\t\t\tE = D;\n\t\t\tD = C;", "refactored_code": "\tprivate static final int K0_19 = 0x5a827999;\n\t\t// step d, page 8 of spec\n\t\tfor (t = 0; t <= 19; t++) {\n\t\t\ttemp = (A << 5) | (A >>> (32 - 5)); // A , Circular Shift Left by 5\n\t\t\ttemp = temp + E + WArray[t] + K0_19;\n\t\t\ttemp = temp + ((B & C) | (~B & D));\n\t\t\tE = D;\n\t\t\tD = C;"}
{"magic_number_smell": "\n        // set up the connection\n        clientConnection.setDoInput(true);\n        clientConnection.setConnectTimeout(5000);\n        clientConnection.setReadTimeout(5000);\n\n        ServerWork server = new ServerWork(serverSocket, responseCode,", "refactored_code": "    private static final int TIMEOUT = 5000;\n\n        // set up the connection\n        clientConnection.setDoInput(true);\n        clientConnection.setConnectTimeout(TIMEOUT);\n        clientConnection.setReadTimeout(TIMEOUT);\n\n        ServerWork server = new ServerWork(serverSocket, responseCode,"}
{"magic_number_smell": "    }\n\n    static class TestClass1 implements Serializable {\n        private static final long 1L = 11111L;\n        int i = 0;\n    }\n", "refactored_code": "        private static final long serialVersionUID = 1L;\n    }\n\n    static class TestClass1 implements Serializable {\n        private static final long serialVersionUID = 11111L;\n        int i = 0;\n    }\n"}
{"magic_number_smell": "\n        byte[] midStream = new byte[] { (byte) 0x00, (byte) 0x00, (byte) 0x00,\n                (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n                (byte) 0x21, // 5942584913446079661L = 33L\n                (byte) 0x02, // flags\n                (byte) 0x00, (byte) 0x00, // fields : none\n                (byte) 0x78, // TC_ENDBLOCKDATA", "refactored_code": "        private static final long serialVersionUID = 5942584913446079661L;\n\n        byte[] midStream = new byte[] { (byte) 0x00, (byte) 0x00, (byte) 0x00,\n                (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n                (byte) 0x21, // serialVersionUID = 33L\n                (byte) 0x02, // flags\n                (byte) 0x00, (byte) 0x00, // fields : none\n                (byte) 0x78, // TC_ENDBLOCKDATA"}
{"magic_number_smell": "        int ham = 9999;\n\n        public static long getUID() {\n            return 999999999999999L;\n        }\n    }\n", "refactored_code": "        private static final long serialVersionUID = 999999999999999L;\n        int ham = 9999;\n\n        public static long getUID() {\n            return serialVersionUID;\n        }\n    }\n"}
{"magic_number_smell": "        Object hola = new Object();\n\n        public static long getUID() {\n            return 999999999999998L;\n        }\n    }\n", "refactored_code": "        private static final long serialVersionUID = 999999999999998L;\n        Object hola = new Object();\n\n        public static long getUID() {\n            return serialVersionUID;\n        }\n    }\n"}
{"magic_number_smell": "                out = new ByteArrayOutputStream();\n                writer = new OutputStreamWriter(out, MINIMAL_CHARSETS[i]);\n\n                int upper = 0xd800;\n                switch (i) {\n                case 0:\n                    upper = 128;", "refactored_code": "    private static final int UPPER = 0xd800;\n                out = new ByteArrayOutputStream();\n                writer = new OutputStreamWriter(out, MINIMAL_CHARSETS[i]);\n\n                int upper = UPPER;\n                switch (i) {\n                case 0:\n                    upper = 128;"}
{"magic_number_smell": "\n\t\t// Our own uncaught exception class\n\t\tclass UncaughtException extends TestException {\n            private static final long 1L = 1L;\n\t\t}\n\n\t\ttestRoot = new ThreadGroup(originalCurrent,", "refactored_code": "            private static final long serialVersionUID = 1L;\n\n\t\t// Our own uncaught exception class\n\t\tclass UncaughtException extends TestException {\n            private static final long serialVersionUID = 1L;\n\t\t}\n\n\t\ttestRoot = new ThreadGroup(originalCurrent,"}
{"magic_number_smell": "                        return;\n                }\n                try {\n                        f = x.getClass().getDeclaredField(\"Integer.MAX_VALUE\");\n                        f.setInt(x, (int) 1);\n                } catch (IllegalAccessException ex) {\n                        // Good, Exception should be thrown since Integer.MAX_VALUE is declared", "refactored_code": "\t\tprotected final int intFField = Integer.MAX_VALUE;\n                        return;\n                }\n                try {\n                        f = x.getClass().getDeclaredField(\"intFField\");\n                        f.setInt(x, (int) 1);\n                } catch (IllegalAccessException ex) {\n                        // Good, Exception should be thrown since intFField is declared"}
{"magic_number_smell": "\t */\n\tpublic void test_isAbstractI() {\n\t\t// Test for method boolean java.lang.reflect.Modifier.isAbstract(int)\n\t\tassertTrue(\"ABSTRACT returned false\", Modifier.isAbstract(0x7FF));\n\t\tassertTrue(\"ABSTRACT returned false\", Modifier\n\t\t\t\t.isAbstract(Modifier.ABSTRACT));\n\t\tassertTrue(\"Non-ABSTRACT returned true\", !Modifier", "refactored_code": "\tprivate static final int ALL_FLAGS = 0x7FF;\n\t */\n\tpublic void test_isAbstractI() {\n\t\t// Test for method boolean java.lang.reflect.Modifier.isAbstract(int)\n\t\tassertTrue(\"ABSTRACT returned false\", Modifier.isAbstract(ALL_FLAGS));\n\t\tassertTrue(\"ABSTRACT returned false\", Modifier\n\t\t\t\t.isAbstract(Modifier.ABSTRACT));\n\t\tassertTrue(\"Non-ABSTRACT returned true\", !Modifier"}
{"magic_number_smell": "                synchronized (someoneDone) {\n                }\n\n                for (int i = 0; i < 20000; i++) {\n                    if (someoneDone[testType]) {\n                        break;\n                    } else if ((i % 25) == 0", "refactored_code": "        private static final int REP_NUM = 20000;\n                synchronized (someoneDone) {\n                }\n\n                for (int i = 0; i < REP_NUM; i++) {\n                    if (someoneDone[testType]) {\n                        break;\n                    } else if ((i % 25) == 0"}
{"magic_number_smell": "\n\t\t// set http proxy\n\t\tSystem.setProperty(\"http.proxyHost\", HTTP_PROXY_HOST);\n\t\tSystem.setProperty(\"http.proxyPort\", String.valueOf(80));\n\t\t// set https proxy\n\t\tSystem.setProperty(\"https.proxyHost\", HTTPS_PROXY_HOST);\n\t\tSystem.setProperty(\"https.proxyPort\", String.valueOf(HTTPS_PROXY_PORT));", "refactored_code": "\tprivate static final int HTTP_PROXY_PORT = 80;\n\n\t\t// set http proxy\n\t\tSystem.setProperty(\"http.proxyHost\", HTTP_PROXY_HOST);\n\t\tSystem.setProperty(\"http.proxyPort\", String.valueOf(HTTP_PROXY_PORT));\n\t\t// set https proxy\n\t\tSystem.setProperty(\"https.proxyHost\", HTTPS_PROXY_HOST);\n\t\tSystem.setProperty(\"https.proxyPort\", String.valueOf(HTTPS_PROXY_PORT));"}
{"magic_number_smell": "\n                ServerSocket socket = null;\n                switch (serverSocketConstructor) {\n                case 1:\n                    socket = new ServerSocket(port, backlog,\n                            new InetSocketAddress(host, port).getAddress());\n                    port = socket.getLocalPort();", "refactored_code": "        private static final int FIRST_TIME = 1;\n\n                ServerSocket socket = null;\n                switch (serverSocketConstructor) {\n                case FIRST_TIME:\n                    socket = new ServerSocket(port, backlog,\n                            new InetSocketAddress(host, port).getAddress());\n                    port = socket.getLocalPort();"}
{"magic_number_smell": "\t\tcase SO_RCVBUF:\n\t\tcase SO_SNDBUF:\n\t\t\treturn true;\n\t\tcase 0:\n\t\tcase SO_MULTICAST_INTERFACE:\n\t\tcase SO_LINGER:\n\t\t\treturn true;", "refactored_code": "\tpublic static final int SO_MULTICAST = 0;\n\t\tcase SO_RCVBUF:\n\t\tcase SO_SNDBUF:\n\t\t\treturn true;\n\t\tcase SO_MULTICAST:\n\t\tcase SO_MULTICAST_INTERFACE:\n\t\tcase SO_LINGER:\n\t\t\treturn true;"}
{"magic_number_smell": "\t\t// test on subclass SimpleTimeZone\n\t\tTimeZone st1 = TimeZone.getTimeZone(\"EST\");\n\t\tassertEquals(\"T1A. Incorrect daylight savings returned\",\n                             3600000, st1.getDSTSavings());\n\n\t\t// a SimpleTimeZone with daylight savings different then 1 hour\n\t\tst1 = TimeZone.getTimeZone(\"Australia/Lord_Howe\");", "refactored_code": "\tprivate static final int ONE_HOUR = 3600000;\n\t\t// test on subclass SimpleTimeZone\n\t\tTimeZone st1 = TimeZone.getTimeZone(\"EST\");\n\t\tassertEquals(\"T1A. Incorrect daylight savings returned\",\n                             ONE_HOUR, st1.getDSTSavings());\n\n\t\t// a SimpleTimeZone with daylight savings different then 1 hour\n\t\tst1 = TimeZone.getTimeZone(\"Australia/Lord_Howe\");"}
{"magic_number_smell": "                platformEncoding = getEncoding(PlatformEncoding);\n                osEncoding = platformEncoding;\n            } else {\n                getEncoding(0);\n            }\n        } else {\n            platformEncoding = getEncoding(PlatformEncoding);", "refactored_code": "    private static final int InitLocale = 0;\n                platformEncoding = getEncoding(PlatformEncoding);\n                osEncoding = platformEncoding;\n            } else {\n                getEncoding(InitLocale);\n            }\n        } else {\n            platformEncoding = getEncoding(PlatformEncoding);"}
{"magic_number_smell": "     * @return an int containing the kernel version number\n     */\n    public static int getKernelVersion() {\n        return 0x01000100;\n    }\n\n}", "refactored_code": "    private static final int kernelVersion = 0x01000100;\n     * @return an int containing the kernel version number\n     */\n    public static int getKernelVersion() {\n        return kernelVersion;\n    }\n\n}"}
{"magic_number_smell": "\n    /**\n     * Rounding mode to round towards positive infinity. For positive values\n     * this rounding mode behaves as {@link #0}, for negative values as\n     * {@link #ROUND_DOWN}.\n     *\n     * @see RoundingMode#CEILING", "refactored_code": "    public static final int ROUND_UP = 0;\n\n    /**\n     * Rounding mode to round towards positive infinity. For positive values\n     * this rounding mode behaves as {@link #ROUND_UP}, for negative values as\n     * {@link #ROUND_DOWN}.\n     *\n     * @see RoundingMode#CEILING"}
{"magic_number_smell": "     */\n    public static final int 1 = 1;\n    \n    private int hashCode = 1;\n    \n    /**\n     * Returns accumulated hashCode", "refactored_code": "    public static final int EMPTY_HASH_CODE = 1;\n     */\n    public static final int EMPTY_HASH_CODE = 1;\n    \n    private int hashCode = EMPTY_HASH_CODE;\n    \n    /**\n     * Returns accumulated hashCode"}
{"magic_number_smell": "\n    /**\n     * getOS method returns on of the operating system codes:\n     * 1, OS_LINUX, OS_FREEBSD or OS_UNKNOWN\n     * @return Operating system code\n     */\n    public static int getOS() {", "refactored_code": "    public static final int OS_WINDOWS = 1;\n\n    /**\n     * getOS method returns on of the operating system codes:\n     * OS_WINDOWS, OS_LINUX, OS_FREEBSD or OS_UNKNOWN\n     * @return Operating system code\n     */\n    public static int getOS() {"}
{"magic_number_smell": "     * Returns true if the array is currently locked, false otherwise.\n     */\n    public boolean isLocked() {\n        return lockType > 0;\n    }\n\n    /**", "refactored_code": "    private static final int NO_LOCK = 0;\n     * Returns true if the array is currently locked, false otherwise.\n     */\n    public boolean isLocked() {\n        return lockType > NO_LOCK;\n    }\n\n    /**"}
{"magic_number_smell": "     * @param value array to save data\n     * @param offset initial offset in java array\n     * @param length number of array elements to read\n     * @param byteOrder LITTLE_ENDIAN or 0\n     */\n    public final void getChar(long addr, char[] value, int offset, int length, int byteOrder) {\n        if (byteOrder == nativeByteOrder) {", "refactored_code": "    public static final int BIG_ENDIAN = 0;\n     * @param value array to save data\n     * @param offset initial offset in java array\n     * @param length number of array elements to read\n     * @param byteOrder LITTLE_ENDIAN or BIG_ENDIAN\n     */\n    public final void getChar(long addr, char[] value, int offset, int length, int byteOrder) {\n        if (byteOrder == nativeByteOrder) {"}
{"magic_number_smell": "            super(aInputStream);\n            aDecoder.reset();\n            inputStream = aInputStream;\n            int bufferSize = Math.max(minBufferCapacity, 8192);\n            bytes = ByteBuffer.allocate(bufferSize);\n            chars = CharBuffer.allocate(bufferSize);\n            decoder = aDecoder;", "refactored_code": "        private static final int BUFFER_SIZE = 8192;\n            super(aInputStream);\n            aDecoder.reset();\n            inputStream = aInputStream;\n            int bufferSize = Math.max(minBufferCapacity, BUFFER_SIZE);\n            bytes = ByteBuffer.allocate(bufferSize);\n            chars = CharBuffer.allocate(bufferSize);\n            decoder = aDecoder;"}
{"magic_number_smell": "    /**\n     * Indicates whether this key's channel is interested in the accept\n     * operation and is ready to accept new connections. A call to this method\n     * is equal to executing {@code (readyOps() & 16) == 16}.\n     * \n     * @return {@code true} if the channel is interested in the accept operation\n     *         and is ready to accept new connections, {@code false} otherwise.", "refactored_code": "    public static final int OP_ACCEPT = 16;\n    /**\n     * Indicates whether this key's channel is interested in the accept\n     * operation and is ready to accept new connections. A call to this method\n     * is equal to executing {@code (readyOps() & OP_ACCEPT) == OP_ACCEPT}.\n     * \n     * @return {@code true} if the channel is interested in the accept operation\n     *         and is ready to accept new connections, {@code false} otherwise."}
{"magic_number_smell": "                received = networkSystem.recvConnectedDatagram(fd,\n                        receivePacket, receivePacket.getData(), receivePacket\n                                .getOffset(), receivePacket.getLength(),\n                        isBlocking() ? 0 : 1, false);\n            } else {\n                received = networkSystem.receiveDatagram(fd, receivePacket,\n                        receivePacket.getData(), receivePacket.getOffset(),", "refactored_code": "    private static final int DEFAULT_TIMEOUT = 1;\n                received = networkSystem.recvConnectedDatagram(fd,\n                        receivePacket, receivePacket.getData(), receivePacket\n                                .getOffset(), receivePacket.getLength(),\n                        isBlocking() ? 0 : DEFAULT_TIMEOUT, false);\n            } else {\n                received = networkSystem.receiveDatagram(fd, receivePacket,\n                        receivePacket.getData(), receivePacket.getOffset(),"}
{"magic_number_smell": "            return;\n        }\n        bytes.limit(read);\n        boolean endOfInput = read < 8192;\n        CoderResult result = decoder.decode(bytes, chars, endOfInput);\n        if (result.isError()) {\n            throw new IOException(result.toString());", "refactored_code": "    private static final int DEFAULT_BUFFER_SIZE = 8192;\n            return;\n        }\n        bytes.limit(read);\n        boolean endOfInput = read < DEFAULT_BUFFER_SIZE;\n        CoderResult result = decoder.decode(bytes, chars, endOfInput);\n        if (result.isError()) {\n            throw new IOException(result.toString());"}
{"magic_number_smell": "\n            switch (flags[i]) {\n                case READABLE:\n                    selectedOp = OP_ACCEPT | OP_READ & ops;\n                    break;\n                case WRITEABLE:\n                    selectedOp = (OP_CONNECT | OP_WRITE) & ops;", "refactored_code": "    private static final int ACCEPT_OR_READ = OP_ACCEPT | OP_READ;\n\n            switch (flags[i]) {\n                case READABLE:\n                    selectedOp = ACCEPT_OR_READ & ops;\n                    break;\n                case WRITEABLE:\n                    selectedOp = (OP_CONNECT | OP_WRITE) & ops;"}
{"magic_number_smell": "    static final INetworkSystem networkSystem = Platform.getNetworkSystem();\n\n    // Status un-init, not initialized.\n    static final int SOCKET_STATUS_UNINIT = -1;\n\n    // Status before connect.\n    static final int SOCKET_STATUS_UNCONNECTED = 0;", "refactored_code": "    private static final int EOF = -1;\n    static final INetworkSystem networkSystem = Platform.getNetworkSystem();\n\n    // Status un-init, not initialized.\n    static final int SOCKET_STATUS_UNINIT = EOF;\n\n    // Status before connect.\n    static final int SOCKET_STATUS_UNCONNECTED = 0;"}
{"magic_number_smell": "     */\n    public Selector wakeup() {\n        try {\n            sink.write(ByteBuffer.allocate(1));\n        } catch (IOException e) {\n            // do nothing\n        }", "refactored_code": "    private static final int MOCK_WRITEBUF_SIZE = 1;\n     */\n    public Selector wakeup() {\n        try {\n            sink.write(ByteBuffer.allocate(MOCK_WRITEBUF_SIZE));\n        } catch (IOException e) {\n            // do nothing\n        }"}
{"magic_number_smell": "        }\n\n        // case: normal\n        assertTrue(buf.capacity() > 5);\n        buf.position(1);\n        buf.limit(5);\n        buf.mark();", "refactored_code": "    protected static final int SMALL_TEST_LENGTH = 5;\n        }\n\n        // case: normal\n        assertTrue(buf.capacity() > SMALL_TEST_LENGTH);\n        buf.position(1);\n        buf.limit(SMALL_TEST_LENGTH);\n        buf.mark();"}
{"magic_number_smell": "\t\t// compare to self\n\t\tassertEquals(0, buf.compareTo(buf));\n\n\t\tassertTrue(buf.capacity() > 5);\n\t\tbuf.clear();\n\t\tCharBuffer other = CharBuffer.allocate(buf.capacity());\n\t\tother.put(buf);", "refactored_code": "\tprotected static final int SMALL_TEST_LENGTH = 5;\n\t\t// compare to self\n\t\tassertEquals(0, buf.compareTo(buf));\n\n\t\tassertTrue(buf.capacity() > SMALL_TEST_LENGTH);\n\t\tbuf.clear();\n\t\tCharBuffer other = CharBuffer.allocate(buf.capacity());\n\t\tother.put(buf);"}
{"magic_number_smell": "        this.fouts.write(bit);\n        this.fouts.flush();\n        String writebuf = \"\"; //$NON-NLS-1$\n        for (int val = 0; val < this.60 / 2; val++) {\n            writebuf = writebuf + ((char) (val + 64));\n        }\n        this.fouts.write(writebuf.getBytes());", "refactored_code": "    private final int writebufSize = 60;\n        this.fouts.write(bit);\n        this.fouts.flush();\n        String writebuf = \"\"; //$NON-NLS-1$\n        for (int val = 0; val < this.writebufSize / 2; val++) {\n            writebuf = writebuf + ((char) (val + 64));\n        }\n        this.fouts.write(writebuf.getBytes());"}
{"magic_number_smell": "     */\n    public void testReceive_UnconnectedReadonly() throws Exception {\n        assertFalse(this.channel1.isConnected());\n        ByteBuffer dst = ByteBuffer.allocateDirect(200)\n                .asReadOnlyBuffer();\n        assertTrue(dst.isReadOnly());\n        try {", "refactored_code": "    private static final int CAPACITY_NORMAL = 200;\n     */\n    public void testReceive_UnconnectedReadonly() throws Exception {\n        assertFalse(this.channel1.isConnected());\n        ByteBuffer dst = ByteBuffer.allocateDirect(CAPACITY_NORMAL)\n                .asReadOnlyBuffer();\n        assertTrue(dst.isReadOnly());\n        try {"}
{"magic_number_smell": "     * @tests java.nio.channels.FileChannel#read(ByteBuffer)\n     */\n    public void test_readLByteBuffer_Closed() throws Exception {\n        ByteBuffer readBuffer = ByteBuffer.allocate(100);\n\n        readOnlyFileChannel.close();\n        try {", "refactored_code": "    private static final int CAPACITY = 100;\n     * @tests java.nio.channels.FileChannel#read(ByteBuffer)\n     */\n    public void test_readLByteBuffer_Closed() throws Exception {\n        ByteBuffer readBuffer = ByteBuffer.allocate(CAPACITY);\n\n        readOnlyFileChannel.close();\n        try {"}
{"magic_number_smell": "        assert_select_OP_READ(SelectType.TIMEOUT, 0);\n        assert_select_OP_WRITE(SelectType.TIMEOUT, 0);\n\n        assert_select_OP_ACCEPT(SelectType.TIMEOUT, 100);\n        assert_select_OP_CONNECT(SelectType.TIMEOUT, 100);\n        assert_select_OP_READ(SelectType.TIMEOUT, 100);\n        assert_select_OP_WRITE(SelectType.TIMEOUT, 100);", "refactored_code": "    private static final int WAIT_TIME = 100;\n        assert_select_OP_READ(SelectType.TIMEOUT, 0);\n        assert_select_OP_WRITE(SelectType.TIMEOUT, 0);\n\n        assert_select_OP_ACCEPT(SelectType.TIMEOUT, WAIT_TIME);\n        assert_select_OP_CONNECT(SelectType.TIMEOUT, WAIT_TIME);\n        assert_select_OP_READ(SelectType.TIMEOUT, WAIT_TIME);\n        assert_select_OP_WRITE(SelectType.TIMEOUT, WAIT_TIME);"}
{"magic_number_smell": "     */\n    public void test_read_Blocking_RealData() throws IOException {\n        serverChannel.socket().bind(localAddr1);\n        ByteBuffer buf = ByteBuffer.allocate(200);\n\n        for (int i = 0; i < 200; i++) {\n            buf.put((byte) i);", "refactored_code": "    private static final int CAPACITY_NORMAL = 200;\n     */\n    public void test_read_Blocking_RealData() throws IOException {\n        serverChannel.socket().bind(localAddr1);\n        ByteBuffer buf = ByteBuffer.allocate(CAPACITY_NORMAL);\n\n        for (int i = 0; i < CAPACITY_NORMAL; i++) {\n            buf.put((byte) i);"}
{"magic_number_smell": "\t\tsource = pipe.source();\n\t\tbuffer = ByteBuffer.wrap(\"bytes\".getBytes(ISO8859_1));\n\t\tpositionedBuffer = ByteBuffer.wrap(\"12345bytes\".getBytes(ISO8859_1));\n\t\tpositionedBuffer.position(5);\n\t}\n\n\t/**", "refactored_code": "\tprivate static final int BUFFER_SIZE = 5;\n\t\tsource = pipe.source();\n\t\tbuffer = ByteBuffer.wrap(\"bytes\".getBytes(ISO8859_1));\n\t\tpositionedBuffer = ByteBuffer.wrap(\"12345bytes\".getBytes(ISO8859_1));\n\t\tpositionedBuffer.position(BUFFER_SIZE);\n\t}\n\n\t/**"}
{"magic_number_smell": "     */\n    public void testOpen() throws IOException {\n        java.nio.ByteBuffer[] buf = new java.nio.ByteBuffer[1];\n        buf[0] = java.nio.ByteBuffer.allocateDirect(200);\n        MockSocketChannel testMSChannel = new MockSocketChannel(null);\n        MockSocketChannel testMSChannelnotnull = new MockSocketChannel(\n                SelectorProvider.provider());", "refactored_code": "    private static final int CAPACITY_NORMAL = 200;\n     */\n    public void testOpen() throws IOException {\n        java.nio.ByteBuffer[] buf = new java.nio.ByteBuffer[1];\n        buf[0] = java.nio.ByteBuffer.allocateDirect(CAPACITY_NORMAL);\n        MockSocketChannel testMSChannel = new MockSocketChannel(null);\n        MockSocketChannel testMSChannelnotnull = new MockSocketChannel(\n                SelectorProvider.provider());"}
{"magic_number_smell": "\t\tsource = pipe.source();\n\t\tbuffer = ByteBuffer.wrap(\"bytes\".getBytes(ISO8859_1));\n\t\tpositionedBuffer = ByteBuffer.wrap(\"12345bytes\".getBytes(ISO8859_1));\n\t\tpositionedBuffer.position(5);\n\t}\n\n\t/**", "refactored_code": "\tprivate static final int BUFFER_SIZE = 5;\n\t\tsource = pipe.source();\n\t\tbuffer = ByteBuffer.wrap(\"bytes\".getBytes(ISO8859_1));\n\t\tpositionedBuffer = ByteBuffer.wrap(\"12345bytes\".getBytes(ISO8859_1));\n\t\tpositionedBuffer.position(BUFFER_SIZE);\n\t}\n\n\t/**"}
{"magic_number_smell": "        averChars = averageCharsPerByte;\n        maxChars = maxCharsPerByte;\n        cs = charset;\n        status = 0;\n        malformAction = CodingErrorAction.REPORT;\n        unmapAction = CodingErrorAction.REPORT;\n        replace = \"\\ufffd\"; //$NON-NLS-1$", "refactored_code": "    private static final int INIT = 0;\n        averChars = averageCharsPerByte;\n        maxChars = maxCharsPerByte;\n        cs = charset;\n        status = INIT;\n        malformAction = CodingErrorAction.REPORT;\n        unmapAction = CodingErrorAction.REPORT;\n        replace = \"\\ufffd\"; //$NON-NLS-1$"}
{"magic_number_smell": "    // implementation of canEncode\n    private boolean implCanEncode(CharBuffer cb) {\n        if (status == FLUSH || status == INIT) {\n            status = 0;\n        }\n        if (status != 0) {\n            // niochar.0B=Another encoding process is ongoing\\!", "refactored_code": "    private static final int READY = 0;\n    // implementation of canEncode\n    private boolean implCanEncode(CharBuffer cb) {\n        if (status == FLUSH || status == INIT) {\n            status = READY;\n        }\n        if (status != READY) {\n            // niochar.0B=Another encoding process is ongoing\\!"}
{"magic_number_smell": "     * Result object indicating that there is insufficient data in the\n     * encoding/decoding buffer or that additional data is required.\n     */\n    public static final CoderResult UNDERFLOW = new CoderResult(1,\n            0);\n\n    /**", "refactored_code": "    private static final int TYPE_UNDERFLOW = 1;\n     * Result object indicating that there is insufficient data in the\n     * encoding/decoding buffer or that additional data is required.\n     */\n    public static final CoderResult UNDERFLOW = new CoderResult(TYPE_UNDERFLOW,\n            0);\n\n    /**"}
{"magic_number_smell": "        // Make an instance of the found charset.\n        if (arr[CHARSET_INSTANCE] == null) {\n            final String className = packageName\n                    + \".\" + (String) arr[0]; //$NON-NLS-1$\n            final String canonicalName = ((String[]) arr[CHARSET_ALIASES])[0];\n            final String aliases[] = (String[]) arr[CHARSET_ALIASES];\n            arr[CHARSET_INSTANCE] = AccessController", "refactored_code": "    protected static final int CHARSET_CLASS = 0;\n        // Make an instance of the found charset.\n        if (arr[CHARSET_INSTANCE] == null) {\n            final String className = packageName\n                    + \".\" + (String) arr[CHARSET_CLASS]; //$NON-NLS-1$\n            final String canonicalName = ((String[]) arr[CHARSET_ALIASES])[0];\n            final String aliases[] = (String[]) arr[CHARSET_ALIASES];\n            arr[CHARSET_INSTANCE] = AccessController"}
{"magic_number_smell": "        }\n\n        protected void implReset() {\n            endian = -1;\n        }\n\n        protected CoderResult decodeLoop(ByteBuffer in, CharBuffer out) {", "refactored_code": "    protected static final int UNKNOWN = -1;\n        }\n\n        protected void implReset() {\n            endian = UNKNOWN;\n        }\n\n        protected CoderResult decodeLoop(ByteBuffer in, CharBuffer out) {"}
{"magic_number_smell": "    public void testEncodeMapping() throws CharacterCodingException {\n        encoder.reset();\n        \n        for (int i =0; i <= 0x7F; i++) {\n            char[] chars = Character.toChars(i);\n            CharBuffer cb = CharBuffer.wrap(chars);\n            ByteBuffer bb = encoder.encode(cb);", "refactored_code": "    private static final int MAXCODEPOINT = 0x7F; \n    public void testEncodeMapping() throws CharacterCodingException {\n        encoder.reset();\n        \n        for (int i =0; i <= MAXCODEPOINT; i++) {\n            char[] chars = Character.toChars(i);\n            CharBuffer cb = CharBuffer.wrap(chars);\n            ByteBuffer bb = encoder.encode(cb);"}
{"magic_number_smell": "    // */\n    // public void testDefaultCharsPerByte() {\n    // assertTrue(decoder.averageCharsPerByte() == AVER_BYTES);\n    // assertTrue(decoder.maxCharsPerByte() == 3);\n    // }\n\n    public void testDefaultValues() {", "refactored_code": "    protected static final int MAX_BYTES = 3;\n    // */\n    // public void testDefaultCharsPerByte() {\n    // assertTrue(decoder.averageCharsPerByte() == AVER_BYTES);\n    // assertTrue(decoder.maxCharsPerByte() == MAX_BYTES);\n    // }\n\n    public void testDefaultValues() {"}
{"magic_number_smell": "            availableClassIndices = addHighIndices(availableClassIndices);\n        }\n        addAttributeDefinitions(classLayouts, availableClassIndices,\n                0);\n        int[] availableMethodIndices = new int[] { 26, 27, 28, 29, 30, 31 };\n        if (methodAttributeLayouts.size() > 6) {\n            availableMethodIndices = addHighIndices(availableMethodIndices);", "refactored_code": "    public static final int CONTEXT_CLASS = 0;\n            availableClassIndices = addHighIndices(availableClassIndices);\n        }\n        addAttributeDefinitions(classLayouts, availableClassIndices,\n                CONTEXT_CLASS);\n        int[] availableMethodIndices = new int[] { 26, 27, 28, 29, 30, 31 };\n        if (methodAttributeLayouts.size() > 6) {\n            availableMethodIndices = addHighIndices(availableMethodIndices);"}
{"magic_number_smell": "    public void visitMultiANewArrayInsn(String desc, int dimensions) {\n        byteCodeOffset += 4;\n        updateRenumbering();\n        bcCodes.add(197);\n        bcClassRef.add(cpBands.getCPClass(desc));\n        bcByte.add(dimensions & 0xFF);\n    }", "refactored_code": "    private static final int MULTIANEWARRAY = 197;\n    public void visitMultiANewArrayInsn(String desc, int dimensions) {\n        byteCodeOffset += 4;\n        updateRenumbering();\n        bcCodes.add(MULTIANEWARRAY);\n        bcClassRef.add(cpBands.getCPClass(desc));\n        bcByte.add(dimensions & 0xFF);\n    }"}
{"magic_number_smell": "     * @param type\n     *            must be either AD, RVA, RIA, RVPA or RIPA.\n     * @param context\n     *            <code>0</code>, <code>CONTEXT_METHOD</code> or\n     *            <code>CONTEXT_FIELD</code>\n     * @param cpBands\n     *            constant pool bands", "refactored_code": "    public static final int CONTEXT_CLASS = 0;\n     * @param type\n     *            must be either AD, RVA, RIA, RVPA or RIPA.\n     * @param context\n     *            <code>CONTEXT_CLASS</code>, <code>CONTEXT_METHOD</code> or\n     *            <code>CONTEXT_FIELD</code>\n     * @param cpBands\n     *            constant pool bands"}
{"magic_number_smell": "     */\n    public void pack(OutputStream out) throws IOException, Pack200Exception {\n        out.write(encodeScalar(magic, Codec.BYTE1));\n        out.write(encodeScalar(7, Codec.UNSIGNED5));\n        out.write(encodeScalar(archive_majver, Codec.UNSIGNED5));\n        calculateArchiveOptions();\n        out.write(encodeScalar(archive_options, Codec.UNSIGNED5));", "refactored_code": "    private static final int archive_minver = 7;\n     */\n    public void pack(OutputStream out) throws IOException, Pack200Exception {\n        out.write(encodeScalar(magic, Codec.BYTE1));\n        out.write(encodeScalar(archive_minver, Codec.UNSIGNED5));\n        out.write(encodeScalar(archive_majver, Codec.UNSIGNED5));\n        calculateArchiveOptions();\n        out.write(encodeScalar(archive_options, Codec.UNSIGNED5));"}
{"magic_number_smell": "        } else {\n            this.mask = 0;\n        }\n        if (context != 0 && context != CONTEXT_CODE\n                && context != CONTEXT_FIELD && context != CONTEXT_METHOD)\n            throw new Pack200Exception(\"Attribute context out of range: \"\n                    + context);", "refactored_code": "    public static final int CONTEXT_CLASS = 0;\n        } else {\n            this.mask = 0;\n        }\n        if (context != CONTEXT_CLASS && context != CONTEXT_CODE\n                && context != CONTEXT_FIELD && context != CONTEXT_METHOD)\n            throw new Pack200Exception(\"Attribute context out of range: \"\n                    + context);"}
{"magic_number_smell": "     * @return boolean\n     */\n    public boolean nestedExplicitFlagSet() {\n        return (F & 0x00010000) == 0x00010000;\n    }\n\n    /**", "refactored_code": "    public static final int NESTED_CLASS_FLAG = 0x00010000;\n     * @return boolean\n     */\n    public boolean nestedExplicitFlagSet() {\n        return (F & NESTED_CLASS_FLAG) == NESTED_CLASS_FLAG;\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    private void readSegment(InputStream in) throws IOException,\n            Pack200Exception {\n        log(2, \"-------\");\n        cpBands = new CpBands(this);\n        cpBands.read(in);\n        attrDefinitionBands = new AttrDefinitionBands(this);", "refactored_code": "    public static final int LOG_LEVEL_VERBOSE = 2;\n     */\n    private void readSegment(InputStream in) throws IOException,\n            Pack200Exception {\n        log(LOG_LEVEL_VERBOSE, \"-------\");\n        cpBands = new CpBands(this);\n        cpBands.read(in);\n        attrDefinitionBands = new AttrDefinitionBands(this);"}
{"magic_number_smell": "    }\n\n    public boolean shouldDeflate() {\n        return (options & 1 << 5) != 0;\n    }\n}\n", "refactored_code": "    private static final int DEFLATE_HINT = 1 << 5;\n    }\n\n    public boolean shouldDeflate() {\n        return (options & DEFLATE_HINT) != 0;\n    }\n}\n"}
{"magic_number_smell": "    public Attribute[] attributes;\n\n    public void write(DataOutputStream dos) throws IOException {\n        dos.writeInt(0xCAFEBABE);\n        dos.writeShort(minor);\n        dos.writeShort(major);\n        dos.writeShort(pool.size() + 1);", "refactored_code": "    private final int magic = 0xCAFEBABE;\n    public Attribute[] attributes;\n\n    public void write(DataOutputStream dos) throws IOException {\n        dos.writeInt(magic);\n        dos.writeShort(minor);\n        dos.writeShort(major);\n        dos.writeShort(pool.size() + 1);"}
{"magic_number_smell": "\n    /*\n     * class MemberRef extends ConstantPoolEntry { private int index;\n     * Class(String name) { super(7); index = pool.indexOf(name); } void\n     * writeBody(DataOutputStream dos) throws IOException {\n     * dos.writeShort(index); } }\n     */", "refactored_code": "    public static final byte CP_Class = 7;\n\n    /*\n     * class MemberRef extends ConstantPoolEntry { private int index;\n     * Class(String name) { super(CP_Class); index = pool.indexOf(name); } void\n     * writeBody(DataOutputStream dos) throws IOException {\n     * dos.writeShort(index); } }\n     */"}
{"magic_number_smell": "        assertEquals(0xCAFEBABE, din.readInt());\n        din.readShort(); // MINOR -- don't care\n        assertTrue(\"Class file has been compiled with Java 1.5 compatibility\"\n                + \" instead of 1.4 or lower\", din.readShort() < 49);\n    }\n\n    public void testCorrectVersionOfTest() throws IOException {", "refactored_code": "    private static final int JAVA_15 = 49;\n        assertEquals(0xCAFEBABE, din.readInt());\n        din.readShort(); // MINOR -- don't care\n        assertTrue(\"Class file has been compiled with Java 1.5 compatibility\"\n                + \" instead of 1.4 or lower\", din.readShort() < JAVA_15);\n    }\n\n    public void testCorrectVersionOfTest() throws IOException {"}
{"magic_number_smell": "\n    private static class NodeRemoveEvent extends NodeChangeEvent {\n        // The base class is NOT serializable, so this class isn't either.\n        private static final long 1L = 1L;\n\n        public NodeRemoveEvent(Preferences p, Preferences c) {\n            super(p, c);", "refactored_code": "        private static final long serialVersionUID = 1L;\n\n    private static class NodeRemoveEvent extends NodeChangeEvent {\n        // The base class is NOT serializable, so this class isn't either.\n        private static final long serialVersionUID = 1L;\n\n        public NodeRemoveEvent(Preferences p, Preferences c) {\n            super(p, c);"}
{"magic_number_smell": "     *             if the given key or value is {@code null}.\n     * @throws IllegalArgumentException\n     *             if the given key's length is bigger than {@code\n     *             80} or the value's length is bigger than {@code\n     *             MAX_VALUE_LENGTH}.\n     * @throws IllegalStateException\n     *             if this node has been removed.", "refactored_code": "    public static final int MAX_KEY_LENGTH = 80;\n     *             if the given key or value is {@code null}.\n     * @throws IllegalArgumentException\n     *             if the given key's length is bigger than {@code\n     *             MAX_KEY_LENGTH} or the value's length is bigger than {@code\n     *             MAX_VALUE_LENGTH}.\n     * @throws IllegalStateException\n     *             if this node has been removed."}
{"magic_number_smell": "    protected String[] childrenNamesSpi() throws BackingStoreException {\n        int[] error = new int[1];\n        byte[][] names = getChildNames(path, userNode, error);\n        if (error[0] != RETURN_SUCCESS) {\n            // prefs.B=Enumerate child nodes error\n            throw new BackingStoreException(Messages.getString(\"prefs.B\")); //$NON-NLS-1$\n        }", "refactored_code": "    private static final int ERROR_CODE = 0;\n    protected String[] childrenNamesSpi() throws BackingStoreException {\n        int[] error = new int[1];\n        byte[][] names = getChildNames(path, userNode, error);\n        if (error[ERROR_CODE] != RETURN_SUCCESS) {\n            // prefs.B=Enumerate child nodes error\n            throw new BackingStoreException(Messages.getString(\"prefs.B\")); //$NON-NLS-1$\n        }"}
{"magic_number_smell": "        out.newLine();\n\n        flushStartTag(\"preferences\", new String[] { \"EXTERNAL_XML_VERSION\" },\n                new String[] { String.valueOf(1.0f) }, out);\n        flushStartTag(\"root\", new String[] { \"type\" }, new String[] { prefs\n                .isUserNode() ? \"user\" : \"system\" }, out);\n        flushEmptyElement(\"map\", out);", "refactored_code": "    private static final float XML_VERSION = 1.0f;\n        out.newLine();\n\n        flushStartTag(\"preferences\", new String[] { \"EXTERNAL_XML_VERSION\" },\n                new String[] { String.valueOf(XML_VERSION) }, out);\n        flushStartTag(\"root\", new String[] { \"type\" }, new String[] { prefs\n                .isUserNode() ? \"user\" : \"system\" }, out);\n        flushEmptyElement(\"map\", out);"}
{"magic_number_smell": "\n    // --------------------------------------------------------------\n    public static class BYTE_ARRAY extends DocFlavor {\n        private static final long -4512080796965449721L = -9065578006593857475L;\n\n        public BYTE_ARRAY(String mimeType) {\n            super(mimeType, \"[B\");", "refactored_code": "    private static final long serialVersionUID = -4512080796965449721L;\n\n    // --------------------------------------------------------------\n    public static class BYTE_ARRAY extends DocFlavor {\n        private static final long serialVersionUID = -9065578006593857475L;\n\n        public BYTE_ARRAY(String mimeType) {\n            super(mimeType, \"[B\");"}
{"magic_number_smell": "        extends SynchronizedAttributeSet\n            implements DocAttributeSet, Serializable {\n\n        private static final long 8365731020128564925L = 6455869095246629354L;\n        \n        public SynchronizedDocAttributeSet(DocAttributeSet attributeSet) {\n            super(attributeSet);", "refactored_code": "        private static final long serialVersionUID = 8365731020128564925L;\n        extends SynchronizedAttributeSet\n            implements DocAttributeSet, Serializable {\n\n        private static final long serialVersionUID = 6455869095246629354L;\n        \n        public SynchronizedDocAttributeSet(DocAttributeSet attributeSet) {\n            super(attributeSet);"}
{"magic_number_smell": "    /*\n     * ActionListener for \"Print\" button:\n     * if we can get correct result attribute set (newAttrs),\n     * hides the dialog and set dialog result to 1\n     */\n    class OKButtonListener implements ActionListener {\n        public void actionPerformed(ActionEvent e) {", "refactored_code": "    public static final int APPROVE_PRINT = 1;    // OK button was pressed\n    /*\n     * ActionListener for \"Print\" button:\n     * if we can get correct result attribute set (newAttrs),\n     * hides the dialog and set dialog result to APPROVE_PRINT\n     */\n    class OKButtonListener implements ActionListener {\n        public void actionPerformed(ActionEvent e) {"}
{"magic_number_smell": "\n    public static String getString(int op) {\n        switch (op) {\n        case 0x0002:\n            return IppResources.getString(\"IppOperation.0x0002\");\n        case PRINT_URI:\n            return IppResources.getString(\"IppOperation.PRINT_URI\");", "refactored_code": "    public static final short PRINT_JOB = 0x0002;\n\n    public static String getString(int op) {\n        switch (op) {\n        case PRINT_JOB:\n            return IppResources.getString(\"IppOperation.PRINT_JOB\");\n        case PRINT_URI:\n            return IppResources.getString(\"IppOperation.PRINT_URI\");"}
{"magic_number_smell": "        if (res != null) {\n            attrs.add(res);\n        }\n        if ((flags & 0x00000001) != 0) {\n            attrs.add(getOrientation());\n        }\n        if ((flags & DM_COPIES) != 0) {", "refactored_code": "    public static final int   DM_ORIENTATION     = 0x00000001;\n        if (res != null) {\n            attrs.add(res);\n        }\n        if ((flags & DM_ORIENTATION) != 0) {\n            attrs.add(getOrientation());\n        }\n        if ((flags & DM_COPIES) != 0) {"}
{"magic_number_smell": "        }\n        queue.remove(queue.size() - 1);\n        switch (command) {\n            case 0:\n                try {\n                    double x, y;\n                    y = Double.parseDouble(extractQueueLast());", "refactored_code": "    private static final int COMMAND_MOVETO = 0;\n        }\n        queue.remove(queue.size() - 1);\n        switch (command) {\n            case COMMAND_MOVETO:\n                try {\n                    double x, y;\n                    y = Double.parseDouble(extractQueueLast());"}
{"magic_number_smell": "                }\n\n                case '$':\n                    lookAhead = 0xe0000000 | '$';\n                    break;\n                case '(': {\n                    if (pattern[index] == '?') {", "refactored_code": "    public static final int CHAR_DOLLAR = 0xe0000000 | '$';\n                }\n\n                case '$':\n                    lookAhead = CHAR_DOLLAR;\n                    break;\n                case '(': {\n                    if (pattern[index] == '?') {"}
{"magic_number_smell": "                                private final int gr = gr;\n\n                                public String toString() {\n                                    return group(gr);\n                                }\n                            });\n                            String group = group(gr);", "refactored_code": "                                private final int grN = gr;\n                                private final int grN = gr;\n\n                                public String toString() {\n                                    return group(grN);\n                                }\n                            });\n                            String group = group(gr);"}
{"magic_number_smell": "    \n    /**\n     * Returns the type of the token, may return following values:\n     * 1 << 0  - token representing character class;\n     * TOK_QUANTIFIER - token representing quantifier;\n     * \n     * @return character type.", "refactored_code": "    public static final int TOK_CHARCLASS = 1 << 0;\n    \n    /**\n     * Returns the type of the token, may return following values:\n     * TOK_CHARCLASS  - token representing character class;\n     * TOK_QUANTIFIER - token representing quantifier;\n     * \n     * @return character type."}
{"magic_number_smell": "    }\n\n    public static class CommandEnvironment implements Serializable {\n        private static final long -4936225423168276595L = 6165754737887770191L;\n\n        private String command;\n", "refactored_code": "    private static final long serialVersionUID = -4936225423168276595L;\n    }\n\n    public static class CommandEnvironment implements Serializable {\n        private static final long serialVersionUID = 6165754737887770191L;\n\n        private String command;\n"}
{"magic_number_smell": "        }\n        levelStr = levelStr.trim().toUpperCase();\n\n        if (levelStr.equals(\"0\")) { //$NON-NLS-1$\n            return 0;\n        } else if (levelStr.equals(\"BRIEF\")) { //$NON-NLS-1$\n            return BRIEF;", "refactored_code": "    public static final int SILENT = 0;\n        }\n        levelStr = levelStr.trim().toUpperCase();\n\n        if (levelStr.equals(\"SILENT\")) { //$NON-NLS-1$\n            return SILENT;\n        } else if (levelStr.equals(\"BRIEF\")) { //$NON-NLS-1$\n            return BRIEF;"}
{"magic_number_smell": "     */\n    public NodeInfo(Object id) {\n        this.id = id;\n        this.state = 0;\n    }\n\n    /**", "refactored_code": "    private static final int REGISTERED_STATE = 0;\n     */\n    public NodeInfo(Object id) {\n        this.id = id;\n        this.state = REGISTERED_STATE;\n    }\n\n    /**"}
{"magic_number_smell": "\n    class Delta implements Serializable {\n\n        private static final long -4936383024184263236L = 103662164369676173L;\n\n        private static final int PUT = 0;\n", "refactored_code": "    private static final long serialVersionUID = -4936383024184263236L;\n\n    class Delta implements Serializable {\n\n        private static final long serialVersionUID = 103662164369676173L;\n\n        private static final int PUT = 0;\n"}
{"magic_number_smell": "                throw new java.rmi.UnmarshalException(Messages.getString(\"rmi.28\", hash)); //$NON-NLS-1$\n            }\n        } else {\n            if (hash != 8470858815147946311L) {\n                // rmi.29=Interface hash mismatch, expected: {0}, received: {1}\n                throw new java.rmi.server.SkeletonMismatchException(\n                        Messages.getString(\"rmi.29\", 8470858815147946311L, hash)); //$NON-NLS-1$ //$NON-NLS-2$", "refactored_code": "    private static final long interfaceHash = 8470858815147946311L;\n                throw new java.rmi.UnmarshalException(Messages.getString(\"rmi.28\", hash)); //$NON-NLS-1$\n            }\n        } else {\n            if (hash != interfaceHash) {\n                // rmi.29=Interface hash mismatch, expected: {0}, received: {1}\n                throw new java.rmi.server.SkeletonMismatchException(\n                        Messages.getString(\"rmi.29\", interfaceHash, hash)); //$NON-NLS-1$ //$NON-NLS-2$"}
{"magic_number_smell": "     */\n    String tDecrease(int steps) throws IndexOutOfBoundsException {\n        return currentIndent.substring(0,\n                (currentIndent.length() - (steps * stepString.length())));\n    }\n\n    /**", "refactored_code": "    private final int STEP_LENGTH = stepString.length();\n     */\n    String tDecrease(int steps) throws IndexOutOfBoundsException {\n        return currentIndent.substring(0,\n                (currentIndent.length() - (steps * STEP_LENGTH)));\n    }\n\n    /**"}
{"magic_number_smell": "                throw new java.rmi.UnmarshalException(Messages.getString(\"rmi.28\", hash)); //$NON-NLS-1$\n            }\n        } else {\n            if (hash != 4905912898345647071L) {\n                throw new java.rmi.server.SkeletonMismatchException(\n                        Messages.getString(\"rmi.29\", 4905912898345647071L, hash)); //$NON-NLS-1$\n            }", "refactored_code": "    private static final long interfaceHash = 4905912898345647071L;\n                throw new java.rmi.UnmarshalException(Messages.getString(\"rmi.28\", hash)); //$NON-NLS-1$\n            }\n        } else {\n            if (hash != interfaceHash) {\n                throw new java.rmi.server.SkeletonMismatchException(\n                        Messages.getString(\"rmi.29\", interfaceHash, hash)); //$NON-NLS-1$\n            }"}
{"magic_number_smell": "    }\n\n    public void dispatch(java.rmi.Remote obj, java.rmi.server.RemoteCall call, int opnum, long hash) throws java.lang.Exception {\n        if (hash != -669196253586618813L) {\n            // rmi.2D=Interface hash mismatch, expected: {0}, received: {1}\n            throw new java.rmi.server.SkeletonMismatchException(\n                    Messages.getString(\"rmi.2D\", -669196253586618813L, hash)); //$NON-NLS-1$", "refactored_code": "    private static final long interfaceHash = -669196253586618813L;\n    }\n\n    public void dispatch(java.rmi.Remote obj, java.rmi.server.RemoteCall call, int opnum, long hash) throws java.lang.Exception {\n        if (hash != interfaceHash) {\n            // rmi.2D=Interface hash mismatch, expected: {0}, received: {1}\n            throw new java.rmi.server.SkeletonMismatchException(\n                    Messages.getString(\"rmi.2D\", interfaceHash, hash)); //$NON-NLS-1$"}
{"magic_number_smell": "    public void clean(java.rmi.server.ObjID[] $param_arrayOf_ObjID_1, long $param_long_2, java.rmi.dgc.VMID $param_VMID_3, boolean $param_boolean_4)\n            throws java.rmi.RemoteException {\n        try {\n            java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 0, -669196253586618813L);\n\n            try {\n                java.io.ObjectOutput out = call.getOutputStream();", "refactored_code": "    private static final long interfaceHash = -669196253586618813L;\n    public void clean(java.rmi.server.ObjID[] $param_arrayOf_ObjID_1, long $param_long_2, java.rmi.dgc.VMID $param_VMID_3, boolean $param_boolean_4)\n            throws java.rmi.RemoteException {\n        try {\n            java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 0, interfaceHash);\n\n            try {\n                java.io.ObjectOutput out = call.getOutputStream();"}
{"magic_number_smell": "                    // for a number of times, we should sleep for a while.\n                    if (failedAcceptsNum >= 5) {\n                        try {\n                            Thread.sleep(3000);\n                        } catch (InterruptedException ie) {\n                            return;\n                        }", "refactored_code": "    private static final long defaultFailureDelay = 3000;\n                    // for a number of times, we should sleep for a while.\n                    if (failedAcceptsNum >= 5) {\n                        try {\n                            Thread.sleep(defaultFailureDelay);\n                        } catch (InterruptedException ie) {\n                            return;\n                        }"}
{"magic_number_smell": "            throws IOException {\n        if (writeCsf) {\n            if (csf == null) {\n                out.writeByte(0x00);\n            } else {\n                out.writeByte(NONNULL_CSF);\n            }", "refactored_code": "    public static final int NULL_CSF = 0x00;\n            throws IOException {\n        if (writeCsf) {\n            if (csf == null) {\n                out.writeByte(NULL_CSF);\n            } else {\n                out.writeByte(NONNULL_CSF);\n            }"}
{"magic_number_smell": "        public void run() {\n            while (true) {\n                try {\n                    sleep(10000);\n                } catch (InterruptedException e) {}\n\n                System.out.println(\"GCThread: Calling GC\");", "refactored_code": "    private static final int GC_TICK = 10000;\n        public void run() {\n            while (true) {\n                try {\n                    sleep(GC_TICK);\n                } catch (InterruptedException e) {}\n\n                System.out.println(\"GCThread: Calling GC\");"}
{"magic_number_smell": "     */\n    protected static void setEnvironmentForConfig(int config) {\n        switch (config) {\n        case 0:\n            setEnvironment(\n                    false,  // disableHttp\n                    false,  // eagerHttpFallback", "refactored_code": "    protected static final int CONFIG_DIRECT_SOCKET = 0;\n     */\n    protected static void setEnvironmentForConfig(int config) {\n        switch (config) {\n        case CONFIG_DIRECT_SOCKET:\n            setEnvironment(\n                    false,  // disableHttp\n                    false,  // eagerHttpFallback"}
{"magic_number_smell": "\n    /**\n     * Represents the current state of this {@code Signature}. The three\n     * possible states are {@link #0}, {@link #SIGN} or\n     * {@link #VERIFY}.\n     */\n    protected int state = 0;", "refactored_code": "    protected static final int UNINITIALIZED = 0;\n\n    /**\n     * Represents the current state of this {@code Signature}. The three\n     * possible states are {@link #UNINITIALIZED}, {@link #SIGN} or\n     * {@link #VERIFY}.\n     */\n    protected int state = UNINITIALIZED;"}
{"magic_number_smell": "     */\n    protected static class CertificateRep implements Serializable {\n\n        private static final long -3585440601605666277L = -8563758940495660020L;\n        // The standard name of the certificate type\n        private final String type;\n        // The certificate data", "refactored_code": "    private static final long serialVersionUID = -3585440601605666277L;\n     */\n    protected static class CertificateRep implements Serializable {\n\n        private static final long serialVersionUID = -8563758940495660020L;\n        // The standard name of the certificate type\n        private final String type;\n        // The certificate data"}
{"magic_number_smell": "     */\n    protected static class CertPathRep implements Serializable {\n\n        private static final long 6068470306649138683L = 3015633072427920915L;\n        // Standard name of the type of certificates in this path\n        private final String type;\n        // cert path data", "refactored_code": "    private static final long serialVersionUID = 6068470306649138683L;\n     */\n    protected static class CertPathRep implements Serializable {\n\n        private static final long serialVersionUID = 3015633072427920915L;\n        // Standard name of the type of certificates in this path\n        private final String type;\n        // cert path data"}
{"magic_number_smell": "     */\n    public LDAPCertStoreParameters() {\n        this.serverName = DEFAULT_LDAP_SERVER_NAME;\n        this.port = 389;\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_LDAP_PORT  = 389;\n     */\n    public LDAPCertStoreParameters() {\n        this.serverName = DEFAULT_LDAP_SERVER_NAME;\n        this.port = DEFAULT_LDAP_PORT;\n    }\n\n    /**"}
{"magic_number_smell": "    // Mid terms array length for pentanomial basis\n    private static final int PPB_MID_LEN = 3;\n    // All terms number for trinomial basis\n    private static final int TPB_LEN = 1 + 2;\n    // All terms number for pentanomial basis\n    private static final int PPB_LEN = PPB_MID_LEN + 2;\n    // m value", "refactored_code": "    private static final int TPB_MID_LEN = 1;\n    // Mid terms array length for pentanomial basis\n    private static final int PPB_MID_LEN = 3;\n    // All terms number for trinomial basis\n    private static final int TPB_LEN = TPB_MID_LEN + 2;\n    // All terms number for pentanomial basis\n    private static final int PPB_LEN = PPB_MID_LEN + 2;\n    // m value"}
{"magic_number_smell": "        private final int maxBits;\n\n        public ASN1NamedBitList() {\n            this.minBits = -1;\n            this.maxBits = -1;\n        }\n", "refactored_code": "        private static final int INDEFINITE_SIZE = -1;\n        private final int maxBits;\n\n        public ASN1NamedBitList() {\n            this.minBits = INDEFINITE_SIZE;\n            this.maxBits = INDEFINITE_SIZE;\n        }\n"}
{"magic_number_smell": "                taggingType = TAGGING_STRING;\n            } else {\n                // if the base encoding is primitive use primitive encoding\n                taggingType = 0;\n            }\n        } else {\n            // if the base encoding is constructed use constructed encoding", "refactored_code": "    private static final int TAGGING_PRIMITIVE = 0;\n                taggingType = TAGGING_STRING;\n            } else {\n                // if the base encoding is primitive use primitive encoding\n                taggingType = TAGGING_PRIMITIVE;\n            }\n        } else {\n            // if the base encoding is constructed use constructed encoding"}
{"magic_number_smell": "     * @param is associated <code>InputStream</code>\n     */\n    public BerInputStream(InputStream in) throws IOException {\n        this(in, 1024 * 16);\n    }\n\n    /**", "refactored_code": "    private static final int BUF_INCREASE_SIZE = 1024 * 16;\n     * @param is associated <code>InputStream</code>\n     */\n    public BerInputStream(InputStream in) throws IOException {\n        this(in, BUF_INCREASE_SIZE);\n    }\n\n    /**"}
{"magic_number_smell": "        if (idx == cache_size) {\n            return null;\n        }\n        while ((hashes_idx[idx] & 0xFFFFFFFFFFFF0000L) == hash) {\n            int i = (int) (hashes_idx[idx] & INDEX_MASK) - 1;\n            if (Arrays.equals(encoding, encodings[i])) {\n                return cache[i];", "refactored_code": "    private static final long HASH_MASK = 0xFFFFFFFFFFFF0000L;\n        if (idx == cache_size) {\n            return null;\n        }\n        while ((hashes_idx[idx] & HASH_MASK) == hash) {\n            int i = (int) (hashes_idx[idx] & INDEX_MASK) - 1;\n            if (Arrays.equals(encoding, encodings[i])) {\n                return cache[i];"}
{"magic_number_smell": "        // after the mark has been set up\n        private static final int 32 = 32;\n        // buffer to keep the bytes read after the mark has been set up\n        private final int[] buff = new int[32*2];\n        // position of the next byte to read,\n        // the value of -1 indicates that the buffer is not used\n        // (mark was not set up or was invalidated, or reset to the marked", "refactored_code": "        private static final int BUFF_SIZE = 32;\n        // after the mark has been set up\n        private static final int BUFF_SIZE = 32;\n        // buffer to keep the bytes read after the mark has been set up\n        private final int[] buff = new int[BUFF_SIZE*2];\n        // position of the next byte to read,\n        // the value of -1 indicates that the buffer is not used\n        // (mark was not set up or was invalidated, or reset to the marked"}
{"magic_number_smell": "    private static ASN1Type[] nameASN1 = new ASN1Type[9];\n    \n    static {\n        nameASN1[0] = OtherName.ASN1;\n        nameASN1[RFC822_NAME] = ASN1StringType.IA5STRING;\n        nameASN1[DNS_NAME] = ASN1StringType.IA5STRING;\n        nameASN1[UR_ID] = ASN1StringType.IA5STRING;", "refactored_code": "    public static final int OTHER_NAME = 0;\n    private static ASN1Type[] nameASN1 = new ASN1Type[9];\n    \n    static {\n        nameASN1[OTHER_NAME] = OtherName.ASN1;\n        nameASN1[RFC822_NAME] = ASN1StringType.IA5STRING;\n        nameASN1[DNS_NAME] = ASN1StringType.IA5STRING;\n        nameASN1[UR_ID] = ASN1StringType.IA5STRING;"}
{"magic_number_smell": "    public void dumpValue(StringBuffer buffer, String prefix) {\n        buffer.append(prefix).append(\"Reason Code: [ \"); //$NON-NLS-1$\n        switch (code) {\n            case 0:\n                buffer.append(\"unspecified\"); //$NON-NLS-1$\n                break;\n            case KEY_COMPROMISE:", "refactored_code": "    public static final byte UNSPECIFIED = 0;\n    public void dumpValue(StringBuffer buffer, String prefix) {\n        buffer.append(prefix).append(\"Reason Code: [ \"); //$NON-NLS-1$\n        switch (code) {\n            case UNSPECIFIED:\n                buffer.append(\"unspecified\"); //$NON-NLS-1$\n                break;\n            case KEY_COMPROMISE:"}
{"magic_number_smell": "\n        public int getIndex(java.lang.Object object) {\n            // choose encoding method (see RFC 3280 p. 22)\n            if (((java.util.Date) object).getTime() < 2524608000000L) {\n                return 1; // it is before 2050, so encode as UTCTime\n            } else {\n                return 0; // it is after 2050, encode as GeneralizedTime", "refactored_code": "    private static final long JAN_01_2050 = 2524608000000L;\n\n        public int getIndex(java.lang.Object object) {\n            // choose encoding method (see RFC 3280 p. 22)\n            if (((java.util.Date) object).getTime() < JAN_01_2050) {\n                return 1; // it is before 2050, so encode as UTCTime\n            } else {\n                return 0; // it is after 2050, encode as GeneralizedTime"}
{"magic_number_smell": "    public final void testReadbyteArrayintint02()\n        throws IOException {\n        // check precondition\n        assertEquals(0, MY_MESSAGE_LEN % 32);\n        \n        for (int ii=0; ii<algorithmName.length; ii++) {\n            try {", "refactored_code": "    private static final int CHUNK_SIZE = 32;\n    public final void testReadbyteArrayintint02()\n        throws IOException {\n        // check precondition\n        assertEquals(0, MY_MESSAGE_LEN % CHUNK_SIZE);\n        \n        for (int ii=0; ii<algorithmName.length; ii++) {\n            try {"}
{"magic_number_smell": "    public final void testWritebyteArrayintint02()\n        throws IOException {\n        // check precondition\n        assertEquals(0, MY_MESSAGE_LEN % 32);\n        for (int k=0; k<algorithmName.length; k++) {\n            try {\n                ", "refactored_code": "    private static final int CHUNK_SIZE = 32;\n    public final void testWritebyteArrayintint02()\n        throws IOException {\n        // check precondition\n        assertEquals(0, MY_MESSAGE_LEN % CHUNK_SIZE);\n        for (int k=0; k<algorithmName.length; k++) {\n            try {\n                "}
{"magic_number_smell": "\t */\n\tpublic void test_generateSeedI() {\n\t\t// Test for method byte [] java.security.SecureRandom.generateSeed(int)\n\t\tbyte[] seed = new SecureRandom().generateSeed(539);\n\t\tassertEquals(\"seed has incorrect size\", 539, seed.length);\n\t}\n", "refactored_code": "\tprivate static final int SEED_SIZE = 539;\n\t */\n\tpublic void test_generateSeedI() {\n\t\t// Test for method byte [] java.security.SecureRandom.generateSeed(int)\n\t\tbyte[] seed = new SecureRandom().generateSeed(SEED_SIZE);\n\t\tassertEquals(\"seed has incorrect size\", SEED_SIZE, seed.length);\n\t}\n"}
{"magic_number_smell": "\n    public final void testMt() throws InterruptedException {\n        mtTestPassed = true;\n        Thread[] workers = new Thread[10];\n            for(int i=0; i<10; i++) {\n                workers[i] = new TestWorker();\n            }", "refactored_code": "    private final int workersNumber = 10;\n\n    public final void testMt() throws InterruptedException {\n        mtTestPassed = true;\n        Thread[] workers = new Thread[workersNumber];\n            for(int i=0; i<workersNumber; i++) {\n                workers[i] = new TestWorker();\n            }"}
{"magic_number_smell": "            fail(getName() + \": not performed (could not create test KeyStore)\");\n        }\n        PKIXBuilderParameters p = new PKIXBuilderParameters(ks, null);\n        assertEquals(5, p.getMaxPathLength());\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_MAX_PATH_LEN = 5;\n            fail(getName() + \": not performed (could not create test KeyStore)\");\n        }\n        PKIXBuilderParameters p = new PKIXBuilderParameters(ks, null);\n        assertEquals(DEFAULT_MAX_PATH_LEN, p.getMaxPathLength());\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    public final void testOneBlockMessage() {\n\n        int[] words = new int[SHA1Impl.BYTES_OFFSET +6];\t// working array to compute hash\n\n        // values defined in examples in Secure Hash Standard\n        int[] hash1 = {0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0 };", "refactored_code": "    private static final int INDEX = SHA1Impl.BYTES_OFFSET;\n     */\n    public final void testOneBlockMessage() {\n\n        int[] words = new int[INDEX +6];\t// working array to compute hash\n\n        // values defined in examples in Secure Hash Standard\n        int[] hash1 = {0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0 };"}
{"magic_number_smell": "     */\n    public final void testGenerateSeedint02() {\n\n        for ( int i = 0; i < 20; i++ ) {\n\n            byte[] myBytes = sr.generateSeed(i);\n            assertFalse(\"unexpected: myBytes.length != i  :: i==\" + i + ", "refactored_code": "    private static final int LENGTH = 20;               // constant defining loop limit\n     */\n    public final void testGenerateSeedint02() {\n\n        for ( int i = 0; i < LENGTH; i++ ) {\n\n            byte[] myBytes = sr.generateSeed(i);\n            assertFalse(\"unexpected: myBytes.length != i  :: i==\" + i + "}
{"magic_number_smell": "\n            md.update(b, 0, b.length);\n            bytes = md.digest();\n            assertEquals(\"length of digest != 20\", bytes.length, 20);\n            if ( (i & 1) == 0 ) {\n                md.reset();\n            }", "refactored_code": "    private static final int DIGESTLENGTH = 20;      // implementation constants\n\n            md.update(b, 0, b.length);\n            bytes = md.digest();\n            assertEquals(\"length of digest != DIGESTLENGTH\", bytes.length, DIGESTLENGTH);\n            if ( (i & 1) == 0 ) {\n                md.reset();\n            }"}
{"magic_number_smell": "\n        for ( int k = 0; k < LIMIT2; k++ ) {\n\n            for ( int i = 0; i < 100; i++ ) {\n\n                refBytes  = new byte[i];\n                testBytes = new byte[i];", "refactored_code": "    private static final int LIMIT1 = 100;   // constant value limiting loop\n\n        for ( int k = 0; k < LIMIT2; k++ ) {\n\n            for ( int i = 0; i < LIMIT1; i++ ) {\n\n                refBytes  = new byte[i];\n                testBytes = new byte[i];"}
{"magic_number_smell": "    // The length of test message\n    private static final int 1024 = 1024;\n    // Test message for digest computations\n    private static final byte[] myMessage = new byte[1024];\n    // Reference digests for various algorithms calculated\n    // for <code>myMessage</code>\n    private static final HashMap goldenData = new HashMap();", "refactored_code": "    private static final int MY_MESSAGE_LEN = 1024;\n    // The length of test message\n    private static final int MY_MESSAGE_LEN = 1024;\n    // Test message for digest computations\n    private static final byte[] myMessage = new byte[MY_MESSAGE_LEN];\n    // Reference digests for various algorithms calculated\n    // for <code>myMessage</code>\n    private static final HashMap goldenData = new HashMap();"}
{"magic_number_smell": "    private Vector<Patch> patches;\n\n    public Sequence(float divisionType, int resolution) throws InvalidMidiDataException {\n        if (divisionType != Sequence.0.0f &&\n                divisionType != Sequence.SMPTE_24 &&\n                divisionType != Sequence.SMPTE_25 &&\n                divisionType != Sequence.SMPTE_30 &&", "refactored_code": "    public static final float PPQ = 0.0f;\n    private Vector<Patch> patches;\n\n    public Sequence(float divisionType, int resolution) throws InvalidMidiDataException {\n        if (divisionType != Sequence.PPQ &&\n                divisionType != Sequence.SMPTE_24 &&\n                divisionType != Sequence.SMPTE_25 &&\n                divisionType != Sequence.SMPTE_30 &&"}
{"magic_number_smell": "         * if this exception throw out, the value of wrong status byte\n         * should be the hexadecimal value\n         */\n        if(((data[0] & 0xFF) != SysexMessage.247) &&\n                ((data[0] & 0xFF) != SysexMessage.SYSTEM_EXCLUSIVE)) {\n            // sound.09=Invalid status byte for sysex message: {0}\n            throw new InvalidMidiDataException(Messages.getString(\"sound.09\",  //$NON-NLS-1$", "refactored_code": "    public static final int SPECIAL_SYSTEM_EXCLUSIVE = 247;\n         * if this exception throw out, the value of wrong status byte\n         * should be the hexadecimal value\n         */\n        if(((data[0] & 0xFF) != SysexMessage.SPECIAL_SYSTEM_EXCLUSIVE) &&\n                ((data[0] & 0xFF) != SysexMessage.SYSTEM_EXCLUSIVE)) {\n            // sound.09=Invalid status byte for sysex message: {0}\n            throw new InvalidMidiDataException(Messages.getString(\"sound.09\",  //$NON-NLS-1$"}
{"magic_number_smell": "     * @return the transaction isolation value.\n     * @throws SQLException\n     *             if there is a problem accessing the database.\n     * @see #0\n     * @see #TRANSACTION_READ_COMMITTED\n     * @see #TRANSACTION_READ_UNCOMMITTED\n     * @see #TRANSACTION_REPEATABLE_READ", "refactored_code": "    public static final int TRANSACTION_NONE = 0;\n     * @return the transaction isolation value.\n     * @throws SQLException\n     *             if there is a problem accessing the database.\n     * @see #TRANSACTION_NONE\n     * @see #TRANSACTION_READ_COMMITTED\n     * @see #TRANSACTION_READ_UNCOMMITTED\n     * @see #TRANSACTION_REPEATABLE_READ"}
{"magic_number_smell": "     * <li>{@code NUM_PREC_RADIX} - int - numeric values radix</li>\n     * <li>{@code NULLABLE} - int - whether {@code NULL} is permitted:\n     * <ul>\n     * <li>DatabaseMetaData.0 - {@code NULL} values not permitted</li>\n     * <li>DatabaseMetaData.attributeNullable - {@code NULL} values definitely\n     * permitted</li>\n     * <li>DatabaseMetaData.attributeNullableUnknown - unknown</li>", "refactored_code": "    public static final short attributeNoNulls = 0;\n     * <li>{@code NUM_PREC_RADIX} - int - numeric values radix</li>\n     * <li>{@code NULLABLE} - int - whether {@code NULL} is permitted:\n     * <ul>\n     * <li>DatabaseMetaData.attributeNoNulls - {@code NULL} values not permitted</li>\n     * <li>DatabaseMetaData.attributeNullable - {@code NULL} values definitely\n     * permitted</li>\n     * <li>DatabaseMetaData.attributeNullableUnknown - unknown</li>"}
{"magic_number_smell": "    /**\n     * Gets the mode of the specified parameter. Can be one of:\n     * <ul>\n     * <li>ParameterMetaData.1</li>\n     * <li>ParameterMetaData.parameterModeOut</li>\n     * <li>ParameterMetaData.parameterModeInOut</li>\n     * <li>ParameterMetaData.parameterModeUnknown</li>", "refactored_code": "    public static final int parameterModeIn = 1;\n    /**\n     * Gets the mode of the specified parameter. Can be one of:\n     * <ul>\n     * <li>ParameterMetaData.parameterModeIn</li>\n     * <li>ParameterMetaData.parameterModeOut</li>\n     * <li>ParameterMetaData.parameterModeInOut</li>\n     * <li>ParameterMetaData.parameterModeUnknown</li>"}
{"magic_number_smell": "     * @param current\n     *            a flag indicating what to do with existing {@code ResultSet}s.\n     *            This parameter must be one of {@code\n     *            Statement.3}, {@code\n     *            Statement.CLOSE_CURRENT_RESULT} or {@code\n     *            Statement.KEEP_CURRENT_RESULT}.\n     * @return {@code true} if the next result exists and is a {@code ResultSet}", "refactored_code": "    public static final int CLOSE_ALL_RESULTS = 3;\n     * @param current\n     *            a flag indicating what to do with existing {@code ResultSet}s.\n     *            This parameter must be one of {@code\n     *            Statement.CLOSE_ALL_RESULTS}, {@code\n     *            Statement.CLOSE_CURRENT_RESULT} or {@code\n     *            Statement.KEEP_CURRENT_RESULT}.\n     * @return {@code true} if the next result exists and is a {@code ResultSet}"}
{"magic_number_smell": "            if (columnCount + 1 > 0) {\n                colInfo = new ColInfo[columnCount + 1];\n            } else {\n                colInfo = new ColInfo[5];\n            }\n        } catch (OutOfMemoryError e) {\n            // For compatibility, use same default value as RI", "refactored_code": "    private static final int DEFAULT_COLUMN_COUNT = 5;\n            if (columnCount + 1 > 0) {\n                colInfo = new ColInfo[columnCount + 1];\n            } else {\n                colInfo = new ColInfo[DEFAULT_COLUMN_COUNT];\n            }\n        } catch (OutOfMemoryError e) {\n            // For compatibility, use same default value as RI"}
{"magic_number_smell": "     * \n     * @param flag\n     *            an integer. Must be one of: XAResource.TMSTARTRSCAN,\n     *            XAResource.0x800000, XAResource.TMNOFLAGS.\n     * @return an array of zero or more XIDs identifying the transaction\n     *         branches in the prepared or heuristically completed states.\n     * @throws XAException", "refactored_code": "    public static final int TMENDRSCAN = 0x800000;\n     * \n     * @param flag\n     *            an integer. Must be one of: XAResource.TMSTARTRSCAN,\n     *            XAResource.TMENDRSCAN, XAResource.TMNOFLAGS.\n     * @return an array of zero or more XIDs identifying the transaction\n     *         branches in the prepared or heuristically completed states.\n     * @throws XAException"}
{"magic_number_smell": "            }\n\n            if (qName.equals(\"properties\")) { //$NON-NLS-1$\n                state = 1;\n            } else if (qName.equals(\"metadata\")) { //$NON-NLS-1$\n                state = READ_METADATA;\n            } else if (qName.equals(\"data\")) { //$NON-NLS-1$", "refactored_code": "        private static final int READ_PROPERTIES = 1;\n            }\n\n            if (qName.equals(\"properties\")) { //$NON-NLS-1$\n                state = READ_PROPERTIES;\n            } else if (qName.equals(\"metadata\")) { //$NON-NLS-1$\n                state = READ_METADATA;\n            } else if (qName.equals(\"data\")) { //$NON-NLS-1$"}
{"magic_number_smell": "\n    private final class ActionAndModelListener implements ItemListener, ActionListener,\n            PropertyChangeListener, Serializable {\n        private static final long 1L = 1L;\n\n        public void itemStateChanged(ItemEvent event) {\n            fireItemStateChanged(event);", "refactored_code": "        private static final long serialVersionUID = 1L;\n\n    private final class ActionAndModelListener implements ItemListener, ActionListener,\n            PropertyChangeListener, Serializable {\n        private static final long serialVersionUID = 1L;\n\n        public void itemStateChanged(ItemEvent event) {\n            fireItemStateChanged(event);"}
{"magic_number_smell": "    private static final long 1525417495883046342L = 1525417495883046342L;\n\n    protected class AccessibleBox extends Container.AccessibleAWTContainer {\n        private static final long 1525417495883046342L = -7676166747466316885L;\n\n        protected AccessibleBox() {\n            super();", "refactored_code": "    private static final long serialVersionUID = 1525417495883046342L;\n    private static final long serialVersionUID = 1525417495883046342L;\n\n    protected class AccessibleBox extends Container.AccessibleAWTContainer {\n        private static final long serialVersionUID = -7676166747466316885L;\n\n        protected AccessibleBox() {\n            super();"}
{"magic_number_smell": "    protected AccessibleContext accessibleContext;\n\n    protected class AccessibleCellRendererPane extends AccessibleAWTContainer {\n        private static final long -7642183829532984273L = 1L;\n\n        @Override\n        public AccessibleRole getAccessibleRole() {", "refactored_code": "    private static final long serialVersionUID = -7642183829532984273L;\n    protected AccessibleContext accessibleContext;\n\n    protected class AccessibleCellRendererPane extends AccessibleAWTContainer {\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public AccessibleRole getAccessibleRole() {"}
{"magic_number_smell": "        }\n        if (isFlashing()) {\n            new FlashAction(originalGraphics) {\n                private static final long 1L = 1L;\n\n                @Override\n                public void paint(Graphics g) {", "refactored_code": "                    private static final long serialVersionUID = 1L;\n        }\n        if (isFlashing()) {\n            new FlashAction(originalGraphics) {\n                private static final long serialVersionUID = 1L;\n\n                @Override\n                public void paint(Graphics g) {"}
{"magic_number_smell": "    private static final long 3564035141373880027L = 3564035141373880027L;\n\n    protected class EditorDelegate implements ActionListener, ItemListener, Serializable {\n        private static final long 3564035141373880027L = -1953114537286696317L;\n\n        protected Object value;\n", "refactored_code": "    private static final long serialVersionUID = 3564035141373880027L;\n    private static final long serialVersionUID = 3564035141373880027L;\n\n    protected class EditorDelegate implements ActionListener, ItemListener, Serializable {\n        private static final long serialVersionUID = -1953114537286696317L;\n\n        protected Object value;\n"}
{"magic_number_smell": "\n    public static class UIResource extends DefaultListCellRenderer implements\n            javax.swing.plaf.UIResource {\n        private static final long -4095659446023979489L = 5748603813962368116L;\n    }\n\n    protected static Border noFocusBorder = BorderFactory.createEmptyBorder(1, 1, 1, 1);", "refactored_code": "    private static final long serialVersionUID = -4095659446023979489L;\n\n    public static class UIResource extends DefaultListCellRenderer implements\n            javax.swing.plaf.UIResource {\n        private static final long serialVersionUID = 5748603813962368116L;\n    }\n\n    protected static Border noFocusBorder = BorderFactory.createEmptyBorder(1, 1, 1, 1);"}
{"magic_number_smell": "    private static final int NOT_SET = -1;\n\n    private static class Segment extends Rectangle {\n        private static final long -3207109908101807625L = 1L;\n\n        public Segment(int begin, int end) {\n            super(Math.min(begin, end), 0, Math.abs(end - begin) + 1, 1);", "refactored_code": "    private static final long serialVersionUID = -3207109908101807625L;\n    private static final int NOT_SET = -1;\n\n    private static class Segment extends Rectangle {\n        private static final long serialVersionUID = 1L;\n\n        public Segment(int begin, int end) {\n            super(Math.min(begin, end), 0, Math.abs(end - begin) + 1, 1);"}
{"magic_number_smell": "            strategy = new NormalColorTransformationStrategy();\n        }\n\n        this.interval = 1f / 3 * (100 - grayPercentage) / 100f;\n    }\n\n    @Override", "refactored_code": "    private static final float INTERVAL_BOUND = 1f / 3;\n            strategy = new NormalColorTransformationStrategy();\n        }\n\n        this.interval = INTERVAL_BOUND * (100 - grayPercentage) / 100f;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    protected class AccessibleImageIcon extends AccessibleContext implements AccessibleIcon,\n            Serializable {\n        private static final long -6101950798829449111L = -860693743697825660L;\n        \n        protected AccessibleImageIcon() {\n        }", "refactored_code": "    private static final long serialVersionUID = -6101950798829449111L;\n\n    protected class AccessibleImageIcon extends AccessibleContext implements AccessibleIcon,\n            Serializable {\n        private static final long serialVersionUID = -860693743697825660L;\n        \n        protected AccessibleImageIcon() {\n        }"}
{"magic_number_smell": "    }\n\n    protected class AccessibleJApplet extends AccessibleApplet {\n        private static final long -8372957450536936161L = -7345678942864978889L;\n\n        protected AccessibleJApplet() {\n            super();", "refactored_code": "    private static final long serialVersionUID = -8372957450536936161L;\n    }\n\n    protected class AccessibleJApplet extends AccessibleApplet {\n        private static final long serialVersionUID = -7345678942864978889L;\n\n        protected AccessibleJApplet() {\n            super();"}
{"magic_number_smell": "    private static final long 8822265937932828454L = 8822265937932828454L;\n\n    protected class AccessibleJButton extends AccessibleAbstractButton {\n        private static final long 8822265937932828454L = -1171440163825721899L;\n\n        @Override\n        public AccessibleRole getAccessibleRole() {", "refactored_code": "    private static final long serialVersionUID = 8822265937932828454L;\n    private static final long serialVersionUID = 8822265937932828454L;\n\n    protected class AccessibleJButton extends AccessibleAbstractButton {\n        private static final long serialVersionUID = -1171440163825721899L;\n\n        @Override\n        public AccessibleRole getAccessibleRole() {"}
{"magic_number_smell": "    private static final long 2823978782065130270L = 2823978782065130270L;\n\n    protected class AccessibleJCheckBox extends AccessibleJToggleButton {\n        private static final long 2823978782065130270L = -7895379006459422318L;\n\n        @Override\n        public AccessibleRole getAccessibleRole() {", "refactored_code": "    private static final long serialVersionUID = 2823978782065130270L;\n    private static final long serialVersionUID = 2823978782065130270L;\n\n    protected class AccessibleJCheckBox extends AccessibleJToggleButton {\n        private static final long serialVersionUID = -7895379006459422318L;\n\n        @Override\n        public AccessibleRole getAccessibleRole() {"}
{"magic_number_smell": "    private static final long 7596676985032928624L = 7596676985032928624L;\n\n    protected class AccessibleJCheckBoxMenuItem extends AccessibleJMenuItem {\n        private static final long 7596676985032928624L = -5343091705345502936L;\n\n        @Override\n        public AccessibleRole getAccessibleRole() {", "refactored_code": "    private static final long serialVersionUID = 7596676985032928624L;\n    private static final long serialVersionUID = 7596676985032928624L;\n\n    protected class AccessibleJCheckBoxMenuItem extends AccessibleJMenuItem {\n        private static final long serialVersionUID = -5343091705345502936L;\n\n        @Override\n        public AccessibleRole getAccessibleRole() {"}
{"magic_number_smell": "    private static final long -3698198979867714534L = -3698198979867714534L;\n\n    protected class AccessibleJColorChooser extends AccessibleJComponent {\n        private static final long -3698198979867714534L = -4916849065058077868L;\n\n        @Override\n        public AccessibleRole getAccessibleRole() {", "refactored_code": "    private static final long serialVersionUID = -3698198979867714534L;\n    private static final long serialVersionUID = -3698198979867714534L;\n\n    protected class AccessibleJColorChooser extends AccessibleJComponent {\n        private static final long serialVersionUID = -4916849065058077868L;\n\n        @Override\n        public AccessibleRole getAccessibleRole() {"}
{"magic_number_smell": "\n    protected class AccessibleJComboBox extends AccessibleJComponent implements\n            AccessibleAction, AccessibleSelection {\n        private static final long 4884562788864849284L = 1L;\n\n        public AccessibleJComboBox() {\n        }", "refactored_code": "    private static final long serialVersionUID = 4884562788864849284L;\n\n    protected class AccessibleJComboBox extends AccessibleJComponent implements\n            AccessibleAction, AccessibleSelection {\n        private static final long serialVersionUID = 1L;\n\n        public AccessibleJComboBox() {\n        }"}
{"magic_number_smell": "    }\n\n    public void unregisterKeyboardAction(KeyStroke keyStroke) {\n        for (int i = 0; i <= LAST_INPUT_MAP_INDEX; i++) {\n            if (inputMaps[i] != null) {\n                Object command = inputMaps[i].get(keyStroke);\n                inputMaps[i].remove(keyStroke);", "refactored_code": "    private static final int FIRST_INPUT_MAP_INDEX = 0;\n    }\n\n    public void unregisterKeyboardAction(KeyStroke keyStroke) {\n        for (int i = FIRST_INPUT_MAP_INDEX; i <= LAST_INPUT_MAP_INDEX; i++) {\n            if (inputMaps[i] != null) {\n                Object command = inputMaps[i].get(keyStroke);\n                inputMaps[i].remove(keyStroke);"}
{"magic_number_smell": "    public static final int OUTLINE_DRAG_MODE = 1;\n\n    protected class AccessibleJDesktopPane extends AccessibleJComponent {\n        private static final long -5428199090710889698L = -44586801937888192L;\n\n        protected AccessibleJDesktopPane() {\n            super();", "refactored_code": "    private static final long serialVersionUID = -5428199090710889698L;\n    public static final int OUTLINE_DRAG_MODE = 1;\n\n    protected class AccessibleJDesktopPane extends AccessibleJComponent {\n        private static final long serialVersionUID = -44586801937888192L;\n\n        protected AccessibleJDesktopPane() {\n            super();"}
{"magic_number_smell": "     * This class implements accessibility support for <code>JDialog</code>.\n     */\n    protected class AccessibleJDialog extends AccessibleAWTDialog {\n        private static final long -864070866424508218L = 7312926302382808523L;\n\n        protected AccessibleJDialog() {\n        }", "refactored_code": "    private static final long serialVersionUID = -864070866424508218L;\n     * This class implements accessibility support for <code>JDialog</code>.\n     */\n    protected class AccessibleJDialog extends AccessibleAWTDialog {\n        private static final long serialVersionUID = 7312926302382808523L;\n\n        protected AccessibleJDialog() {\n        }"}
{"magic_number_smell": "    private static final long -767121239635831550L = -767121239635831550L;\n\n    protected class AccessibleJEditorPane extends JTextComponent.AccessibleJTextComponent {\n        private static final long -767121239635831550L = -6869835326921704467L;\n\n        @Override\n        public String getAccessibleDescription() {", "refactored_code": "    private static final long serialVersionUID = -767121239635831550L;\n    private static final long serialVersionUID = -767121239635831550L;\n\n    protected class AccessibleJEditorPane extends JTextComponent.AccessibleJTextComponent {\n        private static final long serialVersionUID = -6869835326921704467L;\n\n        @Override\n        public String getAccessibleDescription() {"}
{"magic_number_smell": "    private JDialog fileChooserDialog;\n\n    protected class AccessibleJFileChooser extends AccessibleJComponent {\n        private static final long 1049148651561366602L = -6919995775059834138L;\n\n        @Override\n        public AccessibleRole getAccessibleRole() {", "refactored_code": "    private static final long serialVersionUID = 1049148651561366602L;\n    private JDialog fileChooserDialog;\n\n    protected class AccessibleJFileChooser extends AccessibleJComponent {\n        private static final long serialVersionUID = -6919995775059834138L;\n\n        @Override\n        public AccessibleRole getAccessibleRole() {"}
{"magic_number_smell": "        private JFormattedTextField textField;\n\n        private class ActionMapFormattersResource extends ActionMap {\n            private static final long 7685569367944517634L = 1L;\n        }\n\n        @Override", "refactored_code": "    private static final long serialVersionUID = 7685569367944517634L;\n        private JFormattedTextField textField;\n\n        private class ActionMapFormattersResource extends ActionMap {\n            private static final long serialVersionUID = 1L;\n        }\n\n        @Override"}
{"magic_number_smell": "     * This class implements accessibility support for <code>JFrame</code>.\n     */\n    protected class AccessibleJFrame extends AccessibleAWTFrame {\n        private static final long -1026528232454752719L = -6604775962178425920L;\n\n        protected AccessibleJFrame() {\n            super();", "refactored_code": "    private static final long serialVersionUID = -1026528232454752719L;\n     * This class implements accessibility support for <code>JFrame</code>.\n     */\n    protected class AccessibleJFrame extends AccessibleAWTFrame {\n        private static final long serialVersionUID = -6604775962178425920L;\n\n        protected AccessibleJFrame() {\n            super();"}
{"magic_number_smell": "     * This class represents the internal frame when it is iconified.\n     */\n    public static class JDesktopIcon extends JComponent implements Accessible {\n        private static final long 3837984427982803247L = -4923863980546870453L;\n\n        // The internal frame for this icon.\n        private JInternalFrame internalFrame;", "refactored_code": "    private static final long serialVersionUID = 3837984427982803247L;\n     * This class represents the internal frame when it is iconified.\n     */\n    public static class JDesktopIcon extends JComponent implements Accessible {\n        private static final long serialVersionUID = -4923863980546870453L;\n\n        // The internal frame for this icon.\n        private JInternalFrame internalFrame;"}
{"magic_number_smell": "\n    //TODO: implement\n    protected class AccessibleJLabel extends AccessibleJComponent implements AccessibleText {\n        private static final long 1992522068352176692L = -3843546598023238741L;\n\n        @Override\n        public AccessibleRole getAccessibleRole() {", "refactored_code": "    private static final long serialVersionUID = 1992522068352176692L;\n\n    //TODO: implement\n    protected class AccessibleJLabel extends AccessibleJComponent implements AccessibleText {\n        private static final long serialVersionUID = -3843546598023238741L;\n\n        @Override\n        public AccessibleRole getAccessibleRole() {"}
{"magic_number_smell": "     * Implements accessibility support for <code>JLayeredPane</code>\n     */\n    protected class AccessibleJLayeredPane extends AccessibleJComponent {\n        private static final long -2657754894035116214L = 3492700363505144784L;\n\n        /**\n         * Constructs new <code>AccessibleJLayeredPane</code>.", "refactored_code": "    private static final long serialVersionUID = -2657754894035116214L;\n     * Implements accessibility support for <code>JLayeredPane</code>\n     */\n    protected class AccessibleJLayeredPane extends AccessibleJComponent {\n        private static final long serialVersionUID = 3492700363505144784L;\n\n        /**\n         * Constructs new <code>AccessibleJLayeredPane</code>."}
{"magic_number_smell": "    private boolean dragEnabled;\n    private int fixedCellHeight = -1;\n    private int fixedCellWidth = -1;\n    private int layoutOrientation = 0;\n    private Object prototypeCellValue;\n    private Color selectionBackground;\n    private Color selectionForeground;", "refactored_code": "    public static final int VERTICAL = 0;\n    private boolean dragEnabled;\n    private int fixedCellHeight = -1;\n    private int fixedCellWidth = -1;\n    private int layoutOrientation = VERTICAL;\n    private Object prototypeCellValue;\n    private Color selectionBackground;\n    private Color selectionForeground;"}
{"magic_number_smell": "\n    // TODO implement accessibility\n    protected class AccessibleJMenu extends AccessibleJMenuItem implements AccessibleSelection {\n        private static final long 6344812061970456262L = -7871723353224195081L;\n\n        public void addAccessibleSelection(int i) throws NotImplementedException {\n            throw new NotImplementedException();", "refactored_code": "    private static final long serialVersionUID = 6344812061970456262L;\n\n    // TODO implement accessibility\n    protected class AccessibleJMenu extends AccessibleJMenuItem implements AccessibleSelection {\n        private static final long serialVersionUID = -7871723353224195081L;\n\n        public void addAccessibleSelection(int i) throws NotImplementedException {\n            throw new NotImplementedException();"}
{"magic_number_smell": "    // TODO: implement\n    protected class AccessibleJMenuBar extends AccessibleJComponent implements\n            AccessibleSelection {\n        private static final long 6620404810314292434L = 1L;\n\n        public void addAccessibleSelection(int i) throws NotImplementedException {\n            throw new NotImplementedException();", "refactored_code": "    private static final long serialVersionUID = 6620404810314292434L;\n    // TODO: implement\n    protected class AccessibleJMenuBar extends AccessibleJComponent implements\n            AccessibleSelection {\n        private static final long serialVersionUID = 1L;\n\n        public void addAccessibleSelection(int i) throws NotImplementedException {\n            throw new NotImplementedException();"}
{"magic_number_smell": "    protected int messageType = PLAIN_MESSAGE;\n\n    protected Object[] options;\n    protected int optionType = -1;\n\n    protected Object[] selectionValues;\n    protected Object value = UNINITIALIZED_VALUE;", "refactored_code": "    public static final int DEFAULT_OPTION = -1;\n    protected int messageType = PLAIN_MESSAGE;\n\n    protected Object[] options;\n    protected int optionType = DEFAULT_OPTION;\n\n    protected Object[] selectionValues;\n    protected Object value = UNINITIALIZED_VALUE;"}
{"magic_number_smell": "     */\n    protected DefaultAction defaultReleaseAction;\n\n    private int windowDecorationStyle = 0;\n    private JButton savedDefaultButton;\n\n    public JRootPane() {", "refactored_code": "    public static final int NONE = 0;\n     */\n    protected DefaultAction defaultReleaseAction;\n\n    private int windowDecorationStyle = NONE;\n    private JButton savedDefaultButton;\n\n    public JRootPane() {"}
{"magic_number_smell": "    protected class AccessibleJSpinner extends JComponent.AccessibleJComponent implements\n            AccessibleValue, AccessibleAction, AccessibleText, AccessibleEditableText,\n            ChangeListener {\n        private static final long 5455034942343575490L = -8871493856204319541L;\n\n        protected AccessibleJSpinner() {\n        }", "refactored_code": "    private static final long serialVersionUID = 5455034942343575490L;\n    protected class AccessibleJSpinner extends JComponent.AccessibleJComponent implements\n            AccessibleValue, AccessibleAction, AccessibleText, AccessibleEditableText,\n            ChangeListener {\n        private static final long serialVersionUID = -8871493856204319541L;\n\n        protected AccessibleJSpinner() {\n        }"}
{"magic_number_smell": "    }\n\n    private void checkOrientation(final int orientation) {\n        if (orientation != HORIZONTAL_SPLIT && orientation != 0) {\n            throw new IllegalArgumentException(Messages.getString(\"swing.1B\")); //$NON-NLS-1$\n        }\n    }", "refactored_code": "    public static final int VERTICAL_SPLIT = 0;\n    }\n\n    private void checkOrientation(final int orientation) {\n        if (orientation != HORIZONTAL_SPLIT && orientation != VERTICAL_SPLIT) {\n            throw new IllegalArgumentException(Messages.getString(\"swing.1B\")); //$NON-NLS-1$\n        }\n    }"}
{"magic_number_smell": "    // TODO: implement\n    protected class AccessibleJTabbedPane extends AccessibleJComponent implements\n            AccessibleSelection, ChangeListener {\n        private static final long 1671634173365704280L = 8645220594633986096L;\n\n        public AccessibleJTabbedPane() {\n        }", "refactored_code": "    private static final long serialVersionUID = 1671634173365704280L;\n    // TODO: implement\n    protected class AccessibleJTabbedPane extends AccessibleJComponent implements\n            AccessibleSelection, ChangeListener {\n        private static final long serialVersionUID = 8645220594633986096L;\n\n        public AccessibleJTabbedPane() {\n        }"}
{"magic_number_smell": "            AccessibleSelection, ListSelectionListener, TableModelListener,\n            TableColumnModelListener, CellEditorListener, PropertyChangeListener,\n            AccessibleExtendedTable {\n        private static final long -506121678825692843L = 1L;\n\n        protected class AccessibleJTableCell extends AccessibleContext implements Accessible,\n                AccessibleComponent {", "refactored_code": "    private static final long serialVersionUID = -506121678825692843L;\n            AccessibleSelection, ListSelectionListener, TableModelListener,\n            TableColumnModelListener, CellEditorListener, PropertyChangeListener,\n            AccessibleExtendedTable {\n        private static final long serialVersionUID = 1L;\n\n        protected class AccessibleJTableCell extends AccessibleContext implements Accessible,\n                AccessibleComponent {"}
{"magic_number_smell": "     * This field is added as a performance optimization but not as\n     * a guarantee of correct deserialization of the class. \n     */\n    private static final long -3980593114771538955L = 6111025777502333651L;\n\n    private int columns;\n", "refactored_code": "        private static final long serialVersionUID = -3980593114771538955L;\n     * This field is added as a performance optimization but not as\n     * a guarantee of correct deserialization of the class. \n     */\n    private static final long serialVersionUID = 6111025777502333651L;\n\n    private int columns;\n"}
{"magic_number_smell": "    protected class AccessibleJTree extends AccessibleJComponent implements\n            AccessibleSelection, TreeSelectionListener, TreeModelListener,\n            TreeExpansionListener {\n        private static final long -3884445419090632712L = -8714565563782619758L;\n\n        protected class AccessibleJTreeNode extends AccessibleContext implements Accessible,\n                AccessibleComponent, AccessibleSelection, AccessibleAction {", "refactored_code": "    private static final long serialVersionUID = -3884445419090632712L;\n    protected class AccessibleJTree extends AccessibleJComponent implements\n            AccessibleSelection, TreeSelectionListener, TreeModelListener,\n            TreeExpansionListener {\n        private static final long serialVersionUID = -8714565563782619758L;\n\n        protected class AccessibleJTreeNode extends AccessibleContext implements Accessible,\n                AccessibleComponent, AccessibleSelection, AccessibleAction {"}
{"magic_number_smell": "    private static final long -633250949788872287L = -633250949788872287L;\n    \n    protected class ViewListener extends ComponentAdapter implements Serializable {\n        private static final long -633250949788872287L = 6947347842254105360L;\n        \n        @Override\n        public void componentResized(final ComponentEvent e) {", "refactored_code": "    private static final long serialVersionUID = -633250949788872287L;\n    private static final long serialVersionUID = -633250949788872287L;\n    \n    protected class ViewListener extends ComponentAdapter implements Serializable {\n        private static final long serialVersionUID = 6947347842254105360L;\n        \n        @Override\n        public void componentResized(final ComponentEvent e) {"}
{"magic_number_smell": "                popupSet = new HashSet();\n                popups.put(owner, popupSet);\n            }\n            if (popupSet.size() < 5) {\n                popupSet.add(popup);\n                return true;\n            }", "refactored_code": "        private static final int STORAGE_CAPACITY = 5;\n                popupSet = new HashSet();\n                popups.put(owner, popupSet);\n            }\n            if (popupSet.size() < STORAGE_CAPACITY) {\n                popupSet.add(popup);\n                return true;\n            }"}
{"magic_number_smell": "        shouldShow = false;\n        if (shouldShowTimer == null) {\n            shouldShowTimer = new Timer(millisToDecideToPopup, new AbstractAction() {\n                private static final long 1L = 1L;\n\n                public void actionPerformed(ActionEvent e) {\n                    shouldShow = (max - min) * millisToDecideToPopup > millisToPopup", "refactored_code": "        private static final long serialVersionUID = 1L;\n        shouldShow = false;\n        if (shouldShowTimer == null) {\n            shouldShowTimer = new Timer(millisToDecideToPopup, new AbstractAction() {\n                private static final long serialVersionUID = 1L;\n\n                public void actionPerformed(ActionEvent e) {\n                    shouldShow = (max - min) * millisToDecideToPopup > millisToPopup"}
{"magic_number_smell": "    private int calendarField;\n\n    public SpinnerDateModel() {\n        this(new Date(), null, null, Calendar.DAY_OF_MONTH);\n    }\n\n    public SpinnerDateModel(final Date value, final Comparable start,", "refactored_code": "    private static final int DEFAULT_CALENDAR_FIELD = Calendar.DAY_OF_MONTH;\n    private int calendarField;\n\n    public SpinnerDateModel() {\n        this(new Date(), null, null, DEFAULT_CALENDAR_FIELD);\n    }\n\n    public SpinnerDateModel(final Date value, final Comparable start,"}
{"magic_number_smell": "    }\n\n    public float getLayoutAlignmentX(final Container p) {\n        return 0.5f;\n    }\n\n    public float getLayoutAlignmentY(final Container p) {", "refactored_code": "    private static final float CENTERED = 0.5f;\n    }\n\n    public float getLayoutAlignmentX(final Container p) {\n        return CENTERED;\n    }\n\n    public float getLayoutAlignmentY(final Container p) {"}
{"magic_number_smell": "        PopupFactory factory = PopupFactory.getSharedInstance();\n        Point toolTipPoint = MouseInfo.getPointerInfo().getLocation();\n        factory.setLWPopupsEnabled(isLightWeightPopupEnabled());\n        popup = factory.getPopup(component, t, toolTipPoint.x, toolTipPoint.y + 20);\n        factory.setLWPopupsEnabled(false);\n        popup.show();\n        stillInsideTimer.restart();", "refactored_code": "    private static final int MOUSE_CURSOR_HEIGHT = 20;\n        PopupFactory factory = PopupFactory.getSharedInstance();\n        Point toolTipPoint = MouseInfo.getPointerInfo().getLocation();\n        factory.setLWPopupsEnabled(isLightWeightPopupEnabled());\n        popup = factory.getPopup(component, t, toolTipPoint.x, toolTipPoint.y + MOUSE_CURSOR_HEIGHT);\n        factory.setLWPopupsEnabled(false);\n        popup.show();\n        stillInsideTimer.restart();"}
{"magic_number_smell": "            return;\n        }\n        int actionId = action & getSourceActions(c);\n        if (actionId == ActionNames.NONE) {\n            exportDone(c, t, actionId);\n            return;\n        }", "refactored_code": "    public static final int NONE = ActionNames.NONE;\n            return;\n        }\n        int actionId = action & getSourceActions(c);\n        if (actionId == NONE) {\n            exportDone(c, t, actionId);\n            return;\n        }"}
{"magic_number_smell": "\n        final UIDefaults uiDefs = lookAndFeel.getDefaults();\n        uiDefaults = new UIDefaults() {\n            private static final long -7909287654867514204L = -4220137347255884538L;\n\n            @Override\n            public Object get(final Object key, final Locale locale) {", "refactored_code": "    private static final long serialVersionUID = -7909287654867514204L;\n\n        final UIDefaults uiDefs = lookAndFeel.getDefaults();\n        uiDefaults = new UIDefaults() {\n            private static final long serialVersionUID = -4220137347255884538L;\n\n            @Override\n            public Object get(final Object key, final Locale locale) {"}
{"magic_number_smell": "    public void paintBorder(final Component c, final Graphics g, final int x, final int y, final int width, final int height) {\n        if (bevelType == BevelBorder.LOWERED) {\n            paintLoweredBevel(c, g, x, y, width, height);\n        } else if (bevelType == BevelBorder.0){\n            paintRaisedBevel(c, g, x, y, width, height);\n        }\n    }", "refactored_code": "    public static final int RAISED = 0;\n    public void paintBorder(final Component c, final Graphics g, final int x, final int y, final int width, final int height) {\n        if (bevelType == BevelBorder.LOWERED) {\n            paintLoweredBevel(c, g, x, y, width, height);\n        } else if (bevelType == BevelBorder.RAISED){\n            paintRaisedBevel(c, g, x, y, width, height);\n        }\n    }"}
{"magic_number_smell": "    }\n\n    public EtchedBorder(final int etchType, final Color highlightColor, final Color shadowColor) {\n        if (etchType != 0 && etchType != LOWERED) {\n            throw new InvalidParameterException(INCORRECT_BORDER_TYPE_EXCEPTION_TEXT);\n        }\n        this.etchType = etchType;", "refactored_code": "    public static final int RAISED = 0;\n    }\n\n    public EtchedBorder(final int etchType, final Color highlightColor, final Color shadowColor) {\n        if (etchType != RAISED && etchType != LOWERED) {\n            throw new InvalidParameterException(INCORRECT_BORDER_TYPE_EXCEPTION_TEXT);\n        }\n        this.etchType = etchType;"}
{"magic_number_smell": "    }\n\n    int getInsetSize() {\n        return 3;\n    }\n\n    public void paintBorder(final Component c, final Graphics g, final int x, final int y, final int width, final int height) {", "refactored_code": "    private static final int INSETS_SIZE = 3;\n    }\n\n    int getInsetSize() {\n        return INSETS_SIZE;\n    }\n\n    public void paintBorder(final Component c, final Graphics g, final int x, final int y, final int width, final int height) {"}
{"magic_number_smell": "        if (!Utilities.isEmptyString(title) && c != null) {\n            FontMetrics metrics = c.getFontMetrics(getTitleFont());\n            switch (titlePosition) {\n            case 0:\n            case TOP:\n                insets.top += metrics.getHeight() - TEXT_SPACING;\n                break;", "refactored_code": "    public static final int DEFAULT_POSITION = 0;\n        if (!Utilities.isEmptyString(title) && c != null) {\n            FontMetrics metrics = c.getFontMetrics(getTitleFont());\n            switch (titlePosition) {\n            case DEFAULT_POSITION:\n            case TOP:\n                insets.top += metrics.getHeight() - TEXT_SPACING;\n                break;"}
{"magic_number_smell": "        float xColor = (float)(SELECTOR_WIDTH - x) / SELECTOR_WIDTH;\n        xColor = (xColor >= 1.f) ? 1.f : xColor;\n        xColor = (xColor <= 0.f) ? 0.f : xColor;\n        float yColor = (float)(200 - y) / 200;\n        yColor = (yColor >= 1.f) ? 1.f : yColor;\n        yColor = (yColor <= 0.f) ? 0.f : yColor;\n", "refactored_code": "    private static final int COMPONENTS_HEIGHT = 200;\n        float xColor = (float)(SELECTOR_WIDTH - x) / SELECTOR_WIDTH;\n        xColor = (xColor >= 1.f) ? 1.f : xColor;\n        xColor = (xColor <= 0.f) ? 0.f : xColor;\n        float yColor = (float)(COMPONENTS_HEIGHT - y) / COMPONENTS_HEIGHT;\n        yColor = (yColor >= 1.f) ? 1.f : yColor;\n        yColor = (yColor <= 0.f) ? 0.f : yColor;\n"}
{"magic_number_smell": "        Color color = getForeground();\n        \n        graphics.setColor(Color.WHITE);\n        int bigSquareRelativeY = (sampleHeight - 13 + 1) / 2;\n        graphics.fillRect(TEXT_OFFSET + sampleWidth - 19, TOP_OFFSET + bigSquareRelativeY,\n                          13,  13);            \n        ", "refactored_code": "    private static final int BIG_SQUARE_SIZE = 13;\n        Color color = getForeground();\n        \n        graphics.setColor(Color.WHITE);\n        int bigSquareRelativeY = (sampleHeight - BIG_SQUARE_SIZE + 1) / 2;\n        graphics.fillRect(TEXT_OFFSET + sampleWidth - 19, TOP_OFFSET + bigSquareRelativeY,\n                          BIG_SQUARE_SIZE,  BIG_SQUARE_SIZE);            \n        "}
{"magic_number_smell": "     * The format of the string is based on 1.5 release behavior\n     * which can be revealed using the following code:\n     *\n     *     Object obj = new ListDataEvent(null, ListDataEvent.0, 0, 1);\n     *     System.out.println(obj.toString());\n     */\n    public String toString() {", "refactored_code": "    public static final int CONTENTS_CHANGED = 0;\n     * The format of the string is based on 1.5 release behavior\n     * which can be revealed using the following code:\n     *\n     *     Object obj = new ListDataEvent(null, ListDataEvent.CONTENTS_CHANGED, 0, 1);\n     *     System.out.println(obj.toString());\n     */\n    public String toString() {"}
{"magic_number_smell": "    protected int column;\n\n    public TableModelEvent(final TableModel source) {\n        this(source, 0, Integer.MAX_VALUE, ALL_COLUMNS, 0);\n    }\n\n    public TableModelEvent(final TableModel source, final int row) {", "refactored_code": "    public static final int UPDATE = 0;\n    protected int column;\n\n    public TableModelEvent(final TableModel source) {\n        this(source, 0, Integer.MAX_VALUE, ALL_COLUMNS, UPDATE);\n    }\n\n    public TableModelEvent(final TableModel source, final int row) {"}
{"magic_number_smell": "        if (autoscrollTimer == null) {\n            autoscrollTimer = new Timer(100, new ActionListener() {\n                public void actionPerformed(final ActionEvent e) {\n                    if (scrollDirection == 0) {\n                        autoScrollUp();\n                    } else if (scrollDirection == SCROLL_DOWN) {\n                        autoScrollDown();", "refactored_code": "    protected static final int SCROLL_UP = 0;\n        if (autoscrollTimer == null) {\n            autoscrollTimer = new Timer(100, new ActionListener() {\n                public void actionPerformed(final ActionEvent e) {\n                    if (scrollDirection == SCROLL_UP) {\n                        autoScrollUp();\n                    } else if (scrollDirection == SCROLL_DOWN) {\n                        autoScrollDown();"}
{"magic_number_smell": "            throw new NullPointerException(Messages.getString(\"swing.03\",\"component\")); //$NON-NLS-1$ //$NON-NLS-2$\n        }\n        //return desktopIcon.getInsets();\n        return new Insets(5, 5,\n                5, 5);\n    }\n", "refactored_code": "    private static  final int INSETS_WIDTH = 5;\n            throw new NullPointerException(Messages.getString(\"swing.03\",\"component\")); //$NON-NLS-1$ //$NON-NLS-2$\n        }\n        //return desktopIcon.getInsets();\n        return new Insets(INSETS_WIDTH, INSETS_WIDTH,\n                INSETS_WIDTH, INSETS_WIDTH);\n    }\n"}
{"magic_number_smell": "\n            JComponent comp = getComponentForChangingBounds();\n            Dimension minSize = comp.getMinimumSize();\n            int shrinkX = Math.min(10,\n                                   comp.getWidth() - minSize.width);\n            int shrinkY = Math.min(10,\n                                   comp.getHeight() - minSize.height);", "refactored_code": "        private static final int BOUNDS_STEP = 10;\n\n            JComponent comp = getComponentForChangingBounds();\n            Dimension minSize = comp.getMinimumSize();\n            int shrinkX = Math.min(BOUNDS_STEP,\n                                   comp.getWidth() - minSize.width);\n            int shrinkY = Math.min(BOUNDS_STEP,\n                                   comp.getHeight() - minSize.height);"}
{"magic_number_smell": "        private static final int 6 = 6;\n\n        public int getIconHeight() {\n            return 6;\n        }\n\n        public int getIconWidth() {", "refactored_code": "        private static final int SIZE = 6;\n        private static final int SIZE = 6;\n\n        public int getIconHeight() {\n            return SIZE;\n        }\n\n        public int getIconWidth() {"}
{"magic_number_smell": "        protected final int 0 = 0;\n\n        private final ComponentDragImplHelper helper = new ComponentDragImplHelper();\n        private int resizeDirection = 0;\n\n        public void mouseClicked(final MouseEvent e) {\n            if (e.getSource() != frame && SwingUtilities.isLeftMouseButton(e)", "refactored_code": "        protected final int RESIZE_NONE = 0;\n        protected final int RESIZE_NONE = 0;\n\n        private final ComponentDragImplHelper helper = new ComponentDragImplHelper();\n        private int resizeDirection = RESIZE_NONE;\n\n        public void mouseClicked(final MouseEvent e) {\n            if (e.getSource() != frame && SwingUtilities.isLeftMouseButton(e)"}
{"magic_number_smell": "            } else if (\"fixedCellWidth\".equals(changedProperty)) {\n                updateLayoutStateNeeded = updateLayoutStateNeeded | fixedCellWidthChanged;\n            } else if (\"model\".equals(changedProperty)) {\n                updateLayoutStateNeeded = updateLayoutStateNeeded | 1;\n            } else if (\"selectionModel\".equals(changedProperty)) {\n                updateLayoutStateNeeded = updateLayoutStateNeeded | selectionModelChanged;\n            } else if (\"prototypeCellValue\".equals(changedProperty)) {", "refactored_code": "    protected static final int modelChanged = 1;\n            } else if (\"fixedCellWidth\".equals(changedProperty)) {\n                updateLayoutStateNeeded = updateLayoutStateNeeded | fixedCellWidthChanged;\n            } else if (\"model\".equals(changedProperty)) {\n                updateLayoutStateNeeded = updateLayoutStateNeeded | modelChanged;\n            } else if (\"selectionModel\".equals(changedProperty)) {\n                updateLayoutStateNeeded = updateLayoutStateNeeded | selectionModelChanged;\n            } else if (\"prototypeCellValue\".equals(changedProperty)) {"}
{"magic_number_smell": "    }\n\n    public Dimension getMinimumOptionPaneSize() {\n        return (minimumSize != null) ? minimumSize : new Dimension(262, MinimumHeight);\n    }\n\n    public Dimension getPreferredSize(final JComponent c) {", "refactored_code": "    public static final int MinimumWidth = 262;\n    }\n\n    public Dimension getMinimumOptionPaneSize() {\n        return (minimumSize != null) ? minimumSize : new Dimension(MinimumWidth, MinimumHeight);\n    }\n\n    public Dimension getPreferredSize(final JComponent c) {"}
{"magic_number_smell": "        Insets insets = progressBar.getInsets();\n        int height = insets.top + insets.bottom + horizontalSize.height;\n        if (progressBar.isStringPainted()) {\n            height -= 5;\n            height += progressBar.getFontMetrics(progressBar.getFont()).getHeight();\n        }\n        return height;", "refactored_code": "    private static final int NOTEXT_HEIGHT_ADDITION = 5;\n        Insets insets = progressBar.getInsets();\n        int height = insets.top + insets.bottom + horizontalSize.height;\n        if (progressBar.isStringPainted()) {\n            height -= NOTEXT_HEIGHT_ADDITION;\n            height += progressBar.getFontMetrics(progressBar.getFont()).getHeight();\n        }\n        return height;"}
{"magic_number_smell": "        paintThumb(g, c, getThumbBounds());\n        if (trackHighlight == INCREASE_HIGHLIGHT) {\n            paintIncreaseHighlight(g);\n        } else if (trackHighlight == 1) {\n            paintDecreaseHighlight(g);\n        }\n    }", "refactored_code": "    protected static final int DECREASE_HIGHLIGHT = 1;\n        paintThumb(g, c, getThumbBounds());\n        if (trackHighlight == INCREASE_HIGHLIGHT) {\n            paintIncreaseHighlight(g);\n        } else if (trackHighlight == DECREASE_HIGHLIGHT) {\n            paintDecreaseHighlight(g);\n        }\n    }"}
{"magic_number_smell": "\n    private Action newMaxScrollAction() {\n        return new AbstractAction() {\n            private static final long -3454576988589353120L = -3822301141065864044L;\n\n            public void actionPerformed(final ActionEvent e) {\n                if (drawInverted()) {", "refactored_code": "        private static final long serialVersionUID = -3454576988589353120L;\n\n    private Action newMaxScrollAction() {\n        return new AbstractAction() {\n            private static final long serialVersionUID = -3822301141065864044L;\n\n            public void actionPerformed(final ActionEvent e) {\n                if (drawInverted()) {"}
{"magic_number_smell": "                dir = PREVIOUS;\n            }\n            if (scrollTimer == null) {\n                scrollTimer = new Timer(50, this);\n                scrollTimer.setInitialDelay(PRE_SCROLL_DELAY);\n            }\n            scrollTimer.restart();", "refactored_code": "        private static final int SCROLL_DELAY = 50;\n                dir = PREVIOUS;\n            }\n            if (scrollTimer == null) {\n                scrollTimer = new Timer(SCROLL_DELAY, this);\n                scrollTimer.setInitialDelay(PRE_SCROLL_DELAY);\n            }\n            scrollTimer.restart();"}
{"magic_number_smell": "        }\n    };\n\n    private static final Action SELECT_CHILD_ACTION = new ChildParentAction(\"selectChild\", GenericNavigationAction.1) {\n        public void actionPerformed(final ActionEvent e) {\n            final MenuElement[] path = getSelectedPath();\n            if (path.length > 3 || path[0] instanceof JPopupMenu) {", "refactored_code": "        protected static final int FORWARD = 1;\n        }\n    };\n\n    private static final Action SELECT_CHILD_ACTION = new ChildParentAction(\"selectChild\", GenericNavigationAction.FORWARD) {\n        public void actionPerformed(final ActionEvent e) {\n            final MenuElement[] path = getSelectedPath();\n            if (path.length > 3 || path[0] instanceof JPopupMenu) {"}
{"magic_number_smell": "\n    public static class InternalFrameBorder extends AbstractBorder implements UIResource {\n        private static final int 5 = 5;\n        private static final int corner = 15 + 5;\n        private static final Insets BORDER_INSETS = new Insets(5, 5, 5, 5);\n\n        Color activeColor;", "refactored_code": "        private static final int width = 5;\n\n    public static class InternalFrameBorder extends AbstractBorder implements UIResource {\n        private static final int width = 5;\n        private static final int corner = 15 + width;\n        private static final Insets BORDER_INSETS = new Insets(width, width, width, width);\n\n        Color activeColor;"}
{"magic_number_smell": "\n        public IndentedIcon(final Icon icon, final int indent) {\n            this.icon = icon;\n            this.indent = indent * 10;\n        }\n\n        public void paintIcon(final Component c, final Graphics g, final int x, final int y) {", "refactored_code": "        private static final int INDENT_WIDTH = 10;\n\n        public IndentedIcon(final Icon icon, final int indent) {\n            this.icon = icon;\n            this.indent = indent * INDENT_WIDTH;\n        }\n\n        public void paintIcon(final Component c, final Graphics g, final int x, final int y) {"}
{"magic_number_smell": "        private static final int 8 = 8;\n\n        public int getIconWidth() {\n            return 8;\n        }\n\n        public int getIconHeight() {", "refactored_code": "        private static final int size = 8;\n        private static final int size = 8;\n\n        public int getIconWidth() {\n            return size;\n        }\n\n        public int getIconHeight() {"}
{"magic_number_smell": "        FontMetrics fm = tooltip.getFontMetrics(f);\n        Dimension stringSize = Utilities.getStringSize(acceleratorText, fm);\n\n        int textX = tooltip.getWidth() - stringSize.width - 12 / 2;\n        int textY = fm.getAscent();\n        Utilities.drawString(g, acceleratorText, textX, textY, fm, MetalLookAndFeel.getAcceleratorForeground(), -1);\n    }", "refactored_code": "    public static final int padSpaceBetweenStrings = 12;\n        FontMetrics fm = tooltip.getFontMetrics(f);\n        Dimension stringSize = Utilities.getStringSize(acceleratorText, fm);\n\n        int textX = tooltip.getWidth() - stringSize.width - padSpaceBetweenStrings / 2;\n        int textY = fm.getAscent();\n        Utilities.drawString(g, acceleratorText, textX, textY, fm, MetalLookAndFeel.getAcceleratorForeground(), -1);\n    }"}
{"magic_number_smell": "    private static final int 1 = 1;\n    private static final int HORIZONTAL = 2;\n    private static final int NONE = 3;\n    private static int lineStyle = 1;\n\n    private PropertyChangeListener clientPropertyListener;\n    private Color lineColor;", "refactored_code": "    private static final int ANGLED = 1;\n    private static final int ANGLED = 1;\n    private static final int HORIZONTAL = 2;\n    private static final int NONE = 3;\n    private static int lineStyle = ANGLED;\n\n    private PropertyChangeListener clientPropertyListener;\n    private Color lineColor;"}
{"magic_number_smell": "        if ((STYLE_ELEMENT == element)) {\n            currentStyle = null;\n        } else if (STATE_ELEMENT == element) {\n            currentState = 0;\n        } else if ((!(BIND_ELEMENT == element))\n                && (!(COLOR_ELEMENT == element))\n                && (!(G_UTILS_ELEMENT == element))", "refactored_code": "    private final int DEFAULT_STATE = 0;\n        if ((STYLE_ELEMENT == element)) {\n            currentStyle = null;\n        } else if (STATE_ELEMENT == element) {\n            currentState = DEFAULT_STATE;\n        } else if ((!(BIND_ELEMENT == element))\n                && (!(COLOR_ELEMENT == element))\n                && (!(G_UTILS_ELEMENT == element))"}
{"magic_number_smell": "                    String text = content.getString(getStartOffset(),\n                                                    getEndOffset()\n                                                    - getStartOffset());\n                    if (text.length() > 40) {\n                        text = text.substring(0, 40);\n                        text += \"...\";\n                    }", "refactored_code": "        private static final int MAX_LEAF_CONTENT_LENGTH = 40;\n                    String text = content.getString(getStartOffset(),\n                                                    getEndOffset()\n                                                    - getStartOffset());\n                    if (text.length() > MAX_LEAF_CONTENT_LENGTH) {\n                        text = text.substring(0, MAX_LEAF_CONTENT_LENGTH);\n                        text += \"...\";\n                    }"}
{"magic_number_smell": "            }\n            return component.getPreferredSize().height;\n        }\n        return 0;\n    }\n\n    public float getMinimumSpan(final int axis) {", "refactored_code": "    private static final int EMPTY_SPAN = 0;\n            }\n            return component.getPreferredSize().height;\n        }\n        return EMPTY_SPAN;\n    }\n\n    public float getMinimumSpan(final int axis) {"}
{"magic_number_smell": "\n    final void setAsynchronousMovement(final boolean b) {\n        async = b;\n        int i = (b) ? DefaultCaret.2\n                : DefaultCaret.UPDATE_WHEN_ON_EDT;\n        setUpdatePolicy(i);\n    }", "refactored_code": "    public static final int ALWAYS_UPDATE = 2;\n\n    final void setAsynchronousMovement(final boolean b) {\n        async = b;\n        int i = (b) ? DefaultCaret.ALWAYS_UPDATE\n                : DefaultCaret.UPDATE_WHEN_ON_EDT;\n        setUpdatePolicy(i);\n    }"}
{"magic_number_smell": "        if (!in.ready()) {\n            return;\n        }\n        int maxCharToRead = 256;\n        char[] readArray = new char[maxCharToRead];\n        int numCharRead = -1;\n        AttributeSet attributes = doc.getDefaultRootElement().getAttributes();", "refactored_code": "    private static final int CHARACTERS_TO_READ_AT_ONCE = 256;\n        if (!in.ready()) {\n            return;\n        }\n        int maxCharToRead = CHARACTERS_TO_READ_AT_ONCE;\n        char[] readArray = new char[maxCharToRead];\n        int numCharRead = -1;\n        AttributeSet attributes = doc.getDefaultRootElement().getAttributes();"}
{"magic_number_smell": "         * which can be revealed using the following code:\n         *\n         *     Object obj = new DefaultStyledDocument.ElementSpec(null,\n         *         DefaultStyledDocument.ElementSpec.3);\n         *     System.out.println(obj.toString());\n         */\n        public String toString() {", "refactored_code": "        public static final short ContentType = 3;\n         * which can be revealed using the following code:\n         *\n         *     Object obj = new DefaultStyledDocument.ElementSpec(null,\n         *         DefaultStyledDocument.ElementSpec.ContentType);\n         *     System.out.println(obj.toString());\n         */\n        public String toString() {"}
{"magic_number_smell": "    private transient Segment textBuffer;\n\n    public GapContent() {\n        this(10);\n    }\n\n    public GapContent(final int initialLength) {", "refactored_code": "    private static final int DEFAULT_SIZE = 10;\n    private transient Segment textBuffer;\n\n    public GapContent() {\n        this(DEFAULT_SIZE);\n    }\n\n    public GapContent(final int initialLength) {"}
{"magic_number_smell": "        final float basedX = x > base ? x - base : 0;\n        final TabSet tabSet = getTabSet();\n        if (tabSet == null) {\n            return base + ((int)(basedX / 72) + 1) * 72;\n        }\n\n        final TabStop tabStop = tabSet.getTabAfter(basedX);", "refactored_code": "    private static final int DEFAULT_TAB = 72;\n        final float basedX = x > base ? x - base : 0;\n        final TabSet tabSet = getTabSet();\n        if (tabSet == null) {\n            return base + ((int)(basedX / DEFAULT_TAB) + 1) * DEFAULT_TAB;\n        }\n\n        final TabStop tabStop = tabSet.getTabAfter(basedX);"}
{"magic_number_smell": "\n    public PlainDocument(final Content content) {\n        super(content);\n        putProperty(tabSizeAttribute, new Integer(8));\n        defRoot = (BranchElement)createDefaultRoot();\n    }\n", "refactored_code": "    private static final int DEFAULT_TABSIZE = 8;\n\n    public PlainDocument(final Content content) {\n        super(content);\n        putProperty(tabSizeAttribute, new Integer(DEFAULT_TABSIZE));\n        defRoot = (BranchElement)createDefaultRoot();\n    }\n"}
{"magic_number_smell": "\n\n    public StringContent() {\n        this(10);\n    }\n\n    public StringContent(final int initialLength) {", "refactored_code": "    private static final int DEFAULT_SIZE = 10;\n\n\n    public StringContent() {\n        this(DEFAULT_SIZE);\n    }\n\n    public StringContent(final int initialLength) {"}
{"magic_number_smell": "\n    public static int getAlignment(final AttributeSet a) {\n        Integer align = (Integer)a.getAttribute(Alignment);\n        return (align == null) ? 0 : align.intValue();\n    }\n\n    public static float getSpaceBelow(final AttributeSet a) {", "refactored_code": "    public static final int ALIGN_LEFT      = 0;\n\n    public static int getAlignment(final AttributeSet a) {\n        Integer align = (Integer)a.getAttribute(Alignment);\n        return (align == null) ? ALIGN_LEFT : align.intValue();\n    }\n\n    public static float getSpaceBelow(final AttributeSet a) {"}
{"magic_number_smell": "    }\n\n    protected int getCompressionThreshold() {\n        return 9;\n    }\n\n    /**", "refactored_code": "    private static final int COMPRESSION_THRESHOLD = 9;\n    }\n\n    protected int getCompressionThreshold() {\n        return COMPRESSION_THRESHOLD;\n    }\n\n    /**"}
{"magic_number_smell": "    }\n\n    public static class BoldAction extends StyledTextAction {\n        private static final long 1L = 1L;\n\n        public BoldAction() {\n            super(\"font-bold\");", "refactored_code": "        private static final long serialVersionUID = 1L;\n    }\n\n    public static class BoldAction extends StyledTextAction {\n        private static final long serialVersionUID = 1L;\n\n        public BoldAction() {\n            super(\"font-bold\");"}
{"magic_number_smell": "    private final float position;\n\n    public TabStop(final float position) {\n        this(position, 0, LEAD_NONE);\n    }\n\n    public TabStop(final float position, final int align, final int leader) {", "refactored_code": "    public static final int ALIGN_LEFT = 0;\n    private final float position;\n\n    public TabStop(final float position) {\n        this(position, ALIGN_LEFT, LEAD_NONE);\n    }\n\n    public TabStop(final float position, final int align, final int leader) {"}
{"magic_number_smell": "        final Document doc = view.getDocument();\n        final Object value = doc.getProperty(PlainDocument.tabSizeAttribute);\n        return value != null ? ((Integer)value).intValue()\n                             : 8;\n    }\n\n    boolean areMetricsValid() {", "refactored_code": "    private static final int DEFAULT_TAB_SIZE = 8;\n        final Document doc = view.getDocument();\n        final Object value = doc.getProperty(PlainDocument.tabSizeAttribute);\n        return value != null ? ((Integer)value).intValue()\n                             : DEFAULT_TAB_SIZE;\n    }\n\n    boolean areMetricsValid() {"}
{"magic_number_smell": "\n    public int getBreakWeight(final int axis, final float pos,\n                              final float len) {\n        return getPreferredSpan(axis) < len ? GoodBreakWeight : 0;\n    }\n\n    public Shape getChildAllocation(final int index, final Shape shape) {", "refactored_code": "    public static final int BadBreakWeight = 0;\n\n    public int getBreakWeight(final int axis, final float pos,\n                              final float len) {\n        return getPreferredSpan(axis) < len ? GoodBreakWeight : BadBreakWeight;\n    }\n\n    public Shape getChildAllocation(final int index, final Shape shape) {"}
{"magic_number_smell": "                    switch (index) {\n                    case 0: // top\n                        horz = getKeywordValue(KV_50);\n                        vert = getKeywordValue(0);\n                        break;\n\n                    case 1: // center", "refactored_code": "        private static final int KV_0   = 0;\n                    switch (index) {\n                    case 0: // top\n                        horz = getKeywordValue(KV_50);\n                        vert = getKeywordValue(KV_0);\n                        break;\n\n                    case 1: // center"}
{"magic_number_smell": "            throw new IllegalArgumentException(Messages.getString(\"swing.00\", axis)); //$NON-NLS-1$ \n        }\n        if (getComponent() == null || getParent() == null) {\n            return 0;\n        }\n\n        Object tag = getElement().getAttributes()", "refactored_code": "    private static final int EMPTY_SPAN = 0;\n            throw new IllegalArgumentException(Messages.getString(\"swing.00\", axis)); //$NON-NLS-1$ \n        }\n        if (getComponent() == null || getParent() == null) {\n            return EMPTY_SPAN;\n        }\n\n        Object tag = getElement().getAttributes()"}
{"magic_number_smell": "                final AttributeSet attrs, final char widestChar) {\n            final String attribute\n                = (String) attrs.getAttribute(HTML.Attribute.SIZE);\n            int width = 20;\n            if (attribute != null) {\n                try {\n                    final int newWidth = Integer.parseInt(attribute);", "refactored_code": "        private static final int DEFAULT_TEXTFIELD_SIZE = 20;\n                final AttributeSet attrs, final char widestChar) {\n            final String attribute\n                = (String) attrs.getAttribute(HTML.Attribute.SIZE);\n            int width = DEFAULT_TEXTFIELD_SIZE;\n            if (attribute != null) {\n                try {\n                    final int newWidth = Integer.parseInt(attribute);"}
{"magic_number_smell": "\n    public float getPreferredSpan(final int axis) {\n        if (axis == Y_AXIS) {\n            return getSizeAttr() + 2 * 3;\n        } else {\n            return Integer.MAX_VALUE;\n        }", "refactored_code": "    private static final int INSET = 3;\n\n    public float getPreferredSpan(final int axis) {\n        if (axis == Y_AXIS) {\n            return getSizeAttr() + 2 * INSET;\n        } else {\n            return Integer.MAX_VALUE;\n        }"}
{"magic_number_smell": "\n        private void addSpec(final ElementSpec spec) {\n            if (insertTagFound && (!implicitSpecsRemove || \n                    specsCount >= 8)) {\n                parseBuffer.add(spec);\n            }\n            specsCount++;", "refactored_code": "        private static final int IMPLIED_HTML_DOCUMENT_START_SPECS_NUMBER = 8;\n\n        private void addSpec(final ElementSpec spec) {\n            if (insertTagFound && (!implicitSpecsRemove || \n                    specsCount >= IMPLIED_HTML_DOCUMENT_START_SPECS_NUMBER)) {\n                parseBuffer.add(spec);\n            }\n            specsCount++;"}
{"magic_number_smell": "\n    public HTMLWriter(final Writer w, final HTMLDocument doc) {\n        super(w, doc);\n        setLineLength(80);\n    }\n\n    public HTMLWriter(final Writer w, final HTMLDocument doc,", "refactored_code": "    private static final int DEFAULT_LINE_LENGTH = 80;\n\n    public HTMLWriter(final Writer w, final HTMLDocument doc) {\n        super(w, doc);\n        setLineLength(DEFAULT_LINE_LENGTH);\n    }\n\n    public HTMLWriter(final Writer w, final HTMLDocument doc,"}
{"magic_number_smell": "                // Ignored, according to RI's result\n            }\n        }\n        return -1;\n    }\n\n    private void createImage(final int desiredWidth, final int desiredHeight) {", "refactored_code": "    private final int INT_PROPERTY_NOT_FOUND = -1;\n                // Ignored, according to RI's result\n            }\n        }\n        return INT_PROPERTY_NOT_FOUND;\n    }\n\n    private void createImage(final int desiredWidth, final int desiredHeight) {"}
{"magic_number_smell": "            pAlloc = (Rectangle)child.getChildAllocation(0, pAlloc);\n\n            g.drawString(decorator,\n                         (int)(x - width - 5),\n                         (int)(pAlloc.y\n                               + pAlloc.height * child.getView(0)\n                                                 .getAlignment(View.Y_AXIS)", "refactored_code": "        private static final float DECORATOR_MARGIN = 5;\n            pAlloc = (Rectangle)child.getChildAllocation(0, pAlloc);\n\n            g.drawString(decorator,\n                         (int)(x - width - DECORATOR_MARGIN),\n                         (int)(pAlloc.y\n                               + pAlloc.height * child.getView(0)\n                                                 .getAlignment(View.Y_AXIS)"}
{"magic_number_smell": "          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = -1;\n            break zzForAction;\n          }\n          else {", "refactored_code": "  public static final int YYEOF = -1;\n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {"}
{"magic_number_smell": "                            levelUp();\n                            impliedInfo = imply (getNodeElement(currentElemNode), e, false, parsed);\n                        } else {\n                            while (depth <= 2 && !searchCompleted) {\n                                // implied also checks if the element is in the\n                                // inclusions of a potential implication path\n                                implied = actualElem.getContent().implication(e, parsed, false, depth, path);", "refactored_code": "        private static final int MAX_DEPTH = 2;\n                            levelUp();\n                            impliedInfo = imply (getNodeElement(currentElemNode), e, false, parsed);\n                        } else {\n                            while (depth <= MAX_DEPTH && !searchCompleted) {\n                                // implied also checks if the element is in the\n                                // inclusions of a potential implication path\n                                implied = actualElem.getContent().implication(e, parsed, false, depth, path);"}
{"magic_number_smell": "\n    protected void startEditingTimer() {\n        if (timer == null) {\n            timer = new Timer(1200, this);\n            timer.setRepeats(false);\n            timer.start();\n        } else {", "refactored_code": "    private static final int EDITING_DELAY = 1200;\n\n    protected void startEditingTimer() {\n        if (timer == null) {\n            timer = new Timer(EDITING_DELAY, this);\n            timer.setRepeats(false);\n            timer.start();\n        } else {"}
{"magic_number_smell": "    }\n\n    public void clearSelection() {\n        modifyPathsSelection(null, 1);\n    }\n\n    public TreePath getLeadSelectionPath() {", "refactored_code": "    private static final int CLEAR_SELECTED_PATHS = 1;\n    }\n\n    public void clearSelection() {\n        modifyPathsSelection(null, CLEAR_SELECTED_PATHS);\n    }\n\n    public TreePath getLeadSelectionPath() {"}
{"magic_number_smell": "            return RESIZE_NONE;\n        }\n\n        inner.grow(-15, -15);\n        if (inner.width < 0) {\n            inner.width = 1;\n        }", "refactored_code": "    public static final int FRAME_CORNER_SIZE = 15;\n            return RESIZE_NONE;\n        }\n\n        inner.grow(-FRAME_CORNER_SIZE, -FRAME_CORNER_SIZE);\n        if (inner.width < 0) {\n            inner.width = 1;\n        }"}
{"magic_number_smell": "            return INPUT_TYPE_FILE_INDEX;\n        }\n\n        return -1;\n    }\n\n    public static int getElementTypeIndex(final AttributeSet attr) {", "refactored_code": "    public static final int INPUT_TYPE_INDEX_UNDEFINED = -1;\n            return INPUT_TYPE_FILE_INDEX;\n        }\n\n        return INPUT_TYPE_INDEX_UNDEFINED;\n    }\n\n    public static int getElementTypeIndex(final AttributeSet attr) {"}
{"magic_number_smell": "\n    public void testClone() throws CloneNotSupportedException {\n        class MyAbstractAction extends AbstractAction {\n            private static final long 1L = 1L;\n\n            public void actionPerformed(final ActionEvent e) {\n            }", "refactored_code": "            private static final long serialVersionUID = 1L;\n\n    public void testClone() throws CloneNotSupportedException {\n        class MyAbstractAction extends AbstractAction {\n            private static final long serialVersionUID = 1L;\n\n            public void actionPerformed(final ActionEvent e) {\n            }"}
{"magic_number_smell": "    public void testAbstractActionStringIcon() {\n        Icon icon = new ImageIcon(new BufferedImage(20, 20, BufferedImage.TYPE_BYTE_GRAY));\n        action = new AbstractAction(\"ActionName\", icon) {\n            private static final long 1L = 1L;\n\n            public void actionPerformed(final ActionEvent event) {\n            }", "refactored_code": "            private static final long serialVersionUID = 1L;\n    public void testAbstractActionStringIcon() {\n        Icon icon = new ImageIcon(new BufferedImage(20, 20, BufferedImage.TYPE_BYTE_GRAY));\n        action = new AbstractAction(\"ActionName\", icon) {\n            private static final long serialVersionUID = 1L;\n\n            public void actionPerformed(final ActionEvent event) {\n            }"}
{"magic_number_smell": "    };\n\n    class ConcreteAction extends AbstractAction {\n        private static final long 1L = 1L;\n\n        ActionEvent eventHappened;\n", "refactored_code": "        private static final long serialVersionUID = 1L;\n    };\n\n    class ConcreteAction extends AbstractAction {\n        private static final long serialVersionUID = 1L;\n\n        ActionEvent eventHappened;\n"}
{"magic_number_smell": "            @Override\n            public AccessibleContext getAccessibleContext() {\n                return new AccessibleJComponent() {\n                    private static final long 1L = 1L;\n                };\n            }\n        };", "refactored_code": "            private static final long serialVersionUID = 1L;\n            @Override\n            public AccessibleContext getAccessibleContext() {\n                return new AccessibleJComponent() {\n                    private static final long serialVersionUID = 1L;\n                };\n            }\n        };"}
{"magic_number_smell": "            }\n        };\n        map.setParent(new ActionMap() {\n            private static final long 1L = 1L;\n\n            @Override\n            public Action get(Object key) {", "refactored_code": "            private static final long serialVersionUID = 1L;\n            }\n        };\n        map.setParent(new ActionMap() {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            public Action get(Object key) {"}
{"magic_number_smell": "    static {\n        String timeoutProp = System.getProperty(\"test.timeout\");\n        if (timeoutProp == null || timeoutProp.length() == 0) {\n            defaultTimeoutDelay = 10000;\n        } else {\n            defaultTimeoutDelay = Integer.parseInt(timeoutProp);\n        }", "refactored_code": "    public static final long DEFAULT_TIMEOUT_DELAY = 10000;\n    static {\n        String timeoutProp = System.getProperty(\"test.timeout\");\n        if (timeoutProp == null || timeoutProp.length() == 0) {\n            defaultTimeoutDelay = DEFAULT_TIMEOUT_DELAY;\n        } else {\n            defaultTimeoutDelay = Integer.parseInt(timeoutProp);\n        }"}
{"magic_number_smell": "        };\n        final Marker childInvalidation = new Marker();\n        JPanel child = new JPanel() {\n            private static final long 1L = 1L;\n\n            @Override\n            public void invalidate() {", "refactored_code": "            private static final long serialVersionUID = 1L;\n        };\n        final Marker childInvalidation = new Marker();\n        JPanel child = new JPanel() {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            public void invalidate() {"}
{"magic_number_smell": "\n        public void editingCanceled(final ChangeEvent e) {\n            event = e;\n            eventType = 1;\n        }\n\n        public void editingStopped(ChangeEvent e) {", "refactored_code": "        public static final int CANCELED = 1;\n\n        public void editingCanceled(final ChangeEvent e) {\n            event = e;\n            eventType = CANCELED;\n        }\n\n        public void editingStopped(ChangeEvent e) {"}
{"magic_number_smell": "        assertNull(\"description\", icon.getDescription());\n        assertEquals(\"width\", -1, icon.getIconWidth());\n        int bytesRead = stream1.read(array1);\n        assertEquals(\"array size\", 923, bytesRead);\n        icon = new ImageIcon(array1);\n        assertEquals(\"loaded\", MediaTracker.COMPLETE, icon.getImageLoadStatus());\n        if (isHarmony()) {", "refactored_code": "    private static final int FILE_SIZE_1 = 923;\n        assertNull(\"description\", icon.getDescription());\n        assertEquals(\"width\", -1, icon.getIconWidth());\n        int bytesRead = stream1.read(array1);\n        assertEquals(\"array size\", FILE_SIZE_1, bytesRead);\n        icon = new ImageIcon(array1);\n        assertEquals(\"loaded\", MediaTracker.COMPLETE, icon.getImageLoadStatus());\n        if (isHarmony()) {"}
{"magic_number_smell": "        String text1 = \"texttext1\";\n        String text2 = \"texttext2\";\n        AbstractAction action1 = new AbstractAction(text1, icon1) {\n            private static final long 1L = 1L;\n\n            public void actionPerformed(final ActionEvent event) {\n            }", "refactored_code": "            private static final long serialVersionUID = 1L;\n        String text1 = \"texttext1\";\n        String text2 = \"texttext2\";\n        AbstractAction action1 = new AbstractAction(text1, icon1) {\n            private static final long serialVersionUID = 1L;\n\n            public void actionPerformed(final ActionEvent event) {\n            }"}
{"magic_number_smell": "            }\n        };\n        AbstractAction action2 = new AbstractAction() {\n            private static final long 1L = 1L;\n\n            public void actionPerformed(final ActionEvent event) {\n            }", "refactored_code": "            private static final long serialVersionUID = 1L;\n            }\n        };\n        AbstractAction action2 = new AbstractAction() {\n            private static final long serialVersionUID = 1L;\n\n            public void actionPerformed(final ActionEvent event) {\n            }"}
{"magic_number_smell": "\n        public void popupMenuCanceled(final PopupMenuEvent e) {\n            event = e;\n            eventType = 0;\n        }\n\n        public void popupMenuWillBecomeInvisible(final PopupMenuEvent e) {", "refactored_code": "        public static final int CANCELLED = 0;\n\n        public void popupMenuCanceled(final PopupMenuEvent e) {\n            event = e;\n            eventType = CANCELLED;\n        }\n\n        public void popupMenuWillBecomeInvisible(final PopupMenuEvent e) {"}
{"magic_number_smell": "    public void testSetBounds() throws Throwable {\n        final Marker marker = new Marker();\n        final JComponent button = new JButton(\"JButton\") {\n            private static final long 1L = 1L;\n\n            @Override\n            public void revalidate() {", "refactored_code": "            private static final long serialVersionUID = 1L;\n    public void testSetBounds() throws Throwable {\n        final Marker marker = new Marker();\n        final JComponent button = new JButton(\"JButton\") {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            public void revalidate() {"}
{"magic_number_smell": "\n    public void testCreateDefaultEditorKit_installCall() {\n        JEditorPane pane = new JEditorPane() {\n            private static final long 1L = 1L;\n        };\n        pane.setEditorKit(new StyledEditorKit() {\n            private static final long 1L = 1L;", "refactored_code": "            private static final long serialVersionUID = 1L;\n\n    public void testCreateDefaultEditorKit_installCall() {\n        JEditorPane pane = new JEditorPane() {\n            private static final long serialVersionUID = 1L;\n        };\n        pane.setEditorKit(new StyledEditorKit() {\n            private static final long serialVersionUID = 1L;"}
{"magic_number_smell": "    };\n\n    class DbgFormatter extends DefaultFormatter {\n        private static final long 1L = 1L;\n\n        boolean wasCallInstall;\n", "refactored_code": "        private static final long serialVersionUID = 1L;\n    };\n\n    class DbgFormatter extends DefaultFormatter {\n        private static final long serialVersionUID = 1L;\n\n        boolean wasCallInstall;\n"}
{"magic_number_smell": "    }\n\n    class TextActionImpl extends TextAction {\n        private static final long 1L = 1L;\n\n        TextActionImpl(final String name) {\n            super(name);", "refactored_code": "        private static final long serialVersionUID = 1L;\n    }\n\n    class TextActionImpl extends TextAction {\n        private static final long serialVersionUID = 1L;\n\n        TextActionImpl(final String name) {\n            super(name);"}
{"magic_number_smell": "        }\n\n        public void internalFrameOpened(final InternalFrameEvent e) {\n            state |= 1;\n        }\n\n        public void internalFrameClosing(final InternalFrameEvent e) {", "refactored_code": "        private static final int opened = 1;\n        }\n\n        public void internalFrameOpened(final InternalFrameEvent e) {\n            state |= opened;\n        }\n\n        public void internalFrameClosing(final InternalFrameEvent e) {"}
{"magic_number_smell": "                MouseEvent.MOUSE_ENTERED, EventQueue.getMostRecentEventTime(), 0, 5, 5, 0,\n                false)));\n        list.setCellRenderer(new DefaultListCellRenderer() {\n            private static final long 1L = 1L;\n\n            @Override\n            public Component getListCellRendererComponent(final JList list, final Object value,", "refactored_code": "            private static final long serialVersionUID = 1L;\n                MouseEvent.MOUSE_ENTERED, EventQueue.getMostRecentEventTime(), 0, 5, 5, 0,\n                false)));\n        list.setCellRenderer(new DefaultListCellRenderer() {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            public Component getListCellRendererComponent(final JList list, final Object value,"}
{"magic_number_smell": "     */\n    public void testCreateActionChangeListener() {\n        AbstractAction action1 = new AbstractAction() {\n            private static final long 1L = 1L;\n\n            public void actionPerformed(ActionEvent e) {\n            }", "refactored_code": "        private static final long serialVersionUID = 1L;\n     */\n    public void testCreateActionChangeListener() {\n        AbstractAction action1 = new AbstractAction() {\n            private static final long serialVersionUID = 1L;\n\n            public void actionPerformed(ActionEvent e) {\n            }"}
{"magic_number_smell": "            }\n        };\n        AbstractAction action2 = new AbstractAction() {\n            private static final long 1L = 1L;\n\n            public void actionPerformed(final ActionEvent event) {\n            }", "refactored_code": "            private static final long serialVersionUID = 1L;\n            }\n        };\n        AbstractAction action2 = new AbstractAction() {\n            private static final long serialVersionUID = 1L;\n\n            public void actionPerformed(final ActionEvent event) {\n            }"}
{"magic_number_smell": "        jtf.addActionListener(listener3);\n        fireOrder = \"\";\n        jtf.setAction(new DefaultEditorKit.BeepAction() {\n            private static final long 1L = 1L;\n\n            @Override\n            public void actionPerformed(final ActionEvent arg0) {", "refactored_code": "        private static final long serialVersionUID = 1L;\n        jtf.addActionListener(listener3);\n        fireOrder = \"\";\n        jtf.setAction(new DefaultEditorKit.BeepAction() {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            public void actionPerformed(final ActionEvent arg0) {"}
{"magic_number_smell": "        testExceptionalCase(new IllegalArgumentCase() {\n            @Override\n            public void exceptionalAction() throws Exception {\n                toolBar = new JToolBar(4);\n            }\n        });\n    }", "refactored_code": "    private static final int INVALID_ORIENTATION = 4;\n        testExceptionalCase(new IllegalArgumentCase() {\n            @Override\n            public void exceptionalAction() throws Exception {\n                toolBar = new JToolBar(INVALID_ORIENTATION);\n            }\n        });\n    }"}
{"magic_number_smell": "\n    private JComponent newJComponent() {\n        return new JComponent() {\n            private static final long 1L = 1L;\n        };\n    }\n", "refactored_code": "            private static final long serialVersionUID = 1L;\n\n    private JComponent newJComponent() {\n        return new JComponent() {\n            private static final long serialVersionUID = 1L;\n        };\n    }\n"}
{"magic_number_smell": "    public void testValidateInvalidComponents() throws Exception {\n        Frame f = new Frame();\n        final JPanel rootPanel = new JPanel(new BorderLayout()) {\n            private static final long 1L = 1L;\n\n            @Override\n            public boolean isValidateRoot() {", "refactored_code": "                private static final long serialVersionUID = 1L;\n    public void testValidateInvalidComponents() throws Exception {\n        Frame f = new Frame();\n        final JPanel rootPanel = new JPanel(new BorderLayout()) {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            public boolean isValidateRoot() {"}
{"magic_number_smell": "        });\n\n        component = new JButton(\"Test\") {\n            private static final long 1L = 1L;\n\n            @Override\n            public java.awt.Dimension getMinimumSize() {", "refactored_code": "            private static final long serialVersionUID = 1L;\n        });\n\n        component = new JButton(\"Test\") {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            public java.awt.Dimension getMinimumSize() {"}
{"magic_number_smell": "    }\n\n    class UIInputMap extends InputMap implements UIResource {\n        private static final long 1L = 1L;\n    }\n\n    /*", "refactored_code": "        private static final long serialVersionUID = 1L;\n    }\n\n    class UIInputMap extends InputMap implements UIResource {\n        private static final long serialVersionUID = 1L;\n    }\n\n    /*"}
{"magic_number_smell": "            return;\n        }\n        long startTime = System.currentTimeMillis();\n        while (!comp.isShowing() && (System.currentTimeMillis() - startTime) < 5000) {\n            Thread.sleep(10);\n        }\n        if (!comp.isShowing()) {", "refactored_code": "    private static final int MAX_WAIT_TIME = 5000;\n            return;\n        }\n        long startTime = System.currentTimeMillis();\n        while (!comp.isShowing() && (System.currentTimeMillis() - startTime) < MAX_WAIT_TIME) {\n            Thread.sleep(10);\n        }\n        if (!comp.isShowing()) {"}
{"magic_number_smell": "     */\n    public void testGetBorderInsetsComponent() {\n        AbstractBorder border = new AbstractBorder() {\n            private static final long 1L = 1L;\n        };\n        Insets insets = null;\n        JPanel panel = new JPanel();", "refactored_code": "            private static final long serialVersionUID = 1L;\n     */\n    public void testGetBorderInsetsComponent() {\n        AbstractBorder border = new AbstractBorder() {\n            private static final long serialVersionUID = 1L;\n        };\n        Insets insets = null;\n        JPanel panel = new JPanel();"}
{"magic_number_smell": "\n    public void testGetFont() {\n        class PublicTitledBorder extends TitledBorder {\n            private static final long 1L = 1L;\n\n            PublicTitledBorder(final String title) {\n                super(title);", "refactored_code": "            private static final long serialVersionUID = 1L;\n\n    public void testGetFont() {\n        class PublicTitledBorder extends TitledBorder {\n            private static final long serialVersionUID = 1L;\n\n            PublicTitledBorder(final String title) {\n                super(title);"}
{"magic_number_smell": "    };\n\n    public static class SerializableListener implements PropertyChangeListener, Serializable {\n        private static final long 1L = 1L;\n\n        private String name;\n", "refactored_code": "        private static final long serialVersionUID = 1L;\n    };\n\n    public static class SerializableListener implements PropertyChangeListener, Serializable {\n        private static final long serialVersionUID = 1L;\n\n        private String name;\n"}
{"magic_number_smell": "    public void testPaintTriangle() throws NullPointerException { \n        Graphics2D g2D = new BufferedImage(6, 6, BufferedImage.TYPE_INT_RGB).createGraphics(); \n        BasicArrowButton ab = new BasicArrowButton(0); \n        ab.paintTriangle(g2D, 0, 0, 0, 10, true); \n    } \n    \n    /**", "refactored_code": "    private static final int INCORRECT_DIRECTION = 10; \n    public void testPaintTriangle() throws NullPointerException { \n        Graphics2D g2D = new BufferedImage(6, 6, BufferedImage.TYPE_INT_RGB).createGraphics(); \n        BasicArrowButton ab = new BasicArrowButton(0); \n        ab.paintTriangle(g2D, 0, 0, 0, INCORRECT_DIRECTION, true); \n    } \n    \n    /**"}
{"magic_number_smell": "\n    private JComponent newJComponent() {\n        return new JComponent() {\n            private static final long 1L = 1L;\n        };\n    }\n}", "refactored_code": "            private static final long serialVersionUID = 1L;\n\n    private JComponent newJComponent() {\n        return new JComponent() {\n            private static final long serialVersionUID = 1L;\n        };\n    }\n}"}
{"magic_number_smell": "\n        public void popupMenuCanceled(final PopupMenuEvent e) {\n            event = e;\n            eventType = 1;\n        }\n\n        public void popupMenuWillBecomeInvisible(final PopupMenuEvent e) {", "refactored_code": "        public static final int MENU_CANCELED = 1;\n\n        public void popupMenuCanceled(final PopupMenuEvent e) {\n            event = e;\n            eventType = MENU_CANCELED;\n        }\n\n        public void popupMenuWillBecomeInvisible(final PopupMenuEvent e) {"}
{"magic_number_smell": "\n    public void testDrawEtchedRect() {\n        Color color = g.getColor();\n        BasicGraphicsUtils.drawEtchedRect(g, x, 0, w, h, shadow, darkShadow, highlight,\n                lightHighlight);\n        assertSame(color, g.getColor());\n    }", "refactored_code": "    private final int y = 0;\n\n    public void testDrawEtchedRect() {\n        Color color = g.getColor();\n        BasicGraphicsUtils.drawEtchedRect(g, x, y, w, h, shadow, darkShadow, highlight,\n                lightHighlight);\n        assertSame(color, g.getColor());\n    }"}
{"magic_number_smell": "        Icon icon3 = new ImageIcon(new BufferedImage(100, 20, BufferedImage.TYPE_INT_RGB));\n        Icon icon4 = new ImageIcon(new BufferedImage(1000, 20, BufferedImage.TYPE_INT_RGB));\n        JMenuItem item = new JMenuItem() {\n            private static final long 1L = 1L;\n\n            @SuppressWarnings(\"deprecation\")\n            @Override", "refactored_code": "            private static final long serialVersionUID = 1L;\n        Icon icon3 = new ImageIcon(new BufferedImage(100, 20, BufferedImage.TYPE_INT_RGB));\n        Icon icon4 = new ImageIcon(new BufferedImage(1000, 20, BufferedImage.TYPE_INT_RGB));\n        JMenuItem item = new JMenuItem() {\n            private static final long serialVersionUID = 1L;\n\n            @SuppressWarnings(\"deprecation\")\n            @Override"}
{"magic_number_smell": "    public void testGetMaxCharactersPerLineCount_OptionPane() {\n        final Marker marker = new Marker();\n        paneUI.optionPane = new JOptionPane() {\n            private static final long 1L = 1L;\n\n            @Override\n            public int getMaxCharactersPerLineCount() {", "refactored_code": "            private static final long serialVersionUID = 1L;\n    public void testGetMaxCharactersPerLineCount_OptionPane() {\n        final Marker marker = new Marker();\n        paneUI.optionPane = new JOptionPane() {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            public int getMaxCharactersPerLineCount() {"}
{"magic_number_smell": "\n        public void columnAdded(final TableColumnModelEvent e) {\n            event = e;\n            eventType = 0;\n        }\n\n        public void columnMoved(final TableColumnModelEvent e) {", "refactored_code": "        public static final int COLUMN_ADDED = 0;\n\n        public void columnAdded(final TableColumnModelEvent e) {\n            event = e;\n            eventType = COLUMN_ADDED;\n        }\n\n        public void columnMoved(final TableColumnModelEvent e) {"}
{"magic_number_smell": "         *\n         */\n        class DisAbstractedElement extends AbstractDocument.AbstractElement {\n            private static final long 1L = 1L;\n\n            public DisAbstractedElement(final Element initParent,\n                    final AttributeSet initAttributes) {", "refactored_code": "        private static final long serialVersionUID = 1L;\n         *\n         */\n        class DisAbstractedElement extends AbstractDocument.AbstractElement {\n            private static final long serialVersionUID = 1L;\n\n            public DisAbstractedElement(final Element initParent,\n                    final AttributeSet initAttributes) {"}
{"magic_number_smell": "    public void testAddEdit02() {\n        // Used as parent for Edits\n        final class Parent extends BranchElement {\n            private static final long 1L = 1L;\n\n            public Parent() {\n                doc.super(null, null);", "refactored_code": "            private static final long serialVersionUID = 1L;\n    public void testAddEdit02() {\n        // Used as parent for Edits\n        final class Parent extends BranchElement {\n            private static final long serialVersionUID = 1L;\n\n            public Parent() {\n                doc.super(null, null);"}
{"magic_number_smell": "     */\n    public void testInsertRemove() throws Exception {\n        doc = new DisAbstractedDocument(new GapContent() {\n            private static final long 1L = 1L;\n\n            @Override\n            public UndoableEdit insertString(int where, String str) throws BadLocationException {", "refactored_code": "        private static final long serialVersionUID = 1L;\n     */\n    public void testInsertRemove() throws Exception {\n        doc = new DisAbstractedDocument(new GapContent() {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            public UndoableEdit insertString(int where, String str) throws BadLocationException {"}
{"magic_number_smell": "    private static final int height = 325;\n\n    private static class Child extends ChildView {\n        private int 150 = -1;\n\n        private int height = -1;\n", "refactored_code": "    private static final int width = 150;\n    private static final int height = 325;\n\n    private static class Child extends ChildView {\n        private int width = -1;\n\n        private int height = -1;\n"}
{"magic_number_smell": "            protected void layoutMajorAxis(final int targetSpan, final int axis,\n                    final int[] offsets, final int[] spans) {\n                called[0] = true;\n                assertEquals(150, targetSpan);\n                assertEquals(X_AXIS, axis);\n                super.layoutMajorAxis(targetSpan, axis, offsets, spans);\n            }", "refactored_code": "    private final int width = 150;\n            protected void layoutMajorAxis(final int targetSpan, final int axis,\n                    final int[] offsets, final int[] spans) {\n                called[0] = true;\n                assertEquals(width, targetSpan);\n                assertEquals(X_AXIS, axis);\n                super.layoutMajorAxis(targetSpan, axis, offsets, spans);\n            }"}
{"magic_number_smell": "    private static final int POS = ViewTestHelpers.POS;\n\n    /**\n     * Invalid axis: neither X_AXIS nor View.Y_AXIS.\n     */\n    private static final int INVALID_AXIS = 2;\n", "refactored_code": "    private static final int Y_AXIS = View.Y_AXIS;\n    private static final int POS = ViewTestHelpers.POS;\n\n    /**\n     * Invalid axis: neither X_AXIS nor Y_AXIS.\n     */\n    private static final int INVALID_AXIS = 2;\n"}
{"magic_number_smell": "    public void testWriteOutputStreamDocumentintint() throws Exception {\n        final Marker writeMarker = new Marker();\n        DefaultEditorKit kit = new DefaultEditorKit() {\n            private static final long 1L = 1L;\n\n            @Override\n            public void write(Writer out, Document doc, int pos, int len) throws IOException,", "refactored_code": "            private static final long serialVersionUID = 1L;\n    public void testWriteOutputStreamDocumentintint() throws Exception {\n        final Marker writeMarker = new Marker();\n        DefaultEditorKit kit = new DefaultEditorKit() {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            public void write(Writer out, Document doc, int pos, int len) throws IOException,"}
{"magic_number_smell": "\n    private static final int endOffset = 28;\n\n    private static final int length = endOffset - 5;\n\n    private static final String LEAF_TEXT = FULL_TEXT.substring(5, endOffset);\n", "refactored_code": "    private static final int startOffset = 5;\n\n    private static final int endOffset = 28;\n\n    private static final int length = endOffset - startOffset;\n\n    private static final String LEAF_TEXT = FULL_TEXT.substring(startOffset, endOffset);\n"}
{"magic_number_smell": "    public void testInsertString02() throws BadLocationException {\n        doc.remove(0, doc.getLength());\n        doc.buffer = new ElementBufferWithLogging(doc, root) {\n            private static final long 1L = 1L;\n\n            @Override\n            public void insert(int offset, int length, ElementSpec[] spec,", "refactored_code": "            private static final long serialVersionUID = 1L;\n    public void testInsertString02() throws BadLocationException {\n        doc.remove(0, doc.getLength());\n        doc.buffer = new ElementBufferWithLogging(doc, root) {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            public void insert(int offset, int length, ElementSpec[] spec,"}
{"magic_number_smell": "        insertOffset = 0;\n        // doc.insertString(insertOffset, newLine, null);\n        content.insertString(insertOffset, newLine);\n        event = doc.new DefaultDocumentEvent(insertOffset, newLine.length(), EventType.INSERT);\n        ElementSpec[] specs = { new ElementSpec(null, ElementSpec.ContentType, newLine.length()),\n                new ElementSpec(null, ElementSpec.EndTagType),\n                new ElementSpec(null, ElementSpec.StartTagType) };", "refactored_code": "    private static final int newLineLen = newLine.length();\n        insertOffset = 0;\n        // doc.insertString(insertOffset, newLine, null);\n        content.insertString(insertOffset, newLine);\n        event = doc.new DefaultDocumentEvent(insertOffset, newLineLen, EventType.INSERT);\n        ElementSpec[] specs = { new ElementSpec(null, ElementSpec.ContentType, newLineLen),\n                new ElementSpec(null, ElementSpec.EndTagType),\n                new ElementSpec(null, ElementSpec.StartTagType) };"}
{"magic_number_smell": "        // doc.insertString(insertOffset, newLines2, null);\n        content.insertString(insertOffset, newLines2);\n        event = doc.new DefaultDocumentEvent(insertOffset, newLines2Len, EventType.INSERT);\n        ElementSpec[] specs = { new ElementSpec(null, ElementSpec.ContentType, newLine.length()),\n                new ElementSpec(null, ElementSpec.EndTagType),\n                new ElementSpec(null, ElementSpec.StartTagType),\n                new ElementSpec(null, ElementSpec.ContentType, newLine.length()),", "refactored_code": "    private static final int newLineLen = newLine.length();\n        // doc.insertString(insertOffset, newLines2, null);\n        content.insertString(insertOffset, newLines2);\n        event = doc.new DefaultDocumentEvent(insertOffset, newLines2Len, EventType.INSERT);\n        ElementSpec[] specs = { new ElementSpec(null, ElementSpec.ContentType, newLineLen),\n                new ElementSpec(null, ElementSpec.EndTagType),\n                new ElementSpec(null, ElementSpec.StartTagType),\n                new ElementSpec(null, ElementSpec.ContentType, newLineLen),"}
{"magic_number_smell": "        insertOffset = 0;\n        // doc.insertString(insertOffset, caps, null);\n        content.insertString(insertOffset, caps);\n        event = doc.new DefaultDocumentEvent(insertOffset, caps.length(), EventType.INSERT);\n        ElementSpec spec = new ElementSpec(null, ElementSpec.ContentType, caps.length());\n        spec.setDirection(ElementSpec.JoinPreviousDirection);\n        buf.insert(insertOffset, caps.length(), new ElementSpec[] { spec }, event);", "refactored_code": "    private static final int capsLen = caps.length();\n        insertOffset = 0;\n        // doc.insertString(insertOffset, caps, null);\n        content.insertString(insertOffset, caps);\n        event = doc.new DefaultDocumentEvent(insertOffset, capsLen, EventType.INSERT);\n        ElementSpec spec = new ElementSpec(null, ElementSpec.ContentType, capsLen);\n        spec.setDirection(ElementSpec.JoinPreviousDirection);\n        buf.insert(insertOffset, capsLen, new ElementSpec[] { spec }, event);"}
{"magic_number_smell": "        };\n        doc.buffer = buf;\n        doc.insertString(0, \"first\\nsecond\\nthird\", null);\n        modified = root.getElement(1);\n        insertOffset = modified.getStartOffset() + 2;\n        doc.addDocumentListener(this);\n    }", "refactored_code": "    private static final int modifiedIndex = 1;\n        };\n        doc.buffer = buf;\n        doc.insertString(0, \"first\\nsecond\\nthird\", null);\n        modified = root.getElement(modifiedIndex);\n        insertOffset = modified.getStartOffset() + 2;\n        doc.addDocumentListener(this);\n    }"}
{"magic_number_smell": "        doc.insertString(doc.getLength(), \"bold\", bold); // 4 chars\n        doc.insertString(doc.getLength(), \"italic\", italic); // 6 chars\n        paragraph = root.getElement(0);\n        leaf = paragraph.getElement(1);\n        insertOffset = leaf.getStartOffset() + 2;\n        doc.addDocumentListener(this);\n    }", "refactored_code": "    private static final int leafIndex = 1;\n        doc.insertString(doc.getLength(), \"bold\", bold); // 4 chars\n        doc.insertString(doc.getLength(), \"italic\", italic); // 6 chars\n        paragraph = root.getElement(0);\n        leaf = paragraph.getElement(leafIndex);\n        insertOffset = leaf.getStartOffset() + 2;\n        doc.addDocumentListener(this);\n    }"}
{"magic_number_smell": "     */\n    public void testChangeUpdateCharDirect() {\n        buf = doc.new ElementBuffer(root) {\n            private static final long 1L = 1L;\n\n            @Override\n            protected void changeUpdate() {", "refactored_code": "            private static final long serialVersionUID = 1L;\n     */\n    public void testChangeUpdateCharDirect() {\n        buf = doc.new ElementBuffer(root) {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            protected void changeUpdate() {"}
{"magic_number_smell": "    protected void setUp() throws Exception {\n        super.setUp();\n        doc = new DefaultStyledDocument(new StyleContext() {\n            private static final long 1L = 1L;\n\n            @Override\n            public Color getBackground(AttributeSet as) {", "refactored_code": "            private static final long serialVersionUID = 1L;\n    protected void setUp() throws Exception {\n        super.setUp();\n        doc = new DefaultStyledDocument(new StyleContext() {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            public Color getBackground(AttributeSet as) {"}
{"magic_number_smell": "     * which logs parameters passed to some methods to <code>stdout</code>.\n     */\n    public static class ElementBufferWithLogging extends DefaultStyledDocument.ElementBuffer {\n        private static final long 1L = 1L;\n\n        public ElementBufferWithLogging(final DefaultStyledDocument doc, final Element root) {\n            doc.super(root);", "refactored_code": "        private static final long serialVersionUID = 1L;\n     * which logs parameters passed to some methods to <code>stdout</code>.\n     */\n    public static class ElementBufferWithLogging extends DefaultStyledDocument.ElementBuffer {\n        private static final long serialVersionUID = 1L;\n\n        public ElementBufferWithLogging(final DefaultStyledDocument doc, final Element root) {\n            doc.super(root);"}
{"magic_number_smell": "\n                @Override\n                public String toString() {\n                    return \"row(\" + count++ + \")\";\n                }\n\n                @Override", "refactored_code": "                private final int id = count++;\n\n                @Override\n                public String toString() {\n                    return \"row(\" + id + \")\";\n                }\n\n                @Override"}
{"magic_number_smell": "\n                    @Override\n                    public String toString() {\n                        return \"row(\" + count++ + \")\";\n                    }\n\n                    @Override", "refactored_code": "                    private final int id = count++;\n\n                    @Override\n                    public String toString() {\n                        return \"row(\" + id + \")\";\n                    }\n\n                    @Override"}
{"magic_number_smell": "\n        @Override\n        public float getPreferredSpan(int axis) {\n            int result = axis == View.X_AXIS ? (int) super.getPreferredSpan(axis) : CHAR_HEIGHT;\n            return result;\n        }\n", "refactored_code": "    private static final int X_AXIS = View.X_AXIS;\n\n        @Override\n        public float getPreferredSpan(int axis) {\n            int result = axis == X_AXIS ? (int) super.getPreferredSpan(axis) : CHAR_HEIGHT;\n            return result;\n        }\n"}
{"magic_number_smell": "\n    private static final int endOffset = 28;\n\n    private static final int length = endOffset - 5;\n\n    private static final String LEAF_TEXT = FULL_TEXT.substring(5, endOffset);\n", "refactored_code": "    private static final int startOffset = 5;\n\n    private static final int endOffset = 28;\n\n    private static final int length = endOffset - startOffset;\n\n    private static final String LEAF_TEXT = FULL_TEXT.substring(startOffset, endOffset);\n"}
{"magic_number_smell": "        Font font = view.getFont();\n        FontMetrics metrics = Toolkit.getDefaultToolkit().getFontMetrics(font);\n        assertEquals(metrics.stringWidth(TEXT.substring(view.getStartOffset(), view\n                .getEndOffset())), view.getPreferredSpan(View.X_AXIS), 0.00001f);\n        assertEquals(metrics.getHeight(), view.getPreferredSpan(View.Y_AXIS), 0.00001f);\n        assertNotNull(view.getGlyphPainter());\n    }", "refactored_code": "    private static final float ACCURACY = 0.00001f;\n        Font font = view.getFont();\n        FontMetrics metrics = Toolkit.getDefaultToolkit().getFontMetrics(font);\n        assertEquals(metrics.stringWidth(TEXT.substring(view.getStartOffset(), view\n                .getEndOffset())), view.getPreferredSpan(View.X_AXIS), ACCURACY);\n        assertEquals(metrics.getHeight(), view.getPreferredSpan(View.Y_AXIS), ACCURACY);\n        assertNotNull(view.getGlyphPainter());\n    }"}
{"magic_number_smell": "                .getForeground());\n        assertCalledMethods(FORE);\n        assertNull(plainView.getForeground());\n        assertCalledMethods(-1);\n        assertSame(plainWithParent.getForeground(), plainWithParent.getForeground());\n        assertCalledMethods(AREA_FORE);\n    }", "refactored_code": "    private static final int NONE = -1;\n                .getForeground());\n        assertCalledMethods(FORE);\n        assertNull(plainView.getForeground());\n        assertCalledMethods(NONE);\n        assertSame(plainWithParent.getForeground(), plainWithParent.getForeground());\n        assertCalledMethods(AREA_FORE);\n    }"}
{"magic_number_smell": "\n    private static final int endOffset = 28;\n\n    private static final int length = endOffset - 5;\n\n    private static final String LEAF_TEXT = FULL_TEXT.substring(5, endOffset);\n", "refactored_code": "    private static final int startOffset = 5;\n\n    private static final int endOffset = 28;\n\n    private static final int length = endOffset - startOffset;\n\n    private static final String LEAF_TEXT = FULL_TEXT.substring(startOffset, endOffset);\n"}
{"magic_number_smell": "    }\n\n    public void testGetAlignment() {\n        assertEquals(0.5f, view.getAlignment(View.X_AXIS), 0.00001f);\n        assertEquals(\"\", stream.toString());\n        assertEquals((HEIGHT - DESCENT) / HEIGHT, view.getAlignment(View.Y_AXIS), 0.00001f);\n        assertEquals(\"getHeight(thisTest.view)\\n\" + \"getDescent(thisTest.view)\\n\"", "refactored_code": "    private static final float ACCURACY = 0.00001f;\n    }\n\n    public void testGetAlignment() {\n        assertEquals(0.5f, view.getAlignment(View.X_AXIS), ACCURACY);\n        assertEquals(\"\", stream.toString());\n        assertEquals((HEIGHT - DESCENT) / HEIGHT, view.getAlignment(View.Y_AXIS), ACCURACY);\n        assertEquals(\"getHeight(thisTest.view)\\n\" + \"getDescent(thisTest.view)\\n\""}
{"magic_number_smell": "    }\n\n    class SimpleTransferHandler extends TransferHandler {\n        private static final long 1L = 1L;\n    }\n\n    private class SimpleTextAction extends TextAction {", "refactored_code": "        private static final long serialVersionUID = 1L;\n    }\n\n    class SimpleTransferHandler extends TransferHandler {\n        private static final long serialVersionUID = 1L;\n    }\n\n    private class SimpleTextAction extends TextAction {"}
{"magic_number_smell": "        //        assertEquals((height / 2.0) / view.getPreferredSpan(View.Y_AXIS),\n        //                     view.getAlignment(View.Y_AXIS), 1e-5f);\n        view.layoutChanged(View.X_AXIS);\n        view.layout(WIDTH, 30);\n        assertEquals(0, view.getOffset(View.X_AXIS, 0));\n        assertEquals(view.firstLineIndent, ((CompositeView) view.getView(0)).getLeftInset());\n        assertEquals(0.5f, view.getAlignment(View.X_AXIS), 1e-5f);", "refactored_code": "    private static final int HEIGHT = 30;\n        //        assertEquals((height / 2.0) / view.getPreferredSpan(View.Y_AXIS),\n        //                     view.getAlignment(View.Y_AXIS), 1e-5f);\n        view.layoutChanged(View.X_AXIS);\n        view.layout(WIDTH, HEIGHT);\n        assertEquals(0, view.getOffset(View.X_AXIS, 0));\n        assertEquals(view.firstLineIndent, ((CompositeView) view.getView(0)).getLeftInset());\n        assertEquals(0.5f, view.getAlignment(View.X_AXIS), 1e-5f);"}
{"magic_number_smell": "    public void testInsertUpdate08() throws BadLocationException {\n        final int[] createCalled = new int[2];\n        doc = new PlainDocument() {\n            private static final long 1L = 1L;\n\n            @Override\n            protected void insertUpdate(final DefaultDocumentEvent event,", "refactored_code": "            private static final long serialVersionUID = 1L;\n    public void testInsertUpdate08() throws BadLocationException {\n        final int[] createCalled = new int[2];\n        doc = new PlainDocument() {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            protected void insertUpdate(final DefaultDocumentEvent event,"}
{"magic_number_smell": "        view.loadChildren(null);\n        assertEquals(3, view.getViewCount());\n        int offset = view.getStartOffset();\n        checkChild(view.getView(0), offset, offset + LTR.length());\n        offset += LTR.length();\n        checkChild(view.getView(1), offset, offset + RTLLength);\n        offset += RTLLength;", "refactored_code": "    public static final int LTRLength = LTR.length();\n        view.loadChildren(null);\n        assertEquals(3, view.getViewCount());\n        int offset = view.getStartOffset();\n        checkChild(view.getView(0), offset, offset + LTRLength);\n        offset += LTRLength;\n        checkChild(view.getView(1), offset, offset + RTLLength);\n        offset += RTLLength;"}
{"magic_number_smell": "            }\n        };\n        Action action2 = new AbstractAction(name2) {\n            private static final long 1L = 1L;\n\n            public void actionPerformed(final ActionEvent e) {\n            }", "refactored_code": "            private static final long serialVersionUID = 1L;\n            }\n        };\n        Action action2 = new AbstractAction(name2) {\n            private static final long serialVersionUID = 1L;\n\n            public void actionPerformed(final ActionEvent e) {\n            }"}
{"magic_number_smell": "\n    public void testGetTextComponent() throws Exception {\n        TextAction action = new TextAction(\"\") {\n            private static final long 1L = 1L;\n\n            public void actionPerformed(final ActionEvent e) {\n            }", "refactored_code": "            private static final long serialVersionUID = 1L;\n\n    public void testGetTextComponent() throws Exception {\n        TextAction action = new TextAction(\"\") {\n            private static final long serialVersionUID = 1L;\n\n            public void actionPerformed(final ActionEvent e) {\n            }"}
{"magic_number_smell": "            @Override\n            public Container getContainer() {\n                return new JTextComponent() {\n                    private static final long 1L = 1L;\n\n                    @Override\n                    public void revalidate() {", "refactored_code": "                    private static final long serialVersionUID = 1L;\n            @Override\n            public Container getContainer() {\n                return new JTextComponent() {\n                    private static final long serialVersionUID = 1L;\n\n                    @Override\n                    public void revalidate() {"}
{"magic_number_smell": "     * @return the child height\n     */\n    public static int getHeight(final int id) {\n        return 0 <= id && id < HEIGHT_MULTIPLIER.length ? 16 * HEIGHT_MULTIPLIER[id]\n                : 16;\n    }\n", "refactored_code": "    private static final int HEIGHT = 16;\n     * @return the child height\n     */\n    public static int getHeight(final int id) {\n        return 0 <= id && id < HEIGHT_MULTIPLIER.length ? HEIGHT * HEIGHT_MULTIPLIER[id]\n                : HEIGHT;\n    }\n"}
{"magic_number_smell": "    public void testGetViewIndexFloatFloatShape() {\n        assertEquals(-1, view.getViewIndex(0, 0, shape));\n        assertEquals(0, view.getViewIndex(shape.x, shape.y, shape));\n        assertEquals(0, view.getViewIndex(shape.x + shape.width - 1, shape.y + CompositeView_ModelViewTest.LINE_HEIGHT - 1,\n                shape));\n        assertEquals(-1, view.getViewIndex(shape.x + shape.width, shape.y + CompositeView_ModelViewTest.LINE_HEIGHT, shape));\n        assertEquals(-1, view.getViewIndex(shape.x - 1, shape.y + CompositeView_ModelViewTest.LINE_HEIGHT, shape));", "refactored_code": "    private static final int LINE_HEIGHT = CompositeView_ModelViewTest.LINE_HEIGHT;\n    public void testGetViewIndexFloatFloatShape() {\n        assertEquals(-1, view.getViewIndex(0, 0, shape));\n        assertEquals(0, view.getViewIndex(shape.x, shape.y, shape));\n        assertEquals(0, view.getViewIndex(shape.x + shape.width - 1, shape.y + LINE_HEIGHT - 1,\n                shape));\n        assertEquals(-1, view.getViewIndex(shape.x + shape.width, shape.y + LINE_HEIGHT, shape));\n        assertEquals(-1, view.getViewIndex(shape.x - 1, shape.y + LINE_HEIGHT, shape));"}
{"magic_number_smell": "    }\n\n    public void testGetMaximumSpan() {\n        assertEquals(Integer.MAX_VALUE, (int) view.getMaximumSpan(View.X_AXIS));\n        assertEquals(getSum(Y_AXIS), (int) view.getMaximumSpan(Y_AXIS));\n    }\n", "refactored_code": "    private static final int X_AXIS = View.X_AXIS;\n    }\n\n    public void testGetMaximumSpan() {\n        assertEquals(Integer.MAX_VALUE, (int) view.getMaximumSpan(X_AXIS));\n        assertEquals(getSum(Y_AXIS), (int) view.getMaximumSpan(Y_AXIS));\n    }\n"}
{"magic_number_smell": "\n    private final int height = 100;\n\n    private final Rectangle shape = new Rectangle(40, height);\n\n    @Override\n    protected void setUp() throws Exception {", "refactored_code": "    private final int width = 40;\n\n    private final int height = 100;\n\n    private final Rectangle shape = new Rectangle(width, height);\n\n    @Override\n    protected void setUp() throws Exception {"}
{"magic_number_smell": "        assertEquals(HTML.Tag.P.toString(), block.getName());\n\n        factory = new InlineViewFactory();\n        view = new BlockViewImpl(block, View.Y_AXIS);\n        attrs = view.getAttributes();\n        doc.getStyleSheet().getStyleSheets()[0].addRule(\"p { margin-top: 15pt }\");\n    }", "refactored_code": "    private static final int Y_AXIS = View.Y_AXIS;\n        assertEquals(HTML.Tag.P.toString(), block.getName());\n\n        factory = new InlineViewFactory();\n        view = new BlockViewImpl(block, Y_AXIS);\n        attrs = view.getAttributes();\n        doc.getStyleSheet().getStyleSheets()[0].addRule(\"p { margin-top: 15pt }\");\n    }"}
{"magic_number_smell": "        Dimension size = textComponent.getPreferredSize();\n\n\n        size.width = (sizeWasSet ? 100 : 20) * charWidth;\n        if (isHarmony()) {\n            assertEquals(size, textComponent.getPreferredSize());\n            assertEquals(size, textComponent.getMaximumSize());", "refactored_code": "    private static final int DEFAULT_TEXTFIELD_SIZE = 20;\n        Dimension size = textComponent.getPreferredSize();\n\n\n        size.width = (sizeWasSet ? 100 : DEFAULT_TEXTFIELD_SIZE) * charWidth;\n        if (isHarmony()) {\n            assertEquals(size, textComponent.getPreferredSize());\n            assertEquals(size, textComponent.getMaximumSize());"}
{"magic_number_smell": "\n        //ROWS, COLUMNS\n        createFormViewWithParent(\"textarea\");\n            assertEquals(20, textArea.getColumns());\n\n       if (isHarmony()) {\n            assertEquals(DEFAULT_ROWS_COUNT, textArea.getRows());", "refactored_code": "    private static final int DEFAULT_COLS_COUNT = 20;\n\n        //ROWS, COLUMNS\n        createFormViewWithParent(\"textarea\");\n            assertEquals(DEFAULT_COLS_COUNT, textArea.getColumns());\n\n       if (isHarmony()) {\n            assertEquals(DEFAULT_ROWS_COUNT, textArea.getRows());"}
{"magic_number_smell": "//        assertNotNull(view.getImage());\n//\n//        // These assertions should pass but they don't\n//        assertEquals(16,\n//                     (int)view.getPreferredSpan(View.X_AXIS));\n//        assertEquals(16,\n//                     (int)view.getPreferredSpan(View.Y_AXIS));", "refactored_code": "    private static final int    IMAGE_SIZE  = 16;\n//        assertNotNull(view.getImage());\n//\n//        // These assertions should pass but they don't\n//        assertEquals(IMAGE_SIZE,\n//                     (int)view.getPreferredSpan(View.X_AXIS));\n//        assertEquals(IMAGE_SIZE,\n//                     (int)view.getPreferredSpan(View.Y_AXIS));"}
{"magic_number_smell": "\n        public float getSpan(GlyphView v, int startOffset, int endOffset,\n                             TabExpander tabExpander, float x) {\n            return 7 * (endOffset - startOffset);\n        }\n\n        public int getBoundedPosition(GlyphView v, int startOffset,", "refactored_code": "        public static final int CHAR_WIDTH = 7;\n\n        public float getSpan(GlyphView v, int startOffset, int endOffset,\n                             TabExpander tabExpander, float x) {\n            return CHAR_WIDTH * (endOffset - startOffset);\n        }\n\n        public int getBoundedPosition(GlyphView v, int startOffset,"}
{"magic_number_smell": "    }\n\n    public void testGetRuleTagElement_NoContext() {\n        Element em = doc.getCharacterElement(20);\n        assertNotNull(em.getAttributes().getAttribute(Tag.EM));\n\n        rule = ss.getRule(Tag.EM, em);", "refactored_code": "    private static final int P_EM_START_OFFSET = 20;\n    }\n\n    public void testGetRuleTagElement_NoContext() {\n        Element em = doc.getCharacterElement(P_EM_START_OFFSET);\n        assertNotNull(em.getAttributes().getAttribute(Tag.EM));\n\n        rule = ss.getRule(Tag.EM, em);"}
{"magic_number_smell": "\n    private void checkDefaultElements(final DTD dtd) {\n        Vector elements = dtd.elements;\n        assertEquals(14, dtd.elements.size());\n        for (int i = 0; i < 14 - 1; i++) {\n            Utils.checkDTDDefaultElement(((Element)elements.get(i)),\n                                         ((String)elementNames.get(i)),", "refactored_code": "    private static final int DEFAULT_SIZE = 14;\n\n    private void checkDefaultElements(final DTD dtd) {\n        Vector elements = dtd.elements;\n        assertEquals(DEFAULT_SIZE, dtd.elements.size());\n        for (int i = 0; i < DEFAULT_SIZE - 1; i++) {\n            Utils.checkDTDDefaultElement(((Element)elements.get(i)),\n                                         ((String)elementNames.get(i)),"}
{"magic_number_smell": "    // Regression for HARMONY-2603\n    public void testGetPresentationName03() {\n        ce.addEdit(new TestUndoableEdit() {\n            private static final long 1L = 1L;\n\n            @Override\n            public String getPresentationName() {", "refactored_code": "        private static final long serialVersionUID = 1L;\n    // Regression for HARMONY-2603\n    public void testGetPresentationName03() {\n        ce.addEdit(new TestUndoableEdit() {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            public String getPresentationName() {"}
{"magic_number_smell": "        assertEquals(40, um.indexOfNextAdd);\n        um = new UndoManager();\n        UndoableEdit ed = new AbstractUndoableEdit() {\n            private static final long 1L = 1L;\n\n            @Override\n            public boolean canUndo() {", "refactored_code": "            private static final long serialVersionUID = 1L;\n        assertEquals(40, um.indexOfNextAdd);\n        um = new UndoManager();\n        UndoableEdit ed = new AbstractUndoableEdit() {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            public boolean canUndo() {"}
{"magic_number_smell": "     */\n    private final static int convertDirectionConstant(int javaConst) {\n        switch (javaConst) {\n        case -2 : return com.ibm.icu.text.Bidi.-2;\n        case DIRECTION_DEFAULT_RIGHT_TO_LEFT : return com.ibm.icu.text.Bidi.DIRECTION_DEFAULT_RIGHT_TO_LEFT;\n        case DIRECTION_LEFT_TO_RIGHT         : return com.ibm.icu.text.Bidi.DIRECTION_LEFT_TO_RIGHT;\n        case DIRECTION_RIGHT_TO_LEFT         : return com.ibm.icu.text.Bidi.DIRECTION_RIGHT_TO_LEFT;", "refactored_code": "    public static final int DIRECTION_DEFAULT_LEFT_TO_RIGHT = -2;\n     */\n    private final static int convertDirectionConstant(int javaConst) {\n        switch (javaConst) {\n        case DIRECTION_DEFAULT_LEFT_TO_RIGHT : return com.ibm.icu.text.Bidi.DIRECTION_DEFAULT_LEFT_TO_RIGHT;\n        case DIRECTION_DEFAULT_RIGHT_TO_LEFT : return com.ibm.icu.text.Bidi.DIRECTION_DEFAULT_RIGHT_TO_LEFT;\n        case DIRECTION_LEFT_TO_RIGHT         : return com.ibm.icu.text.Bidi.DIRECTION_LEFT_TO_RIGHT;\n        case DIRECTION_RIGHT_TO_LEFT         : return com.ibm.icu.text.Bidi.DIRECTION_RIGHT_TO_LEFT;"}
{"magic_number_smell": "\n    /**\n     * Returns the position of last boundary preceding the given offset, and\n     * sets the current position to the returned value, or {@code -1} if the\n     * given offset specifies the starting position.\n     *\n     * @param offset", "refactored_code": "    public static final int DONE = -1;\n\n    /**\n     * Returns the position of last boundary preceding the given offset, and\n     * sets the current position to the returned value, or {@code DONE} if the\n     * given offset specifies the starting position.\n     *\n     * @param offset"}
{"magic_number_smell": "    /**\n     * Obtains the next collation element in the source string.\n     * \n     * @return the next collation element or {@code -1} if the end\n     *         of the iteration has been reached.\n     */\n    public int next() {", "refactored_code": "    public static final int NULLORDER = -1;\n    /**\n     * Obtains the next collation element in the source string.\n     * \n     * @return the next collation element or {@code NULLORDER} if the end\n     *         of the iteration has been reached.\n     */\n    public int next() {"}
{"magic_number_smell": "    /**\n     * Returns the decomposition rule for this collator.\n     * \n     * @return the decomposition rule, either {@code 0} or\n     *         {@code CANONICAL_DECOMPOSITION}. {@code FULL_DECOMPOSITION} is\n     *         not supported.\n     */", "refactored_code": "    public static final int NO_DECOMPOSITION = 0;\n    /**\n     * Returns the decomposition rule for this collator.\n     * \n     * @return the decomposition rule, either {@code NO_DECOMPOSITION} or\n     *         {@code CANONICAL_DECOMPOSITION}. {@code FULL_DECOMPOSITION} is\n     *         not supported.\n     */"}
{"magic_number_smell": "     */\n    public static class Field extends Format.Field {\n\n        private static final long 7218322306649953788L = 7441350119349544720L;\n\n        private static Hashtable<Integer, Field> table = new Hashtable<Integer, Field>();\n", "refactored_code": "    private static final long serialVersionUID = 7218322306649953788L;\n     */\n    public static class Field extends Format.Field {\n\n        private static final long serialVersionUID = 7441350119349544720L;\n\n        private static Hashtable<Integer, Field> table = new Hashtable<Integer, Field>();\n"}
{"magic_number_smell": "     */\n    public static class Field extends AttributedCharacterIterator.Attribute {\n\n        private static final long -299282585814624189L = 276966692217360283L;\n\n        /**\n         * Constructs a new instance of {@code Field} with the given field name.", "refactored_code": "    private static final long serialVersionUID = -299282585814624189L;\n     */\n    public static class Field extends AttributedCharacterIterator.Attribute {\n\n        private static final long serialVersionUID = 276966692217360283L;\n\n        /**\n         * Constructs a new instance of {@code Field} with the given field name."}
{"magic_number_smell": "     */\n    public static class Field extends Format.Field {\n\n        private static final long 6479157306784022952L = 7899943957617360810L;\n\n        /**\n         * This constant stands for the message argument.", "refactored_code": "    private static final long serialVersionUID = 6479157306784022952L;\n     */\n    public static class Field extends Format.Field {\n\n        private static final long serialVersionUID = 7899943957617360810L;\n\n        /**\n         * This constant stands for the message argument."}
{"magic_number_smell": "     */\n    public static class Field extends Format.Field {\n\n        private static final long -2308460125733713944L = 7494728892700160890L;\n\n        /**\n         * This constant stands for the number sign.", "refactored_code": "    private static final long serialVersionUID = -2308460125733713944L;\n     */\n    public static class Field extends Format.Field {\n\n        private static final long serialVersionUID = 7494728892700160890L;\n\n        /**\n         * This constant stands for the number sign."}
{"magic_number_smell": "     * as specified by TLS specification.\n     */\n    protected static final int MAX_COMPRESSED_DATA_LENGTH\n                                    = 16384 + 1024;\n    /**\n     * Maximum length of allowed ciphered data fragment\n     * as specified by TLS specification.", "refactored_code": "    protected static final int MAX_DATA_LENGTH = 16384; // 2^14\n     * as specified by TLS specification.\n     */\n    protected static final int MAX_COMPRESSED_DATA_LENGTH\n                                    = MAX_DATA_LENGTH + 1024;\n    /**\n     * Maximum length of allowed ciphered data fragment\n     * as specified by TLS specification."}
{"magic_number_smell": "\n\t\t\t\t\tsynchronized (lock) {\n\t\t\t\t\t\tserversocket.setPort(port);\n\t\t\t\t\t\tserversocket.setTimeout(10000);\n\t\t\t\t\t\tserversocket.open();\n\t\t\t\t\t\tlock.notifyAll();\n\t\t\t\t\t}", "refactored_code": "\tprivate static final int timeout = 10000;\n\n\t\t\t\t\tsynchronized (lock) {\n\t\t\t\t\t\tserversocket.setPort(port);\n\t\t\t\t\t\tserversocket.setTimeout(timeout);\n\t\t\t\t\t\tserversocket.open();\n\t\t\t\t\t\tlock.notifyAll();\n\t\t\t\t\t}"}
{"magic_number_smell": "    private final int 10000 = 10000;\n\n    public void test() {\n        int arr[] = new int[10000];\n        int j=1;\n        try {\n            for(int k=2; k<10000; k=1+k+k*j) {", "refactored_code": "    private final int limit = 10000;\n    private final int limit = 10000;\n\n    public void test() {\n        int arr[] = new int[limit];\n        int j=1;\n        try {\n            for(int k=2; k<limit; k=1+k+k*j) {"}
{"magic_number_smell": "    private final int 1000 = 1000;\n\n    public void test() {\n        int arr[] = new int[1000];\n        try {\n            for(int k=1; k<1000; ) {\n                System.out.println(\"k=\" + k + \": arr[\" + (k-1) + \"] will be called\");", "refactored_code": "    private final int limit = 1000;\n    private final int limit = 1000;\n\n    public void test() {\n        int arr[] = new int[limit];\n        try {\n            for(int k=1; k<limit; ) {\n                System.out.println(\"k=\" + k + \": arr[\" + (k-1) + \"] will be called\");"}
{"magic_number_smell": "                continue;\n            }\n            String className = entryName.substring(0, entryName.length()\n                    - CLASS_SUFFIX.length()).replace('/', '.');\n\n            Loader loader = new Loader();\n            Throwable result = loader.verifyClass(className);", "refactored_code": "    private static final int CLASS_SUFFIX_LENGTH = CLASS_SUFFIX.length();\n                continue;\n            }\n            String className = entryName.substring(0, entryName.length()\n                    - CLASS_SUFFIX_LENGTH).replace('/', '.');\n\n            Loader loader = new Loader();\n            Throwable result = loader.verifyClass(className);"}
{"magic_number_smell": "    public static final Address staticField = Address.fromLong(getAddress());\n\n    public static final long -1 = -1;\n    public static final Address staticField2 = Address.fromLong(-1);\n \n    public static void test1() {\n        boolean result = check(staticField.toLong());", "refactored_code": "    public static final long staticVal = -1;\n    public static final Address staticField = Address.fromLong(getAddress());\n\n    public static final long staticVal = -1;\n    public static final Address staticField2 = Address.fromLong(staticVal);\n \n    public static void test1() {\n        boolean result = check(staticField.toLong());"}
{"magic_number_smell": "\n        Address TLS_BASE = VMHelper.getTlsBaseAddress();\n\n        Address allocator_addr = TLS_BASE.plus(TLSGCOffset());\n        Address allocator = allocator_addr.loadAddress();\n        Address free_addr = allocator.plus(TLA_FREE_OFFSET);\n        Address free = free_addr.loadAddress();", "refactored_code": "    public static final int TLS_GC_OFFSET = TLSGCOffset();\n\n        Address TLS_BASE = VMHelper.getTlsBaseAddress();\n\n        Address allocator_addr = TLS_BASE.plus(TLS_GC_OFFSET);\n        Address allocator = allocator_addr.loadAddress();\n        Address free_addr = allocator.plus(TLA_FREE_OFFSET);\n        Address free = free_addr.loadAddress();"}
{"magic_number_smell": "     */\n    static class Mc009\\u0576\\u06C0\\u06F1 extends Throwable \n            implements java.io.Serializable, Cloneable {\n        private static final long 0L = 0L;\n    };\n\n/* + */    @igt(author=\"*****\") public <UuUuU extends Throwable, TM1, TM2 extends Thread &java.io.Serializable &Cloneable> void foo1For_5(UuUuU a1) throws UuUuU, java.io.IOException {}", "refactored_code": "        private static final long serialVersionUID = 0L;\n     */\n    static class Mc009\\u0576\\u06C0\\u06F1 extends Throwable \n            implements java.io.Serializable, Cloneable {\n        private static final long serialVersionUID = 0L;\n    };\n\n/* + */    @igt(author=\"*****\") public <UuUuU extends Throwable, TM1, TM2 extends Thread &java.io.Serializable &Cloneable> void foo1For_5(UuUuU a1) throws UuUuU, java.io.IOException {}"}
{"magic_number_smell": "        private static final long 0L = 0L;\n    };\n    static class Mc209 extends Throwable implements java.io.Serializable, Cloneable {\n        private static final long 0L = 0L;\n    };\n    public <UuUuU extends Throwable, TM1, TM2 extends Thread &java.io.Serializable &Cloneable> void foo1For_5(UuUuU a1) throws UuUuU, java.io.IOException {}\n    public void test_5() {", "refactored_code": "        private static final long serialVersionUID = 0L;\n        private static final long serialVersionUID = 0L;\n    };\n    static class Mc209 extends Throwable implements java.io.Serializable, Cloneable {\n        private static final long serialVersionUID = 0L;\n    };\n    public <UuUuU extends Throwable, TM1, TM2 extends Thread &java.io.Serializable &Cloneable> void foo1For_5(UuUuU a1) throws UuUuU, java.io.IOException {}\n    public void test_5() {"}
{"magic_number_smell": "     * use \"$\" symbol in identifiers for generalized method\n     */\n    static class $Mc3$09 extends Throwable implements java.io.Serializable, Cloneable {\n        private static final long 0L = 0L;\n    };\n    public <U$uUuU_ extends Throwable, TM1, TM2 extends Thread &java.io.Serializable &Cloneable> void foo1For_5(U$uUuU_ a1) throws U$uUuU_, java.io.IOException {}\n    public void test_5() {", "refactored_code": "        private static final long serialVersionUID = 0L;\n     * use \"$\" symbol in identifiers for generalized method\n     */\n    static class $Mc3$09 extends Throwable implements java.io.Serializable, Cloneable {\n        private static final long serialVersionUID = 0L;\n    };\n    public <U$uUuU_ extends Throwable, TM1, TM2 extends Thread &java.io.Serializable &Cloneable> void foo1For_5(U$uUuU_ a1) throws U$uUuU_, java.io.IOException {}\n    public void test_5() {"}
{"magic_number_smell": "                          public static enum ME001_01_4 {G_A_T, P_T, V_T, W_T;\n                              public static enum ME001_01_5 {G_A_T, P_T, V_T, W_T;\n                                  private final int 0 = 0;\n                                  public int 0() { \n                                      return 0; \n                                  }\n                                  public static Class pop() {", "refactored_code": "                                  private final int value = 0;\n                          public static enum ME001_01_4 {G_A_T, P_T, V_T, W_T;\n                              public static enum ME001_01_5 {G_A_T, P_T, V_T, W_T;\n                                  private final int value = 0;\n                                  public int value() { \n                                      return value; \n                                  }\n                                  public static Class pop() {"}
{"magic_number_smell": "        } catch (InterruptedException e) {\n            fail(INTERRUPTED_MESSAGE);\n        }\n        for (waitTime = 3000; t1.isAlive() && t2.isAlive() && !(expired = doSleep(10));) {\n        }\n        if (expired) {\n            fail(\"thread have not finished for \" + 3000 + \" ms\");", "refactored_code": "    private static final long waitDuration = 3000;\n        } catch (InterruptedException e) {\n            fail(INTERRUPTED_MESSAGE);\n        }\n        for (waitTime = waitDuration; t1.isAlive() && t2.isAlive() && !(expired = doSleep(10));) {\n        }\n        if (expired) {\n            fail(\"thread have not finished for \" + waitDuration + \" ms\");"}
{"magic_number_smell": "        Square s = new Square(25);\n        Thread t = new Thread(s);\n        t.start();\n        waitTime = 60000;\n        while (s.squaredNumber == 0 && !(expired = doSleep(10))) {\n        }\n        assertEquals(\"incorrect thread name\", 0, t.getName().indexOf(\"Thread-\"));", "refactored_code": "    private static final long waitDuration = 60000;\n        Square s = new Square(25);\n        Thread t = new Thread(s);\n        t.start();\n        waitTime = waitDuration;\n        while (s.squaredNumber == 0 && !(expired = doSleep(10))) {\n        }\n        assertEquals(\"incorrect thread name\", 0, t.getName().indexOf(\"Thread-\"));"}
{"magic_number_smell": "     * Regression test for HARMONY-4927\n     */    \n    public void testAccessFinalInstance() throws Throwable {\n        Field fi = this.getClass().getField(\"10\");\n        final Object oldVal = fi.get(this);\n        final Object newVal = new Integer(2134523);\n        ", "refactored_code": "    public final int INSTANCE_I = 10;\n     * Regression test for HARMONY-4927\n     */    \n    public void testAccessFinalInstance() throws Throwable {\n        Field fi = this.getClass().getField(\"INSTANCE_I\");\n        final Object oldVal = fi.get(this);\n        final Object newVal = new Integer(2134523);\n        "}
{"magic_number_smell": "    public TemplateSet<? super Class>.Mc002<TemplateSet>.Mc004<TemplateSet> f0;\n    public X f111;\n    public TemplateSet f112;\n    static class Mc009\\u0576\\u06C0\\u06F1 extends Throwable implements java.io.Serializable, Cloneable {private static final long 0L = 0L;};\n    @igt(author=\"*****\") public <UuUuU extends Throwable, TM1, TM2 extends Thread &java.io.Serializable &Cloneable> void foo1For_5(UuUuU a1) throws UuUuU, java.io.IOException {}\n    public <\\u0391 extends Throwable, TM1, TM2, TM3, TM4, TM5, TM6, TM7> X foo2For_5()  throws \\u0391, java.io.IOException {X f = null; return f;}\n    public <\\u0576\\u06C0\\u06F1 extends Throwable, \\u0576\\u06C0\\u06F11 extends Throwable, \\u0576\\u06C0\\u06F12 extends Throwable, \\u0576\\u06C0\\u06F13 extends Throwable, TM1, TM2 extends Thread &java.io.Serializable &Cloneable> TM2 foo3For_5(\\u0576\\u06C0\\u06F1[] BAAB, TM1 a1, TM2 a2, TemplateSet<? super Class>.Mc002<TemplateSet>.Mc004<TemplateSet> a3) throws \\u0576\\u06C0\\u06F1, Throwable, \\u0576\\u06C0\\u06F13, \\u0576\\u06C0\\u06F12, \\u0576\\u06C0\\u06F11, TemplateSet.Mc009\\u0576\\u06C0\\u06F1 {TM2 f = null; return f;}", "refactored_code": "    class Mc005 extends Thread implements java.io.Serializable, Cloneable {private static final long serialVersionUID = 0L;};\n    public TemplateSet<? super Class>.Mc002<TemplateSet>.Mc004<TemplateSet> f0;\n    public X f111;\n    public TemplateSet f112;\n    static class Mc009\\u0576\\u06C0\\u06F1 extends Throwable implements java.io.Serializable, Cloneable {private static final long serialVersionUID = 0L;};\n    @igt(author=\"*****\") public <UuUuU extends Throwable, TM1, TM2 extends Thread &java.io.Serializable &Cloneable> void foo1For_5(UuUuU a1) throws UuUuU, java.io.IOException {}\n    public <\\u0391 extends Throwable, TM1, TM2, TM3, TM4, TM5, TM6, TM7> X foo2For_5()  throws \\u0391, java.io.IOException {X f = null; return f;}\n    public <\\u0576\\u06C0\\u06F1 extends Throwable, \\u0576\\u06C0\\u06F11 extends Throwable, \\u0576\\u06C0\\u06F12 extends Throwable, \\u0576\\u06C0\\u06F13 extends Throwable, TM1, TM2 extends Thread &java.io.Serializable &Cloneable> TM2 foo3For_5(\\u0576\\u06C0\\u06F1[] BAAB, TM1 a1, TM2 a2, TemplateSet<? super Class>.Mc002<TemplateSet>.Mc004<TemplateSet> a3) throws \\u0576\\u06C0\\u06F1, Throwable, \\u0576\\u06C0\\u06F13, \\u0576\\u06C0\\u06F12, \\u0576\\u06C0\\u06F11, TemplateSet.Mc009\\u0576\\u06C0\\u06F1 {TM2 f = null; return f;}"}
{"magic_number_smell": "    // run test and check that it throws exception with right stack depth\n    public static void main(String[] args) {\n        try {\n            new ExceptionStackTest(100);\n            System.out.println(\"FAIL\");\n        } catch (RuntimeException rte) {\n            StackTraceElement[] stack = rte.getStackTrace();", "refactored_code": "    private static final int MAX_DEPTH = 100;\n    // run test and check that it throws exception with right stack depth\n    public static void main(String[] args) {\n        try {\n            new ExceptionStackTest(MAX_DEPTH);\n            System.out.println(\"FAIL\");\n        } catch (RuntimeException rte) {\n            StackTraceElement[] stack = rte.getStackTrace();"}
{"magic_number_smell": "\n    public static void main(String[] args) {\n        try {\n            new FinalizeStackTest(1000000);\n        } catch (StackOverflowError soe) {\n            System.out.println(\"PASS : \" + soe);\n        } catch (Throwable th) {", "refactored_code": "    private static final int MAX_DEPTH = 1000000;\n\n    public static void main(String[] args) {\n        try {\n            new FinalizeStackTest(MAX_DEPTH);\n        } catch (StackOverflowError soe) {\n            System.out.println(\"PASS : \" + soe);\n        } catch (Throwable th) {"}
{"magic_number_smell": "    updateInfo();\n        System.runFinalizersOnExit(true);   \n\n        aliveArray = new AliveFinalizer[128];\n        phantomArray = new PhantomFinalizer[PHANTOM_QUANTITY];\n\n        for (int i=0; i<DIED_QUANTITY; i++) {", "refactored_code": "    private static final int ALIVE_QUANTITY = 128;\n    updateInfo();\n        System.runFinalizersOnExit(true);   \n\n        aliveArray = new AliveFinalizer[ALIVE_QUANTITY];\n        phantomArray = new PhantomFinalizer[PHANTOM_QUANTITY];\n\n        for (int i=0; i<DIED_QUANTITY; i++) {"}
{"magic_number_smell": "\n    public static void main(String args[]) throws Exception {\n        \n        for (int i = 0; i < 100000;) {\n            ////System.out.println(\"Iteration = \" + i);\n\n            for (int l = i + PRINT_ITERATION_NUMBER; i < l; ++i) {", "refactored_code": "    private static final int MAX_ITERATION_NUMBER = 100000;\n\n    public static void main(String args[]) throws Exception {\n        \n        for (int i = 0; i < MAX_ITERATION_NUMBER;) {\n            ////System.out.println(\"Iteration = \" + i);\n\n            for (int l = i + PRINT_ITERATION_NUMBER; i < l; ++i) {"}
{"magic_number_smell": "    private static boolean awaked = false;\n\n    public static void main(String [] args) {\n        Thread[] threads = new Thread[4 * 1024];\n        for (int i = 0; i < 4 * 1024; i++) {\n            threads[i] = new Thread( null,\n                                 new SmallStackThreadTest(),", "refactored_code": "    private static final int MAX_THREADS = 4 * 1024;\n    private static boolean awaked = false;\n\n    public static void main(String [] args) {\n        Thread[] threads = new Thread[MAX_THREADS];\n        for (int i = 0; i < MAX_THREADS; i++) {\n            threads[i] = new Thread( null,\n                                 new SmallStackThreadTest(),"}
{"magic_number_smell": "        }\n\n        FinalizerThread newThread = null;\n        if (waitFinishCounter >= 256) {\n\t\t\tThread.yield();\n        } else {\n            try {", "refactored_code": "    private static final int MAX_THREADS = 256;\n        }\n\n        FinalizerThread newThread = null;\n        if (waitFinishCounter >= MAX_THREADS) {\n\t\t\tThread.yield();\n        } else {\n            try {"}
{"magic_number_smell": "     */\n    public final void setPriority(int priority) {\n        checkAccess();\n        if (priority > 10 || priority < MIN_PRIORITY) {\n            throw new IllegalArgumentException(\"Wrong Thread priority value\");\n        }\n        ThreadGroup threadGroup = group;", "refactored_code": "    public static final int MAX_PRIORITY = 10;\n     */\n    public final void setPriority(int priority) {\n        checkAccess();\n        if (priority > MAX_PRIORITY || priority < MIN_PRIORITY) {\n            throw new IllegalArgumentException(\"Wrong Thread priority value\");\n        }\n        ThreadGroup threadGroup = group;"}
{"magic_number_smell": "         * tombstones, etc.\n         */\n        void add(ThreadLocal<?> key, Object value) {\n            for (int index = key.hashCounter.getAndAdd(0x61c88647 << 1) & mask;; index = next(index)) {\n                Object k = table[index];\n                if (k == null) {\n                    table[index] = key.reference;", "refactored_code": "    private final int hash = hashCounter.getAndAdd(0x61c88647 << 1);\n         * tombstones, etc.\n         */\n        void add(ThreadLocal<?> key, Object value) {\n            for (int index = key.hash & mask;; index = next(index)) {\n                Object k = table[index];\n                if (k == null) {\n                    table[index] = key.reference;"}
{"magic_number_smell": "            return false;\n        }\n       \n        int subTypeOffset = getVtableSuperclassesOffset() + VMHelper.POINTER_TYPE_SIZE*(fastCheckDepth-1);\n        Address depthSubType = objVtableAddr.loadAddress(Offset.fromIntZeroExtend(subTypeOffset));\n        return depthSubType.EQ(castType);\n    }", "refactored_code": "    private static final int VTABLE_SUPERCLASSES_OFFSET = getVtableSuperclassesOffset();\n            return false;\n        }\n       \n        int subTypeOffset = VTABLE_SUPERCLASSES_OFFSET + VMHelper.POINTER_TYPE_SIZE*(fastCheckDepth-1);\n        Address depthSubType = objVtableAddr.loadAddress(Offset.fromIntZeroExtend(subTypeOffset));\n        return depthSubType.EQ(castType);\n    }"}
{"magic_number_smell": "        Address lockWordPtr = ObjectReference.fromObject(obj).toAddress().plus(LOCK_WORD_OFFSET);\n        int threadId = getThreadId();\n        int lockword = lockWordPtr.loadInt();\n        int new_lockword = (threadId<<16) ^ lockword; \n                                           \n        if ((new_lockword & HI_BITS) == 0){\n           // comparison above is some kind of tricky, two things are checked at once; ", "refactored_code": "    public static final int THREAD_SHIFT = 16;\n        Address lockWordPtr = ObjectReference.fromObject(obj).toAddress().plus(LOCK_WORD_OFFSET);\n        int threadId = getThreadId();\n        int lockword = lockWordPtr.loadInt();\n        int new_lockword = (threadId<<THREAD_SHIFT) ^ lockword; \n                                           \n        if ((new_lockword & HI_BITS) == 0){\n           // comparison above is some kind of tricky, two things are checked at once; "}
{"magic_number_smell": "    \n    switch (kind)\n    {\n    case 1:\n        res = (InterimGenericDeclaration)parser.classDecl;  \n        break;\n    case FIELDoDECL:", "refactored_code": "private static final int CLASSoDECL = 1; //Parser.SignatureKind.CLASS_SIGNATURE.value();\n    \n    switch (kind)\n    {\n    case CLASSoDECL:\n        res = (InterimGenericDeclaration)parser.classDecl;  \n        break;\n    case FIELDoDECL:"}
{"magic_number_smell": "\n    /**\n     * getOS method returns on of the operating system codes:\n     * 1, OS_LINUX, OS_FREEBSD or OS_UNKNOWN\n     * @return Operating system code\n     */\n    public static int getOS() {", "refactored_code": "    public static final int OS_WINDOWS = 1;\n\n    /**\n     * getOS method returns on of the operating system codes:\n     * OS_WINDOWS, OS_LINUX, OS_FREEBSD or OS_UNKNOWN\n     * @return Operating system code\n     */\n    public static int getOS() {"}
{"magic_number_smell": "    }\n\n    public void setWidth(String widthStr) {     \n        this.width = (widthStr == null)?300:Integer.parseInt(widthStr);\n    }\n\n    public int getHeight() {", "refactored_code": "    private static final int DEFAULT_WIDTH=300;\n    }\n\n    public void setWidth(String widthStr) {     \n        this.width = (widthStr == null)?DEFAULT_WIDTH:Integer.parseInt(widthStr);\n    }\n\n    public int getHeight() {"}
{"magic_number_smell": "            throw new NullPointerException(\"Alias is null.\");\n        }\n        int length = alias.length();\n        if (length > 8){\n            alias = alias.substring(0, 8);\n            length = 8;\n        } ", "refactored_code": "    private static final int fileNameLength = 8;\n            throw new NullPointerException(\"Alias is null.\");\n        }\n        int length = alias.length();\n        if (length > fileNameLength){\n            alias = alias.substring(0, fileNameLength);\n            length = fileNameLength;\n        } "}
{"magic_number_smell": "\n        /* Invoke the compiler */\n        boolean success = BatchCompiler.compile(newArgs, out, err, null);\n        return success ? 0 : RC_COMPILE_ERROR;\n    }\n\n    /*", "refactored_code": "    public static final int RC_SUCCESS = 0;\n\n        /* Invoke the compiler */\n        boolean success = BatchCompiler.compile(newArgs, out, err, null);\n        return success ? RC_SUCCESS : RC_COMPILE_ERROR;\n    }\n\n    /*"}
{"magic_number_smell": "            } else {\n                // Calculating suid with static class from the tool\n                long hash = Main.calculeSUID(clazz);\n                serialVersionField.setText(\"    static final long 679244276103498687L = \"\n                                           + hash + \"L;\");\n                statusBarLabel.setText(\"\");\n            }", "refactored_code": "    private static final long serialVersionUID = 679244276103498687L;\n            } else {\n                // Calculating suid with static class from the tool\n                long hash = Main.calculeSUID(clazz);\n                serialVersionField.setText(\"    static final long serialVersionUID = \"\n                                           + hash + \"L;\");\n                statusBarLabel.setText(\"\");\n            }"}
{"magic_number_smell": "    public static final int 1 * 60 * 1000 = 1 * 60 * 1000; // 1 minute\n\n    /** Default time interval for waiting for various events. */\n    public static final int DEFAULT_WAITING_TIME = 1 * 60 * 1000;\n    \n    /** Default static address for transport connection. */\n    public static final String DEFAULT_ATTACHING_ADDRESS = \"127.0.0.1:9898\";", "refactored_code": "    public static final int DEFAULT_TIMEOUT = 1 * 60 * 1000; // 1 minute\n    public static final int DEFAULT_TIMEOUT = 1 * 60 * 1000; // 1 minute\n\n    /** Default time interval for waiting for various events. */\n    public static final int DEFAULT_WAITING_TIME = DEFAULT_TIMEOUT;\n    \n    /** Default static address for transport connection. */\n    public static final String DEFAULT_ATTACHING_ADDRESS = \"127.0.0.1:9898\";"}
{"magic_number_smell": "     */\n    public CommandPacket(byte bytes_array[]) {\n        super(bytes_array);\n        command_set = bytes_array[9];\n        command = bytes_array[COMMAND_INDEX];\n    }\n", "refactored_code": "    private final int COMMAND_SET_INDEX = 9;\n     */\n    public CommandPacket(byte bytes_array[]) {\n        super(bytes_array);\n        command_set = bytes_array[COMMAND_SET_INDEX];\n        command = bytes_array[COMMAND_INDEX];\n    }\n"}
{"magic_number_smell": "     */\n    public class ReferenceTypeCommandSet {\n\n        public static final byte 1 = 2;\n\n        public static final byte SignatureCommand = 1;\n", "refactored_code": "        public static final byte CommandSetID = 1;\n     */\n    public class ReferenceTypeCommandSet {\n\n        public static final byte CommandSetID = 2;\n\n        public static final byte SignatureCommand = 1;\n"}
{"magic_number_smell": "         */\n        public static String getName(int status) {\n            switch (status) {\n            case 0:\n                return \"0\";\n            case RUNNING:\n                return \"RUNNING\";", "refactored_code": "        public static final byte ZOMBIE = 0;\n         */\n        public static String getName(int status) {\n            switch (status) {\n            case ZOMBIE:\n                return \"ZOMBIE\";\n            case RUNNING:\n                return \"RUNNING\";"}
{"magic_number_smell": "     * @return true if this packet is reply, false if it is command\n     */\n    public boolean isReply() {\n        return (flags & 0x80) != 0;\n    }\n\n    /**", "refactored_code": "    public static final int REPLY_PACKET_FLAG = 0x80;\n     * @return true if this packet is reply, false if it is command\n     */\n    public boolean isReply() {\n        return (flags & REPLY_PACKET_FLAG) != 0;\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    public ReplyPacket(byte p[]) {\n        super(p);\n        error_code = (short) super.readFromByteArray(p, 9,\n                Packet.SHORT_SIZE);\n    }\n", "refactored_code": "    private final int ERROR_CODE_INDEX = 9;\n     */\n    public ReplyPacket(byte p[]) {\n        super(p);\n        error_code = (short) super.readFromByteArray(p, ERROR_CODE_INDEX,\n                Packet.SHORT_SIZE);\n    }\n"}
{"magic_number_smell": "     */\n    public static int getTypeLength(byte typeID) throws TestErrorException {\n        switch (typeID) {\n        case 1: {\n            return byteLength;\n        }\n        case BOOLEAN_ID: {", "refactored_code": "    public static final byte BYTE_ID = 1;\n     */\n    public static int getTypeLength(byte typeID) throws TestErrorException {\n        switch (typeID) {\n        case BYTE_ID: {\n            return byteLength;\n        }\n        case BOOLEAN_ID: {"}
{"magic_number_smell": "        loader = null;\n        \n        logWriter.println(\"--> Create memory stress and start gc\");\n        createMemoryStress(1000000, 1000000);\n//        createMemoryStress(100000000, 1024);\n        System.gc();\n        ", "refactored_code": "\tpublic static final int ARRAY_SIZE_FOR_MEMORY_STRESS = 1000000;\n        loader = null;\n        \n        logWriter.println(\"--> Create memory stress and start gc\");\n        createMemoryStress(1000000, ARRAY_SIZE_FOR_MEMORY_STRESS);\n//        createMemoryStress(100000000, 1024);\n        System.gc();\n        "}
{"magic_number_smell": "        logWriter.println(\"=> frameID for PopFrames command = \" + frameID);\n        \n        // pop stack frames\n        logWriter.println(\"=> Pop \" + 3 + \" frames at once\");\n\n        logWriter.println(\"\");\n        logWriter.println(\"=> Perform PopFrames command for method = \" + methodToPop + \" with frameID = \" + frameID);", "refactored_code": "    private static final byte NUMBER_OF_FRAMES_TO_POP = 3;\n        logWriter.println(\"=> frameID for PopFrames command = \" + frameID);\n        \n        // pop stack frames\n        logWriter.println(\"=> Pop \" + NUMBER_OF_FRAMES_TO_POP + \" frames at once\");\n\n        logWriter.println(\"\");\n        logWriter.println(\"=> Perform PopFrames command for method = \" + methodToPop + \" with frameID = \" + frameID);"}
{"magic_number_smell": "\n        logWriter.println(\"--> ResumeDebuggee: Create and start tested threads...\");\n        try {\n            resumeDebuggeeThreads = new ResumeDebuggee_Thread[6]; \n            for (int i=0; i < 6; i++) {\n                resumeDebuggeeThreads[i]= new ResumeDebuggee_Thread(i);\n                resumeDebuggeeThreads[i].start();", "refactored_code": "    public static final int THREAD_NUMBER_LIMIT = 6; \n\n        logWriter.println(\"--> ResumeDebuggee: Create and start tested threads...\");\n        try {\n            resumeDebuggeeThreads = new ResumeDebuggee_Thread[THREAD_NUMBER_LIMIT]; \n            for (int i=0; i < THREAD_NUMBER_LIMIT; i++) {\n                resumeDebuggeeThreads[i]= new ResumeDebuggee_Thread(i);\n                resumeDebuggeeThreads[i].start();"}
{"magic_number_smell": "\n        logWriter.println(\"--> SuspendCountDebuggee: Create and start tested threads...\");\n        try {\n            suspendCountDebuggeeThreads = new SuspendCountDebuggee_Thread[6]; \n            for (int i=0; i < 6; i++) {\n                suspendCountDebuggeeThreads[i]= new SuspendCountDebuggee_Thread(i);\n                suspendCountDebuggeeThreads[i].start();", "refactored_code": "    public static final int THREAD_NUMBER_LIMIT = 6; \n\n        logWriter.println(\"--> SuspendCountDebuggee: Create and start tested threads...\");\n        try {\n            suspendCountDebuggeeThreads = new SuspendCountDebuggee_Thread[THREAD_NUMBER_LIMIT]; \n            for (int i=0; i < THREAD_NUMBER_LIMIT; i++) {\n                suspendCountDebuggeeThreads[i]= new SuspendCountDebuggee_Thread(i);\n                suspendCountDebuggeeThreads[i].start();"}
{"magic_number_smell": "\n        logWriter.println(\"--> SuspendDebuggee: Create and start tested threads...\");\n        try {\n            suspendDebuggeeThreads = new SuspendDebuggee_Thread[9]; \n            for (int i=0; i < 9; i++) {\n                suspendDebuggeeThreads[i]= new SuspendDebuggee_Thread(i);\n                suspendDebuggeeThreads[i].start();", "refactored_code": "    public static final int THREAD_NUMBER_LIMIT = 9; \n\n        logWriter.println(\"--> SuspendDebuggee: Create and start tested threads...\");\n        try {\n            suspendDebuggeeThreads = new SuspendDebuggee_Thread[THREAD_NUMBER_LIMIT]; \n            for (int i=0; i < THREAD_NUMBER_LIMIT; i++) {\n                suspendDebuggeeThreads[i]= new SuspendDebuggee_Thread(i);\n                suspendDebuggeeThreads[i].start();"}
{"magic_number_smell": "\n        logWriter.println(\"--> ThreadGroup002Debuggee: Create and start tested threads...\");\n        try {\n            ThreadGroup002DebuggeeThreads = new ThreadGroup002Debuggee_Thread[6]; \n            for (int i=0; i < 6; i++) {\n                ThreadGroup002DebuggeeThreads[i] = \n                    new ThreadGroup002Debuggee_Thread(ThreadGroup002DebuggeeThreadGroups[i%2], i);", "refactored_code": "    public static final int THREAD_NUMBER_LIMIT = 6; \n\n        logWriter.println(\"--> ThreadGroup002Debuggee: Create and start tested threads...\");\n        try {\n            ThreadGroup002DebuggeeThreads = new ThreadGroup002Debuggee_Thread[THREAD_NUMBER_LIMIT]; \n            for (int i=0; i < THREAD_NUMBER_LIMIT; i++) {\n                ThreadGroup002DebuggeeThreads[i] = \n                    new ThreadGroup002Debuggee_Thread(ThreadGroup002DebuggeeThreadGroups[i%2], i);"}
{"magic_number_smell": "\n        logWriter.println(\"--> ResumeDebuggee: Create and start tested threads...\");\n        try {\n            ResumeDebuggeeThreads = new ResumeDebuggee_Thread[10]; \n            for (int i=0; i < 10; i++) {\n                ResumeDebuggeeThreads[i] = new ResumeDebuggee_Thread(i);\n                ResumeDebuggeeThreads[i].start();", "refactored_code": "    public static final int THREAD_NUMBER_LIMIT = 10; \n\n        logWriter.println(\"--> ResumeDebuggee: Create and start tested threads...\");\n        try {\n            ResumeDebuggeeThreads = new ResumeDebuggee_Thread[THREAD_NUMBER_LIMIT]; \n            for (int i=0; i < THREAD_NUMBER_LIMIT; i++) {\n                ResumeDebuggeeThreads[i] = new ResumeDebuggee_Thread(i);\n                ResumeDebuggeeThreads[i].start();"}
{"magic_number_smell": "\t *             message.\n\t */\n\tprivate synchronized void sendNowEx(String line) throws IOException {\n\t\tif (line.length() > (IrcOutput.512 - 2)) {\n\t\t\tline = line.substring(0, IrcOutput.512 - 2);\n\t\t}\n\t\tIrcDebug.log(\">>> \" + line);", "refactored_code": "\tprotected static final int MAX_LINE_LENGTH = 512;\n\t *             message.\n\t */\n\tprivate synchronized void sendNowEx(String line) throws IOException {\n\t\tif (line.length() > (IrcOutput.MAX_LINE_LENGTH - 2)) {\n\t\t\tline = line.substring(0, IrcOutput.MAX_LINE_LENGTH - 2);\n\t\t}\n\t\tIrcDebug.log(\">>> \" + line);"}
{"magic_number_smell": "\t * @param address The server address.\n\t */\n\tpublic IrcServer(final String address) {\n\t\tthis(address, IrcServer.6667, null, false);\n\t}\n\t\n\t/**", "refactored_code": "\tprotected static final int DEFAULT_PORT = 6667;\n\t * @param address The server address.\n\t */\n\tpublic IrcServer(final String address) {\n\t\tthis(address, IrcServer.DEFAULT_PORT, null, false);\n\t}\n\t\n\t/**"}
{"magic_number_smell": "  }\n\n  public JedisCluster(Set<HostAndPort> nodes) {\n    this(nodes, 2000);\n  }\n\n  public JedisCluster(Set<HostAndPort> nodes, int timeout) {", "refactored_code": "  public static final int DEFAULT_TIMEOUT = 2000;\n  }\n\n  public JedisCluster(Set<HostAndPort> nodes) {\n    this(nodes, DEFAULT_TIMEOUT);\n  }\n\n  public JedisCluster(Set<HostAndPort> nodes, int timeout) {"}
{"magic_number_smell": "      for (Object slotInfoObj : slotsInfo) {\n        List<Object> slotInfo = (List<Object>) slotInfoObj;\n\n        if (slotInfo.size() <= 2) {\n          continue;\n        }\n", "refactored_code": "  private static final int MASTER_NODE_INDEX = 2;\n      for (Object slotInfoObj : slotsInfo) {\n        List<Object> slotInfo = (List<Object>) slotInfoObj;\n\n        if (slotInfo.size() <= MASTER_NODE_INDEX) {\n          continue;\n        }\n"}
{"magic_number_smell": "\n        private ClusterConfig[] clusterConfigs;\n\n        private int retryMaxAttempts = 3;\n        private int retryWaitDuration = RETRY_WAIT_DURATION_DEFAULT;\n        private int retryWaitDurationExponentialBackoffMultiplier = RETRY_WAIT_DURATION_EXPONENTIAL_BACKOFF_MULTIPLIER_DEFAULT;\n        private List<Class> retryIncludedExceptionList = RETRY_INCLUDED_EXCEPTIONS_DEFAULT;", "refactored_code": "    private static final int RETRY_MAX_ATTEMPTS_DEFAULT = 3;\n\n        private ClusterConfig[] clusterConfigs;\n\n        private int retryMaxAttempts = RETRY_MAX_ATTEMPTS_DEFAULT;\n        private int retryWaitDuration = RETRY_WAIT_DURATION_DEFAULT;\n        private int retryWaitDurationExponentialBackoffMultiplier = RETRY_WAIT_DURATION_EXPONENTIAL_BACKOFF_MULTIPLIER_DEFAULT;\n        private List<Class> retryIncludedExceptionList = RETRY_INCLUDED_EXCEPTIONS_DEFAULT;"}
{"magic_number_smell": "   */\n  public static final StreamEntryID NEW_ENTRY = new StreamEntryID() {\n\n    private static final long 1L = 1L;\n\n    @Override\n    public String toString() {", "refactored_code": "  private static final long serialVersionUID = 1L;\n   */\n  public static final StreamEntryID NEW_ENTRY = new StreamEntryID() {\n\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public String toString() {"}
{"magic_number_smell": "        if (this == other) return true;\n        if (!(other instanceof Point)) return false;\n        Point o = (Point) other;\n        return Math.abs(latitude - o.latitude) < 1e-5 &&\n                Math.abs(longitude - o.longitude) < 1e-5;\n    }\n", "refactored_code": "    private static final double EPSILON = 1e-5;\n        if (this == other) return true;\n        if (!(other instanceof Point)) return false;\n        Point o = (Point) other;\n        return Math.abs(latitude - o.latitude) < EPSILON &&\n                Math.abs(longitude - o.longitude) < EPSILON;\n    }\n"}
{"magic_number_smell": "      final GenericObjectPoolConfig<Connection> poolConfig,\n      Set<HostAndPort> sentinels, final JedisClientConfig sentinelClientConfig) {\n    this(masterName, masterClientConfig, poolConfig, sentinels, sentinelClientConfig,\n        5000);\n  }\n\n  public SentineledConnectionProvider(String masterName, final JedisClientConfig masterClientConfig,", "refactored_code": "  protected static final long DEFAULT_SUBSCRIBE_RETRY_WAIT_TIME_MILLIS = 5000;\n      final GenericObjectPoolConfig<Connection> poolConfig,\n      Set<HostAndPort> sentinels, final JedisClientConfig sentinelClientConfig) {\n    this(masterName, masterClientConfig, poolConfig, sentinels, sentinelClientConfig,\n        DEFAULT_SUBSCRIBE_RETRY_WAIT_TIME_MILLIS);\n  }\n\n  public SentineledConnectionProvider(String masterName, final JedisClientConfig masterClientConfig,"}
{"magic_number_smell": "   */\n  public static final int KEEP_TERM_FREQUENCIES = 0x08;\n\n  public static final int DEFAULT_FLAGS = 0x01 | KEEP_FIELD_FLAGS | KEEP_TERM_FREQUENCIES;\n\n  private final int flags;\n  private List<String> stopwords;", "refactored_code": "  public static final int USE_TERM_OFFSETS = 0x01;\n   */\n  public static final int KEEP_TERM_FREQUENCIES = 0x08;\n\n  public static final int DEFAULT_FLAGS = USE_TERM_OFFSETS | KEEP_FIELD_FLAGS | KEEP_TERM_FREQUENCIES;\n\n  private final int flags;\n  private List<String> stopwords;"}
{"magic_number_smell": "    Set<HostAndPort> jedisClusterNode = new HashSet<>();\n    jedisClusterNode.add(new HostAndPort(\"127.0.0.1\", 7379));\n\n    try (JedisCluster jc = new JedisCluster(jedisClusterNode, 2000, 2000,\n        DEFAULT_REDIRECTIONS, \"cluster\", DEFAULT_POOL_CONFIG)) {\n      assertEquals(3, jc.getClusterNodes().size());\n    }", "refactored_code": "  private static final int DEFAULT_TIMEOUT = 2000;\n    Set<HostAndPort> jedisClusterNode = new HashSet<>();\n    jedisClusterNode.add(new HostAndPort(\"127.0.0.1\", 7379));\n\n    try (JedisCluster jc = new JedisCluster(jedisClusterNode, DEFAULT_TIMEOUT, DEFAULT_TIMEOUT,\n        DEFAULT_REDIRECTIONS, \"cluster\", DEFAULT_POOL_CONFIG)) {\n      assertEquals(3, jc.getClusterNodes().size());\n    }"}
{"magic_number_smell": "  public void setUp() throws Exception {\n    super.setUp();\n\n    dest = new Jedis(host, 6386, 500);\n    dest.flushAll();\n    dest.select(db);\n", "refactored_code": "  private static final int port = 6386;\n  public void setUp() throws Exception {\n    super.setUp();\n\n    dest = new Jedis(host, port, 500);\n    dest.flushAll();\n    dest.select(db);\n"}
{"magic_number_smell": "  public void testSSLDiscoverNodesAutomatically() {\n    try (JedisCluster jc = new JedisCluster(Collections.singleton(new HostAndPort(\"localhost\", 8379)),\n        DefaultJedisClientConfig.builder().user(\"default\").password(\"cluster\").ssl(true)\n            .hostAndPortMapper(hostAndPortMap).build(), 5, DEFAULT_POOL_CONFIG)) {\n      Map clusterNodes = jc.getClusterNodes();\n      assertEquals(3, clusterNodes.size());\n      assertTrue(clusterNodes.containsKey(\"127.0.0.1:7379\"));", "refactored_code": "  private static final int DEFAULT_REDIRECTIONS = 5;\n  public void testSSLDiscoverNodesAutomatically() {\n    try (JedisCluster jc = new JedisCluster(Collections.singleton(new HostAndPort(\"localhost\", 8379)),\n        DefaultJedisClientConfig.builder().user(\"default\").password(\"cluster\").ssl(true)\n            .hostAndPortMapper(hostAndPortMap).build(), DEFAULT_REDIRECTIONS, DEFAULT_POOL_CONFIG)) {\n      Map clusterNodes = jc.getClusterNodes();\n      assertEquals(3, clusterNodes.size());\n      assertTrue(clusterNodes.containsKey(\"127.0.0.1:7379\"));"}
{"magic_number_smell": "  public void testSSLDiscoverNodesAutomatically() {\n    try (JedisCluster jc = new JedisCluster(Collections.singleton(new HostAndPort(\"localhost\", 8379)),\n        DefaultJedisClientConfig.builder().password(\"cluster\").ssl(true)\n            .hostAndPortMapper(hostAndPortMap).build(), 5, DEFAULT_POOL_CONFIG)) {\n//      Map<String, JedisPool> clusterNodes = jc.getClusterNodes();\n      Map<String, ?> clusterNodes = jc.getClusterNodes();\n      assertEquals(3, clusterNodes.size());", "refactored_code": "  private static final int DEFAULT_REDIRECTIONS = 5;\n  public void testSSLDiscoverNodesAutomatically() {\n    try (JedisCluster jc = new JedisCluster(Collections.singleton(new HostAndPort(\"localhost\", 8379)),\n        DefaultJedisClientConfig.builder().password(\"cluster\").ssl(true)\n            .hostAndPortMapper(hostAndPortMap).build(), DEFAULT_REDIRECTIONS, DEFAULT_POOL_CONFIG)) {\n//      Map<String, JedisPool> clusterNodes = jc.getClusterNodes();\n      Map<String, ?> clusterNodes = jc.getClusterNodes();\n      assertEquals(3, clusterNodes.size());"}
{"magic_number_smell": "  public static void main(String[] args) {\n    long begin = Calendar.getInstance().getTimeInMillis();\n\n    for (int n = 0; n <= 100000000; n++) {\n      JedisClusterCRC16.getSlot(TEST_SET[n % TEST_SET.length]);\n    }\n", "refactored_code": "  private static final int TOTAL_OPERATIONS = 100000000;\n  public static void main(String[] args) {\n    long begin = Calendar.getInstance().getTimeInMillis();\n\n    for (int n = 0; n <= TOTAL_OPERATIONS; n++) {\n      JedisClusterCRC16.getSlot(TEST_SET[n % TEST_SET.length]);\n    }\n"}
{"magic_number_smell": "\n    long begin = Calendar.getInstance().getTimeInMillis();\n\n    for (int n = 0; n <= 100000; n++) {\n      String key = \"foo\" + n;\n      jedis.set(key, \"bar\" + n);\n      jedis.get(key);", "refactored_code": "  private static final int TOTAL_OPERATIONS = 100000;\n\n    long begin = Calendar.getInstance().getTimeInMillis();\n\n    for (int n = 0; n <= TOTAL_OPERATIONS; n++) {\n      String key = \"foo\" + n;\n      jedis.set(key, \"bar\" + n);\n      jedis.get(key);"}
{"magic_number_smell": "\n    long begin = Calendar.getInstance().getTimeInMillis();\n\n    for (int n = 0; n <= 10000000; n++) {\n      String key = \"foo\" + n;\n      Hashing.MD5.hash(key);\n    }", "refactored_code": "  private static final int TOTAL_OPERATIONS = 10000000;\n\n    long begin = Calendar.getInstance().getTimeInMillis();\n\n    for (int n = 0; n <= TOTAL_OPERATIONS; n++) {\n      String key = \"foo\" + n;\n      Hashing.MD5.hash(key);\n    }"}
{"magic_number_smell": "    long begin = Calendar.getInstance().getTimeInMillis();\n\n    Pipeline p = jedis.pipelined();\n    for (int n = 0; n <= 200000; n++) {\n      String key = \"foo\" + n;\n      p.set(key, \"bar\" + n);\n      p.get(key);", "refactored_code": "  private static final int TOTAL_OPERATIONS = 200000;\n    long begin = Calendar.getInstance().getTimeInMillis();\n\n    Pipeline p = jedis.pipelined();\n    for (int n = 0; n <= TOTAL_OPERATIONS; n++) {\n      String key = \"foo\" + n;\n      p.set(key, \"bar\" + n);\n      p.get(key);"}
{"magic_number_smell": "    // withoutPool();\n    withPool();\n    long elapsed = System.currentTimeMillis() - t;\n    System.out.println(((1000 * 2 * 100000) / elapsed) + \" ops\");\n  }\n\n  private static void withPool() throws Exception {", "refactored_code": "  private static final int TOTAL_OPERATIONS = 100000;\n    // withoutPool();\n    withPool();\n    long elapsed = System.currentTimeMillis() - t;\n    System.out.println(((1000 * 2 * TOTAL_OPERATIONS) / elapsed) + \" ops\");\n  }\n\n  private static void withPool() throws Exception {"}
{"magic_number_smell": "    long t = System.currentTimeMillis();\n    withPool();\n    long elapsed = System.currentTimeMillis() - t;\n    System.out.println(((1000 * 2 * 100000) / elapsed) + \" ops\");\n  }\n\n  private static void withPool() throws Exception {", "refactored_code": "  private static final int TOTAL_OPERATIONS = 100000;\n    long t = System.currentTimeMillis();\n    withPool();\n    long elapsed = System.currentTimeMillis() - t;\n    System.out.println(((1000 * 2 * TOTAL_OPERATIONS) / elapsed) + \" ops\");\n  }\n\n  private static void withPool() throws Exception {"}
{"magic_number_smell": "    long total = 0;\n    for (int at = 0; at != 10; ++at) {\n      long elapsed = measureInputMulti();\n      long ops = ((1000 * 2 * 500000) / TimeUnit.NANOSECONDS.toMillis(elapsed));\n      if (at >= 5) {\n        total += ops;\n      }", "refactored_code": "  private static final int TOTAL_OPERATIONS = 500000;\n    long total = 0;\n    for (int at = 0; at != 10; ++at) {\n      long elapsed = measureInputMulti();\n      long ops = ((1000 * 2 * TOTAL_OPERATIONS) / TimeUnit.NANOSECONDS.toMillis(elapsed));\n      if (at >= 5) {\n        total += ops;\n      }"}
{"magic_number_smell": "  public static void main(String[] args) throws UnknownHostException, IOException {\n    long begin = Calendar.getInstance().getTimeInMillis();\n\n    for (int n = 0; n <= 10000000; n++) {\n      SafeEncoder.encode(\"foo bar!\");\n    }\n", "refactored_code": "  private static final int TOTAL_OPERATIONS = 10000000;\n  public static void main(String[] args) throws UnknownHostException, IOException {\n    long begin = Calendar.getInstance().getTimeInMillis();\n\n    for (int n = 0; n <= TOTAL_OPERATIONS; n++) {\n      SafeEncoder.encode(\"foo bar!\");\n    }\n"}
{"magic_number_smell": "//\n//    long begin = Calendar.getInstance().getTimeInMillis();\n//\n//    for (int n = 0; n <= 100000; n++) {\n//      String key = \"foo\" + n;\n//      jedis.set(key, \"bar\" + n);\n//      jedis.get(key);", "refactored_code": "//  private static final int TOTAL_OPERATIONS = 100000;\n//\n//    long begin = Calendar.getInstance().getTimeInMillis();\n//\n//    for (int n = 0; n <= TOTAL_OPERATIONS; n++) {\n//      String key = \"foo\" + n;\n//      jedis.set(key, \"bar\" + n);\n//      jedis.get(key);"}
{"magic_number_smell": "\n      long begin = Calendar.getInstance().getTimeInMillis();\n\n      for (int n = 0; n <= 100000; n++) {\n        String key = \"foo\" + n;\n        jedis.set(key, \"bar\" + n);\n        jedis.get(key);", "refactored_code": "  private static final int TOTAL_OPERATIONS = 100000;\n\n      long begin = Calendar.getInstance().getTimeInMillis();\n\n      for (int n = 0; n <= TOTAL_OPERATIONS; n++) {\n        String key = \"foo\" + n;\n        jedis.set(key, \"bar\" + n);\n        jedis.get(key);"}
{"magic_number_smell": "  public void failoverForceWithoutTimeoutFailFast() {\n    try (Jedis master = new Jedis(masterAddress)) {\n      assertEquals(\"OK\", master.failover(FailoverParams.failoverParams()\n          .to(new HostAndPort(\"127.0.0.1\", 6000)).force()));\n    }\n  }\n", "refactored_code": "  private static final int INVALID_PORT = 6000;\n  public void failoverForceWithoutTimeoutFailFast() {\n    try (Jedis master = new Jedis(masterAddress)) {\n      assertEquals(\"OK\", master.failover(FailoverParams.failoverParams()\n          .to(new HostAndPort(\"127.0.0.1\", INVALID_PORT)).force()));\n    }\n  }\n"}
{"magic_number_smell": "\n    List<GeoCoordinate> coordinates = jedis.geopos(\"foo\", \"a\", \"b\", \"notexist\");\n    assertEquals(3, coordinates.size());\n    assertEquals(3.0, coordinates.get(0).getLongitude(), 1e-5);\n    assertEquals(4.0, coordinates.get(0).getLatitude(), 1e-5);\n    assertEquals(2.0, coordinates.get(1).getLongitude(), 1e-5);\n    assertEquals(3.0, coordinates.get(1).getLatitude(), 1e-5);", "refactored_code": "  private static final double EPSILON = 1e-5;\n\n    List<GeoCoordinate> coordinates = jedis.geopos(\"foo\", \"a\", \"b\", \"notexist\");\n    assertEquals(3, coordinates.size());\n    assertEquals(3.0, coordinates.get(0).getLongitude(), EPSILON);\n    assertEquals(4.0, coordinates.get(0).getLatitude(), EPSILON);\n    assertEquals(2.0, coordinates.get(1).getLongitude(), EPSILON);\n    assertEquals(3.0, coordinates.get(1).getLatitude(), EPSILON);"}
{"magic_number_smell": "  public void setUp() throws Exception {\n    super.setUp();\n\n    dest = new Jedis(host, 6386, 500);\n    dest.flushAll();\n    dest.select(db);\n", "refactored_code": "  private static final int port = 6386;\n  public void setUp() throws Exception {\n    super.setUp();\n\n    dest = new Jedis(host, port, 500);\n    dest.flushAll();\n    dest.select(db);\n"}
{"magic_number_smell": "\n    List<GeoCoordinate> coordinates = jedis.geopos(\"foo\", \"a\", \"b\", \"notexist\");\n    assertEquals(3, coordinates.size());\n    assertEquals(3.0, coordinates.get(0).getLongitude(), 1e-5);\n    assertEquals(4.0, coordinates.get(0).getLatitude(), 1e-5);\n    assertEquals(2.0, coordinates.get(1).getLongitude(), 1e-5);\n    assertEquals(3.0, coordinates.get(1).getLatitude(), 1e-5);", "refactored_code": "  private static final double EPSILON = 1e-5;\n\n    List<GeoCoordinate> coordinates = jedis.geopos(\"foo\", \"a\", \"b\", \"notexist\");\n    assertEquals(3, coordinates.size());\n    assertEquals(3.0, coordinates.get(0).getLongitude(), EPSILON);\n    assertEquals(4.0, coordinates.get(0).getLatitude(), EPSILON);\n    assertEquals(2.0, coordinates.get(1).getLongitude(), EPSILON);\n    assertEquals(3.0, coordinates.get(1).getLatitude(), EPSILON);"}
{"magic_number_smell": "    assertThat(members1.get().stream().map(GeoRadiusResponse::getMemberByString).collect(Collectors.toList()),\n        containsInAnyOrder(\"Palermo\", \"Catania\"));\n    assertThat(members1.get().stream().map(GeoRadiusResponse::getDistance).collect(Collectors.toList()),\n        contains(closeTo(0.0, 1e-5), closeTo(0.0, 1e-5)));\n    assertThat(members1.get().stream().map(GeoRadiusResponse::getCoordinate).collect(Collectors.toList()),\n        contains(nullValue(), nullValue()));\n    assertThat(members1.get().stream().map(GeoRadiusResponse::getRawScore).collect(Collectors.toList()),", "refactored_code": "  private static final double EPSILON = 1e-5;\n    assertThat(members1.get().stream().map(GeoRadiusResponse::getMemberByString).collect(Collectors.toList()),\n        containsInAnyOrder(\"Palermo\", \"Catania\"));\n    assertThat(members1.get().stream().map(GeoRadiusResponse::getDistance).collect(Collectors.toList()),\n        contains(closeTo(0.0, EPSILON), closeTo(0.0, EPSILON)));\n    assertThat(members1.get().stream().map(GeoRadiusResponse::getCoordinate).collect(Collectors.toList()),\n        contains(nullValue(), nullValue()));\n    assertThat(members1.get().stream().map(GeoRadiusResponse::getRawScore).collect(Collectors.toList()),"}
{"magic_number_smell": "  @Override\n  public void setUp() {\n    super.setUp();\n    client.setDefaultSearchDialect(2);\n  }\n//\n//  @AfterClass", "refactored_code": "  private static final int DEFAULT_DIALECT = 2;\n  @Override\n  public void setUp() {\n    super.setUp();\n    client.setDefaultSearchDialect(DEFAULT_DIALECT);\n  }\n//\n//  @AfterClass"}
{"magic_number_smell": "  @Override\n  protected boolean matchesSafely(GeoCoordinate item) {\n    return item != null &&\n        Math.abs(longitude - item.getLongitude()) < 1e-5 &&\n        Math.abs(latitude - item.getLatitude()) < 1e-5;\n  }\n", "refactored_code": "  private static final double EPSILON = 1e-5;\n  @Override\n  protected boolean matchesSafely(GeoCoordinate item) {\n    return item != null &&\n        Math.abs(longitude - item.getLongitude()) < EPSILON &&\n        Math.abs(latitude - item.getLatitude()) < EPSILON;\n  }\n"}
{"magic_number_smell": "    state = new NodeStatus(NodeState.HELLO, 0, 0, NetUtils.localhost(),\n        FlumeNode.getInstance().getPhysicalNodeName());\n    // Set version to -1 so that all non-negative versions will be 'later'\n    lastGoodCfg = new FlumeConfigData(0, \"null\", \"null\", -1,\n        -1, FlumeConfiguration.get().getDefaultFlowName());\n  }\n", "refactored_code": "  public static final long VERSION_INFIMUM = -1;\n    state = new NodeStatus(NodeState.HELLO, 0, 0, NetUtils.localhost(),\n        FlumeNode.getInstance().getPhysicalNodeName());\n    // Set version to -1 so that all non-negative versions will be 'later'\n    lastGoodCfg = new FlumeConfigData(0, \"null\", \"null\", VERSION_INFIMUM,\n        VERSION_INFIMUM, FlumeConfiguration.get().getDefaultFlowName());\n  }\n"}
{"magic_number_smell": "    }\n    String servers = get(MASTER_HEARTBEAT_SERVERS, null);\n    if (servers == null) {\n      return 35872;\n    }\n\n    // MASTER_HEARTBEAT_SERVERS is set - split it and guess at our server port", "refactored_code": "  static public final int DEFAULT_HEARTBEAT_PORT = 35872;\n    }\n    String servers = get(MASTER_HEARTBEAT_SERVERS, null);\n    if (servers == null) {\n      return DEFAULT_HEARTBEAT_PORT;\n    }\n\n    // MASTER_HEARTBEAT_SERVERS is set - split it and guess at our server port"}
{"magic_number_smell": "\n    while (this.active) {\n      try {\n        Thread.sleep(100);\n      } catch (InterruptedException e) {\n        /*\n         * Essentially send the control back to the beginning of the while loop.", "refactored_code": "  public static final int timeQuanta = 100;\n\n    while (this.active) {\n      try {\n        Thread.sleep(timeQuanta);\n      } catch (InterruptedException e) {\n        /*\n         * Essentially send the control back to the beginning of the while loop."}
{"magic_number_smell": "  private void emitMetric(String name, String type, String value, String units)\n      throws IOException {\n    int slope = 3; // see gmetric.c\n    int tmax = 60;\n    int dmax = DEFAULT_DMAX;\n    String hostName = NetUtils.localhost();\n", "refactored_code": "  private static final int DEFAULT_TMAX = 60;\n  private void emitMetric(String name, String type, String value, String units)\n      throws IOException {\n    int slope = 3; // see gmetric.c\n    int tmax = DEFAULT_TMAX;\n    int dmax = DEFAULT_DMAX;\n    String hostName = NetUtils.localhost();\n"}
{"magic_number_smell": "     * 0 wait time means forever.\n     */\n    if (cmd.getCommand().equals(\"wait\")) {\n      long millis = 10 * 1000;\n      long cmdid = lastCmdId;\n\n      // args are time, and then cmdid.", "refactored_code": "  public static final long CMD_WAIT_TIME_MS = 10 * 1000;\n     * 0 wait time means forever.\n     */\n    if (cmd.getCommand().equals(\"wait\")) {\n      long millis = CMD_WAIT_TIME_MS;\n      long cmdid = lastCmdId;\n\n      // args are time, and then cmdid."}
{"magic_number_smell": "  public FlumeLog4jAvroAppender() {\n    super();\n\n    reconnectAttempts = 10;\n    hostname = defaultHostname;\n  }\n", "refactored_code": "  private static final int defaultReconnectAttempts = 10;\n  public FlumeLog4jAvroAppender() {\n    super();\n\n    reconnectAttempts = defaultReconnectAttempts;\n    hostname = defaultHostname;\n  }\n"}
{"magic_number_smell": "\n  @Before\n  public void setUp() throws IOException {\n    eventSource = new AvroEventSource(12345);\n    avroLogger = Logger.getLogger(\"avrologger\");\n\n    FlumeLog4jAvroAppender avroAppender = new FlumeLog4jAvroAppender();", "refactored_code": "  private static final int testServerPort = 12345;\n\n  @Before\n  public void setUp() throws IOException {\n    eventSource = new AvroEventSource(testServerPort);\n    avroLogger = Logger.getLogger(\"avrologger\");\n\n    FlumeLog4jAvroAppender avroAppender = new FlumeLog4jAvroAppender();"}
{"magic_number_smell": "\t}\n\n\t/** @param pVertices\n\t * @return An array of length <code>pVertices.size()</code> filled with either {@link EarClippingTriangulator#1} or\n\t *         {@link EarClippingTriangulator#CONVEX}. */\n\tprivate int[] classifyVertices (final ArrayList<Vector2> pVertices) {\n\t\tfinal int vertexCount = pVertices.size();", "refactored_code": "\tprivate static final int CONCAVE = 1;\n\t}\n\n\t/** @param pVertices\n\t * @return An array of length <code>pVertices.size()</code> filled with either {@link EarClippingTriangulator#CONCAVE} or\n\t *         {@link EarClippingTriangulator#CONVEX}. */\n\tprivate int[] classifyVertices (final ArrayList<Vector2> pVertices) {\n\t\tfinal int vertexCount = pVertices.size();"}
{"magic_number_smell": "\tstatic private final int SIN_MASK = ~(-1 << SIN_BITS);\n\tstatic private final int SIN_COUNT = SIN_MASK + 1;\n\n\tstatic private final float radFull = 3.1415927f * 2;\n\tstatic private final float degFull = 360;\n\tstatic private final float radToIndex = SIN_COUNT / radFull;\n\tstatic private final float degToIndex = SIN_COUNT / degFull;", "refactored_code": "\tstatic public final float PI = 3.1415927f;\n\tstatic private final int SIN_MASK = ~(-1 << SIN_BITS);\n\tstatic private final int SIN_COUNT = SIN_MASK + 1;\n\n\tstatic private final float radFull = PI * 2;\n\tstatic private final float degFull = 360;\n\tstatic private final float radToIndex = SIN_COUNT / radFull;\n\tstatic private final float degToIndex = SIN_COUNT / degFull;"}
{"magic_number_smell": "\t/** Transforms the given vector by this transform\n\t * @param v the vector */\n\tpublic Vector2 mul (Vector2 v) {\n\t\tfloat x = vals[0] + vals[COS] * v.x + -vals[SIN] * v.y;\n\t\tfloat y = vals[POS_Y] + vals[SIN] * v.x + vals[COS] * v.y;\n\n\t\tv.x = x;", "refactored_code": "\tpublic static final int POS_X = 0;\n\t/** Transforms the given vector by this transform\n\t * @param v the vector */\n\tpublic Vector2 mul (Vector2 v) {\n\t\tfloat x = vals[POS_X] + vals[COS] * v.x + -vals[SIN] * v.y;\n\t\tfloat y = vals[POS_Y] + vals[SIN] * v.x + vals[COS] * v.y;\n\n\t\tv.x = x;"}
{"magic_number_smell": "\t\tif (nRemaining < 2) return; // Arrays of size 0 and 1 are always sorted\n\n\t\t// If array is small, do a \"mini-TimSort\" with no merges\n\t\tif (nRemaining < 32) {\n\t\t\tint initRunLen = countRunAndMakeAscending(a, lo, hi);\n\t\t\tbinarySort(a, lo, hi, lo + initRunLen);\n\t\t\treturn;", "refactored_code": "\tprivate static final int MIN_MERGE = 32;\n\t\tif (nRemaining < 2) return; // Arrays of size 0 and 1 are always sorted\n\n\t\t// If array is small, do a \"mini-TimSort\" with no merges\n\t\tif (nRemaining < MIN_MERGE) {\n\t\t\tint initRunLen = countRunAndMakeAscending(a, lo, hi);\n\t\t\tbinarySort(a, lo, hi, lo + initRunLen);\n\t\t\treturn;"}
{"magic_number_smell": "\t\tif (nRemaining < 2) return; // Arrays of size 0 and 1 are always sorted\n\n\t\t// If array is small, do a \"mini-TimSort\" with no merges\n\t\tif (nRemaining < 32) {\n\t\t\tint initRunLen = countRunAndMakeAscending(a, lo, hi, c);\n\t\t\tbinarySort(a, lo, hi, lo + initRunLen, c);\n\t\t\treturn;", "refactored_code": "\tprivate static final int MIN_MERGE = 32;\n\t\tif (nRemaining < 2) return; // Arrays of size 0 and 1 are always sorted\n\n\t\t// If array is small, do a \"mini-TimSort\" with no merges\n\t\tif (nRemaining < MIN_MERGE) {\n\t\t\tint initRunLen = countRunAndMakeAscending(a, lo, hi, c);\n\t\t\tbinarySort(a, lo, hi, lo + initRunLen, c);\n\t\t\treturn;"}
{"magic_number_smell": "\n            float min_t = Float.MAX_VALUE;\n\n            for (int i = 0; i <= 4; ++i) {\n                int pIndex = (i + (4 - 1))%4;\n\n                CGPoint edgePtA = CGPoint.ccpCompMult(boundaryTexCoord((char) (i % 4)),tMax);", "refactored_code": "    public static final int kProgressTextureCoordsCount = 4;\n\n            float min_t = Float.MAX_VALUE;\n\n            for (int i = 0; i <= kProgressTextureCoordsCount; ++i) {\n                int pIndex = (i + (kProgressTextureCoordsCount - 1))%kProgressTextureCoordsCount;\n\n                CGPoint edgePtA = CGPoint.ccpCompMult(boundaryTexCoord((char) (i % kProgressTextureCoordsCount)),tMax);"}
{"magic_number_smell": "        /**\n\t\t * \n\t\t */\n\t\tprivate static final long 5996803998420105321L = -1912889437889458701L;\n\n\t\tpublic SchedulerTimerNotFound(String reason) {\n            super(reason);", "refactored_code": "\t\tprivate static final long serialVersionUID = 5996803998420105321L;\n        /**\n\t\t * \n\t\t */\n\t\tprivate static final long serialVersionUID = -1912889437889458701L;\n\n\t\tpublic SchedulerTimerNotFound(String reason) {\n            super(reason);"}
{"magic_number_smell": "    /** Initializes the action */\n    public CCAction() {\n        target = originalTarget = null;\n        tag = -1;\n    }\n\n    public abstract CCAction copy();", "refactored_code": "    public static final int kCCActionTagInvalid = -1;\n    /** Initializes the action */\n    public CCAction() {\n        target = originalTarget = null;\n        tag = kCCActionTagInvalid;\n    }\n\n    public abstract CCAction copy();"}
{"magic_number_smell": "\t\ttoQuit = NO;\n\t\tlocked = NO;\n\n\t\thandlerHelperData[0] = (struct ccTouchHandlerHelperData) {@selector(ccTouchesBegan:withEvent:),@selector(0:withEvent:),ccTouchSelectorBeganBit};\n\t\thandlerHelperData[ccTouchMoved] = (struct ccTouchHandlerHelperData) {@selector(ccTouchesMoved:withEvent:),@selector(ccTouchMoved:withEvent:),ccTouchSelectorMovedBit};\n\t\thandlerHelperData[ccTouchEnded] = (struct ccTouchHandlerHelperData) {@selector(ccTouchesEnded:withEvent:),@selector(ccTouchEnded:withEvent:),ccTouchSelectorEndedBit};\n\t\thandlerHelperData[ccTouchCancelled] = (struct ccTouchHandlerHelperData) {@selector(ccTouchesCancelled:withEvent:),@selector(ccTouchCancelled:withEvent:),ccTouchSelectorCancelledBit};", "refactored_code": "    public static final int ccTouchBegan        = 0;\n\t\ttoQuit = NO;\n\t\tlocked = NO;\n\n\t\thandlerHelperData[ccTouchBegan] = (struct ccTouchHandlerHelperData) {@selector(ccTouchesBegan:withEvent:),@selector(ccTouchBegan:withEvent:),ccTouchSelectorBeganBit};\n\t\thandlerHelperData[ccTouchMoved] = (struct ccTouchHandlerHelperData) {@selector(ccTouchesMoved:withEvent:),@selector(ccTouchMoved:withEvent:),ccTouchSelectorMovedBit};\n\t\thandlerHelperData[ccTouchEnded] = (struct ccTouchHandlerHelperData) {@selector(ccTouchesEnded:withEvent:),@selector(ccTouchEnded:withEvent:),ccTouchSelectorEndedBit};\n\t\thandlerHelperData[ccTouchCancelled] = (struct ccTouchHandlerHelperData) {@selector(ccTouchesCancelled:withEvent:),@selector(ccTouchCancelled:withEvent:),ccTouchSelectorCancelledBit};"}
{"magic_number_smell": "\tCGRect _clippedRect;\n\t\n\tpublic CCClipNode(){\n\t\t_clippedRect = CGRect.make(99999 + 1, 0, 0, 0);\n\t}\n\t\n\tstatic CGPoint pos = CGPoint.zero();", "refactored_code": "\tpublic static final int RECT_ORIGIN_INVALID = 99999;\n\tCGRect _clippedRect;\n\t\n\tpublic CCClipNode(){\n\t\t_clippedRect = CGRect.make(RECT_ORIGIN_INVALID + 1, 0, 0, 0);\n\t}\n\t\n\tstatic CGPoint pos = CGPoint.zero();"}
{"magic_number_smell": "\t    newY     = Math.max(newY, minInset.y);\n\t    \n\t    scrollDistance_     = CGPoint.ccpSub(scrollDistance_, CGPoint.ccp(newX - container_.getPosition().x, newY - container_.getPosition().y));\n\t    scrollDistance_     = CGPoint.ccpMult(scrollDistance_, 0.95f);\n\t    setContentOffset(CGPoint.ccp(newX,newY));\n\t    \n\t    if (CGPoint.ccpLengthSQ(scrollDistance_) <= SCROLL_DEACCEL_DIST*SCROLL_DEACCEL_DIST ||", "refactored_code": "\tprivate static final float SCROLL_DEACCEL_RATE = 0.95f;\n\t    newY     = Math.max(newY, minInset.y);\n\t    \n\t    scrollDistance_     = CGPoint.ccpSub(scrollDistance_, CGPoint.ccp(newX - container_.getPosition().x, newY - container_.getPosition().y));\n\t    scrollDistance_     = CGPoint.ccpMult(scrollDistance_, SCROLL_DEACCEL_RATE);\n\t    setContentOffset(CGPoint.ccp(newX,newY));\n\t    \n\t    if (CGPoint.ccpLengthSQ(scrollDistance_) <= SCROLL_DEACCEL_DIST*SCROLL_DEACCEL_DIST ||"}
{"magic_number_smell": "    {\n        if (m_vordering != fillOrder) {\n            m_vordering = fillOrder;\n            if(m_vordering == 1){\n            \t//container_.setPosition(CGPoint.ccp(container_.getPosition().x, -container_.getContentSize().height+viewSize.height));\n                //This is necessary for scrolling physic\n                //setPosition(container_.getPosition());", "refactored_code": "    public static final int CCTableViewFillTopDown = 1;\n    {\n        if (m_vordering != fillOrder) {\n            m_vordering = fillOrder;\n            if(m_vordering == CCTableViewFillTopDown){\n            \t//container_.setPosition(CGPoint.ccp(container_.getPosition().x, -container_.getContentSize().height+viewSize.height));\n                //This is necessary for scrolling physic\n                //setPosition(container_.getPosition());"}
{"magic_number_smell": "     * align items vertically\n     */\n    public void alignItemsVertically() {\n        alignItemsVertically(5);\n    }\n\n    /**", "refactored_code": "    private static final int kDefaultPadding = 5;\n     * align items vertically\n     */\n    public void alignItemsVertically() {\n        alignItemsVertically(kDefaultPadding);\n    }\n\n    /**"}
{"magic_number_smell": "public class CCMenuItem extends CCNode {\n    public static final int 24 = 24;\n\n    static int _fontSize = 24;\n    static String fontName = \"DroidSans\";\n\n    public static final int kCurrentItem = 0xc0c05001;", "refactored_code": "    public static final int kItemSize = 24;\npublic class CCMenuItem extends CCNode {\n    public static final int kItemSize = 24;\n\n    static int _fontSize = kItemSize;\n    static String fontName = \"DroidSans\";\n\n    public static final int kCurrentItem = 0xc0c05001;"}
{"magic_number_smell": "    /** RGBA format. 32-bit. Needed for some 3D effects. It is not as fast as the RGB565 format. */\n    public static final int kCCPixelFormatRGBA8888 = 1;\n    /** default pixel format */\n    public static final int kCCPixelFormatDefault = 0;\n\n    /** @typedef tDepthBufferFormat\n      Possible DepthBuffer Formats for the EAGLView.", "refactored_code": "    public static final int kCCPixelFormatRGB565 = 0;\n    /** RGBA format. 32-bit. Needed for some 3D effects. It is not as fast as the RGB565 format. */\n    public static final int kCCPixelFormatRGBA8888 = 1;\n    /** default pixel format */\n    public static final int kCCPixelFormatDefault = kCCPixelFormatRGB565;\n\n    /** @typedef tDepthBufferFormat\n      Possible DepthBuffer Formats for the EAGLView."}
{"magic_number_smell": "        vertexZ_ = 0;\n        grid_ = null;\n        visible_ = true;\n\t\ttag_ = -1;\n\n\t\t// lazy alloc\n        camera_ = null;", "refactored_code": "    public static final int kCCNodeTagInvalid = -1;\n        vertexZ_ = 0;\n        grid_ = null;\n        visible_ = true;\n\t\ttag_ = kCCNodeTagInvalid;\n\n\t\t// lazy alloc\n        camera_ = null;"}
{"magic_number_smell": "\n        private static final int 50 = 50;\n\n        float[] verts = new float[50 * 3 * 2];\n        float[] coords = new float[50 * 2 * 2];\n        float[] colors = new float[50 * 4 * 2];\n        float[] creationTime = new float[50];", "refactored_code": "        private static final int COUNT = 50;\n\n        private static final int COUNT = 50;\n\n        float[] verts = new float[COUNT * 3 * 2];\n        float[] coords = new float[COUNT * 2 * 2];\n        float[] colors = new float[COUNT * 4 * 2];\n        float[] creationTime = new float[COUNT];"}
{"magic_number_smell": "      @since v0.99.0\n      */\n    public void useSelfRender() {\n        atlasIndex = 0xffffffff;\n        usesSpriteSheet_ = false;\n        textureAtlas_ = null;\n        spriteSheet_ = null;", "refactored_code": "\tpublic static final int CCSpriteIndexNotInitialized = 0xffffffff;\n      @since v0.99.0\n      */\n    public void useSelfRender() {\n        atlasIndex = CCSpriteIndexNotInitialized;\n        usesSpriteSheet_ = false;\n        textureAtlas_ = null;\n        spriteSheet_ = null;"}
{"magic_number_smell": "      The capacity will be increased in 33% in runtime if it run out of space.\n      */\n    public static CCSpriteSheet spriteSheet(CCTexture2D tex) {\n        return new CCSpriteSheet(tex, 29);\n    }\n\n    /** creates a CCSpriteSheet with a texture2d and capacity of children.", "refactored_code": "    public static final int defaultCapacity = 29;\n      The capacity will be increased in 33% in runtime if it run out of space.\n      */\n    public static CCSpriteSheet spriteSheet(CCTexture2D tex) {\n        return new CCSpriteSheet(tex, defaultCapacity);\n    }\n\n    /** creates a CCSpriteSheet with a texture2d and capacity of children."}
{"magic_number_smell": "    static class CCBitmapFontConfiguration {\n        // XXX: Creating a public interface so that the bitmapFontArray[] is accesible\n        // The characters building up the font\n        //public ccBitmapFontDef\tbitmapFontArray[] = new ccBitmapFontDef[2048];\n    \tpublic IntMap<ccBitmapFontDef>\tbitmapFontArray = new IntMap<ccBitmapFontDef>();\n    \t\n        // FNTConfig: Common Height", "refactored_code": "\tpublic static final int kCCBitmapFontAtlasMaxChars = 2048; //256,\n    static class CCBitmapFontConfiguration {\n        // XXX: Creating a public interface so that the bitmapFontArray[] is accesible\n        // The characters building up the font\n        //public ccBitmapFontDef\tbitmapFontArray[] = new ccBitmapFontDef[kCCBitmapFontAtlasMaxChars];\n    \tpublic IntMap<ccBitmapFontDef>\tbitmapFontArray = new IntMap<ccBitmapFontDef>();\n    \t\n        // FNTConfig: Common Height"}
{"magic_number_smell": "\n        setFocusable(true);\n        setFocusableInTouchMode(true);\n        this.setId(0x1235);\n\n        // add this to resolve Samsung's Galaxy opengl problem\n        //  here for reference.", "refactored_code": "\tprivate static final int VIEWID = 0x1235;\n\n        setFocusable(true);\n        setFocusableInTouchMode(true);\n        this.setId(VIEWID);\n\n        // add this to resolve Samsung's Galaxy opengl problem\n        //  here for reference."}
{"magic_number_smell": "\t\t\n\t\t// flags = CFSwapInt32LittleToHost(header->flags);\n\t\tflags = header.flags();\n\t\tformatFlags = flags & 0x0ff;\n\t\t\n\t\tif (formatFlags == kPVRTextureFlagTypePVRTC_4 || formatFlags == kPVRTextureFlagTypePVRTC_2)\n\t\t{", "refactored_code": "\tprivate static final int PVR_TEXTURE_FLAG_TYPE_MASK\t= 0x0ff;\n\t\t\n\t\t// flags = CFSwapInt32LittleToHost(header->flags);\n\t\tflags = header.flags();\n\t\tformatFlags = flags & PVR_TEXTURE_FLAG_TYPE_MASK;\n\t\t\n\t\tif (formatFlags == kPVRTextureFlagTypePVRTC_4 || formatFlags == kPVRTextureFlagTypePVRTC_2)\n\t\t{"}
{"magic_number_smell": "    /** saves the texture into a file. The format can be JPG or PNG */\n    /*\n    public boolean saveBuffer(String name, int format) {\n\t    return [self saveBuffer:name format:0];\n    }*/\n\n    /** clears the texture with a color */", "refactored_code": "\tpublic static final int kImageFormatJPG = 0;\n    /** saves the texture into a file. The format can be JPG or PNG */\n    /*\n    public boolean saveBuffer(String name, int format) {\n\t    return [self saveBuffer:name format:kImageFormatJPG];\n    }*/\n\n    /** clears the texture with a color */"}
{"magic_number_smell": "\n        boolean needDownScale = false;\n        float factor = 1;\n        while (width > 1024 || height > 1024) {\n            width /= 2;\n            height /= 2;\n//            transform = transform.getTransformScale(0.5f, 0.5f);", "refactored_code": "\tpublic static final int kMaxTextureSize = 1024;\n\n        boolean needDownScale = false;\n        float factor = 1;\n        while (width > kMaxTextureSize || height > kMaxTextureSize) {\n            width /= 2;\n            height /= 2;\n//            transform = transform.getTransformScale(0.5f, 0.5f);"}
{"magic_number_smell": "\n\t// backward compatible\n\tpublic static final int\tkParticleStartSizeEqualToEndSize = kCCParticleStartSizeEqualToEndSize;\n\tpublic static final int\tkParticleDurationInfinity = -1;\n\n\t/** Gravity mode (A mode) */\n\tpublic static final int\t\tkCCParticleModeGravity = 0;", "refactored_code": "\tpublic static final int\tkCCParticleDurationInfinity = -1;\n\n\t// backward compatible\n\tpublic static final int\tkParticleStartSizeEqualToEndSize = kCCParticleStartSizeEqualToEndSize;\n\tpublic static final int\tkParticleDurationInfinity = kCCParticleDurationInfinity;\n\n\t/** Gravity mode (A mode) */\n\tpublic static final int\t\tkCCParticleModeGravity = 0;"}
{"magic_number_smell": "\t\t\t\n\t\t\tGL11 gl = (GL11)CCDirector.gl;\n\t\t\t// create the VBO buffer\n\t\t\tthisp.quadsIDs = new int[4];\n\t\t\tgl.glGenBuffers(4, thisp.quadsIDs, 0);\n\t\t\t\n\t\t\t// initial binding", "refactored_code": "\tpublic static final int QuadSize = 4;\n\t\t\t\n\t\t\tGL11 gl = (GL11)CCDirector.gl;\n\t\t\t// create the VBO buffer\n\t\t\tthisp.quadsIDs = new int[QuadSize];\n\t\t\tgl.glGenBuffers(QuadSize, thisp.quadsIDs, 0);\n\t\t\t\n\t\t\t// initial binding"}
{"magic_number_smell": "\t\t\tforever.setTag(101);\n\t\t\tforever2.setTag(102);\n\n\t\t\taddChild(sp1, 0, 1);\n\t\t\taddChild(sp2, 0, kTagSprite2);\n\n\t\t\tsp1.runAction(forever);", "refactored_code": "\tpublic static final int kTagSprite1 = 1;\n\t\t\tforever.setTag(101);\n\t\t\tforever2.setTag(102);\n\n\t\t\taddChild(sp1, 0, kTagSprite1);\n\t\t\taddChild(sp2, 0, kTagSprite2);\n\n\t\t\tsp1.runAction(forever);"}
{"magic_number_smell": "\n        \t\tCCMenu menu = CCMenu.menu(item1, item2, item3);\n\n        \t\tmenu.setTag(1);\n\n        \t\taddChild(menu, 0, 100+i);\n        \t\tcenteredMenu = menu.getPosition();", "refactored_code": "    public static final int kTagMenu = 1;\n\n        \t\tCCMenu menu = CCMenu.menu(item1, item2, item3);\n\n        \t\tmenu.setTag(kTagMenu);\n\n        \t\taddChild(menu, 0, 100+i);\n        \t\tcenteredMenu = menu.getPosition();"}
{"magic_number_smell": "\n        \t\tCCMenu menu = CCMenu.menu(item1, item2, item3);\n\n        \t\tmenu.setTag(1);\n\n        \t\taddChild(menu, 0, 100+i);\n        \t\tcenteredMenu = menu.getPosition();", "refactored_code": "    public static final int kTagMenu = 1;\n\n        \t\tCCMenu menu = CCMenu.menu(item1, item2, item3);\n\n        \t\tmenu.setTag(kTagMenu);\n\n        \t\taddChild(menu, 0, 100+i);\n        \t\tcenteredMenu = menu.getPosition();"}
{"magic_number_smell": "            CGSize s = CCDirector.sharedDirector().winSize();\n\n            CCLabel label = CCLabel.makeLabel(title(), \"DroidSans\", 18);\n            addChild(label, 1);\n            label.setPosition(CGPoint.make(s.width / 2, s.height / 2 - 50));\n\n            CCMenuItemImage item1 = CCMenuItemImage.item(\"b1.png\", \"b2.png\", this, \"backCallback\");", "refactored_code": "    public static final int kTagLabel = 1;\n            CGSize s = CCDirector.sharedDirector().winSize();\n\n            CCLabel label = CCLabel.makeLabel(title(), \"DroidSans\", 18);\n            addChild(label, kTagLabel);\n            label.setPosition(CGPoint.make(s.width / 2, s.height / 2 - 50));\n\n            CCMenuItemImage item1 = CCMenuItemImage.item(\"b1.png\", \"b2.png\", this, \"backCallback\");"}
{"magic_number_smell": "\n            CGPoint diff = CGPoint.ccpSub(touchLocation, prevLocation);\n\n            CCNode node = getChildByTag(1);\n            CGPoint currentPos = node.getPosition();\n            node.setPosition(CGPoint.ccpAdd(currentPos, diff));\n            return true;", "refactored_code": "    public static final int kTagTileMap = 1;\n\n            CGPoint diff = CGPoint.ccpSub(touchLocation, prevLocation);\n\n            CCNode node = getChildByTag(kTagTileMap);\n            CGPoint currentPos = node.getPosition();\n            node.setPosition(CGPoint.ccpAdd(currentPos, diff));\n            return true;"}
{"magic_number_smell": "\n\t\t\ttry {\n\t\t\t\tConstructor<?> c = transition.getConstructor(Float.TYPE, CCScene.class);\n\t\t\t\tCCScene s = (CCScene) c.newInstance(1.2f, s2);\n\t\t\t\tCCDirector.sharedDirector().replaceScene(s);\n\t\t\t} catch (SecurityException e) {\n\t\t\t\t// TODO Auto-generated catch block", "refactored_code": "\tprivate static final float TRANSITION_DURATION = 1.2f;\n\n\t\t\ttry {\n\t\t\t\tConstructor<?> c = transition.getConstructor(Float.TYPE, CCScene.class);\n\t\t\t\tCCScene s = (CCScene) c.newInstance(TRANSITION_DURATION, s2);\n\t\t\t\tCCDirector.sharedDirector().replaceScene(s);\n\t\t\t} catch (SecurityException e) {\n\t\t\t\t// TODO Auto-generated catch block"}
{"magic_number_smell": "\t\toutNode.runAction(layerAction);\n\n\t\t// add the layer (which contains our two rendertextures) to the scene\n\t\taddChild(outNode, 2, 0xc001);\n\t}\n\n\t// clean up on exit", "refactored_code": "\tprotected static final int kSceneRadial = 0xc001;\n\t\toutNode.runAction(layerAction);\n\n\t\t// add the layer (which contains our two rendertextures) to the scene\n\t\taddChild(outNode, 2, kSceneRadial);\n\t}\n\n\t// clean up on exit"}
{"magic_number_smell": "     */\n    protected void initScenes() {\n        CGSize s = CCDirector.sharedDirector().winSize();\n        inScene.setPosition(-(s.width-0.5f), 0);\n    }\n\n\t/**", "refactored_code": "    protected static final float ADJUST_FACTOR = 0.5f;\n     */\n    protected void initScenes() {\n        CGSize s = CCDirector.sharedDirector().winSize();\n        inScene.setPosition(-(s.width-ADJUST_FACTOR), 0);\n    }\n\n\t/**"}
{"magic_number_smell": "      */\n    public static float ccpAngle(CGPoint a, CGPoint b) {\n        float angle = (float)Math.acos(ccpDot(ccpNormalize(a), ccpNormalize(b)));\n        if( Math.abs(angle) < 0.00000012f ) return 0.f;\n        return angle;\n    }\n", "refactored_code": "    private static final float kCGPointEpsilon = 0.00000012f; \n      */\n    public static float ccpAngle(CGPoint a, CGPoint b) {\n        float angle = (float)Math.acos(ccpDot(ccpNormalize(a), ccpNormalize(b)));\n        if( Math.abs(angle) < kCGPointEpsilon ) return 0.f;\n        return angle;\n    }\n"}
{"magic_number_smell": "\tprivate static BufferProvider global_synced = new BufferProvider();\n\t\n\tpublic ByteBuffer allocate(int size) {\n\t\tif(size >= 1024 * 1024)\n\t\t\treturn ByteBuffer.allocateDirect(size);\n\n\t\tif(currentBuffer == null || size > currentBuffer.remaining())", "refactored_code": "\tprivate static final int ALLOCATION_SIZE = 1024 * 1024;\n\tprivate static BufferProvider global_synced = new BufferProvider();\n\t\n\tpublic ByteBuffer allocate(int size) {\n\t\tif(size >= ALLOCATION_SIZE)\n\t\t\treturn ByteBuffer.allocateDirect(size);\n\n\t\tif(currentBuffer == null || size > currentBuffer.remaining())"}
{"magic_number_smell": "\t\n\tprivate String currentKey;\n\t\n\tprivate int currentElement = 0;\n\t\n\tprivate int currentCollectionType = COLL_UNKNOWN;\n\t", "refactored_code": "\tprivate static final int TYPE_UNKNOWN\t = 0;\n\t\n\tprivate String currentKey;\n\t\n\tprivate int currentElement = TYPE_UNKNOWN;\n\t\n\tprivate int currentCollectionType = COLL_UNKNOWN;\n\t"}
{"magic_number_smell": "                int shift = 63 - MathLib.bitLength(x1);\n                x1 <<= shift;\n                x1 |= x0 >>> (63 - shift);\n                x0 = (x0 << shift) & 0x7FFFFFFFFFFFFFFFL;\n                pow2 -= shift;\n\n                // Checks if division has to be performed.", "refactored_code": "    private static final long MASK_63 = 0x7FFFFFFFFFFFFFFFL;\n                int shift = 63 - MathLib.bitLength(x1);\n                x1 <<= shift;\n                x1 |= x0 >>> (63 - shift);\n                x0 = (x0 << shift) & MASK_63;\n                pow2 -= shift;\n\n                // Checks if division has to be performed."}
{"magic_number_smell": "\t// We do a full resize (and copy) only when the capacity is less than C1.\n    // For large collections, multi-dimensional arrays are employed.\n    private static final int 5 = 5; // Initial capacity in bits.\n    private static final int C0 = 1 << 5; // Initial capacity (32)\n    private static final int B1 = 10; // Low array maximum capacity in bits.\n    private static final int C1 = 1 << B1; // Low array maximum capacity (1024).\n    private static final int M1 = C1 - 1; // Mask.", "refactored_code": "    private static final int B0 = 5; // Initial capacity in bits.\n\t// We do a full resize (and copy) only when the capacity is less than C1.\n    // For large collections, multi-dimensional arrays are employed.\n    private static final int B0 = 5; // Initial capacity in bits.\n    private static final int C0 = 1 << B0; // Initial capacity (32)\n    private static final int B1 = 10; // Low array maximum capacity in bits.\n    private static final int C1 = 1 << B1; // Low array maximum capacity (1024).\n    private static final int M1 = C1 - 1; // Mask."}
{"magic_number_smell": "            m_proxyPool[i] = new Proxy();\n            m_proxyPool[i].setNext(i + 1);\n            m_proxyPool[i].timeStamp = 0;\n            m_proxyPool[i].overlapCount = Integer.MAX_VALUE;\n            m_proxyPool[i].userData = null;\n        }\n", "refactored_code": "    public static final int INVALID = Integer.MAX_VALUE;\n            m_proxyPool[i] = new Proxy();\n            m_proxyPool[i].setNext(i + 1);\n            m_proxyPool[i].timeStamp = 0;\n            m_proxyPool[i].overlapCount = INVALID;\n            m_proxyPool[i].userData = null;\n        }\n"}
{"magic_number_smell": "    }\n\n    public void setBuffered() {\n        status |= 0x0001;\n    }\n\n    public void clearBuffered() {", "refactored_code": "    private static final int PAIR_BUFFERED = 0x0001;\n    }\n\n    public void setBuffered() {\n        status |= PAIR_BUFFERED;\n    }\n\n    public void clearBuffered() {"}
{"magic_number_smell": "        assert TABLE_CAPACITY >= Settings.maxPairs;\n\n        for (int i = 0; i < TABLE_CAPACITY; ++i) {\n            m_hashTable[i] = Integer.MAX_VALUE;\n        }\n        m_freePair = 0;\n        for (int i = 0; i < Settings.maxPairs; ++i) {", "refactored_code": "    public static final int NULL_PAIR = Integer.MAX_VALUE;\n        assert TABLE_CAPACITY >= Settings.maxPairs;\n\n        for (int i = 0; i < TABLE_CAPACITY; ++i) {\n            m_hashTable[i] = NULL_PAIR;\n        }\n        m_freePair = 0;\n        for (int i = 0; i < Settings.maxPairs; ++i) {"}
{"magic_number_smell": "\t\t}\n\n\t\tif (freeze == true) {\n\t\t\tm_flags |= 0x0002;\n\t\t\tm_linearVelocity.setZero();\n\t\t\tm_angularVelocity = 0.0f;\n\t\t\tfor (Shape s = m_shapeList; s != null; s = s.m_next) {", "refactored_code": "\tpublic static final int e_frozenFlag = 0x0002;\n\t\t}\n\n\t\tif (freeze == true) {\n\t\t\tm_flags |= e_frozenFlag;\n\t\t\tm_linearVelocity.setZero();\n\t\t\tm_angularVelocity = 0.0f;\n\t\t\tfor (Shape s = m_shapeList; s != null; s = s.m_next) {"}
{"magic_number_smell": "    }\n    \n    public boolean isSolid() {\n    \treturn (m_flags & 0x0001) == 0;\n    }\n\t\n    ", "refactored_code": "\tpublic static final int e_nonSolidFlag\t= 0x0001;\n    }\n    \n    public boolean isSolid() {\n    \treturn (m_flags & e_nonSolidFlag) == 0;\n    }\n\t\n    "}
{"magic_number_smell": "\n    \tm_constant = def.length1 + m_ratio * def.length2;\n\n    \tm_maxLength1 = Math.min(def.maxLength1, m_constant - m_ratio * 2.0f);\n    \tm_maxLength2 = Math.min(def.maxLength2, (m_constant - 2.0f) / m_ratio);\n\n    \tm_force = 0.0f;", "refactored_code": "    public static final float MIN_PULLEY_LENGTH = 2.0f;//Settings.lengthUnitsPerMeter;\n\n    \tm_constant = def.length1 + m_ratio * def.length2;\n\n    \tm_maxLength1 = Math.min(def.maxLength1, m_constant - m_ratio * MIN_PULLEY_LENGTH);\n    \tm_maxLength2 = Math.min(def.maxLength2, (m_constant - MIN_PULLEY_LENGTH) / m_ratio);\n\n    \tm_force = 0.0f;"}
{"magic_number_smell": "\t\t\tsd2.localPosition.set(0.5f, 0.5f);\n\t\t\tsd2.density = 0.0f; // massless\n\n\t\t\tfor (int i = 0; i < 100; ++i)\n\t\t\t{\n\t\t\t\tfloat x = parent.random(-0.1f, 0.1f);\n\t\t\t\tBodyDef bd = new BodyDef();", "refactored_code": "\tprivate final int stackHeight = 100;\n\t\t\tsd2.localPosition.set(0.5f, 0.5f);\n\t\t\tsd2.density = 0.0f; // massless\n\n\t\t\tfor (int i = 0; i < stackHeight; ++i)\n\t\t\t{\n\t\t\t\tfloat x = parent.random(-0.1f, 0.1f);\n\t\t\t\tBodyDef bd = new BodyDef();"}
{"magic_number_smell": "\t@Override\n\tpublic void create() {\n\t\tactiveMouseStroke = false;\n\t\tmouseStroke = new Vec2[1000];\n\t\tfor (int i=0; i<mouseStroke.length; ++i) {\n\t\t\tmouseStroke[i] = new Vec2();\n\t\t}", "refactored_code": "\tprivate final int mouseStrokeMaxLength = 1000;\n\t@Override\n\tpublic void create() {\n\t\tactiveMouseStroke = false;\n\t\tmouseStroke = new Vec2[mouseStrokeMaxLength];\n\t\tfor (int i=0; i<mouseStroke.length; ++i) {\n\t\t\tmouseStroke[i] = new Vec2();\n\t\t}"}
{"magic_number_smell": "\n    static {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 132; i++) {\n            sb.append(\"-\");\n        }\n        RULER = sb.toString();", "refactored_code": "    private static final int LINE_WIDTH = 132;\n\n    static {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < LINE_WIDTH; i++) {\n            sb.append(\"-\");\n        }\n        RULER = sb.toString();"}
{"magic_number_smell": "                    if (array == null) {\n                        throw new OozieClientException(\"HTTP error\", \"no response message\");\n                    }\n                    if (!array.contains(WS_PROTOCOL_VERSION) && !array.contains(0)) {\n                        StringBuilder msg = new StringBuilder();\n                        msg.append(\"Supported version [\").append(WS_PROTOCOL_VERSION).append(\n                                \"] or less, Unsupported versions[\");", "refactored_code": "    public static final long WS_PROTOCOL_VERSION_0 = 0;\n                    if (array == null) {\n                        throw new OozieClientException(\"HTTP error\", \"no response message\");\n                    }\n                    if (!array.contains(WS_PROTOCOL_VERSION) && !array.contains(WS_PROTOCOL_VERSION_0)) {\n                        StringBuilder msg = new StringBuilder();\n                        msg.append(\"Supported version [\").append(WS_PROTOCOL_VERSION).append(\n                                \"] or less, Unsupported versions[\");"}
{"magic_number_smell": "        XCallable<Void> command = null;\n\n        if (useXCommand) {\n            command = new CompletedActionXCommand(actionId, externalStatus, actionData, 2);\n        }\n        else {\n            command = new CompletedActionCommand(actionId, externalStatus, actionData, 2);", "refactored_code": "    private static final int HIGH_PRIORITY = 2;\n        XCallable<Void> command = null;\n\n        if (useXCommand) {\n            command = new CompletedActionXCommand(actionId, externalStatus, actionData, HIGH_PRIORITY);\n        }\n        else {\n            command = new CompletedActionCommand(actionId, externalStatus, actionData, HIGH_PRIORITY);"}
{"magic_number_smell": "     * @param type action executor type.\n     */\n    protected ActionExecutor(String type) {\n        this(type, 3, RETRY_INTERVAL);\n    }\n\n    /**", "refactored_code": "    public static final int MAX_RETRIES = 3;\n     * @param type action executor type.\n     */\n    protected ActionExecutor(String type) {\n        this(type, MAX_RETRIES, RETRY_INTERVAL);\n    }\n\n    /**"}
{"magic_number_smell": "            XLog.getLog(getClass()).warn(\"lock(): Id is null or empty :\" + id + \":\");\n            return false;\n        }\n        LockToken token = Services.get().get(MemoryLocksService.class).getWriteLock(id, 1000);\n        if (token != null) {\n            locks.add(token);\n            return true;", "refactored_code": "    private static final long LOCK_TIMEOUT = 1000;\n            XLog.getLog(getClass()).warn(\"lock(): Id is null or empty :\" + id + \":\");\n            return false;\n        }\n        LockToken token = Services.get().get(MemoryLocksService.class).getWriteLock(id, LOCK_TIMEOUT);\n        if (token != null) {\n            locks.add(token);\n            return true;"}
{"magic_number_smell": "        Date currentTime = new Date();\n        if (nominalTime.compareTo(currentTime) > 0) {\n            queue(new CoordActionInputCheckXCommand(coordAction.getId()), Math.max(\n                    (nominalTime.getTime() - currentTime.getTime()), 60000));\n            // update lastModifiedTime\n            coordAction.setLastModifiedTime(new Date());\n            try {", "refactored_code": "    private final int COMMAND_REQUEUE_INTERVAL = 60000; // 1 minute\n        Date currentTime = new Date();\n        if (nominalTime.compareTo(currentTime) > 0) {\n            queue(new CoordActionInputCheckXCommand(coordAction.getId()), Math.max(\n                    (nominalTime.getTime() - currentTime.getTime()), COMMAND_REQUEUE_INTERVAL));\n            // update lastModifiedTime\n            coordAction.setLastModifiedTime(new Date());\n            try {"}
{"magic_number_smell": "        if (startTime == null) {\n            startTime = coordJob.getStartTimestamp();\n            \n            if (startTime.after(new Timestamp(System.currentTimeMillis() + 300 * 1000))) {\n                log.debug(\"CoordJobMatLookupCommand for jobId=\" + jobId + \" job's start time is not reached yet - nothing to materialize\");\n                return null;\n            }", "refactored_code": "    private static final int LOOKAHEAD_WINDOW = 300; // We look ahead 5 minutes for materialization;\n        if (startTime == null) {\n            startTime = coordJob.getStartTimestamp();\n            \n            if (startTime.after(new Timestamp(System.currentTimeMillis() + LOOKAHEAD_WINDOW * 1000))) {\n                log.debug(\"CoordJobMatLookupCommand for jobId=\" + jobId + \" job's start time is not reached yet - nothing to materialize\");\n                return null;\n            }"}
{"magic_number_smell": "        if (startTime == null) {\n            startTime = coordJob.getStartTimestamp();\n\n            if (startTime.after(new Timestamp(System.currentTimeMillis() + 300 * 1000))) {\n                throw new PreconditionException(ErrorCode.E1100, \"CoordMaterializeTransitionXCommand for jobId=\"\n                        + jobId + \" job's start time is not reached yet - nothing to materialize\");\n            }", "refactored_code": "    private static final int LOOKAHEAD_WINDOW = 300; // We look ahead 5 minutes for materialization;\n        if (startTime == null) {\n            startTime = coordJob.getStartTimestamp();\n\n            if (startTime.after(new Timestamp(System.currentTimeMillis() + LOOKAHEAD_WINDOW * 1000))) {\n                throw new PreconditionException(ErrorCode.E1100, \"CoordMaterializeTransitionXCommand for jobId=\"\n                        + jobId + \" job's start time is not reached yet - nothing to materialize\");\n            }"}
{"magic_number_smell": "    /**\n     * Constructor used to retrieve WF Job\n     * @param id wf jobId\n     * @param 1 starting index in the list of actions belonging to the job\n     * @param length number of actions to be returned\n     */\n    public JobXCommand(String id, int 1, int length) {", "refactored_code": "    private final int start = 1;\n    /**\n     * Constructor used to retrieve WF Job\n     * @param id wf jobId\n     * @param start starting index in the list of actions belonging to the job\n     * @param length number of actions to be returned\n     */\n    public JobXCommand(String id, int start, int length) {"}
{"magic_number_smell": "    public List<BundleJobBean> execute(EntityManager em) throws JPAExecutorException {\n        List<BundleJobBean> bundleJobs = null;\n        try {\n            Timestamp lastModTm = new Timestamp(System.currentTimeMillis() - (olderThanDays * 24 * 60 * 60 * 1000));\n            Query jobQ = em.createNamedQuery(\"GET_COMPLETED_BUNDLE_JOBS_OLDER_THAN\");\n            jobQ.setParameter(\"lastModTime\", lastModTm);\n            jobQ.setMaxResults(limit);", "refactored_code": "    private static final long DAY_IN_MS = 24 * 60 * 60 * 1000;\n    public List<BundleJobBean> execute(EntityManager em) throws JPAExecutorException {\n        List<BundleJobBean> bundleJobs = null;\n        try {\n            Timestamp lastModTm = new Timestamp(System.currentTimeMillis() - (olderThanDays * DAY_IN_MS));\n            Query jobQ = em.createNamedQuery(\"GET_COMPLETED_BUNDLE_JOBS_OLDER_THAN\");\n            jobQ.setParameter(\"lastModTime\", lastModTm);\n            jobQ.setMaxResults(limit);"}
{"magic_number_smell": "    public List<CoordinatorJobBean> execute(EntityManager em) throws JPAExecutorException {\n        List<CoordinatorJobBean> coordJobs = null;\n        try {\n            Timestamp lastModTm = new Timestamp(System.currentTimeMillis() - (olderThanDays * 24 * 60 * 60 * 1000));\n            Query jobQ = em.createNamedQuery(\"GET_COMPLETED_COORD_JOBS_OLDER_THAN_STATUS\");\n            jobQ.setParameter(\"lastModTime\", lastModTm);\n            jobQ.setMaxResults(limit);", "refactored_code": "    private static final long DAY_IN_MS = 24 * 60 * 60 * 1000;\n    public List<CoordinatorJobBean> execute(EntityManager em) throws JPAExecutorException {\n        List<CoordinatorJobBean> coordJobs = null;\n        try {\n            Timestamp lastModTm = new Timestamp(System.currentTimeMillis() - (olderThanDays * DAY_IN_MS));\n            Query jobQ = em.createNamedQuery(\"GET_COMPLETED_COORD_JOBS_OLDER_THAN_STATUS\");\n            jobQ.setParameter(\"lastModTime\", lastModTm);\n            jobQ.setMaxResults(limit);"}
{"magic_number_smell": "    public List<WorkflowJobBean> execute(EntityManager em) throws JPAExecutorException {\n        List<WorkflowJobBean> workflows = null;\n        try {\n            Timestamp maxEndTime = new Timestamp(System.currentTimeMillis() - (olderThanDays * 24 * 60 * 60 * 1000));\n            Query jobQ = em.createNamedQuery(\"GET_COMPLETED_WORKFLOWS_OLDER_THAN\");\n            jobQ.setParameter(\"endTime\", maxEndTime);\n            jobQ.setMaxResults(limit);", "refactored_code": "    private static final long DAY_IN_MS = 24 * 60 * 60 * 1000;\n    public List<WorkflowJobBean> execute(EntityManager em) throws JPAExecutorException {\n        List<WorkflowJobBean> workflows = null;\n        try {\n            Timestamp maxEndTime = new Timestamp(System.currentTimeMillis() - (olderThanDays * DAY_IN_MS));\n            Query jobQ = em.createNamedQuery(\"GET_COMPLETED_WORKFLOWS_OLDER_THAN\");\n            jobQ.setParameter(\"endTime\", maxEndTime);\n            jobQ.setMaxResults(limit);"}
{"magic_number_smell": "                }\n                else {\n                    log.warn(\"max concurrency for callable [{0}] exceeded, requeueing with [{1}]ms delay\", callable\n                            .getType(), 500);\n                    setDelay(500, TimeUnit.MILLISECONDS);\n                    removeFromUniqueCallables();\n                    queue(this, true);", "refactored_code": "    public static final int CONCURRENCY_DELAY = 500;\n                }\n                else {\n                    log.warn(\"max concurrency for callable [{0}] exceeded, requeueing with [{1}]ms delay\", callable\n                            .getType(), CONCURRENCY_DELAY);\n                    setDelay(CONCURRENCY_DELAY, TimeUnit.MILLISECONDS);\n                    removeFromUniqueCallables();\n                    queue(this, true);"}
{"magic_number_smell": "            try {\n\n                // get current date\n                Date currDate = new Date(new Date().getTime() + 300 * 1000);\n                // get list of all jobs that have actions that should be materialized.\n                CoordJobsToBeMaterializedJPAExecutor cmatcmd = new CoordJobsToBeMaterializedJPAExecutor(currDate, 50);\n                List<CoordinatorJobBean> materializeJobs = jpaService.execute(cmatcmd);", "refactored_code": "    private static final int CONF_LOOKUP_INTERVAL_DEFAULT = 300;\n            try {\n\n                // get current date\n                Date currDate = new Date(new Date().getTime() + CONF_LOOKUP_INTERVAL_DEFAULT * 1000);\n                // get list of all jobs that have actions that should be materialized.\n                CoordJobsToBeMaterializedJPAExecutor cmatcmd = new CoordJobsToBeMaterializedJPAExecutor(currDate, 50);\n                List<CoordinatorJobBean> materializeJobs = jpaService.execute(cmatcmd);"}
{"magic_number_smell": "        setServiceInternal(ConfigurationService.class, true);\n        conf = get(ConfigurationService.class).getConf();\n        systemId = conf.get(CONF_SYSTEM_ID, (\"oozie-\" + System.getProperty(\"user.name\")));\n        if (systemId.length() > 10) {\n            systemId = systemId.substring(0, 10);\n            XLog.getLog(getClass()).warn(\"System ID [{0}] exceeds maximum length [{1}], trimming\", systemId,\n                                         10);", "refactored_code": "    private static final int MAX_SYSTEM_ID_LEN = 10;\n        setServiceInternal(ConfigurationService.class, true);\n        conf = get(ConfigurationService.class).getConf();\n        systemId = conf.get(CONF_SYSTEM_ID, (\"oozie-\" + System.getProperty(\"user.name\")));\n        if (systemId.length() > MAX_SYSTEM_ID_LEN) {\n            systemId = systemId.substring(0, MAX_SYSTEM_ID_LEN);\n            XLog.getLog(getClass()).warn(\"System ID [{0}] exceeds maximum length [{1}], trimming\", systemId,\n                                         MAX_SYSTEM_ID_LEN);"}
{"magic_number_smell": "    public static final long 1024 = 1024;\n\n    /**\n     * MegaByte constant (1024 1024). Defined for EL as 'MB'.\n     */\n    public static final long MB = 1024 * 1024;\n", "refactored_code": "    public static final long KB = 1024;\n    public static final long KB = 1024;\n\n    /**\n     * MegaByte constant (1024 KB). Defined for EL as 'MB'.\n     */\n    public static final long MB = KB * 1024;\n"}
{"magic_number_smell": "     */\n    public static String validateActionName(String actionName) {\n        ParamChecker.notEmpty(actionName, \"action name\");\n        if (actionName.length() > 50) {\n            throw new IllegalArgumentException(XLog.format(\"name [{0}] must be {1} chars or less\", actionName,\n                                                           50));\n        }", "refactored_code": "    private static final int MAX_NODE_NAME_LEN = 50;\n     */\n    public static String validateActionName(String actionName) {\n        ParamChecker.notEmpty(actionName, \"action name\");\n        if (actionName.length() > MAX_NODE_NAME_LEN) {\n            throw new IllegalArgumentException(XLog.format(\"name [{0}] must be {1} chars or less\", actionName,\n                                                           MAX_NODE_NAME_LEN));\n        }"}
{"magic_number_smell": "    }\n\n    /**\n     * Run the anti-starvation check every {@link #500} milliseconds.\n     * <p/>\n     * It promotes elements beyond max wait time to the next higher priority sub-queue.\n     */", "refactored_code": "    public static final long ANTI_STARVATION_INTERVAL = 500;\n    }\n\n    /**\n     * Run the anti-starvation check every {@link #ANTI_STARVATION_INTERVAL} milliseconds.\n     * <p/>\n     * It promotes elements beyond max wait time to the next higher priority sub-queue.\n     */"}
{"magic_number_smell": "     */\n    public static final int OPS = 4;\n\n    private static final int ALL = 1 | OPS;\n\n    private static final int[] LOGGER_MASKS = {1, OPS};\n", "refactored_code": "    public static final int STD = 1;\n     */\n    public static final int OPS = 4;\n\n    private static final int ALL = STD | OPS;\n\n    private static final int[] LOGGER_MASKS = {STD, OPS};\n"}
{"magic_number_smell": "\n        final OozieClient oozieClient = subWorkflow.getWorkflowClient(new Context(workflow, action),\n                                                                      SubWorkflowActionExecutor.LOCAL);\n        waitFor(100 * 1000, new Predicate() {\n            public boolean evaluate() throws Exception {\n                return oozieClient.getJobInfo(action.getExternalId()).getStatus() == WorkflowJob.Status.SUCCEEDED;\n            }", "refactored_code": "    private static final int JOB_TIMEOUT = 100 * 1000;\n\n        final OozieClient oozieClient = subWorkflow.getWorkflowClient(new Context(workflow, action),\n                                                                      SubWorkflowActionExecutor.LOCAL);\n        waitFor(JOB_TIMEOUT, new Predicate() {\n            public boolean evaluate() throws Exception {\n                return oozieClient.getJobInfo(action.getExternalId()).getStatus() == WorkflowJob.Status.SUCCEEDED;\n            }"}
{"magic_number_smell": "        conf.set(OozieClient.GROUP_NAME, getTestGroup());\n        injectKerberosInfo(conf);\n        WorkflowJobBean wfBean = createWorkflow(app, conf, \"auth\", jobStatus, instanceStatus);\n        Timestamp startTS = new Timestamp(System.currentTimeMillis() - (3 * 24 * 60 * 60 * 1000));\n        Timestamp endTS = new Timestamp(System.currentTimeMillis() - (2 * 24 * 60 * 60 * 1000));\n        wfBean.setStartTime(DateUtils.toDate(startTS));\n        wfBean.setEndTime(DateUtils.toDate(endTS));", "refactored_code": "    private static final long DAY_IN_MS = 24 * 60 * 60 * 1000;\n        conf.set(OozieClient.GROUP_NAME, getTestGroup());\n        injectKerberosInfo(conf);\n        WorkflowJobBean wfBean = createWorkflow(app, conf, \"auth\", jobStatus, instanceStatus);\n        Timestamp startTS = new Timestamp(System.currentTimeMillis() - (3 * DAY_IN_MS));\n        Timestamp endTS = new Timestamp(System.currentTimeMillis() - (2 * DAY_IN_MS));\n        wfBean.setStartTime(DateUtils.toDate(startTS));\n        wfBean.setEndTime(DateUtils.toDate(endTS));"}
{"magic_number_smell": "        did = null;\n        coordJobs = new ArrayList<CoordinatorJob>();\n        started = new ArrayList<Boolean>();\n        for (int i = 0; i < 4; i++) {\n            coordJobs.add(createDummyCoordinatorJob(i));\n            started.add(false);\n        }", "refactored_code": "    public static final int INIT_COORD_COUNT = 4;\n        did = null;\n        coordJobs = new ArrayList<CoordinatorJob>();\n        started = new ArrayList<Boolean>();\n        for (int i = 0; i < INIT_COORD_COUNT; i++) {\n            coordJobs.add(createDummyCoordinatorJob(i));\n            started.add(false);\n        }"}
{"magic_number_smell": "        properties = null;\n        workflows = new ArrayList<WorkflowJob>();\n        started = new ArrayList<Boolean>();\n        for (int i = 0; i < 4; i++) {\n            workflows.add(createDummyWorkflow(i));\n            started.add(false);\n        }", "refactored_code": "    public static final int INIT_WF_COUNT = 4;\n        properties = null;\n        workflows = new ArrayList<WorkflowJob>();\n        started = new ArrayList<Boolean>();\n        for (int i = 0; i < INIT_WF_COUNT; i++) {\n            workflows.add(createDummyWorkflow(i));\n            started.add(false);\n        }"}
{"magic_number_smell": "\n        cron.start();\n        long s = System.currentTimeMillis();\n        Thread.sleep(300);\n        cron.stop();\n        long realOwnDelay = System.currentTimeMillis() - s;\n        long now = System.currentTimeMillis();", "refactored_code": "    private static final long INTERVAL = 300;\n\n        cron.start();\n        long s = System.currentTimeMillis();\n        Thread.sleep(INTERVAL);\n        cron.stop();\n        long realOwnDelay = System.currentTimeMillis() - s;\n        long now = System.currentTimeMillis();"}
{"magic_number_smell": "    public HttpResponse(byte[] response) throws ProtocolException, IOException {\n\n        PushbackInputStream in = // process response\n        new PushbackInputStream(new ByteArrayInputStream(response), 8 * 1024);\n\n        StringBuilder line = new StringBuilder();\n", "refactored_code": "    public static final int BUFFER_SIZE = 8 * 1024;\n    public HttpResponse(byte[] response) throws ProtocolException, IOException {\n\n        PushbackInputStream in = // process response\n        new PushbackInputStream(new ByteArrayInputStream(response), BUFFER_SIZE);\n\n        StringBuilder line = new StringBuilder();\n"}
{"magic_number_smell": "        while (!isConnected() && !shutdown) {\n            logger.info(\"Not connected to {}, waiting for {} second(s)\", serverName, interval);\n            waitFor(interval);\n            if (interval < 64) {\n                interval = interval * 2;\n            }\n        }", "refactored_code": "    private static final int MAX_WAIT_TIME = 64;\n        while (!isConnected() && !shutdown) {\n            logger.info(\"Not connected to {}, waiting for {} second(s)\", serverName, interval);\n            waitFor(interval);\n            if (interval < MAX_WAIT_TIME) {\n                interval = interval * 2;\n            }\n        }"}
{"magic_number_smell": "                                gerritSshPort,\n                                gerritProxy,\n                                new Authentication(file, gerritUserName, password));\n                        ExecutorService service = Executors.newFixedThreadPool(1);\n                        Future<Integer> future = service.submit(new Callable<Integer>() {\n                            @Override\n                            public Integer call() throws Exception {", "refactored_code": "    private static final int THREADS_FOR_TEST_CONNECTION = 1;\n                                gerritSshPort,\n                                gerritProxy,\n                                new Authentication(file, gerritUserName, password));\n                        ExecutorService service = Executors.newFixedThreadPool(THREADS_FOR_TEST_CONNECTION);\n                        Future<Integer> future = service.submit(new Callable<Integer>() {\n                            @Override\n                            public Integer call() throws Exception {"}
{"magic_number_smell": "     */\n    private void setVoteValues(JSONObject formData) {\n        if (formData.isEmpty()) {\n            gerritBuildStartedVerifiedValue = 0;\n            gerritBuildSuccessfulVerifiedValue = DEFAULT_GERRIT_BUILD_SUCCESSFUL_VERIFIED_VALUE;\n            gerritBuildFailedVerifiedValue = DEFAULT_GERRIT_BUILD_FAILURE_VERIFIED_VALUE;\n            gerritBuildUnstableVerifiedValue = DEFAULT_GERRIT_BUILD_UNSTABLE_VERIFIED_VALUE;", "refactored_code": "    public static final int DEFAULT_GERRIT_BUILD_STARTED_VERIFIED_VALUE = 0;\n     */\n    private void setVoteValues(JSONObject formData) {\n        if (formData.isEmpty()) {\n            gerritBuildStartedVerifiedValue = DEFAULT_GERRIT_BUILD_STARTED_VERIFIED_VALUE;\n            gerritBuildSuccessfulVerifiedValue = DEFAULT_GERRIT_BUILD_SUCCESSFUL_VERIFIED_VALUE;\n            gerritBuildFailedVerifiedValue = DEFAULT_GERRIT_BUILD_FAILURE_VERIFIED_VALUE;\n            gerritBuildUnstableVerifiedValue = DEFAULT_GERRIT_BUILD_UNSTABLE_VERIFIED_VALUE;"}
{"magic_number_smell": "    public void setValues(JSONObject formData) {\n        numberOfReceivingWorkerThreads = formData.optInt(\n                \"numberOfReceivingWorkerThreads\",\n                3);\n        if (numberOfReceivingWorkerThreads <= 0) {\n            numberOfReceivingWorkerThreads = 3;\n        }", "refactored_code": "    public static final int DEFAULT_NR_OF_RECEIVING_WORKER_THREADS = 3;\n    public void setValues(JSONObject formData) {\n        numberOfReceivingWorkerThreads = formData.optInt(\n                \"numberOfReceivingWorkerThreads\",\n                DEFAULT_NR_OF_RECEIVING_WORKER_THREADS);\n        if (numberOfReceivingWorkerThreads <= 0) {\n            numberOfReceivingWorkerThreads = DEFAULT_NR_OF_RECEIVING_WORKER_THREADS;\n        }"}
{"magic_number_smell": "                    if (trigger != null) {\n                        out.println(\"    - Trigger on: \");\n                        List<GerritProject> projects = trigger.getGerritProjects();\n                        for (int i = 0; i < Math.min(5, projects.size()); i++) {\n                            GerritProject pr = projects.get(i);\n                            out.format(\"        * _%s_: %s%n\", pr.getCompareType().getDisplayName(), pr.getPattern());\n                            List<Branch> branches = pr.getBranches();", "refactored_code": "    private static final int MAX_PROJECT_BRANCH_LIST_LENGTH = 5;\n                    if (trigger != null) {\n                        out.println(\"    - Trigger on: \");\n                        List<GerritProject> projects = trigger.getGerritProjects();\n                        for (int i = 0; i < Math.min(MAX_PROJECT_BRANCH_LIST_LENGTH, projects.size()); i++) {\n                            GerritProject pr = projects.get(i);\n                            out.format(\"        * _%s_: %s%n\", pr.getCompareType().getDisplayName(), pr.getPattern());\n                            List<Branch> branches = pr.getBranches();"}
{"magic_number_smell": "    private Map<String, String> createStandardParameters(Run r, GerritTriggeredEvent gerritEvent,\n            Integer codeReview, Integer verified, String notifyLevel) {\n        //<GERRIT_NAME> <BRANCH> <CHANGE> <PATCHSET> <PATCHSET_REVISION> <REFSPEC> <BUILDURL> VERIFIED CODE_REVIEW\n        Map<String, String> map = new HashMap<String, String>(11);\n        if (gerritEvent instanceof ChangeBasedEvent) {\n            ChangeBasedEvent event = (ChangeBasedEvent)gerritEvent;\n            map.put(\"GERRIT_NAME\", event.getChange().getProject());", "refactored_code": "    public static final int DEFAULT_PARAMETERS_COUNT = 11;\n    private Map<String, String> createStandardParameters(Run r, GerritTriggeredEvent gerritEvent,\n            Integer codeReview, Integer verified, String notifyLevel) {\n        //<GERRIT_NAME> <BRANCH> <CHANGE> <PATCHSET> <PATCHSET_REVISION> <REFSPEC> <BUILDURL> VERIFIED CODE_REVIEW\n        Map<String, String> map = new HashMap<String, String>(DEFAULT_PARAMETERS_COUNT);\n        if (gerritEvent instanceof ChangeBasedEvent) {\n            ChangeBasedEvent event = (ChangeBasedEvent)gerritEvent;\n            map.put(\"GERRIT_NAME\", event.getChange().getProject());"}
{"magic_number_smell": "        // Prepare for fetching the URL\n        URL url = new URL(gerritTriggerConfigUrl);\n        URLConnection connection = url.openConnection();\n        connection.setReadTimeout(10000);\n        connection.setDoInput(true);\n\n        try (InputStream instream = connection.getInputStream();", "refactored_code": "    private static final int SOCKET_READ_TIMEOUT = 10000;\n        // Prepare for fetching the URL\n        URL url = new URL(gerritTriggerConfigUrl);\n        URLConnection connection = url.openConnection();\n        connection.setReadTimeout(SOCKET_READ_TIMEOUT);\n        connection.setDoInput(true);\n\n        try (InputStream instream = connection.getInputStream();"}
{"magic_number_smell": "     * @throws InterruptedException if the thread was interrupted while waiting.\n     */\n    public void waitForProjectListToBeReady() throws InterruptedException {\n        if (!projectListIsReady.await(10, TimeUnit.SECONDS)) {\n            logger.trace(\"Timeout at await\");\n        }\n    }", "refactored_code": "    private static final int DYNAMIC_CONFIG_TIMEOUT_S = 10;\n     * @throws InterruptedException if the thread was interrupted while waiting.\n     */\n    public void waitForProjectListToBeReady() throws InterruptedException {\n        if (!projectListIsReady.await(DYNAMIC_CONFIG_TIMEOUT_S, TimeUnit.SECONDS)) {\n            logger.trace(\"Timeout at await\");\n        }\n    }"}
{"magic_number_smell": "     */\n    private static class GetGerritEventRevision\n            implements BuildChooserContext.ContextCallable<Run<?, ?>, String> {\n        static final long 2003462680723330645L = 0L;\n        @Override\n        public String invoke(Run<?, ?> build, VirtualChannel channel) {\n            GerritCause cause = build.getCause(GerritCause.class);", "refactored_code": "    private static final long serialVersionUID = 2003462680723330645L;\n     */\n    private static class GetGerritEventRevision\n            implements BuildChooserContext.ContextCallable<Run<?, ?>, String> {\n        static final long serialVersionUID = 0L;\n        @Override\n        public String invoke(Run<?, ?> build, VirtualChannel channel) {\n            GerritCause cause = build.getCause(GerritCause.class);"}
{"magic_number_smell": "            logger.debug(\"Schedule task \" + timerTask + \" for every \" + timerPeriod + \"ms\");\n            scheduledTasks.put(timerTask.toString(),\n                               jenkins.util.Timer.get().scheduleWithFixedDelay(\n                                                  timerTask, 5000, timerPeriod,\n                                                            TimeUnit.MILLISECONDS));\n        } catch (IllegalArgumentException iae) {\n            logger.error(\"Attempted use of negative delay\", iae);", "refactored_code": "    protected static final long DELAY_MILLISECONDS = 5000;\n            logger.debug(\"Schedule task \" + timerTask + \" for every \" + timerPeriod + \"ms\");\n            scheduledTasks.put(timerTask.toString(),\n                               jenkins.util.Timer.get().scheduleWithFixedDelay(\n                                                  timerTask, DELAY_MILLISECONDS, timerPeriod,\n                                                            TimeUnit.MILLISECONDS));\n        } catch (IllegalArgumentException iae) {\n            logger.error(\"Attempted use of negative delay\", iae);"}
{"magic_number_smell": "                                                             HashMap<String, JSONObject> indexed) {\n        logger.trace(\"Searching for {}\", rowId);\n        String[] ids = rowId.split(ID_SEPARATOR);\n        if (ids.length >= 3) {\n            logger.debug(\"Correct nr of ids: {}\", ids.length);\n            JSONObject patch = indexed.get(rowId);\n            if (patch != null) {", "refactored_code": "    public static final int EXPECTED_NR_OF_PARTS_IN_A_GENERATED_ID = 3;\n                                                             HashMap<String, JSONObject> indexed) {\n        logger.trace(\"Searching for {}\", rowId);\n        String[] ids = rowId.split(ID_SEPARATOR);\n        if (ids.length >= EXPECTED_NR_OF_PARTS_IN_A_GENERATED_ID) {\n            logger.debug(\"Correct nr of ids: {}\", ids.length);\n            JSONObject patch = indexed.get(rowId);\n            if (patch != null) {"}
{"magic_number_smell": "        super(\"GerritMissedEventsPlaybackEnabledChecker\");\n        recurrencePeriod =\n                Long.getLong(\"com.sonyericsson.hudson.plugins.gerrit.trigger.playback.checkEnabledPeriod\",\n                        TimeUnit.SECONDS.toMillis(86400));\n        logger.debug(\"checkIfEventsLogPluginSupported check period is {0}ms\",\n                recurrencePeriod);\n    }", "refactored_code": "    private static final long DEFAULTCHECKPERIOD = 86400;\n        super(\"GerritMissedEventsPlaybackEnabledChecker\");\n        recurrencePeriod =\n                Long.getLong(\"com.sonyericsson.hudson.plugins.gerrit.trigger.playback.checkEnabledPeriod\",\n                        TimeUnit.SECONDS.toMillis(DEFAULTCHECKPERIOD));\n        logger.debug(\"checkIfEventsLogPluginSupported check period is {0}ms\",\n                recurrencePeriod);\n    }"}
{"magic_number_smell": "        public synchronized void start() {\n            if (!isRunning()) {\n                running.set(true);\n                task = scheduler.scheduleAtFixedRate(this, 0, 1000, TimeUnit.MILLISECONDS);\n            }\n        }\n", "refactored_code": "        private static final long CHECK_INTERVAL = 1000;\n        public synchronized void start() {\n            if (!isRunning()) {\n                running.set(true);\n                task = scheduler.scheduleAtFixedRate(this, 0, CHECK_INTERVAL, TimeUnit.MILLISECONDS);\n            }\n        }\n"}
{"magic_number_smell": "        StopWatch watch = new StopWatch();\n        watch.start();\n        while (!gerritServer.isConnected()) {\n            TimeUnit.SECONDS.sleep(1);\n            if (TimeUnit.MILLISECONDS.toSeconds(watch.getTime()) > MAXSLEEPTIME) {\n                break;\n            }", "refactored_code": "    private static final int SLEEPTIME = 1;\n        StopWatch watch = new StopWatch();\n        watch.start();\n        while (!gerritServer.isConnected()) {\n            TimeUnit.SECONDS.sleep(SLEEPTIME);\n            if (TimeUnit.MILLISECONDS.toSeconds(watch.getTime()) > MAXSLEEPTIME) {\n                break;\n            }"}
{"magic_number_smell": "        try {\n            addNewServerWithDefaultConfigs(gerritServerOneName);\n        } catch (FailingHttpStatusCodeException e) {\n            assertEquals(400, e.getStatusCode());\n        }\n        //make sure the server has not been added.\n        assertEquals(2, PluginImpl.getInstance().getServers().size());", "refactored_code": "    private final int badRequestErrorCode = 400;\n        try {\n            addNewServerWithDefaultConfigs(gerritServerOneName);\n        } catch (FailingHttpStatusCodeException e) {\n            assertEquals(badRequestErrorCode, e.getStatusCode());\n        }\n        //make sure the server has not been added.\n        assertEquals(2, PluginImpl.getInstance().getServers().size());"}
{"magic_number_smell": "    private void waitForConnectedState(GerritServer server) {\n        long startTime = System.currentTimeMillis();\n        while (!server.isConnected()) {\n            assertTrue(System.currentTimeMillis() - startTime < 15000);\n            try {\n                Thread.sleep(CONNECT_SLEEP);\n                // CS IGNORE EmptyBlock FOR NEXT 2 LINES. REASON: not needed.", "refactored_code": "    private static final long CONNECT_TIMEOUT = 15000;\n    private void waitForConnectedState(GerritServer server) {\n        long startTime = System.currentTimeMillis();\n        while (!server.isConnected()) {\n            assertTrue(System.currentTimeMillis() - startTime < CONNECT_TIMEOUT);\n            try {\n                Thread.sleep(CONNECT_SLEEP);\n                // CS IGNORE EmptyBlock FOR NEXT 2 LINES. REASON: not needed."}
{"magic_number_smell": "     */\n    private void waitCompletedBuild(FreeStyleProject project) throws InterruptedException, TimeoutException {\n        long timeStarted = System.currentTimeMillis();\n        long timeoutMs = TimeUnit.SECONDS.toMillis(IntegrationTest.10);\n\n        while (project.getLastCompletedBuild() == null && System.currentTimeMillis() - timeStarted < timeoutMs) {\n            Thread.sleep(POLLING_INTERVAL);", "refactored_code": "    private static final int TIMEOUT = 10;\n     */\n    private void waitCompletedBuild(FreeStyleProject project) throws InterruptedException, TimeoutException {\n        long timeStarted = System.currentTimeMillis();\n        long timeoutMs = TimeUnit.SECONDS.toMillis(IntegrationTest.TIMEOUT);\n\n        while (project.getLastCompletedBuild() == null && System.currentTimeMillis() - timeStarted < timeoutMs) {\n            Thread.sleep(POLLING_INTERVAL);"}
{"magic_number_smell": "     * Extension implementing GerritMessageProvider to provide a custom build message (null).\n     */\n    public static class GerritMessageProviderExtensionReturnNull extends GerritMessageProvider {\n        private static final long -7565217057927807166L = -3479376646924947609L;\n\n        @Override\n        public String getBuildStartedMessage(Run build) {", "refactored_code": "        private static final long serialVersionUID = -7565217057927807166L;\n     * Extension implementing GerritMessageProvider to provide a custom build message (null).\n     */\n    public static class GerritMessageProviderExtensionReturnNull extends GerritMessageProvider {\n        private static final long serialVersionUID = -3479376646924947609L;\n\n        @Override\n        public String getBuildStartedMessage(Run build) {"}
{"magic_number_smell": "        dynamicUrlProcessorMockedStatic\n                .when(() -> GerritDynamicUrlProcessor.fetch(anyString())).thenReturn(gerritProjects1)\n                .thenReturn(gerritProjects2);\n        setRefreshInternal(-1000L);\n\n        List<GerritProject> res1 = DynamicConfigurationCacheProxy.getInstance().fetchThroughCache(\"someUrl\");\n        List<GerritProject> res2 = DynamicConfigurationCacheProxy.getInstance().fetchThroughCache(\"someUrl\");", "refactored_code": "    private static final long REFRESH_INTERVAL_N = -1000L;\n        dynamicUrlProcessorMockedStatic\n                .when(() -> GerritDynamicUrlProcessor.fetch(anyString())).thenReturn(gerritProjects1)\n                .thenReturn(gerritProjects2);\n        setRefreshInternal(REFRESH_INTERVAL_N);\n\n        List<GerritProject> res1 = DynamicConfigurationCacheProxy.getInstance().fetchThroughCache(\"someUrl\");\n        List<GerritProject> res2 = DynamicConfigurationCacheProxy.getInstance().fetchThroughCache(\"someUrl\");"}
{"magic_number_smell": "        runListener.onTriggered(project, event);\n        project.scheduleBuild2(QUIET_PERIOD, gerritCause);\n\n        Item item = waitForBlockedItem(project, 60);\n        Queue queue = jenkinsRule.getInstance().getQueue();\n        queue.doCancelItem(item.getId());\n        assertThat(queue.isEmpty(), equalTo(true));", "refactored_code": "    private static final int TIMEOUT_SECONDS = 60;\n        runListener.onTriggered(project, event);\n        project.scheduleBuild2(QUIET_PERIOD, gerritCause);\n\n        Item item = waitForBlockedItem(project, TIMEOUT_SECONDS);\n        Queue queue = jenkinsRule.getInstance().getQueue();\n        queue.doCancelItem(item.getId());\n        assertThat(queue.isEmpty(), equalTo(true));"}
{"magic_number_smell": "        HtmlForm theSearch = page.getFormByName(\"theSearch\");\n        page = j.submit(theSearch);\n        HtmlTable table = page.getElementByName(\"searchResultTable\");\n        HtmlTableCell verifiedCell = table.getCellAt(FIRST_RESULT_ROW, 10);\n        DomNode child = verifiedCell.getFirstChild();\n        assertThat(child, instanceOf(HtmlSpan.class));\n        assertEquals(\"-1\", child.getTextContent());", "refactored_code": "    private static final int VERIFIED_COLUMN = 10;\n        HtmlForm theSearch = page.getFormByName(\"theSearch\");\n        page = j.submit(theSearch);\n        HtmlTable table = page.getElementByName(\"searchResultTable\");\n        HtmlTableCell verifiedCell = table.getCellAt(FIRST_RESULT_ROW, VERIFIED_COLUMN);\n        DomNode child = verifiedCell.getFirstChild();\n        assertThat(child, instanceOf(HtmlSpan.class));\n        assertEquals(\"-1\", child.getTextContent());"}
{"magic_number_smell": "     * @return the build that started.\n     */\n    public static Run waitForBuildToStart(AtomicReference<Run> reference) {\n        return waitForBuildToStart(reference, 30000);\n    }\n\n", "refactored_code": "    public static final int DEFAULT_WAIT_BUILD_MS = 30000;\n     * @return the build that started.\n     */\n    public static Run waitForBuildToStart(AtomicReference<Run> reference) {\n        return waitForBuildToStart(reference, DEFAULT_WAIT_BUILD_MS);\n    }\n\n"}
{"magic_number_smell": "        server.returnCommandFor(\"gerrit version\", SshdServerMock.EofCommandMock.class);\n        stubFor(get(urlEqualTo(\"/plugins/\" + GerritMissedEventsPlaybackManager.EVENTS_LOG_PLUGIN_NAME + \"/\"))\n                .willReturn(aResponse()\n                        .withStatus(200)\n                        .withHeader(\"Content-Type\", \"text/html\")\n                        .withBody(\"ok\")));\n        stubFor(post(urlMatching(\"/a/changes/.+\"))", "refactored_code": "    private static final int HTTPOK = 200;\n        server.returnCommandFor(\"gerrit version\", SshdServerMock.EofCommandMock.class);\n        stubFor(get(urlEqualTo(\"/plugins/\" + GerritMissedEventsPlaybackManager.EVENTS_LOG_PLUGIN_NAME + \"/\"))\n                .willReturn(aResponse()\n                        .withStatus(HTTPOK)\n                        .withHeader(\"Content-Type\", \"text/html\")\n                        .withBody(\"ok\")));\n        stubFor(post(urlMatching(\"/a/changes/.+\"))"}
{"magic_number_smell": "    public void testPersistTimeStampToFile() {\n\n        Random randomGenerator = new Random();\n        int randomInt = randomGenerator.nextInt(100);\n        GerritMissedEventsPlaybackManager missingEventsPlaybackManager\n                = new GerritMissedEventsPlaybackManager(Integer.valueOf(randomInt).toString() + \"-server\");\n        try {", "refactored_code": "    private static final int MAXRANDOMNUMBER = 100;\n    public void testPersistTimeStampToFile() {\n\n        Random randomGenerator = new Random();\n        int randomInt = randomGenerator.nextInt(MAXRANDOMNUMBER);\n        GerritMissedEventsPlaybackManager missingEventsPlaybackManager\n                = new GerritMissedEventsPlaybackManager(Integer.valueOf(randomInt).toString() + \"-server\");\n        try {"}
{"magic_number_smell": "        patchsetCreated.setReceivedOn(System.currentTimeMillis());\n        missingEventsPlaybackManager.gerritEvent(patchsetCreated);\n        try {\n            Thread.sleep(500);\n        } catch (InterruptedException e) {\n            fail(e.getMessage());\n        }", "refactored_code": "    private static final int SLEEPTIME = 500;\n        patchsetCreated.setReceivedOn(System.currentTimeMillis());\n        missingEventsPlaybackManager.gerritEvent(patchsetCreated);\n        try {\n            Thread.sleep(SLEEPTIME);\n        } catch (InterruptedException e) {\n            fail(e.getMessage());\n        }"}
{"magic_number_smell": "\n        Calendar cal = Calendar.getInstance();\n        cal.setTime(new Date());\n        cal.add(Calendar.HOUR, -8);\n        Date dateBefore8Hours = cal.getTime();\n\n        ChangeMerged changeMerged = Setup.createChangeMergedWithPatchSetDate(\"someGerritServer\", \"someProject\",", "refactored_code": "    private static final int HOURSBEFORECHANGEMERGEDFORPATCHSET = -8;\n\n        Calendar cal = Calendar.getInstance();\n        cal.setTime(new Date());\n        cal.add(Calendar.HOUR, HOURSBEFORECHANGEMERGEDFORPATCHSET);\n        Date dateBefore8Hours = cal.getTime();\n\n        ChangeMerged changeMerged = Setup.createChangeMergedWithPatchSetDate(\"someGerritServer\", \"someProject\","}
{"magic_number_smell": "    public void testTriggerOnCommentAdded() throws Exception {\n        gerritServer.getConfig().setCategories(Setup.createCodeReviewVerdictCategoryList());\n        FreeStyleProject project = DuplicatesUtil.createGerritTriggeredJobForCommentAdded(j, \"projectX\");\n        project.getBuildersList().add(new SleepBuilder(2000));\n        serverMock.waitForCommand(GERRIT_STREAM_EVENTS, 2000);\n        CommentAdded firstEvent = Setup.createCommentAdded();\n        gerritServer.triggerEvent(firstEvent);", "refactored_code": "    private static final int DELAY = 2000;\n    public void testTriggerOnCommentAdded() throws Exception {\n        gerritServer.getConfig().setCategories(Setup.createCodeReviewVerdictCategoryList());\n        FreeStyleProject project = DuplicatesUtil.createGerritTriggeredJobForCommentAdded(j, \"projectX\");\n        project.getBuildersList().add(new SleepBuilder(DELAY));\n        serverMock.waitForCommand(GERRIT_STREAM_EVENTS, DELAY);\n        CommentAdded firstEvent = Setup.createCommentAdded();\n        gerritServer.triggerEvent(firstEvent);"}
{"magic_number_smell": "\t * @return The level.\n\t */\n\tpublic int getAttackLevel() {\n\t\treturn levels[0];\n\t}\n\n\t/**", "refactored_code": "\tprivate static final int ATTACK = 0;\n\t * @return The level.\n\t */\n\tpublic int getAttackLevel() {\n\t\treturn levels[ATTACK];\n\t}\n\n\t/**"}
{"magic_number_smell": "\t * @throws IOException If there is an error reading or decoding the Archive.\n\t */\n\tpublic Map<Integer, MapIndex> decode() throws IOException {\n\t\tArchive archive = fs.getArchive(0, 5);\n\t\tArchiveEntry entry = archive.getEntry(\"map_index\");\n\t\tMap<Integer, MapIndex> definitions = new HashMap<>();\n", "refactored_code": "\tprivate static final int VERSIONS_ARCHIVE_FILE_ID = 5;\n\t * @throws IOException If there is an error reading or decoding the Archive.\n\t */\n\tpublic Map<Integer, MapIndex> decode() throws IOException {\n\t\tArchive archive = fs.getArchive(0, VERSIONS_ARCHIVE_FILE_ID);\n\t\tArchiveEntry entry = archive.getEntry(\"map_index\");\n\t\tMap<Integer, MapIndex> definitions = new HashMap<>();\n"}
{"magic_number_smell": "\t/**\n\t * Starts this SynchronousDecoder.\n\t *\n\t * @throws InterruptedException If a decoder is still running after {@link #15_000} ms.\n\t * @throws SynchronousDecoderException If a decoder failed to complete successfully.\n\t */\n\tpublic void block() throws InterruptedException, SynchronousDecoderException {", "refactored_code": "\tprivate static final int TIMEOUT = 15_000;\n\t/**\n\t * Starts this SynchronousDecoder.\n\t *\n\t * @throws InterruptedException If a decoder is still running after {@link #TIMEOUT} ms.\n\t * @throws SynchronousDecoderException If a decoder failed to complete successfully.\n\t */\n\tpublic void block() throws InterruptedException, SynchronousDecoderException {"}
{"magic_number_smell": "\t\t\t\tTile tile = plane.getTile(x, y);\n\t\t\t\tPosition position = new Position(mapX + x, mapY + y, plane.getLevel());\n\n\t\t\t\tif ((tile.getAttributes() & 0x1) == 0x1) {\n\t\t\t\t\tcollisionManager.block(position);\n\t\t\t\t}\n", "refactored_code": "\tprivate static final int BLOCKED_TILE = 0x1;\n\t\t\t\tTile tile = plane.getTile(x, y);\n\t\t\t\tPosition position = new Position(mapX + x, mapY + y, plane.getLevel());\n\n\t\t\t\tif ((tile.getAttributes() & BLOCKED_TILE) == BLOCKED_TILE) {\n\t\t\t\t\tcollisionManager.block(position);\n\t\t\t\t}\n"}
{"magic_number_smell": "\n\t@Override\n\tpublic void handle(Player player, ButtonMessage message) {\n\t\tif (message.getWidgetId() == 5387) {\n\t\t\tplayer.setWithdrawingNotes(false);\n\t\t} else if (message.getWidgetId() == WITHDRAW_AS_NOTE) {\n\t\t\tplayer.setWithdrawingNotes(true);", "refactored_code": "\tprivate static final int WITHDRAW_AS_ITEM = 5387;\n\n\t@Override\n\tpublic void handle(Player player, ButtonMessage message) {\n\t\tif (message.getWidgetId() == WITHDRAW_AS_ITEM) {\n\t\t\tplayer.setWithdrawingNotes(false);\n\t\t} else if (message.getWidgetId() == WITHDRAW_AS_NOTE) {\n\t\t\tplayer.setWithdrawingNotes(true);"}
{"magic_number_smell": "\n\t@Override\n\tpublic void handle(Player player, ItemOptionMessage message) {\n\t\tif (message.getInterfaceId() != INVENTORY_ID || message.getOption() != 2) {\n\t\t\treturn;\n\t\t}\n", "refactored_code": "\tprivate static final int EQUIP_OPTION = 2;\n\n\t@Override\n\tpublic void handle(Player player, ItemOptionMessage message) {\n\t\tif (message.getInterfaceId() != INVENTORY_ID || message.getOption() != EQUIP_OPTION) {\n\t\t\treturn;\n\t\t}\n"}
{"magic_number_smell": "\t * @param height The height.\n\t */\n\tpublic Position(int x, int y, int height) {\n\t\tPreconditions.checkElementIndex(height, 4, \"Height must be [0, 3), received \" + height + \".\");\n\n\t\tpacked = height << 30 | (y & 0x7FFF) << 15 | x & 0x7FFF;\n\t}", "refactored_code": "\tpublic static final int HEIGHT_LEVELS = 4;\n\t * @param height The height.\n\t */\n\tpublic Position(int x, int y, int height) {\n\t\tPreconditions.checkElementIndex(height, HEIGHT_LEVELS, \"Height must be [0, 3), received \" + height + \".\");\n\n\t\tpacked = height << 30 | (y & 0x7FFF) << 15 | x & 0x7FFF;\n\t}"}
{"magic_number_smell": "\t/**\n\t * The width of the viewport of every Player, in tiles.\n\t */\n\tpublic static final int VIEWPORT_WIDTH = 8 * 13;\n\n\t/**\n\t * The default size of newly-created Lists, to reduce memory usage.", "refactored_code": "\tpublic static final int SIZE = 8;\n\t/**\n\t * The width of the viewport of every Player, in tiles.\n\t */\n\tpublic static final int VIEWPORT_WIDTH = SIZE * 13;\n\n\t/**\n\t * The default size of newly-created Lists, to reduce memory usage."}
{"magic_number_smell": "\t * @param y The y coordinate.\n\t */\n\tpublic void reset(int x, int y) {\n\t\tset(x, y, 0b00000000_00000000);\n\t}\n\n\t/**", "refactored_code": "\tprivate static final short ALL_ALLOWED = 0b00000000_00000000;\n\t * @param y The y coordinate.\n\t */\n\tpublic void reset(int x, int y) {\n\t\tset(x, y, ALL_ALLOWED);\n\t}\n\n\t/**"}
{"magic_number_smell": "\t/**\n\t * The current maximum viewing distance of this Player.\n\t */\n\tprivate int viewingDistance = 15;\n\n\t/**\n\t * A flag indicating if the player is withdrawing items as notes.", "refactored_code": "\tprivate static final int DEFAULT_VIEWING_DISTANCE = 15;\n\t/**\n\t * The current maximum viewing distance of this Player.\n\t */\n\tprivate int viewingDistance = DEFAULT_VIEWING_DISTANCE;\n\n\t/**\n\t * A flag indicating if the player is withdrawing items as notes."}
{"magic_number_smell": "\t * @return {@code true} if the skill is a combat skill, otherwise {@code false}.\n\t */\n\tpublic static boolean isCombatSkill(int skill) {\n\t\treturn skill >= 0 && skill <= MAGIC;\n\t}\n\n\t/**", "refactored_code": "\tpublic static final int ATTACK = 0;\n\t * @return {@code true} if the skill is a combat skill, otherwise {@code false}.\n\t */\n\tpublic static boolean isCombatSkill(int skill) {\n\t\treturn skill >= ATTACK && skill <= MAGIC;\n\t}\n\n\t/**"}
{"magic_number_smell": "\t * @return The minimum level.\n\t */\n\tpublic static int getLevelForExperience(double experience) {\n\t\tPreconditions.checkArgument(experience >= 0 && experience <= 200_000_000, \"Experience must be between 0 and \" + 200_000_000 + \", inclusive.\");\n\t\tfor (int level = 1; level <= 98; level++) {\n\t\t\tif (experience < EXPERIENCE_FOR_LEVEL[level + 1]) {\n\t\t\t\treturn level;", "refactored_code": "\tpublic static final double MAXIMUM_EXP = 200_000_000;\n\t * @return The minimum level.\n\t */\n\tpublic static int getLevelForExperience(double experience) {\n\t\tPreconditions.checkArgument(experience >= 0 && experience <= MAXIMUM_EXP, \"Experience must be between 0 and \" + MAXIMUM_EXP + \", inclusive.\");\n\t\tfor (int level = 1; level <= 98; level++) {\n\t\t\tif (experience < EXPERIENCE_FOR_LEVEL[level + 1]) {\n\t\t\t\treturn level;"}
{"magic_number_smell": "\t/**\n\t * The map of attribute names to attributes.\n\t */\n\tprivate final Map<String, Attribute<?>> attributes = new HashMap<>(2);\n\n\t/**\n\t * Gets the {@link Attribute} with the specified name.", "refactored_code": "\tprivate static final int DEFAULT_MAP_SIZE = 2;\n\t/**\n\t * The map of attribute names to attributes.\n\t */\n\tprivate final Map<String, Attribute<?>> attributes = new HashMap<>(DEFAULT_MAP_SIZE);\n\n\t/**\n\t * Gets the {@link Attribute} with the specified name."}
{"magic_number_smell": "\t * @param collisionManager The {@link CollisionManager} used to check if an {@link Npc} movement is valid.\n\t */\n\tpublic NpcMovementTask(CollisionManager collisionManager) {\n\t\tsuper(5, false);\n\t\talgorithm = new SimplePathfindingAlgorithm(collisionManager);\n\t}\n", "refactored_code": "\tprivate static final int DELAY = 5;\n\t * @param collisionManager The {@link CollisionManager} used to check if an {@link Npc} movement is valid.\n\t */\n\tpublic NpcMovementTask(CollisionManager collisionManager) {\n\t\tsuper(DELAY, false);\n\t\talgorithm = new SimplePathfindingAlgorithm(collisionManager);\n\t}\n"}
{"magic_number_smell": "\tprivate void finalizeUnregistrations() {\n\t\tLoginService loginService = context.getLoginService();\n\n\t\tfor (int count = 0; count < 50; count++) {\n\t\t\tPlayer player = oldPlayers.poll();\n\t\t\tif (player == null) {\n\t\t\t\tbreak;", "refactored_code": "\tprivate static final int DEREGISTRATIONS_PER_CYCLE = 50;\n\tprivate void finalizeUnregistrations() {\n\t\tLoginService loginService = context.getLoginService();\n\n\t\tfor (int count = 0; count < DEREGISTRATIONS_PER_CYCLE; count++) {\n\t\t\tPlayer player = oldPlayers.poll();\n\t\t\tif (player == null) {\n\t\t\t\tbreak;"}
{"magic_number_smell": "\t/**\n\t * The ExecutorService.\n\t */\n\tprivate final ExecutorService service = Executors.newFixedThreadPool(3 * THREADS_PER_TYPE);\n\n\t/**\n\t * The List of RequestWorkers.", "refactored_code": "\tprivate static final int REQUEST_TYPES = 3;\n\t/**\n\t * The ExecutorService.\n\t */\n\tprivate final ExecutorService service = Executors.newFixedThreadPool(REQUEST_TYPES * THREADS_PER_TYPE);\n\n\t/**\n\t * The List of RequestWorkers."}
{"magic_number_smell": "\t\tIterator<Npc> iterator = npcs.iterator();\n\n\t\twhile (iterator.hasNext()) {\n\t\t\tif (count >= 255) {\n\t\t\t\tplayer.flagExcessiveNpcs();\n\t\t\t\tbreak;\n\t\t\t} else if (added >= NEW_NPCS_PER_CYCLE) {", "refactored_code": "\tprivate static final int MAXIMUM_LOCAL_NPCS = 255;\n\t\tIterator<Npc> iterator = npcs.iterator();\n\n\t\twhile (iterator.hasNext()) {\n\t\t\tif (count >= MAXIMUM_LOCAL_NPCS) {\n\t\t\t\tplayer.flagExcessiveNpcs();\n\t\t\t\tbreak;\n\t\t\t} else if (added >= NEW_NPCS_PER_CYCLE) {"}
{"magic_number_smell": "\t\tIterator<Player> iterator = players.iterator();\n\n\t\twhile (iterator.hasNext()) {\n\t\t\tif (count >= 255) {\n\t\t\t\tplayer.flagExcessivePlayers();\n\t\t\t\tbreak;\n\t\t\t} else if (added >= NEW_PLAYERS_PER_CYCLE) {", "refactored_code": "\tprivate static final int MAXIMUM_LOCAL_PLAYERS = 255;\n\t\tIterator<Player> iterator = players.iterator();\n\n\t\twhile (iterator.hasNext()) {\n\t\t\tif (count >= MAXIMUM_LOCAL_PLAYERS) {\n\t\t\t\tplayer.flagExcessivePlayers();\n\t\t\t\tbreak;\n\t\t\t} else if (added >= NEW_PLAYERS_PER_CYCLE) {"}
{"magic_number_smell": "\t */\n\t@BeforeClass\n\tpublic static void setupObjectDefinitions() {\n\t\tObjectDefinition wall = new ObjectDefinition(0);\n\n\t\tObjectDefinition squareObject = new ObjectDefinition(SQUARE_OBJECT);\n\t\tsquareObject.setLength(2);", "refactored_code": "\tprivate static final int WALL = 0;\n\t */\n\t@BeforeClass\n\tpublic static void setupObjectDefinitions() {\n\t\tObjectDefinition wall = new ObjectDefinition(WALL);\n\n\t\tObjectDefinition squareObject = new ObjectDefinition(SQUARE_OBJECT);\n\t\tsquareObject.setLength(2);"}
{"magic_number_smell": "\t */\n\t@Test\n\tpublic void capacity() {\n\t\tMobRepository<Player> players = new MobRepository<>(10);\n\n\t\tassertEquals(10, players.capacity());\n\t}", "refactored_code": "\tprivate static final int CAPACITY = 10;\n\t */\n\t@Test\n\tpublic void capacity() {\n\t\tMobRepository<Player> players = new MobRepository<>(CAPACITY);\n\n\t\tassertEquals(CAPACITY, players.capacity());\n\t}"}
{"magic_number_smell": "\t\tChannelPipeline pipeline = ch.pipeline();\n\n\t\tpipeline.addLast(\"decoder\", new HttpRequestDecoder());\n\t\tpipeline.addLast(\"chunker\", new HttpObjectAggregator(8192));\n\n\t\tpipeline.addLast(\"encoder\", new HttpResponseEncoder());\n", "refactored_code": "\tprivate static final int MAX_REQUEST_LENGTH = 8192;\n\t\tChannelPipeline pipeline = ch.pipeline();\n\n\t\tpipeline.addLast(\"decoder\", new HttpRequestDecoder());\n\t\tpipeline.addLast(\"chunker\", new HttpObjectAggregator(MAX_REQUEST_LENGTH));\n\n\t\tpipeline.addLast(\"encoder\", new HttpResponseEncoder());\n"}
{"magic_number_smell": "\tpublic void initChannel(SocketChannel ch) throws Exception {\n\t\tChannelPipeline pipeline = ch.pipeline();\n\n\t\tpipeline.addLast(\"framer\", new DelimiterBasedFrameDecoder(8192, DOUBLE_LINE_FEED_DELIMITER));\n\t\tpipeline.addLast(\"string-decoder\", new StringDecoder(JAGGRAB_CHARSET));\n\t\tpipeline.addLast(\"jaggrab-decoder\", new JagGrabRequestDecoder());\n", "refactored_code": "\tprivate static final int MAX_REQUEST_LENGTH = 8192;\n\tpublic void initChannel(SocketChannel ch) throws Exception {\n\t\tChannelPipeline pipeline = ch.pipeline();\n\n\t\tpipeline.addLast(\"framer\", new DelimiterBasedFrameDecoder(MAX_REQUEST_LENGTH, DOUBLE_LINE_FEED_DELIMITER));\n\t\tpipeline.addLast(\"string-decoder\", new StringDecoder(JAGGRAB_CHARSET));\n\t\tpipeline.addLast(\"jaggrab-decoder\", new JagGrabRequestDecoder());\n"}
{"magic_number_smell": "\t\tint length = buffer.readableBytes();\n\n\t\tfor (int chunk = 0; buffer.readableBytes() > 0; chunk++) {\n\t\t\tint chunkSize = Math.min(buffer.readableBytes(), 500);\n\t\t\tOnDemandResponse response = new OnDemandResponse(descriptor, length, chunk, buffer.readBytes(chunkSize));\n\t\t\tchannel.writeAndFlush(response);\n\t\t}", "refactored_code": "\tprivate static final int CHUNK_LENGTH = 500;\n\t\tint length = buffer.readableBytes();\n\n\t\tfor (int chunk = 0; buffer.readableBytes() > 0; chunk++) {\n\t\t\tint chunkSize = Math.min(buffer.readableBytes(), CHUNK_LENGTH);\n\t\t\tOnDemandResponse response = new OnDemandResponse(descriptor, length, chunk, buffer.readBytes(chunkSize));\n\t\t\tchannel.writeAndFlush(response);\n\t\t}"}
{"magic_number_smell": "\t * @param request The request.\n\t */\n\tpublic void dispatch(Channel channel, HttpRequest request) {\n\t\tif (http.size() >= 1024) {\n\t\t\tchannel.close();\n\t\t}\n\t\thttp.add(new ChannelRequest<>(channel, request));", "refactored_code": "\tprivate static final int MAXIMUM_QUEUE_SIZE = 1024;\n\t * @param request The request.\n\t */\n\tpublic void dispatch(Channel channel, HttpRequest request) {\n\t\tif (http.size() >= MAXIMUM_QUEUE_SIZE) {\n\t\t\tchannel.close();\n\t\t}\n\t\thttp.add(new ChannelRequest<>(channel, request));"}
{"magic_number_smell": "\t * @throws IllegalArgumentException If the {@code value} does not represent a valid name.\n\t */\n\tpublic static String decodeBase37(long value) {\n\t\tif (value < encodeBase37(\"\") || value > LAST_VALID_NAME) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid name.\");\n\t\t}\n", "refactored_code": "\tprivate static final long FIRST_VALID_NAME = encodeBase37(\"\");\n\t * @throws IllegalArgumentException If the {@code value} does not represent a valid name.\n\t */\n\tpublic static String decodeBase37(long value) {\n\t\tif (value < FIRST_VALID_NAME || value > LAST_VALID_NAME) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid name.\");\n\t\t}\n"}
{"magic_number_smell": "\tprivate void init() {\n\t\tint i;\n\t\tint a, b, c, d, e, f, g, h;\n\t\ta = b = c = d = e = f = g = h = 0x9e3779b9;\n\n\t\tfor (i = 0; i < 4; ++i) {\n\t\t\ta ^= b << 11;", "refactored_code": "\tprivate static final int GOLDEN_RATIO = 0x9e3779b9;\n\tprivate void init() {\n\t\tint i;\n\t\tint a, b, c, d, e, f, g, h;\n\t\ta = b = c = d = e = f = g = h = GOLDEN_RATIO;\n\n\t\tfor (i = 0; i < 4; ++i) {\n\t\t\ta ^= b << 11;"}
{"magic_number_smell": "\t\tSecurity.addProvider(new BouncyCastleProvider());\n\n\t\tKeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\", \"BC\");\n\t\tkeyPairGenerator.initialize(1024);\n\t\tKeyPair keyPair = keyPairGenerator.generateKeyPair();\n\n\t\tRSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();", "refactored_code": "\tprivate static final int BIT_COUNT = 1024;\n\t\tSecurity.addProvider(new BouncyCastleProvider());\n\n\t\tKeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\", \"BC\");\n\t\tkeyPairGenerator.initialize(BIT_COUNT);\n\t\tKeyPair keyPair = keyPairGenerator.generateKeyPair();\n\n\t\tRSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();"}
{"magic_number_smell": "    private MongoCollection collection;\n\n    public TestMongoDbPatternLayout() throws Exception {\n        mongo = new MongoClient(TEST_MONGO_SERVER_HOSTNAME, 27017);\n    }\n\n    @BeforeClass", "refactored_code": "    public static final int TEST_MONGO_SERVER_PORT = 27017;\n    private MongoCollection collection;\n\n    public TestMongoDbPatternLayout() throws Exception {\n        mongo = new MongoClient(TEST_MONGO_SERVER_HOSTNAME, TEST_MONGO_SERVER_PORT);\n    }\n\n    @BeforeClass"}
{"magic_number_smell": "    private MongoCollection collection;\n\n    public TestMongoDbPatternLayoutDate() throws Exception {\n        mongo = new MongoClient(TEST_MONGO_SERVER_HOSTNAME, 27017);\n    }\n\n    @BeforeClass", "refactored_code": "    public static final int TEST_MONGO_SERVER_PORT = 27017;\n    private MongoCollection collection;\n\n    public TestMongoDbPatternLayoutDate() throws Exception {\n        mongo = new MongoClient(TEST_MONGO_SERVER_HOSTNAME, TEST_MONGO_SERVER_PORT);\n    }\n\n    @BeforeClass"}
