{"magic_number_smell": "    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);"}
{"magic_number_smell": "    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);"}
{"magic_number_smell": "\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != 0x414E4554) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n", "refactored_code": "    private static final int FILE_MAGIC = 0x414E4554;\n\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != FILE_MAGIC) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n"}
{"magic_number_smell": "            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + AlarmManager.INTERVAL_HOUR;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {", "refactored_code": "    private static final long BACKUP_INTERVAL = AlarmManager.INTERVAL_HOUR;\n            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + BACKUP_INTERVAL;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {"}
{"magic_number_smell": "            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > 50 ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;", "refactored_code": "    private static final int INET_CONDITION_THRESHOLD = 50;\n            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;"}
{"magic_number_smell": "        }\n\n        long getDefaultDisplayDelayTimeout() {\n            return 10000;\n        }\n    }\n", "refactored_code": "    private static final long WAIT_FOR_DEFAULT_DISPLAY_TIMEOUT = 10000;\n        }\n\n        long getDefaultDisplayDelayTimeout() {\n            return WAIT_FOR_DEFAULT_DISPLAY_TIMEOUT;\n        }\n    }\n"}
{"magic_number_smell": "    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #-1}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode", "refactored_code": "    public static final int INFINITE = -1;\n    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #INFINITE}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode"}
{"magic_number_smell": "        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+5*1000) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }", "refactored_code": "    private static final long MIN_TIME_BETWEEN_GCS = 5*1000;\n        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+MIN_TIME_BETWEEN_GCS) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }"}
{"magic_number_smell": "        String version = \"\" + ((char) magic[4]) + ((char) magic[5]) +((char) magic[6]);\n\n        if (version.equals(VERSION_CURRENT)) {\n            return 14;\n        } else if (version.equals(VERSION_FOR_API_13)) {\n            return 13;\n        }", "refactored_code": "    public static final int API_CURRENT = 14;\n        String version = \"\" + ((char) magic[4]) + ((char) magic[5]) +((char) magic[6]);\n\n        if (version.equals(VERSION_CURRENT)) {\n            return API_CURRENT;\n        } else if (version.equals(VERSION_FOR_API_13)) {\n            return 13;\n        }"}
{"magic_number_smell": "     * @return true if the magic is valid\n     */\n    private boolean isGoodMagic(int magic) {\n        return magic == 0xcafebabe;\n    }\n\n    /**", "refactored_code": "    private static final int CLASS_FILE_MAGIC = 0xcafebabe;\n     * @return true if the magic is valid\n     */\n    private boolean isGoodMagic(int magic) {\n        return magic == CLASS_FILE_MAGIC;\n    }\n\n    /**"}
{"magic_number_smell": "        String version = \"\" + ((char) magic[4]) + ((char) magic[5]) +((char) magic[6]);\n\n        if (version.equals(VERSION_CURRENT)) {\n            return 14;\n        } else if (version.equals(VERSION_FOR_API_13)) {\n            return 13;\n        }", "refactored_code": "    public static final int API_CURRENT = 14;\n        String version = \"\" + ((char) magic[4]) + ((char) magic[5]) +((char) magic[6]);\n\n        if (version.equals(VERSION_CURRENT)) {\n            return API_CURRENT;\n        } else if (version.equals(VERSION_FOR_API_13)) {\n            return 13;\n        }"}
{"magic_number_smell": "        @Override\n        public int getItemViewType(int index) {\n            if (index == 0) {\n                return 0;\n            } else if (index == 1) {\n                return VIEW_TYPE_ALL_PHOTOS;\n            } else {", "refactored_code": "    private final int VIEW_TYPE_TAKE_PHOTO = 0;\n        @Override\n        public int getItemViewType(int index) {\n            if (index == 0) {\n                return VIEW_TYPE_TAKE_PHOTO;\n            } else if (index == 1) {\n                return VIEW_TYPE_ALL_PHOTOS;\n            } else {"}
{"magic_number_smell": "                        } else {\n                            // Calculate the time we need to be idle before we\n                            // start checking thumbnail.\n                            long t = 1000000000 -\n                                    (System.nanoTime() - mLastWorkTime);\n                            t = t / 1000000;  // convert to milliseconds.\n                            if (t > 0) {", "refactored_code": "        private static final long IDLE_TIME = 1000000000;  // in nanoseconds.\n                        } else {\n                            // Calculate the time we need to be idle before we\n                            // start checking thumbnail.\n                            long t = IDLE_TIME -\n                                    (System.nanoTime() - mLastWorkTime);\n                            t = t / 1000000;  // convert to milliseconds.\n                            if (t > 0) {"}
{"magic_number_smell": "\n    protected BaseImageList mContainer;\n\n    private int mWidth = -1;\n    private int mHeight = -1;\n\n    protected BaseImage(BaseImageList container, ContentResolver cr,", "refactored_code": "    private static final int UNKNOWN_LENGTH = -1;\n\n    protected BaseImageList mContainer;\n\n    private int mWidth = UNKNOWN_LENGTH;\n    private int mHeight = UNKNOWN_LENGTH;\n\n    protected BaseImage(BaseImageList container, ContentResolver cr,"}
{"magic_number_smell": "    private static final String TAG = \"BaseImageList\";\n    private static final int 512 = 512;\n    private final LruCache<Integer, BaseImage> mCache =\n            new LruCache<Integer, BaseImage>(512);\n\n    protected ContentResolver mContentResolver;\n    protected int mSort;", "refactored_code": "    private static final int CACHE_CAPACITY = 512;\n    private static final String TAG = \"BaseImageList\";\n    private static final int CACHE_CAPACITY = 512;\n    private final LruCache<Integer, BaseImage> mCache =\n            new LruCache<Integer, BaseImage>(CACHE_CAPACITY);\n\n    protected ContentResolver mContentResolver;\n    protected int mSort;"}
{"magic_number_smell": "    }\n\n    private void removeOldFile() {\n        String oldPath = randomAccessFilePath(3 - 1);\n        File oldFile = new File(oldPath);\n        if (oldFile.exists()) {\n            try {", "refactored_code": "    private static final int MINI_THUMB_DATA_FILE_VERSION = 3;\n    }\n\n    private void removeOldFile() {\n        String oldPath = randomAccessFilePath(MINI_THUMB_DATA_FILE_VERSION - 1);\n        File oldFile = new File(oldPath);\n        if (oldFile.exists()) {\n            try {"}
{"magic_number_smell": "        CheckedOutputStream crcOut = new CheckedOutputStream(sessOS, new Adler32());\n        //CheckedOutputStream cout = new CheckedOutputStream()\n        OutputArchive oa = BinaryOutputArchive.getArchive(crcOut);\n        FileHeader header = new FileHeader(SNAP_MAGIC, 2, dbId);\n        serialize(dt,sessions,oa, header);\n        long val = crcOut.getChecksum().getValue();\n        oa.writeLong(val, \"val\");", "refactored_code": "    private static final int VERSION=2;\n        CheckedOutputStream crcOut = new CheckedOutputStream(sessOS, new Adler32());\n        //CheckedOutputStream cout = new CheckedOutputStream()\n        OutputArchive oa = BinaryOutputArchive.getArchive(crcOut);\n        FileHeader header = new FileHeader(SNAP_MAGIC, VERSION, dbId);\n        serialize(dt,sessions,oa, header);\n        long val = crcOut.getChecksum().getValue();\n        oa.writeLong(val, \"val\");"}
{"magic_number_smell": "        CheckedOutputStream crcOut = new CheckedOutputStream(sessOS, new Adler32());\n        //CheckedOutputStream cout = new CheckedOutputStream()\n        OutputArchive oa = BinaryOutputArchive.getArchive(crcOut);\n        FileHeader header = new FileHeader(SNAP_MAGIC, 2, dbId);\n        serialize(dt,sessions,oa, header);\n        long val = crcOut.getChecksum().getValue();\n        oa.writeLong(val, \"val\");", "refactored_code": "    private static final int VERSION=2;\n        CheckedOutputStream crcOut = new CheckedOutputStream(sessOS, new Adler32());\n        //CheckedOutputStream cout = new CheckedOutputStream()\n        OutputArchive oa = BinaryOutputArchive.getArchive(crcOut);\n        FileHeader header = new FileHeader(SNAP_MAGIC, VERSION, dbId);\n        serialize(dt,sessions,oa, header);\n        long val = crcOut.getChecksum().getValue();\n        oa.writeLong(val, \"val\");"}
{"magic_number_smell": "            final String token = frames.nextToken();\n            // Determine if the line starts with <whitespace>at\n            final int at = token.indexOf(\"at\");\n            if (at != -1 && token.substring(0, at).trim().isEmpty()) {\n                traceStarted = true;\n                list.add(token);\n            } else if (traceStarted) {", "refactored_code": "    private static final int NOT_FOUND = -1;\n            final String token = frames.nextToken();\n            // Determine if the line starts with <whitespace>at\n            final int at = token.indexOf(\"at\");\n            if (at != NOT_FOUND && token.substring(0, at).trim().isEmpty()) {\n                traceStarted = true;\n                list.add(token);\n            } else if (traceStarted) {"}
{"magic_number_smell": "                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**", "refactored_code": "    private static final int NOT_FOUND = -1;\n                return i;\n            }\n        }\n        return NOT_FOUND;\n    }\n\n    /**"}
{"magic_number_smell": "        } else if (stripChars.length() == 0) {\n            return str;\n        } else {\n            while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != -1)) {\n                start++;\n            }\n        }", "refactored_code": "    public static final int INDEX_NOT_FOUND = -1;\n        } else if (stripChars.length() == 0) {\n            return str;\n        } else {\n            while ((start != strLen) && (stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND)) {\n                start++;\n            }\n        }"}
{"magic_number_smell": "    /**\n     * <p>Finds the index of the given object in the array.</p>\n     *\n     * <p>This method returns {@link #-1} (<code>-1</code>) for a <code>null</code> input array.</p>\n     * \n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param objectToFind  the object to find, may be <code>null</code>", "refactored_code": "    public static final int INDEX_NOT_FOUND = -1;\n    /**\n     * <p>Finds the index of the given object in the array.</p>\n     *\n     * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>\n     * \n     * @param array  the array to search through for the object, may be <code>null</code>\n     * @param objectToFind  the object to find, may be <code>null</code>"}
{"magic_number_smell": "        if (rv <= 0) {\n            // We have had an error. It can simply be that we have reached\n            // the timeout (very unlikely, as we have set it to MAX_INTEGER)\n            if (rv != -120001) {\n                // It's not a timeout being exceeded. Throw the error\n                throwException(rv);\n            }", "refactored_code": "    private static final int APR_TIMEUP_ERROR = -120001;\n        if (rv <= 0) {\n            // We have had an error. It can simply be that we have reached\n            // the timeout (very unlikely, as we have set it to MAX_INTEGER)\n            if (rv != APR_TIMEUP_ERROR) {\n                // It's not a timeout being exceeded. Throw the error\n                throwException(rv);\n            }"}
{"magic_number_smell": "     * @return the updated path\n     */\n    public static String separatorsToUnix(final String path) {\n        if (path == null || path.indexOf(WINDOWS_SEPARATOR) == -1) {\n            return path;\n        }\n        return path.replace(WINDOWS_SEPARATOR, UNIX_SEPARATOR);", "refactored_code": "    private static final int NOT_FOUND = -1;\n     * @return the updated path\n     */\n    public static String separatorsToUnix(final String path) {\n        if (path == null || path.indexOf(WINDOWS_SEPARATOR) == NOT_FOUND) {\n            return path;\n        }\n        return path.replace(WINDOWS_SEPARATOR, UNIX_SEPARATOR);"}
{"magic_number_smell": "    private long pos = 0;\n\n    /** the marked position */\n    private long mark = -1;\n\n    /** flag if close shoud be propagated */\n    private boolean propagateClose = true;", "refactored_code": "    private static final int EOF = -1;\n    private long pos = 0;\n\n    /** the marked position */\n    private long mark = EOF;\n\n    /** flag if close shoud be propagated */\n    private boolean propagateClose = true;"}
{"magic_number_smell": "            final int len1 = bom1.length();\n            final int len2 = bom2.length();\n            if (len1 > len2) {\n                return -1;\n            }\n            if (len2 > len1) {\n                return 1;", "refactored_code": "    private static final int EOF = -1;\n            final int len1 = bom1.length();\n            final int len2 = bom2.length();\n            if (len1 > len2) {\n                return EOF;\n            }\n            if (len2 > len1) {\n                return 1;"}
{"magic_number_smell": "     * @param listener the TailerListener to use.\n     */\n    public Tailer(File file, TailerListener listener) {\n        this(file, listener, 1000);\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_DELAY_MILLIS = 1000;\n     * @param listener the TailerListener to use.\n     */\n    public Tailer(File file, TailerListener listener) {\n        this(file, listener, DEFAULT_DELAY_MILLIS);\n    }\n\n    /**"}
{"magic_number_smell": "     * @param charset the character set name to use\n     */\n    public CharSequenceInputStream(final CharSequence s, final Charset charset) {\n        this(s, charset, 2048);\n    }\n\n    /**", "refactored_code": "    private static final int BUFFER_SIZE = 2048;\n     * @param charset the character set name to use\n     */\n    public CharSequenceInputStream(final CharSequence s, final Charset charset) {\n        this(s, charset, BUFFER_SIZE);\n    }\n\n    /**"}
{"magic_number_smell": "     * @param charset the character set name to use\n     */\n    public CharSequenceInputStream(final CharSequence s, final Charset charset) {\n        this(s, charset, 2048);\n    }\n\n    /**", "refactored_code": "    private static final int BUFFER_SIZE = 2048;\n     * @param charset the character set name to use\n     */\n    public CharSequenceInputStream(final CharSequence s, final Charset charset) {\n        this(s, charset, BUFFER_SIZE);\n    }\n\n    /**"}
{"magic_number_smell": "        int offset = 0;\n        int readed;\n\n        while (offset < size && (readed = input.read(data, offset, size - offset)) != -1) {\n            offset += readed;\n        }\n", "refactored_code": "    private static final int EOF = -1;\n        int offset = 0;\n        int readed;\n\n        while (offset < size && (readed = input.read(data, offset, size - offset)) != EOF) {\n            offset += readed;\n        }\n"}
{"magic_number_smell": "            }\n\n        } catch (Exception ex) {\n            os = -1;\n        }\n        OS = os;\n        DF = dfPath;", "refactored_code": "    private static final int INIT_PROBLEM = -1;\n            }\n\n        } catch (Exception ex) {\n            os = INIT_PROBLEM;\n        }\n        OS = os;\n        DF = dfPath;"}
{"magic_number_smell": "     * @param charset the character set name to use\n     */\n    public CharSequenceInputStream(final CharSequence s, final Charset charset) {\n        this(s, charset, 2048);\n    }\n\n    /**", "refactored_code": "    private static final int BUFFER_SIZE = 2048;\n     * @param charset the character set name to use\n     */\n    public CharSequenceInputStream(final CharSequence s, final Charset charset) {\n        this(s, charset, BUFFER_SIZE);\n    }\n\n    /**"}
{"magic_number_smell": "     * @throws IOException If an I/O error occurs\n     */\n    public MemoryMappedFileInputStream(final Path file) throws IOException {\n        this(file, 256 * 1024);\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_BUFFER_SIZE = 256 * 1024;\n     * @throws IOException If an I/O error occurs\n     */\n    public MemoryMappedFileInputStream(final Path file) throws IOException {\n        this(file, DEFAULT_BUFFER_SIZE);\n    }\n\n    /**"}
{"magic_number_smell": "    }\n\n    public HttpRequestExecutor() {\n        this(3000);\n    }\n\n    /**", "refactored_code": "    public static final int DEFAULT_WAIT_FOR_CONTINUE = 3000;\n    }\n\n    public HttpRequestExecutor() {\n        this(DEFAULT_WAIT_FOR_CONTINUE);\n    }\n\n    /**"}
{"magic_number_smell": "\t\t\t}\n\n\t\t\tif (!from_me && delivery_status == ChatConstants.DS_NEW) {\n\t\t\t\tmarkAsReadDelayed(_id, 2000);\n\t\t\t}\n\n\t\t\tString from = jid;", "refactored_code": "\tprivate static final int DELAY_NEWMSG = 2000;\n\t\t\t}\n\n\t\t\tif (!from_me && delivery_status == ChatConstants.DS_NEW) {\n\t\t\t\tmarkAsReadDelayed(_id, DELAY_NEWMSG);\n\t\t\t}\n\n\t\t\tString from = jid;"}
{"magic_number_smell": "\t\t\t}\n\n\t\t\tif (from_me == 0 && delivery_status == ChatConstants.DS_NEW) {\n\t\t\t\tmarkAsReadDelayed(_id, 2000);\n\t\t\t}\n\n\t\t\tString from = jid;", "refactored_code": "\tprivate static final int DELAY_NEWMSG = 2000;\n\t\t\t}\n\n\t\t\tif (from_me == 0 && delivery_status == ChatConstants.DS_NEW) {\n\t\t\t\tmarkAsReadDelayed(_id, DELAY_NEWMSG);\n\t\t\t}\n\n\t\t\tString from = jid;"}
{"magic_number_smell": "\n\t/**\n\t * GetLatestVersion attempt timeout.\n\t * TODO  This timeout is set to 1000 to work around the problem\n\t * in ccnd where some interests take >300ms (and sometimes longer, have seen periodic delays >800ms)\n\t * when that bug is found and fixed, this can be reduced back to the SHORT_TIMEOUT.\n\t * long attemptTimeout = SystemConfiguration.SHORT_TIMEOUT;", "refactored_code": "\tpublic static final long MEDIUM_TIMEOUT = 1000;\n\n\t/**\n\t * GetLatestVersion attempt timeout.\n\t * TODO  This timeout is set to MEDIUM_TIMEOUT to work around the problem\n\t * in ccnd where some interests take >300ms (and sometimes longer, have seen periodic delays >800ms)\n\t * when that bug is found and fixed, this can be reduced back to the SHORT_TIMEOUT.\n\t * long attemptTimeout = SystemConfiguration.SHORT_TIMEOUT;"}
{"magic_number_smell": "\t\n\tpublic static String defaultSymmetricKeystoreType() { return DEFAULT_SYMMETRIC_KEYSTORE_TYPE; }\n\t\n\tpublic static int defaultKeyLength() { return 1024; }\n\n\tpublic static Component defaultKeyNamespaceMarker() { return DEFAULT_KEY_NAMESPACE_MARKER; }\n}", "refactored_code": "\tprotected static final int DEFAULT_KEY_LENGTH = 1024;\n\t\n\tpublic static String defaultSymmetricKeystoreType() { return DEFAULT_SYMMETRIC_KEYSTORE_TYPE; }\n\t\n\tpublic static int defaultKeyLength() { return DEFAULT_KEY_LENGTH; }\n\n\tpublic static Component defaultKeyNamespaceMarker() { return DEFAULT_KEY_NAMESPACE_MARKER; }\n}"}
{"magic_number_smell": "\tprotected long _timeout = SystemConfiguration.FC_TIMEOUT;\n\tprotected long _timeoutToUse = SystemConfiguration.FC_TIMEOUT;\n\n\tprotected int _capacity = CCNSegmenter.HOLD_COUNT + 1;\n\n\t// Value used to determine whether the buffer is draining in waitForPutDrain\n\tprotected long _nOut = 0;", "refactored_code": "\tprotected static final int DEFAULT_CAPACITY = CCNSegmenter.HOLD_COUNT + 1;\n\tprotected long _timeout = SystemConfiguration.FC_TIMEOUT;\n\tprotected long _timeoutToUse = SystemConfiguration.FC_TIMEOUT;\n\n\tprotected int _capacity = DEFAULT_CAPACITY;\n\n\t// Value used to determine whether the buffer is draining in waitForPutDrain\n\tprotected long _nOut = 0;"}
{"magic_number_smell": "\t\t\t\tsynchronized (_opencloseLock) {\n\t\t\t\t\t_opencloseLock.wait(_downDelay);\n\t\t\t\t\tif (! _ncConnected) {\n\t\t\t\t\t\tif (_downDelay < 3500)\n\t\t\t\t\t\t\t_downDelay = _downDelay * 2 + 1;\n\t\t\t\t\t\topen();\n\t\t\t\t\t}", "refactored_code": "\tpublic static final int HEARTBEAT_PERIOD = 3500;\n\t\t\t\tsynchronized (_opencloseLock) {\n\t\t\t\t\t_opencloseLock.wait(_downDelay);\n\t\t\t\t\tif (! _ncConnected) {\n\t\t\t\t\t\tif (_downDelay < HEARTBEAT_PERIOD)\n\t\t\t\t\t\t\t_downDelay = _downDelay * 2 + 1;\n\t\t\t\t\t\topen();\n\t\t\t\t\t}"}
{"magic_number_smell": "\tprotected FileOutputStream _tapStreamOut = null;\n\tprotected FileOutputStream _tapStreamIn = null;\n\tprotected long _lastHeartbeat = 0;\n\tprotected int _port = 9695;\n\tprotected String _host = DEFAULT_AGENT_HOST;\n\tprotected NetworkProtocol _protocol = SystemConfiguration.AGENT_PROTOCOL;\n", "refactored_code": "\tpublic static final int DEFAULT_AGENT_PORT = 9695; // ccnx registered port\n\tprotected FileOutputStream _tapStreamOut = null;\n\tprotected FileOutputStream _tapStreamIn = null;\n\tprotected long _lastHeartbeat = 0;\n\tprotected int _port = DEFAULT_AGENT_PORT;\n\tprotected String _host = DEFAULT_AGENT_HOST;\n\tprotected NetworkProtocol _protocol = SystemConfiguration.AGENT_PROTOCOL;\n"}
{"magic_number_smell": "\tprotected int _byteScale = SegmentationProfile.DEFAULT_SCALE;\n\tprotected SegmentNumberType _sequenceType = SegmentNumberType.SEGMENT_FIXED_INCREMENT;\n\n\tprotected ArrayList<ContentObject> _blocks = new ArrayList<ContentObject>(128 + 1);\n\n\tprotected CCNHandle _handle;\n", "refactored_code": "\tpublic static final int HOLD_COUNT = 128;\n\tprotected int _byteScale = SegmentationProfile.DEFAULT_SCALE;\n\tprotected SegmentNumberType _sequenceType = SegmentNumberType.SEGMENT_FIXED_INCREMENT;\n\n\tprotected ArrayList<ContentObject> _blocks = new ArrayList<ContentObject>(HOLD_COUNT + 1);\n\n\tprotected CCNHandle _handle;\n"}
{"magic_number_smell": "public final class BinaryXMLDecoder extends GenericXMLDecoder implements XMLDecoder {\n\n\tpublic final int 512 = 512;\t// Default max we can go back for a resync\n\tprotected int _resyncLimit = 512;\n\tprotected boolean _resyncable = false;\n\n\tpublic BinaryXMLDecoder() {", "refactored_code": "\tpublic final int RESYNC_LIMIT = 512;\t// Default max we can go back for a resync\npublic final class BinaryXMLDecoder extends GenericXMLDecoder implements XMLDecoder {\n\n\tpublic final int RESYNC_LIMIT = 512;\t// Default max we can go back for a resync\n\tprotected int _resyncLimit = RESYNC_LIMIT;\n\tprotected boolean _resyncable = false;\n\n\tpublic BinaryXMLDecoder() {"}
{"magic_number_smell": "\tprotected static final String [] _tagToStringMap = new String[]{\n\t\tnull, null, null, null, null, null, null, null, null, null, null,\n\t\tnull, null,\n\t\t\"13\", \"Name\", \"Component\", \"Certificate\", \"Collection\", \"CompleteName\",\n\t\t\"Content\", \"SignedInfo\", \"ContentDigest\", \"ContentHash\", null, \"Count\", \"Header\",\n\t\t\"Interest\", \"Key\", \"KeyLocator\", \"KeyName\", \"Length\", \"Link\", \"LinkAuthenticator\",\n\t\t\"NameComponentCount\", \"ExtOpt\", null, \"RootDigest\", \"Signature\", \"Start\", \"Timestamp\", \"Type\",", "refactored_code": "\tpublic static final int Any = 13;\n\tprotected static final String [] _tagToStringMap = new String[]{\n\t\tnull, null, null, null, null, null, null, null, null, null, null,\n\t\tnull, null,\n\t\t\"Any\", \"Name\", \"Component\", \"Certificate\", \"Collection\", \"CompleteName\",\n\t\t\"Content\", \"SignedInfo\", \"ContentDigest\", \"ContentHash\", null, \"Count\", \"Header\",\n\t\t\"Interest\", \"Key\", \"KeyLocator\", \"KeyName\", \"Length\", \"Link\", \"LinkAuthenticator\",\n\t\t\"NameComponentCount\", \"ExtOpt\", null, \"RootDigest\", \"Signature\", \"Start\", \"Timestamp\", \"Type\","}
{"magic_number_smell": "\n\tpublic void add(ContentObject co) {\n\t\t_currentQueueSize++;\n\t\tif (!_throttled && _currentQueueSize > 2000) {\n\t\t\t_throttled = true;\n\t\t\t_server.setThrottle(true);\n\t\t}", "refactored_code": "\tpublic static final int THROTTLE_TOP = 2000;\n\n\tpublic void add(ContentObject co) {\n\t\t_currentQueueSize++;\n\t\tif (!_throttled && _currentQueueSize > THROTTLE_TOP) {\n\t\t\t_throttled = true;\n\t\t\t_server.setThrottle(true);\n\t\t}"}
{"magic_number_smell": "\tpublic byte [] root() { \n\t\tif ((null == _tree) || (_tree.length == 0))\n\t\t\treturn new byte[0];\n\t\treturn get(1);\n\t} \n\t\n\t/**", "refactored_code": "\tprotected static final int ROOT_NODE = 1;\n\tpublic byte [] root() { \n\t\tif ((null == _tree) || (_tree.length == 0))\n\t\t\treturn new byte[0];\n\t\treturn get(ROOT_NODE);\n\t} \n\t\n\t/**"}
{"magic_number_smell": "\t */\n\tpublic static synchronized ContentKeys generateRandomKeys() throws NoSuchAlgorithmException, NoSuchPaddingException {\n\t\tbyte [] key = new byte[DEFAULT_KEY_LENGTH];\n\t\tbyte [] iv = new byte[8];\n\t\t// do we want additional whitening?\n\t\tSecureRandom random = ContentKeys.getRandom();\n\t\trandom.nextBytes(key);", "refactored_code": "\tpublic static final int IV_MASTER_LENGTH = 8; // bytes\n\t */\n\tpublic static synchronized ContentKeys generateRandomKeys() throws NoSuchAlgorithmException, NoSuchPaddingException {\n\t\tbyte [] key = new byte[DEFAULT_KEY_LENGTH];\n\t\tbyte [] iv = new byte[IV_MASTER_LENGTH];\n\t\t// do we want additional whitening?\n\t\tSecureRandom random = ContentKeys.getRandom();\n\t\trandom.nextBytes(key);"}
{"magic_number_smell": "\t\t\to = (DERTaggedObject)e.nextElement();\n\t\t\t\n\t\t\tswitch (o.getTagNo()) {\n\t\t\t\tcase 0:\n\t\t\t\t\tthis._keyIdentifier = ASN1OctetString.getInstance(o);\n\t\t\t\t\tbreak;\n\t\t\t\tcase tag_IssuerName:", "refactored_code": "\tpublic static final int tag_KeyIdentifier \t\t\t= 0;\n\t\t\to = (DERTaggedObject)e.nextElement();\n\t\t\t\n\t\t\tswitch (o.getTagNo()) {\n\t\t\t\tcase tag_KeyIdentifier:\n\t\t\t\t\tthis._keyIdentifier = ASN1OctetString.getInstance(o);\n\t\t\t\t\tbreak;\n\t\t\t\tcase tag_IssuerName:"}
{"magic_number_smell": "\t\t\t\t\t\t\"ca_compromise\", \"extra_space\", \"affiliation_changed\",\n\t\t\t\t\t\t\"superseded\", \"cessation_of_operation\", \"certificate_hold\",\n\t\t\t\t\t\t\"remove_from_crl\"};\n\tpublic static final int REASON_CODES[] = {0, REASON_KEY_COMPROMISE,\n\t\t\tREASON_CA_COMPROMISE, REASON_AFFILIATION_CHANGED, REASON_SUPERSEDED,\n\t\t\tREASON_CESSATION_OF_OPERATION, REASON_CERTIFICATE_HOLD, REASON_REMOVE_FROM_CRL\n\t\t\t};", "refactored_code": "\tpublic static final int REASON_UNSPECIFIED \t\t= 0;\n\t\t\t\t\t\t\"ca_compromise\", \"extra_space\", \"affiliation_changed\",\n\t\t\t\t\t\t\"superseded\", \"cessation_of_operation\", \"certificate_hold\",\n\t\t\t\t\t\t\"remove_from_crl\"};\n\tpublic static final int REASON_CODES[] = {REASON_UNSPECIFIED, REASON_KEY_COMPROMISE,\n\t\t\tREASON_CA_COMPROMISE, REASON_AFFILIATION_CHANGED, REASON_SUPERSEDED,\n\t\t\tREASON_CESSATION_OF_OPERATION, REASON_CERTIFICATE_HOLD, REASON_REMOVE_FROM_CRL\n\t\t\t};"}
{"magic_number_smell": "\tpublic static Mac _AESKeyMac;\n\tpublic static String _AESKeyAlgorithm = MAC_ALGORITHM;\n\t\n\tprotected static DERInteger _version = new DERInteger(1);\n\t\n\tprotected byte[] _id = null;\n\tprotected KeyStore.Entry _ourEntry = null;", "refactored_code": "\tpublic static final int VERSION = 1;\n\tpublic static Mac _AESKeyMac;\n\tpublic static String _AESKeyAlgorithm = MAC_ALGORITHM;\n\t\n\tprotected static DERInteger _version = new DERInteger(VERSION);\n\t\n\tprotected byte[] _id = null;\n\tprotected KeyStore.Entry _ourEntry = null;"}
{"magic_number_smell": "\n\tprotected static class DaemonListenerClass extends UnicastRemoteObject implements DaemonListener {\n\n\t\tprivate static final long -4969812722104756329L = -9217344397211709762L;\n\t\tprotected WorkerThread _daemonThread;\n\n\t\tpublic DaemonListenerClass(WorkerThread daemonThread) throws RemoteException {", "refactored_code": "\t\tprivate static final long serialVersionUID = -4969812722104756329L;\n\n\tprotected static class DaemonListenerClass extends UnicastRemoteObject implements DaemonListener {\n\n\t\tprivate static final long serialVersionUID = -9217344397211709762L;\n\t\tprotected WorkerThread _daemonThread;\n\n\t\tpublic DaemonListenerClass(WorkerThread daemonThread) throws RemoteException {"}
{"magic_number_smell": "\tprotected static final int 1 = 1;\n\t\n\tpublic DetailedFormatter() {\n\t\t_args[1] = new Date();\n\t}\n\t\n\tprotected Date getDate() { return (Date)_args[1]; }", "refactored_code": "\tprotected static final int DATE_INDEX = 1;\n\tprotected static final int DATE_INDEX = 1;\n\t\n\tpublic DetailedFormatter() {\n\t\t_args[DATE_INDEX] = new Date();\n\t}\n\t\n\tprotected Date getDate() { return (Date)_args[DATE_INDEX]; }"}
{"magic_number_smell": "\t * @return true means would write log\n\t */\n\tpublic static boolean isLoggable(Level level) {\n\t\tif (level.intValue() <\t_fac_value[FAC_DEFAULT]\t || _fac_value[FAC_DEFAULT] == Level.OFF.intValue()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;", "refactored_code": "\tprotected static final int offValue = Level.OFF.intValue();\n\t * @return true means would write log\n\t */\n\tpublic static boolean isLoggable(Level level) {\n\t\tif (level.intValue() <\t_fac_value[FAC_DEFAULT]\t || _fac_value[FAC_DEFAULT] == offValue) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;"}
{"magic_number_smell": "\t\tif (null != startName)\n\t\t\t_doCallbacks = false;\n\t\t_decoder = new BinaryXMLDecoder();\n\t\t_decoder.setInitialBufferSize(756);\n\t}\n\t\n\t/**", "refactored_code": "\tpublic static final int DECODER_SIZE = 756;\n\t\tif (null != startName)\n\t\t\t_doCallbacks = false;\n\t\t_decoder = new BinaryXMLDecoder();\n\t\t_decoder.setInitialBufferSize(DECODER_SIZE);\n\t}\n\t\n\t/**"}
{"magic_number_smell": "\n\t\t\tInterest i = null;\n\n\t\t\twhile (_sentInterests.size() + inOrderSegments.size() + outOfOrderSegments.size() + 0 < SystemConfiguration.PIPELINE_SIZE && !doneAdvancing) {\n\t\t\t\tif (Log.isLoggable(Log.FAC_PIPELINE, Level.INFO))\n\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: _sentInterests.size() = {0} inOrderSegments.size() = {1} outOfOrderSegments.size()  = {2} 0 = {3} total = {4}\", _sentInterests.size(), inOrderSegments.size(), outOfOrderSegments.size(), 0, (_sentInterests.size() + inOrderSegments.size() + outOfOrderSegments.size() + 0) );\n", "refactored_code": "\tprivate final int processingDefer = 0;\n\n\t\t\tInterest i = null;\n\n\t\t\twhile (_sentInterests.size() + inOrderSegments.size() + outOfOrderSegments.size() + processingDefer < SystemConfiguration.PIPELINE_SIZE && !doneAdvancing) {\n\t\t\t\tif (Log.isLoggable(Log.FAC_PIPELINE, Level.INFO))\n\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: _sentInterests.size() = {0} inOrderSegments.size() = {1} outOfOrderSegments.size()  = {2} processingDefer = {3} total = {4}\", _sentInterests.size(), inOrderSegments.size(), outOfOrderSegments.size(), processingDefer, (_sentInterests.size() + inOrderSegments.size() + outOfOrderSegments.size() + processingDefer) );\n"}
{"magic_number_smell": "\t\tsuper((SegmentationProfile.isSegment(baseName) ? SegmentationProfile.segmentRoot(baseName) : baseName),\n\t\t\t  locator, publisher, type, keys, segmenter);\n\n\t\t_buffers = new byte[128][];\n\t\t// Always make the first one; it simplifies error handling later and only is superfluous if we\n\t\t// attempt to write an empty stream, which is rare.\n\t\t_buffers[0] = new byte[_segmenter.getBlockSize()];", "refactored_code": "\tpublic static final int BLOCK_BUF_COUNT = 128;\t// Must be at least 2\n\t\tsuper((SegmentationProfile.isSegment(baseName) ? SegmentationProfile.segmentRoot(baseName) : baseName),\n\t\t\t  locator, publisher, type, keys, segmenter);\n\n\t\t_buffers = new byte[BLOCK_BUF_COUNT][];\n\t\t// Always make the first one; it simplifies error handling later and only is superfluous if we\n\t\t// attempt to write an empty stream, which is rare.\n\t\t_buffers[0] = new byte[_segmenter.getBlockSize()];"}
{"magic_number_smell": "\n\t/**\n\t * GetLatestVersion attempt timeout.\n\t * TODO  This timeout is set to 1000 to work around the problem\n\t * in ccnd where some interests take >300ms (and sometimes longer, have seen periodic delays >800ms)\n\t * when that bug is found and fixed, this can be reduced back to the SHORT_TIMEOUT.\n\t * long attemptTimeout = SystemConfiguration.SHORT_TIMEOUT;", "refactored_code": "\tpublic static final long MEDIUM_TIMEOUT = 1000;\n\n\t/**\n\t * GetLatestVersion attempt timeout.\n\t * TODO  This timeout is set to MEDIUM_TIMEOUT to work around the problem\n\t * in ccnd where some interests take >300ms (and sometimes longer, have seen periodic delays >800ms)\n\t * when that bug is found and fixed, this can be reduced back to the SHORT_TIMEOUT.\n\t * long attemptTimeout = SystemConfiguration.SHORT_TIMEOUT;"}
{"magic_number_smell": "\t\n\tpublic static String defaultSymmetricKeystoreType() { return DEFAULT_SYMMETRIC_KEYSTORE_TYPE; }\n\t\n\tpublic static int defaultKeyLength() { return 1024; }\n\n\tpublic static Component defaultKeyNamespaceMarker() { return DEFAULT_KEY_NAMESPACE_MARKER; }\n}", "refactored_code": "\tprotected static final int DEFAULT_KEY_LENGTH = 1024;\n\t\n\tpublic static String defaultSymmetricKeystoreType() { return DEFAULT_SYMMETRIC_KEYSTORE_TYPE; }\n\t\n\tpublic static int defaultKeyLength() { return DEFAULT_KEY_LENGTH; }\n\n\tpublic static Component defaultKeyNamespaceMarker() { return DEFAULT_KEY_NAMESPACE_MARKER; }\n}"}
{"magic_number_smell": "\tprotected FileOutputStream _tapStreamOut = null;\n\tprotected FileOutputStream _tapStreamIn = null;\n\tprotected long _lastHeartbeat = 0;\n\tprotected int _port = 9695;\n\tprotected String _host = DEFAULT_AGENT_HOST;\n\tprotected NetworkProtocol _protocol = SystemConfiguration.AGENT_PROTOCOL;\n", "refactored_code": "\tpublic static final int DEFAULT_AGENT_PORT = 9695; // ccnx registered port\n\tprotected FileOutputStream _tapStreamOut = null;\n\tprotected FileOutputStream _tapStreamIn = null;\n\tprotected long _lastHeartbeat = 0;\n\tprotected int _port = DEFAULT_AGENT_PORT;\n\tprotected String _host = DEFAULT_AGENT_HOST;\n\tprotected NetworkProtocol _protocol = SystemConfiguration.AGENT_PROTOCOL;\n"}
{"magic_number_smell": "\tpublic static Mac _AESKeyMac;\n\tpublic static String _AESKeyAlgorithm = MAC_ALGORITHM;\n\t\n\tprotected static DERInteger _version = new DERInteger(1);\n\t\n\tprotected byte[] _id = null;\n\tprotected KeyStore.Entry _ourEntry = null;", "refactored_code": "\tpublic static final int VERSION = 1;\n\tpublic static Mac _AESKeyMac;\n\tpublic static String _AESKeyAlgorithm = MAC_ALGORITHM;\n\t\n\tprotected static DERInteger _version = new DERInteger(VERSION);\n\t\n\tprotected byte[] _id = null;\n\tprotected KeyStore.Entry _ourEntry = null;"}
{"magic_number_smell": "\n\t\t\tInterest i = null;\n\n\t\t\twhile (_sentInterests.size() + inOrderSegments.size() + outOfOrderSegments.size() + 0 < SystemConfiguration.PIPELINE_SIZE && !doneAdvancing) {\n\t\t\t\tif (Log.isLoggable(Log.FAC_PIPELINE, Level.INFO))\n\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: _sentInterests.size() = {0} inOrderSegments.size() = {1} outOfOrderSegments.size()  = {2} 0 = {3} total = {4}\", _sentInterests.size(), inOrderSegments.size(), outOfOrderSegments.size(), 0, (_sentInterests.size() + inOrderSegments.size() + outOfOrderSegments.size() + 0) );\n", "refactored_code": "\tprivate final int processingDefer = 0;\n\n\t\t\tInterest i = null;\n\n\t\t\twhile (_sentInterests.size() + inOrderSegments.size() + outOfOrderSegments.size() + processingDefer < SystemConfiguration.PIPELINE_SIZE && !doneAdvancing) {\n\t\t\t\tif (Log.isLoggable(Log.FAC_PIPELINE, Level.INFO))\n\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: _sentInterests.size() = {0} inOrderSegments.size() = {1} outOfOrderSegments.size()  = {2} processingDefer = {3} total = {4}\", _sentInterests.size(), inOrderSegments.size(), outOfOrderSegments.size(), processingDefer, (_sentInterests.size() + inOrderSegments.size() + outOfOrderSegments.size() + processingDefer) );\n"}
{"magic_number_smell": "\t\tAssert.assertFalse(gotInterest);\n\t\tgetHandle.cancelInterest(interest1, tl);\n\t\tgetHandle.expressInterest(interest2, tl);\n\t\tAssert.assertTrue(\"Couldn't get semaphore\", filterSema.tryAcquire(8000, TimeUnit.MILLISECONDS));\n\t\tgetHandle.checkError(TEST_TIMEOUT);\n\t\tAssert.assertTrue(gotInterest);\n\t\tgetHandle.cancelInterest(interest2, tl);", "refactored_code": "\tprotected static final int WAIT_MILLIS = 8000;\n\t\tAssert.assertFalse(gotInterest);\n\t\tgetHandle.cancelInterest(interest1, tl);\n\t\tgetHandle.expressInterest(interest2, tl);\n\t\tAssert.assertTrue(\"Couldn't get semaphore\", filterSema.tryAcquire(WAIT_MILLIS, TimeUnit.MILLISECONDS));\n\t\tgetHandle.checkError(TEST_TIMEOUT);\n\t\tAssert.assertTrue(gotInterest);\n\t\tgetHandle.cancelInterest(interest2, tl);"}
{"magic_number_smell": "     * @throws IOException on IO error\n     */\n    static void crossStreams(final InputStream in, final OutputStream out) throws IOException {\n        final byte[] buffer = new byte[0x20000];\n        int len;\n        while ((len = in.read(buffer)) != -1) {\n            out.write(buffer, 0, len);", "refactored_code": "    private static final int bufferSize = 0x20000; // ~130K.\n     * @throws IOException on IO error\n     */\n    static void crossStreams(final InputStream in, final OutputStream out) throws IOException {\n        final byte[] buffer = new byte[bufferSize];\n        int len;\n        while ((len = in.read(buffer)) != -1) {\n            out.write(buffer, 0, len);"}
{"magic_number_smell": "     * @throws IOException on IO error\n     */\n    static void crossStreams(final InputStream in, final OutputStream out) throws IOException {\n        final byte[] buffer = new byte[0x20000];\n        int len;\n        while ((len = in.read(buffer)) != -1) {\n            out.write(buffer, 0, len);", "refactored_code": "    private static final int bufferSize = 0x20000; // ~130K.\n     * @throws IOException on IO error\n     */\n    static void crossStreams(final InputStream in, final OutputStream out) throws IOException {\n        final byte[] buffer = new byte[bufferSize];\n        int len;\n        while ((len = in.read(buffer)) != -1) {\n            out.write(buffer, 0, len);"}
{"magic_number_smell": "            }\n            Thread.sleep(timeInMillis);\n            sum += timeInMillis;\n            timeInMillis = Math.min(1000L, timeInMillis * 2);\n        }\n        timeInMillis = maxTimeInMillis - sum;\n        Thread.sleep(Math.max(timeInMillis, 0));", "refactored_code": "    private static final long AWAIT_BUSY_THRESHOLD = 1000L;\n            }\n            Thread.sleep(timeInMillis);\n            sum += timeInMillis;\n            timeInMillis = Math.min(AWAIT_BUSY_THRESHOLD, timeInMillis * 2);\n        }\n        timeInMillis = maxTimeInMillis - sum;\n        Thread.sleep(Math.max(timeInMillis, 0));"}
{"magic_number_smell": "    public static final Setting<TimeValue> CACHE_TTL_SETTING = Setting.timeSetting(\"cache.ttl\", DEFAULT_TTL, Setting.Property.NodeScope);\n\n    private static final int 100_000 = 100_000; //100k users\n    public static final Setting<Integer> CACHE_MAX_USERS_SETTING = Setting.intSetting(\"cache.max_users\", 100_000,\n            Setting.Property.NodeScope);\n\n    private final Cache<String, UserWithHash> cache;", "refactored_code": "    private static final int DEFAULT_MAX_USERS = 100_000; //100k users\n    public static final Setting<TimeValue> CACHE_TTL_SETTING = Setting.timeSetting(\"cache.ttl\", DEFAULT_TTL, Setting.Property.NodeScope);\n\n    private static final int DEFAULT_MAX_USERS = 100_000; //100k users\n    public static final Setting<Integer> CACHE_MAX_USERS_SETTING = Setting.intSetting(\"cache.max_users\", DEFAULT_MAX_USERS,\n            Setting.Property.NodeScope);\n\n    private final Cache<String, UserWithHash> cache;"}
{"magic_number_smell": "\t\t\t\t}\n\t\t\t}\n\t\t\tif ( list.isEmpty() && haslatest)\n\t\t\t\tlist.add( new Version(999999999,0,0));\n\t\t\treturn new SortedList<Version>(list);\n\t\t}\n\t\treturn SortedList.empty();", "refactored_code": "\tpublic static final int\tMAX_MAJOR\t= 999999999;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( list.isEmpty() && haslatest)\n\t\t\t\tlist.add( new Version(MAX_MAJOR,0,0));\n\t\t\treturn new SortedList<Version>(list);\n\t\t}\n\t\treturn SortedList.empty();"}
{"magic_number_smell": "\t\t\t\t}\n\t\t\t}\n\t\t\tif ( list.isEmpty() && haslatest)\n\t\t\t\tlist.add( new Version(999999999,0,0));\n\t\t\treturn new SortedList<Version>(list);\n\t\t}\n\t\treturn SortedList.empty();", "refactored_code": "\tpublic static final int\tMAX_MAJOR\t= 999999999;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( list.isEmpty() && haslatest)\n\t\t\t\tlist.add( new Version(MAX_MAJOR,0,0));\n\t\t\treturn new SortedList<Version>(list);\n\t\t}\n\t\treturn SortedList.empty();"}
{"magic_number_smell": "\n\t\t\tCheckResult checkResult;\n\t\t\ttry {\n\t\t\t\tbufferedStream.mark(5 * 1024 * 1024);\n\t\t\t\tcheckResult = provider.checkStream(name, new ProtectedStream(bufferedStream));\n\t\t\t}\n\t\t\tfinally {", "refactored_code": "\tprivate static final int\t\t\t\t\t\t\t\t\tREAD_AHEAD_MAX\t\t\t\t\t= 5 * 1024 * 1024;\n\n\t\t\tCheckResult checkResult;\n\t\t\ttry {\n\t\t\t\tbufferedStream.mark(READ_AHEAD_MAX);\n\t\t\t\tcheckResult = provider.checkStream(name, new ProtectedStream(bufferedStream));\n\t\t\t}\n\t\t\tfinally {"}
{"magic_number_smell": "     * @param directory File working directory (may be null)\n     */\n    public SystemCommand(File directory, Map<String, String> env) {\n        this(directory, 0L, 100, env, null, null, null);\n    }\n\n    /**", "refactored_code": "    protected static final int POLL_INTERVAL = 100;\n     * @param directory File working directory (may be null)\n     */\n    public SystemCommand(File directory, Map<String, String> env) {\n        this(directory, 0L, POLL_INTERVAL, env, null, null, null);\n    }\n\n    /**"}
{"magic_number_smell": "                        } else {\n                            // Calculate the time we need to be idle before we\n                            // start checking thumbnail.\n                            long t = 1000000000 -\n                                    (System.nanoTime() - mLastWorkTime);\n                            t = t / 1000000;  // convert to milliseconds.\n                            if (t > 0) {", "refactored_code": "        private static final long IDLE_TIME = 1000000000;  // in nanoseconds.\n                        } else {\n                            // Calculate the time we need to be idle before we\n                            // start checking thumbnail.\n                            long t = IDLE_TIME -\n                                    (System.nanoTime() - mLastWorkTime);\n                            t = t / 1000000;  // convert to milliseconds.\n                            if (t > 0) {"}
{"magic_number_smell": "\n    protected BaseImageList mContainer;\n\n    private int mWidth = -1;\n    private int mHeight = -1;\n\n    protected BaseImage(BaseImageList container, ContentResolver cr,", "refactored_code": "    private static final int UNKNOWN_LENGTH = -1;\n\n    protected BaseImageList mContainer;\n\n    private int mWidth = UNKNOWN_LENGTH;\n    private int mHeight = UNKNOWN_LENGTH;\n\n    protected BaseImage(BaseImageList container, ContentResolver cr,"}
{"magic_number_smell": "    private static final String TAG = \"BaseImageList\";\n    private static final int 512 = 512;\n    private final LruCache<Integer, BaseImage> mCache =\n            new LruCache<Integer, BaseImage>(512);\n\n    protected ContentResolver mContentResolver;\n    protected int mSort;", "refactored_code": "    private static final int CACHE_CAPACITY = 512;\n    private static final String TAG = \"BaseImageList\";\n    private static final int CACHE_CAPACITY = 512;\n    private final LruCache<Integer, BaseImage> mCache =\n            new LruCache<Integer, BaseImage>(CACHE_CAPACITY);\n\n    protected ContentResolver mContentResolver;\n    protected int mSort;"}
{"magic_number_smell": "    }\n\n    private void removeOldFile() {\n        String oldPath = randomAccessFilePath(3 - 1);\n        File oldFile = new File(oldPath);\n        if (oldFile.exists()) {\n            try {", "refactored_code": "    private static final int MINI_THUMB_DATA_FILE_VERSION = 3;\n    }\n\n    private void removeOldFile() {\n        String oldPath = randomAccessFilePath(MINI_THUMB_DATA_FILE_VERSION - 1);\n        File oldFile = new File(oldPath);\n        if (oldFile.exists()) {\n            try {"}
{"magic_number_smell": "            {\n                weekdayCount++;\n            }\n            startMs += 86400000;\n        }\n        return weekdayCount;\n    }", "refactored_code": "    public static final long MS_IN_DAY = 86400000;\n            {\n                weekdayCount++;\n            }\n            startMs += MS_IN_DAY;\n        }\n        return weekdayCount;\n    }"}
{"magic_number_smell": "    public void test1()\n    {\n        Calendar cal = Calendar.getInstance();\n        cal.set(2011, 0, 7, i12, i30);\n        Date start = cal.getTime();\n\n        cal.set(2011, 0, i14);", "refactored_code": "    private final int i2011 = 2011;\n    public void test1()\n    {\n        Calendar cal = Calendar.getInstance();\n        cal.set(i2011, 0, 7, i12, i30);\n        Date start = cal.getTime();\n\n        cal.set(i2011, 0, i14);"}
{"magic_number_smell": "        @Override\n        public int getItemViewType(int index) {\n            if (index == 0) {\n                return 0;\n            } else if (index == 1) {\n                return VIEW_TYPE_ALL_PHOTOS;\n            } else {", "refactored_code": "    private final int VIEW_TYPE_TAKE_PHOTO = 0;\n        @Override\n        public int getItemViewType(int index) {\n            if (index == 0) {\n                return VIEW_TYPE_TAKE_PHOTO;\n            } else if (index == 1) {\n                return VIEW_TYPE_ALL_PHOTOS;\n            } else {"}
{"magic_number_smell": "        String version = \"\" + ((char) magic[4]) + ((char) magic[5]) +((char) magic[6]);\n\n        if (version.equals(VERSION_CURRENT)) {\n            return 14;\n        } else if (version.equals(VERSION_FOR_API_13)) {\n            return 13;\n        }", "refactored_code": "    public static final int API_CURRENT = 14;\n        String version = \"\" + ((char) magic[4]) + ((char) magic[5]) +((char) magic[6]);\n\n        if (version.equals(VERSION_CURRENT)) {\n            return API_CURRENT;\n        } else if (version.equals(VERSION_FOR_API_13)) {\n            return 13;\n        }"}
{"magic_number_smell": "     * @return true if the magic is valid\n     */\n    private boolean isGoodMagic(int magic) {\n        return magic == 0xcafebabe;\n    }\n\n    /**", "refactored_code": "    private static final int CLASS_FILE_MAGIC = 0xcafebabe;\n     * @return true if the magic is valid\n     */\n    private boolean isGoodMagic(int magic) {\n        return magic == CLASS_FILE_MAGIC;\n    }\n\n    /**"}
{"magic_number_smell": "        String version = \"\" + ((char) magic[4]) + ((char) magic[5]) +((char) magic[6]);\n\n        if (version.equals(VERSION_CURRENT)) {\n            return 14;\n        } else if (version.equals(VERSION_FOR_API_13)) {\n            return 13;\n        }", "refactored_code": "    public static final int API_CURRENT = 14;\n        String version = \"\" + ((char) magic[4]) + ((char) magic[5]) +((char) magic[6]);\n\n        if (version.equals(VERSION_CURRENT)) {\n            return API_CURRENT;\n        } else if (version.equals(VERSION_FOR_API_13)) {\n            return 13;\n        }"}
{"magic_number_smell": "    GeoPoint defCentre = CycleMapDefaults.centre();\n    int lat = pref(PREFS_APP_CENTRE_LAT, (int)(defCentre.getLatitude() * 1E6));\n    int lon = pref(PREFS_APP_CENTRE_LON, (int)(defCentre.getLongitude() * 1E6));\n    int zoom = pref(PREFS_APP_ZOOM_LEVEL, 14);\n    Log.d(TAG, \"onResume: Loading lat/lon=\" + lat + \"/\" + lon + \", zoom=\" + zoom);\n    final GeoPoint centre = new GeoPoint(lat / 1e6, lon / 1e6);\n    getScroller().abortAnimation();", "refactored_code": "  public static final int DEFAULT_ZOOM_LEVEL = 14;\n    GeoPoint defCentre = CycleMapDefaults.centre();\n    int lat = pref(PREFS_APP_CENTRE_LAT, (int)(defCentre.getLatitude() * 1E6));\n    int lon = pref(PREFS_APP_CENTRE_LON, (int)(defCentre.getLongitude() * 1E6));\n    int zoom = pref(PREFS_APP_ZOOM_LEVEL, DEFAULT_ZOOM_LEVEL);\n    Log.d(TAG, \"onResume: Loading lat/lon=\" + lat + \"/\" + lon + \", zoom=\" + zoom);\n    final GeoPoint centre = new GeoPoint(lat / 1e6, lon / 1e6);\n    getScroller().abortAnimation();"}
{"magic_number_smell": "            buffer[index++] = (byte) (0xFF & VERSION_2_MAGIC_NUMBER);\n        } else {\n            // Magic number for version 1.\n            buffer[index++] = (byte) (0xFF & (0x78B1 >> 8));\n            buffer[index++] = (byte) (0xFF & 0x78B1);\n        }\n        // Dictionary version.", "refactored_code": "    private static final int VERSION_1_MAGIC_NUMBER = 0x78B1;\n            buffer[index++] = (byte) (0xFF & VERSION_2_MAGIC_NUMBER);\n        } else {\n            // Magic number for version 1.\n            buffer[index++] = (byte) (0xFF & (VERSION_1_MAGIC_NUMBER >> 8));\n            buffer[index++] = (byte) (0xFF & VERSION_1_MAGIC_NUMBER);\n        }\n        // Dictionary version."}
{"magic_number_smell": "            buffer[index++] = (byte) (0xFF & VERSION_2_MAGIC_NUMBER);\n        } else {\n            // Magic number for version 1.\n            buffer[index++] = (byte) (0xFF & (0x78B1 >> 8));\n            buffer[index++] = (byte) (0xFF & 0x78B1);\n        }\n        // Dictionary version.", "refactored_code": "    private static final int VERSION_1_MAGIC_NUMBER = 0x78B1;\n            buffer[index++] = (byte) (0xFF & VERSION_2_MAGIC_NUMBER);\n        } else {\n            // Magic number for version 1.\n            buffer[index++] = (byte) (0xFF & (VERSION_1_MAGIC_NUMBER >> 8));\n            buffer[index++] = (byte) (0xFF & VERSION_1_MAGIC_NUMBER);\n        }\n        // Dictionary version."}
{"magic_number_smell": "        output.write(MAGIC_NUMBER);\n\n        // Actually copy the file\n        final byte[] buffer = new byte[1024];\n        for (int readBytes = input.read(buffer); readBytes >= 0; readBytes = input.read(buffer))\n            output.write(buffer, 0, readBytes);\n        input.close();", "refactored_code": "    private static final int FILE_READ_BUFFER_SIZE = 1024;\n        output.write(MAGIC_NUMBER);\n\n        // Actually copy the file\n        final byte[] buffer = new byte[FILE_READ_BUFFER_SIZE];\n        for (int readBytes = input.read(buffer); readBytes >= 0; readBytes = input.read(buffer))\n            output.write(buffer, 0, readBytes);\n        input.close();"}
{"magic_number_smell": "        output.write(MAGIC_NUMBER);\n\n        // Actually copy the file\n        final byte[] buffer = new byte[1024];\n        for (int readBytes = input.read(buffer); readBytes >= 0; readBytes = input.read(buffer))\n            output.write(buffer, 0, readBytes);\n        input.close();", "refactored_code": "    private static final int FILE_READ_BUFFER_SIZE = 1024;\n        output.write(MAGIC_NUMBER);\n\n        // Actually copy the file\n        final byte[] buffer = new byte[FILE_READ_BUFFER_SIZE];\n        for (int readBytes = input.read(buffer); readBytes >= 0; readBytes = input.read(buffer))\n            output.write(buffer, 0, readBytes);\n        input.close();"}
{"magic_number_smell": "\n  @Test\n  public void setThreadPriorityOneArgument_setsCurrentThreadPriority_highestPriority() {\n    android.os.Process.setThreadPriority(-20);\n\n    assertThat(android.os.Process.getThreadPriority(android.os.Process.myTid()))\n        .isEqualTo(-20);", "refactored_code": "  private static final int THREAD_PRIORITY_HIGHEST = -20;\n\n  @Test\n  public void setThreadPriorityOneArgument_setsCurrentThreadPriority_highestPriority() {\n    android.os.Process.setThreadPriority(THREAD_PRIORITY_HIGHEST);\n\n    assertThat(android.os.Process.getThreadPriority(android.os.Process.myTid()))\n        .isEqualTo(THREAD_PRIORITY_HIGHEST);"}
{"magic_number_smell": "  @Implementation\n  protected static final void setThreadPriority(int tid, int priority) {\n    checkArgument(\n        priority >= -20 && priority <= THREAD_PRIORITY_LOWEST,\n        \"priority %s out of range [%s, %s]. It is recommended to use a Process.THREAD_PRIORITY_*\"\n            + \" constant.\",\n        priority,", "refactored_code": "  private static final int THREAD_PRIORITY_HIGHEST = -20;\n  @Implementation\n  protected static final void setThreadPriority(int tid, int priority) {\n    checkArgument(\n        priority >= THREAD_PRIORITY_HIGHEST && priority <= THREAD_PRIORITY_LOWEST,\n        \"priority %s out of range [%s, %s]. It is recommended to use a Process.THREAD_PRIORITY_*\"\n            + \" constant.\",\n        priority,"}
{"magic_number_smell": "        if (parts.length == 2) {\n            if (parts[1].matches(\"\\\\d{1,3}\")) { // Need to eliminate signs\n                int bits = Integer.parseInt(parts[1]); // cannot fail because of RE check\n                if (bits < 0 || bits > 128) {\n                    return false; // out of range\n                }\n            } else {", "refactored_code": "    private static final int MAX_BYTE = 128;\n        if (parts.length == 2) {\n            if (parts[1].matches(\"\\\\d{1,3}\")) { // Need to eliminate signs\n                int bits = Integer.parseInt(parts[1]); // cannot fail because of RE check\n                if (bits < 0 || bits > MAX_BYTE) {\n                    return false; // out of range\n                }\n            } else {"}
{"magic_number_smell": "\t\t\t\t\t\tAutomaticIndexingSynchronizationStrategyNames.READ_SYNC )\n\t\t\t\t.setup( Book.class );\n\n\t\tprepareBooks( entityManagerFactory, 8 );\n\t}\n\n\t@Test", "refactored_code": "\tprivate static final int NUMBER_OF_BOOKS = 8;\n\t\t\t\t\t\tAutomaticIndexingSynchronizationStrategyNames.READ_SYNC )\n\t\t\t\t.setup( Book.class );\n\n\t\tprepareBooks( entityManagerFactory, NUMBER_OF_BOOKS );\n\t}\n\n\t@Test"}
{"magic_number_smell": "        if (readerIdleTime <= 0) {\n            readerIdleTimeNanos = 0;\n        } else {\n            readerIdleTimeNanos = Math.max(unit.toNanos(readerIdleTime), TimeUnit.MILLISECONDS.toNanos(1));\n        }\n        if (writerIdleTime <= 0) {\n            writerIdleTimeNanos = 0;", "refactored_code": "    private static final long MIN_TIMEOUT_NANOS = TimeUnit.MILLISECONDS.toNanos(1);\n        if (readerIdleTime <= 0) {\n            readerIdleTimeNanos = 0;\n        } else {\n            readerIdleTimeNanos = Math.max(unit.toNanos(readerIdleTime), MIN_TIMEOUT_NANOS);\n        }\n        if (writerIdleTime <= 0) {\n            writerIdleTimeNanos = 0;"}
{"magic_number_smell": "\n   @Override\n   protected void createCacheManagers() throws Throwable {\n      createHotRodServers(2, getCacheConfiguration());\n   }\n\n   private org.infinispan.configuration.cache.ConfigurationBuilder getCacheConfiguration() {", "refactored_code": "   private static final int NUM_SERVERS = 2;\n\n   @Override\n   protected void createCacheManagers() throws Throwable {\n      createHotRodServers(NUM_SERVERS, getCacheConfiguration());\n   }\n\n   private org.infinispan.configuration.cache.ConfigurationBuilder getCacheConfiguration() {"}
{"magic_number_smell": "      transport.writeByte(CLIENT_INTELLIGENCE_HASH_DISTRIBUTION_AWARE);\n      transport.writeVInt(topologyId.get());\n      //todo change once TX support is added\n      transport.writeByte(0);\n      if (log.isTraceEnabled()) {\n         log.tracef(\"wrote header for message %d. Operation code: %#04x. Flags: %#x\",\n                    messageId, operationCode, flagInt);", "refactored_code": "   private static final byte NO_TX = 0;\n      transport.writeByte(CLIENT_INTELLIGENCE_HASH_DISTRIBUTION_AWARE);\n      transport.writeVInt(topologyId.get());\n      //todo change once TX support is added\n      transport.writeByte(NO_TX);\n      if (log.isTraceEnabled()) {\n         log.tracef(\"wrote header for message %d. Operation code: %#04x. Flags: %#x\",\n                    messageId, operationCode, flagInt);"}
{"magic_number_smell": "        builder = new ConfigurationBuilder();\n        builder.addServer()\n                .host(SERVER_HOST)\n                .port(11222);\n    }\n\n    @After", "refactored_code": "    private final int HOTROD_PORT = 11222;\n        builder = new ConfigurationBuilder();\n        builder.addServer()\n                .host(SERVER_HOST)\n                .port(HOTROD_PORT);\n    }\n\n    @After"}
{"magic_number_smell": "            Log.v(TAG, \"Will create table \" + creator.getTableName());\n            createStatements.put(creator.getTableName(), creator);\n            getWritableDatabase().needUpgrade(++dbVersion);\n            onUpgrade(getWritableDatabase(), 0, 99);\n        }\n    }\n", "refactored_code": "    private static final int ALWAYS_UPGRADE = 99;\n            Log.v(TAG, \"Will create table \" + creator.getTableName());\n            createStatements.put(creator.getTableName(), creator);\n            getWritableDatabase().needUpgrade(++dbVersion);\n            onUpgrade(getWritableDatabase(), 0, ALWAYS_UPGRADE);\n        }\n    }\n"}
{"magic_number_smell": "    // true if more defragged ids can be read from file\n    private boolean haveMore = true;\n    // marks where this sessions released ids will be written\n    private long readBlocksTo = 9;\n    // used to calculate number of ids actually in use\n    private long defraggedIdCount = -1;\n", "refactored_code": "    private static final int HEADER_SIZE = 9;\n    // true if more defragged ids can be read from file\n    private boolean haveMore = true;\n    // marks where this sessions released ids will be written\n    private long readBlocksTo = HEADER_SIZE;\n    // used to calculate number of ids actually in use\n    private long defraggedIdCount = -1;\n"}
{"magic_number_smell": "\n        public int getRecordSize()\n        {\n            return 1;\n        }\n\n        public String getTypeAndVersionDescriptor()", "refactored_code": "        private static final int RECORD_SIZE = 1;\n\n        public int getRecordSize()\n        {\n            return RECORD_SIZE;\n        }\n\n        public String getTypeAndVersionDescriptor()"}
{"magic_number_smell": "    public void whenNoBodyIsReturned() {\n        HttpResponse<JsonNode> i = Unirest.get(MockServer.NOBODY).asJson();\n\n        assertEquals(200, i.getStatus());\n        assertEquals(\"{}\", i.getBody().toString());\n    }\n", "refactored_code": "    private final int HTTP_STATUS_OK = 200;\n    public void whenNoBodyIsReturned() {\n        HttpResponse<JsonNode> i = Unirest.get(MockServer.NOBODY).asJson();\n\n        assertEquals(HTTP_STATUS_OK, i.getStatus());\n        assertEquals(\"{}\", i.getBody().toString());\n    }\n"}
{"magic_number_smell": "\n    public Location findPlaceToStand(Location playerLoc, boolean goUp)\n    {\n        int 0.2;\n        if (goUp)\n        {\n            0.2 = 1;", "refactored_code": "    private final double                     step                   = 0.2;\n\n    public Location findPlaceToStand(Location playerLoc, boolean goUp)\n    {\n        int step;\n        if (goUp)\n        {\n            step = 1;"}
{"magic_number_smell": "    public void testPost() throws Exception {\n        SparkTestUtil.UrlResponse response = testUtil.doMethod(\"POST\", \"/hello\", BODY_CONTENT);\n        LOGGER.info(response.body);\n        Assert.assertEquals(200, response.status);\n        Assert.assertTrue(response.body.contains(BODY_CONTENT));\n\n        Assert.assertEquals(BODY_CONTENT, beforeBody);", "refactored_code": "    private final int HTTP_OK = 200;\n    public void testPost() throws Exception {\n        SparkTestUtil.UrlResponse response = testUtil.doMethod(\"POST\", \"/hello\", BODY_CONTENT);\n        LOGGER.info(response.body);\n        Assert.assertEquals(HTTP_OK, response.status);\n        Assert.assertTrue(response.body.contains(BODY_CONTENT));\n\n        Assert.assertEquals(BODY_CONTENT, beforeBody);"}
{"magic_number_smell": "        if (effect == null || dur == -1 || amp == -1) {\n            return null;\n        } else {\n            return new PotionEffect(effect, dur * 20, amp);\n        }\n    }\n    ", "refactored_code": "    private static final int TICKS_PER_SECOND = 20;\n        if (effect == null || dur == -1 || amp == -1) {\n            return null;\n        } else {\n            return new PotionEffect(effect, dur * TICKS_PER_SECOND, amp);\n        }\n    }\n    "}
{"magic_number_smell": "\n  /**\n   * the amount of bytes that a stack pointer is allowed\n   * to differ from the stack limit beyond {@link #256}.\n   * <p>\n   * This was set based on the historic values so it's probably\n   * safe to change this if you have appropriate test cases.", "refactored_code": "  private static final int BIG_FRAME_MINIMUM_SIZE = 256;\n\n  /**\n   * the amount of bytes that a stack pointer is allowed\n   * to differ from the stack limit beyond {@link #BIG_FRAME_MINIMUM_SIZE}.\n   * <p>\n   * This was set based on the historic values so it's probably\n   * safe to change this if you have appropriate test cases."}
{"magic_number_smell": "    public AdapterResponse<Feed> getFeed(GetFeedRequest getFeedRequest) {\n        AdapterResponse<Feed> response;\n\n        int pageSize = 25;\n        final String pageSizeString = getFeedRequest.getPageSize();\n\n        if (StringUtils.isNotBlank(pageSizeString)) {", "refactored_code": "    private static final int PAGE_SIZE = 25;\n    public AdapterResponse<Feed> getFeed(GetFeedRequest getFeedRequest) {\n        AdapterResponse<Feed> response;\n\n        int pageSize = PAGE_SIZE;\n        final String pageSizeString = getFeedRequest.getPageSize();\n\n        if (StringUtils.isNotBlank(pageSizeString)) {"}
{"magic_number_smell": "    public AdapterResponse<Feed> getFeed(GetFeedRequest getFeedRequest) {\n        AdapterResponse<Feed> response;\n\n        int pageSize = 25;\n        final String pageSizeString = getFeedRequest.getPageSize();\n\n        if (StringUtils.isNotBlank(pageSizeString)) {", "refactored_code": "    private static final int PAGE_SIZE = 25;\n    public AdapterResponse<Feed> getFeed(GetFeedRequest getFeedRequest) {\n        AdapterResponse<Feed> response;\n\n        int pageSize = PAGE_SIZE;\n        final String pageSizeString = getFeedRequest.getPageSize();\n\n        if (StringUtils.isNotBlank(pageSizeString)) {"}
{"magic_number_smell": "\t\t\t\tattrib.type = Attribute.ELF_TYPE_CORE;\n\t\t\t\tbreak;\n            case Elf.ELFhdr.ET_EXEC:\n                attrib.type = Attribute.1;\n                break;\n            case Elf.ELFhdr.ET_REL:\n                attrib.type = Attribute.ELF_TYPE_OBJ;", "refactored_code": "\t\tpublic static final int ELF_TYPE_EXE   = 1;\n\t\t\t\tattrib.type = Attribute.ELF_TYPE_CORE;\n\t\t\t\tbreak;\n            case Elf.ELFhdr.ET_EXEC:\n                attrib.type = Attribute.ELF_TYPE_EXE;\n                break;\n            case Elf.ELFhdr.ET_REL:\n                attrib.type = Attribute.ELF_TYPE_OBJ;"}
{"magic_number_smell": "\t}\n\n\tpublic void testMultipleIncludesError() throws IOException {\n\t\trunParserTest(GCC_ERROR_STREAM1, GCC_ERROR_STREAM1_ERRORS, 1, GCC_ERROR_STREAM1_FILENAMES, null,\n\t\t\t\tnew String[]{GCC_ERROR_PARSER_ID});\n\t}\n", "refactored_code": "\tpublic static final int GCC_ERROR_STREAM1_WARNINGS = 1;\n\t}\n\n\tpublic void testMultipleIncludesError() throws IOException {\n\t\trunParserTest(GCC_ERROR_STREAM1, GCC_ERROR_STREAM1_ERRORS, GCC_ERROR_STREAM1_WARNINGS, GCC_ERROR_STREAM1_FILENAMES, null,\n\t\t\t\tnew String[]{GCC_ERROR_PARSER_ID});\n\t}\n"}
{"magic_number_smell": "        if (fragment == null) {\n            ConfirmationDialog confirm = ConfirmationDialog.newInstance(\n                    R.string.dlg_delete_all_favorites,\n                    19126);\n            confirm.show(fm, ConfirmationDialog.TAG);\n        }\n    }", "refactored_code": "    public static final int DELETE_ALL_FAVORITES_REQUEST_CODE = 19126;\n        if (fragment == null) {\n            ConfirmationDialog confirm = ConfirmationDialog.newInstance(\n                    R.string.dlg_delete_all_favorites,\n                    DELETE_ALL_FAVORITES_REQUEST_CODE);\n            confirm.show(fm, ConfirmationDialog.TAG);\n        }\n    }"}
{"magic_number_smell": "  @Override\n  public void prepareForTransitWith() {\n    this.onTripIndex = UNBOUNDED_TRIP_INDEX;\n    this.onTripBoardTime = -1;\n    this.onTripBoardStop = -1;\n    this.onTrip = null;\n  }", "refactored_code": "  private static final int NOT_SET = -1;\n  @Override\n  public void prepareForTransitWith() {\n    this.onTripIndex = UNBOUNDED_TRIP_INDEX;\n    this.onTripBoardTime = NOT_SET;\n    this.onTripBoardStop = NOT_SET;\n    this.onTrip = null;\n  }"}
{"magic_number_smell": "  @Override\n  public void prepareForTransitWith() {\n    this.onTripIndex = UNBOUNDED_TRIP_INDEX;\n    this.onTripBoardTime = -1;\n    this.onTripBoardStop = -1;\n    this.onTrip = null;\n    this.onTripTimeShift = -1;", "refactored_code": "  private static final int NOT_SET = -1;\n  @Override\n  public void prepareForTransitWith() {\n    this.onTripIndex = UNBOUNDED_TRIP_INDEX;\n    this.onTripBoardTime = NOT_SET;\n    this.onTripBoardStop = NOT_SET;\n    this.onTrip = null;\n    this.onTripTimeShift = NOT_SET;"}
{"magic_number_smell": "  /** Immutable data for the current leg. */\n  private MyLeg leg;\n\n  private int fromTime = -999_999_999;\n  private int toTime = -999_999_999;\n\n  private PathBuilderLeg<T> prev = null;", "refactored_code": "  private static final int NOT_SET = -999_999_999;\n  /** Immutable data for the current leg. */\n  private MyLeg leg;\n\n  private int fromTime = NOT_SET;\n  private int toTime = NOT_SET;\n\n  private PathBuilderLeg<T> prev = null;"}
{"magic_number_smell": "  private static final int DEPARTURE_TIME = 8 * 60 * 60;\n  private static final int ACCESS_DURATION = 10 * 60;\n  private static final int ALIGHT_TIME = DEPARTURE_TIME + ACCESS_DURATION;\n  private static final TestAccessEgress WALK = TestAccessEgress.walk(100, ACCESS_DURATION);\n  private static final int COST = WALK.generalizedCost();\n\n  private final AccessStopArrival<RaptorTripSchedule> subject = new AccessStopArrival<>(", "refactored_code": "  private static final int ALIGHT_STOP = 100;\n  private static final int DEPARTURE_TIME = 8 * 60 * 60;\n  private static final int ACCESS_DURATION = 10 * 60;\n  private static final int ALIGHT_TIME = DEPARTURE_TIME + ACCESS_DURATION;\n  private static final TestAccessEgress WALK = TestAccessEgress.walk(ALIGHT_STOP, ACCESS_DURATION);\n  private static final int COST = WALK.generalizedCost();\n\n  private final AccessStopArrival<RaptorTripSchedule> subject = new AccessStopArrival<>("}
{"magic_number_smell": "   * Default values is defined in the default constructor.\n   */\n  private SearchParams() {\n    earliestDepartureTime = -9_999_999;\n    latestArrivalTime = -9_999_999;\n    searchWindowInSeconds = NOT_SET;\n    preferLateArrival = false;", "refactored_code": "  public static final int TIME_NOT_SET = -9_999_999;\n   * Default values is defined in the default constructor.\n   */\n  private SearchParams() {\n    earliestDepartureTime = TIME_NOT_SET;\n    latestArrivalTime = TIME_NOT_SET;\n    searchWindowInSeconds = NOT_SET;\n    preferLateArrival = false;"}
{"magic_number_smell": "    if (metersPerSecond < 10.0) {\n      return DoubleUtils.roundTo1Decimal(metersPerSecond);\n    }\n    if (metersPerSecond > 340.0) {\n      throw new IllegalArgumentException(\n        \"Are you flying in supersonic speed: \" + metersPerSecond + \" m/s\"\n      );", "refactored_code": "  private static final double ONE_MACH = 340.0;\n    if (metersPerSecond < 10.0) {\n      return DoubleUtils.roundTo1Decimal(metersPerSecond);\n    }\n    if (metersPerSecond > ONE_MACH) {\n      throw new IllegalArgumentException(\n        \"Are you flying in supersonic speed: \" + metersPerSecond + \" m/s\"\n      );"}
{"magic_number_smell": "        ? null\n        : Units.reluctance(\n          builder.relaxGeneralizedCostAtDestination,\n          1.0,\n          MAX_RELAX_COST_AT_DESTINATION\n        );\n  }", "refactored_code": "  private static final double MIN_RELAX_COST_AT_DESTINATION = 1.0;\n        ? null\n        : Units.reluctance(\n          builder.relaxGeneralizedCostAtDestination,\n          MIN_RELAX_COST_AT_DESTINATION,\n          MAX_RELAX_COST_AT_DESTINATION\n        );\n  }"}
{"magic_number_smell": "    .withProfile(PROFILE)\n    .withOptimizations(OPTIMIZATIONS)\n    .withTimeLimit(TIME_LIMIT)\n    .withRelaxGeneralizedCostAtDestination(1.2)\n    .build();\n\n  @Test", "refactored_code": "  private static final double RELAX_GENERALIZED_COST_AT_DESTINATION = 1.2;\n    .withProfile(PROFILE)\n    .withOptimizations(OPTIMIZATIONS)\n    .withTimeLimit(TIME_LIMIT)\n    .withRelaxGeneralizedCostAtDestination(RELAX_GENERALIZED_COST_AT_DESTINATION)\n    .build();\n\n  @Test"}
{"magic_number_smell": "\t\tint stackSize = imp.getStackSize();\n\t\tif (stackSize>1) {\n\t\t\tString macroOptions = Macro.getOptions();\n\t\t\tif (imp.isComposite() && ((CompositeImage)imp).getMode()==IJ.1, COLOR=2, GRAYSCALE=3) {\n\t\t\t\tif (macroOptions==null || !macroOptions.contains(\"slice\"))\n\t\t\t\t\treturn flags | PlugInFilter.DOES_STACKS;\n\t\t\t}", "refactored_code": "\tpublic static final int COMPOSITE=1, COLOR=2, GRAYSCALE=3;\n\t\tint stackSize = imp.getStackSize();\n\t\tif (stackSize>1) {\n\t\t\tString macroOptions = Macro.getOptions();\n\t\t\tif (imp.isComposite() && ((CompositeImage)imp).getMode()==IJ.COMPOSITE) {\n\t\t\t\tif (macroOptions==null || !macroOptions.contains(\"slice\"))\n\t\t\t\t\treturn flags | PlugInFilter.DOES_STACKS;\n\t\t\t}"}
{"magic_number_smell": "\tpublic static final int DEBUG = 256;\n\n\tprivate static final String IJ_X=\"ij.x\",IJ_Y=\"ij.y\";\n\tprivate static int port = 57294;\n\tprivate static String[] arguments;\n\t\n\tprivate Toolbar toolbar;", "refactored_code": "\tpublic static final int DEFAULT_PORT = 57294;\n\tpublic static final int DEBUG = 256;\n\n\tprivate static final String IJ_X=\"ij.x\",IJ_Y=\"ij.y\";\n\tprivate static int port = DEFAULT_PORT;\n\tprivate static String[] arguments;\n\t\n\tprivate Toolbar toolbar;"}
{"magic_number_smell": "\tprivate String title;\n\tprivate\tString url;\n\tprivate FileInfo fileInfo;\n\tprivate int imageType = 0;\n\tprivate boolean typeSet;\n\tprivate ImageStack stack;\n\tprivate static int currentID = -1;", "refactored_code": "\tpublic static final int GRAY8 = 0;\n\tprivate String title;\n\tprivate\tString url;\n\tprivate FileInfo fileInfo;\n\tprivate int imageType = GRAY8;\n\tprivate boolean typeSet;\n\tprivate ImageStack stack;\n\tprivate static int currentID = -1;"}
{"magic_number_smell": "\t\t\n    \t//update Window menu\n    \tint nItems = window.getItemCount();\n    \tint start = 6 + windowMenuItems2;\n    \tint index = start + WindowManager.getCurrentIndex();\n    \ttry {  // workaround for Linux/Java 5.0/bug\n\t\t\tfor (int i=start; i<nItems; i++) {", "refactored_code": "\tpublic static final int WINDOW_MENU_ITEMS = 6; // fixed items at top of Window menu\n\t\t\n    \t//update Window menu\n    \tint nItems = window.getItemCount();\n    \tint start = WINDOW_MENU_ITEMS + windowMenuItems2;\n    \tint index = start + WindowManager.getCurrentIndex();\n    \ttry {  // workaround for Linux/Java 5.0/bug\n\t\t\tfor (int i=start; i<nItems; i++) {"}
{"magic_number_smell": "\t\tint options = getInt(ijProps, OPTIONS);\n\t\tif (options==-1)\n\t\t\treturn true;\n\t\treturn (options&1<<22)!=0;\n\t}\n\t\n\tprotected static int getInt(Properties props, String key) {", "refactored_code": "\tprivate static final int RUN_SOCKET_LISTENER=1<<22;\n\t\tint options = getInt(ijProps, OPTIONS);\n\t\tif (options==-1)\n\t\t\treturn true;\n\t\treturn (options&RUN_SOCKET_LISTENER)!=0;\n\t}\n\t\n\tprotected static int getInt(Properties props, String key) {"}
{"magic_number_smell": "\t\tsuper(width, height, cm);\n\t\tpath = IJ.addSeparator(path);\n\t\tthis.path = path;\n\t\tnames = new String[100];\n\t\tlabels = new String[100];\n\t}\n", "refactored_code": "\tprivate static final int INITIAL_SIZE = 100;\n\t\tsuper(width, height, cm);\n\t\tpath = IJ.addSeparator(path);\n\t\tthis.path = path;\n\t\tnames = new String[INITIAL_SIZE];\n\t\tlabels = new String[INITIAL_SIZE];\n\t}\n"}
{"magic_number_smell": "public class HistogramWindow extends ImageWindow implements Measurements, ActionListener, \n\tClipboardOwner, ImageListener, RoiListener, Runnable {\n\tprivate static final double Prefs.getGuiScale() = Prefs.getGuiScale();\n\tstatic final int HIST_WIDTH = (int)(Prefs.getGuiScale()*256);\n\tstatic final int HIST_HEIGHT = (int)(Prefs.getGuiScale()*128);\n\tstatic final int XMARGIN = (int)(20*Prefs.getGuiScale());\n\tstatic final int YMARGIN = (int)(10*Prefs.getGuiScale());", "refactored_code": "\tprivate static final double SCALE = Prefs.getGuiScale();\npublic class HistogramWindow extends ImageWindow implements Measurements, ActionListener, \n\tClipboardOwner, ImageListener, RoiListener, Runnable {\n\tprivate static final double SCALE = Prefs.getGuiScale();\n\tstatic final int HIST_WIDTH = (int)(SCALE*256);\n\tstatic final int HIST_HEIGHT = (int)(SCALE*128);\n\tstatic final int XMARGIN = (int)(20*SCALE);\n\tstatic final int YMARGIN = (int)(10*SCALE);"}
{"magic_number_smell": "\t\t\t\t\t\tt = position;\n\t\t\t\t}\n\t\t\t\tif (((c==0||c==channel) && (z==0||z==slice) && (t==0||t==frame)) || roiManagerShowAllMode)\n\t\t\t\t\tdrawRoi(g, roi, drawLabels?i+100000:-1);\n\t\t\t} else {\n\t\t\t\tint position =  stackSize>1?roi.getPosition():0;\n\t\t\t\tif (position==0 && stackSize>1)", "refactored_code": "    private static final int LIST_OFFSET = 100000;\n\t\t\t\t\t\tt = position;\n\t\t\t\t}\n\t\t\t\tif (((c==0||c==channel) && (z==0||z==slice) && (t==0||t==frame)) || roiManagerShowAllMode)\n\t\t\t\t\tdrawRoi(g, roi, drawLabels?i+LIST_OFFSET:-1);\n\t\t\t} else {\n\t\t\t\tint position =  stackSize>1?roi.getPosition():0;\n\t\t\t\tif (position==0 && stackSize>1)"}
{"magic_number_smell": "\tprivate Color currentColor;\t\t\t\t\t\t// for next objects added\n\tprivate Color currentColor2;\t\t\t\t\t// 2nd color for next object added (e.g. line for CONNECTED_CIRCLES)\n\tfloat currentLineWidth;\n\tprivate int currentJustification = ImageProcessor.LEFT_JUSTIFY, CENTER=ImageProcessor.CENTER_JUSTIFY, RIGHT=ImageProcessor.RIGHT_JUSTIFY;\n\tprivate boolean ignoreForce2Grid;               // after explicit setting of range (limits), ignore 'FORCE2GRID' flags\n\t//private boolean snapToMinorGrid;  \t\t\t// snap to grid when zooming to selection\n\tprivate static double SEPARATED_BAR_WIDTH=0.5;  // for plots with separate bars (e.g. categories), fraction of space, 0.1-1.0", "refactored_code": "\tpublic static final int LEFT=ImageProcessor.LEFT_JUSTIFY, CENTER=ImageProcessor.CENTER_JUSTIFY, RIGHT=ImageProcessor.RIGHT_JUSTIFY;\n\tprivate Color currentColor;\t\t\t\t\t\t// for next objects added\n\tprivate Color currentColor2;\t\t\t\t\t// 2nd color for next object added (e.g. line for CONNECTED_CIRCLES)\n\tfloat currentLineWidth;\n\tprivate int currentJustification = LEFT;\n\tprivate boolean ignoreForce2Grid;               // after explicit setting of range (limits), ignore 'FORCE2GRID' flags\n\t//private boolean snapToMinorGrid;  \t\t\t// snap to grid when zooming to selection\n\tprivate static double SEPARATED_BAR_WIDTH=0.5;  // for plots with separate bars (e.g. categories), fraction of space, 0.1-1.0"}
{"magic_number_smell": "\tprivate static final BasicStroke twoPixelsWide = new BasicStroke(2);\n\tprivate static final BasicStroke threePixelsWide = new BasicStroke(3);\n\tprivate static final BasicStroke fivePixelsWide = new BasicStroke(5);\n\tprivate static int defaultType = 0, CROSS=1, CROSSHAIR=1, DOT=2, CIRCLE=3;\n\tprivate static int defaultSize = SMALL;\n\tprivate static Font font;\n\tprivate static Color defaultCrossColor = Color.white;", "refactored_code": "\tpublic static final int HYBRID=0, CROSS=1, CROSSHAIR=1, DOT=2, CIRCLE=3;\n\tprivate static final BasicStroke twoPixelsWide = new BasicStroke(2);\n\tprivate static final BasicStroke threePixelsWide = new BasicStroke(3);\n\tprivate static final BasicStroke fivePixelsWide = new BasicStroke(5);\n\tprivate static int defaultType = HYBRID;\n\tprivate static int defaultSize = SMALL;\n\tprivate static Font font;\n\tprivate static Color defaultCrossColor = Color.white;"}
{"magic_number_smell": "\tprivate static int size = 18;\n\tprivate Font font;\n\tprivate static boolean antialiasedText = true; // global flag used by text tool\n\tprivate static int globalJustification = 0, CENTER=1, RIGHT=2;\n\tprivate static Color defaultFillColor;\n\tprivate int justification = 0, CENTER=1, RIGHT=2;\n\tprivate double previousMag;", "refactored_code": "\tpublic static final int LEFT=0, CENTER=1, RIGHT=2;\n\tprivate static int size = 18;\n\tprivate Font font;\n\tprivate static boolean antialiasedText = true; // global flag used by text tool\n\tprivate static int globalJustification = LEFT;\n\tprivate static Color defaultFillColor;\n\tprivate int justification = LEFT;\n\tprivate double previousMag;"}
{"magic_number_smell": "\tprivate long mouseDownTime;\n\tprivate Graphics g;\n\tprivate static Toolbar instance;\n\tprivate int mpPrevious = 0;\n\tprivate String[] names = new String[MAX_TOOLS];\n\tprivate String[] icons = new String[MAX_TOOLS];\n\tprivate PlugInTool[] tools = new PlugInTool[MAX_TOOLS];", "refactored_code": "\tpublic static final int RECTANGLE = 0;\n\tprivate long mouseDownTime;\n\tprivate Graphics g;\n\tprivate static Toolbar instance;\n\tprivate int mpPrevious = RECTANGLE;\n\tprivate String[] names = new String[MAX_TOOLS];\n\tprivate String[] icons = new String[MAX_TOOLS];\n\tprivate PlugInTool[] tools = new PlugInTool[MAX_TOOLS];"}
{"magic_number_smell": "\t/* File format (TIFF, GIF_OR_JPG, BMP, etc.). Used by the File/Revert command */\n\tpublic int fileFormat;\n\t\n\t/* File type (0, GRAY_16_UNSIGNED, RGB, etc.) */\n\tpublic int fileType;\t\n\tpublic String fileName;\n\tpublic String directory;", "refactored_code": "\tpublic static final int GRAY8 = 0;\n\t/* File format (TIFF, GIF_OR_JPG, BMP, etc.). Used by the File/Revert command */\n\tpublic int fileFormat;\n\t\n\t/* File type (GRAY8, GRAY_16_UNSIGNED, RGB, etc.) */\n\tpublic int fileType;\t\n\tpublic String fileName;\n\tpublic String directory;"}
{"magic_number_smell": "\tString getName(int tag) {\n\t\tString name;\n\t\tswitch (tag) {\n\t\t\tcase 254: name=\"NewSubfileType\"; break;\n\t\t\tcase IMAGE_WIDTH: name=\"ImageWidth\"; break;\n\t\t\tcase IMAGE_LENGTH: name=\"ImageLength\"; break;\n\t\t\tcase STRIP_OFFSETS: name=\"StripOffsets\"; break;", "refactored_code": "\tpublic static final int NEW_SUBFILE_TYPE = 254;\n\tString getName(int tag) {\n\t\tString name;\n\t\tswitch (tag) {\n\t\t\tcase NEW_SUBFILE_TYPE: name=\"NewSubfileType\"; break;\n\t\t\tcase IMAGE_WIDTH: name=\"ImageWidth\"; break;\n\t\t\tcase IMAGE_LENGTH: name=\"ImageLength\"; break;\n\t\t\tcase STRIP_OFFSETS: name=\"StripOffsets\"; break;"}
{"magic_number_smell": "\t\tint y  = 60;\n\t\tadd(text[0], width-20, y, font, TextRoi.RIGHT, overlay);\n\t\tint xcenter = 410;\n\t\tfont = new Font(\"SansSerif\", Font.PLAIN, 20, LARGE_FONT=45);\n\t\ty += 45;\n\t\tadd(text[1], xcenter, y, font, TextRoi.CENTER, overlay);\n\t\ty += 27;", "refactored_code": "\t\tprivate static final int SMALL_FONT=20, LARGE_FONT=45;\n\t\tint y  = 60;\n\t\tadd(text[0], width-20, y, font, TextRoi.RIGHT, overlay);\n\t\tint xcenter = 410;\n\t\tfont = new Font(\"SansSerif\", Font.PLAIN, SMALL_FONT);\n\t\ty += 45;\n\t\tadd(text[1], xcenter, y, font, TextRoi.CENTER, overlay);\n\t\ty += 27;"}
{"magic_number_smell": "\tpublic static final int 0, CTZ=1, ZCT=2, ZTC=3, TCZ=4, TZC=5=0, CTZ=1, ZCT=2, ZTC=3, TCZ=4, TZC=5;\n\tstatic final int C=0, Z=1, T=2;\n\tstatic final String[] orders = {\"xyczt(default)\", \"xyctz\", \"xyzct\", \"xyztc\", \"xytcz\", \"xytzc\"};\n\tstatic int ordering = 0, CTZ=1, ZCT=2, ZTC=3, TCZ=4, TZC=5;\n\tstatic boolean splitRGB = true;\n\n\tpublic void run(String arg) {", "refactored_code": "\tpublic static final int CZT=0, CTZ=1, ZCT=2, ZTC=3, TCZ=4, TZC=5;\n\tpublic static final int CZT=0, CTZ=1, ZCT=2, ZTC=3, TCZ=4, TZC=5;\n\tstatic final int C=0, Z=1, T=2;\n\tstatic final String[] orders = {\"xyczt(default)\", \"xyctz\", \"xyzct\", \"xyztc\", \"xytcz\", \"xytzc\"};\n\tstatic int ordering = CZT;\n\tstatic boolean splitRGB = true;\n\n\tpublic void run(String arg) {"}
{"magic_number_smell": " ActionListener, AdjustmentListener, FocusListener, ItemListener, Runnable{\n\n\tprivate static final int 0, RGB=1, LAB=2, YUV=3=0, RGB=1, LAB=2, YUV=3;\n\tprivate static final String[] colorSpaces = {\"0, RGB=1, LAB=2, YUV=3\", \"RGB\", \"Lab\", \"YUV\"};\n\tprivate boolean flag = false;\n\tprivate int colorSpace = 0, RGB=1, LAB=2, YUV=3;\n\tprivate Thread thread;", "refactored_code": "\tprivate static final int HSB=0, RGB=1, LAB=2, YUV=3;\n ActionListener, AdjustmentListener, FocusListener, ItemListener, Runnable{\n\n\tprivate static final int HSB=0, RGB=1, LAB=2, YUV=3;\n\tprivate static final String[] colorSpaces = {\"HSB\", \"RGB\", \"Lab\", \"YUV\"};\n\tprivate boolean flag = false;\n\tprivate int colorSpace = HSB;\n\tprivate Thread thread;"}
{"magic_number_smell": "\t\tJScrollPane scrollPane = new JScrollPane(list, ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS, ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n\t\tadd(\"Center\", scrollPane);\n\t\tpanel = new Panel();\n\t\tint nButtons = 11;\n\t\tpanel.setLayout(new GridLayout(nButtons, 1, 5, 0));\n\t\taddButton(\"Add [t]\");\n\t\taddButton(\"Update\");", "refactored_code": "\tprivate static final int BUTTONS = 11;\n\t\tJScrollPane scrollPane = new JScrollPane(list, ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS, ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n\t\tadd(\"Center\", scrollPane);\n\t\tpanel = new Panel();\n\t\tint nButtons = BUTTONS;\n\t\tpanel.setLayout(new GridLayout(nButtons, 1, 5, 0));\n\t\taddButton(\"Add [t]\");\n\t\taddButton(\"Update\");"}
{"magic_number_smell": "\t}\n\n\t/** Fills pixels that are within the ROI bounding rectangle and part of\n\t*\tthe mask (i.e. pixels that have a value=0xFF000000 in the mask array).\n\t*\tUse ip.getMask() to acquire the mask.\n\t*\tThrows and IllegalArgumentException if the mask is null or\n\t*\tthe size of the mask is not the same as the size of the ROI.", "refactored_code": "\tpublic static final int BLACK = 0xFF000000;\n\t}\n\n\t/** Fills pixels that are within the ROI bounding rectangle and part of\n\t*\tthe mask (i.e. pixels that have a value=BLACK in the mask array).\n\t*\tUse ip.getMask() to acquire the mask.\n\t*\tThrows and IllegalArgumentException if the mask is null or\n\t*\tthe size of the mask is not the same as the size of the ROI."}
{"magic_number_smell": "\n    @Override\n    public int hashCode() {\n        return isEmpty() ? Objects.hash(new LinkedList<>()) : Objects.hash(headers);\n    }\n\n    @Override", "refactored_code": "    private static final int EMPTY_HASH = Objects.hash(new LinkedList<>());\n\n    @Override\n    public int hashCode() {\n        return isEmpty() ? EMPTY_HASH : Objects.hash(headers);\n    }\n\n    @Override"}
{"magic_number_smell": "        return new ConfigDef()\n                .define(NAME_CONFIG, Type.STRING, ConfigDef.NO_DEFAULT_VALUE, nonEmptyStringWithoutControlChars(), Importance.HIGH, NAME_DOC, COMMON_GROUP, ++orderInGroup, Width.MEDIUM, NAME_DISPLAY)\n                .define(CONNECTOR_CLASS_CONFIG, Type.STRING, Importance.HIGH, CONNECTOR_CLASS_DOC, COMMON_GROUP, ++orderInGroup, Width.LONG, CONNECTOR_CLASS_DISPLAY)\n                .define(TASKS_MAX_CONFIG, Type.INT, 1, atLeast(TASKS_MIN_CONFIG), Importance.HIGH, TASKS_MAX_DOC, COMMON_GROUP, ++orderInGroup, Width.SHORT, TASK_MAX_DISPLAY)\n                .define(KEY_CONVERTER_CLASS_CONFIG, Type.CLASS, null, Importance.LOW, KEY_CONVERTER_CLASS_DOC, COMMON_GROUP, ++orderInGroup, Width.SHORT, KEY_CONVERTER_CLASS_DISPLAY)\n                .define(VALUE_CONVERTER_CLASS_CONFIG, Type.CLASS, null, Importance.LOW, VALUE_CONVERTER_CLASS_DOC, COMMON_GROUP, ++orderInGroup, Width.SHORT, VALUE_CONVERTER_CLASS_DISPLAY)\n                .define(HEADER_CONVERTER_CLASS_CONFIG, Type.CLASS, HEADER_CONVERTER_CLASS_DEFAULT, Importance.LOW, HEADER_CONVERTER_CLASS_DOC, COMMON_GROUP, ++orderInGroup, Width.SHORT, HEADER_CONVERTER_CLASS_DISPLAY)", "refactored_code": "    public static final int TASKS_MAX_DEFAULT = 1;\n        return new ConfigDef()\n                .define(NAME_CONFIG, Type.STRING, ConfigDef.NO_DEFAULT_VALUE, nonEmptyStringWithoutControlChars(), Importance.HIGH, NAME_DOC, COMMON_GROUP, ++orderInGroup, Width.MEDIUM, NAME_DISPLAY)\n                .define(CONNECTOR_CLASS_CONFIG, Type.STRING, Importance.HIGH, CONNECTOR_CLASS_DOC, COMMON_GROUP, ++orderInGroup, Width.LONG, CONNECTOR_CLASS_DISPLAY)\n                .define(TASKS_MAX_CONFIG, Type.INT, TASKS_MAX_DEFAULT, atLeast(TASKS_MIN_CONFIG), Importance.HIGH, TASKS_MAX_DOC, COMMON_GROUP, ++orderInGroup, Width.SHORT, TASK_MAX_DISPLAY)\n                .define(KEY_CONVERTER_CLASS_CONFIG, Type.CLASS, null, Importance.LOW, KEY_CONVERTER_CLASS_DOC, COMMON_GROUP, ++orderInGroup, Width.SHORT, KEY_CONVERTER_CLASS_DISPLAY)\n                .define(VALUE_CONVERTER_CLASS_CONFIG, Type.CLASS, null, Importance.LOW, VALUE_CONVERTER_CLASS_DOC, COMMON_GROUP, ++orderInGroup, Width.SHORT, VALUE_CONVERTER_CLASS_DISPLAY)\n                .define(HEADER_CONVERTER_CLASS_CONFIG, Type.CLASS, HEADER_CONVERTER_CLASS_DEFAULT, Importance.LOW, HEADER_CONVERTER_CLASS_DOC, COMMON_GROUP, ++orderInGroup, Width.SHORT, HEADER_CONVERTER_CLASS_DISPLAY)"}
{"magic_number_smell": "                    continue;\n                log.debug(\"{} About to send \" + toSend.size() + \" records to Kafka\", this);\n                if (!sendRecords())\n                    stopRequestedLatch.await(100, TimeUnit.MILLISECONDS);\n            }\n        } catch (InterruptedException e) {\n            // Ignore and allow to exit.", "refactored_code": "    private static final long SEND_FAILED_BACKOFF_MS = 100;\n                    continue;\n                log.debug(\"{} About to send \" + toSend.size() + \" records to Kafka\", this);\n                if (!sendRecords())\n                    stopRequestedLatch.await(SEND_FAILED_BACKOFF_MS, TimeUnit.MILLISECONDS);\n            }\n        } catch (InterruptedException e) {\n            // Ignore and allow to exit."}
{"magic_number_smell": "            forwardRequestExecutor.shutdown();\n            startAndStopExecutor.shutdown();\n\n            if (!forwardRequestExecutor.awaitTermination(TimeUnit.SECONDS.toMillis(10), TimeUnit.MILLISECONDS))\n                forwardRequestExecutor.shutdownNow();\n            if (!startAndStopExecutor.awaitTermination(START_AND_STOP_SHUTDOWN_TIMEOUT_MS, TimeUnit.MILLISECONDS))\n                startAndStopExecutor.shutdownNow();", "refactored_code": "    private static final long FORWARD_REQUEST_SHUTDOWN_TIMEOUT_MS = TimeUnit.SECONDS.toMillis(10);\n            forwardRequestExecutor.shutdown();\n            startAndStopExecutor.shutdown();\n\n            if (!forwardRequestExecutor.awaitTermination(FORWARD_REQUEST_SHUTDOWN_TIMEOUT_MS, TimeUnit.MILLISECONDS))\n                forwardRequestExecutor.shutdownNow();\n            if (!startAndStopExecutor.awaitTermination(START_AND_STOP_SHUTDOWN_TIMEOUT_MS, TimeUnit.MILLISECONDS))\n                startAndStopExecutor.shutdownNow();"}
{"magic_number_smell": "        StatisticsHandler statsHandler = new StatisticsHandler();\n        statsHandler.setHandler(handlers);\n        jettyServer.setHandler(statsHandler);\n        jettyServer.setStopTimeout(60 * 1000);\n        jettyServer.setStopAtShutdown(true);\n\n        try {", "refactored_code": "    private static final long GRACEFUL_SHUTDOWN_TIMEOUT_MS = 60 * 1000;\n        StatisticsHandler statsHandler = new StatisticsHandler();\n        statsHandler.setHandler(handlers);\n        jettyServer.setHandler(statsHandler);\n        jettyServer.setStopTimeout(GRACEFUL_SHUTDOWN_TIMEOUT_MS);\n        jettyServer.setStopAtShutdown(true);\n\n        try {"}
{"magic_number_smell": "    in.seek(96);\n    in.order(true);\n\n    boolean little = in.readShort() == -16224;\n    in.order(little);\n    in.seek(0);\n", "refactored_code": "  private static final short LITTLE_ENDIAN = -16224;\n    in.seek(96);\n    in.order(true);\n\n    boolean little = in.readShort() == LITTLE_ENDIAN;\n    in.order(little);\n    in.seek(0);\n"}
{"magic_number_smell": "  /** Returns the name of the given codec. */\n  public static String getCodecName(int codec) {\n    switch (codec) {\n      case 1:\n        return \"Uncompressed\";\n      case CCITT_1D:\n        return \"CCITT Group 3 1-Dimensional Modified Huffman\";", "refactored_code": "  public static final int UNCOMPRESSED = 1;\n  /** Returns the name of the given codec. */\n  public static String getCodecName(int codec) {\n    switch (codec) {\n      case UNCOMPRESSED:\n        return \"Uncompressed\";\n      case CCITT_1D:\n        return \"CCITT Group 3 1-Dimensional Modified Huffman\";"}
{"magic_number_smell": "    if (x == 0 && y == 0 && w == 1 && h == 1) {\n      return buf;\n    }\n    else if (getSizeX() <= 8192 && getSizeY() <= 8192) {\n      int ifdIndex = getIFDIndex(getSeries(), no);\n      in = new RandomAccessInputStream(currentId);\n      tiffParser = new TiffParser(in);", "refactored_code": "  private static final int MAX_SIZE = 8192;\n    if (x == 0 && y == 0 && w == 1 && h == 1) {\n      return buf;\n    }\n    else if (getSizeX() <= MAX_SIZE && getSizeY() <= MAX_SIZE) {\n      int ifdIndex = getIFDIndex(getSeries(), no);\n      in = new RandomAccessInputStream(currentId);\n      tiffParser = new TiffParser(in);"}
{"magic_number_smell": "            }\n\n            // Tar needs an even bigger buffer to check the signature; read the first block\n            final byte[] tarheader = new byte[512];\n            in.mark(tarheader.length);\n            signatureLength = IOUtils.readFully(in, tarheader);\n            in.reset();", "refactored_code": "    private static final int TAR_HEADER_SIZE = 512;\n            }\n\n            // Tar needs an even bigger buffer to check the signature; read the first block\n            final byte[] tarheader = new byte[TAR_HEADER_SIZE];\n            in.mark(tarheader.length);\n            signatureLength = IOUtils.readFully(in, tarheader);\n            in.reset();"}
{"magic_number_smell": "            }\n\n            // Dump needs a bigger buffer to check the signature;\n            final byte[] dumpsig = new byte[32];\n            in.mark(dumpsig.length);\n            signatureLength = IOUtils.readFully(in, dumpsig);\n            in.reset();", "refactored_code": "    private static final int DUMP_SIGNATURE_SIZE = 32;\n            }\n\n            // Dump needs a bigger buffer to check the signature;\n            final byte[] dumpsig = new byte[DUMP_SIGNATURE_SIZE];\n            in.mark(dumpsig.length);\n            signatureLength = IOUtils.readFully(in, dumpsig);\n            in.reset();"}
{"magic_number_smell": "            throw new IllegalArgumentException(\"Mark is not supported.\");\n        }\n\n        final byte[] signature = new byte[12];\n        in.mark(signature.length);\n        try {\n            int signatureLength = IOUtils.readFully(in, signature);", "refactored_code": "    private static final int SIGNATURE_SIZE = 12;\n            throw new IllegalArgumentException(\"Mark is not supported.\");\n        }\n\n        final byte[] signature = new byte[SIGNATURE_SIZE];\n        in.mark(signature.length);\n        try {\n            int signatureLength = IOUtils.readFully(in, signature);"}
{"magic_number_smell": "\tprivate final long length;\n\n\tpublic ArArchiveEntry(String name, long length) {\n\t\tthis(name, length, 0, 0, 33188, System.currentTimeMillis());\n\t}\n\t\n\tpublic ArArchiveEntry(String name, long length, int userId, int groupId, int mode, long lastModified) {", "refactored_code": "    private static final int DEFAULT_MODE = 33188; // = (octal) 0100644 \n\tprivate final long length;\n\n\tpublic ArArchiveEntry(String name, long length) {\n\t\tthis(name, length, 0, 0, DEFAULT_MODE, System.currentTimeMillis());\n\t}\n\t\n\tpublic ArArchiveEntry(String name, long length, int userId, int groupId, int mode, long lastModified) {"}
{"magic_number_smell": "        buffer.order(ByteOrder.LITTLE_ENDIAN);\n        buffer.putShort((short) GZIPInputStream.GZIP_MAGIC);\n        buffer.put((byte) Deflater.DEFLATED); // compression method (8: deflate)\n        buffer.put((byte) ((filename != null ? 1 << 3 : 0) | (comment != null ? FCOMMENT : 0))); // flags\n        buffer.putInt((int) (parameters.getModificationTime() / 1000));\n        \n        // extra flags", "refactored_code": "    private static final int FNAME = 1 << 3;\n        buffer.order(ByteOrder.LITTLE_ENDIAN);\n        buffer.putShort((short) GZIPInputStream.GZIP_MAGIC);\n        buffer.put((byte) Deflater.DEFLATED); // compression method (8: deflate)\n        buffer.put((byte) ((filename != null ? FNAME : 0) | (comment != null ? FCOMMENT : 0))); // flags\n        buffer.putInt((int) (parameters.getModificationTime() / 1000));\n        \n        // extra flags"}
{"magic_number_smell": "    static {\n        // Initialise as all invalid characters\n        for (int i = 0; i < DECODING_TABLE.length; i++) {\n            DECODING_TABLE[i] = -1;\n        }\n        // set up valid characters\n        for (int i = 0; i < ENCODING_TABLE.length; i++) {", "refactored_code": "    private static final int INVALID_BYTE = -1; // must be outside range 0-63\n    static {\n        // Initialise as all invalid characters\n        for (int i = 0; i < DECODING_TABLE.length; i++) {\n            DECODING_TABLE[i] = INVALID_BYTE;\n        }\n        // set up valid characters\n        for (int i = 0; i < ENCODING_TABLE.length; i++) {"}
{"magic_number_smell": "                    // this is a hex pair we need to convert back to a single byte.\n                    byte c1 = DECODING_TABLE[b1];\n                    byte c2 = DECODING_TABLE[b2];\n                    out.write((c1 << 4) | c2);\n                    // 3 bytes in, one byte out\n                    bytesWritten++;\n                }", "refactored_code": "    private static final int OUT_SHIFT = 4;\n                    // this is a hex pair we need to convert back to a single byte.\n                    byte c1 = DECODING_TABLE[b1];\n                    byte c2 = DECODING_TABLE[b2];\n                    out.write((c1 << OUT_SHIFT) | c2);\n                    // 3 bytes in, one byte out\n                    bytesWritten++;\n                }"}
{"magic_number_smell": "    /**\n     * set up the decoding table.\n     */\n    private static final byte[] DECODING_TABLE = new byte[128];\n\n    static {\n        // initialize the decoding table", "refactored_code": "    private static final int DECODING_TABLE_SIZE = 128;\n    /**\n     * set up the decoding table.\n     */\n    private static final byte[] DECODING_TABLE = new byte[DECODING_TABLE_SIZE];\n\n    static {\n        // initialize the decoding table"}
{"magic_number_smell": "                    // this is a hex pair we need to convert back to a single byte.\n                    byte c1 = DECODING_TABLE[b1];\n                    byte c2 = DECODING_TABLE[b2];\n                    out.write((c1 << Byte.SIZE / 2) | c2);\n                    // 3 bytes in, one byte out\n                    bytesWritten++;\n                }", "refactored_code": "    private static final int UPPER_NIBBLE_SHIFT = Byte.SIZE / 2;\n                    // this is a hex pair we need to convert back to a single byte.\n                    byte c1 = DECODING_TABLE[b1];\n                    byte c2 = DECODING_TABLE[b2];\n                    out.write((c1 << UPPER_NIBBLE_SHIFT) | c2);\n                    // 3 bytes in, one byte out\n                    bytesWritten++;\n                }"}
{"magic_number_smell": "     * (<code>CRLFCRLF</code>).\n     */\n    protected static final byte[] HEADER_SEPARATOR = {\n            0x0D, LF, 0x0D, LF };\n\n\n    /**", "refactored_code": "    public static final byte CR = 0x0D;\n     * (<code>CRLFCRLF</code>).\n     */\n    protected static final byte[] HEADER_SEPARATOR = {\n            CR, LF, CR, LF };\n\n\n    /**"}
{"magic_number_smell": "            out.write((b2 << MASK_4BITS) | (b3 >> MASK_2BITS));\n            out.write((b3 << MASK_6BITS) | b4);\n\n            outLen += 3;\n        }\n\n        if (data[end - MASK_2BITS] == PADDING) {", "refactored_code": "    private static final int BYTES_PER_UNENCODED_BLOCK = 3;\n            out.write((b2 << MASK_4BITS) | (b3 >> MASK_2BITS));\n            out.write((b3 << MASK_6BITS) | b4);\n\n            outLen += BYTES_PER_UNENCODED_BLOCK;\n        }\n\n        if (data[end - MASK_2BITS] == PADDING) {"}
{"magic_number_smell": "\n    public static int Gb( double giga )\n    {\n        return (int) giga * 1024 * 1024 * 1024;\n    }\n\n    public static int Mb( double mega )", "refactored_code": "    private static final int KILOBYTE_UNIT = 1024;\n\n    public static int Gb( double giga )\n    {\n        return (int) giga * KILOBYTE_UNIT * KILOBYTE_UNIT * KILOBYTE_UNIT;\n    }\n\n    public static int Mb( double mega )"}
{"magic_number_smell": "    public static final long fnv1a_64_magic_prime = 0x100000001b3L;\n\n    public static long fnv1a_64_extract(String key){\n        long hashCode = 0xcbf29ce484222325L;\n        for(int i = 0; i < key.length(); ++i){\n            char ch = key.charAt(i);\n            if(ch == '_' || ch == '-'){", "refactored_code": "    public static final long fnv1a_64_magic_hashcode = 0xcbf29ce484222325L;\n    public static final long fnv1a_64_magic_prime = 0x100000001b3L;\n\n    public static long fnv1a_64_extract(String key){\n        long hashCode = fnv1a_64_magic_hashcode;\n        for(int i = 0; i < key.length(); ++i){\n            char ch = key.charAt(i);\n            if(ch == '_' || ch == '-'){"}
{"magic_number_smell": "    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);"}
{"magic_number_smell": "    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);"}
{"magic_number_smell": "\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != 0x414E4554) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n", "refactored_code": "    private static final int FILE_MAGIC = 0x414E4554;\n\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != FILE_MAGIC) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n"}
{"magic_number_smell": "            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + AlarmManager.INTERVAL_HOUR;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {", "refactored_code": "    private static final long BACKUP_INTERVAL = AlarmManager.INTERVAL_HOUR;\n            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + BACKUP_INTERVAL;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {"}
{"magic_number_smell": "            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > 50 ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;", "refactored_code": "    private static final int INET_CONDITION_THRESHOLD = 50;\n            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;"}
{"magic_number_smell": "        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+5*1000) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }", "refactored_code": "    private static final long MIN_TIME_BETWEEN_GCS = 5*1000;\n        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+MIN_TIME_BETWEEN_GCS) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }"}
{"magic_number_smell": "    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);"}
{"magic_number_smell": "    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);"}
{"magic_number_smell": "\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != 0x414E4554) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n", "refactored_code": "    private static final int FILE_MAGIC = 0x414E4554;\n\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != FILE_MAGIC) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n"}
{"magic_number_smell": "            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + AlarmManager.INTERVAL_HOUR;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {", "refactored_code": "    private static final long BACKUP_INTERVAL = AlarmManager.INTERVAL_HOUR;\n            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + BACKUP_INTERVAL;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {"}
{"magic_number_smell": "            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > 50 ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;", "refactored_code": "    private static final int INET_CONDITION_THRESHOLD = 50;\n            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;"}
{"magic_number_smell": "        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+5*1000) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }", "refactored_code": "    private static final long MIN_TIME_BETWEEN_GCS = 5*1000;\n        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+MIN_TIME_BETWEEN_GCS) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }"}
{"magic_number_smell": "    public void getMethodPathValid() throws Exception {\n        ServiceResponse<Void> response = client.getMethodPathValid(unencodedPath);\n        // Will throw ServiceException if not 200.\n        //Assert.assertEquals(200, response.getResponse().code());\n    }\n\n    @Ignore(\"wait for this release -- https://github.com/square/retrofit/commit/2ea70568bd057fa9235ae5183cebbde1659af84d\")", "refactored_code": "    private static final int OK_STATUS_CODE = 200;\n    public void getMethodPathValid() throws Exception {\n        ServiceResponse<Void> response = client.getMethodPathValid(unencodedPath);\n        // Will throw ServiceException if not 200.\n        //Assert.assertEquals(OK_STATUS_CODE, response.getResponse().code());\n    }\n\n    @Ignore(\"wait for this release -- https://github.com/square/retrofit/commit/2ea70568bd057fa9235ae5183cebbde1659af84d\")"}
{"magic_number_smell": "          logger.info(\"Rescheduling {} URLs from previous crawl.\", numPreviouslyInProcessPages);\n          scheduledPages -= numPreviouslyInProcessPages;\n\n          List<WebURL> urls = inProcessPages.get(100);\n          while (!urls.isEmpty()) {\n            scheduleAll(urls);\n            inProcessPages.delete(urls.size());", "refactored_code": "  private static final int MAX_IN_PROCESS_PAGES = 100;\n          logger.info(\"Rescheduling {} URLs from previous crawl.\", numPreviouslyInProcessPages);\n          scheduledPages -= numPreviouslyInProcessPages;\n\n          List<WebURL> urls = inProcessPages.get(MAX_IN_PROCESS_PAGES);\n          while (!urls.isEmpty()) {\n            scheduleAll(urls);\n            inProcessPages.delete(urls.size());"}
{"magic_number_smell": "          logger.info(\"Rescheduling {} URLs from previous crawl.\", numPreviouslyInProcessPages);\n          scheduledPages -= numPreviouslyInProcessPages;\n\n          List<WebURL> urls = inProcessPages.get(100);\n          while (!urls.isEmpty()) {\n            scheduleAll(urls);\n            inProcessPages.delete(urls.size());", "refactored_code": "  private static final int IN_PROCESS_RESCHEDULE_BATCH_SIZE = 100;\n          logger.info(\"Rescheduling {} URLs from previous crawl.\", numPreviouslyInProcessPages);\n          scheduledPages -= numPreviouslyInProcessPages;\n\n          List<WebURL> urls = inProcessPages.get(IN_PROCESS_RESCHEDULE_BATCH_SIZE);\n          while (!urls.isEmpty()) {\n            scheduleAll(urls);\n            inProcessPages.delete(urls.size());"}
{"magic_number_smell": "     */\n    private void updateLeaderboards() {\n        // Only update FFS leaderboards every 10 minutes.. this puts a lot of strain on the server (depending on the size of the database) and should not be done frequently\n        if (System.currentTimeMillis() < lastUpdate + 600000L) {\n            return;\n        }\n", "refactored_code": "    private final long UPDATE_WAIT_TIME = 600000L; // 10 minutes\n     */\n    private void updateLeaderboards() {\n        // Only update FFS leaderboards every 10 minutes.. this puts a lot of strain on the server (depending on the size of the database) and should not be done frequently\n        if (System.currentTimeMillis() < lastUpdate + UPDATE_WAIT_TIME) {\n            return;\n        }\n"}
{"magic_number_smell": "                    if (font != null)\n                    {\n                        int x = (res.getScaledWidth() - font.getStringWidth(name)) / 2;\n                        font.func_175063_a(name, x, y, 0xFFFFFF | (opacity << 24));\n                    }\n                    else\n                    {", "refactored_code": "    private static final int WHITE = 0xFFFFFF;\n                    if (font != null)\n                    {\n                        int x = (res.getScaledWidth() - font.getStringWidth(name)) / 2;\n                        font.func_175063_a(name, x, y, WHITE | (opacity << 24));\n                    }\n                    else\n                    {"}
{"magic_number_smell": "    }\n\n    private static final int BiomeGenBase.getBiomeGenArray().length = BiomeGenBase.getBiomeGenArray().length;\n    private static BiomeInfo[] biomeList = new BiomeInfo[BiomeGenBase.getBiomeGenArray().length];\n    @SuppressWarnings(\"unchecked\")\n    private static ArrayList<BiomeGenBase>[] typeInfoList = new ArrayList[Type.values().length];\n", "refactored_code": "    private static final int BIOME_LIST_SIZE = BiomeGenBase.getBiomeGenArray().length;\n    }\n\n    private static final int BIOME_LIST_SIZE = BiomeGenBase.getBiomeGenArray().length;\n    private static BiomeInfo[] biomeList = new BiomeInfo[BIOME_LIST_SIZE];\n    @SuppressWarnings(\"unchecked\")\n    private static ArrayList<BiomeGenBase>[] typeInfoList = new ArrayList[Type.values().length];\n"}
{"magic_number_smell": "\n    private int getType(String tok) {\n        if (tok.startsWith(\"string\")) { //$NON-NLS-1$\n            return 1;\n        } else if (tok.startsWith(\"belong\")) { //$NON-NLS-1$\n            return BELONG_TYPE;\n        } else if (tok.equals(\"short\")) { //$NON-NLS-1$", "refactored_code": "    public static final int STRING_TYPE = 1;\n\n    private int getType(String tok) {\n        if (tok.startsWith(\"string\")) { //$NON-NLS-1$\n            return STRING_TYPE;\n        } else if (tok.startsWith(\"belong\")) { //$NON-NLS-1$\n            return BELONG_TYPE;\n        } else if (tok.equals(\"short\")) { //$NON-NLS-1$"}
{"magic_number_smell": "    };\n    private final ArrayListComboBoxModel modelStudy = new ArrayListComboBoxModel() {\n\n        private static final long 1826724555734323483L = 2272386715266884376L;\n\n        @Override\n        public void addElement(Object anObject) {", "refactored_code": "        private static final long serialVersionUID = 1826724555734323483L;\n    };\n    private final ArrayListComboBoxModel modelStudy = new ArrayListComboBoxModel() {\n\n        private static final long serialVersionUID = 2272386715266884376L;\n\n        @Override\n        public void addElement(Object anObject) {"}
{"magic_number_smell": "     * @return array of column indices; -1 if the column with that id is not in cursor\n     */\n    public int[] Gen_columnIndices(android.database.Cursor cursor) {\n        int[] result=new int[82];\n        result[0] = cursor.getColumnIndex(GEN_FIELD__ID);\n        // Make compatible with database generated by older version of plugin with uppercase column name\n        if (result[0] == -1) {", "refactored_code": "    public static final int GEN_COUNT = 82;\n     * @return array of column indices; -1 if the column with that id is not in cursor\n     */\n    public int[] Gen_columnIndices(android.database.Cursor cursor) {\n        int[] result=new int[GEN_COUNT];\n        result[0] = cursor.getColumnIndex(GEN_FIELD__ID);\n        // Make compatible with database generated by older version of plugin with uppercase column name\n        if (result[0] == -1) {"}
{"magic_number_smell": "\n        // Prepare the loaders. Either re-connect with an existing ones,\n        // or start new ones.\n        getSupportLoaderManager().initLoader(0, null, this);\n\n        mNfcHelper = new NfcHelper(this, mProviderHelper);\n        mNfcHelper.initNfc(mDataUri);", "refactored_code": "    private static final int LOADER_ID_UNIFIED = 0;\n\n        // Prepare the loaders. Either re-connect with an existing ones,\n        // or start new ones.\n        getSupportLoaderManager().initLoader(LOADER_ID_UNIFIED, null, this);\n\n        mNfcHelper = new NfcHelper(this, mProviderHelper);\n        mNfcHelper.initNfc(mDataUri);"}
{"magic_number_smell": "        int bytes = meta.getInt();\n        int magic = meta.getInt();\n\n        if (magic != TarWriter.INDEX_MAGIC) {\n            return null; // magic byte mismatch\n        }\n", "refactored_code": "    private static final int INDEX_MAGIC = TarWriter.INDEX_MAGIC;\n        int bytes = meta.getInt();\n        int magic = meta.getInt();\n\n        if (magic != INDEX_MAGIC) {\n            return null; // magic byte mismatch\n        }\n"}
{"magic_number_smell": "    @Override\n    public void awaitShutdown() {\n        try {\n            shutdownLatch.await(3, TimeUnit.SECONDS);\n        } catch (InterruptedException ignored) {\n            EmptyStatement.ignore(ignored);\n        }", "refactored_code": "    private static final int SHUTDOWN_TIMEOUT_SECONDS = 3;\n    @Override\n    public void awaitShutdown() {\n        try {\n            shutdownLatch.await(SHUTDOWN_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n        } catch (InterruptedException ignored) {\n            EmptyStatement.ignore(ignored);\n        }"}
{"magic_number_smell": "    /**\n     * Timeout value for nodes to accept client connection requests.\n     */\n    private int connectionTimeout = 5000;\n\n    /**\n     * While client is trying to connect initially to one of the members in the {@link ClientNetworkConfig#addressList},", "refactored_code": "    private static final int CONNECTION_TIMEOUT = 5000;\n    /**\n     * Timeout value for nodes to accept client connection requests.\n     */\n    private int connectionTimeout = CONNECTION_TIMEOUT;\n\n    /**\n     * While client is trying to connect initially to one of the members in the {@link ClientNetworkConfig#addressList},"}
{"magic_number_smell": "                }\n                if (hasLine) {\n                    // hex string\n                    int dataSize = lineStr.length() == 0 ? 0 : Integer.parseInt(lineStr, 16);\n                    if (dataSize == 0) {\n                        return true;\n                    }", "refactored_code": "    private static final int RADIX = 16;\n                }\n                if (hasLine) {\n                    // hex string\n                    int dataSize = lineStr.length() == 0 ? 0 : Integer.parseInt(lineStr, RADIX);\n                    if (dataSize == 0) {\n                        return true;\n                    }"}
{"magic_number_smell": "        if (response instanceof NormalResponse && op instanceof BackupAwareOperation) {\n            final NormalResponse resp = (NormalResponse) response;\n            if (resp.getBackupCount() > 0) {\n                waitForBackups(resp.getBackupCount(), 5, TimeUnit.SECONDS, resp);\n                return;\n            }\n        }", "refactored_code": "    public static final long TIMEOUT = 5;\n        if (response instanceof NormalResponse && op instanceof BackupAwareOperation) {\n            final NormalResponse resp = (NormalResponse) response;\n            if (resp.getBackupCount() > 0) {\n                waitForBackups(resp.getBackupCount(), TIMEOUT, TimeUnit.SECONDS, resp);\n                return;\n            }\n        }"}
{"magic_number_smell": "\n            BasicInvocation inv = new BasicTargetInvocation(\n                    basicInvocation.nodeEngine, basicInvocation.serviceName, isStillExecuting,\n                    target, 0, 0, 5000, null, null, true);\n            Future f = inv.invoke();\n            basicInvocation.logger.warning(\"Asking if operation execution has been started: \" + toString());\n            executing = (Boolean) basicInvocation.nodeEngine.toObject(f.get(GET_TIME, TimeUnit.MILLISECONDS));", "refactored_code": "    private static final long CALL_TIMEOUT = 5000;\n\n            BasicInvocation inv = new BasicTargetInvocation(\n                    basicInvocation.nodeEngine, basicInvocation.serviceName, isStillExecuting,\n                    target, 0, 0, CALL_TIMEOUT, null, null, true);\n            Future f = inv.invoke();\n            basicInvocation.logger.warning(\"Asking if operation execution has been started: \" + toString());\n            executing = (Boolean) basicInvocation.nodeEngine.toObject(f.get(GET_TIME, TimeUnit.MILLISECONDS));"}
{"magic_number_smell": "        boolean reallyMultiCore = coreSize >= CORE_SIZE_CHECK;\n        int concurrencyLevel = reallyMultiCore ? coreSize * CORE_SIZE_FACTOR : CONCURRENCY_LEVEL;\n        this.executingCalls =\n                new ConcurrentHashMap<RemoteCallKey, RemoteCallKey>(1000, LOAD_FACTOR, concurrencyLevel);\n        this.invocations = new ConcurrentHashMap<Long, BasicInvocation>(1000, LOAD_FACTOR, concurrencyLevel);\n        this.scheduler = new BasicOperationScheduler(node, executionService, new BasicOperationProcessorImpl());\n    }", "refactored_code": "    private static final int INITIAL_CAPACITY = 1000;\n        boolean reallyMultiCore = coreSize >= CORE_SIZE_CHECK;\n        int concurrencyLevel = reallyMultiCore ? coreSize * CORE_SIZE_FACTOR : CONCURRENCY_LEVEL;\n        this.executingCalls =\n                new ConcurrentHashMap<RemoteCallKey, RemoteCallKey>(INITIAL_CAPACITY, LOAD_FACTOR, concurrencyLevel);\n        this.invocations = new ConcurrentHashMap<Long, BasicInvocation>(INITIAL_CAPACITY, LOAD_FACTOR, concurrencyLevel);\n        this.scheduler = new BasicOperationScheduler(node, executionService, new BasicOperationProcessorImpl());\n    }"}
{"magic_number_smell": "    /**\n     * Timeout value for nodes to accept client connection requests.\n     */\n    private int connectionTimeout = 5000;\n\n    /**\n     * While client is trying to connect initially to one of the members in the {@link ClientNetworkConfig#addressList},", "refactored_code": "    private static final int CONNECTION_TIMEOUT = 5000;\n    /**\n     * Timeout value for nodes to accept client connection requests.\n     */\n    private int connectionTimeout = CONNECTION_TIMEOUT;\n\n    /**\n     * While client is trying to connect initially to one of the members in the {@link ClientNetworkConfig#addressList},"}
{"magic_number_smell": "                }\n                if (hasLine) {\n                    // hex string\n                    int dataSize = lineStr.length() == 0 ? 0 : Integer.parseInt(lineStr, 16);\n                    if (dataSize == 0) {\n                        return true;\n                    }", "refactored_code": "    private static final int RADIX = 16;\n                }\n                if (hasLine) {\n                    // hex string\n                    int dataSize = lineStr.length() == 0 ? 0 : Integer.parseInt(lineStr, RADIX);\n                    if (dataSize == 0) {\n                        return true;\n                    }"}
{"magic_number_smell": "        if (response instanceof NormalResponse && op instanceof BackupAwareOperation) {\n            final NormalResponse resp = (NormalResponse) response;\n            if (resp.getBackupCount() > 0) {\n                waitForBackups(resp.getBackupCount(), 5, TimeUnit.SECONDS, resp);\n                return;\n            }\n        }", "refactored_code": "    public static final long TIMEOUT = 5;\n        if (response instanceof NormalResponse && op instanceof BackupAwareOperation) {\n            final NormalResponse resp = (NormalResponse) response;\n            if (resp.getBackupCount() > 0) {\n                waitForBackups(resp.getBackupCount(), TIMEOUT, TimeUnit.SECONDS, resp);\n                return;\n            }\n        }"}
{"magic_number_smell": "\n            BasicInvocation inv = new BasicTargetInvocation(\n                    basicInvocation.nodeEngine, basicInvocation.serviceName, isStillExecuting,\n                    target, 0, 0, 5000, null, null, true);\n            Future f = inv.invoke();\n            basicInvocation.logger.warning(\"Asking if operation execution has been started: \" + toString());\n            executing = (Boolean) basicInvocation.nodeEngine.toObject(f.get(GET_TIME, TimeUnit.MILLISECONDS));", "refactored_code": "    private static final long CALL_TIMEOUT = 5000;\n\n            BasicInvocation inv = new BasicTargetInvocation(\n                    basicInvocation.nodeEngine, basicInvocation.serviceName, isStillExecuting,\n                    target, 0, 0, CALL_TIMEOUT, null, null, true);\n            Future f = inv.invoke();\n            basicInvocation.logger.warning(\"Asking if operation execution has been started: \" + toString());\n            executing = (Boolean) basicInvocation.nodeEngine.toObject(f.get(GET_TIME, TimeUnit.MILLISECONDS));"}
{"magic_number_smell": "        boolean reallyMultiCore = coreSize >= CORE_SIZE_CHECK;\n        int concurrencyLevel = reallyMultiCore ? coreSize * CORE_SIZE_FACTOR : CONCURRENCY_LEVEL;\n        this.executingCalls =\n                new ConcurrentHashMap<RemoteCallKey, RemoteCallKey>(1000, LOAD_FACTOR, concurrencyLevel);\n        this.invocations = new ConcurrentHashMap<Long, BasicInvocation>(1000, LOAD_FACTOR, concurrencyLevel);\n        this.scheduler = new BasicOperationScheduler(node, executionService, new BasicOperationProcessorImpl());\n    }", "refactored_code": "    private static final int INITIAL_CAPACITY = 1000;\n        boolean reallyMultiCore = coreSize >= CORE_SIZE_CHECK;\n        int concurrencyLevel = reallyMultiCore ? coreSize * CORE_SIZE_FACTOR : CONCURRENCY_LEVEL;\n        this.executingCalls =\n                new ConcurrentHashMap<RemoteCallKey, RemoteCallKey>(INITIAL_CAPACITY, LOAD_FACTOR, concurrencyLevel);\n        this.invocations = new ConcurrentHashMap<Long, BasicInvocation>(INITIAL_CAPACITY, LOAD_FACTOR, concurrencyLevel);\n        this.scheduler = new BasicOperationScheduler(node, executionService, new BasicOperationProcessorImpl());\n    }"}
{"magic_number_smell": "        if (getCollection().add(item)) {\n            return item.getItemId();\n        }\n        return -1;\n    }\n\n    public void addBackup(long itemId, Data value) {", "refactored_code": "    public static final int INVALID_ITEM_ID = -1;\n        if (getCollection().add(item)) {\n            return item.getItemId();\n        }\n        return INVALID_ITEM_ID;\n    }\n\n    public void addBackup(long itemId, Data value) {"}
{"magic_number_smell": "                setId(lastItem.getItemId() + ID_PROMOTION_OFFSET);\n                itemMap.clear();\n            } else {\n                itemList = new ArrayList<CollectionItem>(1000);\n            }\n            itemMap = null;\n        }", "refactored_code": "    private static final int INITIAL_CAPACITY = 1000;\n                setId(lastItem.getItemId() + ID_PROMOTION_OFFSET);\n                itemMap.clear();\n            } else {\n                itemList = new ArrayList<CollectionItem>(INITIAL_CAPACITY);\n            }\n            itemMap = null;\n        }"}
{"magic_number_smell": "                setId(maxItemId + ID_PROMOTION_OFFSET);\n                itemMap.clear();\n            } else {\n                itemSet = new HashSet<CollectionItem>(1000);\n            }\n            itemMap = null;\n        }", "refactored_code": "    private static final int INITIAL_CAPACITY = 1000;\n                setId(maxItemId + ID_PROMOTION_OFFSET);\n                itemMap.clear();\n            } else {\n                itemSet = new HashSet<CollectionItem>(INITIAL_CAPACITY);\n            }\n            itemMap = null;\n        }"}
{"magic_number_smell": "        LOGGER.info(\"Collection \" + collectionName + \" is stored in partition \" + partitionId);\n\n        // scale up\n        LOGGER.info(\"Scaling up to \" + (4 + 1) + \" members...\");\n        for (int backupCount = 1; backupCount <= 4; backupCount++) {\n            factory.newHazelcastInstance(config);\n            waitAllForSafeState(factory.getAllHazelcastInstances());", "refactored_code": "    protected static final int BACKUP_COUNT = 4;\n        LOGGER.info(\"Collection \" + collectionName + \" is stored in partition \" + partitionId);\n\n        // scale up\n        LOGGER.info(\"Scaling up to \" + (BACKUP_COUNT + 1) + \" members...\");\n        for (int backupCount = 1; backupCount <= BACKUP_COUNT; backupCount++) {\n            factory.newHazelcastInstance(config);\n            waitAllForSafeState(factory.getAllHazelcastInstances());"}
{"magic_number_smell": "        if (getCollection().add(item)) {\n            return item.getItemId();\n        }\n        return -1;\n    }\n\n    public void addBackup(long itemId, Data value) {", "refactored_code": "    public static final int INVALID_ITEM_ID = -1;\n        if (getCollection().add(item)) {\n            return item.getItemId();\n        }\n        return INVALID_ITEM_ID;\n    }\n\n    public void addBackup(long itemId, Data value) {"}
{"magic_number_smell": "                setId(lastItem.getItemId() + ID_PROMOTION_OFFSET);\n                itemMap.clear();\n            } else {\n                itemList = new ArrayList<CollectionItem>(1000);\n            }\n            itemMap = null;\n        }", "refactored_code": "    private static final int INITIAL_CAPACITY = 1000;\n                setId(lastItem.getItemId() + ID_PROMOTION_OFFSET);\n                itemMap.clear();\n            } else {\n                itemList = new ArrayList<CollectionItem>(INITIAL_CAPACITY);\n            }\n            itemMap = null;\n        }"}
{"magic_number_smell": "                setId(maxItemId + ID_PROMOTION_OFFSET);\n                itemMap.clear();\n            } else {\n                itemSet = new HashSet<CollectionItem>(1000);\n            }\n            itemMap = null;\n        }", "refactored_code": "    private static final int INITIAL_CAPACITY = 1000;\n                setId(maxItemId + ID_PROMOTION_OFFSET);\n                itemMap.clear();\n            } else {\n                itemSet = new HashSet<CollectionItem>(INITIAL_CAPACITY);\n            }\n            itemMap = null;\n        }"}
{"magic_number_smell": "        LOGGER.info(\"Collection \" + collectionName + \" is stored in partition \" + partitionId);\n\n        // scale up\n        LOGGER.info(\"Scaling up to \" + (4 + 1) + \" members...\");\n        for (int backupCount = 1; backupCount <= 4; backupCount++) {\n            factory.newHazelcastInstance(config);\n            waitAllForSafeState(factory.getAllHazelcastInstances());", "refactored_code": "    protected static final int BACKUP_COUNT = 4;\n        LOGGER.info(\"Collection \" + collectionName + \" is stored in partition \" + partitionId);\n\n        // scale up\n        LOGGER.info(\"Scaling up to \" + (BACKUP_COUNT + 1) + \" members...\");\n        for (int backupCount = 1; backupCount <= BACKUP_COUNT; backupCount++) {\n            factory.newHazelcastInstance(config);\n            waitAllForSafeState(factory.getAllHazelcastInstances());"}
{"magic_number_smell": "                deltaProgressDown.addDelta(50, 55, -1);\n            }\n            if (progressDown >= 50) {\n                sendNetworkGuiUpdate(IDS.allocId(\"DOWN\"));\n                invDownOut.setStackInSlot(0, invDownIn.getStackInSlot(0));\n                invDownIn.setStackInSlot(0, StackUtil.EMPTY);\n                progressDown = -1;", "refactored_code": "    public static final int NET_DOWN = IDS.allocId(\"DOWN\");\n                deltaProgressDown.addDelta(50, 55, -1);\n            }\n            if (progressDown >= 50) {\n                sendNetworkGuiUpdate(NET_DOWN);\n                invDownOut.setStackInSlot(0, invDownIn.getStackInSlot(0));\n                invDownIn.setStackInSlot(0, StackUtil.EMPTY);\n                progressDown = -1;"}
{"magic_number_smell": "            throw new IllegalStateException(e);\n        }\n        int realLength = SHA_256.getDigestLength();\n        if (realLength != 32) {\n            // Just in case\n            throw new IllegalStateException(\"Digest length of sha-256 is meant to be 32, but returned \" + realLength);\n        }", "refactored_code": "    public static final int DIGEST_LENGTH = 32;\n            throw new IllegalStateException(e);\n        }\n        int realLength = SHA_256.getDigestLength();\n        if (realLength != DIGEST_LENGTH) {\n            // Just in case\n            throw new IllegalStateException(\"Digest length of sha-256 is meant to be 32, but returned \" + realLength);\n        }"}
{"magic_number_smell": "            case TYPE_MC:\n                squishVanillaUncompressed(nbt, new DataOutputStream(stream));\n                return;\n            case NbtSquishConstants.VANILLA_COMPRESSED:\n                squishVanilla(nbt, stream);\n                return;\n            case TYPE_BC_1:", "refactored_code": "    private static final int TYPE_MC_GZIP = NbtSquishConstants.VANILLA_COMPRESSED;\n            case TYPE_MC:\n                squishVanillaUncompressed(nbt, new DataOutputStream(stream));\n                return;\n            case TYPE_MC_GZIP:\n                squishVanilla(nbt, stream);\n                return;\n            case TYPE_BC_1:"}
{"magic_number_smell": "\t\tWebcam.setDriver(new DummyDriver());\n\n\t\tfinal Webcam w = Webcam.getDefault();\n\t\tfinal WebcamPanel p = new WebcamPanel(w, new Dimension(256, height), false);\n\n\t\tw.open();\n\t\tp.repaint();", "refactored_code": "\tprivate final int width = 256;\n\t\tWebcam.setDriver(new DummyDriver());\n\n\t\tfinal Webcam w = Webcam.getDefault();\n\t\tfinal WebcamPanel p = new WebcamPanel(w, new Dimension(width, height), false);\n\n\t\tw.open();\n\t\tp.repaint();"}
{"magic_number_smell": "\tprivate static final long MAGIC = MAGIC_BASE | (MAJOR << 8) | MINOR;\r\n\tprivate long magicBytes = MAGIC;\r\n\tpublic static final int MAGIC_CONT = 0x434f4e54;   // \"CONT\"\r\n\tprivate long fileLen = 1024 * 2;\r\n\tprivate int freeListStart = 0;\r\n\tprivate int mounted = 0;\r\n\tpublic int spanSize = 16;\r", "refactored_code": "\tpublic static final long PAGESIZE = 1024;\r\n\tprivate static final long MAGIC = MAGIC_BASE | (MAJOR << 8) | MINOR;\r\n\tprivate long magicBytes = MAGIC;\r\n\tpublic static final int MAGIC_CONT = 0x434f4e54;   // \"CONT\"\r\n\tprivate long fileLen = PAGESIZE * 2;\r\n\tprivate int freeListStart = 0;\r\n\tprivate int mounted = 0;\r\n\tpublic int spanSize = 16;\r"}
{"magic_number_smell": "\r\n\t\tBlockFile.pageSeek(bf.file, levelPage);\r\n\t\tlong magic = bf.file.readLong();\r\n\t\tif (magic != 0x42534c6576656c73l)\r\n\t\t\tthrow new IOException(\"Bad SkipLevels magic number 0x\" + Long.toHexString(magic) + \" on page \" + levelPage);\r\n\r\n\t\tbsl.levelHash.put(new Integer(this.levelPage), this);\r", "refactored_code": "\tprivate static final long MAGIC = 0x42534c6576656c73l;  // \"BSLevels\"\r\n\r\n\t\tBlockFile.pageSeek(bf.file, levelPage);\r\n\t\tlong magic = bf.file.readLong();\r\n\t\tif (magic != MAGIC)\r\n\t\t\tthrow new IOException(\"Bad SkipLevels magic number 0x\" + Long.toHexString(magic) + \" on page \" + levelPage);\r\n\r\n\t\tbsl.levelHash.put(new Integer(this.levelPage), this);\r"}
{"magic_number_smell": "\r\n\t\tBlockFile.pageSeek(bf.file, skipPage);\r\n\t\tlong magic = bf.file.readLong();\r\n\t\tif (magic != 0x536b69704c697374l)\r\n\t\t\tthrow new IOException(\"Bad SkipList magic number 0x\" + Long.toHexString(magic) + \" on page \" + skipPage);\r\n\t\tfirstSpanPage = bf.file.readUnsignedInt();\r\n\t\tfirstLevelPage = bf.file.readUnsignedInt();\r", "refactored_code": "\tprivate static final long MAGIC = 0x536b69704c697374l;  // \"SkipList\"\r\n\r\n\t\tBlockFile.pageSeek(bf.file, skipPage);\r\n\t\tlong magic = bf.file.readLong();\r\n\t\tif (magic != MAGIC)\r\n\t\t\tthrow new IOException(\"Bad SkipList magic number 0x\" + Long.toHexString(magic) + \" on page \" + skipPage);\r\n\t\tfirstSpanPage = bf.file.readUnsignedInt();\r\n\t\tfirstLevelPage = bf.file.readUnsignedInt();\r"}
{"magic_number_smell": "\r\n\tpublic static void init(BlockFile bf, int page, int spanSize) throws IOException {\r\n\t\tBlockFile.pageSeek(bf.file, page);\r\n\t\tbf.file.writeInt(0x5370616e);\r\n\t\tbf.file.writeInt(0);\r\n\t\tbf.file.writeInt(0);\r\n\t\tbf.file.writeInt(0);\r", "refactored_code": "\tprotected static final int MAGIC = 0x5370616e;  // \"Span\"\r\n\r\n\tpublic static void init(BlockFile bf, int page, int spanSize) throws IOException {\r\n\t\tBlockFile.pageSeek(bf.file, page);\r\n\t\tbf.file.writeInt(MAGIC);\r\n\t\tbf.file.writeInt(0);\r\n\t\tbf.file.writeInt(0);\r\n\t\tbf.file.writeInt(0);\r"}
{"magic_number_smell": "\t\t\t\t\t( mailPart.name != null ? mailPart.name + \", \" : \"\" ) +\r\n\t\t\t\t\t( mailPart.type != null ? '(' + mailPart.type + ')' : _(\"unknown\") ) );\r\n\t\t\t\r\n\t\t\tif( level == 0 && mailPart.13 == null ) {\r\n\t\t\t\t/*\r\n\t\t\t\t * not a MIME mail, so simply print it literally\r\n\t\t\t\t */\r", "refactored_code": "\tprivate static final int version = 13;\r\n\t\t\t\t\t( mailPart.name != null ? mailPart.name + \", \" : \"\" ) +\r\n\t\t\t\t\t( mailPart.type != null ? '(' + mailPart.type + ')' : _(\"unknown\") ) );\r\n\t\t\t\r\n\t\t\tif( level == 0 && mailPart.version == null ) {\r\n\t\t\t\t/*\r\n\t\t\t\t * not a MIME mail, so simply print it literally\r\n\t\t\t\t */\r"}
{"magic_number_smell": "\t\t\tbreak;\n\t\t\tcase ROTATION_STYLE_ALL_AROUND : direction = realRotation;\n\t\t\tbreak;\n\t\t\tcase 0 : direction =\n\t\t\t\t\tisFlipped() ? -DEGREE_UI_OFFSET : DEGREE_UI_OFFSET;\n\t\t}\n\t\treturn direction;", "refactored_code": "\tpublic static final int ROTATION_STYLE_LEFT_RIGHT_ONLY = 0;\n\t\t\tbreak;\n\t\t\tcase ROTATION_STYLE_ALL_AROUND : direction = realRotation;\n\t\t\tbreak;\n\t\t\tcase ROTATION_STYLE_LEFT_RIGHT_ONLY : direction =\n\t\t\t\t\tisFlipped() ? -DEGREE_UI_OFFSET : DEGREE_UI_OFFSET;\n\t\t}\n\t\treturn direction;"}
{"magic_number_smell": "\t\t\tscaleY = 0.0f;\n\t\t}\n\n\t\tint scaleXComp = Math.round(scaleX * 10000.0f);\n\t\tint scaleYComp = Math.round(scaleY * 10000.0f);\n\n\t\tint oldScaleXComp = Math.round(oldScales.x * 10000.0f);", "refactored_code": "\tpublic static final float SCALE_FACTOR_ACCURACY = 10000.0f;\n\t\t\tscaleY = 0.0f;\n\t\t}\n\n\t\tint scaleXComp = Math.round(scaleX * SCALE_FACTOR_ACCURACY);\n\t\tint scaleYComp = Math.round(scaleY * SCALE_FACTOR_ACCURACY);\n\n\t\tint oldScaleXComp = Math.round(oldScales.x * SCALE_FACTOR_ACCURACY);"}
{"magic_number_smell": "\t * into a combined string or regex.\n\t */\n\tpublic static class SortedHeaderMap extends TreeMap<String, String> {\n\t\tprivate static final long -3998102753945339020L = -5090333053981045429L;\n\t\tString headers = null;\n\n\t\tpublic SortedHeaderMap() {", "refactored_code": "\t\t\t\t\tprivate static final long serialVersionUID = -3998102753945339020L;\n\t * into a combined string or regex.\n\t */\n\tpublic static class SortedHeaderMap extends TreeMap<String, String> {\n\t\tprivate static final long serialVersionUID = -5090333053981045429L;\n\t\tString headers = null;\n\n\t\tpublic SortedHeaderMap() {"}
{"magic_number_smell": "\t\tRunnable defer = () -> {\n\t\t\tlong start = startTime;\n\t\t\ttry {\n\t\t\t\tThread.sleep(4000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tLOGGER.error(\"stopPlaying sleep interrupted\", e);\n\t\t\t}", "refactored_code": "\tprivate static final int STOP_PLAYING_DELAY = 4000;\n\t\tRunnable defer = () -> {\n\t\t\tlong start = startTime;\n\t\t\ttry {\n\t\t\t\tThread.sleep(STOP_PLAYING_DELAY);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tLOGGER.error(\"stopPlaying sleep interrupted\", e);\n\t\t\t}"}
{"magic_number_smell": "\n\t\t\tif (lowRange != DLNAMediaInfo.ENDFILE_POS && !HEAD.equals(method)) {\n\t\t\t\t// Send the response body to the client in chunks.\n\t\t\t\tChannelFuture chunkWriteFuture = event.getChannel().write(new ChunkedStream(inputStream, 8 * 1024));\n\n\t\t\t\t// Add a listener to clean up after sending the entire response body.\n\t\t\t\tfinal InputStream finalInputStream = inputStream;", "refactored_code": "\tprivate static final int BUFFER_SIZE = 8 * 1024;\n\n\t\t\tif (lowRange != DLNAMediaInfo.ENDFILE_POS && !HEAD.equals(method)) {\n\t\t\t\t// Send the response body to the client in chunks.\n\t\t\t\tChannelFuture chunkWriteFuture = event.getChannel().write(new ChunkedStream(inputStream, BUFFER_SIZE));\n\n\t\t\t\t// Add a listener to clean up after sending the entire response body.\n\t\t\t\tfinal InputStream finalInputStream = inputStream;"}
{"magic_number_smell": "\t\tRunnable defer = () -> {\n\t\t\tlong start = startTime;\n\t\t\ttry {\n\t\t\t\tThread.sleep(4000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tLOGGER.error(\"stopPlaying sleep interrupted\", e);\n\t\t\t}", "refactored_code": "\tprivate static final int STOP_PLAYING_DELAY = 4000;\n\t\tRunnable defer = () -> {\n\t\t\tlong start = startTime;\n\t\t\ttry {\n\t\t\t\tThread.sleep(STOP_PLAYING_DELAY);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tLOGGER.error(\"stopPlaying sleep interrupted\", e);\n\t\t\t}"}
{"magic_number_smell": "      if (commandLineArgs.containsKey(CommandLineIntepreter.OPTION_ADMINPORT)) {\n         return Integer.parseInt(commandLineArgs.get(CommandLineIntepreter.OPTION_ADMINPORT));\n      }\n      return 8889;\n   }\n}", "refactored_code": "   public static final int DEFAULT_ADMIN_PORT = 8889;\n      if (commandLineArgs.containsKey(CommandLineIntepreter.OPTION_ADMINPORT)) {\n         return Integer.parseInt(commandLineArgs.get(CommandLineIntepreter.OPTION_ADMINPORT));\n      }\n      return DEFAULT_ADMIN_PORT;\n   }\n}"}
{"magic_number_smell": "        Sort sortByMetadataChangeDate = SortUtils.createSort(Sort.Direction.DESC, Metadata_.dataInfo, MetadataDataInfo_.changeDate);\n        int currentPage = 0;\n        Page<Pair<Integer, ISODate>> results = metadataUtils.findAllIdsAndChangeDates(\n            PageRequest.of(currentPage, 50000, sortByMetadataChangeDate));\n\n        // index all metadata in DBMS if needed\n        while (results.getNumberOfElements() > 0) {", "refactored_code": "    private static final int METADATA_BATCH_PAGE_SIZE = 50000;\n        Sort sortByMetadataChangeDate = SortUtils.createSort(Sort.Direction.DESC, Metadata_.dataInfo, MetadataDataInfo_.changeDate);\n        int currentPage = 0;\n        Page<Pair<Integer, ISODate>> results = metadataUtils.findAllIdsAndChangeDates(\n            PageRequest.of(currentPage, METADATA_BATCH_PAGE_SIZE, sortByMetadataChangeDate));\n\n        // index all metadata in DBMS if needed\n        while (results.getNumberOfElements() > 0) {"}
{"magic_number_smell": "        // TODO We limit the notification of config changes to a specific path level, for example\n        //  /dubbo/config/service/configurators, other config changes not in this level will not get notified,\n        //  say /dubbo/config/dubbo.properties\n        if (path.split(\"/\").length >= 5) {\n            String key = pathToKey(path);\n            ConfigChangeType changeType;\n            switch (eventType) {", "refactored_code": "    private static final int MIN_PATH_DEPTH = 5;\n        // TODO We limit the notification of config changes to a specific path level, for example\n        //  /dubbo/config/service/configurators, other config changes not in this level will not get notified,\n        //  say /dubbo/config/dubbo.properties\n        if (path.split(\"/\").length >= MIN_PATH_DEPTH) {\n            String key = pathToKey(path);\n            ConfigChangeType changeType;\n            switch (eventType) {"}
{"magic_number_smell": "                }\r\n            }\r\n        }\r\n        RetryTimerTask retryTimerTask = new RetryTimerTask(loadbalance, invocation, invokers, lastInvoker, retries, 5);\r\n        try {\r\n            failTimer.newTimeout(retryTimerTask, 5, TimeUnit.SECONDS);\r\n        } catch (Throwable e) {\r", "refactored_code": "    private static final long RETRY_FAILED_PERIOD = 5;\r\n                }\r\n            }\r\n        }\r\n        RetryTimerTask retryTimerTask = new RetryTimerTask(loadbalance, invocation, invokers, lastInvoker, retries, RETRY_FAILED_PERIOD);\r\n        try {\r\n            failTimer.newTimeout(retryTimerTask, RETRY_FAILED_PERIOD, TimeUnit.SECONDS);\r\n        } catch (Throwable e) {\r"}
{"magic_number_smell": "\n    public static final String ETCD3_NOTIFY_MAXTHREADS_KEYS = \"etcd3.notify.maxthreads\";\n\n    public static final int DEFAULT_ETCD3_NOTIFY_THREADS = Math.min(Runtime.getRuntime().availableProcessors() + 1, 32);\n\n    public static final String DEFAULT_ETCD3_NOTIFY_QUEUES_KEY = \"etcd3.notify.queues\";\n", "refactored_code": "    public static final int DEFAULT_IO_THREADS = Math.min(Runtime.getRuntime().availableProcessors() + 1, 32);\n\n    public static final String ETCD3_NOTIFY_MAXTHREADS_KEYS = \"etcd3.notify.maxthreads\";\n\n    public static final int DEFAULT_ETCD3_NOTIFY_THREADS = DEFAULT_IO_THREADS;\n\n    public static final String DEFAULT_ETCD3_NOTIFY_QUEUES_KEY = \"etcd3.notify.queues\";\n"}
{"magic_number_smell": "        // TODO We limit the notification of config changes to a specific path level, for example\n        //  /dubbo/config/service/configurators, other config changes not in this level will not get notified,\n        //  say /dubbo/config/dubbo.properties\n        if (path.split(\"/\").length >= 5) {\n            String key = pathToKey(path);\n            ConfigChangeType changeType;\n            switch (eventType) {", "refactored_code": "    private static final int MIN_PATH_DEPTH = 5;\n        // TODO We limit the notification of config changes to a specific path level, for example\n        //  /dubbo/config/service/configurators, other config changes not in this level will not get notified,\n        //  say /dubbo/config/dubbo.properties\n        if (path.split(\"/\").length >= MIN_PATH_DEPTH) {\n            String key = pathToKey(path);\n            ConfigChangeType changeType;\n            switch (eventType) {"}
{"magic_number_smell": "\n    public int getPriority()\n    {\n        return 0;\n    }\n\n    public boolean match( MappingFilter filter, AnyHolder value ) throws UnsupportedFilterableData", "refactored_code": "    public static final int DEFAULT_PRIORITY = 0;\n\n    public int getPriority()\n    {\n        return DEFAULT_PRIORITY;\n    }\n\n    public boolean match( MappingFilter filter, AnyHolder value ) throws UnsupportedFilterableData"}
{"magic_number_smell": "\t * @throws IOException\r\n\t */\r\n\tpublic void writeHeader() throws IOException {\r\n\t\tout.writeByte(0x01);\r\n\t\tout.writeChar(MAGIC_NUMBER);\r\n\t\tout.writeChar(FORMAT_VERSION);\r\n\t}\r", "refactored_code": "\tpublic static final byte BLOCK_HEADER = 0x01;\r\n\t * @throws IOException\r\n\t */\r\n\tpublic void writeHeader() throws IOException {\r\n\t\tout.writeByte(BLOCK_HEADER);\r\n\t\tout.writeChar(MAGIC_NUMBER);\r\n\t\tout.writeChar(FORMAT_VERSION);\r\n\t}\r"}
{"magic_number_smell": "     * is returned.\n     */\n    public static <T> boolean anyMatch(Iterator<? extends T> iterator, Predicate<? super T> pred) {\n        return matches(iterator, pred, 0);\n    }\n\n    /**", "refactored_code": "    private static final int MATCH_ANY = 0;\n     * is returned.\n     */\n    public static <T> boolean anyMatch(Iterator<? extends T> iterator, Predicate<? super T> pred) {\n        return matches(iterator, pred, MATCH_ANY);\n    }\n\n    /**"}
{"magic_number_smell": "     * and accumulates it into an unmodifiable list.\n     */\n    public static <T, R> List<R> map(Iterable<? extends T> from, Function<? super T, ? extends R> f) {\n        return map(from.iterator(), -1, f);\n    }\n\n    /**", "refactored_code": "    private static final int UNKNOWN_SIZE = -1;\n     * and accumulates it into an unmodifiable list.\n     */\n    public static <T, R> List<R> map(Iterable<? extends T> from, Function<? super T, ? extends R> f) {\n        return map(from.iterator(), UNKNOWN_SIZE, f);\n    }\n\n    /**"}
{"magic_number_smell": "\n                // where\n                //     shipdate <= '1998-09-02'\n                if (shipDate <= DateTimeUtils.parseDate(\"1998-09-02\")) {\n                    //     returnflag,\n                    //     linestatus\n                    //     quantity", "refactored_code": "        private static final int MAX_SHIP_DATE = DateTimeUtils.parseDate(\"1998-09-02\");\n\n                // where\n                //     shipdate <= '1998-09-02'\n                if (shipDate <= MAX_SHIP_DATE) {\n                    //     returnflag,\n                    //     linestatus\n                    //     quantity"}
{"magic_number_smell": "                    maxPartialMemory,\n                    spillEnabled,\n                    unspillMemoryLimit,\n                    DataSize.succinctBytes((long) (unspillMemoryLimit.toBytes() * 0.9)),\n                    spillerFactory,\n                    joinCompiler);\n        }", "refactored_code": "    private static final double MERGE_WITH_MEMORY_RATIO = 0.9;\n                    maxPartialMemory,\n                    spillEnabled,\n                    unspillMemoryLimit,\n                    DataSize.succinctBytes((long) (unspillMemoryLimit.toBytes() * MERGE_WITH_MEMORY_RATIO)),\n                    spillerFactory,\n                    joinCompiler);\n        }"}
{"magic_number_smell": "            @Override\n            public boolean hasNext()\n            {\n                return position < groupByHash.getGroupCount();\n            }\n\n            @Override", "refactored_code": "            private final int totalPositions = groupByHash.getGroupCount();\n            @Override\n            public boolean hasNext()\n            {\n                return position < totalPositions;\n            }\n\n            @Override"}
{"magic_number_smell": "            boolean hashAggregation = operatorType.equalsIgnoreCase(\"hash\");\n\n            RowPagesBuilder pagesBuilder = RowPagesBuilder.rowPagesBuilder(hashAggregation, ImmutableList.of(0), VARCHAR, BIGINT);\n            for (int i = 0; i < 140; i++) {\n                BlockBuilder blockBuilder = VARCHAR.createBlockBuilder(null, ROWS_PER_PAGE);\n                for (int j = 0; j < groupsPerPage; j++) {\n                    String groupKey = format(\"%s\", i * groupsPerPage + j);", "refactored_code": "        public static final int TOTAL_PAGES = 140;\n            boolean hashAggregation = operatorType.equalsIgnoreCase(\"hash\");\n\n            RowPagesBuilder pagesBuilder = RowPagesBuilder.rowPagesBuilder(hashAggregation, ImmutableList.of(0), VARCHAR, BIGINT);\n            for (int i = 0; i < TOTAL_PAGES; i++) {\n                BlockBuilder blockBuilder = VARCHAR.createBlockBuilder(null, ROWS_PER_PAGE);\n                for (int j = 0; j < groupsPerPage; j++) {\n                    String groupKey = format(\"%s\", i * groupsPerPage + j);"}
{"magic_number_smell": "    @Test(dataProvider = \"hashEnabledAndMemoryLimitForMergeValues\")\n    public void testHashBuilderResize(boolean hashEnabled, boolean spillEnabled, long memoryLimitForMerge, long memoryLimitForMergeWithMemory)\n    {\n        BlockBuilder builder = VARCHAR.createBlockBuilder(null, 1, 64 * 1024);\n        VARCHAR.writeSlice(builder, Slices.allocate(200_000)); // this must be larger than 64 * 1024, 64K\n        builder.build();\n", "refactored_code": "    private static final int MAX_BLOCK_SIZE_IN_BYTES = 64 * 1024;\n    @Test(dataProvider = \"hashEnabledAndMemoryLimitForMergeValues\")\n    public void testHashBuilderResize(boolean hashEnabled, boolean spillEnabled, long memoryLimitForMerge, long memoryLimitForMergeWithMemory)\n    {\n        BlockBuilder builder = VARCHAR.createBlockBuilder(null, 1, MAX_BLOCK_SIZE_IN_BYTES);\n        VARCHAR.writeSlice(builder, Slices.allocate(200_000)); // this must be larger than MAX_BLOCK_SIZE_IN_BYTES, 64K\n        builder.build();\n"}
{"magic_number_smell": "\t\t// header\r\n\t\tByteBuffer buffer = ByteBuffer.allocate(SIZEOF_INT + SIZEOF_INT + SIZEOF_INT);\r\n\r\n\t\tbuffer.putInt(0xC0DEDEA1);\r\n\t\tbuffer.putInt(currentVersion);\r\n\t\tbuffer.putInt(length);\r\n\t\ttarget.write(buffer.array());\r", "refactored_code": "\tprivate final int byteOrder = 0xC0DEDEA1;\r\n\t\t// header\r\n\t\tByteBuffer buffer = ByteBuffer.allocate(SIZEOF_INT + SIZEOF_INT + SIZEOF_INT);\r\n\r\n\t\tbuffer.putInt(byteOrder);\r\n\t\tbuffer.putInt(currentVersion);\r\n\t\tbuffer.putInt(length);\r\n\t\ttarget.write(buffer.array());\r"}
{"magic_number_smell": "      } else {\n        sqliteConnection.open(false);\n      }\n      sqliteConnection.setBusyTimeout(SQLiteAccessMethod.1000);\n    } catch (final SQLiteException e) {\n      LOGGER.error(e.getMessage(), e);\n      throw new DbException(e);", "refactored_code": "  private static final long DEFAULT_BUSY_TIMEOUT = 1000;\n      } else {\n        sqliteConnection.open(false);\n      }\n      sqliteConnection.setBusyTimeout(SQLiteAccessMethod.DEFAULT_BUSY_TIMEOUT);\n    } catch (final SQLiteException e) {\n      LOGGER.error(e.getMessage(), e);\n      throw new DbException(e);"}
{"magic_number_smell": "     */\n    @Override\n    public int hashCode() {\n        int hash = 3;\n        hash = MAGIC_HASH_MULTIPLIER * hash + ObjectUtils.hashCode(StringUtils.lowerCase(this.name));\n        hash = MAGIC_HASH_MULTIPLIER * hash + ObjectUtils.hashCode(StringUtils.lowerCase(this.source));\n        hash = MAGIC_HASH_MULTIPLIER * hash + ObjectUtils.hashCode(StringUtils.lowerCase(this.value));", "refactored_code": "    private static final int MAGIC_HASH_INIT_VALUE = 3;\n     */\n    @Override\n    public int hashCode() {\n        int hash = MAGIC_HASH_INIT_VALUE;\n        hash = MAGIC_HASH_MULTIPLIER * hash + ObjectUtils.hashCode(StringUtils.lowerCase(this.name));\n        hash = MAGIC_HASH_MULTIPLIER * hash + ObjectUtils.hashCode(StringUtils.lowerCase(this.source));\n        hash = MAGIC_HASH_MULTIPLIER * hash + ObjectUtils.hashCode(StringUtils.lowerCase(this.value));"}
{"magic_number_smell": "        given(commitPointer.getSha()).willReturn(\"sha1\");\n        GhprbTestUtil.setupGhprbTriggerDescriptor(null);\n        project.addProperty(new GithubProjectProperty(\"https://github.com/user/dropwizard\"));\n        given(ghPullRequest.getId()).willReturn(1);\n        given(ghPullRequest.getNumber()).willReturn(1);\n        given(ghRepository.getPullRequest(1)).willReturn(ghPullRequest);\n        Ghprb ghprb = spy(trigger.createGhprb(project));", "refactored_code": "    private final int prId = 1;\n        given(commitPointer.getSha()).willReturn(\"sha1\");\n        GhprbTestUtil.setupGhprbTriggerDescriptor(null);\n        project.addProperty(new GithubProjectProperty(\"https://github.com/user/dropwizard\"));\n        given(ghPullRequest.getId()).willReturn(prId);\n        given(ghPullRequest.getNumber()).willReturn(prId);\n        given(ghRepository.getPullRequest(prId)).willReturn(ghPullRequest);\n        Ghprb ghprb = spy(trigger.createGhprb(project));"}
{"magic_number_smell": "\n\n    public DPXReader(SeekableByteChannel ch) throws IOException {\n        this.readBuf = allocate(2048 + 1024);\n        initialRead(ch);\n        this.magic = readBuf.getInt();\n", "refactored_code": "    private static final int READ_BUFFER_SIZE = 2048 + 1024;\n\n\n    public DPXReader(SeekableByteChannel ch) throws IOException {\n        this.readBuf = allocate(READ_BUFFER_SIZE);\n        initialRead(ch);\n        this.magic = readBuf.getInt();\n"}
{"magic_number_smell": "\n\n    public DPXReader(SeekableByteChannel ch) throws IOException {\n        this.readBuf = allocate(2048 + 1024);\n        initialRead(ch);\n        this.magic = readBuf.getInt();\n", "refactored_code": "    private static final int READ_BUFFER_SIZE = 2048 + 1024;\n\n\n    public DPXReader(SeekableByteChannel ch) throws IOException {\n        this.readBuf = allocate(READ_BUFFER_SIZE);\n        initialRead(ch);\n        this.magic = readBuf.getInt();\n"}
{"magic_number_smell": "\t\t\t\t\tint[] termStringOffsets = new int[n];\n\t\t\t\t\twhile (currentTerm < n) {\n\t\t\t\t\t\tint firstTermInBlock = currentTerm;\n\t\t\t\t\t\tint blockSize = (int)Math.min(bytesLeftToWrite, Integer.MAX_VALUE - 100);\n\n\t\t\t\t\t\t// Calculate byte offsets for all the terms and fill data array\n\t\t\t\t\t\tint currentOffset = 0;", "refactored_code": "\tprivate static final int APPROX_MAX_ARRAY_SIZE = Integer.MAX_VALUE - 100;\n\t\t\t\t\tint[] termStringOffsets = new int[n];\n\t\t\t\t\twhile (currentTerm < n) {\n\t\t\t\t\t\tint firstTermInBlock = currentTerm;\n\t\t\t\t\t\tint blockSize = (int)Math.min(bytesLeftToWrite, APPROX_MAX_ARRAY_SIZE);\n\n\t\t\t\t\t\t// Calculate byte offsets for all the terms and fill data array\n\t\t\t\t\t\tint currentOffset = 0;"}
{"magic_number_smell": "            } else {\r\n                // Set minimum size and adjust after all components have\r\n                // (supposedly) been drawn completely.\r\n                DOM.setStyleAttribute(base, styleAttribute, 50 + \"px\");\r\n                DeferredCommand.addCommand(new Command() {\r\n                    public void execute() {\r\n                        final Element p = DOM.getParent(getElement());\r", "refactored_code": "    private static final int MIN_SIZE = 50;\r\n            } else {\r\n                // Set minimum size and adjust after all components have\r\n                // (supposedly) been drawn completely.\r\n                DOM.setStyleAttribute(base, styleAttribute, MIN_SIZE + \"px\");\r\n                DeferredCommand.addCommand(new Command() {\r\n                    public void execute() {\r\n                        final Element p = DOM.getParent(getElement());\r"}
{"magic_number_smell": "          final double estimatedCardinality = union.getEstimate();\n          final long estimatedNumShards;\n          if (estimatedCardinality <= 0) {\n            estimatedNumShards = 7L;\n            LOG.warn(\"Estimated cardinality for union of estimates is zero or less: %.2f, setting num shards to %d\",\n                     estimatedCardinality, estimatedNumShards\n            );", "refactored_code": "  private static final long DEFAULT_NUM_SHARDS_WHEN_ESTIMATE_GOES_NEGATIVE = 7L;\n          final double estimatedCardinality = union.getEstimate();\n          final long estimatedNumShards;\n          if (estimatedCardinality <= 0) {\n            estimatedNumShards = DEFAULT_NUM_SHARDS_WHEN_ESTIMATE_GOES_NEGATIVE;\n            LOG.warn(\"Estimated cardinality for union of estimates is zero or less: %.2f, setting num shards to %d\",\n                     estimatedCardinality, estimatedNumShards\n            );"}
{"magic_number_smell": "    /** Returns a string representation of this instance. */\n    public String toString() {\n\treturn \"DataServiceHeader[\" +\n\t    \"version:\" + 1 + \".\" + minorVersion +\n\t    \", appName:\\\"\" + appName + \"\\\"]\";\n    }\n", "refactored_code": "    private static final long serialVersionUID = 1;\n    /** Returns a string representation of this instance. */\n    public String toString() {\n\treturn \"DataServiceHeader[\" +\n\t    \"version:\" + serialVersionUID + \".\" + minorVersion +\n\t    \", appName:\\\"\" + appName + \"\\\"]\";\n    }\n"}
{"magic_number_smell": "\tthrows DatabaseException\n    {\n\tlong timeout = 1000L * PropertiesUtil.getLongProperty(\n\t    properties, TXN_TIMEOUT_PROPERTY, 1000);\n\tboolean flushToDisk = PropertiesUtil.getBooleanProperty(\n\t    properties, FLUSH_TO_DISK_PROPERTY, false);\n        EnvironmentConfig config = new EnvironmentConfig();", "refactored_code": "    private static final long DEFAULT_TXN_TIMEOUT = 1000;\n\tthrows DatabaseException\n    {\n\tlong timeout = 1000L * PropertiesUtil.getLongProperty(\n\t    properties, TXN_TIMEOUT_PROPERTY, DEFAULT_TXN_TIMEOUT);\n\tboolean flushToDisk = PropertiesUtil.getBooleanProperty(\n\t    properties, FLUSH_TO_DISK_PROPERTY, false);\n        EnvironmentConfig config = new EnvironmentConfig();"}
{"magic_number_smell": "    }\n\n    static class Counter implements ManagedObject, Serializable {\n\tprivate static final long 1 = 1;\n\tprivate int count;\n\tCounter() { }\n\tint next() { return ++count; }", "refactored_code": "\tprivate static final long serialVersionUID = 1;\n    }\n\n    static class Counter implements ManagedObject, Serializable {\n\tprivate static final long serialVersionUID = 1;\n\tprivate int count;\n\tCounter() { }\n\tint next() { return ++count; }"}
{"magic_number_smell": "\n    public boolean equals(Object object) {\n\treturn object instanceof DummyManagedObject &&\n\t    nextId.getAndIncrement() == ((DummyManagedObject) object).nextId.getAndIncrement();\n    }\n\n    public int hashCode() {", "refactored_code": "    private final int id = nextId.getAndIncrement();\n\n    public boolean equals(Object object) {\n\treturn object instanceof DummyManagedObject &&\n\t    id == ((DummyManagedObject) object).id;\n    }\n\n    public int hashCode() {"}
{"magic_number_smell": "    }\n    public byte[] getId() {\n\treturn new byte[] {\n\t    (byte) (nextId++ >>> 56), (byte) (nextId++ >>> 48), (byte) (nextId++ >>> 40),\n\t    (byte) (nextId++ >>> 32), (byte) (nextId++ >>> 24), (byte) (nextId++ >>> 16),\n\t    (byte) (nextId++ >>> 8), (byte) nextId++ };\n    }", "refactored_code": "    private final long id = nextId++;\n    }\n    public byte[] getId() {\n\treturn new byte[] {\n\t    (byte) (id >>> 56), (byte) (id >>> 48), (byte) (id >>> 40),\n\t    (byte) (id >>> 32), (byte) (id >>> 24), (byte) (id >>> 16),\n\t    (byte) (id >>> 8), (byte) id };\n    }"}
{"magic_number_smell": "                            public void onClick(View view) {\n                                ActivityCompat.requestPermissions(BrowserActivity.this,\n                                        new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},\n                                        1);\n                            }\n                        })\n                        .show();", "refactored_code": "    public static final int REQUEST_PERMISSIONS_WRITE_EXTERNAL_STORAGE = 1;\n                            public void onClick(View view) {\n                                ActivityCompat.requestPermissions(BrowserActivity.this,\n                                        new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE},\n                                        REQUEST_PERMISSIONS_WRITE_EXTERNAL_STORAGE);\n                            }\n                        })\n                        .show();"}
{"magic_number_smell": "     * When running sychonously, return events can be received over transports that\n     * support ack or replyTo This property determines how long to wait for a receive\n     */\n    private int synchronousEventTimeout = 10000;\n\n    /**\n     * The default transaction timeout value used if no specific transaction time out", "refactored_code": "    public static final int DEFAULT_TIMEOUT = 10000;\n     * When running sychonously, return events can be received over transports that\n     * support ack or replyTo This property determines how long to wait for a receive\n     */\n    private int synchronousEventTimeout = DEFAULT_TIMEOUT;\n\n    /**\n     * The default transaction timeout value used if no specific transaction time out"}
{"magic_number_smell": "     */\n    public static final int DEFAULT_POOL_EXHAUST_ACTION = WHEN_EXHAUSTED_RUN;\n\n    private int maxThreadsActive = 8;\n    private int maxThreadsIdle = DEFAULT_MAX_THREADS_IDLE;\n    private int maxBufferSize = DEFAULT_MAX_BUFFER_SIZE;\n    private long threadTTL = DEFAULT_MAX_THREAD_TTL;", "refactored_code": "    public static final int DEFAULT_MAX_THREADS_ACTIVE = 8;\n     */\n    public static final int DEFAULT_POOL_EXHAUST_ACTION = WHEN_EXHAUSTED_RUN;\n\n    private int maxThreadsActive = DEFAULT_MAX_THREADS_ACTIVE;\n    private int maxThreadsIdle = DEFAULT_MAX_THREADS_IDLE;\n    private int maxBufferSize = DEFAULT_MAX_BUFFER_SIZE;\n    private long threadTTL = DEFAULT_MAX_THREAD_TTL;"}
{"magic_number_smell": "    try {\n      this.id = id;\n      this.files = files;\n      this.chunkSize = 64 * 1024 * 1024 / pageSize;\n\n      this.pageSize = pageSize;\n      this.writeAheadLog = writeAheadLog;", "refactored_code": "  private static final int CHUNK_SIZE = 64 * 1024 * 1024;\n    try {\n      this.id = id;\n      this.files = files;\n      this.chunkSize = CHUNK_SIZE / pageSize;\n\n      this.pageSize = pageSize;\n      this.writeAheadLog = writeAheadLog;"}
{"magic_number_smell": "\n  @Test\n  public void testKeyPut() throws Exception {\n    for (int i = 0; i < 500000; i++) {\n      sbTree.put(i, new ORecordId(i % 32000, i));\n    }\n", "refactored_code": "  private static final int KEYS_COUNT = 500000;\n\n  @Test\n  public void testKeyPut() throws Exception {\n    for (int i = 0; i < KEYS_COUNT; i++) {\n      sbTree.put(i, new ORecordId(i % 32000, i));\n    }\n"}
{"magic_number_smell": "    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);"}
{"magic_number_smell": "    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);"}
{"magic_number_smell": "\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != 0x414E4554) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n", "refactored_code": "    private static final int FILE_MAGIC = 0x414E4554;\n\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != FILE_MAGIC) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n"}
{"magic_number_smell": "            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + AlarmManager.INTERVAL_HOUR;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {", "refactored_code": "    private static final long BACKUP_INTERVAL = AlarmManager.INTERVAL_HOUR;\n            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + BACKUP_INTERVAL;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {"}
{"magic_number_smell": "            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > 50 ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;", "refactored_code": "    private static final int INET_CONDITION_THRESHOLD = 50;\n            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;"}
{"magic_number_smell": "        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+5*1000) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }", "refactored_code": "    private static final long MIN_TIME_BETWEEN_GCS = 5*1000;\n        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+MIN_TIME_BETWEEN_GCS) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }"}
{"magic_number_smell": "    public int hashCode()\n    {\n        int result = eventType.hashCode();\n        result = 31 * result + listener.hashCode();\n        return result;\n    }\n", "refactored_code": "    private static final int HASH_FACTOR = 31;\n    public int hashCode()\n    {\n        int result = eventType.hashCode();\n        result = HASH_FACTOR * result + listener.hashCode();\n        return result;\n    }\n"}
{"magic_number_smell": "        }\n\n        final int release = Integer.parseInt(System.getProperty(\"java.version\").substring(6));\n        if (release < 60) {\n            JOptionPane.showMessageDialog(null, ResourceUtils.getString(\"Message.JFX\"),\n                    ResourceUtils.getString(\"Title.Error\"), JOptionPane.ERROR_MESSAGE);\n            return;", "refactored_code": "    private static final int JAVA_RELEASE = 60;\n        }\n\n        final int release = Integer.parseInt(System.getProperty(\"java.version\").substring(6));\n        if (release < JAVA_RELEASE) {\n            JOptionPane.showMessageDialog(null, ResourceUtils.getString(\"Message.JFX\"),\n                    ResourceUtils.getString(\"Title.Error\"), JOptionPane.ERROR_MESSAGE);\n            return;"}
{"magic_number_smell": "        if (minCapacity > cache.length) {\n            int oldCapacity = cache.length;\n            BigDecimal oldCache[] = cache;\n            int newCapacity = oldCapacity + 5;\n            if (newCapacity < minCapacity) {\n                newCapacity = minCapacity;\n            }", "refactored_code": "    public static final int CAPACITY_BUMP_SIZE = 5;\n        if (minCapacity > cache.length) {\n            int oldCapacity = cache.length;\n            BigDecimal oldCache[] = cache;\n            int newCapacity = oldCapacity + CAPACITY_BUMP_SIZE;\n            if (newCapacity < minCapacity) {\n                newCapacity = minCapacity;\n            }"}
{"magic_number_smell": "    // scheduling parameters\n    private int maxActiveTapes = 1;\n    private int minTapeRecallPercentage = 80;\n    private long minNumberOfRequestsForTapeSelection = -1;\n    private long minJobWaitingTime = MINUTES.toMillis(2);\n    private long maxJobWaitingTime = HOURS.toMillis(1);\n    private long tapeinfolessJobWaitingTime = MINUTES.toMillis(10);", "refactored_code": "    public static final long NO_VALUE = -1;\n    // scheduling parameters\n    private int maxActiveTapes = 1;\n    private int minTapeRecallPercentage = 80;\n    private long minNumberOfRequestsForTapeSelection = NO_VALUE;\n    private long minJobWaitingTime = MINUTES.toMillis(2);\n    private long maxJobWaitingTime = HOURS.toMillis(1);\n    private long tapeinfolessJobWaitingTime = MINUTES.toMillis(10);"}
{"magic_number_smell": "    }\n\n    private long getNewCtime() {\n        return System.currentTimeMillis() - 20;\n    }\n\n    private long getExpiredCtime() {", "refactored_code": "    private static final long TIME_SAFETY_MARGIN = 20;\n    }\n\n    private long getNewCtime() {\n        return System.currentTimeMillis() - TIME_SAFETY_MARGIN;\n    }\n\n    private long getExpiredCtime() {"}
{"magic_number_smell": "\n    public RequestContainerV5()\n    {\n        this(60000);\n    }\n\n    @Override", "refactored_code": "    private static final int DEFAULT_TICKER_INTERVAL = 60000;\n\n    public RequestContainerV5()\n    {\n        this(DEFAULT_TICKER_INTERVAL);\n    }\n\n    @Override"}
{"magic_number_smell": "\n\t\t\tAdvancedFloatStatistics stats = AdvancedFloatStatistics.of(allDimsPerRecordArray);\n\t\t\t// throwing out all values with more than 80% NAN\n\t\t\tif (stats.getNaNs() < stats.getN() * 0.8) {\n\t\t\t\tallDimVar.add(new Pair<Float, Integer>(stats.getMedianAbsoluteDeviation(), dimID));\n\t\t\t}\n\t\t}", "refactored_code": "\tprivate static final double NAN_THRESHOLD = 0.8;\n\n\t\t\tAdvancedFloatStatistics stats = AdvancedFloatStatistics.of(allDimsPerRecordArray);\n\t\t\t// throwing out all values with more than 80% NAN\n\t\t\tif (stats.getNaNs() < stats.getN() * NAN_THRESHOLD) {\n\t\t\t\tallDimVar.add(new Pair<Float, Integer>(stats.getMedianAbsoluteDeviation(), dimID));\n\t\t\t}\n\t\t}"}
{"magic_number_smell": "    long waitTimeInMs = TimeUnit.MILLISECONDS.convert(timeout, unit);\n    while (! isTerminated() && \n           Clock.accurateTime() - startTime < waitTimeInMs) {\n      Thread.sleep(100);\n    }\n    \n    return isTerminated();", "refactored_code": "  private static final int AWAIT_TERMINATION_POLL_INTERVAL_IN_MS = 100;\n    long waitTimeInMs = TimeUnit.MILLISECONDS.convert(timeout, unit);\n    while (! isTerminated() && \n           Clock.accurateTime() - startTime < waitTimeInMs) {\n      Thread.sleep(AWAIT_TERMINATION_POLL_INTERVAL_IN_MS);\n    }\n    \n    return isTerminated();"}
{"magic_number_smell": "        final Map<Integer, CIString> results = Maps.newHashMap();\n        final Map<String, Object> params = Maps.newHashMap();\n\n        for (List<Integer> partition : Lists.partition(objectIds, 10_000)) {\n            params.put(\"objectids\", partition);\n            namedParameterJdbcTemplate.query(\n                \"SELECT object_id, status FROM status WHERE object_id IN (:objectids)\",", "refactored_code": "    private static final int QUERY_PARTITION = 10_000;\n        final Map<Integer, CIString> results = Maps.newHashMap();\n        final Map<String, Object> params = Maps.newHashMap();\n\n        for (List<Integer> partition : Lists.partition(objectIds, QUERY_PARTITION)) {\n            params.put(\"objectids\", partition);\n            namedParameterJdbcTemplate.query(\n                \"SELECT object_id, status FROM status WHERE object_id IN (:objectids)\","}
{"magic_number_smell": "    @Override\n    public void validate(final PreparedUpdate update, final UpdateContext updateContext) {\n        Ipv6Resource ipv6Resource = Ipv6Resource.parse(update.getUpdatedObject().getKey());\n        if (ipv6Resource.getPrefixLength() > 64) {\n            updateContext.addMessage(update, UpdateMessages.prefixTooSmall(64));\n        }\n    }", "refactored_code": "    private static final int MINIMUM_PREFIX_LENGTH = 64;\n    @Override\n    public void validate(final PreparedUpdate update, final UpdateContext updateContext) {\n        Ipv6Resource ipv6Resource = Ipv6Resource.parse(update.getUpdatedObject().getKey());\n        if (ipv6Resource.getPrefixLength() > MINIMUM_PREFIX_LENGTH) {\n            updateContext.addMessage(update, UpdateMessages.prefixTooSmall(MINIMUM_PREFIX_LENGTH));\n        }\n    }"}
{"magic_number_smell": "    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);"}
{"magic_number_smell": "    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);"}
{"magic_number_smell": "\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != 0x414E4554) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n", "refactored_code": "    private static final int FILE_MAGIC = 0x414E4554;\n\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != FILE_MAGIC) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n"}
{"magic_number_smell": "            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + AlarmManager.INTERVAL_HOUR;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {", "refactored_code": "    private static final long BACKUP_INTERVAL = AlarmManager.INTERVAL_HOUR;\n            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + BACKUP_INTERVAL;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {"}
{"magic_number_smell": "            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > 50 ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;", "refactored_code": "    private static final int INET_CONDITION_THRESHOLD = 50;\n            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;"}
{"magic_number_smell": "    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #-1}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode", "refactored_code": "    public static final int INFINITE = -1;\n    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #INFINITE}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode"}
{"magic_number_smell": "        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+5*1000) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }", "refactored_code": "    private static final long MIN_TIME_BETWEEN_GCS = 5*1000;\n        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+MIN_TIME_BETWEEN_GCS) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }"}
{"magic_number_smell": "  @NotNull\n  private Set<VirtualFile> scanForRootsInsideDir(@NotNull final VirtualFile dir, final int depth) {\n    final Set<VirtualFile> roots = new HashSet<VirtualFile>();\n    if (depth > 2) {\n      // performance optimization via limitation: don't scan deep though the whole VFS, 2 levels under a content root is enough\n      return roots;\n    }", "refactored_code": "  private static final int MAXIMUM_SCAN_DEPTH = 2;\n  @NotNull\n  private Set<VirtualFile> scanForRootsInsideDir(@NotNull final VirtualFile dir, final int depth) {\n    final Set<VirtualFile> roots = new HashSet<VirtualFile>();\n    if (depth > MAXIMUM_SCAN_DEPTH) {\n      // performance optimization via limitation: don't scan deep though the whole VFS, 2 levels under a content root is enough\n      return roots;\n    }"}
{"magic_number_smell": "\n    static {\n        Calendar calendar = Calendar.getInstance();\n        calendar.add(Calendar.YEAR, 10);\n        Date inTenYears = calendar.getTime();\n        calendar = Calendar.getInstance();\n        calendar.add(Calendar.YEAR, -10);", "refactored_code": "    private static final int DEFAULT_DATE_RANGE = 10;\n\n    static {\n        Calendar calendar = Calendar.getInstance();\n        calendar.add(Calendar.YEAR, DEFAULT_DATE_RANGE);\n        Date inTenYears = calendar.getTime();\n        calendar = Calendar.getInstance();\n        calendar.add(Calendar.YEAR, -DEFAULT_DATE_RANGE);"}
{"magic_number_smell": "\n        //initialise date randomizer to generate dates in [now - 10 years, now + 10 years]\n        Calendar calendar = Calendar.getInstance();\n        calendar.add(Calendar.YEAR, 10);\n        Date inTenYears = calendar.getTime();\n        calendar = Calendar.getInstance();\n        calendar.add(Calendar.YEAR, -10);", "refactored_code": "    private static final int DEFAULT_DATE_RANGE = 10;\n\n        //initialise date randomizer to generate dates in [now - 10 years, now + 10 years]\n        Calendar calendar = Calendar.getInstance();\n        calendar.add(Calendar.YEAR, DEFAULT_DATE_RANGE);\n        Date inTenYears = calendar.getTime();\n        calendar = Calendar.getInstance();\n        calendar.add(Calendar.YEAR, -DEFAULT_DATE_RANGE);"}
{"magic_number_smell": "     */\n    public OptionalRandomizer(final Randomizer<T> delegate, final int optionalPercent) {\n        this.delegate = delegate;\n        this.optionalPercent = optionalPercent > 100 ? 100 : optionalPercent < 0 ? 0 : optionalPercent;\n    }\n\n    @Override", "refactored_code": "    private static final int MAX_PERCENT = 100;\n     */\n    public OptionalRandomizer(final Randomizer<T> delegate, final int optionalPercent) {\n        this.delegate = delegate;\n        this.optionalPercent = optionalPercent > MAX_PERCENT ? MAX_PERCENT : optionalPercent < 0 ? 0 : optionalPercent;\n    }\n\n    @Override"}
{"magic_number_smell": "        }\n        if (field.isAnnotationPresent(javax.validation.constraints.Future.class)) {\n            Calendar calendar = Calendar.getInstance();\n            calendar.add(Calendar.YEAR, 10);\n            object = new DateRangeRandomizer(new Date(), calendar.getTime()).getRandomValue();\n        }\n        if (field.isAnnotationPresent(javax.validation.constraints.Past.class)) {", "refactored_code": "    private static final int DEFAULT_DATE_RANGE = 10;\n        }\n        if (field.isAnnotationPresent(javax.validation.constraints.Future.class)) {\n            Calendar calendar = Calendar.getInstance();\n            calendar.add(Calendar.YEAR, DEFAULT_DATE_RANGE);\n            object = new DateRangeRandomizer(new Date(), calendar.getTime()).getRandomValue();\n        }\n        if (field.isAnnotationPresent(javax.validation.constraints.Past.class)) {"}
{"magic_number_smell": "    in.seek(96);\n    in.order(true);\n\n    boolean little = in.readShort() == -16224;\n    in.order(little);\n    in.seek(0);\n", "refactored_code": "  private static final short LITTLE_ENDIAN = -16224;\n    in.seek(96);\n    in.order(true);\n\n    boolean little = in.readShort() == LITTLE_ENDIAN;\n    in.order(little);\n    in.seek(0);\n"}
{"magic_number_smell": "  /** Returns the name of the given codec. */\n  public static String getCodecName(int codec) {\n    switch (codec) {\n      case 1:\n        return \"Uncompressed\";\n      case CCITT_1D:\n        return \"CCITT Group 3 1-Dimensional Modified Huffman\";", "refactored_code": "  public static final int UNCOMPRESSED = 1;\n  /** Returns the name of the given codec. */\n  public static String getCodecName(int codec) {\n    switch (codec) {\n      case UNCOMPRESSED:\n        return \"Uncompressed\";\n      case CCITT_1D:\n        return \"CCITT Group 3 1-Dimensional Modified Huffman\";"}
{"magic_number_smell": "    if (x == 0 && y == 0 && w == 1 && h == 1) {\n      return buf;\n    }\n    else if (getSizeX() <= 8192 && getSizeY() <= 8192) {\n      int ifdIndex = getIFDIndex(getSeries(), no);\n      in = new RandomAccessInputStream(currentId);\n      tiffParser = new TiffParser(in);", "refactored_code": "  private static final int MAX_SIZE = 8192;\n    if (x == 0 && y == 0 && w == 1 && h == 1) {\n      return buf;\n    }\n    else if (getSizeX() <= MAX_SIZE && getSizeY() <= MAX_SIZE) {\n      int ifdIndex = getIFDIndex(getSeries(), no);\n      in = new RandomAccessInputStream(currentId);\n      tiffParser = new TiffParser(in);"}
{"magic_number_smell": "\n                // If there wasn't a key string in config, make one\n                if (material == null) {\n                    material = new byte[128];\n                    new SecureRandom().nextBytes(material);\n                }\n                // Hash the key string given in config", "refactored_code": "    private static final int MIN_KEY_BYTES = 128;\n\n                // If there wasn't a key string in config, make one\n                if (material == null) {\n                    material = new byte[MIN_KEY_BYTES];\n                    new SecureRandom().nextBytes(material);\n                }\n                // Hash the key string given in config"}
{"magic_number_smell": "        StringBuilder result = buffer.get();\n        if (result == null) {\n            final int currentPatternLength = messagePattern == null ? 0 : messagePattern.length();\n            result = new StringBuilder(Math.min(512, currentPatternLength * 2));\n            buffer.set(result);\n        }\n        result.setLength(0);", "refactored_code": "    private static final int MIN_BUILDER_SIZE = 512;\n        StringBuilder result = buffer.get();\n        if (result == null) {\n            final int currentPatternLength = messagePattern == null ? 0 : messagePattern.length();\n            result = new StringBuilder(Math.min(MIN_BUILDER_SIZE, currentPatternLength * 2));\n            buffer.set(result);\n        }\n        result.setLength(0);"}
{"magic_number_smell": "    private int usedCount;\n    private final int[] indices = new int[256];\n    private transient Object[] varargs;\n    private transient Object[] params = new Object[10];\n    private transient Throwable throwable;\n\n    /**", "refactored_code": "    private static final int MAX_PARMS = 10;\n    private int usedCount;\n    private final int[] indices = new int[256];\n    private transient Object[] varargs;\n    private transient Object[] params = new Object[MAX_PARMS];\n    private transient Throwable throwable;\n\n    /**"}
{"magic_number_smell": "                props.put(\"batch-size\", Integer.toString(batchSize));\r\n            }\r\n            if (retries > 1) {\r\n                if (retries > 3) {\r\n                    retries = 3;\r\n                }\r\n                props.put(\"max-attempts\", Integer.toString(retries * agents.length));\r", "refactored_code": "    private static final int MAX_RECONNECTS = 3;\r\n                props.put(\"batch-size\", Integer.toString(batchSize));\r\n            }\r\n            if (retries > 1) {\r\n                if (retries > MAX_RECONNECTS) {\r\n                    retries = MAX_RECONNECTS;\r\n                }\r\n                props.put(\"max-attempts\", Integer.toString(retries * agents.length));\r"}
{"magic_number_smell": "    private static StringBuilder getThreadLocalStringBuilder() {\n        StringBuilder buffer = threadLocalStringBuilder.get();\n        if (buffer == null) {\n            buffer = new StringBuilder(255);\n            threadLocalStringBuilder.set(buffer);\n        }\n        buffer.setLength(0);", "refactored_code": "    private static final int DEFAULT_STRING_BUILDER_SIZE = 255;\n    private static StringBuilder getThreadLocalStringBuilder() {\n        StringBuilder buffer = threadLocalStringBuilder.get();\n        if (buffer == null) {\n            buffer = new StringBuilder(DEFAULT_STRING_BUILDER_SIZE);\n            threadLocalStringBuilder.set(buffer);\n        }\n        buffer.setLength(0);"}
{"magic_number_smell": "        sGPSColor = getResources().getColor(R.color.gps_track);\n\n        mFirstLocationFix = true;\n        int zoomLevel = 13;\n        GeoPoint lastLoc = null;\n        if (savedInstanceState != null) {\n            mFirstLocationFix = false;", "refactored_code": "    private static final int DEFAULT_ZOOM = 13;\n        sGPSColor = getResources().getColor(R.color.gps_track);\n\n        mFirstLocationFix = true;\n        int zoomLevel = DEFAULT_ZOOM;\n        GeoPoint lastLoc = null;\n        if (savedInstanceState != null) {\n            mFirstLocationFix = false;"}
{"magic_number_smell": "    // Though the tile provider can only provide up to 13, this overlay will display higher.\n    @Override\n    public int getMaximumZoomLevel() {\n        return 20;\n    }\n\n    @Override", "refactored_code": "    public static final int MAX_ZOOM_LEVEL_OF_MAP = 20;\n    // Though the tile provider can only provide up to 13, this overlay will display higher.\n    @Override\n    public int getMaximumZoomLevel() {\n        return MAX_ZOOM_LEVEL_OF_MAP;\n    }\n\n    @Override"}
{"magic_number_smell": "    // Fills the specified point on the bitmap with the currently selected fill color.\n    // int x, int y: The starting coords for the fill\n    public boolean floodFill(int x, int y, Window parent) {\n        final Rectangle largestPossibleFloodArea = new Rectangle(x - 46340 / 2, y - 46340 / 2, 46340, 46340);\n        final Rectangle fillBounds = fillMethod.getBounds();\n        if (! largestPossibleFloodArea.contains(fillBounds)) {\n            boundsTooLarge = true;", "refactored_code": "    private static final int MAX_INT_SQUARE_SIDE = 46340; // sqrt(Integer.MAX_VALUE)\n    // Fills the specified point on the bitmap with the currently selected fill color.\n    // int x, int y: The starting coords for the fill\n    public boolean floodFill(int x, int y, Window parent) {\n        final Rectangle largestPossibleFloodArea = new Rectangle(x - MAX_INT_SQUARE_SIDE / 2, y - MAX_INT_SQUARE_SIDE / 2, MAX_INT_SQUARE_SIDE, MAX_INT_SQUARE_SIDE);\n        final Rectangle fillBounds = fillMethod.getBounds();\n        if (! largestPossibleFloodArea.contains(fillBounds)) {\n            boundsTooLarge = true;"}
{"magic_number_smell": "        if (isP2P) {\r\n            return this.progress_max;\r\n        } else {\r\n            return (int) (this.100);\r\n        }\r\n    }\r\n\r", "refactored_code": "    protected final long fileSize = 100;\r\n        if (isP2P) {\r\n            return this.progress_max;\r\n        } else {\r\n            return (int) (this.fileSize);\r\n        }\r\n    }\r\n\r"}
{"magic_number_smell": "                    }\r\n                }\r\n            }\r\n        }, 0, 1000);\r\n    }\r\n\r\n    /**\r", "refactored_code": "    protected static final int MILLIS_UPDATE = 1000;\r\n                    }\r\n                }\r\n            }\r\n        }, 0, MILLIS_UPDATE);\r\n    }\r\n\r\n    /**\r"}
{"magic_number_smell": "        this.messageTransferQueue = Collections\r\n            .synchronizedList(new LinkedList<MessageTransfer>());\r\n\r\n        this.executor = Executors.newFixedThreadPool(10);\r\n\r\n        this.connection = connection;\r\n        this.chatmanager = connection.getChatManager();\r", "refactored_code": "    public static final int MAX_PARALLEL_SENDS = 10;\r\n        this.messageTransferQueue = Collections\r\n            .synchronizedList(new LinkedList<MessageTransfer>());\r\n\r\n        this.executor = Executors.newFixedThreadPool(MAX_PARALLEL_SENDS);\r\n\r\n        this.connection = connection;\r\n        this.chatmanager = connection.getChatManager();\r"}
{"magic_number_smell": "    final AtomicLong destroyedCount = new AtomicLong(0);\n    final AtomicLong destroyedByEvictorCount = new AtomicLong(0);\n    final AtomicLong destroyedByBorrowValidationCount = new AtomicLong(0);\n    private final StatsStore activeTimes = new StatsStore(100);\n    private final StatsStore idleTimes = new StatsStore(100);\n    private final StatsStore waitTimes = new StatsStore(100);\n    private final AtomicLong maxBorrowWaitTimeMillis = new AtomicLong(0L);", "refactored_code": "    public static final int MEAN_TIMING_STATS_CACHE_SIZE = 100;\n    final AtomicLong destroyedCount = new AtomicLong(0);\n    final AtomicLong destroyedByEvictorCount = new AtomicLong(0);\n    final AtomicLong destroyedByBorrowValidationCount = new AtomicLong(0);\n    private final StatsStore activeTimes = new StatsStore(MEAN_TIMING_STATS_CACHE_SIZE);\n    private final StatsStore idleTimes = new StatsStore(MEAN_TIMING_STATS_CACHE_SIZE);\n    private final StatsStore waitTimes = new StatsStore(MEAN_TIMING_STATS_CACHE_SIZE);\n    private final AtomicLong maxBorrowWaitTimeMillis = new AtomicLong(0L);"}
{"magic_number_smell": "  // Visible for testing.\n  static class DecodeJobFactory {\n    private final DecodeJob.DiskCacheProvider diskCacheProvider;\n    private final Pools.Pool<DecodeJob<?>> pool = FactoryPools.simple(150,\n        new FactoryPools.Factory<DecodeJob<?>>() {\n          @Override\n          public DecodeJob<?> create() {", "refactored_code": "  private static final int JOB_POOL_SIZE = 150;\n  // Visible for testing.\n  static class DecodeJobFactory {\n    private final DecodeJob.DiskCacheProvider diskCacheProvider;\n    private final Pools.Pool<DecodeJob<?>> pool = FactoryPools.simple(JOB_POOL_SIZE,\n        new FactoryPools.Factory<DecodeJob<?>>() {\n          @Override\n          public DecodeJob<?> create() {"}
{"magic_number_smell": "  public void onResourceReady(Resource<R> resource, DataSource dataSource) {\n    this.resource = resource;\n    this.dataSource = dataSource;\n    MAIN_THREAD_HANDLER.obtainMessage(1, this).sendToTarget();\n  }\n\n  @Override", "refactored_code": "  private static final int MSG_COMPLETE = 1;\n  public void onResourceReady(Resource<R> resource, DataSource dataSource) {\n    this.resource = resource;\n    this.dataSource = dataSource;\n    MAIN_THREAD_HANDLER.obtainMessage(MSG_COMPLETE, this).sendToTarget();\n  }\n\n  @Override"}
{"magic_number_smell": "\n    @Override\n    public boolean handleMessage(Message message) {\n      if (message.what == 1) {\n        Resource<?> resource = (Resource<?>) message.obj;\n        resource.recycle();\n        return true;", "refactored_code": "    public static final int RECYCLE_RESOURCE = 1;\n\n    @Override\n    public boolean handleMessage(Message message) {\n      if (message.what == RECYCLE_RESOURCE) {\n        Resource<?> resource = (Resource<?>) message.obj;\n        resource.recycle();\n        return true;"}
{"magic_number_smell": "\n  private boolean mayFillRequest(int requestedSize, Integer actualSize) {\n    return actualSize != null\n        && (isNoMoreThanHalfFull() || actualSize <= (8 * requestedSize));\n  }\n\n  private boolean isNoMoreThanHalfFull() {", "refactored_code": "  private static final int MAX_OVER_SIZE_MULTIPLE = 8;\n\n  private boolean mayFillRequest(int requestedSize, Integer actualSize) {\n    return actualSize != null\n        && (isNoMoreThanHalfFull() || actualSize <= (MAX_OVER_SIZE_MULTIPLE * requestedSize));\n  }\n\n  private boolean isNoMoreThanHalfFull() {"}
{"magic_number_smell": "  private final LruCache<ModelKey<A>, B> cache;\n\n  public ModelCache() {\n    this(250);\n  }\n\n  public ModelCache(int size) {", "refactored_code": "  private static final int DEFAULT_SIZE = 250;\n  private final LruCache<ModelKey<A>, B> cache;\n\n  public ModelCache() {\n    this(DEFAULT_SIZE);\n  }\n\n  public ModelCache(int size) {"}
{"magic_number_smell": "\n    public IntHashMap()\n    {\n        this( 101, DEFAULT_LOAD_FACTOR );\n    }\n\n    /*", "refactored_code": "    private static final int DEFAULT_INITIAL_CAPACITY = 101;\n\n    public IntHashMap()\n    {\n        this( DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR );\n    }\n\n    /*"}
{"magic_number_smell": "        case PRIMITIVE_LONG:\n        case PRIMITIVE_SHORT:\n        case PRIMITIVE_BOOLEAN:\n        case 's':\n            return new SimpleElementValue(type, input.readUnsignedShort(), cpool);\n\n        case ENUM_CONSTANT:", "refactored_code": "    public static final byte STRING = 's';\n        case PRIMITIVE_LONG:\n        case PRIMITIVE_SHORT:\n        case PRIMITIVE_BOOLEAN:\n        case STRING:\n            return new SimpleElementValue(type, input.readUnsignedShort(), cpool);\n\n        case ENUM_CONSTANT:"}
{"magic_number_smell": "     * @param cs array of given constants, new ones will be appended\n     */\n    public ConstantPoolGen(Constant[] cs) {\n        StringBuilder sb = new StringBuilder(256);\n\n        size = Math.max(256, cs.length + 64);\n        constants = new Constant[size];", "refactored_code": "    private static final int DEFAULT_BUFFER_SIZE = 256;\n     * @param cs array of given constants, new ones will be appended\n     */\n    public ConstantPoolGen(Constant[] cs) {\n        StringBuilder sb = new StringBuilder(DEFAULT_BUFFER_SIZE);\n\n        size = Math.max(DEFAULT_BUFFER_SIZE, cs.length + 64);\n        constants = new Constant[size];"}
{"magic_number_smell": "        if (inputStream instanceof DataInputStream) {\n            this.dataInputStream = (DataInputStream) inputStream;\n        } else {\n            this.dataInputStream = new DataInputStream(new BufferedInputStream(inputStream, 8192));\n        }\n    }\n", "refactored_code": "    private static final int BUFSIZE = 8192;\n        if (inputStream instanceof DataInputStream) {\n            this.dataInputStream = (DataInputStream) inputStream;\n        } else {\n            this.dataInputStream = new DataInputStream(new BufferedInputStream(inputStream, BUFSIZE));\n        }\n    }\n"}
{"magic_number_smell": "            int minor, int access_flags, ConstantPool constant_pool, int[] interfaces,\n            Field[] fields, Method[] methods, Attribute[] attributes) {\n        this(class_name_index, superclass_name_index, file_name, major, minor, access_flags,\n                constant_pool, interfaces, fields, methods, attributes, 1);\n    }\n\n", "refactored_code": "    public static final byte HEAP = 1;\n            int minor, int access_flags, ConstantPool constant_pool, int[] interfaces,\n            Field[] fields, Method[] methods, Attribute[] attributes) {\n        this(class_name_index, superclass_name_index, file_name, major, minor, access_flags,\n                constant_pool, interfaces, fields, methods, attributes, HEAP);\n    }\n\n"}
{"magic_number_smell": "    {\n        if (finished.get())\n        {\n            return -1;\n        }\n\n        final int ch = super.read();", "refactored_code": "    private static final int EOF_CHAR = -1;\n    {\n        if (finished.get())\n        {\n            return EOF_CHAR;\n        }\n\n        final int ch = super.read();"}
{"magic_number_smell": "\n    public SftpFileNameParser()\n    {\n        super(22);\n    }\n\n    public static FileNameParser getInstance()", "refactored_code": "    private static final int DEFAULT_PORT = 22;\n\n    public SftpFileNameParser()\n    {\n        super(DEFAULT_PORT);\n    }\n\n    public static FileNameParser getInstance()"}
{"magic_number_smell": "            dataString += \" %s/%s\";\n        }\n        int fieldLength = getNumberOfDigits(totalTests);\n        appendText(format(dataString + \"\\n\", timestamp, formatLong(opsSum, 14),\n                formatLong(opsDelta, 14), formatDouble(opsPerSecDelta, 14),\n                formatLong(numberOfTests, 14 - fieldLength), formatLong(totalTests, fieldLength)), file);\n    }", "refactored_code": "    private static final int NUMBER_FORMAT_LENGTH = 14;\n            dataString += \" %s/%s\";\n        }\n        int fieldLength = getNumberOfDigits(totalTests);\n        appendText(format(dataString + \"\\n\", timestamp, formatLong(opsSum, NUMBER_FORMAT_LENGTH),\n                formatLong(opsDelta, NUMBER_FORMAT_LENGTH), formatDouble(opsPerSecDelta, NUMBER_FORMAT_LENGTH),\n                formatLong(numberOfTests, NUMBER_FORMAT_LENGTH - fieldLength), formatLong(totalTests, fieldLength)), file);\n    }"}
{"magic_number_smell": "\tprivate static final long MAGIC = MAGIC_BASE | (MAJOR << 8) | MINOR;\r\n\tprivate long magicBytes = MAGIC;\r\n\tpublic static final int MAGIC_CONT = 0x434f4e54;   // \"CONT\"\r\n\tprivate long fileLen = 1024 * 2;\r\n\tprivate int freeListStart = 0;\r\n\tprivate int mounted = 0;\r\n\tpublic int spanSize = 16;\r", "refactored_code": "\tpublic static final long PAGESIZE = 1024;\r\n\tprivate static final long MAGIC = MAGIC_BASE | (MAJOR << 8) | MINOR;\r\n\tprivate long magicBytes = MAGIC;\r\n\tpublic static final int MAGIC_CONT = 0x434f4e54;   // \"CONT\"\r\n\tprivate long fileLen = PAGESIZE * 2;\r\n\tprivate int freeListStart = 0;\r\n\tprivate int mounted = 0;\r\n\tpublic int spanSize = 16;\r"}
{"magic_number_smell": "\r\n\t\tBlockFile.pageSeek(bf.file, levelPage);\r\n\t\tlong magic = bf.file.readLong();\r\n\t\tif (magic != 0x42534c6576656c73l)\r\n\t\t\tthrow new IOException(\"Bad SkipLevels magic number 0x\" + Long.toHexString(magic) + \" on page \" + levelPage);\r\n\r\n\t\tbsl.levelHash.put(new Integer(this.levelPage), this);\r", "refactored_code": "\tprivate static final long MAGIC = 0x42534c6576656c73l;  // \"BSLevels\"\r\n\r\n\t\tBlockFile.pageSeek(bf.file, levelPage);\r\n\t\tlong magic = bf.file.readLong();\r\n\t\tif (magic != MAGIC)\r\n\t\t\tthrow new IOException(\"Bad SkipLevels magic number 0x\" + Long.toHexString(magic) + \" on page \" + levelPage);\r\n\r\n\t\tbsl.levelHash.put(new Integer(this.levelPage), this);\r"}
{"magic_number_smell": "\r\n\t\tBlockFile.pageSeek(bf.file, skipPage);\r\n\t\tlong magic = bf.file.readLong();\r\n\t\tif (magic != 0x536b69704c697374l)\r\n\t\t\tthrow new IOException(\"Bad SkipList magic number 0x\" + Long.toHexString(magic) + \" on page \" + skipPage);\r\n\t\tfirstSpanPage = bf.file.readUnsignedInt();\r\n\t\tfirstLevelPage = bf.file.readUnsignedInt();\r", "refactored_code": "\tprivate static final long MAGIC = 0x536b69704c697374l;  // \"SkipList\"\r\n\r\n\t\tBlockFile.pageSeek(bf.file, skipPage);\r\n\t\tlong magic = bf.file.readLong();\r\n\t\tif (magic != MAGIC)\r\n\t\t\tthrow new IOException(\"Bad SkipList magic number 0x\" + Long.toHexString(magic) + \" on page \" + skipPage);\r\n\t\tfirstSpanPage = bf.file.readUnsignedInt();\r\n\t\tfirstLevelPage = bf.file.readUnsignedInt();\r"}
{"magic_number_smell": "\r\n\tpublic static void init(BlockFile bf, int page, int spanSize) throws IOException {\r\n\t\tBlockFile.pageSeek(bf.file, page);\r\n\t\tbf.file.writeInt(0x5370616e);\r\n\t\tbf.file.writeInt(0);\r\n\t\tbf.file.writeInt(0);\r\n\t\tbf.file.writeInt(0);\r", "refactored_code": "\tprotected static final int MAGIC = 0x5370616e;  // \"Span\"\r\n\r\n\tpublic static void init(BlockFile bf, int page, int spanSize) throws IOException {\r\n\t\tBlockFile.pageSeek(bf.file, page);\r\n\t\tbf.file.writeInt(MAGIC);\r\n\t\tbf.file.writeInt(0);\r\n\t\tbf.file.writeInt(0);\r\n\t\tbf.file.writeInt(0);\r"}
{"magic_number_smell": "                DanmakuTimer timer, boolean fromCachingTask) {\n            boolean filtered = danmaku != null && mFilterTypes.contains(danmaku.getType());\n            if (filtered) {\n                danmaku.mFilterParam |= 0x00000001;\n            }\n        }\n", "refactored_code": "    public static final int FILTER_TYPE_TYPE = 0x00000001;\n                DanmakuTimer timer, boolean fromCachingTask) {\n            boolean filtered = danmaku != null && mFilterTypes.contains(danmaku.getType());\n            if (filtered) {\n                danmaku.mFilterParam |= FILTER_TYPE_TYPE;\n            }\n        }\n"}
{"magic_number_smell": "                    });\n                }\n                break;\n            case 1:\n                Long startTime = (Long) msg.obj;\n                if (startTime != null) {\n                    pausedPostion = startTime;", "refactored_code": "    public static final int START = 1;\n                    });\n                }\n                break;\n            case START:\n                Long startTime = (Long) msg.obj;\n                if (startTime != null) {\n                    pausedPostion = startTime;"}
{"magic_number_smell": "                    copyTextPaint,\n                    copyWidthForDropCap,\n                    Layout.Alignment.ALIGN_NORMAL,\n                    1.0f,\n                    lineSpacingExtra,\n                    true\n            );", "refactored_code": "    private static final float SPACING_MULTIPLIER = 1.0f;\n                    copyTextPaint,\n                    copyWidthForDropCap,\n                    Layout.Alignment.ALIGN_NORMAL,\n                    SPACING_MULTIPLIER,\n                    lineSpacingExtra,\n                    true\n            );"}
{"magic_number_smell": "                    copyTextPaint,\n                    copyWidthForDropCap,\n                    Layout.Alignment.ALIGN_NORMAL,\n                    1.0f,\n                    lineSpacingExtra,\n                    true\n            );", "refactored_code": "    private static final float SPACING_MULTIPLIER = 1.0f;\n                    copyTextPaint,\n                    copyWidthForDropCap,\n                    Layout.Alignment.ALIGN_NORMAL,\n                    SPACING_MULTIPLIER,\n                    lineSpacingExtra,\n                    true\n            );"}
{"magic_number_smell": "\t}\n\n\tprivate int ipNumberPart() {\n\t\treturn baseProducer.randomInt(0xFF);\n\t}\n\n}", "refactored_code": "\tprivate static final int MAX = 0xFF;\n\t}\n\n\tprivate int ipNumberPart() {\n\t\treturn baseProducer.randomInt(MAX);\n\t}\n\n}"}
{"magic_number_smell": "    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);"}
{"magic_number_smell": "    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);"}
{"magic_number_smell": "\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != 0x414E4554) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n", "refactored_code": "    private static final int FILE_MAGIC = 0x414E4554;\n\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != FILE_MAGIC) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n"}
{"magic_number_smell": "            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + AlarmManager.INTERVAL_HOUR;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {", "refactored_code": "    private static final long BACKUP_INTERVAL = AlarmManager.INTERVAL_HOUR;\n            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + BACKUP_INTERVAL;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {"}
{"magic_number_smell": "            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > 50 ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;", "refactored_code": "    private static final int INET_CONDITION_THRESHOLD = 50;\n            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;"}
{"magic_number_smell": "        }\n\n        long getDefaultDisplayDelayTimeout() {\n            return 10000;\n        }\n    }\n", "refactored_code": "    private static final long WAIT_FOR_DEFAULT_DISPLAY_TIMEOUT = 10000;\n        }\n\n        long getDefaultDisplayDelayTimeout() {\n            return WAIT_FOR_DEFAULT_DISPLAY_TIMEOUT;\n        }\n    }\n"}
{"magic_number_smell": "    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #-1}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode", "refactored_code": "    public static final int INFINITE = -1;\n    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #INFINITE}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode"}
{"magic_number_smell": "        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+5*1000) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }", "refactored_code": "    private static final long MIN_TIME_BETWEEN_GCS = 5*1000;\n        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+MIN_TIME_BETWEEN_GCS) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }"}
{"magic_number_smell": "        public BugInfoBuilder setExpression(final String expression) {\n            if (expression == null) {\n                bugInfo.expression = \"\";\n            } else if (expression.length() > 200) {\n                bugInfo.expression = expression.substring(0, 200);\n            } else {\n                bugInfo.expression = expression;", "refactored_code": "        private static final int MAX_LENGTH = 200;\n        public BugInfoBuilder setExpression(final String expression) {\n            if (expression == null) {\n                bugInfo.expression = \"\";\n            } else if (expression.length() > MAX_LENGTH) {\n                bugInfo.expression = expression.substring(0, MAX_LENGTH);\n            } else {\n                bugInfo.expression = expression;"}
{"magic_number_smell": "  }\n\n  public void appendOutput(String s) {\n    if (getSize() > 20) {\n      try { Thread.sleep(500); } catch (InterruptedException e) { }\n    }\n    if (getSize() > 20) {", "refactored_code": "  private static final int OUTPUT_QUEUE_SIZE = 20;\n  }\n\n  public void appendOutput(String s) {\n    if (getSize() > OUTPUT_QUEUE_SIZE) {\n      try { Thread.sleep(500); } catch (InterruptedException e) { }\n    }\n    if (getSize() > OUTPUT_QUEUE_SIZE) {"}
{"magic_number_smell": "\n                        // track and wait for the wire Component\n                        String filterString = \"(\" + ConfigurationService.KURA_SERVICE_PID + \"=\" + temporaryName + \")\";\n                        ServiceUtil.waitForService(filterString, 60, TimeUnit.SECONDS);\n\n                        conf = cs.getComponentConfiguration(temporaryName);\n                        comp = createMetatypeOnlyGwtComponentConfiguration(conf);", "refactored_code": "    private static final int SERVICE_WAIT_TIMEOUT = 60;\n\n                        // track and wait for the wire Component\n                        String filterString = \"(\" + ConfigurationService.KURA_SERVICE_PID + \"=\" + temporaryName + \")\";\n                        ServiceUtil.waitForService(filterString, SERVICE_WAIT_TIMEOUT, TimeUnit.SECONDS);\n\n                        conf = cs.getComponentConfiguration(temporaryName);\n                        comp = createMetatypeOnlyGwtComponentConfiguration(conf);"}
{"magic_number_smell": "\n                        // track and wait for the wire Component\n                        String filterString = \"(\" + ConfigurationService.KURA_SERVICE_PID + \"=\" + temporaryName + \")\";\n                        ServiceUtil.waitForService(filterString, 60, TimeUnit.SECONDS);\n\n                        conf = cs.getComponentConfiguration(temporaryName);\n                        comp = createMetatypeOnlyGwtComponentConfiguration(conf);", "refactored_code": "    private static final int SERVICE_WAIT_TIMEOUT = 60;\n\n                        // track and wait for the wire Component\n                        String filterString = \"(\" + ConfigurationService.KURA_SERVICE_PID + \"=\" + temporaryName + \")\";\n                        ServiceUtil.waitForService(filterString, SERVICE_WAIT_TIMEOUT, TimeUnit.SECONDS);\n\n                        conf = cs.getComponentConfiguration(temporaryName);\n                        comp = createMetatypeOnlyGwtComponentConfiguration(conf);"}
{"magic_number_smell": "            if (!isLocalServerRunning()) {\n                startLocalServer();\n            }\n        }, 0, 30, TimeUnit.SECONDS);\n    }\n\n    private void startLocalServer() {", "refactored_code": "    private static final int MONITOR_PERIOD = 30;\n            if (!isLocalServerRunning()) {\n                startLocalServer();\n            }\n        }, 0, MONITOR_PERIOD, TimeUnit.SECONDS);\n    }\n\n    private void startLocalServer() {"}
{"magic_number_smell": "    if (v) {\n      setExpireAfterWrite(ExpiryTimeValues.ETERNAL);\n    } else {\n      setExpireAfterWrite(Long.MAX_VALUE - 1);\n    }\n  }\n", "refactored_code": "  public static final long EXPIRY_NOT_ETERNAL = Long.MAX_VALUE - 1;\n    if (v) {\n      setExpireAfterWrite(ExpiryTimeValues.ETERNAL);\n    } else {\n      setExpireAfterWrite(EXPIRY_NOT_ETERNAL);\n    }\n  }\n"}
{"magic_number_smell": "        PerfRecorder recorderSetRealValue = new PerfRecorder(\"setRealValue\");\n\n        // WHEN\n        for (int i = 0; i < 10_000; i++) {\n            long tsStart = System.nanoTime();\n\n            PrismContainerValue<AssignmentType> newValue = assignmentContainer.createNewValue();", "refactored_code": "    private static final int ITERATIONS = 10_000;\n        PerfRecorder recorderSetRealValue = new PerfRecorder(\"setRealValue\");\n\n        // WHEN\n        for (int i = 0; i < ITERATIONS; i++) {\n            long tsStart = System.nanoTime();\n\n            PrismContainerValue<AssignmentType> newValue = assignmentContainer.createNewValue();"}
{"magic_number_smell": "\n  public static synchronized void reset() {\n    for (final Entry<Integer, boolean[]> each : CLASS_HITS.entrySet()) {\n      if (each.getValue()[0]) { //Probe 0 gets covered by any method that runs\n        Arrays.fill(each.getValue(), false);\n      }\n    }", "refactored_code": "  private static final int                     CLASS_HIT_INDEX   = 0;\n\n  public static synchronized void reset() {\n    for (final Entry<Integer, boolean[]> each : CLASS_HITS.entrySet()) {\n      if (each.getValue()[CLASS_HIT_INDEX]) { //Probe 0 gets covered by any method that runs\n        Arrays.fill(each.getValue(), false);\n      }\n    }"}
{"magic_number_smell": "\n  public static synchronized void reset() {\n    for (final Entry<Integer, boolean[]> each : CLASS_HITS.entrySet()) {\n      if (each.getValue()[0]) { //Probe 0 gets covered by any method that runs\n        Arrays.fill(each.getValue(), false);\n      }\n    }", "refactored_code": "  private static final int                     CLASS_HIT_INDEX   = 0;\n\n  public static synchronized void reset() {\n    for (final Entry<Integer, boolean[]> each : CLASS_HITS.entrySet()) {\n      if (each.getValue()[CLASS_HIT_INDEX]) { //Probe 0 gets covered by any method that runs\n        Arrays.fill(each.getValue(), false);\n      }\n    }"}
{"magic_number_smell": "        while (System.currentTimeMillis() - START_TIME < MAX_TIME_PER_CHOICE) {\r\n\t\t\tpruneScore = createPruneScore();\r\n\t\t\tprocessingLeft = 1;\r\n\t\t\tstartWorker(firstChoice,mainPhases,120,INITIAL_MAX_GAMES);\r\n\t\t\twaitUntilProcessed();\r\n            if (mainPhases >= MAX_MAIN_PHASES || \r\n                firstChoice.aiScore.getScore() > ArtificialScoringSystem.WIN_GAME_SCORE / 2) {\r", "refactored_code": "\tprivate static final int INITIAL_MAX_DEPTH=120;\r\n        while (System.currentTimeMillis() - START_TIME < MAX_TIME_PER_CHOICE) {\r\n\t\t\tpruneScore = createPruneScore();\r\n\t\t\tprocessingLeft = 1;\r\n\t\t\tstartWorker(firstChoice,mainPhases,INITIAL_MAX_DEPTH,INITIAL_MAX_GAMES);\r\n\t\t\twaitUntilProcessed();\r\n            if (mainPhases >= MAX_MAIN_PHASES || \r\n                firstChoice.aiScore.getScore() > ArtificialScoringSystem.WIN_GAME_SCORE / 2) {\r"}
{"magic_number_smell": "    /**\n     * Offset within the log meta data where the active term id is stored.\n     */\n    public static final int LOG_META_DATA_SECTION_INDEX = 3 * 2;\n\n    /**\n     * Offset within the log meta data where the active term id is stored.", "refactored_code": "    public static final int PARTITION_COUNT = 3;\n    /**\n     * Offset within the log meta data where the active term id is stored.\n     */\n    public static final int LOG_META_DATA_SECTION_INDEX = PARTITION_COUNT * 2;\n\n    /**\n     * Offset within the log meta data where the active term id is stored."}
{"magic_number_smell": "    {\n        if (nowNs >= clockUpdateDeadlineNs)\n        {\n            clockUpdateDeadlineNs = nowNs + TimeUnit.MILLISECONDS.toNanos(1);\n            cachedNanoClock.update(nowNs);\n            cachedEpochClock.update(epochClock.time());\n        }", "refactored_code": "    private static final long CLOCK_UPDATE_DURATION_NS = TimeUnit.MILLISECONDS.toNanos(1);\n    {\n        if (nowNs >= clockUpdateDeadlineNs)\n        {\n            clockUpdateDeadlineNs = nowNs + CLOCK_UPDATE_DURATION_NS;\n            cachedNanoClock.update(nowNs);\n            cachedEpochClock.update(epochClock.time());\n        }"}
{"magic_number_smell": "    /**\n     * Offset within the log meta data where the active term id is stored.\n     */\n    public static final int LOG_META_DATA_SECTION_INDEX = 3 * 2;\n\n    /**\n     * Offset within the log meta data where the active term id is stored.", "refactored_code": "    public static final int PARTITION_COUNT = 3;\n    /**\n     * Offset within the log meta data where the active term id is stored.\n     */\n    public static final int LOG_META_DATA_SECTION_INDEX = PARTITION_COUNT * 2;\n\n    /**\n     * Offset within the log meta data where the active term id is stored."}
{"magic_number_smell": "    /**\n     * Offset within the log meta data where the active term id is stored.\n     */\n    public static final int LOG_META_DATA_SECTION_INDEX = 3 * 2;\n\n    /**\n     * Offset within the log meta data where the active term id is stored.", "refactored_code": "    public static final int PARTITION_COUNT = 3;\n    /**\n     * Offset within the log meta data where the active term id is stored.\n     */\n    public static final int LOG_META_DATA_SECTION_INDEX = PARTITION_COUNT * 2;\n\n    /**\n     * Offset within the log meta data where the active term id is stored."}
{"magic_number_smell": "    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);"}
{"magic_number_smell": "    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);"}
{"magic_number_smell": "\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != 0x414E4554) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n", "refactored_code": "    private static final int FILE_MAGIC = 0x414E4554;\n\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != FILE_MAGIC) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n"}
{"magic_number_smell": "            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + AlarmManager.INTERVAL_HOUR;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {", "refactored_code": "    private static final long BACKUP_INTERVAL = AlarmManager.INTERVAL_HOUR;\n            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + BACKUP_INTERVAL;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {"}
{"magic_number_smell": "            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > 50 ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;", "refactored_code": "    private static final int INET_CONDITION_THRESHOLD = 50;\n            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;"}
{"magic_number_smell": "        }\n\n        long getDefaultDisplayDelayTimeout() {\n            return 10000;\n        }\n    }\n", "refactored_code": "    private static final long WAIT_FOR_DEFAULT_DISPLAY_TIMEOUT = 10000;\n        }\n\n        long getDefaultDisplayDelayTimeout() {\n            return WAIT_FOR_DEFAULT_DISPLAY_TIMEOUT;\n        }\n    }\n"}
{"magic_number_smell": "    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #-1}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode", "refactored_code": "    public static final int INFINITE = -1;\n    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #INFINITE}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode"}
{"magic_number_smell": "        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+5*1000) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }", "refactored_code": "    private static final long MIN_TIME_BETWEEN_GCS = 5*1000;\n        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+MIN_TIME_BETWEEN_GCS) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }"}
{"magic_number_smell": "    private static final long 1L = 1L;\n\n    public static class BaseDirectory implements Serializable {\n        private static final long 1L = 1L;\n        private BaseDirValueContext context;\n        private String name;\n", "refactored_code": "    private static final long serialVersionUID = 1L;\n    private static final long serialVersionUID = 1L;\n\n    public static class BaseDirectory implements Serializable {\n        private static final long serialVersionUID = 1L;\n        private BaseDirValueContext context;\n        private String name;\n"}
{"magic_number_smell": "    @Summary(index = 0)\n    private int id;\n\n    @Column(name = \"UUID\", length = 36)\n    // db type is CHAR, this string will thus always be of this length\n    private String uuid;\n", "refactored_code": "    private static final int UUID_LENGTH = 36;\n    @Summary(index = 0)\n    private int id;\n\n    @Column(name = \"UUID\", length = UUID_LENGTH)\n    // db type is CHAR, this string will thus always be of this length\n    private String uuid;\n"}
{"magic_number_smell": "    @Override\n    public void tick() {\n        if (gameOver > 0) {\n            if (++gameOver > 15) {\n                chips.clear();\n                gameOver = 0;\n            } else return;", "refactored_code": "    public static final int TIMEOUT_TICKS = 15;\n    @Override\n    public void tick() {\n        if (gameOver > 0) {\n            if (++gameOver > TIMEOUT_TICKS) {\n                chips.clear();\n                gameOver = 0;\n            } else return;"}
{"magic_number_smell": "        String footer = '\\n' + importFormatsList + outFormatsList + \"\\nPlease report issues at https://github.com/JabRef/jabref/issues.\";\n\n        HelpFormatter formatter = new HelpFormatter();\n        formatter.printHelp(100, \"jabref [OPTIONS] [BIBTEX_FILE]\\n\\nOptions:\", header, getOptions(), footer, true);\n    }\n\n    private String getVersionInfo() {", "refactored_code": "    private static final int WIDTH = 100; // Number of characters per line\n        String footer = '\\n' + importFormatsList + outFormatsList + \"\\nPlease report issues at https://github.com/JabRef/jabref/issues.\";\n\n        HelpFormatter formatter = new HelpFormatter();\n        formatter.printHelp(WIDTH, \"jabref [OPTIONS] [BIBTEX_FILE]\\n\\nOptions:\", header, getOptions(), footer, true);\n    }\n\n    private String getVersionInfo() {"}
{"magic_number_smell": "\n    @Override\n    public void run() {\n        if (basePanel.getSelectedEntries().size() >= 10) {\n            String[] options = new String[]{Localization.lang(\"Look up full text documents\"), Localization.lang(\"Cancel\")};\n            int answer = JOptionPane.showOptionDialog(basePanel.frame(),\n                    Localization.lang(", "refactored_code": "    private static final int warningLimit = 10; // The minimum number of selected entries to ask the user for confirmation\n\n    @Override\n    public void run() {\n        if (basePanel.getSelectedEntries().size() >= warningLimit) {\n            String[] options = new String[]{Localization.lang(\"Look up full text documents\"), Localization.lang(\"Cancel\")};\n            int answer = JOptionPane.showOptionDialog(basePanel.frame(),\n                    Localization.lang("}
{"magic_number_smell": "            return;\n        }\n        final Rectangle r = getVisibleRect();\n        final boolean scrollUp = (cursor.y - r.y) < GroupsTree.10;\n        final boolean scrollDown = ((r.y + r.height) - cursor.y) < GroupsTree.10;\n        final boolean scrollLeft = (cursor.x - r.x) < GroupsTree.10;\n        final boolean scrollRight = ((r.x + r.width) - cursor.x) < GroupsTree.10;", "refactored_code": "    private static final int DRAG_SCROLL_ACTIVATION_MARGIN = 10;\n            return;\n        }\n        final Rectangle r = getVisibleRect();\n        final boolean scrollUp = (cursor.y - r.y) < GroupsTree.DRAG_SCROLL_ACTIVATION_MARGIN;\n        final boolean scrollDown = ((r.y + r.height) - cursor.y) < GroupsTree.DRAG_SCROLL_ACTIVATION_MARGIN;\n        final boolean scrollLeft = (cursor.x - r.x) < GroupsTree.DRAG_SCROLL_ACTIVATION_MARGIN;\n        final boolean scrollRight = ((r.x + r.width) - cursor.x) < GroupsTree.DRAG_SCROLL_ACTIVATION_MARGIN;"}
{"magic_number_smell": "        deselectAll.addActionListener(new SelectionButton(false));\n        deselectAllDuplicates.addActionListener(e -> {\n            for (int i = 0; i < glTable.getRowCount(); i++) {\n                if (glTable.getValueAt(i, 1) != null) {\n                    glTable.setValueAt(false, i, 0);\n                }\n            }", "refactored_code": "    private static final int DUPL_COL = 1;\n        deselectAll.addActionListener(new SelectionButton(false));\n        deselectAllDuplicates.addActionListener(e -> {\n            for (int i = 0; i < glTable.getRowCount(); i++) {\n                if (glTable.getValueAt(i, DUPL_COL) != null) {\n                    glTable.setValueAt(false, i, 0);\n                }\n            }"}
{"magic_number_smell": "    }\n\n    protected boolean isJarFile(File file) throws IOException {\n        return checkMagic(file, 0x504B0304);\n    }\n\n}", "refactored_code": "    private static final int ZIP_MAGIC = 0x504B0304;\n    }\n\n    protected boolean isJarFile(File file) throws IOException {\n        return checkMagic(file, ZIP_MAGIC);\n    }\n\n}"}
{"magic_number_smell": "    while (DecompositionType.DECOMPOSABLE == canExposeExpression(expression)) {\n      exposeExpression(expression);\n      i++;\n      if (i > 1000) {\n        throw new IllegalStateException(\n            \"DecomposeExpression depth exceeded on:\\n\" + expression.toStringTree());\n      }", "refactored_code": "  private static final int MAX_ITERATIONS = 1000;\n    while (DecompositionType.DECOMPOSABLE == canExposeExpression(expression)) {\n      exposeExpression(expression);\n      i++;\n      if (i > MAX_ITERATIONS) {\n        throw new IllegalStateException(\n            \"DecomposeExpression depth exceeded on:\\n\" + expression.toStringTree());\n      }"}
{"magic_number_smell": "            return;\n        }\n        \n        this.isPanelsCollapsed = bundle.responses.size() > 500;\n        \n        switch (viewType) {\n            case RECIPIENT_GIVER_QUESTION:", "refactored_code": "    private static final int RESPONSE_LIMIT_FOR_COLLAPSING_PANEL = 500;\n            return;\n        }\n        \n        this.isPanelsCollapsed = bundle.responses.size() > RESPONSE_LIMIT_FOR_COLLAPSING_PANEL;\n        \n        switch (viewType) {\n            case RECIPIENT_GIVER_QUESTION:"}
{"magic_number_smell": "            if (currentStudent.section.equals(previousStudent.section)) {\n                studentsCount++;\n            } else {\n                if (studentsCount > 100) {\n                    invalidSectionList.add(previousStudent.section);\n                }\n                studentsCount = 1;", "refactored_code": "    private static final int SECTION_SIZE_LIMIT = 100;\n            if (currentStudent.section.equals(previousStudent.section)) {\n                studentsCount++;\n            } else {\n                if (studentsCount > SECTION_SIZE_LIMIT) {\n                    invalidSectionList.add(previousStudent.section);\n                }\n                studentsCount = 1;"}
{"magic_number_smell": "            return;\n        }\n        \n        this.isPanelsCollapsed = bundle.responses.size() > 500;\n        \n        switch (viewType) {\n            case RECIPIENT_GIVER_QUESTION:", "refactored_code": "    private static final int RESPONSE_LIMIT_FOR_COLLAPSING_PANEL = 500;\n            return;\n        }\n        \n        this.isPanelsCollapsed = bundle.responses.size() > RESPONSE_LIMIT_FOR_COLLAPSING_PANEL;\n        \n        switch (viewType) {\n            case RECIPIENT_GIVER_QUESTION:"}
{"magic_number_smell": "        connection.start();\n        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\n        System.out.printf(\"Waiting up to %s milliseconds to receive %s messages\\n\", 15000L, MESSAGE_COUNT);\n        try {\n            // Create a producer for the queue\n            Queue destination = session.createQueue(QUEUE);", "refactored_code": "    private static final long MESSAGE_TIMEOUT_MILLIS = 15000L;\n        connection.start();\n        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\n        System.out.printf(\"Waiting up to %s milliseconds to receive %s messages\\n\", MESSAGE_TIMEOUT_MILLIS, MESSAGE_COUNT);\n        try {\n            // Create a producer for the queue\n            Queue destination = session.createQueue(QUEUE);"}
{"magic_number_smell": "        connection.start();\n        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\n        System.out.printf(\"Waiting up to %s milliseconds to receive %s messages\\n\", 15000L, MESSAGE_COUNT);\n        try {\n            // Create a producer for the queue\n            Queue destination = session.createQueue(QUEUE);", "refactored_code": "    private static final long MESSAGE_TIMEOUT_MILLIS = 15000L;\n        connection.start();\n        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n\n        System.out.printf(\"Waiting up to %s milliseconds to receive %s messages\\n\", MESSAGE_TIMEOUT_MILLIS, MESSAGE_COUNT);\n        try {\n            // Create a producer for the queue\n            Queue destination = session.createQueue(QUEUE);"}
{"magic_number_smell": "\t\tif ( index >= 0 && index < allocatedSize )\n\t\t{\n\t\t\tupdateAccess( dataAccess, index );\n\t\t\tfinal boolean isFree = dataAccess.getInt( 0 ) == -2;\n\t\t\tif ( ! isFree )\n\t\t\t{\n\t\t\t\tdataAccess.putIndex( -2, 0 );", "refactored_code": "\tpublic static final int FREE_ELEMENT_MAGIC_NUMBER = -2;\n\t\tif ( index >= 0 && index < allocatedSize )\n\t\t{\n\t\t\tupdateAccess( dataAccess, index );\n\t\t\tfinal boolean isFree = dataAccess.getInt( 0 ) == FREE_ELEMENT_MAGIC_NUMBER;\n\t\t\tif ( ! isFree )\n\t\t\t{\n\t\t\t\tdataAccess.putIndex( FREE_ELEMENT_MAGIC_NUMBER, 0 );"}
{"magic_number_smell": "\n            // get start day running hours\n            String startDayStr = DATE_FORMAT.format(startTime);\n            long endOfTheDay = DATE_FORMAT.parse(startDayStr).getTime() + TimeUnit.HOURS.toMillis(24) - 1;\n            runningHours = TimeUnit.MILLISECONDS.toHours(endOfTheDay - startTime.getTime());\n            CloudbreakUsage startDayUsage = getCloudbreakUsage(prototype, runningHours, startTime);\n            dailyStackUsageMap.put(DATE_FORMAT.format(startTime), startDayUsage);", "refactored_code": "    private static final int HOURS_IN_DAY = 24;\n\n            // get start day running hours\n            String startDayStr = DATE_FORMAT.format(startTime);\n            long endOfTheDay = DATE_FORMAT.parse(startDayStr).getTime() + TimeUnit.HOURS.toMillis(HOURS_IN_DAY) - 1;\n            runningHours = TimeUnit.MILLISECONDS.toHours(endOfTheDay - startTime.getTime());\n            CloudbreakUsage startDayUsage = getCloudbreakUsage(prototype, runningHours, startTime);\n            dailyStackUsageMap.put(DATE_FORMAT.format(startTime), startDayUsage);"}
{"magic_number_smell": "        if (this.currEntry != null && this.currEntry.isGNULongNameEntry()) {\n            // read in the name\n            StringBuffer longName = new StringBuffer();\n            byte[] buf = new byte[256];\n            int length = 0;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));", "refactored_code": "    private static final int SMALL_BUFFER_SIZE = 256;\n        if (this.currEntry != null && this.currEntry.isGNULongNameEntry()) {\n            // read in the name\n            StringBuffer longName = new StringBuffer();\n            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n            int length = 0;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));"}
{"magic_number_smell": "        long sum = 0;\n\n        for (int i = 0; i < buf.length; ++i) {\n            sum += 255 & buf[i];\n        }\n\n        return sum;", "refactored_code": "    private static final int BYTE_MASK = 255;\n        long sum = 0;\n\n        for (int i = 0; i < buf.length; ++i) {\n            sum += BYTE_MASK & buf[i];\n        }\n\n        return sum;"}
{"magic_number_smell": "     * @since 1.1\n     */\n    public ZipShort getLocalFileDataLength() {\n        return new ZipShort(4         // CRC\n                          + 2         // Mode\n                          + 4         // SizDev\n                          + 2         // UID", "refactored_code": "    private static final int      WORD = 4;\n     * @since 1.1\n     */\n    public ZipShort getLocalFileDataLength() {\n        return new ZipShort(WORD         // CRC\n                          + 2         // Mode\n                          + WORD         // SizDev\n                          + 2         // UID"}
{"magic_number_smell": "     */\n    public void write(int b) throws IOException {\n        byte[] buff = new byte[1];\n        buff[0] = (byte) (b & 0xFF);\n        write(buff, 0, 1);\n    }\n", "refactored_code": "    private static final int BYTE_MASK = 0xFF;\n     */\n    public void write(int b) throws IOException {\n        byte[] buff = new byte[1];\n        buff[0] = (byte) (b & BYTE_MASK);\n        write(buff, 0, 1);\n    }\n"}
{"magic_number_smell": "        long startTime = System.currentTimeMillis();\n\n        // only track progress for files larger than 100kb in verbose mode\n        boolean trackProgress = getVerbose() && filesize > 102400;\n        // since filesize keeps on decreasing we have to store the\n        // initial filesize\n        long initFilesize = filesize;", "refactored_code": "    private static final int HUNDRED_KILOBYTES = 102400;\n        long startTime = System.currentTimeMillis();\n\n        // only track progress for files larger than 100kb in verbose mode\n        boolean trackProgress = getVerbose() && filesize > HUNDRED_KILOBYTES;\n        // since filesize keeps on decreasing we have to store the\n        // initial filesize\n        long initFilesize = filesize;"}
{"magic_number_smell": "        long totalLength = le.getAttrs().getSize();\n\n        SftpProgressMonitor monitor = null;\n        boolean trackProgress = getVerbose() && totalLength > 102400;\n        if (trackProgress) {\n            monitor = getProgressMonitor();\n        }", "refactored_code": "    private static final int HUNDRED_KILOBYTES = 102400;\n        long totalLength = le.getAttrs().getSize();\n\n        SftpProgressMonitor monitor = null;\n        boolean trackProgress = getVerbose() && totalLength > HUNDRED_KILOBYTES;\n        if (trackProgress) {\n            monitor = getProgressMonitor();\n        }"}
{"magic_number_smell": "        long totalLength = 0;\n\n        // only track progress for files larger than 100kb in verbose mode\n        boolean trackProgress = getVerbose() && filesize > 102400;\n        // since filesize keeps on decreasing we have to store the\n        // initial filesize\n        long initFilesize = filesize;", "refactored_code": "    private static final int HUNDRED_KILOBYTES = 102400;\n        long totalLength = 0;\n\n        // only track progress for files larger than 100kb in verbose mode\n        boolean trackProgress = getVerbose() && filesize > HUNDRED_KILOBYTES;\n        // since filesize keeps on decreasing we have to store the\n        // initial filesize\n        long initFilesize = filesize;"}
{"magic_number_smell": "        long totalLength = filesize;\n\n        // only track progress for files larger than 100kb in verbose mode\n        boolean trackProgress = getVerbose() && filesize > 102400;\n\n        SftpProgressMonitor monitor = null;\n        if (trackProgress) {", "refactored_code": "    private static final int HUNDRED_KILOBYTES = 102400;\n        long totalLength = filesize;\n\n        // only track progress for files larger than 100kb in verbose mode\n        boolean trackProgress = getVerbose() && filesize > HUNDRED_KILOBYTES;\n\n        SftpProgressMonitor monitor = null;\n        if (trackProgress) {"}
{"magic_number_smell": "public class AdaptiveSchedulerTest extends TestLogger {\n\n    private static final int 4 = 4;\n    private static final JobVertex JOB_VERTEX = createNoOpVertex(\"v1\", 4);\n\n    @ClassRule\n    public static final TestExecutorResource<ScheduledExecutorService> EXECUTOR_RESOURCE =", "refactored_code": "    private static final int PARALLELISM = 4;\npublic class AdaptiveSchedulerTest extends TestLogger {\n\n    private static final int PARALLELISM = 4;\n    private static final JobVertex JOB_VERTEX = createNoOpVertex(\"v1\", PARALLELISM);\n\n    @ClassRule\n    public static final TestExecutorResource<ScheduledExecutorService> EXECUTOR_RESOURCE ="}
{"magic_number_smell": "\t\tDataOutputSerializer dos = new DataOutputSerializer(32);\n\n\t\tkeySerializer.serialize(key, dos);\n\t\tdos.writeByte(42);\n\t\tnamespaceSerializer.serialize(namespace, dos);\n\n\t\treturn dos.getCopyOfBuffer();", "refactored_code": "\tprivate static final int MAGIC_NUMBER = 42;\n\t\tDataOutputSerializer dos = new DataOutputSerializer(32);\n\n\t\tkeySerializer.serialize(key, dos);\n\t\tdos.writeByte(MAGIC_NUMBER);\n\t\tnamespaceSerializer.serialize(namespace, dos);\n\n\t\treturn dos.getCopyOfBuffer();"}
{"magic_number_smell": "\t\tthis.tasksToCommitTo = checkNotNull(tasksToCommitTo);\n\t\tthis.pendingCheckpoints = new LinkedHashMap<Long, PendingCheckpoint>();\n\t\tthis.completedCheckpointStore = checkNotNull(completedCheckpointStore);\n\t\tthis.recentPendingCheckpoints = new ArrayDeque<Long>(16);\n\t\tthis.userClassLoader = userClassLoader;\n\n\t\t// Started with the periodic scheduler", "refactored_code": "\tprivate static final int NUM_GHOST_CHECKPOINT_IDS = 16;\n\t\tthis.tasksToCommitTo = checkNotNull(tasksToCommitTo);\n\t\tthis.pendingCheckpoints = new LinkedHashMap<Long, PendingCheckpoint>();\n\t\tthis.completedCheckpointStore = checkNotNull(completedCheckpointStore);\n\t\tthis.recentPendingCheckpoints = new ArrayDeque<Long>(NUM_GHOST_CHECKPOINT_IDS);\n\t\tthis.userClassLoader = userClassLoader;\n\n\t\t// Started with the periodic scheduler"}
{"magic_number_smell": "\n\t@Override\n\tpublic int getVersion() {\n\t\treturn 0;\n\t}\n\n\t@Override", "refactored_code": "\tpublic static final int VERSION = 0;\n\n\t@Override\n\tpublic int getVersion() {\n\t\treturn VERSION;\n\t}\n\n\t@Override"}
{"magic_number_smell": "  }\n\n  private void serializeFooter(RedelmMetaData footer, OutputStream os) throws IOException {\n    parquet.format.FileMetaData parquetMetadata = new ParquetMetadataConverter().toParquetMetadata(1, footer);\n    metadataConverter.writeFileMetaData(parquetMetadata, os);\n  }\n", "refactored_code": "  public static final int CURRENT_VERSION = 1;\n  }\n\n  private void serializeFooter(RedelmMetaData footer, OutputStream os) throws IOException {\n    parquet.format.FileMetaData parquetMetadata = new ParquetMetadataConverter().toParquetMetadata(CURRENT_VERSION, footer);\n    metadataConverter.writeFileMetaData(parquetMetadata, os);\n  }\n"}
{"magic_number_smell": "          throw new ParserException(\"X-TIMESTAMP-MAP doesn't contain media timestamp: \" + line);\n        } else {\n          mediaTimestampUs = (Long.parseLong(timestampMatcher.group().substring(7)) * 1000)\n              / 90 + mediaTimestampOffsetUs;\n        }\n        mediaTimestampUs = getAdjustedStartTime(mediaTimestampUs);\n      }", "refactored_code": "  private static final long SAMPLING_RATE = 90;\n          throw new ParserException(\"X-TIMESTAMP-MAP doesn't contain media timestamp: \" + line);\n        } else {\n          mediaTimestampUs = (Long.parseLong(timestampMatcher.group().substring(7)) * 1000)\n              / SAMPLING_RATE + mediaTimestampOffsetUs;\n        }\n        mediaTimestampUs = getAdjustedStartTime(mediaTimestampUs);\n      }"}
{"magic_number_smell": "\n        case R.id.action_settings:\n            Intent prefs = new Intent(getBaseContext(), PreferencesActivity.class);\n            startActivityForResult(prefs, 1);\n            return true;\n\n        case R.id.action_swap:", "refactored_code": "    public static final int REQUEST_PREFS = 1;\n\n        case R.id.action_settings:\n            Intent prefs = new Intent(getBaseContext(), PreferencesActivity.class);\n            startActivityForResult(prefs, REQUEST_PREFS);\n            return true;\n\n        case R.id.action_swap:"}
{"magic_number_smell": "                    notificationManager.notify(NOTIFY_ID_UPDATING, notificationBuilder.build());\n                    Toast.makeText(context, text, Toast.LENGTH_LONG).show();\n                    break;\n                case 0:\n                    break;\n                case STATUS_COMPLETE_AND_SAME:\n                    text = context.getString(R.string.repos_unchanged);", "refactored_code": "    public static final int STATUS_COMPLETE_WITH_CHANGES = 0;\n                    notificationManager.notify(NOTIFY_ID_UPDATING, notificationBuilder.build());\n                    Toast.makeText(context, text, Toast.LENGTH_LONG).show();\n                    break;\n                case STATUS_COMPLETE_WITH_CHANGES:\n                    break;\n                case STATUS_COMPLETE_AND_SAME:\n                    text = context.getString(R.string.repos_unchanged);"}
{"magic_number_smell": "     */\n    public static final int STEP_INITIAL_LOADING = 9;\n\n    @SwapStep private int step = 1;\n\n    /**\n     * Current screen that the swap process is up to.", "refactored_code": "    public static final int STEP_INTRO           = 1;\n     */\n    public static final int STEP_INITIAL_LOADING = 9;\n\n    @SwapStep private int step = STEP_INTRO;\n\n    /**\n     * Current screen that the swap process is up to."}
{"magic_number_smell": "    private static class LocalWrapperException extends RuntimeException {\n\n        /** Serializable UID. */\n        private static final long 4489391420715269318L = 2734331164409224983L;\n\n        /** Wrapped exception. */\n        private final OrekitException wrappedException;", "refactored_code": "    private static final long serialVersionUID = 4489391420715269318L;\n    private static class LocalWrapperException extends RuntimeException {\n\n        /** Serializable UID. */\n        private static final long serialVersionUID = 2734331164409224983L;\n\n        /** Wrapped exception. */\n        private final OrekitException wrappedException;"}
{"magic_number_smell": "                               FramesFactory.getEME2000(), AbsoluteDate.J2000_EPOCH, 3.986004415e14);\n        KeplerianPropagator propagator = new KeplerianPropagator(orbit);\n        propagator.setMasterMode(new OrekitStepHandler() {\n            private static final long 5918362126173997016L = 8183822352839222377L;\n            public void handleStep(OrekitStepInterpolator interpolator,\n                                   boolean isLast) throws PropagationException {\n                if (isLast) {", "refactored_code": "            private static final long serialVersionUID = 5918362126173997016L;\n                               FramesFactory.getEME2000(), AbsoluteDate.J2000_EPOCH, 3.986004415e14);\n        KeplerianPropagator propagator = new KeplerianPropagator(orbit);\n        propagator.setMasterMode(new OrekitStepHandler() {\n            private static final long serialVersionUID = 8183822352839222377L;\n            public void handleStep(OrekitStepInterpolator interpolator,\n                                   boolean isLast) throws PropagationException {\n                if (isLast) {"}
{"magic_number_smell": "    @Test\n    public void testAutoEmbeddedTimer() throws OrekitException {\n    \tdateDetector = new DateDetector(maxCheck, threshold, iniDate.shiftedBy(-dt)) {\n            private static final long 3583432139818469589L = 1L;\n\t\t\tpublic int eventOccurred(SpacecraftState s, boolean increasing) throws OrekitException {\n\t\t\t\tAbsoluteDate nextDate = s.getDate().shiftedBy(-dt);\n\t\t\t\tthis.addEventDate(nextDate);", "refactored_code": "\t\t\tprivate static final long serialVersionUID = 3583432139818469589L;\n    @Test\n    public void testAutoEmbeddedTimer() throws OrekitException {\n    \tdateDetector = new DateDetector(maxCheck, threshold, iniDate.shiftedBy(-dt)) {\n            private static final long serialVersionUID = 1L;\n\t\t\tpublic int eventOccurred(SpacecraftState s, boolean increasing) throws OrekitException {\n\t\t\t\tAbsoluteDate nextDate = s.getDate().shiftedBy(-dt);\n\t\t\t\tthis.addEventDate(nextDate);"}
{"magic_number_smell": "                final boolean isPrimaryKeyQuery = queryAttributeName.equals(primaryKeyPropertyName);\n                final QueryRequest queryRequest = new QueryRequest().withTableName(tableName)\n                        .withKeyConditions(conditions).withExclusiveStartKey(lastEvaluatedKey);\n                queryRequest.setLimit(500);\n                if (!isPrimaryKeyQuery) {\n                    queryRequest.withIndexName(queryAttributeName + \"_idx\");\n                }", "refactored_code": "    public static final int BATCH_SIZE = 500;\n                final boolean isPrimaryKeyQuery = queryAttributeName.equals(primaryKeyPropertyName);\n                final QueryRequest queryRequest = new QueryRequest().withTableName(tableName)\n                        .withKeyConditions(conditions).withExclusiveStartKey(lastEvaluatedKey);\n                queryRequest.setLimit(BATCH_SIZE);\n                if (!isPrimaryKeyQuery) {\n                    queryRequest.withIndexName(queryAttributeName + \"_idx\");\n                }"}
{"magic_number_smell": "  private boolean drawFrameOrFallback(Canvas canvas, int frameNumber, @FrameType int frameType) {\n    CloseableReference<Bitmap> bitmapReference = null;\n    boolean drawn = false;\n    int nextFrameType = -1;\n\n    try {\n      switch (frameType) {", "refactored_code": "  public static final int FRAME_TYPE_UNKNOWN = -1;\n  private boolean drawFrameOrFallback(Canvas canvas, int frameNumber, @FrameType int frameType) {\n    CloseableReference<Bitmap> bitmapReference = null;\n    boolean drawn = false;\n    int nextFrameType = FRAME_TYPE_UNKNOWN;\n\n    try {\n      switch (frameType) {"}
{"magic_number_smell": "  private final ZXPolyModule[] modules;\n  private volatile int currentVideoMode = VIDEOMODE_RESERVED2;\n\n  private Dimension size = new Dimension(512, SCREEN_HEIGHT);\n  private volatile float zoom = 1.0f;\n  private volatile int portFEw = 0;\n", "refactored_code": "  public static final int SCREEN_WIDTH = 512;\n  private final ZXPolyModule[] modules;\n  private volatile int currentVideoMode = VIDEOMODE_RESERVED2;\n\n  private Dimension size = new Dimension(SCREEN_WIDTH, SCREEN_HEIGHT);\n  private volatile float zoom = 1.0f;\n  private volatile int portFEw = 0;\n"}
{"magic_number_smell": "  private static final int 100 = 100;\n\n  private static int safePageSize(final int pageSize) {\n    return 0 < pageSize && pageSize <= 100 ? pageSize : 100;\n  }\n\n  public void allOpenPrev(final String pos, final int pageSize,", "refactored_code": "  private static final int MAX_PER_PAGE = 100;\n  private static final int MAX_PER_PAGE = 100;\n\n  private static int safePageSize(final int pageSize) {\n    return 0 < pageSize && pageSize <= MAX_PER_PAGE ? pageSize : MAX_PER_PAGE;\n  }\n\n  public void allOpenPrev(final String pos, final int pageSize,"}
{"magic_number_smell": "    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);"}
{"magic_number_smell": "    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);"}
{"magic_number_smell": "\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != 0x414E4554) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n", "refactored_code": "    private static final int FILE_MAGIC = 0x414E4554;\n\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != FILE_MAGIC) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n"}
{"magic_number_smell": "            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + AlarmManager.INTERVAL_HOUR;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {", "refactored_code": "    private static final long BACKUP_INTERVAL = AlarmManager.INTERVAL_HOUR;\n            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + BACKUP_INTERVAL;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {"}
{"magic_number_smell": "            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > 50 ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;", "refactored_code": "    private static final int INET_CONDITION_THRESHOLD = 50;\n            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;"}
{"magic_number_smell": "        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+5*1000) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }", "refactored_code": "    private static final long MIN_TIME_BETWEEN_GCS = 5*1000;\n        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+MIN_TIME_BETWEEN_GCS) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }"}
{"magic_number_smell": "\t\t\tLog.d(\"Server\",\"getCapabilities using \" + capabilitiesURL.toString());\n\t\t\tcon = (HttpURLConnection) capabilitiesURL.openConnection();\n\t\t\t//--Start: header not yet send\n\t\t\tcon.setReadTimeout(45 * 1000);\n\t\t\tcon.setConnectTimeout(45 * 1000);\n\t\t\tcon.setRequestProperty(\"User-Agent\", Application.userAgent);\n", "refactored_code": "\tprivate static final int TIMEOUT = 45 * 1000;\n\t\t\tLog.d(\"Server\",\"getCapabilities using \" + capabilitiesURL.toString());\n\t\t\tcon = (HttpURLConnection) capabilitiesURL.openConnection();\n\t\t\t//--Start: header not yet send\n\t\t\tcon.setReadTimeout(TIMEOUT);\n\t\t\tcon.setConnectTimeout(TIMEOUT);\n\t\t\tcon.setRequestProperty(\"User-Agent\", Application.userAgent);\n"}
{"magic_number_smell": "            } else {\r\n                // Set minimum size and adjust after all components have\r\n                // (supposedly) been drawn completely.\r\n                DOM.setStyleAttribute(base, styleAttribute, 50 + \"px\");\r\n                DeferredCommand.addCommand(new Command() {\r\n                    public void execute() {\r\n                        final Element p = DOM.getParent(getElement());\r", "refactored_code": "    private static final int MIN_SIZE = 50;\r\n            } else {\r\n                // Set minimum size and adjust after all components have\r\n                // (supposedly) been drawn completely.\r\n                DOM.setStyleAttribute(base, styleAttribute, MIN_SIZE + \"px\");\r\n                DeferredCommand.addCommand(new Command() {\r\n                    public void execute() {\r\n                        final Element p = DOM.getParent(getElement());\r"}
{"magic_number_smell": "    private final GridMenuItemStyle mStyle;\n    private Array<T> mItems;\n    private final Array<FocusIndicator> mFocusIndicators = new Array<>();\n    private int mSelectedIndex = -1;\n    private int mCurrentIndex = 0;\n    private ItemRenderer<T> mRenderer;\n    private SelectionListener<T> mSelectionListener;", "refactored_code": "    public static final int INVALID_INDEX = -1;\n    private final GridMenuItemStyle mStyle;\n    private Array<T> mItems;\n    private final Array<FocusIndicator> mFocusIndicators = new Array<>();\n    private int mSelectedIndex = INVALID_INDEX;\n    private int mCurrentIndex = 0;\n    private ItemRenderer<T> mRenderer;\n    private SelectionListener<T> mSelectionListener;"}
{"magic_number_smell": "    public static boolean preValidate(String path) throws CTFException {\n        String metadataPath = path + Utils.SEPARATOR + METADATA_FILENAME;\n        File metadataFile = new File(metadataPath);\n        if (metadataFile.exists() && metadataFile.length() > 8) {\n            if (CTFTrace.startsWithMagicNumber(metadataFile, Utils.TSDL_MAGIC) != null) {\n                return true;\n            }", "refactored_code": "    private static final int PREVALIDATION_SIZE = 8;\n    public static boolean preValidate(String path) throws CTFException {\n        String metadataPath = path + Utils.SEPARATOR + METADATA_FILENAME;\n        File metadataFile = new File(metadataPath);\n        if (metadataFile.exists() && metadataFile.length() > PREVALIDATION_SIZE) {\n            if (CTFTrace.startsWithMagicNumber(metadataFile, Utils.TSDL_MAGIC) != null) {\n                return true;\n            }"}
{"magic_number_smell": "        Thread cancellerThread = null;\n\n        try {\n            monitor.beginTask(mainTaskName, 1000);\n\n            ProcessBuilder builder = new ProcessBuilder(command);\n            builder.redirectErrorStream(false);", "refactored_code": "    private static final int PROGRESS_DURATION = 1000;\n        Thread cancellerThread = null;\n\n        try {\n            monitor.beginTask(mainTaskName, PROGRESS_DURATION);\n\n            ProcessBuilder builder = new ProcessBuilder(command);\n            builder.redirectErrorStream(false);"}
{"magic_number_smell": "  }\n\n  private static class BombardComponent extends JPanel {\n    private static final long 5304208569738042592L = -2388895995673156507L;\n    private final JList<Object> list;\n\n    BombardComponent(", "refactored_code": "  private static final long serialVersionUID = 5304208569738042592L;\n  }\n\n  private static class BombardComponent extends JPanel {\n    private static final long serialVersionUID = -2388895995673156507L;\n    private final JList<Object> list;\n\n    BombardComponent("}
{"magic_number_smell": "\n  private final Action selectUnitsAction =\n      new AbstractAction(\"Select Units\") {\n        private static final long -2672163347536778594L = 4745335350716395600L;\n\n        @Override\n        public void actionPerformed(final ActionEvent event) {", "refactored_code": "  private static final long serialVersionUID = -2672163347536778594L;\n\n  private final Action selectUnitsAction =\n      new AbstractAction(\"Select Units\") {\n        private static final long serialVersionUID = 4745335350716395600L;\n\n        @Override\n        public void actionPerformed(final ActionEvent event) {"}
{"magic_number_smell": "\n  private final Action showGameAction =\n      new AbstractAction(\"Show current game\") {\n        private static final long 7640069668264418976L = -7551760679570164254L;\n\n        {\n          setEnabled(false);", "refactored_code": "  private static final long serialVersionUID = 7640069668264418976L;\n\n  private final Action showGameAction =\n      new AbstractAction(\"Show current game\") {\n        private static final long serialVersionUID = -7551760679570164254L;\n\n        {\n          setEnabled(false);"}
{"magic_number_smell": "\t\t// increase the timeout, as otherwise the player often\n\t\t// would use their stake because of reacting too slow.\n\t\t\n\t\tramon.setPlayerChatTimeout(180); \n\n\t\tramon.add(ConversationStates.ATTENDING, \"play\", null,\n\t\t\t\tConversationStates.ATTENDING,", "refactored_code": "\tprivate static final int ONE_MINUTE = 180;\n\t\t// increase the timeout, as otherwise the player often\n\t\t// would use their stake because of reacting too slow.\n\t\t\n\t\tramon.setPlayerChatTimeout(ONE_MINUTE); \n\n\t\tramon.add(ConversationStates.ATTENDING, \"play\", null,\n\t\t\t\tConversationStates.ATTENDING,"}
{"magic_number_smell": "\t}\n\n\tprivate static class LowerCaseLetterDocument extends PlainDocument {\n\t\tprivate static final long 4436228792112530975L = -5123268875802709841L;\n\n\t\t@Override\n\t\tpublic void insertString(final int offs, final String str, final AttributeSet a)", "refactored_code": "\tprivate static final long serialVersionUID = 4436228792112530975L;\n\t}\n\n\tprivate static class LowerCaseLetterDocument extends PlainDocument {\n\t\tprivate static final long serialVersionUID = -5123268875802709841L;\n\n\t\t@Override\n\t\tpublic void insertString(final int offs, final String str, final AttributeSet a)"}
{"magic_number_smell": "\t\t\treturn getInt(\"rate\");\n\t\t}\n\n\t\treturn 5;\n\t}\n\n\t/**", "refactored_code": "\tprivate static final int DEFAULT_ATTACK_RATE = 5;\n\t\t\treturn getInt(\"rate\");\n\t\t}\n\n\t\treturn DEFAULT_ATTACK_RATE;\n\t}\n\n\t/**"}
{"magic_number_smell": "                if (\"\".equalsIgnoreCase(pw)) {\n                    startActivity(new Intent(this, AdminPreferencesActivity.class));\n                } else {\n                    showDialog(1);\n                }\n                return true;\n        }", "refactored_code": "    private static final int PASSWORD_DIALOG = 1;\n                if (\"\".equalsIgnoreCase(pw)) {\n                    startActivity(new Intent(this, AdminPreferencesActivity.class));\n                } else {\n                    showDialog(PASSWORD_DIALOG);\n                }\n                return true;\n        }"}
{"magic_number_smell": "        // For testing:\n        Collect instance = Collect.getInstance();\n        if (instance == null) {\n            return Collect.21;\n        }\n\n        return Integer.parseInt(String.valueOf(GeneralSharedPreferences.getInstance().get(KEY_FONT_SIZE)));", "refactored_code": "    public static final int DEFAULT_FONTSIZE_INT = 21;\n        // For testing:\n        Collect instance = Collect.getInstance();\n        if (instance == null) {\n            return Collect.DEFAULT_FONTSIZE_INT;\n        }\n\n        return Integer.parseInt(String.valueOf(GeneralSharedPreferences.getInstance().get(KEY_FONT_SIZE)));"}
{"magic_number_smell": "        mediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);\n        int rotation = activity.getWindowManager().getDefaultDisplay().getRotation();\n        switch (sensorOrientation) {\n            case 90:\n                mediaRecorder.setOrientationHint(DEFAULT_ORIENTATIONS.get(rotation));\n                break;\n            case SENSOR_ORIENTATION_INVERSE_DEGREES:", "refactored_code": "    private static final int SENSOR_ORIENTATION_DEFAULT_DEGREES = 90;\n        mediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);\n        int rotation = activity.getWindowManager().getDefaultDisplay().getRotation();\n        switch (sensorOrientation) {\n            case SENSOR_ORIENTATION_DEFAULT_DEGREES:\n                mediaRecorder.setOrientationHint(DEFAULT_ORIENTATIONS.get(rotation));\n                break;\n            case SENSOR_ORIENTATION_INVERSE_DEGREES:"}
{"magic_number_smell": "                    ArtilleryAttackAction aaa = (ArtilleryAttackAction) actualFireInfo.buildWeaponAttackAction();\n                    HelperAmmo ammo = findAmmo(shooter, actualFireInfo.getWeapon(), actualFireInfo.getAmmo());\n\n                    if (ammo.equipmentNum > -1) {\n                        //This can happen if princess is towing ammo trailers, which she really shouldn't be doing...\n                        aaa.setAmmoId(ammo.equipmentNum);\n                        aaa.setAmmoMunitionType(ammo.munitionType);", "refactored_code": "    private static final int NO_AMMO = -1;\n                    ArtilleryAttackAction aaa = (ArtilleryAttackAction) actualFireInfo.buildWeaponAttackAction();\n                    HelperAmmo ammo = findAmmo(shooter, actualFireInfo.getWeapon(), actualFireInfo.getAmmo());\n\n                    if (ammo.equipmentNum > NO_AMMO) {\n                        //This can happen if princess is towing ammo trailers, which she really shouldn't be doing...\n                        aaa.setAmmoId(ammo.equipmentNum);\n                        aaa.setAmmoMunitionType(ammo.munitionType);"}
{"magic_number_smell": "    public static final Setting<TimeValue> CACHE_TTL_SETTING = Setting.timeSetting(\"cache.ttl\", DEFAULT_TTL, Setting.Property.NodeScope);\n\n    private static final int 100_000 = 100_000; //100k users\n    public static final Setting<Integer> CACHE_MAX_USERS_SETTING = Setting.intSetting(\"cache.max_users\", 100_000,\n            Setting.Property.NodeScope);\n\n    private final Cache<String, UserWithHash> cache;", "refactored_code": "    private static final int DEFAULT_MAX_USERS = 100_000; //100k users\n    public static final Setting<TimeValue> CACHE_TTL_SETTING = Setting.timeSetting(\"cache.ttl\", DEFAULT_TTL, Setting.Property.NodeScope);\n\n    private static final int DEFAULT_MAX_USERS = 100_000; //100k users\n    public static final Setting<Integer> CACHE_MAX_USERS_SETTING = Setting.intSetting(\"cache.max_users\", DEFAULT_MAX_USERS,\n            Setting.Property.NodeScope);\n\n    private final Cache<String, UserWithHash> cache;"}
{"magic_number_smell": "\t\t\t\t// period is in seconds\n//\t\t\t\tdouble period = timeCache / currentTR * MarsClock.SECONDS_PER_MILLISOL;\n\n\t\t\t\tif (count > 4) {\n//\t\t\t\t\tint speed = getCurrentSpeed();\n//\t\t\t\t\tif (speed == 0)\n//\t\t\t\t\t\tspeed = 1;", "refactored_code": "\tprivate static final int FACTOR = 4;\n\t\t\t\t// period is in seconds\n//\t\t\t\tdouble period = timeCache / currentTR * MarsClock.SECONDS_PER_MILLISOL;\n\n\t\t\t\tif (count > FACTOR) {\n//\t\t\t\t\tint speed = getCurrentSpeed();\n//\t\t\t\t\tif (speed == 0)\n//\t\t\t\t\t\tspeed = 1;"}
{"magic_number_smell": "\t */\n\tpublic void startEarthTimer() {\n\t\t// Set up earth time text update\n\t\ttimeLabeltimer = new Timeline(new KeyFrame(Duration.millis(SettlementWindow.TIME_DELAY), ae -> updateTimeLabels()));\n\t\t// Note: Infinite Timeline might result in a memory leak if not stopped\n\t\t// properly.\n\t\t// All the objects with animated properties would not be garbage collected.", "refactored_code": "\tprivate static final int TIME_DELAY = SettlementWindow.TIME_DELAY;\n\t */\n\tpublic void startEarthTimer() {\n\t\t// Set up earth time text update\n\t\ttimeLabeltimer = new Timeline(new KeyFrame(Duration.millis(TIME_DELAY), ae -> updateTimeLabels()));\n\t\t// Note: Infinite Timeline might result in a memory leak if not stopped\n\t\t// properly.\n\t\t// All the objects with animated properties would not be garbage collected."}
{"magic_number_smell": "\n  /**\n   * the amount of bytes that a stack pointer is allowed\n   * to differ from the stack limit beyond {@link #256}.\n   * <p>\n   * This was set based on the historic values so it's probably\n   * safe to change this if you have appropriate test cases.", "refactored_code": "  private static final int BIG_FRAME_MINIMUM_SIZE = 256;\n\n  /**\n   * the amount of bytes that a stack pointer is allowed\n   * to differ from the stack limit beyond {@link #BIG_FRAME_MINIMUM_SIZE}.\n   * <p>\n   * This was set based on the historic values so it's probably\n   * safe to change this if you have appropriate test cases."}
{"magic_number_smell": "\n    private static class Special implements Serializable {\n        /** default serial version id */\n        private static final long 1L = 1L;\n        private Special() { }\n\n        public static final Special NULL_VALUE = new Special() {", "refactored_code": "    private static final long serialVersionUID = 1L;\n\n    private static class Special implements Serializable {\n        /** default serial version id */\n        private static final long serialVersionUID = 1L;\n        private Special() { }\n\n        public static final Special NULL_VALUE = new Special() {"}
{"magic_number_smell": "  }\n\n  private boolean isLCDActive() {\n    return mmu.readByte(0xFF40) != 0;\n  }\n\n  private TileColor getTileColor(int x, int y) {", "refactored_code": "  private static final int LCD_GPU_CONTROL_ADDRESS = 0xFF40;\n  }\n\n  private boolean isLCDActive() {\n    return mmu.readByte(LCD_GPU_CONTROL_ADDRESS) != 0;\n  }\n\n  private TileColor getTileColor(int x, int y) {"}
{"magic_number_smell": "\n    private Paint paint;\n    private int viewWidth;\n    private int textSize = 20;\n    private int textColorNormal = TEXT_COLOR_NORMAL;\n    private int textColorFocus = TEXT_COLOR_FOCUS;\n    private int lineColor = LINE_COLOR;", "refactored_code": "    public static final int TEXT_SIZE = 20;\n\n    private Paint paint;\n    private int viewWidth;\n    private int textSize = TEXT_SIZE;\n    private int textColorNormal = TEXT_COLOR_NORMAL;\n    private int textColorFocus = TEXT_COLOR_FOCUS;\n    private int lineColor = LINE_COLOR;"}
{"magic_number_smell": "\n    private Paint paint;\n    private int viewWidth;\n    private int textSize = 20;\n    private int textColorNormal = TEXT_COLOR_NORMAL;\n    private int textColorFocus = TEXT_COLOR_FOCUS;\n    private int lineColor = LINE_COLOR;", "refactored_code": "    public static final int TEXT_SIZE = 20;\n\n    private Paint paint;\n    private int viewWidth;\n    private int textSize = TEXT_SIZE;\n    private int textColorNormal = TEXT_COLOR_NORMAL;\n    private int textColorFocus = TEXT_COLOR_FOCUS;\n    private int lineColor = LINE_COLOR;"}
{"magic_number_smell": "\t\t\t\t/*\n\t\t\t\t * \n\t\t\t\t */\n\t\t\t\t((TinyTablesPreproConfiguration) config).setTriplesBatchSize(4096);\n\n\t\t\t\t((TinyTablesPreproConfiguration) config).setTriplesFile(new File(\n\t\t\t\t\t\t\"triples_\" + playerId));", "refactored_code": "\tprivate static final int TRIPLES_BATCH_SIZE = 4096;\n\t\t\t\t/*\n\t\t\t\t * \n\t\t\t\t */\n\t\t\t\t((TinyTablesPreproConfiguration) config).setTriplesBatchSize(TRIPLES_BATCH_SIZE);\n\n\t\t\t\t((TinyTablesPreproConfiguration) config).setTriplesFile(new File(\n\t\t\t\t\t\t\"triples_\" + playerId));"}
{"magic_number_smell": "        throw new MPCException(\"Retriever got interrupted\", e1);\n      } catch (ClientProtocolException e) {\n        logger.warn(\"Retriever could not reach client. Exception message: \" + e.getMessage()\n            + \". Waiting for a \" + 1000 + \"ms before trying again.\");\n        try {\n          Thread.sleep(1000);\n          semaphore.release();", "refactored_code": "  private static final int waitTimeInMs = 1000;\n        throw new MPCException(\"Retriever got interrupted\", e1);\n      } catch (ClientProtocolException e) {\n        logger.warn(\"Retriever could not reach client. Exception message: \" + e.getMessage()\n            + \". Waiting for a \" + waitTimeInMs + \"ms before trying again.\");\n        try {\n          Thread.sleep(waitTimeInMs);\n          semaphore.release();"}
{"magic_number_smell": "    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);"}
{"magic_number_smell": "    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);"}
{"magic_number_smell": "\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != 0x414E4554) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n", "refactored_code": "    private static final int FILE_MAGIC = 0x414E4554;\n\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != FILE_MAGIC) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n"}
{"magic_number_smell": "            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + AlarmManager.INTERVAL_HOUR;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {", "refactored_code": "    private static final long BACKUP_INTERVAL = AlarmManager.INTERVAL_HOUR;\n            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + BACKUP_INTERVAL;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {"}
{"magic_number_smell": "            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > 50 ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;", "refactored_code": "    private static final int INET_CONDITION_THRESHOLD = 50;\n            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;"}
{"magic_number_smell": "        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+5*1000) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }", "refactored_code": "    private static final long MIN_TIME_BETWEEN_GCS = 5*1000;\n        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+MIN_TIME_BETWEEN_GCS) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }"}
{"magic_number_smell": "\n        for (PixelOffset px : pixels) {\n            float d = getDepth(px.offset);\n            if (d != -1) {\n\n//                Vec3D pKinect = calibIR.pixelToWorld(px.x, px.y, d);\n//                depthData.depthPoints[px.offset] = pKinect;", "refactored_code": "    protected static final float INVALID_DEPTH = -1;\n\n        for (PixelOffset px : pixels) {\n            float d = getDepth(px.offset);\n            if (d != INVALID_DEPTH) {\n\n//                Vec3D pKinect = calibIR.pixelToWorld(px.x, px.y, d);\n//                depthData.depthPoints[px.offset] = pKinect;"}
{"magic_number_smell": "        inflater.inflate(R.menu.menu_sort_artists, menu);\n        inflater.inflate(R.menu.menu_view_as, menu);\n\n        menu.addSubMenu(0, 100, 0, R.string.menu_grid_size);\n        SubMenu subMenu = menu.findItem(100).getSubMenu();\n\n        int[] spanCountArray = getResources().getIntArray(R.array.span_count);", "refactored_code": "    private static final int MENU_GRID_SIZE = 100;\n        inflater.inflate(R.menu.menu_sort_artists, menu);\n        inflater.inflate(R.menu.menu_view_as, menu);\n\n        menu.addSubMenu(0, MENU_GRID_SIZE, 0, R.string.menu_grid_size);\n        SubMenu subMenu = menu.findItem(MENU_GRID_SIZE).getSubMenu();\n\n        int[] spanCountArray = getResources().getIntArray(R.array.span_count);"}
{"magic_number_smell": "        inflater.inflate(R.menu.menu_sort_albums, menu);\n        inflater.inflate(R.menu.menu_view_as, menu);\n\n        menu.addSubMenu(0, 100, 0, R.string.menu_grid_size);\n        SubMenu subMenu = menu.findItem(100).getSubMenu();\n\n        int[] spanCountArray = getResources().getIntArray(R.array.span_count);", "refactored_code": "    private static final int MENU_GRID_SIZE = 100;\n        inflater.inflate(R.menu.menu_sort_albums, menu);\n        inflater.inflate(R.menu.menu_view_as, menu);\n\n        menu.addSubMenu(0, MENU_GRID_SIZE, 0, R.string.menu_grid_size);\n        SubMenu subMenu = menu.findItem(MENU_GRID_SIZE).getSubMenu();\n\n        int[] spanCountArray = getResources().getIntArray(R.array.span_count);"}
{"magic_number_smell": "            throw new SubMerchantOnboardingInvalidSmsVerificationCode(\"SMS verification code can not be empty or null\");\n        }\n\n        if (StringUtils.length(verificationCode) != 6) {\n            throw new SubMerchantOnboardingInvalidSmsVerificationCode(\n                    String.format(\"SMS verification code should be %d characters long\", 6)\n            );", "refactored_code": "    private static final int VERIFICATION_CODE_LENGTH = 6;\n            throw new SubMerchantOnboardingInvalidSmsVerificationCode(\"SMS verification code can not be empty or null\");\n        }\n\n        if (StringUtils.length(verificationCode) != VERIFICATION_CODE_LENGTH) {\n            throw new SubMerchantOnboardingInvalidSmsVerificationCode(\n                    String.format(\"SMS verification code should be %d characters long\", VERIFICATION_CODE_LENGTH)\n            );"}
{"magic_number_smell": "            }\n            if (event.getSource() == pt.getSelectionModel() && pt.getRowSelectionAllowed()) {\n                final int selectedRows = pt.getSelectedRowCount();\n                if (selectedRows >= 2) {\n                    PokemonGoMainWindow.window.setTitle(selectedRows + \" Pok\u00e9mon selected\");\n                } else {\n                    PokemonGoMainWindow.window.refreshTitle();", "refactored_code": "    private static final int WHEN_TO_SHOW_SELECTION_TITLE = 2;\n            }\n            if (event.getSource() == pt.getSelectionModel() && pt.getRowSelectionAllowed()) {\n                final int selectedRows = pt.getSelectedRowCount();\n                if (selectedRows >= WHEN_TO_SHOW_SELECTION_TITLE) {\n                    PokemonGoMainWindow.window.setTitle(selectedRows + \" Pok\u00e9mon selected\");\n                } else {\n                    PokemonGoMainWindow.window.refreshTitle();"}
{"magic_number_smell": "        byte[] extensionBytes = ArrayConverter.concatenate(extension.getExtensionType().getValue(), ArrayConverter\n                .intToBytes(extension.getExtensionLength().getValue(), ExtensionByteLength.EXTENSIONS), ArrayConverter\n                .intToBytes(extension.getSignatureAndHashAlgorithmsLength().getValue(),\n                        2), extension.getSignatureAndHashAlgorithms().getValue());\n\n        extension.setExtensionBytes(extensionBytes);\n    }", "refactored_code": "    public static final int SIGNATURE_AND_HASH_ALGORITHMS_LENGTH = 2;\n        byte[] extensionBytes = ArrayConverter.concatenate(extension.getExtensionType().getValue(), ArrayConverter\n                .intToBytes(extension.getExtensionLength().getValue(), ExtensionByteLength.EXTENSIONS), ArrayConverter\n                .intToBytes(extension.getSignatureAndHashAlgorithmsLength().getValue(),\n                        SIGNATURE_AND_HASH_ALGORITHMS_LENGTH), extension.getSignatureAndHashAlgorithms().getValue());\n\n        extension.setExtensionBytes(extensionBytes);\n    }"}
{"magic_number_smell": "    private static final String BASE56_DECODE = \"23456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz\";\n    private static final int 56 = 56;\n    private static final int CHARS_PER_LINE = 19;\n    private static final BigInteger BASE = BigInteger.valueOf(56);\n\n    public static byte[] combine(byte[] a, byte b) {\n        return combine(a, new byte[] {b});", "refactored_code": "    private static final int BASE_INT = 56;\n    private static final String BASE56_DECODE = \"23456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz\";\n    private static final int BASE_INT = 56;\n    private static final int CHARS_PER_LINE = 19;\n    private static final BigInteger BASE = BigInteger.valueOf(BASE_INT);\n\n    public static byte[] combine(byte[] a, byte b) {\n        return combine(a, new byte[] {b});"}
{"magic_number_smell": "        final long initialDelayMs = 0;\n        final boolean isDaemon = true;\n        Timer timer = new Timer(\"EventDispatchThreadHangMonitor\", isDaemon);\n        timer.schedule(new HangChecker(), initialDelayMs, 100);\n    }\n    \n    private class HangChecker extends TimerTask {", "refactored_code": "    private static final long CHECK_INTERVAL_MS = 100;\n        final long initialDelayMs = 0;\n        final boolean isDaemon = true;\n        Timer timer = new Timer(\"EventDispatchThreadHangMonitor\", isDaemon);\n        timer.schedule(new HangChecker(), initialDelayMs, CHECK_INTERVAL_MS);\n    }\n    \n    private class HangChecker extends TimerTask {"}
{"magic_number_smell": "  public Single<Optional<java.io.File>> getDriveFileAsJavaFile(String fileId, java.io.File downloadLocationFile) {\n    try (InputStream is = driveService.files().get(fileId).setFields(\"*\").executeMediaAsInputStream()) {\n      try (FileOutputStream fileOutputStream = new FileOutputStream(downloadLocationFile)) {\n        byte[] buffer = new byte[8192];\n        int read;\n        while ((read = is.read(buffer)) != -1) {\n          fileOutputStream.write(buffer, 0, read);", "refactored_code": "  private static final int BYTE_BUFFER_SIZE = 8192;\n  public Single<Optional<java.io.File>> getDriveFileAsJavaFile(String fileId, java.io.File downloadLocationFile) {\n    try (InputStream is = driveService.files().get(fileId).setFields(\"*\").executeMediaAsInputStream()) {\n      try (FileOutputStream fileOutputStream = new FileOutputStream(downloadLocationFile)) {\n        byte[] buffer = new byte[BYTE_BUFFER_SIZE];\n        int read;\n        while ((read = is.read(buffer)) != -1) {\n          fileOutputStream.write(buffer, 0, read);"}
{"magic_number_smell": "    private static final String TEMPORARY_DIRECTORY_STRING = System\n            .getProperty(PROPERTY_LOCAL_TEMPORARY_DIRECTORY);\n    private static final int 5 = 5;\n    private static final Retry RETRY = new Retry(5, Duration.ONE_SECOND)\n            .withQuadratic(true);\n\n    private final String namespace;", "refactored_code": "    private static final int RETRY_NUMBER = 5;\n    private static final String TEMPORARY_DIRECTORY_STRING = System\n            .getProperty(PROPERTY_LOCAL_TEMPORARY_DIRECTORY);\n    private static final int RETRY_NUMBER = 5;\n    private static final Retry RETRY = new Retry(RETRY_NUMBER, Duration.ONE_SECOND)\n            .withQuadratic(true);\n\n    private final String namespace;"}
{"magic_number_smell": "          throw new ParserException(\"X-TIMESTAMP-MAP doesn't contain media timestamp: \" + line);\n        } else {\n          mediaTimestampUs = (Long.parseLong(timestampMatcher.group().substring(7)) * 1000)\n              / 90 + mediaTimestampOffsetUs;\n        }\n        mediaTimestampUs = getAdjustedStartTime(mediaTimestampUs);\n      }", "refactored_code": "  private static final long SAMPLING_RATE = 90;\n          throw new ParserException(\"X-TIMESTAMP-MAP doesn't contain media timestamp: \" + line);\n        } else {\n          mediaTimestampUs = (Long.parseLong(timestampMatcher.group().substring(7)) * 1000)\n              / SAMPLING_RATE + mediaTimestampOffsetUs;\n        }\n        mediaTimestampUs = getAdjustedStartTime(mediaTimestampUs);\n      }"}
{"magic_number_smell": "  public int maximize(Formula objective) {\n    int id = idGenerator.getFreshId();\n    objectiveMap = objectiveMap.putAndCopy(id, objectiveMap.size());\n    long objectiveId = msat_make_maximize(curEnv, getMsatTerm(objective), 0, 0);\n    msat_assert_objective(curEnv, objectiveId);\n    return id;\n  }", "refactored_code": "  private static final int ERROR_TERM = 0;\n  public int maximize(Formula objective) {\n    int id = idGenerator.getFreshId();\n    objectiveMap = objectiveMap.putAndCopy(id, objectiveMap.size());\n    long objectiveId = msat_make_maximize(curEnv, getMsatTerm(objective), ERROR_TERM, ERROR_TERM);\n    msat_assert_objective(curEnv, objectiveId);\n    return id;\n  }"}
{"magic_number_smell": "\n    static public final String BASE_CRYPTO = Crypto.XMR.getSymbol();\n    static public final int 12 = 12;\n    static public final long ONE_XMR = Math.round(Math.pow(10, Helper.12));\n\n    static public final boolean SHOW_EXCHANGERATES = true;\n    static public final boolean ALLOW_SHIFT = true;", "refactored_code": "    static public final int XMR_DECIMALS = 12;\n\n    static public final String BASE_CRYPTO = Crypto.XMR.getSymbol();\n    static public final int XMR_DECIMALS = 12;\n    static public final long ONE_XMR = Math.round(Math.pow(10, Helper.XMR_DECIMALS));\n\n    static public final boolean SHOW_EXCHANGERATES = true;\n    static public final boolean ALLOW_SHIFT = true;"}
{"magic_number_smell": "\n    static public final String BASE_CRYPTO = Crypto.XMR.getSymbol();\n    static public final int 12 = 12;\n    static public final long ONE_XMR = Math.round(Math.pow(10, Helper.12));\n\n    static public final boolean SHOW_EXCHANGERATES = true;\n    static public final boolean ALLOW_SHIFT = true;", "refactored_code": "    static public final int XMR_DECIMALS = 12;\n\n    static public final String BASE_CRYPTO = Crypto.XMR.getSymbol();\n    static public final int XMR_DECIMALS = 12;\n    static public final long ONE_XMR = Math.round(Math.pow(10, Helper.XMR_DECIMALS));\n\n    static public final boolean SHOW_EXCHANGERATES = true;\n    static public final boolean ALLOW_SHIFT = true;"}
{"magic_number_smell": "                         KubernetesGCPServiceAccountSecretManager serviceAccountSecretManager,\n                         Debug debug, String styxEnvironment) {\n    this(client, stateManager, stats, serviceAccountSecretManager, debug, styxEnvironment,\n        60, DEFAULT_POD_DELETION_DELAY_SECONDS, DEFAULT_TIME,\n        Executors.newSingleThreadScheduledExecutor(THREAD_FACTORY));\n  }\n", "refactored_code": "  private static final int DEFAULT_POLL_PODS_INTERVAL_SECONDS = 60;\n                         KubernetesGCPServiceAccountSecretManager serviceAccountSecretManager,\n                         Debug debug, String styxEnvironment) {\n    this(client, stateManager, stats, serviceAccountSecretManager, debug, styxEnvironment,\n        DEFAULT_POLL_PODS_INTERVAL_SECONDS, DEFAULT_POD_DELETION_DELAY_SECONDS, DEFAULT_TIME,\n        Executors.newSingleThreadScheduledExecutor(THREAD_FACTORY));\n  }\n"}
{"magic_number_smell": "                         KubernetesGCPServiceAccountSecretManager serviceAccountSecretManager,\n                         Debug debug, String styxEnvironment) {\n    this(client, stateManager, stats, serviceAccountSecretManager, debug, styxEnvironment,\n        60, DEFAULT_POD_DELETION_DELAY_SECONDS, DEFAULT_TIME,\n        Executors.newSingleThreadScheduledExecutor(THREAD_FACTORY));\n  }\n", "refactored_code": "  private static final int DEFAULT_POLL_PODS_INTERVAL_SECONDS = 60;\n                         KubernetesGCPServiceAccountSecretManager serviceAccountSecretManager,\n                         Debug debug, String styxEnvironment) {\n    this(client, stateManager, stats, serviceAccountSecretManager, debug, styxEnvironment,\n        DEFAULT_POLL_PODS_INTERVAL_SECONDS, DEFAULT_POD_DELETION_DELAY_SECONDS, DEFAULT_TIME,\n        Executors.newSingleThreadScheduledExecutor(THREAD_FACTORY));\n  }\n"}
{"magic_number_smell": "    private JPanel changingPanel;\n    private JPanel manuPanel;\n    private JPanel autoPanel;\n    private int maxXPos = -10;\n    private int maxPort;\n    private int portCnt;\n    private int anonCnt;", "refactored_code": "    private static final int X_OFFSET = 10;\n    private JPanel changingPanel;\n    private JPanel manuPanel;\n    private JPanel autoPanel;\n    private int maxXPos = -X_OFFSET;\n    private int maxPort;\n    private int portCnt;\n    private int anonCnt;"}
{"magic_number_smell": "            forceValidityCheck(removes);\n            removes.clear();\n            try {\n\t\tThread.sleep(3 * 1000);\n\t    } catch (InterruptedException ignore) {\n                LOG.error(\"InterruptedException!!!\", ignore);\n            }", "refactored_code": "    private static final int SLEEP_SECONDS = 3;\n            forceValidityCheck(removes);\n            removes.clear();\n            try {\n\t\tThread.sleep(SLEEP_SECONDS * 1000);\n\t    } catch (InterruptedException ignore) {\n                LOG.error(\"InterruptedException!!!\", ignore);\n            }"}
{"magic_number_smell": "                            }\r\n                        }\r\n                    }\r\n                }, 1200, 1200);\r\n                if (verbose)\r\n                {\r\n                    getLogger().log(Level.INFO, \"Scheduled the XRay checker.\");\r", "refactored_code": "    private static final long XRAY_TIME = 1200;\r\n                            }\r\n                        }\r\n                    }\r\n                }, XRAY_TIME, XRAY_TIME);\r\n                if (verbose)\r\n                {\r\n                    getLogger().log(Level.INFO, \"Scheduled the XRay checker.\");\r"}
{"magic_number_smell": "    {\n        int format = 0;\n\n        byte[] magic = new byte[8];\n\n        // If this is not an HDF5 file, then the magic number is at\n        // position 0; If it is an HDF5 file, then we need to search", "refactored_code": "    static private final int MAGIC_NUMBER_LEN = 8;\n    {\n        int format = 0;\n\n        byte[] magic = new byte[MAGIC_NUMBER_LEN];\n\n        // If this is not an HDF5 file, then the magic number is at\n        // position 0; If it is an HDF5 file, then we need to search"}
{"magic_number_smell": "        //Constants used in AbstractCard for scale formatting\n        private static final float 300.0F * Settings.scale = 300.0F * Settings.scale;\n        //Multipliers are slightly fudged to be more forgiving to longer names\n        private static final float TITLE_BOX_WIDTH = 300.0F * Settings.scale * 0.7F; //Was 0.6F\n        private static final float TITLE_BOX_WIDTH_NO_COST = 300.0F * Settings.scale * 0.8F; //Was 0.7F\n        private static final GlyphLayout gl = new GlyphLayout();\n", "refactored_code": "        private static final float IMG_WIDTH = 300.0F * Settings.scale;\n        //Constants used in AbstractCard for scale formatting\n        private static final float IMG_WIDTH = 300.0F * Settings.scale;\n        //Multipliers are slightly fudged to be more forgiving to longer names\n        private static final float TITLE_BOX_WIDTH = IMG_WIDTH * 0.7F; //Was 0.6F\n        private static final float TITLE_BOX_WIDTH_NO_COST = IMG_WIDTH * 0.8F; //Was 0.7F\n        private static final GlyphLayout gl = new GlyphLayout();\n"}
{"magic_number_smell": "        //Constants used in AbstractCard for scale formatting\n        private static final float 300.0F * Settings.scale = 300.0F * Settings.scale;\n        //Multipliers are slightly fudged to be more forgiving to longer names\n        private static final float TITLE_BOX_WIDTH = 300.0F * Settings.scale * 0.7F; //Was 0.6F\n        private static final float TITLE_BOX_WIDTH_NO_COST = 300.0F * Settings.scale * 0.8F; //Was 0.7F\n        private static final GlyphLayout gl = new GlyphLayout();\n", "refactored_code": "        private static final float IMG_WIDTH = 300.0F * Settings.scale;\n        //Constants used in AbstractCard for scale formatting\n        private static final float IMG_WIDTH = 300.0F * Settings.scale;\n        //Multipliers are slightly fudged to be more forgiving to longer names\n        private static final float TITLE_BOX_WIDTH = IMG_WIDTH * 0.7F; //Was 0.6F\n        private static final float TITLE_BOX_WIDTH_NO_COST = IMG_WIDTH * 0.8F; //Was 0.7F\n        private static final GlyphLayout gl = new GlyphLayout();\n"}
{"magic_number_smell": "          float cp1Radius = longSegment ? innerRadius : outerRadius;\n          float cp2Radius = longSegment ? outerRadius : innerRadius;\n\n          float cp1x = cp1Radius * cp1Roundedness * .47829f * cp1Dx;\n          float cp1y = cp1Radius * cp1Roundedness * .47829f * cp1Dy;\n          float cp2x = cp2Radius * cp2Roundedness * .47829f * cp2Dx;\n          float cp2y = cp2Radius * cp2Roundedness * .47829f * cp2Dy;", "refactored_code": "    private static final float POLYSTAR_MAGIC_NUMBER = .47829f;\n          float cp1Radius = longSegment ? innerRadius : outerRadius;\n          float cp2Radius = longSegment ? outerRadius : innerRadius;\n\n          float cp1x = cp1Radius * cp1Roundedness * POLYSTAR_MAGIC_NUMBER * cp1Dx;\n          float cp1y = cp1Radius * cp1Roundedness * POLYSTAR_MAGIC_NUMBER * cp1Dy;\n          float cp2x = cp2Radius * cp2Roundedness * POLYSTAR_MAGIC_NUMBER * cp2Dx;\n          float cp2y = cp2Radius * cp2Roundedness * POLYSTAR_MAGIC_NUMBER * cp2Dy;"}
{"magic_number_smell": "\tprotected Feeling feeling = Feeling.UNDEFINED;\n\n\tpublic int entrance;\n\tpublic int compassTarget = -1;\t// Where compass should point\n\n\tprivate HashMap<Integer, Integer> exitMap = new HashMap<>();\n", "refactored_code": "\tprivate static final int INVALID_CELL = -1;\n\tprotected Feeling feeling = Feeling.UNDEFINED;\n\n\tpublic int entrance;\n\tpublic int compassTarget = INVALID_CELL;\t// Where compass should point\n\n\tprivate HashMap<Integer, Integer> exitMap = new HashMap<>();\n"}
{"magic_number_smell": "\t\tadd(title);\n\n\t\tbuttonX = left;\n\t\tbuttonY = bottom - 24;\n\n\t\tbtnNewGame = new GameButton(TXT_NEW) {\n\t\t\t@Override", "refactored_code": "\tprivate static final float BUTTON_HEIGHT = 24;\n\t\tadd(title);\n\n\t\tbuttonX = left;\n\t\tbuttonY = bottom - BUTTON_HEIGHT;\n\n\t\tbtnNewGame = new GameButton(TXT_NEW) {\n\t\t\t@Override"}
{"magic_number_smell": "    private final ScheduledExecutorService scheduledExecutorService;\n\n    public JsonRpc2_0Neow3j(Neow3jService neow3jService) {\n        this(neow3jService, 15 * 1000, Async.defaultExecutorService());\n    }\n\n    public JsonRpc2_0Neow3j(", "refactored_code": "    public static final int DEFAULT_BLOCK_TIME = 15 * 1000;\n    private final ScheduledExecutorService scheduledExecutorService;\n\n    public JsonRpc2_0Neow3j(Neow3jService neow3jService) {\n        this(neow3jService, DEFAULT_BLOCK_TIME, Async.defaultExecutorService());\n    }\n\n    public JsonRpc2_0Neow3j("}
{"magic_number_smell": "        assertThat(transfer.getAssetHash(), is(\"0x\" + NEO_HASH));\n        assertThat(transfer.getTransferAddress(), is(TX_RECIPIENT_1));\n        assertThat(transfer.getAmount(), is(TX_AMOUNT_NEO));\n        assertThat(transfer.getBlockIndex(), is(2L));\n        assertThat(transfer.getTransferNotifyIndex(), is(1L));\n\n        assertNotNull(nep17TransferWrapper.getReceived());", "refactored_code": "    private static final long TX_BLOCK_IDX = 2L;\n        assertThat(transfer.getAssetHash(), is(\"0x\" + NEO_HASH));\n        assertThat(transfer.getTransferAddress(), is(TX_RECIPIENT_1));\n        assertThat(transfer.getAmount(), is(TX_AMOUNT_NEO));\n        assertThat(transfer.getBlockIndex(), is(TX_BLOCK_IDX));\n        assertThat(transfer.getTransferNotifyIndex(), is(1L));\n\n        assertNotNull(nep17TransferWrapper.getReceived());"}
{"magic_number_smell": "        assertThat(transfer.getAssetHash(), is(\"0x\" + NEO_HASH));\n        assertThat(transfer.getTransferAddress(), is(TX_RECIPIENT_1));\n        assertThat(transfer.getAmount(), is(TX_AMOUNT_NEO));\n        assertThat(transfer.getBlockIndex(), is(2L));\n        assertThat(transfer.getTransferNotifyIndex(), is(1L));\n\n        assertNotNull(nep17TransferWrapper.getReceived());", "refactored_code": "    private static final long TX_BLOCK_IDX = 2L;\n        assertThat(transfer.getAssetHash(), is(\"0x\" + NEO_HASH));\n        assertThat(transfer.getTransferAddress(), is(TX_RECIPIENT_1));\n        assertThat(transfer.getAmount(), is(TX_AMOUNT_NEO));\n        assertThat(transfer.getBlockIndex(), is(TX_BLOCK_IDX));\n        assertThat(transfer.getTransferNotifyIndex(), is(1L));\n\n        assertNotNull(nep17TransferWrapper.getReceived());"}
{"magic_number_smell": "\n    private static byte addressVersion = DEFAULT_ADDRESS_VERSION;\n    private Long networkMagic = null;\n    private int blockInterval = 15 * 1000;\n    private long maxValidUntilBlockIncrement = MAX_VALID_UNTIL_BLOCK_INCREMENT_BASE / blockInterval;\n    private int pollingInterval = 15 * 1000;\n    private ScheduledExecutorService scheduledExecutorService = Async.defaultExecutorService();", "refactored_code": "    public static final int DEFAULT_BLOCK_TIME = 15 * 1000;\n\n    private static byte addressVersion = DEFAULT_ADDRESS_VERSION;\n    private Long networkMagic = null;\n    private int blockInterval = DEFAULT_BLOCK_TIME;\n    private long maxValidUntilBlockIncrement = MAX_VALID_UNTIL_BLOCK_INCREMENT_BASE / blockInterval;\n    private int pollingInterval = DEFAULT_BLOCK_TIME;\n    private ScheduledExecutorService scheduledExecutorService = Async.defaultExecutorService();"}
{"magic_number_smell": "    private final ScheduledExecutorService scheduledExecutorService;\n\n    public JsonRpc2_0Neow3j(Neow3jService neow3jService) {\n        this(neow3jService, 15 * 1000, Async.defaultExecutorService());\n    }\n\n    public JsonRpc2_0Neow3j(", "refactored_code": "    public static final int DEFAULT_BLOCK_TIME = 15 * 1000;\n    private final ScheduledExecutorService scheduledExecutorService;\n\n    public JsonRpc2_0Neow3j(Neow3jService neow3jService) {\n        this(neow3jService, DEFAULT_BLOCK_TIME, Async.defaultExecutorService());\n    }\n\n    public JsonRpc2_0Neow3j("}
{"magic_number_smell": "\t\tfinal boolean vibrate = preferences.getBoolean(\"vibrate_on_notification\", true);\n\n\t\tif (notifications.size() == 0) {\n\t\t\tnotificationManager.cancel(0x2342);\n\t\t} else {\n\t\t\tif (notify) {\n\t\t\t\tthis.markLastNotification();", "refactored_code": "\tpublic static final int NOTIFICATION_ID = 0x2342;\n\t\tfinal boolean vibrate = preferences.getBoolean(\"vibrate_on_notification\", true);\n\n\t\tif (notifications.size() == 0) {\n\t\t\tnotificationManager.cancel(NOTIFICATION_ID);\n\t\t} else {\n\t\t\tif (notify) {\n\t\t\t\tthis.markLastNotification();"}
{"magic_number_smell": "\t\tfinal boolean vibrate = preferences.getBoolean(\"vibrate_on_notification\", true);\n\n\t\tif (notifications.size() == 0) {\n\t\t\tnotificationManager.cancel(0x2342);\n\t\t} else {\n\t\t\tif (notify) {\n\t\t\t\tthis.markLastNotification();", "refactored_code": "\tpublic static final int NOTIFICATION_ID = 0x2342;\n\t\tfinal boolean vibrate = preferences.getBoolean(\"vibrate_on_notification\", true);\n\n\t\tif (notifications.size() == 0) {\n\t\t\tnotificationManager.cancel(NOTIFICATION_ID);\n\t\t} else {\n\t\t\tif (notify) {\n\t\t\t\tthis.markLastNotification();"}
{"magic_number_smell": "\n    public HollowProducer(Publisher publisher,\n                          Announcer announcer) {\n        this(new HollowFilesystemBlobStager(), publisher, announcer, Collections.<Validator>emptyList(), Collections.<HollowProducerListener>emptyList(), Collections.<HollowValidationListener>emptyList(), new VersionMinterWithCounter(), null, 0, 16L * 1024L * 1024L, null, new DummyBlobStorageCleaner(), new BasicSingleProducerEnforcer());\n    }\n\n    public HollowProducer(Publisher publisher,", "refactored_code": "    private static final long DEFAULT_TARGET_MAX_TYPE_SHARD_SIZE = 16L * 1024L * 1024L;\n\n    public HollowProducer(Publisher publisher,\n                          Announcer announcer) {\n        this(new HollowFilesystemBlobStager(), publisher, announcer, Collections.<Validator>emptyList(), Collections.<HollowProducerListener>emptyList(), Collections.<HollowValidationListener>emptyList(), new VersionMinterWithCounter(), null, 0, DEFAULT_TARGET_MAX_TYPE_SHARD_SIZE, null, new DummyBlobStorageCleaner(), new BasicSingleProducerEnforcer());\n    }\n\n    public HollowProducer(Publisher publisher,"}
{"magic_number_smell": "\t\t\t\t\t\t.color(0.5F, 0.5F, 0.5F, 1F)\n\t\t\t\t\t\t.endVertex();\n\t\t\t\tbuffer.pos(width, 24F, 0F)\n\t\t\t\t\t\t.tex(width / 32.0F, 0.75F)\n\t\t\t\t\t\t.color(0.5F, 0.5F, 0.5F, 1F)\n\t\t\t\t\t\t.endVertex();\n\t\t\t\tbuffer.pos(width, 8F, 0F)", "refactored_code": "\tprivate static final float backgroundScale = 32.0F;\n\t\t\t\t\t\t.color(0.5F, 0.5F, 0.5F, 1F)\n\t\t\t\t\t\t.endVertex();\n\t\t\t\tbuffer.pos(width, 24F, 0F)\n\t\t\t\t\t\t.tex(width / backgroundScale, 0.75F)\n\t\t\t\t\t\t.color(0.5F, 0.5F, 0.5F, 1F)\n\t\t\t\t\t\t.endVertex();\n\t\t\t\tbuffer.pos(width, 8F, 0F)"}
{"magic_number_smell": "        byte[] tempBytes = getX509Certificate()\n                .getExtensionValue(SUBJECT_KEY_IDENTIFIER_EXTENSION);\n\n        if (tempBytes.length > 20) {\n            this.subjectKeyIdentifier = truncatePrefixBytes(tempBytes);\n        } else {\n            this.subjectKeyIdentifier =", "refactored_code": "    private static final int CA_BYTE_SIZE = 20;\n        byte[] tempBytes = getX509Certificate()\n                .getExtensionValue(SUBJECT_KEY_IDENTIFIER_EXTENSION);\n\n        if (tempBytes.length > CA_BYTE_SIZE) {\n            this.subjectKeyIdentifier = truncatePrefixBytes(tempBytes);\n        } else {\n            this.subjectKeyIdentifier ="}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "\n    @Getter\n    private static NounListNameGenerator instance = new NounListNameGenerator();\n    private List<String> nouns = new ArrayList<>(6801);\n\n    @SneakyThrows\n    private NounListNameGenerator() {", "refactored_code": "    private static final int NOUN_LIST_LENGTH = 6801;\n\n    @Getter\n    private static NounListNameGenerator instance = new NounListNameGenerator();\n    private List<String> nouns = new ArrayList<>(NOUN_LIST_LENGTH);\n\n    @SneakyThrows\n    private NounListNameGenerator() {"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "        glfwSetScrollCallback(context.getWindowHandle(), scrollCallback = new GLFWScrollCallback() {\n            @Override\n            public void invoke(final long window, final double xOffset, final double yOffset) {\n                onWheelScroll(window, xOffset, yOffset * 120);\n            }\n        });\n", "refactored_code": "    private static final int WHEEL_SCALE = 120;\n        glfwSetScrollCallback(context.getWindowHandle(), scrollCallback = new GLFWScrollCallback() {\n            @Override\n            public void invoke(final long window, final double xOffset, final double yOffset) {\n                onWheelScroll(window, xOffset, yOffset * WHEEL_SCALE);\n            }\n        });\n"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);"}
{"magic_number_smell": "    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);"}
{"magic_number_smell": "\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != 0x414E4554) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n", "refactored_code": "    private static final int FILE_MAGIC = 0x414E4554;\n\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != FILE_MAGIC) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n"}
{"magic_number_smell": "            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + AlarmManager.INTERVAL_HOUR;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {", "refactored_code": "    private static final long BACKUP_INTERVAL = AlarmManager.INTERVAL_HOUR;\n            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + BACKUP_INTERVAL;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {"}
{"magic_number_smell": "            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > 50 ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;", "refactored_code": "    private static final int INET_CONDITION_THRESHOLD = 50;\n            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;"}
{"magic_number_smell": "        }\n\n        long getDefaultDisplayDelayTimeout() {\n            return 10000;\n        }\n    }\n", "refactored_code": "    private static final long WAIT_FOR_DEFAULT_DISPLAY_TIMEOUT = 10000;\n        }\n\n        long getDefaultDisplayDelayTimeout() {\n            return WAIT_FOR_DEFAULT_DISPLAY_TIMEOUT;\n        }\n    }\n"}
{"magic_number_smell": "    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #-1}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode", "refactored_code": "    public static final int INFINITE = -1;\n    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #INFINITE}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode"}
{"magic_number_smell": "        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+5*1000) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }", "refactored_code": "    private static final long MIN_TIME_BETWEEN_GCS = 5*1000;\n        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+MIN_TIME_BETWEEN_GCS) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }"}
{"magic_number_smell": "\n            outputStream.finish();\n            long takeTime = System.currentTimeMillis() - start;\n            if (takeTime > 50) {\n                LOGGER.info(\"Compressing takes {}ms\", takeTime);\n            }\n            return byteArrayOutputStream.toByteArray();", "refactored_code": "    private static final long MINIMUM_TAKE_TIME_MILLISECOND = 50;\n\n            outputStream.finish();\n            long takeTime = System.currentTimeMillis() - start;\n            if (takeTime > MINIMUM_TAKE_TIME_MILLISECOND) {\n                LOGGER.info(\"Compressing takes {}ms\", takeTime);\n            }\n            return byteArrayOutputStream.toByteArray();"}
{"magic_number_smell": "        boolean createNew = false;\n\n        try {\n            if (this.lockTopicConfigTable.tryLock(3000, TimeUnit.MILLISECONDS)) {\n                try {\n                    topicConfig = this.topicConfigTable.get(topic);\n                    if (topicConfig != null)", "refactored_code": "    private static final long LOCK_TIMEOUT_MILLIS = 3000;\n        boolean createNew = false;\n\n        try {\n            if (this.lockTopicConfigTable.tryLock(LOCK_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)) {\n                try {\n                    topicConfig = this.topicConfigTable.get(topic);\n                    if (topicConfig != null)"}
{"magic_number_smell": "    private GetResult getHalfMsg(MessageQueue messageQueue, long offset) {\n        GetResult getResult = new GetResult();\n\n        PullResult result = pullHalfMsg(messageQueue, offset, 1);\n        getResult.setPullResult(result);\n        List<MessageExt> messageExts = result.getMsgFoundList();\n        if (messageExts == null) {", "refactored_code": "    private static final int PULL_MSG_RETRY_NUMBER = 1;\n    private GetResult getHalfMsg(MessageQueue messageQueue, long offset) {\n        GetResult getResult = new GetResult();\n\n        PullResult result = pullHalfMsg(messageQueue, offset, PULL_MSG_RETRY_NUMBER);\n        getResult.setPullResult(result);\n        List<MessageExt> messageExts = result.getMsgFoundList();\n        if (messageExts == null) {"}
{"magic_number_smell": "            throw new MQClientException(\"the specified group is blank\", null);\n        }\n\n        if (group.length() > 255) {\n            throw new MQClientException(\"the specified group is longer than group max length 255.\", null);\n        }\n", "refactored_code": "    public static final int CHARACTER_MAX_LENGTH = 255;\n            throw new MQClientException(\"the specified group is blank\", null);\n        }\n\n        if (group.length() > CHARACTER_MAX_LENGTH) {\n            throw new MQClientException(\"the specified group is longer than group max length 255.\", null);\n        }\n"}
{"magic_number_smell": "    }\n\n    public long getBootTimestamp() {\n        return System.currentTimeMillis();\n    }\n\n    public ScheduledExecutorService getScheduledExecutorService() {", "refactored_code": "    private final long bootTimestamp = System.currentTimeMillis();\n    }\n\n    public long getBootTimestamp() {\n        return bootTimestamp;\n    }\n\n    public ScheduledExecutorService getScheduledExecutorService() {"}
{"magic_number_smell": "            return STRING_BLANK;\n        }\n        if (isRetryTopic(originalResource)) {\n            return originalResource.substring(MixAll.RETRY_GROUP_TOPIC_PREFIX.length());\n        }\n\n        if (isDLQTopic(originalResource)) {", "refactored_code": "    public static final int RETRY_PREFIX_LENGTH = MixAll.RETRY_GROUP_TOPIC_PREFIX.length();\n            return STRING_BLANK;\n        }\n        if (isRetryTopic(originalResource)) {\n            return originalResource.substring(RETRY_PREFIX_LENGTH);\n        }\n\n        if (isDLQTopic(originalResource)) {"}
{"magic_number_smell": "            return false;\n        }\n\n        if (topic.length() > 127) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(\"The specified topic is longer than topic max length.\");\n            return false;", "refactored_code": "    private static final int TOPIC_MAX_LENGTH = 127;\n            return false;\n        }\n\n        if (topic.length() > TOPIC_MAX_LENGTH) {\n            response.setCode(ResponseCode.SYSTEM_ERROR);\n            response.setRemark(\"The specified topic is longer than topic max length.\");\n            return false;"}
{"magic_number_smell": "            }\n\n            boolean result = false;\n            for (int i = 0; i < 10 && !result; i++) {\n                result = CommitLog.this.mappedFileQueue.commit(0);\n                CommitLog.log.info(this.getServiceName() + \" service shutdown, retry \" + (i + 1) + \" times \" + (result ? \"OK\" : \"Not OK\"));\n            }", "refactored_code": "        protected static final int RETRY_TIMES_OVER = 10;\n            }\n\n            boolean result = false;\n            for (int i = 0; i < RETRY_TIMES_OVER && !result; i++) {\n                result = CommitLog.this.mappedFileQueue.commit(0);\n                CommitLog.log.info(this.getServiceName() + \" service shutdown, retry \" + (i + 1) + \" times \" + (result ? \"OK\" : \"Not OK\"));\n            }"}
{"magic_number_smell": "     */\n    public static String shortenPath(File file) {\n        String path = removeCWD(file);\n        if (path.length() < 12 * 2) {\n            return path;\n        }\n        return path.substring(0, 12)", "refactored_code": "    private static final int SHORTENED_PATH_LENGTH = 12;\n     */\n    public static String shortenPath(File file) {\n        String path = removeCWD(file);\n        if (path.length() < SHORTENED_PATH_LENGTH * 2) {\n            return path;\n        }\n        return path.substring(0, SHORTENED_PATH_LENGTH)"}
{"magic_number_smell": "     */\n    public static String shortenPath(File file) {\n        String path = removeCWD(file);\n        if (path.length() < 12 * 2) {\n            return path;\n        }\n        return path.substring(0, 12)", "refactored_code": "    private static final int SHORTENED_PATH_LENGTH = 12;\n     */\n    public static String shortenPath(File file) {\n        String path = removeCWD(file);\n        if (path.length() < SHORTENED_PATH_LENGTH * 2) {\n            return path;\n        }\n        return path.substring(0, SHORTENED_PATH_LENGTH)"}
{"magic_number_smell": "     */\n    public static String shortenPath(File file) {\n        String path = removeCWD(file);\n        if (path.length() < 12 * 2) {\n            return path;\n        }\n        return path.substring(0, 12)", "refactored_code": "    private static final int SHORTENED_PATH_LENGTH = 12;\n     */\n    public static String shortenPath(File file) {\n        String path = removeCWD(file);\n        if (path.length() < SHORTENED_PATH_LENGTH * 2) {\n            return path;\n        }\n        return path.substring(0, SHORTENED_PATH_LENGTH)"}
{"magic_number_smell": "     */\n    public static String shortenPath(File file) {\n        String path = removeCWD(file);\n        if (path.length() < 12 * 2) {\n            return path;\n        }\n        return path.substring(0, 12)", "refactored_code": "    private static final int SHORTENED_PATH_LENGTH = 12;\n     */\n    public static String shortenPath(File file) {\n        String path = removeCWD(file);\n        if (path.length() < SHORTENED_PATH_LENGTH * 2) {\n            return path;\n        }\n        return path.substring(0, SHORTENED_PATH_LENGTH)"}
{"magic_number_smell": "     * Note that this method may change the value of top_prot or bottom_prot.\n     * @param prot The protocol to be inserted. Before insertion, a sanity check will ensure that none\n     *             of the existing protocols have the same name as the new protocol.\n     * @param position Where to place the protocol with respect to the neighbor_prot (1, BELOW)\n     * @param neighbor_prot The name of the neighbor protocol. An exception will be thrown if this name\n     *                      is not found\n     * @exception Exception Will be thrown when the new protocol cannot be created, or inserted.", "refactored_code": "    public static final int         ABOVE=1; // used by insertProtocol()\n     * Note that this method may change the value of top_prot or bottom_prot.\n     * @param prot The protocol to be inserted. Before insertion, a sanity check will ensure that none\n     *             of the existing protocols have the same name as the new protocol.\n     * @param position Where to place the protocol with respect to the neighbor_prot (ABOVE, BELOW)\n     * @param neighbor_prot The name of the neighbor protocol. An exception will be thrown if this name\n     *                      is not found\n     * @exception Exception Will be thrown when the new protocol cannot be created, or inserted."}
{"magic_number_smell": "     * Note that this method may change the value of top_prot or bottom_prot.\n     * @param prot The protocol to be inserted. Before insertion, a sanity check will ensure that none\n     *             of the existing protocols have the same name as the new protocol.\n     * @param position Where to place the protocol with respect to the neighbor_prot (1, BELOW)\n     * @param neighbor_prot The name of the neighbor protocol. An exception will be thrown if this name\n     *                      is not found\n     * @exception Exception Will be thrown when the new protocol cannot be created, or inserted.", "refactored_code": "    public static final int         ABOVE=1; // used by insertProtocol()\n     * Note that this method may change the value of top_prot or bottom_prot.\n     * @param prot The protocol to be inserted. Before insertion, a sanity check will ensure that none\n     *             of the existing protocols have the same name as the new protocol.\n     * @param position Where to place the protocol with respect to the neighbor_prot (ABOVE, BELOW)\n     * @param neighbor_prot The name of the neighbor protocol. An exception will be thrown if this name\n     *                      is not found\n     * @exception Exception Will be thrown when the new protocol cannot be created, or inserted."}
{"magic_number_smell": "        // 1. write the leading byte first\n        out.write(leading);\n\n        // the flags (e.g. 1, LOW_PRIO)\n        out.write(flags);\n\n        // 3. src_addr", "refactored_code": "    public static final byte OOB       = 1;\n        // 1. write the leading byte first\n        out.write(leading);\n\n        // the flags (e.g. OOB, LOW_PRIO)\n        out.write(flags);\n\n        // 3. src_addr"}
{"magic_number_smell": "        // 1. write the leading byte first\n        out.write(leading);\n\n        // the flags (e.g. 1, LOW_PRIO)\n        out.write(flags);\n\n        // 3. src_addr", "refactored_code": "    public static final byte OOB       = 1;\n        // 1. write the leading byte first\n        out.write(leading);\n\n        // the flags (e.g. OOB, LOW_PRIO)\n        out.write(flags);\n\n        // 3. src_addr"}
{"magic_number_smell": "    server.start();\n\n    System.setProperty(client + \".niws.client.MaxAutoRetries\", \"0\");\n    System.setProperty(client + \".niws.client.MaxAutoRetriesNextServer\", \"\" + 1);\n    System.setProperty(client + \".niws.client.OkToRetryOnAllOperations\", \"true\");\n    System.setProperty(client + \".niws.client.NIWSServerListClassName\",\n        \"com.netflix.loadbalancer.ConfigurationBasedServerList\");", "refactored_code": "  private static final int retries = 1; // TODO: it seems to be ignoring retry property\n    server.start();\n\n    System.setProperty(client + \".niws.client.MaxAutoRetries\", \"0\");\n    System.setProperty(client + \".niws.client.MaxAutoRetriesNextServer\", \"\" + retries);\n    System.setProperty(client + \".niws.client.OkToRetryOnAllOperations\", \"true\");\n    System.setProperty(client + \".niws.client.NIWSServerListClassName\",\n        \"com.netflix.loadbalancer.ConfigurationBasedServerList\");"}
{"magic_number_smell": "            public void onResponse(Integer ndx) {\n                if (!getActive()) return;\n\n                if (ndx >= 75) {\n                    // last channel is not in first page so grab a set where it will be in the middle\n                    ndx = ndx - (75 / 2);\n                } else {", "refactored_code": "    private static final int PAGE_SIZE = 75;\n            public void onResponse(Integer ndx) {\n                if (!getActive()) return;\n\n                if (ndx >= PAGE_SIZE) {\n                    // last channel is not in first page so grab a set where it will be in the middle\n                    ndx = ndx - (PAGE_SIZE / 2);\n                } else {"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "      }\n    }\n\n    int count = 20;\n    if (StringUtils.isNotEmpty(countString)) {\n      try {\n        count = Integer.parseInt(countString);", "refactored_code": "  private static final int DEFAULT_LIMIT = 20;\n      }\n    }\n\n    int count = DEFAULT_LIMIT;\n    if (StringUtils.isNotEmpty(countString)) {\n      try {\n        count = Integer.parseInt(countString);"}
{"magic_number_smell": "          throws Exception {\n    // CHECKSTYLE:ON\n    if (count < 1)\n      count = 20;\n\n    WorkflowQuery q = new WorkflowQuery();\n    q.withCount(count);", "refactored_code": "  private static final int DEFAULT_LIMIT = 20;\n          throws Exception {\n    // CHECKSTYLE:ON\n    if (count < 1)\n      count = DEFAULT_LIMIT;\n\n    WorkflowQuery q = new WorkflowQuery();\n    q.withCount(count);"}
{"magic_number_smell": "        \n        // VERIFY VERSION\n        int version = data[4] & 0xFF;\n        if (version != 0x9B && version != VERSION_2_0_0)\n            return PARSE_FAILED;\n                \n        // PATCH BANK AND NAME", "refactored_code": "    public static final int VERSION_1_5_5 = 0x9B;\n        \n        // VERIFY VERSION\n        int version = data[4] & 0xFF;\n        if (version != VERSION_1_5_5 && version != VERSION_2_0_0)\n            return PARSE_FAILED;\n                \n        // PATCH BANK AND NAME"}
{"magic_number_smell": "    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);"}
{"magic_number_smell": "    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);"}
{"magic_number_smell": "\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != 0x414E4554) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n", "refactored_code": "    private static final int FILE_MAGIC = 0x414E4554;\n\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != FILE_MAGIC) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n"}
{"magic_number_smell": "            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + AlarmManager.INTERVAL_HOUR;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {", "refactored_code": "    private static final long BACKUP_INTERVAL = AlarmManager.INTERVAL_HOUR;\n            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + BACKUP_INTERVAL;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {"}
{"magic_number_smell": "            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > 50 ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;", "refactored_code": "    private static final int INET_CONDITION_THRESHOLD = 50;\n            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;"}
{"magic_number_smell": "        }\n\n        long getDefaultDisplayDelayTimeout() {\n            return 10000;\n        }\n    }\n", "refactored_code": "    private static final long WAIT_FOR_DEFAULT_DISPLAY_TIMEOUT = 10000;\n        }\n\n        long getDefaultDisplayDelayTimeout() {\n            return WAIT_FOR_DEFAULT_DISPLAY_TIMEOUT;\n        }\n    }\n"}
{"magic_number_smell": "    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #-1}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode", "refactored_code": "    public static final int INFINITE = -1;\n    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #INFINITE}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode"}
{"magic_number_smell": "        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+5*1000) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }", "refactored_code": "    private static final long MIN_TIME_BETWEEN_GCS = 5*1000;\n        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+MIN_TIME_BETWEEN_GCS) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }"}
{"magic_number_smell": "    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);"}
{"magic_number_smell": "    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);"}
{"magic_number_smell": "\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != 0x414E4554) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n", "refactored_code": "    private static final int FILE_MAGIC = 0x414E4554;\n\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != FILE_MAGIC) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n"}
{"magic_number_smell": "            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + AlarmManager.INTERVAL_HOUR;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {", "refactored_code": "    private static final long BACKUP_INTERVAL = AlarmManager.INTERVAL_HOUR;\n            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + BACKUP_INTERVAL;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {"}
{"magic_number_smell": "            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > 50 ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;", "refactored_code": "    private static final int INET_CONDITION_THRESHOLD = 50;\n            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;"}
{"magic_number_smell": "        }\n\n        long getDefaultDisplayDelayTimeout() {\n            return 10000;\n        }\n    }\n", "refactored_code": "    private static final long WAIT_FOR_DEFAULT_DISPLAY_TIMEOUT = 10000;\n        }\n\n        long getDefaultDisplayDelayTimeout() {\n            return WAIT_FOR_DEFAULT_DISPLAY_TIMEOUT;\n        }\n    }\n"}
{"magic_number_smell": "    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #-1}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode", "refactored_code": "    public static final int INFINITE = -1;\n    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #INFINITE}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode"}
{"magic_number_smell": "        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+5*1000) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }", "refactored_code": "    private static final long MIN_TIME_BETWEEN_GCS = 5*1000;\n        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+MIN_TIME_BETWEEN_GCS) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "\t{\n\t\tfor (int i = 0; i < 2048; ++i)\n\t\t{\n\t\t\tSINE[i] = (int) (65536.0D * Math.sin((double) i * Math.PI / 1024d));\n\t\t\tCOSINE[i] = (int) (65536.0D * Math.cos((double) i * Math.PI / 1024d));\n\t\t}\n\t}", "refactored_code": "\tprivate static final double UNIT = Math.PI / 1024d; // How much of the circle each unit of SINE/COSINE is\n\t{\n\t\tfor (int i = 0; i < 2048; ++i)\n\t\t{\n\t\t\tSINE[i] = (int) (65536.0D * Math.sin((double) i * UNIT));\n\t\t\tCOSINE[i] = (int) (65536.0D * Math.cos((double) i * UNIT));\n\t\t}\n\t}"}
{"magic_number_smell": "            {\n                try\n                {\n                    thread.join(1000);\n\n                    if (!thread.isAlive() || done)\n                    {", "refactored_code": "    private static final int TIMEOUT_MS = 1000;\n            {\n                try\n                {\n                    thread.join(TIMEOUT_MS);\n\n                    if (!thread.isAlive() || done)\n                    {"}
{"magic_number_smell": "\n\t\tCollection<TopicPartition> tps;\n\t\tif (partitions == null || partitions.length == 0) {\n\t\t\tMap<String, List<PartitionInfo>> parts = consumer.listTopics(Duration.ofSeconds(10));\n\t\t\ttps = parts.entrySet()\n\t\t\t\t\t.stream()\n\t\t\t\t\t.filter(entry -> entry.getKey().equals(topic))", "refactored_code": "\tprivate static final int TEN = 10;\n\n\t\tCollection<TopicPartition> tps;\n\t\tif (partitions == null || partitions.length == 0) {\n\t\t\tMap<String, List<PartitionInfo>> parts = consumer.listTopics(Duration.ofSeconds(TEN));\n\t\t\ttps = parts.entrySet()\n\t\t\t\t\t.stream()\n\t\t\t\t\t.filter(entry -> entry.getKey().equals(topic))"}
{"magic_number_smell": "\n    private void addReceivedMessage(ByteArrayWrapper message) {\n        if (message != null) {\n            if (this.receivedMessages.size() >= 5000) {\n                this.receivedMessages.clear();\n            }\n            this.receivedMessages.add(message);", "refactored_code": "    public static final int MAX_NUMBER_OF_MESSAGES_CACHED = 5000;\n\n    private void addReceivedMessage(ByteArrayWrapper message) {\n        if (message != null) {\n            if (this.receivedMessages.size() >= MAX_NUMBER_OF_MESSAGES_CACHED) {\n                this.receivedMessages.clear();\n            }\n            this.receivedMessages.add(message);"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "        emitSPIRVCapabilities(module);\n        emitImportOpenCL(asm, module);\n        emitOpenCLAddressingMode(module);\n        emitOpSourceForOpenCL(module, SPIRV_HEADER_VALUES.300000);\n\n        boolean isParallel = crb.isParallel();\n        // Generate this only if the kernel is parallel (it uses the get_global_id)", "refactored_code": "        public static final int SPIRV_VERSION_FOR_OPENCL = 300000;\n        emitSPIRVCapabilities(module);\n        emitImportOpenCL(asm, module);\n        emitOpenCLAddressingMode(module);\n        emitOpSourceForOpenCL(module, SPIRV_HEADER_VALUES.SPIRV_VERSION_FOR_OPENCL);\n\n        boolean isParallel = crb.isParallel();\n        // Generate this only if the kernel is parallel (it uses the get_global_id)"}
{"magic_number_smell": "        emitSPIRVCapabilities(module);\n        emitImportOpenCL(asm, module);\n        emitOpenCLAddressingMode(module);\n        emitOpSourceForOpenCL(module, SPIRV_HEADER_VALUES.300000);\n\n        boolean isParallel = crb.isParallel();\n        // Generate this only if the kernel is parallel (it uses the get_global_id)", "refactored_code": "        public static final int SPIRV_VERSION_FOR_OPENCL = 300000;\n        emitSPIRVCapabilities(module);\n        emitImportOpenCL(asm, module);\n        emitOpenCLAddressingMode(module);\n        emitOpSourceForOpenCL(module, SPIRV_HEADER_VALUES.SPIRV_VERSION_FOR_OPENCL);\n\n        boolean isParallel = crb.isParallel();\n        // Generate this only if the kernel is parallel (it uses the get_global_id)"}
{"magic_number_smell": "                return null;\n            }\n\n            if (currentNode.length() == 2) {\n                // Decode the key\n                byte[] k = unpackToNibbles(currentNode.get(0).asBytes());\n                Object v = currentNode.get(1).asObj();", "refactored_code": "    private static final byte PAIR_SIZE = 2;\n                return null;\n            }\n\n            if (currentNode.length() == PAIR_SIZE) {\n                // Decode the key\n                byte[] k = unpackToNibbles(currentNode.get(0).asBytes());\n                Object v = currentNode.get(1).asObj();"}
{"magic_number_smell": "    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);"}
{"magic_number_smell": "    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);"}
{"magic_number_smell": "\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != 0x414E4554) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n", "refactored_code": "    private static final int FILE_MAGIC = 0x414E4554;\n\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != FILE_MAGIC) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n"}
{"magic_number_smell": "            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + AlarmManager.INTERVAL_HOUR;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {", "refactored_code": "    private static final long BACKUP_INTERVAL = AlarmManager.INTERVAL_HOUR;\n            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + BACKUP_INTERVAL;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {"}
{"magic_number_smell": "            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > 50 ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;", "refactored_code": "    private static final int INET_CONDITION_THRESHOLD = 50;\n            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;"}
{"magic_number_smell": "        }\n\n        long getDefaultDisplayDelayTimeout() {\n            return 10000;\n        }\n    }\n", "refactored_code": "    private static final long WAIT_FOR_DEFAULT_DISPLAY_TIMEOUT = 10000;\n        }\n\n        long getDefaultDisplayDelayTimeout() {\n            return WAIT_FOR_DEFAULT_DISPLAY_TIMEOUT;\n        }\n    }\n"}
{"magic_number_smell": "    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #-1}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode", "refactored_code": "    public static final int INFINITE = -1;\n    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #INFINITE}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode"}
{"magic_number_smell": "        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+5*1000) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }", "refactored_code": "    private static final long MIN_TIME_BETWEEN_GCS = 5*1000;\n        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+MIN_TIME_BETWEEN_GCS) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }"}
{"magic_number_smell": "     */\n    private static Integer fetchDruidResponseTimeOut(String timeOutSysProp) {\n        try {\n            return SYSTEM_CONFIG.getIntProperty(timeOutSysProp, Math.toIntExact(TimeUnit.MINUTES.toMillis(10)));\n        } catch (SystemConfigException e) {\n            LOG.error(e.getMessage(), e);\n            throw new RuntimeException(e.getMessage(), e);", "refactored_code": "    private static final int DRUID_REQUEST_TIMEOUT_DEFAULT = Math.toIntExact(TimeUnit.MINUTES.toMillis(10));\n     */\n    private static Integer fetchDruidResponseTimeOut(String timeOutSysProp) {\n        try {\n            return SYSTEM_CONFIG.getIntProperty(timeOutSysProp, DRUID_REQUEST_TIMEOUT_DEFAULT);\n        } catch (SystemConfigException e) {\n            LOG.error(e.getMessage(), e);\n            throw new RuntimeException(e.getMessage(), e);"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    {\n        int format = 0;\n\n        byte[] magic = new byte[8];\n\n        // If this is not an HDF5 file, then the magic number is at\n        // position 0; If it is an HDF5 file, then we need to search", "refactored_code": "    static private final int MAGIC_NUMBER_LEN = 8;\n    {\n        int format = 0;\n\n        byte[] magic = new byte[MAGIC_NUMBER_LEN];\n\n        // If this is not an HDF5 file, then the magic number is at\n        // position 0; If it is an HDF5 file, then we need to search"}
{"magic_number_smell": "    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkStatsHistory(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                bucketDuration = in.readLong();\n                bucketStart = readLongArray(in);\n                rx = readLongArray(in);"}
{"magic_number_smell": "    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case 1: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);", "refactored_code": "    private static final int VERSION_CURRENT = 1;\n    public NetworkIdentity(DataInputStream in) throws IOException {\n        final int version = in.readInt();\n        switch (version) {\n            case VERSION_CURRENT: {\n                type = in.readInt();\n                subType = in.readInt();\n                subscriberId = readOptionalString(in);"}
{"magic_number_smell": "\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != 0x414E4554) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n", "refactored_code": "    private static final int FILE_MAGIC = 0x414E4554;\n\n            // verify file magic header intact\n            final int magic = in.readInt();\n            if (magic != FILE_MAGIC) {\n                throw new ProtocolException(\"unexpected magic: \" + magic);\n            }\n"}
{"magic_number_smell": "            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + AlarmManager.INTERVAL_HOUR;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {", "refactored_code": "    private static final long BACKUP_INTERVAL = AlarmManager.INTERVAL_HOUR;\n            case MSG_RUN_BACKUP:\n            {\n                mLastBackupPass = System.currentTimeMillis();\n                mNextBackupPass = mLastBackupPass + BACKUP_INTERVAL;\n\n                IBackupTransport transport = getTransport(mCurrentTransport);\n                if (transport == null) {"}
{"magic_number_smell": "            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > 50 ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;", "refactored_code": "    private static final int INET_CONDITION_THRESHOLD = 50;\n            Slog.d(TAG, \"updateConnectivity: connectionStatus=\" + connectionStatus);\n        }\n\n        mInetCondition = (connectionStatus > INET_CONDITION_THRESHOLD ? 1 : 0);\n\n        if (info != null && info.getType() == ConnectivityManager.TYPE_BLUETOOTH) {\n            mBluetoothTethered = info.isConnected() ? true: false;"}
{"magic_number_smell": "        }\n\n        long getDefaultDisplayDelayTimeout() {\n            return 10000;\n        }\n    }\n", "refactored_code": "    private static final long WAIT_FOR_DEFAULT_DISPLAY_TIMEOUT = 10000;\n        }\n\n        long getDefaultDisplayDelayTimeout() {\n            return WAIT_FOR_DEFAULT_DISPLAY_TIMEOUT;\n        }\n    }\n"}
{"magic_number_smell": "    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #-1}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode", "refactored_code": "    public static final int INFINITE = -1;\n    /**\n     * Defines what this animation should do when it reaches the end. This\n     * setting is applied only when the repeat count is either greater than\n     * 0 or {@link #INFINITE}. Defaults to {@link #RESTART}. \n     *\n     * @param repeatMode {@link #RESTART} or {@link #REVERSE}\n     * @attr ref android.R.styleable#Animation_repeatMode"}
{"magic_number_smell": "        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+5*1000) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }", "refactored_code": "    private static final long MIN_TIME_BETWEEN_GCS = 5*1000;\n        final long now = SystemClock.uptimeMillis();\n        //Slog.i(TAG, \"**** WE MIGHT WANT TO GC: then=\" + Binder.getLastGcTime()\n        //        + \"m now=\" + now);\n        if ((BinderInternal.getLastGcTime()+MIN_TIME_BETWEEN_GCS) < now) {\n            //Slog.i(TAG, \"**** WE DO, WE DO WANT TO GC!\");\n            BinderInternal.forceGc(\"bg\");\n        }"}
{"magic_number_smell": "            }\n        }\n        if (bgColor.getAlpha() > 0) {\n            int scaledArc = round(UIManager.getInt(\"TabControlIcon.arc\") * 2 * scaling);\n            g.setColor(bgColor);\n            g.fillRoundRect(0, 0, width, height, scaledArc, scaledArc);\n        }", "refactored_code": "    private static final int arc = UIManager.getInt(\"TabControlIcon.arc\"); // NOI18N\n            }\n        }\n        if (bgColor.getAlpha() > 0) {\n            int scaledArc = round(arc * 2 * scaling);\n            g.setColor(bgColor);\n            g.fillRoundRect(0, 0, width, height, scaledArc, scaledArc);\n        }"}
{"magic_number_smell": "                this.hiddenNotifications.put(subtype, xpstrid, val);\n            }\n        } catch (SQLException sqe) {\n            if (Integer.parseInt(SurveyMain.getNewVersion()) >= 42) {\n                SurveyLog.logException(sqe, \"Getting hidden notifications for uid#\" + userId + \" in \" + localeId, null);\n                throw new InternalError(\"Error getting hidden notifications: \" + sqe.getMessage());\n            }", "refactored_code": "    private final int FIRST_DB_VERSION = 42;\n                this.hiddenNotifications.put(subtype, xpstrid, val);\n            }\n        } catch (SQLException sqe) {\n            if (Integer.parseInt(SurveyMain.getNewVersion()) >= FIRST_DB_VERSION) {\n                SurveyLog.logException(sqe, \"Getting hidden notifications for uid#\" + userId + \" in \" + localeId, null);\n                throw new InternalError(\"Error getting hidden notifications: \" + sqe.getMessage());\n            }"}
{"magic_number_smell": "        int concurrency,\n        AllocationTracker tracker\n    ) {\n        var componentSizeBuilder = HugeSparseLongArray.GrowingBuilder.create(0L, tracker);\n\n        if (concurrency == 1) {\n            // For one thread, we can just iterate through the node space", "refactored_code": "    private static final long EMPTY_COMMUNITY = 0L;\n        int concurrency,\n        AllocationTracker tracker\n    ) {\n        var componentSizeBuilder = HugeSparseLongArray.GrowingBuilder.create(EMPTY_COMMUNITY, tracker);\n\n        if (concurrency == 1) {\n            // For one thread, we can just iterate through the node space"}
{"magic_number_smell": "            long nextConsecutiveId = -1L;\n\n            // TODO is there a better way to set the initial size, e.g. dss.setCount\n            HugeLongLongMap setIdToConsecutiveId = new HugeLongLongMap(BitUtil.ceilDiv(dss.size(), 10L), tracker);\n            this.communities = HugeLongArray.newArray(dss.size(), tracker);\n\n            for (int nodeId = 0; nodeId < dss.size(); nodeId++) {", "refactored_code": "        private static final long MAPPING_SIZE_QUOTIENT = 10L;\n            long nextConsecutiveId = -1L;\n\n            // TODO is there a better way to set the initial size, e.g. dss.setCount\n            HugeLongLongMap setIdToConsecutiveId = new HugeLongLongMap(BitUtil.ceilDiv(dss.size(), MAPPING_SIZE_QUOTIENT), tracker);\n            this.communities = HugeLongArray.newArray(dss.size(), tracker);\n\n            for (int nodeId = 0; nodeId < dss.size(); nodeId++) {"}
{"magic_number_smell": "\t{\n\t\tfor (int i = 0; i < 2048; ++i)\n\t\t{\n\t\t\tSINE[i] = (int) (65536.0D * Math.sin((double) i * Math.PI / 1024d));\n\t\t\tCOSINE[i] = (int) (65536.0D * Math.cos((double) i * Math.PI / 1024d));\n\t\t}\n\t}", "refactored_code": "\tprivate static final double UNIT = Math.PI / 1024d; // How much of the circle each unit of SINE/COSINE is\n\t{\n\t\tfor (int i = 0; i < 2048; ++i)\n\t\t{\n\t\t\tSINE[i] = (int) (65536.0D * Math.sin((double) i * UNIT));\n\t\t\tCOSINE[i] = (int) (65536.0D * Math.cos((double) i * UNIT));\n\t\t}\n\t}"}
{"magic_number_smell": "        final List<Analog> measurements = new ArrayList<>();\n\n        final String eanCode = values[0];\n        for (int index = 1; index < CURRENT_START_INDEX; index++) {\n            final String description = eanCode + \":voltage_L\" + index;\n            measurements.add(this.createAnalog(description, Float.valueOf(values[index]), UnitSymbol.V));\n        }", "refactored_code": "    private static final int VOLTAGE_START_INDEX = 1;\n        final List<Analog> measurements = new ArrayList<>();\n\n        final String eanCode = values[0];\n        for (int index = VOLTAGE_START_INDEX; index < CURRENT_START_INDEX; index++) {\n            final String description = eanCode + \":voltage_L\" + index;\n            measurements.add(this.createAnalog(description, Float.valueOf(values[index]), UnitSymbol.V));\n        }"}
{"magic_number_smell": "    public WebhookCallback(List<String> remoteEndpoints) {\n        this.remoteEndpoints = remoteEndpoints;\n        requestConfig = RequestConfig.custom()\n            .setConnectTimeout(1000)\n            .setConnectionRequestTimeout(HTTP_CONNECTION_REQUEST_TIMEOUT)\n            .setSocketTimeout(HTTP_SOCKET_TIMEOUT).build();\n    }", "refactored_code": "    private static final int HTTP_CONNECT_TIMEOUT = 1000;\n    public WebhookCallback(List<String> remoteEndpoints) {\n        this.remoteEndpoints = remoteEndpoints;\n        requestConfig = RequestConfig.custom()\n            .setConnectTimeout(HTTP_CONNECT_TIMEOUT)\n            .setConnectionRequestTimeout(HTTP_CONNECTION_REQUEST_TIMEOUT)\n            .setSocketTimeout(HTTP_SOCKET_TIMEOUT).build();\n    }"}
{"magic_number_smell": "    \n    @SuppressWarnings(\"unchecked\")\n    public void afterConstruct() {\n        NotifyCenter.registerToPublisher(ValueChangeEvent.class, 16384);\n        listenOldRaftClose();\n    }\n    ", "refactored_code": "    protected final int queueMaxSize = 16384;\n    \n    @SuppressWarnings(\"unchecked\")\n    public void afterConstruct() {\n        NotifyCenter.registerToPublisher(ValueChangeEvent.class, queueMaxSize);\n        listenOldRaftClose();\n    }\n    "}
{"magic_number_smell": "            if (!isValid(tag.trim())) {\n                throw new IllegalArgumentException(\"invalid tag : \" + tag);\n            }\n            if (tag.length() > 16) {\n                throw new IllegalArgumentException(\"too long tag, over 16\");\n            }\n        }", "refactored_code": "    private static final int TAG_MAX_LEN = 16;\n            if (!isValid(tag.trim())) {\n                throw new IllegalArgumentException(\"invalid tag : \" + tag);\n            }\n            if (tag.length() > TAG_MAX_LEN) {\n                throw new IllegalArgumentException(\"too long tag, over 16\");\n            }\n        }"}
{"magic_number_smell": "public class ManagedLedgerFactoryConfig {\n    private static final long 1024 * 1024 = 1024 * 1024;\n\n    private long maxCacheSize = 128 * 1024 * 1024;\n\n    /**\n     * The cache eviction watermark is the percentage of the cache size to reach when removing entries from the cache.", "refactored_code": "    private static final long MB = 1024 * 1024;\npublic class ManagedLedgerFactoryConfig {\n    private static final long MB = 1024 * 1024;\n\n    private long maxCacheSize = 128 * MB;\n\n    /**\n     * The cache eviction watermark is the percentage of the cache size to reach when removing entries from the cache."}
{"magic_number_smell": "        this.mbean = new ManagedLedgerFactoryMBeanImpl(this);\n        this.entryCacheManager = new EntryCacheManager(this);\n        this.statsTask = scheduledExecutor.scheduleAtFixedRate(this::refreshStats,\n                0, 60, TimeUnit.SECONDS);\n        this.flushCursorsTask = scheduledExecutor.scheduleAtFixedRate(this::flushCursors,\n                config.getCursorPositionFlushSeconds(), config.getCursorPositionFlushSeconds(), TimeUnit.SECONDS);\n", "refactored_code": "    public static final int StatsPeriodSeconds = 60;\n        this.mbean = new ManagedLedgerFactoryMBeanImpl(this);\n        this.entryCacheManager = new EntryCacheManager(this);\n        this.statsTask = scheduledExecutor.scheduleAtFixedRate(this::refreshStats,\n                0, StatsPeriodSeconds, TimeUnit.SECONDS);\n        this.flushCursorsTask = scheduledExecutor.scheduleAtFixedRate(this::flushCursors,\n                config.getCursorPositionFlushSeconds(), config.getCursorPositionFlushSeconds(), TimeUnit.SECONDS);\n"}
{"magic_number_smell": "                    .build();\n            metadataByteBuf = PulsarByteBufAllocator.DEFAULT.buffer(\n                    mlInfoMetadata.getSerializedSize() + 6, mlInfoMetadata.getSerializedSize() + 6);\n            metadataByteBuf.writeShort(0x4778);\n            metadataByteBuf.writeInt(mlInfoMetadata.getSerializedSize());\n            metadataByteBuf.writeBytes(mlInfoMetadata.toByteArray());\n", "refactored_code": "    private static final int MAGIC_MANAGED_LEDGER_INFO_METADATA = 0x4778; // 0100 0111 0111 1000\n                    .build();\n            metadataByteBuf = PulsarByteBufAllocator.DEFAULT.buffer(\n                    mlInfoMetadata.getSerializedSize() + 6, mlInfoMetadata.getSerializedSize() + 6);\n            metadataByteBuf.writeShort(MAGIC_MANAGED_LEDGER_INFO_METADATA);\n            metadataByteBuf.writeInt(mlInfoMetadata.getSerializedSize());\n            metadataByteBuf.writeBytes(mlInfoMetadata.toByteArray());\n"}
{"magic_number_smell": "        private static final int TRUE = 1;\n        private static final AtomicIntegerFieldUpdater<LastSendFutureWrapper> THROW_ONCE_UPDATER =\n                AtomicIntegerFieldUpdater.newUpdater(LastSendFutureWrapper.class, \"throwOnce\");\n        private volatile int throwOnce = 0;\n\n        private LastSendFutureWrapper(CompletableFuture<MessageId> lastSendFuture) {\n            this.lastSendFuture = lastSendFuture;", "refactored_code": "        private static final int FALSE = 0;\n        private static final int TRUE = 1;\n        private static final AtomicIntegerFieldUpdater<LastSendFutureWrapper> THROW_ONCE_UPDATER =\n                AtomicIntegerFieldUpdater.newUpdater(LastSendFutureWrapper.class, \"throwOnce\");\n        private volatile int throwOnce = FALSE;\n\n        private LastSendFutureWrapper(CompletableFuture<MessageId> lastSendFuture) {\n            this.lastSendFuture = lastSendFuture;"}
{"magic_number_smell": "    public ChunkHeader next() throws MalformedChunkException, IOException {\n        if (count <= chunkCount) {\n            long currentOffset = this.currentOffset;\n            this.currentOffset += 65536;\n            BinaryReader binaryReader = new BinaryReader(inputStream, 65536);\n            try {\n                return new ChunkHeader(binaryReader, log, currentOffset, count++);", "refactored_code": "    public static final int CHUNK_SIZE = 65536;\n    public ChunkHeader next() throws MalformedChunkException, IOException {\n        if (count <= chunkCount) {\n            long currentOffset = this.currentOffset;\n            this.currentOffset += CHUNK_SIZE;\n            BinaryReader binaryReader = new BinaryReader(inputStream, CHUNK_SIZE);\n            try {\n                return new ChunkHeader(binaryReader, log, currentOffset, count++);"}
{"magic_number_smell": "        assertEquals(1, failureFlowFiles.size());\n        validateFlowFiles(failureFlowFiles);\n        // We expect the same number of records to come out no matter the granularity\n        assertEquals(1053, validateFlowFiles(failureFlowFiles));\n\n        // Whole file fails if there is a failure parsing\n        List<MockFlowFile> successFlowFiles = testRunner.getFlowFilesForRelationship(ParseEvtx.REL_SUCCESS);", "refactored_code": "    public static final int EXPECTED_SUCCESSFUL_EVENT_COUNT = 1053;\n        assertEquals(1, failureFlowFiles.size());\n        validateFlowFiles(failureFlowFiles);\n        // We expect the same number of records to come out no matter the granularity\n        assertEquals(EXPECTED_SUCCESSFUL_EVENT_COUNT, validateFlowFiles(failureFlowFiles));\n\n        // Whole file fails if there is a failure parsing\n        List<MockFlowFile> successFlowFiles = testRunner.getFlowFilesForRelationship(ParseEvtx.REL_SUCCESS);"}
{"magic_number_smell": "        // Config for Append-Only test\n        INPUTS = new ArrayList<>();\n        for (int segmentCount : SEGMENT_COUNTS) {\n            int appendCount = 10000 / segmentCount;\n            for (int appendSize : APPEND_SIZES) {\n                for (int burstSize : BURST_SIZES) {\n                    INPUTS.add(new TestInput(segmentCount, appendCount, appendSize, burstSize));", "refactored_code": "    private static final int APPEND_COUNT = 10000;\n        // Config for Append-Only test\n        INPUTS = new ArrayList<>();\n        for (int segmentCount : SEGMENT_COUNTS) {\n            int appendCount = APPEND_COUNT / segmentCount;\n            for (int appendSize : APPEND_SIZES) {\n                for (int burstSize : BURST_SIZES) {\n                    INPUTS.add(new TestInput(segmentCount, appendCount, appendSize, burstSize));"}
{"magic_number_smell": "     * Creates a new instance of the Operation class.\n     */\n    public Operation() {\n        this.sequenceNumber = Long.MIN_VALUE;\n    }\n\n    /**", "refactored_code": "    public static final long NO_SEQUENCE_NUMBER = Long.MIN_VALUE;\n     * Creates a new instance of the Operation class.\n     */\n    public Operation() {\n        this.sequenceNumber = NO_SEQUENCE_NUMBER;\n    }\n\n    /**"}
{"magic_number_smell": "        assertEquals(statistics1.getMin(), statistics2.getMin());\n        assertEquals(statistics1.getMax(), statistics2.getMax());\n        assertEquals(statistics1.getFirst(), statistics2.getFirst());\n        assertEquals(statistics1.getSum(), statistics2.getSum(), 0.0001d);\n        assertEquals(statistics1.getLast(), statistics2.getLast());\n      }\n    }", "refactored_code": "  private static final double maxError = 0.0001d;\n        assertEquals(statistics1.getMin(), statistics2.getMin());\n        assertEquals(statistics1.getMax(), statistics2.getMax());\n        assertEquals(statistics1.getFirst(), statistics2.getFirst());\n        assertEquals(statistics1.getSum(), statistics2.getSum(), maxError);\n        assertEquals(statistics1.getLast(), statistics2.getLast());\n      }\n    }"}
{"magic_number_smell": "    Filter orFilter = FilterFactory.or(andFilter, TimeFilter.eq(1000L));\n\n    long startTime = System.currentTimeMillis();\n    for (long i = 0; i < 10000000; i++) {\n      orFilter.satisfy(i, i + 0.1);\n    }\n    long endTime = System.currentTimeMillis();", "refactored_code": "  private static final long EFFICIENCY_TEST_COUNT = 10000000;\n    Filter orFilter = FilterFactory.or(andFilter, TimeFilter.eq(1000L));\n\n    long startTime = System.currentTimeMillis();\n    for (long i = 0; i < EFFICIENCY_TEST_COUNT; i++) {\n      orFilter.satisfy(i, i + 0.1);\n    }\n    long endTime = System.currentTimeMillis();"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "\n\t/**\n\t * Convenient way to encode faces that may be null.\n\t * Null is returned as {@link #6}. \n\t * Use {@link #faceFromIndex(int)} to retrieve encoded face.\n\t */\n\tpublic static int toFaceIndex(Direction face) {", "refactored_code": "\tpublic static final int NULL_FACE_ID = 6;\n\n\t/**\n\t * Convenient way to encode faces that may be null.\n\t * Null is returned as {@link #NULL_FACE_ID}. \n\t * Use {@link #faceFromIndex(int)} to retrieve encoded face.\n\t */\n\tpublic static int toFaceIndex(Direction face) {"}
{"magic_number_smell": "\tprivate static final BlendMode[] BLEND_MODES = BlendMode.values();\n\n\tprivate static final int MathHelper.smallestEncompassingPowerOfTwo(BlendMode.values().length) - 1 = MathHelper.smallestEncompassingPowerOfTwo(BlendMode.values().length) - 1;\n\tprivate static final int COLOR_DISABLE_FLAG = MathHelper.smallestEncompassingPowerOfTwo(BlendMode.values().length) - 1 + 1;\n\tprivate static final int EMISSIVE_FLAG = COLOR_DISABLE_FLAG << 1;\n\tprivate static final int DIFFUSE_FLAG = EMISSIVE_FLAG << 1;\n\tprivate static final int AO_FLAG = DIFFUSE_FLAG << 1;", "refactored_code": "\tprivate static final int BLEND_MODE_MASK = MathHelper.smallestEncompassingPowerOfTwo(BlendMode.values().length) - 1;\n\tprivate static final BlendMode[] BLEND_MODES = BlendMode.values();\n\n\tprivate static final int BLEND_MODE_MASK = MathHelper.smallestEncompassingPowerOfTwo(BlendMode.values().length) - 1;\n\tprivate static final int COLOR_DISABLE_FLAG = BLEND_MODE_MASK + 1;\n\tprivate static final int EMISSIVE_FLAG = COLOR_DISABLE_FLAG << 1;\n\tprivate static final int DIFFUSE_FLAG = EMISSIVE_FLAG << 1;\n\tprivate static final int AO_FLAG = DIFFUSE_FLAG << 1;"}
{"magic_number_smell": "    final WebSocketConfiguration config = new WebSocketConfiguration();\n    config.setEnabled(false);\n    config.setHost(DEFAULT_WEBSOCKET_HOST);\n    config.setPort(8546);\n    config.setRpcApis(DEFAULT_WEBSOCKET_APIS);\n    config.setRefreshDelay(DEFAULT_WEBSOCKET_REFRESH_DELAY);\n    return config;", "refactored_code": "  public static final int DEFAULT_WEBSOCKET_PORT = 8546;\n    final WebSocketConfiguration config = new WebSocketConfiguration();\n    config.setEnabled(false);\n    config.setHost(DEFAULT_WEBSOCKET_HOST);\n    config.setPort(DEFAULT_WEBSOCKET_PORT);\n    config.setRpcApis(DEFAULT_WEBSOCKET_APIS);\n    config.setRefreshDelay(DEFAULT_WEBSOCKET_REFRESH_DELAY);\n    return config;"}
{"magic_number_smell": "    paramLabel = MANDATORY_INTEGER_FORMAT_HELP,\n    description = \"Maximum p2p peer connections that can be established (default: ${DEFAULT-VALUE})\"\n  )\n  private final Integer maxPeers = 25;\n\n  @Option(\n    names = {\"--max-trailing-peers\"},", "refactored_code": "  private static final int DEFAULT_MAX_PEERS = 25;\n    paramLabel = MANDATORY_INTEGER_FORMAT_HELP,\n    description = \"Maximum p2p peer connections that can be established (default: ${DEFAULT-VALUE})\"\n  )\n  private final Integer maxPeers = DEFAULT_MAX_PEERS;\n\n  @Option(\n    names = {\"--max-trailing-peers\"},"}
{"magic_number_smell": "\n  private final TransactionValidator transactionValidator = mock(TransactionValidator.class);\n  private MutableBlockchain blockchain;\n  private final PendingTransactions transactions = new PendingTransactions(5);\n  private final Transaction transaction1 = createTransaction(1);\n  private final Transaction transaction2 = createTransaction(2);\n  private TransactionPool transactionPool;", "refactored_code": "  private static final int MAX_TRANSACTIONS = 5;\n\n  private final TransactionValidator transactionValidator = mock(TransactionValidator.class);\n  private MutableBlockchain blockchain;\n  private final PendingTransactions transactions = new PendingTransactions(MAX_TRANSACTIONS);\n  private final Transaction transaction1 = createTransaction(1);\n  private final Transaction transaction2 = createTransaction(2);\n  private TransactionPool transactionPool;"}
{"magic_number_smell": "\n    final DiscoveryTestSocket discoveryTestSocket;\n    try {\n      discoveryTestSocket = result.get(5, TimeUnit.SECONDS);\n    } catch (final Exception ex) {\n      throw new AssertionError(\"Could not initialize test peer\", ex);\n    }", "refactored_code": "  private static final int TEST_SOCKET_START_TIMEOUT_SECS = 5;\n\n    final DiscoveryTestSocket discoveryTestSocket;\n    try {\n      discoveryTestSocket = result.get(TEST_SOCKET_START_TIMEOUT_SECS, TimeUnit.SECONDS);\n    } catch (final Exception ex) {\n      throw new AssertionError(\"Could not initialize test peer\", ex);\n    }"}
{"magic_number_smell": "    // A queue for storing peer bonded events.\n    final ArrayBlockingQueue<PeerBondedEvent> queue = new ArrayBlockingQueue<>(10);\n    agent.observePeerBondedEvents(queue::add);\n    assertThatCode(() -> agent.start(26422).get(5, TimeUnit.SECONDS))\n        .doesNotThrowAnyException();\n\n    // Wait until we've received 5 events.", "refactored_code": "  private static final int BROADCAST_TCP_PORT = 26422;\n    // A queue for storing peer bonded events.\n    final ArrayBlockingQueue<PeerBondedEvent> queue = new ArrayBlockingQueue<>(10);\n    agent.observePeerBondedEvents(queue::add);\n    assertThatCode(() -> agent.start(BROADCAST_TCP_PORT).get(5, TimeUnit.SECONDS))\n        .doesNotThrowAnyException();\n\n    // Wait until we've received 5 events."}
{"magic_number_smell": "    final Bytes32 keccak256 = host.keccak256();\n    final MutableBytesValue template = MutableBytesValue.create(keccak256.size());\n    byte msb = keccak256.get(0);\n    msb ^= -128;\n    template.set(0, msb);\n\n    for (int i = 0; i < n; i++) {", "refactored_code": "  private static final byte MOST_SIGNFICANT_BIT_MASK = -128;\n    final Bytes32 keccak256 = host.keccak256();\n    final MutableBytesValue template = MutableBytesValue.create(keccak256.size());\n    byte msb = keccak256.get(0);\n    msb ^= MOST_SIGNFICANT_BIT_MASK;\n    template.set(0, msb);\n\n    for (int i = 0; i < n; i++) {"}
{"magic_number_smell": "    paramLabel = MANDATORY_INTEGER_FORMAT_HELP,\n    description = \"Maximum p2p peer connections that can be established (default: ${DEFAULT-VALUE})\"\n  )\n  private final Integer maxPeers = 25;\n\n  @Option(\n    names = {\"--max-trailing-peers\"},", "refactored_code": "  private static final int DEFAULT_MAX_PEERS = 25;\n    paramLabel = MANDATORY_INTEGER_FORMAT_HELP,\n    description = \"Maximum p2p peer connections that can be established (default: ${DEFAULT-VALUE})\"\n  )\n  private final Integer maxPeers = DEFAULT_MAX_PEERS;\n\n  @Option(\n    names = {\"--max-trailing-peers\"},"}
{"magic_number_smell": "  // an application-wide executor to run concurrent blaze builds remotely\n  private static final ListeningExecutorService remoteBuildExecutor =\n      MoreExecutors.listeningDecorator(\n          AppExecutorUtil.createBoundedApplicationPoolExecutor(\"FetchExecutor\", 8));\n\n  // a per-project executor to run single-threaded sync phases\n  private final ListeningExecutorService singleThreadedExecutor;", "refactored_code": "  private static final int MAX_BUILD_TASKS = 8;\n  // an application-wide executor to run concurrent blaze builds remotely\n  private static final ListeningExecutorService remoteBuildExecutor =\n      MoreExecutors.listeningDecorator(\n          AppExecutorUtil.createBoundedApplicationPoolExecutor(\"FetchExecutor\", MAX_BUILD_TASKS));\n\n  // a per-project executor to run single-threaded sync phases\n  private final ListeningExecutorService singleThreadedExecutor;"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "//         ThreadTools.scheduleSingleExecution(\"SafetyStop\", guiRecorder::stop, 1200.0);\n      }\n\n      primary3DPanel = new RDX3DPanel(VIEW_3D_WINDOW_NAME, 2, true);\n      primary3DPanel.setBackgroundShade((float) view3DBackgroundShade.get());\n   }\n", "refactored_code": "   public static final int ANTI_ALIASING = 2;\n//         ThreadTools.scheduleSingleExecution(\"SafetyStop\", guiRecorder::stop, 1200.0);\n      }\n\n      primary3DPanel = new RDX3DPanel(VIEW_3D_WINDOW_NAME, ANTI_ALIASING, true);\n      primary3DPanel.setBackgroundShade((float) view3DBackgroundShade.get());\n   }\n"}
{"magic_number_smell": "//         ThreadTools.scheduleSingleExecution(\"SafetyStop\", guiRecorder::stop, 1200.0);\n      }\n\n      primary3DPanel = new RDX3DPanel(VIEW_3D_WINDOW_NAME, 2, true);\n      primary3DPanel.setBackgroundShade((float) view3DBackgroundShade.get());\n   }\n", "refactored_code": "   public static final int ANTI_ALIASING = 2;\n//         ThreadTools.scheduleSingleExecution(\"SafetyStop\", guiRecorder::stop, 1200.0);\n      }\n\n      primary3DPanel = new RDX3DPanel(VIEW_3D_WINDOW_NAME, ANTI_ALIASING, true);\n      primary3DPanel.setBackgroundShade((float) view3DBackgroundShade.get());\n   }\n"}
{"magic_number_smell": "      float posY = ImGui.getWindowPosY() + ImGuiTools.TAB_BAR_HEIGHT;\n      sizeX = ImGui.getWindowSizeX();\n      sizeY = ImGui.getWindowSizeY() - ImGuiTools.TAB_BAR_HEIGHT;\n      float renderSizeX = sizeX * 2;\n      float renderSizeY = sizeY * 2;\n\n      inputCalculator.compute();", "refactored_code": "   public static final int ANTI_ALIASING = 2;\n      float posY = ImGui.getWindowPosY() + ImGuiTools.TAB_BAR_HEIGHT;\n      sizeX = ImGui.getWindowSizeX();\n      sizeY = ImGui.getWindowSizeY() - ImGuiTools.TAB_BAR_HEIGHT;\n      float renderSizeX = sizeX * ANTI_ALIASING;\n      float renderSizeY = sizeY * ANTI_ALIASING;\n\n      inputCalculator.compute();"}
{"magic_number_smell": "//         ThreadTools.scheduleSingleExecution(\"SafetyStop\", guiRecorder::stop, 1200.0);\n      }\n\n      primary3DPanel = new RDX3DPanel(VIEW_3D_WINDOW_NAME, 2, true);\n      primary3DPanel.setBackgroundShade((float) view3DBackgroundShade.get());\n   }\n", "refactored_code": "   public static final int ANTI_ALIASING = 2;\n//         ThreadTools.scheduleSingleExecution(\"SafetyStop\", guiRecorder::stop, 1200.0);\n      }\n\n      primary3DPanel = new RDX3DPanel(VIEW_3D_WINDOW_NAME, ANTI_ALIASING, true);\n      primary3DPanel.setBackgroundShade((float) view3DBackgroundShade.get());\n   }\n"}
{"magic_number_smell": "      float posY = ImGui.getWindowPosY() + ImGuiTools.TAB_BAR_HEIGHT;\n      sizeX = ImGui.getWindowSizeX();\n      sizeY = ImGui.getWindowSizeY() - ImGuiTools.TAB_BAR_HEIGHT;\n      float renderSizeX = sizeX * 2;\n      float renderSizeY = sizeY * 2;\n\n      inputCalculator.compute();", "refactored_code": "   public static final int ANTI_ALIASING = 2;\n      float posY = ImGui.getWindowPosY() + ImGuiTools.TAB_BAR_HEIGHT;\n      sizeX = ImGui.getWindowSizeX();\n      sizeY = ImGui.getWindowSizeY() - ImGuiTools.TAB_BAR_HEIGHT;\n      float renderSizeX = sizeX * ANTI_ALIASING;\n      float renderSizeY = sizeY * ANTI_ALIASING;\n\n      inputCalculator.compute();"}
{"magic_number_smell": "\n               if (dataOkay)\n               {\n                  for (int k = 0; k < 128; k++)\n                  {\n                     float rangeScaled = range[k] / 1000.0F;\n                     if (rangeScaled > 30.0)", "refactored_code": "   public static final int OUSTER_NUMBER_ROWS = 128;\n\n               if (dataOkay)\n               {\n                  for (int k = 0; k < OUSTER_NUMBER_ROWS; k++)\n                  {\n                     float rangeScaled = range[k] / 1000.0F;\n                     if (rangeScaled > 30.0)"}
{"magic_number_smell": "         nodeShift.set(nodeShiftToAvoidObstacles);\n      }\n\n      if (nodeShift.length() > 0.01)\n      {\n         nextPointInWorld2D.add(nodeShift);\n         nodeLocationToPack.set(nextPointInWorld2D, findHeightOfPoint(nextPointInWorld2D, bothRegions));", "refactored_code": "   private static final double minDistanceToMove = 0.01;\n         nodeShift.set(nodeShiftToAvoidObstacles);\n      }\n\n      if (nodeShift.length() > minDistanceToMove)\n      {\n         nextPointInWorld2D.add(nodeShift);\n         nodeLocationToPack.set(nextPointInWorld2D, findHeightOfPoint(nextPointInWorld2D, bothRegions));"}
{"magic_number_smell": "      double headingToObstacle = BodyPathPlannerTools.calculateHeading(headingToClosestObstacle);\n      double distanceToObstacle = headingToClosestObstacle.length() + parameters.getObstacleExtrusionDistance();\n\n      if (distanceToObstacle > parameters.getPreferredObstacleExtrusionDistance() - 5e-2)\n         return nominalHeading;\n\n//      double rotationForAvoidance = computeRotationForAvoidanceUsingBox(distanceToObstacle, parameters.getObstacleExtrusionDistance());", "refactored_code": "   private static final double epsilon = 5e-2;\n      double headingToObstacle = BodyPathPlannerTools.calculateHeading(headingToClosestObstacle);\n      double distanceToObstacle = headingToClosestObstacle.length() + parameters.getObstacleExtrusionDistance();\n\n      if (distanceToObstacle > parameters.getPreferredObstacleExtrusionDistance() - epsilon)\n         return nominalHeading;\n\n//      double rotationForAvoidance = computeRotationForAvoidanceUsingBox(distanceToObstacle, parameters.getObstacleExtrusionDistance());"}
{"magic_number_smell": "         {\n            Point2DReadOnly target = listOfObserverPoints.get(j);\n\n            if (observer.distance(target) > 0.01)\n            {\n               boolean targetIsVisible = isPointVisibleForStaticMaps(clusters, observer, target);\n", "refactored_code": "   private static final double MAGIC_NUMBER = 0.01;\n         {\n            Point2DReadOnly target = listOfObserverPoints.get(j);\n\n            if (observer.distance(target) > MAGIC_NUMBER)\n            {\n               boolean targetIsVisible = isPointVisibleForStaticMaps(clusters, observer, target);\n"}
{"magic_number_smell": "   @After\r\n   public void closeSCS()\r\n   {\r\n      ThreadTools.sleep(2000);\r\n      scs.closeAndDispose();\r\n      scs = null;\r\n   }\r", "refactored_code": "   private static final long CLOSING_SLEEP_TIME = 2000;\r\n   @After\r\n   public void closeSCS()\r\n   {\r\n      ThreadTools.sleep(CLOSING_SLEEP_TIME);\r\n      scs.closeAndDispose();\r\n      scs = null;\r\n   }\r"}
{"magic_number_smell": "\n            double range = upperLimit - lowerLimit;\n\n            if (range > 2.0 * Math.toRadians(5.0))\n            {\n               double safeLowerBound = lowerLimit + Math.toRadians(5.0);\n               double safeUpperBound = upperLimit - Math.toRadians(5.0);", "refactored_code": "   private final double HARDSTOP_RESTRICTION_ANGLE = Math.toRadians(5.0);\n\n            double range = upperLimit - lowerLimit;\n\n            if (range > 2.0 * HARDSTOP_RESTRICTION_ANGLE)\n            {\n               double safeLowerBound = lowerLimit + HARDSTOP_RESTRICTION_ANGLE;\n               double safeUpperBound = upperLimit - HARDSTOP_RESTRICTION_ANGLE;"}
{"magic_number_smell": "   //   private final double maximumHeightAboveGround = 0.925;\n\n   //   // USE THESE FOR VRC Atlas Model TASK 2 UNTIL WALKING WORKS BETTER WITH OTHERS.\n   //   private double 0.785 = 0.68;\n   //   private double nominalHeightAboveGround = 0.76;\n   //   private double maximumHeightAboveGround = 0.82;\n", "refactored_code": "   //   private final double minimumHeightAboveGround = 0.785;\n   //   private final double maximumHeightAboveGround = 0.925;\n\n   //   // USE THESE FOR VRC Atlas Model TASK 2 UNTIL WALKING WORKS BETTER WITH OTHERS.\n   //   private double minimumHeightAboveGround = 0.68;\n   //   private double nominalHeightAboveGround = 0.76;\n   //   private double maximumHeightAboveGround = 0.82;\n"}
{"magic_number_smell": "      isDone.set(false);\n      planId.set(FootstepPlanningRequestPacket.NO_PLAN_ID);\n\n      for (int i = 0; i < 1; i++)\n      {\n         PathPlanningStage pathPlanningStage = createNewPathPlanningStage();\n         registry.addChild(pathPlanningStage.getYoVariableRegistry());", "refactored_code": "   private static final int initialNumberOfPathStages = 1;\n      isDone.set(false);\n      planId.set(FootstepPlanningRequestPacket.NO_PLAN_ID);\n\n      for (int i = 0; i < initialNumberOfPathStages; i++)\n      {\n         PathPlanningStage pathPlanningStage = createNewPathPlanningStage();\n         registry.addChild(pathPlanningStage.getYoVariableRegistry());"}
{"magic_number_smell": "      yPoly.setQuadratic(0.0, 1.0, bodyStartPose.getY(), Math.sin(yaw) * 0.2, bodyGoalPose.getY());\n      zPoly.setQuadratic(0.0, 1.0, bodyStartPose.getZ(), 0.0, bodyGoalPose.getZ());\n      yawPoly.setQuadratic(0.0, 1.0, bodyStartPose.getYaw(), 0.0, bodyGoalPose.getYaw());\n      for (int i = 0; i < 5; i++)\n      {\n         double percent = i / (double) (5 - 1);\n         xPoly.compute(percent);", "refactored_code": "   private static final int numberOfPoints = 5;\n      yPoly.setQuadratic(0.0, 1.0, bodyStartPose.getY(), Math.sin(yaw) * 0.2, bodyGoalPose.getY());\n      zPoly.setQuadratic(0.0, 1.0, bodyStartPose.getZ(), 0.0, bodyGoalPose.getZ());\n      yawPoly.setQuadratic(0.0, 1.0, bodyStartPose.getYaw(), 0.0, bodyGoalPose.getYaw());\n      for (int i = 0; i < numberOfPoints; i++)\n      {\n         double percent = i / (double) (numberOfPoints - 1);\n         xPoly.compute(percent);"}
{"magic_number_smell": "      timeSpentInFootstepPlanner = new YoDouble(\"timeSpentInFootstepPlanner\", registry);\n      yoResult = new YoEnum<>(\"planningResult\", registry, FootstepPlanningResult.class);\n\n      timeout.set(5.0);\n      visualizing = graphicsListRegistry != null;\n      if (visualizing)\n      {", "refactored_code": "   private static final double defaultTimeout = 5.0;\n      timeSpentInFootstepPlanner = new YoDouble(\"timeSpentInFootstepPlanner\", registry);\n      yoResult = new YoEnum<>(\"planningResult\", registry, FootstepPlanningResult.class);\n\n      timeout.set(defaultTimeout);\n      visualizing = graphicsListRegistry != null;\n      if (visualizing)\n      {"}
{"magic_number_smell": "\n      public Controller(YoGraphicsListRegistry graphicsListRegistry)\n      {\n         for (int i = 0; i < 5; i++)\n         {\n            YoFramePoint3D yoPoint = new YoFramePoint3D(\"Position\" + i, ReferenceFrame.getWorldFrame(), registry);\n            YoGraphicPosition position = new YoGraphicPosition(\"Position\" + i, yoPoint, 0.02, YoAppearance.Blue());", "refactored_code": "      private static final int numberOfPoints = 5;\n\n      public Controller(YoGraphicsListRegistry graphicsListRegistry)\n      {\n         for (int i = 0; i < numberOfPoints; i++)\n         {\n            YoFramePoint3D yoPoint = new YoFramePoint3D(\"Position\" + i, ReferenceFrame.getWorldFrame(), registry);\n            YoGraphicPosition position = new YoGraphicPosition(\"Position\" + i, yoPoint, 0.02, YoAppearance.Blue());"}
{"magic_number_smell": "      return new InterRegionConnectionFilter()\n      {\n         private final double getMaxInterRegionConnectionLength() = getMaxInterRegionConnectionLength();\n         private final double maxLengthSquared = MathTools.square(getMaxInterRegionConnectionLength());\n         private final double maxDeltaHeight = getTooHighToStepDistance();\n\n         @Override", "refactored_code": "         private final double maxLength = getMaxInterRegionConnectionLength();\n      return new InterRegionConnectionFilter()\n      {\n         private final double maxLength = getMaxInterRegionConnectionLength();\n         private final double maxLengthSquared = MathTools.square(maxLength);\n         private final double maxDeltaHeight = getTooHighToStepDistance();\n\n         @Override"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "        this.configuration = new FrameConfiguration(frameType);\n        this.position = new Position(configuration.getX(), configuration.getY());\n        this.setLocation(position.getX(), position.getY());\n        this.dimension = new Dimension(Math.max(configuration.getWidth(), 450),\n                Math.max(configuration.getHeight(), MIN_HEIGHT));\n        this.setSize(dimension.width, dimension.height);\n    }", "refactored_code": "    private static final int MIN_WIDTH = 450;\n        this.configuration = new FrameConfiguration(frameType);\n        this.position = new Position(configuration.getX(), configuration.getY());\n        this.setLocation(position.getX(), position.getY());\n        this.dimension = new Dimension(Math.max(configuration.getWidth(), MIN_WIDTH),\n                Math.max(configuration.getHeight(), MIN_HEIGHT));\n        this.setSize(dimension.width, dimension.height);\n    }"}
{"magic_number_smell": "     * During a close operation, this is the time at which we will time out all pending operations\n     * and force the RPC thread to exit. If the admin client is not closing, this will be 0.\n     */\n    private final AtomicLong hardShutdownTimeMs = new AtomicLong(-1);\n\n    /**\n     * A factory which creates TimeoutProcessors for the RPC thread.", "refactored_code": "    private static final long INVALID_SHUTDOWN_TIME = -1;\n     * During a close operation, this is the time at which we will time out all pending operations\n     * and force the RPC thread to exit. If the admin client is not closing, this will be 0.\n     */\n    private final AtomicLong hardShutdownTimeMs = new AtomicLong(INVALID_SHUTDOWN_TIME);\n\n    /**\n     * A factory which creates TimeoutProcessors for the RPC thread."}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "\n        @Override\n        public List<Pos2d> getItemInputPositions(int itemInputCount) {\n            return UIHelper.getGridPositions(itemInputCount, 16, yOrigin, 3);\n        }\n\n        @Override", "refactored_code": "        private static final int xDirMaxCount = 3;\n\n        @Override\n        public List<Pos2d> getItemInputPositions(int itemInputCount) {\n            return UIHelper.getGridPositions(itemInputCount, 16, yOrigin, xDirMaxCount);\n        }\n\n        @Override"}
{"magic_number_smell": "        GT_Multiblock_Tooltip_Builder tt = new GT_Multiblock_Tooltip_Builder();\n        tt.addInfo(\"Transcending Dimensional Boundaries.\")\n                .addInfo(\"Takes \" + EnumChatFormatting.RED\n                        + GT_Utility.formatNumbers(3600d * 8d * 20d / (3600 * 20)) + EnumChatFormatting.GRAY\n                        + \" hours of continuous run time to fully breach dimensional\")\n                .addInfo(\"boundaries and achieve maximum efficiency. This reduces fuel\")\n                .addInfo(\"consumption by up to \" + EnumChatFormatting.RED", "refactored_code": "    private static final double max_efficiency_time_in_ticks = 3600d * 8d * 20d;\n        GT_Multiblock_Tooltip_Builder tt = new GT_Multiblock_Tooltip_Builder();\n        tt.addInfo(\"Transcending Dimensional Boundaries.\")\n                .addInfo(\"Takes \" + EnumChatFormatting.RED\n                        + GT_Utility.formatNumbers(max_efficiency_time_in_ticks / (3600 * 20)) + EnumChatFormatting.GRAY\n                        + \" hours of continuous run time to fully breach dimensional\")\n                .addInfo(\"boundaries and achieve maximum efficiency. This reduces fuel\")\n                .addInfo(\"consumption by up to \" + EnumChatFormatting.RED"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    */\r\n   static class RangeProperties implements Serializable\r\n   {\r\n      private static final long 6730844584074229969L = 5627339191207625169L;\r\n      \r\n      QName qname;\r\n      String lower;\r", "refactored_code": "   private static final long serialVersionUID = 6730844584074229969L;\r\n    */\r\n   static class RangeProperties implements Serializable\r\n   {\r\n      private static final long serialVersionUID = 5627339191207625169L;\r\n      \r\n      QName qname;\r\n      String lower;\r"}
{"magic_number_smell": "  private @Nullable Component mRoot;\n\n  @GuardedBy(\"this\")\n  private int mExternalRootVersion = -1;\n\n  @GuardedBy(\"this\")\n  private int mNextResolveVersion;", "refactored_code": "  public static final int INVALID_LAYOUT_VERSION = -1;\n  private @Nullable Component mRoot;\n\n  @GuardedBy(\"this\")\n  private int mExternalRootVersion = INVALID_LAYOUT_VERSION;\n\n  @GuardedBy(\"this\")\n  private int mNextResolveVersion;"}
{"magic_number_smell": "  }\n\n  public RecyclerBinder(ComponentContext c) {\n    this(c, 4f, new LinearLayoutInfo(c, VERTICAL, false), null, false, false);\n  }\n\n  public RecyclerBinder(ComponentContext c, LayoutInfo layoutInfo) {", "refactored_code": "  public static final float DEFAULT_RANGE_RATIO = 4f;\n  }\n\n  public RecyclerBinder(ComponentContext c) {\n    this(c, DEFAULT_RANGE_RATIO, new LinearLayoutInfo(c, VERTICAL, false), null, false, false);\n  }\n\n  public RecyclerBinder(ComponentContext c, LayoutInfo layoutInfo) {"}
{"magic_number_smell": "    if (currentVrrpGroup == null) {\n      currentVrrpGroup = new VrrpGroup(group);\n      currentVrrpGroup.setPreempt(DEFAULT_VRRP_PREEMPT);\n      currentVrrpGroup.setPriority(100);\n      _currentInterface.getVrrpGroups().put(group, currentVrrpGroup);\n    }\n    _currentVrrpGroup = currentVrrpGroup;", "refactored_code": "  private static final int DEFAULT_VRRP_PRIORITY = 100;\n    if (currentVrrpGroup == null) {\n      currentVrrpGroup = new VrrpGroup(group);\n      currentVrrpGroup.setPreempt(DEFAULT_VRRP_PREEMPT);\n      currentVrrpGroup.setPriority(DEFAULT_VRRP_PRIORITY);\n      _currentInterface.getVrrpGroups().put(group, currentVrrpGroup);\n    }\n    _currentVrrpGroup = currentVrrpGroup;"}
{"magic_number_smell": "\t\t\t\tPreparedStatement ps = cntx.prepareStatement(update + column);\r\n\t\t\t\tps.executeUpdate();\r\n\t\t\t} catch (SQLException ee) {\r\n\t\t\t\tif (ee.getErrorCode() != 1060)\r\n\t\t\t\t\tTownyMessaging.sendErrorMsg(\"Error updating table \" + tableType.tableName() + \":\" + ee.getMessage());\r\n\t\t\t}\r\n\t\t}\r", "refactored_code": "\tprivate static final int MYSQL_DUPLICATE_COLUMN_ERR = 1060;\r\n\t\t\t\tPreparedStatement ps = cntx.prepareStatement(update + column);\r\n\t\t\t\tps.executeUpdate();\r\n\t\t\t} catch (SQLException ee) {\r\n\t\t\t\tif (ee.getErrorCode() != MYSQL_DUPLICATE_COLUMN_ERR)\r\n\t\t\t\t\tTownyMessaging.sendErrorMsg(\"Error updating table \" + tableType.tableName() + \":\" + ee.getMessage());\r\n\t\t\t}\r\n\t\t}\r"}
{"magic_number_smell": "\t\t\t\t\t\tfileCreate(\"payableBytecode\").path(ContractResources.PAYABLE_CONTRACT_BYTECODE_PATH),\n\t\t\t\t\t\tcontractCreate(\"payableContract\").bytecode(\"payableBytecode\").adminKey(THRESHOLD)\n\t\t\t\t).when(\n\t\t\t\t\t\tcontractCall(\"payableContract\", ContractResources.DEPOSIT_ABI, 1000)\n\t\t\t\t\t\t\t\t.via(\"payTxn\").sending(1000)\n\t\t\t\t).then(\n\t\t\t\t\t\tgetTxnRecord(\"payTxn\")", "refactored_code": "\tprivate static final long depositAmount = 1000;\n\t\t\t\t\t\tfileCreate(\"payableBytecode\").path(ContractResources.PAYABLE_CONTRACT_BYTECODE_PATH),\n\t\t\t\t\t\tcontractCreate(\"payableContract\").bytecode(\"payableBytecode\").adminKey(THRESHOLD)\n\t\t\t\t).when(\n\t\t\t\t\t\tcontractCall(\"payableContract\", ContractResources.DEPOSIT_ABI, depositAmount)\n\t\t\t\t\t\t\t\t.via(\"payTxn\").sending(depositAmount)\n\t\t\t\t).then(\n\t\t\t\t\t\tgetTxnRecord(\"payTxn\")"}
{"magic_number_smell": "                public Integer call() {\n                    eventsMonitor.updateEvents();\n                    eventPreferences.markEventsAsInitialised();\n                    return 5;\n                }\n            })\n                    .subscribe();", "refactored_code": "    private static final int A_NUMBER = 5;\n                public Integer call() {\n                    eventsMonitor.updateEvents();\n                    eventPreferences.markEventsAsInitialised();\n                    return A_NUMBER;\n                }\n            })\n                    .subscribe();"}
{"magic_number_smell": "    private static final\n    @MonthInt\n    int MONTH = 10;\n    private static final Date ANY_DATE = Date.on(5, MONTH, 1990);\n\n    @Test\n    public void whenAddingADayOfMonth_thenIncreaseNormally() {", "refactored_code": "    private static final int DAY = 5;\n    private static final\n    @MonthInt\n    int MONTH = 10;\n    private static final Date ANY_DATE = Date.on(DAY, MONTH, 1990);\n\n    @Test\n    public void whenAddingADayOfMonth_thenIncreaseNormally() {"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "\n        int minor = stream.readUnsignedShort();\n        int major = stream.readUnsignedShort();\n        if (major < 51 || major > MAJOR_VERSION_JAVA9) {\n            throw new UnsupportedClassVersionError(\"Unsupported class file version: \" + major + \".\" + minor);\n        }\n", "refactored_code": "    private static final int MAJOR_VERSION_JAVA7 = 51;\n\n        int minor = stream.readUnsignedShort();\n        int major = stream.readUnsignedShort();\n        if (major < MAJOR_VERSION_JAVA7 || major > MAJOR_VERSION_JAVA9) {\n            throw new UnsupportedClassVersionError(\"Unsupported class file version: \" + major + \".\" + minor);\n        }\n"}
{"magic_number_smell": "\n        int minor = stream.readUnsignedShort();\n        int major = stream.readUnsignedShort();\n        if (major < 51 || major > MAJOR_VERSION_JAVA9) {\n            throw new UnsupportedClassVersionError(\"Unsupported class file version: \" + major + \".\" + minor);\n        }\n", "refactored_code": "    private static final int MAJOR_VERSION_JAVA7 = 51;\n\n        int minor = stream.readUnsignedShort();\n        int major = stream.readUnsignedShort();\n        if (major < MAJOR_VERSION_JAVA7 || major > MAJOR_VERSION_JAVA9) {\n            throw new UnsupportedClassVersionError(\"Unsupported class file version: \" + major + \".\" + minor);\n        }\n"}
{"magic_number_smell": "            final StructureConstant structorDefinition = (StructureConstant) arrayConstant.getElement(i);\n            final Symbol prioritySymbol = structorDefinition.getElement(0);\n            final Integer priority = LLVMSymbolReadResolver.evaluateIntegerConstant(prioritySymbol);\n            structors.add(new Pair<>(priority != null ? priority : 65535, functionCall));\n        }\n\n        return structors.stream().sorted(priorityComparator).map(Pair::getSecond).toArray(LLVMExpressionNode[]::new);", "refactored_code": "    private static final int LEAST_CONSTRUCTOR_PRIORITY = 65535;\n            final StructureConstant structorDefinition = (StructureConstant) arrayConstant.getElement(i);\n            final Symbol prioritySymbol = structorDefinition.getElement(0);\n            final Integer priority = LLVMSymbolReadResolver.evaluateIntegerConstant(prioritySymbol);\n            structors.add(new Pair<>(priority != null ? priority : LEAST_CONSTRUCTOR_PRIORITY, functionCall));\n        }\n\n        return structors.stream().sorted(priorityComparator).map(Pair::getSecond).toArray(LLVMExpressionNode[]::new);"}
{"magic_number_smell": "        this.bitstream = bitstream;\n        this.parser = listener;\n        this.block = Block.ROOT;\n        this.idSize = 2;\n        this.offset = 0;\n    }\n", "refactored_code": "    private static final int DEFAULT_ID_SIZE = 2;\n        this.bitstream = bitstream;\n        this.parser = listener;\n        this.block = Block.ROOT;\n        this.idSize = DEFAULT_ID_SIZE;\n        this.offset = 0;\n    }\n"}
{"magic_number_smell": "    @Override\n    public String probeContentType(Path path) throws IOException {\n        long magicWord = readMagicWord(path);\n        if (magicWord == 0xdec04342L || magicWord == WRAPPER_MAGIC_WORD) {\n            return Sulong.LLVM_BITCODE_MIME_TYPE;\n        } else if (magicWord == ELF_MAGIC_WORD) {\n            return Sulong.LLVM_ELF_SHARED_MIME_TYPE;", "refactored_code": "    private static final long BC_MAGIC_WORD = 0xdec04342L; // 'BC' c0de\n    @Override\n    public String probeContentType(Path path) throws IOException {\n        long magicWord = readMagicWord(path);\n        if (magicWord == BC_MAGIC_WORD || magicWord == WRAPPER_MAGIC_WORD) {\n            return Sulong.LLVM_BITCODE_MIME_TYPE;\n        } else if (magicWord == ELF_MAGIC_WORD) {\n            return Sulong.LLVM_ELF_SHARED_MIME_TYPE;"}
{"magic_number_smell": "\n        batchCount++;\n\n        if (batchCount >= 1000) {\n          pipeline.exec();\n          pipeline.multi();\n          batchCount = 0;", "refactored_code": "      private static final int DEFAULT_BATCH_SIZE = 1000;\n\n        batchCount++;\n\n        if (batchCount >= DEFAULT_BATCH_SIZE) {\n          pipeline.exec();\n          pipeline.multi();\n          batchCount = 0;"}
{"magic_number_smell": "        systemErr = new SystemLogHolder(LoggingConstants.SYSTEM_ERR, System.err);\n\n        Timer earlyMessageTraceKiller_Timer = new Timer();\n        earlyMessageTraceKiller_Timer.schedule(new EarlyMessageTraceCleaner(), 5 * 60000); // 5 minutes wait time\n    }\n\n    /**", "refactored_code": "    private static final int MINUTE = 60000;\n        systemErr = new SystemLogHolder(LoggingConstants.SYSTEM_ERR, System.err);\n\n        Timer earlyMessageTraceKiller_Timer = new Timer();\n        earlyMessageTraceKiller_Timer.schedule(new EarlyMessageTraceCleaner(), 5 * MINUTE); // 5 minutes wait time\n    }\n\n    /**"}
{"magic_number_smell": "    RecordEventsReadableSpanImpl span = createTestSpan(Kind.INTERNAL);\n    spanDoWork(span, null);\n    Span spanProto = span.toSpanProto();\n    long timeInNanos = (startTime.getSeconds() + 1) * TimeUnit.SECONDS.toNanos(1);\n    TimedEvent timedEvent = TimedEvent.create(timeInNanos, event);\n    verifySpanProto(\n        spanProto,", "refactored_code": "  private static final long NANOS_PER_SECOND = TimeUnit.SECONDS.toNanos(1);\n    RecordEventsReadableSpanImpl span = createTestSpan(Kind.INTERNAL);\n    spanDoWork(span, null);\n    Span spanProto = span.toSpanProto();\n    long timeInNanos = (startTime.getSeconds() + 1) * NANOS_PER_SECOND;\n    TimedEvent timedEvent = TimedEvent.create(timeInNanos, event);\n    verifySpanProto(\n        spanProto,"}
{"magic_number_smell": "  public void toProtoAttributes() {\n    Attributes expected =\n        Attributes.newBuilder()\n            .setDroppedAttributesCount(1)\n            .putAttributeMap(\n                ATTRIBUTE_KEY_1,\n                io.opentelemetry.proto.trace.v1.AttributeValue.newBuilder()", "refactored_code": "  private static final int DROPPED_ATTRIBUTES_COUNT = 1;\n  public void toProtoAttributes() {\n    Attributes expected =\n        Attributes.newBuilder()\n            .setDroppedAttributesCount(DROPPED_ATTRIBUTES_COUNT)\n            .putAttributeMap(\n                ATTRIBUTE_KEY_1,\n                io.opentelemetry.proto.trace.v1.AttributeValue.newBuilder()"}
{"magic_number_smell": "            assert (variant.end() != null);\n\n            long length = Math.abs(endPosition - variant.start().position());\n            return length >= 1000;\n        }\n\n        return true;", "refactored_code": "    private static final double MIN_LENGTH = 1000;\n            assert (variant.end() != null);\n\n            long length = Math.abs(endPosition - variant.start().position());\n            return length >= MIN_LENGTH;\n        }\n\n        return true;"}
{"magic_number_smell": "                start = ratio;\n            }\n\n            endPosition = ratio.position() + 1000 - 1;\n        }\n\n        if (start != null) {", "refactored_code": "    private static final int SEGMENT_SIZE = 1000;\n                start = ratio;\n            }\n\n            endPosition = ratio.position() + SEGMENT_SIZE - 1;\n        }\n\n        if (start != null) {"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "     */\n    @SuppressWarnings(\"unused\")\n    public static int gsPasswordDeadline() {\n        return 90;\n    }\n    \n    /**", "refactored_code": "    private static final int DEFAULT_PASSWORD_DEADLINE = 90;\n     */\n    @SuppressWarnings(\"unused\")\n    public static int gsPasswordDeadline() {\n        return DEFAULT_PASSWORD_DEADLINE;\n    }\n    \n    /**"}
{"magic_number_smell": "        builder.addGroupBegin().addRuleCollection(getAggregationRules()).addGroupEnd().addMatchOrder(HepMatchOrder.BOTTOM_UP);\n        builder.addGroupBegin().addRuleCollection(getCalcRules()).addGroupEnd().addMatchOrder(HepMatchOrder.BOTTOM_UP);\n        builder.addGroupBegin().addRuleCollection(getSubQueryRules()).addGroupEnd().addMatchOrder(HepMatchOrder.BOTTOM_UP);\n        builder.addMatchLimit(1024);\n        return new HepPlanner(builder.build());\n    }\n    ", "refactored_code": "    private static final int DEFAULT_MATCH_LIMIT = 1024;\n        builder.addGroupBegin().addRuleCollection(getAggregationRules()).addGroupEnd().addMatchOrder(HepMatchOrder.BOTTOM_UP);\n        builder.addGroupBegin().addRuleCollection(getCalcRules()).addGroupEnd().addMatchOrder(HepMatchOrder.BOTTOM_UP);\n        builder.addGroupBegin().addRuleCollection(getSubQueryRules()).addGroupEnd().addMatchOrder(HepMatchOrder.BOTTOM_UP);\n        builder.addMatchLimit(DEFAULT_MATCH_LIMIT);\n        return new HepPlanner(builder.build());\n    }\n    "}
{"magic_number_smell": "        for (String each : selectStatementContext.getTablesContext().getTableNames()) {\n            ShardingSphereTable table = schema.getTable(each);\n            ShardingSpherePreconditions.checkState(null != table, () -> new NoSuchTableException(each));\n            // TODO replace 0 with actual version in ShardingSphereTable\n            result.getTableMetaDataVersions().put(table.getName(), 0);\n        }\n        return result;", "refactored_code": "    private static final int DEFAULT_METADATA_VERSION = 0;\n        for (String each : selectStatementContext.getTablesContext().getTableNames()) {\n            ShardingSphereTable table = schema.getTable(each);\n            ShardingSpherePreconditions.checkState(null != table, () -> new NoSuchTableException(each));\n            // TODO replace DEFAULT_METADATA_VERSION with actual version in ShardingSphereTable\n            result.getTableMetaDataVersions().put(table.getName(), DEFAULT_METADATA_VERSION);\n        }\n        return result;"}
{"magic_number_smell": "        Collection<String> sqlHints = Splitter.on(SQL_HINT_SPLIT).trimResults().splitToList(comment.substring(startIndex, endIndex).trim());\n        for (String each : sqlHints) {\n            List<String> hintValues = Splitter.on(SQL_HINT_VALUE_SPLIT).trimResults().splitToList(each);\n            if (2 == hintValues.size()) {\n                result.put(hintValues.get(0), hintValues.get(1));\n            }\n        }", "refactored_code": "    private static final int SQL_HINT_VALUE_SIZE = 2;\n        Collection<String> sqlHints = Splitter.on(SQL_HINT_SPLIT).trimResults().splitToList(comment.substring(startIndex, endIndex).trim());\n        for (String each : sqlHints) {\n            List<String> hintValues = Splitter.on(SQL_HINT_VALUE_SPLIT).trimResults().splitToList(each);\n            if (SQL_HINT_VALUE_SIZE == hintValues.size()) {\n                result.put(hintValues.get(0), hintValues.get(1));\n            }\n        }"}
{"magic_number_smell": "        OrderByToken orderByToken = orderByTokenGenerator.generateSQLToken(selectStatementContext);\n        assertThat(orderByToken.getColumnLabels().get(0), is(TEST_COLUMN_ORDER_BY_ITEM_SEGMENT_COLUMN_LABEL));\n        assertThat(orderByToken.getColumnLabels().get(1), is(TEST_EXPRESSION_ORDER_BY_ITEM_SEGMENT_COLUMN_LABEL));\n        assertThat(orderByToken.getColumnLabels().get(2), is(String.valueOf(5)));\n        assertThat(orderByToken.getOrderDirections().get(0), is(orderDirection));\n    }\n", "refactored_code": "    private static final int TEST_OTHER_CLASS_ORDER_BY_ITEM_INDEX = 5;\n        OrderByToken orderByToken = orderByTokenGenerator.generateSQLToken(selectStatementContext);\n        assertThat(orderByToken.getColumnLabels().get(0), is(TEST_COLUMN_ORDER_BY_ITEM_SEGMENT_COLUMN_LABEL));\n        assertThat(orderByToken.getColumnLabels().get(1), is(TEST_EXPRESSION_ORDER_BY_ITEM_SEGMENT_COLUMN_LABEL));\n        assertThat(orderByToken.getColumnLabels().get(2), is(String.valueOf(TEST_OTHER_CLASS_ORDER_BY_ITEM_INDEX)));\n        assertThat(orderByToken.getOrderDirections().get(0), is(orderDirection));\n    }\n"}
{"magic_number_smell": "\t\tp.setActive(true);\n\t\tIIdType id = ourClient.create().resource(p).execute().getId().toUnqualifiedVersionless();\n\n\t\tfor (int i = 1; i < 77; i++) {\n\t\t\tObservation obs = new Observation();\n\t\t\tobs.setId(\"A\" + StringUtils.leftPad(Integer.toString(i), 2, '0'));\n\t\t\tobs.setSubject(new Reference(id));", "refactored_code": "\tpublic static final int LARGE_NUMBER = 77;\n\t\tp.setActive(true);\n\t\tIIdType id = ourClient.create().resource(p).execute().getId().toUnqualifiedVersionless();\n\n\t\tfor (int i = 1; i < LARGE_NUMBER; i++) {\n\t\t\tObservation obs = new Observation();\n\t\t\tobs.setId(\"A\" + StringUtils.leftPad(Integer.toString(i), 2, '0'));\n\t\t\tobs.setSubject(new Reference(id));"}
{"magic_number_smell": "    private Callback<WorkbenchFx, Node> navigationDrawerFactory = workbench -> {\n      NavigationDrawer navigationDrawer = new NavigationDrawer(workbench);\n      StackPane.setAlignment(navigationDrawer, Pos.TOP_LEFT);\n      navigationDrawer.maxWidthProperty().bind(workbench.widthProperty().multiply(.333));\n      return navigationDrawer;\n    };\n", "refactored_code": "    private final double widthPercentage = .333;\n    private Callback<WorkbenchFx, Node> navigationDrawerFactory = workbench -> {\n      NavigationDrawer navigationDrawer = new NavigationDrawer(workbench);\n      StackPane.setAlignment(navigationDrawer, Pos.TOP_LEFT);\n      navigationDrawer.maxWidthProperty().bind(workbench.widthProperty().multiply(widthPercentage));\n      return navigationDrawer;\n    };\n"}
{"magic_number_smell": "        Intent intent = new Intent(context, MainActivity.class);\n\n        PendingIntent pendingIntent = PendingIntent.getActivity(context,\n                8959, intent, PendingIntent.FLAG_UPDATE_CURRENT);\n\n        Notification.Builder builder = new Notification.Builder(context)\n                .setContentTitle(String.format(getString(R.string.notification_title), trainerLevel))", "refactored_code": "    private static final int NOTIFICATION_REQ_CODE = 8959;\n        Intent intent = new Intent(context, MainActivity.class);\n\n        PendingIntent pendingIntent = PendingIntent.getActivity(context,\n                NOTIFICATION_REQ_CODE, intent, PendingIntent.FLAG_UPDATE_CURRENT);\n\n        Notification.Builder builder = new Notification.Builder(context)\n                .setContentTitle(String.format(getString(R.string.notification_title), trainerLevel))"}
{"magic_number_smell": "        boolean capped = getSpecification()\n            .getBoolean(GameOptions.BELL_ACCUMULATION_CAPPED);\n        if (capped && sonsOfLiberty >= 100) {\n            liberty = 200 * getUnitCount();\n        }\n    }\n", "refactored_code": "    public static final int LIBERTY_PER_REBEL = 200;\n        boolean capped = getSpecification()\n            .getBoolean(GameOptions.BELL_ACCUMULATION_CAPPED);\n        if (capped && sonsOfLiberty >= 100) {\n            liberty = LIBERTY_PER_REBEL * getUnitCount();\n        }\n    }\n"}
{"magic_number_smell": "     * Returns the amount of gold that this player has.\n     *\n     * @return The amount of gold that this player has.  May return\n     *     Integer.MIN_VALUE for players whose gold is not accounted.\n     */\n    public int getGold() {\n        return gold;", "refactored_code": "    public static final int GOLD_NOT_ACCOUNTED = Integer.MIN_VALUE;\n     * Returns the amount of gold that this player has.\n     *\n     * @return The amount of gold that this player has.  May return\n     *     GOLD_NOT_ACCOUNTED for players whose gold is not accounted.\n     */\n    public int getGold() {\n        return gold;"}
{"magic_number_smell": "\n        // Move back to America:\n        Unit carrier = getUnit();\n        if (!carrier.getOwner().checkGold(600)\n            || transportList.size() > 0) {\n            moveUnitToAmerica();\n        }", "refactored_code": "    private static final int MINIMUM_GOLD_TO_STAY_IN_EUROPE = 600;\n\n        // Move back to America:\n        Unit carrier = getUnit();\n        if (!carrier.getOwner().checkGold(MINIMUM_GOLD_TO_STAY_IN_EUROPE)\n            || transportList.size() > 0) {\n            moveUnitToAmerica();\n        }"}
{"magic_number_smell": "            settlement.changeMissionary(unit);\n            settlement.setConvertProgress(0);\n            List<FreeColGameObject> modifiedSettlements\n                = settlement.modifyAlarm(serverPlayer, -100);\n            modifiedSettlements.remove(settlement);\n            if (!modifiedSettlements.isEmpty()) {\n                cs.add(See.only(serverPlayer), modifiedSettlements);", "refactored_code": "    public static final int ALARM_NEW_MISSIONARY = -100;\n            settlement.changeMissionary(unit);\n            settlement.setConvertProgress(0);\n            List<FreeColGameObject> modifiedSettlements\n                = settlement.modifyAlarm(serverPlayer, ALARM_NEW_MISSIONARY);\n            modifiedSettlements.remove(settlement);\n            if (!modifiedSettlements.isEmpty()) {\n                cs.add(See.only(serverPlayer), modifiedSettlements);"}
{"magic_number_smell": "                }\n\n                // Look at the uses of tiles surrounding the settlement.\n                int alarmRadius = settlement.getRadius() + 2;\n                int alarm = 0;\n                for (Tile tile: settlement.getTile()\n                         .getSurroundingTiles(alarmRadius)) {", "refactored_code": "    public static final int ALARM_RADIUS = 2;\n                }\n\n                // Look at the uses of tiles surrounding the settlement.\n                int alarmRadius = settlement.getRadius() + ALARM_RADIUS;\n                int alarm = 0;\n                for (Tile tile: settlement.getTile()\n                         .getSurroundingTiles(alarmRadius)) {"}
{"magic_number_smell": "        showButton.setActionCommand(SHOW);\n        showButton.addActionListener(this);\n\n        add(Utility.getDefaultTextArea(message, 40), \"wrap 20\");\n        add(okButton, \"split 2, tag ok\");\n        add(showButton);\n    }", "refactored_code": "    private static final int columnWidth = 40;\n        showButton.setActionCommand(SHOW);\n        showButton.addActionListener(this);\n\n        add(Utility.getDefaultTextArea(message, columnWidth), \"wrap 20\");\n        add(okButton, \"split 2, tag ok\");\n        add(showButton);\n    }"}
{"magic_number_smell": "                        updateMetaServer();\n                    } catch (NoRouteToServerException e) {}\n                }\n            }, 60000, 60000);\n    }\n\n    /**", "refactored_code": "    private static final int META_SERVER_UPDATE_INTERVAL = 60000;\n                        updateMetaServer();\n                    } catch (NoRouteToServerException e) {}\n                }\n            }, META_SERVER_UPDATE_INTERVAL, META_SERVER_UPDATE_INTERVAL);\n    }\n\n    /**"}
{"magic_number_smell": "            canvas.showColonyPanel((Colony) unit.getTile().getSettlement());\n        } else if (unit.getMovesLeft() <= 0) {\t\n            //Perform a short pause on an active unit's last move, if the option is enabled.\n            if (freeColClient.getClientOptions().getBoolean(ClientOptions.300)) {\n                canvas.paintImmediately(canvas.getBounds());\n                try {\n                    //300 is an instance variable located at the top of this class.", "refactored_code": "    private final short UNIT_LAST_MOVE_DELAY = 300;\n            canvas.showColonyPanel((Colony) unit.getTile().getSettlement());\n        } else if (unit.getMovesLeft() <= 0) {\t\n            //Perform a short pause on an active unit's last move, if the option is enabled.\n            if (freeColClient.getClientOptions().getBoolean(ClientOptions.UNIT_LAST_MOVE_DELAY)) {\n                canvas.paintImmediately(canvas.getBounds());\n                try {\n                    //UNIT_LAST_MOVE_DELAY is an instance variable located at the top of this class."}
{"magic_number_smell": "        }\n        final byte[] data = item.data();\n        final int len = data.length;\n        if(len > 0 && (data[0] & 0x80) != 0) {\n            return isInt\n                    ? (Object) BizarroIntegers.getInt(data, 0, len)\n                    : (Object) BizarroIntegers.getLong(data, 0, len);", "refactored_code": "    private static final int SIGN_BIT_MASK = 0x80;\n        }\n        final byte[] data = item.data();\n        final int len = data.length;\n        if(len > 0 && (data[0] & SIGN_BIT_MASK) != 0) {\n            return isInt\n                    ? (Object) BizarroIntegers.getInt(data, 0, len)\n                    : (Object) BizarroIntegers.getLong(data, 0, len);"}
{"magic_number_smell": "\n        final int numProcessors = Runtime.getRuntime().availableProcessors();\n        final GambleGambleThread[] threads = new GambleGambleThread[numProcessors];\n        final int workPerProcessor = 400_000 / numProcessors;\n        int i = 0;\n        while (i < threads.length) {\n            (threads[i] = new GambleGambleThread(masterSeed + (i++), workPerProcessor))", "refactored_code": "    private static final int N = 400_000;\n\n        final int numProcessors = Runtime.getRuntime().availableProcessors();\n        final GambleGambleThread[] threads = new GambleGambleThread[numProcessors];\n        final int workPerProcessor = N / numProcessors;\n        int i = 0;\n        while (i < threads.length) {\n            (threads[i] = new GambleGambleThread(masterSeed + (i++), workPerProcessor))"}
{"magic_number_smell": "    private final TupleType inputTypes;\n    private final TupleType outputTypes;\n\n    private final byte[] selector = new byte[4];\n    private final String hashAlgorithm;\n\n    private final String stateMutability;", "refactored_code": "    public static final int SELECTOR_LEN = 4;\n    private final TupleType inputTypes;\n    private final TupleType outputTypes;\n\n    private final byte[] selector = new byte[SELECTOR_LEN];\n    private final String hashAlgorithm;\n\n    private final String stateMutability;"}
{"magic_number_smell": "                final int num = 4_000_000 + (int) Math.pow(3.7, len);\n                for (int j = 0; j < num; j++) {\n                    for (int i = 1; i < lim; i++) {\n                        temp[i] = ALPHABET[r.nextInt(ALPHABET.length)];\n                    }\n                    String sig = new String(temp);\n                    try {", "refactored_code": "    private static final int ALPHABET_LEN = ALPHABET.length;\n                final int num = 4_000_000 + (int) Math.pow(3.7, len);\n                for (int j = 0; j < num; j++) {\n                    for (int i = 1; i < lim; i++) {\n                        temp[i] = ALPHABET[r.nextInt(ALPHABET_LEN)];\n                    }\n                    String sig = new String(temp);\n                    try {"}
{"magic_number_smell": "\n        long recommendedHeartbeatInterval = serverIdleTimeoutMs / 3;\n\n        if (recommendedHeartbeatInterval < 500) {\n            recommendedHeartbeatInterval = 500;\n        }\n", "refactored_code": "    private static final long MIN_RECOMMENDED_HEARTBEAT_INTERVAL = 500;\n\n        long recommendedHeartbeatInterval = serverIdleTimeoutMs / 3;\n\n        if (recommendedHeartbeatInterval < MIN_RECOMMENDED_HEARTBEAT_INTERVAL) {\n            recommendedHeartbeatInterval = MIN_RECOMMENDED_HEARTBEAT_INTERVAL;\n        }\n"}
{"magic_number_smell": "        plc.retryLimit(1);\n\n        try (var client = getClient(plc)) {\n            for (int i = 0; i < 100; i++) {\n                assertEquals(\"t\", client.tables().tables().get(0).name());\n            }\n", "refactored_code": "    private static final int ITER = 100;\n        plc.retryLimit(1);\n\n        try (var client = getClient(plc)) {\n            for (int i = 0; i < ITER; i++) {\n                assertEquals(\"t\", client.tables().tables().get(0).name());\n            }\n"}
{"magic_number_smell": "\n    g2.setColor(gridColor);\n\n    for (int i = 0; i < height; i += 10) {\n      g2.drawLine(0, i, width, i);\n    }\n", "refactored_code": "  private static final int GRID_SIZE = 10;\n\n    g2.setColor(gridColor);\n\n    for (int i = 0; i < height; i += GRID_SIZE) {\n      g2.drawLine(0, i, width, i);\n    }\n"}
{"magic_number_smell": "    public void sizeOfListShouldBeTwo() {\n        assertThat(list)\n                .overridingErrorMessage(\"Expected size of list to be: %d but was: %d\",\n                        2,\n                        list.size()\n                )\n                .hasSize(2);", "refactored_code": "    private static final int EXPECTED_SIZE = 2;\n    public void sizeOfListShouldBeTwo() {\n        assertThat(list)\n                .overridingErrorMessage(\"Expected size of list to be: %d but was: %d\",\n                        EXPECTED_SIZE,\n                        list.size()\n                )\n                .hasSize(EXPECTED_SIZE);"}
{"magic_number_smell": "\t\t\t{\n\t\t\t\tfor(int j=0; j<dbmSize(); j++)\n\t\t\t\t{\n\t\t\t\t\tif(getDbmEntry(i, k) != Integer.MAX_VALUE && getDbmEntry(k, j) != Integer.MAX_VALUE\n\t\t\t\t\t\t\t&& getDbmEntry(i, j) > getDbmEntry(i, k) + getDbmEntry(k, j))\n\t\t\t\t\t{\n\t\t\t\t\t\tsetDbmEntry(i, j, getDbmEntry(i, k) + getDbmEntry(k, j));", "refactored_code": "\tpublic static final int INFINITY = Integer.MAX_VALUE;\n\t\t\t{\n\t\t\t\tfor(int j=0; j<dbmSize(); j++)\n\t\t\t\t{\n\t\t\t\t\tif(getDbmEntry(i, k) != INFINITY && getDbmEntry(k, j) != INFINITY\n\t\t\t\t\t\t\t&& getDbmEntry(i, j) > getDbmEntry(i, k) + getDbmEntry(k, j))\n\t\t\t\t\t{\n\t\t\t\t\t\tsetDbmEntry(i, j, getDbmEntry(i, k) + getDbmEntry(k, j));"}
{"magic_number_smell": "\t\t\t{\n\t\t\t\tfor(int j=0; j<dbmSize(); j++)\n\t\t\t\t{\n\t\t\t\t\tif(getDbmEntry(i, k) != Integer.MAX_VALUE && getDbmEntry(k, j) != Integer.MAX_VALUE\n\t\t\t\t\t\t\t&& getDbmEntry(i, j) > getDbmEntry(i, k) + getDbmEntry(k, j))\n\t\t\t\t\t{\n\t\t\t\t\t\tsetDbmEntry(i, j, getDbmEntry(i, k) + getDbmEntry(k, j));", "refactored_code": "\tpublic static final int INFINITY = Integer.MAX_VALUE;\n\t\t\t{\n\t\t\t\tfor(int j=0; j<dbmSize(); j++)\n\t\t\t\t{\n\t\t\t\t\tif(getDbmEntry(i, k) != INFINITY && getDbmEntry(k, j) != INFINITY\n\t\t\t\t\t\t\t&& getDbmEntry(i, j) > getDbmEntry(i, k) + getDbmEntry(k, j))\n\t\t\t\t\t{\n\t\t\t\t\t\tsetDbmEntry(i, j, getDbmEntry(i, k) + getDbmEntry(k, j));"}
{"magic_number_smell": "\n                // where\n                //     shipdate <= '1998-09-02'\n                if (shipDate <= DateTimeUtils.parseDate(\"1998-09-02\")) {\n                    //     returnflag,\n                    //     linestatus\n                    //     quantity", "refactored_code": "        private static final int MAX_SHIP_DATE = DateTimeUtils.parseDate(\"1998-09-02\");\n\n                // where\n                //     shipdate <= '1998-09-02'\n                if (shipDate <= MAX_SHIP_DATE) {\n                    //     returnflag,\n                    //     linestatus\n                    //     quantity"}
{"magic_number_smell": "                    maxPartialMemory,\n                    spillEnabled,\n                    unspillMemoryLimit,\n                    DataSize.succinctBytes((long) (unspillMemoryLimit.toBytes() * 0.9)),\n                    spillerFactory,\n                    joinCompiler);\n        }", "refactored_code": "    private static final double MERGE_WITH_MEMORY_RATIO = 0.9;\n                    maxPartialMemory,\n                    spillEnabled,\n                    unspillMemoryLimit,\n                    DataSize.succinctBytes((long) (unspillMemoryLimit.toBytes() * MERGE_WITH_MEMORY_RATIO)),\n                    spillerFactory,\n                    joinCompiler);\n        }"}
{"magic_number_smell": "            @Override\n            public boolean hasNext()\n            {\n                return position < groupByHash.getGroupCount();\n            }\n\n            @Override", "refactored_code": "            private final int totalPositions = groupByHash.getGroupCount();\n            @Override\n            public boolean hasNext()\n            {\n                return position < totalPositions;\n            }\n\n            @Override"}
{"magic_number_smell": "            boolean hashAggregation = operatorType.equalsIgnoreCase(\"hash\");\n\n            RowPagesBuilder pagesBuilder = RowPagesBuilder.rowPagesBuilder(hashAggregation, ImmutableList.of(0), VARCHAR, BIGINT);\n            for (int i = 0; i < 140; i++) {\n                BlockBuilder blockBuilder = VARCHAR.createBlockBuilder(null, ROWS_PER_PAGE);\n                for (int j = 0; j < groupsPerPage; j++) {\n                    String groupKey = format(\"%s\", i * groupsPerPage + j);", "refactored_code": "        public static final int TOTAL_PAGES = 140;\n            boolean hashAggregation = operatorType.equalsIgnoreCase(\"hash\");\n\n            RowPagesBuilder pagesBuilder = RowPagesBuilder.rowPagesBuilder(hashAggregation, ImmutableList.of(0), VARCHAR, BIGINT);\n            for (int i = 0; i < TOTAL_PAGES; i++) {\n                BlockBuilder blockBuilder = VARCHAR.createBlockBuilder(null, ROWS_PER_PAGE);\n                for (int j = 0; j < groupsPerPage; j++) {\n                    String groupKey = format(\"%s\", i * groupsPerPage + j);"}
{"magic_number_smell": "    @Test(dataProvider = \"hashEnabledAndMemoryLimitForMergeValues\")\n    public void testHashBuilderResize(boolean hashEnabled, boolean spillEnabled, long memoryLimitForMerge, long memoryLimitForMergeWithMemory)\n    {\n        BlockBuilder builder = VARCHAR.createBlockBuilder(null, 1, 64 * 1024);\n        VARCHAR.writeSlice(builder, Slices.allocate(200_000)); // this must be larger than 64 * 1024, 64K\n        builder.build();\n", "refactored_code": "    private static final int MAX_BLOCK_SIZE_IN_BYTES = 64 * 1024;\n    @Test(dataProvider = \"hashEnabledAndMemoryLimitForMergeValues\")\n    public void testHashBuilderResize(boolean hashEnabled, boolean spillEnabled, long memoryLimitForMerge, long memoryLimitForMergeWithMemory)\n    {\n        BlockBuilder builder = VARCHAR.createBlockBuilder(null, 1, MAX_BLOCK_SIZE_IN_BYTES);\n        VARCHAR.writeSlice(builder, Slices.allocate(200_000)); // this must be larger than MAX_BLOCK_SIZE_IN_BYTES, 64K\n        builder.build();\n"}
{"magic_number_smell": "        //Some known certs have an incorrect \"unused bits\" value, which causes problems on newer versions of BouncyCastle.\n        if(FIXSIG.contains(cert.getSubjectDN().getName())) {\n            byte[] encoded = cert.getEncoded();\n            encoded[encoded.length - 257] = 0;  // Fix the \"unused bits\" field (should always be 0).\n            cert = (X509Certificate) CertificateFactory.getInstance(\"X.509\", BC_PROVIDER).generateCertificate(new ByteArrayInputStream(encoded));\n        }\n        return cert;", "refactored_code": "    private static final int UNUSED_BITS_BYTE_INDEX_FROM_END = 257;\n        //Some known certs have an incorrect \"unused bits\" value, which causes problems on newer versions of BouncyCastle.\n        if(FIXSIG.contains(cert.getSubjectDN().getName())) {\n            byte[] encoded = cert.getEncoded();\n            encoded[encoded.length - UNUSED_BITS_BYTE_INDEX_FROM_END] = 0;  // Fix the \"unused bits\" field (should always be 0).\n            cert = (X509Certificate) CertificateFactory.getInstance(\"X.509\", BC_PROVIDER).generateCertificate(new ByteArrayInputStream(encoded));\n        }\n        return cert;"}
{"magic_number_smell": "                            .setCancelable(true)\n                            .setPositiveButton(R.string.permission_dialog_setting, new DialogInterface.OnClickListener() {\n                                public void onClick(DialogInterface dialog, int id) {\n                                    IntentUtils.intentOpenSettings(activity, 39528);\n                                }\n                            })\n                            .setNegativeButton(R.string.permission_dialog_not_now, new DialogInterface.OnClickListener() {", "refactored_code": "    private static final int REQUEST_SETTINGS = 39528;\n                            .setCancelable(true)\n                            .setPositiveButton(R.string.permission_dialog_setting, new DialogInterface.OnClickListener() {\n                                public void onClick(DialogInterface dialog, int id) {\n                                    IntentUtils.intentOpenSettings(activity, REQUEST_SETTINGS);\n                                }\n                            })\n                            .setNegativeButton(R.string.permission_dialog_not_now, new DialogInterface.OnClickListener() {"}
{"magic_number_smell": "        RedisInstanceInfo info = context.instance().getRedisInstanceInfo();\n\n        MetricData data = new MetricData(TYPE, info.getDcId(), info.getClusterId(), info.getShardId());\n        data.setValue((double) (context.getResult() / 1000));\n        data.setTimestampMilli(context.getRecvTimeMilli());\n        data.setHostPort(info.getHostPort());\n        return data;", "refactored_code": "    private static final int THOUSAND = 1000;\n        RedisInstanceInfo info = context.instance().getRedisInstanceInfo();\n\n        MetricData data = new MetricData(TYPE, info.getDcId(), info.getClusterId(), info.getShardId());\n        data.setValue((double) (context.getResult() / THOUSAND));\n        data.setTimestampMilli(context.getRecvTimeMilli());\n        data.setHostPort(info.getHostPort());\n        return data;"}
{"magic_number_smell": "\t\tList<CandidateElement> candidateElements = new ArrayList<CandidateElement>();\n\t\tint maxValues = getMaxNumberOfValues(eventableCondition.getLinkedInputFields());\n\n\t\tif (maxValues == 0) {\n\t\t\tLOGGER.warn(\"No input values found for element: \"\n\t\t\t        + DomUtils.getElementString(sourceElement));\n\t\t\treturn candidateElements;", "refactored_code": "\tprivate static final int EMPTY = 0;\n\t\tList<CandidateElement> candidateElements = new ArrayList<CandidateElement>();\n\t\tint maxValues = getMaxNumberOfValues(eventableCondition.getLinkedInputFields());\n\n\t\tif (maxValues == EMPTY) {\n\t\t\tLOGGER.warn(\"No input values found for element: \"\n\t\t\t        + DomUtils.getElementString(sourceElement));\n\t\t\treturn candidateElements;"}
{"magic_number_smell": "\t\t} else if (element.hasAttribute(\"alt\")) {\n\t\t\tret = element.getAttribute(\"alt\");\n\t\t}\n\t\tif (ret.length() > 50) {\n\t\t\treturn ret.substring(0, 50);\n\t\t} else {\n\t\t\treturn ret;", "refactored_code": "\tprivate static final int TEXT_CUTOFF = 50;\n\t\t} else if (element.hasAttribute(\"alt\")) {\n\t\t\tret = element.getAttribute(\"alt\");\n\t\t}\n\t\tif (ret.length() > TEXT_CUTOFF) {\n\t\t\treturn ret.substring(0, TEXT_CUTOFF);\n\t\t} else {\n\t\t\treturn ret;"}
{"magic_number_smell": "\t\tString element_lower = element.toLowerCase();\n\t\tString openElement = \"<\" + element_lower;\n\t\tString closeElement = \"</\" + element_lower;\n\t\twhile (i < 10000) {\n\t\t\tif (dom_lower.indexOf(openElement, position) == -1 && dom_lower.indexOf(closeElement, position) == -1) {\n\t\t\t\treturn -1;\n\t\t\t}", "refactored_code": "\tprivate static final int MAX_SEARCH_LOOPS = 10000;\n\t\tString element_lower = element.toLowerCase();\n\t\tString openElement = \"<\" + element_lower;\n\t\tString closeElement = \"</\" + element_lower;\n\t\twhile (i < MAX_SEARCH_LOOPS) {\n\t\t\tif (dom_lower.indexOf(openElement, position) == -1 && dom_lower.indexOf(closeElement, position) == -1) {\n\t\t\t\treturn -1;\n\t\t\t}"}
{"magic_number_smell": "\t@Test\n\tpublic void testWaitConditionNoIndexOutOfBounceAfterTwoTries() {\n\t\tWaitCondition wc = new WaitCondition(\"tmp\", WAIT_TIME_LONG, new TimeoutExpectedCondition());\n\t\tAssert.assertEquals(\"Wait timed out\", 0, wc.testAndWait(browser));\n\t}\n\n\t@Test", "refactored_code": "\tprivate static final int WAIT_TIMEOUT = 0;\n\t@Test\n\tpublic void testWaitConditionNoIndexOutOfBounceAfterTwoTries() {\n\t\tWaitCondition wc = new WaitCondition(\"tmp\", WAIT_TIME_LONG, new TimeoutExpectedCondition());\n\t\tAssert.assertEquals(\"Wait timed out\", WAIT_TIMEOUT, wc.testAndWait(browser));\n\t}\n\n\t@Test"}
{"magic_number_smell": "\t@Test\n\tpublic void randomValuesAreUnique() {\n\t\tSet<String> set = new HashSet<>();\n\t\tfor (int i = 0; i < 1000; i++) {\n\t\t\tassertThat(set.add(generator.getRandomString(LENGTH_MEDIUM)), is(true));\n\t\t}\n\t}", "refactored_code": "\tprivate static final int NUM_RAND_CHECKS = 1000;\n\t@Test\n\tpublic void randomValuesAreUnique() {\n\t\tSet<String> set = new HashSet<>();\n\t\tfor (int i = 0; i < NUM_RAND_CHECKS; i++) {\n\t\t\tassertThat(set.add(generator.getRandomString(LENGTH_MEDIUM)), is(true));\n\t\t}\n\t}"}
{"magic_number_smell": "  public boolean create(String storeName) throws IOException {\n    String path = formPath(storeName);\n\n    return propStore.exists(path, 0) || propStore.create(path, ArrayUtils.EMPTY_BYTE_ARRAY,\n        AccessOption.PERSISTENT);\n  }\n", "refactored_code": "  private static final int DEFAULT_OPTION = 0;\n  public boolean create(String storeName) throws IOException {\n    String path = formPath(storeName);\n\n    return propStore.exists(path, DEFAULT_OPTION) || propStore.create(path, ArrayUtils.EMPTY_BYTE_ARRAY,\n        AccessOption.PERSISTENT);\n  }\n"}
{"magic_number_smell": "\n\t/**\n\t * Convenient way to encode faces that may be null.\n\t * Null is returned as {@link #6}. \n\t * Use {@link #faceFromIndex(int)} to retrieve encoded face.\n\t */\n\tpublic static int toFaceIndex(Direction face) {", "refactored_code": "\tpublic static final int NULL_FACE_ID = 6;\n\n\t/**\n\t * Convenient way to encode faces that may be null.\n\t * Null is returned as {@link #NULL_FACE_ID}. \n\t * Use {@link #faceFromIndex(int)} to retrieve encoded face.\n\t */\n\tpublic static int toFaceIndex(Direction face) {"}
{"magic_number_smell": "\tprivate static final BlendMode[] BLEND_MODES = BlendMode.values();\n\n\tprivate static final int MathHelper.smallestEncompassingPowerOfTwo(BlendMode.values().length) - 1 = MathHelper.smallestEncompassingPowerOfTwo(BlendMode.values().length) - 1;\n\tprivate static final int COLOR_DISABLE_FLAG = MathHelper.smallestEncompassingPowerOfTwo(BlendMode.values().length) - 1 + 1;\n\tprivate static final int EMISSIVE_FLAG = COLOR_DISABLE_FLAG << 1;\n\tprivate static final int DIFFUSE_FLAG = EMISSIVE_FLAG << 1;\n\tprivate static final int AO_FLAG = DIFFUSE_FLAG << 1;", "refactored_code": "\tprivate static final int BLEND_MODE_MASK = MathHelper.smallestEncompassingPowerOfTwo(BlendMode.values().length) - 1;\n\tprivate static final BlendMode[] BLEND_MODES = BlendMode.values();\n\n\tprivate static final int BLEND_MODE_MASK = MathHelper.smallestEncompassingPowerOfTwo(BlendMode.values().length) - 1;\n\tprivate static final int COLOR_DISABLE_FLAG = BLEND_MODE_MASK + 1;\n\tprivate static final int EMISSIVE_FLAG = COLOR_DISABLE_FLAG << 1;\n\tprivate static final int DIFFUSE_FLAG = EMISSIVE_FLAG << 1;\n\tprivate static final int AO_FLAG = DIFFUSE_FLAG << 1;"}
{"magic_number_smell": "    int secs = (int)(micros / 1000000);\n    int usec = (int)(micros % 1000000);\n    int capLen = packet.length;\n    byte[] ret = new byte[4*Integer.BYTES + packet.length];\n    int offset = 0;\n    {\n      byte[] b = Bytes.toBytes(swapBytes?ByteOrderConverter.swap(secs):secs);", "refactored_code": "  public static final int PACKET_HEADER_SIZE = 4*Integer.BYTES;\n    int secs = (int)(micros / 1000000);\n    int usec = (int)(micros % 1000000);\n    int capLen = packet.length;\n    byte[] ret = new byte[PACKET_HEADER_SIZE + packet.length];\n    int offset = 0;\n    {\n      byte[] b = Bytes.toBytes(swapBytes?ByteOrderConverter.swap(secs):secs);"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    public static final Setting<TimeValue> CACHE_TTL_SETTING = Setting.timeSetting(\"cache.ttl\", DEFAULT_TTL, Setting.Property.NodeScope);\n\n    private static final int 100_000 = 100_000; //100k users\n    public static final Setting<Integer> CACHE_MAX_USERS_SETTING = Setting.intSetting(\"cache.max_users\", 100_000,\n            Setting.Property.NodeScope);\n\n    private final Cache<String, UserWithHash> cache;", "refactored_code": "    private static final int DEFAULT_MAX_USERS = 100_000; //100k users\n    public static final Setting<TimeValue> CACHE_TTL_SETTING = Setting.timeSetting(\"cache.ttl\", DEFAULT_TTL, Setting.Property.NodeScope);\n\n    private static final int DEFAULT_MAX_USERS = 100_000; //100k users\n    public static final Setting<Integer> CACHE_MAX_USERS_SETTING = Setting.intSetting(\"cache.max_users\", DEFAULT_MAX_USERS,\n            Setting.Property.NodeScope);\n\n    private final Cache<String, UserWithHash> cache;"}
{"magic_number_smell": "        Path paramFile = modelPath.resolve(String.format(\"%s-%04d.params\", modelName, epoch));\n        try (DataOutputStream dos = new DataOutputStream(Files.newOutputStream(paramFile))) {\n            dos.writeBytes(\"DJL@\");\n            dos.writeInt(1);\n            dos.writeUTF(modelName);\n            dos.writeUTF(dataType.name());\n            inputData = block.describeInput();", "refactored_code": "    private static final int MODEL_VERSION = 1;\n        Path paramFile = modelPath.resolve(String.format(\"%s-%04d.params\", modelName, epoch));\n        try (DataOutputStream dos = new DataOutputStream(Files.newOutputStream(paramFile))) {\n            dos.writeBytes(\"DJL@\");\n            dos.writeInt(MODEL_VERSION);\n            dos.writeUTF(modelName);\n            dos.writeUTF(dataType.name());\n            inputData = block.describeInput();"}
{"magic_number_smell": "            throw new IllegalArgumentException();\n        if (USE_MODULAR_ALGORITHM &&\n                (isGradedOrder(monomialOrder) || isHomogeneousIdeal(generators))\n                && (tryModular && factory.nVariables <= 3))\n            return ModularGB(generators, monomialOrder, hilbertSeries);\n        if (isGradedOrder(monomialOrder))\n            return F4GB(generators, monomialOrder, hilbertSeries);", "refactored_code": "    private static final int MODULAR_ALGORITHM_MAX_N_VARIABLES = 3;\n            throw new IllegalArgumentException();\n        if (USE_MODULAR_ALGORITHM &&\n                (isGradedOrder(monomialOrder) || isHomogeneousIdeal(generators))\n                && (tryModular && factory.nVariables <= MODULAR_ALGORITHM_MAX_N_VARIABLES))\n            return ModularGB(generators, monomialOrder, hilbertSeries);\n        if (isGradedOrder(monomialOrder))\n            return F4GB(generators, monomialOrder, hilbertSeries);"}
{"magic_number_smell": "                && b.size() > SPARSITY_SIZE_THRESHOLD\n                && a.sparsity2() > SPARSITY2_THRESHOLD\n                && b.sparsity2() > SPARSITY2_THRESHOLD\n                && (a.nVariables > 4 || (a.sparsity() > 0.2 && b.sparsity() > 0.2));\n    }\n\n    @SuppressWarnings(\"unchecked\")", "refactored_code": "    private static final double SPARSITY_THRESHOLD_NVARS_4 = 0.2;\n                && b.size() > SPARSITY_SIZE_THRESHOLD\n                && a.sparsity2() > SPARSITY2_THRESHOLD\n                && b.sparsity2() > SPARSITY2_THRESHOLD\n                && (a.nVariables > 4 || (a.sparsity() > SPARSITY_THRESHOLD_NVARS_4 && b.sparsity() > SPARSITY_THRESHOLD_NVARS_4));\n    }\n\n    @SuppressWarnings(\"unchecked\")"}
{"magic_number_smell": "                else\n                    nUnchangedInterpolations = 0;\n\n                if (nUnchangedInterpolations >= 5 || bBasePrime.compareTo(bound2) > 0)\n                    return candidate;\n\n                previousBase = candidate;", "refactored_code": "    private static final int N_UNCHANGED_INTERPOLATIONS = 5;\n                else\n                    nUnchangedInterpolations = 0;\n\n                if (nUnchangedInterpolations >= N_UNCHANGED_INTERPOLATIONS || bBasePrime.compareTo(bound2) > 0)\n                    return candidate;\n\n                previousBase = candidate;"}
{"magic_number_smell": "\n        public BabyGiantSteps(Poly poly) {\n            int n = poly.degree();\n            l = (int) Math.ceil(Math.pow(1.0 * n, 0.5));\n            m = (int) Math.ceil(1.0 * n / 2 / l);\n\n            invMod = UnivariateDivision.fastDivisionPreConditioning(poly);", "refactored_code": "    private static final double SHOUP_BETA = 0.5;\n\n        public BabyGiantSteps(Poly poly) {\n            int n = poly.degree();\n            l = (int) Math.ceil(Math.pow(1.0 * n, SHOUP_BETA));\n            m = (int) Math.ceil(1.0 * n / 2 / l);\n\n            invMod = UnivariateDivision.fastDivisionPreConditioning(poly);"}
{"magic_number_smell": "  private boolean shouldIncreaseIndex;\n\n  NavigationRouteProcessor() {\n    indices = NavigationIndices.create(0, FIRST_STEP_INDEX);\n  }\n\n  @Override", "refactored_code": "  private static final int FIRST_LEG_INDEX = 0;\n  private boolean shouldIncreaseIndex;\n\n  NavigationRouteProcessor() {\n    indices = NavigationIndices.create(FIRST_LEG_INDEX, FIRST_STEP_INDEX);\n  }\n\n  @Override"}
{"magic_number_smell": "   * @param location to be processed\n   */\n  private void queueLocationUpdateTask(Location location) {\n    thread.queueTask(1001, NewLocationModel.create(location, mapboxNavigation));\n  }\n\n  /**", "refactored_code": "  private static final int MSG_LOCATION_UPDATED = 1001;\n   * @param location to be processed\n   */\n  private void queueLocationUpdateTask(Location location) {\n    thread.queueTask(MSG_LOCATION_UPDATED, NewLocationModel.create(location, mapboxNavigation));\n  }\n\n  /**"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    public static final int JMOD_MAJOR_VERSION = 0x01;\n    public static final int JMOD_MINOR_VERSION = 0x00;\n    public static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        0x01, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {", "refactored_code": "    private static final int JMOD_MAJOR_VERSION = 0x01;\n    private static final int JMOD_MINOR_VERSION = 0x00;\n    private static final byte[] JMOD_MAGIC_NUMBER = {\n        0x4A, 0x4D, /* JM */\n        JMOD_MAJOR_VERSION, JMOD_MINOR_VERSION, /* version 1.0 */\n    };\n\n    public static void checkMagic(Path file) throws IOException {"}
{"magic_number_smell": "    List<String> lines = new ArrayList<>(fetch);\n    while (((System.currentTimeMillis() - start) < maxWaitTimeMillis) && (logLinesQueue.size() < fetch)) {\n      try {\n        Thread.sleep(100);\n      } catch (InterruptedException ex) {\n        break;\n      }", "refactored_code": "  private static final int SLEEP_TIME_WAITING_FOR_BATCH_SIZE_MS = 100;\n    List<String> lines = new ArrayList<>(fetch);\n    while (((System.currentTimeMillis() - start) < maxWaitTimeMillis) && (logLinesQueue.size() < fetch)) {\n      try {\n        Thread.sleep(SLEEP_TIME_WAITING_FOR_BATCH_SIZE_MS);\n      } catch (InterruptedException ex) {\n        break;\n      }"}
{"magic_number_smell": "\n\n  public static byte[] readHeader(InputStream inputStream) throws DataParserException {\n    byte[] headerBytes = new byte[2];\n    try {\n      IOUtils.read(inputStream, headerBytes);\n    } catch (IOException e) {", "refactored_code": "  public static final int NUMBER_HEADER_BYTES = 2;\n\n\n  public static byte[] readHeader(InputStream inputStream) throws DataParserException {\n    byte[] headerBytes = new byte[NUMBER_HEADER_BYTES];\n    try {\n      IOUtils.read(inputStream, headerBytes);\n    } catch (IOException e) {"}
{"magic_number_smell": "    zkClient = new ZkClient(zkServer.connectString(), 30000, 30000, ZKStringSerializer$.MODULE$);\n    // setup Broker\n    port = TestUtils.choosePort();\n    Properties props = TestUtils.createBrokerConfig(0, port);\n    kafkaServer = TestUtils.createServer(new KafkaConfig(props), new MockTime());\n    // create topic\n    AdminUtils.createTopic(zkClient, TOPIC1, PARTITIONS, REPLICATION_FACTOR, new Properties());", "refactored_code": "  private static final int BROKER_ID = 0;\n    zkClient = new ZkClient(zkServer.connectString(), 30000, 30000, ZKStringSerializer$.MODULE$);\n    // setup Broker\n    port = TestUtils.choosePort();\n    Properties props = TestUtils.createBrokerConfig(BROKER_ID, port);\n    kafkaServer = TestUtils.createServer(new KafkaConfig(props), new MockTime());\n    // create topic\n    AdminUtils.createTopic(zkClient, TOPIC1, PARTITIONS, REPLICATION_FACTOR, new Properties());"}
{"magic_number_smell": "    zkClient = new ZkClient(zkServer.connectString(), 30000, 30000, ZKStringSerializer$.MODULE$);\n    // setup Broker\n    port = TestUtils.choosePort();\n    Properties props = TestUtils.createBrokerConfig(0, port);\n    kafkaServer = TestUtils.createServer(new KafkaConfig(props), new MockTime());\n    // create topic\n    AdminUtils.createTopic(zkClient, TOPIC1, PARTITIONS, REPLICATION_FACTOR, new Properties());", "refactored_code": "  private static final int BROKER_ID = 0;\n    zkClient = new ZkClient(zkServer.connectString(), 30000, 30000, ZKStringSerializer$.MODULE$);\n    // setup Broker\n    port = TestUtils.choosePort();\n    Properties props = TestUtils.createBrokerConfig(BROKER_ID, port);\n    kafkaServer = TestUtils.createServer(new KafkaConfig(props), new MockTime());\n    // create topic\n    AdminUtils.createTopic(zkClient, TOPIC1, PARTITIONS, REPLICATION_FACTOR, new Properties());"}
{"magic_number_smell": "\t}\n\t\n\tprivate Ref<ACell> write(AArrayBlob key, int keyOffset, Ref<ACell> value, long indexPosition) throws IOException {\n\t\tif (keyOffset>=32) {\n\t\t\tthrow new Error(\"Offset exceeded for key: \"+key);\n\t\t}\n\t\t", "refactored_code": "\tprivate static final int KEY_SIZE=32;\n\t}\n\t\n\tprivate Ref<ACell> write(AArrayBlob key, int keyOffset, Ref<ACell> value, long indexPosition) throws IOException {\n\t\tif (keyOffset>=KEY_SIZE) {\n\t\t\tthrow new Error(\"Offset exceeded for key: \"+key);\n\t\t}\n\t\t"}
{"magic_number_smell": "\t}\n\t\n\tprivate Ref<ACell> write(AArrayBlob key, int keyOffset, Ref<ACell> value, long indexPosition) throws IOException {\n\t\tif (keyOffset>=32) {\n\t\t\tthrow new Error(\"Offset exceeded for key: \"+key);\n\t\t}\n\t\t", "refactored_code": "\tprivate static final int KEY_SIZE=32;\n\t}\n\t\n\tprivate Ref<ACell> write(AArrayBlob key, int keyOffset, Ref<ACell> value, long indexPosition) throws IOException {\n\t\tif (keyOffset>=KEY_SIZE) {\n\t\t\tthrow new Error(\"Offset exceeded for key: \"+key);\n\t\t}\n\t\t"}
{"magic_number_smell": "\n    private void serializeFooter(final ParquetMetadata footer, final OutputStream os) throws IOException {\n        final long footerIndex = writeChannel.position();\n        org.apache.parquet.format.FileMetaData parquetMetadata = metadataConverter.toParquetMetadata(1, footer);\n        writeFileMetaData(parquetMetadata, os);\n        BytesUtils.writeIntLittleEndian(os, (int) (writeChannel.position() - footerIndex));\n        os.write(ParquetFileReader.MAGIC);", "refactored_code": "    private static final int VERSION = 1;\n\n    private void serializeFooter(final ParquetMetadata footer, final OutputStream os) throws IOException {\n        final long footerIndex = writeChannel.position();\n        org.apache.parquet.format.FileMetaData parquetMetadata = metadataConverter.toParquetMetadata(VERSION, footer);\n        writeFileMetaData(parquetMetadata, os);\n        BytesUtils.writeIntLittleEndian(os, (int) (writeChannel.position() - footerIndex));\n        os.write(ParquetFileReader.MAGIC);"}
{"magic_number_smell": "                extraMetaData.put(SPECIAL_TYPE_NAME_PREFIX + colName, DBARRAY_SPECIAL_TYPE);\n            }\n        }\n        return new ParquetFileWriter(path, new LocalFSChannelProvider(), 1 << 20,\n                new HeapByteBufferAllocator(), mappedSchema.getParquetSchema(), codecName, extraMetaData);\n    }\n", "refactored_code": "    private static final int PAGE_SIZE = 1 << 20;\n                extraMetaData.put(SPECIAL_TYPE_NAME_PREFIX + colName, DBARRAY_SPECIAL_TYPE);\n            }\n        }\n        return new ParquetFileWriter(path, new LocalFSChannelProvider(), PAGE_SIZE,\n                new HeapByteBufferAllocator(), mappedSchema.getParquetSchema(), codecName, extraMetaData);\n    }\n"}
{"magic_number_smell": "        this.pageSize = pageSize;\n        this.allocator = allocator;\n        dlEncoder = column.getMaxDefinitionLevel() == 0 ? null : new RunLengthBitPackingHybridEncoder(\n                getWidthFromMaxInt(column.getMaxDefinitionLevel()), 64, pageSize, allocator);\n        rlEncoder = column.getMaxRepetitionLevel() == 0 ? null : new RunLengthBitPackingHybridEncoder(\n                getWidthFromMaxInt(column.getMaxRepetitionLevel()), 64, pageSize, allocator);\n        this.owner = owner;", "refactored_code": "    private static final int MIN_SLAB_SIZE = 64;\n        this.pageSize = pageSize;\n        this.allocator = allocator;\n        dlEncoder = column.getMaxDefinitionLevel() == 0 ? null : new RunLengthBitPackingHybridEncoder(\n                getWidthFromMaxInt(column.getMaxDefinitionLevel()), MIN_SLAB_SIZE, pageSize, allocator);\n        rlEncoder = column.getMaxRepetitionLevel() == 0 ? null : new RunLengthBitPackingHybridEncoder(\n                getWidthFromMaxInt(column.getMaxRepetitionLevel()), MIN_SLAB_SIZE, pageSize, allocator);\n        this.owner = owner;"}
{"magic_number_smell": "\n    private void serializeFooter(final ParquetMetadata footer, final OutputStream os) throws IOException {\n        final long footerIndex = writeChannel.position();\n        org.apache.parquet.format.FileMetaData parquetMetadata = metadataConverter.toParquetMetadata(1, footer);\n        writeFileMetaData(parquetMetadata, os);\n        BytesUtils.writeIntLittleEndian(os, (int) (writeChannel.position() - footerIndex));\n        os.write(ParquetFileReader.MAGIC);", "refactored_code": "    private static final int VERSION = 1;\n\n    private void serializeFooter(final ParquetMetadata footer, final OutputStream os) throws IOException {\n        final long footerIndex = writeChannel.position();\n        org.apache.parquet.format.FileMetaData parquetMetadata = metadataConverter.toParquetMetadata(VERSION, footer);\n        writeFileMetaData(parquetMetadata, os);\n        BytesUtils.writeIntLittleEndian(os, (int) (writeChannel.position() - footerIndex));\n        os.write(ParquetFileReader.MAGIC);"}
{"magic_number_smell": "        PlaybackServiceMediaPlayer psmp = new LocalPSMP(c, callback);\n        Playable p = writeTestPlayable(playableFileUrl, null);\n        psmp.playMediaObject(p, true, false, false);\n        boolean res = countDownLatch.await(3, TimeUnit.SECONDS);\n        if (assertionError != null)\n            throw assertionError;\n        assertTrue(res);", "refactored_code": "    private static final int LATCH_TIMEOUT_SECONDS = 3;\n        PlaybackServiceMediaPlayer psmp = new LocalPSMP(c, callback);\n        Playable p = writeTestPlayable(playableFileUrl, null);\n        psmp.playMediaObject(p, true, false, false);\n        boolean res = countDownLatch.await(LATCH_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n        if (assertionError != null)\n            throw assertionError;\n        assertTrue(res);"}
{"magic_number_smell": "     */\n    public void addHostedFeedData() throws IOException {\n        if (feedDataHosted) throw new IllegalStateException(\"addHostedFeedData was called twice on the same instance\");\n        for (int i = 0; i < 5; i++) {\n            Feed feed = new Feed(0, null, \"Title \" + i, \"http://example.com/\" + i, \"Description of feed \" + i,\n                    \"http://example.com/pay/feed\" + i, \"author \" + i, \"en\", Feed.TYPE_RSS2, \"feed\" + i, null, null,\n                    \"http://example.com/feed/src/\" + i, false);", "refactored_code": "    private static final int NUM_FEEDS = 5;\n     */\n    public void addHostedFeedData() throws IOException {\n        if (feedDataHosted) throw new IllegalStateException(\"addHostedFeedData was called twice on the same instance\");\n        for (int i = 0; i < NUM_FEEDS; i++) {\n            Feed feed = new Feed(0, null, \"Title \" + i, \"http://example.com/\" + i, \"Description of feed \" + i,\n                    \"http://example.com/pay/feed\" + i, \"author \" + i, \"en\", Feed.TYPE_RSS2, \"feed\" + i, null, null,\n                    \"http://example.com/feed/src/\" + i, false);"}
{"magic_number_smell": "                    xml.text(DateFormatter.formatRfc822Date(item.getPubDate()));\n                    xml.endTag(null, \"pubDate\");\n                }\n                if ((flags & 1) != 0) {\n                    xml.startTag(null, \"guid\");\n                    xml.text(item.getItemIdentifier());\n                    xml.endTag(null, \"guid\");", "refactored_code": "    public static final long FEATURE_WRITE_GUID = 1;\n                    xml.text(DateFormatter.formatRfc822Date(item.getPubDate()));\n                    xml.endTag(null, \"pubDate\");\n                }\n                if ((flags & FEATURE_WRITE_GUID) != 0) {\n                    xml.startTag(null, \"guid\");\n                    xml.text(item.getItemIdentifier());\n                    xml.endTag(null, \"guid\");"}
{"magic_number_smell": "                .setTitle(R.string.error_label)\n                .setMessage(R.string.null_value_podcast_error)\n                .setOnDismissListener(dialog1 -> {\n                    setResult(2);\n                    finish();\n                })\n                .show());", "refactored_code": "    private static final int RESULT_ERROR = 2;\n                .setTitle(R.string.error_label)\n                .setMessage(R.string.null_value_podcast_error)\n                .setOnDismissListener(dialog1 -> {\n                    setResult(RESULT_ERROR);\n                    finish();\n                })\n                .show());"}
{"magic_number_smell": "                    .replaceAll(\"\\\\s+\", \" \")\n                    .trim();\n            holder.description.setText(description);\n            holder.description.setMaxLines(2);\n        }\n        holder.description.setTag(Boolean.FALSE); // not expanded\n        holder.preview.setVisibility(View.GONE);", "refactored_code": "    private static final int MAX_LINES_COLLAPSED = 2;\n                    .replaceAll(\"\\\\s+\", \" \")\n                    .trim();\n            holder.description.setText(description);\n            holder.description.setMaxLines(MAX_LINES_COLLAPSED);\n        }\n        holder.description.setTag(Boolean.FALSE); // not expanded\n        holder.preview.setVisibility(View.GONE);"}
{"magic_number_smell": "        int viewType = getItemViewType(position);\n        if (viewType == VIEW_TYPE_SUBSCRIPTION) {\n            return itemAccess.getItem(position - getSubscriptionOffset()).id;\n        } else if (viewType == 0) {\n            return -Math.abs((long) fragmentTags.get(position).hashCode()) - 1; // Folder IDs are >0\n        } else {\n            return 0;", "refactored_code": "    public static final int VIEW_TYPE_NAV = 0;\n        int viewType = getItemViewType(position);\n        if (viewType == VIEW_TYPE_SUBSCRIPTION) {\n            return itemAccess.getItem(position - getSubscriptionOffset()).id;\n        } else if (viewType == VIEW_TYPE_NAV) {\n            return -Math.abs((long) fragmentTags.get(position).hashCode()) - 1; // Folder IDs are >0\n        } else {\n            return 0;"}
{"magic_number_smell": "    private final Activity activity;\n    private OnSelectModeListener onSelectModeListener;\n    boolean shouldSelectLazyLoadedItems = false;\n    private int totalNumberOfItems = -1;\n\n    public SelectableAdapter(Activity activity) {\n        this.activity = activity;", "refactored_code": "    public static final int COUNT_AUTOMATICALLY = -1;\n    private final Activity activity;\n    private OnSelectModeListener onSelectModeListener;\n    boolean shouldSelectLazyLoadedItems = false;\n    private int totalNumberOfItems = COUNT_AUTOMATICALLY;\n\n    public SelectableAdapter(Activity activity) {\n        this.activity = activity;"}
{"magic_number_smell": "    @Override\n    public SubscriptionViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {\n        View itemView = LayoutInflater.from(mainActivityRef.get()).inflate(R.layout.subscription_item, parent, false);\n        itemView.findViewById(R.id.titleLabel).setVisibility(viewType == 1 ? View.VISIBLE : View.GONE);\n        return new SubscriptionViewHolder(itemView);\n    }\n", "refactored_code": "    private static final int COVER_WITH_TITLE = 1;\n    @Override\n    public SubscriptionViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {\n        View itemView = LayoutInflater.from(mainActivityRef.get()).inflate(R.layout.subscription_item, parent, false);\n        itemView.findViewById(R.id.titleLabel).setVisibility(viewType == COVER_WITH_TITLE ? View.VISIBLE : View.GONE);\n        return new SubscriptionViewHolder(itemView);\n    }\n"}
{"magic_number_smell": "\n        viewBinding.enableSwitch.setChecked(SwipeActions.isSwipeActionEnabled(context, tag));\n\n        setupSwipeDirectionView(viewBinding.actionLeftContainer, 1);\n        setupSwipeDirectionView(viewBinding.actionRightContainer, RIGHT);\n\n        builder.setPositiveButton(R.string.confirm_label, (dialog, which) -> {", "refactored_code": "    private static final int LEFT = 1;\n\n        viewBinding.enableSwitch.setChecked(SwipeActions.isSwipeActionEnabled(context, tag));\n\n        setupSwipeDirectionView(viewBinding.actionLeftContainer, LEFT);\n        setupSwipeDirectionView(viewBinding.actionRightContainer, RIGHT);\n\n        builder.setPositiveButton(R.string.confirm_label, (dialog, which) -> {"}
{"magic_number_smell": "            paintDial.setStyle(Paint.Style.STROKE);\n            paintDial.setStrokeCap(Paint.Cap.ROUND);\n            paintDial.setColor(ThemeUtils.getColorFromAttr(getContext(), android.R.attr.textColorPrimary));\n            paintDial.setAlpha(120);\n\n            paintSelected.setAntiAlias(true);\n            paintSelected.setStyle(Paint.Style.STROKE);", "refactored_code": "        private static final int DIAL_ALPHA = 120;\n            paintDial.setStyle(Paint.Style.STROKE);\n            paintDial.setStrokeCap(Paint.Cap.ROUND);\n            paintDial.setColor(ThemeUtils.getColorFromAttr(getContext(), android.R.attr.textColorPrimary));\n            paintDial.setAlpha(DIAL_ALPHA);\n\n            paintSelected.setAntiAlias(true);\n            paintSelected.setStyle(Paint.Style.STROKE);"}
{"magic_number_smell": "            Log.d(TAG, \"getItem(\" + position + \")\");\n\n            switch (position) {\n                case 0:\n                    return new CoverFragment();\n                default:\n                case POS_DESCRIPTION:", "refactored_code": "    public static final int POS_COVER = 0;\n            Log.d(TAG, \"getItem(\" + position + \")\");\n\n            switch (position) {\n                case POS_COVER:\n                    return new CoverFragment();\n                default:\n                case POS_DESCRIPTION:"}
{"magic_number_smell": "\n        ItunesTopListLoader loader = new ItunesTopListLoader(getContext());\n        disposable = Observable.fromCallable(() ->\n                        loader.loadToplist(country, 25, DBReader.getFeedList()))\n                .subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(", "refactored_code": "    private static final int NUM_OF_TOP_PODCASTS = 25;\n\n        ItunesTopListLoader loader = new ItunesTopListLoader(getContext());\n        disposable = Observable.fromCallable(() ->\n                        loader.loadToplist(country, NUM_OF_TOP_PODCASTS, DBReader.getFeedList()))\n                .subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe("}
{"magic_number_smell": "                            nextPage = loadMoreData(applyPage);\n                            handler.handleAction(nextPage);\n                            applyPage++;\n                        } while (nextPage.size() == 150);\n                    }\n                })\n                .subscribeOn(Schedulers.io())", "refactored_code": "    protected static final int EPISODES_PER_PAGE = 150;\n                            nextPage = loadMoreData(applyPage);\n                            handler.handleAction(nextPage);\n                            applyPage++;\n                        } while (nextPage.size() == EPISODES_PER_PAGE);\n                    }\n                })\n                .subscribeOn(Schedulers.io())"}
{"magic_number_smell": "        // Fill with dummy elements to have a fixed height and\n        // prevent the UI elements below from jumping on slow connections\n        List<PodcastSearchResult> dummies = new ArrayList<>();\n        for (int i = 0; i < 12; i++) {\n            dummies.add(PodcastSearchResult.dummy());\n        }\n", "refactored_code": "    private static final int NUM_SUGGESTIONS = 12;\n        // Fill with dummy elements to have a fixed height and\n        // prevent the UI elements below from jumping on slow connections\n        List<PodcastSearchResult> dummies = new ArrayList<>();\n        for (int i = 0; i < NUM_SUGGESTIONS; i++) {\n            dummies.add(PodcastSearchResult.dummy());\n        }\n"}
{"magic_number_smell": "            public boolean onQueryTextChange(String s) {\n                automaticSearchDebouncer.removeCallbacksAndMessages(null);\n                if (s.isEmpty() || s.endsWith(\" \") || (lastQueryChange != 0\n                        && System.currentTimeMillis() > lastQueryChange + 1500)) {\n                    search();\n                } else {\n                    automaticSearchDebouncer.postDelayed(() -> {", "refactored_code": "    private static final int SEARCH_DEBOUNCE_INTERVAL = 1500;\n            public boolean onQueryTextChange(String s) {\n                automaticSearchDebouncer.removeCallbacksAndMessages(null);\n                if (s.isEmpty() || s.endsWith(\" \") || (lastQueryChange != 0\n                        && System.currentTimeMillis() > lastQueryChange + SEARCH_DEBOUNCE_INTERVAL)) {\n                    search();\n                } else {\n                    automaticSearchDebouncer.postDelayed(() -> {"}
{"magic_number_smell": "        for (int i = 0; i < COLUMN_CHECKBOX_IDS.length; i++) {\n            // Do this in Java to localize numbers\n            toolbar.getMenu().findItem(COLUMN_CHECKBOX_IDS[i])\n                    .setTitle(String.format(Locale.getDefault(), \"%d\", i + 2));\n        }\n        refreshToolbarState();\n", "refactored_code": "    private static final int MIN_NUM_COLUMNS = 2;\n        for (int i = 0; i < COLUMN_CHECKBOX_IDS.length; i++) {\n            // Do this in Java to localize numbers\n            toolbar.getMenu().findItem(COLUMN_CHECKBOX_IDS[i])\n                    .setTitle(String.format(Locale.getDefault(), \"%d\", i + MIN_NUM_COLUMNS));\n        }\n        refreshToolbarState();\n"}
{"magic_number_smell": "        TabLayout tabLayout = rootView.findViewById(R.id.sliding_tabs);\n        new TabLayoutMediator(tabLayout, viewPager, (tab, position) -> {\n            switch (position) {\n                case 0:\n                    tab.setText(R.string.developers);\n                    break;\n                case POS_TRANSLATORS:", "refactored_code": "    private static final int POS_DEVELOPERS = 0;\n        TabLayout tabLayout = rootView.findViewById(R.id.sliding_tabs);\n        new TabLayoutMediator(tabLayout, viewPager, (tab, position) -> {\n            switch (position) {\n                case POS_DEVELOPERS:\n                    tab.setText(R.string.developers);\n                    break;\n                case POS_TRANSLATORS:"}
{"magic_number_smell": "    private void advance() {\n        if (currentStep < STEP_FINISH) {\n            View view = viewFlipper.getChildAt(currentStep + 1);\n            if (currentStep == -1) {\n                setupHostView(view);\n            } else if (currentStep == STEP_HOSTNAME) {\n                setupLoginView(view);", "refactored_code": "    private static final int STEP_DEFAULT = -1;\n    private void advance() {\n        if (currentStep < STEP_FINISH) {\n            View view = viewFlipper.getChildAt(currentStep + 1);\n            if (currentStep == STEP_DEFAULT) {\n                setupHostView(view);\n            } else if (currentStep == STEP_HOSTNAME) {\n                setupLoginView(view);"}
{"magic_number_smell": "                MenuItemUtils.setOnClickListeners(menu, DownloadsSection.this::onContextItemSelected);\n            }\n        };\n        adapter.setDummyViews(2);\n        viewBinding.recyclerView.setAdapter(adapter);\n\n        SwipeActions swipeActions = new SwipeActions(this, CompletedDownloadsFragment.TAG);", "refactored_code": "    private static final int NUM_EPISODES = 2;\n                MenuItemUtils.setOnClickListeners(menu, DownloadsSection.this::onContextItemSelected);\n            }\n        };\n        adapter.setDummyViews(NUM_EPISODES);\n        viewBinding.recyclerView.setAdapter(adapter);\n\n        SwipeActions swipeActions = new SwipeActions(this, CompletedDownloadsFragment.TAG);"}
{"magic_number_smell": "                MenuItemUtils.setOnClickListeners(menu, EpisodesSurpriseSection.this::onContextItemSelected);\n            }\n        };\n        listAdapter.setDummyViews(8);\n        viewBinding.recyclerView.setLayoutManager(\n                new LinearLayoutManager(getContext(), RecyclerView.HORIZONTAL, false));\n        viewBinding.recyclerView.setAdapter(listAdapter);", "refactored_code": "    private static final int NUM_EPISODES = 8;\n                MenuItemUtils.setOnClickListeners(menu, EpisodesSurpriseSection.this::onContextItemSelected);\n            }\n        };\n        listAdapter.setDummyViews(NUM_EPISODES);\n        viewBinding.recyclerView.setLayoutManager(\n                new LinearLayoutManager(getContext(), RecyclerView.HORIZONTAL, false));\n        viewBinding.recyclerView.setAdapter(listAdapter);"}
{"magic_number_smell": "                MenuItemUtils.setOnClickListeners(menu, InboxSection.this::onContextItemSelected);\n            }\n        };\n        adapter.setDummyViews(2);\n        viewBinding.recyclerView.setAdapter(adapter);\n\n        SwipeActions swipeActions = new SwipeActions(this, InboxFragment.TAG);", "refactored_code": "    private static final int NUM_EPISODES = 2;\n                MenuItemUtils.setOnClickListeners(menu, InboxSection.this::onContextItemSelected);\n            }\n        };\n        adapter.setDummyViews(NUM_EPISODES);\n        viewBinding.recyclerView.setAdapter(adapter);\n\n        SwipeActions swipeActions = new SwipeActions(this, InboxFragment.TAG);"}
{"magic_number_smell": "                MenuItemUtils.setOnClickListeners(menu, QueueSection.this::onContextItemSelected);\n            }\n        };\n        listAdapter.setDummyViews(8);\n        viewBinding.recyclerView.setLayoutManager(\n                new LinearLayoutManager(getContext(), RecyclerView.HORIZONTAL, false));\n        viewBinding.recyclerView.setAdapter(listAdapter);", "refactored_code": "    private static final int NUM_EPISODES = 8;\n                MenuItemUtils.setOnClickListeners(menu, QueueSection.this::onContextItemSelected);\n            }\n        };\n        listAdapter.setDummyViews(NUM_EPISODES);\n        viewBinding.recyclerView.setLayoutManager(\n                new LinearLayoutManager(getContext(), RecyclerView.HORIZONTAL, false));\n        viewBinding.recyclerView.setAdapter(listAdapter);"}
{"magic_number_smell": "                MenuItemUtils.setOnClickListeners(contextMenu, SubscriptionsSection.this::onContextItemSelected);\n            }\n        };\n        listAdapter.setDummyViews(8);\n        viewBinding.recyclerView.setAdapter(listAdapter);\n        int paddingHorizontal = (int) (12 * getResources().getDisplayMetrics().density);\n        viewBinding.recyclerView.setPadding(paddingHorizontal, 0, paddingHorizontal, 0);", "refactored_code": "    private static final int NUM_FEEDS = 8;\n                MenuItemUtils.setOnClickListeners(contextMenu, SubscriptionsSection.this::onContextItemSelected);\n            }\n        };\n        listAdapter.setDummyViews(NUM_FEEDS);\n        viewBinding.recyclerView.setAdapter(listAdapter);\n        int paddingHorizontal = (int) (12 * getResources().getDisplayMetrics().density);\n        viewBinding.recyclerView.setPadding(paddingHorizontal, 0, paddingHorizontal, 0);"}
{"magic_number_smell": "        long firstDate = mPreferences.getLong(KEY_FIRST_START_DATE, now);\n        long diff = now - firstDate;\n        long diffDays = TimeUnit.DAYS.convert(diff, TimeUnit.MILLISECONDS);\n        return diffDays >= 14;\n    }\n}\n", "refactored_code": "    private static final int AFTER_DAYS = 14;\n        long firstDate = mPreferences.getLong(KEY_FIRST_START_DATE, now);\n        long diff = now - firstDate;\n        long diffDays = TimeUnit.DAYS.convert(diff, TimeUnit.MILLISECONDS);\n        return diffDays >= AFTER_DAYS;\n    }\n}\n"}
{"magic_number_smell": "    }\n\n    public static long getCurrentlyPlayingMediaType() {\n        return prefs.getLong(PREF_CURRENTLY_PLAYING_MEDIA_TYPE, -1);\n    }\n\n    public static long getCurrentlyPlayingFeedMediaId() {", "refactored_code": "    public static final long NO_MEDIA_PLAYING = -1;\n    }\n\n    public static long getCurrentlyPlayingMediaType() {\n        return prefs.getLong(PREF_CURRENTLY_PLAYING_MEDIA_TYPE, NO_MEDIA_PLAYING);\n    }\n\n    public static long getCurrentlyPlayingFeedMediaId() {"}
{"magic_number_smell": "    }\n\n    public static int autoEnableFrom() {\n        return prefs.getInt(PREF_AUTO_ENABLE_FROM, 22);\n    }\n\n    public static void setAutoEnableTo(int hourOfDay) {", "refactored_code": "    private static final int DEFAULT_AUTO_ENABLE_FROM = 22;\n    }\n\n    public static int autoEnableFrom() {\n        return prefs.getInt(PREF_AUTO_ENABLE_FROM, DEFAULT_AUTO_ENABLE_FROM);\n    }\n\n    public static void setAutoEnableTo(int hourOfDay) {"}
{"magic_number_smell": "        float movingAverage = prefs.getFloat(action.type, 0.5f);\n        prefs.edit()\n                .putInt(action.type + action.value, numExecutions + 1)\n                .putFloat(action.type, 0.8f * movingAverage\n                        + (1 - 0.8f) * action.value)\n                .apply();\n    }", "refactored_code": "    private static final float MOVING_AVERAGE_WEIGHT = 0.8f;\n        float movingAverage = prefs.getFloat(action.type, 0.5f);\n        prefs.edit()\n                .putInt(action.type + action.value, numExecutions + 1)\n                .putFloat(action.type, MOVING_AVERAGE_WEIGHT * movingAverage\n                        + (1 - MOVING_AVERAGE_WEIGHT) * action.value)\n                .apply();\n    }"}
{"magic_number_smell": "        builder.cookieJar(new JavaNetCookieJar(cm));\n\n        // set timeouts\n        builder.connectTimeout(10000, TimeUnit.MILLISECONDS);\n        builder.readTimeout(READ_TIMEOUT, TimeUnit.MILLISECONDS);\n        builder.writeTimeout(READ_TIMEOUT, TimeUnit.MILLISECONDS);\n        builder.cache(new Cache(cacheDirectory, 20L * 1000000)); // 20MB", "refactored_code": "    private static final int CONNECTION_TIMEOUT = 10000;\n        builder.cookieJar(new JavaNetCookieJar(cm));\n\n        // set timeouts\n        builder.connectTimeout(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);\n        builder.readTimeout(READ_TIMEOUT, TimeUnit.MILLISECONDS);\n        builder.writeTimeout(READ_TIMEOUT, TimeUnit.MILLISECONDS);\n        builder.cache(new Cache(cacheDirectory, 20L * 1000000)); // 20MB"}
{"magic_number_smell": "                out = new RandomAccessFile(destination, \"rw\");\n            }\n\n            byte[] buffer = new byte[8 * 1024];\n            int count;\n            request.setStatusMsg(R.string.download_running);\n            Log.d(TAG, \"Getting size of download\");", "refactored_code": "    private static final int BUFFER_SIZE = 8 * 1024;\n                out = new RandomAccessFile(destination, \"rw\");\n            }\n\n            byte[] buffer = new byte[BUFFER_SIZE];\n            int count;\n            request.setStatusMsg(R.string.download_running);\n            Log.d(TAG, \"Getting size of download\");"}
{"magic_number_smell": "                if (audioCompletionListener != null && playbackState == Player.STATE_ENDED) {\n                    audioCompletionListener.run();\n                } else if (bufferingUpdateListener != null && playbackState == Player.STATE_BUFFERING) {\n                    bufferingUpdateListener.accept(-1);\n                } else if (bufferingUpdateListener != null) {\n                    bufferingUpdateListener.accept(BUFFERING_ENDED);\n                }", "refactored_code": "    public static final int BUFFERING_STARTED = -1;\n                if (audioCompletionListener != null && playbackState == Player.STATE_ENDED) {\n                    audioCompletionListener.run();\n                } else if (bufferingUpdateListener != null && playbackState == Player.STATE_BUFFERING) {\n                    bufferingUpdateListener.accept(BUFFERING_STARTED);\n                } else if (bufferingUpdateListener != null) {\n                    bufferingUpdateListener.accept(BUFFERING_ENDED);\n                }"}
{"magic_number_smell": "        if (parentId.equals(getResources().getString(R.string.queue_label))) {\n            feedItems = DBReader.getQueue();\n        } else if (parentId.equals(getResources().getString(R.string.downloads_label))) {\n            feedItems = DBReader.getEpisodes(0, 100,\n                    new FeedItemFilter(FeedItemFilter.DOWNLOADED), UserPreferences.getDownloadsSortedOrder());\n        } else if (parentId.equals(getResources().getString(R.string.episodes_label))) {\n            feedItems = DBReader.getEpisodes(0, 100,", "refactored_code": "    public static final int MAX_ANDROID_AUTO_EPISODES_PER_FEED = 100;\n        if (parentId.equals(getResources().getString(R.string.queue_label))) {\n            feedItems = DBReader.getQueue();\n        } else if (parentId.equals(getResources().getString(R.string.downloads_label))) {\n            feedItems = DBReader.getEpisodes(0, MAX_ANDROID_AUTO_EPISODES_PER_FEED,\n                    new FeedItemFilter(FeedItemFilter.DOWNLOADED), UserPreferences.getDownloadsSortedOrder());\n        } else if (parentId.equals(getResources().getString(R.string.episodes_label))) {\n            feedItems = DBReader.getEpisodes(0, MAX_ANDROID_AUTO_EPISODES_PER_FEED,"}
{"magic_number_smell": "        if (!isPositionSaverActive()) {\n            Runnable positionSaver = callback::positionSaverTick;\n            positionSaver = useMainThreadIfNecessary(positionSaver);\n            positionSaverFuture = schedExecutor.scheduleWithFixedDelay(positionSaver, 5000,\n                    5000, TimeUnit.MILLISECONDS);\n\n            Log.d(TAG, \"Started PositionSaver\");", "refactored_code": "    public static final int POSITION_SAVER_WAITING_INTERVAL = 5000;\n        if (!isPositionSaverActive()) {\n            Runnable positionSaver = callback::positionSaverTick;\n            positionSaver = useMainThreadIfNecessary(positionSaver);\n            positionSaverFuture = schedExecutor.scheduleWithFixedDelay(positionSaver, POSITION_SAVER_WAITING_INTERVAL,\n                    POSITION_SAVER_WAITING_INTERVAL, TimeUnit.MILLISECONDS);\n\n            Log.d(TAG, \"Started PositionSaver\");"}
{"magic_number_smell": "     * Loads the download log from the database.\n     *\n     * @return A list with DownloadStatus objects that represent the download log.\n     * The size of the returned list is limited by {@link #200}.\n     */\n    public static List<DownloadResult> getDownloadLog() {\n        Log.d(TAG, \"getDownloadLog() called\");", "refactored_code": "    private static final int DOWNLOAD_LOG_SIZE = 200;\n     * Loads the download log from the database.\n     *\n     * @return A list with DownloadStatus objects that represent the download log.\n     * The size of the returned list is limited by {@link #DOWNLOAD_LOG_SIZE}.\n     */\n    public static List<DownloadResult> getDownloadLog() {\n        Log.d(TAG, \"getDownloadLog() called\");"}
{"magic_number_smell": "    }\n\n    private static int[] millisecondsToHms(long duration) {\n        int h = (int) (duration / 3600000);\n        long rest = duration - h * 3600000;\n        int m = (int) (rest / MINUTES_MIL);\n        rest -= m * MINUTES_MIL;", "refactored_code": "    private static final int HOURS_MIL = 3600000;\n    }\n\n    private static int[] millisecondsToHms(long duration) {\n        int h = (int) (duration / HOURS_MIL);\n        long rest = duration - h * HOURS_MIL;\n        int m = (int) (rest / MINUTES_MIL);\n        rest -= m * MINUTES_MIL;"}
{"magic_number_smell": "        String filename = buf.toString().trim();\n        if (TextUtils.isEmpty(filename)) {\n            return randomString(8);\n        } else if (filename.length() >= 242) {\n            return filename.substring(0, 242 - MD5_HEX_LENGTH - 1) + \"_\" + md5(filename);\n        } else {\n            return filename;", "refactored_code": "    public static final int MAX_FILENAME_LENGTH = 242; // limited by CircleCI\n        String filename = buf.toString().trim();\n        if (TextUtils.isEmpty(filename)) {\n            return randomString(8);\n        } else if (filename.length() >= MAX_FILENAME_LENGTH) {\n            return filename.substring(0, MAX_FILENAME_LENGTH - MD5_HEX_LENGTH - 1) + \"_\" + md5(filename);\n        } else {\n            return filename;"}
{"magic_number_smell": "    }\n\n    /**\n     * Send a {@link #2} log message.\n     * @param tag Used to identify the source of a log message.  It usually identifies\n     *        the class or activity where the log call occurs.\n     * @param msg The message you would like logged.", "refactored_code": "    public static final int VERBOSE = 2;\n    }\n\n    /**\n     * Send a {@link #VERBOSE} log message.\n     * @param tag Used to identify the source of a log message.  It usually identifies\n     *        the class or activity where the log call occurs.\n     * @param msg The message you would like logged."}
{"magic_number_smell": "    private static final String MIME_TYPE = \"audio/mp3\";\n\n    static FeedMedia anyFeedMedia() {\n        return new FeedMedia(null, EPISODE_URL, 42, MIME_TYPE);\n    }\n\n}", "refactored_code": "    private static final long SIZE = 42;\n    private static final String MIME_TYPE = \"audio/mp3\";\n\n    static FeedMedia anyFeedMedia() {\n        return new FeedMedia(null, EPISODE_URL, SIZE, MIME_TYPE);\n    }\n\n}"}
{"magic_number_smell": "        Playable noFeedMedia = mock(Playable.class);\n        when(mediaPlayer.getPlayable()).thenReturn(noFeedMedia);\n\n        playbackVolumeUpdater.updateVolumeIfNecessary(mediaPlayer, 42, VolumeAdaptionSetting.OFF);\n\n        verify(mediaPlayer, never()).pause(anyBoolean(), anyBoolean());\n        verify(mediaPlayer, never()).resume();", "refactored_code": "    private static final long FEED_ID = 42;\n        Playable noFeedMedia = mock(Playable.class);\n        when(mediaPlayer.getPlayable()).thenReturn(noFeedMedia);\n\n        playbackVolumeUpdater.updateVolumeIfNecessary(mediaPlayer, FEED_ID, VolumeAdaptionSetting.OFF);\n\n        verify(mediaPlayer, never()).pause(anyBoolean(), anyBoolean());\n        verify(mediaPlayer, never()).resume();"}
{"magic_number_smell": "\n        SharedPreferences.Editor prefEdit = PreferenceManager.getDefaultSharedPreferences(context\n                .getApplicationContext()).edit();\n        prefEdit.putString(UserPreferences.PREF_EPISODE_CACHE_SIZE, Integer.toString(5));\n        prefEdit.putString(UserPreferences.PREF_EPISODE_CLEANUP,\n                Integer.toString(UserPreferences.EPISODE_CLEANUP_NULL));\n        prefEdit.commit();", "refactored_code": "    private static final int EPISODE_CACHE_SIZE = 5;\n\n        SharedPreferences.Editor prefEdit = PreferenceManager.getDefaultSharedPreferences(context\n                .getApplicationContext()).edit();\n        prefEdit.putString(UserPreferences.PREF_EPISODE_CACHE_SIZE, Integer.toString(EPISODE_CACHE_SIZE));\n        prefEdit.putString(UserPreferences.PREF_EPISODE_CLEANUP,\n                Integer.toString(UserPreferences.EPISODE_CLEANUP_NULL));\n        prefEdit.commit();"}
{"magic_number_smell": "                \"dummy path\", \"download_url\", true, null, 0, 0);\n        item.setMedia(media);\n\n        DBWriter.setFeedItem(item).get(5L, TimeUnit.SECONDS);\n\n        media.setPosition(position);\n        media.setLastPlayedTime(lastPlayedTime);", "refactored_code": "    private static final long TIMEOUT = 5L;\n                \"dummy path\", \"download_url\", true, null, 0, 0);\n        item.setMedia(media);\n\n        DBWriter.setFeedItem(item).get(TIMEOUT, TimeUnit.SECONDS);\n\n        media.setPosition(position);\n        media.setLastPlayedTime(lastPlayedTime);"}
{"magic_number_smell": "        List<FeedItem> items = new ArrayList<>();\n        feed.setItems(items);\n        List<File> files = new ArrayList<>();\n        populateItems(EPISODE_CACHE_SIZE * 2, feed, items, files, FeedItem.UNPLAYED, false, false);\n\n        DBTasks.performAutoCleanup(context);\n        for (int i = 0; i < files.size(); i++) {", "refactored_code": "    private final int numberOfItems = EPISODE_CACHE_SIZE * 2;\n        List<FeedItem> items = new ArrayList<>();\n        feed.setItems(items);\n        List<File> files = new ArrayList<>();\n        populateItems(numberOfItems, feed, items, files, FeedItem.UNPLAYED, false, false);\n\n        DBTasks.performAutoCleanup(context);\n        for (int i = 0; i < files.size(); i++) {"}
{"magic_number_smell": " */\npublic class FeedItemDuplicateGuesserTest {\n    private static final long 1000 * 60 = 1000 * 60;\n    private static final long DAYS = 24 * 60 * 1000 * 60;\n\n    @Test\n    public void testSameId() {", "refactored_code": "    private static final long MINUTES = 1000 * 60;\n */\npublic class FeedItemDuplicateGuesserTest {\n    private static final long MINUTES = 1000 * 60;\n    private static final long DAYS = 24 * 60 * MINUTES;\n\n    @Test\n    public void testSameId() {"}
{"magic_number_smell": "        public static final long 101 = 101;\n\n        /**\n         * Add a FeedItem with ID {@link #101} with the setup\n         */\n        @Test\n        public void test() {", "refactored_code": "        public static final long TFI_ID = 101;\n        public static final long TFI_ID = 101;\n\n        /**\n         * Add a FeedItem with ID {@link #TFI_ID} with the setup\n         */\n        @Test\n        public void test() {"}
{"magic_number_smell": "    }\n\n    public static BufferUpdateEvent started() {\n        return new BufferUpdateEvent(-1);\n    }\n\n    public static BufferUpdateEvent ended() {", "refactored_code": "    private static final float PROGRESS_STARTED = -1;\n    }\n\n    public static BufferUpdateEvent started() {\n        return new BufferUpdateEvent(PROGRESS_STARTED);\n    }\n\n    public static BufferUpdateEvent ended() {"}
{"magic_number_smell": "    }\n\n    public static SleepTimerUpdatedEvent cancelled() {\n        return new SleepTimerUpdatedEvent(Long.MAX_VALUE);\n    }\n\n    public long getTimeLeft() {", "refactored_code": "    private static final long CANCELLED = Long.MAX_VALUE;\n    }\n\n    public static SleepTimerUpdatedEvent cancelled() {\n        return new SleepTimerUpdatedEvent(CANCELLED);\n    }\n\n    public long getTimeLeft() {"}
{"magic_number_smell": "\n    @Override\n    public int getTypeAsInt() {\n        return 0;\n    }\n\n    public String getTitle() {", "refactored_code": "    public static final int FEEDFILETYPE_FEED = 0;\n\n    @Override\n    public int getTypeAsInt() {\n        return FEEDFILETYPE_FEED;\n    }\n\n    public String getTitle() {"}
{"magic_number_smell": "    }\n\n    public boolean isNew() {\n        return state == -1;\n    }\n\n    public int getPlayState() {", "refactored_code": "    public static final int NEW = -1;\n    }\n\n    public boolean isNew() {\n        return state == NEW;\n    }\n\n    public int getPlayState() {"}
{"magic_number_smell": "\n    @Override\n    public int getTypeAsInt() {\n        return 2;\n    }\n\n    public int getDuration() {", "refactored_code": "    public static final int FEEDFILETYPE_FEEDMEDIA = 2;\n\n    @Override\n    public int getTypeAsInt() {\n        return FEEDFILETYPE_FEEDMEDIA;\n    }\n\n    public int getDuration() {"}
{"magic_number_smell": "                           VolumeAdaptionSetting volumeAdaptionSetting, NewEpisodesAction newEpisodesAction,\n                           String username, String password) {\n        this(feedID, autoDownload, true, autoDeleteAction, volumeAdaptionSetting, username, password,\n                new FeedFilter(), -1, 0, 0, false, newEpisodesAction, new HashSet<>());\n    }\n\n    public FeedPreferences(long feedID, boolean autoDownload, boolean keepUpdated,", "refactored_code": "    public static final float SPEED_USE_GLOBAL = -1;\n                           VolumeAdaptionSetting volumeAdaptionSetting, NewEpisodesAction newEpisodesAction,\n                           String username, String password) {\n        this(feedID, autoDownload, true, autoDeleteAction, volumeAdaptionSetting, username, password,\n                new FeedFilter(), SPEED_USE_GLOBAL, 0, 0, false, newEpisodesAction, new HashSet<>());\n    }\n\n    public FeedPreferences(long feedID, boolean autoDownload, boolean keepUpdated,"}
{"magic_number_smell": "\n    @Override\n    public int getPlayableType() {\n        return 3;\n    }\n\n    @Override", "refactored_code": "    public static final int PLAYABLE_TYPE_REMOTE_MEDIA = 3;\n\n    @Override\n    public int getPlayableType() {\n        return PLAYABLE_TYPE_REMOTE_MEDIA;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    private String getTopListFeed(OkHttpClient client, String country) throws IOException {\n        String url = \"https://itunes.apple.com/%s/rss/toppodcasts/limit=\" + 25 + \"/explicit=true/json\";\n        Log.d(TAG, \"Feed URL \" + String.format(url, country));\n        Request.Builder httpReq = new Request.Builder()\n                .cacheControl(new CacheControl.Builder().maxStale(1, TimeUnit.DAYS).build())", "refactored_code": "    private static final int NUM_LOADED = 25;\n    }\n\n    private String getTopListFeed(OkHttpClient client, String country) throws IOException {\n        String url = \"https://itunes.apple.com/%s/rss/toppodcasts/limit=\" + NUM_LOADED + \"/explicit=true/json\";\n        Log.d(TAG, \"Feed URL \" + String.format(url, country));\n        Request.Builder httpReq = new Request.Builder()\n                .cacheControl(new CacheControl.Builder().maxStale(1, TimeUnit.DAYS).build())"}
{"magic_number_smell": "    public UploadChangesResponse uploadEpisodeActions(List<EpisodeAction> episodeActions) throws SyncServiceException {\n        requireLoggedIn();\n        UploadChangesResponse response = null;\n        for (int i = 0; i < episodeActions.size(); i += 30) {\n            response = uploadEpisodeActionsPartial(episodeActions,\n                    i, Math.min(episodeActions.size(), i + 30));\n        }", "refactored_code": "    private static final int UPLOAD_BULK_SIZE = 30;\n    public UploadChangesResponse uploadEpisodeActions(List<EpisodeAction> episodeActions) throws SyncServiceException {\n        requireLoggedIn();\n        UploadChangesResponse response = null;\n        for (int i = 0; i < episodeActions.size(); i += UPLOAD_BULK_SIZE) {\n            response = uploadEpisodeActionsPartial(episodeActions,\n                    i, Math.min(episodeActions.size(), i + UPLOAD_BULK_SIZE));\n        }"}
{"magic_number_smell": "    @Override\n    public UploadChangesResponse uploadEpisodeActions(List<EpisodeAction> queuedEpisodeActions)\n            throws NextcloudSynchronizationServiceException {\n        for (int i = 0; i < queuedEpisodeActions.size(); i += 30) {\n            uploadEpisodeActionsPartial(queuedEpisodeActions,\n                    i, Math.min(queuedEpisodeActions.size(), i + 30));\n        }", "refactored_code": "    private static final int UPLOAD_BULK_SIZE = 30;\n    @Override\n    public UploadChangesResponse uploadEpisodeActions(List<EpisodeAction> queuedEpisodeActions)\n            throws NextcloudSynchronizationServiceException {\n        for (int i = 0; i < queuedEpisodeActions.size(); i += UPLOAD_BULK_SIZE) {\n            uploadEpisodeActionsPartial(queuedEpisodeActions,\n                    i, Math.min(queuedEpisodeActions.size(), i + UPLOAD_BULK_SIZE));\n        }"}
{"magic_number_smell": "                if (MIME_IMAGE_URL.equals(mime)) {\n                    String link = readIsoStringNullTerminated(frameHeader.getSize());\n                    Log.d(TAG, \"Link: \" + link);\n                    if (TextUtils.isEmpty(chapter.getImageUrl()) || type == 3) {\n                        chapter.setImageUrl(link);\n                    }\n                } else {", "refactored_code": "    public static final int IMAGE_TYPE_COVER = 3;\n                if (MIME_IMAGE_URL.equals(mime)) {\n                    String link = readIsoStringNullTerminated(frameHeader.getSize());\n                    Log.d(TAG, \"Link: \" + link);\n                    if (TextUtils.isEmpty(chapter.getImageUrl()) || type == IMAGE_TYPE_COVER) {\n                        chapter.setImageUrl(link);\n                    }\n                } else {"}
{"magic_number_smell": "\n    @NonNull\n    FrameHeader readFrameHeader() throws IOException {\n        String id = readPlainBytesToString(4);\n        int size = readInt();\n        if (tagHeader != null && tagHeader.getVersion() >= 0x0400) {\n            size = unsynchsafe(size);", "refactored_code": "    private static final int FRAME_ID_LENGTH = 4;\n\n    @NonNull\n    FrameHeader readFrameHeader() throws IOException {\n        String id = readPlainBytesToString(FRAME_ID_LENGTH);\n        int size = readInt();\n        if (tagHeader != null && tagHeader.getVersion() >= 0x0400) {\n            size = unsynchsafe(size);"}
{"magic_number_smell": "     * @throws VorbisCommentReaderException\n     * */\n    private static int getIdFromKey(String key) throws VorbisCommentReaderException {\n        if (key.length() >= \"chapterxxx\".length()) { // >= CHAPTERxxx\n            try {\n                String strId = key.substring(8, 10);\n                return Integer.parseInt(strId);", "refactored_code": "    private static final int CHAPTERXXX_LENGTH = \"chapterxxx\".length();\n     * @throws VorbisCommentReaderException\n     * */\n    private static int getIdFromKey(String key) throws VorbisCommentReaderException {\n        if (key.length() >= CHAPTERXXX_LENGTH) { // >= CHAPTERxxx\n            try {\n                String strId = key.substring(8, 10);\n                return Integer.parseInt(strId);"}
{"magic_number_smell": "        final byte[] oggIdentificationHeader = new byte[]{ PACKET_TYPE_IDENTIFICATION, 'v', 'o', 'r', 'b', 'i', 's' };\n        for (int i = 6; i < buffer.length; i++) {\n            if (bufferMatches(buffer, oggIdentificationHeader, i)) {\n                IOUtils.skip(input, 58 - FIRST_OPUS_PAGE_LENGTH);\n                return;\n            } else if (bufferMatches(buffer, \"OpusHead\".getBytes(), i)) {\n                return;", "refactored_code": "    private static final int FIRST_OGG_PAGE_LENGTH = 58;\n        final byte[] oggIdentificationHeader = new byte[]{ PACKET_TYPE_IDENTIFICATION, 'v', 'o', 'r', 'b', 'i', 's' };\n        for (int i = 6; i < buffer.length; i++) {\n            if (bufferMatches(buffer, oggIdentificationHeader, i)) {\n                IOUtils.skip(input, FIRST_OGG_PAGE_LENGTH - FIRST_OPUS_PAGE_LENGTH);\n                return;\n            } else if (bufferMatches(buffer, \"OpusHead\".getBytes(), i)) {\n                return;"}
{"magic_number_smell": "                rewindTime = LONG_REWIND;\n            } else if (elapsedTime > ELAPSED_TIME_FOR_MEDIUM_REWIND) {\n                rewindTime = MEDIUM_REWIND;\n            } else if (elapsedTime > TimeUnit.MINUTES.toMillis(1)) {\n                rewindTime = SHORT_REWIND;\n            }\n", "refactored_code": "    public static final long ELAPSED_TIME_FOR_SHORT_REWIND = TimeUnit.MINUTES.toMillis(1);\n                rewindTime = LONG_REWIND;\n            } else if (elapsedTime > ELAPSED_TIME_FOR_MEDIUM_REWIND) {\n                rewindTime = MEDIUM_REWIND;\n            } else if (elapsedTime > ELAPSED_TIME_FOR_SHORT_REWIND) {\n                rewindTime = SHORT_REWIND;\n            }\n"}
{"magic_number_smell": "        int version = metadata.getInt(KEY_FORMAT_VERSION);\n        if (version <= 0 || version > MAX_VERSION_FORWARD_COMPATIBILITY) {\n            Log.w(TAG, \"MediaInfo object obtained from the cast device is not compatible with this\"\n                    + \"version of AntennaPod CastUtils, curVer=\" + 1\n                    + \", object version=\" + version);\n            return null;\n        }", "refactored_code": "    public static final int FORMAT_VERSION_VALUE = 1;\n        int version = metadata.getInt(KEY_FORMAT_VERSION);\n        if (version <= 0 || version > MAX_VERSION_FORWARD_COMPATIBILITY) {\n            Log.w(TAG, \"MediaInfo object obtained from the cast device is not compatible with this\"\n                    + \"version of AntennaPod CastUtils, curVer=\" + FORMAT_VERSION_VALUE\n                    + \", object version=\" + version);\n            return null;\n        }"}
{"magic_number_smell": "         * @param factory to use for creating cursor objects\n         */\n        public PodDBHelper(final Context context, final String name, final CursorFactory factory) {\n            super(context, name, factory, 3010000, new PodDbErrorHandler());\n        }\n\n        @Override", "refactored_code": "    public static final int VERSION = 3010000;\n         * @param factory to use for creating cursor objects\n         */\n        public PodDBHelper(final Context context, final String name, final CursorFactory factory) {\n            super(context, name, factory, VERSION, new PodDbErrorHandler());\n        }\n\n        @Override"}
{"magic_number_smell": "\npublic class CircularProgressBar extends View {\n    public static final float 0.005f = 0.005f;\n    public static final float MAXIMUM_PERCENTAGE = 1 - 0.005f;\n    private static final PathEffect DASHED = new DashPathEffect(new float[] {5f, 5f}, 0f);\n\n    private final Paint paintBackground = new Paint();", "refactored_code": "    public static final float MINIMUM_PERCENTAGE = 0.005f;\n\npublic class CircularProgressBar extends View {\n    public static final float MINIMUM_PERCENTAGE = 0.005f;\n    public static final float MAXIMUM_PERCENTAGE = 1 - MINIMUM_PERCENTAGE;\n    private static final PathEffect DASHED = new DashPathEffect(new float[] {5f, 5f}, 0f);\n\n    private final Paint paintBackground = new Paint();"}
{"magic_number_smell": "    public static final int DIRECTION_HEIGHT = 1;\n    public static final int DIRECTION_MINIMUM = 2;\n\n    private int direction = 0;\n\n    public SquareImageView(Context context) {\n        super(context);", "refactored_code": "    public static final int DIRECTION_WIDTH = 0;\n    public static final int DIRECTION_HEIGHT = 1;\n    public static final int DIRECTION_MINIMUM = 2;\n\n    private int direction = DIRECTION_WIDTH;\n\n    public SquareImageView(Context context) {\n        super(context);"}
{"magic_number_smell": "\n        // rotate\n        if (corner.left()) {\n            canvas.rotate(-45, 0, height);\n        } else {\n            canvas.rotate(DEGREES_RIGHT, width, height);\n        }", "refactored_code": "    private static final int DEGREES_LEFT = -45;\n\n        // rotate\n        if (corner.left()) {\n            canvas.rotate(DEGREES_LEFT, 0, height);\n        } else {\n            canvas.rotate(DEGREES_RIGHT, width, height);\n        }"}
{"magic_number_smell": "            new ShareCompat.IntentBuilder(this)\n                    .setType(\"image/png\")\n                    .addStream(fileUri)\n                    .setText(getString(R.string.echo_share, 2023))\n                    .setChooserTitle(R.string.share_file_label)\n                    .startChooser();\n        } catch (Exception e) {", "refactored_code": "    public static final int RELEASE_YEAR = 2023;\n            new ShareCompat.IntentBuilder(this)\n                    .setType(\"image/png\")\n                    .addStream(fileUri)\n                    .setText(getString(R.string.echo_share, RELEASE_YEAR))\n                    .setChooserTitle(R.string.share_file_label)\n                    .startChooser();\n        } catch (Exception e) {"}
{"magic_number_smell": "        super(context);\n        for (int i = 0; i < NUM_PARTICLES; i++) {\n            particles.add(new Particle(Math.random(), 2.0 * Math.random() - 0.5, // Could already be off-screen\n                    0, 0.00002 + 2 * 0.00002 * Math.random()));\n        }\n    }\n", "refactored_code": "    protected static final double PARTICLE_SPEED = 0.00002;\n        super(context);\n        for (int i = 0; i < NUM_PARTICLES; i++) {\n            particles.add(new Particle(Math.random(), 2.0 * Math.random() - 0.5, // Could already be off-screen\n                    0, PARTICLE_SPEED + 2 * PARTICLE_SPEED * Math.random()));\n        }\n    }\n"}
{"magic_number_smell": "\n    public StripesScreen(Context context) {\n        super(context);\n        for (int i = 0; i < 15; i++) {\n            particles.add(new Particle(2f * i / 15 - 1f, 0, 0, 0));\n        }\n    }", "refactored_code": "    protected static final int NUM_PARTICLES = 15;\n\n    public StripesScreen(Context context) {\n        super(context);\n        for (int i = 0; i < NUM_PARTICLES; i++) {\n            particles.add(new Particle(2f * i / NUM_PARTICLES - 1f, 0, 0, 0));\n        }\n    }"}
{"magic_number_smell": "\n    public WaveformScreen(Context context) {\n        super(context);\n        for (int i = 0; i < 40; i++) {\n            particles.add(new Particle(1.1f + 1.1f * i / 40 - 0.05f, 0, 0, 0));\n        }\n    }", "refactored_code": "    protected static final int NUM_PARTICLES = 40;\n\n    public WaveformScreen(Context context) {\n        super(context);\n        for (int i = 0; i < NUM_PARTICLES; i++) {\n            particles.add(new Particle(1.1f + 1.1f * i / NUM_PARTICLES - 0.05f, 0, 0, 0));\n        }\n    }"}
{"magic_number_smell": "    public WavesScreen(Context context) {\n        super(context);\n        paintParticles.setStyle(Paint.Style.STROKE);\n        for (int i = 0; i < 10; i++) {\n            particles.add(new Particle(0, 0, 1.0f * i / 10, 0));\n        }\n    }", "refactored_code": "    protected static final int NUM_PARTICLES = 10;\n    public WavesScreen(Context context) {\n        super(context);\n        paintParticles.setStyle(Paint.Style.STROKE);\n        for (int i = 0; i < NUM_PARTICLES; i++) {\n            particles.add(new Particle(0, 0, 1.0f * i / NUM_PARTICLES, 0));\n        }\n    }"}
{"magic_number_smell": "        builder.setLogLevel(Log.WARN);\n        @SuppressLint(\"UsableSpace\")\n        long spaceAvailable = context.getCacheDir().getUsableSpace();\n        long imageCacheSize = (spaceAvailable > 2 * GIGABYTES) ? (250 * 1024 * 1024) : (50 * 1024 * 1024);\n        Log.d(TAG, \"Free space on cache dir: \" + spaceAvailable + \", using image cache size: \" + imageCacheSize);\n        builder.setDiskCache(new InternalCacheDiskCacheFactory(context, imageCacheSize));\n    }", "refactored_code": "    private static final long MEGABYTES = 1024 * 1024;\n        builder.setLogLevel(Log.WARN);\n        @SuppressLint(\"UsableSpace\")\n        long spaceAvailable = context.getCacheDir().getUsableSpace();\n        long imageCacheSize = (spaceAvailable > 2 * GIGABYTES) ? (250 * MEGABYTES) : (50 * MEGABYTES);\n        Log.d(TAG, \"Free space on cache dir: \" + spaceAvailable + \", using image cache size: \" + imageCacheSize);\n        builder.setDiskCache(new InternalCacheDiskCacheFactory(context, imageCacheSize));\n    }"}
{"magic_number_smell": "        int targetWidth = outWidth / 3;\n        int targetHeight = (int) (1.0 * outHeight * targetWidth / outWidth);\n        Bitmap resized = ThumbnailUtils.extractThumbnail(source, targetWidth, targetHeight);\n        Bitmap result = fastBlur(resized, 10);\n        if (result == null) {\n            Log.w(TAG, \"result was null\");\n            return source;", "refactored_code": "    private static final int STACK_BLUR_RADIUS = 10;\n        int targetWidth = outWidth / 3;\n        int targetHeight = (int) (1.0 * outHeight * targetWidth / outWidth);\n        Bitmap resized = ThumbnailUtils.extractThumbnail(source, targetWidth, targetHeight);\n        Bitmap result = fastBlur(resized, STACK_BLUR_RADIUS);\n        if (result == null) {\n            Log.w(TAG, \"result was null\");\n            return source;"}
{"magic_number_smell": "\n                    if (options.outWidth == -1 || options.outHeight == -1) {\n                        throw new IOException(\"Not a valid image\");\n                    } else if (Math.max(options.outHeight, options.outWidth) >= 1500) {\n                        double sampleSize = (double) Math.max(options.outHeight, options.outWidth) / 1500;\n                        options.inSampleSize = (int) Math.pow(2d, Math.floor(Math.log(sampleSize) / Math.log(2d)));\n                    }", "refactored_code": "    private static final int MAX_DIMENSIONS = 1500;\n\n                    if (options.outWidth == -1 || options.outHeight == -1) {\n                        throw new IOException(\"Not a valid image\");\n                    } else if (Math.max(options.outHeight, options.outWidth) >= MAX_DIMENSIONS) {\n                        double sampleSize = (double) Math.max(options.outHeight, options.outWidth) / MAX_DIMENSIONS;\n                        options.inSampleSize = (int) Math.pow(2d, Math.floor(Math.log(sampleSize) / Math.log(2d)));\n                    }"}
{"magic_number_smell": "                    break;\n                }\n                paint.setColor(data.getColorOfItem(i));\n                float padding = i == 0 ? 3f / 2 : 3f;\n                float sweepAngle = (180f - 3f) * data.getPercentageOfItem(i);\n                canvas.drawArc(arcBounds, startAngle + padding, sweepAngle - padding, false, paint);\n                startAngle = startAngle + sweepAngle;", "refactored_code": "        private static final float PADDING_DEGREES = 3f;\n                    break;\n                }\n                paint.setColor(data.getColorOfItem(i));\n                float padding = i == 0 ? PADDING_DEGREES / 2 : PADDING_DEGREES;\n                float sweepAngle = (180f - PADDING_DEGREES) * data.getPercentageOfItem(i);\n                canvas.drawArc(arcBounds, startAngle + padding, sweepAngle - padding, false, paint);\n                startAngle = startAngle + sweepAngle;"}
{"magic_number_smell": "        super.setupPagedToolbar(toolbar, viewPager);\n        new TabLayoutMediator(tabLayout, viewPager, (tab, position) -> {\n            switch (position) {\n                case 0:\n                    tab.setText(R.string.subscriptions_label);\n                    break;\n                case POS_YEARS:", "refactored_code": "    private static final int POS_SUBSCRIPTIONS = 0;\n        super.setupPagedToolbar(toolbar, viewPager);\n        new TabLayoutMediator(tabLayout, viewPager, (tab, position) -> {\n            switch (position) {\n                case POS_SUBSCRIPTIONS:\n                    tab.setText(R.string.subscriptions_label);\n                    break;\n                case POS_YEARS:"}
{"magic_number_smell": "\n    @Override\n    public int getItemViewType(int position) {\n        return position == 0 ? 0 : TYPE_FEED;\n    }\n\n    @NonNull", "refactored_code": "    private static final int TYPE_HEADER = 0;\n\n    @Override\n    public int getItemViewType(int position) {\n        return position == 0 ? TYPE_HEADER : TYPE_FEED;\n    }\n\n    @NonNull"}
{"magic_number_smell": "                canvas.drawRect(x, y, x + stepSize * 0.95f, barHeight, paintBars);\n            }\n\n            float maxLine = (float) (Math.floor(maxValue / (10.0 * 3600000L)) * 10 * 3600000L);\n            float y = (1 - (maxLine / maxValue)) * barHeight;\n            canvas.drawLine(0, y, width, y, paintGridLines);\n            canvas.drawText(String.valueOf((long) maxLine / 3600000L), 0, y + 1.2f * textSize, paintGridText);", "refactored_code": "        private static final long ONE_HOUR = 3600000L;\n                canvas.drawRect(x, y, x + stepSize * 0.95f, barHeight, paintBars);\n            }\n\n            float maxLine = (float) (Math.floor(maxValue / (10.0 * ONE_HOUR)) * 10 * ONE_HOUR);\n            float y = (1 - (maxLine / maxValue)) * barHeight;\n            canvas.drawLine(0, y, width, y, paintGridLines);\n            canvas.drawText(String.valueOf((long) maxLine / ONE_HOUR), 0, y + 1.2f * textSize, paintGridText);"}
{"magic_number_smell": "\n    @Override\n    public int getItemViewType(int position) {\n        return position == 0 ? 0 : TYPE_FEED;\n    }\n\n    @NonNull", "refactored_code": "    private static final int TYPE_HEADER = 0;\n\n    @Override\n    public int getItemViewType(int position) {\n        return position == 0 ? TYPE_HEADER : TYPE_FEED;\n    }\n\n    @NonNull"}
{"magic_number_smell": "    private static final int 3 = 3;\n\n    public static void main(String [] args) throws Exception{\n        if (args.length < 3){\n            System.out.println(\"Please provide \"+3+\" or more arguments:\");\n            System.out.println(\"serverhost serverport filename [arg1 arg2 ...]\");\n            System.out.println(\"e.g. \");", "refactored_code": "    private static final int MINARGS = 3;\n    private static final int MINARGS = 3;\n\n    public static void main(String [] args) throws Exception{\n        if (args.length < MINARGS){\n            System.out.println(\"Please provide \"+MINARGS+\" or more arguments:\");\n            System.out.println(\"serverhost serverport filename [arg1 arg2 ...]\");\n            System.out.println(\"e.g. \");"}
{"magic_number_smell": "        // this custom TreeSelectionModel forbid the selection of some test elements (test plan, thread group, etc..)\n        TreeSelectionModel tsm =  new DefaultTreeSelectionModel() {\n\n            private static final long -4195441608252523573L = 4062816201792954617L;\n\n            private boolean isSelectedPathAllowed(DefaultMutableTreeNode lastSelected) {\n                JMeterTreeNode tn = null;", "refactored_code": "    private static final long serialVersionUID = -4195441608252523573L;\n        // this custom TreeSelectionModel forbid the selection of some test elements (test plan, thread group, etc..)\n        TreeSelectionModel tsm =  new DefaultTreeSelectionModel() {\n\n            private static final long serialVersionUID = 4062816201792954617L;\n\n            private boolean isSelectedPathAllowed(DefaultMutableTreeNode lastSelected) {\n                JMeterTreeNode tn = null;"}
{"magic_number_smell": "        initTableModel();\n        paramTable.setModel(tableModel);\n        HeaderAsPropertyRenderer defaultRenderer = new HeaderAsPropertyRenderer(){\n            private static final long 241L = 240L;\n\n            @Override\n            protected String getText(Object value, int row, int column) {", "refactored_code": "    private static final long serialVersionUID = 241L;\n        initTableModel();\n        paramTable.setModel(tableModel);\n        HeaderAsPropertyRenderer defaultRenderer = new HeaderAsPropertyRenderer(){\n            private static final long serialVersionUID = 240L;\n\n            @Override\n            protected String getText(Object value, int row, int column) {"}
{"magic_number_smell": "    }\n\n    private static boolean valuesAreEqualWithPrecision(double throughput, double lastThroughput) {\n        return Math.abs(throughput - lastThroughput) < 0.00001;\n    }\n}\n", "refactored_code": "    private static final double PRECISION = 0.00001;\n    }\n\n    private static boolean valuesAreEqualWithPrecision(double throughput, double lastThroughput) {\n        return Math.abs(throughput - lastThroughput) < PRECISION;\n    }\n}\n"}
{"magic_number_smell": "     */\n    private static class DOMTreePanel extends JPanel implements MouseListener {\n\n        private static final long 1L = 6871690021183779153L;\n\n        private JTree domJTree;\n        private ExpandPopupMenu popupMenu;", "refactored_code": "        private static final long serialVersionUID = 1L;\n     */\n    private static class DOMTreePanel extends JPanel implements MouseListener {\n\n        private static final long serialVersionUID = 6871690021183779153L;\n\n        private JTree domJTree;\n        private ExpandPopupMenu popupMenu;"}
{"magic_number_smell": "    }\n\n    private class EnterAction extends AbstractAction {\n        private static final long 1L = 2L;\n        @Override\n        public void actionPerformed(ActionEvent ev) {\n            boolean found = doSearch();", "refactored_code": "    private static final long serialVersionUID = 1L;\n    }\n\n    private class EnterAction extends AbstractAction {\n        private static final long serialVersionUID = 2L;\n        @Override\n        public void actionPerformed(ActionEvent ev) {\n            boolean found = doSearch();"}
{"magic_number_smell": "\n\n    private static class ResultsNodeRenderer extends DefaultTreeCellRenderer {\n        private static final long 2L = 4159626601097711565L;\n\n        @Override\n        public Component getTreeCellRendererComponent(JTree tree, Object value,", "refactored_code": "    private static final long serialVersionUID = 2L;\n\n\n    private static class ResultsNodeRenderer extends DefaultTreeCellRenderer {\n        private static final long serialVersionUID = 4159626601097711565L;\n\n        @Override\n        public Component getTreeCellRendererComponent(JTree tree, Object value,"}
{"magic_number_smell": "    /**\n     * Timeboxed percentiles don't makes sense\n     */\n    private final DescriptiveStatistics pctResponseStats = DescriptiveStatisticsFactory.createDescriptiveStatistics(JMeterUtils.getPropDefault(\"backend_metrics_window\", 100));\n    private int successes;\n    private int failures;\n    private int hits;", "refactored_code": "    private static final int SLIDING_WINDOW_SIZE = JMeterUtils.getPropDefault(\"backend_metrics_window\", 100);\n    /**\n     * Timeboxed percentiles don't makes sense\n     */\n    private final DescriptiveStatistics pctResponseStats = DescriptiveStatisticsFactory.createDescriptiveStatistics(SLIDING_WINDOW_SIZE);\n    private int successes;\n    private int failures;\n    private int hits;"}
{"magic_number_smell": "\n    private static final int JMeterUtils.getPropDefault(\"backend_metrics_window\", 100) = JMeterUtils.getPropDefault(\"backend_metrics_window\", 100); //$NON-NLS-1$\n\n    // Limit to sliding window of JMeterUtils.getPropDefault(\"backend_metrics_window\", 100) values\n    private final DescriptiveStatistics usersStats = DescriptiveStatisticsFactory.createDescriptiveStatistics(JMeterUtils.getPropDefault(\"backend_metrics_window\", 100));\n\n    /**", "refactored_code": "    private static final int SLIDING_WINDOW_SIZE = JMeterUtils.getPropDefault(\"backend_metrics_window\", 100); //$NON-NLS-1$\n\n    private static final int SLIDING_WINDOW_SIZE = JMeterUtils.getPropDefault(\"backend_metrics_window\", 100); //$NON-NLS-1$\n\n    // Limit to sliding window of SLIDING_WINDOW_SIZE values\n    private final DescriptiveStatistics usersStats = DescriptiveStatisticsFactory.createDescriptiveStatistics(SLIDING_WINDOW_SIZE);\n\n    /**"}
{"magic_number_smell": "        String graphiteMetricsSenderClass = context.getParameter(GRAPHITE_METRICS_SENDER);\n\n        String graphiteHost = context.getParameter(GRAPHITE_HOST);\n        int graphitePort = context.getIntParameter(GRAPHITE_PORT, 2003);\n        summaryOnly = context.getBooleanParameter(SUMMARY_ONLY, true);\n        samplersList = context.getParameter(SAMPLERS_LIST, \"\");\n        useRegexpForSamplersList = context.getBooleanParameter(USE_REGEXP_FOR_SAMPLERS_LIST, false);", "refactored_code": "    private static final int DEFAULT_PLAINTEXT_PROTOCOL_PORT = 2003;\n        String graphiteMetricsSenderClass = context.getParameter(GRAPHITE_METRICS_SENDER);\n\n        String graphiteHost = context.getParameter(GRAPHITE_HOST);\n        int graphitePort = context.getIntParameter(GRAPHITE_PORT, DEFAULT_PLAINTEXT_PROTOCOL_PORT);\n        summaryOnly = context.getBooleanParameter(SUMMARY_ONLY, true);\n        samplersList = context.getParameter(SAMPLERS_LIST, \"\");\n        useRegexpForSamplersList = context.getBooleanParameter(USE_REGEXP_FOR_SAMPLERS_LIST, false);"}
{"magic_number_smell": "\n        scheduler = Executors.newScheduledThreadPool(MAX_POOL_SIZE);\n        // Start immediately the scheduler and put the pooling ( 5 seconds by default )\n        this.timerHandle = scheduler.scheduleAtFixedRate(this, 0, JMeterUtils.getPropDefault(\"backend_influxdb.send_interval\", 5), TimeUnit.SECONDS);\n    }\n\n    private void initInfluxdbMetricsManager(BackendListenerContext context) throws Exception {", "refactored_code": "    private static final long SEND_INTERVAL = JMeterUtils.getPropDefault(\"backend_influxdb.send_interval\", 5);\n\n        scheduler = Executors.newScheduledThreadPool(MAX_POOL_SIZE);\n        // Start immediately the scheduler and put the pooling ( 5 seconds by default )\n        this.timerHandle = scheduler.scheduleAtFixedRate(this, 0, SEND_INTERVAL, TimeUnit.SECONDS);\n    }\n\n    private void initInfluxdbMetricsManager(BackendListenerContext context) throws Exception {"}
{"magic_number_smell": "        result = assertion.getResult(sample0);\n        assertPassed();\n\n        assertion.setAllowedSize(data1.length());\n        result = assertion.getResult(sample1);\n        assertPassed();\n", "refactored_code": "    private final int data1Len = data1.length();\n        result = assertion.getResult(sample0);\n        assertPassed();\n\n        assertion.setAllowedSize(data1Len);\n        result = assertion.getResult(sample1);\n        assertPassed();\n"}
{"magic_number_smell": "    public void checkResetOkAndAllStats() throws Exception {\n        SamplerMetric metric = new SamplerMetric();\n        metric.add(createSampleResult(true));\n        assertEquals(1_000, metric.getOkMaxTime(), 0.001, \"Before reset  ok.max\");\n        assertEquals(1_000, metric.getAllMaxTime(), 0.001, \"Before reset all.max\");\n        assertEquals(1, metric.getHits(), 0.0, \"Before reset failure\");\n        assertEquals(1000, metric.getSentBytes(), 0.0, \"Before reset sent bytes\");", "refactored_code": "    private static final int DEFAULT_ELAPSED_TIME = 1_000;\n    public void checkResetOkAndAllStats() throws Exception {\n        SamplerMetric metric = new SamplerMetric();\n        metric.add(createSampleResult(true));\n        assertEquals(DEFAULT_ELAPSED_TIME, metric.getOkMaxTime(), 0.001, \"Before reset  ok.max\");\n        assertEquals(DEFAULT_ELAPSED_TIME, metric.getAllMaxTime(), 0.001, \"Before reset all.max\");\n        assertEquals(1, metric.getHits(), 0.0, \"Before reset failure\");\n        assertEquals(1000, metric.getSentBytes(), 0.0, \"Before reset sent bytes\");"}
{"magic_number_smell": "        SamplerMetric metric = new SamplerMetric();\n\n        metric.add(createSampleResult(true));\n        assertEquals(1_000, metric.getOkMaxTime(), 0.001, \"Before reset  ok.max\");\n        assertEquals(1_000, metric.getAllMaxTime(), 0.001, \"Before reset all.max\");\n        assertEquals(1, metric.getHits(), 0.0, \"Before reset hits\");\n        assertEquals(1000, metric.getSentBytes(), 0.0, \"Before reset sent bytes\");", "refactored_code": "    private static final int DEFAULT_ELAPSED_TIME = 1_000;\n        SamplerMetric metric = new SamplerMetric();\n\n        metric.add(createSampleResult(true));\n        assertEquals(DEFAULT_ELAPSED_TIME, metric.getOkMaxTime(), 0.001, \"Before reset  ok.max\");\n        assertEquals(DEFAULT_ELAPSED_TIME, metric.getAllMaxTime(), 0.001, \"Before reset all.max\");\n        assertEquals(1, metric.getHits(), 0.0, \"Before reset hits\");\n        assertEquals(1000, metric.getSentBytes(), 0.0, \"Before reset sent bytes\");"}
{"magic_number_smell": "    }\n\n    private static void startUdpDdaemon(final List<? extends JMeterEngine> engines) {\n        int port = JMeterUtils.getPropDefault(\"jmeterengine.nongui.port\", ShutdownClient.UDP_PORT_DEFAULT); // $NON-NLS-1$\n        int maxPort = JMeterUtils.getPropDefault(\"jmeterengine.nongui.maxport\", 4455); // $NON-NLS-1$\n        if (port > 1000){\n            final DatagramSocket socket = getSocket(port, maxPort);", "refactored_code": "    public static final int UDP_PORT_DEFAULT = ShutdownClient.UDP_PORT_DEFAULT;\n    }\n\n    private static void startUdpDdaemon(final List<? extends JMeterEngine> engines) {\n        int port = JMeterUtils.getPropDefault(\"jmeterengine.nongui.port\", UDP_PORT_DEFAULT); // $NON-NLS-1$\n        int maxPort = JMeterUtils.getPropDefault(\"jmeterengine.nongui.maxport\", 4455); // $NON-NLS-1$\n        if (port > 1000){\n            final DatagramSocket socket = getSocket(port, maxPort);"}
{"magic_number_smell": "\n    private static class ResultHolder implements Serializable\n    {\n        private static final long 1 = 1L;\n        private String baseResult;\n        private String secondaryResult;\n", "refactored_code": "    private static final long serialVersionUID = 1;\n\n    private static class ResultHolder implements Serializable\n    {\n        private static final long serialVersionUID = 1L;\n        private String baseResult;\n        private String secondaryResult;\n"}
{"magic_number_smell": "        // Hide Window on ESC\n        Action escapeAction = new AbstractAction(\"ESCAPE\") {\n\n            private static final long 6578889215615435475L = -8699034338969407625L;\n\n            @Override\n            public void actionPerformed(ActionEvent actionEvent) {", "refactored_code": "    private static final long serialVersionUID = 6578889215615435475L;\n        // Hide Window on ESC\n        Action escapeAction = new AbstractAction(\"ESCAPE\") {\n\n            private static final long serialVersionUID = -8699034338969407625L;\n\n            @Override\n            public void actionPerformed(ActionEvent actionEvent) {"}
{"magic_number_smell": "\n    public int getLoops() {\n        // Evaluation occurs when nbLoops is not yet evaluated\n        // or when nbLoops is equal to special value -1\n        if (nbLoops==null || // No evaluated yet\n                nbLoops ==0 || // Last iteration led to nbLoops == 0,\n                                         // in this case as resetLoopCount will not be called,", "refactored_code": "    public static final int INFINITE_LOOP_COUNT = -1; // $NON-NLS-1$\n\n    public int getLoops() {\n        // Evaluation occurs when nbLoops is not yet evaluated\n        // or when nbLoops is equal to special value INFINITE_LOOP_COUNT\n        if (nbLoops==null || // No evaluated yet\n                nbLoops ==0 || // Last iteration led to nbLoops == 0,\n                                         // in this case as resetLoopCount will not be called,"}
{"magic_number_smell": "        JRootPane rootPane = new JRootPane();\n        javax.swing.Action escapeAction = new AbstractAction(\"ESCAPE\") {\n\n            private static final long 240L = -4036804004190858925L;\n\n            @Override\n            public void actionPerformed(ActionEvent actionEvent) {", "refactored_code": "    private static final long serialVersionUID = 240L;\n        JRootPane rootPane = new JRootPane();\n        javax.swing.Action escapeAction = new AbstractAction(\"ESCAPE\") {\n\n            private static final long serialVersionUID = -4036804004190858925L;\n\n            @Override\n            public void actionPerformed(ActionEvent actionEvent) {"}
{"magic_number_smell": "     */\n    private JTree makeTree(TreeModel treeModel, JMeterTreeListener treeListener) {\n        JTree treevar = new JTree(treeModel) {\n            private static final long 241L = 240L;\n\n            @Override\n            public String getToolTipText(MouseEvent event) {", "refactored_code": "    private static final long serialVersionUID = 241L;\n     */\n    private JTree makeTree(TreeModel treeModel, JMeterTreeListener treeListener) {\n        JTree treevar = new JTree(treeModel) {\n            private static final long serialVersionUID = 240L;\n\n            @Override\n            public String getToolTipText(MouseEvent event) {"}
{"magic_number_smell": "    protected JRootPane createRootPane() {\n        JRootPane rootPane = new JRootPane();\n        Action escapeAction = new AbstractAction(\"ESCAPE\") {\n            private static final long 233L = 2208129319916921772L;\n\n            @Override\n            public void actionPerformed(ActionEvent e) {", "refactored_code": "    private static final long serialVersionUID = 233L;\n    protected JRootPane createRootPane() {\n        JRootPane rootPane = new JRootPane();\n        Action escapeAction = new AbstractAction(\"ESCAPE\") {\n            private static final long serialVersionUID = 2208129319916921772L;\n\n            @Override\n            public void actionPerformed(ActionEvent e) {"}
{"magic_number_smell": "        try {\n            SystemCommand sc = new SystemCommand(\n                    new File(JMeterUtils.getJMeterBinDir()),\n                    JMeterUtils.getPropDefault(\"generate_report_ui.generation_timeout\", 300_000L),\n                    100,\n                    null,\n                    null,", "refactored_code": "    private static final long COMMAND_TIMEOUT = JMeterUtils.getPropDefault(\"generate_report_ui.generation_timeout\", 300_000L);\n        try {\n            SystemCommand sc = new SystemCommand(\n                    new File(JMeterUtils.getJMeterBinDir()),\n                    COMMAND_TIMEOUT,\n                    100,\n                    null,\n                    null,"}
{"magic_number_smell": "    public static List<JComponent> getRecentFileMenuItems() {\n        List<JComponent> menuItems = new ArrayList<>();\n        // Get the preference for the recent files\n        for(int i = 0; i < 9; i++) {\n            // Create the menu item\n            JMenuItem recentFile = new JMenuItem();\n            // Use the index as the name, used when processing the action", "refactored_code": "    private static final int NUMBER_OF_MENU_ITEMS = 9;\n    public static List<JComponent> getRecentFileMenuItems() {\n        List<JComponent> menuItems = new ArrayList<>();\n        // Get the preference for the recent files\n        for(int i = 0; i < NUMBER_OF_MENU_ITEMS; i++) {\n            // Create the menu item\n            JMenuItem recentFile = new JMenuItem();\n            // Use the index as the name, used when processing the action"}
{"magic_number_smell": "     */\n    private static List<File> backupFilesToDelete(List<? extends File> backupFiles) {\n        List<File> filesToDelete = new ArrayList<>();\n        if (JMeterUtils.getPropDefault(JMX_BACKUP_MAX_HOURS, 0) > 0) {\n            filesToDelete.addAll(expiredBackupFiles(backupFiles));\n        }\n        // if max backups is set, ensure that we don't keep more backups than", "refactored_code": "    private static final int BACKUP_MAX_HOURS = JMeterUtils.getPropDefault(JMX_BACKUP_MAX_HOURS, 0);\n     */\n    private static List<File> backupFilesToDelete(List<? extends File> backupFiles) {\n        List<File> filesToDelete = new ArrayList<>();\n        if (BACKUP_MAX_HOURS > 0) {\n            filesToDelete.addAll(expiredBackupFiles(backupFiles));\n        }\n        // if max backups is set, ensure that we don't keep more backups than"}
{"magic_number_smell": "        // Hide Window on ESC\n        Action escapeAction = new AbstractAction(\"ESCAPE\") {\n\n            private static final long -4436834972710248247L = -6543764044868772971L;\n\n            @Override\n            public void actionPerformed(ActionEvent actionEvent) {", "refactored_code": "    private static final long serialVersionUID = -4436834972710248247L;\n        // Hide Window on ESC\n        Action escapeAction = new AbstractAction(\"ESCAPE\") {\n\n            private static final long serialVersionUID = -6543764044868772971L;\n\n            @Override\n            public void actionPerformed(ActionEvent actionEvent) {"}
{"magic_number_smell": "            /**\n             *\n             */\n            private static final long 1 = -6543764044868772971L;\n\n            @Override\n            public void actionPerformed(ActionEvent actionEvent) {", "refactored_code": "    private static final long serialVersionUID = 1;\n            /**\n             *\n             */\n            private static final long serialVersionUID = -6543764044868772971L;\n\n            @Override\n            public void actionPerformed(ActionEvent actionEvent) {"}
{"magic_number_smell": "        final String actionCommand = e.getActionCommand();\n        float scale = JMeterUIDefaults.INSTANCE.getScale();\n        if (actionCommand.equals(ActionNames.ZOOM_IN)) {\n            scale *= JMeterUtils.getPropDefault(\"zoom_scale\", 1.1f);\n        } else if (actionCommand.equals(ActionNames.ZOOM_OUT)) {\n            scale /= JMeterUtils.getPropDefault(\"zoom_scale\", 1.1f);\n        }", "refactored_code": "    private static final float ZOOM_SCALE = JMeterUtils.getPropDefault(\"zoom_scale\", 1.1f);\n        final String actionCommand = e.getActionCommand();\n        float scale = JMeterUIDefaults.INSTANCE.getScale();\n        if (actionCommand.equals(ActionNames.ZOOM_IN)) {\n            scale *= ZOOM_SCALE;\n        } else if (actionCommand.equals(ActionNames.ZOOM_OUT)) {\n            scale /= ZOOM_SCALE;\n        }"}
{"magic_number_smell": "\n    static {\n        log.info(\"Running validation with number of threads:{}, ignoreTimers:{}, number of iterations:{}\",\n                JMeterUtils.getPropDefault(\"testplan_validation.nb_threads_per_thread_group\", 1), VALIDATION_IGNORE_TIMERS, VALIDATION_ITERATIONS);\n    }\n\n    public TreeClonerForValidation() {", "refactored_code": "    protected static final int VALIDATION_NUMBER_OF_THREADS = JMeterUtils.getPropDefault(\"testplan_validation.nb_threads_per_thread_group\", 1); //$NON-NLS-1$\n\n    static {\n        log.info(\"Running validation with number of threads:{}, ignoreTimers:{}, number of iterations:{}\",\n                VALIDATION_NUMBER_OF_THREADS, VALIDATION_IGNORE_TIMERS, VALIDATION_ITERATIONS);\n    }\n\n    public TreeClonerForValidation() {"}
{"magic_number_smell": "            /**\n             *\n             */\n            private static final long 1319421816741139938L = 2208129319916921772L;\n\n            @Override\n            public void actionPerformed(ActionEvent e) {", "refactored_code": "    private static final long serialVersionUID = 1319421816741139938L;\n            /**\n             *\n             */\n            private static final long serialVersionUID = 2208129319916921772L;\n\n            @Override\n            public void actionPerformed(ActionEvent e) {"}
{"magic_number_smell": "            if (\"true\".equals(System.getProperty(\"java.awt.headless\"))) { // $NON-NLS-1$ $NON-NLS-2$\n                return new JSyntaxTextArea(disableUndo) {\n                    private String savedText = \"\";\n                    private static final long 211L = 1L;\n                    @Override\n                    protected void init() {\n                        try {", "refactored_code": "    private static final long serialVersionUID = 211L;\n            if (\"true\".equals(System.getProperty(\"java.awt.headless\"))) { // $NON-NLS-1$ $NON-NLS-2$\n                return new JSyntaxTextArea(disableUndo) {\n                    private String savedText = \"\";\n                    private static final long serialVersionUID = 1L;\n                    @Override\n                    protected void init() {\n                        try {"}
{"magic_number_smell": "        } catch (ClassNotFoundException ignored) {\n            // NOOP\n        }\n        return 100;\n    }\n\n    public String getLabel() {", "refactored_code": "    public static final int SORT_ORDER_DEFAULT = 100;\n        } catch (ClassNotFoundException ignored) {\n            // NOOP\n        }\n        return SORT_ORDER_DEFAULT;\n    }\n\n    public String getLabel() {"}
{"magic_number_smell": "        editorComponent.setRows(3);\n        this.clickCountToStart = 2;\n        delegate = new EditorDelegate() {\n            private static final long 240L = 240L;\n\n            @Override\n            public void setValue(Object value) {", "refactored_code": "    private static final long serialVersionUID = 240L;\n        editorComponent.setRows(3);\n        this.clickCountToStart = 2;\n        delegate = new EditorDelegate() {\n            private static final long serialVersionUID = 240L;\n\n            @Override\n            public void setValue(Object value) {"}
{"magic_number_smell": "        /**\n         *\n         */\n        private static final long 1L = -3718373200229708535L;\n\n        @Override\n        public void stateChanged(ChangeEvent e) {", "refactored_code": "    private static final long serialVersionUID = 1L;\n        /**\n         *\n         */\n        private static final long serialVersionUID = -3718373200229708535L;\n\n        @Override\n        public void stateChanged(ChangeEvent e) {"}
{"magic_number_smell": "            // flush and close previous writer\n            JOrphanUtils.closeQuietly(this.writer);\n        }\n        this.writer = new PrintWriter(new BufferedWriter(newWriter, 10000), false);\n    }\n\n    /**", "refactored_code": "    private static final int BUF_SIZE = 10000;\n            // flush and close previous writer\n            JOrphanUtils.closeQuietly(this.writer);\n        }\n        this.writer = new PrintWriter(new BufferedWriter(newWriter, BUF_SIZE), false);\n    }\n\n    /**"}
{"magic_number_smell": "        try {\n            this.fis = new FileInputStream(file);\n            this.isr = new InputStreamReader(fis, CHARSET);\n            this.reader = new BufferedReader(isr, 1024 * 1024);\n        } catch (FileNotFoundException | UnsupportedEncodingException ex) {\n            JOrphanUtils.closeQuietly(isr);\n            JOrphanUtils.closeQuietly(fis);", "refactored_code": "    private static final int BUF_SIZE = 1024 * 1024;\n        try {\n            this.fis = new FileInputStream(file);\n            this.isr = new InputStreamReader(fis, CHARSET);\n            this.reader = new BufferedReader(isr, BUF_SIZE);\n        } catch (FileNotFoundException | UnsupportedEncodingException ex) {\n            JOrphanUtils.closeQuietly(isr);\n            JOrphanUtils.closeQuietly(fis);"}
{"magic_number_smell": "    }\n\n    public static DescriptiveStatistics createDescriptiveStatistics() {\n        return createDescriptiveStatistics(JMeterUtils.getPropDefault(\"backend_metrics_window\", 100));\n    }\n\n    public static DescriptiveStatistics createDescriptiveStatistics(int windowSize) {", "refactored_code": "    private static final int SLIDING_WINDOW_SIZE = JMeterUtils.getPropDefault(\"backend_metrics_window\", 100); //$NON-NLS-1$\n    }\n\n    public static DescriptiveStatistics createDescriptiveStatistics() {\n        return createDescriptiveStatistics(SLIDING_WINDOW_SIZE);\n    }\n\n    public static DescriptiveStatistics createDescriptiveStatistics(int windowSize) {"}
{"magic_number_smell": "\n    private static final int 50000 = 50000;\n\n    private long chunkSize = 50000;\n\n    private SampleComparator sampleComparator;\n", "refactored_code": "    private static final int DEFAULT_CHUNK_SIZE = 50000;\n\n    private static final int DEFAULT_CHUNK_SIZE = 50000;\n\n    private long chunkSize = DEFAULT_CHUNK_SIZE;\n\n    private SampleComparator sampleComparator;\n"}
{"magic_number_smell": "        SummaryInfo overallInfo = getOverallInfo();\n        StatisticsSummaryData overallData = overallInfo.getData();\n        if (overallData == null) {\n            overallData = new StatisticsSummaryData(new BigDecimal(PCT1_LABEL).doubleValue(),\n                            PERCENTILE_INDEX2, PERCENTILE_INDEX3);\n            overallInfo.setData(overallData);\n        }", "refactored_code": "    private static final double PERCENTILE_INDEX1 = new BigDecimal(PCT1_LABEL).doubleValue();\n        SummaryInfo overallInfo = getOverallInfo();\n        StatisticsSummaryData overallData = overallInfo.getData();\n        if (overallData == null) {\n            overallData = new StatisticsSummaryData(PERCENTILE_INDEX1,\n                            PERCENTILE_INDEX2, PERCENTILE_INDEX3);\n            overallInfo.setData(overallData);\n        }"}
{"magic_number_smell": "    }\n\n    /**\n     * Method will save the JComponent as an image. The formats are 0, and\n     * TIFF.\n     *\n     * @param filename", "refactored_code": "    public static final int PNG = 0;\n    }\n\n    /**\n     * Method will save the JComponent as an image. The formats are PNG, and\n     * TIFF.\n     *\n     * @param filename"}
{"magic_number_smell": "     * Comparator used to sort properties for presentation in the GUI.\n     */\n    private static class PropertyComparator implements Comparator<PropertyDescriptor>, Serializable {\n        private static final long 241L = 240L;\n\n        private final BeanInfo beanInfo;\n        public PropertyComparator(BeanInfo beanInfo) {", "refactored_code": "    private static final long serialVersionUID = 241L;\n     * Comparator used to sort properties for presentation in the GUI.\n     */\n    private static class PropertyComparator implements Comparator<PropertyDescriptor>, Serializable {\n        private static final long serialVersionUID = 240L;\n\n        private final BeanInfo beanInfo;\n        public PropertyComparator(BeanInfo beanInfo) {"}
{"magic_number_smell": "    // Conversions for milli and nano seconds\n    private static final long 1000L = 1000L;\n    private static final long NS_PER_SEC = 1000000000L;\n    private static final long NS_PER_MS  = NS_PER_SEC/1000L;\n\n    /**\n     * Create a pauser with the appropriate speed settings.", "refactored_code": "    private static final long MS_PER_SEC = 1000L;\n    // Conversions for milli and nano seconds\n    private static final long MS_PER_SEC = 1000L;\n    private static final long NS_PER_SEC = 1000000000L;\n    private static final long NS_PER_MS  = NS_PER_SEC/MS_PER_SEC;\n\n    /**\n     * Create a pauser with the appropriate speed settings."}
{"magic_number_smell": "            log.info(\"Using default SSL protocol: {}\", DEFAULT_SSL_PROTOCOL);\n            log.info(\"SSL session context: {}\", SHARED_SESSION_CONTEXT ? \"shared\" : \"per-thread\");\n\n            if (JMeterUtils.getPropDefault(\"httpclient.socket.https.cps\", 0) > 0) {\n                log.info(\"Setting up HTTPS SlowProtocol, cps={}\", JMeterUtils.getPropDefault(\"httpclient.socket.https.cps\", 0));\n            }\n        }", "refactored_code": "    public static final int CPS = JMeterUtils.getPropDefault(\"httpclient.socket.https.cps\", 0); // $NON-NLS-1$\n            log.info(\"Using default SSL protocol: {}\", DEFAULT_SSL_PROTOCOL);\n            log.info(\"SSL session context: {}\", SHARED_SESSION_CONTEXT ? \"shared\" : \"per-thread\");\n\n            if (CPS > 0) {\n                log.info(\"Setting up HTTPS SlowProtocol, cps={}\", CPS);\n            }\n        }"}
{"magic_number_smell": "        tempCsv.deleteOnExit();\n        try (CsvSampleWriter writer = new CsvSampleWriter(tempCsv, metadata)) {\n            writer.setSeparator(',');\n            for (long i = 0; i < 100; i++) {\n                final Sample sample = new SampleBuilder(metadata)\n                        .add(i)\n                        .add(\"a\" + i)", "refactored_code": "    private static final int NR_ROWS = 100;\n        tempCsv.deleteOnExit();\n        try (CsvSampleWriter writer = new CsvSampleWriter(tempCsv, metadata)) {\n            writer.setSeparator(',');\n            for (long i = 0; i < NR_ROWS; i++) {\n                final Sample sample = new SampleBuilder(metadata)\n                        .add(i)\n                        .add(\"a\" + i)"}
{"magic_number_smell": "    }\n\n    private static class DummyTimer extends AbstractTestElement implements Timer {\n        private static final long 1L = 5641410390783919241L;\n        private long delay;\n\n        void setDelay(long delay) {", "refactored_code": "        private static final long serialVersionUID = 1L;\n    }\n\n    private static class DummyTimer extends AbstractTestElement implements Timer {\n        private static final long serialVersionUID = 5641410390783919241L;\n        private long delay;\n\n        void setDelay(long delay) {"}
{"magic_number_smell": "    }\n\n    static class DummyProviderWithConfig extends Provider {\n        private static final long 1L = 1L;\n        public static final String PROVIDER_NAME = \"DUMMY_CONFIG\";\n\n        private String config = null;", "refactored_code": "        private static final long serialVersionUID = 1L;\n    }\n\n    static class DummyProviderWithConfig extends Provider {\n        private static final long serialVersionUID = 1L;\n        public static final String PROVIDER_NAME = \"DUMMY_CONFIG\";\n\n        private String config = null;"}
{"magic_number_smell": "\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, 1, MAX_PARAMETER_COUNT);\n        values = parameters.toArray(new CompoundVariable[parameters.size()]);\n    }\n", "refactored_code": "    private static final int MIN_PARAMETER_COUNT = 1;\n\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAMETER_COUNT, MAX_PARAMETER_COUNT);\n        values = parameters.toArray(new CompoundVariable[parameters.size()]);\n    }\n"}
{"magic_number_smell": "\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, 3, MAX_PARAMETER_COUNT);\n        values = parameters.toArray(new CompoundVariable[parameters.size()]);\n    }\n", "refactored_code": "    private static final int MIN_PARAMETER_COUNT = 3;\n\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAMETER_COUNT, MAX_PARAMETER_COUNT);\n        values = parameters.toArray(new CompoundVariable[parameters.size()]);\n    }\n"}
{"magic_number_smell": "\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, 2, MAX_PARAMETER_COUNT);\n        values = parameters.toArray(new CompoundVariable[parameters.size()]);\n    }\n", "refactored_code": "    private static final int MIN_PARAMETER_COUNT = 2;\n\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAMETER_COUNT, MAX_PARAMETER_COUNT);\n        values = parameters.toArray(new CompoundVariable[parameters.size()]);\n    }\n"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAM_COUNT, 2);\n        values = parameters.toArray(new CompoundVariable[parameters.size()]);\n    }\n", "refactored_code": "    private static final int MAX_PARAM_COUNT = 2;\n    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAM_COUNT, MAX_PARAM_COUNT);\n        values = parameters.toArray(new CompoundVariable[parameters.size()]);\n    }\n"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, 1, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n", "refactored_code": "    private static final int MIN_PARAMETER_COUNT = 1;\n    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAMETER_COUNT, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, 1, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n", "refactored_code": "    private static final int MIN_PARAMETER_COUNT = 1;\n    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAMETER_COUNT, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, 1, MAX_PARAM_COUNT);\n        values = parameters.toArray();\n    }\n", "refactored_code": "    private static final int MIN_PARAM_COUNT = 1;\n    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAM_COUNT, MAX_PARAM_COUNT);\n        values = parameters.toArray();\n    }\n"}
{"magic_number_smell": "    }\n\n    private void endRow() {\n        if (currentRow == -1) {\n            log.warn(\"endRow() called twice in succession\");\n        }\n        currentRow = -1;", "refactored_code": "    private static final int NO_LINE = -1;\n    }\n\n    private void endRow() {\n        if (currentRow == NO_LINE) {\n            log.warn(\"endRow() called twice in succession\");\n        }\n        currentRow = NO_LINE;"}
{"magic_number_smell": "    @Override\n    public void setParameters(Collection<CompoundVariable> parameters)\n            throws InvalidVariableException {\n        checkParameterCount(parameters, 1,\n                MAX_PARAMETER_COUNT);\n        values = parameters.toArray(new CompoundVariable[parameters.size()]);\n    }", "refactored_code": "    private static final int MIN_PARAMETER_COUNT = 1;\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters)\n            throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAMETER_COUNT,\n                MAX_PARAMETER_COUNT);\n        values = parameters.toArray(new CompoundVariable[parameters.size()]);\n    }"}
{"magic_number_smell": "    @Override\n    public void setParameters(Collection<CompoundVariable> parameters)\n            throws InvalidVariableException {\n        checkParameterCount(parameters, 1,\n                MAX_PARAMETER_COUNT);\n        values = parameters.toArray(new CompoundVariable[parameters.size()]);\n    }", "refactored_code": "    private static final int MIN_PARAMETER_COUNT = 1;\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters)\n            throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAMETER_COUNT,\n                MAX_PARAMETER_COUNT);\n        values = parameters.toArray(new CompoundVariable[parameters.size()]);\n    }"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, 1, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n", "refactored_code": "    private static final int MIN_PARAMETER_COUNT = 1;\n    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAMETER_COUNT, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, 1, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n", "refactored_code": "    private static final int MIN_PARAMETER_COUNT = 1;\n    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAMETER_COUNT, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, 1, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n", "refactored_code": "    private static final int MIN_PARAMETER_COUNT = 1;\n    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAMETER_COUNT, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, 1, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n", "refactored_code": "    private static final int MIN_PARAMETER_COUNT = 1;\n    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAMETER_COUNT, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n"}
{"magic_number_smell": "    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n\n        checkParameterCount(parameters, 3, MAX_PARAMETER_COUNT);\n        values = parameters.toArray(new CompoundVariable[parameters.size()]);\n        // Create the cache\n        if (dateRandomFormatterCache == null) {", "refactored_code": "    private static final int MIN_PARAMETER_COUNT = 3;\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n\n        checkParameterCount(parameters, MIN_PARAMETER_COUNT, MAX_PARAMETER_COUNT);\n        values = parameters.toArray(new CompoundVariable[parameters.size()]);\n        // Create the cache\n        if (dateRandomFormatterCache == null) {"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAM_COUNT, 3);\n        values = parameters.toArray(new CompoundVariable[parameters.size()]);\n    }\n", "refactored_code": "    private static final int MAX_PARAM_COUNT = 3;\n    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAM_COUNT, MAX_PARAM_COUNT);\n        values = parameters.toArray(new CompoundVariable[parameters.size()]);\n    }\n"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, 2, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n", "refactored_code": "    private static final int MIN_PARAMETER_COUNT = 2;\n    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAMETER_COUNT, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, 2, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n", "refactored_code": "    private static final int MIN_PARAMETER_COUNT = 2;\n    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAMETER_COUNT, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, 2, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n", "refactored_code": "    private static final int MIN_PARAMETER_COUNT = 2;\n    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAMETER_COUNT, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n"}
{"magic_number_smell": "    public synchronized void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n\n        log.debug(\"{}::StringFromFile.setParameters()\", this);//$NON-NLS-1$\n        checkParameterCount(parameters, 1, MAX_PARAM_COUNT);\n        values = parameters.toArray();\n\n        StringBuilder sb = new StringBuilder(40);", "refactored_code": "    private static final int MIN_PARAM_COUNT = 1;\n    public synchronized void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n\n        log.debug(\"{}::StringFromFile.setParameters()\", this);//$NON-NLS-1$\n        checkParameterCount(parameters, MIN_PARAM_COUNT, MAX_PARAM_COUNT);\n        values = parameters.toArray();\n\n        StringBuilder sb = new StringBuilder(40);"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, 1, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n", "refactored_code": "    private static final int MIN_PARAMETER_COUNT = 1;\n    /** {@inheritDoc} */\n    @Override\n    public void setParameters(Collection<CompoundVariable> parameters) throws InvalidVariableException {\n        checkParameterCount(parameters, MIN_PARAMETER_COUNT, MAX_PARAMETER_COUNT);\n        values = parameters.toArray();\n    }\n"}
{"magic_number_smell": "\n    private int stringLength;\n\n    private int lastChar = Integer.MAX_VALUE;\n\n    private int lastOptionId;\n", "refactored_code": "    private static final int INVALID = Integer.MAX_VALUE;\n\n    private int stringLength;\n\n    private int lastChar = INVALID;\n\n    private int lastOptionId;\n"}
{"magic_number_smell": "     * never return null.\n     */\n    private static final CLOptionDescriptor TEXT_ARGUMENT_DESCRIPTOR = new CLOptionDescriptor(null,\n            CLOptionDescriptor.ARGUMENT_OPTIONAL, 0, null);\n\n    private String[] arguments;\n", "refactored_code": "    public static final int TEXT_ARGUMENT = 0;\n     * never return null.\n     */\n    private static final CLOptionDescriptor TEXT_ARGUMENT_DESCRIPTOR = new CLOptionDescriptor(null,\n            CLOptionDescriptor.ARGUMENT_OPTIONAL, TEXT_ARGUMENT, null);\n\n    private String[] arguments;\n"}
{"magic_number_smell": "\n    private void checkFlags(final int flags) {\n        int modeCount = 0;\n        if ((1 << 1 & flags) == 1 << 1) {\n            modeCount++;\n        }\n        if ((ARGUMENT_OPTIONAL & flags) == ARGUMENT_OPTIONAL) {", "refactored_code": "    public static final int ARGUMENT_REQUIRED = 1 << 1;\n\n    private void checkFlags(final int flags) {\n        int modeCount = 0;\n        if ((ARGUMENT_REQUIRED & flags) == ARGUMENT_REQUIRED) {\n            modeCount++;\n        }\n        if ((ARGUMENT_OPTIONAL & flags) == ARGUMENT_OPTIONAL) {"}
{"magic_number_smell": "            sb.append(lSep);\n\n            if (null != description) {\n                while (description.length() > 60) {\n                    final String descriptionPart = description.substring(0, 60);\n                    description = description.substring(60);\n                    sb.append(\"\\t\\t\");", "refactored_code": "    private static final int MAX_DESCRIPTION_COLUMN_LENGTH = 60;\n            sb.append(lSep);\n\n            if (null != description) {\n                while (description.length() > MAX_DESCRIPTION_COLUMN_LENGTH) {\n                    final String descriptionPart = description.substring(0, MAX_DESCRIPTION_COLUMN_LENGTH);\n                    description = description.substring(MAX_DESCRIPTION_COLUMN_LENGTH);\n                    sb.append(\"\\t\\t\");"}
{"magic_number_smell": "            defaults.put(\"Button.defaultButtonFollowsFocus\", false); // $NON-NLS-1$\n            defaults.put(TEXTAREA_BORDER, (UIDefaults.LazyValue) d -> new JTextField().getBorder());\n\n            addScaledFont(defaults, BUTTON_SMALL_FONT, \"Button.font\", 10f / 12); // $NON-NLS-1$\n            addScaledFont(defaults, CHECKBOX_SMALL_FONT, \"CheckBox.font\", 10f / 12); // $NON-NLS-1$\n            addScaledFont(defaults, LABEL_SMALL_FONT, \"Label.font\", 10f / 12); // $NON-NLS-1$\n            addScaledFont(defaults, TEXTFIELD_SMALL_FONT, \"TextField.font\", 10f / 12); // $NON-NLS-1$", "refactored_code": "    private static final float SMALL_FONT_SCALE = 10f / 12;\n            defaults.put(\"Button.defaultButtonFollowsFocus\", false); // $NON-NLS-1$\n            defaults.put(TEXTAREA_BORDER, (UIDefaults.LazyValue) d -> new JTextField().getBorder());\n\n            addScaledFont(defaults, BUTTON_SMALL_FONT, \"Button.font\", SMALL_FONT_SCALE); // $NON-NLS-1$\n            addScaledFont(defaults, CHECKBOX_SMALL_FONT, \"CheckBox.font\", SMALL_FONT_SCALE); // $NON-NLS-1$\n            addScaledFont(defaults, LABEL_SMALL_FONT, \"Label.font\", SMALL_FONT_SCALE); // $NON-NLS-1$\n            addScaledFont(defaults, TEXTFIELD_SMALL_FONT, \"TextField.font\", SMALL_FONT_SCALE); // $NON-NLS-1$"}
{"magic_number_smell": "\n    private class MenuScrollItem extends JMenuItem implements ChangeListener {\n\n        private static final long 1 = 1;\n\n        private final MenuScrollTimer timer;\n", "refactored_code": "        private static final long serialVersionUID = 1;\n\n    private class MenuScrollItem extends JMenuItem implements ChangeListener {\n\n        private static final long serialVersionUID = 1;\n\n        private final MenuScrollTimer timer;\n"}
{"magic_number_smell": "        String fixedClassName = strClassName.replace('\\\\', '.'); // $NON-NLS-1$ // $NON-NLS-2$\n        fixedClassName = fixedClassName.replace('/', '.'); // $NON-NLS-1$ // $NON-NLS-2$\n        // remove \".class\"\n        fixedClassName = fixedClassName.substring(0, fixedClassName.length() - DOT_CLASS.length());\n        return fixedClassName;\n    }\n", "refactored_code": "    private static final int DOT_CLASS_LEN = DOT_CLASS.length();\n        String fixedClassName = strClassName.replace('\\\\', '.'); // $NON-NLS-1$ // $NON-NLS-2$\n        fixedClassName = fixedClassName.replace('/', '.'); // $NON-NLS-1$ // $NON-NLS-2$\n        // remove \".class\"\n        fixedClassName = fixedClassName.substring(0, fixedClassName.length() - DOT_CLASS_LEN);\n        return fixedClassName;\n    }\n"}
{"magic_number_smell": "        Matcher m2 = parts.matcher(converter.apply(o2));\n\n        while (m1.find() && m2.find()) {\n            int compareCharGroup = m1.group(1).compareTo(m2.group(1));\n            if (compareCharGroup != 0) {\n                return compareCharGroup;\n            }", "refactored_code": "    private static final int ALPHA_PART = 1;\n        Matcher m2 = parts.matcher(converter.apply(o2));\n\n        while (m1.find() && m2.find()) {\n            int compareCharGroup = m1.group(ALPHA_PART).compareTo(m2.group(ALPHA_PART));\n            if (compareCharGroup != 0) {\n                return compareCharGroup;\n            }"}
{"magic_number_smell": "        int bytes = data.length;\n        int offset = 0;\n        while (bytes > 0) {\n            int chunk = Math.min(bytes, 4096);\n            output.write(data, offset, chunk);\n            bytes -= chunk;\n            offset += chunk;", "refactored_code": "    private static final int DEFAULT_CHUNK_SIZE = 4096;\n        int bytes = data.length;\n        int offset = 0;\n        while (bytes > 0) {\n            int chunk = Math.min(bytes, DEFAULT_CHUNK_SIZE);\n            output.write(data, offset, chunk);\n            bytes -= chunk;\n            offset += chunk;"}
{"magic_number_smell": "        void setText(String text) {\n            iterator.setText(text);\n            pos = 0;\n            next = -2;\n        }\n\n        public int getPos() {", "refactored_code": "        private static final int UNINITIALIZED = -2;\n        void setText(String text) {\n            iterator.setText(text);\n            pos = 0;\n            next = UNINITIALIZED;\n        }\n\n        public int getPos() {"}
{"magic_number_smell": "    private static final int TAINT_OPT = 'T';\n\n    private static final CLOptionDescriptor DEFINE = new CLOptionDescriptor(\"define\",\n            CLOptionDescriptor.ARGUMENTS_REQUIRED_2, 'D', \"define\");\n\n    private static final CLOptionDescriptor DEFINE_MANY = new CLOptionDescriptor(\"define\",\n            CLOptionDescriptor.ARGUMENTS_REQUIRED_2 | CLOptionDescriptor.DUPLICATES_ALLOWED, 'D', \"define\");", "refactored_code": "    private static final int DEFINE_OPT = 'D';\n    private static final int TAINT_OPT = 'T';\n\n    private static final CLOptionDescriptor DEFINE = new CLOptionDescriptor(\"define\",\n            CLOptionDescriptor.ARGUMENTS_REQUIRED_2, DEFINE_OPT, \"define\");\n\n    private static final CLOptionDescriptor DEFINE_MANY = new CLOptionDescriptor(\"define\",\n            CLOptionDescriptor.ARGUMENTS_REQUIRED_2 | CLOptionDescriptor.DUPLICATES_ALLOWED, DEFINE_OPT, \"define\");"}
{"magic_number_smell": "    public static void setup(@TempDir Path keystoreDir) throws IOException {\n        keystore = keystoreDir.resolve(\"dummy-keystore.jks\").toFile();\n        password = JOrphanUtils.generateRandomAlphanumericPassword(32);\n        KeyToolUtils.generateProxyCA(keystore, password, 1);\n    }\n\n    /*", "refactored_code": "    private static final int validity = 1;\n    public static void setup(@TempDir Path keystoreDir) throws IOException {\n        keystore = keystoreDir.resolve(\"dummy-keystore.jks\").toFile();\n        password = JOrphanUtils.generateRandomAlphanumericPassword(32);\n        KeyToolUtils.generateProxyCA(keystore, password, validity);\n    }\n\n    /*"}
{"magic_number_smell": "    public static final int 4445 = 4445;\n\n    public static void main(String[] args) throws IOException {\n        int port = 4445;\n        if (args.length > 1){\n            port = Integer.parseInt(args[1]);\n        } else if (args.length == 0) {", "refactored_code": "    public static final int UDP_PORT_DEFAULT = 4445;\n    public static final int UDP_PORT_DEFAULT = 4445;\n\n    public static void main(String[] args) throws IOException {\n        int port = UDP_PORT_DEFAULT;\n        if (args.length > 1){\n            port = Integer.parseInt(args[1]);\n        } else if (args.length == 0) {"}
{"magic_number_smell": "\n    class ValidationTabbedPane extends AbstractValidationTabbedPane {\n\n        private static final long 240L = 7014311238367882881L;\n\n        @Override\n        protected int getValidatedTabIndex(int currentTabIndex, int newTabIndex) {", "refactored_code": "    private static final long serialVersionUID = 240L;\n\n    class ValidationTabbedPane extends AbstractValidationTabbedPane {\n\n        private static final long serialVersionUID = 7014311238367882881L;\n\n        @Override\n        protected int getValidatedTabIndex(int currentTabIndex, int newTabIndex) {"}
{"magic_number_smell": "    private static final CLOptionDescriptor HELP_OPT =\n            new CLOptionDescriptor(\"?\",\n                    CLOptionDescriptor.ARGUMENT_DISALLOWED,\n                    '?',\n                    \"print command line options and exit\");\n    private static final CLOptionDescriptor PORT_OPT =\n            new CLOptionDescriptor(\"port\",", "refactored_code": "    private static final int HELP_OPT_ID = '?';// $NON-NLS-1$\n    private static final CLOptionDescriptor HELP_OPT =\n            new CLOptionDescriptor(\"?\",\n                    CLOptionDescriptor.ARGUMENT_DISALLOWED,\n                    HELP_OPT_ID,\n                    \"print command line options and exit\");\n    private static final CLOptionDescriptor PORT_OPT =\n            new CLOptionDescriptor(\"port\","}
{"magic_number_smell": "            new CLOptionDescriptor(\"header\", CLOptionDescriptor.ARGUMENT_REQUIRED | CLOptionDescriptor.DUPLICATES_ALLOWED, HEADER_OPT,\n                    \"Pass custom header LINE to server\");\n    private static final CLOptionDescriptor D_METHOD_OPT =\n            new CLOptionDescriptor(\"request\", CLOptionDescriptor.ARGUMENT_REQUIRED, 'X',\n                    \"Pass custom header LINE to server\");\n    private static final CLOptionDescriptor D_DATA_OPT =\n            new CLOptionDescriptor(\"data\", CLOptionDescriptor.ARGUMENT_REQUIRED | CLOptionDescriptor.DUPLICATES_ALLOWED, DATA_OPT,", "refactored_code": "    private static final int METHOD_OPT                 = 'X';// $NON-NLS-1$\n            new CLOptionDescriptor(\"header\", CLOptionDescriptor.ARGUMENT_REQUIRED | CLOptionDescriptor.DUPLICATES_ALLOWED, HEADER_OPT,\n                    \"Pass custom header LINE to server\");\n    private static final CLOptionDescriptor D_METHOD_OPT =\n            new CLOptionDescriptor(\"request\", CLOptionDescriptor.ARGUMENT_REQUIRED, METHOD_OPT,\n                    \"Pass custom header LINE to server\");\n    private static final CLOptionDescriptor D_DATA_OPT =\n            new CLOptionDescriptor(\"data\", CLOptionDescriptor.ARGUMENT_REQUIRED | CLOptionDescriptor.DUPLICATES_ALLOWED, DATA_OPT,"}
{"magic_number_smell": "    }\n\n    private static class InnerTableModel extends AbstractTableModel {\n        private static final long -378312656300713635L = 4638155137475747946L;\n        final AuthManager manager;\n\n        public InnerTableModel() {", "refactored_code": "    private static final long serialVersionUID = -378312656300713635L;\n    }\n\n    private static class InnerTableModel extends AbstractTableModel {\n        private static final long serialVersionUID = 4638155137475747946L;\n        final AuthManager manager;\n\n        public InnerTableModel() {"}
{"magic_number_smell": "    }\n\n    private static class InnerTableModel extends AbstractTableModel {\n        private static final long 241L = 240L;\n\n        private final HeaderManager manager;\n", "refactored_code": "    private static final long serialVersionUID = 241L;\n    }\n\n    private static class InnerTableModel extends AbstractTableModel {\n        private static final long serialVersionUID = 240L;\n\n        private final HeaderManager manager;\n"}
{"magic_number_smell": "    protected static boolean isEnableConditionalComments(Float ieVersion) {\n        // Conditional comment have been dropped in IE10\n        // http://msdn.microsoft.com/en-us/library/ie/hh801214%28v=vs.85%29.aspx\n        return ieVersion != null && ieVersion < 10.0f;\n    }\n\n    /**", "refactored_code": "    private   static final float IE_10                = 10.0f;\n    protected static boolean isEnableConditionalComments(Float ieVersion) {\n        // Conditional comment have been dropped in IE10\n        // http://msdn.microsoft.com/en-us/library/ie/hh801214%28v=vs.85%29.aspx\n        return ieVersion != null && ieVersion < IE_10;\n    }\n\n    /**"}
{"magic_number_smell": "                    log.debug(\"match groups {} {}\", match.groupCount(), match);\n                }\n                // Check for a BASE HREF:\n                for (int g = 1; g <= 3 && g <= match.groupCount(); g++) {\n                    s = match.group(g);\n                    if (s != null) {\n                        log.debug(\"new baseUrl: {} - {}\", s, baseUrl);", "refactored_code": "    private static final int NUM_BASE_GROUPS = 3;\n                    log.debug(\"match groups {} {}\", match.groupCount(), match);\n                }\n                // Check for a BASE HREF:\n                for (int g = 1; g <= NUM_BASE_GROUPS && g <= match.groupCount(); g++) {\n                    s = match.group(g);\n                    if (s != null) {\n                        log.debug(\"new baseUrl: {} - {}\", s, baseUrl);"}
{"magic_number_smell": "        this.proxyClass = proxyClass;\n        log.info(\"Creating Daemon Socket on port: {}\", daemonPort);\n        mainSocket = new ServerSocket(daemonPort);\n        mainSocket.setSoTimeout(1000);\n    }\n\n    /**", "refactored_code": "    private static final int ACCEPT_TIMEOUT = 1000;\n        this.proxyClass = proxyClass;\n        log.info(\"Creating Daemon Socket on port: {}\", daemonPort);\n        mainSocket = new ServerSocket(daemonPort);\n        mainSocket.setSoTimeout(ACCEPT_TIMEOUT);\n    }\n\n    /**"}
{"magic_number_smell": "        if (isNumberRequests()) {\n            return getNumberedFormat(httpSampleNameMode);\n        }\n        if (httpSampleNameMode == 0) {\n            return \"{0}{1}\";\n        }\n        if (httpSampleNameMode == SAMPLER_NAME_NAMING_MODE_COMPLETE) {", "refactored_code": "    private static final int SAMPLER_NAME_NAMING_MODE_PREFIX = 0;  // $NON-NLS-1$\n        if (isNumberRequests()) {\n            return getNumberedFormat(httpSampleNameMode);\n        }\n        if (httpSampleNameMode == SAMPLER_NAME_NAMING_MODE_PREFIX) {\n            return \"{0}{1}\";\n        }\n        if (httpSampleNameMode == SAMPLER_NAME_NAMING_MODE_COMPLETE) {"}
{"magic_number_smell": "     * Holds information about a sampler at the time of recording by the HTTP proxy\n     */\n    private static class SamplerInfo implements Serializable {\n        private static final long 240L = 1L;\n        private final HTTPSamplerBase sampler;\n        private final transient TestElement[] testElements;\n        private final JMeterTreeNode target;", "refactored_code": "    private static final long serialVersionUID = 240L;\n     * Holds information about a sampler at the time of recording by the HTTP proxy\n     */\n    private static class SamplerInfo implements Serializable {\n        private static final long serialVersionUID = 1L;\n        private final HTTPSamplerBase sampler;\n        private final transient TestElement[] testElements;\n        private final JMeterTreeNode target;"}
{"magic_number_smell": "        // Hide Window on ESC\n        Action escapeAction = new AbstractAction(\"ESCAPE\") {\n\n            private static final long 931790497924069705L = -6543764044868772971L;\n\n            @Override\n            public void actionPerformed(ActionEvent actionEvent) {", "refactored_code": "    private static final long serialVersionUID = 931790497924069705L;\n        // Hide Window on ESC\n        Action escapeAction = new AbstractAction(\"ESCAPE\") {\n\n            private static final long serialVersionUID = -6543764044868772971L;\n\n            @Override\n            public void actionPerformed(ActionEvent actionEvent) {"}
{"magic_number_smell": "    private static final ViewableFileBody[] EMPTY_FILE_BODIES = new ViewableFileBody[0];\n\n    static {\n        log.info(\"HTTP request retry count = {}\", JMeterUtils.getPropDefault(\"httpclient4.retrycount\", 0));\n\n        // Set up HTTP scheme override if necessary\n        if (CPS_HTTP > 0) {", "refactored_code": "    private static final int RETRY_COUNT = JMeterUtils.getPropDefault(\"httpclient4.retrycount\", 0);\n    private static final ViewableFileBody[] EMPTY_FILE_BODIES = new ViewableFileBody[0];\n\n    static {\n        log.info(\"HTTP request retry count = {}\", RETRY_COUNT);\n\n        // Set up HTTP scheme override if necessary\n        if (CPS_HTTP > 0) {"}
{"magic_number_smell": "\n    protected static final int Integer.parseInt(System.getProperty(\"http.proxyPort\",\"0\")) = Integer.parseInt(System.getProperty(\"http.proxyPort\",\"0\"));\n\n    protected static final boolean PROXY_DEFINED = PROXY_HOST.length() > 0 && Integer.parseInt(System.getProperty(\"http.proxyPort\",\"0\")) > 0;\n\n    protected static final String PROXY_USER = JMeterUtils.getPropDefault(JMeter.HTTP_PROXY_USER,\"\");\n", "refactored_code": "    protected static final int PROXY_PORT = Integer.parseInt(System.getProperty(\"http.proxyPort\",\"0\"));\n\n    protected static final int PROXY_PORT = Integer.parseInt(System.getProperty(\"http.proxyPort\",\"0\"));\n\n    protected static final boolean PROXY_DEFINED = PROXY_HOST.length() > 0 && PROXY_PORT > 0;\n\n    protected static final String PROXY_USER = JMeterUtils.getPropDefault(JMeter.HTTP_PROXY_USER,\"\");\n"}
{"magic_number_smell": "        if (contentType != null) {\n            int charSetStartPos = contentType.toLowerCase(java.util.Locale.ENGLISH).indexOf(CHARSET_EQ);\n            if (charSetStartPos >= 0) {\n                charSet = contentType.substring(charSetStartPos + CHARSET_EQ.length());\n                if (charSet != null) {\n                    // Remove quotes from charset name, see bug 55852\n                    charSet = StringUtils.replaceChars(charSet, \"\\'\\\"\", null);", "refactored_code": "    private static final int CHARSET_EQ_LEN = CHARSET_EQ.length();\n        if (contentType != null) {\n            int charSetStartPos = contentType.toLowerCase(java.util.Locale.ENGLISH).indexOf(CHARSET_EQ);\n            if (charSetStartPos >= 0) {\n                charSet = contentType.substring(charSetStartPos + CHARSET_EQ_LEN);\n                if (charSet != null) {\n                    // Remove quotes from charset name, see bug 55852\n                    charSet = StringUtils.replaceChars(charSet, \"\\'\\\"\", null);"}
{"magic_number_smell": "    private static final byte[] CRLF = { 0x0d, 0x0a };\n    private static final int 8181 = 8181;\n    @RegisterExtension\n    private static final HttpMirrorServerExtension HTTP_MIRROR_SERVER = new HttpMirrorServerExtension(8181);\n\n    @Test\n    public void testGetRequest() throws Exception {", "refactored_code": "    private static final int HTTP_SERVER_PORT = 8181;\n    private static final byte[] CRLF = { 0x0d, 0x0a };\n    private static final int HTTP_SERVER_PORT = 8181;\n    @RegisterExtension\n    private static final HttpMirrorServerExtension HTTP_MIRROR_SERVER = new HttpMirrorServerExtension(HTTP_SERVER_PORT);\n\n    @Test\n    public void testGetRequest() throws Exception {"}
{"magic_number_smell": "    @ParameterizedTest\n    @ValueSource(ints = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10})\n    public void itemised_testPostRequest_UrlEncoded(int item) throws Exception {\n        testPostRequest_UrlEncoded(0, ISO_8859_1, item);\n    }\n\n    @ParameterizedTest", "refactored_code": "    private static final int HTTP_SAMPLER = 0;\n    @ParameterizedTest\n    @ValueSource(ints = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10})\n    public void itemised_testPostRequest_UrlEncoded(int item) throws Exception {\n        testPostRequest_UrlEncoded(HTTP_SAMPLER, ISO_8859_1, item);\n    }\n\n    @ParameterizedTest"}
{"magic_number_smell": "    }\n\n    private static class InnerTableModel extends AbstractTableModel {\n        private static final long -2893899384410289131L = 4638155137475747946L;\n        final JMSProperties jmsProperties;\n\n        public InnerTableModel() {", "refactored_code": "    private static final long serialVersionUID = -2893899384410289131L;\n    }\n\n    private static class InnerTableModel extends AbstractTableModel {\n        private static final long serialVersionUID = 4638155137475747946L;\n        final JMSProperties jmsProperties;\n\n        public InnerTableModel() {"}
{"magic_number_smell": "\n        List<ServerAddress> addresses = new ArrayList<>();\n        for(String connection : Arrays.asList(connections.split(\",\"))) {\n            int port = 27017;\n            String[] hostPort = connection.split(\":\");\n            if(hostPort.length > 1 && !StringUtils.isEmpty(hostPort[1])) {\n                port = Integer.parseInt(hostPort[1].trim());", "refactored_code": "    public static final int DEFAULT_PORT = 27017;\n\n        List<ServerAddress> addresses = new ArrayList<>();\n        for(String connection : Arrays.asList(connections.split(\",\"))) {\n            int port = DEFAULT_PORT;\n            String[] hostPort = connection.split(\":\");\n            if(hostPort.length > 1 && !StringUtils.isEmpty(hostPort[1])) {\n                port = Integer.parseInt(hostPort[1].trim());"}
{"magic_number_smell": "\n    public BinaryTCPClientImpl() {\n        super();\n        setEolByte(JMeterUtils.getPropDefault(\"tcp.BinaryTCPClient.eomByte\", 1000));\n        if (useEolByte) {\n            log.info(\"Using eomByte={}\", eolByte);\n        }", "refactored_code": "    private static final int EOM_INT = JMeterUtils.getPropDefault(\"tcp.BinaryTCPClient.eomByte\", 1000); // $NON_NLS-1$\n\n    public BinaryTCPClientImpl() {\n        super();\n        setEolByte(EOM_INT);\n        if (useEolByte) {\n            log.info(\"Using eomByte={}\", eolByte);\n        }"}
{"magic_number_smell": "     */\n    @Override\n    public void write(OutputStream os, String s)  throws IOException{\n        os.write(intToByteArray(s.length()/2,JMeterUtils.getPropDefault(\"tcp.binarylength.prefix.length\", 2)));\n        if(log.isDebugEnabled()) {\n            log.debug(\"Wrote: \" + s.length()/2 + \" bytes\");\n        }", "refactored_code": "    private final int lengthPrefixLen = JMeterUtils.getPropDefault(\"tcp.binarylength.prefix.length\", 2); // $NON-NLS-1$\n     */\n    @Override\n    public void write(OutputStream os, String s)  throws IOException{\n        os.write(intToByteArray(s.length()/2,lengthPrefixLen));\n        if(log.isDebugEnabled()) {\n            log.debug(\"Wrote: \" + s.length()/2 + \" bytes\");\n        }"}
{"magic_number_smell": "\n    public TCPClientImpl() {\n        super();\n        setEolByte(JMeterUtils.getPropDefault(\"tcp.eolByte\", 1000));\n        if (useEolByte) {\n            log.info(\"Using eolByte={}\", eolByte);\n        }", "refactored_code": "    private static final int EOL_INT = JMeterUtils.getPropDefault(\"tcp.eolByte\", 1000); // $NON-NLS-1$\n\n    public TCPClientImpl() {\n        super();\n        setEolByte(EOL_INT);\n        if (useEolByte) {\n            log.info(\"Using eolByte={}\", eolByte);\n        }"}
{"magic_number_smell": "    private final Object[] awaitBarrier = new Object[0];\n    private final AtomicBoolean outOfOrderBroadcastSupported = new AtomicBoolean(false);\n    protected int writeTimeoutInSecond = -1;\n    protected int waitTime = 100;\n    private boolean backwardCompatible;\n    private LifecycleHandler lifecycleHandler;\n    private Future<?> currentLifecycleTask;", "refactored_code": "    public static final int POLLING_DEFAULT = 100;\n    private final Object[] awaitBarrier = new Object[0];\n    private final AtomicBoolean outOfOrderBroadcastSupported = new AtomicBoolean(false);\n    protected int writeTimeoutInSecond = -1;\n    protected int waitTime = POLLING_DEFAULT;\n    private boolean backwardCompatible;\n    private LifecycleHandler lifecycleHandler;\n    private Future<?> currentLifecycleTask;"}
{"magic_number_smell": "\n        if (n == filters.length) {\n            FilterConfigImpl[] newFilters =\n                    new FilterConfigImpl[n + 20];\n            System.arraycopy(filters, 0, newFilters, 0, n);\n            filters = newFilters;\n        }", "refactored_code": "    public static final int INCREMENT = 20;\n\n        if (n == filters.length) {\n            FilterConfigImpl[] newFilters =\n                    new FilterConfigImpl[n + INCREMENT];\n            System.arraycopy(filters, 0, newFilters, 0, n);\n            filters = newFilters;\n        }"}
{"magic_number_smell": "public class ChunkConcatReaderPool {\n    private final Map<String, ChunkConcatReader> readersPool = new ConcurrentHashMap<>();\n    private static final long 300000 = 300000;\n    private long timeout = 300000;\n\n    /**\n     * Return a reader if the reader specified by the key has not been previously created.", "refactored_code": "    private static final long DEFAULT_TIMEOUT = 300000;\npublic class ChunkConcatReaderPool {\n    private final Map<String, ChunkConcatReader> readersPool = new ConcurrentHashMap<>();\n    private static final long DEFAULT_TIMEOUT = 300000;\n    private long timeout = DEFAULT_TIMEOUT;\n\n    /**\n     * Return a reader if the reader specified by the key has not been previously created."}
{"magic_number_smell": "     * specified charset.\n     */\n    public QueryStringDecoder(String uri, Charset charset, boolean hasPath) {\n        this(uri, charset, hasPath, 1024);\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_MAX_PARAMS = 1024;\n     * specified charset.\n     */\n    public QueryStringDecoder(String uri, Charset charset, boolean hasPath) {\n        this(uri, charset, hasPath, DEFAULT_MAX_PARAMS);\n    }\n\n    /**"}
{"magic_number_smell": "     * @since 2.1\n     */\n    public ReaderInputStream(Reader reader, CharsetEncoder encoder) {\n        this(reader, encoder, 1024);\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_BUFFER_SIZE = 1024;\n     * @since 2.1\n     */\n    public ReaderInputStream(Reader reader, CharsetEncoder encoder) {\n        this(reader, encoder, DEFAULT_BUFFER_SIZE);\n    }\n\n    /**"}
{"magic_number_smell": "\n        final int tag = di.readUnsignedByte();\n        switch (tag) {\n            case 1:\n                constantPool[index] = di.readUTF();\n                return false;\n            case CP_INTEGER:", "refactored_code": "    private static final int CP_UTF8 = 1;\n\n        final int tag = di.readUnsignedByte();\n        switch (tag) {\n            case CP_UTF8:\n                constantPool[index] = di.readUTF();\n                return false;\n            case CP_INTEGER:"}
{"magic_number_smell": "        cache.configure(config);\n\n        Thread t = new Thread(() -> {\n            for (int i = 0; i < 100000; i++) {\n                BroadcastMessage broadcastMessage = createBroadcastMessage();\n                cache.addToCache(BROADCASTER_ID, CLIENT_ID, broadcastMessage);\n            }", "refactored_code": "    public static final int NUM_MESSAGES = 100000;\n        cache.configure(config);\n\n        Thread t = new Thread(() -> {\n            for (int i = 0; i < NUM_MESSAGES; i++) {\n                BroadcastMessage broadcastMessage = createBroadcastMessage();\n                cache.addToCache(BROADCASTER_ID, CLIENT_ID, broadcastMessage);\n            }"}
{"magic_number_smell": "                        final Downloader downloader = new Downloader(getSettings());\n                        final int maxAttempts = this.getSettings().getInt(Settings.KEYS.ANALYZER_CENTRAL_RETRY_COUNT, 3);\n                        int retryCount = 0;\n                        long sleepingTimeBetweenRetriesInMillis = 1500;\n                        boolean success = false;\n                        Model model = null;\n                        if (cache != null) {", "refactored_code": "    private static final int BASE_RETRY_WAIT = 1500;\n                        final Downloader downloader = new Downloader(getSettings());\n                        final int maxAttempts = this.getSettings().getInt(Settings.KEYS.ANALYZER_CENTRAL_RETRY_COUNT, 3);\n                        int retryCount = 0;\n                        long sleepingTimeBetweenRetriesInMillis = BASE_RETRY_WAIT;\n                        boolean success = false;\n                        Model model = null;\n                        if (cache != null) {"}
{"magic_number_smell": "     * Regex to obtain the project version.\n     */\n    private static final Pattern PROJECT_VERSION = Pattern.compile(\"^\\\\s*set\\\\s*\\\\(\\\\s*VERSION\\\\s*\\\"([^\\\"]*)\\\"\\\\)\",\n            Pattern.DOTALL | Pattern.CASE_INSENSITIVE | Pattern.MULTILINE);\n    /**\n     * Regex to obtain variables.\n     */", "refactored_code": "    private static final int REGEX_OPTIONS = Pattern.DOTALL | Pattern.CASE_INSENSITIVE | Pattern.MULTILINE;\n     * Regex to obtain the project version.\n     */\n    private static final Pattern PROJECT_VERSION = Pattern.compile(\"^\\\\s*set\\\\s*\\\\(\\\\s*VERSION\\\\s*\\\"([^\\\"]*)\\\"\\\\)\",\n            REGEX_OPTIONS);\n    /**\n     * Regex to obtain variables.\n     */"}
{"magic_number_smell": "                //we need to keep the correct sequence of terms from the evidence so the term concatenating analyzer\n                //works correctly and will causes searches to take spring framework and produce: spring springframework framework\n                if (boostTerm != null) {\n                    sb.append(\"^\").append(weighting + 1);\n                    if (!boostTerm.equals(word)) {\n                        boostedTerms.append(\" \");\n                        LuceneUtils.appendEscapedLuceneQuery(boostedTerms, boostTerm);", "refactored_code": "    private static final int WEIGHTING_BOOST = 1;\n                //we need to keep the correct sequence of terms from the evidence so the term concatenating analyzer\n                //works correctly and will causes searches to take spring framework and produce: spring springframework framework\n                if (boostTerm != null) {\n                    sb.append(\"^\").append(weighting + WEIGHTING_BOOST);\n                    if (!boostTerm.equals(word)) {\n                        boostedTerms.append(\" \");\n                        LuceneUtils.appendEscapedLuceneQuery(boostedTerms, boostTerm);"}
{"magic_number_smell": "            final Matcher matcher = VERSION_PATTERN.matcher(contents);\n            if (matcher.find()) {\n                found = true;\n                final String version = getOpenSSLVersion(Long.parseLong(matcher.group(1), 16));\n                dependency.addEvidence(EvidenceType.VERSION, OPENSSLV_H, \"Version Constant\",\n                        version, Confidence.HIGH);\n                try {", "refactored_code": "    private static final int HEXADECIMAL = 16;\n            final Matcher matcher = VERSION_PATTERN.matcher(contents);\n            if (matcher.find()) {\n                found = true;\n                final String version = getOpenSSLVersion(Long.parseLong(matcher.group(1), HEXADECIMAL));\n                dependency.addEvidence(EvidenceType.VERSION, OPENSSLV_H, \"Version Constant\",\n                        version, Confidence.HIGH);\n                try {"}
{"magic_number_smell": "    /**\n     * Pattern for matching the module doc string in a source file.\n     */\n    private static final Pattern MODULE_DOCSTRING = Pattern.compile(\"^(['\\\\\\\"]{3})(.*?)\\\\1\", Pattern.DOTALL | Pattern.CASE_INSENSITIVE);\n\n    /**\n     * Matches assignments to version variables in Python source code.", "refactored_code": "    private static final int REGEX_OPTIONS = Pattern.DOTALL | Pattern.CASE_INSENSITIVE;\n    /**\n     * Pattern for matching the module doc string in a source file.\n     */\n    private static final Pattern MODULE_DOCSTRING = Pattern.compile(\"^(['\\\\\\\"]{3})(.*?)\\\\1\", REGEX_OPTIONS);\n\n    /**\n     * Matches assignments to version variables in Python source code."}
{"magic_number_smell": "                    final int max = settings.getInt(Settings.KEYS.MAX_DOWNLOAD_THREAD_POOL_SIZE, 1);\n                    final int downloadPoolSize = Math.min(Runtime.getRuntime().availableProcessors(), max);\n                    // going over 2 threads does not appear to improve performance\n                    final int maxExec = Runtime.getRuntime().availableProcessors();\n                    final int execPoolSize = Math.min(maxExec, 2);\n\n                    ExecutorService processingExecutorService = null;", "refactored_code": "    private static final int PROCESSING_THREAD_POOL_SIZE = Runtime.getRuntime().availableProcessors();\n                    final int max = settings.getInt(Settings.KEYS.MAX_DOWNLOAD_THREAD_POOL_SIZE, 1);\n                    final int downloadPoolSize = Math.min(Runtime.getRuntime().availableProcessors(), max);\n                    // going over 2 threads does not appear to improve performance\n                    final int maxExec = PROCESSING_THREAD_POOL_SIZE;\n                    final int execPoolSize = Math.min(maxExec, 2);\n\n                    ExecutorService processingExecutorService = null;"}
{"magic_number_smell": "        if (\"Metadata-Version\".equals(key)) {\n            final int majorVersion = Integer.parseInt(value.substring(0, value.indexOf('.')), 10);\n            final BigDecimal version = new BigDecimal(value);\n            if (majorVersion > 2) {\n                throw new IllegalArgumentException(String.format(\n                        \"Unsupported PyPA Wheel metadata. Metadata-Version \" + \"is '%s', largest supported major is %d\", value,\n                        2));", "refactored_code": "    private static final int SUPPORTED_MAJOR_UPPERBOUND = 2;\n        if (\"Metadata-Version\".equals(key)) {\n            final int majorVersion = Integer.parseInt(value.substring(0, value.indexOf('.')), 10);\n            final BigDecimal version = new BigDecimal(value);\n            if (majorVersion > SUPPORTED_MAJOR_UPPERBOUND) {\n                throw new IllegalArgumentException(String.format(\n                        \"Unsupported PyPA Wheel metadata. Metadata-Version \" + \"is '%s', largest supported major is %d\", value,\n                        SUPPORTED_MAJOR_UPPERBOUND));"}
{"magic_number_smell": "                    try {\n                        final Timestamp timestamp = new Timestamp(System.currentTimeMillis());\n                        LOGGER.debug(\"Sleeping thread {} ({}) for {} seconds because an exclusive lock on the database could not be obtained ({})\",\n                                Thread.currentThread().getName(), magic, 15000 / 1000, timestamp);\n                        Thread.sleep(15000);\n                    } catch (InterruptedException ex) {\n                        LOGGER.debug(\"sleep was interrupted.\", ex);", "refactored_code": "    public static final int SLEEP_DURATION = 15000;\n                    try {\n                        final Timestamp timestamp = new Timestamp(System.currentTimeMillis());\n                        LOGGER.debug(\"Sleeping thread {} ({}) for {} seconds because an exclusive lock on the database could not be obtained ({})\",\n                                Thread.currentThread().getName(), magic, SLEEP_DURATION / 1000, timestamp);\n                        Thread.sleep(SLEEP_DURATION);\n                    } catch (InterruptedException ex) {\n                        LOGGER.debug(\"sleep was interrupted.\", ex);"}
{"magic_number_smell": "     */\n    public int length() {\n        try {\n            final StringBuilder s = read(2);\n            pushBack.append(s);\n            return s.length();\n        } catch (IOException ex) {", "refactored_code": "    private static final int MIN_LENGTH = 2;\n     */\n    public int length() {\n        try {\n            final StringBuilder s = read(MIN_LENGTH);\n            pushBack.append(s);\n            return s.length();\n        } catch (IOException ex) {"}
{"magic_number_smell": "     * @throws IOException thrown if an I/O error occurs\n     */\n    private void skipToProject() throws IOException {\n        final byte[] buffer = new byte[1024];\n        super.mark(1024);\n        int count = super.read(buffer, 0, 1024);\n        while (count > 0) {", "refactored_code": "    protected static final int BUFFER_SIZE = 1024;\n     * @throws IOException thrown if an I/O error occurs\n     */\n    private void skipToProject() throws IOException {\n        final byte[] buffer = new byte[BUFFER_SIZE];\n        super.mark(BUFFER_SIZE);\n        int count = super.read(buffer, 0, BUFFER_SIZE);\n        while (count > 0) {"}
{"magic_number_smell": "        if ( lineLength <= 0 )\n        {\n            getLog().warn( \"The parameter 'lineLength' should be positive, using '80' as default.\" );\n            lineLength = 80;\n        }\n        if ( indentSize <= 0 )\n        {", "refactored_code": "    private static final int DEFAULT_LINE_LENGTH = 80;\n        if ( lineLength <= 0 )\n        {\n            getLog().warn( \"The parameter 'lineLength' should be positive, using '80' as default.\" );\n            lineLength = DEFAULT_LINE_LENGTH;\n        }\n        if ( indentSize <= 0 )\n        {"}
{"magic_number_smell": "                final MessageDigest md5Digest = getMessageDigest(MD5);\n                final MessageDigest sha1Digest = getMessageDigest(SHA1);\n                final MessageDigest sha256Digest = getMessageDigest(SHA256);\n                final byte[] buffer = new byte[1024];\n                int read = stream.read(buffer, 0, 1024);\n                while (read > -1) {\n                    // update all checksums together instead of reading the file multiple times", "refactored_code": "    private static final int BUFFER_SIZE = 1024;\n                final MessageDigest md5Digest = getMessageDigest(MD5);\n                final MessageDigest sha1Digest = getMessageDigest(SHA1);\n                final MessageDigest sha256Digest = getMessageDigest(SHA256);\n                final byte[] buffer = new byte[BUFFER_SIZE];\n                int read = stream.read(buffer, 0, BUFFER_SIZE);\n                while (read > -1) {\n                    // update all checksums together instead of reading the file multiple times"}
{"magic_number_smell": "            while ((status == HttpURLConnection.HTTP_MOVED_TEMP\n                    || status == HttpURLConnection.HTTP_MOVED_PERM\n                    || status == HttpURLConnection.HTTP_SEE_OTHER)\n                    && 5 > redirectCount++) {\n                final String location = conn.getHeaderField(\"Location\");\n                try {\n                    conn.disconnect();", "refactored_code": "    private static final int MAX_REDIRECT_ATTEMPTS = 5;\n            while ((status == HttpURLConnection.HTTP_MOVED_TEMP\n                    || status == HttpURLConnection.HTTP_MOVED_PERM\n                    || status == HttpURLConnection.HTTP_SEE_OTHER)\n                    && MAX_REDIRECT_ATTEMPTS > redirectCount++) {\n                final String location = conn.getHeaderField(\"Location\");\n                try {\n                    conn.disconnect();"}
{"magic_number_smell": "    /**\n     * The read buffer.\n     */\n    private final byte[] buffer = new byte[2048];\n    /**\n     * The read offset for the buffer.\n     */", "refactored_code": "    private static final int BUFFER_SIZE = 2048;\n    /**\n     * The read buffer.\n     */\n    private final byte[] buffer = new byte[BUFFER_SIZE];\n    /**\n     * The read offset for the buffer.\n     */"}
{"magic_number_smell": "                opSetPersPresence.subscribe(parentProtoGroup, contactID);\n\n            //wait for a confirmation event\n            evtRetriever.waitForEvent(10000);\n        }\n        catch(OperationFailedException ex)\n        {", "refactored_code": "    public static final int CONTACT_LIST_MODIFICATION_TIMEOUT = 10000;\n                opSetPersPresence.subscribe(parentProtoGroup, contactID);\n\n            //wait for a confirmation event\n            evtRetriever.waitForEvent(CONTACT_LIST_MODIFICATION_TIMEOUT);\n        }\n        catch(OperationFailedException ex)\n        {"}
{"magic_number_smell": "\n        if (code == CANCEL_RETURN_CODE)\n            this.fireWizardEvent(WizardEvent.CANCEL);\n        else if (code == 0)\n            this.fireWizardEvent(WizardEvent.SUCCESS);\n        else if (code == ERROR_RETURN_CODE)\n            this.fireWizardEvent(WizardEvent.ERROR);", "refactored_code": "    public static final int FINISH_RETURN_CODE = 0;\n\n        if (code == CANCEL_RETURN_CODE)\n            this.fireWizardEvent(WizardEvent.CANCEL);\n        else if (code == FINISH_RETURN_CODE)\n            this.fireWizardEvent(WizardEvent.SUCCESS);\n        else if (code == ERROR_RETURN_CODE)\n            this.fireWizardEvent(WizardEvent.ERROR);"}
{"magic_number_smell": "     * Creates a new WizardEvent according to the given source and event code.\n     *\n     * @param source the source where this event occurred\n     * @param eventCode the event code : 1 or ERROR\n     */\n    public WizardEvent(Object source, int eventCode) {\n        super(source);", "refactored_code": "    public static final int SUCCESS = 1;\n     * Creates a new WizardEvent according to the given source and event code.\n     *\n     * @param source the source where this event occurred\n     * @param eventCode the event code : SUCCESS or ERROR\n     */\n    public WizardEvent(Object source, int eventCode) {\n        super(source);"}
{"magic_number_smell": "\n    /**\n     * Returns the ID of this event which is one of\n     * {@link #1} and {@link #PLUGIN_COMPONENT_REMOVED}.\n     *\n     * @return the ID of this event which is one of the\n     * <tt>PLUGIN_COMPONENT_XXX</tt> constants defined by the", "refactored_code": "    public static final int PLUGIN_COMPONENT_ADDED = 1;\n\n    /**\n     * Returns the ID of this event which is one of\n     * {@link #PLUGIN_COMPONENT_ADDED} and {@link #PLUGIN_COMPONENT_REMOVED}.\n     *\n     * @return the ID of this event which is one of the\n     * <tt>PLUGIN_COMPONENT_XXX</tt> constants defined by the"}
{"magic_number_smell": "        extends AbstractBorder\n        implements UIResource\n    {\n        private static final long 0L = 0L;\n\n        private static final Insets insets = new Insets(2, 2, 2, 2);\n", "refactored_code": "        private static final long serialVersionUID = 0L;\n        extends AbstractBorder\n        implements UIResource\n    {\n        private static final long serialVersionUID = 0L;\n\n        private static final Insets insets = new Insets(2, 2, 2, 2);\n"}
{"magic_number_smell": "\n    private Object lock = new Object();\n\n    private int result = -2;\n\n    /**\n     * Constructs the <tt>RequestAuthorisationDialog</tt>.", "refactored_code": "    public static final int UNDEFINED_CODE = -2;\n\n    private Object lock = new Object();\n\n    private int result = UNDEFINED_CODE;\n\n    /**\n     * Constructs the <tt>RequestAuthorisationDialog</tt>."}
{"magic_number_smell": "\n    private Object lock = new Object();\n\n    private int returnCode = -1;\n\n    /**\n     * Constructs the <tt>RequestAuthorisationDialog</tt>.", "refactored_code": "    public static final int UNDEFINED_RETURN_CODE = -1;\n\n    private Object lock = new Object();\n\n    private int returnCode = UNDEFINED_RETURN_CODE;\n\n    /**\n     * Constructs the <tt>RequestAuthorisationDialog</tt>."}
{"magic_number_smell": "\n        setBorder(\n                BorderFactory.createEmptyBorder(\n                        2,\n                        2,\n                        2,\n                        2));", "refactored_code": "    private static final int TOOL_BAR_BORDER = 2;\n\n        setBorder(\n                BorderFactory.createEmptyBorder(\n                        TOOL_BAR_BORDER,\n                        TOOL_BAR_BORDER,\n                        TOOL_BAR_BORDER,\n                        TOOL_BAR_BORDER));"}
{"magic_number_smell": "\n        setIconImage(iconImage);\n\n        setPreferredSize(new Dimension(44, DEFAULT_HEIGHT));\n        setName(buttonName);\n        setToolTipText(tooltipText);\n    }", "refactored_code": "    public static final int DEFAULT_WIDTH = 44;\n\n        setIconImage(iconImage);\n\n        setPreferredSize(new Dimension(DEFAULT_WIDTH, DEFAULT_HEIGHT));\n        setName(buttonName);\n        setToolTipText(tooltipText);\n    }"}
{"magic_number_smell": "        /**\n         * Serial version UID.\n         */\n        private static final long 0L = 0L;\n\n        private final ProtocolProviderService protocolProvider;\n", "refactored_code": "    private static final long serialVersionUID = 0L;\n        /**\n         * Serial version UID.\n         */\n        private static final long serialVersionUID = 0L;\n\n        private final ProtocolProviderService protocolProvider;\n"}
{"magic_number_smell": "            /**\n             * Serial version UID.\n             */\n            public static final long 0L = 0L;\n\n            @Override\n            public void paintComponent(Graphics g)", "refactored_code": "            public static final long serialVersionUID = 0L;\n            /**\n             * Serial version UID.\n             */\n            public static final long serialVersionUID = 0L;\n\n            @Override\n            public void paintComponent(Graphics g)"}
{"magic_number_smell": "         * the instances of the class, there're no fields so the default\n         * serialization routine will work.\n         */\n        private static final long 0L = 0L;\n\n        /**\n         * Constructs a new <tt>PeerStatusPanel</tt>.", "refactored_code": "    private static final long serialVersionUID = 0L;\n         * the instances of the class, there're no fields so the default\n         * serialization routine will work.\n         */\n        private static final long serialVersionUID = 0L;\n\n        /**\n         * Constructs a new <tt>PeerStatusPanel</tt>."}
{"magic_number_smell": "    {\n        String filename = FORMAT.format(new Date()) + \"-call\";\n        int maxLength\n            = 64 - 2 - filename.length() - ext.length();\n        String peerName = getCallPeerName(maxLength);\n        filename += ((!peerName.equals(\"\")) ? \"-\" : \"\") + peerName + \".\" + ext;\n        return  filename;", "refactored_code": "    private static final int MAX_FILENAME_LENGTH = 64;\n    {\n        String filename = FORMAT.format(new Date()) + \"-call\";\n        int maxLength\n            = MAX_FILENAME_LENGTH - 2 - filename.length() - ext.length();\n        String peerName = getCallPeerName(maxLength);\n        filename += ((!peerName.equals(\"\")) ? \"-\" : \"\") + peerName + \".\" + ext;\n        return  filename;"}
{"magic_number_smell": "        /**\n         * Serial version UID.\n         */\n        private static final long 0L = 0L;\n\n        /**\n         * The <tt>CallPeer</tt> of this instance.", "refactored_code": "    private static final long serialVersionUID = 0L;\n        /**\n         * Serial version UID.\n         */\n        private static final long serialVersionUID = 0L;\n\n        /**\n         * The <tt>CallPeer</tt> of this instance."}
{"magic_number_smell": "\n        // Sets the minimum, maximum and default volume values for the volume\n        // slider.\n        volumeSlider.setMinimum((int) (volumeControl.getMinValue()*100));\n        volumeSlider.setMaximum((int) (volumeControl.getMaxValue()*100));\n        volumeSlider.setValue((int) (volumeControl.getVolume()*100));\n", "refactored_code": "    private static final int MULTIPLIER = 100;\n\n        // Sets the minimum, maximum and default volume values for the volume\n        // slider.\n        volumeSlider.setMinimum((int) (volumeControl.getMinValue()*MULTIPLIER));\n        volumeSlider.setMaximum((int) (volumeControl.getMaxValue()*MULTIPLIER));\n        volumeSlider.setValue((int) (volumeControl.getVolume()*MULTIPLIER));\n"}
{"magic_number_smell": "            participantImage\n                = ImageUtils.getScaledRoundedIcon(  image,\n                                                    AVATAR_WIDTH,\n                                                    50).getImage();\n        else if (participantImage == null)\n            participantImage\n                = ImageLoader.getImage(ImageLoader.DEFAULT_USER_PHOTO)", "refactored_code": "    private static final int AVATAR_HEIGHT = 50;\n            participantImage\n                = ImageUtils.getScaledRoundedIcon(  image,\n                                                    AVATAR_WIDTH,\n                                                    AVATAR_HEIGHT).getImage();\n        else if (participantImage == null)\n            participantImage\n                = ImageLoader.getImage(ImageLoader.DEFAULT_USER_PHOTO)"}
{"magic_number_smell": "\n        this.accountSelectorBox.setRenderer(new DefaultListCellRenderer()\n        {\n            private static final long 0L = 0L;\n\n            @Override\n            public Component getListCellRendererComponent(JList list,", "refactored_code": "    private static final long serialVersionUID = 0L;\n\n        this.accountSelectorBox.setRenderer(new DefaultListCellRenderer()\n        {\n            private static final long serialVersionUID = 0L;\n\n            @Override\n            public Component getListCellRendererComponent(JList list,"}
{"magic_number_smell": "\n    private class SelectorMenu extends SIPCommMenu\n    {\n        private static final long 0L = 0L;\n\n        Image image = ImageLoader.getImage(ImageLoader.DOWN_ARROW_ICON);\n", "refactored_code": "    private static final long serialVersionUID = 0L;\n\n    private class SelectorMenu extends SIPCommMenu\n    {\n        private static final long serialVersionUID = 0L;\n\n        Image image = ImageLoader.getImage(ImageLoader.DOWN_ARROW_ICON);\n"}
{"magic_number_smell": "                    = ImageUtils.getScaledRoundedIcon(\n                            this.avatarBytes,\n                            AVATAR_ICON_WIDTH,\n                            25);\n        return this.avatar;\n    }\n", "refactored_code": "    public static final int AVATAR_ICON_HEIGHT = 25;\n                    = ImageUtils.getScaledRoundedIcon(\n                            this.avatarBytes,\n                            AVATAR_ICON_WIDTH,\n                            AVATAR_ICON_HEIGHT);\n        return this.avatar;\n    }\n"}
{"magic_number_smell": "    private class SelectorMenu\n        extends SIPCommMenu\n    {\n        private static final long 0L = 0L;\n\n        Image image = ImageLoader.getImage(ImageLoader.DOWN_ARROW_ICON);\n", "refactored_code": "    private static final long serialVersionUID = 0L;\n    private class SelectorMenu\n        extends SIPCommMenu\n    {\n        private static final long serialVersionUID = 0L;\n\n        Image image = ImageLoader.getImage(ImageLoader.DOWN_ARROW_ICON);\n"}
{"magic_number_smell": "        okButton.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent e)\n            {\n                option = 1;\n                d.setVisible(false);\n            }\n        });", "refactored_code": "    public static final int OK_OPTION = 1;\n        okButton.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent e)\n            {\n                option = OK_OPTION;\n                d.setVisible(false);\n            }\n        });"}
{"magic_number_smell": "                if (thumbnail != null && thumbnail.length > 0)\n                {\n                    file = tfOpSet.createFileWithThumbnail(\n                        file, 64, THUMBNAIL_HEIGHT,\n                        \"image/png\", thumbnail);\n                }\n            }", "refactored_code": "    private static final int THUMBNAIL_WIDTH = 64;\n                if (thumbnail != null && thumbnail.length > 0)\n                {\n                    file = tfOpSet.createFileWithThumbnail(\n                        file, THUMBNAIL_WIDTH, THUMBNAIL_HEIGHT,\n                        \"image/png\", thumbnail);\n                }\n            }"}
{"magic_number_smell": "    private ChatConversationPanel chatConvPanel;\n\n    private final JPanel mainPanel\n        = new TransparentPanel(new BorderLayout(5, 5));\n\n    private JProgressBar progressBar;\n", "refactored_code": "    private static final int SPACING = 5;\n    private ChatConversationPanel chatConvPanel;\n\n    private final JPanel mainPanel\n        = new TransparentPanel(new BorderLayout(SPACING, SPACING));\n\n    private JProgressBar progressBar;\n"}
{"magic_number_smell": "        {\n            target.append(StringEscapeUtils.escapeHtml4(piece.substring(\n                prevEnd, m.start()\n                    + m.group(1).length())));\n            prevEnd = m.end() - m.group(INDEX_OPTIONAL_SUFFIX_GROUP).length();\n            final String keywordMatch =\n                m.group(INDEX_KEYWORD_MATCH_GROUP).trim();", "refactored_code": "    private static final int INDEX_OPTIONAL_PREFIX_GROUP = 1;\n        {\n            target.append(StringEscapeUtils.escapeHtml4(piece.substring(\n                prevEnd, m.start()\n                    + m.group(INDEX_OPTIONAL_PREFIX_GROUP).length())));\n            prevEnd = m.end() - m.group(INDEX_OPTIONAL_SUFFIX_GROUP).length();\n            final String keywordMatch =\n                m.group(INDEX_KEYWORD_MATCH_GROUP).trim();"}
{"magic_number_smell": "            /**\n             * An eclipse generated serial version uid.\n             */\n            private static final long 4717173525426074284L = 6321836989166142791L;\n\n            @Override\n            public void tableChanged(TableModelEvent e)", "refactored_code": "    private static final long serialVersionUID = 4717173525426074284L;\n            /**\n             * An eclipse generated serial version uid.\n             */\n            private static final long serialVersionUID = 6321836989166142791L;\n\n            @Override\n            public void tableChanged(TableModelEvent e)"}
{"magic_number_smell": "        /**\n         * Serial version UID.\n         */\n        private static final long 0L = 0L;\n\n        private final UIContactDetailImpl contact;\n", "refactored_code": "    private static final long serialVersionUID = 0L;\n        /**\n         * Serial version UID.\n         */\n        private static final long serialVersionUID = 0L;\n\n        private final UIContactDetailImpl contact;\n"}
{"magic_number_smell": "        /**\n         * Serial version UID.\n         */\n        private static final long 0L = 0L;\n\n        private MetaContact metaContact;\n", "refactored_code": "    private static final long serialVersionUID = 0L;\n        /**\n         * Serial version UID.\n         */\n        private static final long serialVersionUID = 0L;\n\n        private MetaContact metaContact;\n"}
{"magic_number_smell": "            {\n\n                resultCount++;\n                if (resultCount <= 30)\n                {\n                    UIGroup uiGroup = null;\n", "refactored_code": "    private static final int INITIAL_CONTACT_COUNT = 30;\n            {\n\n                resultCount++;\n                if (resultCount <= INITIAL_CONTACT_COUNT)\n                {\n                    UIGroup uiGroup = null;\n"}
{"magic_number_smell": "        amap.put(\"main-rename\", new RenameAction());\n        amap.put(\"enter\", new AbstractAction()\n        {\n            private static final long 0L = 0L;\n\n            public void actionPerformed(ActionEvent e)\n            {", "refactored_code": "    private static final long serialVersionUID = 0L;\n        amap.put(\"main-rename\", new RenameAction());\n        amap.put(\"enter\", new AbstractAction()\n        {\n            private static final long serialVersionUID = 0L;\n\n            public void actionPerformed(ActionEvent e)\n            {"}
{"magic_number_smell": "            {\n                resultCount++;\n\n                if (resultCount <= 30)\n                {\n                    UIGroup uiGroup = null;\n                    if (!MetaContactListSource.isRootGroup(parentGroup))", "refactored_code": "    private static final int INITIAL_CONTACT_COUNT = 30;\n            {\n                resultCount++;\n\n                if (resultCount <= INITIAL_CONTACT_COUNT)\n                {\n                    UIGroup uiGroup = null;\n                    if (!MetaContactListSource.isRootGroup(parentGroup))"}
{"magic_number_smell": "                            ImageLoader\n                                .getImage(ImageLoader.DEFAULT_USER_PHOTO)),\n                    AVATAR_ICON_WIDTH,\n                    50);\n        if (!GuiActivator.getConfigurationService().getBoolean(\n            PNAME_DISABLE_AVATAR_MENU, false))\n        {", "refactored_code": "    private static final int AVATAR_ICON_HEIGHT = 50;\n                            ImageLoader\n                                .getImage(ImageLoader.DEFAULT_USER_PHOTO)),\n                    AVATAR_ICON_WIDTH,\n                    AVATAR_ICON_HEIGHT);\n        if (!GuiActivator.getConfigurationService().getBoolean(\n            PNAME_DISABLE_AVATAR_MENU, false))\n        {"}
{"magic_number_smell": "\n                g.drawImage(\n                    arrowImage,\n                    textWidth + 2*10 + 2,\n                    getX()\n                        + (this.getHeight() - arrowImage.getHeight(null)) / 2\n                        + 1,", "refactored_code": "    private static final int IMAGE_INDENT = 10;\n\n                g.drawImage(\n                    arrowImage,\n                    textWidth + 2*IMAGE_INDENT + 2,\n                    getX()\n                        + (this.getHeight() - arrowImage.getHeight(null)) / 2\n                        + 1,"}
{"magic_number_smell": "\n        panel.setBorder(\n                BorderFactory.createEmptyBorder(\n                        5,\n                        5,\n                        5,\n                        5));", "refactored_code": "    private static final int MARGIN = 5;\n\n        panel.setBorder(\n                BorderFactory.createEmptyBorder(\n                        MARGIN,\n                        MARGIN,\n                        MARGIN,\n                        MARGIN));"}
{"magic_number_smell": "         * List of packets queued to be written in the file.\n         */\n        private final EvictingQueue<Packet> pktsToSave\n            = EvictingQueue.create(1000);\n\n        /**\n         * Initializes a new <tt>SaverThread</tt>.", "refactored_code": "    private static final int EVICTING_QUEUE_MAX_SIZE = 1000;\n         * List of packets queued to be written in the file.\n         */\n        private final EvictingQueue<Packet> pktsToSave\n            = EvictingQueue.create(EVICTING_QUEUE_MAX_SIZE);\n\n        /**\n         * Initializes a new <tt>SaverThread</tt>."}
{"magic_number_smell": "        final PresenceWatcherTask task =\n            new PresenceWatcherTask(this.nickWatchList, queryList,\n                serverIdentity);\n        presenceWatcher.schedule(task, 10000L,\n            PRESENCE_WATCHER_PERIOD);\n        logger.trace(\"Basic Poller presence watcher set up.\");\n    }", "refactored_code": "    private static final long INITIAL_PRESENCE_WATCHER_DELAY = 10000L;\n        final PresenceWatcherTask task =\n            new PresenceWatcherTask(this.nickWatchList, queryList,\n                serverIdentity);\n        presenceWatcher.schedule(task, INITIAL_PRESENCE_WATCHER_DELAY,\n            PRESENCE_WATCHER_PERIOD);\n        logger.trace(\"Basic Poller presence watcher set up.\");\n    }"}
{"magic_number_smell": "        final String name)\n    {\n        if (name == null || name.isEmpty()\n            || name.length() > 200)\n        {\n            throw new IllegalArgumentException(\"Invalid chat room name.\");\n        }", "refactored_code": "    private static final int MAXIMUM_LENGTH_OF_CHANNEL_NAME = 200;\n        final String name)\n    {\n        if (name == null || name.isEmpty()\n            || name.length() > MAXIMUM_LENGTH_OF_CHANNEL_NAME)\n        {\n            throw new IllegalArgumentException(\"Invalid chat room name.\");\n        }"}
{"magic_number_smell": "        {\n            switch (msg.getNumericCode().intValue())\n            {\n            case 311:\n                final String whoismsg = msg.getText();\n                final int endNickIndex = whoismsg.indexOf(' ');\n                final String nick = whoismsg.substring(0, endNickIndex);", "refactored_code": "        private static final int RPL_WHOISUSER = 311;\n        {\n            switch (msg.getNumericCode().intValue())\n            {\n            case RPL_WHOISUSER:\n                final String whoismsg = msg.getText();\n                final int endNickIndex = whoismsg.indexOf(' ');\n                final String nick = whoismsg.substring(0, endNickIndex);"}
{"magic_number_smell": "            this.alternativeNicks.add(nickName + \"__\");\n            this.alternativeNicks.add(nickName + \"___\");\n            this.alternativeNicks.add(nickName + \"____\");\n            for (int i = 1; i < 10; i++)\n            {\n                this.alternativeNicks.add(nickName + i);\n            }", "refactored_code": "        private static final int NUM_INCREMENTS_FOR_ALTERNATIVES = 10;\n            this.alternativeNicks.add(nickName + \"__\");\n            this.alternativeNicks.add(nickName + \"___\");\n            this.alternativeNicks.add(nickName + \"____\");\n            for (int i = 1; i < NUM_INCREMENTS_FOR_ALTERNATIVES; i++)\n            {\n                this.alternativeNicks.add(nickName + i);\n            }"}
{"magic_number_smell": "        final String command;\n        if (end == -1)\n        {\n            command = msg.substring(1);\n        }\n        else\n        {", "refactored_code": "    private static final int START_OF_COMMAND_INDEX = 1;\n        final String command;\n        if (end == -1)\n        {\n            command = msg.substring(START_OF_COMMAND_INDEX);\n        }\n        else\n        {"}
{"magic_number_smell": "            // cut off list to maximum number of entries allowed by server\n            current = current.subList(0, maxListSize);\n        }\n        final int maxLength = 510 - 10;\n        final StringBuilder query = new StringBuilder();\n        for (String nick : current)\n        {", "refactored_code": "    private static final int MONITOR_ADD_CMD_STATIC_OVERHEAD = 10;\n            // cut off list to maximum number of entries allowed by server\n            current = current.subList(0, maxListSize);\n        }\n        final int maxLength = 510 - MONITOR_ADD_CMD_STATIC_OVERHEAD;\n        final StringBuilder query = new StringBuilder();\n        for (String nick : current)\n        {"}
{"magic_number_smell": "            int code = msgCode.intValue();\n            switch (code)\n            {\n            case 305:\n                PresenceManager.this.currentMessage = \"\";\n                PresenceManager.this.away = false;\n                operationSet.updatePresenceStatus(IrcStatusEnum.AWAY,", "refactored_code": "        private static final int IRC_RPL_UNAWAY = 305;\n            int code = msgCode.intValue();\n            switch (code)\n            {\n            case IRC_RPL_UNAWAY:\n                PresenceManager.this.currentMessage = \"\";\n                PresenceManager.this.away = false;\n                operationSet.updatePresenceStatus(IrcStatusEnum.AWAY,"}
{"magic_number_smell": "            = accountID\n                .getAccountPropertyInt(\n                    ProtocolProviderFactory.SERVER_PORT,\n                    6697);\n        //Verify whether a password has already been stored for this account\n        String serverPassword = IrcActivator.\n            getProtocolProviderFactory().loadPassword(getAccountID());", "refactored_code": "    private static final int DEFAULT_SECURE_IRC_PORT = 6697;\n            = accountID\n                .getAccountPropertyInt(\n                    ProtocolProviderFactory.SERVER_PORT,\n                    DEFAULT_SECURE_IRC_PORT);\n        //Verify whether a password has already been stored for this account\n        String serverPassword = IrcActivator.\n            getProtocolProviderFactory().loadPassword(getAccountID());"}
{"magic_number_smell": "        final long timestamp = channellist.getTimestamp();\n        cleanUpJob.schedule(new ChannelListCacheCleanUpTask(channellist,\n            timestamp), CHAT_ROOM_LIST_CACHE_EXPIRATION\n            / RATIO_MILLISECONDS_TO_NANOSECONDS + 1000L);\n    }\n\n    /**", "refactored_code": "    private static final long CACHE_CLEAN_UP_DELAY = 1000L;\n        final long timestamp = channellist.getTimestamp();\n        cleanUpJob.schedule(new ChannelListCacheCleanUpTask(channellist,\n            timestamp), CHAT_ROOM_LIST_CACHE_EXPIRATION\n            / RATIO_MILLISECONDS_TO_NANOSECONDS + CACHE_CLEAN_UP_DELAY);\n    }\n\n    /**"}
{"magic_number_smell": "                }\n                else\n                {\n                    i += 2;\n                    Color background =\n                        parseBackgroundColor(text.substring(i + 1));\n                    if (background != null)", "refactored_code": "    private static final int INDEX_END_FOREGROUND_COLOR_CODE = 2;\n                }\n                else\n                {\n                    i += INDEX_END_FOREGROUND_COLOR_CODE;\n                    Color background =\n                        parseBackgroundColor(text.substring(i + 1));\n                    if (background != null)"}
{"magic_number_smell": "            // cut off list to maximum number of entries allowed by server\n            current = current.subList(0, maxListSize);\n        }\n        final int maxLength = 510 - 6;\n        final StringBuilder query = new StringBuilder();\n        for (String nick : current)\n        {", "refactored_code": "    private static final int WATCH_ADD_CMD_STATIC_OVERHEAD = 6;\n            // cut off list to maximum number of entries allowed by server\n            current = current.subList(0, maxListSize);\n        }\n        final int maxLength = 510 - WATCH_ADD_CMD_STATIC_OVERHEAD;\n        final StringBuilder query = new StringBuilder();\n        for (String nick : current)\n        {"}
{"magic_number_smell": "            TransportAddress addr\n                = new TransportAddress(\n                        DEFAULT_STUN_SERVER_ADDRESS,\n                        3478,\n                        Transport.UDP);\n\n            agent.addCandidateHarvester(new StunCandidateHarvester(addr));", "refactored_code": "    protected static final int DEFAULT_STUN_SERVER_PORT = 3478;\n            TransportAddress addr\n                = new TransportAddress(\n                        DEFAULT_STUN_SERVER_ADDRESS,\n                        DEFAULT_STUN_SERVER_PORT,\n                        Transport.UDP);\n\n            agent.addCandidateHarvester(new StunCandidateHarvester(addr));"}
{"magic_number_smell": "    /**\n     * Remove from our <tt>jids</tt> map all entries that have not seen any\n     * activity (i.e. neither outgoing nor incoming messags) for more than\n     * 10*60*1000. Note that this method is not synchronous and that\n     * it is only meant for use by the {@link #getThreadIDForAddress(BareJid)} and\n     * {@link #putJidForAddress(Jid, String)}\n     */", "refactored_code": "    private static final long JID_INACTIVITY_TIMEOUT = 10*60*1000;//10 min.\n    /**\n     * Remove from our <tt>jids</tt> map all entries that have not seen any\n     * activity (i.e. neither outgoing nor incoming messags) for more than\n     * JID_INACTIVITY_TIMEOUT. Note that this method is not synchronous and that\n     * it is only meant for use by the {@link #getThreadIDForAddress(BareJid)} and\n     * {@link #putJidForAddress(Jid, String)}\n     */"}
{"magic_number_smell": "\n        final long timeSinceLastCoin = System.currentTimeMillis()\n                - callPeerJabber.getLastConferenceInfoSentTimestamp();\n        if (timeSinceLastCoin < 200)\n        {\n            if (callPeerJabber.isConfInfoScheduled())\n                return;", "refactored_code": "    private static final int COIN_MIN_INTERVAL = 200;\n\n        final long timeSinceLastCoin = System.currentTimeMillis()\n                - callPeerJabber.getLastConferenceInfoSentTimestamp();\n        if (timeSinceLastCoin < COIN_MIN_INTERVAL)\n        {\n            if (callPeerJabber.isConfInfoScheduled())\n                return;"}
{"magic_number_smell": "        opSetBasicIM2.sendInstantMessage(contact1, opSetBasicIM2\n            .createMessage(body));\n\n        sendersEventCollector.waitForEvent(1000);\n        opSetBasicIM2.removeMessageListener(sendersEventCollector);\n\n        // assert reception of a message event", "refactored_code": "    private static final long timeout = 1000;\n        opSetBasicIM2.sendInstantMessage(contact1, opSetBasicIM2\n            .createMessage(body));\n\n        sendersEventCollector.waitForEvent(timeout);\n        opSetBasicIM2.removeMessageListener(sendersEventCollector);\n\n        // assert reception of a message event"}
{"magic_number_smell": "            room = null;\n            switch (eventType)\n            {\n                case 1:\n                    opSet.addInvitationListener(this);\n                    opSet.addInvitationRejectionListener(this);\n                    break;", "refactored_code": "        private static final int EVENT_INVITE = 1;\n            room = null;\n            switch (eventType)\n            {\n                case EVENT_INVITE:\n                    opSet.addInvitationListener(this);\n                    opSet.addInvitationRejectionListener(this);\n                    break;"}
{"magic_number_smell": "                    final Timer timer = new Timer();\n                    int interval = retransmitsRingingInterval;\n                    int delay = 0;\n                    for(int i = 0; i < 3; i++)\n                    {\n                        delay += interval;\n                        timer.schedule(new RingingResponseTask(response,", "refactored_code": "    private static final int MAX_RETRANSMISSIONS = 3;\n                    final Timer timer = new Timer();\n                    int interval = retransmitsRingingInterval;\n                    int delay = 0;\n                    for(int i = 0; i < MAX_RETRANSMISSIONS; i++)\n                    {\n                        delay += interval;\n                        timer.schedule(new RingingResponseTask(response,"}
{"magic_number_smell": "        String callId = callIdHeader.getCallId();\n\n        // interval too brief\n        if ((expires < 120) && (expires > 0))\n        {\n            // send him a 423\n            Response response;", "refactored_code": "    private static final int SUBSCRIBE_MIN_EXPIRE = 120;\n        String callId = callIdHeader.getCallId();\n\n        // interval too brief\n        if ((expires < SUBSCRIBE_MIN_EXPIRE) && (expires > 0))\n        {\n            // send him a 423\n            Response response;"}
{"magic_number_smell": "                new EventPackageSubscriber(\n                        provider,\n                        EVENT_PACKAGE,\n                        3600,\n                        CONTENT_SUB_TYPE,\n                        timer,\n                        REFRESH_MARGIN)", "refactored_code": "    private static final int SUBSCRIPTION_DURATION = 3600;\n                new EventPackageSubscriber(\n                        provider,\n                        EVENT_PACKAGE,\n                        SUBSCRIPTION_DURATION,\n                        CONTENT_SUB_TYPE,\n                        timer,\n                        REFRESH_MARGIN)"}
{"magic_number_smell": "        this.subscriptionDuration\n            = (subscriptionExpiration > 0)\n                ? subscriptionExpiration\n                : 3600;\n\n        if (this.presenceEnabled)\n        {", "refactored_code": "    private static final int PRESENCE_DEFAULT_EXPIRE = 3600;\n        this.subscriptionDuration\n            = (subscriptionExpiration > 0)\n                ? subscriptionExpiration\n                : PRESENCE_DEFAULT_EXPIRE;\n\n        if (this.presenceEnabled)\n        {"}
{"magic_number_smell": "            = new EventPackageSubscriber(\n            this.provider,\n            EVENT_PACKAGE,\n            3600,\n            CONTENT_SUB_TYPE,\n            this.timer,\n            REFRESH_MARGIN);", "refactored_code": "    private static final int SUBSCRIPTION_DURATION = 3600;\n            = new EventPackageSubscriber(\n            this.provider,\n            EVENT_PACKAGE,\n            SUBSCRIPTION_DURATION,\n            CONTENT_SUB_TYPE,\n            this.timer,\n            REFRESH_MARGIN);"}
{"magic_number_smell": "                        SUBSCRIPTION_DURATION,\n                        CONTENT_SUB_TYPE,\n                        this.timer,\n                        60);\n        this.notifier\n                = new ConferenceEventPackageNotifier(this.parentProvider,\n                    this.timer);", "refactored_code": "    private static final int REFRESH_MARGIN = 60;\n                        SUBSCRIPTION_DURATION,\n                        CONTENT_SUB_TYPE,\n                        this.timer,\n                        REFRESH_MARGIN);\n        this.notifier\n                = new ConferenceEventPackageNotifier(this.parentProvider,\n                    this.timer);"}
{"magic_number_smell": "        // <refresh>\n        NodeList refreshList = doc.getElementsByTagNameNS(NS_VALUE,\n                REFRESH_ELEMENT);\n        int refresh = 120;\n        if (refreshList.getLength() != 0)\n        {\n           Node refreshNode = refreshList.item(0);", "refactored_code": "    private static final int REFRESH_DEFAULT_TIME = 120;\n        // <refresh>\n        NodeList refreshList = doc.getElementsByTagNameNS(NS_VALUE,\n                REFRESH_ELEMENT);\n        int refresh = REFRESH_DEFAULT_TIME;\n        if (refreshList.getLength() != 0)\n        {\n           Node refreshNode = refreshList.item(0);"}
{"magic_number_smell": "\n    /**\n     * Initializes and returns this provider's default maxForwardsHeader field\n     * using the value specified by 70.\n     *\n     * @return an instance of a MaxForwardsHeader that can be used when\n     * sending requests", "refactored_code": "    private static final int  MAX_FORWARDS = 70;\n\n    /**\n     * Initializes and returns this provider's default maxForwardsHeader field\n     * using the value specified by MAX_FORWARDS.\n     *\n     * @return an instance of a MaxForwardsHeader that can be used when\n     * sending requests"}
{"magic_number_smell": "    * The amount of time (in seconds) that registration take to expire or\n    * otherwise put - the number of seconds we wait before re-registering.\n    */\n    private int registrationsExpiration = 600;\n\n    /**\n    * Keeps our current registration state.", "refactored_code": "    private static final int DEFAULT_REGISTRATION_EXPIRATION = 600;\n    * The amount of time (in seconds) that registration take to expire or\n    * otherwise put - the number of seconds we wait before re-registering.\n    */\n    private int registrationsExpiration = DEFAULT_REGISTRATION_EXPIRATION;\n\n    /**\n    * Keeps our current registration state."}
{"magic_number_smell": "        {\n            if(evt.getNewState() == RegistrationState.UNREGISTERING)\n            {\n                new Timer().schedule(this, 20000);\n            }\n            else\n            {", "refactored_code": "        private static final int TIME_FOR_PP_TO_UNREGISTER = 20000;\n        {\n            if(evt.getNewState() == RegistrationState.UNREGISTERING)\n            {\n                new Timer().schedule(this, TIME_FOR_PP_TO_UNREGISTER);\n            }\n            else\n            {"}
{"magic_number_smell": "        /* set timeout so that we will not blocked forever if we\n         * have no response from DHCP server\n         */\n        socket.setSoTimeout(10000);\n    }\n\n    /**", "refactored_code": "    private static final int DHCP_TIMEOUT = 10000;\n        /* set timeout so that we will not blocked forever if we\n         * have no response from DHCP server\n         */\n        socket.setSoTimeout(DHCP_TIMEOUT);\n    }\n\n    /**"}
{"magic_number_smell": "        }\n\n        ServiceInfo info = jmdns.getServiceInfo(\"_https._tcp.local\",\n                \"Provisioning URL\", 2000);\n\n        if(info == null)\n        {", "refactored_code": "    private static final int MDNS_TIMEOUT = 2000;\n        }\n\n        ServiceInfo info = jmdns.getServiceInfo(\"_https._tcp.local\",\n                \"Provisioning URL\", MDNS_TIMEOUT);\n\n        if(info == null)\n        {"}
{"magic_number_smell": "    public DirectImage(ConfigurationService configService)\n    {\n        logger.trace(\"Creating a Direct Image Link Source.\");\n        imgMaxSize = configService.getInt(MAX_IMG_SIZE, 2 * 1024 * 1024);\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_IMG_MAX_SIZE = 2 * 1024 * 1024;\n    public DirectImage(ConfigurationService configService)\n    {\n        logger.trace(\"Creating a Direct Image Link Source.\");\n        imgMaxSize = configService.getInt(MAX_IMG_SIZE, DEFAULT_IMG_MAX_SIZE);\n    }\n\n    /**"}
{"magic_number_smell": "        // TODO: better way to get the Sparkle Framework path?\n        initSparkle(System.getProperty(\"user.dir\")\n                    + \"/../../Frameworks/Sparkle.framework\",\n                    updateAtStartup, 86400, downloadLink, title);\n\n        if (logger.isInfoEnabled())\n            logger.info(\"Sparkle Plugin ...[Started]\");", "refactored_code": "    private final int checkInterval = 86400;  // 1 day\n        // TODO: better way to get the Sparkle Framework path?\n        initSparkle(System.getProperty(\"user.dir\")\n                    + \"/../../Frameworks/Sparkle.framework\",\n                    updateAtStartup, checkInterval, downloadLink, title);\n\n        if (logger.isInfoEnabled())\n            logger.info(\"Sparkle Plugin ...[Started]\");"}
{"magic_number_smell": "            // Just checked the impl and this doesn't seem to ever be thrown\n            // .... ignore ...\n            logger.error(\"Couldn't create server socket\", exc);\n            return 300;\n        }\n\n        try", "refactored_code": "    public static final int LOCK_ERROR = 300;\n            // Just checked the impl and this doesn't seem to ever be thrown\n            // .... ignore ...\n            logger.error(\"Couldn't create server socket\", exc);\n            return LOCK_ERROR;\n        }\n\n        try"}
{"magic_number_smell": "    /**\n     * Runs in a daemon thread started by {@link #stop(BundleContext)} and\n     * forcibly terminates the currently running Java virtual machine after\n     * {@link #5000} (or {@link #SHUTDOWN_TIMEOUT_PNAME})\n     * milliseconds.\n     */\n    private static void runInShutdownTimeoutThread()", "refactored_code": "    private static final long SHUTDOWN_TIMEOUT_DEFAULT = 5000;//ms\n    /**\n     * Runs in a daemon thread started by {@link #stop(BundleContext)} and\n     * forcibly terminates the currently running Java virtual machine after\n     * {@link #SHUTDOWN_TIMEOUT_DEFAULT} (or {@link #SHUTDOWN_TIMEOUT_PNAME})\n     * milliseconds.\n     */\n    private static void runInShutdownTimeoutThread()"}
{"magic_number_smell": "            {\n                handleVersionArg();\n                //we're supposed to exit after printing version info\n                returnAction = 0;\n                break;\n            }\n            else if (args[i].equals(\"--help\") || args[i].equals(\"-h\"))", "refactored_code": "    public static final int ACTION_EXIT = 0;\n            {\n                handleVersionArg();\n                //we're supposed to exit after printing version info\n                returnAction = ACTION_EXIT;\n                break;\n            }\n            else if (args[i].equals(\"--help\") || args[i].equals(\"-h\"))"}
{"magic_number_smell": "        /**\n         * Serial version UID.\n         */\n        private static final long 0L = 0L;\n\n        @Override\n        public Component getListCellRendererComponent(", "refactored_code": "    private static final long serialVersionUID = 0L;\n        /**\n         * Serial version UID.\n         */\n        private static final long serialVersionUID = 0L;\n\n        @Override\n        public Component getListCellRendererComponent("}
{"magic_number_smell": "        case kABPhoneProperty:\n            c = Category.Phone;\n            break;\n        case 0:\n            sc = SubCategory.AIM;\n            c = Category.InstantMessaging;\n            break;", "refactored_code": "    public static final int kABAIMInstantProperty = 0;\n        case kABPhoneProperty:\n            c = Category.Phone;\n            break;\n        case kABAIMInstantProperty:\n            sc = SubCategory.AIM;\n            c = Category.InstantMessaging;\n            break;"}
{"magic_number_smell": "            PR_HOME2_TELEPHONE_NUMBER,\n            PR_MOBILE_TELEPHONE_NUMBER,\n            PR_OTHER_TELEPHONE_NUMBER,\n            12,\n            dispidEmail2EmailAddress,\n            dispidEmail3EmailAddress,\n            PR_COMPANY_NAME,", "refactored_code": "    public static final int dispidEmail1EmailAddress = 12;\n            PR_HOME2_TELEPHONE_NUMBER,\n            PR_MOBILE_TELEPHONE_NUMBER,\n            PR_OTHER_TELEPHONE_NUMBER,\n            dispidEmail1EmailAddress,\n            dispidEmail2EmailAddress,\n            dispidEmail3EmailAddress,\n            PR_COMPANY_NAME,"}
{"magic_number_smell": "                + \" path \" + logFileName);\n\n            MAPIInitialize(\n                    0,\n                    MAPI_MULTITHREAD_NOTIFICATIONS,\n                    notificationDelegate,\n                    logFileName,", "refactored_code": "    private static final long MAPI_INIT_VERSION = 0;\n                + \" path \" + logFileName);\n\n            MAPIInitialize(\n                    MAPI_INIT_VERSION,\n                    MAPI_MULTITHREAD_NOTIFICATIONS,\n                    notificationDelegate,\n                    logFileName,"}
{"magic_number_smell": "        Object[] props = null;\n        props\n            = IMAPIProp_GetProps(id, MAPICalendarProperties.getALLPropertyIDs(),\n                0x80000000);\n\n        addCalendarItem(props, id);\n    }", "refactored_code": "    public static final long MAPI_UNICODE = 0x80000000;\n        Object[] props = null;\n        props\n            = IMAPIProp_GetProps(id, MAPICalendarProperties.getALLPropertyIDs(),\n                MAPI_UNICODE);\n\n        addCalendarItem(props, id);\n    }"}
{"magic_number_smell": "        /**\n         * Serial version UID.\n         */\n        private static final long 0L = 0L;\n\n        private boolean isSelected = false;\n", "refactored_code": "    private static final long serialVersionUID = 0L;\n        /**\n         * Serial version UID.\n         */\n        private static final long serialVersionUID = 0L;\n\n        private boolean isSelected = false;\n"}
{"magic_number_smell": "    @Override\n    public int getType()\n    {\n        return CONTACT_LIST_TYPE;\n    }\n\n    /**", "refactored_code": "    public static final int BLF_TYPE = CONTACT_LIST_TYPE;\n    @Override\n    public int getType()\n    {\n        return BLF_TYPE;\n    }\n\n    /**"}
{"magic_number_smell": "        /**\n         * Serial version UID.\n         */\n        private static final long 0L = 0L;\n\n        @Override\n        public Component getTableCellRendererComponent(JTable table, Object value,", "refactored_code": "    private static final long serialVersionUID = 0L;\n        /**\n         * Serial version UID.\n         */\n        private static final long serialVersionUID = 0L;\n\n        @Override\n        public Component getTableCellRendererComponent(JTable table, Object value,"}
{"magic_number_smell": "        /**\n         * Serial version UID.\n         */\n        private static final long 0L = 0L;\n\n        @Override\n        public Component getListCellRendererComponent(", "refactored_code": "    private static final long serialVersionUID = 0L;\n        /**\n         * Serial version UID.\n         */\n        private static final long serialVersionUID = 0L;\n\n        @Override\n        public Component getListCellRendererComponent("}
{"magic_number_smell": "        /**\n         * Serial version UID.\n         */\n        private static final long 0L = 0L;\n\n        private boolean isSelected;\n", "refactored_code": "    private static final long serialVersionUID = 0L;\n        /**\n         * Serial version UID.\n         */\n        private static final long serialVersionUID = 0L;\n\n        private boolean isSelected;\n"}
{"magic_number_smell": "        /**\n         * Serial version UID.\n         */\n        private static final long 0L = 0L;\n\n        /**\n         * The regular expression (in the form of compiled <tt>Pattern</tt>)", "refactored_code": "    private static final long serialVersionUID = 0L;\n        /**\n         * Serial version UID.\n         */\n        private static final long serialVersionUID = 0L;\n\n        /**\n         * The regular expression (in the form of compiled <tt>Pattern</tt>)"}
{"magic_number_smell": "        /**\n         * Serial version UID.\n         */\n        private static final long 0L = 0L;\n\n        SwingDragGestureRecognizer(DragGestureListener dgl)\n        {", "refactored_code": "    private static final long serialVersionUID = 0L;\n        /**\n         * Serial version UID.\n         */\n        private static final long serialVersionUID = 0L;\n\n        SwingDragGestureRecognizer(DragGestureListener dgl)\n        {"}
{"magic_number_smell": "        /**\n         * Serial version UID.\n         */\n        private static final long 0L = 0L;\n\n        final static int FILE = 0;\n        final static int STRING = 1;", "refactored_code": "    private static final long serialVersionUID = 0L;\n        /**\n         * Serial version UID.\n         */\n        private static final long serialVersionUID = 0L;\n\n        final static int FILE = 0;\n        final static int STRING = 1;"}
{"magic_number_smell": "        /**\n         * Serial version UID.\n         */\n        private static final long 0L = 0L;\n\n        public void actionPerformed(ActionEvent e)\n        {", "refactored_code": "    private static final long serialVersionUID = 0L;\n        /**\n         * Serial version UID.\n         */\n        private static final long serialVersionUID = 0L;\n\n        public void actionPerformed(ActionEvent e)\n        {"}
{"magic_number_smell": "\n    /**\n     * Change the selection mode for the file choose.\n     * Possible values are DIRECTORIES_ONLY or 0, default is\n     * 0.\n     *\n     * @param mode the mode to use.", "refactored_code": "    public static final int FILES_ONLY = 0;\n\n    /**\n     * Change the selection mode for the file choose.\n     * Possible values are DIRECTORIES_ONLY or FILES_ONLY, default is\n     * FILES_ONLY.\n     *\n     * @param mode the mode to use."}
{"magic_number_smell": "        {\n            List<Image> logos = new ArrayList<Image>(6)\n            {\n                private static final long 0L = 0L;\n                {\n                    add(DesktopUtilActivator.getImage(\n                        \"service.gui.SIP_COMMUNICATOR_LOGO\"));", "refactored_code": "    private static final long serialVersionUID = 0L;\n        {\n            List<Image> logos = new ArrayList<Image>(6)\n            {\n                private static final long serialVersionUID = 0L;\n                {\n                    add(DesktopUtilActivator.getImage(\n                        \"service.gui.SIP_COMMUNICATOR_LOGO\"));"}
{"magic_number_smell": "        extends JViewport\n        implements Skinnable\n    {\n        private static final long 0L = 1L;\n\n        private BufferedImage bgImage;\n", "refactored_code": "    private static final long serialVersionUID = 0L;\n        extends JViewport\n        implements Skinnable\n    {\n        private static final long serialVersionUID = 1L;\n\n        private BufferedImage bgImage;\n"}
{"magic_number_smell": "            /**\n             * Serial version UID.\n             */\n            private static final long 0L = 0L;\n\n            @Override\n            protected void close(boolean isEscaped)", "refactored_code": "    private static final long serialVersionUID = 0L;\n            /**\n             * Serial version UID.\n             */\n            private static final long serialVersionUID = 0L;\n\n            @Override\n            protected void close(boolean isEscaped)"}
{"magic_number_smell": "\n    private int overTabIndex = -1;\n\n    private int closeIndexStatus = 0;\n\n    private int maxIndexStatus = 0;\n", "refactored_code": "    private static final int INACTIVE = 0;\n\n    private int overTabIndex = -1;\n\n    private int closeIndexStatus = INACTIVE;\n\n    private int maxIndexStatus = INACTIVE;\n"}
{"magic_number_smell": "     * Buttons corresponding to images.\n     */\n    private SIPCommButton recentImagesButtons[] =\n        new SIPCommButton[8];\n\n    /**\n     * Next free image index number.", "refactored_code": "    private static final int MAX_STORED_IMAGES = 8;\n     * Buttons corresponding to images.\n     */\n    private SIPCommButton recentImagesButtons[] =\n        new SIPCommButton[MAX_STORED_IMAGES];\n\n    /**\n     * Next free image index number."}
{"magic_number_smell": "\n        public TimerImage(String second)\n        {\n            Dimension d = new Dimension(30, HEIGHT);\n            this.setPreferredSize(d);\n            this.setMinimumSize(d);\n", "refactored_code": "        private static final int WIDTH = 30;\n\n        public TimerImage(String second)\n        {\n            Dimension d = new Dimension(WIDTH, HEIGHT);\n            this.setPreferredSize(d);\n            this.setMinimumSize(d);\n"}
{"magic_number_smell": "        /**\n         * Serial version UID.\n         */\n        private static final long 0L = 0L;\n\n        private List<Entry> data = new ArrayList<Entry>();\n", "refactored_code": "    private static final long serialVersionUID = 0L;\n        /**\n         * Serial version UID.\n         */\n        private static final long serialVersionUID = 0L;\n\n        private List<Entry> data = new ArrayList<Entry>();\n"}
{"magic_number_smell": "                /**\n                 * Serial version UID.\n                 */\n                private static final long 0L = 0L;\n\n                @Override\n                protected void setValue(Object value)", "refactored_code": "    private static final long serialVersionUID = 0L;\n                /**\n                 * Serial version UID.\n                 */\n                private static final long serialVersionUID = 0L;\n\n                @Override\n                protected void setValue(Object value)"}
{"magic_number_smell": "        bitrateField.setText(\n                ((Integer)configurationService.getInt(\n                        Constants.PROP_OPUS_BITRATE,\n                        32))\n                .toString());\n        bitrateField.addFocusListener(new FocusListener() {\n            public void focusGained(FocusEvent focusEvent) {}", "refactored_code": "    private static final int BITRATE_DEFAULT = 32;\n        bitrateField.setText(\n                ((Integer)configurationService.getInt(\n                        Constants.PROP_OPUS_BITRATE,\n                        BITRATE_DEFAULT))\n                .toString());\n        bitrateField.addFocusListener(new FocusListener() {\n            public void focusGained(FocusEvent focusEvent) {}"}
{"magic_number_smell": "        String enabledDefault = resources.getSettingsString(Preferences.ENABLE);\n\n        String timerDefaultStr = resources.getSettingsString(Preferences.TIMER);\n        int timerDefault = 15;\n\n        if (timerDefaultStr != null)\n        {", "refactored_code": "    public static final int DEFAULT_TIMER = 15;\n        String enabledDefault = resources.getSettingsString(Preferences.ENABLE);\n\n        String timerDefaultStr = resources.getSettingsString(Preferences.TIMER);\n        int timerDefault = DEFAULT_TIMER;\n\n        if (timerDefaultStr != null)\n        {"}
{"magic_number_smell": "                    && (possibleStatus >= PresenceStatus.ONLINE_THRESHOLD))\n            {\n                if (status == null\n                        || (Math.abs(possibleStatus - 40)\n                                < Math.abs(\n                                        status.getStatus()\n                                            - 40)))", "refactored_code": "    private static final int AWAY_DEFAULT_STATUS = 40;\n                    && (possibleStatus >= PresenceStatus.ONLINE_THRESHOLD))\n            {\n                if (status == null\n                        || (Math.abs(possibleStatus - AWAY_DEFAULT_STATUS)\n                                < Math.abs(\n                                        status.getStatus()\n                                            - AWAY_DEFAULT_STATUS)))"}
{"magic_number_smell": "    @Override\n    public Dimension getSize()\n    {\n        return new Dimension(WIZARD_DIALOG_WIDTH, 500);\n    }\n\n    /**", "refactored_code": "    private static final int WIZARD_DIALOG_HEIGHT = 500;\n    @Override\n    public Dimension getSize()\n    {\n        return new Dimension(WIZARD_DIALOG_WIDTH, WIZARD_DIALOG_HEIGHT);\n    }\n\n    /**"}
{"magic_number_smell": "    @Override\n    public void execute(final String source, final String line)\n    {\n        if (line.length() < 6)\n        {\n            throw new IllegalArgumentException(\"Missing channel to join.\");\n        }", "refactored_code": "    private static final int END_OF_COMMAND_PREFIX = 6;\n    @Override\n    public void execute(final String source, final String line)\n    {\n        if (line.length() < END_OF_COMMAND_PREFIX)\n        {\n            throw new IllegalArgumentException(\"Missing channel to join.\");\n        }"}
{"magic_number_smell": "    @Override\n    public void execute(final String source, final String line)\n    {\n        if (line.length() < 4)\n        {\n            throw new IllegalArgumentException(\"The message is missing.\");\n        }", "refactored_code": "    private static final int END_OF_ME_COMMAND_PREFIX = 4;\n    @Override\n    public void execute(final String source, final String line)\n    {\n        if (line.length() < END_OF_ME_COMMAND_PREFIX)\n        {\n            throw new IllegalArgumentException(\"The message is missing.\");\n        }"}
{"magic_number_smell": "    @Override\n    public void execute(final String source, final String line)\n    {\n        if (line.length() <= 6)\n        {\n            // does not currently support requesting (and displaying) mode query\n            // results.", "refactored_code": "    private static final int END_OF_MODE_COMMAND_PREFIX = 6;\n    @Override\n    public void execute(final String source, final String line)\n    {\n        if (line.length() <= END_OF_MODE_COMMAND_PREFIX)\n        {\n            // does not currently support requesting (and displaying) mode query\n            // results."}
{"magic_number_smell": "    @Override\n    public void execute(final String source, final String line)\n    {\n        if (line.length() < 5)\n        {\n            throw new IllegalArgumentException(\n                \"Both target nick and message are missing.\");", "refactored_code": "    private static final int END_OF_MSG_COMMAND_PREFIX = 5;\n    @Override\n    public void execute(final String source, final String line)\n    {\n        if (line.length() < END_OF_MSG_COMMAND_PREFIX)\n        {\n            throw new IllegalArgumentException(\n                \"Both target nick and message are missing.\");"}
{"magic_number_smell": "    @Override\n    public void execute(final String source, final String line)\n    {\n        if (line.length() <= 6)\n        {\n            // no name parameter available, so nothing to do here\n            throw new IllegalArgumentException(\"New nick name is missing.\");", "refactored_code": "    private static final int END_OF_COMMAND_PREFIX_INDEX = 6;\n    @Override\n    public void execute(final String source, final String line)\n    {\n        if (line.length() <= END_OF_COMMAND_PREFIX_INDEX)\n        {\n            // no name parameter available, so nothing to do here\n            throw new IllegalArgumentException(\"New nick name is missing.\");"}
{"magic_number_smell": "        /**\n         * Serial version UID.\n         */\n        private static final long 0L = 0L;\n\n        /**\n         * The main panel", "refactored_code": "    private static final long serialVersionUID = 0L;\n        /**\n         * Serial version UID.\n         */\n        private static final long serialVersionUID = 0L;\n\n        /**\n         * The main panel"}
{"magic_number_smell": "   */\n  public static JButton makeThemedButton(String text, final Color reference) {\n    JButton button = new JButton(text) {\n      private static final long 0 = 0;\n\n      @Override\n    public void paintComponent(Graphics g) {", "refactored_code": "   *   private static final long serialVersionUID = 0;\n   */\n  public static JButton makeThemedButton(String text, final Color reference) {\n    JButton button = new JButton(text) {\n      private static final long serialVersionUID = 0;\n\n      @Override\n    public void paintComponent(Graphics g) {"}
{"magic_number_smell": "    private class SIPChooser\n        extends BindingChooser\n    {\n        private static final long 0 = 0;\n\n        // Provides mapping of UI labels to internal action names\n        private HashMap<String, String> actionLabels =", "refactored_code": "    private static final long serialVersionUID = 0;\n    private class SIPChooser\n        extends BindingChooser\n    {\n        private static final long serialVersionUID = 0;\n\n        // Provides mapping of UI labels to internal action names\n        private HashMap<String, String> actionLabels ="}
{"magic_number_smell": "\n    {\n        this.indentField.setPreferredSize(new Dimension(INDENT_WIDTH,\n            25));\n        this.indentField.setForeground(Color.BLACK);\n\n        this.actionField.setPreferredSize(new Dimension(ACTION_WIDTH,", "refactored_code": "    private static final int LINE_HEIGHT = 25;\n\n    {\n        this.indentField.setPreferredSize(new Dimension(INDENT_WIDTH,\n            LINE_HEIGHT));\n        this.indentField.setForeground(Color.BLACK);\n\n        this.actionField.setPreferredSize(new Dimension(ACTION_WIDTH,"}
{"magic_number_smell": "        /**\n         * Serial version UID.\n         */\n        private static final long 0L = 0L;\n\n        /**\n         * The text field ui.", "refactored_code": "    private static final long serialVersionUID = 0L;\n        /**\n         * Serial version UID.\n         */\n        private static final long serialVersionUID = 0L;\n\n        /**\n         * The text field ui."}
{"magic_number_smell": "        /**\n         * Serial version UID.\n         */\n        private static final long 0L = 0L;\n\n        private String[] columnToolTips;\n", "refactored_code": "    private static final long serialVersionUID = 0L;\n        /**\n         * Serial version UID.\n         */\n        private static final long serialVersionUID = 0L;\n\n        private String[] columnToolTips;\n"}
{"magic_number_smell": "        /**\n         * Serial version UID.\n         */\n        private static final long 0L = 0L;\n\n        Image image = OtrActivator.resourceService.getImage(\n                            \"service.gui.icons.DOWN_ARROW_ICON\").getImage();", "refactored_code": "    private static final long serialVersionUID = 0L;\n        /**\n         * Serial version UID.\n         */\n        private static final long serialVersionUID = 0L;\n\n        Image image = OtrActivator.resourceService.getImage(\n                            \"service.gui.icons.DOWN_ARROW_ICON\").getImage();"}
{"magic_number_smell": "                    {\n                        notifyNetworkDown();\n                    }\n                }, 30 * 1000);\n            }\n        }\n    }", "refactored_code": "    private static final long NETWORK_DOWN_THRESHOLD = 30 * 1000;\n                    {\n                        notifyNetworkDown();\n                    }\n                }, NETWORK_DOWN_THRESHOLD);\n            }\n        }\n    }"}
{"magic_number_smell": "        /**\n         * Serial version UID.\n         */\n        private static final long 0L = 0L;\n\n        /**\n         * The table model for the accounts table.", "refactored_code": "    private static final long serialVersionUID = 0L;\n        /**\n         * Serial version UID.\n         */\n        private static final long serialVersionUID = 0L;\n\n        /**\n         * The table model for the accounts table."}
{"magic_number_smell": "        /**\n         * Serial version UID.\n         */\n        private static final long 0L = 0L;\n\n        Image image = Resources.getImage(\"service.gui.icons.DOWN_ARROW_ICON\")\n            .getImage();", "refactored_code": "    private static final long serialVersionUID = 0L;\n        /**\n         * Serial version UID.\n         */\n        private static final long serialVersionUID = 0L;\n\n        Image image = Resources.getImage(\"service.gui.icons.DOWN_ARROW_ICON\")\n            .getImage();"}
{"magic_number_smell": "\n    /**\n     * The name of the property that allows us to override the default\n     * <tt>1500</tt> value.\n     */\n    String PNAME_DNS_PATIENCE =\n        \"net.java.sip.communicator.util.dns.1500\";", "refactored_code": "    public static final int DNS_PATIENCE = 1500;\n\n    /**\n     * The name of the property that allows us to override the default\n     * <tt>DNS_PATIENCE</tt> value.\n     */\n    String PNAME_DNS_PATIENCE =\n        \"net.java.sip.communicator.util.dns.DNS_PATIENCE\";"}
{"magic_number_smell": "\n        if(count <= 0)\n        {\n            count = 20;\n        }\n\n        try", "refactored_code": "    public static final int MAX_RESULT = 20;\n\n        if(count <= 0)\n        {\n            count = MAX_RESULT;\n        }\n\n        try"}
{"magic_number_smell": "    public static class FailedAcquireCredentialException\n        extends Exception\n    {\n        private static final long 6792589736608633346L = 5810534617383420431L;\n\n        private FailedAcquireCredentialException(final Throwable cause)\n        {", "refactored_code": "        private static final long serialVersionUID = 6792589736608633346L;\n    public static class FailedAcquireCredentialException\n        extends Exception\n    {\n        private static final long serialVersionUID = 5810534617383420431L;\n\n        private FailedAcquireCredentialException(final Throwable cause)\n        {"}
{"magic_number_smell": "        synchronized (this.docCreateLock)\n        {\n            if (this.currentDoc == null\n                    || this.currentDocElements > 150)\n            {\n                this.createNewDoc(date, this.currentDoc == null);\n            }", "refactored_code": "    public static final int MAX_RECORDS_PER_FILE = 150;\n        synchronized (this.docCreateLock)\n        {\n            if (this.currentDoc == null\n                    || this.currentDocElements > MAX_RECORDS_PER_FILE)\n            {\n                this.createNewDoc(date, this.currentDoc == null);\n            }"}
{"magic_number_smell": "            .setDefaultRequestConfig(RequestConfig.copy(RequestConfig.DEFAULT)\n                .setSocketTimeout(10_000)\n                .setConnectTimeout(10_000)\n                .setMaxRedirects(10)\n                .build())\n            .setDefaultCredentialsProvider(credentialsProvider.get())\n", "refactored_code": "    private static final int MAX_REDIRECTS = 10;\n            .setDefaultRequestConfig(RequestConfig.copy(RequestConfig.DEFAULT)\n                .setSocketTimeout(10_000)\n                .setConnectTimeout(10_000)\n                .setMaxRedirects(MAX_REDIRECTS)\n                .build())\n            .setDefaultCredentialsProvider(credentialsProvider.get())\n"}
{"magic_number_smell": "            if(history != null)\n            {\n                Iterator<HistoryRecord> recs\n                    = history.getReader().findLast(100);\n                SimpleDateFormat sdf\n                    = new SimpleDateFormat(HistoryService.DATE_FORMAT);\n", "refactored_code": "    private static final int NUMBER_OF_MSGS_IN_HISTORY = 100;\n            if(history != null)\n            {\n                Iterator<HistoryRecord> recs\n                    = history.getReader().findLast(NUMBER_OF_MSGS_IN_HISTORY);\n                SimpleDateFormat sdf\n                    = new SimpleDateFormat(HistoryService.DATE_FORMAT);\n"}
{"magic_number_smell": "     */\n    public static final MessageSourceContactPresenceStatus\n        MSG_SRC_CONTACT_ONLINE = new MessageSourceContactPresenceStatus(\n                                        89,\n                                        ONLINE_STATUS);\n\n    /**", "refactored_code": "    public static final int MSG_SRC_CONTACT_ONLINE_THRESHOLD = 89;\n     */\n    public static final MessageSourceContactPresenceStatus\n        MSG_SRC_CONTACT_ONLINE = new MessageSourceContactPresenceStatus(\n                                        MSG_SRC_CONTACT_ONLINE_THRESHOLD,\n                                        ONLINE_STATUS);\n\n    /**"}
{"magic_number_smell": "\n    /**\n     * Returns an event id specifying whether the type of this event (e.g.\n     * 1 or CHAT_ROOM_REMOVED)\n     * @return one of the CHAT_ROOM_XXX int fields of this class.\n     */\n    public int getEventID()", "refactored_code": "    public static final int CHAT_ROOM_ADDED = 1;\n\n    /**\n     * Returns an event id specifying whether the type of this event (e.g.\n     * CHAT_ROOM_ADDED or CHAT_ROOM_REMOVED)\n     * @return one of the CHAT_ROOM_XXX int fields of this class.\n     */\n    public int getEventID()"}
{"magic_number_smell": "    @Override\n    public boolean isOnline()\n    {\n        return getStatus() == 86;\n    }\n    \n}", "refactored_code": "    public static final int CHAT_ROOM_ONLINE_THRESHOLD = 86;\n    @Override\n    public boolean isOnline()\n    {\n        return getStatus() == CHAT_ROOM_ONLINE_THRESHOLD;\n    }\n    \n}"}
{"magic_number_smell": "            {\n                localHost = BsdLocalhostRetriever\n                    .getLocalSocketAddress(new InetSocketAddress(\n                        intendedDestination, 55721));\n            }\n            catch (IOException e)\n            {", "refactored_code": "    private static final int RANDOM_ADDR_DISC_PORT = 55721;\n            {\n                localHost = BsdLocalhostRetriever\n                    .getLocalSocketAddress(new InetSocketAddress(\n                        intendedDestination, RANDOM_ADDR_DISC_PORT));\n            }\n            catch (IOException e)\n            {"}
{"magic_number_smell": "            // longer than the check interval we consider it as a\n            // new check after standby\n            if(!isAfterStandby && last != 0)\n                isAfterStandby = (last + 4*3000 - curr) < 0;\n\n            if(isAfterStandby)\n            {", "refactored_code": "    private static final int CHECK_INTERVAL = 3000; // 3 sec.\n            // longer than the check interval we consider it as a\n            // new check after standby\n            if(!isAfterStandby && last != 0)\n                isAfterStandby = (last + 4*CHECK_INTERVAL - curr) < 0;\n\n            if(isAfterStandby)\n            {"}
{"magic_number_smell": "        synchronized(handlers)\n        {\n            handlers.put(handler.getActionType(), handler);\n            if((handlers.size() == 4) && (notificationCache != null))\n            {\n                for(NotificationData event : notificationCache)\n                    fireNotification(event);", "refactored_code": "    public static final int NUM_ACTIONS = 4;\n        synchronized(handlers)\n        {\n            handlers.put(handler.getActionType(), handler);\n            if((handlers.size() == NUM_ACTIONS) && (notificationCache != null))\n            {\n                for(NotificationData event : notificationCache)\n                    fireNotification(event);"}
{"magic_number_smell": "                        try\n                        {\n                            loadStoredAccountsQueue\n                                .wait(30000);\n                        }\n                        catch (InterruptedException ex)\n                        {", "refactored_code": "    private static final long LOAD_STORED_ACCOUNTS_TIMEOUT = 30000;\n                        try\n                        {\n                            loadStoredAccountsQueue\n                                .wait(LOAD_STORED_ACCOUNTS_TIMEOUT);\n                        }\n                        catch (InterruptedException ex)\n                        {"}
{"magic_number_smell": "     * @return the time at which this <tt>CallPeer</tt> transitioned\n     *         into a state marking the start of the duration of the\n     *         participation in a <tt>Call</tt> or\n     *         {@link #0} if such a transition\n     *         has not been performed\n     */\n    long getCallDurationStartTime();", "refactored_code": "    public static final long CALL_DURATION_START_TIME_UNKNOWN = 0;\n     * @return the time at which this <tt>CallPeer</tt> transitioned\n     *         into a state marking the start of the duration of the\n     *         participation in a <tt>Call</tt> or\n     *         {@link #CALL_DURATION_START_TIME_UNKNOWN} if such a transition\n     *         has not been performed\n     */\n    long getCallDurationStartTime();"}
{"magic_number_smell": "\n    /**\n     * The file transfer direction.\n     * @return returns the direction of the file transfer : 1 or OUT.\n     */\n    public int getDirection();\n", "refactored_code": "    public static final int IN = 1;\n\n    /**\n     * The file transfer direction.\n     * @return returns the direction of the file transfer : IN or OUT.\n     */\n    public int getDirection();\n"}
{"magic_number_smell": "\n    public void addTransformLayer(TransformLayer transformLayer)\n    {\n        this.addTransformLayer(1, transformLayer);\n    }\n\n    public void addTransformLayer(int priority, TransformLayer transformLayer)", "refactored_code": "    private static final int defaultPriority = 1;\n\n    public void addTransformLayer(TransformLayer transformLayer)\n    {\n        this.addTransformLayer(defaultPriority, transformLayer);\n    }\n\n    public void addTransformLayer(int priority, TransformLayer transformLayer)"}
{"magic_number_smell": "     * Indicates whether the user is Online (can be reached) or not.\n     *\n     * @return true if the the status coefficient is higher than the\n     *         20 and false otherwise\n     */\n    public boolean isOnline()\n    {", "refactored_code": "    public static final int ONLINE_THRESHOLD = 20;\n     * Indicates whether the user is Online (can be reached) or not.\n     *\n     * @return true if the the status coefficient is higher than the\n     *         ONLINE_THRESHOLD and false otherwise\n     */\n    public boolean isOnline()\n    {"}
{"magic_number_smell": "      * occurred\n      * @param message the message that triggered this event.\n      * @param eventType indicating the type of the delivered event. It's\n      * either an ACTION_MESSAGE_DELIVERED or a 1.\n      */\n     public AdHocChatRoomMessageDeliveredEvent(  AdHocChatRoom source,\n                                                 Date timestamp,", "refactored_code": "    public static final int CONVERSATION_MESSAGE_DELIVERED = 1;\n      * occurred\n      * @param message the message that triggered this event.\n      * @param eventType indicating the type of the delivered event. It's\n      * either an ACTION_MESSAGE_DELIVERED or a CONVERSATION_MESSAGE_DELIVERED.\n      */\n     public AdHocChatRoomMessageDeliveredEvent(  AdHocChatRoom source,\n                                                 Date timestamp,"}
{"magic_number_smell": "     /**\n      * An error code indicating the reason for the failure of this delivery.\n      */\n     private int errorCode = 1;\n\n     /**\n      * A timestamp indicating the exact date when the event occurred.", "refactored_code": "     public static final int UNKNOWN_ERROR = 1;\n     /**\n      * An error code indicating the reason for the failure of this delivery.\n      */\n     private int errorCode = UNKNOWN_ERROR;\n\n     /**\n      * A timestamp indicating the exact date when the event occurred."}
{"magic_number_smell": "    /**\n     * The type of the event.\n     */\n    private int type = 0;\n\n    /**\n     * Constructs a BLFStatus event.", "refactored_code": "    public static final int STATUS_OFFLINE = 0;\n    /**\n     * The type of the event.\n     */\n    private int type = STATUS_OFFLINE;\n\n    /**\n     * Constructs a BLFStatus event."}
{"magic_number_smell": "     * @param contactResource the <tt>ContactResource</tt> that is concerned by\n     * the change\n     * @param eventType an integer representing the type of this event. One of\n     * the types defined in this class: 0, RESOURCE_REMOVED,\n     * RESOURCE_MODIFIED.\n     */\n    public ContactResourceEvent(Contact source,", "refactored_code": "    public static final int RESOURCE_ADDED = 0;\n     * @param contactResource the <tt>ContactResource</tt> that is concerned by\n     * the change\n     * @param eventType an integer representing the type of this event. One of\n     * the types defined in this class: RESOURCE_ADDED, RESOURCE_REMOVED,\n     * RESOURCE_MODIFIED.\n     */\n    public ContactResourceEvent(Contact source,"}
{"magic_number_smell": "    {\n        room = pRoom;\n\n        if(evtType == 1)\n            room.addMessageListener(this);\n        else if(evtType == PRESENCE_EVENT)\n            room.addParticipantPresenceListener(this);", "refactored_code": "    public static final int MESSAGE_EVENT = 1;\n    {\n        room = pRoom;\n\n        if(evtType == MESSAGE_EVENT)\n            room.addMessageListener(this);\n        else if(evtType == PRESENCE_EVENT)\n            room.addParticipantPresenceListener(this);"}
{"magic_number_smell": "    /**\n     * A field that we use to track mapping IDs.\n     */\n    private byte nextExtensionMapping = 1;\n\n    /**\n     * A table mapping <tt>RTPExtension</tt> instances to the dynamically", "refactored_code": "    public static final int MIN_HEADER_ID = 1;\n    /**\n     * A field that we use to track mapping IDs.\n     */\n    private byte nextExtensionMapping = MIN_HEADER_ID;\n\n    /**\n     * A table mapping <tt>RTPExtension</tt> instances to the dynamically"}
{"magic_number_smell": "        int packetCount\n            = ProtocolMediaActivator.getConfigurationService().getInt(\n                    HOLE_PUNCH_PKT_COUNT_PROPERTY,\n                    3);\n\n        if (packetCount < 0)\n            packetCount = 3;", "refactored_code": "    private static final int DEFAULT_HOLE_PUNCH_PKT_COUNT = 3;\n        int packetCount\n            = ProtocolMediaActivator.getConfigurationService().getInt(\n                    HOLE_PUNCH_PKT_COUNT_PROPERTY,\n                    DEFAULT_HOLE_PUNCH_PKT_COUNT);\n\n        if (packetCount < 0)\n            packetCount = DEFAULT_HOLE_PUNCH_PKT_COUNT;"}
{"magic_number_smell": "    /**\n     * The time in milliseconds between two checks for system idle.\n     */\n    private static int idleStateCheckDelay = 30 * 1000;\n\n    /**\n     * Whether current service is started or stopped.", "refactored_code": "    private static final int CHECK_FOR_IDLE_DEFAULT = 30 * 1000;\n    /**\n     * The time in milliseconds between two checks for system idle.\n     */\n    private static int idleStateCheckDelay = CHECK_FOR_IDLE_DEFAULT;\n\n    /**\n     * Whether current service is started or stopped."}
{"magic_number_smell": "     * @param message   the <code>Object</code> to display\n     * @param title     the title string for the dialog\n     * @param optionType an int designating the options available on the dialog:\n     *                  <code>0</code>, or\n     *                  <code>YES_NO_CANCEL_OPTION</code>\n     * @return one of the YES_OPTION, NO_OPTION,.., XXX_OPTION, indicating the\n     * option selected by the user", "refactored_code": "    public static final int         YES_NO_OPTION = 0;\n     * @param message   the <code>Object</code> to display\n     * @param title     the title string for the dialog\n     * @param optionType an int designating the options available on the dialog:\n     *                  <code>YES_NO_OPTION</code>, or\n     *                  <code>YES_NO_CANCEL_OPTION</code>\n     * @return one of the YES_OPTION, NO_OPTION,.., XXX_OPTION, indicating the\n     * option selected by the user"}
{"magic_number_smell": "    /**\n     * The port for the FTP connection.\n     */\n    private int port = 21;\n\n    /**\n     * Parses the URL, connects to the FTP server and then executes the login.", "refactored_code": "    private final int DEFAULT_PORT = 21;\n    /**\n     * The port for the FTP connection.\n     */\n    private int port = DEFAULT_PORT;\n\n    /**\n     * Parses the URL, connects to the FTP server and then executes the login."}
{"magic_number_smell": "    /**\n     * Number of milliseconds in a standard minute.\n     */\n    public static final long MILLIS_PER_MINUTE = 60 * 1000;\n\n    /**\n     * Number of milliseconds in a standard hour.", "refactored_code": "    public static final long MILLIS_PER_SECOND = 1000;\n    /**\n     * Number of milliseconds in a standard minute.\n     */\n    public static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND;\n\n    /**\n     * Number of milliseconds in a standard hour."}
{"magic_number_smell": "     */\n    public static int getRandomPortNumber()\n    {\n        return getRandomPortNumber(MIN_PORT_NUMBER, 65535);\n    }\n\n    /**", "refactored_code": "    public static final int    MAX_PORT_NUMBER = 65535;\n     */\n    public static int getRandomPortNumber()\n    {\n        return getRandomPortNumber(MIN_PORT_NUMBER, MAX_PORT_NUMBER);\n    }\n\n    /**"}
{"magic_number_smell": "     * Assesses the strength of the password.\n     *\n     * @param pass the password to assess\n     * @return the score for this password between 0 and <tt>42</tt>\n     */\n    public int assessPassword(String pass)\n    {", "refactored_code": "    public static final int TOTAL_POINTS = 42;\n     * Assesses the strength of the password.\n     *\n     * @param pass the password to assess\n     * @return the score for this password between 0 and <tt>TOTAL_POINTS</tt>\n     */\n    public int assessPassword(String pass)\n    {"}
{"magic_number_smell": "\tArrayList<OnKeyListener> keyListeners = new ArrayList();\n\tArrayList<KeyEvent> keyEvents = new ArrayList();\n\tArrayList<TouchEvent> touchEvents = new ArrayList();\n\tint[] touchX = new int[20];\n\tint[] touchY = new int[20];\n\tint[] deltaX = new int[20];\n\tint[] deltaY = new int[20];", "refactored_code": "\tpublic static final int NUM_TOUCHES = 20;\n\tArrayList<OnKeyListener> keyListeners = new ArrayList();\n\tArrayList<KeyEvent> keyEvents = new ArrayList();\n\tArrayList<TouchEvent> touchEvents = new ArrayList();\n\tint[] touchX = new int[NUM_TOUCHES];\n\tint[] touchY = new int[NUM_TOUCHES];\n\tint[] deltaX = new int[NUM_TOUCHES];\n\tint[] deltaY = new int[NUM_TOUCHES];"}
{"magic_number_smell": "\t\tmNumSamples = numSamples;\n\n\t\tmConfigAttribs = new int[] {EGL10.EGL_RED_SIZE, 4, EGL10.EGL_GREEN_SIZE, 4, EGL10.EGL_BLUE_SIZE, 4,\n\t\t\tEGL10.EGL_RENDERABLE_TYPE, 4, EGL10.EGL_NONE};\n\t}\n\n\tpublic EGLConfig chooseConfig (EGL10 egl, EGLDisplay display) {", "refactored_code": "\tprivate static final int EGL_OPENGL_ES2_BIT = 4;\n\t\tmNumSamples = numSamples;\n\n\t\tmConfigAttribs = new int[] {EGL10.EGL_RED_SIZE, 4, EGL10.EGL_GREEN_SIZE, 4, EGL10.EGL_BLUE_SIZE, 4,\n\t\t\tEGL10.EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT, EGL10.EGL_NONE};\n\t}\n\n\tpublic EGLConfig chooseConfig (EGL10 egl, EGLDisplay display) {"}
{"magic_number_smell": "\t\tthis.bufferCount = bufferCount;\n\t\tthis.format = channels > 1 ? AL_FORMAT_STEREO16 : AL_FORMAT_MONO16;\n\t\tthis.sampleRate = sampleRate;\n\t\tsecondsPerBuffer = (float)bufferSize / 2 / channels / sampleRate;\n\t\ttempBuffer = BufferUtils.createByteBuffer(bufferSize);\n\t}\n", "refactored_code": "\tstatic private final int bytesPerSample = 2;\n\t\tthis.bufferCount = bufferCount;\n\t\tthis.format = channels > 1 ? AL_FORMAT_STEREO16 : AL_FORMAT_MONO16;\n\t\tthis.sampleRate = sampleRate;\n\t\tsecondsPerBuffer = (float)bufferSize / bytesPerSample / channels / sampleRate;\n\t\ttempBuffer = BufferUtils.createByteBuffer(bufferSize);\n\t}\n"}
{"magic_number_smell": "\tstatic private final int 4096 * 10 = 4096 * 10;\n\tstatic private final int bufferCount = 3;\n\tstatic private final int bytesPerSample = 2;\n\tstatic private final byte[] tempBytes = new byte[4096 * 10];\n\tstatic private final ByteBuffer tempBuffer = BufferUtils.createByteBuffer(4096 * 10);\n\n\tprivate FloatArray renderedSecondsQueue = new FloatArray(bufferCount);", "refactored_code": "\tstatic private final int bufferSize = 4096 * 10;\n\tstatic private final int bufferSize = 4096 * 10;\n\tstatic private final int bufferCount = 3;\n\tstatic private final int bytesPerSample = 2;\n\tstatic private final byte[] tempBytes = new byte[bufferSize];\n\tstatic private final ByteBuffer tempBuffer = BufferUtils.createByteBuffer(bufferSize);\n\n\tprivate FloatArray renderedSecondsQueue = new FloatArray(bufferCount);"}
{"magic_number_smell": "\t\t}\n\n\t\t// schedule next frame, drop frame(s) if already too late for next frame\n\t\tnextFrame = Math.max(nextFrame + 1000L * 1000L * 1000L / fps, getTime());\n\t}\n\n\t/** This method will initialise the sync method by setting initial values for sleepDurations/yieldDurations and nextFrame.", "refactored_code": "\tprivate static final long NANOS_IN_SECOND = 1000L * 1000L * 1000L;\n\t\t}\n\n\t\t// schedule next frame, drop frame(s) if already too late for next frame\n\t\tnextFrame = Math.max(nextFrame + NANOS_IN_SECOND / fps, getTime());\n\t}\n\n\t/** This method will initialise the sync method by setting initial values for sleepDurations/yieldDurations and nextFrame."}
{"magic_number_smell": "\t\tthis.bufferCount = bufferCount;\n\t\tthis.format = channels > 1 ? AL_FORMAT_STEREO16 : AL_FORMAT_MONO16;\n\t\tthis.sampleRate = sampleRate;\n\t\tsecondsPerBuffer = (float)bufferSize / 2 / channels / sampleRate;\n\t\ttempBuffer = BufferUtils.createByteBuffer(bufferSize);\n\t}\n", "refactored_code": "\tstatic private final int bytesPerSample = 2;\n\t\tthis.bufferCount = bufferCount;\n\t\tthis.format = channels > 1 ? AL_FORMAT_STEREO16 : AL_FORMAT_MONO16;\n\t\tthis.sampleRate = sampleRate;\n\t\tsecondsPerBuffer = (float)bufferSize / bytesPerSample / channels / sampleRate;\n\t\ttempBuffer = BufferUtils.createByteBuffer(bufferSize);\n\t}\n"}
{"magic_number_smell": "\tstatic private final int 4096 * 10 = 4096 * 10;\n\tstatic private final int bufferCount = 3;\n\tstatic private final int bytesPerSample = 2;\n\tstatic private final byte[] tempBytes = new byte[4096 * 10];\n\tstatic private final ByteBuffer tempBuffer = BufferUtils.createByteBuffer(4096 * 10);\n\n\tprivate FloatArray renderedSecondsQueue = new FloatArray(bufferCount);", "refactored_code": "\tstatic private final int bufferSize = 4096 * 10;\n\tstatic private final int bufferSize = 4096 * 10;\n\tstatic private final int bufferCount = 3;\n\tstatic private final int bytesPerSample = 2;\n\tstatic private final byte[] tempBytes = new byte[bufferSize];\n\tstatic private final ByteBuffer tempBuffer = BufferUtils.createByteBuffer(bufferSize);\n\n\tprivate FloatArray renderedSecondsQueue = new FloatArray(bufferCount);"}
{"magic_number_smell": "\t\t\tsb.append(i + \":\" + touchDown[i] + \" \");\n\t\t}\n\t\tGdx.app.error(\"IOSInput\", \"Pointer ID lookup failed: \" + ptr + \", \" + sb.toString());\n\t\treturn -1;\n\t}\n\n\tprivate static class NSSetExtensions extends NSExtensions {", "refactored_code": "\tprivate static final int POINTER_NOT_FOUND = -1;\n\t\t\tsb.append(i + \":\" + touchDown[i] + \" \");\n\t\t}\n\t\tGdx.app.error(\"IOSInput\", \"Pointer ID lookup failed: \" + ptr + \", \" + sb.toString());\n\t\treturn POINTER_NOT_FOUND;\n\t}\n\n\tprivate static class NSSetExtensions extends NSExtensions {"}
{"magic_number_smell": "\t\t\tsb.append(i + \":\" + touchDown[i] + \" \");\n\t\t}\n\t\tGdx.app.error(\"IOSInput\", \"Pointer ID lookup failed: \" + ptr + \", \" + sb.toString());\n\t\treturn -1;\n\t}\n\n\t/** DO NOT EDIT THIS FILE - it is machine generated */", "refactored_code": "\tprivate static final int POINTER_NOT_FOUND = -1;\n\t\t\tsb.append(i + \":\" + touchDown[i] + \" \");\n\t\t}\n\t\tGdx.app.error(\"IOSInput\", \"Pointer ID lookup failed: \" + ptr + \", \" + sb.toString());\n\t\treturn POINTER_NOT_FOUND;\n\t}\n\n\t/** DO NOT EDIT THIS FILE - it is machine generated */"}
{"magic_number_smell": "\t/** Schedules a task to occur once after the specified delay and then a number of additional times at the specified\n\t * interval. */\n\tpublic Task scheduleTask (Task task, float delaySeconds, float intervalSeconds, int repeatCount) {\n\t\tif (task.repeatCount != -1) throw new IllegalArgumentException(\"The same task may not be scheduled twice.\");\n\t\ttask.executeTimeMillis = TimeUtils.nanoTime() / 1000000 + (long)(delaySeconds * 1000);\n\t\ttask.intervalMillis = (long)(intervalSeconds * 1000);\n\t\ttask.repeatCount = repeatCount;", "refactored_code": "\tstatic private final int CANCELLED = -1;\n\t/** Schedules a task to occur once after the specified delay and then a number of additional times at the specified\n\t * interval. */\n\tpublic Task scheduleTask (Task task, float delaySeconds, float intervalSeconds, int repeatCount) {\n\t\tif (task.repeatCount != CANCELLED) throw new IllegalArgumentException(\"The same task may not be scheduled twice.\");\n\t\ttask.executeTimeMillis = TimeUtils.nanoTime() / 1000000 + (long)(delaySeconds * 1000);\n\t\ttask.intervalMillis = (long)(intervalSeconds * 1000);\n\t\ttask.repeatCount = repeatCount;"}
{"magic_number_smell": "\n\t/** @return The current value of the system timer, in nanoseconds. */\n\tpublic static long nanoTime () {\n\t\treturn System.currentTimeMillis() * 1000000;\n\t}\n\n\t/** @return the difference, measured in milliseconds, between the current time and midnight, January 1, 1970 UTC. */", "refactored_code": "\tprivate static final long nanosPerMilli = 1000000;\n\n\t/** @return The current value of the system timer, in nanoseconds. */\n\tpublic static long nanoTime () {\n\t\treturn System.currentTimeMillis() * nanosPerMilli;\n\t}\n\n\t/** @return the difference, measured in milliseconds, between the current time and midnight, January 1, 1970 UTC. */"}
{"magic_number_smell": "\tprivate int charOffset;\n\n\tpublic Utf8Decoder () {\n\t\tthis.state = 0;\n\t}\n\n\tprotected void reset () {", "refactored_code": "\tprivate static final int UTF8_ACCEPT = 0;\n\tprivate int charOffset;\n\n\tpublic Utf8Decoder () {\n\t\tthis.state = UTF8_ACCEPT;\n\t}\n\n\tprotected void reset () {"}
{"magic_number_smell": "\tprivate HandlerRegistration windowHandler;\n\n\t/** The delay between resize checks. */\n\tint resizeCheckDelay = 400;\n\n\t/** A boolean indicating that resize checking should run. */\n\tboolean resizeCheckingEnabled;", "refactored_code": "\tprivate static final int DEFAULT_RESIZE_CHECK_DELAY = 400;\n\tprivate HandlerRegistration windowHandler;\n\n\t/** The delay between resize checks. */\n\tint resizeCheckDelay = DEFAULT_RESIZE_CHECK_DELAY;\n\n\t/** A boolean indicating that resize checking should run. */\n\tboolean resizeCheckingEnabled;"}
{"magic_number_smell": "\t/** Transforms the given vector by this transform\n\t * @param v the vector */\n\tpublic Vector2 mul (Vector2 v) {\n\t\tfloat x = vals[0] + vals[COS] * v.x + -vals[SIN] * v.y;\n\t\tfloat y = vals[POS_Y] + vals[SIN] * v.x + vals[COS] * v.y;\n\n\t\tv.x = x;", "refactored_code": "\tpublic static final int POS_X = 0;\n\t/** Transforms the given vector by this transform\n\t * @param v the vector */\n\tpublic Vector2 mul (Vector2 v) {\n\t\tfloat x = vals[POS_X] + vals[COS] * v.x + -vals[SIN] * v.y;\n\t\tfloat y = vals[POS_Y] + vals[SIN] * v.x + vals[COS] * v.y;\n\n\t\tv.x = x;"}
{"magic_number_smell": "\t/** Transforms the given vector by this transform\n\t * @param v the vector */\n\tpublic Vector2 mul (Vector2 v) {\n\t\tfloat x = vals[0] + vals[COS] * v.x + -vals[SIN] * v.y;\n\t\tfloat y = vals[POS_Y] + vals[SIN] * v.x + vals[COS] * v.y;\n\n\t\tv.x = x;", "refactored_code": "\tpublic static final int POS_X = 0;\n\t/** Transforms the given vector by this transform\n\t * @param v the vector */\n\tpublic Vector2 mul (Vector2 v) {\n\t\tfloat x = vals[POS_X] + vals[COS] * v.x + -vals[SIN] * v.y;\n\t\tfloat y = vals[POS_Y] + vals[SIN] * v.x + vals[COS] * v.y;\n\n\t\tv.x = x;"}
{"magic_number_smell": "\n\t\t// Main iteration loop\n\t\tint iter = 0;\n\t\twhile (iter < 20) {\n\n\t\t\t// Copy simplex so we can identify duplicates.\n\t\t\tsaveCount = simplex.m_count;", "refactored_code": "\tpublic static final int MAX_ITERS = 20;\n\n\t\t// Main iteration loop\n\t\tint iter = 0;\n\t\twhile (iter < MAX_ITERS) {\n\n\t\t\t// Copy simplex so we can identify duplicates.\n\t\t\tsaveCount = simplex.m_count;"}
{"magic_number_smell": "\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (iter == 1000) {\n\t\t\t\t// System.out.println(\"failed, root finder stuck\");\n\t\t\t\t// Root finder got stuck. Semi-victory.\n\t\t\t\toutput.state = TOIOutputState.FAILED;", "refactored_code": "\tpublic static final int MAX_ITERATIONS = 1000;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (iter == MAX_ITERATIONS) {\n\t\t\t\t// System.out.println(\"failed, root finder stuck\");\n\t\t\t\t// Root finder got stuck. Semi-victory.\n\t\t\t\toutput.state = TOIOutputState.FAILED;"}
{"magic_number_smell": "\npublic class Profile {\n\tprivate static final int 20 = 20;\n\tprivate static final float LONG_FRACTION = 1f / 20;\n\tprivate static final int SHORT_AVG_NUMS = 5;\n\tprivate static final float SHORT_FRACTION = 1f / SHORT_AVG_NUMS;\n", "refactored_code": "\tprivate static final int LONG_AVG_NUMS = 20;\n\npublic class Profile {\n\tprivate static final int LONG_AVG_NUMS = 20;\n\tprivate static final float LONG_FRACTION = 1f / LONG_AVG_NUMS;\n\tprivate static final int SHORT_AVG_NUMS = 5;\n\tprivate static final float SHORT_FRACTION = 1f / SHORT_AVG_NUMS;\n"}
{"magic_number_smell": "\t * \n\t * @param gravity the world gravity vector. */\n\tpublic World (Vec2 gravity) {\n\t\tthis(gravity, new DefaultWorldPool(100, WORLD_POOL_CONTAINER_SIZE));\n\t}\n\n\t/** Construct a world object.", "refactored_code": "\tpublic static final int WORLD_POOL_SIZE = 100;\n\t * \n\t * @param gravity the world gravity vector. */\n\tpublic World (Vec2 gravity) {\n\t\tthis(gravity, new DefaultWorldPool(WORLD_POOL_SIZE, WORLD_POOL_CONTAINER_SIZE));\n\t}\n\n\t/** Construct a world object."}
{"magic_number_smell": "\t\t\t\tbx -= R.ex.x * ax + R.ey.x * ay;\n\t\t\t\tby -= R.ex.y * ax + R.ey.y * ay;\n\n\t\t\t\t// final float 1e-3f = 1e-3f;\n\t\t\t\t// B2_NOT_USED(1e-3f);\n\t\t\t\tfor (;;) {\n\t\t\t\t\t//", "refactored_code": "\tpublic static final float k_errorTol = 1e-3f;\n\t\t\t\tbx -= R.ex.x * ax + R.ey.x * ay;\n\t\t\t\tby -= R.ex.y * ax + R.ey.y * ay;\n\n\t\t\t\t// final float k_errorTol = 1e-3f;\n\t\t\t\t// B2_NOT_USED(k_errorTol);\n\t\t\t\tfor (;;) {\n\t\t\t\t\t//"}
{"magic_number_smell": "\t\t}\n\n\t\tupdateContacts(true);\n\t\tif ((groupDef.flags & ParticleType.b2_springParticle) != 0) {\n\t\t\tfor (int k = 0; k < m_contactCount; k++) {\n\t\t\t\tParticleContact contact = m_contactBuffer[k];\n\t\t\t\tint a = contact.indexA;", "refactored_code": "\tprivate static final int k_pairFlags = ParticleType.b2_springParticle;\n\t\t}\n\n\t\tupdateContacts(true);\n\t\tif ((groupDef.flags & k_pairFlags) != 0) {\n\t\t\tfor (int k = 0; k < m_contactCount; k++) {\n\t\t\t\tParticleContact contact = m_contactBuffer[k];\n\t\t\t\tint a = contact.indexA;"}
{"magic_number_smell": "\t}\n\n\t/** Sets the maximum size that will be used when generating texture atlases for glyphs with <tt>generateData()</tt>. The\n\t * default is 1024. By specifying {@link #-1}, the texture atlas will scale as needed.\n\t * \n\t * The power-of-two square texture size will be capped to the given <tt>texSize</tt>. It's recommended that a power-of-two\n\t * value be used here.", "refactored_code": "\tstatic public final int NO_MAXIMUM = -1;\n\t}\n\n\t/** Sets the maximum size that will be used when generating texture atlases for glyphs with <tt>generateData()</tt>. The\n\t * default is 1024. By specifying {@link #NO_MAXIMUM}, the texture atlas will scale as needed.\n\t * \n\t * The power-of-two square texture size will be capped to the given <tt>texSize</tt>. It's recommended that a power-of-two\n\t * value be used here."}
{"magic_number_smell": "\t\tparams.convertObjectToTileSpace = false;\n\t\tparams.flipY = true;\n\n\t\tviewport = new FitViewport(32, WORLD_HEIGHT);\n\t\tcam = (OrthographicCamera)viewport.getCamera();\n\n\t\tmap = atlasTmxMapLoader.load(TMX_LOC, params);", "refactored_code": "\tprivate final float WORLD_WIDTH = 32;\n\t\tparams.convertObjectToTileSpace = false;\n\t\tparams.flipY = true;\n\n\t\tviewport = new FitViewport(WORLD_WIDTH, WORLD_HEIGHT);\n\t\tcam = (OrthographicCamera)viewport.getCamera();\n\n\t\tmap = atlasTmxMapLoader.load(TMX_LOC, params);"}
{"magic_number_smell": "\t\t\t\tint mouseY = event.getY();\n\t\t\t\tint oldIndex = overIndex;\n\t\t\t\toverIndex = -1;\n\t\t\t\tint pointSize = isExpanded ? POINT_SIZE_EXPANDED : 6;\n\t\t\t\tint i = 0;\n\t\t\t\tfor (Point point : points) {\n\t\t\t\t\tint x = chartX + (int)(chartWidth * (point.x / (float)maxX));", "refactored_code": "\tstatic private final int POINT_SIZE = 6;\n\t\t\t\tint mouseY = event.getY();\n\t\t\t\tint oldIndex = overIndex;\n\t\t\t\toverIndex = -1;\n\t\t\t\tint pointSize = isExpanded ? POINT_SIZE_EXPANDED : POINT_SIZE;\n\t\t\t\tint i = 0;\n\t\t\t\tfor (Point point : points) {\n\t\t\t\t\tint x = chartX + (int)(chartWidth * (point.x / (float)maxX));"}
{"magic_number_smell": "\t\tT res = assetManager.get(resolvedPath);\n\t\tif (currentLoader != null) assetManager.setLoader(type, currentLoader);\n\n\t\tif (exist) EventManager.get().fire(0, new Object[] {oldAsset, res});\n\n\t\treturn res;\n\t}", "refactored_code": "\tpublic static final int EVT_ASSET_RELOADED = 0;\n\t\tT res = assetManager.get(resolvedPath);\n\t\tif (currentLoader != null) assetManager.setLoader(type, currentLoader);\n\n\t\tif (exist) EventManager.get().fire(EVT_ASSET_RELOADED, new Object[] {oldAsset, res});\n\n\t\treturn res;\n\t}"}
{"magic_number_smell": "\n\tstatic public final int 256 = 256;\n\n\tstatic private ByteBuffer scratchByteBuffer = ByteBuffer.allocateDirect(256 * 256 * 4);\n\n\tstatic {\n\t\tscratchByteBuffer.order(ByteOrder.LITTLE_ENDIAN);", "refactored_code": "\tstatic public final int MAX_GLYPH_SIZE = 256;\n\n\tstatic public final int MAX_GLYPH_SIZE = 256;\n\n\tstatic private ByteBuffer scratchByteBuffer = ByteBuffer.allocateDirect(MAX_GLYPH_SIZE * MAX_GLYPH_SIZE * 4);\n\n\tstatic {\n\t\tscratchByteBuffer.order(ByteOrder.LITTLE_ENDIAN);"}
{"magic_number_smell": "\t\tpublic Shape createStrokedShape (Shape shape) {\n\t\t\tGeneralPath result = new GeneralPath();\n\t\t\tshape = new BasicStroke(getWidth(), BasicStroke.CAP_SQUARE, getJoin()).createStrokedShape(shape);\n\t\t\tPathIterator it = new FlatteningPathIterator(shape.getPathIterator(null), 1);\n\t\t\tfloat points[] = new float[6];\n\t\t\tfloat moveX = 0, moveY = 0;\n\t\t\tfloat lastX = 0, lastY = 0;", "refactored_code": "\t\tprivate static final float FLATNESS = 1;\n\t\tpublic Shape createStrokedShape (Shape shape) {\n\t\t\tGeneralPath result = new GeneralPath();\n\t\t\tshape = new BasicStroke(getWidth(), BasicStroke.CAP_SQUARE, getJoin()).createStrokedShape(shape);\n\t\t\tPathIterator it = new FlatteningPathIterator(shape.getPathIterator(null), FLATNESS);\n\t\t\tfloat points[] = new float[6];\n\t\t\tfloat moveX = 0, moveY = 0;\n\t\t\tfloat lastX = 0, lastY = 0;"}
{"magic_number_smell": "\n\t\tpublic Shape createStrokedShape (Shape shape) {\n\t\t\tGeneralPath result = new GeneralPath();\n\t\t\tPathIterator it = new FlatteningPathIterator(shape.getPathIterator(null), 1);\n\t\t\tfloat points[] = new float[6];\n\t\t\tfloat moveX = 0, moveY = 0;\n\t\t\tfloat lastX = 0, lastY = 0;", "refactored_code": "\t\tprivate static final float FLATNESS = 1;\n\n\t\tpublic Shape createStrokedShape (Shape shape) {\n\t\t\tGeneralPath result = new GeneralPath();\n\t\t\tPathIterator it = new FlatteningPathIterator(shape.getPathIterator(null), FLATNESS);\n\t\t\tfloat points[] = new float[6];\n\t\t\tfloat moveX = 0, moveY = 0;\n\t\t\tfloat lastX = 0, lastY = 0;"}
{"magic_number_smell": "\t/** The numberof kernels to apply */\n\tpublic static final int 16 = 16;\n\t/** The blur kernels applied across the effect */\n\tpublic static final float[][] GAUSSIAN_BLUR_KERNELS = generateGaussianBlurKernels(16);\n\n\tprivate Color color = Color.black;\n\tprivate float opacity = 0.6f;", "refactored_code": "\tpublic static final int NUM_KERNELS = 16;\n\t/** The numberof kernels to apply */\n\tpublic static final int NUM_KERNELS = 16;\n\t/** The blur kernels applied across the effect */\n\tpublic static final float[][] GAUSSIAN_BLUR_KERNELS = generateGaussianBlurKernels(NUM_KERNELS);\n\n\tprivate Color color = Color.black;\n\tprivate float opacity = 0.6f;"}
{"magic_number_smell": "\t * @param page The image file related to the page the region is in\n\t * @param region The region to extract */\n\tprivate BufferedImage extractNinePatch (BufferedImage page, Region region, File outputDirFile) {\n\t\tBufferedImage splitImage = extractImage(page, region, outputDirFile, 1);\n\t\tGraphics2D g2 = splitImage.createGraphics();\n\t\tg2.setColor(Color.BLACK);\n", "refactored_code": "\tprivate static final int NINEPATCH_PADDING = 1;\n\t * @param page The image file related to the page the region is in\n\t * @param region The region to extract */\n\tprivate BufferedImage extractNinePatch (BufferedImage page, Region region, File outputDirFile) {\n\t\tBufferedImage splitImage = extractImage(page, region, outputDirFile, NINEPATCH_PADDING);\n\t\tGraphics2D g2 = splitImage.createGraphics();\n\t\tg2.setColor(Color.BLACK);\n"}
{"magic_number_smell": "\t/** Logs a debug message to the console or logcat */\n\tpublic void debug (String tag, String message, Throwable exception);\n\n\t/** Sets the log level. {@link #0} will mute all log output. {@link #LOG_ERROR} will only let error messages through.\n\t * {@link #LOG_INFO} will let all non-debug messages through, and {@link #LOG_DEBUG} will let all messages through.\n\t * @param logLevel {@link #0}, {@link #LOG_ERROR}, {@link #LOG_INFO}, {@link #LOG_DEBUG}. */\n\tpublic void setLogLevel (int logLevel);", "refactored_code": "\tpublic static final int LOG_NONE = 0;\n\t/** Logs a debug message to the console or logcat */\n\tpublic void debug (String tag, String message, Throwable exception);\n\n\t/** Sets the log level. {@link #LOG_NONE} will mute all log output. {@link #LOG_ERROR} will only let error messages through.\n\t * {@link #LOG_INFO} will let all non-debug messages through, and {@link #LOG_DEBUG} will let all messages through.\n\t * @param logLevel {@link #LOG_NONE}, {@link #LOG_ERROR}, {@link #LOG_INFO}, {@link #LOG_DEBUG}. */\n\tpublic void setLogLevel (int logLevel);"}
{"magic_number_smell": "\t\tpublic static final int DPAD_UP = 19;\n\t\tpublic static final int CENTER = 23;\n\t\tpublic static final int DOWN = 20;\n\t\tpublic static final int 0 = 21;\n\t\tpublic static final int RIGHT = 22;\n\t\tpublic static final int UP = 19;\n\t\tpublic static final int E = 33;", "refactored_code": "\t\tpublic static final int LEFT = 0;\n\t\tpublic static final int DPAD_UP = 19;\n\t\tpublic static final int CENTER = 23;\n\t\tpublic static final int DOWN = 20;\n\t\tpublic static final int LEFT = 21;\n\t\tpublic static final int RIGHT = 22;\n\t\tpublic static final int UP = 19;\n\t\tpublic static final int E = 33;"}
{"magic_number_smell": "\t\t\tint type = q[i++];\n\t\t\tcurrentEventTime = (long)q[i++] << 32 | q[i++] & 0xFFFFFFFFL;\n\t\t\tswitch (type) {\n\t\t\tcase -1:\n\t\t\t\ti += q[i];\n\t\t\t\tbreak;\n\t\t\tcase KEY_DOWN:", "refactored_code": "\tstatic private final int SKIP = -1;\n\t\t\tint type = q[i++];\n\t\t\tcurrentEventTime = (long)q[i++] << 32 | q[i++] & 0xFFFFFFFFL;\n\t\t\tswitch (type) {\n\t\t\tcase SKIP:\n\t\t\t\ti += q[i];\n\t\t\t\tbreak;\n\t\t\tcase KEY_DOWN:"}
{"magic_number_smell": "\t/** @author mzechner */\n\tstatic private class CIM {\n\t\tstatic private final int 32000 = 32000;\n\t\tstatic private final byte[] writeBuffer = new byte[32000];\n\t\tstatic private final byte[] readBuffer = new byte[32000];\n\n\t\tstatic public void write (FileHandle file, Pixmap pixmap) {", "refactored_code": "\t\tstatic private final int BUFFER_SIZE = 32000;\n\t/** @author mzechner */\n\tstatic private class CIM {\n\t\tstatic private final int BUFFER_SIZE = 32000;\n\t\tstatic private final byte[] writeBuffer = new byte[BUFFER_SIZE];\n\t\tstatic private final byte[] readBuffer = new byte[BUFFER_SIZE];\n\n\t\tstatic public void write (FileHandle file, Pixmap pixmap) {"}
{"magic_number_smell": " * @author Matthias Mann */\npublic class BitmapFont implements Disposable {\n\tstatic private final int 9 = 9;\n\tstatic private final int PAGE_SIZE = 1 << 9;\n\tstatic private final int PAGES = 0x10000 / PAGE_SIZE;\n\n\tfinal BitmapFontData data;", "refactored_code": "\tstatic private final int LOG2_PAGE_SIZE = 9;\n * @author Matthias Mann */\npublic class BitmapFont implements Disposable {\n\tstatic private final int LOG2_PAGE_SIZE = 9;\n\tstatic private final int PAGE_SIZE = 1 << LOG2_PAGE_SIZE;\n\tstatic private final int PAGES = 0x10000 / PAGE_SIZE;\n\n\tfinal BitmapFontData data;"}
{"magic_number_smell": "\n\tpublic static int toGlFormat (int format) {\n\t\tswitch (format) {\n\t\tcase 1:\n\t\t\treturn GL20.GL_ALPHA;\n\t\tcase GDX2D_FORMAT_LUMINANCE_ALPHA:\n\t\t\treturn GL20.GL_LUMINANCE_ALPHA;", "refactored_code": "\tpublic static final int GDX2D_FORMAT_ALPHA = 1;\n\n\tpublic static int toGlFormat (int format) {\n\t\tswitch (format) {\n\t\tcase GDX2D_FORMAT_ALPHA:\n\t\t\treturn GL20.GL_ALPHA;\n\t\tcase GDX2D_FORMAT_LUMINANCE_ALPHA:\n\t\t\treturn GL20.GL_LUMINANCE_ALPHA;"}
{"magic_number_smell": "\t\t\t\t\tfor (int i = 2; i < lineRun.xAdvances.size; i++) {\n\t\t\t\t\t\tGlyph glyph = lineRun.glyphs.get(i - 1);\n\t\t\t\t\t\tfloat glyphWidth = getGlyphWidth(glyph, fontData);\n\t\t\t\t\t\tif (runWidth + glyphWidth - 0.0001f <= targetWidth) {\n\t\t\t\t\t\t\t// Glyph fits.\n\t\t\t\t\t\t\trunWidth += lineRun.xAdvances.items[i];\n\t\t\t\t\t\t\tcontinue;", "refactored_code": "\tstatic private final float epsilon = 0.0001f;\n\t\t\t\t\tfor (int i = 2; i < lineRun.xAdvances.size; i++) {\n\t\t\t\t\t\tGlyph glyph = lineRun.glyphs.get(i - 1);\n\t\t\t\t\t\tfloat glyphWidth = getGlyphWidth(glyph, fontData);\n\t\t\t\t\t\tif (runWidth + glyphWidth - epsilon <= targetWidth) {\n\t\t\t\t\t\t\t// Glyph fits.\n\t\t\t\t\t\t\trunWidth += lineRun.xAdvances.items[i];\n\t\t\t\t\t\t\tcontinue;"}
{"magic_number_smell": "\n\t\tTextureRegion[] patches = new TextureRegion[9];\n\t\tif (top > 0) {\n\t\t\tif (left > 0) patches[0] = new TextureRegion(region, 0, 0, left, top);\n\t\t\tif (middleWidth > 0) patches[TOP_CENTER] = new TextureRegion(region, left, 0, middleWidth, top);\n\t\t\tif (right > 0) patches[TOP_RIGHT] = new TextureRegion(region, left + middleWidth, 0, right, top);\n\t\t}", "refactored_code": "\tstatic public final int TOP_LEFT = 0;\n\n\t\tTextureRegion[] patches = new TextureRegion[9];\n\t\tif (top > 0) {\n\t\t\tif (left > 0) patches[TOP_LEFT] = new TextureRegion(region, 0, 0, left, top);\n\t\t\tif (middleWidth > 0) patches[TOP_CENTER] = new TextureRegion(region, left, 0, middleWidth, top);\n\t\t\tif (right > 0) patches[TOP_RIGHT] = new TextureRegion(region, left + middleWidth, 0, right, top);\n\t\t}"}
{"magic_number_smell": "\t\tupdateFlags = 0;\n\t\tif (angleValue.active && angleValue.timeline.length > 1) updateFlags |= UPDATE_ANGLE;\n\t\tif (velocityValue.active) updateFlags |= UPDATE_VELOCITY;\n\t\tif (xScaleValue.timeline.length > 1) updateFlags |= 1 << 0;\n\t\tif (yScaleValue.active && yScaleValue.timeline.length > 1) updateFlags |= 1 << 0;\n\t\tif (rotationValue.active && rotationValue.timeline.length > 1) updateFlags |= UPDATE_ROTATION;\n\t\tif (windValue.active) updateFlags |= UPDATE_WIND;", "refactored_code": "\tstatic private final int UPDATE_SCALE = 1 << 0;\n\t\tupdateFlags = 0;\n\t\tif (angleValue.active && angleValue.timeline.length > 1) updateFlags |= UPDATE_ANGLE;\n\t\tif (velocityValue.active) updateFlags |= UPDATE_VELOCITY;\n\t\tif (xScaleValue.timeline.length > 1) updateFlags |= UPDATE_SCALE;\n\t\tif (yScaleValue.active && yScaleValue.timeline.length > 1) updateFlags |= UPDATE_SCALE;\n\t\tif (rotationValue.active && rotationValue.timeline.length > 1) updateFlags |= UPDATE_ROTATION;\n\t\tif (windValue.active) updateFlags |= UPDATE_WIND;"}
{"magic_number_smell": "\tpublic final static String FogAlias = \"fogColor\";\n\tpublic static final long Fog = register(FogAlias);\n\n\tprotected static long Mask = register(AmbientAlias) | Diffuse | Specular | Emissive | Reflection | AmbientLight | Fog;\n\n\tpublic final static boolean is (final long mask) {\n\t\treturn (mask & Mask) != 0;", "refactored_code": "\tpublic static final long Ambient = register(AmbientAlias);\n\tpublic final static String FogAlias = \"fogColor\";\n\tpublic static final long Fog = register(FogAlias);\n\n\tprotected static long Mask = Ambient | Diffuse | Specular | Emissive | Reflection | AmbientLight | Fog;\n\n\tpublic final static boolean is (final long mask) {\n\t\treturn (mask & Mask) != 0;"}
{"magic_number_smell": "\tpublic static final long register(ShininessAlias) = register(ShininessAlias);\n\n\tpublic static FloatAttribute createShininess (float value) {\n\t\treturn new FloatAttribute(register(ShininessAlias), value);\n\t}\n\n\tpublic static final String AlphaTestAlias = \"alphaTest\";", "refactored_code": "\tpublic static final long Shininess = register(ShininessAlias);\n\tpublic static final long Shininess = register(ShininessAlias);\n\n\tpublic static FloatAttribute createShininess (float value) {\n\t\treturn new FloatAttribute(Shininess, value);\n\t}\n\n\tpublic static final String AlphaTestAlias = \"alphaTest\";"}
{"magic_number_smell": "\t *           front faces only), GL_FRONT (render back faces only), or -1 to inherit default\n\t * @return an attribute */\n\tpublic static IntAttribute createCullFace (int value) {\n\t\treturn new IntAttribute(register(CullFaceAlias), value);\n\t}\n\n\tpublic int value;", "refactored_code": "\tpublic static final long CullFace = register(CullFaceAlias);\n\t *           front faces only), GL_FRONT (render back faces only), or -1 to inherit default\n\t * @return an attribute */\n\tpublic static IntAttribute createCullFace (int value) {\n\t\treturn new IntAttribute(CullFace, value);\n\t}\n\n\tpublic int value;"}
{"magic_number_smell": "\n\t@Override\n\tpublic int decideGroup (Decal decal) {\n\t\treturn decal.getMaterial().isOpaque() ? 0 : GROUP_BLEND;\n\t}\n\n\t@Override", "refactored_code": "\tprivate static final int GROUP_OPAQUE = 0;\n\n\t@Override\n\tpublic int decideGroup (Decal decal) {\n\t\treturn decal.getMaterial().isOpaque() ? GROUP_OPAQUE : GROUP_BLEND;\n\t}\n\n\t@Override"}
{"magic_number_smell": "\t/** Size of a decal vertex in floats */\n\tprivate static final int 3 + 1 + 2 = 3 + 1 + 2;\n\t/** Size of the decal in floats. It takes a float[SIZE] to hold the decal. */\n\tpublic static final int SIZE = 4 * 3 + 1 + 2;\n\n\t/** Temporary vector for various calculations. */\n\tprivate static Vector3 tmp = new Vector3();", "refactored_code": "\tprivate static final int VERTEX_SIZE = 3 + 1 + 2;\n\t/** Size of a decal vertex in floats */\n\tprivate static final int VERTEX_SIZE = 3 + 1 + 2;\n\t/** Size of the decal in floats. It takes a float[SIZE] to hold the decal. */\n\tpublic static final int SIZE = 4 * VERTEX_SIZE;\n\n\t/** Temporary vector for various calculations. */\n\tprivate static Vector3 tmp = new Vector3();"}
{"magic_number_smell": "\t * {@link CameraGroupStrategy}\n\t * @param groupStrategy */\n\tpublic DecalBatch (GroupStrategy groupStrategy) {\n\t\tthis(1000, groupStrategy);\n\t}\n\n\tpublic DecalBatch (int size, GroupStrategy groupStrategy) {", "refactored_code": "\tprivate static final int DEFAULT_SIZE = 1000;\n\t * {@link CameraGroupStrategy}\n\t * @param groupStrategy */\n\tpublic DecalBatch (GroupStrategy groupStrategy) {\n\t\tthis(DEFAULT_SIZE, groupStrategy);\n\t}\n\n\tpublic DecalBatch (int size, GroupStrategy groupStrategy) {"}
{"magic_number_smell": "\n\t/** @return true if the material is completely opaque, false if it is not and therefor requires blending */\n\tpublic boolean isOpaque () {\n\t\treturn srcBlendFactor == -1;\n\t}\n\n\tpublic int getSrcBlendFactor () {", "refactored_code": "\tpublic static final int NO_BLEND = -1;\n\n\t/** @return true if the material is completely opaque, false if it is not and therefor requires blending */\n\tpublic boolean isOpaque () {\n\t\treturn srcBlendFactor == NO_BLEND;\n\t}\n\n\tpublic int getSrcBlendFactor () {"}
{"magic_number_smell": "\n\t@Override\n\tpublic int decideGroup (Decal decal) {\n\t\treturn decal.getMaterial().isOpaque() ? 0 : GROUP_BLEND;\n\t}\n\n\t@Override", "refactored_code": "\tprivate static final int GROUP_OPAQUE = 0;\n\n\t@Override\n\tpublic int decideGroup (Decal decal) {\n\t\treturn decal.getMaterial().isOpaque() ? GROUP_OPAQUE : GROUP_BLEND;\n\t}\n\n\t@Override"}
{"magic_number_smell": "\tpublic final float data[];\n\n\tpublic AmbientCubemap () {\n\t\tdata = new float[6 * 3];\n\t}\n\n\tpublic AmbientCubemap (final float copyFrom[]) {", "refactored_code": "\tprivate static final int NUM_VALUES = 6 * 3;\n\tpublic final float data[];\n\n\tpublic AmbientCubemap () {\n\t\tdata = new float[NUM_VALUES];\n\t}\n\n\tpublic AmbientCubemap (final float copyFrom[]) {"}
{"magic_number_smell": "\t\tJsonValue version = json.require(\"version\");\n\t\tmodel.version[0] = version.getShort(0);\n\t\tmodel.version[1] = version.getShort(1);\n\t\tif (model.version[0] != 0 || model.version[1] != VERSION_LO)\n\t\t\tthrow new GdxRuntimeException(\"Model version not supported\");\n\n\t\tmodel.id = json.getString(\"id\", \"\");", "refactored_code": "\tpublic static final short VERSION_HI = 0;\n\t\tJsonValue version = json.require(\"version\");\n\t\tmodel.version[0] = version.getShort(0);\n\t\tmodel.version[1] = version.getShort(1);\n\t\tif (model.version[0] != VERSION_HI || model.version[1] != VERSION_LO)\n\t\t\tthrow new GdxRuntimeException(\"Model version not supported\");\n\n\t\tmodel.id = json.getString(\"id\", \"\");"}
{"magic_number_smell": "\t\ttransform = new Matrix4();\n\t\tscale = new Vector3(1, 1, 1);\n\t\tinfluencers = new Array<Influencer>(true, 3, Influencer.class);\n\t\tsetTimeStep(1f / 60);\n\t}\n\n\tpublic ParticleController (String name, Emitter emitter, ParticleControllerRenderer<?, ?> renderer,", "refactored_code": "\tprotected static final float DEFAULT_TIME_STEP = 1f / 60;\n\t\ttransform = new Matrix4();\n\t\tscale = new Vector3(1, 1, 1);\n\t\tinfluencers = new Array<Influencer>(true, 3, Influencer.class);\n\t\tsetTimeStep(DEFAULT_TIME_STEP);\n\t}\n\n\tpublic ParticleController (String name, Emitter emitter, ParticleControllerRenderer<?, ?> renderer,"}
{"magic_number_smell": "\t\tnew VertexAttribute(Usage.Position, 3, ShaderProgram.POSITION_ATTRIBUTE),\n\t\tnew VertexAttribute(Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE + \"0\"),\n\t\tnew VertexAttribute(Usage.ColorUnpacked, 4, ShaderProgram.COLOR_ATTRIBUTE),\n\t\tnew VertexAttribute(1 << 9, directionUsage = 1 << 10, 4, \"a_sizeAndRotation\")),\n\t\t/*\n\t\t * GPU_EXT_ATTRIBUTES = new VertexAttributes(new VertexAttribute(Usage.Position, 3, ShaderProgram.POSITION_ATTRIBUTE), new\n\t\t * VertexAttribute(Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE+\"0\"), new VertexAttribute(Usage.Color, 4,", "refactored_code": "\tprotected static final int sizeAndRotationUsage = 1 << 9, directionUsage = 1 << 10;\n\t\tnew VertexAttribute(Usage.Position, 3, ShaderProgram.POSITION_ATTRIBUTE),\n\t\tnew VertexAttribute(Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE + \"0\"),\n\t\tnew VertexAttribute(Usage.ColorUnpacked, 4, ShaderProgram.COLOR_ATTRIBUTE),\n\t\tnew VertexAttribute(sizeAndRotationUsage, 4, \"a_sizeAndRotation\")),\n\t\t/*\n\t\t * GPU_EXT_ATTRIBUTES = new VertexAttributes(new VertexAttribute(Usage.Position, 3, ShaderProgram.POSITION_ATTRIBUTE), new\n\t\t * VertexAttribute(Usage.TextureCoordinates, 2, ShaderProgram.TEXCOORD_ATTRIBUTE+\"0\"), new VertexAttribute(Usage.Color, 4,"}
{"magic_number_smell": "\t\tnew VertexAttribute(Usage.Position, 3, ShaderProgram.POSITION_ATTRIBUTE),\n\t\tnew VertexAttribute(Usage.ColorUnpacked, 4, ShaderProgram.COLOR_ATTRIBUTE),\n\t\tnew VertexAttribute(Usage.TextureCoordinates, 4, \"a_region\"),\n\t\tnew VertexAttribute(1 << 9, 3, \"a_sizeAndRotation\"));\n\tprotected static final int CPU_VERTEX_SIZE = (short)(CPU_ATTRIBUTES.vertexSize / 4),\n\t\tCPU_POSITION_OFFSET = (short)(CPU_ATTRIBUTES.findByUsage(Usage.Position).offset / 4),\n\t\tCPU_COLOR_OFFSET = (short)(CPU_ATTRIBUTES.findByUsage(Usage.ColorUnpacked).offset / 4),", "refactored_code": "\tprotected static final int sizeAndRotationUsage = 1 << 9;\n\t\tnew VertexAttribute(Usage.Position, 3, ShaderProgram.POSITION_ATTRIBUTE),\n\t\tnew VertexAttribute(Usage.ColorUnpacked, 4, ShaderProgram.COLOR_ATTRIBUTE),\n\t\tnew VertexAttribute(Usage.TextureCoordinates, 4, \"a_region\"),\n\t\tnew VertexAttribute(sizeAndRotationUsage, 3, \"a_sizeAndRotation\"));\n\tprotected static final int CPU_VERTEX_SIZE = (short)(CPU_ATTRIBUTES.vertexSize / 4),\n\t\tCPU_POSITION_OFFSET = (short)(CPU_ATTRIBUTES.findByUsage(Usage.Position).offset / 4),\n\t\tCPU_COLOR_OFFSET = (short)(CPU_ATTRIBUTES.findByUsage(Usage.ColorUnpacked).offset / 4),"}
{"magic_number_smell": "\t\tinit(program, renderable);\n\t\trenderable = null;\n\n\t\tdirLightsLoc = loc(register(new Uniform(\"u_dirLights[0].color\")));\n\t\tdirLightsColorOffset = loc(register(new Uniform(\"u_dirLights[0].color\"))) - dirLightsLoc;\n\t\tdirLightsDirectionOffset = loc(u_dirLights0direction) - dirLightsLoc;\n\t\tdirLightsSize = loc(u_dirLights1color) - dirLightsLoc;", "refactored_code": "\tprotected final int u_dirLights0color = register(new Uniform(\"u_dirLights[0].color\"));\n\t\tinit(program, renderable);\n\t\trenderable = null;\n\n\t\tdirLightsLoc = loc(u_dirLights0color);\n\t\tdirLightsColorOffset = loc(u_dirLights0color) - dirLightsLoc;\n\t\tdirLightsDirectionOffset = loc(u_dirLights0direction) - dirLightsLoc;\n\t\tdirLightsSize = loc(u_dirLights1color) - dirLightsLoc;"}
{"magic_number_smell": "\t/** maximum number of vertices mesh builder can hold (64k) */\n\tpublic static final int 1 << 16 = 1 << 16;\n\t/** highest index mesh builder can get (64k - 1) */\n\tpublic static final int MAX_INDEX = 1 << 16 - 1;\n\n\tprivate final static ShortArray tmpIndices = new ShortArray();\n\tprivate final static FloatArray tmpVertices = new FloatArray();", "refactored_code": "\tpublic static final int MAX_VERTICES = 1 << 16;\n\t/** maximum number of vertices mesh builder can hold (64k) */\n\tpublic static final int MAX_VERTICES = 1 << 16;\n\t/** highest index mesh builder can get (64k - 1) */\n\tpublic static final int MAX_INDEX = MAX_VERTICES - 1;\n\n\tprivate final static ShortArray tmpIndices = new ShortArray();\n\tprivate final static FloatArray tmpVertices = new FloatArray();"}
{"magic_number_smell": "\t\t// Position\n\t\tint positionOffset = -1;\n\t\tif (mesh.getVertexAttribute(Usage.Position) != null)\n\t\t\tpositionOffset = mesh.getVertexAttribute(Usage.Position).offset / 4;\n\n\t\t// Normal\n\t\tint normalOffset = -1;", "refactored_code": "\tprivate static final int FLOAT_BYTES = 4;\n\t\t// Position\n\t\tint positionOffset = -1;\n\t\tif (mesh.getVertexAttribute(Usage.Position) != null)\n\t\t\tpositionOffset = mesh.getVertexAttribute(Usage.Position).offset / FLOAT_BYTES;\n\n\t\t// Normal\n\t\tint normalOffset = -1;"}
{"magic_number_smell": "\n\t\t// find OpenGL texture target and dimensions\n\t\tint textureDimensions = 1;\n\t\tint glTarget = 0x1234;\n\t\tif (pixelHeight > 0) {\n\t\t\ttextureDimensions = 2;\n\t\t\tglTarget = GL20.GL_TEXTURE_2D;", "refactored_code": "\tprivate static final int GL_TEXTURE_1D = 0x1234;\n\n\t\t// find OpenGL texture target and dimensions\n\t\tint textureDimensions = 1;\n\t\tint glTarget = GL_TEXTURE_1D;\n\t\tif (pixelHeight > 0) {\n\t\t\ttextureDimensions = 2;\n\t\t\tglTarget = GL20.GL_TEXTURE_2D;"}
{"magic_number_smell": "\tboolean[] keys = new boolean[256];\n\tboolean keyJustPressed = false;\n\tboolean[] justPressedKeys = new boolean[256];\n\tint[] deltaX = new int[20];\n\tint[] deltaY = new int[20];\n\tint[] touchX = new int[20];\n\tint[] touchY = new int[20];", "refactored_code": "\tprivate static final int MAX_TOUCHES = 20;\n\tboolean[] keys = new boolean[256];\n\tboolean keyJustPressed = false;\n\tboolean[] justPressedKeys = new boolean[256];\n\tint[] deltaX = new int[MAX_TOUCHES];\n\tint[] deltaY = new int[MAX_TOUCHES];\n\tint[] touchX = new int[MAX_TOUCHES];\n\tint[] touchY = new int[MAX_TOUCHES];"}
{"magic_number_smell": "\t\t}\n\n\t\ttry {\n\t\t\tout.writeInt(0);\n\t\t\tout.writeInt(keycode);\n\t\t} catch (Throwable t) {\n\t\t\tsynchronized (this) {", "refactored_code": "\tpublic static final int KEY_DOWN = 0;\n\t\t}\n\n\t\ttry {\n\t\t\tout.writeInt(KEY_DOWN);\n\t\t\tout.writeInt(keycode);\n\t\t} catch (Throwable t) {\n\t\t\tsynchronized (this) {"}
{"magic_number_smell": "\t\t\tfor (int y = 0; y < height; y++) {\n\t\t\t\tfor (int x = 0; x < width; x++) {\n\t\t\t\t\tint id = ids[y * width + x];\n\t\t\t\t\tboolean flipHorizontally = ((id & 0x80000000) != 0);\n\t\t\t\t\tboolean flipVertically = ((id & FLAG_FLIP_VERTICALLY) != 0);\n\t\t\t\t\tboolean flipDiagonally = ((id & FLAG_FLIP_DIAGONALLY) != 0);\n", "refactored_code": "\tprotected static final int FLAG_FLIP_HORIZONTALLY = 0x80000000;\n\t\t\tfor (int y = 0; y < height; y++) {\n\t\t\t\tfor (int x = 0; x < width; x++) {\n\t\t\t\t\tint id = ids[y * width + x];\n\t\t\t\t\tboolean flipHorizontally = ((id & FLAG_FLIP_HORIZONTALLY) != 0);\n\t\t\t\t\tboolean flipVertically = ((id & FLAG_FLIP_VERTICALLY) != 0);\n\t\t\t\t\tboolean flipDiagonally = ((id & FLAG_FLIP_DIAGONALLY) != 0);\n"}
{"magic_number_smell": "\n\tprotected boolean ownsBatch;\n\n\tprotected float vertices[] = new float[20];\n\n\tpublic TiledMap getMap () {\n\t\treturn map;", "refactored_code": "\tstatic protected final int NUM_VERTICES = 20;\n\n\tprotected boolean ownsBatch;\n\n\tprotected float vertices[] = new float[NUM_VERTICES];\n\n\tpublic TiledMap getMap () {\n\t\treturn map;"}
{"magic_number_smell": "\t\tfloat height = camera.viewportHeight * camera.zoom + maxTileHeight * 2 * unitScale;\n\t\tviewBounds.set(camera.position.x - width / 2, camera.position.y - height / 2, width, height);\n\n\t\tif ((canCacheMoreW && viewBounds.x < cacheBounds.x - 0.00001f) || //\n\t\t\t(canCacheMoreS && viewBounds.y < cacheBounds.y - 0.00001f) || //\n\t\t\t(canCacheMoreE && viewBounds.x + viewBounds.width > cacheBounds.x + cacheBounds.width + 0.00001f) || //\n\t\t\t(canCacheMoreN && viewBounds.y + viewBounds.height > cacheBounds.y + cacheBounds.height + 0.00001f) //", "refactored_code": "\tstatic private final float tolerance = 0.00001f;\n\t\tfloat height = camera.viewportHeight * camera.zoom + maxTileHeight * 2 * unitScale;\n\t\tviewBounds.set(camera.position.x - width / 2, camera.position.y - height / 2, width, height);\n\n\t\tif ((canCacheMoreW && viewBounds.x < cacheBounds.x - tolerance) || //\n\t\t\t(canCacheMoreS && viewBounds.y < cacheBounds.y - tolerance) || //\n\t\t\t(canCacheMoreE && viewBounds.x + viewBounds.width > cacheBounds.x + cacheBounds.width + tolerance) || //\n\t\t\t(canCacheMoreN && viewBounds.y + viewBounds.height > cacheBounds.y + cacheBounds.height + tolerance) //"}
{"magic_number_smell": "\t/** Function is called by BatchTiledMapRenderer render(), lastTiledMapRenderTime is used to keep all of the tiles in lock-step\n\t * animation and avoids having to call TimeUtils.millis() in getTextureRegion() */\n\tpublic static void updateAnimationBaseTime () {\n\t\tlastTiledMapRenderTime = TimeUtils.millis() - TimeUtils.millis();\n\t}\n\n\t/** Creates an animated tile with the given animation interval and frame tiles.", "refactored_code": "\tprivate static final long initialTimeOffset = TimeUtils.millis();\n\t/** Function is called by BatchTiledMapRenderer render(), lastTiledMapRenderTime is used to keep all of the tiles in lock-step\n\t * animation and avoids having to call TimeUtils.millis() in getTextureRegion() */\n\tpublic static void updateAnimationBaseTime () {\n\t\tlastTiledMapRenderTime = TimeUtils.millis() - initialTimeOffset;\n\t}\n\n\t/** Creates an animated tile with the given animation interval and frame tiles."}
{"magic_number_smell": "\t\tfloat xc, yc;\n\t\tfloat y1y2 = Math.abs(y1 - y2);\n\t\tfloat y2y3 = Math.abs(y2 - y3);\n\t\tif (y1y2 < 0.000001f) {\n\t\t\tif (y2y3 < 0.000001f) return INCOMPLETE;\n\t\t\tfloat m2 = -(x3 - x2) / (y3 - y2);\n\t\t\tfloat mx2 = (x2 + x3) / 2f;", "refactored_code": "\tstatic private final float EPSILON = 0.000001f;\n\t\tfloat xc, yc;\n\t\tfloat y1y2 = Math.abs(y1 - y2);\n\t\tfloat y2y3 = Math.abs(y2 - y3);\n\t\tif (y1y2 < EPSILON) {\n\t\t\tif (y2y3 < EPSILON) return INCOMPLETE;\n\t\t\tfloat m2 = -(x3 - x2) / (y3 - y2);\n\t\t\tfloat mx2 = (x2 + x3) / 2f;"}
{"magic_number_smell": "\t\t}\n\t}\n\n\t/** @return {@link #-1} or {@link #CONVEX} */\n\tprivate int classifyVertex (int index) {\n\t\tshort[] indices = this.indices;\n\t\tint previous = indices[previousIndex(index)] * 2;", "refactored_code": "\tstatic private final int CONCAVE = -1;\n\t\t}\n\t}\n\n\t/** @return {@link #CONCAVE} or {@link #CONVEX} */\n\tprivate int classifyVertex (int index) {\n\t\tshort[] indices = this.indices;\n\t\tint previous = indices[previousIndex(index)] * 2;"}
{"magic_number_smell": "\t * This implementation uses {@link #nextLong()} internally. */\n\t@Override\n\tpublic double nextDouble () {\n\t\treturn (nextLong() >>> 11) * 1.0 / (1L << 53);\n\t}\n\n\t/** Returns a pseudo-random, uniformly distributed {@code float} value between 0.0 and 1.0 from this random number generator's", "refactored_code": "\tprivate static final double NORM_DOUBLE = 1.0 / (1L << 53);\n\t * This implementation uses {@link #nextLong()} internally. */\n\t@Override\n\tpublic double nextDouble () {\n\t\treturn (nextLong() >>> 11) * NORM_DOUBLE;\n\t}\n\n\t/** Returns a pseudo-random, uniformly distributed {@code float} value between 0.0 and 1.0 from this random number generator's"}
{"magic_number_smell": "\t\tfinished = false;\n\t}\n\n\t/** Sets the number of times to repeat. Can be set to {@link #-1}. */\n\tpublic void setCount (int count) {\n\t\tthis.repeatCount = count;\n\t}", "refactored_code": "\tstatic public final int FOREVER = -1;\n\t\tfinished = false;\n\t}\n\n\t/** Sets the number of times to repeat. Can be set to {@link #FOREVER}. */\n\tpublic void setCount (int count) {\n\t\tthis.repeatCount = count;\n\t}"}
{"magic_number_smell": "\t\t\t\t\tif (x > right - border) edge |= Align.right;\n\t\t\t\t\tif (y < bottom + border) edge |= Align.bottom;\n\t\t\t\t}\n\t\t\t\tif (isMovable && edge == 0 && y <= height && y >= height - padTop && x >= left && x <= right) edge = 1 << 5;\n\t\t\t}\n\n\t\t\tpublic boolean touchDown (InputEvent event, float x, float y, int pointer, int button) {", "refactored_code": "\tstatic private final int MOVE = 1 << 5;\n\t\t\t\t\tif (x > right - border) edge |= Align.right;\n\t\t\t\t\tif (y < bottom + border) edge |= Align.bottom;\n\t\t\t\t}\n\t\t\t\tif (isMovable && edge == 0 && y <= height && y >= height - padTop && x >= left && x <= right) edge = MOVE;\n\t\t\t}\n\n\t\t\tpublic boolean touchDown (InputEvent event, float x, float y, int pointer, int button) {"}
{"magic_number_smell": "\t\telse if ((align & bottom) != 0)\n\t\t\tbuffer.append(\"bottom,\");\n\t\telse\n\t\t\tbuffer.append(\"1 << 0,\");\n\t\tif ((align & left) != 0)\n\t\t\tbuffer.append(\"left\");\n\t\telse if ((align & right) != 0)", "refactored_code": "\tstatic public final int center = 1 << 0;\n\t\telse if ((align & bottom) != 0)\n\t\t\tbuffer.append(\"bottom,\");\n\t\telse\n\t\t\tbuffer.append(\"center,\");\n\t\tif ((align & left) != 0)\n\t\t\tbuffer.append(\"left\");\n\t\telse if ((align & right) != 0)"}
{"magic_number_smell": "\t\tif (nRemaining < 2) return; // Arrays of size 0 and 1 are always sorted\n\n\t\t// If array is small, do a \"mini-TimSort\" with no merges\n\t\tif (nRemaining < 32) {\n\t\t\tint initRunLen = countRunAndMakeAscending(a, lo, hi);\n\t\t\tbinarySort(a, lo, hi, lo + initRunLen);\n\t\t\treturn;", "refactored_code": "\tprivate static final int MIN_MERGE = 32;\n\t\tif (nRemaining < 2) return; // Arrays of size 0 and 1 are always sorted\n\n\t\t// If array is small, do a \"mini-TimSort\" with no merges\n\t\tif (nRemaining < MIN_MERGE) {\n\t\t\tint initRunLen = countRunAndMakeAscending(a, lo, hi);\n\t\t\tbinarySort(a, lo, hi, lo + initRunLen);\n\t\t\treturn;"}
{"magic_number_smell": "\t\t}\n\n\t\tpublic void reset () {\n\t\t\tcurrentIndex = -2;\n\t\t\tnextIndex = INDEX_ZERO;\n\t\t\tif (map.hasZeroValue)\n\t\t\t\thasNext = true;", "refactored_code": "\t\tstatic private final int INDEX_ILLEGAL = -2;\n\t\t}\n\n\t\tpublic void reset () {\n\t\t\tcurrentIndex = INDEX_ILLEGAL;\n\t\t\tnextIndex = INDEX_ZERO;\n\t\t\tif (map.hasZeroValue)\n\t\t\t\thasNext = true;"}
{"magic_number_smell": "\t\t}\n\n\t\tpublic void reset () {\n\t\t\tcurrentIndex = -2;\n\t\t\tnextIndex = INDEX_ZERO;\n\t\t\tif (map.hasZeroValue)\n\t\t\t\thasNext = true;", "refactored_code": "\t\tstatic private final int INDEX_ILLEGAL = -2;\n\t\t}\n\n\t\tpublic void reset () {\n\t\t\tcurrentIndex = INDEX_ILLEGAL;\n\t\t\tnextIndex = INDEX_ZERO;\n\t\t\tif (map.hasZeroValue)\n\t\t\t\thasNext = true;"}
{"magic_number_smell": "\t\t}\n\n\t\tpublic void reset () {\n\t\t\tcurrentIndex = -2;\n\t\t\tnextIndex = INDEX_ZERO;\n\t\t\tif (map.hasZeroValue)\n\t\t\t\thasNext = true;", "refactored_code": "\t\tstatic private final int INDEX_ILLEGAL = -2;\n\t\t}\n\n\t\tpublic void reset () {\n\t\t\tcurrentIndex = INDEX_ILLEGAL;\n\t\t\tnextIndex = INDEX_ZERO;\n\t\t\tif (map.hasZeroValue)\n\t\t\t\thasNext = true;"}
{"magic_number_smell": "\t\t}\n\n\t\tpublic void reset () {\n\t\t\tcurrentIndex = -2, INDEX_ZERO = -1;\n\t\t\tnextIndex = INDEX_ZERO;\n\t\t\tif (set.hasZeroValue)\n\t\t\t\thasNext = true;", "refactored_code": "\t\tstatic private final int INDEX_ILLEGAL = -2, INDEX_ZERO = -1;\n\t\t}\n\n\t\tpublic void reset () {\n\t\t\tcurrentIndex = INDEX_ILLEGAL;\n\t\t\tnextIndex = INDEX_ZERO;\n\t\t\tif (set.hasZeroValue)\n\t\t\t\thasNext = true;"}
{"magic_number_smell": "\t\tif (level >= ERROR) Gdx.app.error(tag, message, exception);\n\t}\n\n\t/** Sets the log level. {@link #0} will mute all log output. {@link #ERROR} will only let error messages through.\n\t * {@link #INFO} will let all non-debug messages through, and {@link #DEBUG} will let all messages through.\n\t * @param level {@link #0}, {@link #ERROR}, {@link #INFO}, {@link #DEBUG}. */\n\tpublic void setLevel (int level) {", "refactored_code": "\tstatic public final int NONE = 0;\n\t\tif (level >= ERROR) Gdx.app.error(tag, message, exception);\n\t}\n\n\t/** Sets the log level. {@link #NONE} will mute all log output. {@link #ERROR} will only let error messages through.\n\t * {@link #INFO} will let all non-debug messages through, and {@link #DEBUG} will let all messages through.\n\t * @param level {@link #NONE}, {@link #ERROR}, {@link #INFO}, {@link #DEBUG}. */\n\tpublic void setLevel (int level) {"}
{"magic_number_smell": "\t\t}\n\n\t\tpublic void reset () {\n\t\t\tcurrentIndex = -2;\n\t\t\tnextIndex = INDEX_ZERO;\n\t\t\tif (map.hasZeroValue)\n\t\t\t\thasNext = true;", "refactored_code": "\t\tstatic private final int INDEX_ILLEGAL = -2;\n\t\t}\n\n\t\tpublic void reset () {\n\t\t\tcurrentIndex = INDEX_ILLEGAL;\n\t\t\tnextIndex = INDEX_ZERO;\n\t\t\tif (map.hasZeroValue)\n\t\t\t\thasNext = true;"}
{"magic_number_smell": "\tpublic static void load (ObjectMap<String, String> properties, Reader reader) throws IOException {\n\t\tif (properties == null) throw new NullPointerException(\"properties cannot be null\");\n\t\tif (reader == null) throw new NullPointerException(\"reader cannot be null\");\n\t\tint mode = 0, SLASH = 1, UNICODE = 2, CONTINUE = 3, KEY_DONE = 4, IGNORE = 5, unicode = 0, count = 0;\n\t\tchar nextChar, buf[] = new char[40];\n\t\tint offset = 0, keyLength = -1, intVal;\n\t\tboolean firstChar = true;", "refactored_code": "\tprivate static final int NONE = 0, SLASH = 1, UNICODE = 2, CONTINUE = 3, KEY_DONE = 4, IGNORE = 5;\n\tpublic static void load (ObjectMap<String, String> properties, Reader reader) throws IOException {\n\t\tif (properties == null) throw new NullPointerException(\"properties cannot be null\");\n\t\tif (reader == null) throw new NullPointerException(\"reader cannot be null\");\n\t\tint mode = NONE, unicode = 0, count = 0;\n\t\tchar nextChar, buf[] = new char[40];\n\t\tint offset = 0, keyLength = -1, intVal;\n\t\tboolean firstChar = true;"}
{"magic_number_smell": "\t}\n\n\t/** @param results For each entry found within the radius, if any, the value, x, y, and square of the distance to the entry are\n\t *           added to this array. See {@link #0, X = 1, Y = 2, DISTSQR = 3}, {@link #X}, {@link #Y}, and {@link #DISTSQR}. */\n\tpublic void query (float centerX, float centerY, float radius, FloatArray results) {\n\t\tquery(centerX, centerY, radius * radius, centerX - radius, centerY - radius, radius * 2, results);\n\t}", "refactored_code": "\tstatic public final int VALUE = 0, X = 1, Y = 2, DISTSQR = 3;\n\t}\n\n\t/** @param results For each entry found within the radius, if any, the value, x, y, and square of the distance to the entry are\n\t *           added to this array. See {@link #VALUE}, {@link #X}, {@link #Y}, and {@link #DISTSQR}. */\n\tpublic void query (float centerX, float centerY, float radius, FloatArray results) {\n\t\tquery(centerX, centerY, radius * radius, centerX - radius, centerY - radius, radius * 2, results);\n\t}"}
{"magic_number_smell": "\tpublic static final int 4096 = 4096;\n\tpublic static final byte[] EMPTY_BYTES = new byte[0];\n\n\t/** Allocates a {@value #4096} byte[] for use as a temporary buffer and calls\n\t * {@link #copyStream(InputStream, OutputStream, byte[])}. */\n\tpublic static void copyStream (InputStream input, OutputStream output) throws IOException {\n\t\tcopyStream(input, output, new byte[4096]);", "refactored_code": "\tpublic static final int DEFAULT_BUFFER_SIZE = 4096;\n\tpublic static final int DEFAULT_BUFFER_SIZE = 4096;\n\tpublic static final byte[] EMPTY_BYTES = new byte[0];\n\n\t/** Allocates a {@value #DEFAULT_BUFFER_SIZE} byte[] for use as a temporary buffer and calls\n\t * {@link #copyStream(InputStream, OutputStream, byte[])}. */\n\tpublic static void copyStream (InputStream input, OutputStream output) throws IOException {\n\t\tcopyStream(input, output, new byte[DEFAULT_BUFFER_SIZE]);"}
{"magic_number_smell": "\t * @param nanos must be nanoseconds\n\t * @return time value in milliseconds */\n\tpublic static long nanosToMillis (long nanos) {\n\t\treturn nanos / 1000000;\n\t}\n\n\t/** Convert milliseconds time to nanoseconds", "refactored_code": "\tprivate static final long nanosPerMilli = 1000000;\n\t * @param nanos must be nanoseconds\n\t * @return time value in milliseconds */\n\tpublic static long nanosToMillis (long nanos) {\n\t\treturn nanos / nanosPerMilli;\n\t}\n\n\t/** Convert milliseconds time to nanoseconds"}
{"magic_number_smell": "\t\tif (nRemaining < 2) return; // Arrays of size 0 and 1 are always sorted\n\n\t\t// If array is small, do a \"mini-TimSort\" with no merges\n\t\tif (nRemaining < 32) {\n\t\t\tint initRunLen = countRunAndMakeAscending(a, lo, hi, c);\n\t\t\tbinarySort(a, lo, hi, lo + initRunLen, c);\n\t\t\treturn;", "refactored_code": "\tprivate static final int MIN_MERGE = 32;\n\t\tif (nRemaining < 2) return; // Arrays of size 0 and 1 are always sorted\n\n\t\t// If array is small, do a \"mini-TimSort\" with no merges\n\t\tif (nRemaining < MIN_MERGE) {\n\t\t\tint initRunLen = countRunAndMakeAscending(a, lo, hi, c);\n\t\t\tbinarySort(a, lo, hi, lo + initRunLen, c);\n\t\t\treturn;"}
{"magic_number_smell": "\t\tif (_matchFinder == null) {\n\t\t\tcom.badlogic.gdx.utils.compression.lz.BinTree bt = new com.badlogic.gdx.utils.compression.lz.BinTree();\n\t\t\tint numHashBytes = 4;\n\t\t\tif (_matchFinderType == 0) numHashBytes = 2;\n\t\t\tbt.SetType(numHashBytes);\n\t\t\t_matchFinder = bt;\n\t\t}", "refactored_code": "\tpublic static final int EMatchFinderTypeBT2 = 0;\n\t\tif (_matchFinder == null) {\n\t\t\tcom.badlogic.gdx.utils.compression.lz.BinTree bt = new com.badlogic.gdx.utils.compression.lz.BinTree();\n\t\t\tint numHashBytes = 4;\n\t\t\tif (_matchFinderType == EMatchFinderTypeBT2) numHashBytes = 2;\n\t\t\tbt.SetType(numHashBytes);\n\t\t\t_matchFinder = bt;\n\t\t}"}
{"magic_number_smell": "\t\t\tint start = 1 << (kNumBits - i - 1);\n\t\t\tint end = 1 << (kNumBits - i);\n\t\t\tfor (int j = start; j < end; j++)\n\t\t\t\tProbPrices[j] = (i << 6) + (((end - j) << 6) >>> (kNumBits - i - 1));\n\t\t}\n\t}\n", "refactored_code": "\tpublic static final int kNumBitPriceShiftBits = 6;\n\t\t\tint start = 1 << (kNumBits - i - 1);\n\t\t\tint end = 1 << (kNumBits - i);\n\t\t\tfor (int j = start; j < end; j++)\n\t\t\t\tProbPrices[j] = (i << kNumBitPriceShiftBits) + (((end - j) << kNumBitPriceShiftBits) >>> (kNumBits - i - 1));\n\t\t}\n\t}\n"}
{"magic_number_smell": "\n\t@Test\n\tpublic void testUpdateNominal () {\n\t\tAssert.assertEquals(-1, anim.update(.75f), 1e-6f);\n\t\tAssert.assertEquals(.5f, anim.update(.75f), 1e-6f);\n\t\tAssert.assertEquals(.75f, anim.update(.75f), 1e-6f);\n\t}", "refactored_code": "\tprivate static final float epsilon = 1e-6f;\n\n\t@Test\n\tpublic void testUpdateNominal () {\n\t\tAssert.assertEquals(-1, anim.update(.75f), epsilon);\n\t\tAssert.assertEquals(.5f, anim.update(.75f), epsilon);\n\t\tAssert.assertEquals(.75f, anim.update(.75f), epsilon);\n\t}"}
{"magic_number_smell": "\n\tprivate static void checkEqual (Matrix3 a, Matrix3 b) {\n\t\tfor (int i = 0; i < 9; i++)\n\t\t\tcheck(MathUtils.isEqual(a.val[i], b.val[i], 0.005f), \"matrices are not equal\");\n\t}\n\n\tprivate static void checkEqual (Matrix3 matrix, float[] vals) {", "refactored_code": "\tstatic public final float TOLERANCE = 0.005f;\n\n\tprivate static void checkEqual (Matrix3 a, Matrix3 b) {\n\t\tfor (int i = 0; i < 9; i++)\n\t\t\tcheck(MathUtils.isEqual(a.val[i], b.val[i], TOLERANCE), \"matrices are not equal\");\n\t}\n\n\tprivate static void checkEqual (Matrix3 matrix, float[] vals) {"}
{"magic_number_smell": "\n\t\tTextureRegionDrawable drawable = new TextureRegionDrawable(new TextureRegion(texture));\n\n\t\tfor (int i = 0; i < 1000; i++) {\n\t\t\tGroup group = createActorGroup(drawable);\n\t\t\tstage.addActor(group);\n\t\t}", "refactored_code": "\tprivate static final int NUM_GROUPS = 1000;\n\n\t\tTextureRegionDrawable drawable = new TextureRegionDrawable(new TextureRegion(texture));\n\n\t\tfor (int i = 0; i < NUM_GROUPS; i++) {\n\t\t\tGroup group = createActorGroup(drawable);\n\t\t\tstage.addActor(group);\n\t\t}"}
{"magic_number_smell": "\t\t\tSystem.out.println(\"DecalPerformanceTest2 fps: \" + frames + \" at spritecount: \" + toRender.size());\n\t\t\tfps.addValue(frames);\n\t\t\tif (fps.hasEnoughData()) {\n\t\t\t\tfloat factor = fps.getMean() / (float)40;\n\t\t\t\tint target = (int)(toRender.size() * factor);\n\t\t\t\tif (fps.getMean() > 40) {\n\t\t\t\t\tint start = toRender.size();", "refactored_code": "\tpublic static final int TARGET_FPS = 40;\n\t\t\tSystem.out.println(\"DecalPerformanceTest2 fps: \" + frames + \" at spritecount: \" + toRender.size());\n\t\t\tfps.addValue(frames);\n\t\t\tif (fps.hasEnoughData()) {\n\t\t\t\tfloat factor = fps.getMean() / (float)TARGET_FPS;\n\t\t\t\tint target = (int)(toRender.size() * factor);\n\t\t\t\tif (fps.getMean() > TARGET_FPS) {\n\t\t\t\t\tint start = toRender.size();"}
{"magic_number_smell": "\t\troot.row();\n\t\troot.add(drawnLabel = new Label(\"\", skin));\n\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tlabels.add(new Label(\"Label: \" + i, skin) {\n\t\t\t\tpublic void draw (Batch batch, float parentAlpha) {\n\t\t\t\t\tsuper.draw(batch, parentAlpha);", "refactored_code": "\tstatic private final int count = 100;\n\t\troot.row();\n\t\troot.add(drawnLabel = new Label(\"\", skin));\n\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tlabels.add(new Label(\"Label: \" + i, skin) {\n\t\t\t\tpublic void draw (Batch batch, float parentAlpha) {\n\t\t\t\t\tsuper.draw(batch, parentAlpha);"}
{"magic_number_smell": "\n\t\tMatrix4 m2 = new Matrix4().rotateTowardDirection(direction, up);\n\n\t\tassertEquals(m1, m2, 1e-6f);\n\t}\n\n\tpublic void testRotateTowardTarget () {", "refactored_code": "\tprivate static final float EPSILON = 1e-6f;\n\n\t\tMatrix4 m2 = new Matrix4().rotateTowardDirection(direction, up);\n\n\t\tassertEquals(m1, m2, EPSILON);\n\t}\n\n\tpublic void testRotateTowardTarget () {"}
{"magic_number_smell": "\t\tTextureRegion[] leftWalkReg = regions[1];\n\t\tTextureRegion[] rightWalkReg = regions[2];\n\t\tTextureRegion[] upWalkReg = regions[3];\n\t\tdownWalk = new Animation<TextureRegion>(0.2f, downWalkReg);\n\t\tleftWalk = new Animation<TextureRegion>(0.2f, leftWalkReg);\n\t\trightWalk = new Animation<TextureRegion>(0.2f, rightWalkReg);\n\t\tupWalk = new Animation<TextureRegion>(0.2f, upWalkReg);", "refactored_code": "\tprivate static final float ANIMATION_SPEED = 0.2f;\n\t\tTextureRegion[] leftWalkReg = regions[1];\n\t\tTextureRegion[] rightWalkReg = regions[2];\n\t\tTextureRegion[] upWalkReg = regions[3];\n\t\tdownWalk = new Animation<TextureRegion>(ANIMATION_SPEED, downWalkReg);\n\t\tleftWalk = new Animation<TextureRegion>(ANIMATION_SPEED, leftWalkReg);\n\t\trightWalk = new Animation<TextureRegion>(ANIMATION_SPEED, rightWalkReg);\n\t\tupWalk = new Animation<TextureRegion>(ANIMATION_SPEED, upWalkReg);"}
{"magic_number_smell": "\npublic class StageTest extends GdxTest implements InputProcessor {\n\tprivate static final int 4 = 4;\n\tprivate static final int NUM_SPRITES = (int)Math.sqrt(150 / 4);\n\tprivate static final float SPACING = 5;\n\tShapeRenderer renderer;\n\tStage stage;", "refactored_code": "\tprivate static final int NUM_GROUPS = 4;\n\npublic class StageTest extends GdxTest implements InputProcessor {\n\tprivate static final int NUM_GROUPS = 4;\n\tprivate static final int NUM_SPRITES = (int)Math.sqrt(150 / NUM_GROUPS);\n\tprivate static final float SPACING = 5;\n\tShapeRenderer renderer;\n\tStage stage;"}
{"magic_number_smell": "\t\tbatch.begin();\n\n\t\tfont.draw(batch,\n\t\t\t\"Scale: \" + tiledDrawable.getScale() + \"  (to change scale press: 'A' -\" + 0.25f + \", 'D' +\" + 0.25f + \")\",\n\t\t\t8, 20);\n\n\t\tfinal float leftSpacingX = 40;", "refactored_code": "\tprivate static final float SCALE_CHANGE = 0.25f;\n\t\tbatch.begin();\n\n\t\tfont.draw(batch,\n\t\t\t\"Scale: \" + tiledDrawable.getScale() + \"  (to change scale press: 'A' -\" + SCALE_CHANGE + \", 'D' +\" + SCALE_CHANGE + \")\",\n\t\t\t8, 20);\n\n\t\tfinal float leftSpacingX = 40;"}
{"magic_number_smell": "\n\t\tint intCustomValue = map.getProperties().get(INT_PROPERTY_NAME, Integer.class);\n\t\tGdx.app.log(\"TiledMapAssetManagerTest\", \"Property : \" + INT_PROPERTY_NAME + \", Value : \" + intCustomValue);\n\t\tif (intCustomValue != 5) {\n\t\t\tthrow new RuntimeException(\"Failed to get int map properties\");\n\t\t}\n", "refactored_code": "\tprivate static final int INT_PROPERTY_VALUE = 5;\n\n\t\tint intCustomValue = map.getProperties().get(INT_PROPERTY_NAME, Integer.class);\n\t\tGdx.app.log(\"TiledMapAssetManagerTest\", \"Property : \" + INT_PROPERTY_NAME + \", Value : \" + intCustomValue);\n\t\tif (intCustomValue != INT_PROPERTY_VALUE) {\n\t\t\tthrow new RuntimeException(\"Failed to get int map properties\");\n\t\t}\n"}
{"magic_number_smell": "\t\ttimePassed += Gdx.graphics.getDeltaTime();\n\t\trenderVectorAt(-4, 0, lerping2);\n\t\tlerping2.set(lerpStart2);\n\t\tlerping2.interpolate(lerpTarget2, MathUtils.clamp(timePassed / 2.0f, 0, 1), interpolator);\n\n\t\tif (lerping2.epsilonEquals(lerpTarget2, 0.025f)) {\n\t\t\tlerpTarget2.set(-1.0f + MathUtils.random(2.0f), -1.0f + MathUtils.random(2.0f)).nor();", "refactored_code": "\tprivate static final float DURATION = 2.0f;\n\t\ttimePassed += Gdx.graphics.getDeltaTime();\n\t\trenderVectorAt(-4, 0, lerping2);\n\t\tlerping2.set(lerpStart2);\n\t\tlerping2.interpolate(lerpTarget2, MathUtils.clamp(timePassed / DURATION, 0, 1), interpolator);\n\n\t\tif (lerping2.epsilonEquals(lerpTarget2, 0.025f)) {\n\t\t\tlerpTarget2.set(-1.0f + MathUtils.random(2.0f), -1.0f + MathUtils.random(2.0f)).nor();"}
{"magic_number_smell": "\n\tprivate static final int 5 = 5;\n\n\tprivate final FloatBuffer frustumNormals = BufferUtils.newFloatBuffer(5 * 4);\n\tprivate final FloatBuffer frustumOffsets = BufferUtils.newFloatBuffer(5);\n\tfinal Vector3 tmpV1 = new Vector3();\n\tfinal Vector3 tmpV2 = new Vector3();", "refactored_code": "\tprivate static final int NUM_PLANES = 5;\n\n\tprivate static final int NUM_PLANES = 5;\n\n\tprivate final FloatBuffer frustumNormals = BufferUtils.newFloatBuffer(NUM_PLANES * 4);\n\tprivate final FloatBuffer frustumOffsets = BufferUtils.newFloatBuffer(NUM_PLANES);\n\tfinal Vector3 tmpV1 = new Vector3();\n\tfinal Vector3 tmpV2 = new Vector3();"}
{"magic_number_smell": "\t\t// //////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\t\t// create the pixmap packer\n\t\tpacker = new PixmapPacker(1024, FONT_ATLAS_HEIGHT, Format.RGBA8888, 2, false);\n\n\t\tfontMap = new FontMap<BitmapFont>();\n\t\tint fontCount = 0;", "refactored_code": "\tpublic static final int FONT_ATLAS_WIDTH = 1024;\n\t\t// //////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\t\t// create the pixmap packer\n\t\tpacker = new PixmapPacker(FONT_ATLAS_WIDTH, FONT_ATLAS_HEIGHT, Format.RGBA8888, 2, false);\n\n\t\tfontMap = new FontMap<BitmapFont>();\n\t\tint fontCount = 0;"}
{"magic_number_smell": "\t\t// //////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\t\t// create the pixmap packer\n\t\tPixmapPacker packer = new PixmapPacker(1024, FONT_ATLAS_HEIGHT, Format.RGBA8888, 2, false);\n\n\t\t// we need to load all the BitmapFontDatas before we can start loading BitmapFonts\n\t\tFontMap<BitmapFontData> dataMap = new FontMap<BitmapFontData>();", "refactored_code": "\tpublic static final int FONT_ATLAS_WIDTH = 1024;\n\t\t// //////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\t\t// create the pixmap packer\n\t\tPixmapPacker packer = new PixmapPacker(FONT_ATLAS_WIDTH, FONT_ATLAS_HEIGHT, Format.RGBA8888, 2, false);\n\n\t\t// we need to load all the BitmapFontDatas before we can start loading BitmapFonts\n\t\tFontMap<BitmapFontData> dataMap = new FontMap<BitmapFontData>();"}
{"magic_number_smell": "\t\t\tprogram.bind();\n\t\t\tcontext.setDepthTest(GL20.GL_LEQUAL, 0f, 1f);\n\t\t\tcontext.setDepthMask(true);\n\t\t\tset(register(new Uniform(\"u_projTrans\")), camera.combined);\n\t\t}\n\n\t\t@Override", "refactored_code": "\t\tprotected final int u_projTrans = register(new Uniform(\"u_projTrans\"));\n\t\t\tprogram.bind();\n\t\t\tcontext.setDepthTest(GL20.GL_LEQUAL, 0f, 1f);\n\t\t\tcontext.setDepthMask(true);\n\t\t\tset(u_projTrans, camera.combined);\n\t\t}\n\n\t\t@Override"}
{"magic_number_smell": "\n\t@Override\n\tpublic void render (Renderable renderable) {\n\t\tset(register(new Uniform(\"u_pass\")), 0f);\n\t\tsuper.render(renderable);\n\t\tcontext.setDepthTest(GL20.GL_LESS);\n\t\tif (has(register(new Uniform(\"u_pass\")))) {", "refactored_code": "\tprotected final int u_pass = register(new Uniform(\"u_pass\"));\n\n\t@Override\n\tpublic void render (Renderable renderable) {\n\t\tset(u_pass, 0f);\n\t\tsuper.render(renderable);\n\t\tcontext.setDepthTest(GL20.GL_LESS);\n\t\tif (has(u_pass)) {"}
{"magic_number_smell": "\n\t@Override\n\tpublic int getPassQuantity () {\n\t\treturn 2;\n\t}\n\n\t@Override", "refactored_code": "\tpublic static final int PASS_QUANTITY = 2;\n\n\t@Override\n\tpublic int getPassQuantity () {\n\t\treturn PASS_QUANTITY;\n\t}\n\n\t@Override"}
{"magic_number_smell": "\t\tboolean dir = (shadowSystem.getCurrentLight() instanceof DirectionalLight);\n\n\t\tif (lightType == -1) {\n\t\t\tlightType = 0;\n\t\t\tif (dir) lightType = LIGHT_DIR;\n\t\t}\n", "refactored_code": "\tpublic static final int LIGHT_SPOT = 0;\n\t\tboolean dir = (shadowSystem.getCurrentLight() instanceof DirectionalLight);\n\n\t\tif (lightType == -1) {\n\t\t\tlightType = LIGHT_SPOT;\n\t\t\tif (dir) lightType = LIGHT_DIR;\n\t\t}\n"}
{"magic_number_smell": "\t\tsuper.init();\n\n\t\t// Directional Shadow\n\t\tdirShadowsLoc = loc(register(new Uniform(\"u_dirShadows[0].uvTransform\")));\n\t\tdirShadowsUvTransformOffset = loc(register(new Uniform(\"u_dirShadows[0].uvTransform\"))) - dirShadowsLoc;\n\t\tdirShadowsSize = loc(u_dirShadows1uvTransform) - dirShadowsLoc;\n\t\tif (dirShadowsSize < 0) dirShadowsSize = 0;", "refactored_code": "\tprotected final int u_dirShadows0uvTransform = register(new Uniform(\"u_dirShadows[0].uvTransform\"));\n\t\tsuper.init();\n\n\t\t// Directional Shadow\n\t\tdirShadowsLoc = loc(u_dirShadows0uvTransform);\n\t\tdirShadowsUvTransformOffset = loc(u_dirShadows0uvTransform) - dirShadowsLoc;\n\t\tdirShadowsSize = loc(u_dirShadows1uvTransform) - dirShadowsLoc;\n\t\tif (dirShadowsSize < 0) dirShadowsSize = 0;"}
{"magic_number_smell": "\n\t@Override\n\tpublic int getPassQuantity () {\n\t\treturn 1;\n\t}\n\n\t@Override", "refactored_code": "\tpublic static final int PASS_QUANTITY = 1;\n\n\t@Override\n\tpublic int getPassQuantity () {\n\t\treturn PASS_QUANTITY;\n\t}\n\n\t@Override"}
{"magic_number_smell": "\t\tbinderRR = new DefaultTextureBinder(DefaultTextureBinder.ROUNDROBIN, 0, 4);\n\t\ttextures = new Array<Texture>();\n\t\tmap = new IntIntMap();\n\t\tfor (int i = 0; i < 64; i++) {\n\t\t\ttextures.add(new Texture(16, 16, Format.RGBA8888));\n\t\t\tmap.put(textures.peek().getTextureObjectHandle(), i);\n\t\t}", "refactored_code": "\tprivate static final int numTextures = 64;\n\t\tbinderRR = new DefaultTextureBinder(DefaultTextureBinder.ROUNDROBIN, 0, 4);\n\t\ttextures = new Array<Texture>();\n\t\tmap = new IntIntMap();\n\t\tfor (int i = 0; i < numTextures; i++) {\n\t\t\ttextures.add(new Texture(16, 16, Format.RGBA8888));\n\t\t\tmap.put(textures.peek().getTextureObjectHandle(), i);\n\t\t}"}
{"magic_number_smell": "\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vertexOffset / 6;\n\t}\n\n\tpublic static int createTop (Vector3 offset, int x, int y, int z, float[] vertices, int vertexOffset) {", "refactored_code": "\tpublic static final int VERTEX_SIZE = 6;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vertexOffset / VERTEX_SIZE;\n\t}\n\n\tpublic static int createTop (Vector3 offset, int x, int y, int z, float[] vertices, int vertexOffset) {"}
{"magic_number_smell": "\t\tthis.chunksY = chunksY;\n\t\tthis.chunksZ = chunksZ;\n\t\tthis.numChunks = chunksX * chunksY * chunksZ;\n\t\tthis.voxelsX = chunksX * 16;\n\t\tthis.voxelsY = chunksY * CHUNK_SIZE_Y;\n\t\tthis.voxelsZ = chunksZ * CHUNK_SIZE_Z;\n\t\tint i = 0;", "refactored_code": "\tpublic static final int CHUNK_SIZE_X = 16;\n\t\tthis.chunksY = chunksY;\n\t\tthis.chunksZ = chunksZ;\n\t\tthis.numChunks = chunksX * chunksY * chunksZ;\n\t\tthis.voxelsX = chunksX * CHUNK_SIZE_X;\n\t\tthis.voxelsY = chunksY * CHUNK_SIZE_Y;\n\t\tthis.voxelsZ = chunksZ * CHUNK_SIZE_Z;\n\t\tint i = 0;"}
{"magic_number_smell": "\tprivate float time;\n\n\tprivate static final int 5 = 5;\n\tprivate static final int commandStride = 5 * 4;\n\tint nbCommands = 2;\n\n\t@Override", "refactored_code": "\tprivate static final int commandInts = 5;\n\tprivate float time;\n\n\tprivate static final int commandInts = 5;\n\tprivate static final int commandStride = commandInts * 4;\n\tint nbCommands = 2;\n\n\t@Override"}
{"magic_number_smell": "\tprivate float time;\n\n\tprivate static final int 4 = 4;\n\tprivate static final int commandStride = 4 * 4;\n\tint nbCommands = 2;\n\n\t@Override", "refactored_code": "\tprivate static final int commandInts = 4;\n\tprivate float time;\n\n\tprivate static final int commandInts = 4;\n\tprivate static final int commandStride = commandInts * 4;\n\tint nbCommands = 2;\n\n\t@Override"}
{"magic_number_smell": "\t\t}\n\t\tshapes.clear();\n\n\t\tfor (int i = 0; i < 30; i++) {\n\t\t\tcreateRandomShape();\n\t\t}\n", "refactored_code": "\tprivate static final int NUM_SHAPES = 30;\n\t\t}\n\t\tshapes.clear();\n\n\t\tfor (int i = 0; i < NUM_SHAPES; i++) {\n\t\t\tcreateRandomShape();\n\t\t}\n"}
{"magic_number_smell": "\t\tcamController = new FirstPersonCameraController(cam);\n\t\tGdx.input.setInputProcessor(this);\n\n\t\tVector3 min = new Vector3(-100 / 2, -100 / 2, -100 / 2);\n\t\tVector3 max = new Vector3(100 / 2, 100 / 2, 100 / 2);\n\t\toctree = new Octree<GameObject>(min, max, MAX_DEPTH, MAX_ITEMS_PER_NODE, new Octree.Collider<GameObject>() {\n\t\t\t@Override", "refactored_code": "\tprivate static final float AREA_SIZE = 100;\n\t\tcamController = new FirstPersonCameraController(cam);\n\t\tGdx.input.setInputProcessor(this);\n\n\t\tVector3 min = new Vector3(-AREA_SIZE / 2, -AREA_SIZE / 2, -AREA_SIZE / 2);\n\t\tVector3 max = new Vector3(AREA_SIZE / 2, AREA_SIZE / 2, AREA_SIZE / 2);\n\t\toctree = new Octree<GameObject>(min, max, MAX_DEPTH, MAX_ITEMS_PER_NODE, new Octree.Collider<GameObject>() {\n\t\t\t@Override"}
{"magic_number_smell": "\t\t}\n\t\t// Clear the list\n\t\tboxes.clear();\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tboxes.add(new Box());\n\t\t}\n\t}", "refactored_code": "\tprivate static final int NUM_BOXES = 100;\n\t\t}\n\t\t// Clear the list\n\t\tboxes.clear();\n\t\tfor (int i = 0; i < NUM_BOXES; i++) {\n\t\t\tboxes.add(new Box());\n\t\t}\n\t}"}
{"magic_number_smell": "\t\tif (Gdx.input.isKeyJustPressed(Keys.B)) debug = !debug;\n\n\t\t// apply gravity if we are falling\n\t\tkoala.velocity.add(0, -2.5f);\n\n\t\t// clamp the velocity to the maximum, x-axis only\n\t\tkoala.velocity.x = MathUtils.clamp(koala.velocity.x, -Koala.MAX_VELOCITY, Koala.MAX_VELOCITY);", "refactored_code": "\tprivate static final float GRAVITY = -2.5f;\n\t\tif (Gdx.input.isKeyJustPressed(Keys.B)) debug = !debug;\n\n\t\t// apply gravity if we are falling\n\t\tkoala.velocity.add(0, GRAVITY);\n\n\t\t// clamp the velocity to the maximum, x-axis only\n\t\tkoala.velocity.x = MathUtils.clamp(koala.velocity.x, -Koala.MAX_VELOCITY, Koala.MAX_VELOCITY);"}
{"magic_number_smell": "                }\n            } else {\n                // park for a bit so other threads can schedule\n                LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(1));\n            }\n        }\n    }", "refactored_code": "    private static final long PARK_TIME = TimeUnit.MILLISECONDS.toNanos(1);\n                }\n            } else {\n                // park for a bit so other threads can schedule\n                LockSupport.parkNanos(PARK_TIME);\n            }\n        }\n    }"}
{"magic_number_smell": "                URL currentUrl = url;\n                var userAgent = this.agent + ' ' + mod.getModId() + '/' + mod.getVersion();\n\n                for (int redirects = 0; redirects < Integer.getInteger(\"http.maxRedirects\", 20); redirects++) {\n                    var request = HttpRequest.newBuilder()\n                            .uri(currentUrl.toURI())\n                            .timeout(Duration.ofSeconds(HTTP_TIMEOUT_SECS))", "refactored_code": "    private static final int MAX_HTTP_REDIRECTS = Integer.getInteger(\"http.maxRedirects\", 20);\n                URL currentUrl = url;\n                var userAgent = this.agent + ' ' + mod.getModId() + '/' + mod.getVersion();\n\n                for (int redirects = 0; redirects < MAX_HTTP_REDIRECTS; redirects++) {\n                    var request = HttpRequest.newBuilder()\n                            .uri(currentUrl.toURI())\n                            .timeout(Duration.ofSeconds(HTTP_TIMEOUT_SECS))"}
{"magic_number_smell": "            if ((nt = System.nanoTime()) < nextFrameTime) {\n                return;\n            }\n            nextFrameTime = nt + TimeUnit.MILLISECONDS.toNanos(10);\n            glfwMakeContextCurrent(window);\n            framebuffer.activate();\n            glViewport(0, 0, this.context.scaledWidth(), this.context.scaledHeight());", "refactored_code": "    private static final long MINFRAMETIME = TimeUnit.MILLISECONDS.toNanos(10); // This is the FPS cap on the window - note animation is capped at 20FPS via the tickTimer\n            if ((nt = System.nanoTime()) < nextFrameTime) {\n                return;\n            }\n            nextFrameTime = nt + MINFRAMETIME;\n            glfwMakeContextCurrent(window);\n            framebuffer.activate();\n            glViewport(0, 0, this.context.scaledWidth(), this.context.scaledHeight());"}
{"magic_number_smell": "    private static final int 20 = 20;\n    private static final int BAR_WIDTH = 400;\n    private static Renderer barRenderer(int cnt, int alpha, SimpleFont font, ProgressMeter pm, DisplayContext context) {\n        var barSpacing = font.lineSpacing() - font.descent() + 20;\n        var y = 250 * context.scale() + cnt * barSpacing;\n        var colour = (alpha << 24) | 0xFFFFFF;\n        Renderer bar;", "refactored_code": "    private static final int BAR_HEIGHT = 20;\n    private static final int BAR_HEIGHT = 20;\n    private static final int BAR_WIDTH = 400;\n    private static Renderer barRenderer(int cnt, int alpha, SimpleFont font, ProgressMeter pm, DisplayContext context) {\n        var barSpacing = font.lineSpacing() - font.descent() + BAR_HEIGHT;\n        var y = 250 * context.scale() + cnt * barSpacing;\n        var colour = (alpha << 24) | 0xFFFFFF;\n        Renderer bar;"}
{"magic_number_smell": "        glActiveTexture(GL_TEXTURE0+textureNumber);\n        this.textureNumber = textureNumber;\n        glBindTexture(GL_TEXTURE_2D, fontTextureId);\n        try (var packedchars = STBTTPackedchar.malloc(127-32)) {\n            int texwidth = 256;\n            int texheight = 128;\n            try (STBTTPackRange.Buffer packRanges = STBTTPackRange.malloc(1)) {", "refactored_code": "    private final int GLYPH_COUNT = 127-32;\n        glActiveTexture(GL_TEXTURE0+textureNumber);\n        this.textureNumber = textureNumber;\n        glBindTexture(GL_TEXTURE_2D, fontTextureId);\n        try (var packedchars = STBTTPackedchar.malloc(GLYPH_COUNT)) {\n            int texwidth = 256;\n            int texheight = 128;\n            try (STBTTPackRange.Buffer packRanges = STBTTPackRange.malloc(1)) {"}
{"magic_number_smell": "    private static String getPrefix()\n    {\n        StackTraceElement[] elems = Thread.currentThread().getStackTrace();\n        StackTraceElement elem = elems[Math.min(4, elems.length - 1)]; // The caller is always at 4, including this call.\n        if (elem.getClassName().startsWith(\"kotlin.io.\"))\n        {\n            elem = elems[Math.min(4 + 2, elems.length - 1)]; // Kotlins IoPackage masks origins 2 deeper in the stack.", "refactored_code": "    private static final int BASE_DEPTH = 4;\n    private static String getPrefix()\n    {\n        StackTraceElement[] elems = Thread.currentThread().getStackTrace();\n        StackTraceElement elem = elems[Math.min(BASE_DEPTH, elems.length - 1)]; // The caller is always at BASE_DEPTH, including this call.\n        if (elem.getClassName().startsWith(\"kotlin.io.\"))\n        {\n            elem = elems[Math.min(BASE_DEPTH + 2, elems.length - 1)]; // Kotlins IoPackage masks origins 2 deeper in the stack."}
{"magic_number_smell": "        private List<FormattedCharSequence> lines = Collections.emptyList();\n\n        InfoPanel(Minecraft mcIn, int widthIn, int heightIn, int topIn) {\n            super(mcIn, widthIn, heightIn, topIn, modList.getRight() + 6);\n        }\n\n        void setInfo(List<String> lines, ResourceLocation logoPath, Size2i logoDims) {", "refactored_code": "    private static final int PADDING = 6;\n        private List<FormattedCharSequence> lines = Collections.emptyList();\n\n        InfoPanel(Minecraft mcIn, int widthIn, int heightIn, int topIn) {\n            super(mcIn, widthIn, heightIn, topIn, modList.getRight() + PADDING);\n        }\n\n        void setInfo(List<String> lines, ResourceLocation logoPath, Size2i logoDims) {"}
{"magic_number_smell": "        private final List<Pair<FormattedCharSequence, Pair<FormattedCharSequence, FormattedCharSequence>>> lineTable;\n        private final int contentSize;\n        private final int 10 = 10;\n        private final int tableWidth = width - border * 2 - 6 - 10;\n        private final int nameWidth = tableWidth * 3 / 5;\n        private final int versionWidth = (tableWidth - nameWidth) / 2;\n", "refactored_code": "        private final int nameIndent = 10;\n        private final List<Pair<FormattedCharSequence, Pair<FormattedCharSequence, FormattedCharSequence>>> lineTable;\n        private final int contentSize;\n        private final int nameIndent = 10;\n        private final int tableWidth = width - border * 2 - 6 - nameIndent;\n        private final int nameWidth = tableWidth * 3 / 5;\n        private final int versionWidth = (tableWidth - nameWidth) / 2;\n"}
{"magic_number_smell": "                guiGraphics.pose().translate(width / 2D, height - Math.max(yShift, 68), 0.0D);\n                RenderSystem.enableBlend();\n                RenderSystem.defaultBlendFunc();\n                int color = (animateOverlayMessageColor ? Mth.hsvToRgb(hue / 50.0F, 0.7F, 0.6F) & 0xFFFFFF : 0xFFFFFF);\n                int messageWidth = getFont().width(overlayMessageString);\n                drawBackdrop(guiGraphics, getFont(), -4, messageWidth, 16777215 | (opacity << 24));\n                guiGraphics.drawString(getFont(), overlayMessageString.getVisualOrderText(), -messageWidth / 2, -4, color | (opacity << 24));", "refactored_code": "    private static final int WHITE = 0xFFFFFF;\n                guiGraphics.pose().translate(width / 2D, height - Math.max(yShift, 68), 0.0D);\n                RenderSystem.enableBlend();\n                RenderSystem.defaultBlendFunc();\n                int color = (animateOverlayMessageColor ? Mth.hsvToRgb(hue / 50.0F, 0.7F, 0.6F) & WHITE : WHITE);\n                int messageWidth = getFont().width(overlayMessageString);\n                drawBackdrop(guiGraphics, getFont(), -4, messageWidth, 16777215 | (opacity << 24));\n                guiGraphics.drawString(getFont(), overlayMessageString.getVisualOrderText(), -messageWidth / 2, -4, color | (opacity << 24));"}
{"magic_number_smell": "    }\n\n    public void horizontalBlock(Block block, ModelFile model) {\n        horizontalBlock(block, model, 180);\n    }\n\n    public void horizontalBlock(Block block, ModelFile model, int angleOffset) {", "refactored_code": "    private static final int DEFAULT_ANGLE_OFFSET = 180;\n    }\n\n    public void horizontalBlock(Block block, ModelFile model) {\n        horizontalBlock(block, model, DEFAULT_ANGLE_OFFSET);\n    }\n\n    public void horizontalBlock(Block block, ModelFile model, int angleOffset) {"}
{"magic_number_smell": "    }\n\n    public static ConfiguredModel[] allYRotations(ModelFile model, int x, boolean uvlock) {\n        return allYRotations(model, x, uvlock, 1);\n    }\n\n    public static ConfiguredModel[] allYRotations(ModelFile model, int x, boolean uvlock, int weight) {", "refactored_code": "    public static final int DEFAULT_WEIGHT = 1;\n    }\n\n    public static ConfiguredModel[] allYRotations(ModelFile model, int x, boolean uvlock) {\n        return allYRotations(model, x, uvlock, DEFAULT_WEIGHT);\n    }\n\n    public static ConfiguredModel[] allYRotations(ModelFile model, int x, boolean uvlock, int weight) {"}
{"magic_number_smell": "    @Override\n    protected int calculateLightmap(float[] position, byte[] normal)\n    {\n        if ((isFullCube || position[1] < -1f - 1e-2f) && normal[1] <= -MAX_NORMAL)\n            return packedLight[Direction.DOWN.ordinal()];\n\n        if ((isFullCube || position[1] > 1f - 1e-2f) && normal[1] >= MAX_NORMAL)", "refactored_code": "    private static final float MAX_POSITION = 1f - 1e-2f;\n    @Override\n    protected int calculateLightmap(float[] position, byte[] normal)\n    {\n        if ((isFullCube || position[1] < -MAX_POSITION) && normal[1] <= -MAX_NORMAL)\n            return packedLight[Direction.DOWN.ordinal()];\n\n        if ((isFullCube || position[1] > MAX_POSITION) && normal[1] >= MAX_NORMAL)"}
{"magic_number_smell": "    private final Consumer<BakedQuad> quadConsumer;\n\n    int vertexIndex = 0;\n    private int[] quadData = new int[IQuadTransformer.STRIDE * 4];\n\n    private int tintIndex;\n    private Direction direction = Direction.DOWN;", "refactored_code": "    private static final int QUAD_DATA_SIZE = IQuadTransformer.STRIDE * 4;\n    private final Consumer<BakedQuad> quadConsumer;\n\n    int vertexIndex = 0;\n    private int[] quadData = new int[QUAD_DATA_SIZE];\n\n    private int tintIndex;\n    private Direction direction = Direction.DOWN;"}
{"magic_number_smell": "        private final SoundType type;\n\n        // Optional parameters, available in specs\n        private float volume = 1.0F;\n        private float pitch = DEFAULT_PITCH;\n        private int weight = DEFAULT_WEIGHT;\n        private boolean stream = DEFAULT_STREAM;", "refactored_code": "        private static final float DEFAULT_VOLUME = 1.0F;\n        private final SoundType type;\n\n        // Optional parameters, available in specs\n        private float volume = DEFAULT_VOLUME;\n        private float pitch = DEFAULT_PITCH;\n        private int weight = DEFAULT_WEIGHT;\n        private boolean stream = DEFAULT_STREAM;"}
{"magic_number_smell": "\n        // If the inputs are too close for comfort, linearly interpolate\n        // and normalize the result.\n        if (dot > 0.9995) {\n            float x = Mth.lerp(t, v0.x(), v1.x());\n            float y = Mth.lerp(t, v0.y(), v1.y());\n            float z = Mth.lerp(t, v0.z(), v1.z());", "refactored_code": "    private static final double THRESHOLD = 0.9995;\n\n        // If the inputs are too close for comfort, linearly interpolate\n        // and normalize the result.\n        if (dot > THRESHOLD) {\n            float x = Mth.lerp(t, v0.x(), v1.x());\n            float y = Mth.lerp(t, v0.y(), v1.y());\n            float z = Mth.lerp(t, v0.z(), v1.z());"}
{"magic_number_smell": "            for (var i = 0; i < modsSize; i++) {\n                var channelSizeAndVersionFlag = buf.readVarInt();\n                var channelSize = channelSizeAndVersionFlag >>> 1;\n                var isIgnoreServerOnly = (channelSizeAndVersionFlag & 0b1) != 0;\n                var modId = buf.readUtf();\n                var modVersion = isIgnoreServerOnly ? IExtensionPoint.DisplayTest.IGNORESERVERONLY : buf.readUtf();\n                for (var i1 = 0; i1 < channelSize; i1++) {", "refactored_code": "    private static final int VERSION_FLAG_IGNORESERVERONLY = 0b1;\n            for (var i = 0; i < modsSize; i++) {\n                var channelSizeAndVersionFlag = buf.readVarInt();\n                var channelSize = channelSizeAndVersionFlag >>> 1;\n                var isIgnoreServerOnly = (channelSizeAndVersionFlag & VERSION_FLAG_IGNORESERVERONLY) != 0;\n                var modId = buf.readUtf();\n                var modVersion = isIgnoreServerOnly ? IExtensionPoint.DisplayTest.IGNORESERVERONLY : buf.readUtf();\n                for (var i1 = 0; i1 < channelSize; i1++) {"}
{"magic_number_smell": "        } else {\n            FriendlyByteBuf buf = new FriendlyByteBuf(Unpooled.buffer());\n            packet.write(buf);\n            if (buf.readableBytes() <= CompressionDecoder.MAXIMUM_UNCOMPRESSED_LENGTH) {\n                buf.release();\n                out.add(packet);\n            } else {", "refactored_code": "    private static final int PROTOCOL_MAX = CompressionDecoder.MAXIMUM_UNCOMPRESSED_LENGTH;\n        } else {\n            FriendlyByteBuf buf = new FriendlyByteBuf(Unpooled.buffer());\n            packet.write(buf);\n            if (buf.readableBytes() <= PROTOCOL_MAX) {\n                buf.release();\n                out.add(packet);\n            } else {"}
{"magic_number_smell": "\n    public static MismatchData decode(FriendlyByteBuf buf) {\n        var mismatched = buf.readMap(\n            i -> new ResourceLocation(i.readUtf(0x100)),\n            i -> new Version(\n                i.readUtf(0x100),\n                i.readUtf(0x100)", "refactored_code": "    private static final int MAX_LENGTH = 0x100;\n\n    public static MismatchData decode(FriendlyByteBuf buf) {\n        var mismatched = buf.readMap(\n            i -> new ResourceLocation(i.readUtf(MAX_LENGTH)),\n            i -> new Version(\n                i.readUtf(MAX_LENGTH),\n                i.readUtf(MAX_LENGTH)"}
{"magic_number_smell": "\n    public static ModVersions decode(FriendlyByteBuf buf) {\n        return new ModVersions(buf.readMap(\n            o -> o.readUtf(0x100),\n            o -> new Info(\n                o.readUtf(0x100),\n                o.readUtf(0x100)", "refactored_code": "    private static final int MAX_LENGTH = 0x100;\n\n    public static ModVersions decode(FriendlyByteBuf buf) {\n        return new ModVersions(buf.readMap(\n            o -> o.readUtf(MAX_LENGTH),\n            o -> new Info(\n                o.readUtf(MAX_LENGTH),\n                o.readUtf(MAX_LENGTH)"}
{"magic_number_smell": "\n    static RegistryBuilder<EntityDataSerializer<?>> getDataSerializersRegistryBuilder()\n    {\n        return makeRegistry(Keys.ENTITY_DATA_SERIALIZERS, 256 /*vanilla space*/, Integer.MAX_VALUE - 1).disableSaving().disableOverrides();\n    }\n\n    static RegistryBuilder<Codec<? extends IGlobalLootModifier>> getGLMSerializersRegistryBuilder()", "refactored_code": "    private static final int MAX_VARINT = Integer.MAX_VALUE - 1; //We were told it is their intention to have everything in a reg be unlimited, so assume that until we find cases where it isnt.\n\n    static RegistryBuilder<EntityDataSerializer<?>> getDataSerializersRegistryBuilder()\n    {\n        return makeRegistry(Keys.ENTITY_DATA_SERIALIZERS, 256 /*vanilla space*/, MAX_VARINT).disableSaving().disableOverrides();\n    }\n\n    static RegistryBuilder<Codec<? extends IGlobalLootModifier>> getGLMSerializersRegistryBuilder()"}
{"magic_number_smell": "    private ResourceLocation registryName;\n    private ResourceLocation optionalDefaultKey;\n    private int minId = 0;\n    private int maxId = Integer.MAX_VALUE - 1;\n    private List<AddCallback<T>> addCallback = Lists.newArrayList();\n    private List<ClearCallback<T>> clearCallback = Lists.newArrayList();\n    private List<CreateCallback<T>> createCallback = Lists.newArrayList();", "refactored_code": "    private static final int MAX_ID = Integer.MAX_VALUE - 1;\n    private ResourceLocation registryName;\n    private ResourceLocation optionalDefaultKey;\n    private int minId = 0;\n    private int maxId = MAX_ID;\n    private List<AddCallback<T>> addCallback = Lists.newArrayList();\n    private List<ClearCallback<T>> clearCallback = Lists.newArrayList();\n    private List<CreateCallback<T>> createCallback = Lists.newArrayList();"}
{"magic_number_smell": "            final Supplier<Stream<String>> names)\n    {\n        final String allElementNames = names.get().sorted().collect(Collectors.joining(\"\\n\"));\n        final long totalPages = (count - 1) / 8 + 1;\n        final long actualPage = (long) Mth.clamp(currentPage, 1, totalPages);\n\n        MutableComponent containsComponent = Component.translatable(containsText, count);", "refactored_code": "    private static final long PAGE_SIZE = 8;\n            final Supplier<Stream<String>> names)\n    {\n        final String allElementNames = names.get().sorted().collect(Collectors.joining(\"\\n\"));\n        final long totalPages = (count - 1) / PAGE_SIZE + 1;\n        final long actualPage = (long) Mth.clamp(currentPage, 1, totalPages);\n\n        MutableComponent containsComponent = Component.translatable(containsText, count);"}
{"magic_number_smell": "\n    private static CompoundTag damaged() {\n        return CompoundTag.builder()\n            .putInt(ItemStack.TAG_DAMAGE, 3)\n            .build();\n    }\n", "refactored_code": "    private static final int TEST_DAMAGE = 3;\n\n    private static CompoundTag damaged() {\n        return CompoundTag.builder()\n            .putInt(ItemStack.TAG_DAMAGE, TEST_DAMAGE)\n            .build();\n    }\n"}
{"magic_number_smell": "        spec.afterReload();\n        setUseCachesField(true);\n        final Stopwatch watchDisabled = Stopwatch.createStarted();\n        for (int i = 0; i < 10000; i++)\n        {\n            Assert.assertEquals(defaultKeyValue, simpleValue.get());\n        }", "refactored_code": "    private final int TEST_SIZE = 10000;\n        spec.afterReload();\n        setUseCachesField(true);\n        final Stopwatch watchDisabled = Stopwatch.createStarted();\n        for (int i = 0; i < TEST_SIZE; i++)\n        {\n            Assert.assertEquals(defaultKeyValue, simpleValue.get());\n        }"}
{"magic_number_smell": "            for(int i = 0; i < capacity; i++)\n            {\n                buffer.put(i, (byte) (Math.sin(value) * 127));\n                value = (value + 2 * Math.PI * 220 / 44100) % Math.PI;\n            }\n            return buffer;\n        }", "refactored_code": "        private static final double DT = 2 * Math.PI * 220 / 44100;\n            for(int i = 0; i < capacity; i++)\n            {\n                buffer.put(i, (byte) (Math.sin(value) * 127));\n                value = (value + DT) % Math.PI;\n            }\n            return buffer;\n        }"}
{"magic_number_smell": "            if ((FMLEnvironment.dist == Dist.DEDICATED_SERVER && REGISTER_FOR_SERVER) || (FMLEnvironment.dist == Dist.CLIENT && REGISTER_FOR_CLIENT)) {\n                var channel = ChannelBuilder\n                        .named(new ResourceLocation(MOD_ID, \"channel\"))\n                        .networkProtocolVersion(FMLEnvironment.dist == Dist.CLIENT ? 1 : 2)\n                        .simpleChannel();\n            }\n            if (REGISTER_REGISTRY_ENTRY && FMLEnvironment.dist == Dist.DEDICATED_SERVER)", "refactored_code": "    private static final int CHANNEL_PROTOCOL_VERSION = FMLEnvironment.dist == Dist.CLIENT ? 1 : 2;\n            if ((FMLEnvironment.dist == Dist.DEDICATED_SERVER && REGISTER_FOR_SERVER) || (FMLEnvironment.dist == Dist.CLIENT && REGISTER_FOR_CLIENT)) {\n                var channel = ChannelBuilder\n                        .named(new ResourceLocation(MOD_ID, \"channel\"))\n                        .networkProtocolVersion(CHANNEL_PROTOCOL_VERSION)\n                        .simpleChannel();\n            }\n            if (REGISTER_REGISTRY_ENTRY && FMLEnvironment.dist == Dist.DEDICATED_SERVER)"}
{"magic_number_smell": "        ItemStack item = slot.getItem();\n        ret = item.copy();\n\n        if (idx == 0) {\n            if (!this.moveItemStackTo(item, INVENTORY_START, INVENTORY_STOP + 1, true))\n                return ItemStack.EMPTY;\n", "refactored_code": "    private static final int RESULT_SLOT = 0;\n        ItemStack item = slot.getItem();\n        ret = item.copy();\n\n        if (idx == RESULT_SLOT) {\n            if (!this.moveItemStackTo(item, INVENTORY_START, INVENTORY_STOP + 1, true))\n                return ItemStack.EMPTY;\n"}
{"magic_number_smell": "    private static final boolean ENABLED = true;\n    private static final int 100000 = 100000;\n\n    private static final List<ItemStack> WARMUP_RESULTS           = new ArrayList<>(100000 * 4);\n    private static final List<ItemStack> NO_CAPS_DISABLED_RESULTS = new ArrayList<>(100000);\n    private static final List<ItemStack> WITH_CAPS_DISABLED_RESULTS = new ArrayList<>(100000);\n    private static final List<ItemStack> NO_CAPS_ENABLED_RESULTS = new ArrayList<>(100000);", "refactored_code": "    private static final int SAMPLE_SIZE = 100000;\n    private static final boolean ENABLED = true;\n    private static final int SAMPLE_SIZE = 100000;\n\n    private static final List<ItemStack> WARMUP_RESULTS           = new ArrayList<>(SAMPLE_SIZE * 4);\n    private static final List<ItemStack> NO_CAPS_DISABLED_RESULTS = new ArrayList<>(SAMPLE_SIZE);\n    private static final List<ItemStack> WITH_CAPS_DISABLED_RESULTS = new ArrayList<>(SAMPLE_SIZE);\n    private static final List<ItemStack> NO_CAPS_ENABLED_RESULTS = new ArrayList<>(SAMPLE_SIZE);"}
{"magic_number_smell": "        Column column = column(\"Column\", TextTable.Alignment.LEFT);\n        column.fit(WIDTH_REFERENCE);\n        String paddedHeader = column.formatHeader(\"-\");\n        assertEquals(WIDTH_REFERENCE.length(), paddedHeader.length(), \"Formatted column header didn't have correct length\");\n        assertEquals(\"Column---------\", paddedHeader, \"Formatted column header wasn't padded properly\");\n\n        String paddedReference = column.format(WIDTH_REFERENCE, \"-\");", "refactored_code": "    private static final int WIDTH_REFERENCE_LENGTH = WIDTH_REFERENCE.length();\n        Column column = column(\"Column\", TextTable.Alignment.LEFT);\n        column.fit(WIDTH_REFERENCE);\n        String paddedHeader = column.formatHeader(\"-\");\n        assertEquals(WIDTH_REFERENCE_LENGTH, paddedHeader.length(), \"Formatted column header didn't have correct length\");\n        assertEquals(\"Column---------\", paddedHeader, \"Formatted column header wasn't padded properly\");\n\n        String paddedReference = column.format(WIDTH_REFERENCE, \"-\");"}
{"magic_number_smell": "\tArrayList<OnKeyListener> keyListeners = new ArrayList();\n\tArrayList<KeyEvent> keyEvents = new ArrayList();\n\tArrayList<TouchEvent> touchEvents = new ArrayList();\n\tint[] touchX = new int[20];\n\tint[] touchY = new int[20];\n\tint[] deltaX = new int[20];\n\tint[] deltaY = new int[20];", "refactored_code": "\tpublic static final int NUM_TOUCHES = 20;\n\tArrayList<OnKeyListener> keyListeners = new ArrayList();\n\tArrayList<KeyEvent> keyEvents = new ArrayList();\n\tArrayList<TouchEvent> touchEvents = new ArrayList();\n\tint[] touchX = new int[NUM_TOUCHES];\n\tint[] touchY = new int[NUM_TOUCHES];\n\tint[] deltaX = new int[NUM_TOUCHES];\n\tint[] deltaY = new int[NUM_TOUCHES];"}
{"magic_number_smell": "\t\tmNumSamples = numSamples;\n\n\t\tmConfigAttribs = new int[] {EGL10.EGL_RED_SIZE, 4, EGL10.EGL_GREEN_SIZE, 4, EGL10.EGL_BLUE_SIZE, 4,\n\t\t\tEGL10.EGL_RENDERABLE_TYPE, 4, EGL10.EGL_NONE};\n\t}\n\n\tpublic EGLConfig chooseConfig (EGL10 egl, EGLDisplay display) {", "refactored_code": "\tprivate static final int EGL_OPENGL_ES2_BIT = 4;\n\t\tmNumSamples = numSamples;\n\n\t\tmConfigAttribs = new int[] {EGL10.EGL_RED_SIZE, 4, EGL10.EGL_GREEN_SIZE, 4, EGL10.EGL_BLUE_SIZE, 4,\n\t\t\tEGL10.EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT, EGL10.EGL_NONE};\n\t}\n\n\tpublic EGLConfig chooseConfig (EGL10 egl, EGLDisplay display) {"}
{"magic_number_smell": "\t\tthis.bufferCount = bufferCount;\n\t\tthis.format = channels > 1 ? AL_FORMAT_STEREO16 : AL_FORMAT_MONO16;\n\t\tthis.sampleRate = sampleRate;\n\t\tsecondsPerBuffer = (float)bufferSize / 2 / channels / sampleRate;\n\t\ttempBuffer = BufferUtils.createByteBuffer(bufferSize);\n\t}\n", "refactored_code": "\tstatic private final int bytesPerSample = 2;\n\t\tthis.bufferCount = bufferCount;\n\t\tthis.format = channels > 1 ? AL_FORMAT_STEREO16 : AL_FORMAT_MONO16;\n\t\tthis.sampleRate = sampleRate;\n\t\tsecondsPerBuffer = (float)bufferSize / bytesPerSample / channels / sampleRate;\n\t\ttempBuffer = BufferUtils.createByteBuffer(bufferSize);\n\t}\n"}
{"magic_number_smell": "\tstatic private final int 4096 * 10 = 4096 * 10;\n\tstatic private final int bufferCount = 3;\n\tstatic private final int bytesPerSample = 2;\n\tstatic private final byte[] tempBytes = new byte[4096 * 10];\n\tstatic private final ByteBuffer tempBuffer = BufferUtils.createByteBuffer(4096 * 10);\n\n\tprivate FloatArray renderedSecondsQueue = new FloatArray(bufferCount);", "refactored_code": "\tstatic private final int bufferSize = 4096 * 10;\n\tstatic private final int bufferSize = 4096 * 10;\n\tstatic private final int bufferCount = 3;\n\tstatic private final int bytesPerSample = 2;\n\tstatic private final byte[] tempBytes = new byte[bufferSize];\n\tstatic private final ByteBuffer tempBuffer = BufferUtils.createByteBuffer(bufferSize);\n\n\tprivate FloatArray renderedSecondsQueue = new FloatArray(bufferCount);"}
{"magic_number_smell": "\t\t}\n\n\t\t// schedule next frame, drop frame(s) if already too late for next frame\n\t\tnextFrame = Math.max(nextFrame + 1000L * 1000L * 1000L / fps, getTime());\n\t}\n\n\t/** This method will initialise the sync method by setting initial values for sleepDurations/yieldDurations and nextFrame.", "refactored_code": "\tprivate static final long NANOS_IN_SECOND = 1000L * 1000L * 1000L;\n\t\t}\n\n\t\t// schedule next frame, drop frame(s) if already too late for next frame\n\t\tnextFrame = Math.max(nextFrame + NANOS_IN_SECOND / fps, getTime());\n\t}\n\n\t/** This method will initialise the sync method by setting initial values for sleepDurations/yieldDurations and nextFrame."}
{"magic_number_smell": "\t\tthis.bufferCount = bufferCount;\n\t\tthis.format = channels > 1 ? AL_FORMAT_STEREO16 : AL_FORMAT_MONO16;\n\t\tthis.sampleRate = sampleRate;\n\t\tsecondsPerBuffer = (float)bufferSize / 2 / channels / sampleRate;\n\t\ttempBuffer = BufferUtils.createByteBuffer(bufferSize);\n\t}\n", "refactored_code": "\tstatic private final int bytesPerSample = 2;\n\t\tthis.bufferCount = bufferCount;\n\t\tthis.format = channels > 1 ? AL_FORMAT_STEREO16 : AL_FORMAT_MONO16;\n\t\tthis.sampleRate = sampleRate;\n\t\tsecondsPerBuffer = (float)bufferSize / bytesPerSample / channels / sampleRate;\n\t\ttempBuffer = BufferUtils.createByteBuffer(bufferSize);\n\t}\n"}
{"magic_number_smell": "\tstatic private final int 4096 * 10 = 4096 * 10;\n\tstatic private final int bufferCount = 3;\n\tstatic private final int bytesPerSample = 2;\n\tstatic private final byte[] tempBytes = new byte[4096 * 10];\n\tstatic private final ByteBuffer tempBuffer = BufferUtils.createByteBuffer(4096 * 10);\n\n\tprivate FloatArray renderedSecondsQueue = new FloatArray(bufferCount);", "refactored_code": "\tstatic private final int bufferSize = 4096 * 10;\n\tstatic private final int bufferSize = 4096 * 10;\n\tstatic private final int bufferCount = 3;\n\tstatic private final int bytesPerSample = 2;\n\tstatic private final byte[] tempBytes = new byte[bufferSize];\n\tstatic private final ByteBuffer tempBuffer = BufferUtils.createByteBuffer(bufferSize);\n\n\tprivate FloatArray renderedSecondsQueue = new FloatArray(bufferCount);"}
{"magic_number_smell": "\t\t\tsb.append(i + \":\" + touchDown[i] + \" \");\n\t\t}\n\t\tGdx.app.error(\"IOSInput\", \"Pointer ID lookup failed: \" + ptr + \", \" + sb.toString());\n\t\treturn -1;\n\t}\n\n\tprivate static class NSSetExtensions extends NSExtensions {", "refactored_code": "\tprivate static final int POINTER_NOT_FOUND = -1;\n\t\t\tsb.append(i + \":\" + touchDown[i] + \" \");\n\t\t}\n\t\tGdx.app.error(\"IOSInput\", \"Pointer ID lookup failed: \" + ptr + \", \" + sb.toString());\n\t\treturn POINTER_NOT_FOUND;\n\t}\n\n\tprivate static class NSSetExtensions extends NSExtensions {"}
{"magic_number_smell": "\t\t\tsb.append(i + \":\" + touchDown[i] + \" \");\n\t\t}\n\t\tGdx.app.error(\"IOSInput\", \"Pointer ID lookup failed: \" + ptr + \", \" + sb.toString());\n\t\treturn -1;\n\t}\n\n\t/** DO NOT EDIT THIS FILE - it is machine generated */", "refactored_code": "\tprivate static final int POINTER_NOT_FOUND = -1;\n\t\t\tsb.append(i + \":\" + touchDown[i] + \" \");\n\t\t}\n\t\tGdx.app.error(\"IOSInput\", \"Pointer ID lookup failed: \" + ptr + \", \" + sb.toString());\n\t\treturn POINTER_NOT_FOUND;\n\t}\n\n\t/** DO NOT EDIT THIS FILE - it is machine generated */"}
{"magic_number_smell": "\t/** Schedules a task to occur once after the specified delay and then a number of additional times at the specified\n\t * interval. */\n\tpublic Task scheduleTask (Task task, float delaySeconds, float intervalSeconds, int repeatCount) {\n\t\tif (task.repeatCount != -1) throw new IllegalArgumentException(\"The same task may not be scheduled twice.\");\n\t\ttask.executeTimeMillis = TimeUtils.nanoTime() / 1000000 + (long)(delaySeconds * 1000);\n\t\ttask.intervalMillis = (long)(intervalSeconds * 1000);\n\t\ttask.repeatCount = repeatCount;", "refactored_code": "\tstatic private final int CANCELLED = -1;\n\t/** Schedules a task to occur once after the specified delay and then a number of additional times at the specified\n\t * interval. */\n\tpublic Task scheduleTask (Task task, float delaySeconds, float intervalSeconds, int repeatCount) {\n\t\tif (task.repeatCount != CANCELLED) throw new IllegalArgumentException(\"The same task may not be scheduled twice.\");\n\t\ttask.executeTimeMillis = TimeUtils.nanoTime() / 1000000 + (long)(delaySeconds * 1000);\n\t\ttask.intervalMillis = (long)(intervalSeconds * 1000);\n\t\ttask.repeatCount = repeatCount;"}
{"magic_number_smell": "\n\t/** @return The current value of the system timer, in nanoseconds. */\n\tpublic static long nanoTime () {\n\t\treturn System.currentTimeMillis() * 1000000;\n\t}\n\n\t/** @return the difference, measured in milliseconds, between the current time and midnight, January 1, 1970 UTC. */", "refactored_code": "\tprivate static final long nanosPerMilli = 1000000;\n\n\t/** @return The current value of the system timer, in nanoseconds. */\n\tpublic static long nanoTime () {\n\t\treturn System.currentTimeMillis() * nanosPerMilli;\n\t}\n\n\t/** @return the difference, measured in milliseconds, between the current time and midnight, January 1, 1970 UTC. */"}
{"magic_number_smell": "\tprivate int charOffset;\n\n\tpublic Utf8Decoder () {\n\t\tthis.state = 0;\n\t}\n\n\tprotected void reset () {", "refactored_code": "\tprivate static final int UTF8_ACCEPT = 0;\n\tprivate int charOffset;\n\n\tpublic Utf8Decoder () {\n\t\tthis.state = UTF8_ACCEPT;\n\t}\n\n\tprotected void reset () {"}
{"magic_number_smell": "\tprivate HandlerRegistration windowHandler;\n\n\t/** The delay between resize checks. */\n\tint resizeCheckDelay = 400;\n\n\t/** A boolean indicating that resize checking should run. */\n\tboolean resizeCheckingEnabled;", "refactored_code": "\tprivate static final int DEFAULT_RESIZE_CHECK_DELAY = 400;\n\tprivate HandlerRegistration windowHandler;\n\n\t/** The delay between resize checks. */\n\tint resizeCheckDelay = DEFAULT_RESIZE_CHECK_DELAY;\n\n\t/** A boolean indicating that resize checking should run. */\n\tboolean resizeCheckingEnabled;"}
{"magic_number_smell": "\t/** Transforms the given vector by this transform\n\t * @param v the vector */\n\tpublic Vector2 mul (Vector2 v) {\n\t\tfloat x = vals[0] + vals[COS] * v.x + -vals[SIN] * v.y;\n\t\tfloat y = vals[POS_Y] + vals[SIN] * v.x + vals[COS] * v.y;\n\n\t\tv.x = x;", "refactored_code": "\tpublic static final int POS_X = 0;\n\t/** Transforms the given vector by this transform\n\t * @param v the vector */\n\tpublic Vector2 mul (Vector2 v) {\n\t\tfloat x = vals[POS_X] + vals[COS] * v.x + -vals[SIN] * v.y;\n\t\tfloat y = vals[POS_Y] + vals[SIN] * v.x + vals[COS] * v.y;\n\n\t\tv.x = x;"}
{"magic_number_smell": "\t/** Transforms the given vector by this transform\n\t * @param v the vector */\n\tpublic Vector2 mul (Vector2 v) {\n\t\tfloat x = vals[0] + vals[COS] * v.x + -vals[SIN] * v.y;\n\t\tfloat y = vals[POS_Y] + vals[SIN] * v.x + vals[COS] * v.y;\n\n\t\tv.x = x;", "refactored_code": "\tpublic static final int POS_X = 0;\n\t/** Transforms the given vector by this transform\n\t * @param v the vector */\n\tpublic Vector2 mul (Vector2 v) {\n\t\tfloat x = vals[POS_X] + vals[COS] * v.x + -vals[SIN] * v.y;\n\t\tfloat y = vals[POS_Y] + vals[SIN] * v.x + vals[COS] * v.y;\n\n\t\tv.x = x;"}
{"magic_number_smell": "\n\t\t// Main iteration loop\n\t\tint iter = 0;\n\t\twhile (iter < 20) {\n\n\t\t\t// Copy simplex so we can identify duplicates.\n\t\t\tsaveCount = simplex.m_count;", "refactored_code": "\tpublic static final int MAX_ITERS = 20;\n\n\t\t// Main iteration loop\n\t\tint iter = 0;\n\t\twhile (iter < MAX_ITERS) {\n\n\t\t\t// Copy simplex so we can identify duplicates.\n\t\t\tsaveCount = simplex.m_count;"}
{"magic_number_smell": "\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (iter == 1000) {\n\t\t\t\t// System.out.println(\"failed, root finder stuck\");\n\t\t\t\t// Root finder got stuck. Semi-victory.\n\t\t\t\toutput.state = TOIOutputState.FAILED;", "refactored_code": "\tpublic static final int MAX_ITERATIONS = 1000;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (iter == MAX_ITERATIONS) {\n\t\t\t\t// System.out.println(\"failed, root finder stuck\");\n\t\t\t\t// Root finder got stuck. Semi-victory.\n\t\t\t\toutput.state = TOIOutputState.FAILED;"}
{"magic_number_smell": "\npublic class Profile {\n\tprivate static final int 20 = 20;\n\tprivate static final float LONG_FRACTION = 1f / 20;\n\tprivate static final int SHORT_AVG_NUMS = 5;\n\tprivate static final float SHORT_FRACTION = 1f / SHORT_AVG_NUMS;\n", "refactored_code": "\tprivate static final int LONG_AVG_NUMS = 20;\n\npublic class Profile {\n\tprivate static final int LONG_AVG_NUMS = 20;\n\tprivate static final float LONG_FRACTION = 1f / LONG_AVG_NUMS;\n\tprivate static final int SHORT_AVG_NUMS = 5;\n\tprivate static final float SHORT_FRACTION = 1f / SHORT_AVG_NUMS;\n"}
{"magic_number_smell": "\t * \n\t * @param gravity the world gravity vector. */\n\tpublic World (Vec2 gravity) {\n\t\tthis(gravity, new DefaultWorldPool(100, WORLD_POOL_CONTAINER_SIZE));\n\t}\n\n\t/** Construct a world object.", "refactored_code": "\tpublic static final int WORLD_POOL_SIZE = 100;\n\t * \n\t * @param gravity the world gravity vector. */\n\tpublic World (Vec2 gravity) {\n\t\tthis(gravity, new DefaultWorldPool(WORLD_POOL_SIZE, WORLD_POOL_CONTAINER_SIZE));\n\t}\n\n\t/** Construct a world object."}
{"magic_number_smell": "\t\t\t\tbx -= R.ex.x * ax + R.ey.x * ay;\n\t\t\t\tby -= R.ex.y * ax + R.ey.y * ay;\n\n\t\t\t\t// final float 1e-3f = 1e-3f;\n\t\t\t\t// B2_NOT_USED(1e-3f);\n\t\t\t\tfor (;;) {\n\t\t\t\t\t//", "refactored_code": "\tpublic static final float k_errorTol = 1e-3f;\n\t\t\t\tbx -= R.ex.x * ax + R.ey.x * ay;\n\t\t\t\tby -= R.ex.y * ax + R.ey.y * ay;\n\n\t\t\t\t// final float k_errorTol = 1e-3f;\n\t\t\t\t// B2_NOT_USED(k_errorTol);\n\t\t\t\tfor (;;) {\n\t\t\t\t\t//"}
{"magic_number_smell": "\t\t}\n\n\t\tupdateContacts(true);\n\t\tif ((groupDef.flags & ParticleType.b2_springParticle) != 0) {\n\t\t\tfor (int k = 0; k < m_contactCount; k++) {\n\t\t\t\tParticleContact contact = m_contactBuffer[k];\n\t\t\t\tint a = contact.indexA;", "refactored_code": "\tprivate static final int k_pairFlags = ParticleType.b2_springParticle;\n\t\t}\n\n\t\tupdateContacts(true);\n\t\tif ((groupDef.flags & k_pairFlags) != 0) {\n\t\t\tfor (int k = 0; k < m_contactCount; k++) {\n\t\t\t\tParticleContact contact = m_contactBuffer[k];\n\t\t\t\tint a = contact.indexA;"}
{"magic_number_smell": "\t}\n\n\t/** Sets the maximum size that will be used when generating texture atlases for glyphs with <tt>generateData()</tt>. The\n\t * default is 1024. By specifying {@link #-1}, the texture atlas will scale as needed.\n\t * \n\t * The power-of-two square texture size will be capped to the given <tt>texSize</tt>. It's recommended that a power-of-two\n\t * value be used here.", "refactored_code": "\tstatic public final int NO_MAXIMUM = -1;\n\t}\n\n\t/** Sets the maximum size that will be used when generating texture atlases for glyphs with <tt>generateData()</tt>. The\n\t * default is 1024. By specifying {@link #NO_MAXIMUM}, the texture atlas will scale as needed.\n\t * \n\t * The power-of-two square texture size will be capped to the given <tt>texSize</tt>. It's recommended that a power-of-two\n\t * value be used here."}
{"magic_number_smell": "\t\tparams.convertObjectToTileSpace = false;\n\t\tparams.flipY = true;\n\n\t\tviewport = new FitViewport(32, WORLD_HEIGHT);\n\t\tcam = (OrthographicCamera)viewport.getCamera();\n\n\t\tmap = atlasTmxMapLoader.load(TMX_LOC, params);", "refactored_code": "\tprivate final float WORLD_WIDTH = 32;\n\t\tparams.convertObjectToTileSpace = false;\n\t\tparams.flipY = true;\n\n\t\tviewport = new FitViewport(WORLD_WIDTH, WORLD_HEIGHT);\n\t\tcam = (OrthographicCamera)viewport.getCamera();\n\n\t\tmap = atlasTmxMapLoader.load(TMX_LOC, params);"}
{"magic_number_smell": "\t\t\t\tint mouseY = event.getY();\n\t\t\t\tint oldIndex = overIndex;\n\t\t\t\toverIndex = -1;\n\t\t\t\tint pointSize = isExpanded ? POINT_SIZE_EXPANDED : 6;\n\t\t\t\tint i = 0;\n\t\t\t\tfor (Point point : points) {\n\t\t\t\t\tint x = chartX + (int)(chartWidth * (point.x / (float)maxX));", "refactored_code": "\tstatic private final int POINT_SIZE = 6;\n\t\t\t\tint mouseY = event.getY();\n\t\t\t\tint oldIndex = overIndex;\n\t\t\t\toverIndex = -1;\n\t\t\t\tint pointSize = isExpanded ? POINT_SIZE_EXPANDED : POINT_SIZE;\n\t\t\t\tint i = 0;\n\t\t\t\tfor (Point point : points) {\n\t\t\t\t\tint x = chartX + (int)(chartWidth * (point.x / (float)maxX));"}
{"magic_number_smell": "\t\tT res = assetManager.get(resolvedPath);\n\t\tif (currentLoader != null) assetManager.setLoader(type, currentLoader);\n\n\t\tif (exist) EventManager.get().fire(0, new Object[] {oldAsset, res});\n\n\t\treturn res;\n\t}", "refactored_code": "\tpublic static final int EVT_ASSET_RELOADED = 0;\n\t\tT res = assetManager.get(resolvedPath);\n\t\tif (currentLoader != null) assetManager.setLoader(type, currentLoader);\n\n\t\tif (exist) EventManager.get().fire(EVT_ASSET_RELOADED, new Object[] {oldAsset, res});\n\n\t\treturn res;\n\t}"}
{"magic_number_smell": "\n\tstatic public final int 256 = 256;\n\n\tstatic private ByteBuffer scratchByteBuffer = ByteBuffer.allocateDirect(256 * 256 * 4);\n\n\tstatic {\n\t\tscratchByteBuffer.order(ByteOrder.LITTLE_ENDIAN);", "refactored_code": "\tstatic public final int MAX_GLYPH_SIZE = 256;\n\n\tstatic public final int MAX_GLYPH_SIZE = 256;\n\n\tstatic private ByteBuffer scratchByteBuffer = ByteBuffer.allocateDirect(MAX_GLYPH_SIZE * MAX_GLYPH_SIZE * 4);\n\n\tstatic {\n\t\tscratchByteBuffer.order(ByteOrder.LITTLE_ENDIAN);"}
{"magic_number_smell": "\t\tpublic Shape createStrokedShape (Shape shape) {\n\t\t\tGeneralPath result = new GeneralPath();\n\t\t\tshape = new BasicStroke(getWidth(), BasicStroke.CAP_SQUARE, getJoin()).createStrokedShape(shape);\n\t\t\tPathIterator it = new FlatteningPathIterator(shape.getPathIterator(null), 1);\n\t\t\tfloat points[] = new float[6];\n\t\t\tfloat moveX = 0, moveY = 0;\n\t\t\tfloat lastX = 0, lastY = 0;", "refactored_code": "\t\tprivate static final float FLATNESS = 1;\n\t\tpublic Shape createStrokedShape (Shape shape) {\n\t\t\tGeneralPath result = new GeneralPath();\n\t\t\tshape = new BasicStroke(getWidth(), BasicStroke.CAP_SQUARE, getJoin()).createStrokedShape(shape);\n\t\t\tPathIterator it = new FlatteningPathIterator(shape.getPathIterator(null), FLATNESS);\n\t\t\tfloat points[] = new float[6];\n\t\t\tfloat moveX = 0, moveY = 0;\n\t\t\tfloat lastX = 0, lastY = 0;"}
{"magic_number_smell": "\n\t\tpublic Shape createStrokedShape (Shape shape) {\n\t\t\tGeneralPath result = new GeneralPath();\n\t\t\tPathIterator it = new FlatteningPathIterator(shape.getPathIterator(null), 1);\n\t\t\tfloat points[] = new float[6];\n\t\t\tfloat moveX = 0, moveY = 0;\n\t\t\tfloat lastX = 0, lastY = 0;", "refactored_code": "\t\tprivate static final float FLATNESS = 1;\n\n\t\tpublic Shape createStrokedShape (Shape shape) {\n\t\t\tGeneralPath result = new GeneralPath();\n\t\t\tPathIterator it = new FlatteningPathIterator(shape.getPathIterator(null), FLATNESS);\n\t\t\tfloat points[] = new float[6];\n\t\t\tfloat moveX = 0, moveY = 0;\n\t\t\tfloat lastX = 0, lastY = 0;"}
{"magic_number_smell": "\t/** The numberof kernels to apply */\n\tpublic static final int 16 = 16;\n\t/** The blur kernels applied across the effect */\n\tpublic static final float[][] GAUSSIAN_BLUR_KERNELS = generateGaussianBlurKernels(16);\n\n\tprivate Color color = Color.black;\n\tprivate float opacity = 0.6f;", "refactored_code": "\tpublic static final int NUM_KERNELS = 16;\n\t/** The numberof kernels to apply */\n\tpublic static final int NUM_KERNELS = 16;\n\t/** The blur kernels applied across the effect */\n\tpublic static final float[][] GAUSSIAN_BLUR_KERNELS = generateGaussianBlurKernels(NUM_KERNELS);\n\n\tprivate Color color = Color.black;\n\tprivate float opacity = 0.6f;"}
{"magic_number_smell": "\t * @param page The image file related to the page the region is in\n\t * @param region The region to extract */\n\tprivate BufferedImage extractNinePatch (BufferedImage page, Region region, File outputDirFile) {\n\t\tBufferedImage splitImage = extractImage(page, region, outputDirFile, 1);\n\t\tGraphics2D g2 = splitImage.createGraphics();\n\t\tg2.setColor(Color.BLACK);\n", "refactored_code": "\tprivate static final int NINEPATCH_PADDING = 1;\n\t * @param page The image file related to the page the region is in\n\t * @param region The region to extract */\n\tprivate BufferedImage extractNinePatch (BufferedImage page, Region region, File outputDirFile) {\n\t\tBufferedImage splitImage = extractImage(page, region, outputDirFile, NINEPATCH_PADDING);\n\t\tGraphics2D g2 = splitImage.createGraphics();\n\t\tg2.setColor(Color.BLACK);\n"}
{"magic_number_smell": "\t/** Logs a debug message to the console or logcat */\n\tpublic void debug (String tag, String message, Throwable exception);\n\n\t/** Sets the log level. {@link #0} will mute all log output. {@link #LOG_ERROR} will only let error messages through.\n\t * {@link #LOG_INFO} will let all non-debug messages through, and {@link #LOG_DEBUG} will let all messages through.\n\t * @param logLevel {@link #0}, {@link #LOG_ERROR}, {@link #LOG_INFO}, {@link #LOG_DEBUG}. */\n\tpublic void setLogLevel (int logLevel);", "refactored_code": "\tpublic static final int LOG_NONE = 0;\n\t/** Logs a debug message to the console or logcat */\n\tpublic void debug (String tag, String message, Throwable exception);\n\n\t/** Sets the log level. {@link #LOG_NONE} will mute all log output. {@link #LOG_ERROR} will only let error messages through.\n\t * {@link #LOG_INFO} will let all non-debug messages through, and {@link #LOG_DEBUG} will let all messages through.\n\t * @param logLevel {@link #LOG_NONE}, {@link #LOG_ERROR}, {@link #LOG_INFO}, {@link #LOG_DEBUG}. */\n\tpublic void setLogLevel (int logLevel);"}
{"magic_number_smell": "\t\tpublic static final int DPAD_UP = 19;\n\t\tpublic static final int CENTER = 23;\n\t\tpublic static final int DOWN = 20;\n\t\tpublic static final int 0 = 21;\n\t\tpublic static final int RIGHT = 22;\n\t\tpublic static final int UP = 19;\n\t\tpublic static final int E = 33;", "refactored_code": "\t\tpublic static final int LEFT = 0;\n\t\tpublic static final int DPAD_UP = 19;\n\t\tpublic static final int CENTER = 23;\n\t\tpublic static final int DOWN = 20;\n\t\tpublic static final int LEFT = 21;\n\t\tpublic static final int RIGHT = 22;\n\t\tpublic static final int UP = 19;\n\t\tpublic static final int E = 33;"}
{"magic_number_smell": "\t\t\tint type = q[i++];\n\t\t\tcurrentEventTime = (long)q[i++] << 32 | q[i++] & 0xFFFFFFFFL;\n\t\t\tswitch (type) {\n\t\t\tcase -1:\n\t\t\t\ti += q[i];\n\t\t\t\tbreak;\n\t\t\tcase KEY_DOWN:", "refactored_code": "\tstatic private final int SKIP = -1;\n\t\t\tint type = q[i++];\n\t\t\tcurrentEventTime = (long)q[i++] << 32 | q[i++] & 0xFFFFFFFFL;\n\t\t\tswitch (type) {\n\t\t\tcase SKIP:\n\t\t\t\ti += q[i];\n\t\t\t\tbreak;\n\t\t\tcase KEY_DOWN:"}
{"magic_number_smell": "\t/** @author mzechner */\n\tstatic private class CIM {\n\t\tstatic private final int 32000 = 32000;\n\t\tstatic private final byte[] writeBuffer = new byte[32000];\n\t\tstatic private final byte[] readBuffer = new byte[32000];\n\n\t\tstatic public void write (FileHandle file, Pixmap pixmap) {", "refactored_code": "\t\tstatic private final int BUFFER_SIZE = 32000;\n\t/** @author mzechner */\n\tstatic private class CIM {\n\t\tstatic private final int BUFFER_SIZE = 32000;\n\t\tstatic private final byte[] writeBuffer = new byte[BUFFER_SIZE];\n\t\tstatic private final byte[] readBuffer = new byte[BUFFER_SIZE];\n\n\t\tstatic public void write (FileHandle file, Pixmap pixmap) {"}
{"magic_number_smell": "\tpublic static CheckerFrameworkVersion valueOf(String versionString) {\n\t\tif (versionString != null) versionString = versionString.trim();\n\t\tif (versionString == null || versionString.equalsIgnoreCase(\"false\") || versionString.equals(\"0\")) return new CheckerFrameworkVersion(0);\n\t\tif (versionString.equalsIgnoreCase(\"true\")) return new CheckerFrameworkVersion(3200);\n\t\tMatcher m = VERSION.matcher(versionString);\n\t\tif (!m.matches()) throw new IllegalArgumentException(\"Expected 'true' or 'false' or a major/minor version, such as '2.9'\");\n\t\tint major = Integer.parseInt(m.group(1));", "refactored_code": "\tprivate static final int DEFAULT = 3200;\n\tpublic static CheckerFrameworkVersion valueOf(String versionString) {\n\t\tif (versionString != null) versionString = versionString.trim();\n\t\tif (versionString == null || versionString.equalsIgnoreCase(\"false\") || versionString.equals(\"0\")) return new CheckerFrameworkVersion(0);\n\t\tif (versionString.equalsIgnoreCase(\"true\")) return new CheckerFrameworkVersion(DEFAULT);\n\t\tMatcher m = VERSION.matcher(versionString);\n\t\tif (!m.matches()) throw new IllegalArgumentException(\"Expected 'true' or 'false' or a major/minor version, such as '2.9'\");\n\t\tint major = Integer.parseInt(m.group(1));"}
{"magic_number_smell": "\t\t// Still, eventually that's going to cause a bit of a memory leak, so lets just completely clear them out every many minutes.\n\t\tlong now = System.currentTimeMillis();\n\t\tlong delta = now - lastCacheClear;\n\t\tif (delta > TimeUnit.MINUTES.toMillis(30)) {\n\t\t\tlastCacheClear = now;\n\t\t\tfileCache.clear();\n\t\t\turiCache.clear();", "refactored_code": "\tprivate static final long FULL_CACHE_CLEAR_INTERVAL = TimeUnit.MINUTES.toMillis(30);\n\t\t// Still, eventually that's going to cause a bit of a memory leak, so lets just completely clear them out every many minutes.\n\t\tlong now = System.currentTimeMillis();\n\t\tlong delta = now - lastCacheClear;\n\t\tif (delta > FULL_CACHE_CLEAR_INTERVAL) {\n\t\t\tlastCacheClear = now;\n\t\t\tfileCache.clear();\n\t\t\turiCache.clear();"}
{"magic_number_smell": "\t\tlong now = System.currentTimeMillis();\n\t\tlong delta = end - startToken;\n\t\tif (delta < 0L) delta = 0L;\n\t\tint interval = (int) (now / 1000 * 60);\n\t\tint[] currentInterval = {0};\n\t\tlong[] bars = this.bars.get(currentInterval);\n\t\tlong[] newBars;", "refactored_code": "\tprivate static final long REPORT_WINDOW = 1000 * 60;\n\t\tlong now = System.currentTimeMillis();\n\t\tlong delta = end - startToken;\n\t\tif (delta < 0L) delta = 0L;\n\t\tint interval = (int) (now / REPORT_WINDOW);\n\t\tint[] currentInterval = {0};\n\t\tlong[] bars = this.bars.get(currentInterval);\n\t\tlong[] newBars;"}
{"magic_number_smell": "\t\t\t\tif (squelchTimeout > now) return;\n\t\t\t\tsquelchTimeout = now + SQUELCH_TIMEOUT;\n\t\t\t\tprintSquelchWarning = true;\n\t\t\t} else if (ct >= 200) {\n\t\t\t\tsquelchTimeout = System.currentTimeMillis() + SQUELCH_TIMEOUT;\n\t\t\t\tprintSquelchWarning = true;\n\t\t\t}", "refactored_code": "\t\tprivate static final int MAX_LOG = 200;\n\t\t\t\tif (squelchTimeout > now) return;\n\t\t\t\tsquelchTimeout = now + SQUELCH_TIMEOUT;\n\t\t\t\tprintSquelchWarning = true;\n\t\t\t} else if (ct >= MAX_LOG) {\n\t\t\t\tsquelchTimeout = System.currentTimeMillis() + SQUELCH_TIMEOUT;\n\t\t\t\tprintSquelchWarning = true;\n\t\t\t}"}
{"magic_number_smell": "\t\t\tfilled = true;\n\t\t}\n\t\t\n\t\tif ((td.modifiers & ClassFileConstants.AccInterface | ClassFileConstants.AccStatic | ClassFileConstants.AccEnum | Eclipse.AccRecord) != 0) return filled; // Once we hit a static class, no further typeparams needed.\n\t\tboolean f2 = fillOuterTypeParams(rr, idx - 1, node.up(), p);\n\t\treturn f2 || filled;\n\t}", "refactored_code": "\tprivate static final int MODIFIERS_INDICATING_STATIC = ClassFileConstants.AccInterface | ClassFileConstants.AccStatic | ClassFileConstants.AccEnum | Eclipse.AccRecord;\n\t\t\tfilled = true;\n\t\t}\n\t\t\n\t\tif ((td.modifiers & MODIFIERS_INDICATING_STATIC) != 0) return filled; // Once we hit a static class, no further typeparams needed.\n\t\tboolean f2 = fillOuterTypeParams(rr, idx - 1, node.up(), p);\n\t\treturn f2 || filled;\n\t}"}
{"magic_number_smell": "\t\tthis.source = source;\n\t\tthis.sourceStart = this.source.sourceStart;\n\t\tthis.sourceEnd = this.source.sourceEnd;\n\t\tthis.sourcePos = (long)sourceStart << 32 | (sourceEnd & 0x00000000FFFFFFFFL);\n\t}\n\t\n\tprivate void fixPositions(JavadocAllocationExpression node) {", "refactored_code": "\tprivate static final long INT_TO_LONG_MASK = 0x00000000FFFFFFFFL;\n\t\tthis.source = source;\n\t\tthis.sourceStart = this.source.sourceStart;\n\t\tthis.sourceEnd = this.source.sourceEnd;\n\t\tthis.sourcePos = (long)sourceStart << 32 | (sourceEnd & INT_TO_LONG_MASK);\n\t}\n\t\n\tprivate void fixPositions(JavadocAllocationExpression node) {"}
{"magic_number_smell": "\t\tif ((v & SEALED) != 0) print(\"sealed \");\n\t\tif ((v & NON_SEALED) != 0) print(\"non-sealed \");\n\t\tif ((v & STRICTFP) != 0) print(\"strictfp \");\n\t\tif ((v & 1L<<43) != 0 && (v & INTERFACE) == 0) print(\"default \");\n\t}\n\t\n\t@Override public void visitSelect(JCFieldAccess tree) {", "refactored_code": "\tprivate static final long DEFAULT = 1L<<43;\n\t\tif ((v & SEALED) != 0) print(\"sealed \");\n\t\tif ((v & NON_SEALED) != 0) print(\"non-sealed \");\n\t\tif ((v & STRICTFP) != 0) print(\"strictfp \");\n\t\tif ((v & DEFAULT) != 0 && (v & INTERFACE) == 0) print(\"default \");\n\t}\n\t\n\t@Override public void visitSelect(JCFieldAccess tree) {"}
{"magic_number_smell": "\t\t\n\t\tpublic static boolean checkBit24(Object node) throws Exception {\n\t\t\tint bits = (Integer)(node.getClass().getField(\"bits\").get(node));\n\t\t\treturn (bits & 0x800000) != 0;\n\t\t}\n\t\t\n\t\tpublic static boolean skipRewritingGeneratedNodes(org.eclipse.jdt.core.dom.ASTNode node) throws Exception {", "refactored_code": "\t\tpublic static final int ALREADY_PROCESSED_FLAG = 0x800000;  //Bit 24\n\t\t\n\t\tpublic static boolean checkBit24(Object node) throws Exception {\n\t\t\tint bits = (Integer)(node.getClass().getField(\"bits\").get(node));\n\t\t\treturn (bits & ALREADY_PROCESSED_FLAG) != 0;\n\t\t}\n\t\t\n\t\tpublic static boolean skipRewritingGeneratedNodes(org.eclipse.jdt.core.dom.ASTNode node) throws Exception {"}
{"magic_number_smell": "\t\tconstraints.gridy = 2;\n\t\tcontainer.add(buttonBar, constraints);\n\t\t\n\t\tcontainer.setPreferredSize(new Dimension(662, 415));\n\t\tcontainer.setMinimumSize(new Dimension(662, 415));\n\t\treturn container;\n\t}", "refactored_code": "\tprivate static final int INSTALLER_WINDOW_WIDTH = 662;\n\t\tconstraints.gridy = 2;\n\t\tcontainer.add(buttonBar, constraints);\n\t\t\n\t\tcontainer.setPreferredSize(new Dimension(INSTALLER_WINDOW_WIDTH, 415));\n\t\tcontainer.setMinimumSize(new Dimension(INSTALLER_WINDOW_WIDTH, 415));\n\t\treturn container;\n\t}"}
{"magic_number_smell": "\t\t\tposition++;\n\t\t\toffsets[i] = position;\n\t\t\tswitch (type) {\n\t\t\tcase 1:\n\t\t\t\tint length = readValue(position);\n\t\t\t\tposition += 2;\n\t\t\t\tutf8s[i] = decodeString(position, length);", "refactored_code": "\tprivate static final byte UTF8 = 1;\n\t\t\tposition++;\n\t\t\toffsets[i] = position;\n\t\t\tswitch (type) {\n\t\t\tcase UTF8:\n\t\t\t\tint length = readValue(position);\n\t\t\t\tposition += 2;\n\t\t\t\tutf8s[i] = decodeString(position, length);"}
{"magic_number_smell": "\t\tint[] startPoints = new int[260];\n\t\tint maxStartPoints;\n\t\t\n\t\tfor (int offset : md.getOffsets(1)) {\n\t\t\tint len = readValue(b, offset);\n\t\t\toffset += 2;\n\t\t\tstartPoints[0] = offset;", "refactored_code": "\tprivate static final byte CONSTANTPOOLTYPE_UTF8 = 1;\n\t\tint[] startPoints = new int[260];\n\t\tint maxStartPoints;\n\t\t\n\t\tfor (int offset : md.getOffsets(CONSTANTPOOLTYPE_UTF8)) {\n\t\t\tint len = readValue(b, offset);\n\t\t\toffset += 2;\n\t\t\tstartPoints[0] = offset;"}
{"magic_number_smell": "\t}\n\t\n\tprivate void go(boolean open) throws Exception {\n\t\tport(4569);\n\t\tget(\"/\", serve(\"index.html\"));\n\t\tget(\"/setup/overview\", serve(\"setup/index.html\"));\n\t\tget(\"/setup\", serve(\"setup/index.html\"));", "refactored_code": "\tprivate static final int DEFAULT_PORT = 4569;\n\t}\n\t\n\tprivate void go(boolean open) throws Exception {\n\t\tport(DEFAULT_PORT);\n\t\tget(\"/\", serve(\"index.html\"));\n\t\tget(\"/setup/overview\", serve(\"setup/index.html\"));\n\t\tget(\"/setup\", serve(\"setup/index.html\"));"}
{"magic_number_smell": "\t}\n\t@java.lang.SuppressWarnings(\"all\")\n\tpublic int getZero() {\n\t\treturn this.0;\n\t}\n\t@java.lang.Override\n\t@java.lang.SuppressWarnings(\"all\")", "refactored_code": "\tprivate final int zero = 0;\n\t}\n\t@java.lang.SuppressWarnings(\"all\")\n\tpublic int getZero() {\n\t\treturn this.zero;\n\t}\n\t@java.lang.Override\n\t@java.lang.SuppressWarnings(\"all\")"}
{"magic_number_smell": "\t}\n\t@java.lang.SuppressWarnings(\"all\")\n\tpublic int getZero() {\n\t\treturn this.0;\n\t}\n\t@java.lang.Override\n\t@java.lang.SuppressWarnings(\"all\")", "refactored_code": "\tprivate final int zero = 0;\n\t}\n\t@java.lang.SuppressWarnings(\"all\")\n\tpublic int getZero() {\n\t\treturn this.zero;\n\t}\n\t@java.lang.Override\n\t@java.lang.SuppressWarnings(\"all\")"}
{"magic_number_smell": "\tprivate static final int 20 = 20;\n\tpublic void testComplex() {\n\t\tfinal char[] shouldBeCharArray = field.toCharArray();\n\t\tfinal int shouldBeInt = 20;\n\t\tfinal java.lang.Object lock = new Object();\n\t\tsynchronized (lock) {\n\t\t\tfinal int field = 20; //Shadowing", "refactored_code": "\tprivate static final int CONSTANT = 20;\n\tprivate static final int CONSTANT = 20;\n\tpublic void testComplex() {\n\t\tfinal char[] shouldBeCharArray = field.toCharArray();\n\t\tfinal int shouldBeInt = CONSTANT;\n\t\tfinal java.lang.Object lock = new Object();\n\t\tsynchronized (lock) {\n\t\t\tfinal int field = 20; //Shadowing"}
{"magic_number_smell": "\tprivate static final int 20 = 20;\n\tpublic void testComplex() {\n\t\tchar[] shouldBeCharArray = field.toCharArray();\n\t\tint shouldBeInt = 20;\n\t\tjava.lang.Object lock = new Object();\n\t\tsynchronized (lock) {\n\t\t\tint field = 20; //Shadowing", "refactored_code": "\tprivate static final int CONSTANT = 20;\n\tprivate static final int CONSTANT = 20;\n\tpublic void testComplex() {\n\t\tchar[] shouldBeCharArray = field.toCharArray();\n\t\tint shouldBeInt = CONSTANT;\n\t\tjava.lang.Object lock = new Object();\n\t\tsynchronized (lock) {\n\t\t\tint field = 20; //Shadowing"}
{"magic_number_smell": "    return new BuilderAndValue.BuilderAndValueBuilder();\n  }\n  public @java.lang.SuppressWarnings(\"all\") int getZero() {\n    return this.0;\n  }\n  public @java.lang.Override @java.lang.SuppressWarnings(\"all\") boolean equals(final java.lang.Object o) {\n    if ((o == this))", "refactored_code": "  private final int zero = 0;\n    return new BuilderAndValue.BuilderAndValueBuilder();\n  }\n  public @java.lang.SuppressWarnings(\"all\") int getZero() {\n    return this.zero;\n  }\n  public @java.lang.Override @java.lang.SuppressWarnings(\"all\") boolean equals(final java.lang.Object o) {\n    if ((o == this))"}
{"magic_number_smell": "    return new BuilderAndValueWithSetterPrefix.BuilderAndValueWithSetterPrefixBuilder();\n  }\n  public @java.lang.SuppressWarnings(\"all\") int getZero() {\n    return this.0;\n  }\n  public @java.lang.Override @java.lang.SuppressWarnings(\"all\") boolean equals(final java.lang.Object o) {\n    if ((o == this))", "refactored_code": "  private final int zero = 0;\n    return new BuilderAndValueWithSetterPrefix.BuilderAndValueWithSetterPrefixBuilder();\n  }\n  public @java.lang.SuppressWarnings(\"all\") int getZero() {\n    return this.zero;\n  }\n  public @java.lang.Override @java.lang.SuppressWarnings(\"all\") boolean equals(final java.lang.Object o) {\n    if ((o == this))"}
{"magic_number_smell": "    }\n  }\n  int field1;\n  int 5;\n  int thirdField;\n  FieldNameConstantsHandrolled3() {\n    super();", "refactored_code": "    public static final int alsoAField = 5;\n    }\n  }\n  int field1;\n  int alsoAField;\n  int thirdField;\n  FieldNameConstantsHandrolled3() {\n    super();"}
{"magic_number_smell": "  }\n  public void testComplex() {\n    final @val char[] shouldBeCharArray = field.toCharArray();\n    final @val int shouldBeInt = 20;\n    final @val java.lang.Object lock = new Object();\n    synchronized (lock)\n      {", "refactored_code": "  private static final int CONSTANT = 20;\n  }\n  public void testComplex() {\n    final @val char[] shouldBeCharArray = field.toCharArray();\n    final @val int shouldBeInt = CONSTANT;\n    final @val java.lang.Object lock = new Object();\n    synchronized (lock)\n      {"}
{"magic_number_smell": "  }\n  public void testComplex() {\n    @var char[] shouldBeCharArray = field.toCharArray();\n    @var int shouldBeInt = 20;\n    @var java.lang.Object lock = new Object();\n    synchronized (lock)\n      {", "refactored_code": "  private static final int CONSTANT = 20;\n  }\n  public void testComplex() {\n    @var char[] shouldBeCharArray = field.toCharArray();\n    @var int shouldBeInt = CONSTANT;\n    @var java.lang.Object lock = new Object();\n    synchronized (lock)\n      {"}
{"magic_number_smell": "\n@lombok.Builder @lombok.Data\nclass BuilderAndData {\n\tprivate final int 0 = 0;\n}\n", "refactored_code": "\tprivate final int zero = 0;\n\n@lombok.Builder @lombok.Data\nclass BuilderAndData {\n\tprivate final int zero = 0;\n}\n"}
{"magic_number_smell": "\n@lombok.Builder(setterPrefix = \"with\") @lombok.Data\nclass BuilderAndDataWithSetterPrefix {\n\tprivate final int 0 = 0;\n}\n", "refactored_code": "\tprivate final int zero = 0;\n\n@lombok.Builder(setterPrefix = \"with\") @lombok.Data\nclass BuilderAndDataWithSetterPrefix {\n\tprivate final int zero = 0;\n}\n"}
{"magic_number_smell": "\t\n\tpublic void testComplex() {\n\t\tval shouldBeCharArray = field.toCharArray();\n\t\tval shouldBeInt = 20;\n\t\tval lock = new Object();\n\t\tsynchronized (lock) {\n\t\t\tval field = 20; //Shadowing", "refactored_code": "\tprivate static final int CONSTANT = 20;\n\t\n\tpublic void testComplex() {\n\t\tval shouldBeCharArray = field.toCharArray();\n\t\tval shouldBeInt = CONSTANT;\n\t\tval lock = new Object();\n\t\tsynchronized (lock) {\n\t\t\tval field = 20; //Shadowing"}
{"magic_number_smell": "\n\tpublic void testComplex() {\n\t\tvar shouldBeCharArray = field.toCharArray();\n\t\tvar shouldBeInt = 20;\n\t\tvar lock = new Object();\n\t\tsynchronized (lock) {\n\t\t\tvar field = 20; //Shadowing", "refactored_code": "\tprivate static final int CONSTANT = 20;\n\n\tpublic void testComplex() {\n\t\tvar shouldBeCharArray = field.toCharArray();\n\t\tvar shouldBeInt = CONSTANT;\n\t\tvar lock = new Object();\n\t\tsynchronized (lock) {\n\t\t\tvar field = 20; //Shadowing"}
{"magic_number_smell": "\n    /**\n     *  This is the generic version string you should use when printing out the version.  It is of\n     *  the form \"2.REVISION.MINORREVISION[-POSTFIX][-BUILD]\".\n     */\n    public static final String     VERSTR        = 2 + \".\" +\n                                                   REVISION + \".\" +", "refactored_code": "    public static final int        VERSION       = 2;\n\n    /**\n     *  This is the generic version string you should use when printing out the version.  It is of\n     *  the form \"VERSION.REVISION.MINORREVISION[-POSTFIX][-BUILD]\".\n     */\n    public static final String     VERSTR        = VERSION + \".\" +\n                                                   REVISION + \".\" +"}
{"magic_number_smell": "            cache = cacheManager.getCache( cacheName );\n        } else {\n            LOG.info( \"cache with name {} not found in ehcache configuration file, creating it with defaults.\", cacheName );\n            cache = new Cache( cacheName, 1_000, false, false, DEFAULT_CACHE_EXPIRY_PERIOD, DEFAULT_CACHE_EXPIRY_PERIOD );\n            cacheManager.addCache( cache );\n        }\n        cacheMap.put( cacheName, cache );", "refactored_code": "    private static final int DEFAULT_CACHE_SIZE = 1_000;\n            cache = cacheManager.getCache( cacheName );\n        } else {\n            LOG.info( \"cache with name {} not found in ehcache configuration file, creating it with defaults.\", cacheName );\n            cache = new Cache( cacheName, DEFAULT_CACHE_SIZE, false, false, DEFAULT_CACHE_EXPIRY_PERIOD, DEFAULT_CACHE_EXPIRY_PERIOD );\n            cacheManager.addCache( cache );\n        }\n        cacheMap.put( cacheName, cache );"}
{"magic_number_smell": "        private static final int 30 = 30;\n\n        public WatchDogThread( final Engine engine ) {\n            super( engine, 30 );\n            setName( \"WatchDog for '\" + engine.getApplicationName() + \"'\" );\n        }\n", "refactored_code": "        private static final int CHECK_INTERVAL = 30;\n        private static final int CHECK_INTERVAL = 30;\n\n        public WatchDogThread( final Engine engine ) {\n            super( engine, CHECK_INTERVAL );\n            setName( \"WatchDog for '\" + engine.getApplicationName() + \"'\" );\n        }\n"}
{"magic_number_smell": "                // LOG.debug( \"Running background task: \" + name + \".\" );\n                backgroundTask();\n                \n                // Sleep for the interval we're supposed to, but wake up every 1_000L to see if thread should die\n                boolean interrupted = false;\n                try {\n                    for( int i = 0; i < m_interval; i++ ) {", "refactored_code": "    private static final long POLLING_INTERVAL = 1_000L;\n                // LOG.debug( \"Running background task: \" + name + \".\" );\n                backgroundTask();\n                \n                // Sleep for the interval we're supposed to, but wake up every POLLING_INTERVAL to see if thread should die\n                boolean interrupted = false;\n                try {\n                    for( int i = 0; i < m_interval; i++ ) {"}
{"magic_number_smell": "     */\n    private void delayLogin( final String username ) {\n        try {\n            m_lastLoginAttempts.cleanup( 10 * 60 * 1_000L );\n            final int count = m_lastLoginAttempts.count( username );\n\n            final long delay = Math.min( 1L << count, MAX_LOGIN_DELAY );", "refactored_code": "    private static final long LASTLOGINS_CLEANUP_TIME = 10 * 60 * 1_000L; // Ten minutes\n     */\n    private void delayLogin( final String username ) {\n        try {\n            m_lastLoginAttempts.cleanup( LASTLOGINS_CLEANUP_TIME );\n            final int count = m_lastLoginAttempts.count( username );\n\n            final long delay = Math.min( 1L << count, MAX_LOGIN_DELAY );"}
{"magic_number_smell": "        //  Scrub away old files\n        final long now = System.currentTimeMillis();\n        if( now > ( c_lastScrubTime + SCRUB_PERIOD ) ) {\n            scrub( TextUtil.getIntegerProperty( engine.getWikiProperties(), PROP_LOGIN_EXPIRY_DAYS, 14 ), cookieDir );\n            c_lastScrubTime = now;\n        }\n", "refactored_code": "    private static final int DEFAULT_EXPIRY_DAYS = 14;\n        //  Scrub away old files\n        final long now = System.currentTimeMillis();\n        if( now > ( c_lastScrubTime + SCRUB_PERIOD ) ) {\n            scrub( TextUtil.getIntegerProperty( engine.getWikiProperties(), PROP_LOGIN_EXPIRY_DAYS, DEFAULT_EXPIRY_DAYS ), cookieDir );\n            c_lastScrubTime = now;\n        }\n"}
{"magic_number_smell": "        if( !m_stopAtFirstMatch ) {\n            final Integer score = context.getVariable( ATTR_SPAMFILTER_SCORE );\n\n            if( score != null && score >= 1 ) {\n                throw new RedirectException( \"Herb says you got too many points\", getRedirectPage( context ) );\n            }\n        }", "refactored_code": "    private final int             m_scoreLimit = 1;\n        if( !m_stopAtFirstMatch ) {\n            final Integer score = context.getVariable( ATTR_SPAMFILTER_SCORE );\n\n            if( score != null && score >= m_scoreLimit ) {\n                throw new RedirectException( \"Herb says you got too many points\", getRedirectPage( context ) );\n            }\n        }"}
{"magic_number_smell": "    public static final int HEADING_LARGE  = 3;\n\n    /**\n     *  Denotes the level of the heading. Either 1, HEADING_MEDIUM, or HEADING_LARGE.\n     */\n    public int    m_level;\n    ", "refactored_code": "    public static final int HEADING_SMALL  = 1;\n    public static final int HEADING_LARGE  = 3;\n\n    /**\n     *  Denotes the level of the heading. Either HEADING_SMALL, HEADING_MEDIUM, or HEADING_LARGE.\n     */\n    public int    m_level;\n    "}
{"magic_number_smell": "        final ResourceBundle rb = Preferences.getBundle( m_context, InternationalizationManager.CORE_BUNDLE );\n\n        switch( type ) {\n            case 0:\n                el = createAnchor( 0, m_context.getURL( ContextEnum.PAGE_VIEW.getRequestContext(), link), text, section );\n                break;\n", "refactored_code": "    protected static final int              READ          = 0;\n        final ResourceBundle rb = Preferences.getBundle( m_context, InternationalizationManager.CORE_BUNDLE );\n\n        switch( type ) {\n            case READ:\n                el = createAnchor( READ, m_context.getURL( ContextEnum.PAGE_VIEW.getRequestContext(), link), text, section );\n                break;\n"}
{"magic_number_smell": "    public Reader setInputReader( final Reader in ) {\n        final Reader old = m_in;\n        if( in != null ) {\n            m_in = new PushbackReader( new BufferedReader( in ), 10*1024 );\n        }\n\n        return old;", "refactored_code": "    protected static final int PUSHBACK_BUFFER_SIZE = 10*1024;\n    public Reader setInputReader( final Reader in ) {\n        final Reader old = m_in;\n        if( in != null ) {\n            m_in = new PushbackReader( new BufferedReader( in ), PUSHBACK_BUFFER_SIZE );\n        }\n\n        return old;"}
{"magic_number_smell": "        int count = 0;\n\n        //  The output will be B Item[1] A S B Item[2] A S B Item[3] A\n        while( it.hasNext() && ( (count < numItems) || ( numItems == -1 ) ) ) {\n            final String value = it.next();\n            if( count > 0 ) {\n                output.append( m_after );", "refactored_code": "    public static final int    ALL_ITEMS              = -1;\n        int count = 0;\n\n        //  The output will be B Item[1] A S B Item[2] A S B Item[3] A\n        while( it.hasNext() && ( (count < numItems) || ( numItems == ALL_ITEMS ) ) ) {\n            final String value = it.next();\n            if( count > 0 ) {\n                output.append( m_after );"}
{"magic_number_smell": "        } else {\n            //  Determine how much to increment\n            final String incrementObj = params.get( PARAM_INCREMENT );\n            int increment = 1;\n            if( incrementObj != null ) {\n                increment = Integer.parseInt( incrementObj );\n            }", "refactored_code": "    private static final int     DEFAULT_INCREMENT   = 1;\n        } else {\n            //  Determine how much to increment\n            final String incrementObj = params.get( PARAM_INCREMENT );\n            int increment = DEFAULT_INCREMENT;\n            if( incrementObj != null ) {\n                increment = Integer.parseInt( incrementObj );\n            }"}
{"magic_number_smell": "\n            // backup counters every 5 minutes\n            if( m_pageCountSaveThread == null ) {\n                m_pageCountSaveThread = new CounterSaveThread( engine, 5 * 60, this );\n                m_pageCountSaveThread.start();\n            }\n", "refactored_code": "    private static final int STORAGE_INTERVAL = 60;\n\n            // backup counters every 5 minutes\n            if( m_pageCountSaveThread == null ) {\n                m_pageCountSaveThread = new CounterSaveThread( engine, 5 * STORAGE_INTERVAL, this );\n                m_pageCountSaveThread.start();\n            }\n"}
{"magic_number_smell": "     */\n    @Override\n    public String execute( final Context context, final Map< String, String > params ) throws PluginException {\n        final int since = TextUtil.parseIntParameter( params.get( \"since\" ), 100*365 );\n        String spacing  = \"4\";\n        boolean showAuthor = true;\n        boolean showChangenote = true;", "refactored_code": "    private static final int   DEFAULT_DAYS = 100*365;\n     */\n    @Override\n    public String execute( final Context context, final Map< String, String > params ) throws PluginException {\n        final int since = TextUtil.parseIntParameter( params.get( \"since\" ), DEFAULT_DAYS );\n        String spacing  = \"4\";\n        boolean showAuthor = true;\n        boolean showChangenote = true;"}
{"magic_number_smell": "            m_formatSort = true  ;\n        }\n\n        m_depth = TextUtil.parseIntParameter( params.get( PARAM_DEPTH ), 1 );\n        if( m_depth > MAX_DEPTH ) {\n            m_depth = MAX_DEPTH;\n        }", "refactored_code": "    public static final int MIN_DEPTH = 1;\n            m_formatSort = true  ;\n        }\n\n        m_depth = TextUtil.parseIntParameter( params.get( PARAM_DEPTH ), MIN_DEPTH );\n        if( m_depth > MAX_DEPTH ) {\n            m_depth = MAX_DEPTH;\n        }"}
{"magic_number_smell": "\n        //  Find the first page that has no page lock.\n        int idx = max + 1;\n        while( idx < 10_000 ) {\n            final Page page = Wiki.contents().page( engine, WeblogPlugin.makeEntryPage( baseName, date, Integer.toString( idx ) ) );\n            final PageLock lock = engine.getManager( PageManager.class ).getCurrentLock(page);\n            if (lock == null) {", "refactored_code": "    private static final int MAX_BLOG_ENTRIES = 10_000; // Just a precaution.\n\n        //  Find the first page that has no page lock.\n        int idx = max + 1;\n        while( idx < MAX_BLOG_ENTRIES ) {\n            final Page page = Wiki.contents().page( engine, WeblogPlugin.makeEntryPage( baseName, date, Integer.toString( idx ) ) );\n            final PageLock lock = engine.getManager( PageManager.class ).getCurrentLock(page);\n            if (lock == null) {"}
{"magic_number_smell": "    public String execute( final Context context, final Map< String, String > params ) throws PluginException {\n        final Calendar   startTime;\n        final Calendar   stopTime;\n        int        numDays = 7;\n        final Engine engine = context.getEngine();\n        final AuthorizationManager mgr = engine.getManager( AuthorizationManager.class );\n", "refactored_code": "    private static final int     DEFAULT_DAYS = 7;\n    public String execute( final Context context, final Map< String, String > params ) throws PluginException {\n        final Calendar   startTime;\n        final Calendar   stopTime;\n        int        numDays = DEFAULT_DAYS;\n        final Engine engine = context.getEngine();\n        final AuthorizationManager mgr = engine.getManager( AuthorizationManager.class );\n"}
{"magic_number_smell": "    public static final int DEFAULT_MAX_PROPVALUELENGTH = 4096;\n\n    /** This parameter limits the number of custom page properties allowed on a page */\n    public static int MAX_PROPLIMIT = 200;\n\n    /**\n     * This number limits the length of a custom page property key length. The default value here designed with future JDBC providers in mind.", "refactored_code": "    public static final int DEFAULT_MAX_PROPLIMIT = 200;\n    public static final int DEFAULT_MAX_PROPVALUELENGTH = 4096;\n\n    /** This parameter limits the number of custom page properties allowed on a page */\n    public static int MAX_PROPLIMIT = DEFAULT_MAX_PROPLIMIT;\n\n    /**\n     * This number limits the length of a custom page property key length. The default value here designed with future JDBC providers in mind."}
{"magic_number_smell": "\n            final long ver = in.readLong();\n\n            if( ver != 4L ) {\n                throw new IOException(\"File format has changed; I need to recalculate references.\");\n            }\n", "refactored_code": "    private static final long serialVersionUID = 4L;\n\n            final long ver = in.readLong();\n\n            if( ver != serialVersionUID ) {\n                throw new IOException(\"File format has changed; I need to recalculate references.\");\n            }\n"}
{"magic_number_smell": "            //  Description\n            if( firstLine > 0 ) {\n                int maxlen = pageText.length();\n                if( maxlen > Integer.MAX_VALUE-1 ) {\n                    maxlen = Integer.MAX_VALUE-1;\n                }\n                pageText = m_engine.getManager( RenderingManager.class ).textToHTML( wikiContext, pageText.substring( firstLine + 1, maxlen ).trim() );", "refactored_code": "    private static final int MAX_CHARACTERS = Integer.MAX_VALUE-1;\n            //  Description\n            if( firstLine > 0 ) {\n                int maxlen = pageText.length();\n                if( maxlen > MAX_CHARACTERS ) {\n                    maxlen = MAX_CHARACTERS;\n                }\n                pageText = m_engine.getManager( RenderingManager.class ).textToHTML( wikiContext, pageText.substring( firstLine + 1, maxlen ).trim() );"}
{"magic_number_smell": "        public static final String AJAX_ACTION_SUGGESTIONS = \"suggestions\";\n        public static final String AJAX_ACTION_PAGES = \"pages\";\n        public static final int 20 = 20;\n        public int maxResults = 20;\n\n        /** {@inheritDoc} */\n        @Override", "refactored_code": "        public static final int DEFAULT_MAX_RESULTS = 20;\n        public static final String AJAX_ACTION_SUGGESTIONS = \"suggestions\";\n        public static final String AJAX_ACTION_PAGES = \"pages\";\n        public static final int DEFAULT_MAX_RESULTS = 20;\n        public int maxResults = DEFAULT_MAX_RESULTS;\n\n        /** {@inheritDoc} */\n        @Override"}
{"magic_number_smell": "                        String[] fragments = new String[ 0 ];\n                        if( text != null && highlighter != null ) {\n                            final TokenStream tokenStream = getLuceneAnalyzer().tokenStream( LUCENE_PAGE_CONTENTS, new StringReader( text ) );\n                            fragments = highlighter.getBestFragments( tokenStream, text, 3 );\n                        }\n\n                        final SearchResult result = new SearchResultImpl( page, score, fragments );", "refactored_code": "    private static final int MAX_FRAGMENTS = 3;\n                        String[] fragments = new String[ 0 ];\n                        if( text != null && highlighter != null ) {\n                            final TokenStream tokenStream = getLuceneAnalyzer().tokenStream( LUCENE_PAGE_CONTENTS, new StringReader( text ) );\n                            fragments = highlighter.getBestFragments( tokenStream, text, MAX_FRAGMENTS );\n                        }\n\n                        final SearchResult result = new SearchResultImpl( page, score, fragments );"}
{"magic_number_smell": "     */\n    public static class FixedQueue extends LinkedList< String > implements Serializable {\n        private final int m_size;\n        private static final long 0L = 0L;\n\n        FixedQueue( final int size ) {\n            m_size = size;", "refactored_code": "    private static final long serialVersionUID = 0L;\n     */\n    public static class FixedQueue extends LinkedList< String > implements Serializable {\n        private final int m_size;\n        private static final long serialVersionUID = 0L;\n\n        FixedQueue( final int size ) {\n            m_size = size;"}
{"magic_number_smell": "    }\n\n    /**\n     * Validates a string against the {@link #0} validator and additionally checks that the value is not <code>null</code> or blank.\n     *\n     * @param input the string to validate\n     * @param label the label for the string or field (\"E-mail address\")", "refactored_code": "    public static final int STANDARD = 0;\n    }\n\n    /**\n     * Validates a string against the {@link #STANDARD} validator and additionally checks that the value is not <code>null</code> or blank.\n     *\n     * @param input the string to validate\n     * @param label the label for the string or field (\"E-mail address\")"}
{"magic_number_smell": "\n        public JSPWikiServletResponseWrapper( final HttpServletResponse r, final String wikiEncoding, final boolean useEncoding ) throws UnsupportedEncodingException {\n            super( r );\n            m_output = new ByteArrayOutputStream( 0x8000 );\n            m_servletOut = new ByteArrayServletOutputStream( m_output );\n            m_writer = new PrintWriter( new OutputStreamWriter( m_servletOut, wikiEncoding ), true );\n            this.useEncoding = useEncoding;", "refactored_code": "        private static final int INIT_BUFFER_SIZE = 0x8000;\n\n        public JSPWikiServletResponseWrapper( final HttpServletResponse r, final String wikiEncoding, final boolean useEncoding ) throws UnsupportedEncodingException {\n            super( r );\n            m_output = new ByteArrayOutputStream( INIT_BUFFER_SIZE );\n            m_servletOut = new ByteArrayServletOutputStream( m_output );\n            m_writer = new PrintWriter( new OutputStreamWriter( m_servletOut, wikiEncoding ), true );\n            this.useEncoding = useEncoding;"}
{"magic_number_smell": "    /** Status: The PI is finished. */\n    public static final int FINISHED = 3;\n\n    protected int m_state = 0;\n\n    /**\n     *  Get the state of the ProgressItem.", "refactored_code": "    public static final int CREATED  = 0;\n    /** Status: The PI is finished. */\n    public static final int FINISHED = 3;\n\n    protected int m_state = CREATED;\n\n    /**\n     *  Get the state of the ProgressItem."}
{"magic_number_smell": "        sw.start();\n        try( final ObjectInputStream in = new ObjectInputStream( new BufferedInputStream( Files.newInputStream( f.toPath() ) ) ) ) {\n            final long ver = in.readLong();\n            if( ver != 6L ) {\n                LOG.warn( \"File format has changed; Unable to recover workflows and decision queue from disk.\" );\n            } else {\n                saved        = in.readLong();", "refactored_code": "    private static final long serialVersionUID = 6L;\n        sw.start();\n        try( final ObjectInputStream in = new ObjectInputStream( new BufferedInputStream( Files.newInputStream( f.toPath() ) ) ) ) {\n            final long ver = in.readLong();\n            if( ver != serialVersionUID ) {\n                LOG.warn( \"File format has changed; Unable to recover workflows and decision queue from disk.\" );\n            } else {\n                saved        = in.readLong();"}
{"magic_number_smell": "        // Create HTTP listener\n        final NetworkTrafficServerConnector connector = new NetworkTrafficServerConnector( server );\n        connector.setHost( \"localhost\" );\n        connector.setPort( 10024 );\n        connector.setIdleTimeout( 60_000 );\n\n        server.setConnectors( new Connector[] {connector} );", "refactored_code": "    public static final int HTTP_PORT = 10024;\n        // Create HTTP listener\n        final NetworkTrafficServerConnector connector = new NetworkTrafficServerConnector( server );\n        connector.setHost( \"localhost\" );\n        connector.setPort( HTTP_PORT );\n        connector.setIdleTimeout( 60_000 );\n\n        server.setConnectors( new Connector[] {connector} );"}
{"magic_number_smell": "    /** Sample Task that encounters an error during processing. */\n    public static class ErrorTask extends Task {\n\n        private static final long 1L = 1L;\n\n        public ErrorTask( final Workflow workflow ) {\n            super( workflow.getId(), workflow.getAttributes(), \"task.error\" );", "refactored_code": "        private static final long serialVersionUID = 1L;\n    /** Sample Task that encounters an error during processing. */\n    public static class ErrorTask extends Task {\n\n        private static final long serialVersionUID = 1L;\n\n        public ErrorTask( final Workflow workflow ) {\n            super( workflow.getId(), workflow.getAttributes(), \"task.error\" );"}
{"magic_number_smell": "     * Creates an RFC 2307-compliant salted, hashed password with the SHA1 or SHA-256\n     * MessageDigest algorithm. After the password is digested, the first 20 or 32\n     * bytes of the digest will be the actual password hash; the remaining bytes\n     * will be a randomly generated salt of length {@link #8},\n     * for example: <blockquote><code>{SSHA}3cGWem65NCEkF5Ew5AEk45ak8LHUWAwPVXAyyw==</code></blockquote>\n     * </p>\n     * <p>", "refactored_code": "    private static final int DEFAULT_SALT_SIZE = 8;\n     * Creates an RFC 2307-compliant salted, hashed password with the SHA1 or SHA-256\n     * MessageDigest algorithm. After the password is digested, the first 20 or 32\n     * bytes of the digest will be the actual password hash; the remaining bytes\n     * will be a randomly generated salt of length {@link #DEFAULT_SALT_SIZE},\n     * for example: <blockquote><code>{SSHA}3cGWem65NCEkF5Ew5AEk45ak8LHUWAwPVXAyyw==</code></blockquote>\n     * </p>\n     * <p>"}
{"magic_number_smell": "     *  @throws IOException If reading or writing failed.\n     */\n    public static void copyContents( final Reader in, final Writer out ) throws IOException {\n        final char[] buf = new char[8192];\n        int bytesRead;\n        while( ( bytesRead = in.read( buf ) ) > 0 ) {\n            out.write( buf, 0, bytesRead );", "refactored_code": "    private static final int      BUFFER_SIZE = 8192;\n     *  @throws IOException If reading or writing failed.\n     */\n    public static void copyContents( final Reader in, final Writer out ) throws IOException {\n        final char[] buf = new char[BUFFER_SIZE];\n        int bytesRead;\n        while( ( bytesRead = in.read( buf ) ) > 0 ) {\n            out.write( buf, 0, bytesRead );"}
{"magic_number_smell": "                return false;\n            }\n            final int ch = name.charAt( i );\n            final boolean isDigit = ch >= 48 && ch <= NINE;\n            final boolean isDot = ch == DOT;\n            if( !isDigit && !isDot ) {\n                return false;", "refactored_code": "    private static final int    ONE                   = 48;\n                return false;\n            }\n            final int ch = name.charAt( i );\n            final boolean isDigit = ch >= ONE && ch <= NINE;\n            final boolean isDot = ch == DOT;\n            if( !isDigit && !isDot ) {\n                return false;"}
{"magic_number_smell": "    @Override\n    public boolean add(final E o )\n    {\n        add( o, 0 );\n\n        return true;\n    }", "refactored_code": "    public static final int DEFAULT_PRIORITY = 0;\n    @Override\n    public boolean add(final E o )\n    {\n        add( o, DEFAULT_PRIORITY );\n\n        return true;\n    }"}
{"magic_number_smell": "     * @since 2.4\n     */\n    public static String generateRandomPassword() {\n        return IntStream.range(0, 8).map(i -> (int) (RANDOM.nextDouble() * PWD_BASE.length())).mapToObj(index -> String.valueOf(PWD_BASE.charAt(index))).collect(Collectors.joining());\n    }\n\n}", "refactored_code": "    public static final int PASSWORD_LENGTH = 8;\n     * @since 2.4\n     */\n    public static String generateRandomPassword() {\n        return IntStream.range(0, PASSWORD_LENGTH).map(i -> (int) (RANDOM.nextDouble() * PWD_BASE.length())).mapToObj(index -> String.valueOf(PWD_BASE.charAt(index))).collect(Collectors.joining());\n    }\n\n}"}
{"magic_number_smell": "\t\t @Path(value=\"/url\", priority=Path.HIGH)\n\t\t @Path(value=\"/url\", priority=Path.DEFAULT)\n\t\t @Path(value=\"/url\", priority=Path.LOW)\n\t\t @Path(value=\"/url\", priority=Path.Integer.MAX_VALUE)\n\t </pre>\n\t *\n\t */", "refactored_code": "\tpublic static final int LOWEST = Integer.MAX_VALUE;\n\t\t @Path(value=\"/url\", priority=Path.HIGH)\n\t\t @Path(value=\"/url\", priority=Path.DEFAULT)\n\t\t @Path(value=\"/url\", priority=Path.LOW)\n\t\t @Path(value=\"/url\", priority=Path.LOWEST)\n\t </pre>\n\t *\n\t */"}
{"magic_number_smell": "\n\tprivate MimeType convertToMimeType(String string) {\n\t\tif (string.contains(\"*/*\")) {\n\t\t\treturn new MimeType(\"text/html\", 0.01);\n\t\t} else if (string.contains(\";\")) {\n\t\t\tString type = string.substring(0, string.indexOf(';'));\n\t\t\treturn new MimeType(type, extractQualifier(string));", "refactored_code": "\tprivate static final double DEFAULT_QUALIFIER_VALUE = 0.01;\n\n\tprivate MimeType convertToMimeType(String string) {\n\t\tif (string.contains(\"*/*\")) {\n\t\t\treturn new MimeType(\"text/html\", DEFAULT_QUALIFIER_VALUE);\n\t\t} else if (string.contains(\";\")) {\n\t\t\tString type = string.substring(0, string.indexOf(';'));\n\t\t\treturn new MimeType(type, extractQualifier(string));"}
{"magic_number_smell": "\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\t// Checks if the leader keepalive cookie was updated not long ago\n\t\t\t\tif ((Long.parseLong(Cookies.getCookie(LEADER_KEEPALIVE)) + 1000 * 3) < getTime()) {\n\t\t\t\t\t// If it isn't updated for a while, then getting the leadership\n\t\t\t\t\tFreenetJs.log(\"Getting leadership lastKeepalive:\" + Cookies.getCookie(LEADER_KEEPALIVE));\n\t\t\t\t\t// Cancells the follower timers", "refactored_code": "\tprivate static final int\t\t\t\tsharedConnectionKeepaliveIntervalInMs\t= 1000;\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\t// Checks if the leader keepalive cookie was updated not long ago\n\t\t\t\tif ((Long.parseLong(Cookies.getCookie(LEADER_KEEPALIVE)) + sharedConnectionKeepaliveIntervalInMs * 3) < getTime()) {\n\t\t\t\t\t// If it isn't updated for a while, then getting the leadership\n\t\t\t\t\tFreenetJs.log(\"Getting leadership lastKeepalive:\" + Cookies.getCookie(LEADER_KEEPALIVE));\n\t\t\t\t\t// Cancells the follower timers"}
{"magic_number_smell": "\t */\n\tprivate final class ArchivePutHandler extends PutHandler {\n\n        private static final long 1L = 1L;\n\n        private ArchivePutHandler(BaseManifestPutter bmp, PutHandler parent, String name, HashMap<String, Object> data, FreenetURI insertURI) {\n\t\t\tsuper(bmp, parent, name, null, containerPutHandlers);", "refactored_code": "    private static final long serialVersionUID = 1L;\n\t */\n\tprivate final class ArchivePutHandler extends PutHandler {\n\n        private static final long serialVersionUID = 1L;\n\n        private ArchivePutHandler(BaseManifestPutter bmp, PutHandler parent, String name, HashMap<String, Object> data, FreenetURI insertURI) {\n\t\t\tsuper(bmp, parent, name, null, containerPutHandlers);"}
{"magic_number_smell": "\tpublic static final long 0x6d58249f72d67ed9L = 0x6d58249f72d67ed9L;\n\tpublic static final short BINARY_BLOB_OVERALL_VERSION = 0;\n\tpublic static void writeBinaryBlobHeader(DataOutputStream binaryBlobStream) throws IOException {\n\t\tbinaryBlobStream.writeLong(BinaryBlob.0x6d58249f72d67ed9L);\n\t\tbinaryBlobStream.writeShort(BinaryBlob.BINARY_BLOB_OVERALL_VERSION);\n\t}\n\tpublic static void writeKey(DataOutputStream binaryBlobStream, KeyBlock block, Key key) throws IOException {", "refactored_code": "\tpublic static final long BINARY_BLOB_MAGIC = 0x6d58249f72d67ed9L;\n\tpublic static final long BINARY_BLOB_MAGIC = 0x6d58249f72d67ed9L;\n\tpublic static final short BINARY_BLOB_OVERALL_VERSION = 0;\n\tpublic static void writeBinaryBlobHeader(DataOutputStream binaryBlobStream) throws IOException {\n\t\tbinaryBlobStream.writeLong(BinaryBlob.BINARY_BLOB_MAGIC);\n\t\tbinaryBlobStream.writeShort(BinaryBlob.BINARY_BLOB_OVERALL_VERSION);\n\t}\n\tpublic static void writeKey(DataOutputStream binaryBlobStream, KeyBlock block, Key key) throws IOException {"}
{"magic_number_smell": "            ClientContext context, RequestStarterGroup requestStarters, Random random, boolean noSerialize) throws NodeInitException, IOException {\n        ObjectInputStream ois = new ObjectInputStream(fis);\n        long magic = ois.readLong();\n        if(magic != 0xd332925f3caf4aedL) throw new IOException(\"Bad magic\");\n        int version = ois.readInt();\n        if(version != VERSION) throw new IOException(\"Bad version\");\n        byte[] salt = new byte[32];", "refactored_code": "    private static final long MAGIC = 0xd332925f3caf4aedL;\n            ClientContext context, RequestStarterGroup requestStarters, Random random, boolean noSerialize) throws NodeInitException, IOException {\n        ObjectInputStream ois = new ObjectInputStream(fis);\n        long magic = ois.readLong();\n        if(magic != MAGIC) throw new IOException(\"Bad magic\");\n        int version = ois.readInt();\n        if(version != VERSION) throw new IOException(\"Bad version\");\n        byte[] salt = new byte[32];"}
{"magic_number_smell": "\t * IMHO; we DO want to avoid rerequesting keys we've tried many times before.\n\t */\n\tprotected static int fixRetryCount(int retryCount) {\n\t\treturn Math.max(0, retryCount-3);\n\t}\n\n\tprivate boolean contains(KeyListener[] listeners, KeyListener listener) {", "refactored_code": "\tprivate static final int MIN_RETRY_COUNT = 3;\n\t * IMHO; we DO want to avoid rerequesting keys we've tried many times before.\n\t */\n\tprotected static int fixRetryCount(int retryCount) {\n\t\treturn Math.max(0, retryCount-MIN_RETRY_COUNT);\n\t}\n\n\tprivate boolean contains(KeyListener[] listeners, KeyListener listener) {"}
{"magic_number_smell": "\t\t\t\t} else {\n\t\t\t\t\tfinal boolean persistent = this.persistent;\n\t\t\t\t\tfetchArchive(false, archiveMetadata, ArchiveManager.METADATA_NAME, new ArchiveExtractCallback() {\n                        private static final long 1L = 1L;\n                        @Override\n\t\t\t\t\t\tpublic void gotBucket(Bucket data, ClientContext context) {\n\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"gotBucket on \"+SingleFileFetcher.this+\" persistent=\"+persistent);", "refactored_code": "    private static final long serialVersionUID = 1L;\n\t\t\t\t} else {\n\t\t\t\t\tfinal boolean persistent = this.persistent;\n\t\t\t\t\tfetchArchive(false, archiveMetadata, ArchiveManager.METADATA_NAME, new ArchiveExtractCallback() {\n                        private static final long serialVersionUID = 1L;\n                        @Override\n\t\t\t\t\t\tpublic void gotBucket(Bucket data, ClientContext context) {\n\t\t\t\t\t\t\tif(logMINOR) Logger.minor(this, \"gotBucket on \"+SingleFileFetcher.this+\" persistent=\"+persistent);"}
{"magic_number_smell": "\t */\n\tpublic class SplitHandler implements PutCompletionCallback, ClientPutState, Serializable {\n\n        private static final long 1L = 1L;\n        ClientPutState sfi;\n\t\tClientPutState metadataPutter;\n\t\tboolean finished;", "refactored_code": "    private static final long serialVersionUID = 1L;\n\t */\n\tpublic class SplitHandler implements PutCompletionCallback, ClientPutState, Serializable {\n\n        private static final long serialVersionUID = 1L;\n        ClientPutState sfi;\n\t\tClientPutState metadataPutter;\n\t\tboolean finished;"}
{"magic_number_smell": "\t\tthis.origUSK = origUSK;\n\t\tthis.uskManager = manager;\n\t\tthis.origMinFailures = minFailures;\n\t\tif(origMinFailures > 50)\n\t\t\tthrow new IllegalArgumentException();\n\t\tfirstLoop = true;\n\t\tcallbacks = new ArrayList<USKFetcherCallback>();", "refactored_code": "\tprivate static final int WATCH_KEYS = 50;\n\t\tthis.origUSK = origUSK;\n\t\tthis.uskManager = manager;\n\t\tthis.origMinFailures = minFailures;\n\t\tif(origMinFailures > WATCH_KEYS)\n\t\t\tthrow new IllegalArgumentException();\n\t\tfirstLoop = true;\n\t\tcallbacks = new ArrayList<USKFetcherCallback>();"}
{"magic_number_smell": "\t\t\tint lastByte;\n\t\t\twhile (!terminated && (lastByte = input.read()) != -1) {\n\t\t\t\tswitch(lastByte) {\n\t\t\t\t\tcase 0x2C:\n\t\t\t\t\t\timageSeen |= filterImage();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GIF_TERMINATOR:", "refactored_code": "\t\tprivate static final int IMAGE_SEPARATOR = 0x2C;\n\t\t\tint lastByte;\n\t\t\twhile (!terminated && (lastByte = input.read()) != -1) {\n\t\t\t\tswitch(lastByte) {\n\t\t\t\t\tcase IMAGE_SEPARATOR:\n\t\t\t\t\t\timageSeen |= filterImage();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GIF_TERMINATOR:"}
{"magic_number_smell": "\t\t\t\tLogger.minor(this, \"Marker type: \"+Integer.toHexString(markerType));\n\t\t\tlong countAtStart = cis.count(); // After marker but before type\n\t\t\tint blockLength;\n\t\t\tif(markerType == 0xD9 || markerType >= MARKER_RST0 && markerType <= MARKER_RST7)\n\t\t\t\tblockLength = 0;\n\t\t\telse {\n\t\t\t\tblockLength = dis.readUnsignedShort();", "refactored_code": "\tprivate static final int MARKER_EOI = 0xD9; // End of image\n\t\t\t\tLogger.minor(this, \"Marker type: \"+Integer.toHexString(markerType));\n\t\t\tlong countAtStart = cis.count(); // After marker but before type\n\t\t\tint blockLength;\n\t\t\tif(markerType == MARKER_EOI || markerType >= MARKER_RST0 && markerType <= MARKER_RST7)\n\t\t\t\tblockLength = 0;\n\t\t\telse {\n\t\t\t\tblockLength = dis.readUnsignedShort();"}
{"magic_number_smell": "\t    FetchContext defaultFetchContext = core.getClientContext().getDefaultPersistentFetchContext();\n\t\tfinal ClientGet cg =\n\t\t\tnew ClientGet(persistRebootOnly ? globalRebootClient : globalForeverClient, fetchURI, defaultFetchContext.localRequestOnly,\n\t\t\t\t\tdefaultFetchContext.ignoreStore, filterData, -1,\n\t\t\t\t\t-1, QUEUE_MAX_DATA_SIZE, returnType, persistRebootOnly, id,\n\t\t\t\t\tInteger.MAX_VALUE, RequestStarter.BULK_SPLITFILE_PRIORITY_CLASS, returnFilename, null, false, realTimeFlag, false, core);\n\t\tcg.register(false);", "refactored_code": "\tpublic static final int QUEUE_MAX_RETRIES = -1;\n\t    FetchContext defaultFetchContext = core.getClientContext().getDefaultPersistentFetchContext();\n\t\tfinal ClientGet cg =\n\t\t\tnew ClientGet(persistRebootOnly ? globalRebootClient : globalForeverClient, fetchURI, defaultFetchContext.localRequestOnly,\n\t\t\t\t\tdefaultFetchContext.ignoreStore, filterData, QUEUE_MAX_RETRIES,\n\t\t\t\t\tQUEUE_MAX_RETRIES, QUEUE_MAX_DATA_SIZE, returnType, persistRebootOnly, id,\n\t\t\t\t\tInteger.MAX_VALUE, RequestStarter.BULK_SPLITFILE_PRIORITY_CLASS, returnFilename, null, false, realTimeFlag, false, core);\n\t\tcg.register(false);"}
{"magic_number_smell": "\t\t\t}\n\n\n\t\t\tString action = req.getPartAsStringFailsafe(\"action\", 20);\n\n\t\t\tif(req.isPartSet(\"confirmdelete\")) {\n\t\t\t\tbookmarkManager.removeBookmark(bookmarkPath);", "refactored_code": "\tprivate static final int MAX_ACTION_LENGTH = 20;\n\t\t\t}\n\n\n\t\t\tString action = req.getPartAsStringFailsafe(\"action\", MAX_ACTION_LENGTH);\n\n\t\t\tif(req.isPartSet(\"confirmdelete\")) {\n\t\t\t\tbookmarkManager.removeBookmark(bookmarkPath);"}
{"magic_number_smell": "\n\t\t\tHTMLNode formNode = ctx.addFormChild(content, path(), \"yes-button\");\n\t\t\tString subconfig = request.getPartAsStringFailsafe(\"subconfig\",\n\t\t\t\t\t1024 * 1024);\n\t\t\tformNode.addChild(\"input\",\n\t\t\t\t\tnew String[] { \"type\", \"name\", \"value\" }, new String[] {\n\t\t\t\t\t\t\t\"hidden\", \"subconfig\", subconfig });", "refactored_code": "\tprivate static final int MAX_PARAM_VALUE_SIZE = 1024 * 1024;\n\n\t\t\tHTMLNode formNode = ctx.addFormChild(content, path(), \"yes-button\");\n\t\t\tString subconfig = request.getPartAsStringFailsafe(\"subconfig\",\n\t\t\t\t\tMAX_PARAM_VALUE_SIZE);\n\t\t\tformNode.addChild(\"input\",\n\t\t\t\t\tnew String[] { \"type\", \"name\", \"value\" }, new String[] {\n\t\t\t\t\t\t\t\"hidden\", \"subconfig\", subconfig });"}
{"magic_number_smell": "\t}\n\n\tpublic void handleMethodPOST(URI uri, HTTPRequest request, ToadletContext ctx) throws ToadletContextClosedException, IOException {\n\t\tString url = request.getPartAsStringFailsafe(magicHTTPEscapeString, 1024 * 1024);\n\t\tMultiValueTable<String, String> headers = new MultiValueTable<String, String>();\n\t\t//If the user clicked cancel, or the URL is not defined, return to the main page.\n\t\t//TODO: This will mean the beginning of the first time wizard if it's still in progress.", "refactored_code": "\tprivate static final int MAX_URL_LENGTH = 1024 * 1024;\n\t}\n\n\tpublic void handleMethodPOST(URI uri, HTTPRequest request, ToadletContext ctx) throws ToadletContextClosedException, IOException {\n\t\tString url = request.getPartAsStringFailsafe(magicHTTPEscapeString, MAX_URL_LENGTH);\n\t\tMultiValueTable<String, String> headers = new MultiValueTable<String, String>();\n\t\t//If the user clicked cancel, or the URL is not defined, return to the main page.\n\t\t//TODO: This will mean the beginning of the first time wizard if it's still in progress."}
{"magic_number_smell": "\n        private String storageLimit;\n\n        private final String minStorageLimit = String.format(Locale.ENGLISH, \"%.2f\", (float) Node.MIN_STORE_SIZE * 5 / 4 / DatastoreUtil.oneGiB);\n\n        private String setPassword = \"\";\n", "refactored_code": "    private static final long MIN_STORAGE_LIMIT = Node.MIN_STORE_SIZE * 5 / 4;  // min store size + 10% for client cache + 10% for slashdot cache\n\n        private String storageLimit;\n\n        private final String minStorageLimit = String.format(Locale.ENGLISH, \"%.2f\", (float) MIN_STORAGE_LIMIT / DatastoreUtil.oneGiB);\n\n        private String setPassword = \"\";\n"}
{"magic_number_smell": "\t\tboolean force = false;\n\t\tif(forceString != null) {\n\t\t\tif(forceString.equals(getForceValue(key, now)) ||\n\t\t\t\t\tforceString.equals(getForceValue(key, now-HOURS.toMillis(1))))\n\t\t\t\tforce = true;\n\t\t}\n", "refactored_code": "\tprivate static final long FORCE_GRAIN_INTERVAL = HOURS.toMillis(1);\n\t\tboolean force = false;\n\t\tif(forceString != null) {\n\t\t\tif(forceString.equals(getForceValue(key, now)) ||\n\t\t\t\t\tforceString.equals(getForceValue(key, now-FORCE_GRAIN_INTERVAL)))\n\t\t\t\tforce = true;\n\t\t}\n"}
{"magic_number_smell": "\t\t\t// The text that will be drawn\n\t\t\tString text = req.getParam(\"text\");\n\t\t\t// If width or height is specified, we use it, if not, then we use the default\n\t\t\tint requiredWidth = req.getParam(\"width\").compareTo(\"\") != 0 ? Integer.parseInt(req.getParam(\"width\").endsWith(\"px\")?req.getParam(\"width\").substring(0, req.getParam(\"width\").length()-2):req.getParam(\"width\")) : 100;\n\t\t\tint requiredHeight = req.getParam(\"height\").compareTo(\"\") != 0 ? Integer.parseInt(req.getParam(\"height\").endsWith(\"px\")?req.getParam(\"height\").substring(0, req.getParam(\"height\").length()-2):req.getParam(\"height\")) : DEFAULT_HEIGHT;\n\t\t\t// Validate image size\n\t\t\tif (requiredWidth <= 0 || requiredHeight <= 0) {", "refactored_code": "\tpublic static final int\t\tDEFAULT_WIDTH\t= 100;\n\t\t\t// The text that will be drawn\n\t\t\tString text = req.getParam(\"text\");\n\t\t\t// If width or height is specified, we use it, if not, then we use the default\n\t\t\tint requiredWidth = req.getParam(\"width\").compareTo(\"\") != 0 ? Integer.parseInt(req.getParam(\"width\").endsWith(\"px\")?req.getParam(\"width\").substring(0, req.getParam(\"width\").length()-2):req.getParam(\"width\")) : DEFAULT_WIDTH;\n\t\t\tint requiredHeight = req.getParam(\"height\").compareTo(\"\") != 0 ? Integer.parseInt(req.getParam(\"height\").endsWith(\"px\")?req.getParam(\"height\").substring(0, req.getParam(\"height\").length()-2):req.getParam(\"height\")) : DEFAULT_HEIGHT;\n\t\t\t// Validate image size\n\t\t\tif (requiredWidth <= 0 || requiredHeight <= 0) {"}
{"magic_number_smell": "\t\t\t\n\t\t\t// If there are more elements, it reschedules\n\t\t\tif (elements.size() > 0) {\n\t\t\t\tticker.queueTimedJob(this, \"Stats refresher\", 10000, false, true);\n\t\t\t}\n\t\t}\n\t};", "refactored_code": "\tprivate static final int\t\t\tREFRESH_PERIOD\t= 10000;\n\t\t\t\n\t\t\t// If there are more elements, it reschedules\n\t\t\tif (elements.size() > 0) {\n\t\t\t\tticker.queueTimedJob(this, \"Stats refresher\", REFRESH_PERIOD, false, true);\n\t\t\t}\n\t\t}\n\t};"}
{"magic_number_smell": "\tprivate Hashtable<String, String> readPOST (HTTPRequest request) {\n\t\tHashtable<String, String> set = new Hashtable<String, String>();\n\t\tfor (String key : request.getParts()) {\n\t\t\tset.put(key, request.getPartAsStringFailsafe(key, 1024*1024));\n\t\t}\n\t\treturn set;\n\t}", "refactored_code": "\tprivate static final int MAX_POST_SIZE = 1024*1024;\n\tprivate Hashtable<String, String> readPOST (HTTPRequest request) {\n\t\tHashtable<String, String> set = new Hashtable<String, String>();\n\t\tfor (String key : request.getParts()) {\n\t\t\tset.put(key, request.getPartAsStringFailsafe(key, MAX_POST_SIZE));\n\t\t}\n\t\treturn set;\n\t}"}
{"magic_number_smell": "\t\t\t\tString uri = ctx.getUri().getQuery();\n\t\t\t\tMap<String, List<String>> parameters = HTTPRequestImpl.parseUriParameters(uri, true);\n\t\t\t\tList<String> newModeSwitchValues = new ArrayList<String>();\n\t\t\t\tnewModeSwitchValues.add(String.valueOf(isAdvancedMode ? 1 : MODE_ADVANCED));\n\t\t\t\t/* overwrite any previously existing parameter value. */\n\t\t\t\tparameters.put(MODE_SWITCH_PARAMETER, newModeSwitchValues);\n", "refactored_code": "\tpublic static final int MODE_SIMPLE = 1;\n\t\t\t\tString uri = ctx.getUri().getQuery();\n\t\t\t\tMap<String, List<String>> parameters = HTTPRequestImpl.parseUriParameters(uri, true);\n\t\t\t\tList<String> newModeSwitchValues = new ArrayList<String>();\n\t\t\t\tnewModeSwitchValues.add(String.valueOf(isAdvancedMode ? MODE_SIMPLE : MODE_ADVANCED));\n\t\t\t\t/* overwrite any previously existing parameter value. */\n\t\t\t\tparameters.put(MODE_SWITCH_PARAMETER, newModeSwitchValues);\n"}
{"magic_number_smell": "\t\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (request.getPartAsStringFailsafe(\"unloadconfirm\", 1024).length() > 0) {\n\t\t\t\tString pluginThreadName = request.getPartAsStringFailsafe(\"unloadconfirm\", 1024);\n\t\t\t\tString pluginSpecification = getPluginSpecification(pm, pluginThreadName);\n\t\t\t\tpm.killPlugin(pluginThreadName, MAX_THREADED_UNLOAD_WAIT_TIME, false);", "refactored_code": "\tprivate static final int MAX_PLUGIN_NAME_LENGTH = 1024;\n\t\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (request.getPartAsStringFailsafe(\"unloadconfirm\", MAX_PLUGIN_NAME_LENGTH).length() > 0) {\n\t\t\t\tString pluginThreadName = request.getPartAsStringFailsafe(\"unloadconfirm\", MAX_PLUGIN_NAME_LENGTH);\n\t\t\t\tString pluginSpecification = getPluginSpecification(pm, pluginThreadName);\n\t\t\t\tpm.killPlugin(pluginThreadName, MAX_THREADED_UNLOAD_WAIT_TIME, false);"}
{"magic_number_smell": "\t\t\t\t\tpart = part.substring(\"identifier-\".length());\n\t\t\t\t\tif(part.length() > 50) continue; // It's just a number \n\t\t\t\t\t\n\t\t\t\t\tString identifier = request.getPartAsStringFailsafe(\"identifier-\"+part, 1024*1024);\n\t\t\t\t\tif(identifier == null) continue;\n\t\t\t\t\tString filename = request.getPartAsStringFailsafe(\"filename-\"+part, MAX_FILENAME_LENGTH);\n\t\t\t\t\tString keyString = request.getPartAsStringFailsafe(\"key-\"+part, MAX_KEY_LENGTH);", "refactored_code": "\tprivate static final int MAX_IDENTIFIER_LENGTH = 1024*1024;\n\t\t\t\t\tpart = part.substring(\"identifier-\".length());\n\t\t\t\t\tif(part.length() > 50) continue; // It's just a number \n\t\t\t\t\t\n\t\t\t\t\tString identifier = request.getPartAsStringFailsafe(\"identifier-\"+part, MAX_IDENTIFIER_LENGTH);\n\t\t\t\t\tif(identifier == null) continue;\n\t\t\t\t\tString filename = request.getPartAsStringFailsafe(\"filename-\"+part, MAX_FILENAME_LENGTH);\n\t\t\t\t\tString keyString = request.getPartAsStringFailsafe(\"key-\"+part, MAX_KEY_LENGTH);"}
{"magic_number_smell": "\t\t\tif(logMINOR) Logger.minor(this, \"New physical threat level: \"+newPhysicalLevel+\" old = \"+node.getSecurityLevels().getPhysicalThreatLevel());\n\t\t\tif(newPhysicalLevel != null) {\n\t\t\t\tif(newPhysicalLevel == oldPhysicalLevel && newPhysicalLevel == PHYSICAL_THREAT_LEVEL.HIGH) {\n\t\t\t\t\tString password = request.getPartAsStringFailsafe(\"masterPassword\", 1024);\n\t\t\t\t\tString oldPassword = request.getPartAsStringFailsafe(\"oldPassword\", 1024);\n\t\t\t\t\tString confirmPassword = request.getPartAsStringFailsafe(\"confirmMasterPassword\", 1024);\n\t\t\t\t\tif (!oldPassword.isEmpty() && !confirmPassword.isEmpty() && !password.isEmpty() && password.equals(confirmPassword)) {", "refactored_code": "\tpublic static final int MAX_PASSWORD_LENGTH = 1024;\n\t\t\tif(logMINOR) Logger.minor(this, \"New physical threat level: \"+newPhysicalLevel+\" old = \"+node.getSecurityLevels().getPhysicalThreatLevel());\n\t\t\tif(newPhysicalLevel != null) {\n\t\t\t\tif(newPhysicalLevel == oldPhysicalLevel && newPhysicalLevel == PHYSICAL_THREAT_LEVEL.HIGH) {\n\t\t\t\t\tString password = request.getPartAsStringFailsafe(\"masterPassword\", MAX_PASSWORD_LENGTH);\n\t\t\t\t\tString oldPassword = request.getPartAsStringFailsafe(\"oldPassword\", MAX_PASSWORD_LENGTH);\n\t\t\t\t\tString confirmPassword = request.getPartAsStringFailsafe(\"confirmMasterPassword\", MAX_PASSWORD_LENGTH);\n\t\t\t\t\tif (!oldPassword.isEmpty() && !confirmPassword.isEmpty() && !password.isEmpty() && password.equals(confirmPassword)) {"}
{"magic_number_smell": "\t\tprivate Session(String myUserID, long currentTime) {\n\t\t\tmID = UUID.randomUUID();\n\t\t\tmUserID = myUserID;\n\t\t\tmExpiresAtTime = currentTime + SessionManager.HOURS.toMillis(1);\n\t\t}\n\t\t\n\t\t@Override", "refactored_code": "\tpublic static final long MAX_SESSION_IDLE_TIME = HOURS.toMillis(1);\n\t\tprivate Session(String myUserID, long currentTime) {\n\t\t\tmID = UUID.randomUUID();\n\t\t\tmUserID = myUserID;\n\t\t\tmExpiresAtTime = currentTime + SessionManager.MAX_SESSION_IDLE_TIME;\n\t\t}\n\t\t\n\t\t@Override"}
{"magic_number_smell": "\t\t\n\t\tfproxyConfig.register(\"ssl\", false, configItemOrder++, true, true, \"SimpleToadletServer.ssl\", \"SimpleToadletServer.sslLong\",\n\t\t\t\tnew FProxySSLCallback());\n\t\tfproxyConfig.register(\"port\", 8888, configItemOrder++, true, true, \"SimpleToadletServer.port\", \"SimpleToadletServer.portLong\",\n\t\t\t\tnew FProxyPortCallback(), false);\n\t\tfproxyConfig.register(\"bindTo\", NetworkInterface.DEFAULT_BIND_TO, configItemOrder++, true, true, \"SimpleToadletServer.bindTo\", \"SimpleToadletServer.bindToLong\",\n\t\t\t\tnew FProxyBindtoCallback());", "refactored_code": "\tpublic static final int DEFAULT_FPROXY_PORT = 8888;\n\t\t\n\t\tfproxyConfig.register(\"ssl\", false, configItemOrder++, true, true, \"SimpleToadletServer.ssl\", \"SimpleToadletServer.sslLong\",\n\t\t\t\tnew FProxySSLCallback());\n\t\tfproxyConfig.register(\"port\", DEFAULT_FPROXY_PORT, configItemOrder++, true, true, \"SimpleToadletServer.port\", \"SimpleToadletServer.portLong\",\n\t\t\t\tnew FProxyPortCallback(), false);\n\t\tfproxyConfig.register(\"bindTo\", NetworkInterface.DEFAULT_BIND_TO, configItemOrder++, true, true, \"SimpleToadletServer.bindTo\", \"SimpleToadletServer.bindToLong\",\n\t\t\t\tnew FProxyBindtoCallback());"}
{"magic_number_smell": "\t * Bandwidth used if both the upload and download limit are at the minimum. In GB. Assumes 24/7 uptime.\n\t * 49.4384765625 GiB\n\t */\n\tpublic static final Double minMonthlyLimit = 2 * Node.getMinimumBandwidth() * 2592000d / DatastoreUtil.oneGiB;\n\n\t/**\n\t * Download limit in bytes.", "refactored_code": "\tpublic static final double secondsPerMonth = 2592000d;\n\t * Bandwidth used if both the upload and download limit are at the minimum. In GB. Assumes 24/7 uptime.\n\t * 49.4384765625 GiB\n\t */\n\tpublic static final Double minMonthlyLimit = 2 * Node.getMinimumBandwidth() * secondsPerMonth / DatastoreUtil.oneGiB;\n\n\t/**\n\t * Download limit in bytes."}
{"magic_number_smell": "        new DataInputStream(is).readFully(nonce);\n        cipher = new OCBBlockCipher_v149(hashCipher, mainCipher);\n        KeyParameter keyParam = new KeyParameter(key);\n        AEADParameters params = new AEADParameters(keyParam, AEADOutputStream.MAC_SIZE_BITS, nonce);\n        cipher.init(false, params);\n        excess = new byte[mainCipher.getBlockSize()];\n        excessEnd = 0;", "refactored_code": "    private static final int MAC_SIZE_BITS = AEADOutputStream.MAC_SIZE_BITS;\n        new DataInputStream(is).readFully(nonce);\n        cipher = new OCBBlockCipher_v149(hashCipher, mainCipher);\n        KeyParameter keyParam = new KeyParameter(key);\n        AEADParameters params = new AEADParameters(keyParam, MAC_SIZE_BITS, nonce);\n        cipher.init(false, params);\n        excess = new byte[mainCipher.getBlockSize()];\n        excessEnd = 0;"}
{"magic_number_smell": "     * @throws IllegalArgumentException If there is no ChecksumChecker for that ID.\n     */\n    public static ChecksumChecker create(int checksumID) {\n        if(checksumID == 1)\n            return new CRCChecksumChecker();\n        else\n            throw new IllegalArgumentException(\"Bad checksum ID\");", "refactored_code": "    public static final int CHECKSUM_CRC = 1;\n     * @throws IllegalArgumentException If there is no ChecksumChecker for that ID.\n     */\n    public static ChecksumChecker create(int checksumID) {\n        if(checksumID == CHECKSUM_CRC)\n            return new CRCChecksumChecker();\n        else\n            throw new IllegalArgumentException(\"Bad checksum ID\");"}
{"magic_number_smell": "        {\n            throw new IllegalArgumentException(\"'hashCipher' cannot be null\");\n        }\n        if (hashCipher.getBlockSize() != 16)\n        {\n            throw new IllegalArgumentException(\"'hashCipher' must have a block size of \"\n                + 16);", "refactored_code": "    private static final int BLOCK_SIZE = 16;\n        {\n            throw new IllegalArgumentException(\"'hashCipher' cannot be null\");\n        }\n        if (hashCipher.getBlockSize() != BLOCK_SIZE)\n        {\n            throw new IllegalArgumentException(\"'hashCipher' must have a block size of \"\n                + BLOCK_SIZE);"}
{"magic_number_smell": "\t}\n\n\tpublic static int getDigestLength() {\n\t\treturn 32;\n\t}\n}\n", "refactored_code": "\tprivate static final int HASH_SIZE = 32;\n\t}\n\n\tpublic static int getDigestLength() {\n\t\treturn HASH_SIZE;\n\t}\n}\n"}
{"magic_number_smell": "\t\t\t\t\tObject x500Name = x500NameCtor.newInstance(CERTIFICATE_CN, CERTIFICATE_OU, CERTIFICATE_ON, \"\", \"\", \"\");\n\t\t\t\t\t\n\t\t\t\t\tMethod certAndKeyGenGenerate = certAndKeyGenClazz.getMethod(\"generate\", int.class);\n\t\t\t\t\tcertAndKeyGenGenerate.invoke(keypair, 256);\n\t\t\t\t\t\n\t\t\t\t\tMethod certAndKeyGetPrivateKey = certAndKeyGenClazz.getMethod(\"getPrivateKey\");\n\t\t\t\t\tPrivateKey privKey = (PrivateKey) certAndKeyGetPrivateKey.invoke(keypair);", "refactored_code": "\tprivate static final int KEY_SIZE = 256;\n\t\t\t\t\tObject x500Name = x500NameCtor.newInstance(CERTIFICATE_CN, CERTIFICATE_OU, CERTIFICATE_ON, \"\", \"\", \"\");\n\t\t\t\t\t\n\t\t\t\t\tMethod certAndKeyGenGenerate = certAndKeyGenClazz.getMethod(\"generate\", int.class);\n\t\t\t\t\tcertAndKeyGenGenerate.invoke(keypair, KEY_SIZE);\n\t\t\t\t\t\n\t\t\t\t\tMethod certAndKeyGetPrivateKey = certAndKeyGenClazz.getMethod(\"getPrivateKey\");\n\t\t\t\t\tPrivateKey privKey = (PrivateKey) certAndKeyGetPrivateKey.invoke(keypair);"}
{"magic_number_smell": "\t\t\t\tthrow new RuntimeException(\"Symmetric operation failed\");\n\t\t}\n\t\tcatch (Exception x) {\n\t\t\tif (RDEBUG && (RDEBUG ? 6 : 0 > 0)) {\n\t\t\t\tdebug(\"Exception encountered during self-test: \" + x.getMessage());\n\t\t\t\tx.printStackTrace();\n\t\t\t}", "refactored_code": "\tprivate static final int debuglevel = RDEBUG ? 6 : 0;\n\t\t\t\tthrow new RuntimeException(\"Symmetric operation failed\");\n\t\t}\n\t\tcatch (Exception x) {\n\t\t\tif (RDEBUG && (debuglevel > 0)) {\n\t\t\t\tdebug(\"Exception encountered during self-test: \" + x.getMessage());\n\t\t\t\tx.printStackTrace();\n\t\t\t}"}
{"magic_number_smell": "\tpublic static final long HOURS.toMillis(24) = HOURS.toMillis(24);\n\n\tpublic long getLongestSendReceiveGap() {\n\t\treturn getLongestSendReceiveGap(HOURS.toMillis(24));\n\t}\n\n\t/**", "refactored_code": "\tpublic static final long HORIZON = HOURS.toMillis(24);\n\tpublic static final long HORIZON = HOURS.toMillis(24);\n\n\tpublic long getLongestSendReceiveGap() {\n\t\treturn getLongestSendReceiveGap(HORIZON);\n\t}\n\n\t/**"}
{"magic_number_smell": "\t\tpacketsReceived = 0;\n\t\tthis.timeDefinitelyNoPacketsReceived = timeDefinitelyNoPacketsReceived;\n\t\tthis.timeDefinitelyNoPacketsSent = timeDefinitelyNoPacketsSent;\n\t\tgapLengths = new long[5];\n\t\tgapLengthRecvTimes = new long[5];\n\t}\n\t", "refactored_code": "\tpublic static final int TRACK_GAPS = 5;\n\t\tpacketsReceived = 0;\n\t\tthis.timeDefinitelyNoPacketsReceived = timeDefinitelyNoPacketsReceived;\n\t\tthis.timeDefinitelyNoPacketsSent = timeDefinitelyNoPacketsSent;\n\t\tgapLengths = new long[TRACK_GAPS];\n\t\tgapLengthRecvTimes = new long[TRACK_GAPS];\n\t}\n\t"}
{"magic_number_smell": "\n\tprivate int[][] _getTotalStatistics() {\n\t\t//String[] keys = (String[])targets.keySet().toArray();\n\t\tint ret[][] = new int[10][2];\n\t\tfor (int i = 0 ; i < 10 ; i++) {\n\t\t\tret[i][0] = ret[i][1] = 0;\n\t\t}", "refactored_code": "\tpublic static final int STATISTICS_ENTRIES = 10;\n\n\tprivate int[][] _getTotalStatistics() {\n\t\t//String[] keys = (String[])targets.keySet().toArray();\n\t\tint ret[][] = new int[STATISTICS_ENTRIES][2];\n\t\tfor (int i = 0 ; i < STATISTICS_ENTRIES ; i++) {\n\t\t\tret[i][0] = ret[i][1] = 0;\n\t\t}"}
{"magic_number_smell": "\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!matched) {\n\t\t\t\t    while (_unclaimed.size() > 50000) {\n\t\t\t\t        Message removed = _unclaimed.removeFirst();\n\t\t\t\t        long messageLifeTime = System.currentTimeMillis() - removed.localInstantiationTime;\n\t\t\t\t        if ((removed.getSource()) instanceof PeerNode) {", "refactored_code": "\tprivate static final int MAX_UNMATCHED_FIFO_SIZE = 50000;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!matched) {\n\t\t\t\t    while (_unclaimed.size() > MAX_UNMATCHED_FIFO_SIZE) {\n\t\t\t\t        Message removed = _unclaimed.removeFirst();\n\t\t\t\t        long messageLifeTime = System.currentTimeMillis() - removed.localInstantiationTime;\n\t\t\t\t        if ((removed.getSource()) instanceof PeerNode) {"}
{"magic_number_smell": "\t\t_ticker = ticker;\n\t\t_realTime = realTime;\n\t\tthis.completeAfterAckedAllReceived = completeAfterAckedAllReceived;\n\t\tRECEIPT_TIMEOUT = _realTime ? SECONDS.toMillis(10) : RECEIPT_TIMEOUT_BULK;\n\t\tMAX_ROUND_TRIP_TIME = RECEIPT_TIMEOUT;\n//\t\t_doTooLong = doTooLong;\n\t}", "refactored_code": "\tpublic static final long RECEIPT_TIMEOUT_REALTIME = SECONDS.toMillis(10);\n\t\t_ticker = ticker;\n\t\t_realTime = realTime;\n\t\tthis.completeAfterAckedAllReceived = completeAfterAckedAllReceived;\n\t\tRECEIPT_TIMEOUT = _realTime ? RECEIPT_TIMEOUT_REALTIME : RECEIPT_TIMEOUT_BULK;\n\t\tMAX_ROUND_TRIP_TIME = RECEIPT_TIMEOUT;\n//\t\t_doTooLong = doTooLong;\n\t}"}
{"magic_number_smell": "\t\t\t\t\t\t\t_receivedSendCompletion = true;\n\t\t\t\t\t\t\t_receivedSendSuccess = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//60000 (one minute) after all packets have been transmitted, terminate the send.\n\t\t\t\t\t\tif(_failed) {\n\t\t\t\t\t\t\t// Already failed, we were just waiting for the acknowledgement sendAborted.\n\t\t\t\t\t\t\tif(!hadSendCompletion) {", "refactored_code": "\tpublic static final int SEND_TIMEOUT = 60000;\n\t\t\t\t\t\t\t_receivedSendCompletion = true;\n\t\t\t\t\t\t\t_receivedSendSuccess = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//SEND_TIMEOUT (one minute) after all packets have been transmitted, terminate the send.\n\t\t\t\t\t\tif(_failed) {\n\t\t\t\t\t\t\t// Already failed, we were just waiting for the acknowledgement sendAborted.\n\t\t\t\t\t\t\tif(!hadSendCompletion) {"}
{"magic_number_smell": "\t}\n\n\tprotected static final double 0.875 = 0.875;\n\tprotected static final double PACKET_TRANSMIT_INCREMENT = (4 * (1 - (0.875 * 0.875))) / 3;\n\tprotected static final double SLOW_START_DIVISOR = 3.0;\n\tprotected static final long MAX_DELAY = 1000;\n\tprotected static final long MIN_DELAY = 1;", "refactored_code": "\tprotected static final double PACKET_DROP_DECREASE_MULTIPLE = 0.875;\n\t}\n\n\tprotected static final double PACKET_DROP_DECREASE_MULTIPLE = 0.875;\n\tprotected static final double PACKET_TRANSMIT_INCREMENT = (4 * (1 - (PACKET_DROP_DECREASE_MULTIPLE * PACKET_DROP_DECREASE_MULTIPLE))) / 3;\n\tprotected static final double SLOW_START_DIVISOR = 3.0;\n\tprotected static final long MAX_DELAY = 1000;\n\tprotected static final long MIN_DELAY = 1;"}
{"magic_number_smell": "        \t\treturn BucketTools.makeImmutableBucket(factory, dataOutput, 2, dataLength - 2);\n        }\n\n        Bucket b = Key.decompress(compressionAlgorithm >= 0, dataOutput, dataLength, factory, Math.min(32768, maxLength), compressionAlgorithm, true);\n        return b;\n\t}\n", "refactored_code": "\tstatic public final int MAX_DECOMPRESSED_DATA_LENGTH = 32768;\n        \t\treturn BucketTools.makeImmutableBucket(factory, dataOutput, 2, dataLength - 2);\n        }\n\n        Bucket b = Key.decompress(compressionAlgorithm >= 0, dataOutput, dataLength, factory, Math.min(MAX_DECOMPRESSED_DATA_LENGTH, maxLength), compressionAlgorithm, true);\n        return b;\n\t}\n"}
{"magic_number_smell": "\t * High 8 bit (<tt>(type >> 8) & 0xFF</tt>) is the base type ({@link NodeCHK#BASE_TYPE} or\n\t * {@link NodeSSK#BASE_TYPE}).\n\t * <li>Low 8 bit (<tt>type & 0xFF</tt>) is the crypto algorithm. (Currently only\n\t * {@link #2} is supported).\n\t * </ul>\n\t */\n\tpublic abstract short getType();", "refactored_code": "    public static final byte ALGO_AES_PCFB_256_SHA256 = 2;\n\t * High 8 bit (<tt>(type >> 8) & 0xFF</tt>) is the base type ({@link NodeCHK#BASE_TYPE} or\n\t * {@link NodeSSK#BASE_TYPE}).\n\t * <li>Low 8 bit (<tt>type & 0xFF</tt>) is the crypto algorithm. (Currently only\n\t * {@link #ALGO_AES_PCFB_256_SHA256} is supported).\n\t * </ul>\n\t */\n\tpublic abstract short getType();"}
{"magic_number_smell": "\n\t@Override\n\tpublic byte[] getFullKey() {\n\t\tbyte[] buf = new byte[34];\n\t\tshort type = getType();\n\t\tbuf[0] = (byte) (type >> 8);\n\t\tbuf[1] = (byte) (type & 0xFF);", "refactored_code": "    public static final short FULL_KEY_LENGTH = 34;\n\n\t@Override\n\tpublic byte[] getFullKey() {\n\t\tbyte[] buf = new byte[FULL_KEY_LENGTH];\n\t\tshort type = getType();\n\t\tbuf[0] = (byte) (type >> 8);\n\t\tbuf[1] = (byte) (type & 0xFF);"}
{"magic_number_smell": "    \tif(block.hashIdentifier != hashIdentifier) return false;\n    \tif(block.symCipherIdentifier != symCipherIdentifier) return false;\n    \t// only compare some of the headers (see top)\n    \tfor (int i = 0; i < 71; i++) {\n    \t\tif (block.headers[i] != headers[i]) return false;\n    \t}\n    \t//if(!Arrays.equals(block.headers, headers)) return false;", "refactored_code": "\tprivate static final int HEADER_COMPARE_TO = 71;\n    \tif(block.hashIdentifier != hashIdentifier) return false;\n    \tif(block.symCipherIdentifier != symCipherIdentifier) return false;\n    \t// only compare some of the headers (see top)\n    \tfor (int i = 0; i < HEADER_COMPARE_TO; i++) {\n    \t\tif (block.headers[i] != headers[i]) return false;\n    \t}\n    \t//if(!Arrays.equals(block.headers, headers)) return false;"}
{"magic_number_smell": "\t\t\t// So lets connect to a few seednodes, and attempt an announcement.\n\t\t\tSystem.err.println(\"Attempting announcement to seednodes...\");\n\t\t\tsynchronized(this) {\n\t\t\t\tregisterEvent(0);\n\t\t\t\tstarted = true;\n\t\t\t}\n\t\t\tconnectSomeSeednodes();", "refactored_code": "\tprivate static final int STATUS_LOADING = 0;\n\t\t\t// So lets connect to a few seednodes, and attempt an announcement.\n\t\t\tSystem.err.println(\"Attempting announcement to seednodes...\");\n\t\t\tsynchronized(this) {\n\t\t\t\tregisterEvent(STATUS_LOADING);\n\t\t\t\tstarted = true;\n\t\t\t}\n\t\t\tconnectSomeSeednodes();"}
{"magic_number_smell": "                    Logger.minor(this, e.getMessage());\n                    throw e;\n                } finally {\n                    node.getTicker().queueTimedJob(this, HOURS.toMillis(24));\n                }\n            }\n        }, HOURS.toMillis(24));", "refactored_code": "    private static final long DELAY_HOURS = 24;\n                    Logger.minor(this, e.getMessage());\n                    throw e;\n                } finally {\n                    node.getTicker().queueTimedJob(this, HOURS.toMillis(DELAY_HOURS));\n                }\n            }\n        }, HOURS.toMillis(DELAY_HOURS));"}
{"magic_number_smell": "    \t\t\n    \t\tboolean canRerouteWhileWaiting = true;\n    \t\tsynchronized(this) {\n    \t\t\tif(rejectedLoops > 3)\n    \t\t\t\tcanRerouteWhileWaiting = false;\n    \t\t}\n    \t\t", "refactored_code": "    private static final int MAX_REJECTED_LOOPS = 3;\n    \t\t\n    \t\tboolean canRerouteWhileWaiting = true;\n    \t\tsynchronized(this) {\n    \t\t\tif(rejectedLoops > MAX_REJECTED_LOOPS)\n    \t\t\t\tcanRerouteWhileWaiting = false;\n    \t\t}\n    \t\t"}
{"magic_number_smell": "\t\t// The node didn't accept the request. So we don't need to send them the data.\n\t\t// However, we do need to wait a bit longer to try to postpone the fatalTimeout().\n\t\t// Somewhat intricate logic to try to avoid fatalTimeout() if at all possible.\n\t\tMessageFilter mf = makeAcceptedRejectedFilter(next, MINUTES.toMillis(1), tag);\n\t\ttry {\n\t\t\tnode.getUSM().addAsyncFilter(mf, new SlowAsyncMessageFilterCallback() {\n", "refactored_code": "\tprivate static final long TIMEOUT_AFTER_ACCEPTEDREJECTED_TIMEOUT = MINUTES.toMillis(1);\n\t\t// The node didn't accept the request. So we don't need to send them the data.\n\t\t// However, we do need to wait a bit longer to try to postpone the fatalTimeout().\n\t\t// Somewhat intricate logic to try to avoid fatalTimeout() if at all possible.\n\t\tMessageFilter mf = makeAcceptedRejectedFilter(next, TIMEOUT_AFTER_ACCEPTEDREJECTED_TIMEOUT, tag);\n\t\ttry {\n\t\t\tnode.getUSM().addAsyncFilter(mf, new SlowAsyncMessageFilterCallback() {\n"}
{"magic_number_smell": "\n\tprivate static final int SHA256.getDigestLength() = SHA256.getDigestLength();\n\t/** The size of the key used to authenticate the hmac */\n\tprivate static final int TRANSIENT_KEY_SIZE = SHA256.getDigestLength();\n\t/** The key used to authenticate the hmac */\n\tprivate final byte[] transientKey = new byte[TRANSIENT_KEY_SIZE];\n\tpublic static final long TRANSIENT_KEY_REKEYING_MIN_INTERVAL = MINUTES.toMillis(30);", "refactored_code": "\tprivate static final int HASH_LENGTH = SHA256.getDigestLength();\n\n\tprivate static final int HASH_LENGTH = SHA256.getDigestLength();\n\t/** The size of the key used to authenticate the hmac */\n\tprivate static final int TRANSIENT_KEY_SIZE = HASH_LENGTH;\n\t/** The key used to authenticate the hmac */\n\tprivate final byte[] transientKey = new byte[TRANSIENT_KEY_SIZE];\n\tpublic static final long TRANSIENT_KEY_REKEYING_MIN_INTERVAL = MINUTES.toMillis(30);"}
{"magic_number_smell": "\t\tfinishedReporting = false;\n\t\tbyHTL = new StatsLine[node.maxHTL() + 1];\n\t\tfor (int i = 0; i < byHTL.length; i++) byHTL[i] = new StatsLine();\n\t\tbyDist = new StatsLine[16];\n\t\tfor (int i = 0; i < byDist.length; i++) byDist[i] = new StatsLine();\n\n\t\tbeginTime = new Date();", "refactored_code": "\tprivate static final int N_DISTANCE_GROUPS = 16;\n\t\tfinishedReporting = false;\n\t\tbyHTL = new StatsLine[node.maxHTL() + 1];\n\t\tfor (int i = 0; i < byHTL.length; i++) byHTL[i] = new StatsLine();\n\t\tbyDist = new StatsLine[N_DISTANCE_GROUPS];\n\t\tfor (int i = 0; i < byDist.length; i++) byDist[i] = new StatsLine();\n\n\t\tbeginTime = new Date();"}
{"magic_number_smell": "\t/**\n\t * Parses a location.\n\t * @param init a location string\n\t * @return the location, or -1.0 for all invalid locations and on parse errors.\n\t */\n\tpublic static double getLocation(String init) {\n\t\ttry {", "refactored_code": "\tpublic static final double LOCATION_INVALID = -1.0;\n\t/**\n\t * Parses a location.\n\t * @param init a location string\n\t * @return the location, or LOCATION_INVALID for all invalid locations and on parse errors.\n\t */\n\tpublic static double getLocation(String init) {\n\t\ttry {"}
{"magic_number_smell": "     */\n    public void start() {\n    \tif(node.isEnableSwapping()) {\n          node.getTicker().queueTimedJob(sender, MINUTES.toMillis(1));\n      }\n\t\tnode.getTicker().queueTimedJob(new Runnable() {\n", "refactored_code": "    private static final long STARTUP_DELAY = MINUTES.toMillis(1);\n     */\n    public void start() {\n    \tif(node.isEnableSwapping()) {\n          node.getTicker().queueTimedJob(sender, STARTUP_DELAY);\n      }\n\t\tnode.getTicker().queueTimedJob(new Runnable() {\n"}
{"magic_number_smell": "\t\t\tint index = (keyContext.watchListPointer + i) % keyContext.seqNumWatchList.length;\n\t\t\tif (!Fields.byteArrayEqual(\n\t\t\t\t\t\tbuf, keyContext.seqNumWatchList[index],\n\t\t\t\t\t\toffset + 10, 0,\n\t\t\t\t\t\tkeyContext.seqNumWatchList[index].length))\n\t\t\t\tcontinue;\n\t\t\t", "refactored_code": "\tprivate static final int HMAC_LENGTH = 10;\n\t\t\tint index = (keyContext.watchListPointer + i) % keyContext.seqNumWatchList.length;\n\t\t\tif (!Fields.byteArrayEqual(\n\t\t\t\t\t\tbuf, keyContext.seqNumWatchList[index],\n\t\t\t\t\t\toffset + HMAC_LENGTH, 0,\n\t\t\t\t\t\tkeyContext.seqNumWatchList[index].length))\n\t\t\t\tcontinue;\n\t\t\t"}
{"magic_number_smell": "\t * they are acked after we had decided they were lost. */\n\tprivate static final int 128 = 128;\n\t/** We add all lost packets sequence numbers and the corresponding sent time to this cache. */\n\tprivate final SentTimeCache lostSentTimes = new SentTimeCache(128);\n\t\n\tprivate final Object sequenceNumberLock = new Object();\n\t", "refactored_code": "\tprivate static final int MAX_LOST_SENT_TIMES = 128;\n\t * they are acked after we had decided they were lost. */\n\tprivate static final int MAX_LOST_SENT_TIMES = 128;\n\t/** We add all lost packets sequence numbers and the corresponding sent time to this cache. */\n\tprivate final SentTimeCache lostSentTimes = new SentTimeCache(MAX_LOST_SENT_TIMES);\n\t\n\tprivate final Object sequenceNumberLock = new Object();\n\t"}
{"magic_number_smell": "\t\t\t\t\t\tfalse, Node.FORK_ON_CACHEABLE_DEFAULT, false,\n\t\t\t\t\t\tCompressor.DEFAULT_COMPRESSORDESCRIPTOR, 0, 0,\n\t\t\t\t\t\tInsertContext.CompatibilityMode.COMPAT_DEFAULT),\n\t\t\t\tRequestStarter.PREFETCH_PRIORITY_CLASS, 8192,\n\t\t\t\tnew HealingDecisionSupplier(node::getLocation, node::isOpennetEnabled));\n\n\t\tPooledFileRandomAccessBufferFactory raff =", "refactored_code": "\tprivate static final int MAX_RUNNING_HEALING_INSERTS = 8192;\n\t\t\t\t\t\tfalse, Node.FORK_ON_CACHEABLE_DEFAULT, false,\n\t\t\t\t\t\tCompressor.DEFAULT_COMPRESSORDESCRIPTOR, 0, 0,\n\t\t\t\t\t\tInsertContext.CompatibilityMode.COMPAT_DEFAULT),\n\t\t\t\tRequestStarter.PREFETCH_PRIORITY_CLASS, MAX_RUNNING_HEALING_INSERTS,\n\t\t\t\tnew HealingDecisionSupplier(node::getLocation, node::isOpennetEnabled));\n\n\t\tPooledFileRandomAccessBufferFactory raff ="}
{"magic_number_smell": "\t\tmyARKNumber = 0;\n\t\tclientNonce = new byte[32];\n\t\tnode.getRandom().nextBytes(clientNonce);\n\t\tmyIdentity = new byte[32];\n\t\tnode.getRandom().nextBytes(myIdentity);\n\t\tidentityHash = SHA256.digest(myIdentity);\n\t\tidentityHashHash = SHA256.digest(identityHash);", "refactored_code": "\tpublic static final int IDENTITY_LENGTH = 32;\n\t\tmyARKNumber = 0;\n\t\tclientNonce = new byte[32];\n\t\tnode.getRandom().nextBytes(clientNonce);\n\t\tmyIdentity = new byte[IDENTITY_LENGTH];\n\t\tnode.getRandom().nextBytes(myIdentity);\n\t\tidentityHash = SHA256.digest(myIdentity);\n\t\tidentityHashHash = SHA256.digest(identityHash);"}
{"magic_number_smell": "\t\t\tIterator<RoutedContext> i = routedContexts.values().iterator();\n\t\t\twhile (i.hasNext()) {\n\t\t\t\tRoutedContext rc = i.next();\n\t\t\t\tif (now-rc.createdTime > 20000) {\n\t\t\t\t\ti.remove();\n\t\t\t\t}\n\t\t\t}", "refactored_code": "\tprivate static final long STALE_CONTEXT=20000;\n\t\t\tIterator<RoutedContext> i = routedContexts.values().iterator();\n\t\t\twhile (i.hasNext()) {\n\t\t\t\tRoutedContext rc = i.next();\n\t\t\t\tif (now-rc.createdTime > STALE_CONTEXT) {\n\t\t\t\t\ti.remove();\n\t\t\t\t}\n\t\t\t}"}
{"magic_number_smell": "\t\t\tif ((key2 != null) && !key2.equals(key))\n\t\t\t\tthrow new IllegalArgumentException(\"Wrong hash?? Already have different key with same hash!\");\n\t\t\tcachedPubKeys.push(w, key);\n\t\t\twhile (cachedPubKeys.size() > 1000)\n\t\t\t\tcachedPubKeys.popKey();\n\t\t}\n\t\ttry {", "refactored_code": "\tprivate static final int MAX_MEMORY_CACHED_PUBKEYS = 1000;\n\t\t\tif ((key2 != null) && !key2.equals(key))\n\t\t\t\tthrow new IllegalArgumentException(\"Wrong hash?? Already have different key with same hash!\");\n\t\t\tcachedPubKeys.push(w, key);\n\t\t\twhile (cachedPubKeys.size() > MAX_MEMORY_CACHED_PUBKEYS)\n\t\t\t\tcachedPubKeys.popKey();\n\t\t}\n\t\ttry {"}
{"magic_number_smell": "\t\t}, false);\n\t\tmaxPingTime = statsConfig.getLong(\"maxPingTime\");\n\n\t\tstatsConfig.register(\"subMaxPingTime\", MILLISECONDS.toMillis(700), sortOrder++, true, true, \"NodeStat.subMaxPingTime\", \"NodeStat.subMaxPingTimeLong\", new LongCallback() {\n\n\t\t\t@Override\n\t\t\tpublic Long get() {", "refactored_code": "\tpublic static final long DEFAULT_SUB_MAX_PING_TIME = MILLISECONDS.toMillis(700);\n\t\t}, false);\n\t\tmaxPingTime = statsConfig.getLong(\"maxPingTime\");\n\n\t\tstatsConfig.register(\"subMaxPingTime\", DEFAULT_SUB_MAX_PING_TIME, sortOrder++, true, true, \"NodeStat.subMaxPingTime\", \"NodeStat.subMaxPingTimeLong\", new LongCallback() {\n\n\t\t\t@Override\n\t\t\tpublic Long get() {"}
{"magic_number_smell": "\t * @see freenet.node.OpennetManager.LinkLengthClass\n\t */\n\tpublic static final int MAX_PEERS_FOR_SCALING =\n\t\t(int) (AVAILABLE_SHORT_DISTANCE_NODES / 1.0 - LONG_PROPORTION);\n\t/** Maximum number of peers for purposes of FOAF attack/sanity check */\n\tpublic static final int PANIC_MAX_PEERS = MAX_PEERS_FOR_SCALING + 10;\n\t/** Stop trying to reconnect to an old-opennet-peer after a month. */", "refactored_code": "\tpublic static final double SHORT_PROPORTION = 1.0 - LONG_PROPORTION;\n\t * @see freenet.node.OpennetManager.LinkLengthClass\n\t */\n\tpublic static final int MAX_PEERS_FOR_SCALING =\n\t\t(int) (AVAILABLE_SHORT_DISTANCE_NODES / SHORT_PROPORTION);\n\t/** Maximum number of peers for purposes of FOAF attack/sanity check */\n\tpublic static final int PANIC_MAX_PEERS = MAX_PEERS_FOR_SCALING + 10;\n\t/** Stop trying to reconnect to an old-opennet-peer after a month. */"}
{"magic_number_smell": "\t\tsynchronized(this) {\n\t\t\tif(now <= nextOldestNeverConnectedDarknetPeerAgeUpdateTime)\n\t\t\t\treturn;\n\t\t\tnextOldestNeverConnectedDarknetPeerAgeUpdateTime = now + 5000;\n\t\t\tpeerList = myPeers;\n\t\t}\n\t\toldestNeverConnectedDarknetPeerAge = 0;", "refactored_code": "\tprivate static final long oldestNeverConnectedPeerAgeUpdateInterval = 5000;\n\t\tsynchronized(this) {\n\t\t\tif(now <= nextOldestNeverConnectedDarknetPeerAgeUpdateTime)\n\t\t\t\treturn;\n\t\t\tnextOldestNeverConnectedDarknetPeerAgeUpdateTime = now + oldestNeverConnectedPeerAgeUpdateInterval;\n\t\t\tpeerList = myPeers;\n\t\t}\n\t\toldestNeverConnectedDarknetPeerAge = 0;"}
{"magic_number_smell": "\tpublic static final int SELECTION_MIN_PEERS = 5;\n\t// Should be good enough provided we don't get selected more than 10 times per/sec\n\t// Lower the following value if you want to spare memory... or better switch from a TreeSet to a bit field.\n\tpublic static final int SELECTION_MAX_SAMPLES = (int) (10 * SECONDS.convert(MINUTES.toMillis(5), MILLISECONDS));\n\n\t/** Is the peer connected? If currentTracker == null then we have no way to send packets \n\t * (though we may be able to receive them on the other trackers), and are disconnected. So we", "refactored_code": "\tpublic static final long SELECTION_SAMPLING_PERIOD = MINUTES.toMillis(5);\n\tpublic static final int SELECTION_MIN_PEERS = 5;\n\t// Should be good enough provided we don't get selected more than 10 times per/sec\n\t// Lower the following value if you want to spare memory... or better switch from a TreeSet to a bit field.\n\tpublic static final int SELECTION_MAX_SAMPLES = (int) (10 * SECONDS.convert(SELECTION_SAMPLING_PERIOD, MILLISECONDS));\n\n\t/** Is the peer connected? If currentTracker == null then we have no way to send packets \n\t * (though we may be able to receive them on the other trackers), and are disconnected. So we"}
{"magic_number_smell": "\t/** Anything less important than prefetch (redundant??) */\n\tpublic static final short PAUSED_PRIORITY_CLASS = 6;\n\t\n\tpublic static final short NUMBER_OF_PRIORITY_CLASSES = PAUSED_PRIORITY_CLASS - 0 + 1; // include 0 and max !!\n\t\n    public static final short MINIMUM_FETCHABLE_PRIORITY_CLASS = PREFETCH_PRIORITY_CLASS;\n    ", "refactored_code": "\tpublic static final short MAXIMUM_PRIORITY_CLASS = 0;\n\t/** Anything less important than prefetch (redundant??) */\n\tpublic static final short PAUSED_PRIORITY_CLASS = 6;\n\t\n\tpublic static final short NUMBER_OF_PRIORITY_CLASSES = PAUSED_PRIORITY_CLASS - MAXIMUM_PRIORITY_CLASS + 1; // include 0 and max !!\n\t\n    public static final short MINIMUM_FETCHABLE_PRIORITY_CLASS = PREFETCH_PRIORITY_CLASS;\n    "}
{"magic_number_smell": "\t\t\titem.acceptedAnnounce();\n\t\t\titem.setVersion(ver);\n\t\t\titemsByIP.push(addr, item);\n\t\t\twhile(itemsByIP.size() > 100*1000)\n\t\t\t\titemsByIP.popKey();\n\t\t\treturn true;\n\t\t}", "refactored_code": "\tprivate static final int MAX_SIZE = 100*1000;\n\t\t\titem.acceptedAnnounce();\n\t\t\titem.setVersion(ver);\n\t\t\titemsByIP.push(addr, item);\n\t\t\twhile(itemsByIP.size() > MAX_SIZE)\n\t\t\t\titemsByIP.popKey();\n\t\t\treturn true;\n\t\t}"}
{"magic_number_smell": "\t\t}\n\t\tfor(Thread r : early) {\n\t\t\ttry {\n\t\t\t\tr.join(SECONDS.toMillis(100));\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\t// :(\n\t\t\t\t// May as well move on", "refactored_code": "\tprivate static final long TIMEOUT = SECONDS.toMillis(100);\n\t\t}\n\t\tfor(Thread r : early) {\n\t\t\ttry {\n\t\t\t\tr.join(TIMEOUT);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\t// :(\n\t\t\t\t// May as well move on"}
{"magic_number_smell": "\t\t// The node didn't accept the request. So we don't need to send them the data.\n\t\t// However, we do need to wait a bit longer to try to postpone the fatalTimeout().\n\t\t// Somewhat intricate logic to try to avoid fatalTimeout() if at all possible.\n\t\tMessageFilter mf = makeAcceptedRejectedFilter(next, SECONDS.toMillis(60), tag);\n\t\ttry {\n\t\t\tnode.getUSM().addAsyncFilter(mf, new SlowAsyncMessageFilterCallback() {\n", "refactored_code": "\tprivate static final long TIMEOUT_AFTER_ACCEPTEDREJECTED_TIMEOUT = SECONDS.toMillis(60);\n\t\t// The node didn't accept the request. So we don't need to send them the data.\n\t\t// However, we do need to wait a bit longer to try to postpone the fatalTimeout().\n\t\t// Somewhat intricate logic to try to avoid fatalTimeout() if at all possible.\n\t\tMessageFilter mf = makeAcceptedRejectedFilter(next, TIMEOUT_AFTER_ACCEPTEDREJECTED_TIMEOUT, tag);\n\t\ttry {\n\t\t\tnode.getUSM().addAsyncFilter(mf, new SlowAsyncMessageFilterCallback() {\n"}
{"magic_number_smell": "\tpublic void maybeLogStillPresent(long now, Long uid) {\n\t\tif(now - createdTime > RequestTracker.TIMEOUT) {\n\t\t\tsynchronized(this) {\n\t\t\t\tif(now - loggedStillPresent < SECONDS.toMillis(60)) return;\n\t\t\t\tloggedStillPresent = now;\n\t\t\t}\n\t\t\tlogStillPresent(uid);", "refactored_code": "\tprivate static final long LOGGED_STILL_PRESENT_INTERVAL = SECONDS.toMillis(60);\n\tpublic void maybeLogStillPresent(long now, Long uid) {\n\t\tif(now - createdTime > RequestTracker.TIMEOUT) {\n\t\t\tsynchronized(this) {\n\t\t\t\tif(now - loggedStillPresent < LOGGED_STILL_PRESENT_INTERVAL) return;\n\t\t\t\tloggedStillPresent = now;\n\t\t\t}\n\t\t\tlogStillPresent(uid);"}
{"magic_number_smell": "\t *\n\t * @return The build number (not SVN revision number) of this node.\n\t */\n\tpublic static int 1497() {\n\t\treturn 1497;\n\t}\n", "refactored_code": "\tprivate static final int buildNumber = 1497;\n\t *\n\t * @return The build number (not SVN revision number) of this node.\n\t */\n\tpublic static int buildNumber() {\n\t\treturn buildNumber;\n\t}\n"}
{"magic_number_smell": "    /** Initialising with an empty NodeThreadSnapshot to avoid possible race conditions */\n    private final AtomicReference<NodeThreadSnapshot> nodeThreadSnapshot =\n            new AtomicReference<>(\n                    new NodeThreadSnapshot(new ArrayList<>(), 1000)\n            );\n\n    private final ThreadMXBean threadMxBean = ManagementFactory.getThreadMXBean();", "refactored_code": "    private static final int DEFAULT_MONITOR_INTERVAL = 1000;\n    /** Initialising with an empty NodeThreadSnapshot to avoid possible race conditions */\n    private final AtomicReference<NodeThreadSnapshot> nodeThreadSnapshot =\n            new AtomicReference<>(\n                    new NodeThreadSnapshot(new ArrayList<>(), DEFAULT_MONITOR_INTERVAL)\n            );\n\n    private final ThreadMXBean threadMxBean = ManagementFactory.getThreadMXBean();"}
{"magic_number_smell": "\t */\n\tstatic boolean isValid(byte code) {\n\t\t//Assumes codes are consecutive, start at zero, and all are valid.\n\t\treturn code >= 0 && code < Error.values().length;\n\t}\n\n\t/**", "refactored_code": "\tprivate static final int MAX_CODE = Error.values().length;\n\t */\n\tstatic boolean isValid(byte code) {\n\t\t//Assumes codes are consecutive, start at zero, and all are valid.\n\t\treturn code >= 0 && code < MAX_CODE;\n\t}\n\n\t/**"}
{"magic_number_smell": "\n\t/**\n\t * Sends an outgoing probe request.\n\t * @param htl htl for this outgoing probe: should be [1, 70]\n\t * @param listener will be called with results.\n\t * @see Listener\n\t */", "refactored_code": "\tpublic static final byte MAX_HTL = 70;\n\n\t/**\n\t * Sends an outgoing probe request.\n\t * @param htl htl for this outgoing probe: should be [1, MAX_HTL]\n\t * @param listener will be called with results.\n\t * @see Listener\n\t */"}
{"magic_number_smell": "\t * @return true if the code can be converted to an enum value; false if not.\n\t */\n\tstatic boolean isValid(byte code) {\n\t\treturn code >= 0 && code < Type.values().length;\n\t}\n\n\t/**", "refactored_code": "\tprivate static final int MAX_CODE = Type.values().length;\n\t * @return true if the code can be converted to an enum value; false if not.\n\t */\n\tstatic boolean isValid(byte code) {\n\t\treturn code >= 0 && code < MAX_CODE;\n\t}\n\n\t/**"}
{"magic_number_smell": "\t}\t\n\t\n\tprivate static RandomAccessBucket randomData(Node node) throws IOException {\n\t    RandomAccessBucket data = node.getClientCore().getTempBucketFactory().makeBucket(32 * 1024);\n\t\tOutputStream os = data.getOutputStream();\n\t\ttry {\n\t\tbyte[] buf = new byte[4096];", "refactored_code": "\tprivate static final int TEST_SIZE = 32 * 1024;\n\t}\t\n\t\n\tprivate static RandomAccessBucket randomData(Node node) throws IOException {\n\t    RandomAccessBucket data = node.getClientCore().getTempBucketFactory().makeBucket(TEST_SIZE);\n\t\tOutputStream os = data.getOutputStream();\n\t\ttry {\n\t\tbyte[] buf = new byte[4096];"}
{"magic_number_smell": "\t}\t\n\t\n\tprivate static RandomAccessBucket randomData(Node node) throws IOException {\n\t    RandomAccessBucket data = node.getClientCore().getTempBucketFactory().makeBucket(64 * 1024);\n\t\tOutputStream os = data.getOutputStream();\n\t\ttry {\n\t\tbyte[] buf = new byte[4096];", "refactored_code": "\tprivate static final int TEST_SIZE = 64 * 1024;\n\t}\t\n\t\n\tprivate static RandomAccessBucket randomData(Node node) throws IOException {\n\t    RandomAccessBucket data = node.getClientCore().getTempBucketFactory().makeBucket(TEST_SIZE);\n\t\tOutputStream os = data.getOutputStream();\n\t\ttry {\n\t\tbyte[] buf = new byte[4096];"}
{"magic_number_smell": "\t}\n\n\tprivate static RandomAccessBucket randomData(Node node) throws IOException {\n\t    RandomAccessBucket data = node.getClientCore().getTempBucketFactory().makeBucket(64 * 1024);\n\t\tOutputStream os = data.getOutputStream();\n\t\ttry {\n\t\tbyte[] buf = new byte[4096];", "refactored_code": "\tprivate static final int TEST_SIZE = 64 * 1024;\n\t}\n\n\tprivate static RandomAccessBucket randomData(Node node) throws IOException {\n\t    RandomAccessBucket data = node.getClientCore().getTempBucketFactory().makeBucket(TEST_SIZE);\n\t\tOutputStream os = data.getOutputStream();\n\t\ttry {\n\t\tbyte[] buf = new byte[4096];"}
{"magic_number_smell": "\t\n\n\tprivate static RandomAccessBucket randomData(Node node) throws IOException {\n\t    RandomAccessBucket data = node.getClientCore().getTempBucketFactory().makeBucket(64 * 1024);\n\t\tOutputStream os = data.getOutputStream();\n\t\ttry {\n\t\tbyte[] buf = new byte[4096];", "refactored_code": "\tprivate static final int TEST_SIZE = 64 * 1024;\n\t\n\n\tprivate static RandomAccessBucket randomData(Node node) throws IOException {\n\t    RandomAccessBucket data = node.getClientCore().getTempBucketFactory().makeBucket(TEST_SIZE);\n\t\tOutputStream os = data.getOutputStream();\n\t\ttry {\n\t\tbyte[] buf = new byte[4096];"}
{"magic_number_smell": "\t}\n\n\tprivate static RandomAccessBucket randomData(Node node) throws IOException {\n\t    RandomAccessBucket data = node.getClientCore().getTempBucketFactory().makeBucket(64 * 1024);\n\t\tOutputStream os = data.getOutputStream();\n\t\ttry {\n\t\tbyte[] buf = new byte[4096];", "refactored_code": "\tprivate static final int TEST_SIZE = 64 * 1024;\n\t}\n\n\tprivate static RandomAccessBucket randomData(Node node) throws IOException {\n\t    RandomAccessBucket data = node.getClientCore().getTempBucketFactory().makeBucket(TEST_SIZE);\n\t\tOutputStream os = data.getOutputStream();\n\t\ttry {\n\t\tbyte[] buf = new byte[4096];"}
{"magic_number_smell": "        RandomSource random = NodeStarter.globalTestInit(\"pingtest\", false, LogLevel.ERROR, \"\", true);\n        // Create 2 nodes\n        Executor executor = new PooledExecutor();\n        Node node1 = NodeStarter.createTestNode(RealNodeBusyNetworkTest.DARKNET_PORT_END, 0, \"pingtest\", true, Node.DEFAULT_MAX_HTL, 0, random, executor, 1000, 65536, true, false, false, false, false, false, true, 0, false, false, true, false, null);\n        Node node2 = NodeStarter.createTestNode(DARKNET_PORT2, 0, \"pingtest\", true, Node.DEFAULT_MAX_HTL, 0, random, executor, 1000, 65536, true, false, false, false, false, false, true, 0, false, false, true, false, null);\n        // Connect\n        node1.connect(node2, trust, visibility);", "refactored_code": "\tpublic static final int DARKNET_PORT1 = RealNodeBusyNetworkTest.DARKNET_PORT_END;\n        RandomSource random = NodeStarter.globalTestInit(\"pingtest\", false, LogLevel.ERROR, \"\", true);\n        // Create 2 nodes\n        Executor executor = new PooledExecutor();\n        Node node1 = NodeStarter.createTestNode(DARKNET_PORT1, 0, \"pingtest\", true, Node.DEFAULT_MAX_HTL, 0, random, executor, 1000, 65536, true, false, false, false, false, false, true, 0, false, false, true, false, null);\n        Node node2 = NodeStarter.createTestNode(DARKNET_PORT2, 0, \"pingtest\", true, Node.DEFAULT_MAX_HTL, 0, random, executor, 1000, 65536, true, false, false, false, false, false, true, 0, false, false, true, false, null);\n        // Connect\n        node1.connect(node2, trust, visibility);"}
{"magic_number_smell": "\n\t\t// start the nodes and adjust mitigation times\n\t\tnodes[0].getLocationManager().PITCH_BLACK_MITIGATION_FREQUENCY_ONE_DAY = PITCH_BLACK_MITIGATION_FREQUENCY_ONE_DAY;\n\t\tnodes[0].getLocationManager().MINUTES.toMillis(1) = MINUTES.toMillis(1);\n\t\tfor (int i = 0; i < NUMBER_OF_NODES; i++) {\n\t\t\tSystem.err.println(\"Starting node \" + i);\n\t\t\tnodes[i].start(false);", "refactored_code": "\tpublic static final long PITCH_BLACK_MITIGATION_STARTUP_DELAY = MINUTES.toMillis(1);\n\n\t\t// start the nodes and adjust mitigation times\n\t\tnodes[0].getLocationManager().PITCH_BLACK_MITIGATION_FREQUENCY_ONE_DAY = PITCH_BLACK_MITIGATION_FREQUENCY_ONE_DAY;\n\t\tnodes[0].getLocationManager().PITCH_BLACK_MITIGATION_STARTUP_DELAY = PITCH_BLACK_MITIGATION_STARTUP_DELAY;\n\t\tfor (int i = 0; i < NUMBER_OF_NODES; i++) {\n\t\t\tSystem.err.println(\"Starting node \" + i);\n\t\t\tnodes[i].start(false);"}
{"magic_number_smell": "    static final int BWLIMIT = 1000*1024;\n    \n    //public static final int RealNodePingTest.DARKNET_PORT2+1 = RealNodePingTest.DARKNET_PORT2+1;\n    public static final int RealNodePingTest.DARKNET_PORT2+1 = 10000;\n    public static final int DARKNET_PORT_END = RealNodePingTest.DARKNET_PORT2+1 + NUMBER_OF_NODES;\n    \n\tpublic static void main(String[] args) throws FSParseException, PeerParseException, CHKEncodeException, InvalidThresholdException, NodeInitException, ReferenceSignatureVerificationException, InterruptedException {", "refactored_code": "    //public static final int DARKNET_PORT_BASE = RealNodePingTest.DARKNET_PORT2+1;\n    static final int BWLIMIT = 1000*1024;\n    \n    //public static final int DARKNET_PORT_BASE = RealNodePingTest.DARKNET_PORT2+1;\n    public static final int DARKNET_PORT_BASE = 10000;\n    public static final int DARKNET_PORT_END = DARKNET_PORT_BASE + NUMBER_OF_NODES;\n    \n\tpublic static void main(String[] args) throws FSParseException, PeerParseException, CHKEncodeException, InvalidThresholdException, NodeInitException, ReferenceSignatureVerificationException, InterruptedException {"}
{"magic_number_smell": "\tstatic final FRIEND_VISIBILITY visibility = FRIEND_VISIBILITY.NO;\n\n    public static final int RealNodePingTest.DARKNET_PORT_END = RealNodePingTest.DARKNET_PORT_END;\n    public static final int DARKNET_PORT_END = RealNodePingTest.DARKNET_PORT_END + NUMBER_OF_NODES;\n    \n    public static void main(String[] args) throws FSParseException, PeerParseException, CHKEncodeException, InvalidThresholdException, NodeInitException, ReferenceSignatureVerificationException, KeyCollisionException, SSKEncodeException, IOException, InterruptedException, SSKVerifyException, InvalidCompressionCodecException, PeerTooOldException {\n        System.err.println(\"ULPR test\");", "refactored_code": "    public static final int DARKNET_PORT_BASE = RealNodePingTest.DARKNET_PORT_END;\n\tstatic final FRIEND_VISIBILITY visibility = FRIEND_VISIBILITY.NO;\n\n    public static final int DARKNET_PORT_BASE = RealNodePingTest.DARKNET_PORT_END;\n    public static final int DARKNET_PORT_END = DARKNET_PORT_BASE + NUMBER_OF_NODES;\n    \n    public static void main(String[] args) throws FSParseException, PeerParseException, CHKEncodeException, InvalidThresholdException, NodeInitException, ReferenceSignatureVerificationException, KeyCollisionException, SSKEncodeException, IOException, InterruptedException, SSKVerifyException, InvalidCompressionCodecException, PeerTooOldException {\n        System.err.println(\"ULPR test\");"}
{"magic_number_smell": "\t\tlong started = updateManager.getStartedFetchingNextMainJarTimestamp();\n\t\tlong whenToTakeOverTheNormalUpdater;\n\t\tif(started > 0)\n\t\t\twhenToTakeOverTheNormalUpdater = started + HOURS.toMillis(3);\n\t\telse\n\t\t\twhenToTakeOverTheNormalUpdater = System.currentTimeMillis() + HOURS.toMillis(3);\n\t\tboolean isOutdated = updateManager.getNode().isOudated();", "refactored_code": "\tpublic static final long GRACE_TIME = HOURS.toMillis(3);\n\t\tlong started = updateManager.getStartedFetchingNextMainJarTimestamp();\n\t\tlong whenToTakeOverTheNormalUpdater;\n\t\tif(started > 0)\n\t\t\twhenToTakeOverTheNormalUpdater = started + GRACE_TIME;\n\t\telse\n\t\t\twhenToTakeOverTheNormalUpdater = System.currentTimeMillis() + GRACE_TIME;\n\t\tboolean isOutdated = updateManager.getNode().isOudated();"}
{"magic_number_smell": "\t\t\t\t\treturn l10n(\"noPeersTitle\");\n\t\t\t\tif(conns == 0)\n\t\t\t\t\treturn l10n(\"noConnsTitle\");\n\t\t\t\tif(conns < 3)\n\t\t\t\t\treturn l10n(\"onlyFewConnsTitle\", \"count\", Integer.toString(conns));\n\t\t\t}\n\t\t\tif(bwlimitDelayAlertRelevant && (bwlimitDelayTime > NodeStats.MAX_BWLIMIT_DELAY_TIME_ALERT_THRESHOLD))", "refactored_code": "\tpublic static final int MIN_CONN_ALERT_THRESHOLD = 3;\n\t\t\t\t\treturn l10n(\"noPeersTitle\");\n\t\t\t\tif(conns == 0)\n\t\t\t\t\treturn l10n(\"noConnsTitle\");\n\t\t\t\tif(conns < MIN_CONN_ALERT_THRESHOLD)\n\t\t\t\t\treturn l10n(\"onlyFewConnsTitle\", \"count\", Integer.toString(conns));\n\t\t\t}\n\t\t\tif(bwlimitDelayAlertRelevant && (bwlimitDelayTime > NodeStats.MAX_BWLIMIT_DELAY_TIME_ALERT_THRESHOLD))"}
{"magic_number_smell": "\tpublic static final int 300000 = 300000;\n\t// FIXME is static the best way to do this? It seems simplest at least...\n\t/** -1 = write immediately, 0 = write only on shutdown, +ve = write period in millis */\n\tprivate static int globalPersistenceTime = 300000;\n\tprivate Ticker ticker;\n\t/** Is the buffer dirty? Protected by (this). */\n\tprivate boolean dirty;", "refactored_code": "\tpublic static final int DEFAULT_PERSISTENCE_TIME = 300000;\n\tpublic static final int DEFAULT_PERSISTENCE_TIME = 300000;\n\t// FIXME is static the best way to do this? It seems simplest at least...\n\t/** -1 = write immediately, 0 = write only on shutdown, +ve = write period in millis */\n\tprivate static int globalPersistenceTime = DEFAULT_PERSISTENCE_TIME;\n\tprivate Ticker ticker;\n\t/** Is the buffer dirty? Protected by (this). */\n\tprivate boolean dirty;"}
{"magic_number_smell": "\t\t\tslotFilter = null;\n\t\t}\n\n\t\tif ((flags & 0x1) != 0)\n\t\t\tSystem.err.println(\"Datastore(\" + name + \") is dirty.\");\n\n\t\tflags |= 0x1; // datastore is now dirty until flushAndClose()", "refactored_code": "\tprivate static final byte FLAG_DIRTY = 0x1;\n\t\t\tslotFilter = null;\n\t\t}\n\n\t\tif ((flags & FLAG_DIRTY) != 0)\n\t\t\tSystem.err.println(\"Datastore(\" + name + \") is dirty.\");\n\n\t\tflags |= FLAG_DIRTY; // datastore is now dirty until flushAndClose()"}
{"magic_number_smell": "\t}\n\n\tpublic synchronized static void error(Class<?> c, String s) {\n\t\tlogger.log(c, s, LogLevel.LogLevel.ERROR.ordinal());\n\t}\n\n\tpublic synchronized static void error(Class<?> c, String s, Throwable t) {", "refactored_code": "\tpublic static final int ERROR = LogLevel.ERROR.ordinal();\n\t}\n\n\tpublic synchronized static void error(Class<?> c, String s) {\n\t\tlogger.log(c, s, LogLevel.ERROR);\n\t}\n\n\tpublic synchronized static void error(Class<?> c, String s, Throwable t) {"}
{"magic_number_smell": "            \n            @Override\n            public int getPriority() {\n                return NativeThread.LOW_PRIORITY;\n            }\n            \n        });", "refactored_code": "    public static final int THREAD_PRIORITY = NativeThread.LOW_PRIORITY;\n            \n            @Override\n            public int getPriority() {\n                return THREAD_PRIORITY;\n            }\n            \n        });"}
{"magic_number_smell": "\t}\n\n\tpublic PrioritizedSerialExecutor(int priority, int internalPriorityCount, int defaultPriority, boolean invertOrder) {\n\t\tthis(priority, internalPriorityCount, defaultPriority, invertOrder, MINUTES.toMillis(5), null, null);\n\t}\n\n\tpublic void start(Executor realExecutor, String name) {", "refactored_code": "\tprivate static final long DEFAULT_JOB_TIMEOUT = MINUTES.toMillis(5);\n\t}\n\n\tpublic PrioritizedSerialExecutor(int priority, int internalPriorityCount, int defaultPriority, boolean invertOrder) {\n\t\tthis(priority, internalPriorityCount, defaultPriority, invertOrder, DEFAULT_JOB_TIMEOUT, null, null);\n\t}\n\n\tpublic void start(Executor realExecutor, String name) {"}
{"magic_number_smell": "\t\t\t\t}\n\t\t\t\tRunnable job = null;\n\t\t\t\t\t\ttry {\n\t\t\t\t\tjob = jobs.poll(MINUTES.toMillis(5), TimeUnit.MILLISECONDS);\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t// ignore\n\t\t\t\t\t\t}", "refactored_code": "\tprivate static final long NEWJOB_TIMEOUT = MINUTES.toMillis(5);\n\t\t\t\t}\n\t\t\t\tRunnable job = null;\n\t\t\t\t\t\ttry {\n\t\t\t\t\tjob = jobs.poll(NEWJOB_TIMEOUT, TimeUnit.MILLISECONDS);\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t// ignore\n\t\t\t\t\t\t}"}
{"magic_number_smell": "\t\t} else if (type.equals(Peer.class)) {\n\t\t\treturn new Peer(dis);\n\t\t} else if (type.equals(BitArray.class)) {\n\t\t\treturn new BitArray(dis, 2048*8);\n\t\t} else if (type.equals(NodeCHK.class)) {\n\t\t\t// Use Key.read(...) rather than NodeCHK-specific method because write(...) writes the TYPE field.\n\t\t\treturn Key.read(dis);", "refactored_code": "\tpublic static final int MAX_BITARRAY_SIZE = 2048*8;\n\t\t} else if (type.equals(Peer.class)) {\n\t\t\treturn new Peer(dis);\n\t\t} else if (type.equals(BitArray.class)) {\n\t\t\treturn new BitArray(dis, MAX_BITARRAY_SIZE);\n\t\t} else if (type.equals(NodeCHK.class)) {\n\t\t\t// Use Key.read(...) rather than NodeCHK-specific method because write(...) writes the TYPE field.\n\t\t\treturn Key.read(dis);"}
{"magic_number_smell": "\t\n    @Override\n    public void storeTo(DataOutputStream dos) throws IOException {\n        dos.writeInt(0xc4b7533d);\n        dos.writeInt(VERSION);\n        dos.writeBoolean(freed);\n    }", "refactored_code": "\tpublic static final int MAGIC = 0xc4b7533d;\n\t\n    @Override\n    public void storeTo(DataOutputStream dos) throws IOException {\n        dos.writeInt(MAGIC);\n        dos.writeInt(VERSION);\n        dos.writeBoolean(freed);\n    }"}
{"magic_number_smell": "\t\ttry {\n\n\t\t// No benefit to allocateDirect() as we're wrapping streams anyway, and worse, it'd be a memory leak.\n\t\tByteBuffer buffer = ByteBuffer.allocate(64 * 1024);\n\t\twhile (readChannel.read(buffer) != -1) {\n\t\t\tbuffer.flip();\n\t\t\twhile(buffer.hasRemaining())", "refactored_code": "\tprivate static final int BUFFER_SIZE = 64 * 1024;\n\t\ttry {\n\n\t\t// No benefit to allocateDirect() as we're wrapping streams anyway, and worse, it'd be a memory leak.\n\t\tByteBuffer buffer = ByteBuffer.allocate(BUFFER_SIZE);\n\t\twhile (readChannel.read(buffer) != -1) {\n\t\t\tbuffer.flip();\n\t\t\twhile(buffer.hasRemaining())"}
{"magic_number_smell": "\n        // check ram limitations\n        long maxMemory = NodeStarter.getMemoryLimitBytes();\n        if (maxMemory == Long.MAX_VALUE || maxMemory < 128 * 1024 * 1024) {\n            maxDatastoreSize = oneGiB; // 1GB default if don't know or very small memory.\n        } else {\n            // Don't use the first 100MB for slot filters.", "refactored_code": "    public static final long oneMiB = 1024 * 1024;\n\n        // check ram limitations\n        long maxMemory = NodeStarter.getMemoryLimitBytes();\n        if (maxMemory == Long.MAX_VALUE || maxMemory < 128 * oneMiB) {\n            maxDatastoreSize = oneGiB; // 1GB default if don't know or very small memory.\n        } else {\n            // Don't use the first 100MB for slot filters."}
{"magic_number_smell": "\n  public Fallocate keepSize() {\n    requireLinux(\"fallocate keep size\");\n    mode |= 0x01;\n    return this;\n  }\n", "refactored_code": "  private static final int FALLOC_FL_KEEP_SIZE = 0x01;\n\n  public Fallocate keepSize() {\n    requireLinux(\"fallocate keep size\");\n    mode |= FALLOC_FL_KEEP_SIZE;\n    return this;\n  }\n"}
{"magic_number_smell": "\t */\n\tpublic static long findLength(InputStream source) throws IOException {\n\t\tlong length = 0;\n\t\tbyte[] buffer = new byte[32*1024];\n\t\tint read = 0;\n\t\twhile (read > -1) {\n\t\t\tread = source.read(buffer);", "refactored_code": "\tpublic static final int BUFFER_SIZE = 32*1024;\n\t */\n\tpublic static long findLength(InputStream source) throws IOException {\n\t\tlong length = 0;\n\t\tbyte[] buffer = new byte[BUFFER_SIZE];\n\t\tint read = 0;\n\t\twhile (read > -1) {\n\t\t\tread = source.read(buffer);"}
{"magic_number_smell": "\n\tclass ReaderBucket implements Bucket, Serializable {\n\t\t\n        private static final long 1L = 1L;\n        private boolean freed;\n\n\t\t@Override", "refactored_code": "    private static final long serialVersionUID = 1L;\n\n\tclass ReaderBucket implements Bucket, Serializable {\n\t\t\n        private static final long serialVersionUID = 1L;\n        private boolean freed;\n\n\t\t@Override"}
{"magic_number_smell": "\t\t\t// they are 3 main prio levels\n\t\t\tHAS_THREE_NICE_LEVELS = NATIVE_PRIORITY_RANGE >= 3;\n\t\t\tHAS_ENOUGH_NICE_LEVELS = NATIVE_PRIORITY_RANGE >= ENOUGH_NICE_LEVELS;\n\t\t\tHAS_PLENTY_NICE_LEVELS = NATIVE_PRIORITY_RANGE >=Thread.MAX_PRIORITY - Thread.MIN_PRIORITY;\n\t\t\tif(!(HAS_ENOUGH_NICE_LEVELS && HAS_THREE_NICE_LEVELS))\n\t\t\t\tSystem.err.println(\"WARNING!!! The JVM has been niced down to a level which won't allow it to schedule threads properly! LOWER THE NICE LEVEL!!\");\n\t\t\t_loadNative = true;", "refactored_code": "\tpublic static final int JAVA_PRIORITY_RANGE = Thread.MAX_PRIORITY - Thread.MIN_PRIORITY;\n\t\t\t// they are 3 main prio levels\n\t\t\tHAS_THREE_NICE_LEVELS = NATIVE_PRIORITY_RANGE >= 3;\n\t\t\tHAS_ENOUGH_NICE_LEVELS = NATIVE_PRIORITY_RANGE >= ENOUGH_NICE_LEVELS;\n\t\t\tHAS_PLENTY_NICE_LEVELS = NATIVE_PRIORITY_RANGE >=JAVA_PRIORITY_RANGE;\n\t\t\tif(!(HAS_ENOUGH_NICE_LEVELS && HAS_THREE_NICE_LEVELS))\n\t\t\t\tSystem.err.println(\"WARNING!!! The JVM has been niced down to a level which won't allow it to schedule threads properly! LOWER THE NICE LEVEL!!\");\n\t\t\t_loadNative = true;"}
{"magic_number_smell": "\n\tpublic static class ReadOnlyFileSliceBucketException extends IOException {\n\n\t\tprivate static final long 1L = -1;\n\n\t\tpublic ReadOnlyFileSliceBucketException(FileNotFoundException e) {\n\t\t\tsuper(\"File not found: \" + e.getMessage());", "refactored_code": "    private static final long serialVersionUID = 1L;\n\n\tpublic static class ReadOnlyFileSliceBucketException extends IOException {\n\n\t\tprivate static final long serialVersionUID = -1;\n\n\t\tpublic ReadOnlyFileSliceBucketException(FileNotFoundException e) {\n\t\t\tsuper(\"File not found: \" + e.getMessage());"}
{"magic_number_smell": "public class SkipShieldingInputStream extends FilterInputStream {\n    private static final int 8192 = 8192;\n    // we can use a shared buffer as the content is discarded anyway\n    private static final byte[] SKIP_BUFFER = new byte[8192];\n    public SkipShieldingInputStream(InputStream in) {\n        super(in);\n    }", "refactored_code": "    private static final int SKIP_BUFFER_SIZE = 8192;\npublic class SkipShieldingInputStream extends FilterInputStream {\n    private static final int SKIP_BUFFER_SIZE = 8192;\n    // we can use a shared buffer as the content is discarded anyway\n    private static final byte[] SKIP_BUFFER = new byte[SKIP_BUFFER_SIZE];\n    public SkipShieldingInputStream(InputStream in) {\n        super(in);\n    }"}
{"magic_number_smell": "    private static final int TEMPERING_MASK_C = 0xefc60000;\n    \n    private int mt[]; // the array for the state vector\n    private int mti; // mti==624+1 means mt[624] is not initialized\n    private int mag01[];\n    \n    // a good initial seed (of int size, though stored in a long)", "refactored_code": "    private static final int N = 624;\n    private static final int TEMPERING_MASK_C = 0xefc60000;\n    \n    private int mt[]; // the array for the state vector\n    private int mti; // mti==N+1 means mt[N] is not initialized\n    private int mag01[];\n    \n    // a good initial seed (of int size, though stored in a long)"}
{"magic_number_smell": "     * contains the permutation entry.\n     */\n    private static void encodeDecode(FECCode encode, FECCode decode, int[] index) {\n        byte[] src = new byte[192 * PACKET_SIZE];\n        Util.rand.nextBytes(src);\n        Buffer[] srcBufs = createBuffers(src);\n", "refactored_code": "    public static final int KK = 192;\n     * contains the permutation entry.\n     */\n    private static void encodeDecode(FECCode encode, FECCode decode, int[] index) {\n        byte[] src = new byte[KK * PACKET_SIZE];\n        Util.rand.nextBytes(src);\n        Buffer[] srcBufs = createBuffers(src);\n"}
{"magic_number_smell": "        int data = 128;\n        int check = 128;\n        originalDataBlocks = createOriginalDataBlocks(random, data);\n        originalDataBlocks[data - 1] = new byte[4096 / 2];\n        checkBlocks = setupCheckBlocks(check);\n        dataBlocks = copy(originalDataBlocks);\n", "refactored_code": "    private static final int BLOCK_SIZE = 4096;\n        int data = 128;\n        int check = 128;\n        originalDataBlocks = createOriginalDataBlocks(random, data);\n        originalDataBlocks[data - 1] = new byte[BLOCK_SIZE / 2];\n        checkBlocks = setupCheckBlocks(check);\n        dataBlocks = copy(originalDataBlocks);\n"}
{"magic_number_smell": "        }\n\n        static TestSplitfile constructSingleSegment(long size, int checkBlocks, boolean persistent) throws IOException, CHKEncodeException, MetadataUnresolvedException, MetadataParseException {\n            assertTrue(checkBlocks <= 256);\n            assertTrue(size < 256 * (long) BLOCK_SIZE);\n            Bucket data = makeRandomBucket(size);\n            byte[][] originalDataBlocks = splitAndPadBlocks(data, size);", "refactored_code": "    private static final int MAX_SEGMENT_SIZE = 256;\n        }\n\n        static TestSplitfile constructSingleSegment(long size, int checkBlocks, boolean persistent) throws IOException, CHKEncodeException, MetadataUnresolvedException, MetadataParseException {\n            assertTrue(checkBlocks <= MAX_SEGMENT_SIZE);\n            assertTrue(size < MAX_SEGMENT_SIZE * (long) BLOCK_SIZE);\n            Bucket data = makeRandomBucket(size);\n            byte[][] originalDataBlocks = splitAndPadBlocks(data, size);"}
{"magic_number_smell": "public class HMAC_legacy {\n\n\tprotected static final int 64 = 64;\n\tprotected static byte[] ipad = new byte[64];\n\tprotected static byte[] opad = new byte[64];\n\n\tstatic {", "refactored_code": "\tprotected static final int B = 64;\npublic class HMAC_legacy {\n\n\tprotected static final int B = 64;\n\tprotected static byte[] ipad = new byte[B];\n\tprotected static byte[] opad = new byte[B];\n\n\tstatic {"}
{"magic_number_smell": "\n    @Test\n    public void testGenNonceLength() {\n        assertEquals(KeyGenUtils.genNonce(16).capacity(), 16);\n    }\n\n    @Test (expected = NegativeArraySizeException.class)", "refactored_code": "    private static final int trueLength = 16;\n\n    @Test\n    public void testGenNonceLength() {\n        assertEquals(KeyGenUtils.genNonce(trueLength).capacity(), trueLength);\n    }\n\n    @Test (expected = NegativeArraySizeException.class)"}
{"magic_number_smell": "//\t\tYarrow y = new Yarrow(SEED_FILE, \"SHA1\", \"Rijndael\", false, false, false);\n//\t\tMessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n//\n//\t\tbyte[] bytes = new byte[624];\n//\n//\t\ty.nextBytes(bytes);\n//\t\tmd.update(bytes);", "refactored_code": "\tprivate static final int SEED_SIZE = 624;\n//\t\tYarrow y = new Yarrow(SEED_FILE, \"SHA1\", \"Rijndael\", false, false, false);\n//\t\tMessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n//\n//\t\tbyte[] bytes = new byte[SEED_SIZE];\n//\n//\t\ty.nextBytes(bytes);\n//\t\tmd.update(bytes);"}
{"magic_number_smell": "    @Test\n    public void testDistance() {\n        // Simple cases.\n        assertEquals(DIST_12, Location.distance(VALID_1, VALID_2), 1e-12);\n        assertEquals(DIST_12, Location.distance(VALID_2, VALID_1), 1e-12);\n        \n        // Corner case.", "refactored_code": "    private static final double EPSILON = 1e-12;\n    @Test\n    public void testDistance() {\n        // Simple cases.\n        assertEquals(DIST_12, Location.distance(VALID_1, VALID_2), EPSILON);\n        assertEquals(DIST_12, Location.distance(VALID_2, VALID_1), EPSILON);\n        \n        // Corner case."}
{"magic_number_smell": "            for (double target : TARGET_LOCATIONS) {\n                int closest = PeerLocation.findClosestLocation(peers, target);\n                double ref = trivialFindClosestDistance(peers, target);\n                assertEquals(ref, Location.distance(peers[closest], target), 1e-15);\n            }\n        }\n    }", "refactored_code": "    private static final double EPSILON = 1e-15;\n            for (double target : TARGET_LOCATIONS) {\n                int closest = PeerLocation.findClosestLocation(peers, target);\n                double ref = trivialFindClosestDistance(peers, target);\n                assertEquals(ref, Location.distance(peers[closest], target), EPSILON);\n            }\n        }\n    }"}
{"magic_number_smell": "\n\tprivate static final int TestProperty.EXTENSIVE ? 100 : 20 = TestProperty.EXTENSIVE ? 100 : 20;\n\tprivate static final int ACCEPTABLE_FALSE_POSITIVES = TestProperty.EXTENSIVE ? 5 : 2;\n\tprivate static final int STORE_SIZE = TestProperty.EXTENSIVE ? 100 : 20 * 5;\n\tprivate static final File TEMP_DIR = new File(\"tmp-SaltedHashSlotFilterTest\");\n\n\tprivate Random weakPRNG = new Random(12340);", "refactored_code": "\tprivate static final int TEST_COUNT = TestProperty.EXTENSIVE ? 100 : 20;\n\n\tprivate static final int TEST_COUNT = TestProperty.EXTENSIVE ? 100 : 20;\n\tprivate static final int ACCEPTABLE_FALSE_POSITIVES = TestProperty.EXTENSIVE ? 5 : 2;\n\tprivate static final int STORE_SIZE = TEST_COUNT * 5;\n\tprivate static final File TEMP_DIR = new File(\"tmp-SaltedHashSlotFilterTest\");\n\n\tprivate Random weakPRNG = new Random(12340);"}
{"magic_number_smell": "\t */\n\t@Test\n\tpublic void testBitArray_int() {\n\t\tBitArray methodBitArray = new BitArray(10);\n\t\tfor(int i=0;i<10;i++)\n\t\t\tassertFalse(methodBitArray.bitAt(i));\n\t\tassertEquals(methodBitArray.getSize(),10);", "refactored_code": "\tprivate final int sampleBitsNumber = 10;\n\t */\n\t@Test\n\tpublic void testBitArray_int() {\n\t\tBitArray methodBitArray = new BitArray(sampleBitsNumber);\n\t\tfor(int i=0;i<sampleBitsNumber;i++)\n\t\t\tassertFalse(methodBitArray.bitAt(i));\n\t\tassertEquals(methodBitArray.getSize(),sampleBitsNumber);"}
{"magic_number_smell": "\n\t@Test\n\tpublic void testCountingFilterPositive() {\n\t\tint K = BloomFilter.optimialK(4 * 1024, PASS_POS);\n\t\tBloomFilter filter = BloomFilter.createFilter(4 * 1024, K, true);\n\t\t_testFilterPositive(filter);\n\t}", "refactored_code": "\tprivate static final int FILTER_SIZE = 4 * 1024; // MUST be > PASS,\n\n\t@Test\n\tpublic void testCountingFilterPositive() {\n\t\tint K = BloomFilter.optimialK(FILTER_SIZE, PASS_POS);\n\t\tBloomFilter filter = BloomFilter.createFilter(FILTER_SIZE, K, true);\n\t\t_testFilterPositive(filter);\n\t}"}
{"magic_number_smell": "\t */\n\t@Test\n\tpublic void testPushNull() {\n\t\tLRUMap<Object, Object> methodLRUht = createSampleHashTable(100);\n\t\ttry {\n\t\t\t//a null value is admitted\n\t\t\tmethodLRUht.push(new Object(),null);}\t\t", "refactored_code": "\tprivate static final int sampleElemsNumber = 100;\n\t */\n\t@Test\n\tpublic void testPushNull() {\n\t\tLRUMap<Object, Object> methodLRUht = createSampleHashTable(sampleElemsNumber);\n\t\ttry {\n\t\t\t//a null value is admitted\n\t\t\tmethodLRUht.push(new Object(),null);}\t\t"}
{"magic_number_smell": "\t */\n\t@Test\n\tpublic void testPushNull() {\n\t\tLRUQueue<Object> methodLRUQueue = this.createSampleQueue(100);\n\t\ttry {\n\t\t\tmethodLRUQueue.push(null);\n\t\t\tfail(\"Expected Exception Error Not Thrown!\"); }", "refactored_code": "\tprivate static final int sampleElemsNumber = 100;\n\t */\n\t@Test\n\tpublic void testPushNull() {\n\t\tLRUQueue<Object> methodLRUQueue = this.createSampleQueue(sampleElemsNumber);\n\t\ttry {\n\t\t\tmethodLRUQueue.push(null);\n\t\t\tfail(\"Expected Exception Error Not Thrown!\"); }"}
{"magic_number_smell": "    private MultiValueTable<Object, Object> fillMultiValueTable(Object[][] sampleObjects) {\n\t\tMultiValueTable<Object, Object> methodMVTable = new MultiValueTable<Object, Object>();\n\t\tIterator<Object> itr;\n\t\tfor(int i=0;i<100;i++) {\n\t\t\titr = ((List<Object>)(sampleObjects[i][1])).iterator();\n\t\t\twhile( itr.hasNext())\n\t\t\t\tmethodMVTable.put(sampleObjects[i][0], itr.next());", "refactored_code": "\tprivate static final int sampleKeyNumber = 100;\n    private MultiValueTable<Object, Object> fillMultiValueTable(Object[][] sampleObjects) {\n\t\tMultiValueTable<Object, Object> methodMVTable = new MultiValueTable<Object, Object>();\n\t\tIterator<Object> itr;\n\t\tfor(int i=0;i<sampleKeyNumber;i++) {\n\t\t\titr = ((List<Object>)(sampleObjects[i][1])).iterator();\n\t\t\twhile( itr.hasNext())\n\t\t\t\tmethodMVTable.put(sampleObjects[i][0], itr.next());"}
{"magic_number_smell": "\n    @Before\n    public void setUp() {\n        Integer[] objects = new Integer[100];\n        for (int i = 0; i < 100; i++) {\n            objects[i] = i;\n        }", "refactored_code": "    private static final int NUM_ELEMENTS = 100;\n\n    @Before\n    public void setUp() {\n        Integer[] objects = new Integer[NUM_ELEMENTS];\n        for (int i = 0; i < NUM_ELEMENTS; i++) {\n            objects[i] = i;\n        }"}
{"magic_number_smell": "    public void testMaxSize() {\n        SentTimeCache c = newCache();\n        fillWithSequence(c);\n        c.sent(32 + 1);\n        assertEquals(c.size(), 32);\n    }\n", "refactored_code": "    private static final int CACHE_SIZE = 32;\n    public void testMaxSize() {\n        SentTimeCache c = newCache();\n        fillWithSequence(c);\n        c.sent(CACHE_SIZE + 1);\n        assertEquals(c.size(), CACHE_SIZE);\n    }\n"}
{"magic_number_smell": "\t\tis = new ByteArrayInputStream(LENGTH_CHECKING_LINE.getBytes());\n\t\tinstance = new LineReadingInputStream(is);\n\t\ttry {\n\t\t\tinstance.readLineWithoutMarking(3 - 1, BUFFER_SIZE, true);\n\t\t\tfail();\n\t\t} catch (TooLongException e) {}\n\t\t", "refactored_code": "\tpublic static final int LENGTH_CHECKING_LINE_LF = 3;\n\t\tis = new ByteArrayInputStream(LENGTH_CHECKING_LINE.getBytes());\n\t\tinstance = new LineReadingInputStream(is);\n\t\ttry {\n\t\t\tinstance.readLineWithoutMarking(LENGTH_CHECKING_LINE_LF - 1, BUFFER_SIZE, true);\n\t\t\tfail();\n\t\t} catch (TooLongException e) {}\n\t\t"}
{"magic_number_smell": "        int x = 0;\n        // Write (and check as go)\n        while(x < sz) {\n            int maxRead = (int)Math.min(65536, sz - x);\n            int toRead = maxRead == 1 ? 1 : r.nextInt(maxRead-1)+1;\n            byte[] buf = new byte[toRead];\n            for(int i=0;i<buf.length;i++) buf[i] = f.getByte(i+x);", "refactored_code": "    private static final int BUFFER_SIZE = 65536;\n        int x = 0;\n        // Write (and check as go)\n        while(x < sz) {\n            int maxRead = (int)Math.min(BUFFER_SIZE, sz - x);\n            int toRead = maxRead == 1 ? 1 : r.nextInt(maxRead-1)+1;\n            byte[] buf = new byte[toRead];\n            for(int i=0;i<buf.length;i++) buf[i] = f.getByte(i+x);"}
{"magic_number_smell": "\n\t\t@Test\n\t\tpublic void testRamLimitCreate() throws IOException {\n\t\t\tTempBucketFactory tbf = new TempBucketFactory(exec, fg, 16, 128, weakPRNG, false, 2*1024*1024, secret);\n\n\t\t\tint maxRamBucket = 128 / 16;\n", "refactored_code": "    private static final long MIN_DISK_SPACE = 2*1024*1024;\n\n\t\t@Test\n\t\tpublic void testRamLimitCreate() throws IOException {\n\t\t\tTempBucketFactory tbf = new TempBucketFactory(exec, fg, 16, 128, weakPRNG, false, MIN_DISK_SPACE, secret);\n\n\t\t\tint maxRamBucket = 128 / 16;\n"}
{"magic_number_smell": "\n\t// Should be sufficient for testing MT\n\tprivate static final int 624 = 624;\n\tprivate static final int[] INT_SEED = new int[624];\n\tprivate static final byte[] BYTE_SEED;\n\n\tstatic {", "refactored_code": "\tprivate static final int SEED_SIZE = 624;\n\n\t// Should be sufficient for testing MT\n\tprivate static final int SEED_SIZE = 624;\n\tprivate static final int[] INT_SEED = new int[SEED_SIZE];\n\tprivate static final byte[] BYTE_SEED;\n\n\tstatic {"}
{"magic_number_smell": "\n        protected long version()\n        {\n            return 0;\n        }\n\n        protected String type()", "refactored_code": "    public static final long CURRENT_VERSION = 0;\n\n        protected long version()\n        {\n            return CURRENT_VERSION;\n        }\n\n        protected String type()"}
{"magic_number_smell": "    public static KeyspaceMetadata metadata()\n    {\n        return KeyspaceMetadata.create(SchemaConstants.AUTH_KEYSPACE_NAME,\n                                       KeyspaceParams.simple(Math.max(CassandraRelevantProperties.SYSTEM_AUTH_DEFAULT_RF.getInt(), DatabaseDescriptor.getDefaultKeyspaceRF())),\n                                       Tables.of(Roles, RoleMembers, RolePermissions,\n                                                 ResourceRoleIndex, NetworkPermissions,\n                                                 CIDRPermissions, CIDRGroups, IdentityToRoles));", "refactored_code": "    public static final int DEFAULT_RF = CassandraRelevantProperties.SYSTEM_AUTH_DEFAULT_RF.getInt();\n    public static KeyspaceMetadata metadata()\n    {\n        return KeyspaceMetadata.create(SchemaConstants.AUTH_KEYSPACE_NAME,\n                                       KeyspaceParams.simple(Math.max(DEFAULT_RF, DatabaseDescriptor.getDefaultKeyspaceRF())),\n                                       Tables.of(Roles, RoleMembers, RolePermissions,\n                                                 ResourceRoleIndex, NetworkPermissions,\n                                                 CIDRPermissions, CIDRGroups, IdentityToRoles));"}
{"magic_number_smell": "\n    private static String hashpw(String password)\n    {\n        return BCrypt.hashpw(password, BCrypt.gensalt(getGensaltLogRounds()));\n    }\n\n    private static String escape(String name)", "refactored_code": "    private static final int GENSALT_LOG2_ROUNDS = getGensaltLogRounds();\n\n    private static String hashpw(String password)\n    {\n        return BCrypt.hashpw(password, BCrypt.gensalt(GENSALT_LOG2_ROUNDS));\n    }\n\n    private static String escape(String name)"}
{"magic_number_smell": "                                               SchemaConstants.AUTH_KEYSPACE_NAME,\n                                               AuthKeyspace.CIDR_GROUPS);\n\n        return QueryProcessor.executeInternalWithPaging(getAllRowsQuery, 128);\n    }\n\n    public Set<String> getAvailableCidrGroups()", "refactored_code": "    private static final int PAGE_SIZE = 128;\n                                               SchemaConstants.AUTH_KEYSPACE_NAME,\n                                               AuthKeyspace.CIDR_GROUPS);\n\n        return QueryProcessor.executeInternalWithPaging(getAllRowsQuery, PAGE_SIZE);\n    }\n\n    public Set<String> getAvailableCidrGroups()"}
{"magic_number_smell": "\n        batchlogTasks.scheduleWithFixedDelay(this::replayFailedBatches,\n                                             StorageService.RING_DELAY_MILLIS,\n                                             10 * 1000,\n                                             MILLISECONDS);\n    }\n", "refactored_code": "    private static final long REPLAY_INTERVAL = 10 * 1000; // milliseconds\n\n        batchlogTasks.scheduleWithFixedDelay(this::replayFailedBatches,\n                                             StorageService.RING_DELAY_MILLIS,\n                                             REPLAY_INTERVAL,\n                                             MILLISECONDS);\n    }\n"}
{"magic_number_smell": "public class ChunkCache implements CacheLoader<ChunkCache.Key, ChunkCache.Buffer>, RemovalListener<ChunkCache.Key, ChunkCache.Buffer>, CacheSize\n{\n    public static final int 32 = 32;\n    public static final long cacheSize = 1024L * 1024L * Math.max(0, DatabaseDescriptor.getFileCacheSizeInMiB() - 32);\n    public static final boolean roundUp = DatabaseDescriptor.getFileCacheRoundUp();\n\n    private static boolean enabled = DatabaseDescriptor.getFileCacheEnabled() && cacheSize > 0;", "refactored_code": "    public static final int RESERVED_POOL_SPACE_IN_MiB = 32;\npublic class ChunkCache implements CacheLoader<ChunkCache.Key, ChunkCache.Buffer>, RemovalListener<ChunkCache.Key, ChunkCache.Buffer>, CacheSize\n{\n    public static final int RESERVED_POOL_SPACE_IN_MiB = 32;\n    public static final long cacheSize = 1024L * 1024L * Math.max(0, DatabaseDescriptor.getFileCacheSizeInMiB() - RESERVED_POOL_SPACE_IN_MiB);\n    public static final boolean roundUp = DatabaseDescriptor.getFileCacheRoundUp();\n\n    private static boolean enabled = DatabaseDescriptor.getFileCacheEnabled() && cacheSize > 0;"}
{"magic_number_smell": "\n    public long unsharedHeapSize()\n    {\n        return ObjectSizes.measure(new RowCacheKey(null, null, new byte[0])) + ObjectSizes.sizeOfArray(key);\n    }\n\n    @Override", "refactored_code": "    private static final long EMPTY_SIZE = ObjectSizes.measure(new RowCacheKey(null, null, new byte[0]));\n\n    public long unsharedHeapSize()\n    {\n        return EMPTY_SIZE + ObjectSizes.sizeOfArray(key);\n    }\n\n    @Override"}
{"magic_number_smell": "        {\n            // if stopCheck has caught up with present, we've been spinning too much, so if we can atomically\n            // set it to the past again, we should stop a worker\n            if (pool.stopCheck.compareAndSet(stopCheck, now - TimeUnit.MILLISECONDS.toNanos(10L)))\n            {\n                // try and stop ourselves;\n                // if we've already been assigned work stop another worker", "refactored_code": "    private static final long stopCheckInterval = TimeUnit.MILLISECONDS.toNanos(10L);\n        {\n            // if stopCheck has caught up with present, we've been spinning too much, so if we can atomically\n            // set it to the past again, we should stop a worker\n            if (pool.stopCheck.compareAndSet(stopCheck, now - stopCheckInterval))\n            {\n                // try and stop ourselves;\n                // if we've already been assigned work stop another worker"}
{"magic_number_smell": "    @Deprecated(since = \"4.0\")\n    public static final int 200 = 200;\n    @Deprecated(since = \"4.0\")\n    public int otc_coalescing_window_us = 200;\n    @Deprecated(since = \"4.0\")\n    public int otc_coalescing_enough_coalesced_messages = 8;\n    @Deprecated(since = \"4.0\")", "refactored_code": "    public static final int otc_coalescing_window_us_default = 200;\n    @Deprecated(since = \"4.0\")\n    public static final int otc_coalescing_window_us_default = 200;\n    @Deprecated(since = \"4.0\")\n    public int otc_coalescing_window_us = otc_coalescing_window_us_default;\n    @Deprecated(since = \"4.0\")\n    public int otc_coalescing_enough_coalesced_messages = 8;\n    @Deprecated(since = \"4.0\")"}
{"magic_number_smell": "        if (conf.concurrent_materialized_view_builders <= 0)\n            throw new ConfigurationException(\"concurrent_materialized_view_builders should be strictly greater than 0, but was \" + conf.concurrent_materialized_view_builders, false);\n\n        if (conf.num_tokens != null && conf.num_tokens > 1536)\n            throw new ConfigurationException(String.format(\"A maximum number of %d tokens per node is supported\", 1536), false);\n\n        try", "refactored_code": "    private static final int MAX_NUM_TOKENS = 1536;\n        if (conf.concurrent_materialized_view_builders <= 0)\n            throw new ConfigurationException(\"concurrent_materialized_view_builders should be strictly greater than 0, but was \" + conf.concurrent_materialized_view_builders, false);\n\n        if (conf.num_tokens != null && conf.num_tokens > MAX_NUM_TOKENS)\n            throw new ConfigurationException(String.format(\"A maximum number of %d tokens per node is supported\", MAX_NUM_TOKENS), false);\n\n        try"}
{"magic_number_smell": "    public static final int 2000 = 2000;\n    public static final int DEFAULT_FAIL_THRESHOLD = 32000;\n\n    public volatile int cached_rows_warn_threshold = 2000;\n    public volatile int cached_rows_fail_threshold = DEFAULT_FAIL_THRESHOLD;\n}\n", "refactored_code": "    public static final int DEFAULT_WARN_THRESHOLD = 2000;\n    public static final int DEFAULT_WARN_THRESHOLD = 2000;\n    public static final int DEFAULT_FAIL_THRESHOLD = 32000;\n\n    public volatile int cached_rows_warn_threshold = DEFAULT_WARN_THRESHOLD;\n    public volatile int cached_rows_fail_threshold = DEFAULT_FAIL_THRESHOLD;\n}\n"}
{"magic_number_smell": "    public static final String INVALID_BUFFER_SIZE_ERROR = \"Invalid value for segment_write_buffer_size. \" +\n                                                           \"Value must be a positive integer less than \" + MAXIMUM_SEGMENT_BUFFER_MB + \"MiB\";\n\n    public DataStorageSpec.IntMebibytesBound segment_write_buffer_size = new DataStorageSpec.IntMebibytesBound(1024);\n\n    public void validate()\n    {", "refactored_code": "    public static final int DEFAULT_SEGMENT_BUFFER_MB = 1024;\n    public static final String INVALID_BUFFER_SIZE_ERROR = \"Invalid value for segment_write_buffer_size. \" +\n                                                           \"Value must be a positive integer less than \" + MAXIMUM_SEGMENT_BUFFER_MB + \"MiB\";\n\n    public DataStorageSpec.IntMebibytesBound segment_write_buffer_size = new DataStorageSpec.IntMebibytesBound(DEFAULT_SEGMENT_BUFFER_MB);\n\n    public void validate()\n    {"}
{"magic_number_smell": "        if (ttl < 0)\n            throw new InvalidRequestException(\"A TTL must be greater or equal to 0, but was \" + ttl);\n\n        if (ttl > 20 * 365 * 24 * 60 * 60)\n            throw new InvalidRequestException(String.format(\"ttl is too large. requested (%d) maximum (%d)\", ttl, 20 * 365 * 24 * 60 * 60));\n\n        if (metadata.params.defaultTimeToLive != LivenessInfo.NO_TTL && ttl == LivenessInfo.NO_TTL)", "refactored_code": "    public static final int MAX_TTL = 20 * 365 * 24 * 60 * 60; // 20 years in seconds\n        if (ttl < 0)\n            throw new InvalidRequestException(\"A TTL must be greater or equal to 0, but was \" + ttl);\n\n        if (ttl > MAX_TTL)\n            throw new InvalidRequestException(String.format(\"ttl is too large. requested (%d) maximum (%d)\", ttl, MAX_TTL));\n\n        if (metadata.params.defaultTimeToLive != LivenessInfo.NO_TTL && ttl == LivenessInfo.NO_TTL)"}
{"magic_number_smell": "\n    public long unsharedHeapSize()\n    {\n        return ObjectSizes.measure(new ColumnIdentifier(ByteBufferUtil.EMPTY_BYTE_BUFFER, \"\", false))\n             + ObjectSizes.sizeOnHeapOf(bytes)\n             + ObjectSizes.sizeOf(text);\n    }", "refactored_code": "    private static final long EMPTY_SIZE = ObjectSizes.measure(new ColumnIdentifier(ByteBufferUtil.EMPTY_BYTE_BUFFER, \"\", false));\n\n    public long unsharedHeapSize()\n    {\n        return EMPTY_SIZE\n             + ObjectSizes.sizeOnHeapOf(bytes)\n             + ObjectSizes.sizeOf(text);\n    }"}
{"magic_number_smell": "public final class Duration\n{\n    public static final long 1000L = 1000L;\n    public static final long NANOS_PER_MILLI = 1000 * 1000L;\n    public static final long NANOS_PER_SECOND = 1000 * NANOS_PER_MILLI;\n    public static final long NANOS_PER_MINUTE = 60 * NANOS_PER_SECOND;\n    public static final long NANOS_PER_HOUR = 60 * NANOS_PER_MINUTE;", "refactored_code": "    public static final long NANOS_PER_MICRO = 1000L;\npublic final class Duration\n{\n    public static final long NANOS_PER_MICRO = 1000L;\n    public static final long NANOS_PER_MILLI = 1000 * NANOS_PER_MICRO;\n    public static final long NANOS_PER_SECOND = 1000 * NANOS_PER_MILLI;\n    public static final long NANOS_PER_MINUTE = 60 * NANOS_PER_SECOND;\n    public static final long NANOS_PER_HOUR = 60 * NANOS_PER_MINUTE;"}
{"magic_number_smell": "     */\n    private static int getSnippetFirstTokenIndex(int index)\n    {\n        return Math.max(0, index - 10);\n    }\n}\n", "refactored_code": "    private static final int FIRST_TOKEN_OFFSET = 10;\n     */\n    private static int getSnippetFirstTokenIndex(int index)\n    {\n        return Math.max(0, index - FIRST_TOKEN_OFFSET);\n    }\n}\n"}
{"magic_number_smell": "                                      ProtocolVersion version,\n                                      String keyspace)\n    {\n        return create(consistency, values, skipMetadata, pageSize, pagingState, serialConsistency, version, keyspace, Long.MIN_VALUE, Long.MIN_VALUE);\n    }\n\n    public static QueryOptions create(ConsistencyLevel consistency,", "refactored_code": "    private static final long UNSET_NOWINSEC = Long.MIN_VALUE;\n                                      ProtocolVersion version,\n                                      String keyspace)\n    {\n        return create(consistency, values, skipMetadata, pageSize, pagingState, serialConsistency, version, keyspace, Long.MIN_VALUE, UNSET_NOWINSEC);\n    }\n\n    public static QueryOptions create(ConsistencyLevel consistency,"}
{"magic_number_smell": "\n    public UDFExecutorService(NamedThreadFactory threadFactory, String jmxPath)\n    {\n        super(getAvailableProcessors(), UDF_EXECUTOR_THREAD_KEEPALIVE_MS.getInt(), MILLISECONDS, newBlockingQueue(), threadFactory);\n        ThreadPoolExecutorJMXAdapter.register(jmxPath, this);\n    }\n", "refactored_code": "    private static final int KEEPALIVE = UDF_EXECUTOR_THREAD_KEEPALIVE_MS.getInt();\n\n    public UDFExecutorService(NamedThreadFactory threadFactory, String jmxPath)\n    {\n        super(getAvailableProcessors(), KEEPALIVE, MILLISECONDS, newBlockingQueue(), threadFactory);\n        ThreadPoolExecutorJMXAdapter.register(jmxPath, this);\n    }\n"}
{"magic_number_smell": "{\n\n    private static final long 1000L = 1000L;\n    private static final long NANOS_PER_MILLI = 1000 * 1000L;\n    private static final long NANOS_PER_SECOND = 1000 * NANOS_PER_MILLI;\n    private static final long NANOS_PER_MINUTE = 60 * NANOS_PER_SECOND;\n    private static final long NANOS_PER_HOUR = 60 * NANOS_PER_MINUTE;", "refactored_code": "    private static final long NANOS_PER_MICRO = 1000L;\n{\n\n    private static final long NANOS_PER_MICRO = 1000L;\n    private static final long NANOS_PER_MILLI = 1000 * NANOS_PER_MICRO;\n    private static final long NANOS_PER_SECOND = 1000 * NANOS_PER_MILLI;\n    private static final long NANOS_PER_MINUTE = 60 * NANOS_PER_SECOND;\n    private static final long NANOS_PER_HOUR = 60 * NANOS_PER_MINUTE;"}
{"magic_number_smell": "                PartitionUpdate update = updateEntry.getValue().build();\n                updates.put(updateEntry.getKey(), update);\n            }\n            return new Mutation(keyspaceName, key, updates.build(), approxTime.now());\n        }\n\n        public PartitionUpdate.Builder get(TableId tableId)", "refactored_code": "        private final long createdAt = approxTime.now();\n                PartitionUpdate update = updateEntry.getValue().build();\n                updates.put(updateEntry.getKey(), update);\n            }\n            return new Mutation(keyspaceName, key, updates.build(), createdAt);\n        }\n\n        public PartitionUpdate.Builder get(TableId tableId)"}
{"magic_number_smell": "    {\n        try (DataOutputBuffer out = new DataOutputBuffer())\n        {\n            out.writeShort(0x0001);\n            out.writeUTF(FBUtilities.getReleaseVersionString());\n            out.write(UUIDGen.decompose(schemaVersion));\n            out.writeLong(nextPageOffset);", "refactored_code": "    private static final int PAGING_STATE_VERSION = 0x0001;\n    {\n        try (DataOutputBuffer out = new DataOutputBuffer())\n        {\n            out.writeShort(PAGING_STATE_VERSION);\n            out.writeUTF(FBUtilities.getReleaseVersionString());\n            out.write(UUIDGen.decompose(schemaVersion));\n            out.writeLong(nextPageOffset);"}
{"magic_number_smell": "        // Group by and aggregation queries will always be paged internally to avoid OOM.\n        // If the user provided a pageSize we'll use that to page internally (because why not), otherwise we use our default\n        if (pageSize <= 0)\n            pageSize = 10000;\n\n        // Aggregation queries work fine on top of the group by paging but to maintain\n        // backward compatibility we need to use the old way.", "refactored_code": "    public static final int DEFAULT_PAGE_SIZE = 10000;\n        // Group by and aggregation queries will always be paged internally to avoid OOM.\n        // If the user provided a pageSize we'll use that to page internally (because why not), otherwise we use our default\n        if (pageSize <= 0)\n            pageSize = DEFAULT_PAGE_SIZE;\n\n        // Aggregation queries work fine on top of the group by paging but to maintain\n        // backward compatibility we need to use the old way."}
{"magic_number_smell": "            {\n                if (remainingInBatch == 0)\n                {\n                    long time = PrecisionTime.1262304000000L - (currentTimeMillis() - PrecisionTime.1262304000000L);\n                    remainingInBatch = Math.min(PrecisionTime.MAX_NANOS, i) + 1;\n                    pt = PrecisionTime.getNext(time, remainingInBatch);\n                }", "refactored_code": "        private static final long REFERENCE_TIME = 1262304000000L;\n            {\n                if (remainingInBatch == 0)\n                {\n                    long time = PrecisionTime.REFERENCE_TIME - (currentTimeMillis() - PrecisionTime.REFERENCE_TIME);\n                    remainingInBatch = Math.min(PrecisionTime.MAX_NANOS, i) + 1;\n                    pt = PrecisionTime.getNext(time, remainingInBatch);\n                }"}
{"magic_number_smell": "        long elementsSize = 0;\n        for (int i = 0; i < values.length; i++)\n            elementsSize += ObjectSizes.sizeOfArray(values[i]);\n        return ObjectSizes.measure(new ArrayClustering(EMPTY_VALUES_ARRAY)) + arrayRefSize + elementsSize;\n    }\n\n    public long unsharedHeapSizeExcludingData()", "refactored_code": "    public static final long EMPTY_SIZE = ObjectSizes.measure(new ArrayClustering(EMPTY_VALUES_ARRAY));\n        long elementsSize = 0;\n        for (int i = 0; i < values.length; i++)\n            elementsSize += ObjectSizes.sizeOfArray(values[i]);\n        return EMPTY_SIZE + arrayRefSize + elementsSize;\n    }\n\n    public long unsharedHeapSizeExcludingData()"}
{"magic_number_smell": "\n    public long unsharedHeapSize()\n    {\n        return ObjectSizes.measure(new ArrayClusteringBound(ClusteringPrefix.Kind.INCL_START_BOUND, EMPTY_VALUES_ARRAY)) + ObjectSizes.sizeOfArray(values) + values.length;\n    }\n\n    @Override", "refactored_code": "    private static final long EMPTY_SIZE = ObjectSizes.measure(new ArrayClusteringBound(ClusteringPrefix.Kind.INCL_START_BOUND, EMPTY_VALUES_ARRAY));\n\n    public long unsharedHeapSize()\n    {\n        return EMPTY_SIZE + ObjectSizes.sizeOfArray(values) + values.length;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public long unsharedHeapSize()\n    {\n        return ObjectSizes.measure(new ArrayClusteringBoundary(ClusteringPrefix.Kind.INCL_START_BOUND, EMPTY_VALUES_ARRAY)) + ObjectSizes.sizeOfArray(values) + values.length;\n    }\n\n    public static ClusteringBoundary<byte[]> create(Kind kind, byte[][] values)", "refactored_code": "    private static final long EMPTY_SIZE = ObjectSizes.measure(new ArrayClusteringBoundary(ClusteringPrefix.Kind.INCL_START_BOUND, EMPTY_VALUES_ARRAY));\n\n    public long unsharedHeapSize()\n    {\n        return EMPTY_SIZE + ObjectSizes.sizeOfArray(values) + values.length;\n    }\n\n    public static ClusteringBoundary<byte[]> create(Kind kind, byte[][] values)"}
{"magic_number_smell": "    {\n        if (this == Clustering.EMPTY || this == Clustering.STATIC_CLUSTERING)\n            return 0;\n        return ObjectSizes.measure(new BufferClustering(EMPTY_VALUES_ARRAY)) + ObjectSizes.sizeOnHeapOf(values);\n    }\n\n    public long unsharedHeapSizeExcludingData()", "refactored_code": "    private static final long EMPTY_SIZE = ObjectSizes.measure(new BufferClustering(EMPTY_VALUES_ARRAY));\n    {\n        if (this == Clustering.EMPTY || this == Clustering.STATIC_CLUSTERING)\n            return 0;\n        return EMPTY_SIZE + ObjectSizes.sizeOnHeapOf(values);\n    }\n\n    public long unsharedHeapSizeExcludingData()"}
{"magic_number_smell": "\n    public long unsharedHeapSize()\n    {\n        return ObjectSizes.measure(new BufferClusteringBound(Kind.INCL_START_BOUND, EMPTY_VALUES_ARRAY)) + ObjectSizes.sizeOnHeapOf(values);\n    }\n\n    @Override", "refactored_code": "    private static final long EMPTY_SIZE = ObjectSizes.measure(new BufferClusteringBound(Kind.INCL_START_BOUND, EMPTY_VALUES_ARRAY));\n\n    public long unsharedHeapSize()\n    {\n        return EMPTY_SIZE + ObjectSizes.sizeOnHeapOf(values);\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public long unsharedHeapSize()\n    {\n        return ObjectSizes.measure(new BufferClusteringBoundary(Kind.INCL_START_BOUND, EMPTY_VALUES_ARRAY)) + ObjectSizes.sizeOnHeapOf(values);\n    }\n\n    public static ClusteringBoundary<ByteBuffer> create(Kind kind, ByteBuffer[] values)", "refactored_code": "    private static final long EMPTY_SIZE = ObjectSizes.measure(new BufferClusteringBoundary(Kind.INCL_START_BOUND, EMPTY_VALUES_ARRAY));\n\n    public long unsharedHeapSize()\n    {\n        return EMPTY_SIZE + ObjectSizes.sizeOnHeapOf(values);\n    }\n\n    public static ClusteringBoundary<ByteBuffer> create(Kind kind, ByteBuffer[] values)"}
{"magic_number_smell": "\n    public long unsharedHeapSize()\n    {\n        return ObjectSizes.measure(new ClockAndCount(0, 0));\n    }\n\n    @Override", "refactored_code": "    private static final long EMPTY_SIZE = ObjectSizes.measure(new ClockAndCount(0, 0));\n\n    public long unsharedHeapSize()\n    {\n        return EMPTY_SIZE;\n    }\n\n    @Override"}
{"magic_number_smell": "        if (this == LIVE)\n            return 0;\n\n        return ObjectSizes.measure(new DeletionTime(0, 0));\n    }\n    \n    public static Serializer getSerializer(Version version)", "refactored_code": "    public static final long EMPTY_SIZE = ObjectSizes.measure(new DeletionTime(0, 0));\n        if (this == LIVE)\n            return 0;\n\n        return EMPTY_SIZE;\n    }\n    \n    public static Serializer getSerializer(Version version)"}
{"magic_number_smell": "                     * by {@link #computeLocalExpirationTime(long, int)}, which converts the negative TTL\n                     * to {@link org.apache.cassandra.db.BufferExpiringCell#MAX_DELETION_TIME}\n                     */\n                    NoSpamLogger.log(logger, NoSpamLogger.Level.WARN, CassandraRelevantProperties.EXPIRATION_OVERFLOW_WARNING_INTERVAL_MINUTES.getInt(), TimeUnit.MINUTES, MAXIMUM_EXPIRATION_DATE_EXCEEDED_WARNING,\n                                     metadata.keyspace, metadata.name, isDefaultTTL? \"default \" : \"\", ttl, getMaxExpirationDateTS());\n                    return;\n", "refactored_code": "    private static final int EXPIRATION_OVERFLOW_WARNING_INTERVAL_MINUTES = CassandraRelevantProperties.EXPIRATION_OVERFLOW_WARNING_INTERVAL_MINUTES.getInt();\n                     * by {@link #computeLocalExpirationTime(long, int)}, which converts the negative TTL\n                     * to {@link org.apache.cassandra.db.BufferExpiringCell#MAX_DELETION_TIME}\n                     */\n                    NoSpamLogger.log(logger, NoSpamLogger.Level.WARN, EXPIRATION_OVERFLOW_WARNING_INTERVAL_MINUTES, TimeUnit.MINUTES, MAXIMUM_EXPIRATION_DATE_EXCEEDED_WARNING,\n                                     metadata.keyspace, metadata.name, isDefaultTTL? \"default \" : \"\", ttl, getMaxExpirationDateTS());\n                    return;\n"}
{"magic_number_smell": "    public static final int EXPIRED_LIVENESS_TTL = Integer.MAX_VALUE;\n    public static final long NO_EXPIRATION_TIME = Cell.NO_DELETION_TIME;\n\n    public static final LivenessInfo EMPTY = new LivenessInfo(Long.MIN_VALUE);\n    private static final long UNSHARED_HEAP_SIZE = ObjectSizes.measure(EMPTY);\n\n    protected final long timestamp;", "refactored_code": "    public static final long NO_TIMESTAMP = Long.MIN_VALUE;\n    public static final int EXPIRED_LIVENESS_TTL = Integer.MAX_VALUE;\n    public static final long NO_EXPIRATION_TIME = Cell.NO_DELETION_TIME;\n\n    public static final LivenessInfo EMPTY = new LivenessInfo(NO_TIMESTAMP);\n    private static final long UNSHARED_HEAP_SIZE = ObjectSizes.measure(EMPTY);\n\n    protected final long timestamp;"}
{"magic_number_smell": "        if (this == LIVE)\n            return 0;\n\n        return ObjectSizes.measure(new MutableDeletionInfo(0, 0)) + partitionDeletion.unsharedHeapSize() + (ranges == null ? 0 : ranges.unsharedHeapSize());\n    }\n\n    public void collectStats(EncodingStats.Collector collector)", "refactored_code": "    private static final long EMPTY_SIZE = ObjectSizes.measure(new MutableDeletionInfo(0, 0));\n        if (this == LIVE)\n            return 0;\n\n        return EMPTY_SIZE + partitionDeletion.unsharedHeapSize() + (ranges == null ? 0 : ranges.unsharedHeapSize());\n    }\n\n    public void collectStats(EncodingStats.Collector collector)"}
{"magic_number_smell": "    // Contains serialized representations of this mutation.\n    // Note: there is no functionality to clear/remove serialized instances, because a mutation must never\n    // be modified (e.g. calling add(PartitionUpdate)) when it's being serialized.\n    private final Serialization[] cachedSerializations = new Serialization[MessagingService.Version.values().length];\n\n    /** @see CassandraRelevantProperties#CACHEABLE_MUTATION_SIZE_LIMIT */\n    private static final long CACHEABLE_MUTATION_SIZE_LIMIT = CassandraRelevantProperties.CACHEABLE_MUTATION_SIZE_LIMIT.getLong();", "refactored_code": "    private static final int SERIALIZATION_VERSION_COUNT = MessagingService.Version.values().length;\n    // Contains serialized representations of this mutation.\n    // Note: there is no functionality to clear/remove serialized instances, because a mutation must never\n    // be modified (e.g. calling add(PartitionUpdate)) when it's being serialized.\n    private final Serialization[] cachedSerializations = new Serialization[SERIALIZATION_VERSION_COUNT];\n\n    /** @see CassandraRelevantProperties#CACHEABLE_MUTATION_SIZE_LIMIT */\n    private static final long CACHEABLE_MUTATION_SIZE_LIMIT = CassandraRelevantProperties.CACHEABLE_MUTATION_SIZE_LIMIT.getLong();"}
{"magic_number_smell": "                                                                       upd.metadata().partitionKeyType.getString(upd.partitionKey().getKey())))\n                                             .collect(Collectors.toList());\n\n        String topKeys = makeTopKeysString(topPartitions, 1024);\n        return String.format(\"Rejected an oversized mutation (%d/%d) for keyspace: %s. Top keys are: %s\",\n                             totalSize,\n                             MAX_MUTATION_SIZE,", "refactored_code": "    public static final int PARTITION_MESSAGE_LIMIT = 1024;\n                                                                       upd.metadata().partitionKeyType.getString(upd.partitionKey().getKey())))\n                                             .collect(Collectors.toList());\n\n        String topKeys = makeTopKeysString(topPartitions, PARTITION_MESSAGE_LIMIT);\n        return String.format(\"Rejected an oversized mutation (%d/%d) for keyspace: %s. Top keys are: %s\",\n                             totalSize,\n                             MAX_MUTATION_SIZE,"}
{"magic_number_smell": "\n    public long unsharedHeapSize()\n    {\n        return ObjectSizes.measure(new NativeClustering());\n    }\n\n    public long unsharedHeapSizeExcludingData()", "refactored_code": "    private static final long EMPTY_SIZE = ObjectSizes.measure(new NativeClustering());\n\n    public long unsharedHeapSize()\n    {\n        return EMPTY_SIZE;\n    }\n\n    public long unsharedHeapSizeExcludingData()"}
{"magic_number_smell": "        @Override\n        protected UnfilteredRowIterator applyToPartition(UnfilteredRowIterator partition)\n        {\n            FBUtilities.sleepQuietly(CassandraRelevantProperties.TEST_READ_ITERATION_DELAY_MS.getInt());\n            return Transformation.apply(partition, this);\n        }\n", "refactored_code": "    private static final int TEST_ITERATION_DELAY_MILLIS = CassandraRelevantProperties.TEST_READ_ITERATION_DELAY_MS.getInt();\n        @Override\n        protected UnfilteredRowIterator applyToPartition(UnfilteredRowIterator partition)\n        {\n            FBUtilities.sleepQuietly(TEST_ITERATION_DELAY_MILLIS);\n            return Transformation.apply(partition, this);\n        }\n"}
{"magic_number_smell": "\n    public static ReadExecutionController empty()\n    {\n        return new ReadExecutionController(null, null, null, null, null, Long.MIN_VALUE, false);\n    }\n\n    /**", "refactored_code": "    private static final long NO_SAMPLING = Long.MIN_VALUE;\n\n    public static ReadExecutionController empty()\n    {\n        return new ReadExecutionController(null, null, null, null, null, NO_SAMPLING, false);\n    }\n\n    /**"}
{"magic_number_smell": "    @SuppressWarnings(\"unused\")\n    public static int sizeof(boolean value)\n    {\n        return 1;\n    }\n\n    @SuppressWarnings(\"unused\")", "refactored_code": "    public static final int BOOL_SIZE = 1;\n    @SuppressWarnings(\"unused\")\n    public static int sizeof(boolean value)\n    {\n        return BOOL_SIZE;\n    }\n\n    @SuppressWarnings(\"unused\")"}
{"magic_number_smell": "\n    public BatchCommitLogService(CommitLog commitLog)\n    {\n        super(commitLog, \"COMMIT-LOG-WRITER\", BATCH_COMMIT_LOG_SYNC_INTERVAL.getInt());\n    }\n\n    protected void maybeWaitForSync(CommitLogSegment.Allocation alloc)", "refactored_code": "    private static final int POLL_TIME_MILLIS = BATCH_COMMIT_LOG_SYNC_INTERVAL.getInt();\n\n    public BatchCommitLogService(CommitLog commitLog)\n    {\n        super(commitLog, \"COMMIT-LOG-WRITER\", POLL_TIME_MILLIS);\n    }\n\n    protected void maybeWaitForSync(CommitLogSegment.Allocation alloc)"}
{"magic_number_smell": "    {\n        CRC32 checkcrc = new CRC32();\n        int version = input.readInt();\n        if (version < 6)\n            throw new IllegalArgumentException(\"Unsupported pre-3.0 commit log found; cannot read.\");\n\n        updateChecksumInt(checkcrc, version);", "refactored_code": "    public static final int VERSION_30 = 6;\n    {\n        CRC32 checkcrc = new CRC32();\n        int version = input.readInt();\n        if (version < VERSION_30)\n            throw new IllegalArgumentException(\"Unsupported pre-3.0 commit log found; cannot read.\");\n\n        updateChecksumInt(checkcrc, version);"}
{"magic_number_smell": "            int serializedSize;\n            try\n            {\n                // We rely on reading serialized size == 0 (0) to identify the end\n                // of a segment, which happens naturally due to the 0 padding of the empty segment on creation.\n                // However, it's possible with 2.1 era commitlogs that the last mutation ended less than 4 bytes\n                // from the end of the file, which means that we'll be unable to read an a full int and instead", "refactored_code": "    private static final int LEGACY_END_OF_SEGMENT_MARKER = 0;\n            int serializedSize;\n            try\n            {\n                // We rely on reading serialized size == 0 (LEGACY_END_OF_SEGMENT_MARKER) to identify the end\n                // of a segment, which happens naturally due to the 0 padding of the empty segment on creation.\n                // However, it's possible with 2.1 era commitlogs that the last mutation ended less than 4 bytes\n                // from the end of the file, which means that we'll be unable to read an a full int and instead"}
{"magic_number_smell": "                                                         this));\n        // If there are finished mutations, or too many outstanding bytes/mutations\n        // drain the futures in the queue\n        while (futures.size() > COMMITLOG_MAX_OUTSTANDING_REPLAY_COUNT.getInt()\n               || pendingMutationBytes > MAX_OUTSTANDING_REPLAY_BYTES\n               || (!futures.isEmpty() && futures.peek().isDone()))\n        {", "refactored_code": "    private static final int MAX_OUTSTANDING_REPLAY_COUNT = COMMITLOG_MAX_OUTSTANDING_REPLAY_COUNT.getInt();\n                                                         this));\n        // If there are finished mutations, or too many outstanding bytes/mutations\n        // drain the futures in the queue\n        while (futures.size() > MAX_OUTSTANDING_REPLAY_COUNT\n               || pendingMutationBytes > MAX_OUTSTANDING_REPLAY_BYTES\n               || (!futures.isEmpty() && futures.peek().isDone()))\n        {"}
{"magic_number_smell": "\n            // save space for the sync marker at the beginning of this section\n            final long syncMarkerPosition = lastWrittenPos;\n            channel.position(syncMarkerPosition + SYNC_MARKER_SIZE + 4);\n\n            // loop over the segment data in encryption buffer sized chunks\n            while (contentStart < nextMarker)", "refactored_code": "    private static final int ENCRYPTED_SECTION_HEADER_SIZE = SYNC_MARKER_SIZE + 4;\n\n            // save space for the sync marker at the beginning of this section\n            final long syncMarkerPosition = lastWrittenPos;\n            channel.position(syncMarkerPosition + ENCRYPTED_SECTION_HEADER_SIZE);\n\n            // loop over the segment data in encryption buffer sized chunks\n            while (contentStart < nextMarker)"}
{"magic_number_smell": "\n    protected void maybeWaitForSync(CommitLogSegment.Allocation alloc)\n    {\n        long expectedSyncTime = nanoTime() - TimeUnit.MILLISECONDS.toNanos(DatabaseDescriptor.getPeriodicCommitLogSyncBlock());\n        if (lastSyncedAt < expectedSyncTime)\n        {\n            pending.incrementAndGet();", "refactored_code": "    private static final long blockWhenSyncLagsNanos = TimeUnit.MILLISECONDS.toNanos(DatabaseDescriptor.getPeriodicCommitLogSyncBlock());\n\n    protected void maybeWaitForSync(CommitLogSegment.Allocation alloc)\n    {\n        long expectedSyncTime = nanoTime() - blockWhenSyncLagsNanos;\n        if (lastSyncedAt < expectedSyncTime)\n        {\n            pending.incrementAndGet();"}
{"magic_number_smell": "        {\n            validateOptions(options);\n            String optionValue = options.get(TOMBSTONE_THRESHOLD_OPTION);\n            tombstoneThreshold = optionValue == null ? 0.2f : Float.parseFloat(optionValue);\n            optionValue = options.get(TOMBSTONE_COMPACTION_INTERVAL_OPTION);\n            tombstoneCompactionInterval = optionValue == null ? DEFAULT_TOMBSTONE_COMPACTION_INTERVAL : Long.parseLong(optionValue);\n            optionValue = options.get(UNCHECKED_TOMBSTONE_COMPACTION_OPTION);", "refactored_code": "    protected static final float DEFAULT_TOMBSTONE_THRESHOLD = 0.2f;\n        {\n            validateOptions(options);\n            String optionValue = options.get(TOMBSTONE_THRESHOLD_OPTION);\n            tombstoneThreshold = optionValue == null ? DEFAULT_TOMBSTONE_THRESHOLD : Float.parseFloat(optionValue);\n            optionValue = options.get(TOMBSTONE_COMPACTION_INTERVAL_OPTION);\n            tombstoneCompactionInterval = optionValue == null ? DEFAULT_TOMBSTONE_COMPACTION_INTERVAL : Long.parseLong(optionValue);\n            optionValue = options.get(UNCHECKED_TOMBSTONE_COMPACTION_OPTION);"}
{"magic_number_smell": "        protected void updateProgress()\n        {\n            totalSourceCQLRows++;\n            if ((++compactedUnfiltered) % 100 == 0)\n                updateBytesRead();\n        }\n", "refactored_code": "    private static final long UNFILTERED_TO_UPDATE_PROGRESS = 100;\n        protected void updateProgress()\n        {\n            totalSourceCQLRows++;\n            if ((++compactedUnfiltered) % UNFILTERED_TO_UPDATE_PROGRESS == 0)\n                updateBytesRead();\n        }\n"}
{"magic_number_smell": "            @Override\n            public void execute(LifecycleTransaction txn)\n            {\n                AbstractCompactionTask task = cfs.getCompactionStrategyManager().getCompactionTask(txn, Integer.MIN_VALUE, Long.MAX_VALUE);\n                task.setUserDefined(true);\n                task.setCompactionType(OperationType.UPGRADE_SSTABLES);\n                task.execute(active);", "refactored_code": "    public static final int NO_GC = Integer.MIN_VALUE;\n            @Override\n            public void execute(LifecycleTransaction txn)\n            {\n                AbstractCompactionTask task = cfs.getCompactionStrategyManager().getCompactionTask(txn, NO_GC, Long.MAX_VALUE);\n                task.setUserDefined(true);\n                task.setCompactionType(OperationType.UPGRADE_SSTABLES);\n                task.execute(active);"}
{"magic_number_smell": "    {\n        super(cfs, options);\n        int configuredMaxSSTableSize = 160;\n        int configuredLevelFanoutSize = 10;\n        boolean configuredSingleSSTableUplevel = false;\n        SizeTieredCompactionStrategyOptions localOptions = new SizeTieredCompactionStrategyOptions(options);\n        if (options != null)", "refactored_code": "    public static final int DEFAULT_LEVEL_FANOUT_SIZE = 10;\n    {\n        super(cfs, options);\n        int configuredMaxSSTableSize = 160;\n        int configuredLevelFanoutSize = DEFAULT_LEVEL_FANOUT_SIZE;\n        boolean configuredSingleSSTableUplevel = false;\n        SizeTieredCompactionStrategyOptions localOptions = new SizeTieredCompactionStrategyOptions(options);\n        if (options != null)"}
{"magic_number_smell": "\n    private CompactionCandidate getSTCSInL0CompactionCandidate()\n    {\n        if (!DatabaseDescriptor.getDisableSTCSInL0() && generations.get(0).size() > 32)\n        {\n            List<SSTableReader> mostInteresting = getSSTablesForSTCS(generations.get(0));\n            if (!mostInteresting.isEmpty())", "refactored_code": "    private static final int MAX_COMPACTING_L0 = 32;\n\n    private CompactionCandidate getSTCSInL0CompactionCandidate()\n    {\n        if (!DatabaseDescriptor.getDisableSTCSInL0() && generations.get(0).size() > MAX_COMPACTING_L0)\n        {\n            List<SSTableReader> mostInteresting = getSSTablesForSTCS(generations.get(0));\n            if (!mostInteresting.isEmpty())"}
{"magic_number_smell": "    public SizeTieredCompactionStrategyOptions(Map<String, String> options)\n    {\n        String optionValue = options.get(MIN_SSTABLE_SIZE_KEY);\n        minSSTableSize = optionValue == null ? 50L * 1024L * 1024L : Long.parseLong(optionValue);\n        optionValue = options.get(BUCKET_LOW_KEY);\n        bucketLow = optionValue == null ? DEFAULT_BUCKET_LOW : Double.parseDouble(optionValue);\n        optionValue = options.get(BUCKET_HIGH_KEY);", "refactored_code": "    protected static final long DEFAULT_MIN_SSTABLE_SIZE = 50L * 1024L * 1024L;\n    public SizeTieredCompactionStrategyOptions(Map<String, String> options)\n    {\n        String optionValue = options.get(MIN_SSTABLE_SIZE_KEY);\n        minSSTableSize = optionValue == null ? DEFAULT_MIN_SSTABLE_SIZE : Long.parseLong(optionValue);\n        optionValue = options.get(BUCKET_LOW_KEY);\n        bucketLow = optionValue == null ? DEFAULT_BUCKET_LOW : Double.parseDouble(optionValue);\n        optionValue = options.get(BUCKET_HIGH_KEY);"}
{"magic_number_smell": "        sstableWindowUnit = optionValue == null ? DEFAULT_COMPACTION_WINDOW_UNIT : TimeUnit.valueOf(optionValue);\n\n        optionValue = options.get(COMPACTION_WINDOW_SIZE_KEY);\n        sstableWindowSize = optionValue == null ? 1 : Integer.parseInt(optionValue);\n\n        optionValue = options.get(EXPIRED_SSTABLE_CHECK_FREQUENCY_SECONDS_KEY);\n        expiredSSTableCheckFrequency = TimeUnit.MILLISECONDS.convert(optionValue == null ? DEFAULT_EXPIRED_SSTABLE_CHECK_FREQUENCY_SECONDS : Long.parseLong(optionValue), TimeUnit.SECONDS);", "refactored_code": "    protected static final int DEFAULT_COMPACTION_WINDOW_SIZE = 1;\n        sstableWindowUnit = optionValue == null ? DEFAULT_COMPACTION_WINDOW_UNIT : TimeUnit.valueOf(optionValue);\n\n        optionValue = options.get(COMPACTION_WINDOW_SIZE_KEY);\n        sstableWindowSize = optionValue == null ? DEFAULT_COMPACTION_WINDOW_SIZE : Integer.parseInt(optionValue);\n\n        optionValue = options.get(EXPIRED_SSTABLE_CHECK_FREQUENCY_SECONDS_KEY);\n        expiredSSTableCheckFrequency = TimeUnit.MILLISECONDS.convert(optionValue == null ? DEFAULT_EXPIRED_SSTABLE_CHECK_FREQUENCY_SECONDS : Long.parseLong(optionValue), TimeUnit.SECONDS);"}
{"magic_number_smell": "\n    public SplittingSizeTieredCompactionWriter(ColumnFamilyStore cfs, Directories directories, LifecycleTransaction txn, Set<SSTableReader> nonExpiredSSTables)\n    {\n        this(cfs, directories, txn, nonExpiredSSTables, 50_000_000);\n    }\n\n    public SplittingSizeTieredCompactionWriter(ColumnFamilyStore cfs, Directories directories, LifecycleTransaction txn, Set<SSTableReader> nonExpiredSSTables, long smallestSSTable)", "refactored_code": "    public static final long DEFAULT_SMALLEST_SSTABLE_BYTES = 50_000_000;\n\n    public SplittingSizeTieredCompactionWriter(ColumnFamilyStore cfs, Directories directories, LifecycleTransaction txn, Set<SSTableReader> nonExpiredSSTables)\n    {\n        this(cfs, directories, txn, nonExpiredSSTables, DEFAULT_SMALLEST_SSTABLE_BYTES);\n    }\n\n    public SplittingSizeTieredCompactionWriter(ColumnFamilyStore cfs, Directories directories, LifecycleTransaction txn, Set<SSTableReader> nonExpiredSSTables, long smallestSSTable)"}
{"magic_number_smell": "\n    public static <V> int headerLength(V context, ValueAccessor<V> accessor)\n    {\n        return TypeSizes.sizeof(Short.MAX_VALUE) + Math.abs(accessor.getShort(context, 0)) * HEADER_ELT_LENGTH;\n    }\n\n    private static int compareId(ByteBuffer bb1, int pos1, ByteBuffer bb2, int pos2)", "refactored_code": "    private static final int HEADER_SIZE_LENGTH = TypeSizes.sizeof(Short.MAX_VALUE);\n\n    public static <V> int headerLength(V context, ValueAccessor<V> accessor)\n    {\n        return HEADER_SIZE_LENGTH + Math.abs(accessor.getShort(context, 0)) * HEADER_ELT_LENGTH;\n    }\n\n    private static int compareId(ByteBuffer bb1, int pos1, ByteBuffer bb2, int pos2)"}
{"magic_number_smell": "\n        private static int makeHeaderByte(ColumnFilter selection)\n        {\n            return (selection.fetchesAllColumns(false) ? 0x01 : 0)\n                   | (!selection.isWildcard() ? HAS_QUERIED_MASK : 0)\n                   | (selection.subSelections() != null ? HAS_SUB_SELECTIONS_MASK : 0)\n                   | (selection.fetchesAllColumns(true) ? FETCH_ALL_STATICS_MASK : 0);", "refactored_code": "        private static final int FETCH_ALL_REGULARS_MASK = 0x01;\n\n        private static int makeHeaderByte(ColumnFilter selection)\n        {\n            return (selection.fetchesAllColumns(false) ? FETCH_ALL_REGULARS_MASK : 0)\n                   | (!selection.isWildcard() ? HAS_QUERIED_MASK : 0)\n                   | (selection.subSelections() != null ? HAS_SUB_SELECTIONS_MASK : 0)\n                   | (selection.fetchesAllColumns(true) ? FETCH_ALL_STATICS_MASK : 0);"}
{"magic_number_smell": "\n    public static final int Integer.MAX_VALUE = Integer.MAX_VALUE;\n\n    public static final DataLimits NONE = new CQLLimits(Integer.MAX_VALUE)\n    {\n        @Override\n        public boolean hasEnoughLiveData(CachedPartition cached, long nowInSec, boolean countPartitionsWithOnlyStaticData, boolean enforceStrictLiveness)", "refactored_code": "    public static final int NO_LIMIT = Integer.MAX_VALUE;\n\n    public static final int NO_LIMIT = Integer.MAX_VALUE;\n\n    public static final DataLimits NONE = new CQLLimits(NO_LIMIT)\n    {\n        @Override\n        public boolean hasEnoughLiveData(CachedPartition cached, long nowInSec, boolean countPartitionsWithOnlyStaticData, boolean enforceStrictLiveness)"}
{"magic_number_smell": "            return false;\n\n        int header = accessor.getShort(value, 0);\n        if ((header & 0xFFFF) != 0xFFFF)\n            return false;\n\n        return true;", "refactored_code": "    private static final int STATIC_MARKER = 0xFFFF;\n            return false;\n\n        int header = accessor.getShort(value, 0);\n        if ((header & 0xFFFF) != STATIC_MARKER)\n            return false;\n\n        return true;"}
{"magic_number_smell": "    private static final ByteBuffer MASKED_VALUE = instance.decompose(BigDecimal.ZERO);\n\n    private static final int 32 = 32;\n    private static final int MIN_SIGNIFICANT_DIGITS = 32;\n    private static final int MAX_SCALE = 1000;\n    private static final MathContext MAX_PRECISION = new MathContext(10000);\n", "refactored_code": "    private static final int MIN_SCALE = 32;\n    private static final ByteBuffer MASKED_VALUE = instance.decompose(BigDecimal.ZERO);\n\n    private static final int MIN_SCALE = 32;\n    private static final int MIN_SIGNIFICANT_DIGITS = MIN_SCALE;\n    private static final int MAX_SCALE = 1000;\n    private static final MathContext MAX_PRECISION = new MathContext(10000);\n"}
{"magic_number_smell": "                    {\n                        sizeReported = true;\n                        return signbyte >= 0\n                               ? 0x80 + (sizeToReport - 1)\n                               : 0x80 - sizeToReport;\n                    }\n                }", "refactored_code": "    private static final int POSITIVE_VARINT_HEADER = 0x80;\n                    {\n                        sizeReported = true;\n                        return signbyte >= 0\n                               ? POSITIVE_VARINT_HEADER + (sizeToReport - 1)\n                               : POSITIVE_VARINT_HEADER - sizeToReport;\n                    }\n                }"}
{"magic_number_smell": "    private void flushIfPeriodExpired()\n    {\n        int period = metadata().params.memtableFlushPeriodInMs;\n        if (period > 0 && (Clock.Global.nanoTime() - Clock.Global.nanoTime() >= TimeUnit.MILLISECONDS.toNanos(period)))\n        {\n            if (isClean())\n            {", "refactored_code": "    private final long creationNano = Clock.Global.nanoTime();\n    private void flushIfPeriodExpired()\n    {\n        int period = metadata().params.memtableFlushPeriodInMs;\n        if (period > 0 && (Clock.Global.nanoTime() - creationNano >= TimeUnit.MILLISECONDS.toNanos(period)))\n        {\n            if (isClean())\n            {"}
{"magic_number_smell": "                    data.putSingleton(key,\n                                      update,\n                                      updater::mergePartitions,\n                                      key.getKeyLength() < 128);\n                    allocator.offHeap().adjust(data.sizeOffHeap() - offHeap, opGroup);\n                    allocator.onHeap().adjust(data.sizeOnHeap() - onHeap, opGroup);\n                }", "refactored_code": "    public static final int MAX_RECURSIVE_KEY_LENGTH = 128;\n                    data.putSingleton(key,\n                                      update,\n                                      updater::mergePartitions,\n                                      key.getKeyLength() < MAX_RECURSIVE_KEY_LENGTH);\n                    allocator.offHeap().adjust(data.sizeOffHeap() - offHeap, opGroup);\n                    allocator.onHeap().adjust(data.sizeOnHeap() - onHeap, opGroup);\n                }"}
{"magic_number_smell": "    private static final int MAX_OPERATIONS = MONITORING_MAX_OPERATIONS.getInt();\n\n    @VisibleForTesting\n    static MonitoringTask instance = make(Math.max(0, MONITORING_REPORT_INTERVAL_MS.getInt()), MAX_OPERATIONS);\n\n    private final ScheduledFuture<?> reportingTask;\n    private final OperationsQueue failedOperationsQueue;", "refactored_code": "    private static final int REPORT_INTERVAL_MS = Math.max(0, MONITORING_REPORT_INTERVAL_MS.getInt());\n    private static final int MAX_OPERATIONS = MONITORING_MAX_OPERATIONS.getInt();\n\n    @VisibleForTesting\n    static MonitoringTask instance = make(REPORT_INTERVAL_MS, MAX_OPERATIONS);\n\n    private final ScheduledFuture<?> reportingTask;\n    private final OperationsQueue failedOperationsQueue;"}
{"magic_number_smell": "                                 ExecutorService executor,\n                                 BooleanSupplier isCancelled)\n    {\n        this(prsId, tables, tokenRanges, ACQUIRE_RETRY_SECONDS, CassandraRelevantProperties.ACQUIRE_SLEEP_MS.getInt(), executor, isCancelled);\n    }\n\n    @VisibleForTesting", "refactored_code": "    private static final int ACQUIRE_SLEEP_MS = CassandraRelevantProperties.ACQUIRE_SLEEP_MS.getInt();\n                                 ExecutorService executor,\n                                 BooleanSupplier isCancelled)\n    {\n        this(prsId, tables, tokenRanges, ACQUIRE_RETRY_SECONDS, ACQUIRE_SLEEP_MS, executor, isCancelled);\n    }\n\n    @VisibleForTesting"}
{"magic_number_smell": "    @Override\n    public long unsharedHeapSize()\n    {\n        return ObjectSizes.measure(new ArrayCell(ColumnMetadata.regularColumn(\"\", \"\", \"\", ByteType.instance), 0L, 0, 0, EMPTY_BYTE_ARRAY, null)) + ObjectSizes.sizeOfArray(value) + (path == null ? 0 : path.unsharedHeapSize());\n    }\n\n    @Override", "refactored_code": "    private static final long EMPTY_SIZE = ObjectSizes.measure(new ArrayCell(ColumnMetadata.regularColumn(\"\", \"\", \"\", ByteType.instance), 0L, 0, 0, EMPTY_BYTE_ARRAY, null));\n    @Override\n    public long unsharedHeapSize()\n    {\n        return EMPTY_SIZE + ObjectSizes.sizeOfArray(value) + (path == null ? 0 : path.unsharedHeapSize());\n    }\n\n    @Override"}
{"magic_number_smell": "    @Override\n    public long unsharedHeapSize()\n    {\n        long heapSize = ObjectSizes.measure(emptyRow(Clustering.EMPTY))\n                        + clustering.unsharedHeapSize()\n                        + primaryKeyLivenessInfo.unsharedHeapSize()\n                        + deletion.unsharedHeapSize()", "refactored_code": "    private static final long EMPTY_SIZE = ObjectSizes.measure(emptyRow(Clustering.EMPTY));\n    @Override\n    public long unsharedHeapSize()\n    {\n        long heapSize = EMPTY_SIZE\n                        + clustering.unsharedHeapSize()\n                        + primaryKeyLivenessInfo.unsharedHeapSize()\n                        + deletion.unsharedHeapSize()"}
{"magic_number_smell": "    @Override\n    public long unsharedHeapSize()\n    {\n        return ObjectSizes.measure(new BufferCell(ColumnMetadata.regularColumn(\"\", \"\", \"\", ByteType.instance), 0L, 0, 0, ByteBufferUtil.EMPTY_BYTE_BUFFER, null)) + ObjectSizes.sizeOnHeapOf(value) + (path == null ? 0 : path.unsharedHeapSize());\n    }\n\n    @Override", "refactored_code": "    private static final long EMPTY_SIZE = ObjectSizes.measure(new BufferCell(ColumnMetadata.regularColumn(\"\", \"\", \"\", ByteType.instance), 0L, 0, 0, ByteBufferUtil.EMPTY_BYTE_BUFFER, null));\n    @Override\n    public long unsharedHeapSize()\n    {\n        return EMPTY_SIZE + ObjectSizes.sizeOnHeapOf(value) + (path == null ? 0 : path.unsharedHeapSize());\n    }\n\n    @Override"}
{"magic_number_smell": "    /**\n     * The cell ttl.\n     *\n     * @return the cell ttl, or {@code 0} if the cell isn't an expiring one.\n     */\n    public abstract int ttl();\n", "refactored_code": "    public static final int NO_TTL = 0;\n    /**\n     * The cell ttl.\n     *\n     * @return the cell ttl, or {@code NO_TTL} if the cell isn't an expiring one.\n     */\n    public abstract int ttl();\n"}
{"magic_number_smell": "        @Override\n        public long unsharedHeapSize()\n        {\n            return ObjectSizes.measure(new SingleItemCellPath(ByteBufferUtil.EMPTY_BYTE_BUFFER)) + ObjectSizes.sizeOnHeapOf(value);\n        }\n\n        @Override", "refactored_code": "        private static final long EMPTY_SIZE = ObjectSizes.measure(new SingleItemCellPath(ByteBufferUtil.EMPTY_BYTE_BUFFER));\n        @Override\n        public long unsharedHeapSize()\n        {\n            return EMPTY_SIZE + ObjectSizes.sizeOnHeapOf(value);\n        }\n\n        @Override"}
{"magic_number_smell": "    }\n\n    // We should use this sparingly obviously\n    public static final EncodingStats NO_STATS = new EncodingStats(TIMESTAMP_EPOCH, DELETION_TIME_EPOCH, 0);\n    public static final long HEAP_SIZE = ObjectSizes.measure(NO_STATS);\n\n    public static final Serializer serializer = new Serializer();", "refactored_code": "    private static final int TTL_EPOCH = 0;\n    }\n\n    // We should use this sparingly obviously\n    public static final EncodingStats NO_STATS = new EncodingStats(TIMESTAMP_EPOCH, DELETION_TIME_EPOCH, TTL_EPOCH);\n    public static final long HEAP_SIZE = ObjectSizes.measure(NO_STATS);\n\n    public static final Serializer serializer = new Serializer();"}
{"magic_number_smell": "    @Override\n    public long unsharedHeapSize()\n    {\n        return ObjectSizes.measure(new NativeCell());\n    }\n\n    @Override", "refactored_code": "    private static final long EMPTY_SIZE = ObjectSizes.measure(new NativeCell());\n    @Override\n    public long unsharedHeapSize()\n    {\n        return EMPTY_SIZE;\n    }\n\n    @Override"}
{"magic_number_smell": "    @Override\n    public long unsharedHeapSize()\n    {\n        return ObjectSizes.measure(new RangeTombstoneBoundaryMarker(new ArrayClusteringBoundary(ClusteringPrefix.Kind.INCL_END_EXCL_START_BOUNDARY, new byte[][] { new byte[0]}), null, null)) + startDeletion.unsharedHeapSize() + endDeletion.unsharedHeapSize();\n    }\n\n    public String toString(TableMetadata metadata)", "refactored_code": "    private static final long EMPTY_SIZE = ObjectSizes.measure(new RangeTombstoneBoundaryMarker(new ArrayClusteringBoundary(ClusteringPrefix.Kind.INCL_END_EXCL_START_BOUNDARY, new byte[][] { new byte[0]}), null, null));\n    @Override\n    public long unsharedHeapSize()\n    {\n        return EMPTY_SIZE + startDeletion.unsharedHeapSize() + endDeletion.unsharedHeapSize();\n    }\n\n    public String toString(TableMetadata metadata)"}
{"magic_number_smell": "    @Override\n    public long unsharedHeapSize()\n    {\n        return ObjectSizes.measure(new RangeTombstoneBoundMarker(new ArrayClusteringBound(ClusteringPrefix.Kind.INCL_START_BOUND, AbstractArrayClusteringPrefix.EMPTY_VALUES_ARRAY), null)) + deletion.unsharedHeapSize();\n    }\n\n    public String toString(TableMetadata metadata)", "refactored_code": "    private static final long EMPTY_SIZE = ObjectSizes.measure(new RangeTombstoneBoundMarker(new ArrayClusteringBound(ClusteringPrefix.Kind.INCL_START_BOUND, AbstractArrayClusteringPrefix.EMPTY_VALUES_ARRAY), null));\n    @Override\n    public long unsharedHeapSize()\n    {\n        return EMPTY_SIZE + deletion.unsharedHeapSize();\n    }\n\n    public String toString(TableMetadata metadata)"}
{"magic_number_smell": "            if(this == LIVE)\n                return 0;\n\n            return ObjectSizes.measure(DeletionTime.build(0, 0)) + time().unsharedHeapSize();\n        }\n\n        @Override", "refactored_code": "        private static final long EMPTY_SIZE = ObjectSizes.measure(DeletionTime.build(0, 0));\n            if(this == LIVE)\n                return 0;\n\n            return EMPTY_SIZE + time().unsharedHeapSize();\n        }\n\n        @Override"}
{"magic_number_smell": "        {\n            if (cd.column().isSimple())\n            {\n                l = accumulateOnCell(collector, (Cell<?>) cd, l) + 1L << 32;\n            }\n            else\n            {", "refactored_code": "        private static final long COLUMN_INCR = 1L << 32;\n        {\n            if (cd.column().isSimple())\n            {\n                l = accumulateOnCell(collector, (Cell<?>) cd, l) + COLUMN_INCR;\n            }\n            else\n            {"}
{"magic_number_smell": "\n        if (iterator.isEmpty())\n        {\n            out.writeByte((byte)(flags | 0x01));\n            return;\n        }\n", "refactored_code": "    public  static final int IS_EMPTY               = 0x01;\n\n        if (iterator.isEmpty())\n        {\n            out.writeByte((byte)(flags | IS_EMPTY));\n            return;\n        }\n"}
{"magic_number_smell": "                long bytesTransferred = 0;\n                while (bytesTransferred < length)\n                {\n                    int toTransfer = (int) Math.min(1 << 16, length - bytesTransferred);\n                    long position = section.start + bytesTransferred;\n\n                    out.writeToChannel(bufferSupplier -> {", "refactored_code": "    private static final int CHUNK_SIZE = 1 << 16;\n                long bytesTransferred = 0;\n                while (bytesTransferred < length)\n                {\n                    int toTransfer = (int) Math.min(CHUNK_SIZE, length - bytesTransferred);\n                    long position = section.start + bytesTransferred;\n\n                    out.writeToChannel(bufferSupplier -> {"}
{"magic_number_smell": "        {\n            Keyspace ks = Keyspace.open(reader.getKeyspaceName());\n            // When doing mutation-based repair we split each partition into smaller batches\n            // ({@link Stream REPAIR_MUTATION_REPAIR_ROWS_PER_BATCH.getInt()}) to avoid OOMing and generating heap pressure\n            try (ISSTableScanner scanner = reader.getScanner();\n                 CloseableIterator<UnfilteredRowIterator> throttledPartitions = ThrottledUnfilteredIterator.throttle(scanner, REPAIR_MUTATION_REPAIR_ROWS_PER_BATCH.getInt()))\n            {", "refactored_code": "    private static final int MAX_ROWS_PER_BATCH = REPAIR_MUTATION_REPAIR_ROWS_PER_BATCH.getInt();\n        {\n            Keyspace ks = Keyspace.open(reader.getKeyspaceName());\n            // When doing mutation-based repair we split each partition into smaller batches\n            // ({@link Stream MAX_ROWS_PER_BATCH}) to avoid OOMing and generating heap pressure\n            try (ISSTableScanner scanner = reader.getScanner();\n                 CloseableIterator<UnfilteredRowIterator> throttledPartitions = ThrottledUnfilteredIterator.throttle(scanner, MAX_ROWS_PER_BATCH))\n            {"}
{"magic_number_smell": "        try(ChannelProxy proxy = sstable.getDataChannel().newChannel();\n            ChecksumValidator validator = sstable.maybeGetChecksumValidator())\n        {\n            int bufferSize = validator == null ? 64 * 1024: validator.chunkSize;\n\n            // setting up data compression stream\n            long progress = 0L;", "refactored_code": "    private static final int DEFAULT_CHUNK_SIZE = 64 * 1024;\n        try(ChannelProxy proxy = sstable.getDataChannel().newChannel();\n            ChecksumValidator validator = sstable.maybeGetChecksumValidator())\n        {\n            int bufferSize = validator == null ? DEFAULT_CHUNK_SIZE: validator.chunkSize;\n\n            // setting up data compression stream\n            long progress = 0L;"}
{"magic_number_smell": "                // configured uncompressed chunk size - depending on data, min_compress_ratio, and compressor;\n                // we may need to resize the compressed buffer.\n                FileUtils.clean(compressedChunk);\n                compressedChunk = ByteBuffer.allocateDirect(max((int) (compressedChunk.capacity() * 1.5), chunkLength));\n            }\n\n            compressedChunk.position(0).limit(chunkLength);", "refactored_code": "    private static final double GROWTH_FACTOR = 1.5;\n                // configured uncompressed chunk size - depending on data, min_compress_ratio, and compressor;\n                // we may need to resize the compressed buffer.\n                FileUtils.clean(compressedChunk);\n                compressedChunk = ByteBuffer.allocateDirect(max((int) (compressedChunk.capacity() * GROWTH_FACTOR), chunkLength));\n            }\n\n            compressedChunk.position(0).limit(chunkLength);"}
{"magic_number_smell": "    public long sizeOnHeap()\n    {\n        return contentCount * MemoryMeterStrategy.MEMORY_LAYOUT.getReferenceSize() +\n               ObjectSizes.measureDeep(new AtomicReferenceArray<>(0)) * getChunkIdx(contentCount, CONTENTS_START_SHIFT, CONTENTS_START_SIZE) +\n               (bufferType == BufferType.ON_HEAP ? allocatedPos + EMPTY_SIZE_ON_HEAP : EMPTY_SIZE_OFF_HEAP) +\n               ObjectSizes.measureDeep(new AtomicReferenceArray<>(0)) * getChunkIdx(allocatedPos, BUF_START_SHIFT, BUF_START_SIZE);\n    }", "refactored_code": "    private static final long REFERENCE_ARRAY_ON_HEAP_SIZE = ObjectSizes.measureDeep(new AtomicReferenceArray<>(0));\n    public long sizeOnHeap()\n    {\n        return contentCount * MemoryMeterStrategy.MEMORY_LAYOUT.getReferenceSize() +\n               REFERENCE_ARRAY_ON_HEAP_SIZE * getChunkIdx(contentCount, CONTENTS_START_SHIFT, CONTENTS_START_SIZE) +\n               (bufferType == BufferType.ON_HEAP ? allocatedPos + EMPTY_SIZE_ON_HEAP : EMPTY_SIZE_OFF_HEAP) +\n               REFERENCE_ARRAY_ON_HEAP_SIZE * getChunkIdx(allocatedPos, BUF_START_SHIFT, BUF_START_SIZE);\n    }"}
{"magic_number_smell": "        // Split the new local ranges and add them to the pending set\n        DatabaseDescriptor.getPartitioner()\n                          .splitter()\n                          .map(s -> s.split(newRanges, Runtime.getRuntime().availableProcessors() * 4))\n                          .orElse(newRanges)\n                          .forEach(r -> pendingRanges.put(r, Pair.<Token, Long>create(null, 0L)));\n", "refactored_code": "    private static final int NUM_TASKS = Runtime.getRuntime().availableProcessors() * 4;\n        // Split the new local ranges and add them to the pending set\n        DatabaseDescriptor.getPartitioner()\n                          .splitter()\n                          .map(s -> s.split(newRanges, NUM_TASKS))\n                          .orElse(newRanges)\n                          .forEach(r -> pendingRanges.put(r, Pair.<Token, Long>create(null, 0L)));\n"}
{"magic_number_smell": "                        buildKey(key);\n                        ++keysBuilt;\n                    }\n                    if (keysBuilt % 1000 == 1)\n                        SystemKeyspace.updateViewBuildStatus(ksName, view.name, range, token, keysBuilt);\n                    prevToken = token;\n                }", "refactored_code": "    private static final int ROWS_BETWEEN_CHECKPOINTS = 1000;\n                        buildKey(key);\n                        ++keysBuilt;\n                    }\n                    if (keysBuilt % ROWS_BETWEEN_CHECKPOINTS == 1)\n                        SystemKeyspace.updateViewBuildStatus(ksName, view.name, range, token, keysBuilt);\n                    prevToken = token;\n                }"}
{"magic_number_smell": "    static int resolveBufferSize()\n    {\n        int size = CassandraRelevantProperties.LOGS_VIRTUAL_TABLE_MAX_ROWS.getInt();\n        return (size < 1000 || size > LOGS_VIRTUAL_TABLE_MAX_ROWS)\n               ? LOGS_VIRTUAL_TABLE_DEFAULT_ROWS : size;\n    }\n", "refactored_code": "    public static final int LOGS_VIRTUAL_TABLE_MIN_ROWS = 1000;\n    static int resolveBufferSize()\n    {\n        int size = CassandraRelevantProperties.LOGS_VIRTUAL_TABLE_MAX_ROWS.getInt();\n        return (size < LOGS_VIRTUAL_TABLE_MIN_ROWS || size > LOGS_VIRTUAL_TABLE_MAX_ROWS)\n               ? LOGS_VIRTUAL_TABLE_DEFAULT_ROWS : size;\n    }\n"}
{"magic_number_smell": "        @Override\n        public long getHeapSize()\n        {\n            return ObjectSizes.measure(MINIMUM) + ObjectSizes.sizeOfArray(token);\n        }\n\n        @Override", "refactored_code": "    private static final long EMPTY_SIZE = ObjectSizes.measure(MINIMUM);\n        @Override\n        public long getHeapSize()\n        {\n            return EMPTY_SIZE + ObjectSizes.sizeOfArray(token);\n        }\n\n        @Override"}
{"magic_number_smell": "        @Override\n        public long getHeapSize()\n        {\n            return ObjectSizes.measure(new LocalPartitioner(null).new LocalToken()) + ObjectSizes.sizeOnHeapOf(token);\n        }\n    }\n}", "refactored_code": "    private static final long EMPTY_SIZE = ObjectSizes.measure(new LocalPartitioner(null).new LocalToken());\n        @Override\n        public long getHeapSize()\n        {\n            return EMPTY_SIZE + ObjectSizes.sizeOnHeapOf(token);\n        }\n    }\n}"}
{"magic_number_smell": "{\n    public static final LongToken MINIMUM = new LongToken(Long.MIN_VALUE);\n    public static final long Long.MAX_VALUE = Long.MAX_VALUE;\n    private static final int MAXIMUM_TOKEN_SIZE = TypeSizes.sizeof(Long.MAX_VALUE);\n\n    private static final int HEAP_SIZE = (int) ObjectSizes.measureDeep(MINIMUM);\n", "refactored_code": "    public static final long MAXIMUM = Long.MAX_VALUE;\n{\n    public static final LongToken MINIMUM = new LongToken(Long.MIN_VALUE);\n    public static final long MAXIMUM = Long.MAX_VALUE;\n    private static final int MAXIMUM_TOKEN_SIZE = TypeSizes.sizeof(MAXIMUM);\n\n    private static final int HEAP_SIZE = (int) ObjectSizes.measureDeep(MINIMUM);\n"}
{"magic_number_smell": "        @Override\n        public long getHeapSize()\n        {\n            return ObjectSizes.measure(MINIMUM) + ObjectSizes.sizeOf(token);\n        }\n\n        @Override", "refactored_code": "    private static final long EMPTY_SIZE = ObjectSizes.measure(MINIMUM);\n        @Override\n        public long getHeapSize()\n        {\n            return EMPTY_SIZE + ObjectSizes.sizeOf(token);\n        }\n\n        @Override"}
{"magic_number_smell": "\n    public int getMaxTokenSize()\n    {\n        return MAXIMUM.bitLength() / 8 + 1;\n    }\n\n    public Map<Token, Float> describeOwnership(List<Token> sortedTokens)", "refactored_code": "    public static final int MAXIMUM_TOKEN_SIZE = MAXIMUM.bitLength() / 8 + 1;\n\n    public int getMaxTokenSize()\n    {\n        return MAXIMUM_TOKEN_SIZE;\n    }\n\n    public Map<Token, Float> describeOwnership(List<Token> sortedTokens)"}
{"magic_number_smell": "            BigInteger r = partitioner.splitter().get().valueForToken(range.right);\n            if (r.compareTo(l) <= 0)\n                return false;\n            if (r.subtract(l).compareTo(BigInteger.valueOf(1000)) < 0)\n                return true;\n        }\n        return false;", "refactored_code": "    private static final long TRIVIAL_RANGE_LIMIT = 1000;\n            BigInteger r = partitioner.splitter().get().valueForToken(range.right);\n            if (r.compareTo(l) <= 0)\n                return false;\n            if (r.subtract(l).compareTo(BigInteger.valueOf(TRIVIAL_RANGE_LIMIT)) < 0)\n                return true;\n        }\n        return false;"}
{"magic_number_smell": "        @Override\n        public long getHeapSize()\n        {\n            return ObjectSizes.measure(MIN_TOKEN);\n        }\n\n        @Override", "refactored_code": "    private static final long HEAP_SIZE = ObjectSizes.measure(MIN_TOKEN);\n        @Override\n        public long getHeapSize()\n        {\n            return HEAP_SIZE;\n        }\n\n        @Override"}
{"magic_number_smell": "    Map<Unit, PriorityQueue<Weighted<TokenInfo>>> tokensInUnits = Maps.newHashMap();\n\n    private static final double 0.90 = 0.90;\n    private static final double MIN_TAKEOVER_RATIO = 1.0 - 0.90;\n\n    public NoReplicationTokenAllocator(NavigableMap<Token, Unit> sortedTokens,\n                                       ReplicationStrategy<Unit> strategy,", "refactored_code": "    private static final double MAX_TAKEOVER_RATIO = 0.90;\n    Map<Unit, PriorityQueue<Weighted<TokenInfo>>> tokensInUnits = Maps.newHashMap();\n\n    private static final double MAX_TAKEOVER_RATIO = 0.90;\n    private static final double MIN_TAKEOVER_RATIO = 1.0 - MAX_TAKEOVER_RATIO;\n\n    public NoReplicationTokenAllocator(NavigableMap<Token, Unit> sortedTokens,\n                                       ReplicationStrategy<Unit> strategy,"}
{"magic_number_smell": "        logger.debug(\"Replicated node load in datacenter after allocation {}\", statToString(ns));\n\n        double stdDevGrowth = ns.getStandardDeviation() - os.getStandardDeviation();\n        if (stdDevGrowth > TokenAllocation.0.05)\n        {\n            logger.warn(String.format(\"Growth of %.2f%% in token ownership standard deviation after allocation above warning threshold of %d%%\",\n                                      stdDevGrowth * 100, (int)(TokenAllocation.0.05 * 100)));", "refactored_code": "    public static final double WARN_STDEV_GROWTH = 0.05;\n        logger.debug(\"Replicated node load in datacenter after allocation {}\", statToString(ns));\n\n        double stdDevGrowth = ns.getStandardDeviation() - os.getStandardDeviation();\n        if (stdDevGrowth > TokenAllocation.WARN_STDEV_GROWTH)\n        {\n            logger.warn(String.format(\"Growth of %.2f%% in token ownership standard deviation after allocation above warning threshold of %d%%\",\n                                      stdDevGrowth * 100, (int)(TokenAllocation.WARN_STDEV_GROWTH * 100)));"}
{"magic_number_smell": "        @Override\n        protected long version()\n        {\n            return 0;\n        }\n\n        @Override", "refactored_code": "    public static final long CURRENT_VERSION = 0; // encode a dummy version, to prevent pain in decoding in the future\n        @Override\n        protected long version()\n        {\n            return CURRENT_VERSION;\n        }\n\n        @Override"}
{"magic_number_smell": "        if (heartbeatWindow == null)\n        {\n            // avoid adding an empty ArrivalWindow to the Map\n            heartbeatWindow = new ArrivalWindow(1000);\n            heartbeatWindow.add(now, ep);\n            heartbeatWindow = arrivalSamples.putIfAbsent(ep, heartbeatWindow);\n            if (heartbeatWindow != null)", "refactored_code": "    private static final int SAMPLE_SIZE = 1000;\n        if (heartbeatWindow == null)\n        {\n            // avoid adding an empty ArrivalWindow to the Map\n            heartbeatWindow = new ArrivalWindow(SAMPLE_SIZE);\n            heartbeatWindow.add(now, ep);\n            heartbeatWindow = arrivalSamples.putIfAbsent(ep, heartbeatWindow);\n            if (heartbeatWindow != null)"}
{"magic_number_smell": "\n    protected long getExpireTimeForEndpoint(InetAddressAndPort endpoint)\n    {\n        /* default expireTime is getVeryLongTime() */\n        Long storedTime = expireTimeEndpointMap.get(endpoint);\n        return storedTime == null ? computeExpireTime() : storedTime;\n    }", "refactored_code": "    public static final long aVeryLongTime = getVeryLongTime();\n\n    protected long getExpireTimeForEndpoint(InetAddressAndPort endpoint)\n    {\n        /* default expireTime is aVeryLongTime */\n        Long storedTime = expireTimeEndpointMap.get(endpoint);\n        return storedTime == null ? computeExpireTime() : storedTime;\n    }"}
{"magic_number_smell": "\n    public static HeartBeatState empty()\n    {\n        return new HeartBeatState(0, -1);\n    }\n\n    public boolean isEmpty()", "refactored_code": "    public static final int EMPTY_VERSION = -1;\n\n    public static HeartBeatState empty()\n    {\n        return new HeartBeatState(0, EMPTY_VERSION);\n    }\n\n    public boolean isEmpty()"}
{"magic_number_smell": "            boolean timedOut;\n            try\n            {\n                timedOut = !condition.awaitUntil(HINT_REQ.expiresAtNanos(approxTime.now()));\n            }\n            catch (InterruptedException e)\n            {", "refactored_code": "        private final long start = approxTime.now();\n            boolean timedOut;\n            try\n            {\n                timedOut = !condition.awaitUntil(HINT_REQ.expiresAtNanos(start));\n            }\n            catch (InterruptedException e)\n            {"}
{"magic_number_smell": "                if (input.isEOF())\n                    return endOfData(); // reached EOF\n\n                if (position.subtract(offset) >= 512 << 10)\n                    return endOfData(); // read page size or more bytes\n\n                try", "refactored_code": "    private static final int PAGE_SIZE = 512 << 10;\n                if (input.isEOF())\n                    return endOfData(); // reached EOF\n\n                if (position.subtract(offset) >= PAGE_SIZE)\n                    return endOfData(); // read page size or more bytes\n\n                try"}
{"magic_number_smell": "        catalog = HintsCatalog.load(hintsDirectory, createDescriptorParams());\n        writeExecutor = new HintsWriteExecutor(catalog);\n\n        int bufferSize = Math.max(DatabaseDescriptor.getMaxMutationSize() * 2, 32 << 20);\n        bufferPool = new HintsBufferPool(bufferSize, writeExecutor::flushBuffer);\n\n        isDispatchPaused = new AtomicBoolean(true);", "refactored_code": "    private static final int MIN_BUFFER_SIZE = 32 << 20;\n        catalog = HintsCatalog.load(hintsDirectory, createDescriptorParams());\n        writeExecutor = new HintsWriteExecutor(catalog);\n\n        int bufferSize = Math.max(DatabaseDescriptor.getMaxMutationSize() * 2, MIN_BUFFER_SIZE);\n        bufferPool = new HintsBufferPool(bufferSize, writeExecutor::flushBuffer);\n\n        isDispatchPaused = new AtomicBoolean(true);"}
{"magic_number_smell": "    public int calculateIndexingPageSize()\n    {\n        if (FORCE_DEFAULT_INDEXING_PAGE_SIZE.getBoolean())\n            return 10000;\n\n        double targetPageSizeInBytes = 32 * 1024 * 1024;\n        double meanPartitionSize = baseCfs.getMeanPartitionSize();", "refactored_code": "    public static final int DEFAULT_PAGE_SIZE = 10000;\n    public int calculateIndexingPageSize()\n    {\n        if (FORCE_DEFAULT_INDEXING_PAGE_SIZE.getBoolean())\n            return DEFAULT_PAGE_SIZE;\n\n        double targetPageSizeInBytes = 32 * 1024 * 1024;\n        double meanPartitionSize = baseCfs.getMeanPartitionSize();"}
{"magic_number_smell": "        memtableIndexManager = new MemtableIndexManager(this);\n        indexMetrics = new IndexMetrics(this, memtableIndexManager);\n        maxTermSize = indexTermType.isVector() ? MAX_VECTOR_TERM_SIZE\n                                               : (indexTermType.isFrozen() ? MAX_FROZEN_TERM_SIZE : SAI_MAX_STRING_TERM_SIZE.getSizeInBytes());\n    }\n\n    /**", "refactored_code": "    public static final long MAX_STRING_TERM_SIZE = SAI_MAX_STRING_TERM_SIZE.getSizeInBytes();\n        memtableIndexManager = new MemtableIndexManager(this);\n        indexMetrics = new IndexMetrics(this, memtableIndexManager);\n        maxTermSize = indexTermType.isVector() ? MAX_VECTOR_TERM_SIZE\n                                               : (indexTermType.isFrozen() ? MAX_FROZEN_TERM_SIZE : MAX_STRING_TERM_SIZE);\n    }\n\n    /**"}
{"magic_number_smell": "                    throw new InvalidRequestException(String.format(\"Maximum number of connections %s is not a valid integer for index %s\",\n                                                                    options.get(MAXIMUM_NODE_CONNECTIONS), indexName));\n                }\n                if (maximumNodeConnections <= 0 || maximumNodeConnections > 512)\n                    throw new InvalidRequestException(String.format(\"Maximum number of connections for index %s cannot be <= 0 or > %s, was %s\", indexName, 512, maximumNodeConnections));\n            }\n            if (options.containsKey(CONSTRUCTION_BEAM_WIDTH))", "refactored_code": "    public static final int MAXIMUM_MAXIMUM_NODE_CONNECTIONS = 512;\n                    throw new InvalidRequestException(String.format(\"Maximum number of connections %s is not a valid integer for index %s\",\n                                                                    options.get(MAXIMUM_NODE_CONNECTIONS), indexName));\n                }\n                if (maximumNodeConnections <= 0 || maximumNodeConnections > MAXIMUM_MAXIMUM_NODE_CONNECTIONS)\n                    throw new InvalidRequestException(String.format(\"Maximum number of connections for index %s cannot be <= 0 or > %s, was %s\", indexName, MAXIMUM_MAXIMUM_NODE_CONNECTIONS, maximumNodeConnections));\n            }\n            if (options.containsKey(CONSTRUCTION_BEAM_WIDTH))"}
{"magic_number_smell": "\n    private PrimaryKey minKey;\n    private PrimaryKey maxKey;\n    private long maxSSTableRowId = -1;\n    private int rowCount;\n\n    public MemtableIndexWriter(MemtableIndex memtable,", "refactored_code": "    private static final int NO_ROWS = -1;\n\n    private PrimaryKey minKey;\n    private PrimaryKey maxKey;\n    private long maxSSTableRowId = NO_ROWS;\n    private int rowCount;\n\n    public MemtableIndexWriter(MemtableIndex memtable,"}
{"magic_number_smell": "\n        if (index.termType().isNonFrozenCollection())\n        {\n            Iterator<ByteBuffer> valueIterator = index.termType().valuesOf(row, FBUtilities.nowInSeconds());\n            if (valueIterator != null)\n            {\n                while (valueIterator.hasNext())", "refactored_code": "    private final long nowInSec = FBUtilities.nowInSeconds();\n\n        if (index.termType().isNonFrozenCollection())\n        {\n            Iterator<ByteBuffer> valueIterator = index.termType().valuesOf(row, nowInSec);\n            if (valueIterator != null)\n            {\n                while (valueIterator.hasNext())"}
{"magic_number_smell": "     */\n    public static final long DatabaseDescriptor.getSAISegmentWriteBufferSpace().toBytes() = DatabaseDescriptor.getSAISegmentWriteBufferSpace().toBytes();\n\n    public static final NamedMemoryLimiter SEGMENT_BUILD_MEMORY_LIMITER = new NamedMemoryLimiter(DatabaseDescriptor.getSAISegmentWriteBufferSpace().toBytes(),\n                                                                                                 \"Storage Attached Index Segment Builder\");\n\n    static", "refactored_code": "    public static final long SEGMENT_BUILD_MEMORY_LIMIT = DatabaseDescriptor.getSAISegmentWriteBufferSpace().toBytes();\n     */\n    public static final long SEGMENT_BUILD_MEMORY_LIMIT = DatabaseDescriptor.getSAISegmentWriteBufferSpace().toBytes();\n\n    public static final NamedMemoryLimiter SEGMENT_BUILD_MEMORY_LIMITER = new NamedMemoryLimiter(SEGMENT_BUILD_MEMORY_LIMIT,\n                                                                                                 \"Storage Attached Index Segment Builder\");\n\n    static"}
{"magic_number_smell": "                              IndexIdentifier indexIdentifier,\n                              int bytesPerValue)\n    {\n        this(indexDescriptor, indexIdentifier, BlockBalancedTreeWriter.DEFAULT_MAX_POINTS_IN_LEAF_NODE, bytesPerValue);\n    }\n\n    @VisibleForTesting", "refactored_code": "    public static final int MAX_POINTS_IN_LEAF_NODE = BlockBalancedTreeWriter.DEFAULT_MAX_POINTS_IN_LEAF_NODE;\n                              IndexIdentifier indexIdentifier,\n                              int bytesPerValue)\n    {\n        this(indexDescriptor, indexIdentifier, MAX_POINTS_IN_LEAF_NODE, bytesPerValue);\n    }\n\n    @VisibleForTesting"}
{"magic_number_smell": "                               MetadataWriter metadataWriter,\n                               boolean monotonic) throws IOException\n    {\n        this(indexDescriptor, indexComponent, metadataWriter, monotonic, monotonic ? 16384 : BLOCK_SIZE);\n    }\n\n    public NumericValuesWriter(IndexDescriptor indexDescriptor,", "refactored_code": "    public static final int MONOTONIC_BLOCK_SIZE = 16384;\n                               MetadataWriter metadataWriter,\n                               boolean monotonic) throws IOException\n    {\n        this(indexDescriptor, indexComponent, metadataWriter, monotonic, monotonic ? MONOTONIC_BLOCK_SIZE : BLOCK_SIZE);\n    }\n\n    public NumericValuesWriter(IndexDescriptor indexDescriptor,"}
{"magic_number_smell": "\n        try\n        {\n            trie.putSingleton(term, segmentRowId, postingsAccumulator, termLength <= 128);\n        }\n        catch (InMemoryTrie.SpaceExhaustedException e)\n        {", "refactored_code": "    private static final int MAX_RECURSIVE_TERM_LENGTH = 128;\n\n        try\n        {\n            trie.putSingleton(term, segmentRowId, postingsAccumulator, termLength <= MAX_RECURSIVE_TERM_LENGTH);\n        }\n        catch (InMemoryTrie.SpaceExhaustedException e)\n        {"}
{"magic_number_smell": "    {\n        // Since we are looking for an exact match we are always expecting the follow\n        // to return END_OF_STREAM if the key was found.\n        return follow(key) == ByteSource.END_OF_STREAM ? getCurrentPayload() : -1;\n    }\n\n    private long getCurrentPayload()", "refactored_code": "    public static final long NOT_FOUND = -1;\n    {\n        // Since we are looking for an exact match we are always expecting the follow\n        // to return END_OF_STREAM if the key was found.\n        return follow(key) == ByteSource.END_OF_STREAM ? getCurrentPayload() : NOT_FOUND;\n    }\n\n    private long getCurrentPayload()"}
{"magic_number_smell": "                throw new IllegalArgumentException(\"non-finite value at vector[\" + i + \"]=\" + v[i]);\n            }\n\n            if (Math.abs(v[i]) > 1E17f)\n            {\n                throw new IllegalArgumentException(\"Out-of-bounds value at vector[\" + i + \"]=\" + v[i]);\n            }", "refactored_code": "    public static final float MAX_FLOAT32_COMPONENT = 1E17f;\n                throw new IllegalArgumentException(\"non-finite value at vector[\" + i + \"]=\" + v[i]);\n            }\n\n            if (Math.abs(v[i]) > MAX_FLOAT32_COMPONENT)\n            {\n                throw new IllegalArgumentException(\"Out-of-bounds value at vector[\" + i + \"]=\" + v[i]);\n            }"}
{"magic_number_smell": "\n            try\n            {\n                if (term.limit() <= 128)\n                {\n                    data.putRecursive(comparableBytes, primaryKey, primaryKeysReducer);\n                }", "refactored_code": "    private static final int MAX_RECURSIVE_KEY_LENGTH = 128;\n\n            try\n            {\n                if (term.limit() <= MAX_RECURSIVE_KEY_LENGTH)\n                {\n                    data.putRecursive(comparableBytes, primaryKey, primaryKeysReducer);\n                }"}
{"magic_number_smell": "        else if (isBigInteger())\n            return BIG_INTEGER_APPROXIMATION_BYTES;\n        else if (isBigDecimal())\n            return 24;\n        return DEFAULT_FIXED_LENGTH;\n    }\n", "refactored_code": "    private static final int DECIMAL_APPROXIMATION_BYTES = 24;\n        else if (isBigInteger())\n            return BIG_INTEGER_APPROXIMATION_BYTES;\n        else if (isBigDecimal())\n            return DECIMAL_APPROXIMATION_BYTES;\n        return DEFAULT_FIXED_LENGTH;\n    }\n"}
{"magic_number_smell": "\n    public long unsharedHeapSize()\n    {\n        return ObjectSizes.measure(new PrimaryKeys());\n    }\n\n    @Override", "refactored_code": "    private static final long EMPTY_SIZE = ObjectSizes.measure(new PrimaryKeys());\n\n    public long unsharedHeapSize()\n    {\n        return EMPTY_SIZE;\n    }\n\n    @Override"}
{"magic_number_smell": "        private boolean allTermsToUpperCase;\n        private boolean allTermsToLowerCase;\n        private int minTokenLength = DEFAULT_MIN_TOKEN_LENGTH;\n        private int maxTokenLength = 255;\n\n        public OptionsBuilder()\n        {", "refactored_code": "    public static final int DEFAULT_MAX_TOKEN_LENGTH = 255;\n        private boolean allTermsToUpperCase;\n        private boolean allTermsToLowerCase;\n        private int minTokenLength = DEFAULT_MIN_TOKEN_LENGTH;\n        private int maxTokenLength = DEFAULT_MAX_TOKEN_LENGTH;\n\n        public OptionsBuilder()\n        {"}
{"magic_number_smell": "    private static final String INDEX_IS_LITERAL_OPTION = \"is_literal\";\n    private static final String INDEX_MAX_FLUSH_MEMORY_OPTION = \"max_compaction_flush_memory_in_mb\";\n    private static final double 0.15 = 0.15;\n    private static final long DEFAULT_MAX_MEM_BYTES = (long) (1073741824 * 0.15); // 1G default for memtable\n\n    public final Mode mode;\n    public final boolean isAnalyzed, isLiteral;", "refactored_code": "    private static final double INDEX_MAX_FLUSH_DEFAULT_MULTIPLIER = 0.15;\n    private static final String INDEX_IS_LITERAL_OPTION = \"is_literal\";\n    private static final String INDEX_MAX_FLUSH_MEMORY_OPTION = \"max_compaction_flush_memory_in_mb\";\n    private static final double INDEX_MAX_FLUSH_DEFAULT_MULTIPLIER = 0.15;\n    private static final long DEFAULT_MAX_MEM_BYTES = (long) (1073741824 * INDEX_MAX_FLUSH_DEFAULT_MULTIPLIER); // 1G default for memtable\n\n    public final Mode mode;\n    public final boolean isAnalyzed, isLiteral;"}
{"magic_number_smell": "         */\n        private int mask(int bit)\n        {\n            return 1 << Byte.SIZE-1 >>> bit;\n        }\n    }\n}", "refactored_code": "        private static final int MSB = 1 << Byte.SIZE-1;\n         */\n        private int mask(int bit)\n        {\n            return MSB >>> bit;\n        }\n    }\n}"}
{"magic_number_smell": "    public static final int IS_PARTIAL_BIT = 15;\n\n    private static final SequentialWriterOption WRITER_OPTION = SequentialWriterOption.newBuilder()\n                                                                                      .bufferSize(4096)\n                                                                                      .build();\n\n    private final List<MutableLevel<InMemoryPointerTerm>> levels = new ArrayList<>();", "refactored_code": "    public static final int BLOCK_SIZE = 4096;\n    public static final int IS_PARTIAL_BIT = 15;\n\n    private static final SequentialWriterOption WRITER_OPTION = SequentialWriterOption.newBuilder()\n                                                                                      .bufferSize(BLOCK_SIZE)\n                                                                                      .build();\n\n    private final List<MutableLevel<InMemoryPointerTerm>> levels = new ArrayList<>();"}
{"magic_number_smell": "    static\n    {\n        INDEX_FLUSHER_GENERAL = executorFactory().withJmxInternal()\n                                                 .pooled(\"SASI-General\", 8);\n\n        INDEX_FLUSHER_MEMTABLE = executorFactory().withJmxInternal()\n                                                  .pooled(\"SASI-Memtable\", 8);", "refactored_code": "    private static final int POOL_SIZE = 8;\n    static\n    {\n        INDEX_FLUSHER_GENERAL = executorFactory().withJmxInternal()\n                                                 .pooled(\"SASI-General\", POOL_SIZE);\n\n        INDEX_FLUSHER_MEMTABLE = executorFactory().withJmxInternal()\n                                                  .pooled(\"SASI-Memtable\", POOL_SIZE);"}
{"magic_number_smell": "            if (minToken > token)\n            {\n                // seek to beginning of child offsets to locate first child\n                file.position(seekBase + tokenCount * Long.SIZE / 8);\n                blockStart = (startPos + (int) file.getLong());\n            }\n            else if (maxToken < token)", "refactored_code": "    private static final int LONG_BYTES = Long.SIZE / 8;\n            if (minToken > token)\n            {\n                // seek to beginning of child offsets to locate first child\n                file.position(seekBase + tokenCount * LONG_BYTES);\n                blockStart = (startPos + (int) file.getLong());\n            }\n            else if (maxToken < token)"}
{"magic_number_smell": "\n    public long add(DecoratedKey key, ByteBuffer value)\n    {\n        long overhead = 128; // DKs are shared\n        ConcurrentSkipListSet<DecoratedKey> keys = index.get(value);\n\n        if (keys == null)", "refactored_code": "    public static final int CSLM_OVERHEAD = 128; // average overhead of CSLM\n\n    public long add(DecoratedKey key, ByteBuffer value)\n    {\n        long overhead = CSLM_OVERHEAD; // DKs are shared\n        ConcurrentSkipListSet<DecoratedKey> keys = index.get(value);\n\n        if (keys == null)"}
{"magic_number_smell": "\n                suffixes[i] = (termIndex << 32) | i;\n                if (isComplete)\n                    suffixes[i] |= (1L << 31);\n\n                isComplete = false;\n            }", "refactored_code": "        private static final int COMPLETE_BIT = 31;\n\n                suffixes[i] = (termIndex << 32) | i;\n                if (isComplete)\n                    suffixes[i] |= (1L << COMPLETE_BIT);\n\n                isComplete = false;\n            }"}
{"magic_number_smell": "    static class TrieEntry<K,V> extends BasicEntry<K, V>\n    {\n\n        private static final long -2303909182832019043L = 4596023148184140013L;\n\n        /** The index this entry is comparing. */\n        protected int bitIndex;", "refactored_code": "    private static final long serialVersionUID = -2303909182832019043L;\n    static class TrieEntry<K,V> extends BasicEntry<K, V>\n    {\n\n        private static final long serialVersionUID = 4596023148184140013L;\n\n        /** The index this entry is comparing. */\n        protected int bitIndex;"}
{"magic_number_smell": "     */\n    abstract static class BasicEntry<K, V> implements Map.Entry<K, V>, Serializable\n    {\n        private static final long -6358111100045408883L = -944364551314110330L;\n\n        protected K key;\n", "refactored_code": "    private static final long serialVersionUID = -6358111100045408883L;\n     */\n    abstract static class BasicEntry<K, V> implements Map.Entry<K, V>, Serializable\n    {\n        private static final long serialVersionUID = -944364551314110330L;\n\n        protected K key;\n"}
{"magic_number_smell": "    public static Integer validateCompressionLevel(String compressionLevel) throws ConfigurationException\n    {\n        if (compressionLevel == null)\n            return 9;\n\n        ConfigurationException ex = new ConfigurationException(\"Invalid value [\" + compressionLevel + \"] for parameter '\"\n                                                                 + LZ4_HIGH_COMPRESSION_LEVEL + \"'. Value must be between 1 and 17.\");", "refactored_code": "    private static final int DEFAULT_HIGH_COMPRESSION_LEVEL = 9;\n    public static Integer validateCompressionLevel(String compressionLevel) throws ConfigurationException\n    {\n        if (compressionLevel == null)\n            return DEFAULT_HIGH_COMPRESSION_LEVEL;\n\n        ConfigurationException ex = new ConfigurationException(\"Invalid value [\" + compressionLevel + \"] for parameter '\"\n                                                                 + LZ4_HIGH_COMPRESSION_LEVEL + \"'. Value must be between 1 and 17.\");"}
{"magic_number_smell": "     */\n    private static boolean isValid(int level)\n    {\n        return (level >= Zstd.minCompressionLevel() && level <= BEST_COMPRESSION_LEVEL);\n    }\n\n    /**", "refactored_code": "    public static final int FAST_COMPRESSION_LEVEL = Zstd.minCompressionLevel();\n     */\n    private static boolean isValid(int level)\n    {\n        return (level >= FAST_COMPRESSION_LEVEL && level <= BEST_COMPRESSION_LEVEL);\n    }\n\n    /**"}
{"magic_number_smell": "            // Assign the default max SSTable size if not defined in builder\n            if (isMaxSSTableSizeUnset())\n            {\n                maxSSTableSizeInMiB = sorted ? -1L : 128L;\n            }\n\n            synchronized (CQLSSTableWriter.class)", "refactored_code": "        private static final long DEFAULT_BUFFER_SIZE_IN_MIB_FOR_UNSORTED = 128L;\n            // Assign the default max SSTable size if not defined in builder\n            if (isMaxSSTableSizeUnset())\n            {\n                maxSSTableSizeInMiB = sorted ? -1L : DEFAULT_BUFFER_SIZE_IN_MIB_FOR_UNSORTED;\n            }\n\n            synchronized (CQLSSTableWriter.class)"}
{"magic_number_smell": "        if (originalIndexes != null)\n            return originalIndexes;\n\n        List<Integer> pattern = getSamplingPattern(128).subList(0, 128 - samplingLevel);\n        originalIndexes = new ArrayList<>(samplingLevel);\n        for (int j = 0; j < 128; j++)\n        {", "refactored_code": "    public static final int BASE_SAMPLING_LEVEL = 128;\n        if (originalIndexes != null)\n            return originalIndexes;\n\n        List<Integer> pattern = getSamplingPattern(BASE_SAMPLING_LEVEL).subList(0, BASE_SAMPLING_LEVEL - samplingLevel);\n        originalIndexes = new ArrayList<>(samplingLevel);\n        for (int j = 0; j < BASE_SAMPLING_LEVEL; j++)\n        {"}
{"magic_number_smell": "\n    public long unsharedHeapSize()\n    {\n        return ObjectSizes.measure(new IndexInfo(null, null, 0, 0, null))\n             + firstName.unsharedHeapSize()\n             + lastName.unsharedHeapSize()\n             + (endOpenMarker == null ? 0 : endOpenMarker.unsharedHeapSize());", "refactored_code": "    public static final long EMPTY_SIZE = ObjectSizes.measure(new IndexInfo(null, null, 0, 0, null));\n\n    public long unsharedHeapSize()\n    {\n        return EMPTY_SIZE\n             + firstName.unsharedHeapSize()\n             + lastName.unsharedHeapSize()\n             + (endOpenMarker == null ? 0 : endOpenMarker.unsharedHeapSize());"}
{"magic_number_smell": "                             Version version,\n                             ISerializer<IndexInfo> indexInfoSerializer)\n    {\n        this(header, writer, version, indexInfoSerializer, DatabaseDescriptor.getColumnIndexCacheSize(), DatabaseDescriptor.getColumnIndexSize(64 * 1024));\n    }\n\n    BigFormatPartitionWriter(SerializationHeader header,", "refactored_code": "    public static final int DEFAULT_GRANULARITY = 64 * 1024;\n                             Version version,\n                             ISerializer<IndexInfo> indexInfoSerializer)\n    {\n        this(header, writer, version, indexInfoSerializer, DatabaseDescriptor.getColumnIndexCacheSize(), DatabaseDescriptor.getColumnIndexSize(DEFAULT_GRANULARITY));\n    }\n\n    BigFormatPartitionWriter(SerializationHeader header,"}
{"magic_number_smell": "    @Override\n    public long unsharedHeapSize()\n    {\n        return ObjectSizes.measure(new RowIndexEntry(0));\n    }\n\n    /**", "refactored_code": "    private static final long EMPTY_SIZE = ObjectSizes.measure(new RowIndexEntry(0));\n    @Override\n    public long unsharedHeapSize()\n    {\n        return EMPTY_SIZE;\n    }\n\n    /**"}
{"magic_number_smell": "                             SequentialWriter rowIndexWriter,\n                             Version version)\n    {\n        this(header, comparator, dataWriter, rowIndexWriter, version, DatabaseDescriptor.getColumnIndexSize(16 * 1024));\n    }\n\n", "refactored_code": "    private static final int DEFAULT_GRANULARITY = 16 * 1024;\n                             SequentialWriter rowIndexWriter,\n                             Version version)\n    {\n        this(header, comparator, dataWriter, rowIndexWriter, version, DatabaseDescriptor.getColumnIndexSize(DEFAULT_GRANULARITY));\n    }\n\n"}
{"magic_number_smell": "        public Payload(long position, short hashBits)\n        {\n            this.position = position;\n            assert this.position != Long.MIN_VALUE : \"Partition position \" + Long.MIN_VALUE + \" is not valid.\";\n            this.hashBits = hashBits;\n        }\n    }", "refactored_code": "    public static final long NOT_FOUND = Long.MIN_VALUE;\n        public Payload(long position, short hashBits)\n        {\n            this.position = position;\n            assert this.position != NOT_FOUND : \"Partition position \" + NOT_FOUND + \" is not valid.\";\n            this.hashBits = hashBits;\n        }\n    }"}
{"magic_number_smell": "        long dataOffset;\n        if (bits == 0)\n            return null;\n        int bytes = bits & ~8;\n        dataOffset = SizedInts.read(buf, ppos, bytes);\n        ppos += bytes;\n        DeletionTime deletion = (bits & 8) != 0", "refactored_code": "    private static final int FLAG_OPEN_MARKER = 8;\n        long dataOffset;\n        if (bits == 0)\n            return null;\n        int bytes = bits & ~FLAG_OPEN_MARKER;\n        dataOffset = SizedInts.read(buf, ppos, bytes);\n        ppos += bytes;\n        DeletionTime deletion = (bits & FLAG_OPEN_MARKER) != 0"}
{"magic_number_smell": "        else\n        {\n            key = null;\n            dataPosition = -1;\n        }\n    }\n", "refactored_code": "    public static final int EXHAUSTED = -1;\n        else\n        {\n            key = null;\n            dataPosition = EXHAUSTED;\n        }\n    }\n"}
{"magic_number_smell": "                                 Integer.MAX_VALUE,\n                                 0,\n                                 Integer.MAX_VALUE,\n                                 -1.0,\n                                 defaultTombstoneDropTimeHistogram(),\n                                 0,\n                                 Collections.emptyList(),", "refactored_code": "    public static final double NO_COMPRESSION_RATIO = -1.0;\n                                 Integer.MAX_VALUE,\n                                 0,\n                                 Integer.MAX_VALUE,\n                                 NO_COMPRESSION_RATIO,\n                                 defaultTombstoneDropTimeHistogram(),\n                                 0,\n                                 Collections.emptyList(),"}
{"magic_number_smell": "        maybeWriteChecksum(crc, out, version);\n\n        // build and write toc\n        int lastPosition = 4 + (8 * sortedComponents.size()) + (checksum ? 2 * 4 : 0);\n        Map<MetadataType, Integer> sizes = new EnumMap<>(MetadataType.class);\n        for (MetadataComponent component : sortedComponents)\n        {", "refactored_code": "    private static final int CHECKSUM_LENGTH = 4; // CRC32\n        maybeWriteChecksum(crc, out, version);\n\n        // build and write toc\n        int lastPosition = 4 + (8 * sortedComponents.size()) + (checksum ? 2 * CHECKSUM_LENGTH : 0);\n        Map<MetadataType, Integer> sizes = new EnumMap<>(MetadataType.class);\n        for (MetadataComponent component : sortedComponents)\n        {"}
{"magic_number_smell": "    {\n        private static final int 1024 = 1024;\n        @SuppressWarnings(\"rawtypes\")\n        private static final LightweightRecycler<ArrayList> CHILDREN_LIST_RECYCLER = ThreadLocals.createLightweightRecycler(1024);\n        @SuppressWarnings(\"rawtypes\")\n        private static final ArrayList EMPTY_LIST = new ArrayList<>(0);\n", "refactored_code": "        private static final int CHILDREN_LIST_RECYCLER_LIMIT = 1024;\n    {\n        private static final int CHILDREN_LIST_RECYCLER_LIMIT = 1024;\n        @SuppressWarnings(\"rawtypes\")\n        private static final LightweightRecycler<ArrayList> CHILDREN_LIST_RECYCLER = ThreadLocals.createLightweightRecycler(CHILDREN_LIST_RECYCLER_LIMIT);\n        @SuppressWarnings(\"rawtypes\")\n        private static final ArrayList EMPTY_LIST = new ArrayList<>(0);\n"}
{"magic_number_smell": "    abstract long transitionDelta(ByteBuffer src, int position, int childIndex);\n\n    /**\n     * Returns position of node to transition to for the given search index. Argument must be positive. May return -1\n     * if a transition with that index does not exist (DENSE nodes).\n     * Position is the offset of the node within the ByteBuffer. positionLong is its global placement, which is the\n     * base for any offset calculations.", "refactored_code": "    public static final int NONE = -1;\n    abstract long transitionDelta(ByteBuffer src, int position, int childIndex);\n\n    /**\n     * Returns position of node to transition to for the given search index. Argument must be positive. May return NONE\n     * if a transition with that index does not exist (DENSE nodes).\n     * Position is the offset of the node within the ByteBuffer. positionLong is its global placement, which is the\n     * base for any offset calculations."}
{"magic_number_smell": "\n    public BufferedDataOutputStreamPlus(WritableByteChannel wbc)\n    {\n        this(wbc, NIO_DATA_OUTPUT_STREAM_PLUS_BUFFER_SIZE.getInt());\n    }\n\n    public BufferedDataOutputStreamPlus(WritableByteChannel wbc, int bufferSize)", "refactored_code": "    private static final int DEFAULT_BUFFER_SIZE = NIO_DATA_OUTPUT_STREAM_PLUS_BUFFER_SIZE.getInt();\n\n    public BufferedDataOutputStreamPlus(WritableByteChannel wbc)\n    {\n        this(wbc, DEFAULT_BUFFER_SIZE);\n    }\n\n    public BufferedDataOutputStreamPlus(WritableByteChannel wbc, int bufferSize)"}
{"magic_number_smell": "                @Override\n                public void close()\n                {\n                    if (buffer != null && buffer.capacity() <= DOB_MAX_RECYCLE_BYTES.getInt())\n                    {\n                        buffer.clear();\n                    }", "refactored_code": "    private static final int MAX_RECYCLE_BUFFER_SIZE = DOB_MAX_RECYCLE_BYTES.getInt();\n                @Override\n                public void close()\n                {\n                    if (buffer != null && buffer.capacity() <= MAX_RECYCLE_BUFFER_SIZE)\n                    {\n                        buffer.clear();\n                    }"}
{"magic_number_smell": "    protected static byte[] retrieveTemporaryBuffer(int minSize)\n    {\n        byte[] bytes = tempBuffer.get();\n        if (bytes.length < Math.min(minSize, DATA_OUTPUT_STREAM_PLUS_TEMP_BUFFER_SIZE.getInt()))\n        {\n            // increase in powers of 2, to avoid wasted repeat allocations\n            bytes = new byte[Math.min(DATA_OUTPUT_STREAM_PLUS_TEMP_BUFFER_SIZE.getInt(), 2 * Integer.highestOneBit(minSize))];", "refactored_code": "    private static final int MAX_BUFFER_SIZE = DATA_OUTPUT_STREAM_PLUS_TEMP_BUFFER_SIZE.getInt();\n    protected static byte[] retrieveTemporaryBuffer(int minSize)\n    {\n        byte[] bytes = tempBuffer.get();\n        if (bytes.length < Math.min(minSize, MAX_BUFFER_SIZE))\n        {\n            // increase in powers of 2, to avoid wasted repeat allocations\n            bytes = new byte[Math.min(MAX_BUFFER_SIZE, 2 * Integer.highestOneBit(minSize))];"}
{"magic_number_smell": "    private static final Logger logger = LoggerFactory.getLogger(FileUtils.class);\n\n    public static final long 1024 = 1024;\n    public static final long ONE_MIB = 1024 * 1024;\n    public static final long ONE_GIB = 1024 * ONE_MIB;\n    public static final long ONE_TIB = 1024 * ONE_GIB;\n", "refactored_code": "    public static final long ONE_KIB = 1024;\n    private static final Logger logger = LoggerFactory.getLogger(FileUtils.class);\n\n    public static final long ONE_KIB = 1024;\n    public static final long ONE_MIB = 1024 * ONE_KIB;\n    public static final long ONE_GIB = 1024 * ONE_MIB;\n    public static final long ONE_TIB = 1024 * ONE_GIB;\n"}
{"magic_number_smell": "            return;\n\n        checkBounds(memoryOffset, memoryOffset + count);\n        unsafe.copyMemory(buffer, unsafe.arrayBaseOffset(byte[].class) + bufferOffset, null, peer + memoryOffset, count);\n    }\n\n    public byte getByte(long offset)", "refactored_code": "    private static final long BYTE_ARRAY_BASE_OFFSET = unsafe.arrayBaseOffset(byte[].class);\n            return;\n\n        checkBounds(memoryOffset, memoryOffset + count);\n        unsafe.copyMemory(buffer, BYTE_ARRAY_BASE_OFFSET + bufferOffset, null, peer + memoryOffset, count);\n    }\n\n    public byte getByte(long offset)"}
{"magic_number_smell": "public final class PageAware\n{\n    public static final int 4096 = 4096; // must be a power of two\n    public static final int PAGE_SIZE_SHIFT = Integer.numberOfTrailingZeros(4096);\n\n    /**\n     * Calculate the end of the page identified by the given position.", "refactored_code": "    public static final int PAGE_SIZE = 4096; // must be a power of two\npublic final class PageAware\n{\n    public static final int PAGE_SIZE = 4096; // must be a power of two\n    public static final int PAGE_SIZE_SHIFT = Integer.numberOfTrailingZeros(PAGE_SIZE);\n\n    /**\n     * Calculate the end of the page identified by the given position."}
{"magic_number_smell": "        ChannelProxy channel = new ChannelProxy(file);\n        try\n        {\n            ChunkReader reader = new SimpleChunkReader(channel, -1, BufferType.OFF_HEAP, 4096);\n            Rebufferer rebufferer = reader.instantiateRebufferer();\n            return new RandomAccessReaderWithOwnChannel(rebufferer);\n        }", "refactored_code": "    public static final int DEFAULT_BUFFER_SIZE = 4096;\n        ChannelProxy channel = new ChannelProxy(file);\n        try\n        {\n            ChunkReader reader = new SimpleChunkReader(channel, -1, BufferType.OFF_HEAP, DEFAULT_BUFFER_SIZE);\n            Rebufferer rebufferer = reader.instantiateRebufferer();\n            return new RandomAccessReaderWithOwnChannel(rebufferer);\n        }"}
{"magic_number_smell": "        ExponentiallyDecayingReservoir sample = samples.get(host);\n        if (sample == null)\n        {\n            ExponentiallyDecayingReservoir maybeNewSample = new ExponentiallyDecayingReservoir(WINDOW_SIZE, 0.75);\n            sample = samples.putIfAbsent(host, maybeNewSample);\n            if (sample == null)\n                sample = maybeNewSample;", "refactored_code": "    private static final double ALPHA = 0.75; // set to 0.75 to make EDS more biased to towards the newer values\n        ExponentiallyDecayingReservoir sample = samples.get(host);\n        if (sample == null)\n        {\n            ExponentiallyDecayingReservoir maybeNewSample = new ExponentiallyDecayingReservoir(WINDOW_SIZE, ALPHA);\n            sample = samples.putIfAbsent(host, maybeNewSample);\n            if (sample == null)\n                sample = maybeNewSample;"}
{"magic_number_smell": "            }\n        }\n\n        if (seeds.size() > CassandraRelevantProperties.SEED_COUNT_WARN_THRESHOLD.getInt(20))\n            logger.warn(\"Seed provider returned more than {} seeds. \" +\n                        \"A large seed list may impact effectiveness of the third gossip round.\",\n                        CassandraRelevantProperties.SEED_COUNT_WARN_THRESHOLD.getInt(20));", "refactored_code": "    private static final int SEED_COUNT_WARN_THRESHOLD = CassandraRelevantProperties.SEED_COUNT_WARN_THRESHOLD.getInt(20);\n            }\n        }\n\n        if (seeds.size() > SEED_COUNT_WARN_THRESHOLD)\n            logger.warn(\"Seed provider returned more than {} seeds. \" +\n                        \"A large seed list may impact effectiveness of the third gossip round.\",\n                        SEED_COUNT_WARN_THRESHOLD);"}
{"magic_number_smell": "    private static final int[] DISTRIBUTION_PRIMES = new int[] { 17, 19, 23, 29 };\n\n    // The offsets used with a default sized bucket array without a separate bucket for zero values.\n    public static final long[] DEFAULT_WITHOUT_ZERO_BUCKET_OFFSETS = EstimatedHistogram.newOffsets(164, false);\n\n    // The offsets used with a default sized bucket array with a separate bucket for zero values.\n    public static final long[] DEFAULT_WITH_ZERO_BUCKET_OFFSETS = EstimatedHistogram.newOffsets(164, true);", "refactored_code": "    public static final int DEFAULT_BUCKET_COUNT = 164;\n    private static final int[] DISTRIBUTION_PRIMES = new int[] { 17, 19, 23, 29 };\n\n    // The offsets used with a default sized bucket array without a separate bucket for zero values.\n    public static final long[] DEFAULT_WITHOUT_ZERO_BUCKET_OFFSETS = EstimatedHistogram.newOffsets(DEFAULT_BUCKET_COUNT, false);\n\n    // The offsets used with a default sized bucket array with a separate bucket for zero values.\n    public static final long[] DEFAULT_WITH_ZERO_BUCKET_OFFSETS = EstimatedHistogram.newOffsets(DEFAULT_BUCKET_COUNT, true);"}
{"magic_number_smell": "    public void scheduleLogging()\n    {\n        ScheduledExecutors.scheduledTasks.scheduleWithFixedDelay(this::logDroppedMessages,\n                                                                 5000,\n                                                                 5000,\n                                                                 MILLISECONDS);\n    }", "refactored_code": "    private static final int LOG_DROPPED_INTERVAL_IN_MS = 5000;\n    public void scheduleLogging()\n    {\n        ScheduledExecutors.scheduledTasks.scheduleWithFixedDelay(this::logDroppedMessages,\n                                                                 LOG_DROPPED_INTERVAL_IN_MS,\n                                                                 LOG_DROPPED_INTERVAL_IN_MS,\n                                                                 MILLISECONDS);\n    }"}
{"magic_number_smell": "        final long oldTick = lastTick.get();\n        final long newTick = clock.getTick();\n        final long age = newTick - oldTick;\n        if (age > TimeUnit.SECONDS.toNanos(5))\n        {\n            final long newIntervalStartTick = newTick - age % TimeUnit.SECONDS.toNanos(5);\n            if (lastTick.compareAndSet(oldTick, newIntervalStartTick))", "refactored_code": "    private static final long TICK_INTERVAL = TimeUnit.SECONDS.toNanos(5);\n        final long oldTick = lastTick.get();\n        final long newTick = clock.getTick();\n        final long age = newTick - oldTick;\n        if (age > TICK_INTERVAL)\n        {\n            final long newIntervalStartTick = newTick - age % TICK_INTERVAL;\n            if (lastTick.compareAndSet(oldTick, newIntervalStartTick))"}
{"magic_number_smell": "            if (queue.relaxedIsEmpty())\n                return; // we can return early if no handlers have registered with the wait queue\n\n            if (0 == scheduledUpdater.getAndUpdate(this, i -> min(RUN_AGAIN, i + 1)))\n            {\n                do\n                {", "refactored_code": "        private static final int NOT_RUNNING = 0;\n            if (queue.relaxedIsEmpty())\n                return; // we can return early if no handlers have registered with the wait queue\n\n            if (NOT_RUNNING == scheduledUpdater.getAndUpdate(this, i -> min(RUN_AGAIN, i + 1)))\n            {\n                do\n                {"}
{"magic_number_smell": "     */\n    static int crc24(long bytes, int len)\n    {\n        int crc = 0x875060;\n        while (len-- > 0)\n        {\n            crc ^= (bytes & 0xff) << 16;", "refactored_code": "    private static final int CRC24_INIT = 0x875060;\n     */\n    static int crc24(long bytes, int len)\n    {\n        int crc = CRC24_INIT;\n        while (len-- > 0)\n        {\n            crc ^= (bytes & 0xff) << 16;"}
{"magic_number_smell": "        boolean isSelfContained = isSelfContained(header6b);\n\n        CRC32 crc = crc32();\n        int readFullCrc = in.getInt(end - 4);\n        if (in.order() == ByteOrder.BIG_ENDIAN)\n            readFullCrc = Integer.reverseBytes(readFullCrc);\n", "refactored_code": "    private static final int TRAILER_LENGTH = 4;\n        boolean isSelfContained = isSelfContained(header6b);\n\n        CRC32 crc = crc32();\n        int readFullCrc = in.getInt(end - TRAILER_LENGTH);\n        if (in.order() == ByteOrder.BIG_ENDIAN)\n            readFullCrc = Integer.reverseBytes(readFullCrc);\n"}
{"magic_number_smell": "        if (input.order() == ByteOrder.BIG_ENDIAN)\n            readFullCrc = Integer.reverseBytes(readFullCrc);\n\n        updateCrc32(crc, input, begin + 8, end - TRAILER_LENGTH);\n        int computeFullCrc = (int) crc.getValue();\n\n        if (readFullCrc != computeFullCrc)", "refactored_code": "    private static final int HEADER_LENGTH = 8;\n        if (input.order() == ByteOrder.BIG_ENDIAN)\n            readFullCrc = Integer.reverseBytes(readFullCrc);\n\n        updateCrc32(crc, input, begin + HEADER_LENGTH, end - TRAILER_LENGTH);\n        int computeFullCrc = (int) crc.getValue();\n\n        if (readFullCrc != computeFullCrc)"}
{"magic_number_smell": "\n    public static final FrameEncoderCrc instance = new FrameEncoderCrc();\n    static final PayloadAllocator allocator = (isSelfContained, capacity) ->\n        new Payload(isSelfContained, capacity, HEADER_LENGTH, 4);\n\n    public PayloadAllocator allocator()\n    {", "refactored_code": "    private static final int TRAILER_LENGTH = 4;\n\n    public static final FrameEncoderCrc instance = new FrameEncoderCrc();\n    static final PayloadAllocator allocator = (isSelfContained, capacity) ->\n        new Payload(isSelfContained, capacity, HEADER_LENGTH, TRAILER_LENGTH);\n\n    public PayloadAllocator allocator()\n    {"}
{"magic_number_smell": "            int maxOutputLength = compressor.maxCompressedLength(uncompressedLength);\n            frame = bufferPool.getAtLeast(HEADER_AND_TRAILER_LENGTH + maxOutputLength, BufferType.OFF_HEAP);\n\n            int compressedLength = compressor.compress(in, in.position(), uncompressedLength, frame, 8, maxOutputLength);\n\n            if (compressedLength >= uncompressedLength)\n            {", "refactored_code": "    private static final int HEADER_LENGTH = 8;\n            int maxOutputLength = compressor.maxCompressedLength(uncompressedLength);\n            frame = bufferPool.getAtLeast(HEADER_AND_TRAILER_LENGTH + maxOutputLength, BufferType.OFF_HEAP);\n\n            int compressedLength = compressor.compress(in, in.position(), uncompressedLength, frame, HEADER_LENGTH, maxOutputLength);\n\n            if (compressedLength >= uncompressedLength)\n            {"}
{"magic_number_smell": "\n        static Initiate maybeDecode(ByteBuf buf) throws IOException\n        {\n            if (buf.readableBytes() < 8)\n                return null;\n\n            ByteBuffer nio = buf.nioBuffer();", "refactored_code": "        private static final int MIN_LENGTH = 8;\n\n        static Initiate maybeDecode(ByteBuf buf) throws IOException\n        {\n            if (buf.readableBytes() < MIN_LENGTH)\n                return null;\n\n            ByteBuffer nio = buf.nioBuffer();"}
{"magic_number_smell": "        {\n            id = nextId.incrementAndGet();\n        }\n        while (id == 0L);\n\n        return id;\n    }", "refactored_code": "    private static final long NO_ID = 0L; // this is a valid ID for pre40 nodes\n        {\n            id = nextId.incrementAndGet();\n        }\n        while (id == NO_ID);\n\n        return id;\n    }"}
{"magic_number_smell": "    private static final int 42 = 42;\n    private static boolean isMaxPendingCount(long pendingCountAndBytes)\n    {\n        return (pendingCountAndBytes & (-1L << 42)) == (-1L << 42);\n    }\n\n    private static int pendingCount(long pendingCountAndBytes)", "refactored_code": "    private static final int pendingByteBits = 42;\n    private static final int pendingByteBits = 42;\n    private static boolean isMaxPendingCount(long pendingCountAndBytes)\n    {\n        return (pendingCountAndBytes & (-1L << pendingByteBits)) == (-1L << pendingByteBits);\n    }\n\n    private static int pendingCount(long pendingCountAndBytes)"}
{"magic_number_smell": "\n    private ShareableBytes(ByteBuffer bytes)\n    {\n        this.count = -1;\n        this.owner = this;\n        this.bytes = bytes;\n    }", "refactored_code": "    private static final int UNSHARED = -1;\n\n    private ShareableBytes(ByteBuffer bytes)\n    {\n        this.count = UNSHARED;\n        this.owner = this;\n        this.bytes = bytes;\n    }"}
{"magic_number_smell": "    {\n        this.provider = provider;\n        this.acceptGroup = provider.makeEventLoopGroup(1, \"Messaging-AcceptLoop\");\n        this.defaultGroup = provider.makeEventLoopGroup(INTERNODE_EVENT_THREADS.getInt(FBUtilities.getAvailableProcessors()), NamedThreadFactory.globalPrefix() + \"Messaging-EventLoop\");\n        this.outboundStreamingGroup = provider.makeEventLoopGroup(INTERNODE_EVENT_THREADS.getInt(FBUtilities.getAvailableProcessors()), \"Streaming-EventLoop\");\n    }\n", "refactored_code": "    private static final int EVENT_THREADS = INTERNODE_EVENT_THREADS.getInt(FBUtilities.getAvailableProcessors());\n    {\n        this.provider = provider;\n        this.acceptGroup = provider.makeEventLoopGroup(1, \"Messaging-AcceptLoop\");\n        this.defaultGroup = provider.makeEventLoopGroup(EVENT_THREADS, NamedThreadFactory.globalPrefix() + \"Messaging-EventLoop\");\n        this.outboundStreamingGroup = provider.makeEventLoopGroup(EVENT_THREADS, \"Streaming-EventLoop\");\n    }\n"}
{"magic_number_smell": "        }\n\n        // validate options\n        if (jobThreads > 4)\n        {\n            throw new IllegalArgumentException(\"Too many job threads. Max is \" + 4);\n        }", "refactored_code": "    public static final int MAX_JOB_THREADS = 4;\n        }\n\n        // validate options\n        if (jobThreads > MAX_JOB_THREADS)\n        {\n            throw new IllegalArgumentException(\"Too many job threads. Max is \" + MAX_JOB_THREADS);\n        }"}
{"magic_number_smell": "\n    private final Class<T> klass;\n    protected final long[] stateTimesNanos;\n    protected int currentState = -1;\n\n    public AbstractState(Clock clock, I id, Class<T> klass)\n    {", "refactored_code": "    public static final int INIT = -1;\n\n    private final Class<T> klass;\n    protected final long[] stateTimesNanos;\n    protected int currentState = INIT;\n\n    public AbstractState(Clock clock, I id, Class<T> klass)\n    {"}
{"magic_number_smell": "\n    /*\n     * If the column is a partition key or clustering column, its position relative to\n     * other columns of the same kind. Otherwise,  -1 (-1).\n     *\n     * Note that partition key and clustering columns are numbered separately so\n     * the first clustering column is 0.", "refactored_code": "    public static final int NO_POSITION = -1;\n\n    /*\n     * If the column is a partition key or clustering column, its position relative to\n     * other columns of the same kind. Otherwise,  NO_POSITION (-1).\n     *\n     * Note that partition key and clustering columns are numbered separately so\n     * the first clustering column is 0."}
{"magic_number_smell": "        DEFAULT_PROVIDE_OVERLAPPING_TOMBSTONES.getEnum(TombstoneOption.NONE);\n\n    public static final Map<String, String> DEFAULT_THRESHOLDS =\n        ImmutableMap.of(Option.MIN_THRESHOLD.toString(), Integer.toString(4),\n                        Option.MAX_THRESHOLD.toString(), Integer.toString(DEFAULT_MAX_THRESHOLD));\n\n    public static final CompactionParams DEFAULT;", "refactored_code": "    public static final int DEFAULT_MIN_THRESHOLD = 4;\n        DEFAULT_PROVIDE_OVERLAPPING_TOMBSTONES.getEnum(TombstoneOption.NONE);\n\n    public static final Map<String, String> DEFAULT_THRESHOLDS =\n        ImmutableMap.of(Option.MIN_THRESHOLD.toString(), Integer.toString(DEFAULT_MIN_THRESHOLD),\n                        Option.MAX_THRESHOLD.toString(), Integer.toString(DEFAULT_MAX_THRESHOLD));\n\n    public static final CompactionParams DEFAULT;"}
{"magic_number_smell": "    public static final CompressionParams DEFAULT = !CassandraRelevantProperties.DETERMINISM_SSTABLE_COMPRESSION_DEFAULT.getBoolean()\n                                                    ? noCompression()\n                                                    : new CompressionParams(LZ4Compressor.create(Collections.emptyMap()),\n                                                                            1024 * 16,\n                                                                            calcMaxCompressedLength(1024 * 16, DEFAULT_MIN_COMPRESS_RATIO),\n                                                                            DEFAULT_MIN_COMPRESS_RATIO,\n                                                                            Collections.emptyMap());", "refactored_code": "    public static final int DEFAULT_CHUNK_LENGTH = 1024 * 16;\n    public static final CompressionParams DEFAULT = !CassandraRelevantProperties.DETERMINISM_SSTABLE_COMPRESSION_DEFAULT.getBoolean()\n                                                    ? noCompression()\n                                                    : new CompressionParams(LZ4Compressor.create(Collections.emptyMap()),\n                                                                            DEFAULT_CHUNK_LENGTH,\n                                                                            calcMaxCompressedLength(DEFAULT_CHUNK_LENGTH, DEFAULT_MIN_COMPRESS_RATIO),\n                                                                            DEFAULT_MIN_COMPRESS_RATIO,\n                                                                            Collections.emptyMap());"}
{"magic_number_smell": "\n    public static boolean isValidName(String name)\n    {\n        return name != null && !name.isEmpty() && name.length() <= 48 && PATTERN_WORD_CHARS.matcher(name).matches();\n    }\n\n    static", "refactored_code": "    public static final int NAME_LENGTH = 48;\n\n    public static boolean isValidName(String name)\n    {\n        return name != null && !name.isEmpty() && name.length() <= NAME_LENGTH && PATTERN_WORD_CHARS.matcher(name).matches();\n    }\n\n    static"}
{"magic_number_smell": "    public static KeyspaceMetadata metadata()\n    {\n        return KeyspaceMetadata.create(SchemaConstants.DISTRIBUTED_KEYSPACE_NAME,\n                                       KeyspaceParams.simple(Math.max(CassandraRelevantProperties.SYSTEM_DISTRIBUTED_DEFAULT_RF.getInt(), DatabaseDescriptor.getDefaultKeyspaceRF())),\n                                       Tables.of(RepairHistory, ParentRepairHistory, ViewBuildStatus, PartitionDenylistTable));\n    }\n", "refactored_code": "    public static final int DEFAULT_RF = CassandraRelevantProperties.SYSTEM_DISTRIBUTED_DEFAULT_RF.getInt();\n    public static KeyspaceMetadata metadata()\n    {\n        return KeyspaceMetadata.create(SchemaConstants.DISTRIBUTED_KEYSPACE_NAME,\n                                       KeyspaceParams.simple(Math.max(DEFAULT_RF, DatabaseDescriptor.getDefaultKeyspaceRF())),\n                                       Tables.of(RepairHistory, ParentRepairHistory, ViewBuildStatus, PartitionDenylistTable));\n    }\n"}
{"magic_number_smell": "\n    private static TableId fromLong(long start)\n    {\n        return TableId.fromUUID(new UUID(1956074401491665062L, start));\n    }\n\n    /**", "refactored_code": "    public static final long MAGIC = 1956074401491665062L;\n\n    private static TableId fromLong(long start)\n    {\n        return TableId.fromUUID(new UUID(MAGIC, start));\n    }\n\n    /**"}
{"magic_number_smell": "    {\n        int inputLength = inputBuffer.remaining();\n        final int compressedLength = compressor.initialCompressedBufferLength(inputLength);\n        outputBuffer = ByteBufferUtil.ensureCapacity(outputBuffer, compressedLength + 4, allowBufferResize);\n\n        outputBuffer.putInt(inputLength);\n        compressor.compress(inputBuffer, outputBuffer);", "refactored_code": "    public static final int COMPRESSED_BLOCK_HEADER_SIZE = 4;\n    {\n        int inputLength = inputBuffer.remaining();\n        final int compressedLength = compressor.initialCompressedBufferLength(inputLength);\n        outputBuffer = ByteBufferUtil.ensureCapacity(outputBuffer, compressedLength + COMPRESSED_BLOCK_HEADER_SIZE, allowBufferResize);\n\n        outputBuffer.putInt(inputLength);\n        compressor.compress(inputBuffer, outputBuffer);"}
{"magic_number_smell": "        {\n            ScheduledExecutors.scheduledTasks\n                .scheduleWithFixedDelay(SSLFactory::checkCertFilesForHotReloading,\n                                        600,\n                                        DEFAULT_HOT_RELOAD_PERIOD_SEC, TimeUnit.SECONDS);\n        }\n", "refactored_code": "    public static final int DEFAULT_HOT_RELOAD_INITIAL_DELAY_SEC = 600;\n        {\n            ScheduledExecutors.scheduledTasks\n                .scheduleWithFixedDelay(SSLFactory::checkCertFilesForHotReloading,\n                                        DEFAULT_HOT_RELOAD_INITIAL_DELAY_SEC,\n                                        DEFAULT_HOT_RELOAD_PERIOD_SEC, TimeUnit.SECONDS);\n        }\n"}
{"magic_number_smell": "        {\n            LocalDate parsed = formatter.parse(source, LocalDate::from);\n            long millis = parsed.atStartOfDay(UTC).toInstant().toEpochMilli();\n            if (millis < TimeUnit.DAYS.toMillis(Integer.MIN_VALUE))\n                throw new MarshalException(String.format(\"Input date %s is less than min supported date %s\", source,\n                        ZonedDateTime.ofInstant(Instant.ofEpochMilli(TimeUnit.DAYS.toMillis(Integer.MIN_VALUE)), UTC).toString()));\n            if (millis > maxSupportedDateMillis)", "refactored_code": "    private static final long minSupportedDateMillis = TimeUnit.DAYS.toMillis(Integer.MIN_VALUE);\n        {\n            LocalDate parsed = formatter.parse(source, LocalDate::from);\n            long millis = parsed.atStartOfDay(UTC).toInstant().toEpochMilli();\n            if (millis < minSupportedDateMillis)\n                throw new MarshalException(String.format(\"Input date %s is less than min supported date %s\", source,\n                        ZonedDateTime.ofInstant(Instant.ofEpochMilli(minSupportedDateMillis), UTC).toString()));\n            if (millis > maxSupportedDateMillis)"}
{"magic_number_smell": "\n    /**\n     * we only want to set repairedAt for incremental repairs including all replicas for a token range. For non-global\n     * incremental repairs, forced incremental repairs, and full repairs, the 0 value will prevent\n     * sstables from being promoted to repaired or preserve the repairedAt/pendingRepair values, respectively.\n     */\n    long getRepairedAt(RepairOption options, boolean force)", "refactored_code": "    public static final long UNREPAIRED_SSTABLE = 0;\n\n    /**\n     * we only want to set repairedAt for incremental repairs including all replicas for a token range. For non-global\n     * incremental repairs, forced incremental repairs, and full repairs, the UNREPAIRED_SSTABLE value will prevent\n     * sstables from being promoted to repaired or preserve the repairedAt/pendingRepair values, respectively.\n     */\n    long getRepairedAt(RepairOption options, boolean force)"}
{"magic_number_smell": "            if (options.isDisabled(getStartupCheckType()))\n                return;\n            long now = currentTimeMillis();\n            if (now < 1215820800000L)\n                throw new StartupException(StartupException.ERR_WRONG_MACHINE_STATE,\n                                           String.format(\"current machine time is %s, but that is seemingly incorrect. exiting now.\",\n                                                         new Date(now).toString()));", "refactored_code": "        private static final long EARLIEST_LAUNCH_DATE = 1215820800000L;\n            if (options.isDisabled(getStartupCheckType()))\n                return;\n            long now = currentTimeMillis();\n            if (now < EARLIEST_LAUNCH_DATE)\n                throw new StartupException(StartupException.ERR_WRONG_MACHINE_STATE,\n                                           String.format(\"current machine time is %s, but that is seemingly incorrect. exiting now.\",\n                                                         new Date(now).toString()));"}
{"magic_number_smell": "        // rather than being hidden by more common errors such as timeout or unavailable\n        // see CASSANDRA-17754\n        String msg = exception.getClass().getSimpleName() + \" \\\"{}\\\" while executing {}\";\n        NoSpamLogger.log(logger, NoSpamLogger.Level.INFO, CassandraRelevantProperties.FAILURE_LOGGING_INTERVAL_SECONDS.getInt(), TimeUnit.SECONDS,\n                         msg,\n                         () -> new Object[]\n                               {", "refactored_code": "    private static final int FAILURE_LOGGING_INTERVAL_SECONDS = CassandraRelevantProperties.FAILURE_LOGGING_INTERVAL_SECONDS.getInt();\n        // rather than being hidden by more common errors such as timeout or unavailable\n        // see CASSANDRA-17754\n        String msg = exception.getClass().getSimpleName() + \" \\\"{}\\\" while executing {}\";\n        NoSpamLogger.log(logger, NoSpamLogger.Level.INFO, FAILURE_LOGGING_INTERVAL_SECONDS, TimeUnit.SECONDS,\n                         msg,\n                         () -> new Object[]\n                               {"}
{"magic_number_smell": "            supersededByUpdater.accumulateAndGet(this, supersededBy, (a, b) -> a == null ? b : b.uuidTimestamp() > a.uuidTimestamp() ? b : a);\n\n        long increment = supersededBy == null\n                ? 1\n                : REFUSAL_INCREMENT;\n\n        update(increment);", "refactored_code": "    @VisibleForTesting public static final long ACCEPT_INCREMENT = 1;\n            supersededByUpdater.accumulateAndGet(this, supersededBy, (a, b) -> a == null ? b : b.uuidTimestamp() > a.uuidTimestamp() ? b : a);\n\n        long increment = supersededBy == null\n                ? ACCEPT_INCREMENT\n                : REFUSAL_INCREMENT;\n\n        update(increment);"}
{"magic_number_smell": "\n        participants = Participants.get(table, partitionKey(), paxosConsistency);\n\n        if (waitUntil > Long.MIN_VALUE && waitUntil - startedNanos() > getRetryTimeoutNanos())\n            return new Failure(null);\n\n        try", "refactored_code": "    private static final long RETRY_TIMEOUT_NANOS = getRetryTimeoutNanos();\n\n        participants = Participants.get(table, partitionKey(), paxosConsistency);\n\n        if (waitUntil > Long.MIN_VALUE && waitUntil - startedNanos() > RETRY_TIMEOUT_NANOS)\n            return new Failure(null);\n\n        try"}
{"magic_number_smell": "        try (RandomAccessReader reader = RandomAccessReader.open(file))\n        {\n            int version = reader.readInt();\n            if (version != 0)\n                throw new IOException(\"Unsupported ballot file version: \" + version);\n\n            byte[] bytes = new byte[16];", "refactored_code": "    private static final int FILE_VERSION = 0;\n        try (RandomAccessReader reader = RandomAccessReader.open(file))\n        {\n            int version = reader.readInt();\n            if (version != FILE_VERSION)\n                throw new IOException(\"Unsupported ballot file version: \" + version);\n\n            byte[] bytes = new byte[16];"}
{"magic_number_smell": "            this.file = new File(this.directory, fileName(generation) + TMP_SUFFIX);\n            this.crcFile = new File(this.directory, crcName(generation) + TMP_SUFFIX);\n            this.writer = new ChecksummedSequentialWriter(file, crcFile, null, SequentialWriterOption.DEFAULT);\n            this.writer.writeInt(0);\n        }\n\n        void append(PaxosKeyState state) throws IOException", "refactored_code": "    private static final int VERSION = 0;\n            this.file = new File(this.directory, fileName(generation) + TMP_SUFFIX);\n            this.crcFile = new File(this.directory, crcName(generation) + TMP_SUFFIX);\n            this.writer = new ChecksummedSequentialWriter(file, crcFile, null, SequentialWriterOption.DEFAULT);\n            this.writer.writeInt(VERSION);\n        }\n\n        void append(PaxosKeyState state) throws IOException"}
{"magic_number_smell": "            float resultsPerRange = estimateResultsPerRange(command, keyspace);\n            // underestimate how many rows we will get per-range in order to increase the likelihood that we'll\n            // fetch enough rows in the first round\n            resultsPerRange -= resultsPerRange * 0.10;\n            concurrencyFactor = resultsPerRange == 0.0\n                                ? 1\n                                : Math.max(1, Math.min(maxConcurrencyFactor, (int) Math.ceil(command.limits().count() / resultsPerRange)));", "refactored_code": "    private static final double CONCURRENT_SUBREQUESTS_MARGIN = 0.10;\n            float resultsPerRange = estimateResultsPerRange(command, keyspace);\n            // underestimate how many rows we will get per-range in order to increase the likelihood that we'll\n            // fetch enough rows in the first round\n            resultsPerRange -= resultsPerRange * CONCURRENT_SUBREQUESTS_MARGIN;\n            concurrencyFactor = resultsPerRange == 0.0\n                                ? 1\n                                : Math.max(1, Math.min(maxConcurrencyFactor, (int) Math.ceil(command.limits().count() / resultsPerRange)));"}
{"magic_number_smell": "    {\n        long costOfPeers = peers().size() * (ObjectSizes.IPV6_SOCKET_ADDRESS_SIZE + 48); // 48 represents the datastructure cost computed by the JOL\n        long costOfCompleteMessage = ObjectSizes.sizeOf(completeMessage());\n        return costOfPeers + costOfCompleteMessage + ObjectSizes.measureDeep(new StreamingState(nextTimeUUID(), StreamOperation.OTHER, false));\n    }\n\n    public StreamingState(StreamResultFuture result)", "refactored_code": "    public static final long EMPTY = ObjectSizes.measureDeep(new StreamingState(nextTimeUUID(), StreamOperation.OTHER, false));\n    {\n        long costOfPeers = peers().size() * (ObjectSizes.IPV6_SOCKET_ADDRESS_SIZE + 48); // 48 represents the datastructure cost computed by the JOL\n        long costOfCompleteMessage = ObjectSizes.sizeOf(completeMessage());\n        return costOfPeers + costOfCompleteMessage + EMPTY;\n    }\n\n    public StreamingState(StreamResultFuture result)"}
{"magic_number_smell": "            }\n        }\n        long totalNanos = nanoTime() - startNanos;\n        if (totalNanos > DatabaseDescriptor.getStreamingSlowEventsLogTimeout().toNanoseconds())\n            NoSpamLogger.log(logger, NoSpamLogger.Level.WARN, 1, TimeUnit.MINUTES, \"Handling streaming events took longer than {}; took {}\",\n                             () -> new Object[] { Duration.ofNanos(DatabaseDescriptor.getStreamingSlowEventsLogTimeout().toNanoseconds()), Duration.ofNanos(totalNanos)});\n    }", "refactored_code": "    private final long slowEventsLogTimeoutNanos = DatabaseDescriptor.getStreamingSlowEventsLogTimeout().toNanoseconds();\n            }\n        }\n        long totalNanos = nanoTime() - startNanos;\n        if (totalNanos > slowEventsLogTimeoutNanos)\n            NoSpamLogger.log(logger, NoSpamLogger.Level.WARN, 1, TimeUnit.MINUTES, \"Handling streaming events took longer than {}; took {}\",\n                             () -> new Object[] { Duration.ofNanos(slowEventsLogTimeoutNanos), Duration.ofNanos(totalNanos)});\n    }"}
{"magic_number_smell": "            sendControlMessage(new SessionFailedMessage()).awaitUninterruptibly();\n        }\n        StringBuilder failureReason = new StringBuilder(\"Failed because of an unknown exception\\n\");\n        boundStackTrace(e, CASSANDRA_STREAMING_DEBUG_STACKTRACE_LIMIT.getInt(), failureReason);\n        return closeSession(State.FAILED, failureReason.toString());\n    }\n", "refactored_code": "    private static final int DEBUG_STACKTRACE_LIMIT = CASSANDRA_STREAMING_DEBUG_STACKTRACE_LIMIT.getInt();\n            sendControlMessage(new SessionFailedMessage()).awaitUninterruptibly();\n        }\n        StringBuilder failureReason = new StringBuilder(\"Failed because of an unknown exception\\n\");\n        boundStackTrace(e, DEBUG_STACKTRACE_LIMIT, failureReason);\n        return closeSession(State.FAILED, failureReason.toString());\n    }\n"}
{"magic_number_smell": "            int uncompressedLength = in.remaining();\n            int maxLength = compressor.maxCompressedLength(uncompressedLength);\n            ByteBuffer out = bufferSupplier.get(maxLength);\n            out.position(8);\n            compressor.compress(in, out);\n            int compressedLength = out.position() - 8;\n            out.putInt(0, compressedLength);", "refactored_code": "    private static final int HEADER_LENGTH = 8;\n            int uncompressedLength = in.remaining();\n            int maxLength = compressor.maxCompressedLength(uncompressedLength);\n            ByteBuffer out = bufferSupplier.get(maxLength);\n            out.position(HEADER_LENGTH);\n            compressor.compress(in, out);\n            int compressedLength = out.position() - HEADER_LENGTH;\n            out.putInt(0, compressedLength);"}
{"magic_number_smell": "    private static final Logger logger = LoggerFactory.getLogger(StreamingMultiplexedChannel.class);\n\n    private static final int getAvailableProcessors() = getAvailableProcessors();\n    private static final int MAX_PARALLEL_TRANSFERS = STREAMING_SESSION_PARALLELTRANSFERS.getInt(getAvailableProcessors());\n\n    // a simple mechansim for allowing a degree of fairness across multiple sessions\n    private static final Semaphore fileTransferSemaphore = newFairSemaphore(getAvailableProcessors());", "refactored_code": "    private static final int DEFAULT_MAX_PARALLEL_TRANSFERS = getAvailableProcessors();\n    private static final Logger logger = LoggerFactory.getLogger(StreamingMultiplexedChannel.class);\n\n    private static final int DEFAULT_MAX_PARALLEL_TRANSFERS = getAvailableProcessors();\n    private static final int MAX_PARALLEL_TRANSFERS = STREAMING_SESSION_PARALLELTRANSFERS.getInt(DEFAULT_MAX_PARALLEL_TRANSFERS);\n\n    // a simple mechansim for allowing a degree of fairness across multiple sessions\n    private static final Semaphore fileTransferSemaphore = newFairSemaphore(DEFAULT_MAX_PARALLEL_TRANSFERS);"}
{"magic_number_smell": "            case FILE_PROGRESS:\n                ProgressInfo progress = ((StreamEvent.ProgressEvent) event).progress;\n                long current = currentTimeMillis();\n                if (current - progressLastSent >= 1000 || progress.isCompleted())\n                {\n                    notif = new Notification(StreamEvent.ProgressEvent.class.getCanonicalName(),\n                                             StreamManagerMBean.OBJECT_NAME,", "refactored_code": "    private static final long PROGRESS_NOTIFICATION_INTERVAL = 1000;\n            case FILE_PROGRESS:\n                ProgressInfo progress = ((StreamEvent.ProgressEvent) event).progress;\n                long current = currentTimeMillis();\n                if (current - progressLastSent >= PROGRESS_NOTIFICATION_INTERVAL || progress.isCompleted())\n                {\n                    notif = new Notification(StreamEvent.ProgressEvent.class.getCanonicalName(),\n                                             StreamManagerMBean.OBJECT_NAME,"}
{"magic_number_smell": "            {\n                if (t instanceof Success)\n                {\n                    out.writeByte(1);\n                    out.writeUnsignedVInt32(serializationVersion.asInt());\n                    LogState.metadataSerializer.serialize(t.success().logState, out, serializationVersion);\n                    Epoch.serializer.serialize(t.success().epoch, out, serializationVersion);", "refactored_code": "            private static final byte SUCCESS = 1;\n            {\n                if (t instanceof Success)\n                {\n                    out.writeByte(SUCCESS);\n                    out.writeUnsignedVInt32(serializationVersion.asInt());\n                    LogState.metadataSerializer.serialize(t.success().logState, out, serializationVersion);\n                    Epoch.serializer.serialize(t.success().epoch, out, serializationVersion);"}
{"magic_number_smell": "\n    public Retry(Meter retryMeter)\n    {\n        this(DatabaseDescriptor.getCmsDefaultRetryMaxTries(), retryMeter);\n    }\n\n    public Retry(int maxTries, Meter retryMeter)", "refactored_code": "    protected static final int MAX_TRIES = DatabaseDescriptor.getCmsDefaultRetryMaxTries();\n\n    public Retry(Meter retryMeter)\n    {\n        this(MAX_TRIES, retryMeter);\n    }\n\n    public Retry(int maxTries, Meter retryMeter)"}
{"magic_number_smell": "\n                ConsistencyLevel prev = currentCL;\n                currentCL = relaxConsistency(prev);\n                logger.info(String.format(\"Could not collect epoch acknowledgements within %dms for %s. Falling back to %s.\", DatabaseDescriptor.getProgressBarrierTimeout(TimeUnit.MILLISECONDS), prev, currentCL));\n            }\n            return true;\n        }", "refactored_code": "    private static final long TIMEOUT_MILLIS = DatabaseDescriptor.getProgressBarrierTimeout(TimeUnit.MILLISECONDS);\n\n                ConsistencyLevel prev = currentCL;\n                currentCL = relaxConsistency(prev);\n                logger.info(String.format(\"Could not collect epoch acknowledgements within %dms for %s. Falling back to %s.\", TIMEOUT_MILLIS, prev, currentCL));\n            }\n            return true;\n        }"}
{"magic_number_smell": "\n        int minProposedSize = (int) Math.min(placements.reads.forRange(replica.range()).get().stream().filter(r -> !r.endpoint().equals(endpoint)).count(),\n                                             placements.writes.forRange(replica.range()).get().stream().filter(r -> !r.endpoint().equals(endpoint)).count());\n        if (minProposedSize < 3)\n        {\n            logger.warn(\"Removing {} from CMS members would reduce the service size to {} which is below the \" +\n                        \"configured safe quorum {}. This requires the force option which is set to {}, {}proceeding\",", "refactored_code": "    public static final int MIN_SAFE_CMS_SIZE = 3;\n\n        int minProposedSize = (int) Math.min(placements.reads.forRange(replica.range()).get().stream().filter(r -> !r.endpoint().equals(endpoint)).count(),\n                                             placements.writes.forRange(replica.range()).get().stream().filter(r -> !r.endpoint().equals(endpoint)).count());\n        if (minProposedSize < MIN_SAFE_CMS_SIZE)\n        {\n            logger.warn(\"Removing {} from CMS members would reduce the service size to {} which is below the \" +\n                        \"configured safe quorum {}. This requires the force option which is set to {}, {}proceeding\","}
{"magic_number_smell": "    public AbstractJmxClient(String host, Integer port, String username, String password) throws IOException\n    {\n        this.host = (host != null) ? host : DEFAULT_HOST;\n        this.port = (port != null) ? port : 7199;\n        this.username = username;\n        this.password = password;\n        jmxConn = new JMXConnection(this.host, this.port, username, password);", "refactored_code": "    protected static final int DEFAULT_JMX_PORT = 7199;\n    public AbstractJmxClient(String host, Integer port, String username, String password) throws IOException\n    {\n        this.host = (host != null) ? host : DEFAULT_HOST;\n        this.port = (port != null) ? port : DEFAULT_JMX_PORT;\n        this.username = username;\n        this.password = password;\n        jmxConn = new JMXConnection(this.host, this.port, username, password);"}
{"magic_number_smell": "            if (password.length() < MIN_PASS_LENGTH)\n                System.err.println(\"WARNING: The provided password is very short, probably too short to be secure.\");\n\n            int logRounds = cmd.hasOption(LOGROUNDS_OPTION) ? Integer.parseInt(cmd.getOptionValue(LOGROUNDS_OPTION)) : 10;\n            if (logRounds < 4 || logRounds > 30)\n            {\n                System.err.println(String.format(\"Bad value for --%s %d. \" +", "refactored_code": "    private static final int LOGROUNDS_DEFAULT = 10;\n            if (password.length() < MIN_PASS_LENGTH)\n                System.err.println(\"WARNING: The provided password is very short, probably too short to be secure.\");\n\n            int logRounds = cmd.hasOption(LOGROUNDS_OPTION) ? Integer.parseInt(cmd.getOptionValue(LOGROUNDS_OPTION)) : LOGROUNDS_DEFAULT;\n            if (logRounds < 4 || logRounds > 30)\n            {\n                System.err.println(String.format(\"Bad value for --%s %d. \" +"}
{"magic_number_smell": "\n            charsPerLevel = indent.length();\n\n            indents = new char[indent.length() * 16];\n            int offset = 0;\n            for (int i = 0; i < 16; i++)\n            {", "refactored_code": "        private static final int INDENT_LEVELS = 16;\n\n            charsPerLevel = indent.length();\n\n            indents = new char[indent.length() * INDENT_LEVELS];\n            int offset = 0;\n            for (int i = 0; i < INDENT_LEVELS; i++)\n            {"}
{"magic_number_smell": "    public NodeProbe(String host) throws IOException\n    {\n        this.host = host;\n        this.port = 7199;\n        this.output = Output.CONSOLE;\n        connect();\n    }", "refactored_code": "    private static final int defaultPort = 7199;\n    public NodeProbe(String host) throws IOException\n    {\n        this.host = host;\n        this.port = defaultPort;\n        this.output = Output.CONSOLE;\n        connect();\n    }"}
{"magic_number_smell": "                Options opts = new Options(Arrays.asList(args));\n                opts.debug = cmd.hasOption(DEBUG_OPTION);\n                opts.snapshot = !cmd.hasOption(NO_SNAPSHOT_OPTION);\n                opts.sizeInMB = 50;\n\n                if (cmd.hasOption(SIZE_OPTION))\n                    opts.sizeInMB = Integer.parseInt(cmd.getOptionValue(SIZE_OPTION));", "refactored_code": "    public static final int DEFAULT_SSTABLE_SIZE = 50;\n                Options opts = new Options(Arrays.asList(args));\n                opts.debug = cmd.hasOption(DEBUG_OPTION);\n                opts.snapshot = !cmd.hasOption(NO_SNAPSHOT_OPTION);\n                opts.sizeInMB = DEFAULT_SSTABLE_SIZE;\n\n                if (cmd.hasOption(SIZE_OPTION))\n                    opts.sizeInMB = Integer.parseInt(cmd.getOptionValue(SIZE_OPTION));"}
{"magic_number_smell": "\n    public static KeyspaceMetadata metadata()\n    {\n        return KeyspaceMetadata.create(SchemaConstants.TRACE_KEYSPACE_NAME, KeyspaceParams.simple(Math.max(CassandraRelevantProperties.SYSTEM_TRACES_DEFAULT_RF.getInt(), DatabaseDescriptor.getDefaultKeyspaceRF())), Tables.of(Sessions, Events));\n    }\n\n    static Mutation makeStartSessionMutation(ByteBuffer sessionId,", "refactored_code": "    public static final int DEFAULT_RF = CassandraRelevantProperties.SYSTEM_TRACES_DEFAULT_RF.getInt();\n\n    public static KeyspaceMetadata metadata()\n    {\n        return KeyspaceMetadata.create(SchemaConstants.TRACE_KEYSPACE_NAME, KeyspaceParams.simple(Math.max(DEFAULT_RF, DatabaseDescriptor.getDefaultKeyspaceRF())), Tables.of(Sessions, Events));\n    }\n\n    static Mutation makeStartSessionMutation(ByteBuffer sessionId,"}
{"magic_number_smell": "\n    public static UUID readUUID(ByteBuf cb)\n    {\n        ByteBuffer buffer = cb.nioBuffer(cb.readerIndex(), 16);\n        cb.skipBytes(buffer.remaining());\n        return UUIDGen.getUUID(buffer);\n    }", "refactored_code": "    private static final int UUID_SIZE = 16;\n\n    public static UUID readUUID(ByteBuf cb)\n    {\n        ByteBuffer buffer = cb.nioBuffer(cb.readerIndex(), UUID_SIZE);\n        cb.skipBytes(buffer.remaining());\n        return UUIDGen.getUUID(buffer);\n    }"}
{"magic_number_smell": "            byte[] input = CBUtil.readRawBytes(uncompressed.body);\n\n            int maxCompressedLength = compressor.maxCompressedLength(input.length);\n            ByteBuf outputBuf = CBUtil.allocator.heapBuffer(4 + maxCompressedLength);\n\n            byte[] output = outputBuf.array();\n            int outputOffset = outputBuf.arrayOffset();", "refactored_code": "        private static final int INTEGER_BYTES = 4;\n            byte[] input = CBUtil.readRawBytes(uncompressed.body);\n\n            int maxCompressedLength = compressor.maxCompressedLength(input.length);\n            ByteBuf outputBuf = CBUtil.allocator.heapBuffer(INTEGER_BYTES + maxCompressedLength);\n\n            byte[] output = outputBuf.array();\n            int outputOffset = outputBuf.arrayOffset();"}
{"magic_number_smell": "    {\n        super(decoder,\n              channel,\n              FrameEncoder.Payload.MAX_SIZE - 1,\n              queueCapacity,\n              resources.endpointLimit(),\n              resources.globalLimit(),", "refactored_code": "    public static final int LARGE_MESSAGE_THRESHOLD = FrameEncoder.Payload.MAX_SIZE - 1;\n    {\n        super(decoder,\n              channel,\n              LARGE_MESSAGE_THRESHOLD,\n              queueCapacity,\n              resources.endpointLimit(),\n              resources.globalLimit(),"}
{"magic_number_smell": "        }\n\n        @Override\n        public long nanoTime()()\n        {\n            return nanoTime();\n        }", "refactored_code": "        private final long creationTimeNanos = nanoTime();\n        }\n\n        @Override\n        public long creationTimeNanos()\n        {\n            return creationTimeNanos;\n        }"}
{"magic_number_smell": "                                        buffer.remaining());\n            int idx = buffer.position();\n            int firstByte = buffer.get(idx++);\n            int versionNum = firstByte & 0x7f;\n            int flags = buffer.get(idx++);\n            int streamId = buffer.getShort(idx);\n            idx += 2;", "refactored_code": "    public static final byte PROTOCOL_VERSION_MASK = 0x7f;\n                                        buffer.remaining());\n            int idx = buffer.position();\n            int firstByte = buffer.get(idx++);\n            int versionNum = firstByte & PROTOCOL_VERSION_MASK;\n            int flags = buffer.get(idx++);\n            int streamId = buffer.getShort(idx);\n            idx += 2;"}
{"magic_number_smell": "\n    ProtocolVersionTracker()\n    {\n        this(100);\n    }\n\n    private ProtocolVersionTracker(int capacity)", "refactored_code": "    private static final int DEFAULT_MAX_CAPACITY = 100;\n\n    ProtocolVersionTracker()\n    {\n        this(DEFAULT_MAX_CAPACITY);\n    }\n\n    private ProtocolVersionTracker(int capacity)"}
{"magic_number_smell": "        {\n            request.attach(connection);\n            lastWriteFuture = channel.writeAndFlush(Collections.singletonList(request));\n            Message.Response msg = responseHandler.responses.poll(10, TimeUnit.SECONDS);\n            if (msg == null)\n                throw new RuntimeException(\"timeout\");\n            if (throwOnErrorResponse && msg instanceof ErrorMessage)", "refactored_code": "    public static final int TIMEOUT_SECONDS = 10;\n        {\n            request.attach(connection);\n            lastWriteFuture = channel.writeAndFlush(Collections.singletonList(request));\n            Message.Response msg = responseHandler.responses.poll(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n            if (msg == null)\n                throw new RuntimeException(\"timeout\");\n            if (throwOnErrorResponse && msg instanceof ErrorMessage)"}
{"magic_number_smell": "        int maxK = probs[maxBucketsPerElement].length - 1;\n\n        // Handle the trivial cases\n        if(maxFalsePosProb >= probs[2][minK])\n        {\n            return new BloomSpecification(2, optKPerBuckets[2]);\n        }", "refactored_code": "    private static final int minBuckets = 2;\n        int maxK = probs[maxBucketsPerElement].length - 1;\n\n        // Handle the trivial cases\n        if(maxFalsePosProb >= probs[minBuckets][minK])\n        {\n            return new BloomSpecification(2, optKPerBuckets[2]);\n        }"}
{"magic_number_smell": "    {\n        ByteBuffer dup = bb.duplicate();\n        dup.position(offset);\n        dup.limit(dup.position() + 16);\n        return wrap(dup);\n    }\n", "refactored_code": "    public static final int LENGTH = 16; // we assume a fixed length size for all CounterIds\n    {\n        ByteBuffer dup = bb.duplicate();\n        dup.position(offset);\n        dup.limit(dup.position() + LENGTH);\n        return wrap(dup);\n    }\n"}
{"magic_number_smell": "                                                                           getSnapshotName(prefix),\n                                                                           false));\n\n            if (!ranges.isEmpty() && ranges.size() < 100)\n                msg = msg.withParam(SNAPSHOT_RANGES, ranges);\n            for (InetAddressAndPort replica : endpoints)\n                MessagingService.instance().send(msg, replica);", "refactored_code": "    private static final int MAX_SNAPSHOT_RANGE_COUNT = 100; // otherwise, snapshot everything\n                                                                           getSnapshotName(prefix),\n                                                                           false));\n\n            if (!ranges.isEmpty() && ranges.size() < MAX_SNAPSHOT_RANGE_COUNT)\n                msg = msg.withParam(SNAPSHOT_RANGES, ranges);\n            for (InetAddressAndPort replica : endpoints)\n                MessagingService.instance().send(msg, replica);"}
{"magic_number_smell": "\n    public EstimatedHistogram()\n    {\n        this(90);\n    }\n\n    public EstimatedHistogram(int bucketCount)", "refactored_code": "    public static final int DEFAULT_BUCKET_COUNT = 90;\n\n    public EstimatedHistogram()\n    {\n        this(DEFAULT_BUCKET_COUNT);\n    }\n\n    public EstimatedHistogram(int bucketCount)"}
{"magic_number_smell": "        {\n            while (length > 0)\n            {\n                long size = (length > 1 << 20) ? 1 << 20 : length;\n                // if src or dst are null, the offsets are absolute base addresses:\n                theUnsafe.copyMemory(src, srcOffset, dst, dstOffset, size);\n                length -= size;", "refactored_code": "        private static final long UNSAFE_COPY_THRESHOLD = 1 << 20;\n        {\n            while (length > 0)\n            {\n                long size = (length > UNSAFE_COPY_THRESHOLD) ? UNSAFE_COPY_THRESHOLD : length;\n                // if src or dst are null, the offsets are absolute base addresses:\n                theUnsafe.copyMemory(src, srcOffset, dst, dstOffset, size);\n                length -= size;"}
{"magic_number_smell": "\n    private static IFilter createFilter(int hash, long numElements, int bucketsPer)\n    {\n        long numBits = (numElements * bucketsPer) + 20;\n        IBitSet bitset = new OffHeapBitSet(numBits);\n        return new BloomFilter(hash, bitset);\n    }", "refactored_code": "    private static final long BITSET_EXCESS = 20;\n\n    private static IFilter createFilter(int hash, long numElements, int bucketsPer)\n    {\n        long numBits = (numElements * bucketsPer) + BITSET_EXCESS;\n        IBitSet bitset = new OffHeapBitSet(numBits);\n        return new BloomFilter(hash, bitset);\n    }"}
{"magic_number_smell": "         * measured to be too expensive when sorting \"mid-sized\" arrays (e.g.,\n         * 100 elements) in Java.  Therefore, we use smaller (but sufficiently\n         * large) stack lengths for smaller arrays.  The \"magic numbers\" in the\n         * computation below must be changed if 32 is decreased.  See\n         * the 32 declaration above for more information.\n         */\n        int stackLen = (len <    120  ?  5 :", "refactored_code": "    private static final int MIN_MERGE = 32;\n         * measured to be too expensive when sorting \"mid-sized\" arrays (e.g.,\n         * 100 elements) in Java.  Therefore, we use smaller (but sufficiently\n         * large) stack lengths for smaller arrays.  The \"magic numbers\" in the\n         * computation below must be changed if MIN_MERGE is decreased.  See\n         * the MIN_MERGE declaration above for more information.\n         */\n        int stackLen = (len <    120  ?  5 :"}
{"magic_number_smell": "    private static final Logger logger = LoggerFactory.getLogger(MerkleTree.class);\n\n    private static final int 32 = 32; // 2xMM3_128 = 32 bytes.\n    private static final byte[] EMPTY_HASH = new byte[32];\n\n    /*\n     * Thread-local byte array, large enough to host 32B of digest or MM3/Random partitoners' tokens", "refactored_code": "    private static final int HASH_SIZE = 32; // 2xMM3_128 = 32 bytes.\n    private static final Logger logger = LoggerFactory.getLogger(MerkleTree.class);\n\n    private static final int HASH_SIZE = 32; // 2xMM3_128 = 32 bytes.\n    private static final byte[] EMPTY_HASH = new byte[HASH_SIZE];\n\n    /*\n     * Thread-local byte array, large enough to host 32B of digest or MM3/Random partitoners' tokens"}
{"magic_number_smell": "            if (almostSameTimeUpdater != null)\n                throw new IllegalStateException(\"Already running\");\n            updateAlmostSameTime();\n            logger.info(\"Scheduling approximate time conversion task with an interval of {} milliseconds\", NANOTIMETOMILLIS_TIMESTAMP_UPDATE_INTERVAL.getLong());\n            almostSameTimeUpdater = ScheduledExecutors.scheduledFastTasks.scheduleWithFixedDelay(this::updateAlmostSameTime, NANOTIMETOMILLIS_TIMESTAMP_UPDATE_INTERVAL.getLong(), NANOTIMETOMILLIS_TIMESTAMP_UPDATE_INTERVAL.getLong(), MILLISECONDS);\n        }\n", "refactored_code": "        private static final long UPDATE_INTERVAL_MS = NANOTIMETOMILLIS_TIMESTAMP_UPDATE_INTERVAL.getLong();\n            if (almostSameTimeUpdater != null)\n                throw new IllegalStateException(\"Already running\");\n            updateAlmostSameTime();\n            logger.info(\"Scheduling approximate time conversion task with an interval of {} milliseconds\", UPDATE_INTERVAL_MS);\n            almostSameTimeUpdater = ScheduledExecutors.scheduledFastTasks.scheduleWithFixedDelay(this::updateAlmostSameTime, UPDATE_INTERVAL_MS, UPDATE_INTERVAL_MS, MILLISECONDS);\n        }\n"}
{"magic_number_smell": "            if (!(e instanceof LastErrorException))\n                throw e;\n\n            if (errno(e) == 12 && osType == LINUX)\n            {\n                logger.warn(\"Unable to lock JVM memory (12).\"\n                        + \" This can result in part of the JVM being swapped out, especially with mmapped I/O enabled.\"", "refactored_code": "    private static final int ENOMEM = 12;\n            if (!(e instanceof LastErrorException))\n                throw e;\n\n            if (errno(e) == ENOMEM && osType == LINUX)\n            {\n                logger.warn(\"Unable to lock JVM memory (ENOMEM).\"\n                        + \" This can result in part of the JVM being swapped out, especially with mmapped I/O enabled.\""}
{"magic_number_smell": "            if (buffer.isDirect())\n                return DIRECT_BUFFER_SHALLOW_SIZE; // We ignore the underlying buffer\n\n            return measure(ByteBufferUtil.EMPTY_BYTE_BUFFER) + buffer.remaining(); // We ignore the array overhead\n        }\n\n        if (buffer.isDirect())", "refactored_code": "    private static final long HEAP_BUFFER_SHALLOW_SIZE = measure(ByteBufferUtil.EMPTY_BYTE_BUFFER);\n            if (buffer.isDirect())\n                return DIRECT_BUFFER_SHALLOW_SIZE; // We ignore the underlying buffer\n\n            return HEAP_BUFFER_SHALLOW_SIZE + buffer.remaining(); // We ignore the array overhead\n        }\n\n        if (buffer.isDirect())"}
{"magic_number_smell": "                            continue;\n\n                        String limit = parts[2];\n                        return \"unlimited\".equals(limit) ? -1L : Long.parseLong(limit);\n                    }\n                }\n                logger.error(\"'Max processes' not found in {}\", path);", "refactored_code": "    private static final long INFINITY = -1L;\n                            continue;\n\n                        String limit = parts[2];\n                        return \"unlimited\".equals(limit) ? INFINITY : Long.parseLong(limit);\n                    }\n                }\n                logger.error(\"'Max processes' not found in {}\", path);"}
{"magic_number_smell": "\n    public static ByteBuffer toByteBuffer(UUID uuid)\n    {\n        ByteBuffer buffer = ByteBuffer.allocate(16);\n        buffer.putLong(uuid.getMostSignificantBits());\n        buffer.putLong(uuid.getLeastSignificantBits());\n        buffer.flip();", "refactored_code": "    public static final int UUID_LEN = 16;\n\n    public static ByteBuffer toByteBuffer(UUID uuid)\n    {\n        ByteBuffer buffer = ByteBuffer.allocate(UUID_LEN);\n        buffer.putLong(uuid.getMostSignificantBits());\n        buffer.putLong(uuid.getLeastSignificantBits());\n        buffer.flip();"}
{"magic_number_smell": "    private static final long TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES) = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n\n    /**\n     * use a DelayQueue to simplify retries - we want first tries to be executed immediately and retries should wait TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES)\n     */\n    private final DelayQueue<DelayFile> archiveQueue = new DelayQueue<>();\n    private final String archiveCommand;", "refactored_code": "    private static final long DEFAULT_RETRY_DELAY_MS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n    private static final long DEFAULT_RETRY_DELAY_MS = TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES);\n\n    /**\n     * use a DelayQueue to simplify retries - we want first tries to be executed immediately and retries should wait DEFAULT_RETRY_DELAY_MS\n     */\n    private final DelayQueue<DelayFile> archiveQueue = new DelayQueue<>();\n    private final String archiveCommand;"}
{"magic_number_smell": "     */\n    public static final int BTREE_BRANCH_SHIFT.getInt() = BTREE_BRANCH_SHIFT.getInt();\n\n    private static final int BRANCH_FACTOR = 1 << BTREE_BRANCH_SHIFT.getInt();\n    public static final int MIN_KEYS = BRANCH_FACTOR / 2 - 1;\n    public static final int MAX_KEYS = BRANCH_FACTOR - 1;\n", "refactored_code": "    public static final int BRANCH_SHIFT = BTREE_BRANCH_SHIFT.getInt();\n     */\n    public static final int BRANCH_SHIFT = BTREE_BRANCH_SHIFT.getInt();\n\n    private static final int BRANCH_FACTOR = 1 << BRANCH_SHIFT;\n    public static final int MIN_KEYS = BRANCH_FACTOR / 2 - 1;\n    public static final int MAX_KEYS = BRANCH_FACTOR - 1;\n"}
{"magic_number_smell": "    private final int lowerBound, upperBound; // inclusive\n\n    private static final int 0 = 0; // only \"exists\" as an absence of other states\n    private static final int ON_ITEM = 1; // may only co-exist with LAST (or 0, which is 0)\n    private static final int BEFORE_FIRST = 2; // may not coexist with any other state\n    private static final int LAST = 4; // may co-exist with ON_ITEM, in which case we are also at END\n    private static final int END = 5; // equal to LAST | ON_ITEM", "refactored_code": "    private static final int MIDDLE = 0; // only \"exists\" as an absence of other states\n    private final int lowerBound, upperBound; // inclusive\n\n    private static final int MIDDLE = 0; // only \"exists\" as an absence of other states\n    private static final int ON_ITEM = 1; // may only co-exist with LAST (or MIDDLE, which is 0)\n    private static final int BEFORE_FIRST = 2; // may not coexist with any other state\n    private static final int LAST = 4; // may co-exist with ON_ITEM, in which case we are also at END\n    private static final int END = 5; // equal to LAST | ON_ITEM"}
{"magic_number_smell": "        private static final int Integer.MIN_VALUE = Integer.MIN_VALUE;\n\n        private final ByteSource wrapped;\n        private int peeked = Integer.MIN_VALUE;\n\n        public Peekable(ByteSource wrapped)\n        {", "refactored_code": "        private static final int NONE = Integer.MIN_VALUE;\n        private static final int NONE = Integer.MIN_VALUE;\n\n        private final ByteSource wrapped;\n        private int peeked = NONE;\n\n        public Peekable(ByteSource wrapped)\n        {"}
{"magic_number_smell": "     * bytes, <strong>excluding the {@link ByteSource#END_OF_STREAM}</strong>.\n     * <p>\n     * This is equivalent to {@link #readBytes(ByteSource, int)} where the second actual parameter is\n     * {@linkplain #32} ({@value 32}).\n     *\n     * @param byteSource The source which bytes we're interested in.\n     * @return A byte array containing exactly all the read bytes. In case of a {@code null} source, the returned byte", "refactored_code": "    private static final int INITIAL_BUFFER_CAPACITY = 32;\n     * bytes, <strong>excluding the {@link ByteSource#END_OF_STREAM}</strong>.\n     * <p>\n     * This is equivalent to {@link #readBytes(ByteSource, int)} where the second actual parameter is\n     * {@linkplain #INITIAL_BUFFER_CAPACITY} ({@value INITIAL_BUFFER_CAPACITY}).\n     *\n     * @param byteSource The source which bytes we're interested in.\n     * @return A byte array containing exactly all the read bytes. In case of a {@code null} source, the returned byte"}
{"magic_number_smell": "public class NonBlockingRateLimiter\n{\n    public static final long TimeUnit.SECONDS.toNanos(1) = TimeUnit.SECONDS.toNanos(1);\n    static final long DEFAULT_BURST_NANOS = TimeUnit.SECONDS.toNanos(1);\n\n    /** a starting time for elapsed time calculations */\n    private final long startedNanos;", "refactored_code": "    public static final long NANOS_PER_SECOND = TimeUnit.SECONDS.toNanos(1);\npublic class NonBlockingRateLimiter\n{\n    public static final long NANOS_PER_SECOND = TimeUnit.SECONDS.toNanos(1);\n    static final long DEFAULT_BURST_NANOS = NANOS_PER_SECOND;\n\n    /** a starting time for elapsed time calculations */\n    private final long startedNanos;"}
{"magic_number_smell": "         * 1) LIVE:      many calls to register() and close()\n         * 2) FINISHING: a call to expire() (after a barrier issue), means calls to register() will now fail,\n         *               and we are now 'in the past' (new operations will be started against a new Ordered)\n         * 3) -1:  once the last close() is called, this Ordered is done. We call unlink().\n         * 4) ZOMBIE:    all our operations are finished, but some operations against an earlier Ordered are still\n         *               running, or tidying up, so unlink() fails to remove us\n         * 5) COMPLETE:  all operations started on or before us are -1 (and COMPLETE), so we are unlinked", "refactored_code": "    private static final int FINISHED = -1;\n         * 1) LIVE:      many calls to register() and close()\n         * 2) FINISHING: a call to expire() (after a barrier issue), means calls to register() will now fail,\n         *               and we are now 'in the past' (new operations will be started against a new Ordered)\n         * 3) FINISHED:  once the last close() is called, this Ordered is done. We call unlink().\n         * 4) ZOMBIE:    all our operations are finished, but some operations against an earlier Ordered are still\n         *               running, or tidying up, so unlink() fails to remove us\n         * 5) COMPLETE:  all operations started on or before us are FINISHED (and COMPLETE), so we are unlinked"}
{"magic_number_smell": "\n            public boolean isCancelled()\n            {\n                return state == -1;\n            }\n\n            public boolean isSet()", "refactored_code": "        private static final int CANCELLED = -1;\n\n            public boolean isCancelled()\n            {\n                return state == CANCELLED;\n            }\n\n            public boolean isSet()"}
{"magic_number_smell": "     * Used by chunk cache to store decompressed data and buffers may be held by chunk cache for arbitrary period.\n     */\n    private static final long DatabaseDescriptor.getFileCacheSizeInMiB() * 1024L * 1024L = DatabaseDescriptor.getFileCacheSizeInMiB() * 1024L * 1024L;\n    private static final BufferPool CHUNK_CACHE_POOL = new BufferPool(\"chunk-cache\", DatabaseDescriptor.getFileCacheSizeInMiB() * 1024L * 1024L, true);\n\n    /**\n     * Used by client-server or inter-node requests, buffers should be released immediately after use.", "refactored_code": "    private static final long FILE_MEMORY_USAGE_THRESHOLD = DatabaseDescriptor.getFileCacheSizeInMiB() * 1024L * 1024L;\n     * Used by chunk cache to store decompressed data and buffers may be held by chunk cache for arbitrary period.\n     */\n    private static final long FILE_MEMORY_USAGE_THRESHOLD = DatabaseDescriptor.getFileCacheSizeInMiB() * 1024L * 1024L;\n    private static final BufferPool CHUNK_CACHE_POOL = new BufferPool(\"chunk-cache\", FILE_MEMORY_USAGE_THRESHOLD, true);\n\n    /**\n     * Used by client-server or inter-node requests, buffers should be released immediately after use."}
{"magic_number_smell": "    {\n        while (count > 0)\n        {\n            long size = (count> 1024 * 1024L) ? 1024 * 1024L : count;\n            unsafe.copyMemory(src, trg, size);\n            count -= size;\n            src += size;", "refactored_code": "    private static final long UNSAFE_COPY_THRESHOLD = 1024 * 1024L; // copied from java.nio.Bits\n    {\n        while (count > 0)\n        {\n            long size = (count> UNSAFE_COPY_THRESHOLD) ? UNSAFE_COPY_THRESHOLD : count;\n            unsafe.copyMemory(src, trg, size);\n            count -= size;\n            src += size;"}
{"magic_number_smell": "        {\n            points = new long[maxCapacity];\n            values = new int[maxCapacity];\n            Arrays.fill(points, Long.MAX_VALUE);\n            Arrays.fill(values, 0);\n            this.roundSeconds = roundSeconds;\n        }", "refactored_code": "        private static final long EMPTY = Long.MAX_VALUE;\n        {\n            points = new long[maxCapacity];\n            values = new int[maxCapacity];\n            Arrays.fill(points, EMPTY);\n            Arrays.fill(values, 0);\n            this.roundSeconds = roundSeconds;\n        }"}
{"magic_number_smell": "            this.runForNanos = runForNanos;\n\n            int i = 0;\n            long minId = 0, maxId = 1 << 20 - 1;\n            for (InetAddressAndPort recipient : endpoints)\n            {\n                for (InetAddressAndPort sender : endpoints)", "refactored_code": "        private static final int messageIdsPerConnection = 1 << 20;\n            this.runForNanos = runForNanos;\n\n            int i = 0;\n            long minId = 0, maxId = messageIdsPerConnection - 1;\n            for (InetAddressAndPort recipient : endpoints)\n            {\n                for (InetAddressAndPort sender : endpoints)"}
{"magic_number_smell": "                }\n\n                // allocate a new buffer\n                size = (int) Math.max(1, 16 << 10 + (STDEV_BUFFER_SIZE * rand.nextGaussian()));\n                if (size <= BufferPool.NORMAL_CHUNK_SIZE)\n                {\n                    totalSize += BufferPool.roundUp(size);", "refactored_code": "    private static final int AVG_BUFFER_SIZE = 16 << 10;\n                }\n\n                // allocate a new buffer\n                size = (int) Math.max(1, AVG_BUFFER_SIZE + (STDEV_BUFFER_SIZE * rand.nextGaussian()));\n                if (size <= BufferPool.NORMAL_CHUNK_SIZE)\n                {\n                    totalSize += BufferPool.roundUp(size);"}
{"magic_number_smell": "    {\n        private static final int -1 = -1;\n\n        private int numColumns = -1;\n        private String[] names;\n        private final List<Object[]> results = new ArrayList<>();\n        private final List<String> warnings = new ArrayList<>();", "refactored_code": "        private static final int UNSET = -1;\n    {\n        private static final int UNSET = -1;\n\n        private int numColumns = UNSET;\n        private String[] names;\n        private final List<Object[]> results = new ArrayList<>();\n        private final List<String> warnings = new ArrayList<>();"}
{"magic_number_smell": "    {\n        checkAccess();\n        int idx = findIndex(name);\n        if (idx == -1)\n            throw new NoSuchElementException(\"by name: \" + name);\n        return (T) results[idx];\n    }", "refactored_code": "    private static final int NOT_FOUND = -1;\n    {\n        checkAccess();\n        int idx = findIndex(name);\n        if (idx == NOT_FOUND)\n            throw new NoSuchElementException(\"by name: \" + name);\n        return (T) results[idx];\n    }"}
{"magic_number_smell": "            // alive for long enough (minutes) to keep classloaders from being collected.\n            // Set these two system properties to a low value to allow cleanup to occur fast enough\n            // for GC to collect our classloaders.\n            JAVA_RMI_DGC_LEASE_VALUE_IN_JVM_DTEST.setInt(1000);\n            SUN_RMI_TRANSPORT_TCP_THREADKEEPALIVETIME.setInt(1000);\n            ORG_APACHE_CASSANDRA_DISABLE_MBEAN_REGISTRATION.setBoolean(false);\n            InetAddress addr = config.broadcastAddress().getAddress();", "refactored_code": "    public static final int RMI_KEEPALIVE_TIME = 1000;\n            // alive for long enough (minutes) to keep classloaders from being collected.\n            // Set these two system properties to a low value to allow cleanup to occur fast enough\n            // for GC to collect our classloaders.\n            JAVA_RMI_DGC_LEASE_VALUE_IN_JVM_DTEST.setInt(RMI_KEEPALIVE_TIME);\n            SUN_RMI_TRANSPORT_TCP_THREADKEEPALIVETIME.setInt(RMI_KEEPALIVE_TIME);\n            ORG_APACHE_CASSANDRA_DISABLE_MBEAN_REGISTRATION.setBoolean(false);\n            InetAddress addr = config.broadcastAddress().getAddress();"}
{"magic_number_smell": "                                1, rowId, 0);\n\n                // threads should be numbered from 1 to allow 0 to be \"unlocked\"\n                for (int j = 1; j <= 5; j++)\n                {\n                    int threadId = j;\n                    AtomicInteger lockedTimes = new AtomicInteger();", "refactored_code": "    private static final int threadCount = 5;\n                                1, rowId, 0);\n\n                // threads should be numbered from 1 to allow 0 to be \"unlocked\"\n                for (int j = 1; j <= threadCount; j++)\n                {\n                    int threadId = j;\n                    AtomicInteger lockedTimes = new AtomicInteger();"}
{"magic_number_smell": "    {\n        cluster.schemaChange(withKeyspace(\"CREATE TABLE %s.tbl (pk int, v text, PRIMARY KEY (pk));\"));\n\n        for (int i = 0; i < 1000; i++) {\n            cluster.coordinator(1).execute(withKeyspace(\"INSERT INTO %s.tbl (pk, v) VALUES (?,?)\"), ConsistencyLevel.ALL, i, \"compressable\");\n        }\n", "refactored_code": "    private static final int MUTATIONS = 1000;\n    {\n        cluster.schemaChange(withKeyspace(\"CREATE TABLE %s.tbl (pk int, v text, PRIMARY KEY (pk));\"));\n\n        for (int i = 0; i < MUTATIONS; i++) {\n            cluster.coordinator(1).execute(withKeyspace(\"INSERT INTO %s.tbl (pk, v) VALUES (?,?)\"), ConsistencyLevel.ALL, i, \"compressable\");\n        }\n"}
{"magic_number_smell": "    }\n\n    public static NodeToolResult repair(ICluster<IInvokableInstance> cluster, RepairType repairType, boolean withNotifications, String... args) {\n        return repair(cluster, 1, repairType, withNotifications, args);\n    }\n\n    public static NodeToolResult repair(ICluster<IInvokableInstance> cluster, int node, RepairType repairType, boolean withNotifications, String... args) {", "refactored_code": "    public static final int DEFAULT_COORDINATOR = 1;\n    }\n\n    public static NodeToolResult repair(ICluster<IInvokableInstance> cluster, RepairType repairType, boolean withNotifications, String... args) {\n        return repair(cluster, DEFAULT_COORDINATOR, repairType, withNotifications, args);\n    }\n\n    public static NodeToolResult repair(ICluster<IInvokableInstance> cluster, int node, RepairType repairType, boolean withNotifications, String... args) {"}
{"magic_number_smell": "            AtomicInteger writes = new AtomicInteger(0);\n            AtomicInteger paxos = new AtomicInteger(0);\n            \n            for (int i = 0; i < 256; i++)\n            {\n                int k = i;\n                executor.execute(() -> cluster.coordinator(1).execute(\"INSERT INTO \" + KEYSPACE + \".tbl (k, v) VALUES (\" + k + \", 0)\", ConsistencyLevel.ALL));", "refactored_code": "    public static final int ITERATIONS = 256;\n            AtomicInteger writes = new AtomicInteger(0);\n            AtomicInteger paxos = new AtomicInteger(0);\n            \n            for (int i = 0; i < ITERATIONS; i++)\n            {\n                int k = i;\n                executor.execute(() -> cluster.coordinator(1).execute(\"INSERT INTO \" + KEYSPACE + \".tbl (k, v) VALUES (\" + k + \", 0)\", ConsistencyLevel.ALL));"}
{"magic_number_smell": "    public static Collection<Object[]> data()\n    {\n        List<Object[]> result = new ArrayList<>();\n        for (int coordinator = 1; coordinator <= 2; coordinator++)\n            for (boolean paging : BOOLEANS)\n                for (boolean reverse : BOOLEANS)\n                    result.add(new Object[]{ ReadRepairStrategy.BLOCKING, coordinator, paging, reverse });", "refactored_code": "    private static final int NUM_NODES = 2;\n    public static Collection<Object[]> data()\n    {\n        List<Object[]> result = new ArrayList<>();\n        for (int coordinator = 1; coordinator <= NUM_NODES; coordinator++)\n            for (boolean paging : BOOLEANS)\n                for (boolean reverse : BOOLEANS)\n                    result.add(new Object[]{ ReadRepairStrategy.BLOCKING, coordinator, paging, reverse });"}
{"magic_number_smell": "    public static Collection<Object[]> data()\n    {\n        List<Object[]> result = new ArrayList<>();\n        for (int coordinator = 1; coordinator <= 2; coordinator++)\n            for (boolean flush : BOOLEANS)\n                for (boolean paging : BOOLEANS)\n                    result.add(new Object[]{ ReadRepairStrategy.BLOCKING, coordinator, flush, paging });", "refactored_code": "    private static final int NUM_NODES = 2;\n    public static Collection<Object[]> data()\n    {\n        List<Object[]> result = new ArrayList<>();\n        for (int coordinator = 1; coordinator <= NUM_NODES; coordinator++)\n            for (boolean flush : BOOLEANS)\n                for (boolean paging : BOOLEANS)\n                    result.add(new Object[]{ ReadRepairStrategy.BLOCKING, coordinator, flush, paging });"}
{"magic_number_smell": "    public static void setup() throws IOException\n    {\n        cluster = init(Cluster.build()\n                              .withNodes(2)\n                              .withConfig(config -> config.set(\"hinted_handoff_enabled\", false)\n                                                          .set(\"commitlog_sync\", \"batch\")).start());\n", "refactored_code": "    private static final int REPLICAS = 2;\n    public static void setup() throws IOException\n    {\n        cluster = init(Cluster.build()\n                              .withNodes(REPLICAS)\n                              .withConfig(config -> config.set(\"hinted_handoff_enabled\", false)\n                                                          .set(\"commitlog_sync\", \"batch\")).start());\n"}
{"magic_number_smell": "    @BeforeClass\n    public static void setupCluster() throws IOException\n    {\n        cluster = init(Cluster.build(3).start(), REPLICATION_FACTOR);\n    }\n\n    @AfterClass", "refactored_code": "    private static final int NUM_NODES = 3;\n    @BeforeClass\n    public static void setupCluster() throws IOException\n    {\n        cluster = init(Cluster.build(NUM_NODES).start(), REPLICATION_FACTOR);\n    }\n\n    @AfterClass"}
{"magic_number_smell": "    public static void setupCluster() throws IOException\n    {\n        cluster = init(Cluster.build()\n                              .withNodes(3)\n                              .withConfig(config -> config.set(\"hinted_handoff_enabled\", false))\n                              .start());\n    }", "refactored_code": "    private static final int NUM_NODES = 3;\n    public static void setupCluster() throws IOException\n    {\n        cluster = init(Cluster.build()\n                              .withNodes(NUM_NODES)\n                              .withConfig(config -> config.set(\"hinted_handoff_enabled\", false))\n                              .start());\n    }"}
{"magic_number_smell": "    @BeforeClass\n    public static void setupCluster() throws IOException\n    {\n        cluster = init(Cluster.build(4).start(), REPLICATION_FACTOR);\n    }\n\n    @AfterClass", "refactored_code": "    private static final int NUM_NODES = 4;\n    @BeforeClass\n    public static void setupCluster() throws IOException\n    {\n        cluster = init(Cluster.build(NUM_NODES).start(), REPLICATION_FACTOR);\n    }\n\n    @AfterClass"}
{"magic_number_smell": "        try\n        {\n            Cluster.Builder builder = Cluster.build(3);\n            builder.withConfig(c -> c.set(\"compaction_tombstone_warning_threshold\", 75));\n            cluster = builder.createWithoutStarting();\n        }\n        catch (IOException e)", "refactored_code": "    private static final int COMPACTION_TOMBSTONE_WARN = 75;\n        try\n        {\n            Cluster.Builder builder = Cluster.build(3);\n            builder.withConfig(c -> c.set(\"compaction_tombstone_warning_threshold\", COMPACTION_TOMBSTONE_WARN));\n            cluster = builder.createWithoutStarting();\n        }\n        catch (IOException e)"}
{"magic_number_smell": "    @BeforeClass\n    public static void setupCluster() throws IOException\n    {\n        cluster = init(Cluster.build(2)\n                              .withConfig(c -> c.with(Feature.GOSSIP, Feature.NATIVE_PROTOCOL)\n                                                .set(\"collection_size_warn_threshold\", WARN_THRESHOLD + \"B\")\n                                                .set(\"collection_size_fail_threshold\", FAIL_THRESHOLD + \"B\"))", "refactored_code": "    private static final int NUM_NODES = 2;\n    @BeforeClass\n    public static void setupCluster() throws IOException\n    {\n        cluster = init(Cluster.build(NUM_NODES)\n                              .withConfig(c -> c.with(Feature.GOSSIP, Feature.NATIVE_PROTOCOL)\n                                                .set(\"collection_size_warn_threshold\", WARN_THRESHOLD + \"B\")\n                                                .set(\"collection_size_fail_threshold\", FAIL_THRESHOLD + \"B\"))"}
{"magic_number_smell": "        String insert = format(\"INSERT INTO %s(k, v) VALUES (?, 0)\");\n\n        // With both nodes in SPACIOUS state, we can write without warnings nor failures\n        for (int i = 0; i < 100; i++)\n        {\n            ResultSet rs = driverSession.execute(insert, i);\n            Assertions.assertThat(rs.getExecutionInfo().getWarnings()).isEmpty();", "refactored_code": "    private static final int NUM_ROWS = 100;\n        String insert = format(\"INSERT INTO %s(k, v) VALUES (?, 0)\");\n\n        // With both nodes in SPACIOUS state, we can write without warnings nor failures\n        for (int i = 0; i < NUM_ROWS; i++)\n        {\n            ResultSet rs = driverSession.execute(insert, i);\n            Assertions.assertThat(rs.getExecutionInfo().getWarnings()).isEmpty();"}
{"magic_number_smell": "    @BeforeClass\n    public static void setupCluster() throws IOException\n    {\n        cluster = init(Cluster.build(2)\n                              .withConfig(c -> c.set(\"items_per_collection_warn_threshold\", WARN_THRESHOLD)\n                                                .set(\"items_per_collection_fail_threshold\", FAIL_THRESHOLD))\n                              .start());", "refactored_code": "    private static final int NUM_NODES = 2;\n    @BeforeClass\n    public static void setupCluster() throws IOException\n    {\n        cluster = init(Cluster.build(NUM_NODES)\n                              .withConfig(c -> c.set(\"items_per_collection_warn_threshold\", WARN_THRESHOLD)\n                                                .set(\"items_per_collection_fail_threshold\", FAIL_THRESHOLD))\n                              .start());"}
{"magic_number_smell": "public class GuardrailPartitionSizeTest extends GuardrailTester\n{\n    private static final int 1024 * 1024 = 1024 * 1024; // bytes (1 MiB)\n    private static final int FAIL_THRESHOLD = 1024 * 1024 * 2; // bytes (2 MiB)\n\n    private static final int NUM_NODES = 1;\n    private static final int NUM_CLUSTERINGS = 5;", "refactored_code": "    private static final int WARN_THRESHOLD = 1024 * 1024; // bytes (1 MiB)\npublic class GuardrailPartitionSizeTest extends GuardrailTester\n{\n    private static final int WARN_THRESHOLD = 1024 * 1024; // bytes (1 MiB)\n    private static final int FAIL_THRESHOLD = WARN_THRESHOLD * 2; // bytes (2 MiB)\n\n    private static final int NUM_NODES = 1;\n    private static final int NUM_CLUSTERINGS = 5;"}
{"magic_number_smell": "public class GuardrailPartitionTombstonesTest extends GuardrailTester\n{\n    private static final int 500 = 500; // high enough to exceed system tables, which aren't excluded\n    private static final int FAIL_THRESHOLD = 500 * 2;\n\n    private static Cluster cluster;\n", "refactored_code": "    private static final int WARN_THRESHOLD = 500; // high enough to exceed system tables, which aren't excluded\npublic class GuardrailPartitionTombstonesTest extends GuardrailTester\n{\n    private static final int WARN_THRESHOLD = 500; // high enough to exceed system tables, which aren't excluded\n    private static final int FAIL_THRESHOLD = WARN_THRESHOLD * 2;\n\n    private static Cluster cluster;\n"}
{"magic_number_smell": "                                      .withTokenSupplier(node -> even.token(node == 4 || node == 5 ? NODE_TO_REMOVE_NUM : node))\n                                      .start())\n        {\n            IInvokableInstance seed = cluster.get(1);\n            IInvokableInstance nodeToRemove = cluster.get(NODE_TO_REMOVE_NUM);\n            IInvokableInstance peer = cluster.get(PEER_NUM);\n", "refactored_code": "    protected static final int SEED_NUM = 1;\n                                      .withTokenSupplier(node -> even.token(node == 4 || node == 5 ? NODE_TO_REMOVE_NUM : node))\n                                      .start())\n        {\n            IInvokableInstance seed = cluster.get(SEED_NUM);\n            IInvokableInstance nodeToRemove = cluster.get(NODE_TO_REMOVE_NUM);\n            IInvokableInstance peer = cluster.get(PEER_NUM);\n"}
{"magic_number_smell": "                                         .withConfig(c -> c.with(Feature.values()))\n                                         .withInstanceInitializer(BB::install);\n        TokenSupplier even = TokenSupplier.evenlyDistributedTokens(3, builder.getTokenCount());\n        builder = builder.withTokenSupplier((TokenSupplier) node -> even.tokens(node == 4 ? 2 : node));\n        try (Cluster cluster = builder.start())\n        {\n            List<IInvokableInstance> alive = Arrays.asList(cluster.get(1), cluster.get(3));", "refactored_code": "    private static final int NODE_TO_REMOVE = 2;\n                                         .withConfig(c -> c.with(Feature.values()))\n                                         .withInstanceInitializer(BB::install);\n        TokenSupplier even = TokenSupplier.evenlyDistributedTokens(3, builder.getTokenCount());\n        builder = builder.withTokenSupplier((TokenSupplier) node -> even.tokens(node == 4 ? NODE_TO_REMOVE : node));\n        try (Cluster cluster = builder.start())\n        {\n            List<IInvokableInstance> alive = Arrays.asList(cluster.get(1), cluster.get(3));"}
{"magic_number_smell": "    public static long next(long input)\n    {\n        if (input == 0)\n            return next(0x2545F4914F6CDD1DL);\n\n        return xorshift64star(input);\n    }", "refactored_code": "    private static final long CONSTANT = 0x2545F4914F6CDD1DL;\n    public static long next(long input)\n    {\n        if (input == 0)\n            return next(CONSTANT);\n\n        return xorshift64star(input);\n    }"}
{"magic_number_smell": "            // write the first half of the rows with the second node dropping mutation requests,\n            // so some hints will be created for that node\n            dropWritesForNode2.set(true);\n            for (int i = 0; i < 100 / 2; i++)\n                coordinator.execute(withKeyspace(\"INSERT INTO %s.t (k, v) VALUES (?, ?)\"), QUORUM, i, i);\n            dropWritesForNode2.set(false);\n", "refactored_code": "    private static final int NUM_ROWS = 100;\n            // write the first half of the rows with the second node dropping mutation requests,\n            // so some hints will be created for that node\n            dropWritesForNode2.set(true);\n            for (int i = 0; i < NUM_ROWS / 2; i++)\n                coordinator.execute(withKeyspace(\"INSERT INTO %s.t (k, v) VALUES (?, ?)\"), QUORUM, i, i);\n            dropWritesForNode2.set(false);\n"}
{"magic_number_smell": "    @Before\n    public void before()\n    {\n        CLUSTER.get(1).runOnInstance(() -> MessagingService.instance().callbacks.unsafeClear());\n        CLUSTER.filters().reset();\n        BB.reset();\n    }", "refactored_code": "    public static final int COORDINATOR = 1;\n    @Before\n    public void before()\n    {\n        CLUSTER.get(COORDINATOR).runOnInstance(() -> MessagingService.instance().callbacks.unsafeClear());\n        CLUSTER.filters().reset();\n        BB.reset();\n    }"}
{"magic_number_smell": "    @Test\n    public void testConcurrentValidations() throws Throwable\n    {\n        try (Cluster cluster = init(builder().withNodes(4)\n                                             .withInstanceInitializer(ConcurrentValidationRequestsTest.BBHelper::install)\n                                             .withConfig(c -> c.set(\"concurrent_merkle_tree_requests\", MAX_REQUESTS)\n                                                               .with(NETWORK, GOSSIP))", "refactored_code": "    private static final int NODES = 4;\n    @Test\n    public void testConcurrentValidations() throws Throwable\n    {\n        try (Cluster cluster = init(builder().withNodes(NODES)\n                                             .withInstanceInitializer(ConcurrentValidationRequestsTest.BBHelper::install)\n                                             .withConfig(c -> c.set(\"concurrent_merkle_tree_requests\", MAX_REQUESTS)\n                                                               .with(NETWORK, GOSSIP))"}
{"magic_number_smell": "    @Before\n    public void init() throws IOException\n    {\n        cluster = init(Cluster.build(3).withTokenSupplier(generateTokenSupplier())\n                                           .withTokenCount(1)\n                                           .withConfig(config -> config.with(GOSSIP).with(NETWORK)).start());\n    }", "refactored_code": "    private static final int NODES = 3;\n    @Before\n    public void init() throws IOException\n    {\n        cluster = init(Cluster.build(NODES).withTokenSupplier(generateTokenSupplier())\n                                           .withTokenCount(1)\n                                           .withConfig(config -> config.with(GOSSIP).with(NETWORK)).start());\n    }"}
{"magic_number_smell": "    {\n        final Specification specification;\n\n        final List<Map<String, Integer>> previousRows = new ArrayList<>(20);\n        final List<Map<String, Integer>> currentRows = new ArrayList<>(20);\n\n        private int nextCellValue = 1;", "refactored_code": "    private static final int PARTITIONS_PER_TEST = 20;\n    {\n        final Specification specification;\n\n        final List<Map<String, Integer>> previousRows = new ArrayList<>(PARTITIONS_PER_TEST);\n        final List<Map<String, Integer>> currentRows = new ArrayList<>(PARTITIONS_PER_TEST);\n\n        private int nextCellValue = 1;"}
{"magic_number_smell": "        resultVectors = getVectors(result);\n        assertDescendingScore(queryVector, resultVectors);\n        double memtableRecallWithPaging = getRecall(vectors, queryVector, resultVectors);\n        assertThat(memtableRecallWithPaging).isGreaterThanOrEqualTo(0.7);\n\n        assertThatThrownBy(() -> searchWithPageWithoutLimit(randomVector()))\n        .hasMessageContaining(SelectStatement.TOPK_LIMIT_ERROR);", "refactored_code": "    private static final double MIN_RECALL = 0.7;\n        resultVectors = getVectors(result);\n        assertDescendingScore(queryVector, resultVectors);\n        double memtableRecallWithPaging = getRecall(vectors, queryVector, resultVectors);\n        assertThat(memtableRecallWithPaging).isGreaterThanOrEqualTo(MIN_RECALL);\n\n        assertThatThrownBy(() -> searchWithPageWithoutLimit(randomVector()))\n        .hasMessageContaining(SelectStatement.TOPK_LIMIT_ERROR);"}
{"magic_number_smell": "\n        public static void install(ClassLoader classLoader, Integer num)\n        {\n            if (num != 2)\n                return;\n            new ByteBuddy().rebase(SequentialWriter.class)\n                           .method(named(\"writeDirectlyToChannel\").and(takesArguments(1)))", "refactored_code": "    protected static final int FAILING_NODE = 2;\n\n        public static void install(ClassLoader classLoader, Integer num)\n        {\n            if (num != FAILING_NODE)\n                return;\n            new ByteBuddy().rebase(SequentialWriter.class)\n                           .method(named(\"writeDirectlyToChannel\").and(takesArguments(1)))"}
{"magic_number_smell": "    public void testSingleException()\n    {\n        Throwable exceptionToTest = exception(\"test exception\");\n        StringBuilder boundedStackTrace = StreamSession.boundStackTrace(exceptionToTest, 2, new StringBuilder());\n\n        String expectedStackTrace = \"java.lang.RuntimeException: test exception\\n\" +\n                                    \"\\torg.apache.cassandra.distributed.test.streaming.BoundExceptionTest.method(BoundExceptionTest.java:0)\\n\" +", "refactored_code": "    private static final int LIMIT = 2;\n    public void testSingleException()\n    {\n        Throwable exceptionToTest = exception(\"test exception\");\n        StringBuilder boundedStackTrace = StreamSession.boundStackTrace(exceptionToTest, LIMIT, new StringBuilder());\n\n        String expectedStackTrace = \"java.lang.RuntimeException: test exception\\n\" +\n                                    \"\\torg.apache.cassandra.distributed.test.streaming.BoundExceptionTest.method(BoundExceptionTest.java:0)\\n\" +"}
{"magic_number_smell": "                first.flush(KEYSPACE);\n            }\n            if (zeroCopyStreaming) // will include all components so need to account for\n                expectedFiles *= 7;\n\n            second.nodetoolResult(\"rebuild\", \"--keyspace\", KEYSPACE).asserts().success();\n", "refactored_code": "    private static final int NUM_COMPONENTS = 7;\n                first.flush(KEYSPACE);\n            }\n            if (zeroCopyStreaming) // will include all components so need to account for\n                expectedFiles *= NUM_COMPONENTS;\n\n            second.nodetoolResult(\"rebuild\", \"--keyspace\", KEYSPACE).asserts().success();\n"}
{"magic_number_smell": "    {\n        logger.info(\"[test step : @BeforeClass] setupClass\");\n        Cluster.Builder builder = Cluster.build(3);\n        builder.withConfig(c -> c.set(\"tombstone_warn_threshold\", 50)\n                                 .set(\"tombstone_failure_threshold\", TOMBSTONE_FAIL)\n                                 .with(Feature.NATIVE_PROTOCOL, Feature.GOSSIP));\n        builder.withInstanceInitializer(BB::install);", "refactored_code": "    private static final int TOMBSTONE_WARN = 50;\n    {\n        logger.info(\"[test step : @BeforeClass] setupClass\");\n        Cluster.Builder builder = Cluster.build(3);\n        builder.withConfig(c -> c.set(\"tombstone_warn_threshold\", TOMBSTONE_WARN)\n                                 .set(\"tombstone_failure_threshold\", TOMBSTONE_FAIL)\n                                 .with(Feature.NATIVE_PROTOCOL, Feature.GOSSIP));\n        builder.withInstanceInitializer(BB::install);"}
{"magic_number_smell": "\n            Callable<?> pending = pauseBeforeCommit(cluster.get(1), (e) -> e instanceof PrepareLeave.StartLeave);\n            CompletableFuture<Void> nodetool = CompletableFuture.runAsync(() -> toDecom.nodetoolResult(\"decommission\").asserts().success());\n            ClusterUtils.awaitGossipStateMatch(cluster, cluster.get(6), ApplicationState.SEVERITY);\n            pending.call();\n            unpauseCommits(cluster.get(1));\n", "refactored_code": "    public static final int DECOM_NODE = 6;\n\n            Callable<?> pending = pauseBeforeCommit(cluster.get(1), (e) -> e instanceof PrepareLeave.StartLeave);\n            CompletableFuture<Void> nodetool = CompletableFuture.runAsync(() -> toDecom.nodetoolResult(\"decommission\").asserts().success());\n            ClusterUtils.awaitGossipStateMatch(cluster, cluster.get(DECOM_NODE), ApplicationState.SEVERITY);\n            pending.call();\n            unpauseCommits(cluster.get(1));\n"}
{"magic_number_smell": "    public void testAvailability() throws Throwable\n    {\n        new TestCase()\n        .nodes(3)\n        .nodesToUpgrade(upgradedCoordinator() ? 1 : 2)\n        .upgradesToCurrentFrom(v30)\n        .withConfig(config -> config.with(GOSSIP, NETWORK, NATIVE_PROTOCOL)", "refactored_code": "    private static final int NUM_NODES = 3;\n    public void testAvailability() throws Throwable\n    {\n        new TestCase()\n        .nodes(NUM_NODES)\n        .nodesToUpgrade(upgradedCoordinator() ? 1 : 2)\n        .upgradesToCurrentFrom(v30)\n        .withConfig(config -> config.with(GOSSIP, NETWORK, NATIVE_PROTOCOL)"}
{"magic_number_smell": "        {\n            StringBuilder batchBuilder = new StringBuilder(\"BEGIN \" + (isLogged ? \"\" : \"UNLOGGED \") + \"BATCH\\n\");\n            String name = \"Julia\";\n            Runnable[] tests = new Runnable[10];\n\n            // ...and sample enough keys that we cover the ring.\n            for (int j = 0; j < 10; j++)", "refactored_code": "    private static final int KEYS_PER_BATCH = 10;\n        {\n            StringBuilder batchBuilder = new StringBuilder(\"BEGIN \" + (isLogged ? \"\" : \"UNLOGGED \") + \"BATCH\\n\");\n            String name = \"Julia\";\n            Runnable[] tests = new Runnable[KEYS_PER_BATCH];\n\n            // ...and sample enough keys that we cover the ring.\n            for (int j = 0; j < KEYS_PER_BATCH; j++)"}
{"magic_number_smell": "    {\n        new UpgradeTestBase.TestCase()\n        .nodes(2)\n        .nodesToUpgrade(1)\n        .upgradesToCurrentFrom(v40)\n        .withConfig(config -> config.with(NETWORK, GOSSIP).set(\"storage_compatibility_mode\", \"CASSANDRA_4\"))\n        .setup(cluster -> {", "refactored_code": "    public static final int UPGRADED_NODE = 1;\n    {\n        new UpgradeTestBase.TestCase()\n        .nodes(2)\n        .nodesToUpgrade(UPGRADED_NODE)\n        .upgradesToCurrentFrom(v40)\n        .withConfig(config -> config.with(NETWORK, GOSSIP).set(\"storage_compatibility_mode\", \"CASSANDRA_4\"))\n        .setup(cluster -> {"}
{"magic_number_smell": "                TokenPlacementModel.ReplicationFactor rf = new TokenPlacementModel.SimpleReplicationFactor(1);\n\n                DataTracker tracker = new DefaultDataTracker();\n                modelChecker.init(new ReplayingHistoryBuilder(1, maxPartitionSize, STEPS_PER_ITERATION, new DefaultDataTracker(), sut, schema, rf, SystemUnderTest.ConsistencyLevel.ALL))\n                            .step((history) -> {\n                                      int rowIdx = entropySource.nextInt(maxPartitionSize);\n                                      int partitionIdx = partitions[entropySource.nextInt(partitions.length)];", "refactored_code": "    private final long seed = 1;\n                TokenPlacementModel.ReplicationFactor rf = new TokenPlacementModel.SimpleReplicationFactor(1);\n\n                DataTracker tracker = new DefaultDataTracker();\n                modelChecker.init(new ReplayingHistoryBuilder(seed, maxPartitionSize, STEPS_PER_ITERATION, new DefaultDataTracker(), sut, schema, rf, SystemUnderTest.ConsistencyLevel.ALL))\n                            .step((history) -> {\n                                      int rowIdx = entropySource.nextInt(maxPartitionSize);\n                                      int partitionIdx = partitions[entropySource.nextInt(partitions.length)];"}
{"magic_number_smell": "                                                                ColumnSpec.floatType,\n                                                                ColumnSpec.doubleType})\n        {\n            for (int i = 0; i < 100; i++)\n            {\n                DataGenerators.SinglePartKeyGenerator gen = new DataGenerators.SinglePartKeyGenerator(Collections.singletonList(ColumnSpec.ck(\"ck0\", dt, false)));\n                long descriptor = rand.next();", "refactored_code": "    private static final int RUNS = 100;\n                                                                ColumnSpec.floatType,\n                                                                ColumnSpec.doubleType})\n        {\n            for (int i = 0; i < RUNS; i++)\n            {\n                DataGenerators.SinglePartKeyGenerator gen = new DataGenerators.SinglePartKeyGenerator(Collections.singletonList(ColumnSpec.ck(\"ck0\", dt, false)));\n                long descriptor = rand.next();"}
{"magic_number_smell": "    public static QuickTheory qt()\n    {\n        return QuickTheory.qt()\n                          .withExamples(10)\n                          .withShrinkCycles(0);\n    }\n}", "refactored_code": "    private static final int CYCLES = 10;\n    public static QuickTheory qt()\n    {\n        return QuickTheory.qt()\n                          .withExamples(CYCLES)\n                          .withShrinkCycles(0);\n    }\n}"}
{"magic_number_smell": "        return new Configuration.QuiescentCheckerConfig();\n    }\n\n    public Configuration.ConfigurationBuilder configuration(long 1L, SchemaSpec schema)\n    {\n        return super.configuration(1L, schema)\n                    .setPartitionDescriptorSelector(new Configuration.DefaultPDSelectorConfiguration(2, 2))", "refactored_code": "    private final long seed = 1L;\n        return new Configuration.QuiescentCheckerConfig();\n    }\n\n    public Configuration.ConfigurationBuilder configuration(long seed, SchemaSpec schema)\n    {\n        return super.configuration(seed, schema)\n                    .setPartitionDescriptorSelector(new Configuration.DefaultPDSelectorConfiguration(2, 2))"}
{"magic_number_smell": "        Run run = config.createRun();\n\n        new Runner.ChainRunner(run, config,\n                               Arrays.asList(writer(20_000, 2, TimeUnit.MINUTES),\n                                             (r,  c) -> new Runner.SingleVisitRunner(r, c, Collections.singletonList(this::validator)) {\n                                                 @Override\n                                                 public void runInternal()", "refactored_code": "    private final int ITERATIONS = 20_000;\n        Run run = config.createRun();\n\n        new Runner.ChainRunner(run, config,\n                               Arrays.asList(writer(ITERATIONS, 2, TimeUnit.MINUTES),\n                                             (r,  c) -> new Runner.SingleVisitRunner(r, c, Collections.singletonList(this::validator)) {\n                                                 @Override\n                                                 public void runInternal()"}
{"magic_number_smell": "\n            QueryResponseCorruptor corruptor = this.corruptorFactory.create(run);\n\n            for (int i = 0; i < 1000; i++)\n                visitor.visit();\n\n            while (true)", "refactored_code": "    private final int CYCLES = 1000;\n\n            QueryResponseCorruptor corruptor = this.corruptorFactory.create(run);\n\n            for (int i = 0; i < CYCLES; i++)\n                visitor.visit();\n\n            while (true)"}
{"magic_number_smell": "        return new SingleValidator(100, run, modelConfiguration()) {\n            public void visit()\n            {\n                visit(0L);\n            }\n        };\n    }", "refactored_code": "    private final long CORRUPT_LTS = 0L;\n        return new SingleValidator(100, run, modelConfiguration()) {\n            public void visit()\n            {\n                visit(CORRUPT_LTS);\n            }\n        };\n    }"}
{"magic_number_smell": "        sut.schemaChange(schema.compile().cql());\n\n        TokenPlacementModel.ReplicationFactor rf = new TokenPlacementModel.SimpleReplicationFactor(1);\n        ReplayingHistoryBuilder historyBuilder = new ReplayingHistoryBuilder(1, 100, 1, new DefaultDataTracker(), sut, schema, rf, SystemUnderTest.ConsistencyLevel.QUORUM);\n        historyBuilder.visitPartition(1).insert(1,\n                                                new long[]{ DataGenerators.UNSET_DESCR, DataGenerators.UNSET_DESCR },\n                                                new long[]{ 1L, 1L });", "refactored_code": "    private final long seed = 1; // 88\n        sut.schemaChange(schema.compile().cql());\n\n        TokenPlacementModel.ReplicationFactor rf = new TokenPlacementModel.SimpleReplicationFactor(1);\n        ReplayingHistoryBuilder historyBuilder = new ReplayingHistoryBuilder(seed, 100, 1, new DefaultDataTracker(), sut, schema, rf, SystemUnderTest.ConsistencyLevel.QUORUM);\n        historyBuilder.visitPartition(1).insert(1,\n                                                new long[]{ DataGenerators.UNSET_DESCR, DataGenerators.UNSET_DESCR },\n                                                new long[]{ 1L, 1L });"}
{"magic_number_smell": "                // The goal here is to make replicas as out of date as possible, modulo the efforts of repair\n                // and read-repair in the test itself.\n                if (cql.contains(\"SELECT\"))\n                    return super.execute(cql, ConsistencyLevel.ALL, 10, bindings);\n                return super.execute(cql, ConsistencyLevel.NODE_LOCAL, bindings);\n            }\n        };", "refactored_code": "    private static final int FETCH_SIZE = 10;\n                // The goal here is to make replicas as out of date as possible, modulo the efforts of repair\n                // and read-repair in the test itself.\n                if (cql.contains(\"SELECT\"))\n                    return super.execute(cql, ConsistencyLevel.ALL, FETCH_SIZE, bindings);\n                return super.execute(cql, ConsistencyLevel.NODE_LOCAL, bindings);\n            }\n        };"}
{"magic_number_smell": "                                                                      rf,\n                                                                      SystemUnderTest.ConsistencyLevel.QUORUM);\n\n        for (int run = 0; run < 1; run++)\n        {\n            logger.info(\"Starting run {}/{}...\", run + 1, 1);\n            EntropySource random = new JdkRandomEntropySource(run);", "refactored_code": "    private static final int RUNS = 1;\n                                                                      rf,\n                                                                      SystemUnderTest.ConsistencyLevel.QUORUM);\n\n        for (int run = 0; run < RUNS; run++)\n        {\n            logger.info(\"Starting run {}/{}...\", run + 1, RUNS);\n            EntropySource random = new JdkRandomEntropySource(run);"}
{"magic_number_smell": "        DataTracker tracker = new DefaultDataTracker();\n        TokenPlacementModel.ReplicationFactor rf = new TokenPlacementModel.SimpleReplicationFactor(cluster.size());\n        ReplayingHistoryBuilder history = new ReplayingHistoryBuilder(seed,\n                                                                      10_000,\n                                                                      100,\n                                                                      tracker,\n                                                                      new DoubleWritingSut(sut,", "refactored_code": "    private static final int MAX_PARTITION_SIZE = 10_000;\n        DataTracker tracker = new DefaultDataTracker();\n        TokenPlacementModel.ReplicationFactor rf = new TokenPlacementModel.SimpleReplicationFactor(cluster.size());\n        ReplayingHistoryBuilder history = new ReplayingHistoryBuilder(seed,\n                                                                      MAX_PARTITION_SIZE,\n                                                                      100,\n                                                                      tracker,\n                                                                      new DoubleWritingSut(sut,"}
{"magic_number_smell": "    public ApproximateClock(int historySize, long epoch, TimeUnit epochTimeUnit)\n    {\n        this(TimeUnit.MILLISECONDS.toMicros(System.currentTimeMillis()),\n             historySize, new CopyOnWriteArrayList<>(), 0, 0, epoch, epochTimeUnit);\n        rebase();\n    }\n", "refactored_code": "    public static final long START_VALUE = 0;\n    public ApproximateClock(int historySize, long epoch, TimeUnit epochTimeUnit)\n    {\n        this(TimeUnit.MILLISECONDS.toMicros(System.currentTimeMillis()),\n             historySize, new CopyOnWriteArrayList<>(), START_VALUE, 0, epoch, epochTimeUnit);\n        rebase();\n    }\n"}
{"magic_number_smell": "\n        public int byteSize()\n        {\n            return Float.BYTES - 1;\n        }\n    }\n", "refactored_code": "        private static final int SIZE = Float.BYTES - 1;\n\n        public int byteSize()\n        {\n            return SIZE;\n        }\n    }\n"}
{"magic_number_smell": "\n    public StringBijection(String[] nibbles, int nibbleSize, int maxRandomBytes)\n    {\n        assert nibbles.length == 256;\n        this.nibbles = nibbles;\n        this.inverse = new HashMap<>();\n        this.nibbleSize = nibbleSize;", "refactored_code": "    public static final int NIBBLES_SIZE = 256;\n\n    public StringBijection(String[] nibbles, int nibbleSize, int maxRandomBytes)\n    {\n        assert nibbles.length == NIBBLES_SIZE;\n        this.nibbles = nibbles;\n        this.inverse = new HashMap<>();\n        this.nibbleSize = nibbleSize;"}
{"magic_number_smell": "        long acc_plus = 0;\n\n        long cur_plus = streamIncrement(stream);\n        long cur_mult = 6364136223846793005L;\n\n        while (Long.compareUnsigned(steps, 0) > 0)\n        {", "refactored_code": "    private static final long NEXT_MULTIPLIER = 6364136223846793005L;\n        long acc_plus = 0;\n\n        long cur_plus = streamIncrement(stream);\n        long cur_mult = NEXT_MULTIPLIER;\n\n        while (Long.compareUnsigned(steps, 0) > 0)\n        {"}
{"magic_number_smell": "    public static long next(long input)\n    {\n        if (input == 0)\n            return next(0x2545F4914F6CDD1DL);\n\n        return xorshift64star(input);\n    }", "refactored_code": "    private static final long CONSTANT = 0x2545F4914F6CDD1DL;\n    public static long next(long input)\n    {\n        if (input == 0)\n            return next(CONSTANT);\n\n        return xorshift64star(input);\n    }"}
{"magic_number_smell": "\n    public PartitionState inflatePartitionState(final long pd, DataTracker tracker, Query query)\n    {\n        PartitionState partitionState = new PartitionState(pd, -1L, schema);\n\n        class Processor extends VisitExecutor\n        {", "refactored_code": "    private final long debugCd = -1L;\n\n    public PartitionState inflatePartitionState(final long pd, DataTracker tracker, Query query)\n    {\n        PartitionState partitionState = new PartitionState(pd, debugCd, schema);\n\n        class Processor extends VisitExecutor\n        {"}
{"magic_number_smell": "\n    public Query clusteringSliceQuery(long pd, long cd, long queryDescriptor, boolean reverse)\n    {\n        boolean isGt = RngUtils.asBoolean(rng.next(queryDescriptor, 0b1));\n        // TODO: make generation of EQ configurable; turn it off and on\n        boolean isEquals = RngUtils.asBoolean(rng.next(queryDescriptor, E_STREAM));\n", "refactored_code": "    private static final long GT_STREAM = 0b1;\n\n    public Query clusteringSliceQuery(long pd, long cd, long queryDescriptor, boolean reverse)\n    {\n        boolean isGt = RngUtils.asBoolean(rng.next(queryDescriptor, GT_STREAM));\n        // TODO: make generation of EQ configurable; turn it off and on\n        boolean isEquals = RngUtils.asBoolean(rng.next(queryDescriptor, E_STREAM));\n"}
{"magic_number_smell": "\n        Object[] pk = schema.inflatePartitionKey(pd);\n        List<TokenPlacementModel.Node> replicas = getRing().replicasFor(TokenUtil.token(ByteUtils.compose(ByteUtils.objectsToBytes(pk))));\n        while (retries++ < 10)\n        {\n            try\n            {", "refactored_code": "    private final int MAX_RETRIES = 10;\n\n        Object[] pk = schema.inflatePartitionKey(pd);\n        List<TokenPlacementModel.Node> replicas = getRing().replicasFor(TokenUtil.token(ByteUtils.compose(ByteUtils.objectsToBytes(pk))));\n        while (retries++ < MAX_RETRIES)\n        {\n            try\n            {"}
{"magic_number_smell": "                                     Generator<T2> gen2,\n                                     BiConsumer<T1, T2> validate)\n    {\n        for (int i = 0; i < 100; i++)\n        {\n            validate.accept(gen1.generate(rand),\n                            gen2.generate(rand));", "refactored_code": "    private static final int CYCLES = 100;\n                                     Generator<T2> gen2,\n                                     BiConsumer<T1, T2> validate)\n    {\n        for (int i = 0; i < CYCLES; i++)\n        {\n            validate.accept(gen1.generate(rand),\n                            gen2.generate(rand));"}
{"magic_number_smell": "\n            int retries = 0;\n\n            while (retries++ < 10)\n            {\n                try\n                {", "refactored_code": "        private final int maxRetries = 10;\n\n            int retries = 0;\n\n            while (retries++ < maxRetries)\n            {\n                try\n                {"}
{"magic_number_smell": "        final CountDownLatch failure = new CountDownLatch(1);\n\n\n        ExecutorService executor = Executors.newFixedThreadPool(40);\n        for (int i = 0; i < 40; i++)\n        {\n            executor.execute(new Runnable()", "refactored_code": "    private final int THREADPOOL_SIZE=40;\n        final CountDownLatch failure = new CountDownLatch(1);\n\n\n        ExecutorService executor = Executors.newFixedThreadPool(THREADPOOL_SIZE);\n        for (int i = 0; i < THREADPOOL_SIZE; i++)\n        {\n            executor.execute(new Runnable()"}
{"magic_number_smell": "    @Test\n    public void testExistingCluster()\n    {\n        super.testExistingCluster(new Murmur3Partitioner(), 64);\n    }\n\n    @Test", "refactored_code": "    private static final int MAX_VNODE_COUNT = 64;\n    @Test\n    public void testExistingCluster()\n    {\n        super.testExistingCluster(new Murmur3Partitioner(), MAX_VNODE_COUNT);\n    }\n\n    @Test"}
{"magic_number_smell": "    @Test\n    public void testExistingCluster()\n    {\n        testExistingCluster(new RandomPartitioner(), 16);\n    }\n\n    @Test", "refactored_code": "    private static final int MAX_VNODE_COUNT = 16;\n    @Test\n    public void testExistingCluster()\n    {\n        testExistingCluster(new RandomPartitioner(), MAX_VNODE_COUNT);\n    }\n\n    @Test"}
{"magic_number_smell": "\n    private void testWriteReadCycle(File directory, HintsDescriptor descriptor) throws IOException\n    {\n        // write 10_000_000 hints to a file\n        writeHints(directory, descriptor);\n\n        // calculate the checksum of the file, then compare to the .crc32 checksum file content", "refactored_code": "    private static final int HINTS_COUNT = 10_000_000;\n\n    private void testWriteReadCycle(File directory, HintsDescriptor descriptor) throws IOException\n    {\n        // write HINTS_COUNT hints to a file\n        writeHints(directory, descriptor);\n\n        // calculate the checksum of the file, then compare to the .crc32 checksum file content"}
{"magic_number_smell": "            while (!stopped)\n            {\n                Replica host = hosts.get(random.nextInt(hosts.size()));\n                int score = random.nextInt(100);\n                dsnitch.receiveTiming(host.endpoint(), score, MILLISECONDS);\n            }\n        }", "refactored_code": "        private static final int SCORE_RANGE = 100;\n            while (!stopped)\n            {\n                Replica host = hosts.get(random.nextInt(hosts.size()));\n                int score = random.nextInt(SCORE_RANGE);\n                dsnitch.receiveTiming(host.endpoint(), score, MILLISECONDS);\n            }\n        }"}
{"magic_number_smell": "\n        public void sampleAllocation(int count, String desc, Object newObj, long bytes)\n        {\n            if (Thread.currentThread().getId() != Thread.currentThread().getId())\n                return;\n\n            objectsAllocated++;", "refactored_code": "        private final long threadID = Thread.currentThread().getId();\n\n        public void sampleAllocation(int count, String desc, Object newObj, long bytes)\n        {\n            if (Thread.currentThread().getId() != threadID)\n                return;\n\n            objectsAllocated++;"}
{"magic_number_smell": "    @Setup(Level.Trial)\n    public void setup() throws Throwable\n    {\n        data = seq(32, cellSize);\n        nonExistData = new ArrayList<>();\n        btree = BTree.build(data, UpdateFunction.noOp());\n        for (String d : data)", "refactored_code": "    private final int btreeSize = 32;\n    @Setup(Level.Trial)\n    public void setup() throws Throwable\n    {\n        data = seq(btreeSize, cellSize);\n        nonExistData = new ArrayList<>();\n        btree = BTree.build(data, UpdateFunction.noOp());\n        for (String d : data)"}
{"magic_number_smell": "        for (ColumnFamilyStore cfs: columnFamilyStores)\n        {\n            cfs.truncateBlocking();\n            for (int i = 0; i < 100 ; i++)\n            {\n                ColumnMetadata colDef = ColumnMetadata.regularColumn(cfs.metadata(), ByteBufferUtil.bytes(\"val\"), AsciiType.instance);\n                for (int k = 0; k < numKeysPerTable; k++)", "refactored_code": "    private static final int numSSTables = 100;\n        for (ColumnFamilyStore cfs: columnFamilyStores)\n        {\n            cfs.truncateBlocking();\n            for (int i = 0; i < numSSTables ; i++)\n            {\n                ColumnMetadata colDef = ColumnMetadata.regularColumn(cfs.metadata(), ByteBufferUtil.bytes(\"val\"), AsciiType.instance);\n                for (int k = 0; k < numKeysPerTable; k++)"}
{"magic_number_smell": "                do\n                {\n                    key = rand.nextInt(KEY_RANGE);\n                    long cid = rand.nextInt(1000);\n                    int cstart = (int) (cid * CLUSTERING_RANGE / 1000);\n                    int cend = (int) ((cid + 1) * CLUSTERING_RANGE / 1000);\n                    res = execute(\"SELECT column FROM %s WHERE key = ? AND column >= ? AND column < ? LIMIT 1\", key, cstart, cend);", "refactored_code": "    private static final int DEL_SECTIONS = 1000;\n                do\n                {\n                    key = rand.nextInt(KEY_RANGE);\n                    long cid = rand.nextInt(DEL_SECTIONS);\n                    int cstart = (int) (cid * CLUSTERING_RANGE / DEL_SECTIONS);\n                    int cend = (int) ((cid + 1) * CLUSTERING_RANGE / DEL_SECTIONS);\n                    res = execute(\"SELECT column FROM %s WHERE key = ? AND column >= ? AND column < ? LIMIT 1\", key, cstart, cend);"}
{"magic_number_smell": "        ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(table);\n        cfs.disableAutoCompaction();\n\n        System.out.println(\"Writing \" + (10 * NUM_CLUSTERINGS) + \" rows...\");\n        int n = 0;\n        for (int k = 0; k < 10; k++)\n        {", "refactored_code": "    private static final int NUM_PARTITIONS = 10;\n        ColumnFamilyStore cfs = Keyspace.open(KEYSPACE).getColumnFamilyStore(table);\n        cfs.disableAutoCompaction();\n\n        System.out.println(\"Writing \" + (NUM_PARTITIONS * NUM_CLUSTERINGS) + \" rows...\");\n        int n = 0;\n        for (int k = 0; k < NUM_PARTITIONS; k++)\n        {"}
{"magic_number_smell": "                do\n                {\n                    key = rand.nextInt(KEY_RANGE);\n                    long cid = rand.nextInt(1000);\n                    int cstart = (int) (cid * CLUSTERING_RANGE / 1000);\n                    int cend = (int) ((cid + 1) * CLUSTERING_RANGE / 1000);\n                    res = execute(\"SELECT column FROM %s WHERE key = ? AND column >= ? AND column < ? LIMIT 1\", key, cstart, cend);", "refactored_code": "    private static final int DEL_SECTIONS = 1000;\n                do\n                {\n                    key = rand.nextInt(KEY_RANGE);\n                    long cid = rand.nextInt(DEL_SECTIONS);\n                    int cstart = (int) (cid * CLUSTERING_RANGE / DEL_SECTIONS);\n                    int cend = (int) ((cid + 1) * CLUSTERING_RANGE / DEL_SECTIONS);\n                    res = execute(\"SELECT column FROM %s WHERE key = ? AND column >= ? AND column < ? LIMIT 1\", key, cstart, cend);"}
{"magic_number_smell": "        boolean success = true;\n        try\n        {\n            int chunkLen = len / 64;\n\n            for (int i = 0; i < 64; i++)\n            {", "refactored_code": "    private static final int subBufferCount = 64;\n        boolean success = true;\n        try\n        {\n            int chunkLen = len / subBufferCount;\n\n            for (int i = 0; i < subBufferCount; i++)\n            {"}
{"magic_number_smell": "\n        PrimaryKey.Factory factory = new PrimaryKey.Factory(metadata.partitioner, metadata.comparator);\n\n        PrimaryKey[] primaryKeys = new PrimaryKey[1_000_000];\n        int partition = 0;\n        int partitionRowCounter = 0;\n        for (int index = 0; index < 1_000_000; index++)", "refactored_code": "    private static final int rows = 1_000_000;\n\n        PrimaryKey.Factory factory = new PrimaryKey.Factory(metadata.partitioner, metadata.comparator);\n\n        PrimaryKey[] primaryKeys = new PrimaryKey[rows];\n        int partition = 0;\n        int partitionRowCounter = 0;\n        for (int index = 0; index < rows; index++)"}
{"magic_number_smell": "\n    public InterceptClasses(ChanceSupplier monitorDelayChance, ChanceSupplier nemesisChance, NemesisFieldKind.Selector nemesisFieldSelector, ClassLoader prewarmClassLoader, Predicate<String> prewarm)\n    {\n        this(Opcodes.ASM7, monitorDelayChance, nemesisChance, nemesisFieldSelector, prewarmClassLoader, prewarm);\n    }\n\n    public InterceptClasses(int api, ChanceSupplier monitorDelayChance, ChanceSupplier nemesisChance, NemesisFieldKind.Selector nemesisFieldSelector, ClassLoader prewarmClassLoader, Predicate<String> prewarm)", "refactored_code": "    public static final int BYTECODE_VERSION = Opcodes.ASM7;\n\n    public InterceptClasses(ChanceSupplier monitorDelayChance, ChanceSupplier nemesisChance, NemesisFieldKind.Selector nemesisFieldSelector, ClassLoader prewarmClassLoader, Predicate<String> prewarm)\n    {\n        this(BYTECODE_VERSION, monitorDelayChance, nemesisChance, nemesisFieldSelector, prewarmClassLoader, prewarm);\n    }\n\n    public InterceptClasses(int api, ChanceSupplier monitorDelayChance, ChanceSupplier nemesisChance, NemesisFieldKind.Selector nemesisFieldSelector, ClassLoader prewarmClassLoader, Predicate<String> prewarm)"}
{"magic_number_smell": "        public synchronized long randomSeed()\n        {\n            long next = nextSeed;\n            nextSeed *= 2862933555777941757L;\n            nextSeed += SEED_CONSTANT;\n            return next;\n        }", "refactored_code": "        private static final long SEED_MULTIPLIER = 2862933555777941757L;\n        public synchronized long randomSeed()\n        {\n            long next = nextSeed;\n            nextSeed *= SEED_MULTIPLIER;\n            nextSeed += SEED_CONSTANT;\n            return next;\n        }"}
{"magic_number_smell": "\n        int subsequentFailures = pairs.compute(pair, (k, v) -> v == null ? 1 : v+1);\n\n        if (subsequentFailures > 1)\n        {\n            logger.info(\"Delivering {} after {} failures in a row\", pair, 1);\n            pairs.put(pair, 0);", "refactored_code": "    private static final int TIMEOUTS_IN_A_ROW = 1;\n\n        int subsequentFailures = pairs.compute(pair, (k, v) -> v == null ? 1 : v+1);\n\n        if (subsequentFailures > TIMEOUTS_IN_A_ROW)\n        {\n            logger.info(\"Delivering {} after {} failures in a row\", pair, TIMEOUTS_IN_A_ROW);\n            pairs.put(pair, 0);"}
{"magic_number_smell": "            public int getAsInt()\n            {\n                int id = nextId;\n                nextId = (id * 22695477) + constant;\n                id ^= id >> 16;\n                return id;\n            }", "refactored_code": "            private static final int LCG_MULTIPLIER = 22695477;\n            public int getAsInt()\n            {\n                int id = nextId;\n                nextId = (id * LCG_MULTIPLIER) + constant;\n                id ^= id >> 16;\n                return id;\n            }"}
{"magic_number_smell": "                for (int j = 0 ; j < nodes ; ++j)\n                {\n                    long[] state = this.state[i][j];\n                    state[0, TARGET = 1, STEP = 2] = range.select(random);\n                    next(random, state);\n                }\n            }", "refactored_code": "        private static final int CUR = 0, TARGET = 1, STEP = 2;\n                for (int j = 0 ; j < nodes ; ++j)\n                {\n                    long[] state = this.state[i][j];\n                    state[CUR] = range.select(random);\n                    next(random, state);\n                }\n            }"}
{"magic_number_smell": "        sb.append(\", Skipped: \");\n        sb.append(suite.skipCount());\n        sb.append(\", Time elapsed: \");\n        sb.append(numberFormat.format(suite.getRunTime() / 1000.0));\n        sb.append(\" sec\");\n        sb.append(StringUtils.LINE_SEP);\n        sb.append(StringUtils.LINE_SEP);", "refactored_code": "    private static final double ONE_SECOND = 1000.0;\n        sb.append(\", Skipped: \");\n        sb.append(suite.skipCount());\n        sb.append(\", Time elapsed: \");\n        sb.append(numberFormat.format(suite.getRunTime() / ONE_SECOND));\n        sb.append(\" sec\");\n        sb.append(StringUtils.LINE_SEP);\n        sb.append(StringUtils.LINE_SEP);"}
{"magic_number_smell": "        rootElement.setAttribute(ATTR_ERRORS, \"\" + suite.errorCount());\n        rootElement.setAttribute(ATTR_SKIPPED, \"\" + suite.skipCount());\n        rootElement.setAttribute(\n            ATTR_TIME, \"\" + (suite.getRunTime() / 1000.0));\n        if (out != null) {\n            Writer wri = null;\n            try {", "refactored_code": "    private static final double ONE_SECOND = 1000.0;\n        rootElement.setAttribute(ATTR_ERRORS, \"\" + suite.errorCount());\n        rootElement.setAttribute(ATTR_SKIPPED, \"\" + suite.skipCount());\n        rootElement.setAttribute(\n            ATTR_TIME, \"\" + (suite.getRunTime() / ONE_SECOND));\n        if (out != null) {\n            Writer wri = null;\n            try {"}
{"magic_number_smell": "        }\n        else\n        {\n            iterations = 10;\n        }\n\n        runner = buildRunner(runnerClass, testClass);", "refactored_code": "    private static final int DEFAULT_REPETITIONS = 10;\n        }\n        else\n        {\n            iterations = DEFAULT_REPETITIONS;\n        }\n\n        runner = buildRunner(runnerClass, testClass);"}
{"magic_number_smell": "    {\n        Supplier<Map<String, Integer>> bulkLoader = () -> {\n            Map<String, Integer> entries = new HashMap<>();\n            for (int i = 0; i < 10 * 2; i++)\n                entries.put(Integer.toString(i), i);\n            return entries;\n        };", "refactored_code": "    private final int MAX_ENTRIES = 10;\n    {\n        Supplier<Map<String, Integer>> bulkLoader = () -> {\n            Map<String, Integer> entries = new HashMap<>();\n            for (int i = 0; i < MAX_ENTRIES * 2; i++)\n                entries.put(Integer.toString(i), i);\n            return entries;\n        };"}
{"magic_number_smell": "        cache.put(key4, partition);\n        cache.put(key5, partition);\n\n        assertEquals(4, cache.size());\n    }\n\n    private void assertDigests(IRowCacheEntry one, CachedBTreePartition two)", "refactored_code": "    private static final long CAPACITY = 4;\n        cache.put(key4, partition);\n        cache.put(key5, partition);\n\n        assertEquals(CAPACITY, cache.size());\n    }\n\n    private void assertDigests(IRowCacheEntry one, CachedBTreePartition two)"}
{"magic_number_smell": "        assertEquals(new DataStorageSpec.LongBytesBound(\"10GiB\"), new DataStorageSpec.LongBytesBound(\"10240MiB\"));\n        assertEquals(new DataStorageSpec.LongBytesBound(\"10240MiB\"), new DataStorageSpec.LongBytesBound(\"10GiB\"));\n\n        assertEquals(new DataStorageSpec.LongBytesBound(Long.MAX_VALUE - 1, BYTES), new DataStorageSpec.LongBytesBound(Long.MAX_VALUE - 1, BYTES));\n\n        assertNotEquals(new DataStorageSpec.LongBytesBound(\"0MiB\"), new DataStorageSpec.LongBytesBound(\"10KiB\"));\n    }", "refactored_code": "    private static final long MAX_LONG_CONFIG_VALUE = Long.MAX_VALUE - 1;\n        assertEquals(new DataStorageSpec.LongBytesBound(\"10GiB\"), new DataStorageSpec.LongBytesBound(\"10240MiB\"));\n        assertEquals(new DataStorageSpec.LongBytesBound(\"10240MiB\"), new DataStorageSpec.LongBytesBound(\"10GiB\"));\n\n        assertEquals(new DataStorageSpec.LongBytesBound(MAX_LONG_CONFIG_VALUE, BYTES), new DataStorageSpec.LongBytesBound(MAX_LONG_CONFIG_VALUE, BYTES));\n\n        assertNotEquals(new DataStorageSpec.LongBytesBound(\"0MiB\"), new DataStorageSpec.LongBytesBound(\"10KiB\"));\n    }"}
{"magic_number_smell": "    public void testConversions()\n    {\n        assertEquals(10000000000L, new DurationSpec.LongNanosecondsBound (\"10s\").toNanoseconds());\n        assertEquals(Integer.MAX_VALUE - 1, new DurationSpec.IntSecondsBound(Integer.MAX_VALUE - 1 + \"s\").toSeconds());\n        assertEquals(Integer.MAX_VALUE - 1, new DurationSpec.LongMillisecondsBound(Integer.MAX_VALUE - 1 + \"ms\").toMilliseconds());\n        assertEquals(600000000000L, new DurationSpec.LongNanosecondsBound (\"10m\").toNanoseconds());\n        assertEquals(Integer.MAX_VALUE - 1, new DurationSpec.IntMinutesBound(Integer.MAX_VALUE - 1 + \"m\").toMinutes());", "refactored_code": "    private static final long MAX_INT_CONFIG_VALUE = Integer.MAX_VALUE - 1;\n    public void testConversions()\n    {\n        assertEquals(10000000000L, new DurationSpec.LongNanosecondsBound (\"10s\").toNanoseconds());\n        assertEquals(MAX_INT_CONFIG_VALUE, new DurationSpec.IntSecondsBound(MAX_INT_CONFIG_VALUE + \"s\").toSeconds());\n        assertEquals(MAX_INT_CONFIG_VALUE, new DurationSpec.LongMillisecondsBound(MAX_INT_CONFIG_VALUE + \"ms\").toMilliseconds());\n        assertEquals(600000000000L, new DurationSpec.LongNanosecondsBound (\"10m\").toNanoseconds());\n        assertEquals(MAX_INT_CONFIG_VALUE, new DurationSpec.IntMinutesBound(MAX_INT_CONFIG_VALUE + \"m\").toMinutes());"}
{"magic_number_smell": "    {\n        CassandraRelevantProperties.SUPERUSER_SETUP_DELAY_MS.setLong(0);\n        ServerTestUtils.daemonInitialization();\n        if (new DataStorageSpec.LongMebibytesBound(TEST_ROW_CACHE_SIZE.getString(\"0MiB\")).toMebibytes() > 0)\n            DatabaseDescriptor.setRowCacheSizeInMiB(new DataStorageSpec.LongMebibytesBound(TEST_ROW_CACHE_SIZE.getString(\"0MiB\")).toMebibytes());\n        StorageService.instance.registerMBeans();\n        StorageService.instance.setPartitionerUnsafe(Murmur3Partitioner.instance);", "refactored_code": "    protected static final long ROW_CACHE_SIZE_IN_MIB = new DataStorageSpec.LongMebibytesBound(TEST_ROW_CACHE_SIZE.getString(\"0MiB\")).toMebibytes();\n    {\n        CassandraRelevantProperties.SUPERUSER_SETUP_DELAY_MS.setLong(0);\n        ServerTestUtils.daemonInitialization();\n        if (ROW_CACHE_SIZE_IN_MIB > 0)\n            DatabaseDescriptor.setRowCacheSizeInMiB(ROW_CACHE_SIZE_IN_MIB);\n        StorageService.instance.registerMBeans();\n        StorageService.instance.setPartitionerUnsafe(Murmur3Partitioner.instance);"}
{"magic_number_smell": "            for (int i = 0; i < examples; i++)\n            {\n                if (i > 0)\n                    seed = (seed * 0x5DEECE66DL + addend) & mask;\n                random.setSeed(seed);\n                try\n                {", "refactored_code": "        private static final long multiplier = 0x5DEECE66DL;\n            for (int i = 0; i < examples; i++)\n            {\n                if (i > 0)\n                    seed = (seed * multiplier + addend) & mask;\n                random.setSeed(seed);\n                try\n                {"}
{"magic_number_smell": "    @Test\n    public void testPrecisionTime_getNext_simple()\n    {\n        PrecisionTime.set(424242424242L, DEFAULT_NANOS);\n\n        long millis = 424242424242L - 100;\n        int count = 1;", "refactored_code": "    private static final long DEFAULT_MILLIS = 424242424242L;\n    @Test\n    public void testPrecisionTime_getNext_simple()\n    {\n        PrecisionTime.set(DEFAULT_MILLIS, DEFAULT_NANOS);\n\n        long millis = DEFAULT_MILLIS - 100;\n        int count = 1;"}
{"magic_number_smell": "    {\n        createTable(\"CREATE TABLE %s(a int, b int, c blob, PRIMARY KEY (a))\");\n        createIndex(\"CREATE INDEX ON %s(c)\");\n        failInsert(\"INSERT INTO %s (a, b, c) VALUES (0, 0, ?)\", ByteBuffer.allocate(1024 * 65));\n        failInsert(\"INSERT INTO %s (a, b, c) VALUES (0, 0, ?) IF NOT EXISTS\", ByteBuffer.allocate(1024 * 65));\n        failInsert(\"BEGIN BATCH\\n\" +\n                   \"INSERT INTO %s (a, b, c) VALUES (0, 0, ?);\\n\" +", "refactored_code": "    public static final int TOO_BIG = 1024 * 65;\n    {\n        createTable(\"CREATE TABLE %s(a int, b int, c blob, PRIMARY KEY (a))\");\n        createIndex(\"CREATE INDEX ON %s(c)\");\n        failInsert(\"INSERT INTO %s (a, b, c) VALUES (0, 0, ?)\", ByteBuffer.allocate(TOO_BIG));\n        failInsert(\"INSERT INTO %s (a, b, c) VALUES (0, 0, ?) IF NOT EXISTS\", ByteBuffer.allocate(TOO_BIG));\n        failInsert(\"BEGIN BATCH\\n\" +\n                   \"INSERT INTO %s (a, b, c) VALUES (0, 0, ?);\\n\" +"}
{"magic_number_smell": "        assertEmpty(execute(\"SELECT TTL(v) FROM %s\"));\n\n        // Insert row without TTL\n        execute(\"INSERT INTO %s (pk, ck, v) VALUES (1, 2, 3) USING TIMESTAMP ?\", 1);\n        assertWritetimeAndTTL(\"v\", 1, NO_TTL);\n\n        // Update the row with TTL and a new timestamp", "refactored_code": "    private static final long TIMESTAMP_1 = 1;\n        assertEmpty(execute(\"SELECT TTL(v) FROM %s\"));\n\n        // Insert row without TTL\n        execute(\"INSERT INTO %s (pk, ck, v) VALUES (1, 2, 3) USING TIMESTAMP ?\", TIMESTAMP_1);\n        assertWritetimeAndTTL(\"v\", TIMESTAMP_1, NO_TTL);\n\n        // Update the row with TTL and a new timestamp"}
{"magic_number_smell": "        StatsMetadata metadata = cfs.getLiveSSTables().iterator().next().getSSTableMetadata();\n        assertEquals(9999, metadata.minTimestamp);\n        assertEquals(10000, metadata.maxTimestamp);\n        assertEquals(Long.MAX_VALUE, metadata.maxLocalDeletionTime, 5);\n        cfs.forceMajorCompaction();\n        metadata = cfs.getLiveSSTables().iterator().next().getSSTableMetadata();\n        assertEquals(9999, metadata.minTimestamp);", "refactored_code": "    public static final double DELTA = 5;\n        StatsMetadata metadata = cfs.getLiveSSTables().iterator().next().getSSTableMetadata();\n        assertEquals(9999, metadata.minTimestamp);\n        assertEquals(10000, metadata.maxTimestamp);\n        assertEquals(Long.MAX_VALUE, metadata.maxLocalDeletionTime, DELTA);\n        cfs.forceMajorCompaction();\n        metadata = cfs.getLiveSSTables().iterator().next().getSSTableMetadata();\n        assertEquals(9999, metadata.minTimestamp);"}
{"magic_number_smell": "        new TokenUpdater().withTokens(InetAddressAndPort.getByName(\"127.0.0.1\"), token(new byte[]{ 50 })).update();\n\n        // insert data and verify we get it back w/ range query\n        fillCF(cfs, \"val\", 200);\n\n        // record max timestamps of the sstables pre-cleanup\n        List<Long> expectedMaxTimestamps = getMaxTimestampList(cfs);", "refactored_code": "    public static final int LOOPS = 200;\n        new TokenUpdater().withTokens(InetAddressAndPort.getByName(\"127.0.0.1\"), token(new byte[]{ 50 })).update();\n\n        // insert data and verify we get it back w/ range query\n        fillCF(cfs, \"val\", LOOPS);\n\n        // record max timestamps of the sstables pre-cleanup\n        List<Long> expectedMaxTimestamps = getMaxTimestampList(cfs);"}
{"magic_number_smell": "\n\n        // insert data and verify we get it back w/ range query\n        fillCF(cfs, \"val\", 200);\n\n        // record max timestamps of the sstables pre-cleanup\n        List<Long> expectedMaxTimestamps = getMaxTimestampList(cfs);", "refactored_code": "    public static final int LOOPS = 200;\n\n\n        // insert data and verify we get it back w/ range query\n        fillCF(cfs, \"val\", LOOPS);\n\n        // record max timestamps of the sstables pre-cleanup\n        List<Long> expectedMaxTimestamps = getMaxTimestampList(cfs);"}
{"magic_number_smell": "    @Test\n    public void withTrackingAppliesRepairedDataCounter()\n    {\n        DataLimits.Counter counter = DataLimits.cqlLimits(15).newCounter(FBUtilities.nowInSeconds(), false, false, false).onlyCount();\n        RepairedDataInfo info = new RepairedDataInfo(counter);\n        info.prepare(cfs, FBUtilities.nowInSeconds(), Integer.MAX_VALUE);\n        UnfilteredRowIterator[] partitions = new UnfilteredRowIterator[3];", "refactored_code": "    private final long nowInSec = FBUtilities.nowInSeconds();\n    @Test\n    public void withTrackingAppliesRepairedDataCounter()\n    {\n        DataLimits.Counter counter = DataLimits.cqlLimits(15).newCounter(nowInSec, false, false, false).onlyCount();\n        RepairedDataInfo info = new RepairedDataInfo(counter);\n        info.prepare(cfs, nowInSec, Integer.MAX_VALUE);\n        UnfilteredRowIterator[] partitions = new UnfilteredRowIterator[3];"}
{"magic_number_smell": "        long startNano = nanoTime();\n        CommitLog.instance.add(m);\n        long delta = TimeUnit.NANOSECONDS.toMillis(nanoTime() - startNano);\n        Assert.assertTrue(\"Expect batch commitlog sync immediately, but took \" + delta, delta < 1000);\n    }\n\n    @Test", "refactored_code": "    private static final long CL_BATCH_SYNC_WINDOW = 1000; // 1 second\n        long startNano = nanoTime();\n        CommitLog.instance.add(m);\n        long delta = TimeUnit.NANOSECONDS.toMillis(nanoTime() - startNano);\n        Assert.assertTrue(\"Expect batch commitlog sync immediately, but took \" + delta, delta < CL_BATCH_SYNC_WINDOW);\n    }\n\n    @Test"}
{"magic_number_smell": "        System.out.println(\"GC compaction resulted in \" + size(result) + \" Unfiltereds\");\n        generator.verifyValid(result);\n        verifyEquivalent(inputLists, result, tombstoneLists, generator);\n        List<Unfiltered> expectedResult = generator.parse(expected, 1000 - 1);\n        if (!expectedResult.equals(result))\n            fail(\"Expected \" + expected + \", got \" + generator.str(result));\n    }", "refactored_code": "    private static final int NOW = 1000;\n        System.out.println(\"GC compaction resulted in \" + size(result) + \" Unfiltereds\");\n        generator.verifyValid(result);\n        verifyEquivalent(inputLists, result, tombstoneLists, generator);\n        List<Unfiltered> expectedResult = generator.parse(expected, NOW - 1);\n        if (!expectedResult.equals(result))\n            fail(\"Expected \" + expected + \", got \" + generator.str(result));\n    }"}
{"magic_number_smell": "        flush();\n        execute(\"insert into %s (id) values ('1')\");\n        flush();\n        waitForMinor(KEYSPACE, currentTable(), 5000, true);\n    }\n\n    @Test", "refactored_code": "    public static final int SLEEP_TIME = 5000;\n        flush();\n        execute(\"insert into %s (id) values ('1')\");\n        flush();\n        waitForMinor(KEYSPACE, currentTable(), SLEEP_TIME, true);\n    }\n\n    @Test"}
{"magic_number_smell": "\n        // Create a expiring sstable with a TTL\n        DecoratedKey key = Util.dk(\"expired\");\n        new RowUpdateBuilder(cfs.metadata(), System.currentTimeMillis(), 10, key.getKey())\n            .clustering(\"column\")\n            .add(\"val\", value).build().applyUnsafe();\n", "refactored_code": "    private static final int TTL_SECONDS = 10;\n\n        // Create a expiring sstable with a TTL\n        DecoratedKey key = Util.dk(\"expired\");\n        new RowUpdateBuilder(cfs.metadata(), System.currentTimeMillis(), TTL_SECONDS, key.getKey())\n            .clustering(\"column\")\n            .add(\"val\", value).build().applyUnsafe();\n"}
{"magic_number_smell": "        ColumnFamilyStore cfs = getColumnFamilyStore();\n        for (int i = 0; i < count; i++)\n        {\n            for (int j = 0; j < 10; j++)\n                execute(String.format(\"INSERT INTO %s.%s(k, t, v) VALUES (?, ?, ?)\", KEYSPACE, TABLE), i, j, b);\n\n            if (i % (count / 4) == 0)", "refactored_code": "    private static final int ROW_PER_PARTITION = 10;\n        ColumnFamilyStore cfs = getColumnFamilyStore();\n        for (int i = 0; i < count; i++)\n        {\n            for (int j = 0; j < ROW_PER_PARTITION; j++)\n                execute(String.format(\"INSERT INTO %s.%s(k, t, v) VALUES (?, ?, ?)\", KEYSPACE, TABLE), i, j, b);\n\n            if (i % (count / 4) == 0)"}
{"magic_number_smell": "    {\n        byte [] payload = new byte[5000];\n        ByteBuffer b = ByteBuffer.wrap(payload);\n        int rowCount = (int) Math.ceil((double) totSizeBytes / (8 + 10 * payload.length));\n\n        for (int i = 0; i < rowCount; i++)\n        {", "refactored_code": "    private static final int ROW_PER_PARTITION = 10;\n    {\n        byte [] payload = new byte[5000];\n        ByteBuffer b = ByteBuffer.wrap(payload);\n        int rowCount = (int) Math.ceil((double) totSizeBytes / (8 + ROW_PER_PARTITION * payload.length));\n\n        for (int i = 0; i < rowCount; i++)\n        {"}
{"magic_number_smell": "        ByteBuffer b = ByteBuffer.wrap(payload);\n\n        for (int i = 0; i < count; i++)\n            for (int j = 0; j < 10; j++)\n                execute(String.format(\"INSERT INTO %s.%s(k, t, v) VALUES (?, ?, ?)\", KEYSPACE, TABLE), i, j, b);\n\n        ColumnFamilyStore cfs = getColumnFamilyStore();", "refactored_code": "    private static final int ROW_PER_PARTITION = 10;\n        ByteBuffer b = ByteBuffer.wrap(payload);\n\n        for (int i = 0; i < count; i++)\n            for (int j = 0; j < ROW_PER_PARTITION; j++)\n                execute(String.format(\"INSERT INTO %s.%s(k, t, v) VALUES (?, ?, ?)\", KEYSPACE, TABLE), i, j, b);\n\n        ColumnFamilyStore cfs = getColumnFamilyStore();"}
{"magic_number_smell": "    public void testAllocate()\n    {\n        ContextState allGlobal = ContextState.allocate(3, 0, 0);\n        assertEquals(2 + 3 * headerEltLength + 3 * stepLength, allGlobal.context.remaining());\n\n        ContextState allLocal = ContextState.allocate(0, 3, 0);\n        assertEquals(2 + 3 * headerEltLength + 3 * stepLength, allLocal.context.remaining());", "refactored_code": "    private static final int headerSizeLength = 2;\n    public void testAllocate()\n    {\n        ContextState allGlobal = ContextState.allocate(3, 0, 0);\n        assertEquals(headerSizeLength + 3 * headerEltLength + 3 * stepLength, allGlobal.context.remaining());\n\n        ContextState allLocal = ContextState.allocate(0, 3, 0);\n        assertEquals(headerSizeLength + 3 * headerEltLength + 3 * stepLength, allLocal.context.remaining());"}
{"magic_number_smell": "public class GuardrailCollectionSizeTest extends ThresholdTester\n{\n    private static final int 1024 = 1024; // bytes\n    private static final int FAIL_THRESHOLD = 1024 * 4; // bytes\n\n    public GuardrailCollectionSizeTest()\n    {", "refactored_code": "    private static final int WARN_THRESHOLD = 1024; // bytes\npublic class GuardrailCollectionSizeTest extends ThresholdTester\n{\n    private static final int WARN_THRESHOLD = 1024; // bytes\n    private static final int FAIL_THRESHOLD = WARN_THRESHOLD * 4; // bytes\n\n    public GuardrailCollectionSizeTest()\n    {"}
{"magic_number_smell": "\n    public GuardrailColumnsPerTableTest()\n    {\n        super(2,\n              COLUMNS_PER_TABLE_FAIL_THRESHOLD,\n              Guardrails.columnsPerTable,\n              Guardrails::setColumnsPerTableThreshold,", "refactored_code": "    private static final int COLUMNS_PER_TABLE_WARN_THRESHOLD = 2;\n\n    public GuardrailColumnsPerTableTest()\n    {\n        super(COLUMNS_PER_TABLE_WARN_THRESHOLD,\n              COLUMNS_PER_TABLE_FAIL_THRESHOLD,\n              Guardrails.columnsPerTable,\n              Guardrails::setColumnsPerTableThreshold,"}
{"magic_number_smell": "public class GuardrailColumnValueSizeTest extends ThresholdTester\n{\n    private static final int 1024 = 1024; // bytes\n    private static final int FAIL_THRESHOLD = 1024 * 4; // bytes\n\n    public GuardrailColumnValueSizeTest()\n    {", "refactored_code": "    private static final int WARN_THRESHOLD = 1024; // bytes\npublic class GuardrailColumnValueSizeTest extends ThresholdTester\n{\n    private static final int WARN_THRESHOLD = 1024; // bytes\n    private static final int FAIL_THRESHOLD = WARN_THRESHOLD * 4; // bytes\n\n    public GuardrailColumnValueSizeTest()\n    {"}
{"magic_number_smell": "\n    public GuardrailFieldsPerUDTTest()\n    {\n        super(2,\n              FAIL_THRESHOLD,\n              Guardrails.fieldsPerUDT,\n              Guardrails::setFieldsPerUDTThreshold,", "refactored_code": "    private static final int WARN_THRESHOLD = 2;\n\n    public GuardrailFieldsPerUDTTest()\n    {\n        super(WARN_THRESHOLD,\n              FAIL_THRESHOLD,\n              Guardrails.fieldsPerUDT,\n              Guardrails::setFieldsPerUDTThreshold,"}
{"magic_number_smell": "    private static final int FAIL_THRESHOLD = 25;\n\n    private static final String WARN_MESSAGE = \"The cartesian product of the IN restrictions on %s produces %d \" +\n                                               \"values, this exceeds warning threshold of \" + 16;\n    private static final String FAIL_MESSAGE = \"Aborting query because the cartesian product of the IN restrictions \" +\n                                               \"on %s produces %d values, this exceeds fail threshold of \" + FAIL_THRESHOLD;\n", "refactored_code": "    private static final int WARN_THRESHOLD = 16;\n    private static final int FAIL_THRESHOLD = 25;\n\n    private static final String WARN_MESSAGE = \"The cartesian product of the IN restrictions on %s produces %d \" +\n                                               \"values, this exceeds warning threshold of \" + WARN_THRESHOLD;\n    private static final String FAIL_MESSAGE = \"Aborting query because the cartesian product of the IN restrictions \" +\n                                               \"on %s produces %d values, this exceeds fail threshold of \" + FAIL_THRESHOLD;\n"}
{"magic_number_smell": "\n    public GuardrailItemsPerCollectionTest()\n    {\n        super(10,\n              FAIL_THRESHOLD,\n              Guardrails.itemsPerCollection,\n              Guardrails::setItemsPerCollectionThreshold,", "refactored_code": "    private static final int WARN_THRESHOLD = 10;\n\n    public GuardrailItemsPerCollectionTest()\n    {\n        super(WARN_THRESHOLD,\n              FAIL_THRESHOLD,\n              Guardrails.itemsPerCollection,\n              Guardrails::setItemsPerCollectionThreshold,"}
{"magic_number_smell": "public class GuardrailKeyspacesTest extends ThresholdTester\n{\n    private static final int 3 = 3; // CQLTester creates two keyspaces\n    private static final int FAIL_THRESHOLD = 3 + 1;\n\n    public GuardrailKeyspacesTest()\n    {", "refactored_code": "    private static final int WARN_THRESHOLD = 3; // CQLTester creates two keyspaces\npublic class GuardrailKeyspacesTest extends ThresholdTester\n{\n    private static final int WARN_THRESHOLD = 3; // CQLTester creates two keyspaces\n    private static final int FAIL_THRESHOLD = WARN_THRESHOLD + 1;\n\n    public GuardrailKeyspacesTest()\n    {"}
{"magic_number_smell": "\n    public GuardrailMaximumReplicationFactorTest()\n    {\n        super(2,\n              MAXIMUM_REPLICATION_FACTOR_FAIL_THRESHOLD,\n              Guardrails.maximumReplicationFactor,\n              Guardrails::setMaximumReplicationFactorThreshold,", "refactored_code": "    private static final int MAXIMUM_REPLICATION_FACTOR_WARN_THRESHOLD = 2;\n\n    public GuardrailMaximumReplicationFactorTest()\n    {\n        super(MAXIMUM_REPLICATION_FACTOR_WARN_THRESHOLD,\n              MAXIMUM_REPLICATION_FACTOR_FAIL_THRESHOLD,\n              Guardrails.maximumReplicationFactor,\n              Guardrails::setMaximumReplicationFactorThreshold,"}
{"magic_number_smell": "\n    public GuardrailMinimumReplicationFactorTest()\n    {\n        super(4,\n              MINIMUM_REPLICATION_FACTOR_FAIL_THRESHOLD,\n              Guardrails.minimumReplicationFactor,\n              Guardrails::setMinimumReplicationFactorThreshold,", "refactored_code": "    private static final int MINIMUM_REPLICATION_FACTOR_WARN_THRESHOLD = 4;\n\n    public GuardrailMinimumReplicationFactorTest()\n    {\n        super(MINIMUM_REPLICATION_FACTOR_WARN_THRESHOLD,\n              MINIMUM_REPLICATION_FACTOR_FAIL_THRESHOLD,\n              Guardrails.minimumReplicationFactor,\n              Guardrails::setMinimumReplicationFactorThreshold,"}
{"magic_number_smell": "\n    public GuardrailPageSizeTest()\n    {\n        super(5,\n              PAGE_SIZE_FAIL_THRESHOLD,\n              Guardrails.pageSize,\n              Guardrails::setPageSizeThreshold,", "refactored_code": "    private static final int PAGE_SIZE_WARN_THRESHOLD = 5;\n\n    public GuardrailPageSizeTest()\n    {\n        super(PAGE_SIZE_WARN_THRESHOLD,\n              PAGE_SIZE_FAIL_THRESHOLD,\n              Guardrails.pageSize,\n              Guardrails::setPageSizeThreshold,"}
{"magic_number_smell": "\n    public GuardrailPartitionKeysInSelectTest()\n    {\n        super(3,\n              PARTITION_KEYS_SELECT_FAIL_THRESHOLD,\n              Guardrails.partitionKeysInSelect,\n              Guardrails::setPartitionKeysInSelectThreshold,", "refactored_code": "    private static final int PARTITION_KEYS_SELECT_WARN_THRESHOLD = 3;\n\n    public GuardrailPartitionKeysInSelectTest()\n    {\n        super(PARTITION_KEYS_SELECT_WARN_THRESHOLD,\n              PARTITION_KEYS_SELECT_FAIL_THRESHOLD,\n              Guardrails.partitionKeysInSelect,\n              Guardrails::setPartitionKeysInSelectThreshold,"}
{"magic_number_smell": "public class GuardrailPartitionSizeTest extends ThresholdTester\n{\n    private static final int 1024 * 1024 = 1024 * 1024; // bytes (1 MiB)\n    private static final int FAIL_THRESHOLD = 1024 * 1024 * 2; // bytes (2 MiB)\n    private static final int NUM_CLUSTERINGS = 10;\n    private static final String REDACTED_MESSAGE = \"Guardrail partition_size violated: Partition <redacted> has size\";\n", "refactored_code": "    private static final int WARN_THRESHOLD = 1024 * 1024; // bytes (1 MiB)\npublic class GuardrailPartitionSizeTest extends ThresholdTester\n{\n    private static final int WARN_THRESHOLD = 1024 * 1024; // bytes (1 MiB)\n    private static final int FAIL_THRESHOLD = WARN_THRESHOLD * 2; // bytes (2 MiB)\n    private static final int NUM_CLUSTERINGS = 10;\n    private static final String REDACTED_MESSAGE = \"Guardrail partition_size violated: Partition <redacted> has size\";\n"}
{"magic_number_smell": "public class GuardrailPartitionTombstonesTest extends ThresholdTester\n{\n    private static final int 500 = 500; // high enough to exceed system tables, which aren't excluded\n    private static final int FAIL_THRESHOLD = 500 + 1;\n    private static final String REDACTED_MESSAGE = \"Guardrail partition_tombstones violated: Partition <redacted>\";\n\n    public GuardrailPartitionTombstonesTest()", "refactored_code": "    private static final int WARN_THRESHOLD = 500; // high enough to exceed system tables, which aren't excluded\npublic class GuardrailPartitionTombstonesTest extends ThresholdTester\n{\n    private static final int WARN_THRESHOLD = 500; // high enough to exceed system tables, which aren't excluded\n    private static final int FAIL_THRESHOLD = WARN_THRESHOLD + 1;\n    private static final String REDACTED_MESSAGE = \"Guardrail partition_tombstones violated: Partition <redacted>\";\n\n    public GuardrailPartitionTombstonesTest()"}
{"magic_number_smell": "\n    public GuardrailSecondaryIndexesPerTableTest()\n    {\n        super(1,\n              INDEXES_PER_TABLE_FAIL_THRESHOLD,\n              Guardrails.secondaryIndexesPerTable,\n              Guardrails::setSecondaryIndexesPerTableThreshold,", "refactored_code": "    private static final int INDEXES_PER_TABLE_WARN_THRESHOLD = 1;\n\n    public GuardrailSecondaryIndexesPerTableTest()\n    {\n        super(INDEXES_PER_TABLE_WARN_THRESHOLD,\n              INDEXES_PER_TABLE_FAIL_THRESHOLD,\n              Guardrails.secondaryIndexesPerTable,\n              Guardrails::setSecondaryIndexesPerTableThreshold,"}
{"magic_number_smell": "    public void testDisabledMaxThreshold() throws Throwable\n    {\n        Threshold.ErrorMessageProvider errorMessageProvider = (isWarn, what, v, t) -> \"Should never trigger\";\n        testDisabledThreshold(new MaxThreshold(\"x\", REASON, state -> -1, state -> -1, errorMessageProvider));\n    }\n\n    @Test", "refactored_code": "    public static final int DISABLED = -1;\n    public void testDisabledMaxThreshold() throws Throwable\n    {\n        Threshold.ErrorMessageProvider errorMessageProvider = (isWarn, what, v, t) -> \"Should never trigger\";\n        testDisabledThreshold(new MaxThreshold(\"x\", REASON, state -> DISABLED, state -> DISABLED, errorMessageProvider));\n    }\n\n    @Test"}
{"magic_number_smell": "\n    public GuardrailTablesTest()\n    {\n        super(1,\n              TABLES_LIMIT_FAIL_THRESHOLD,\n              Guardrails.tables,\n              Guardrails::setTablesThreshold,", "refactored_code": "    private static final int TABLES_LIMIT_WARN_THRESHOLD = 1;\n\n    public GuardrailTablesTest()\n    {\n        super(TABLES_LIMIT_WARN_THRESHOLD,\n              TABLES_LIMIT_FAIL_THRESHOLD,\n              Guardrails.tables,\n              Guardrails::setTablesThreshold,"}
{"magic_number_smell": "\n    public GuardrailVectorDimensionsTest()\n    {\n        super(2,\n              FAIL_THRESHOLD,\n              Guardrails.vectorDimensions,\n              Guardrails::setVectorDimensionsThreshold,", "refactored_code": "    private static final int WARN_THRESHOLD = 2;\n\n    public GuardrailVectorDimensionsTest()\n    {\n        super(WARN_THRESHOLD,\n              FAIL_THRESHOLD,\n              Guardrails.vectorDimensions,\n              Guardrails::setVectorDimensionsThreshold,"}
{"magic_number_smell": "\n    public GuardrailViewsPerTableTest()\n    {\n        super(1,\n              VIEWS_PER_TABLE_FAIL_THRESHOLD,\n              Guardrails.materializedViewsPerTable,\n              Guardrails::setMaterializedViewsPerTableThreshold,", "refactored_code": "    private static final int VIEWS_PER_TABLE_WARN_THRESHOLD = 1;\n\n    public GuardrailViewsPerTableTest()\n    {\n        super(VIEWS_PER_TABLE_WARN_THRESHOLD,\n              VIEWS_PER_TABLE_FAIL_THRESHOLD,\n              Guardrails.materializedViewsPerTable,\n              Guardrails::setMaterializedViewsPerTableThreshold,"}
{"magic_number_smell": "    }\n\n    private static final int 3 = 3;\n    private static final TimeUUID[] uuids = new TimeUUID[3];\n    static\n    {\n        for (int i = 0; i < 3; ++i)", "refactored_code": "    private static final int UUID_COUNT = 3;\n    }\n\n    private static final int UUID_COUNT = 3;\n    private static final TimeUUID[] uuids = new TimeUUID[UUID_COUNT];\n    static\n    {\n        for (int i = 0; i < UUID_COUNT; ++i)"}
{"magic_number_smell": "    }\n\n    private static final int 3 = 3;\n    public static final UUID[] uuids = new UUID[3];\n    static\n    {\n        for (int i = 0; i < 3; ++i)", "refactored_code": "    private static final int UUID_COUNT = 3;\n    }\n\n    private static final int UUID_COUNT = 3;\n    public static final UUID[] uuids = new UUID[UUID_COUNT];\n    static\n    {\n        for (int i = 0; i < UUID_COUNT; ++i)"}
{"magic_number_smell": "    {\n        private final String name;\n\n        TestMonitor(String name, long timestamp, boolean isCrossNode, long MILLISECONDS.toNanos(100), long slow)\n        {\n            this.name = name;\n            setMonitoringTime(timestamp, isCrossNode, MILLISECONDS.toNanos(100), slow);", "refactored_code": "    private static final long timeout = MILLISECONDS.toNanos(100);\n    {\n        private final String name;\n\n        TestMonitor(String name, long timestamp, boolean isCrossNode, long timeout, long slow)\n        {\n            this.name = name;\n            setMonitoringTime(timestamp, isCrossNode, timeout, slow);"}
{"magic_number_smell": "\n    private static final int 250 = 250;\n    private static final int TESTS = 1000;\n    private static final int KEY_RANGE = 250 * 5;\n\n    private static final int TIMESTAMP = KEY_RANGE + 1;\n", "refactored_code": "    private static final int ENTRIES = 250;\n\n    private static final int ENTRIES = 250;\n    private static final int TESTS = 1000;\n    private static final int KEY_RANGE = ENTRIES * 5;\n\n    private static final int TIMESTAMP = KEY_RANGE + 1;\n"}
{"magic_number_smell": "    @Test\n    public void repro() // For running in the IDE, update with failing testCase parameters to run\n    {\n        new TestCase(2000, Cell.NO_TTL, Cell.NO_DELETION_TIME, DeletionTime.build(EARLIER_TS, EARLIER_LDT), 1,\n                     EARLIER_TS, Cell.NO_TTL, Cell.NO_DELETION_TIME, DeletionTime.LIVE, 3).execute();\n    }\n", "refactored_code": "    public static final int INITIAL_TS = 2000;\n    @Test\n    public void repro() // For running in the IDE, update with failing testCase parameters to run\n    {\n        new TestCase(INITIAL_TS, Cell.NO_TTL, Cell.NO_DELETION_TIME, DeletionTime.build(EARLIER_TS, EARLIER_LDT), 1,\n                     EARLIER_TS, Cell.NO_TTL, Cell.NO_DELETION_TIME, DeletionTime.LIVE, 3).execute();\n    }\n"}
{"magic_number_smell": "                                                          Arrays.asList(range(5, 6), range(7, 8))),\n                                               Arrays.asList(\"a\", \"b\", \"c\"));\n\n        int expectedSize = (int) StreamRequest.serializer.serializedSize(orig, MessagingService.current_version);\n        try (DataOutputBuffer out = new DataOutputBuffer(expectedSize))\n        {\n            StreamRequest.serializer.serialize(orig, out, MessagingService.current_version);", "refactored_code": "    private final int version = MessagingService.current_version;\n                                                          Arrays.asList(range(5, 6), range(7, 8))),\n                                               Arrays.asList(\"a\", \"b\", \"c\"));\n\n        int expectedSize = (int) StreamRequest.serializer.serializedSize(orig, version);\n        try (DataOutputBuffer out = new DataOutputBuffer(expectedSize))\n        {\n            StreamRequest.serializer.serialize(orig, out, version);"}
{"magic_number_smell": "        for (int i = 0; i < clusteringValues.length; i++)\n            clusteringByteBuffers[i] = decompose(metadata.clusteringColumns().get(i).type, clusteringValues[i]);\n\n        return new RangeTombstoneBoundMarker(BufferClusteringBound.create(kind, clusteringByteBuffers), DeletionTime.build(timestamp, FBUtilities.nowInSeconds()));\n    }\n\n    private RangeTombstoneBoundaryMarker boundary(ClusteringPrefix.Kind kind, long closeTimestamp, long openTimestamp, Object... clusteringValues)", "refactored_code": "    private final long nowInSec = FBUtilities.nowInSeconds();\n        for (int i = 0; i < clusteringValues.length; i++)\n            clusteringByteBuffers[i] = decompose(metadata.clusteringColumns().get(i).type, clusteringValues[i]);\n\n        return new RangeTombstoneBoundMarker(BufferClusteringBound.create(kind, clusteringByteBuffers), DeletionTime.build(timestamp, nowInSec));\n    }\n\n    private RangeTombstoneBoundaryMarker boundary(ClusteringPrefix.Kind kind, long closeTimestamp, long openTimestamp, Object... clusteringValues)"}
{"magic_number_smell": "    @Test\n    public void testDirect()\n    {\n        ByteComparable[] src1 = generateKeys(rand, 15000);\n        ByteComparable[] src2 = generateKeys(rand, 15000);\n        SortedMap<ByteComparable, ByteBuffer> content1 = new TreeMap<>((bytes1, bytes2) -> ByteComparable.compare(bytes1, bytes2, VERSION));\n        SortedMap<ByteComparable, ByteBuffer> content2 = new TreeMap<>((bytes1, bytes2) -> ByteComparable.compare(bytes1, bytes2, VERSION));", "refactored_code": "    private static final int COUNT = 15000;\n    @Test\n    public void testDirect()\n    {\n        ByteComparable[] src1 = generateKeys(rand, COUNT);\n        ByteComparable[] src2 = generateKeys(rand, COUNT);\n        SortedMap<ByteComparable, ByteBuffer> content1 = new TreeMap<>((bytes1, bytes2) -> ByteComparable.compare(bytes1, bytes2, VERSION));\n        SortedMap<ByteComparable, ByteBuffer> content2 = new TreeMap<>((bytes1, bytes2) -> ByteComparable.compare(bytes1, bytes2, VERSION));"}
{"magic_number_smell": "    @Test\n    public void testDirect()\n    {\n        ByteComparable[] src = generateKeys(rand, 100000);\n        SortedMap<ByteComparable, ByteBuffer> content = new TreeMap<>((bytes1, bytes2) -> ByteComparable.compare(bytes1, bytes2, VERSION));\n        InMemoryTrie<ByteBuffer> trie = makeInMemoryTrie(src, content, usePut());\n        int keysize = Arrays.stream(src)", "refactored_code": "    private static final int COUNT = 100000;\n    @Test\n    public void testDirect()\n    {\n        ByteComparable[] src = generateKeys(rand, COUNT);\n        SortedMap<ByteComparable, ByteBuffer> content = new TreeMap<>((bytes1, bytes2) -> ByteComparable.compare(bytes1, bytes2, VERSION));\n        InMemoryTrie<ByteBuffer> trie = makeInMemoryTrie(src, content, usePut());\n        int keysize = Arrays.stream(src)"}
{"magic_number_smell": "public class InMemoryTrieThreadedTest\n{\n    private static final int 300000 = 300000;\n    private static final int OTHERS = 300000 / 10;\n    private static final int PROGRESS_UPDATE = 300000 / 15;\n    private static final int READERS = 8;\n    private static final int WALKERS = 2;", "refactored_code": "    private static final int COUNT = 300000;\npublic class InMemoryTrieThreadedTest\n{\n    private static final int COUNT = 300000;\n    private static final int OTHERS = COUNT / 10;\n    private static final int PROGRESS_UPDATE = COUNT / 15;\n    private static final int READERS = 8;\n    private static final int WALKERS = 2;"}
{"magic_number_smell": "    @Test\n    public void testDirect()\n    {\n        ByteComparable[] src1 = generateKeys(rand, 15000);\n        ByteComparable[] src2 = generateKeys(rand, 15000);\n        SortedMap<ByteComparable, ByteBuffer> content1 = new TreeMap<>((bytes1, bytes2) -> ByteComparable.compare(bytes1, bytes2, VERSION));\n        SortedMap<ByteComparable, ByteBuffer> content2 = new TreeMap<>((bytes1, bytes2) -> ByteComparable.compare(bytes1, bytes2, VERSION));", "refactored_code": "    private static final int COUNT = 15000;\n    @Test\n    public void testDirect()\n    {\n        ByteComparable[] src1 = generateKeys(rand, COUNT);\n        ByteComparable[] src2 = generateKeys(rand, COUNT);\n        SortedMap<ByteComparable, ByteBuffer> content1 = new TreeMap<>((bytes1, bytes2) -> ByteComparable.compare(bytes1, bytes2, VERSION));\n        SortedMap<ByteComparable, ByteBuffer> content2 = new TreeMap<>((bytes1, bytes2) -> ByteComparable.compare(bytes1, bytes2, VERSION));"}
{"magic_number_smell": "    @Test\n    public void testIntersectRangeDirect()\n    {\n        testIntersectRange(15000);\n    }\n\n    public void testIntersectRange(int count)", "refactored_code": "    private static final int COUNT = 15000;\n    @Test\n    public void testIntersectRangeDirect()\n    {\n        testIntersectRange(COUNT);\n    }\n\n    public void testIntersectRange(int count)"}
{"magic_number_smell": "public abstract class PartitionerTestCase\n{\n    private static final double 0.10 = 0.10;\n    private static final double SPLIT_RATIO_MAX = 1 - 0.10;\n\n    protected IPartitioner partitioner;\n", "refactored_code": "    private static final double SPLIT_RATIO_MIN = 0.10;\npublic abstract class PartitionerTestCase\n{\n    private static final double SPLIT_RATIO_MIN = 0.10;\n    private static final double SPLIT_RATIO_MAX = 1 - SPLIT_RATIO_MIN;\n\n    protected IPartitioner partitioner;\n"}
{"magic_number_smell": "    {\n        Message<GossipShutdown> message = Message.out(Verb.GOSSIP_SHUTDOWN, new GossipShutdown(new EndpointState(HeartBeatState.empty())));\n\n        Assertions.assertThat(serde(message, MessagingService.Version.VERSION_40.value)).isNull();\n        Assertions.assertThat(serde(message, AFTER_CHANGE)).isInstanceOf(GossipShutdown.class);\n\n        // got from 4.x peer", "refactored_code": "    private static final int BEFORE_CHANGE = MessagingService.Version.VERSION_40.value;\n    {\n        Message<GossipShutdown> message = Message.out(Verb.GOSSIP_SHUTDOWN, new GossipShutdown(new EndpointState(HeartBeatState.empty())));\n\n        Assertions.assertThat(serde(message, BEFORE_CHANGE)).isNull();\n        Assertions.assertThat(serde(message, AFTER_CHANGE)).isInstanceOf(GossipShutdown.class);\n\n        // got from 4.x peer"}
{"magic_number_smell": "\n        // map each index to one random UUID from the previously created UUID array\n        Random random = new Random(System.currentTimeMillis());\n        UUID[] load = new UUID[300_000];\n        for (int i = 0; i < load.length; i++)\n            load[i] = hostIds[random.nextInt(HOST_ID_COUNT)];\n", "refactored_code": "    private static final int HINTS_COUNT = 300_000;\n\n        // map each index to one random UUID from the previously created UUID array\n        Random random = new Random(System.currentTimeMillis());\n        UUID[] load = new UUID[HINTS_COUNT];\n        for (int i = 0; i < load.length; i++)\n            load[i] = hostIds[random.nextInt(HOST_ID_COUNT)];\n"}
{"magic_number_smell": "    {\n        try (HintsWriter writer = HintsWriter.create(directory, descriptor))\n        {\n            ByteBuffer writeBuffer = ByteBuffer.allocateDirect(256 << 10);\n            try (HintsWriter.Session session = writer.newSession(writeBuffer))\n            {\n                long now = FBUtilities.timestampMicros();", "refactored_code": "    private static final int WRITE_BUFFER_SIZE = 256 << 10;\n    {\n        try (HintsWriter writer = HintsWriter.create(directory, descriptor))\n        {\n            ByteBuffer writeBuffer = ByteBuffer.allocateDirect(WRITE_BUFFER_SIZE);\n            try (HintsWriter.Session session = writer.newSession(writeBuffer))\n            {\n                long now = FBUtilities.timestampMicros();"}
{"magic_number_smell": "                targetTask.run();\n                taskCompleted.countDown();\n\n                verificationThread.join(300_000);\n            }\n            catch (InterruptedException e)\n            {", "refactored_code": "        private static final int verificationMaxInMs = 300_000; // 300s\n                targetTask.run();\n                taskCompleted.countDown();\n\n                verificationThread.join(verificationMaxInMs);\n            }\n            catch (InterruptedException e)\n            {"}
{"magic_number_smell": "\n        for (int i = 0; i < keys.size(); i++)\n        {\n            String ttl = deletable().contains(i) ? \" USING TTL \" + 10 : \"\";\n            executeLocal(tester, String.format(template, primaryKey, columnNames, keys.get(i), rows.get(i), ttl));\n        }\n    }", "refactored_code": "    public static final int DEFAULT_TTL_SECONDS = 10;\n\n        for (int i = 0; i < keys.size(); i++)\n        {\n            String ttl = deletable().contains(i) ? \" USING TTL \" + DEFAULT_TTL_SECONDS : \"\";\n            executeLocal(tester, String.format(template, primaryKey, columnNames, keys.get(i), rows.get(i), ttl));\n        }\n    }"}
{"magic_number_smell": "    @Test\n    public void testMultipleSegmentsForCreatingIndex() throws Throwable\n    {\n        createTable(\"CREATE TABLE %s (pk int, val vector<float, \" + 100 + \">, PRIMARY KEY(pk))\");\n\n        int vectorCount = 100;\n        List<float[]> vectors = new ArrayList<>();", "refactored_code": "    private static final int dimension = 100;\n    @Test\n    public void testMultipleSegmentsForCreatingIndex() throws Throwable\n    {\n        createTable(\"CREATE TABLE %s (pk int, val vector<float, \" + dimension + \">, PRIMARY KEY(pk))\");\n\n        int vectorCount = 100;\n        List<float[]> vectors = new ArrayList<>();"}
{"magic_number_smell": "    public static void insertData(SAITester tester, Object[][] allRows, Scenario scenario)\n    {\n        int sstableCounter = 0;\n        int sstableIncrement = 64 / 8;\n        for (int count = 0; count < allRows.length; count++)\n        {\n            tester.execute(\"INSERT INTO %s (pk, ck, value) VALUES (?, ?, ?)\", allRows[count][0], allRows[count][1], allRows[count][2]);", "refactored_code": "    public static final int NUMBER_OF_VALUES = 64;\n    public static void insertData(SAITester tester, Object[][] allRows, Scenario scenario)\n    {\n        int sstableCounter = 0;\n        int sstableIncrement = NUMBER_OF_VALUES / 8;\n        for (int count = 0; count < allRows.length; count++)\n        {\n            tester.execute(\"INSERT INTO %s (pk, ck, value) VALUES (?, ?, ?)\", allRows[count][0], allRows[count][1], allRows[count][2]);"}
{"magic_number_smell": "            // Query each value for all operators\n            for (int index = 0; index < allRows.length; index++)\n            {\n                assertRows(tester.execute(\"SELECT * FROM %s WHERE value = ?\", allRows[index][2]), new Object[][] { allRows[index] });\n                assertRowsIgnoringOrder(tester.execute(\"SELECT * FROM %s WHERE value > ?\", allRows[index][2]), Arrays.copyOfRange(allRows, index + 1, allRows.length));\n                assertRowsIgnoringOrder(tester.execute(\"SELECT * FROM %s WHERE value >= ?\", allRows[index][2]), Arrays.copyOfRange(allRows, index, allRows.length));\n                assertRowsIgnoringOrder(tester.execute(\"SELECT * FROM %s WHERE value < ?\", allRows[index][2]), Arrays.copyOfRange(allRows, 0, index));", "refactored_code": "    private static final int VALUE_INDEX = 2;\n            // Query each value for all operators\n            for (int index = 0; index < allRows.length; index++)\n            {\n                assertRows(tester.execute(\"SELECT * FROM %s WHERE value = ?\", allRows[index][VALUE_INDEX]), new Object[][] { allRows[index] });\n                assertRowsIgnoringOrder(tester.execute(\"SELECT * FROM %s WHERE value > ?\", allRows[index][VALUE_INDEX]), Arrays.copyOfRange(allRows, index + 1, allRows.length));\n                assertRowsIgnoringOrder(tester.execute(\"SELECT * FROM %s WHERE value >= ?\", allRows[index][VALUE_INDEX]), Arrays.copyOfRange(allRows, index, allRows.length));\n                assertRowsIgnoringOrder(tester.execute(\"SELECT * FROM %s WHERE value < ?\", allRows[index][VALUE_INDEX]), Arrays.copyOfRange(allRows, 0, index));"}
{"magic_number_smell": "    {\n        List<Object[]> scenarios = new LinkedList<>();\n\n        scenarios.add( new Object[] { Populator.INDEXABLE_ROWS, IndexStateOnRestart.VALID, StartupTaskRunOrder.PRE_JOIN_RUNS_BEFORE_BUILD, 0, 0, 0, 100 });\n        scenarios.add( new Object[] { Populator.INDEXABLE_ROWS, IndexStateOnRestart.VALID, StartupTaskRunOrder.PRE_JOIN_RUNS_AFTER_BUILD, 0, 0, 0, 100 });\n        scenarios.add( new Object[] { Populator.INDEXABLE_ROWS, IndexStateOnRestart.ALL_EMPTY, StartupTaskRunOrder.PRE_JOIN_RUNS_BEFORE_BUILD, 1, 1, 1, 100 });\n        scenarios.add( new Object[] { Populator.INDEXABLE_ROWS, IndexStateOnRestart.ALL_EMPTY, StartupTaskRunOrder.PRE_JOIN_RUNS_AFTER_BUILD, 1, 1, 1, 100 });", "refactored_code": "    private static final int DOCS = 100;\n    {\n        List<Object[]> scenarios = new LinkedList<>();\n\n        scenarios.add( new Object[] { Populator.INDEXABLE_ROWS, IndexStateOnRestart.VALID, StartupTaskRunOrder.PRE_JOIN_RUNS_BEFORE_BUILD, 0, 0, 0, DOCS });\n        scenarios.add( new Object[] { Populator.INDEXABLE_ROWS, IndexStateOnRestart.VALID, StartupTaskRunOrder.PRE_JOIN_RUNS_AFTER_BUILD, 0, 0, 0, DOCS });\n        scenarios.add( new Object[] { Populator.INDEXABLE_ROWS, IndexStateOnRestart.ALL_EMPTY, StartupTaskRunOrder.PRE_JOIN_RUNS_BEFORE_BUILD, 1, 1, 1, DOCS });\n        scenarios.add( new Object[] { Populator.INDEXABLE_ROWS, IndexStateOnRestart.ALL_EMPTY, StartupTaskRunOrder.PRE_JOIN_RUNS_AFTER_BUILD, 1, 1, 1, DOCS });"}
{"magic_number_smell": "    public void testEqQueriesAgainstInt32Index() throws Exception\n    {\n        IndexSegmentSearcher indexSearcher = BlockBalancedTreeIndexBuilder.buildInt32Searcher(newIndexDescriptor(),\n                                                                                              0, EQ_TEST_UPPER_BOUND_EXCLUSIVE);\n        testEqQueries(indexSearcher, Int32Type.instance, Integer::valueOf);\n    }\n", "refactored_code": "    private static final short EQ_TEST_LOWER_BOUND_INCLUSIVE = 0;\n    public void testEqQueriesAgainstInt32Index() throws Exception\n    {\n        IndexSegmentSearcher indexSearcher = BlockBalancedTreeIndexBuilder.buildInt32Searcher(newIndexDescriptor(),\n                                                                                              EQ_TEST_LOWER_BOUND_INCLUSIVE, EQ_TEST_UPPER_BOUND_EXCLUSIVE);\n        testEqQueries(indexSearcher, Int32Type.instance, Integer::valueOf);\n    }\n"}
{"magic_number_smell": "        }\n        if (doAwait)\n        {\n            latch.await(20, TimeUnit.SECONDS);\n            if (cyclic)\n            {\n                reset();", "refactored_code": "    private static final int LATCH_TIMEOUT_SECONDS = 20;\n        }\n        if (doAwait)\n        {\n            latch.await(LATCH_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n            if (cyclic)\n            {\n                reset();"}
{"magic_number_smell": "        if (verifyDataAfterLoading)\n        {\n            UntypedResultSet rs = QueryProcessor.executeInternal(\"SELECT * FROM \" + qualifiedTable + \";\");\n            assertEquals(threads.length * 10, rs.size());\n        }\n    }\n", "refactored_code": "    private static final int NUMBER_WRITES_IN_RUNNABLE = 10;\n        if (verifyDataAfterLoading)\n        {\n            UntypedResultSet rs = QueryProcessor.executeInternal(\"SELECT * FROM \" + qualifiedTable + \";\");\n            assertEquals(threads.length * NUMBER_WRITES_IN_RUNNABLE, rs.size());\n        }\n    }\n"}
{"magic_number_smell": "            for (long writtenKibibytes = 0L; writtenKibibytes < totalKibibytes; writtenKibibytes += partitionKibibytes)\n            {\n                String pk = Long.toBinaryString(writtenKibibytes);\n                for (long kibibytes = 0L; kibibytes < partitionKibibytes; kibibytes += 8)\n                {\n                    String ck = Long.toBinaryString(kibibytes);\n                    execute(\"INSERT INTO %s (pk, ck, val) VALUES (?,?,?)\", pk, ck, randomText(8 * 1024));", "refactored_code": "    private static final int rowKibibytes = 8;\n            for (long writtenKibibytes = 0L; writtenKibibytes < totalKibibytes; writtenKibibytes += partitionKibibytes)\n            {\n                String pk = Long.toBinaryString(writtenKibibytes);\n                for (long kibibytes = 0L; kibibytes < partitionKibibytes; kibibytes += rowKibibytes)\n                {\n                    String ck = Long.toBinaryString(kibibytes);\n                    execute(\"INSERT INTO %s (pk, ck, val) VALUES (?,?,?)\", pk, ck, randomText(rowKibibytes * 1024));"}
{"magic_number_smell": "\n        // Setting up/writing large values is an expensive operation, we only want to do it once per run\n        writer = getWriter(cfs, dir, txn);\n        for (int i = 0; i < 1000; i++)\n        {\n            UpdateBuilder builder = UpdateBuilder.create(cfs.metadata(), String.format(\"pkvalue_%07d\", i)).withTimestamp(1);\n            byte[] reg1 = new byte[valueSize];", "refactored_code": "    private static final int numberOfPks = 1000;\n\n        // Setting up/writing large values is an expensive operation, we only want to do it once per run\n        writer = getWriter(cfs, dir, txn);\n        for (int i = 0; i < numberOfPks; i++)\n        {\n            UpdateBuilder builder = UpdateBuilder.create(cfs.metadata(), String.format(\"pkvalue_%07d\", i)).withTimestamp(1);\n            byte[] reg1 = new byte[valueSize];"}
{"magic_number_smell": "        for (SSTableReader sstable : store.getLiveSSTables())\n        {\n            firstDelTime = sstable.getMaxLocalDeletionTime();\n            assertEquals(ttltimestamp + 10000, firstDelTime, 10);\n\n        }\n", "refactored_code": "    public static final double DELTA = 10;\n        for (SSTableReader sstable : store.getLiveSSTables())\n        {\n            firstDelTime = sstable.getMaxLocalDeletionTime();\n            assertEquals(ttltimestamp + 10000, firstDelTime, DELTA);\n\n        }\n"}
{"magic_number_smell": "\n        public long unsharedHeapSize()\n        {\n            return ObjectSizes.measure(new Pre_C_11206_RowIndexEntry(0));\n        }\n\n        public static class Serializer", "refactored_code": "        private static final long EMPTY_SIZE = ObjectSizes.measure(new Pre_C_11206_RowIndexEntry(0));\n\n        public long unsharedHeapSize()\n        {\n            return EMPTY_SIZE;\n        }\n\n        public static class Serializer"}
{"magic_number_smell": "    @After\n    public void resetMaxSegmentSize()\n    {\n        MmappedRegions.MAX_SEGMENT_SIZE = MmappedRegions.MAX_SEGMENT_SIZE;\n    }\n\n    private static ByteBuffer allocateBuffer(int size)", "refactored_code": "    private final int OLD_MAX_SEGMENT_SIZE = MmappedRegions.MAX_SEGMENT_SIZE;\n    @After\n    public void resetMaxSegmentSize()\n    {\n        MmappedRegions.MAX_SEGMENT_SIZE = OLD_MAX_SEGMENT_SIZE;\n    }\n\n    private static ByteBuffer allocateBuffer(int size)"}
{"magic_number_smell": "            super(sw);\n            this.file = file;\n            this.writer = sw;\n            fullContents = new byte[8 << 10 + 8 << 10 / 2];\n            ThreadLocalRandom.current().nextBytes(fullContents);\n            partialContents = Arrays.copyOf(fullContents, 8 << 10);\n            sw.write(fullContents);", "refactored_code": "        protected static final int BUFFER_SIZE = 8 << 10;\n            super(sw);\n            this.file = file;\n            this.writer = sw;\n            fullContents = new byte[BUFFER_SIZE + BUFFER_SIZE / 2];\n            ThreadLocalRandom.current().nextBytes(fullContents);\n            partialContents = Arrays.copyOf(fullContents, BUFFER_SIZE);\n            sw.write(fullContents);"}
{"magic_number_smell": "\n    /**\n     * A test runner that runs the `test` while changing the ReplicationStrategy of the raced keyspace.\n     * It loops at most for 100 time if unable to produce the race or any exception.\n     */\n    private static void raceOfReplicationStrategyTest(KeyspaceParams init,\n                                                      KeyspaceParams alterTo,", "refactored_code": "    private static final int RACE_TEST_LOOPS = 100;\n\n    /**\n     * A test runner that runs the `test` while changing the ReplicationStrategy of the raced keyspace.\n     * It loops at most for RACE_TEST_LOOPS time if unable to produce the race or any exception.\n     */\n    private static void raceOfReplicationStrategyTest(KeyspaceParams init,\n                                                      KeyspaceParams alterTo,"}
{"magic_number_smell": "    public void testLoggedPartitionsPerBatch()\n    {\n        qt().withExamples(25)\n            .forAll(intArrays(integers().between(1, 3),\n                              integers().between(1, MAX_STATEMENTS_PER_ROUND)),\n                    integers().between(1, MAX_DISTINCT_PARTITIONS))\n            .checkAssert((rounds, distinctPartitions) ->", "refactored_code": "    private static final int MAX_ROUNDS_TO_PERFORM = 3;\n    public void testLoggedPartitionsPerBatch()\n    {\n        qt().withExamples(25)\n            .forAll(intArrays(integers().between(1, MAX_ROUNDS_TO_PERFORM),\n                              integers().between(1, MAX_STATEMENTS_PER_ROUND)),\n                    integers().between(1, MAX_DISTINCT_PARTITIONS))\n            .checkAssert((rounds, distinctPartitions) ->"}
{"magic_number_smell": "        // calculations - applying some general assertions for hitRate calculations that essentially just smoke test\n        // existence (i.e. NaN at initialization) since they are established by way of an inner class on CacheMetrics\n        // itself.\n        assertEquals(expectation.cacheSize.65536(), actual.65536.getValue().longValue());\n        assertEquals(expectation.cacheSize.weightedSize(), actual.size.getValue().longValue());\n        assertEquals(expectation.cacheSize.size(), actual.entries.getValue().intValue());\n        assertEquals(expectation.hits, actual.hits.getCount());", "refactored_code": "    private static final long capacity = 65536;\n        // calculations - applying some general assertions for hitRate calculations that essentially just smoke test\n        // existence (i.e. NaN at initialization) since they are established by way of an inner class on CacheMetrics\n        // itself.\n        assertEquals(expectation.cacheSize.capacity(), actual.capacity.getValue().longValue());\n        assertEquals(expectation.cacheSize.weightedSize(), actual.size.getValue().longValue());\n        assertEquals(expectation.cacheSize.size(), actual.entries.getValue().intValue());\n        assertEquals(expectation.hits, actual.hits.getCount());"}
{"magic_number_smell": "        @Test\n        public void testFindIndex()\n        {\n            qt().withExamples(1000000)\n                .forAll(booleans().all()\n                                  .flatMap(b -> offsets.flatMap(offs -> this.offsetsAndValue(offs, b, 0))))\n                .check(this::checkFindIndex);", "refactored_code": "        public static final int numExamples = 1000000;\n        @Test\n        public void testFindIndex()\n        {\n            qt().withExamples(numExamples)\n                .forAll(booleans().all()\n                                  .flatMap(b -> offsets.flatMap(offs -> this.offsetsAndValue(offs, b, 0))))\n                .check(this::checkFindIndex);"}
{"magic_number_smell": "        OverrideConfigurationLoader.override((config) -> {\n            config.partitioner = \"Murmur3Partitioner\";\n        });\n        MEMTABLE_SHARD_COUNT.setInt(13);\n\n        EmbeddedCassandraService cassandra = new EmbeddedCassandraService();\n        cassandra.start();", "refactored_code": "    private static final int NUM_SHARDS = 13;\n        OverrideConfigurationLoader.override((config) -> {\n            config.partitioner = \"Murmur3Partitioner\";\n        });\n        MEMTABLE_SHARD_COUNT.setInt(NUM_SHARDS);\n\n        EmbeddedCassandraService cassandra = new EmbeddedCassandraService();\n        cassandra.start();"}
{"magic_number_smell": "    @Before\n    public void setUp() throws UnknownHostException\n    {\n        localQuorumConnectivityChecker = new StartupClusterConnectivityChecker(100, false);\n        globalQuorumConnectivityChecker = new StartupClusterConnectivityChecker(100, true);\n        noopChecker = new StartupClusterConnectivityChecker(-1, false);\n        zeroWaitChecker = new StartupClusterConnectivityChecker(0, false);", "refactored_code": "    private static final long TIMEOUT_NANOS = 100;\n    @Before\n    public void setUp() throws UnknownHostException\n    {\n        localQuorumConnectivityChecker = new StartupClusterConnectivityChecker(TIMEOUT_NANOS, false);\n        globalQuorumConnectivityChecker = new StartupClusterConnectivityChecker(TIMEOUT_NANOS, true);\n        noopChecker = new StartupClusterConnectivityChecker(-1, false);\n        zeroWaitChecker = new StartupClusterConnectivityChecker(0, false);"}
{"magic_number_smell": "    {\n        ValidationState state = validator.state;\n        int maxDepth = DatabaseDescriptor.getRepairSessionMaxTreeDepth();\n        state.phase.start(1, 1024);\n\n        MerkleTrees trees = new MerkleTrees(cfs.getPartitioner());\n        for (Range<Token> range : validator.desc.ranges)", "refactored_code": "    private static final int MISMATCH_NUM_PARTITIONS = 1;\n    {\n        ValidationState state = validator.state;\n        int maxDepth = DatabaseDescriptor.getRepairSessionMaxTreeDepth();\n        state.phase.start(MISMATCH_NUM_PARTITIONS, 1024);\n\n        MerkleTrees trees = new MerkleTrees(cfs.getPartitioner());\n        for (Range<Token> range : validator.desc.ranges)"}
{"magic_number_smell": "        job.run();\n\n        Thread.sleep(1000);\n        RepairResult result = job.get(10, TimeUnit.SECONDS);\n\n        // Since there are no differences, there should be nothing to sync.\n        assertThat(result.stats).hasSize(0);", "refactored_code": "    private static final long TEST_TIMEOUT_S = 10;\n        job.run();\n\n        Thread.sleep(1000);\n        RepairResult result = job.get(TEST_TIMEOUT_S, TimeUnit.SECONDS);\n\n        // Since there are no differences, there should be nothing to sync.\n        assertThat(result.stats).hasSize(0);"}
{"magic_number_smell": "        Token min = trees.partitioner().getMinimumToken();\n        assertNotNull(trees.hash(new Range<>(min, min)));\n\n        Message message = outgoingMessageSink.get(60, TimeUnit.SECONDS);\n        assertEquals(Verb.VALIDATION_RSP, message.verb());\n        ValidationResponse m = (ValidationResponse) message.payload;\n        assertEquals(desc, m.desc);", "refactored_code": "    private static final long TEST_TIMEOUT = 60; //seconds\n        Token min = trees.partitioner().getMinimumToken();\n        assertNotNull(trees.hash(new Range<>(min, min)));\n\n        Message message = outgoingMessageSink.get(TEST_TIMEOUT, TimeUnit.SECONDS);\n        assertEquals(Verb.VALIDATION_RSP, message.verb());\n        ValidationResponse m = (ValidationResponse) message.payload;\n        assertEquals(desc, m.desc);"}
{"magic_number_smell": "{\n    private static final String KEYSPACE = \"schemaargsparsertest\";\n    private static final int 3 = 3;\n    private static TableMetadata[] cfm = new TableMetadata[3];\n    private static ColumnFamilyStore[] cfs = new ColumnFamilyStore[3];\n\n    @BeforeClass", "refactored_code": "    private static final int NUM_TBL = 3;\n{\n    private static final String KEYSPACE = \"schemaargsparsertest\";\n    private static final int NUM_TBL = 3;\n    private static TableMetadata[] cfm = new TableMetadata[NUM_TBL];\n    private static ColumnFamilyStore[] cfs = new ColumnFamilyStore[NUM_TBL];\n\n    @BeforeClass"}
{"magic_number_smell": "\n    private <T extends RepairMessage> T serializeRoundTrip(T msg, IVersionedSerializer<T> serializer) throws IOException\n    {\n        long size = serializer.serializedSize(msg, MessagingService.current_version);\n\n        ByteBuffer buf = ByteBuffer.allocate((int)size);\n        DataOutputPlus out = new DataOutputBufferFixed(buf);", "refactored_code": "    private static final int PROTOCOL_VERSION = MessagingService.current_version;\n\n    private <T extends RepairMessage> T serializeRoundTrip(T msg, IVersionedSerializer<T> serializer) throws IOException\n    {\n        long size = serializer.serializedSize(msg, PROTOCOL_VERSION);\n\n        ByteBuffer buf = ByteBuffer.allocate((int)size);\n        DataOutputPlus out = new DataOutputBufferFixed(buf);"}
{"magic_number_smell": "            // Serialized values are unsigned int, unwrap bits w/overflow\n            deserialized -= Integer.MIN_VALUE;\n\n            Timestamp ts = new Timestamp(deserialized * ChronoUnit.DAYS.getDuration().toMillis());\n            testCalendar.setTime(ts);\n\n            Date newDate = testCalendar.getTime();", "refactored_code": "    private static final long millisPerDay = ChronoUnit.DAYS.getDuration().toMillis();\n            // Serialized values are unsigned int, unwrap bits w/overflow\n            deserialized -= Integer.MIN_VALUE;\n\n            Timestamp ts = new Timestamp(deserialized * millisPerDay);\n            testCalendar.setTime(ts);\n\n            Date newDate = testCalendar.getTime();"}
{"magic_number_smell": "public class TimestampSerializerTest\n{\n    public static final long 1000L = 1000L;\n    public static final long ONE_MINUTE = 60 * 1000L;\n    public static final long ONE_HOUR = 60 * ONE_MINUTE;\n    public static final long ONE_DAY = 24 * ONE_HOUR;\n    public static final long BASE_OFFSET = TimestampSerializer.dateStringToTimestamp(\"1970-01-01\");", "refactored_code": "    public static final long ONE_SECOND = 1000L;\npublic class TimestampSerializerTest\n{\n    public static final long ONE_SECOND = 1000L;\n    public static final long ONE_MINUTE = 60 * ONE_SECOND;\n    public static final long ONE_HOUR = 60 * ONE_MINUTE;\n    public static final long ONE_DAY = 24 * ONE_HOUR;\n    public static final long BASE_OFFSET = TimestampSerializer.dateStringToTimestamp(\"1970-01-01\");"}
{"magic_number_smell": "\n            // allow executing tests to complete\n            blocked.signalAll();\n            completed.await(10 + 1, TimeUnit.SECONDS);\n\n            // Submission is unblocked\n            Thread.sleep(250);", "refactored_code": "    public static final int TASK_SECONDS = 10;\n\n            // allow executing tests to complete\n            blocked.signalAll();\n            completed.await(TASK_SECONDS + 1, TimeUnit.SECONDS);\n\n            // Submission is unblocked\n            Thread.sleep(250);"}
{"magic_number_smell": "        Slice slice = Slice.make(cmp.make(start), cmp.make(end));\n        ClusteringIndexSliceFilter filter = new ClusteringIndexSliceFilter(Slices.with(cmp, slice), reversed);\n\n        return SinglePartitionReadCommand.create(metadata, FBUtilities.nowInSeconds(), ColumnFilter.all(metadata), RowFilter.none(), DataLimits.NONE, Util.dk(key), filter);\n    }\n\n    private static ReadCommand rangeNamesQuery(String keyStart, String keyEnd, int count, String... names)", "refactored_code": "    public static final long nowInSec = FBUtilities.nowInSeconds();\n        Slice slice = Slice.make(cmp.make(start), cmp.make(end));\n        ClusteringIndexSliceFilter filter = new ClusteringIndexSliceFilter(Slices.with(cmp, slice), reversed);\n\n        return SinglePartitionReadCommand.create(metadata, nowInSec, ColumnFilter.all(metadata), RowFilter.none(), DataLimits.NONE, Util.dk(key), filter);\n    }\n\n    private static ReadCommand rangeNamesQuery(String keyStart, String keyEnd, int count, String... names)"}
{"magic_number_smell": "\n    private void testSyncRequestWrite() throws IOException\n    {\n        InetAddressAndPort local = InetAddressAndPort.getByNameOverrideDefaults(\"127.0.0.1\", 7010);\n        InetAddressAndPort src = InetAddressAndPort.getByNameOverrideDefaults(\"127.0.0.2\", 7010);\n        InetAddressAndPort dest = InetAddressAndPort.getByNameOverrideDefaults(\"127.0.0.3\", 7010);\n", "refactored_code": "    private static final int PORT = 7010;\n\n    private void testSyncRequestWrite() throws IOException\n    {\n        InetAddressAndPort local = InetAddressAndPort.getByNameOverrideDefaults(\"127.0.0.1\", PORT);\n        InetAddressAndPort src = InetAddressAndPort.getByNameOverrideDefaults(\"127.0.0.2\", PORT);\n        InetAddressAndPort dest = InetAddressAndPort.getByNameOverrideDefaults(\"127.0.0.3\", PORT);\n"}
{"magic_number_smell": "\n    private Gen<List<Descriptor>> descriptorLists(int minSize)\n    {\n        return lists().of(descriptors()).ofSizeBetween(minSize, 10);\n    }\n\n    private Gen<SSTableFormat<?, ?>> sstableFormatTypes()", "refactored_code": "    private static final int MAX_VERSION_LIST_SIZE = 10;\n\n    private Gen<List<Descriptor>> descriptorLists(int minSize)\n    {\n        return lists().of(descriptors()).ofSizeBetween(minSize, MAX_VERSION_LIST_SIZE);\n    }\n\n    private Gen<SSTableFormat<?, ?>> sstableFormatTypes()"}
{"magic_number_smell": "        StorageService.instance.unsafeSetInitialized();\n\n        final ColumnFamilyStore table = Keyspace.open(KEYSPACE).getColumnFamilyStore(TABLE);\n        for (int row = 0; row < 1000; row++)\n        {\n            final ByteBuffer value = ByteBufferUtil.bytes(String.valueOf(row));\n            new RowUpdateBuilder(table.metadata(), System.currentTimeMillis(), value)", "refactored_code": "    private static final int ROWS = 1000;\n        StorageService.instance.unsafeSetInitialized();\n\n        final ColumnFamilyStore table = Keyspace.open(KEYSPACE).getColumnFamilyStore(TABLE);\n        for (int row = 0; row < ROWS; row++)\n        {\n            final ByteBuffer value = ByteBufferUtil.bytes(String.valueOf(row));\n            new RowUpdateBuilder(table.metadata(), System.currentTimeMillis(), value)"}
{"magic_number_smell": "                                              .addRegularColumn(\"v\", LongType.instance)\n                                              .build();\n        Row row =  BTreeRow.emptyRow(Clustering.EMPTY);\n        for (int i = 0; i < 50_000; i++)\n            checkState(metadata, MAX_PK_SIZE, row);\n    }\n", "refactored_code": "    private static final int ROUNDS = 50_000;\n                                              .addRegularColumn(\"v\", LongType.instance)\n                                              .build();\n        Row row =  BTreeRow.emptyRow(Clustering.EMPTY);\n        for (int i = 0; i < ROUNDS; i++)\n            checkState(metadata, MAX_PK_SIZE, row);\n    }\n"}
{"magic_number_smell": "    private static final long maxQueryTimeoutMicros()/2 = maxQueryTimeoutMicros()/2;\n\n    private static final WaitParseValidator DEFAULT_WAIT_RANDOMIZER_VALIDATOR = new WaitParseValidator(defaultWaitRandomizer(), QEXP, 1.5);\n    private static final BoundParseValidator DEFAULT_MIN_VALIDATOR = new BoundParseValidator(defaultMinWait(), true, assertBound(0, maxQueryTimeoutMicros()/2, 0, selectors.maxReadWrite(0f).getClass(), 0.50, 0, modifiers.multiply(0f).getClass(), 0.66));\n    private static final BoundParseValidator DEFAULT_MAX_VALIDATOR = new BoundParseValidator(defaultMaxWait(), false, assertBound(10000, 100000, 100000, selectors.maxReadWrite(0f).getClass(), 0.95, 0, modifiers.multiplyByAttemptsExp(0f).getClass(), 1.8));\n    private static final BoundParseValidator DEFAULT_MIN_DELTA_VALIDATOR = new BoundParseValidator(defaultMinDelta(), true, assertBound(5000, maxQueryTimeoutMicros()/2, 5000, selectors.maxReadWrite(0f).getClass(), 0.50, 0, modifiers.multiply(0f).getClass(), 0.5));\n", "refactored_code": "    private static final long MAX = maxQueryTimeoutMicros()/2;\n    private static final long MAX = maxQueryTimeoutMicros()/2;\n\n    private static final WaitParseValidator DEFAULT_WAIT_RANDOMIZER_VALIDATOR = new WaitParseValidator(defaultWaitRandomizer(), QEXP, 1.5);\n    private static final BoundParseValidator DEFAULT_MIN_VALIDATOR = new BoundParseValidator(defaultMinWait(), true, assertBound(0, MAX, 0, selectors.maxReadWrite(0f).getClass(), 0.50, 0, modifiers.multiply(0f).getClass(), 0.66));\n    private static final BoundParseValidator DEFAULT_MAX_VALIDATOR = new BoundParseValidator(defaultMaxWait(), false, assertBound(10000, 100000, 100000, selectors.maxReadWrite(0f).getClass(), 0.95, 0, modifiers.multiplyByAttemptsExp(0f).getClass(), 1.8));\n    private static final BoundParseValidator DEFAULT_MIN_DELTA_VALIDATOR = new BoundParseValidator(defaultMinDelta(), true, assertBound(5000, MAX, 5000, selectors.maxReadWrite(0f).getClass(), 0.50, 0, modifiers.multiply(0f).getClass(), 0.5));\n"}
{"magic_number_smell": "    @BeforeClass\n    public static void defineSchema() throws ConfigurationException\n    {\n        properties = new WithProperties().set(MAX_CONCURRENT_RANGE_REQUESTS, 4);\n    }\n\n    @AfterClass", "refactored_code": "    private static final int MAX_CONCURRENCY_FACTOR = 4;\n    @BeforeClass\n    public static void defineSchema() throws ConfigurationException\n    {\n        properties = new WithProperties().set(MAX_CONCURRENT_RANGE_REQUESTS, MAX_CONCURRENCY_FACTOR);\n    }\n\n    @AfterClass"}
{"magic_number_smell": "    private static double defaultInterDCStreamThroughputBytesPerSec;\n    private static final int Integer.MAX_VALUE - 1 = Integer.MAX_VALUE - 1;\n    private static final double INTEGER_MAX_VALUE_MEGABITS_IN_BYTES = DataRateSpec.LongBytesPerSecondBound\n                                                                          .megabitsPerSecondInBytesPerSecond(Integer.MAX_VALUE - 1)\n                                                                          .toBytesPerSecond();\n\n    private static double defaultEntireSSTableStreamThroughputBytesPerSec;", "refactored_code": "    private static final int MAX_INT_CONFIG_VALUE = Integer.MAX_VALUE - 1;\n    private static double defaultInterDCStreamThroughputBytesPerSec;\n    private static final int MAX_INT_CONFIG_VALUE = Integer.MAX_VALUE - 1;\n    private static final double INTEGER_MAX_VALUE_MEGABITS_IN_BYTES = DataRateSpec.LongBytesPerSecondBound\n                                                                          .megabitsPerSecondInBytesPerSecond(MAX_INT_CONFIG_VALUE)\n                                                                          .toBytesPerSecond();\n\n    private static double defaultEntireSSTableStreamThroughputBytesPerSec;"}
{"magic_number_smell": "    public void roundTrip_HappyPath_NotReadabaleByteBuffer() throws IOException\n    {\n        populateInput();\n        StreamCompressionSerializer.serialize(compressor, input, MessagingService.current_version).write(size -> compressed = ByteBuffer.allocateDirect(size));\n        input.flip();\n        output = serializer.deserialize(decompressor, new DataInputBuffer(compressed, false), MessagingService.current_version);\n        validateResults();", "refactored_code": "    private static final int VERSION = MessagingService.current_version;\n    public void roundTrip_HappyPath_NotReadabaleByteBuffer() throws IOException\n    {\n        populateInput();\n        StreamCompressionSerializer.serialize(compressor, input, VERSION).write(size -> compressed = ByteBuffer.allocateDirect(size));\n        input.flip();\n        output = serializer.deserialize(decompressor, new DataInputBuffer(compressed, false), VERSION);\n        validateResults();"}
{"magic_number_smell": "    @Test\n    public void revertBootstrapAndJoinEffects() throws Throwable\n    {\n        for (int i = 0; i < 100; i++)\n            testRevertingBootstrap(System.nanoTime());\n    }\n", "refactored_code": "    private static final int ITERATIONS = 100;\n    @Test\n    public void revertBootstrapAndJoinEffects() throws Throwable\n    {\n        for (int i = 0; i < ITERATIONS; i++)\n            testRevertingBootstrap(System.nanoTime());\n    }\n"}
{"magic_number_smell": "\n        public void run()\n        {\n            byte[] buffer = new byte[8_192];\n            while (true)\n            {\n                try", "refactored_code": "        private static final int BUFFER_SIZE = 8_192;\n\n        public void run()\n        {\n            byte[] buffer = new byte[BUFFER_SIZE];\n            while (true)\n            {\n                try"}
{"magic_number_smell": "    @Test\n    public void testMaxValue()\n    {\n        assertSetGetValidThroughput(Integer.MAX_VALUE - 1);\n    }\n\n    @Test", "refactored_code": "    private static final int MAX_INT_CONFIG_VALUE_IN_MBIT = Integer.MAX_VALUE - 1;\n    @Test\n    public void testMaxValue()\n    {\n        assertSetGetValidThroughput(MAX_INT_CONFIG_VALUE_IN_MBIT);\n    }\n\n    @Test"}
{"magic_number_smell": "    @Test\n    public void testMaxValue()\n    {\n        assertSetGetValidThroughput(Integer.MAX_VALUE - 1, Integer.MAX_VALUE - 1 * StreamRateLimiter.BYTES_PER_MEBIBYTE);\n    }\n\n    @Test", "refactored_code": "    private static final int MAX_INT_CONFIG_VALUE_MIB = Integer.MAX_VALUE - 1;\n    @Test\n    public void testMaxValue()\n    {\n        assertSetGetValidThroughput(MAX_INT_CONFIG_VALUE_MIB, MAX_INT_CONFIG_VALUE_MIB * StreamRateLimiter.BYTES_PER_MEBIBYTE);\n    }\n\n    @Test"}
{"magic_number_smell": "    @Test\n    public void testMaxValue()\n    {\n        assertSetGetValidThroughput(Integer.MAX_VALUE - 1, Integer.MAX_VALUE - 1 * StreamRateLimiter.BYTES_PER_MEBIBYTE);\n    }\n\n    @Test", "refactored_code": "    private static final int MAX_INT_CONFIG_VALUE_MIB = Integer.MAX_VALUE - 1;\n    @Test\n    public void testMaxValue()\n    {\n        assertSetGetValidThroughput(MAX_INT_CONFIG_VALUE_MIB, MAX_INT_CONFIG_VALUE_MIB * StreamRateLimiter.BYTES_PER_MEBIBYTE);\n    }\n\n    @Test"}
{"magic_number_smell": "{\n    private static final int Integer.MAX_VALUE - 1 = Integer.MAX_VALUE - 1;\n    private static final double BYTES_PER_MEGABIT = 125_000;\n    private static final int MAX_INT_CONFIG_VALUE_MIB = (int) (Integer.MAX_VALUE - 1 * BYTES_PER_MEGABIT) / 1024 / 1024;\n    private static final double INTEGER_MAX_VALUE_MEGABITS_IN_BYTES = DataRateSpec.LongBytesPerSecondBound\n                                                                      .megabitsPerSecondInBytesPerSecond(Integer.MAX_VALUE - 1)\n                                                                      .toBytesPerSecond();", "refactored_code": "    private static final int MAX_INT_CONFIG_VALUE_IN_MBIT = Integer.MAX_VALUE - 1;\n{\n    private static final int MAX_INT_CONFIG_VALUE_IN_MBIT = Integer.MAX_VALUE - 1;\n    private static final double BYTES_PER_MEGABIT = 125_000;\n    private static final int MAX_INT_CONFIG_VALUE_MIB = (int) (MAX_INT_CONFIG_VALUE_IN_MBIT * BYTES_PER_MEGABIT) / 1024 / 1024;\n    private static final double INTEGER_MAX_VALUE_MEGABITS_IN_BYTES = DataRateSpec.LongBytesPerSecondBound\n                                                                      .megabitsPerSecondInBytesPerSecond(MAX_INT_CONFIG_VALUE_IN_MBIT)\n                                                                      .toBytesPerSecond();"}
{"magic_number_smell": "{\n    private static final int Integer.MAX_VALUE - 1 = Integer.MAX_VALUE - 1;\n    private static final double BYTES_PER_MEGABIT = 125_000;\n    private static final int MAX_INT_CONFIG_VALUE_MIB = (int) (Integer.MAX_VALUE - 1 * BYTES_PER_MEGABIT) / 1024 / 1024;\n    private static final double INTEGER_MAX_VALUE_MEGABITS_IN_BYTES = DataRateSpec.LongBytesPerSecondBound\n                                                                      .megabitsPerSecondInBytesPerSecond(Integer.MAX_VALUE - 1)\n                                                                      .toBytesPerSecond();", "refactored_code": "    private static final int MAX_INT_CONFIG_VALUE_IN_MBIT = Integer.MAX_VALUE - 1;\n{\n    private static final int MAX_INT_CONFIG_VALUE_IN_MBIT = Integer.MAX_VALUE - 1;\n    private static final double BYTES_PER_MEGABIT = 125_000;\n    private static final int MAX_INT_CONFIG_VALUE_MIB = (int) (MAX_INT_CONFIG_VALUE_IN_MBIT * BYTES_PER_MEGABIT) / 1024 / 1024;\n    private static final double INTEGER_MAX_VALUE_MEGABITS_IN_BYTES = DataRateSpec.LongBytesPerSecondBound\n                                                                      .megabitsPerSecondInBytesPerSecond(MAX_INT_CONFIG_VALUE_IN_MBIT)\n                                                                      .toBytesPerSecond();"}
{"magic_number_smell": "    public static void setUp()\n    {\n        DatabaseDescriptor.setNativeTransportReceiveQueueCapacityInBytes(1);\n        DatabaseDescriptor.setNativeTransportMaxRequestDataInFlightPerIpInBytes(600L);\n        DatabaseDescriptor.setNativeTransportConcurrentRequestDataInFlightInBytes(600L);\n\n        requireNetwork();", "refactored_code": "    private static final long LOW_LIMIT = 600L;\n    public static void setUp()\n    {\n        DatabaseDescriptor.setNativeTransportReceiveQueueCapacityInBytes(1);\n        DatabaseDescriptor.setNativeTransportMaxRequestDataInFlightPerIpInBytes(LOW_LIMIT);\n        DatabaseDescriptor.setNativeTransportConcurrentRequestDataInFlightInBytes(LOW_LIMIT);\n\n        requireNetwork();"}
{"magic_number_smell": "    public static void setUp()\n    {\n        requireNetwork();\n        DatabaseDescriptor.setNativeTransportIdleTimeout(2000L);\n    }\n\n    @Test", "refactored_code": "    private static final long TIMEOUT = 2000L;\n    public static void setUp()\n    {\n        requireNetwork();\n        DatabaseDescriptor.setNativeTransportIdleTimeout(TIMEOUT);\n    }\n\n    @Test"}
{"magic_number_smell": "    @Test\n    public void shouldThrowOnOverloadSmallMessages() throws Exception\n    {\n        int payloadSize = 1000 / 4;\n        testOverload(payloadSize, true);\n    }\n", "refactored_code": "    private static final int LARGE_PAYLOAD_THRESHOLD_BYTES = 1000;\n    @Test\n    public void shouldThrowOnOverloadSmallMessages() throws Exception\n    {\n        int payloadSize = LARGE_PAYLOAD_THRESHOLD_BYTES / 4;\n        testOverload(payloadSize, true);\n    }\n"}
{"magic_number_smell": "    {\n        if (min < 0)\n            throw new IllegalArgumentException(\"Asked for negative bytes; given \" + min);\n        if (max > 1 * 1024 * 1024)\n            throw new IllegalArgumentException(\"Requested bytes larger than shared bytes allowed; \" +\n                                               \"asked for \" + max + \" but only have \" + 1 * 1024 * 1024);\n        if (max < min)", "refactored_code": "    private static final int MAX_BLOB_LENGTH = 1 * 1024 * 1024;\n    {\n        if (min < 0)\n            throw new IllegalArgumentException(\"Asked for negative bytes; given \" + min);\n        if (max > MAX_BLOB_LENGTH)\n            throw new IllegalArgumentException(\"Requested bytes larger than shared bytes allowed; \" +\n                                               \"asked for \" + max + \" but only have \" + MAX_BLOB_LENGTH);\n        if (max < min)"}
{"magic_number_smell": "    @Test\n    public void testDecodeBufferDecoratedKey()\n    {\n        for (int i = 0; i < 100; ++i)\n        {\n            BufferDecoratedKey initialBuffer =\n                    (BufferDecoratedKey) ByteOrderedPartitioner.instance.decorateKey(newRandomBytesBuffer());", "refactored_code": "    private static final int NUM_ITERATIONS = 100;\n    @Test\n    public void testDecodeBufferDecoratedKey()\n    {\n        for (int i = 0; i < NUM_ITERATIONS; ++i)\n        {\n            BufferDecoratedKey initialBuffer =\n                    (BufferDecoratedKey) ByteOrderedPartitioner.instance.decorateKey(newRandomBytesBuffer());"}
{"magic_number_smell": "public class MemtableCleanerThreadTest\n{\n    private static final long 5 = 5;\n    private static final long TIMEOUT_MILLIS = TimeUnit.SECONDS.toMillis(5);\n\n    @Mock\n    private MemtablePool pool;", "refactored_code": "    private static final long TIMEOUT_SECONDS = 5;\npublic class MemtableCleanerThreadTest\n{\n    private static final long TIMEOUT_SECONDS = 5;\n    private static final long TIMEOUT_MILLIS = TimeUnit.SECONDS.toMillis(TIMEOUT_SECONDS);\n\n    @Mock\n    private MemtablePool pool;"}
{"magic_number_smell": "                }\n\n                Timer timer = metrics.timer(\"queries\");\n                if (timer.getCount() % 5000 == 0)\n                    logger.info(String.format(\"%d queries, rate = %.2f\", timer.getCount(), timer.getOneMinuteRate()));\n            }\n        }", "refactored_code": "    private static final int PRINT_RATE = 5000;\n                }\n\n                Timer timer = metrics.timer(\"queries\");\n                if (timer.getCount() % PRINT_RATE == 0)\n                    logger.info(String.format(\"%d queries, rate = %.2f\", timer.getCount(), timer.getOneMinuteRate()));\n            }\n        }"}
{"magic_number_smell": "            if (row == null && !finishedHosts.contains(i))\n            {\n                appenders.get(i).writeDocument(wire -> {\n                    wire.write(VERSION).int16(0);\n                    wire.write(TYPE).text(END);\n                });\n                finishedHosts.add(i);", "refactored_code": "    private static final int CURRENT_VERSION = 0;\n            if (row == null && !finishedHosts.contains(i))\n            {\n                appenders.get(i).writeDocument(wire -> {\n                    wire.write(VERSION).int16(CURRENT_VERSION);\n                    wire.write(TYPE).text(END);\n                });\n                finishedHosts.add(i);"}
{"magic_number_smell": "        if (histogram.getTotalCount() != 0)\n        {\n            histogram.setTag(opName);\n            final long relativeStartNs = startNs - nanoTime();\n            final long startMs = (long) (1000 *((epochMs + NANOSECONDS.toMillis(relativeStartNs))/1000.0));\n            histogram.setStartTimeStamp(startMs);\n            final long relativeEndNs = endNs - nanoTime();", "refactored_code": "    private final long epochNs = nanoTime();\n        if (histogram.getTotalCount() != 0)\n        {\n            histogram.setTag(opName);\n            final long relativeStartNs = startNs - epochNs;\n            final long startMs = (long) (1000 *((epochMs + NANOSECONDS.toMillis(relativeStartNs))/1000.0));\n            histogram.setStartTimeStamp(startMs);\n            final long relativeEndNs = endNs - epochNs;"}
{"magic_number_smell": "  }\n\n  public int getMaxIndexRows() {\n    return this.conf.getInt(MAX_INDEX_ROWS, 20000);\n  }\n\n  public final Set<String> getIndexColumns() {", "refactored_code": "  public static final int DEFAULT_MAX_ROWIDS = 20000;\n  }\n\n  public int getMaxIndexRows() {\n    return this.conf.getInt(MAX_INDEX_ROWS, DEFAULT_MAX_ROWIDS);\n  }\n\n  public final Set<String> getIndexColumns() {"}
{"magic_number_smell": "      // TODO: Make script output prefixing configurable. Had to disable this since\n      // it results in lots of test diffs.\n      for (String cmd : cmds) {\n        info(getColorBuffer().pad(SCRIPT_OUTPUT_PREFIX, 5).append(cmd));\n        // if we do not force script execution, abort\n        // when a failure occurs.\n        if (dispatch(cmd) || getOpts().getForce()) {", "refactored_code": "  private static final int SCRIPT_OUTPUT_PAD_SIZE = 5;\n      // TODO: Make script output prefixing configurable. Had to disable this since\n      // it results in lots of test diffs.\n      for (String cmd : cmds) {\n        info(getColorBuffer().pad(SCRIPT_OUTPUT_PREFIX, SCRIPT_OUTPUT_PAD_SIZE).append(cmd));\n        // if we do not force script execution, abort\n        // when a failure occurs.\n        if (dispatch(cmd) || getOpts().getForce()) {"}
{"magic_number_smell": "  private boolean entireLineAsCommand = false;\n  private String numberFormat = \"default\";\n  private final Terminal terminal = TerminalFactory.get();\n  private int maxWidth = 80;\n  private int maxHeight = DEFAULT_MAX_HEIGHT;\n  private int maxColumnWidth = DEFAULT_MAX_COLUMN_WIDTH;\n  int timeout = -1;", "refactored_code": "  public static final int DEFAULT_MAX_WIDTH = 80;\n  private boolean entireLineAsCommand = false;\n  private String numberFormat = \"default\";\n  private final Terminal terminal = TerminalFactory.get();\n  private int maxWidth = DEFAULT_MAX_WIDTH;\n  private int maxHeight = DEFAULT_MAX_HEIGHT;\n  private int maxColumnWidth = DEFAULT_MAX_COLUMN_WIDTH;\n  int timeout = -1;"}
{"magic_number_smell": "  private Runnable createLogRunnable(final Statement statement,\n      InPlaceUpdateStream.EventNotifier eventNotifier) {\n    if (statement instanceof HiveStatement) {\n      return new LogRunnable(this, (HiveStatement) statement, 1000,\n          eventNotifier);\n    } else {\n      beeLine.debug(", "refactored_code": "  private static final int DEFAULT_QUERY_PROGRESS_INTERVAL = 1000;\n  private Runnable createLogRunnable(final Statement statement,\n      InPlaceUpdateStream.EventNotifier eventNotifier) {\n    if (statement instanceof HiveStatement) {\n      return new LogRunnable(this, (HiveStatement) statement, DEFAULT_QUERY_PROGRESS_INTERVAL,\n          eventNotifier);\n    } else {\n      beeLine.debug("}
{"magic_number_smell": "\n  @Test\n  public void testCmd() {\n    verifyCMD(\"show tables;!ls;show tables;\\n\", \"src\", out, null, 0, true);\n  }\n\n  @Test", "refactored_code": "  private static final int ERRNO_OK = 0;\n\n  @Test\n  public void testCmd() {\n    verifyCMD(\"show tables;!ls;show tables;\\n\", \"src\", out, null, ERRNO_OK, true);\n  }\n\n  @Test"}
{"magic_number_smell": "\n    LongWritable key = new LongWritable();\n    BytesRefArrayWritable value = new BytesRefArrayWritable();\n    StringBuilder buf = new StringBuilder(16 * 1024); // extra capacity in case we overrun, to avoid resizing\n    while (recordReader.next(key, value)) {\n      printRecord(value, buf);\n      recordCount++;", "refactored_code": "  private static final int STRING_BUFFER_SIZE = 16 * 1024;\n\n    LongWritable key = new LongWritable();\n    BytesRefArrayWritable value = new BytesRefArrayWritable();\n    StringBuilder buf = new StringBuilder(STRING_BUFFER_SIZE); // extra capacity in case we overrun, to avoid resizing\n    while (recordReader.next(key, value)) {\n      printRecord(value, buf);\n      recordCount++;"}
{"magic_number_smell": "   * @param repeatNum number of retry done so far.\n   */\n  public static int getSleepTime(int repeatNum) {\n    return 100 * (int)(Math.pow(2.0, repeatNum));\n  }\n\n  /**", "refactored_code": "  public static final int IO_ERROR_SLEEP_TIME = 100;\n   * @param repeatNum number of retry done so far.\n   */\n  public static int getSleepTime(int repeatNum) {\n    return IO_ERROR_SLEEP_TIME * (int)(Math.pow(2.0, repeatNum));\n  }\n\n  /**"}
{"magic_number_smell": "  }\n\n  public HeapMemoryMonitor(double threshold) {\n    this.threshold = threshold <= 0.0d || threshold > 1.0d ? 0.7d : threshold;\n    setupTenuredGenPoolThreshold(tenuredGenPool);\n  }\n", "refactored_code": "  private static final double DEFAULT_THRESHOLD = 0.7d;\n  }\n\n  public HeapMemoryMonitor(double threshold) {\n    this.threshold = threshold <= 0.0d || threshold > 1.0d ? DEFAULT_THRESHOLD : threshold;\n    setupTenuredGenPoolThreshold(tenuredGenPool);\n  }\n"}
{"magic_number_smell": "      while (shouldRun) {\n        sw.reset().start();\n        try {\n          Thread.sleep(500);\n        } catch (InterruptedException ie) {\n          return;\n        }", "refactored_code": "  private static final long SLEEP_INTERVAL_MS = 500;\n      while (shouldRun) {\n        sw.reset().start();\n        try {\n          Thread.sleep(SLEEP_INTERVAL_MS);\n        } catch (InterruptedException ie) {\n          return;\n        }"}
{"magic_number_smell": "      int newCapacity = currentCapacity + (currentCapacity >> 1);\n\n      // Check for overflow scenarios\n      if (newCapacity < 0 || newCapacity > Integer.MAX_VALUE - 8) {\n        newCapacity = Integer.MAX_VALUE - 8;\n      } else if (newCapacity < requestCapacity) {\n        newCapacity = requestCapacity;", "refactored_code": "  private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n      int newCapacity = currentCapacity + (currentCapacity >> 1);\n\n      // Check for overflow scenarios\n      if (newCapacity < 0 || newCapacity > MAX_ARRAY_SIZE) {\n        newCapacity = MAX_ARRAY_SIZE;\n      } else if (newCapacity < requestCapacity) {\n        newCapacity = requestCapacity;"}
{"magic_number_smell": "  private static final String FOOTER_FORMAT = \"%-15s  %-30s %-4s  %-25s\";\n\n  private static final int PROGRESS_BAR_CHARS = 30;\n  private static final String SEPARATOR = new String(new char[94]).replace(\"\\0\", \"-\");\n\n  /* Pretty print the values */\n  private final DecimalFormat secondsFormatter = new DecimalFormat(\"#0.00\");", "refactored_code": "  public static final int MIN_TERMINAL_WIDTH = 94;\n  private static final String FOOTER_FORMAT = \"%-15s  %-30s %-4s  %-25s\";\n\n  private static final int PROGRESS_BAR_CHARS = 30;\n  private static final String SEPARATOR = new String(new char[MIN_TERMINAL_WIDTH]).replace(\"\\0\", \"-\");\n\n  /* Pretty print the values */\n  private final DecimalFormat secondsFormatter = new DecimalFormat(\"#0.00\");"}
{"magic_number_smell": "      while ((line = in.readLine()) != null) {\n        logger.info(line);\n        if (errLogs != null) {\n          if (numErrLogLines++ < 1000) {\n            errLogs.add(line);\n          }\n        }", "refactored_code": "  private static final long MAX_ERR_LOG_LINES_FOR_RPC = 1000;\n      while ((line = in.readLine()) != null) {\n        logger.info(line);\n        if (errLogs != null) {\n          if (numErrLogLines++ < MAX_ERR_LOG_LINES_FOR_RPC) {\n            errLogs.add(line);\n          }\n        }"}
{"magic_number_smell": "      throw new ArithmeticException(\n          \"Decimal128 does not support negative scaling\");\n    }\n    if (scale > 38) {\n      throw new ArithmeticException(\"Beyond possible Decimal128 scaling\");\n    }\n  }", "refactored_code": "  public static final short MAX_SCALE = 38;\n      throw new ArithmeticException(\n          \"Decimal128 does not support negative scaling\");\n    }\n    if (scale > MAX_SCALE) {\n      throw new ArithmeticException(\"Beyond possible Decimal128 scaling\");\n    }\n  }"}
{"magic_number_smell": "    if (positive) {\n      return val & FULLBITS_63;\n    }\n    return val | 0x8000000000000000L;\n  }\n\n  /**", "refactored_code": "  public static final long NEGATIVE_LONG_MASK = 0x8000000000000000L;\n    if (positive) {\n      return val & FULLBITS_63;\n    }\n    return val | NEGATIVE_LONG_MASK;\n  }\n\n  /**"}
{"magic_number_smell": "  public static Timestamp stringToTimestamp(final String text) {\n    final String s = Objects.requireNonNull(text).trim();\n    // Handle simpler cases directly avoiding exceptions\n    if (s.length() == \"YYYY-MM-DD\".length()) {\n      Date d = DateParser.parseDate(s);\n      if (d == null) {\n        throw new IllegalArgumentException(\"Cannot parse date: \" + text);", "refactored_code": "  private static final int DATE_LENGTH = \"YYYY-MM-DD\".length();\n  public static Timestamp stringToTimestamp(final String text) {\n    final String s = Objects.requireNonNull(text).trim();\n    // Handle simpler cases directly avoiding exceptions\n    if (s.length() == DATE_LENGTH) {\n      Date d = DateParser.parseDate(s);\n      if (d == null) {\n        throw new IllegalArgumentException(\"Cannot parse date: \" + text);"}
{"magic_number_smell": "  public static final int 4 = 4;\n\n  /** Number of bytes to store this object. */\n  public static final int BYTE_SIZE = 4 * 4;\n\n  /** Can hold up to 10^38. */\n  public static final int MAX_DIGITS = 38;", "refactored_code": "  public static final int INT_COUNT = 4;\n  public static final int INT_COUNT = 4;\n\n  /** Number of bytes to store this object. */\n  public static final int BYTE_SIZE = 4 * INT_COUNT;\n\n  /** Can hold up to 10^38. */\n  public static final int MAX_DIGITS = 38;"}
{"magic_number_smell": "        \"Expected inflation factor between disk/in memory representation of hash tables\"),\n    HIVE_LOG_TRACE_ID(\"hive.log.trace.id\", \"\",\n        \"Log tracing id that can be used by upstream clients for tracking respective logs. \" +\n        \"Truncated to \" + 64 + \" characters. Defaults to use auto-generated session id.\"),\n\n    HIVE_MM_AVOID_GLOBSTATUS_ON_S3(\"hive.mm.avoid.s3.globstatus\", true,\n        \"Whether to use listFiles (optimized on S3) instead of globStatus when on S3.\"),", "refactored_code": "  private static final int LOG_PREFIX_LENGTH = 64;\n        \"Expected inflation factor between disk/in memory representation of hash tables\"),\n    HIVE_LOG_TRACE_ID(\"hive.log.trace.id\", \"\",\n        \"Log tracing id that can be used by upstream clients for tracking respective logs. \" +\n        \"Truncated to \" + LOG_PREFIX_LENGTH + \" characters. Defaults to use auto-generated session id.\"),\n\n    HIVE_MM_AVOID_GLOBSTATUS_ON_S3(\"hive.mm.avoid.s3.globstatus\", true,\n        \"Whether to use listFiles (optimized on S3) instead of globStatus when on S3.\"),"}
{"magic_number_smell": "\n  public static final int 1000000000 = 1000000000;\n  public static final BigDecimal MAX_INT_BD = new BigDecimal(Integer.MAX_VALUE);\n  public static final BigDecimal NANOS_PER_SEC_BD = new BigDecimal(1000000000);\n\n  public static int parseNumericValueWithRange(String fieldName,\n      String strVal, int minValue, int maxValue) throws IllegalArgumentException {", "refactored_code": "  public static final int NANOS_PER_SEC = 1000000000;\n\n  public static final int NANOS_PER_SEC = 1000000000;\n  public static final BigDecimal MAX_INT_BD = new BigDecimal(Integer.MAX_VALUE);\n  public static final BigDecimal NANOS_PER_SEC_BD = new BigDecimal(NANOS_PER_SEC);\n\n  public static int parseNumericValueWithRange(String fieldName,\n      String strVal, int minValue, int maxValue) throws IllegalArgumentException {"}
{"magic_number_smell": "    int markerShift, deltaShift, rcShift;\n\n    public final long setMarker(long dest, long val) {\n      return setValue(dest, val, markerShift, 0xffffL, DELTA_MASK = 0xffL, RC_MASK = 0xffL);\n    }\n\n    public final long setDelta(long dest, long val) {", "refactored_code": "    private static final long MARKER_MASK = 0xffffL, DELTA_MASK = 0xffL, RC_MASK = 0xffL;\n    int markerShift, deltaShift, rcShift;\n\n    public final long setMarker(long dest, long val) {\n      return setValue(dest, val, markerShift, MARKER_MASK);\n    }\n\n    public final long setDelta(long dest, long val) {"}
{"magic_number_smell": "          LOG.info(toStartupShutdownString(\"SHUTDOWN_MSG: \", new String[]{\n            \"Shutting down \" + classname + \" at \" + hostname}));\n        }\n      }, 0);\n\n  }\n", "refactored_code": "  public static final int SHUTDOWN_HOOK_PRIORITY = 0;\n          LOG.info(toStartupShutdownString(\"SHUTDOWN_MSG: \", new String[]{\n            \"Shutting down \" + classname + \" at \" + hostname}));\n        }\n      }, SHUTDOWN_HOOK_PRIORITY);\n\n  }\n"}
{"magic_number_smell": "   * @param timeout timeout of the shutdownHook\n   */\n  public static void addGracefulShutDownHook(Runnable shutdownHook, long timeout) {\n    addShutdownHook(shutdownHook, 1000, timeout);\n  }\n\n  /**", "refactored_code": "  public static final int GRACEFUL_SHUTDOWN_HOOK_PRIORITY = 1000;\n   * @param timeout timeout of the shutdownHook\n   */\n  public static void addGracefulShutDownHook(Runnable shutdownHook, long timeout) {\n    addShutdownHook(shutdownHook, GRACEFUL_SHUTDOWN_HOOK_PRIORITY, timeout);\n  }\n\n  /**"}
{"magic_number_smell": "  }\n\n  public static class BadFormatException extends Exception {\n    private static final long 1L = 1L;\n\n    public BadFormatException(String msg) {\n      super(msg);", "refactored_code": "  private static final long serialVersionUID = 1L;\n  }\n\n  public static class BadFormatException extends Exception {\n    private static final long serialVersionUID = 1L;\n\n    public BadFormatException(String msg) {\n      super(msg);"}
{"magic_number_smell": "        JSON_MAPPER.writeValue(descriptorOut, segment);\n        descriptorOut.flush();\n      }\n    }, RetryPolicies.exponentialBackoffRetry(8, SECONDS_BETWEEN_RETRIES, TimeUnit.SECONDS));\n    descriptorPusher.push();\n  }\n", "refactored_code": "  private static final int NUM_RETRIES = 8;\n        JSON_MAPPER.writeValue(descriptorOut, segment);\n        descriptorOut.flush();\n      }\n    }, RetryPolicies.exponentialBackoffRetry(NUM_RETRIES, SECONDS_BETWEEN_RETRIES, TimeUnit.SECONDS));\n    descriptorPusher.push();\n  }\n"}
{"magic_number_smell": "\n  @Override\n  public LazyObjectBase createKey(ObjectInspector inspector) throws SerDeException {\n    return new FixedLengthed(10);\n  }\n\n  private final ByteStream.Output output = new ByteStream.Output();", "refactored_code": "  private static final int FIXED_LENGTH = 10;\n\n  @Override\n  public LazyObjectBase createKey(ObjectInspector inspector) throws SerDeException {\n    return new FixedLengthed(FIXED_LENGTH);\n  }\n\n  private final ByteStream.Output output = new ByteStream.Output();"}
{"magic_number_smell": "        String comparisonOp = condition.getComparisonOp();\n        String constantVal = String.valueOf(condition.getConstantDesc().getValue());\n\n        byte[] valueAsBytes = toBinary(constantVal, 10, false, false);\n\n        if (comparisonOp.endsWith(\"UDFOPEqualOrGreaterThan\")) {\n          filters.add(new RowFilter(CompareOp.GREATER_OR_EQUAL, new BinaryComparator(valueAsBytes)));", "refactored_code": "  private static final int FIXED_LENGTH = 10;\n        String comparisonOp = condition.getComparisonOp();\n        String constantVal = String.valueOf(condition.getConstantDesc().getValue());\n\n        byte[] valueAsBytes = toBinary(constantVal, FIXED_LENGTH, false, false);\n\n        if (comparisonOp.endsWith(\"UDFOPEqualOrGreaterThan\")) {\n          filters.add(new RowFilter(CompareOp.GREATER_OR_EQUAL, new BinaryComparator(valueAsBytes)));"}
{"magic_number_smell": "   */\n  public static byte findType(Object o) {\n    if (o == null) {\n      return 1;\n    }\n\n    Class<?> clazz = o.getClass();", "refactored_code": "  public static final byte NULL = 1;\n   */\n  public static byte findType(Object o) {\n    if (o == null) {\n      return NULL;\n    }\n\n    Class<?> clazz = o.getClass();"}
{"magic_number_smell": "\n  private final static Logger LOG = LoggerFactory.getLogger(HCatRecordObjectInspectorFactory.class);\n  private static final int 1024 = 1024;\n  private static final int MAX_CACHE_CAPACITY = 10 * 1024;\n\n  private static final CacheBuilder<Object, Object> boundedCache =\n      CacheBuilder.newBuilder()", "refactored_code": "  private static final int INITIAL_CACHE_CAPACITY = 1024;\n\n  private final static Logger LOG = LoggerFactory.getLogger(HCatRecordObjectInspectorFactory.class);\n  private static final int INITIAL_CACHE_CAPACITY = 1024;\n  private static final int MAX_CACHE_CAPACITY = 10 * INITIAL_CACHE_CAPACITY;\n\n  private static final CacheBuilder<Object, Object> boundedCache =\n      CacheBuilder.newBuilder()"}
{"magic_number_smell": "      customDynamicLocationUsed = false;\n    }\n\n    this.maxAppendAttempts = context.getConfiguration().getInt(HCatConstants.HCAT_APPEND_LIMIT, 1000);\n  }\n\n  @Override", "refactored_code": "  private static final int APPEND_COUNTER_WARN_THRESHOLD = 1000;\n      customDynamicLocationUsed = false;\n    }\n\n    this.maxAppendAttempts = context.getConfiguration().getInt(HCatConstants.HCAT_APPEND_LIMIT, APPEND_COUNTER_WARN_THRESHOLD);\n  }\n\n  @Override"}
{"magic_number_smell": "      System.setSecurityManager(new NoExitSecurityManager());\n      hiveConf = new HiveConf(TestHiveClientCache.class);\n      hiveConf.setVar(HiveConf.ConfVars.METASTORE_URIS, \"thrift://localhost:\"\n          + 20101);\n      hiveConf.setIntVar(HiveConf.ConfVars.METASTORE_THRIFT_CONNECTION_RETRIES, 3);\n      hiveConf.setIntVar(HiveConf.ConfVars.METASTORE_THRIFT_FAILURE_RETRIES, 3);\n      hiveConf.set(HiveConf.ConfVars.SEMANTIC_ANALYZER_HOOK.varname,", "refactored_code": "    public final int MS_PORT = 20101;\n      System.setSecurityManager(new NoExitSecurityManager());\n      hiveConf = new HiveConf(TestHiveClientCache.class);\n      hiveConf.setVar(HiveConf.ConfVars.METASTORE_URIS, \"thrift://localhost:\"\n          + MS_PORT);\n      hiveConf.setIntVar(HiveConf.ConfVars.METASTORE_THRIFT_CONNECTION_RETRIES, 3);\n      hiveConf.setIntVar(HiveConf.ConfVars.METASTORE_THRIFT_FAILURE_RETRIES, 3);\n      hiveConf.set(HiveConf.ConfVars.SEMANTIC_ANALYZER_HOOK.varname,"}
{"magic_number_smell": "  @Test\n  public void testGet() throws Exception {\n    HCatRecord r = new LazyHCatRecord(getHCatRecord(), getObjectInspector());\n    Assert.assertEquals(789, ((Integer) r.get(0)).intValue());\n    Assert.assertEquals(LONG_CONST, ((Long) r.get(1)).longValue());\n    Assert.assertEquals(DOUBLE_CONST, ((Double) r.get(2)).doubleValue(), 0);\n    Assert.assertEquals(STRING_CONST, r.get(3));", "refactored_code": "  private final int INT_CONST = 789;\n  @Test\n  public void testGet() throws Exception {\n    HCatRecord r = new LazyHCatRecord(getHCatRecord(), getObjectInspector());\n    Assert.assertEquals(INT_CONST, ((Integer) r.get(0)).intValue());\n    Assert.assertEquals(LONG_CONST, ((Long) r.get(1)).longValue());\n    Assert.assertEquals(DOUBLE_CONST, ((Double) r.get(2)).doubleValue(), 0);\n    Assert.assertEquals(STRING_CONST, r.get(3));"}
{"magic_number_smell": "      String outputFormatClass) throws Exception {\n    super(formatName, serdeClass, inputFormatClass, outputFormatClass);\n    tableName = \"testHCatDynamicPartitionedTable_\" + formatName;\n    generateWriteRecords(20, NUM_TOP_PARTITIONS, 0);\n    generateDataColumns();\n  }\n", "refactored_code": "  protected static final int NUM_RECORDS = 20;\n      String outputFormatClass) throws Exception {\n    super(formatName, serdeClass, inputFormatClass, outputFormatClass);\n    tableName = \"testHCatDynamicPartitionedTable_\" + formatName;\n    generateWriteRecords(NUM_RECORDS, NUM_TOP_PARTITIONS, 0);\n    generateDataColumns();\n  }\n"}
{"magic_number_smell": "   * @param topicName is the name on message broker on which message is sent.\n   */\n  protected void send(HCatEventMessage hCatEventMessage, String topicName) {\n    send(hCatEventMessage, topicName, 1);\n  }\n\n  /**", "refactored_code": "  public static final int NUM_RETRIES = 1;\n   * @param topicName is the name on message broker on which message is sent.\n   */\n  protected void send(HCatEventMessage hCatEventMessage, String topicName) {\n    send(hCatEventMessage, topicName, NUM_RETRIES);\n  }\n\n  /**"}
{"magic_number_smell": "  }\n\n  public void run() {\n    int port = conf.getInt(AppConfig.PORT, 8080);\n    try {\n      checkEnv();\n      runServer(port);", "refactored_code": "  public static final int DEFAULT_PORT = 8080;\n  }\n\n  public void run() {\n    int port = conf.getInt(AppConfig.PORT, DEFAULT_PORT);\n    try {\n      checkEnv();\n      runServer(port);"}
{"magic_number_smell": "    this.database = database;\n    this.tableName = table;\n    this.metadataRefreshMaxRetries =\n        conf.getInt(HIVE_ICEBERG_METADATA_REFRESH_MAX_RETRIES, 2);\n    this.maxHiveTablePropertySize = conf.getLong(HIVE_TABLE_PROPERTY_MAX_SIZE, HIVE_TABLE_PROPERTY_MAX_SIZE_DEFAULT);\n  }\n", "refactored_code": "  private static final int HIVE_ICEBERG_METADATA_REFRESH_MAX_RETRIES_DEFAULT = 2;\n    this.database = database;\n    this.tableName = table;\n    this.metadataRefreshMaxRetries =\n        conf.getInt(HIVE_ICEBERG_METADATA_REFRESH_MAX_RETRIES, HIVE_ICEBERG_METADATA_REFRESH_MAX_RETRIES_DEFAULT);\n    this.maxHiveTablePropertySize = conf.getLong(HIVE_TABLE_PROPERTY_MAX_SIZE, HIVE_TABLE_PROPERTY_MAX_SIZE_DEFAULT);\n  }\n"}
{"magic_number_smell": "    this.tableName = tableName;\n\n    this.lockAcquireTimeout =\n        conf.getLong(HIVE_ACQUIRE_LOCK_TIMEOUT_MS, 3 * 60 * 1000);\n    this.lockCheckMinWaitTime =\n        conf.getLong(HIVE_LOCK_CHECK_MIN_WAIT_MS, HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT);\n    this.lockCheckMaxWaitTime =", "refactored_code": "  private static final long HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n    this.tableName = tableName;\n\n    this.lockAcquireTimeout =\n        conf.getLong(HIVE_ACQUIRE_LOCK_TIMEOUT_MS, HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT);\n    this.lockCheckMinWaitTime =\n        conf.getLong(HIVE_LOCK_CHECK_MIN_WAIT_MS, HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT);\n    this.lockCheckMaxWaitTime ="}
{"magic_number_smell": "                CatalogUtil.ICEBERG_CATALOG_TYPE_HIVE,\n                ImmutableMap.of(\n                    CatalogProperties.CLIENT_POOL_CACHE_EVICTION_INTERVAL_MS,\n                    String.valueOf(TimeUnit.SECONDS.toMillis(10))),\n                hiveConfWithOverrides);\n  }\n", "refactored_code": "  protected static final long EVICTION_INTERVAL = TimeUnit.SECONDS.toMillis(10);\n                CatalogUtil.ICEBERG_CATALOG_TYPE_HIVE,\n                ImmutableMap.of(\n                    CatalogProperties.CLIENT_POOL_CACHE_EVICTION_INTERVAL_MS,\n                    String.valueOf(EVICTION_INTERVAL)),\n                hiveConfWithOverrides);\n  }\n"}
{"magic_number_smell": "   * Starts a TestHiveMetastore with the default connection pool size (5) and the default HiveConf.\n   */\n  public void start() {\n    start(new HiveConf(new Configuration(), TestHiveMetastore.class), 5);\n  }\n\n  /**", "refactored_code": "  private static final int DEFAULT_POOL_SIZE = 5;\n   * Starts a TestHiveMetastore with the default connection pool size (5) and the default HiveConf.\n   */\n  public void start() {\n    start(new HiveConf(new Configuration(), TestHiveMetastore.class), DEFAULT_POOL_SIZE);\n  }\n\n  /**"}
{"magic_number_smell": "    // It gets the config from the FileSinkOperator which has its own config for every target table\n    Table table = HiveIcebergStorageHandler.table(jc, jc.get(hive_metastoreConstants.META_TABLE_NAME));\n    String tableName = jc.get(Catalogs.NAME);\n    int poolSize = jc.getInt(DELETE_FILE_THREAD_POOL_SIZE, 10);\n\n    setWriterLevelConfiguration(jc, table);\n    return WriterBuilder.builderFor(table)", "refactored_code": "  private static final int DELETE_FILE_THREAD_POOL_SIZE_DEFAULT = 10;\n    // It gets the config from the FileSinkOperator which has its own config for every target table\n    Table table = HiveIcebergStorageHandler.table(jc, jc.get(hive_metastoreConstants.META_TABLE_NAME));\n    String tableName = jc.get(Catalogs.NAME);\n    int poolSize = jc.getInt(DELETE_FILE_THREAD_POOL_SIZE, DELETE_FILE_THREAD_POOL_SIZE_DEFAULT);\n\n    setWriterLevelConfiguration(jc, table);\n    return WriterBuilder.builderFor(table)"}
{"magic_number_smell": "        String[] row =\n            fetcher.convert(currSerDe.deserialize(value), currSerDe.getObjectInspector())\n                .toString().split(\"\\t\");\n        parts.add(HiveTableUtil.getParseData(row[PART_IDX], row[1], mapper, tbl.spec().specId()));\n      }\n    }\n    Collections.sort(parts);", "refactored_code": "  private static final int SPEC_IDX = 1;\n        String[] row =\n            fetcher.convert(currSerDe.deserialize(value), currSerDe.getObjectInspector())\n                .toString().split(\"\\t\");\n        parts.add(HiveTableUtil.getParseData(row[PART_IDX], row[SPEC_IDX], mapper, tbl.spec().specId()));\n      }\n    }\n    Collections.sort(parts);"}
{"magic_number_smell": "public final class ParquetFooterInputFromCache\n    extends SeekableInputStream implements InputFile {\n  public static final int 4 = 4; // For the file size check.\n  private static final int TAIL_LENGTH = ParquetFileWriter.MAGIC.length + 4;\n  private static final int FAKE_PREFIX_LENGTH = ParquetFileWriter.MAGIC.length;\n  private final int length;\n  private final int footerLength;", "refactored_code": "  public static final int FOOTER_LENGTH_SIZE = 4; // For the file size check.\npublic final class ParquetFooterInputFromCache\n    extends SeekableInputStream implements InputFile {\n  public static final int FOOTER_LENGTH_SIZE = 4; // For the file size check.\n  private static final int TAIL_LENGTH = ParquetFileWriter.MAGIC.length + FOOTER_LENGTH_SIZE;\n  private static final int FAKE_PREFIX_LENGTH = ParquetFileWriter.MAGIC.length;\n  private final int length;\n  private final int footerLength;"}
{"magic_number_smell": "    }\n\n    protected int getMaxEntries() {\n      return 20;\n    }\n\n    @Override", "refactored_code": "    private static final int MAX_ENTRIES = 20;\n    }\n\n    protected int getMaxEntries() {\n      return MAX_ENTRIES;\n    }\n\n    @Override"}
{"magic_number_smell": "   */\n  private List<Record> writeRecords(String name, int taskNum, int attemptNum, boolean commitTasks, boolean abortTasks,\n                                    JobConf conf, OutputCommitter committer) throws IOException {\n    List<Record> expected = Lists.newArrayListWithExpectedSize(5 * taskNum);\n\n    Table table = HiveIcebergStorageHandler.table(conf, name);\n    Schema schema = HiveIcebergStorageHandler.schema(conf);", "refactored_code": "  private static final int RECORD_NUM = 5;\n   */\n  private List<Record> writeRecords(String name, int taskNum, int attemptNum, boolean commitTasks, boolean abortTasks,\n                                    JobConf conf, OutputCommitter committer) throws IOException {\n    List<Record> expected = Lists.newArrayListWithExpectedSize(RECORD_NUM * taskNum);\n\n    Table table = HiveIcebergStorageHandler.table(conf, name);\n    Schema schema = HiveIcebergStorageHandler.schema(conf);"}
{"magic_number_smell": "        conf.setVar(HiveConf.ConfVars.METASTORE_RAW_STORE_IMPL, DummyRawStoreFailEvent.class.getName());\n        MetastoreConf.setVar(conf, MetastoreConf.ConfVars.EVENT_MESSAGE_FACTORY, JSONMessageEncoder.class.getName());\n        MetastoreConf.setTimeVar(conf, MetastoreConf.ConfVars.EVENT_DB_LISTENER_CLEAN_INTERVAL, CLEANUP_SLEEP_TIME, TimeUnit.SECONDS);\n        MetastoreConf.setTimeVar(conf, MetastoreConf.ConfVars.EVENT_DB_LISTENER_TTL, 30, TimeUnit.SECONDS);\n        MetastoreConf.setTimeVar(conf, EVENT_DB_LISTENER_CLEAN_STARTUP_WAIT_INTERVAL, 20, TimeUnit.SECONDS);\n        conf.setVar(HiveConf.ConfVars.HIVE_AUTHORIZATION_MANAGER,\n                \"org.apache.hadoop.hive.ql.security.authorization.plugin.sqlstd.SQLStdHiveAuthorizerFactory\");", "refactored_code": "    private static final int EVENTS_TTL = 30;\n        conf.setVar(HiveConf.ConfVars.METASTORE_RAW_STORE_IMPL, DummyRawStoreFailEvent.class.getName());\n        MetastoreConf.setVar(conf, MetastoreConf.ConfVars.EVENT_MESSAGE_FACTORY, JSONMessageEncoder.class.getName());\n        MetastoreConf.setTimeVar(conf, MetastoreConf.ConfVars.EVENT_DB_LISTENER_CLEAN_INTERVAL, CLEANUP_SLEEP_TIME, TimeUnit.SECONDS);\n        MetastoreConf.setTimeVar(conf, MetastoreConf.ConfVars.EVENT_DB_LISTENER_TTL, EVENTS_TTL, TimeUnit.SECONDS);\n        MetastoreConf.setTimeVar(conf, EVENT_DB_LISTENER_CLEAN_STARTUP_WAIT_INTERVAL, 20, TimeUnit.SECONDS);\n        conf.setVar(HiveConf.ConfVars.HIVE_AUTHORIZATION_MANAGER,\n                \"org.apache.hadoop.hive.ql.security.authorization.plugin.sqlstd.SQLStdHiveAuthorizerFactory\");"}
{"magic_number_smell": "    conf.setVar(HiveConf.ConfVars.METASTORE_TRANSACTIONAL_EVENT_LISTENERS,\n        DbNotificationListener.class.getName());\n    conf.setVar(HiveConf.ConfVars.METASTORE_EVENT_LISTENERS, MockMetaStoreEventListener.class.getName());\n    conf.setVar(HiveConf.ConfVars.METASTORE_EVENT_DB_LISTENER_TTL, String.valueOf(30) + \"s\");\n    conf.setBoolVar(HiveConf.ConfVars.HIVE_SUPPORT_CONCURRENCY, false);\n    conf.setBoolVar(HiveConf.ConfVars.FIRE_EVENTS_FOR_DML, true);\n    conf.setVar(HiveConf.ConfVars.METASTORE_RAW_STORE_IMPL, DummyRawStoreFailEvent.class.getName());", "refactored_code": "  private static final int EVENTS_TTL = 30;\n    conf.setVar(HiveConf.ConfVars.METASTORE_TRANSACTIONAL_EVENT_LISTENERS,\n        DbNotificationListener.class.getName());\n    conf.setVar(HiveConf.ConfVars.METASTORE_EVENT_LISTENERS, MockMetaStoreEventListener.class.getName());\n    conf.setVar(HiveConf.ConfVars.METASTORE_EVENT_DB_LISTENER_TTL, String.valueOf(EVENTS_TTL) + \"s\");\n    conf.setBoolVar(HiveConf.ConfVars.HIVE_SUPPORT_CONCURRENCY, false);\n    conf.setBoolVar(HiveConf.ConfVars.FIRE_EVENTS_FOR_DML, true);\n    conf.setVar(HiveConf.ConfVars.METASTORE_RAW_STORE_IMPL, DummyRawStoreFailEvent.class.getName());"}
{"magic_number_smell": "        throw new RuntimeException(\"timestamps are not equal in bench as expected\");\n      }\n\n      for (int j = 0; j < 50000L; j++) {\n        l1 = PrimitiveObjectInspectorUtils.getTimestamp(v1,\n            (PrimitiveObjectInspector) expressionDef.getOI());\n        l2 = PrimitiveObjectInspectorUtils.getTimestamp(v2,", "refactored_code": "  private static final long INNER_ITERATIONS = 50000L;\n        throw new RuntimeException(\"timestamps are not equal in bench as expected\");\n      }\n\n      for (int j = 0; j < INNER_ITERATIONS; j++) {\n        l1 = PrimitiveObjectInspectorUtils.getTimestamp(v1,\n            (PrimitiveObjectInspector) expressionDef.getOI());\n        l2 = PrimitiveObjectInspectorUtils.getTimestamp(v2,"}
{"magic_number_smell": "\n    public SizeOptimizedSparseStressN(int stressN) {\n      this.stressN = stressN;\n      numIterations = 1000000 / stressN;\n    }\n\n    @Override", "refactored_code": "  public static final int DEFAULT_ITER_TIME = 1000000;\n\n    public SizeOptimizedSparseStressN(int stressN) {\n      this.stressN = stressN;\n      numIterations = DEFAULT_ITER_TIME / stressN;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public void bench() {\n      for (int i = 0; i < 1000000; i++) {\n        obj.init(ref, offsets[i % sizes.length], sizes[i % sizes.length]);\n      }\n    }", "refactored_code": "  public static final int DEFAULT_ITER_TIME = 1000000;\n\n    @Override\n    public void bench() {\n      for (int i = 0; i < DEFAULT_ITER_TIME; i++) {\n        obj.init(ref, offsets[i % sizes.length], sizes[i % sizes.length]);\n      }\n    }"}
{"magic_number_smell": "  @Warmup(iterations = 2, time = 2, timeUnit = TimeUnit.MILLISECONDS)\n  @Measurement(iterations = 2, time = 2, timeUnit = TimeUnit.MILLISECONDS)\n  public void bench() throws HiveException {\n    for (int i = 0; i < 1000000; i++) {\n      rowBatch.selectedInUse = false;\n      rowBatch.size = VectorizedRowBatch.DEFAULT_SIZE;\n", "refactored_code": "  private static final int DEFAULT_ITER_TIME = 1000000;\n  @Warmup(iterations = 2, time = 2, timeUnit = TimeUnit.MILLISECONDS)\n  @Measurement(iterations = 2, time = 2, timeUnit = TimeUnit.MILLISECONDS)\n  public void bench() throws HiveException {\n    for (int i = 0; i < DEFAULT_ITER_TIME; i++) {\n      rowBatch.selectedInUse = false;\n      rowBatch.size = VectorizedRowBatch.DEFAULT_SIZE;\n"}
{"magic_number_smell": "  private static MiniHiveKdc miniHiveKdc = null;\n\n  @ClassRule\n  public static final WireMockRule MOCK_JWKS_SERVER = new WireMockRule(8089);\n\n  @BeforeClass\n  public static void setUpBeforeClass() throws Exception {", "refactored_code": "  private static final int MOCK_JWKS_SERVER_PORT = 8089;\n  private static MiniHiveKdc miniHiveKdc = null;\n\n  @ClassRule\n  public static final WireMockRule MOCK_JWKS_SERVER = new WireMockRule(MOCK_JWKS_SERVER_PORT);\n\n  @BeforeClass\n  public static void setUpBeforeClass() throws Exception {"}
{"magic_number_smell": "    new File(\"src/test/resources/auth.jwt/jwt-verification-jwks.json\");\n\n  @ClassRule\n  public static final WireMockRule MOCK_JWKS_SERVER = new WireMockRule(8089);\n\n  @Before\n  public void setUp() throws Exception {", "refactored_code": "  private static final int MOCK_JWKS_SERVER_PORT = 8089;\n    new File(\"src/test/resources/auth.jwt/jwt-verification-jwks.json\");\n\n  @ClassRule\n  public static final WireMockRule MOCK_JWKS_SERVER = new WireMockRule(MOCK_JWKS_SERVER_PORT);\n\n  @Before\n  public void setUp() throws Exception {"}
{"magic_number_smell": "  }\n\n  private void addHouseKeepingThreadConfigs() throws Exception {\n    conf.setTimeDuration(METASTORE_THREAD_TASK_FREQ_CONF, 1,\n                          TimeUnit.MILLISECONDS);\n    addStatsUpdaterThreadConfigs();\n    addReplChangeManagerConfigs();", "refactored_code": "  private static final long REMOTE_TASKS_INTERVAL = 1;\n  }\n\n  private void addHouseKeepingThreadConfigs() throws Exception {\n    conf.setTimeDuration(METASTORE_THREAD_TASK_FREQ_CONF, REMOTE_TASKS_INTERVAL,\n                          TimeUnit.MILLISECONDS);\n    addStatsUpdaterThreadConfigs();\n    addReplChangeManagerConfigs();"}
{"magic_number_smell": "      next = Integer.parseInt(ReplDumpWork.getTestInjectDumpDir()) + 1;\n      Path ackPath = new Path(dumpRoot, String.valueOf(next) + File.separator + ReplUtils.REPL_HIVE_BASE_DIR\n              + File.separator + ReplAck.LOAD_ACKNOWLEDGEMENT.toString());\n      waitForAck(fs, ackPath, 5 * 60 * 1000L);\n      replica.run(\"use \" + replicatedDbName)\n              .run(\"show tables like 't1'\")\n              .verifyResult(\"t1\")", "refactored_code": "  private static final long DEFAULT_PROBE_TIMEOUT = 5 * 60 * 1000L; // 5 minutes\n      next = Integer.parseInt(ReplDumpWork.getTestInjectDumpDir()) + 1;\n      Path ackPath = new Path(dumpRoot, String.valueOf(next) + File.separator + ReplUtils.REPL_HIVE_BASE_DIR\n              + File.separator + ReplAck.LOAD_ACKNOWLEDGEMENT.toString());\n      waitForAck(fs, ackPath, DEFAULT_PROBE_TIMEOUT);\n      replica.run(\"use \" + replicatedDbName)\n              .run(\"show tables like 't1'\")\n              .verifyResult(\"t1\")"}
{"magic_number_smell": "    // getXXX returns 0 for numeric types, false for boolean and null for other\n    assertEquals(0, res.getInt(1));\n    assertEquals(false, res.getBoolean(2));\n    assertEquals(0d, res.getDouble(3), 0.0001f);\n    assertEquals(null, res.getString(4));\n    assertEquals(null, res.getString(5));\n    assertEquals(null, res.getString(6));", "refactored_code": "  private static final float floatCompareDelta = 0.0001f;\n    // getXXX returns 0 for numeric types, false for boolean and null for other\n    assertEquals(0, res.getInt(1));\n    assertEquals(false, res.getBoolean(2));\n    assertEquals(0d, res.getDouble(3), floatCompareDelta);\n    assertEquals(null, res.getString(4));\n    assertEquals(null, res.getString(5));\n    assertEquals(null, res.getString(6));"}
{"magic_number_smell": "    // getXXX returns 0 for numeric types, false for boolean and null for other\n    assertEquals(0, res.getInt(1));\n    assertEquals(false, res.getBoolean(2));\n    assertEquals(0d, res.getDouble(3), 0.0001f);\n    assertEquals(null, res.getString(4));\n    assertEquals(null, res.getString(5));\n    assertEquals(null, res.getString(6));", "refactored_code": "  private static final float floatCompareDelta = 0.0001f;\n    // getXXX returns 0 for numeric types, false for boolean and null for other\n    assertEquals(0, res.getInt(1));\n    assertEquals(false, res.getBoolean(2));\n    assertEquals(0d, res.getDouble(3), floatCompareDelta);\n    assertEquals(null, res.getString(4));\n    assertEquals(null, res.getString(5));\n    assertEquals(null, res.getString(6));"}
{"magic_number_smell": "\n  private static final int 8089 = 8089;\n  @ClassRule\n  public static final WireMockRule MOCK_JWKS_SERVER = new WireMockRule(8089);\n\n  /**\n   * This is a hack to make environment variables modifiable.", "refactored_code": "  private static final int MOCK_JWKS_SERVER_PORT = 8089;\n\n  private static final int MOCK_JWKS_SERVER_PORT = 8089;\n  @ClassRule\n  public static final WireMockRule MOCK_JWKS_SERVER = new WireMockRule(MOCK_JWKS_SERVER_PORT);\n\n  /**\n   * This is a hack to make environment variables modifiable."}
{"magic_number_smell": "  }\n\n  private CuratorFramework getClient() {\n    return CuratorFrameworkFactory.builder().connectString(server.getConnectString()).sessionTimeoutMs(1000 * 100)\n        .connectionTimeoutMs(1000).retryPolicy(new RetryOneTime(1)).build();\n  }\n", "refactored_code": "  private static final int TIMEOUT = 1000;\n  }\n\n  private CuratorFramework getClient() {\n    return CuratorFrameworkFactory.builder().connectString(server.getConnectString()).sessionTimeoutMs(TIMEOUT * 100)\n        .connectionTimeoutMs(TIMEOUT).retryPolicy(new RetryOneTime(1)).build();\n  }\n"}
{"magic_number_smell": "\n  @Parameters(name = \"{0}\")\n  public static List<Object[]> getParameters() throws Exception {\n    return SplitSupport.process(adapter.getParameters(), TestCliDriver.class, 17);\n  }\n\n  @ClassRule", "refactored_code": "  private static final int N_SPLITS = 17;\n\n  @Parameters(name = \"{0}\")\n  public static List<Object[]> getParameters() throws Exception {\n    return SplitSupport.process(adapter.getParameters(), TestCliDriver.class, N_SPLITS);\n  }\n\n  @ClassRule"}
{"magic_number_smell": "\n  @Parameters(name = \"{0}\")\n  public static List<Object[]> getParameters() throws Exception {\n    return SplitSupport.process(adapter.getParameters(), TestEncryptedHDFSCliDriver.class, 3);\n  }\n\n  @ClassRule", "refactored_code": "  private static final int N_SPLITS = 3;\n\n  @Parameters(name = \"{0}\")\n  public static List<Object[]> getParameters() throws Exception {\n    return SplitSupport.process(adapter.getParameters(), TestEncryptedHDFSCliDriver.class, N_SPLITS);\n  }\n\n  @ClassRule"}
{"magic_number_smell": "\n  @Parameters(name = \"{0}\")\n  public static List<Object[]> getParameters() throws Exception {\n    return SplitSupport.process(adapter.getParameters(), TestMiniLlapCliDriver.class, 3);\n  }\n\n  @ClassRule", "refactored_code": "  private static final int N_SPLITS = 3;\n\n  @Parameters(name = \"{0}\")\n  public static List<Object[]> getParameters() throws Exception {\n    return SplitSupport.process(adapter.getParameters(), TestMiniLlapCliDriver.class, N_SPLITS);\n  }\n\n  @ClassRule"}
{"magic_number_smell": "   * @param port the port to check for availability\n   */\n  public static boolean available(int port) {\n    if (port < 60000 || port > MAX_PORT_NUMBER) {\n      throw new IllegalArgumentException(\"Invalid start port: \" + port);\n    }\n", "refactored_code": "  private static final int MIN_PORT_NUMBER = 60000;\n   * @param port the port to check for availability\n   */\n  public static boolean available(int port) {\n    if (port < MIN_PORT_NUMBER || port > MAX_PORT_NUMBER) {\n      throw new IllegalArgumentException(\"Invalid start port: \" + port);\n    }\n"}
{"magic_number_smell": "  public SingleNodeKafkaCluster(String name, String logDir, Integer zkPort, Integer brokerPort){\n    super(name);\n    Properties properties = new Properties();\n    this.brokerPort = brokerPort == null ? 9092 : brokerPort;\n    File dir = new File(logDir);\n    if (dir.exists()) {\n      // need to clean data directory to ensure that there is no interference from old runs", "refactored_code": "  private static final int BROKER_PORT = 9092;\n  public SingleNodeKafkaCluster(String name, String logDir, Integer zkPort, Integer brokerPort){\n    super(name);\n    Properties properties = new Properties();\n    this.brokerPort = brokerPort == null ? BROKER_PORT : brokerPort;\n    File dir = new File(logDir);\n    if (dir.exists()) {\n      // need to clean data directory to ensure that there is no interference from old runs"}
{"magic_number_smell": "    util = new HBaseTestingUtility(hbaseConf);\n\n    util.startMiniDFSCluster(1);\n    hbaseCluster = util.startMiniHBaseCluster(1, 1);\n    hbaseConn = util.getConnection();\n\n    // opening the META table ensures that cluster is running", "refactored_code": "  private static final int NUM_REGIONSERVERS = 1;\n    util = new HBaseTestingUtility(hbaseConf);\n\n    util.startMiniDFSCluster(1);\n    hbaseCluster = util.startMiniHBaseCluster(1, NUM_REGIONSERVERS);\n    hbaseConn = util.getConnection();\n\n    // opening the META table ensures that cluster is running"}
{"magic_number_smell": "  }\n\n  private String truncatefNeeded(String orig) {\n    if (orig.length() > 2000) {\n      return orig.substring(0, 2000) + \"\\r\\n\" + TRUNCATED_OUTPUT;\n    } else {\n      return orig;", "refactored_code": "  private static final short MAX_OUTPUT_CHAR_LENGTH = 2000;\n  }\n\n  private String truncatefNeeded(String orig) {\n    if (orig.length() > MAX_OUTPUT_CHAR_LENGTH) {\n      return orig.substring(0, MAX_OUTPUT_CHAR_LENGTH) + \"\\r\\n\" + TRUNCATED_OUTPUT;\n    } else {\n      return orig;"}
{"magic_number_smell": "              printDockerEvents();\n              throw new RuntimeException(\"Failed to get docker logs\");\n            }\n        } while (startTime + 5 * 60 * 1000 >= System.currentTimeMillis() && !isContainerReady(pr));\n        if (startTime + 5 * 60 * 1000 < System.currentTimeMillis()) {\n          printDockerEvents();\n          throw new RuntimeException(", "refactored_code": "    private static final int MAX_STARTUP_WAIT = 5 * 60 * 1000;\n              printDockerEvents();\n              throw new RuntimeException(\"Failed to get docker logs\");\n            }\n        } while (startTime + MAX_STARTUP_WAIT >= System.currentTimeMillis() && !isContainerReady(pr));\n        if (startTime + MAX_STARTUP_WAIT < System.currentTimeMillis()) {\n          printDockerEvents();\n          throw new RuntimeException("}
{"magic_number_smell": "    private boolean isMetastoreSecure;\n    private String metastoreServerPrincipal;\n    private String metastoreServerKeyTab;\n    private int dataNodes = 4; // default number of datanodes for miniHS2\n\n    public Builder() {\n    }", "refactored_code": "  private static final int DEFAULT_DATANODE_COUNT = 4;\n    private boolean isMetastoreSecure;\n    private String metastoreServerPrincipal;\n    private String metastoreServerKeyTab;\n    private int dataNodes = DEFAULT_DATANODE_COUNT; // default number of datanodes for miniHS2\n\n    public Builder() {\n    }"}
{"magic_number_smell": "  }\n\n  /**\n   *  Returns the value of 128.\n   *\n   */\n  public int getMaxColumnNameLength() throws SQLException {", "refactored_code": "  private static final int maxColumnNameLength = 128;\n  }\n\n  /**\n   *  Returns the value of maxColumnNameLength.\n   *\n   */\n  public int getMaxColumnNameLength() throws SQLException {"}
{"magic_number_smell": "    timeoutInMs = Integer.parseInt(\n        connectionParams.getSessionVars()\n            .getOrDefault(JdbcConnectionParams.AUTH_BROWSER_RESPONSE_TIMEOUT_SECS,\n                String.valueOf(120))) * 1000L;\n  }\n\n  @Override", "refactored_code": "  private static final int DEFAULT_SOCKET_TIMEOUT_SECS = 120;\n    timeoutInMs = Integer.parseInt(\n        connectionParams.getSessionVars()\n            .getOrDefault(JdbcConnectionParams.AUTH_BROWSER_RESPONSE_TIMEOUT_SECS,\n                String.valueOf(DEFAULT_SOCKET_TIMEOUT_SECS))) * 1000L;\n  }\n\n  @Override"}
{"magic_number_smell": "\n\n  protected int getFetchSize(Configuration conf) {\n    return conf.getInt(JdbcStorageConfig.JDBC_FETCH_SIZE.getPropertyName(), 1000);\n  }\n\n  @Override", "refactored_code": "  protected static final int DEFAULT_FETCH_SIZE = 1000;\n\n\n  protected int getFetchSize(Configuration conf) {\n    return conf.getInt(JdbcStorageConfig.JDBC_FETCH_SIZE.getPropertyName(), DEFAULT_FETCH_SIZE);\n  }\n\n  @Override"}
{"magic_number_smell": "\n  private static long nextRetrySleepMillis(final int nTry) {\n    final double fuzzyMultiplier = Math.min(Math.max(1 + 0.2 * ThreadLocalRandom.current().nextGaussian(), 0), 2);\n    return (long) (Math.min(60000, BASE_SLEEP_MILLIS * Math.pow(2, nTry - 1)) * fuzzyMultiplier);\n  }\n}\n", "refactored_code": "  private static final long MAX_SLEEP_MILLIS = 60000;\n\n  private static long nextRetrySleepMillis(final int nTry) {\n    final double fuzzyMultiplier = Math.min(Math.max(1 + 0.2 * ThreadLocalRandom.current().nextGaussian(), 0), 2);\n    return (long) (Math.min(MAX_SLEEP_MILLIS, BASE_SLEEP_MILLIS * Math.pow(2, nTry - 1)) * fuzzyMultiplier);\n  }\n}\n"}
{"magic_number_smell": "  private static final String TOPIC = \"test-tx-producer\";\n  private static final List<ProducerRecord<byte[], byte[]>>\n      RECORDS =\n      IntStream.range(0, 17384).mapToObj(number -> {\n        final byte[] value = (\"VALUE-\" + number).getBytes(StandardCharsets.UTF_8);\n        return new ProducerRecord<>(TOPIC, value, KEY_BYTES);\n      }).collect(Collectors.toList());", "refactored_code": "  private static final int RECORD_NUMBER = 17384;\n  private static final String TOPIC = \"test-tx-producer\";\n  private static final List<ProducerRecord<byte[], byte[]>>\n      RECORDS =\n      IntStream.range(0, RECORD_NUMBER).mapToObj(number -> {\n        final byte[] value = (\"VALUE-\" + number).getBytes(StandardCharsets.UTF_8);\n        return new ProducerRecord<>(TOPIC, value, KEY_BYTES);\n      }).collect(Collectors.toList());"}
{"magic_number_smell": "  }\n\n  private static List<ConsumerRecord<byte[], byte[]>> getRecords(String topic) {\n    return IntStream.range(0, 19384).mapToObj(number -> {\n      final byte[] value = (\"VALUE-\" + Integer.toString(number)).getBytes(Charset.forName(\"UTF-8\"));\n      return new ConsumerRecord<>(topic, 0, (long) number, 0L, null, 0L, 0, 0, KEY_BYTES, value);\n    }).collect(Collectors.toList());", "refactored_code": "  private static final int RECORD_NUMBER = 19384;\n  }\n\n  private static List<ConsumerRecord<byte[], byte[]>> getRecords(String topic) {\n    return IntStream.range(0, RECORD_NUMBER).mapToObj(number -> {\n      final byte[] value = (\"VALUE-\" + Integer.toString(number)).getBytes(Charset.forName(\"UTF-8\"));\n      return new ConsumerRecord<>(topic, 0, (long) number, 0L, null, 0L, 0, 0, KEY_BYTES, value);\n    }).collect(Collectors.toList());"}
{"magic_number_smell": "    private static final KafkaBrokerResource KAFKA_BROKER_RESOURCE = new KafkaBrokerResource();\n\n    private static List<ConsumerRecord<byte[], byte[]>> getRecords(String topic) {\n        return IntStream.range(0, 17384).mapToObj(number -> {\n            final byte[] value = (\"VALUE-\" + Integer.toString(number)).getBytes(Charset.forName(\"UTF-8\"));\n            return new ConsumerRecord<>(topic, 0, (long) number, 0L, null, 0L, 0, 0, KEY_BYTES, value);\n        }).collect(Collectors.toList());", "refactored_code": "    private static final int RECORD_NUMBER = 17384;\n    private static final KafkaBrokerResource KAFKA_BROKER_RESOURCE = new KafkaBrokerResource();\n\n    private static List<ConsumerRecord<byte[], byte[]>> getRecords(String topic) {\n        return IntStream.range(0, RECORD_NUMBER).mapToObj(number -> {\n            final byte[] value = (\"VALUE-\" + Integer.toString(number)).getBytes(Charset.forName(\"UTF-8\"));\n            return new ConsumerRecord<>(topic, 0, (long) number, 0L, null, 0L, 0, 0, KEY_BYTES, value);\n        }).collect(Collectors.toList());"}
{"magic_number_smell": "  private static final byte[] KEY_BYTES = \"KEY\".getBytes(Charset.forName(\"UTF-8\"));\n  private static final KafkaBrokerResource KAFKA_BROKER_RESOURCE = new KafkaBrokerResource();\n  private static final List<KafkaWritable> RECORDS_WRITABLES = IntStream\n      .range(0, 17384)\n      .mapToObj(number -> {\n        final byte[] value = (\"VALUE-\" + Integer.toString(number)).getBytes(Charset.forName(\"UTF-8\"));\n        return new KafkaWritable(0, (long) number, value, KEY_BYTES);", "refactored_code": "  private static final int RECORD_NUMBER = 17384;\n  private static final byte[] KEY_BYTES = \"KEY\".getBytes(Charset.forName(\"UTF-8\"));\n  private static final KafkaBrokerResource KAFKA_BROKER_RESOURCE = new KafkaBrokerResource();\n  private static final List<KafkaWritable> RECORDS_WRITABLES = IntStream\n      .range(0, RECORD_NUMBER)\n      .mapToObj(number -> {\n        final byte[] value = (\"VALUE-\" + Integer.toString(number)).getBytes(Charset.forName(\"UTF-8\"));\n        return new KafkaWritable(0, (long) number, value, KEY_BYTES);"}
{"magic_number_smell": "  private static final int 1000 = 1000;\n  private static final byte[] KEY_BYTES = \"key\".getBytes();\n  private static final List<KafkaWritable> RECORDS_WRITABLES = IntStream\n      .range(0, 1000)\n      .mapToObj(number -> {\n        final byte[] value = (\"VALUE-\" + Integer.toString(number)).getBytes(Charset.forName(\"UTF-8\"));\n        return new KafkaWritable(0, (long) number, value, KEY_BYTES);", "refactored_code": "  private static final int RECORD_NUMBER = 1000;\n  private static final int RECORD_NUMBER = 1000;\n  private static final byte[] KEY_BYTES = \"key\".getBytes();\n  private static final List<KafkaWritable> RECORDS_WRITABLES = IntStream\n      .range(0, RECORD_NUMBER)\n      .mapToObj(number -> {\n        final byte[] value = (\"VALUE-\" + Integer.toString(number)).getBytes(Charset.forName(\"UTF-8\"));\n        return new KafkaWritable(0, (long) number, value, KEY_BYTES);"}
{"magic_number_smell": "    ROW.addDouble(\"double\", 1.1d);\n    ROW.addString(\"string\", \"one\");\n    ROW.addBinary(\"binary\", \"one\".getBytes(UTF_8));\n    ROW.addTimestamp(\"timestamp\", new Timestamp(System.currentTimeMillis()));\n    ROW.addDecimal(\"decimal\", new BigDecimal(\"1.111\"));\n    ROW.setNull(\"null\");\n    // Not setting the \"default\" column.", "refactored_code": "  private static final long NOW_MS = System.currentTimeMillis();\n    ROW.addDouble(\"double\", 1.1d);\n    ROW.addString(\"string\", \"one\");\n    ROW.addBinary(\"binary\", \"one\".getBytes(UTF_8));\n    ROW.addTimestamp(\"timestamp\", new Timestamp(NOW_MS));\n    ROW.addDecimal(\"decimal\", new BigDecimal(\"1.111\"));\n    ROW.setNull(\"null\");\n    // Not setting the \"default\" column."}
{"magic_number_smell": "      row.addDouble(\"double\", 1.1d);\n      row.addString(\"string\", \"one\");\n      row.addBinary(\"binary\", \"one\".getBytes(UTF_8));\n      row.addTimestamp(\"timestamp\", new Timestamp(System.currentTimeMillis()));\n      row.addDecimal(\"decimal\", new BigDecimal(\"1.111\"));\n      row.setNull(\"null\");\n      // Not setting the \"default\" column.", "refactored_code": "  private static final long NOW_MS = System.currentTimeMillis();\n      row.addDouble(\"double\", 1.1d);\n      row.addString(\"string\", \"one\");\n      row.addBinary(\"binary\", \"one\".getBytes(UTF_8));\n      row.addTimestamp(\"timestamp\", new Timestamp(NOW_MS));\n      row.addDecimal(\"decimal\", new BigDecimal(\"1.111\"));\n      row.setNull(\"null\");\n      // Not setting the \"default\" column."}
{"magic_number_smell": "    ROW.addDouble(\"double\", 1.1d);\n    ROW.addString(\"string\", \"one\");\n    ROW.addBinary(\"binary\", \"one\".getBytes(UTF_8));\n    ROW.addTimestamp(\"timestamp\", new Timestamp(System.currentTimeMillis()));\n    ROW.addDecimal(\"decimal\", new BigDecimal(\"1.111\"));\n    ROW.setNull(\"null\");\n    // Not setting the \"default\" column.", "refactored_code": "  private static final long NOW_MS = System.currentTimeMillis();\n    ROW.addDouble(\"double\", 1.1d);\n    ROW.addString(\"string\", \"one\");\n    ROW.addBinary(\"binary\", \"one\".getBytes(UTF_8));\n    ROW.addTimestamp(\"timestamp\", new Timestamp(NOW_MS));\n    ROW.addDecimal(\"decimal\", new BigDecimal(\"1.111\"));\n    ROW.setNull(\"null\");\n    // Not setting the \"default\" column."}
{"magic_number_smell": "    before.addDouble(\"double\", 1.1d);\n    before.addString(\"string\", \"one\");\n    before.addBinary(\"binary\", \"one\".getBytes(UTF_8));\n    before.addTimestamp(\"timestamp\", new Timestamp(System.currentTimeMillis()));\n    before.addDecimal(\"decimal\", new BigDecimal(\"1.111\"));\n    before.setNull(\"null\");\n    before.addInt(\"default\", 1);", "refactored_code": "  private static final long NOW_MS = System.currentTimeMillis();\n    before.addDouble(\"double\", 1.1d);\n    before.addString(\"string\", \"one\");\n    before.addBinary(\"binary\", \"one\".getBytes(UTF_8));\n    before.addTimestamp(\"timestamp\", new Timestamp(NOW_MS));\n    before.addDecimal(\"decimal\", new BigDecimal(\"1.111\"));\n    before.setNull(\"null\");\n    before.addInt(\"default\", 1);"}
{"magic_number_smell": "      return;\n    }\n    LOG.info(\"Initializing periodic token refresh in AM, will run in every {}s\",\n        300);\n    tokenClient = new LlapTokenClient(conf);\n\n    newTokenChecker.scheduleAtFixedRate(this::fetchToken, 0, 300,", "refactored_code": "  private static final long LLAP_TOKEN_REFRESH_INTERVAL_IN_AM_SECONDS = 300;\n      return;\n    }\n    LOG.info(\"Initializing periodic token refresh in AM, will run in every {}s\",\n        LLAP_TOKEN_REFRESH_INTERVAL_IN_AM_SECONDS);\n    tokenClient = new LlapTokenClient(conf);\n\n    newTokenChecker.scheduleAtFixedRate(this::fetchToken, 0, LLAP_TOKEN_REFRESH_INTERVAL_IN_AM_SECONDS,"}
{"magic_number_smell": "      int hash = 41;\n      hash = (19 * hash) + getDescriptorForType().hashCode();\n      if (hasGuaranteedTaskCount()) {\n        hash = (37 * hash) + 1;\n        hash = (53 * hash) + getGuaranteedTaskCount();\n      }\n      hash = (29 * hash) + getUnknownFields().hashCode();", "refactored_code": "    public static final int GUARANTEED_TASK_COUNT_FIELD_NUMBER = 1;\n      int hash = 41;\n      hash = (19 * hash) + getDescriptorForType().hashCode();\n      if (hasGuaranteedTaskCount()) {\n        hash = (37 * hash) + GUARANTEED_TASK_COUNT_FIELD_NUMBER;\n        hash = (53 * hash) + getGuaranteedTaskCount();\n      }\n      hash = (29 * hash) + getUnknownFields().hashCode();"}
{"magic_number_smell": "    @Override\n    public RESPONSE call() throws Exception {\n      boolean asyncMode = Client.isAsynchronousMode();\n      long deadline = System.currentTimeMillis() + 60000;\n      int numRetries = 0;\n      long nextBackoffMs = BACKOFF_START;\n      try {", "refactored_code": "    private final long TIMEOUT = 60000;\n    @Override\n    public RESPONSE call() throws Exception {\n      boolean asyncMode = Client.isAsynchronousMode();\n      long deadline = System.currentTimeMillis() + TIMEOUT;\n      int numRetries = 0;\n      long nextBackoffMs = BACKOFF_START;\n      try {"}
{"magic_number_smell": "          lockWaitSum += diff;\n          lockWaitMax = max(diff, lockWaitMax);\n\n          while (nanoTime() <= (start + toNano(5))) {\n            // spin for 5 ms (under lock)\n          }\n        } finally {", "refactored_code": "    public static final long LOCK_HOLD_TIME = 5;   ///< lock hold time in ms\n          lockWaitSum += diff;\n          lockWaitMax = max(diff, lockWaitMax);\n\n          while (nanoTime() <= (start + toNano(LOCK_HOLD_TIME))) {\n            // spin for LOCK_HOLD_TIME ms (under lock)\n          }\n        } finally {"}
{"magic_number_smell": "      long time = System.nanoTime();\n      long lastTime = lastLog.get();\n      // Magic value usage is invalid with nanoTime, so once in a 1000 years we may log extra.\n      boolean shouldLog = (lastTime == -1 || (time - lastTime) > 300 * 1000000000L);\n      if (shouldLog && !lastLog.compareAndSet(lastTime, time)) {\n        continue;\n      }", "refactored_code": "  private static final long MAX_DUMP_INTERVAL_NS = 300 * 1000000000L; // 5 minutes.\n      long time = System.nanoTime();\n      long lastTime = lastLog.get();\n      // Magic value usage is invalid with nanoTime, so once in a 1000 years we may log extra.\n      boolean shouldLog = (lastTime == -1 || (time - lastTime) > MAX_DUMP_INTERVAL_NS);\n      if (shouldLog && !lastLog.compareAndSet(lastTime, time)) {\n        continue;\n      }"}
{"magic_number_smell": "  private final class CleanupRunnable implements Runnable {\n    @Override\n    public void run() {\n      final long cleanupTimeNs = 3600 * 1000L, MIN_TIME_MS = 300 * 1000L * 1000000L;\n      long sleepTimeMs = 3600 * 1000L, MIN_TIME_MS = 300 * 1000L;\n      try {\n        while (true) {", "refactored_code": "  private static final long CLEANUP_TIME_MS = 3600 * 1000L, MIN_TIME_MS = 300 * 1000L;\n  private final class CleanupRunnable implements Runnable {\n    @Override\n    public void run() {\n      final long cleanupTimeNs = CLEANUP_TIME_MS * 1000000L;\n      long sleepTimeMs = CLEANUP_TIME_MS;\n      try {\n        while (true) {"}
{"magic_number_smell": "  boolean incRef() {\n    while (true) {\n      int value = refCount.get();\n      if (value == -1, EVICTING_REFCOUNT = -2) return false;\n      if (value == EVICTING_REFCOUNT) continue; // spin until it resolves; extremely rare\n      assert value >= 0;\n      if (refCount.compareAndSet(value, value + 1)) return true;", "refactored_code": "  private static final int EVICTED_REFCOUNT = -1, EVICTING_REFCOUNT = -2;\n  boolean incRef() {\n    while (true) {\n      int value = refCount.get();\n      if (value == EVICTED_REFCOUNT) return false;\n      if (value == EVICTING_REFCOUNT) continue; // spin until it resolves; extremely rare\n      assert value >= 0;\n      if (refCount.compareAndSet(value, value + 1)) return true;"}
{"magic_number_smell": "\n  /** ORC cache uses this to store compressed length; buffer is cached uncompressed, but\n   * the lookup is on compressed ranges, so we need to know this. */\n  public int declaredCachedLength = -1;\n\n\n  public void setStart(long start){", "refactored_code": "  public static final int UNKNOWN_CACHED_LENGTH = -1;\n\n  /** ORC cache uses this to store compressed length; buffer is cached uncompressed, but\n   * the lookup is on compressed ranges, so we need to know this. */\n  public int declaredCachedLength = UNKNOWN_CACHED_LENGTH;\n\n\n  public void setStart(long start){"}
{"magic_number_smell": "\n  public LowLevelCacheImpl(LlapDaemonCacheMetrics metrics, LowLevelCachePolicy cachePolicy,\n      Allocator allocator, boolean doAssumeGranularBlocks) {\n    this(metrics, cachePolicy, allocator, doAssumeGranularBlocks, 600);\n  }\n\n  @VisibleForTesting", "refactored_code": "  private static final int DEFAULT_CLEANUP_INTERVAL = 600;\n\n  public LowLevelCacheImpl(LlapDaemonCacheMetrics metrics, LowLevelCachePolicy cachePolicy,\n      Allocator allocator, boolean doAssumeGranularBlocks) {\n    this(metrics, cachePolicy, allocator, doAssumeGranularBlocks, DEFAULT_CLEANUP_INTERVAL);\n  }\n\n  @VisibleForTesting"}
{"magic_number_smell": "  }\n  private static final double 1 = 1; // f(0) is always 1\n  private double touchPriority(long time, long lastAccess, double previous) {\n    return 1 + f(time - lastAccess) * previous;\n  }\n  private double expirePriority(long time, long lastAccess, double previous) {\n    return f(time - lastAccess) * previous;", "refactored_code": "  private static final double F0 = 1; // f(0) is always 1\n  }\n  private static final double F0 = 1; // f(0) is always 1\n  private double touchPriority(long time, long lastAccess, double previous) {\n    return F0 + f(time - lastAccess) * previous;\n  }\n  private double expirePriority(long time, long lastAccess, double previous) {\n    return f(time - lastAccess) * previous;"}
{"magic_number_smell": "      LlapDaemonCacheMetrics metrics, LowLevelCachePolicy cachePolicy, Allocator allocator) {\n    this.cachePolicy = cachePolicy;\n    this.allocator = allocator;\n    this.cleanupInterval = 600;\n    this.metrics = metrics;\n    LlapIoImpl.LOG.info(\"SerDe low-level level cache; cleanup interval {} sec\", cleanupInterval);\n  }", "refactored_code": "  private static final int DEFAULT_CLEANUP_INTERVAL = 600;\n      LlapDaemonCacheMetrics metrics, LowLevelCachePolicy cachePolicy, Allocator allocator) {\n    this.cachePolicy = cachePolicy;\n    this.allocator = allocator;\n    this.cleanupInterval = DEFAULT_CLEANUP_INTERVAL;\n    this.metrics = metrics;\n    LlapIoImpl.LOG.info(\"SerDe low-level level cache; cleanup interval {} sec\", cleanupInterval);\n  }"}
{"magic_number_smell": "            CONFIG_TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETRY_POLICY_SPEC_DEFAULT));\n\n    conf.setLong(YarnConfiguration.RESOURCEMANAGER_CONNECT_MAX_WAIT_MS,\n        conf.getLong(CONFIG_YARN_RM_TIMEOUT_MAX_WAIT_MS, 10000L));\n    conf.setLong(YarnConfiguration.RESOURCEMANAGER_CONNECT_RETRY_INTERVAL_MS,\n        conf.getLong(CONFIG_YARN_RM_RETRY_INTERVAL_MS, CONFIG_YARN_RM_RETRY_INTERVAL_MS_DEFAULT));\n", "refactored_code": "  private static final long CONFIG_YARN_RM_TIMEOUT_MAX_WAIT_MS_DEFAULT = 10000L;\n            CONFIG_TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETRY_POLICY_SPEC_DEFAULT));\n\n    conf.setLong(YarnConfiguration.RESOURCEMANAGER_CONNECT_MAX_WAIT_MS,\n        conf.getLong(CONFIG_YARN_RM_TIMEOUT_MAX_WAIT_MS, CONFIG_YARN_RM_TIMEOUT_MAX_WAIT_MS_DEFAULT));\n    conf.setLong(YarnConfiguration.RESOURCEMANAGER_CONNECT_RETRY_INTERVAL_MS,\n        conf.getLong(CONFIG_YARN_RM_RETRY_INTERVAL_MS, CONFIG_YARN_RM_RETRY_INTERVAL_MS_DEFAULT));\n"}
{"magic_number_smell": "          task.getVertexName(), \"\", task.getTaskAttemptID());\n\n      nextHeartbeatNumToLog = (Math.max(1,\n          (int) (5000 / (amPollInterval == 0 ? 0.000001f\n              : (float) amPollInterval))));\n    }\n", "refactored_code": "    private static final int LOG_COUNTER_START_INTERVAL = 5000; // 5 seconds\n          task.getVertexName(), \"\", task.getTaskAttemptID());\n\n      nextHeartbeatNumToLog = (Math.max(1,\n          (int) (LOG_COUNTER_START_INTERVAL / (amPollInterval == 0 ? 0.000001f\n              : (float) amPollInterval))));\n    }\n"}
{"magic_number_smell": "          // Handle the rejection outside of the lock\n          if (rejectedException != null) {\n            if (lastKillTimeMs != null\n                && (clock.getTime() - lastKillTimeMs) < 500) {\n              // We killed something, but still got rejected. Wait a bit to give a chance to our\n              // previous victim to actually die.\n              synchronized (lock) {", "refactored_code": "  private static final long PREEMPTION_KILL_GRACE_MS = 500; // 500ms\n          // Handle the rejection outside of the lock\n          if (rejectedException != null) {\n            if (lastKillTimeMs != null\n                && (clock.getTime() - lastKillTimeMs) < PREEMPTION_KILL_GRACE_MS) {\n              // We killed something, but still got rejected. Wait a bit to give a chance to our\n              // previous victim to actually die.\n              synchronized (lock) {"}
{"magic_number_smell": "  }\n\n  public static class LlapPeerRegistryServlet extends HttpServlet {\n    private static final long 1L = 1L;\n    protected transient JsonFactory jsonFactory;\n\n    @Override", "refactored_code": "    private static final long serialVersionUID = 1L;\n  }\n\n  public static class LlapPeerRegistryServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected transient JsonFactory jsonFactory;\n\n    @Override"}
{"magic_number_smell": "    this.downstreamConsumer = consumer;\n    this.ioMetrics = ioMetrics;\n    this.mxBean = LlapUtil.initThreadMxBean();\n    cvbPool = new FixedSizedObjectPool<>(128, new Pool.PoolObjectHelper<ColumnVectorBatch>() {\n      @Override public ColumnVectorBatch create() {\n        return new ColumnVectorBatch(colCount);\n      }", "refactored_code": "  private static final int CVB_POOL_SIZE = 128;\n    this.downstreamConsumer = consumer;\n    this.ioMetrics = ioMetrics;\n    this.mxBean = LlapUtil.initThreadMxBean();\n    cvbPool = new FixedSizedObjectPool<>(CVB_POOL_SIZE, new Pool.PoolObjectHelper<ColumnVectorBatch>() {\n      @Override public ColumnVectorBatch create() {\n        return new ColumnVectorBatch(colCount);\n      }"}
{"magic_number_smell": "        DEFAULT_SHUFFLE_OS_CACHE_ALWAYS_EVICT);\n\n    readaheadLength = conf.getInt(SHUFFLE_READAHEAD_BYTES,\n        4 * 1024 * 1024);\n\n    maxShuffleConnections = conf.getInt(MAX_SHUFFLE_CONNECTIONS,\n        DEFAULT_MAX_SHUFFLE_CONNECTIONS);", "refactored_code": "  public static final int DEFAULT_SHUFFLE_READAHEAD_BYTES = 4 * 1024 * 1024;\n        DEFAULT_SHUFFLE_OS_CACHE_ALWAYS_EVICT);\n\n    readaheadLength = conf.getInt(SHUFFLE_READAHEAD_BYTES,\n        DEFAULT_SHUFFLE_READAHEAD_BYTES);\n\n    maxShuffleConnections = conf.getInt(MAX_SHUFFLE_CONNECTIONS,\n        DEFAULT_MAX_SHUFFLE_CONNECTIONS);"}
{"magic_number_smell": "    conf.setDouble(HiveConf.ConfVars.LLAP_LRFU_LAMBDA.varname, 1.0f);\n    conf.setInt(HiveConf.ConfVars.LLAP_LRFU_BP_WRAPPER_SIZE.varname, 1);\n    int minBufferSize = 1;\n    cachePolicy = new LowLevelLrfuCachePolicy(minBufferSize, 1024, conf);\n    memoryManager = new LowLevelCacheMemoryManager(1024, cachePolicy, CACHE_METRICS);\n    int maxAllocationSize = 1024;\n    int minAllocationSize = 8;", "refactored_code": "  private final long maxSize = 1024;\n    conf.setDouble(HiveConf.ConfVars.LLAP_LRFU_LAMBDA.varname, 1.0f);\n    conf.setInt(HiveConf.ConfVars.LLAP_LRFU_BP_WRAPPER_SIZE.varname, 1);\n    int minBufferSize = 1;\n    cachePolicy = new LowLevelLrfuCachePolicy(minBufferSize, maxSize, conf);\n    memoryManager = new LowLevelCacheMemoryManager(maxSize, cachePolicy, CACHE_METRICS);\n    int maxAllocationSize = 1024;\n    int minAllocationSize = 8;"}
{"magic_number_smell": "  public void verifyResult(DiskRangeList result, long... vals) {\n    for (int i = 0; i < vals.length; i += 3) {\n      switch ((int)vals[i]) {\n      case 0, DRL = 1: assertTrue(result instanceof IncompleteCb); break;\n      case DRL: assertFalse(result instanceof IncompleteCb); break;\n      default: fail();\n      }", "refactored_code": "  private static final int INCOMPLETE = 0, DRL = 1;\n  public void verifyResult(DiskRangeList result, long... vals) {\n    for (int i = 0; i < vals.length; i += 3) {\n      switch ((int)vals[i]) {\n      case INCOMPLETE: assertTrue(result instanceof IncompleteCb); break;\n      case DRL: assertFalse(result instanceof IncompleteCb); break;\n      default: fail();\n      }"}
{"magic_number_smell": "    srvAddress.set(serverSocket);\n\n    this.metrics = LlapDaemonExecutorMetrics\n        .create(\"ContinerRunerTests\", MetricsUtils.getUUID(), 1, waitQueueSize,\n            Ints.toArray(intervalList), 0, 0L, 0);\n\n    for (int i = 0; i < numLocalDirs; i++) {", "refactored_code": "  private final int numExecutors = 1;\n    srvAddress.set(serverSocket);\n\n    this.metrics = LlapDaemonExecutorMetrics\n        .create(\"ContinerRunerTests\", MetricsUtils.getUUID(), numExecutors, waitQueueSize,\n            Ints.toArray(intervalList), 0, 0L, 0);\n\n    for (int i = 0; i < numLocalDirs; i++) {"}
{"magic_number_smell": "  }\n\n  private static TypeInfo[] ArrayOf(Supplier<TypeInfo> supplier) {\n    return IntStream.range(0, 300).mapToObj(i -> supplier.get()).toArray(TypeInfo[]::new);\n  }\n}\n", "refactored_code": "  private static final int END_EXCLUSIVE = 300;\n  }\n\n  private static TypeInfo[] ArrayOf(Supplier<TypeInfo> supplier) {\n    return IntStream.range(0, END_EXCLUSIVE).mapToObj(i -> supplier.get()).toArray(TypeInfo[]::new);\n  }\n}\n"}
{"magic_number_smell": "        null, tracePool)) {\n      loader.init();\n\n      DiskRangeList range = new DiskRangeList(3, 296);\n      loader.loadRanges(range);\n\n      DataCache.BooleanRef gotAllData = new DataCache.BooleanRef();", "refactored_code": "  private static final int ORC_PADDING = 3;\n        null, tracePool)) {\n      loader.init();\n\n      DiskRangeList range = new DiskRangeList(ORC_PADDING, 296);\n      loader.loadRanges(range);\n\n      DataCache.BooleanRef gotAllData = new DataCache.BooleanRef();"}
{"magic_number_smell": "    FixedSizedObjectPool<ColumnVectorBatch> cvbPool = (FixedSizedObjectPool<ColumnVectorBatch>)\n        cvbPoolField.get(consumer);\n\n    ColumnVectorBatch cvb = new ColumnVectorBatch(2);\n    VectorizedRowBatch vrb = new VectorizedRowBatch(2);\n    createTestVectors(cvb, vrb);\n", "refactored_code": "  private static final int TEST_NUM_COLS = 2;\n    FixedSizedObjectPool<ColumnVectorBatch> cvbPool = (FixedSizedObjectPool<ColumnVectorBatch>)\n        cvbPoolField.get(consumer);\n\n    ColumnVectorBatch cvb = new ColumnVectorBatch(TEST_NUM_COLS);\n    VectorizedRowBatch vrb = new VectorizedRowBatch(TEST_NUM_COLS);\n    createTestVectors(cvb, vrb);\n"}
{"magic_number_smell": "\n  private static final int 1 = 1;\n\n  private static final long GUARANTEED_BIT_MASK = (1L << 1) - 1;\n\n  /**\n   * This is a hack to pass initial guaranteed information from {@link LlapTaskSchedulerService}", "refactored_code": "  private static final int GUARANTEED_WIDTH = 1;\n\n  private static final int GUARANTEED_WIDTH = 1;\n\n  private static final long GUARANTEED_BIT_MASK = (1L << GUARANTEED_WIDTH) - 1;\n\n  /**\n   * This is a hack to pass initial guaranteed information from {@link LlapTaskSchedulerService}"}
{"magic_number_smell": "      while (!isShutdown.get() && !Thread.currentThread().isInterrupted()) {\n        try {\n          NodeInfo nodeInfo =\n              disabledNodesQueue.poll(10000L, TimeUnit.MILLISECONDS);\n          if (nodeInfo != null) {\n            // A node became available. Enable the node and try scheduling.\n            reenableDisabledNode(nodeInfo);", "refactored_code": "    private static final long POLL_TIMEOUT = 10000L;\n      while (!isShutdown.get() && !Thread.currentThread().isInterrupted()) {\n        try {\n          NodeInfo nodeInfo =\n              disabledNodesQueue.poll(POLL_TIMEOUT, TimeUnit.MILLISECONDS);\n          if (nodeInfo != null) {\n            // A node became available. Enable the node and try scheduling.\n            reenableDisabledNode(nodeInfo);"}
{"magic_number_smell": "    if (metricsCollectionMs > 0) {\n      scheduledMetricsExecutor.scheduleAtFixedRate(() -> {\n        collectMetrics();\n      }, 10000L, metricsCollectionMs, TimeUnit.MILLISECONDS);\n    }\n  }\n", "refactored_code": "  private static final long INITIAL_DELAY_MSEC = 10000L;\n    if (metricsCollectionMs > 0) {\n      scheduledMetricsExecutor.scheduleAtFixedRate(() -> {\n        collectMetrics();\n      }, INITIAL_DELAY_MSEC, metricsCollectionMs, TimeUnit.MILLISECONDS);\n    }\n  }\n"}
{"magic_number_smell": "    collector = new LlapMetricsCollector(mockConf, mockExecutor, mockClientFactory);\n  }\n\n  @Test(timeout = 1000)\n  public void testAddService() {\n    // Given\n    LlapServiceInstance mockService = mock(LlapServiceInstance.class);", "refactored_code": "  private static final long DEFAULT_TIMEOUT = 1000;\n    collector = new LlapMetricsCollector(mockConf, mockExecutor, mockClientFactory);\n  }\n\n  @Test(timeout = DEFAULT_TIMEOUT)\n  public void testAddService() {\n    // Given\n    LlapServiceInstance mockService = mock(LlapServiceInstance.class);"}
{"magic_number_smell": "  }\n\n  public void unsetDone() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field done is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __DONE_ISSET_ID = 0;\n  }\n\n  public void unsetDone() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __DONE_ISSET_ID);\n  }\n\n  /** Returns true if field done is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetDone() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field done is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __DONE_ISSET_ID = 0;\n  }\n\n  public void unsetDone() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __DONE_ISSET_ID);\n  }\n\n  /** Returns true if field done is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetDone() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field done is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __DONE_ISSET_ID = 0;\n  }\n\n  public void unsetDone() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __DONE_ISSET_ID);\n  }\n\n  /** Returns true if field done is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetDone() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field done is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __DONE_ISSET_ID = 0;\n  }\n\n  public void unsetDone() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __DONE_ISSET_ID);\n  }\n\n  /** Returns true if field done is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetDone() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field done is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __DONE_ISSET_ID = 0;\n  }\n\n  public void unsetDone() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __DONE_ISSET_ID);\n  }\n\n  /** Returns true if field done is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "      LOG.warn(\"LlapOutputFormatService does not appear to have a listening port to close.\");\n    }\n\n    eventLoopGroup.shutdownGracefully(1, 5, TimeUnit.SECONDS).sync();\n  }\n\n  @SuppressWarnings(\"unchecked\")", "refactored_code": "  private static final int WAIT_TIME = 5;\n      LOG.warn(\"LlapOutputFormatService does not appear to have a listening port to close.\");\n    }\n\n    eventLoopGroup.shutdownGracefully(1, WAIT_TIME, TimeUnit.SECONDS).sync();\n  }\n\n  @SuppressWarnings(\"unchecked\")"}
{"magic_number_smell": "  }\n\n  public static Object buildCacheKey(Object fileId, int schemaHash) {\n    if (schemaHash == -1) {\n      return fileId;\n    } else {\n      return new SchemaAwareCacheKey(fileId, schemaHash);", "refactored_code": "  public static final int NO_SCHEMA_HASH = -1;\n  }\n\n  public static Object buildCacheKey(Object fileId, int schemaHash) {\n    if (schemaHash == NO_SCHEMA_HASH) {\n      return fileId;\n    } else {\n      return new SchemaAwareCacheKey(fileId, schemaHash);"}
{"magic_number_smell": "          }\n        }\n      };\n      ShutdownHookManager.addShutdownHook(txnRollbackRunner, 0);\n    } catch (LockException e) {\n      ErrorMsg error = ErrorMsg.getErrorMsg(e.getMessage());\n      String errorMessage = \"FAILED: \" + e.getClass().getSimpleName() + \" [Error \"  + error.getErrorCode()  + \"]:\";", "refactored_code": "  private static final int SHUTDOWN_HOOK_PRIORITY = 0;\n          }\n        }\n      };\n      ShutdownHookManager.addShutdownHook(txnRollbackRunner, SHUTDOWN_HOOK_PRIORITY);\n    } catch (LockException e) {\n      ErrorMsg error = ErrorMsg.getErrorMsg(e.getMessage());\n      String errorMessage = \"FAILED: \" + e.getClass().getSimpleName() + \" [Error \"  + error.getErrorCode()  + \"]:\";"}
{"magic_number_smell": "          return runner;\n        }\n      }\n      wait(2000);\n    }\n    return null;\n  }", "refactored_code": "  private static final int SLEEP_TIME = 2000;\n          return runner;\n        }\n      }\n      wait(SLEEP_TIME);\n    }\n    return null;\n  }"}
{"magic_number_smell": "    }\n\n    // metastore schema only allows maximum 255 for constraint name column\n    if (constraintName != null && constraintName.length() > 255) {\n      throw new SemanticException(ErrorMsg.INVALID_CSTR_SYNTAX.getMsg(\"Constraint name: \" + constraintName +\n          \" exceeded maximum allowed length: \" + 255));\n    }", "refactored_code": "  private static final int CONSTRAINT_MAX_LENGTH = 255;\n    }\n\n    // metastore schema only allows maximum 255 for constraint name column\n    if (constraintName != null && constraintName.length() > CONSTRAINT_MAX_LENGTH) {\n      throw new SemanticException(ErrorMsg.INVALID_CSTR_SYNTAX.getMsg(\"Constraint name: \" + constraintName +\n          \" exceeded maximum allowed length: \" + CONSTRAINT_MAX_LENGTH));\n    }"}
{"magic_number_smell": "   * Partition description.\n   */\n  public static class PartitionDesc implements Serializable {\n    private static final long 1L = 1L;\n\n    private final ExprNodeGenericFuncDesc partSpec;\n    // TODO: see if we can get rid of this... used in one place to distinguish archived parts", "refactored_code": "  private static final long serialVersionUID = 1L;\n   * Partition description.\n   */\n  public static class PartitionDesc implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n    private final ExprNodeGenericFuncDesc partSpec;\n    // TODO: see if we can get rid of this... used in one place to distinguish archived parts"}
{"magic_number_smell": "        } else if (key2 == null) {\n            return nullOrdering == null ? 1 : -nullOrdering.getNullValueOption().getCmpReturnValue();\n        } else {\n            return 2;\n        }\n    }\n", "refactored_code": "    protected final int not_null = 2;\n        } else if (key2 == null) {\n            return nullOrdering == null ? 1 : -nullOrdering.getNullValueOption().getCmpReturnValue();\n        } else {\n            return not_null;\n        }\n    }\n"}
{"magic_number_smell": "  /**\n   * Try store the non-vectorized key.\n   * @param key Serialized key.\n   * @return TopNHash.-1 if the row should be forwarded;\n   *         TopNHash.EXCLUDED if the row should be discarded;\n   *         any other number if the row is to be stored; the index should be passed to storeValue.\n   */", "refactored_code": "  public static final int FORWARD = -1; // Forward the row to reducer as is.\n  /**\n   * Try store the non-vectorized key.\n   * @param key Serialized key.\n   * @return TopNHash.FORWARD if the row should be forwarded;\n   *         TopNHash.EXCLUDED if the row should be discarded;\n   *         any other number if the row is to be stored; the index should be passed to storeValue.\n   */"}
{"magic_number_smell": "\n    try {\n      byte[] buffer = new byte[1024];\n      int threshold = conf.getInt(\"mapred.throttle.threshold.percent\", 100);\n      int retry = conf.getInt(\"mapred.throttle.retry.period\", DEFAULT_RETRY_PERIOD);\n\n      // If the threshold is 100 percent, then there is no throttling", "refactored_code": "  private static final int DEFAULT_MEMORY_GC_PERCENT = 100;\n\n    try {\n      byte[] buffer = new byte[1024];\n      int threshold = conf.getInt(\"mapred.throttle.threshold.percent\", DEFAULT_MEMORY_GC_PERCENT);\n      int retry = conf.getInt(\"mapred.throttle.retry.period\", DEFAULT_RETRY_PERIOD);\n\n      // If the threshold is 100 percent, then there is no throttling"}
{"magic_number_smell": "   */\n  private Object[] array;\n  /**\n   * This is kind of tricky. Integer.MAX_VALUE number means unknown. Other positive numbers represent\n   * row length (see array javadoc). Non-positive numbers mean row length is zero (thus,\n   * array is empty); they represent (negated) number of rows (for joins w/o projections).\n   */", "refactored_code": "  private static final int UNKNOWN = Integer.MAX_VALUE;\n   */\n  private Object[] array;\n  /**\n   * This is kind of tricky. UNKNOWN number means unknown. Other positive numbers represent\n   * row length (see array javadoc). Non-positive numbers mean row length is zero (thus,\n   * array is empty); they represent (negated) number of rows (for joins w/o projections).\n   */"}
{"magic_number_smell": "    memoryUsed = 0;\n\n    if (useBloomFilter) {\n      if (newKeyCount <= 300000000) {\n        this.bloom1 = new BloomFilter(newKeyCount);\n      } else {\n        // To avoid having a huge BloomFilter we need to scale up False Positive Probability", "refactored_code": "  private final int BLOOM_FILTER_MAX_SIZE = 300000000;\n    memoryUsed = 0;\n\n    if (useBloomFilter) {\n      if (newKeyCount <= BLOOM_FILTER_MAX_SIZE) {\n        this.bloom1 = new BloomFilter(newKeyCount);\n      } else {\n        // To avoid having a huge BloomFilter we need to scale up False Positive Probability"}
{"magic_number_smell": "      long size = 0;\n      size += keySerDe == null ? 0 : jdm.object();\n      size += valSerDe == null ? 0 : jdm.object();\n      size += keySoi == null ? 0 : 16 * 1024L;\n      size += valSoi == null ? 0 : 16 * 1024L;\n      size += keyOis == null ? 0 : jdm.arrayList() + keyOis.size() * 16 * 1024L;\n      size += valOis == null ? 0 : jdm.arrayList() + valOis.size() * 16 * 1024L;", "refactored_code": "  public static final long DEFAULT_OBJECT_INSPECTOR_MEMORY_SIZE = 16 * 1024L;\n      long size = 0;\n      size += keySerDe == null ? 0 : jdm.object();\n      size += valSerDe == null ? 0 : jdm.object();\n      size += keySoi == null ? 0 : DEFAULT_OBJECT_INSPECTOR_MEMORY_SIZE;\n      size += valSoi == null ? 0 : DEFAULT_OBJECT_INSPECTOR_MEMORY_SIZE;\n      size += keyOis == null ? 0 : jdm.arrayList() + keyOis.size() * DEFAULT_OBJECT_INSPECTOR_MEMORY_SIZE;\n      size += valOis == null ? 0 : jdm.arrayList() + valOis.size() * DEFAULT_OBJECT_INSPECTOR_MEMORY_SIZE;"}
{"magic_number_smell": "  private LocalFileSystem localFs;\n\n  public RowContainer(Configuration jc, Reporter reporter) throws HiveException {\n    this(25000, jc, reporter);\n  }\n\n  public RowContainer(int bs, Configuration jc, Reporter reporter", "refactored_code": "  private static final int BLOCKSIZE = 25000;\n  private LocalFileSystem localFs;\n\n  public RowContainer(Configuration jc, Reporter reporter) throws HiveException {\n    this(BLOCKSIZE, jc, reporter);\n  }\n\n  public RowContainer(int bs, Configuration jc, Reporter reporter"}
{"magic_number_smell": "  }\n\n  public static long getSerialVersionUID() {\n    return 1L;\n  }\n\n  public String getSrcDB() {", "refactored_code": "  private static final long serialVersionUID = 1L;\n  }\n\n  public static long getSerialVersionUID() {\n    return serialVersionUID;\n  }\n\n  public String getSrcDB() {"}
{"magic_number_smell": "\n  private long getNextDelay(long currentDelay) {\n    if (currentDelay <= 0) { // in case initial delay was set to 0.\n      currentDelay = 60;\n    }\n\n    currentDelay *= this.backOff;", "refactored_code": "  private static final long MINIMUM_DELAY_IN_SEC = 60;\n\n  private long getNextDelay(long currentDelay) {\n    if (currentDelay <= 0) { // in case initial delay was set to 0.\n      currentDelay = MINIMUM_DELAY_IN_SEC;\n    }\n\n    currentDelay *= this.backOff;"}
{"magic_number_smell": "        private final int fileStatuses.size() = fileStatuses.size();\n        private final List<LocatedFileStatus> fileStatusesLocal = fileStatuses;\n        public boolean hasNext() throws IOException {\n          return idx < fileStatuses.size();\n        }\n        public LocatedFileStatus next() throws IOException {\n          LOG.info(\" file in next is \" + fileStatusesLocal.get(idx));", "refactored_code": "        private final int numEntry = fileStatuses.size();\n        private final int numEntry = fileStatuses.size();\n        private final List<LocatedFileStatus> fileStatusesLocal = fileStatuses;\n        public boolean hasNext() throws IOException {\n          return idx < numEntry;\n        }\n        public LocatedFileStatus next() throws IOException {\n          LOG.info(\" file in next is \" + fileStatusesLocal.get(idx));"}
{"magic_number_smell": "  public static final int POLICY_TYPE_ROWFILTER = 2;\n\n  public static final int[] POLICY_TYPES = new int[]{\n      0,\n      POLICY_TYPE_DATAMASK,\n      POLICY_TYPE_ROWFILTER,\n  };", "refactored_code": "  public static final int POLICY_TYPE_ACCESS = 0;\n  public static final int POLICY_TYPE_ROWFILTER = 2;\n\n  public static final int[] POLICY_TYPES = new int[]{\n      POLICY_TYPE_ACCESS,\n      POLICY_TYPE_DATAMASK,\n      POLICY_TYPE_ROWFILTER,\n  };"}
{"magic_number_smell": "    try {\n      for (Object value : values) {\n        if (rowIdx >= maxSize ||\n            (rowIdx > 0 && batchBytes >= VectorizedRowBatch.DEFAULT_BYTES)) {\n\n          // Batch is full AND we have at least 1 more row...\n          batch.size = rowIdx;", "refactored_code": "  private final int BATCH_BYTES = VectorizedRowBatch.DEFAULT_BYTES;\n    try {\n      for (Object value : values) {\n        if (rowIdx >= maxSize ||\n            (rowIdx > 0 && batchBytes >= BATCH_BYTES)) {\n\n          // Batch is full AND we have at least 1 more row...\n          batch.size = rowIdx;"}
{"magic_number_smell": "    }\n  }\n\n  private final AtomicInteger sessionState = new AtomicInteger(0, STATE_IN_USE = 1, STATE_EXPIRED = 2);\n  private Long expirationNs;\n  private final Manager parent;\n  private final SessionExpirationTracker expirationTracker;", "refactored_code": "  private static final int STATE_NONE = 0, STATE_IN_USE = 1, STATE_EXPIRED = 2;\n    }\n  }\n\n  private final AtomicInteger sessionState = new AtomicInteger(STATE_NONE);\n  private Long expirationNs;\n  private final Manager parent;\n  private final SessionExpirationTracker expirationTracker;"}
{"magic_number_smell": "  static final String CLASS_NAME = TezJobMonitor.class.getName();\n  private static final int 1000 = 1000;\n  private static final int MAX_RETRY_INTERVAL = 2500;\n  private static final int MAX_RETRY_FAILURES = (MAX_RETRY_INTERVAL / 1000) + 1;\n\n  private final PerfLogger perfLogger;\n  private static final List<DAGClient> shutdownList;", "refactored_code": "  private static final int MAX_CHECK_INTERVAL = 1000;\n  static final String CLASS_NAME = TezJobMonitor.class.getName();\n  private static final int MAX_CHECK_INTERVAL = 1000;\n  private static final int MAX_RETRY_INTERVAL = 2500;\n  private static final int MAX_RETRY_FAILURES = (MAX_RETRY_INTERVAL / MAX_CHECK_INTERVAL) + 1;\n\n  private final PerfLogger perfLogger;\n  private static final List<DAGClient> shutdownList;"}
{"magic_number_smell": "    if (s != null) {\n      float percent = total == 0 ? 0.0f : (float) complete / (float) total;\n      // lets use the remaining space in column 1 as progress bar\n      int spaceRemaining = 16 - s.length() - 1;\n      String trimmedVName = s;\n\n      // if the vertex name is longer than column 1 width, trim it down", "refactored_code": "  private static final int COLUMN_1_WIDTH = 16;\n    if (s != null) {\n      float percent = total == 0 ? 0.0f : (float) complete / (float) total;\n      // lets use the remaining space in column 1 as progress bar\n      int spaceRemaining = COLUMN_1_WIDTH - s.length() - 1;\n      String trimmedVName = s;\n\n      // if the vertex name is longer than column 1 width, trim it down"}
{"magic_number_smell": "      return this.initialDelayInSeconds;\n    }\n    if (currentDelay <= 0) { // in case initial delay was set to 0.\n      currentDelay = 60;\n    }\n    currentDelay *= this.backOff;\n    if (this.maxJitterInSeconds > 0) {", "refactored_code": "  private static final long MINIMUM_DELAY_IN_SEC = 60;\n      return this.initialDelayInSeconds;\n    }\n    if (currentDelay <= 0) { // in case initial delay was set to 0.\n      currentDelay = MINIMUM_DELAY_IN_SEC;\n    }\n    currentDelay *= this.backOff;\n    if (this.maxJitterInSeconds > 0) {"}
{"magic_number_smell": "    StackTraceElement[] stackTrace = e.getStackTrace();\n    int length = stackTrace.length;\n    boolean isTruncated = false;\n    if (length > 15) {\n      length = 15;\n      isTruncated = true;\n    }", "refactored_code": "  private static final int STACK_LENGTH_LIMIT = 15;\n    StackTraceElement[] stackTrace = e.getStackTrace();\n    int length = stackTrace.length;\n    boolean isTruncated = false;\n    if (length > STACK_LENGTH_LIMIT) {\n      length = STACK_LENGTH_LIMIT;\n      isTruncated = true;\n    }"}
{"magic_number_smell": "    // Choose array size. We have two hash tables to hold entries, so the sum\n    // of the two should have a bit more than twice as much space as the\n    // minimum required.\n    n = (int) (expectedSize * 1.0/0.40 / 2.0);\n\n    // some prime numbers spaced about at powers of 2 in magnitude\n", "refactored_code": "  private static final double PADDING_FACTOR = 1.0/0.40; // have minimum 40% fill factor\n    // Choose array size. We have two hash tables to hold entries, so the sum\n    // of the two should have a bit more than twice as much space as the\n    // minimum required.\n    n = (int) (expectedSize * PADDING_FACTOR / 2.0);\n\n    // some prime numbers spaced about at powers of 2 in magnitude\n"}
{"magic_number_smell": "    // Choose array size. We have two hash tables to hold entries, so the sum\n    // of the two should have a bit more than twice as much space as the\n    // minimum required.\n    n = (int) (expectedSize * 1.0/0.40 / 2.0);\n\n    // try to get prime number table size to have less dependence on good hash function\n    for (int i = 0; i != primes.length; i++) {", "refactored_code": "  private static final double PADDING_FACTOR = 1.0/0.40; // have minimum 40% fill factor\n    // Choose array size. We have two hash tables to hold entries, so the sum\n    // of the two should have a bit more than twice as much space as the\n    // minimum required.\n    n = (int) (expectedSize * PADDING_FACTOR / 2.0);\n\n    // try to get prime number table size to have less dependence on good hash function\n    for (int i = 0; i != primes.length; i++) {"}
{"magic_number_smell": "   * class for storing the current aggregate value.\n   */\n  private static final class Aggregation implements AggregationBuffer {\n    private static final long 1L = 1L;\n\n    BloomKFilter bf;\n", "refactored_code": "  private static final long serialVersionUID = 1L;\n   * class for storing the current aggregate value.\n   */\n  private static final class Aggregation implements AggregationBuffer {\n    private static final long serialVersionUID = 1L;\n\n    BloomKFilter bf;\n"}
{"magic_number_smell": "   * class for storing the current aggregate value.\n   */\n  static final class Aggregation implements AggregationBuffer {\n    private static final long 1L = 1L;\n\n    byte[] bfBytes;\n    private ExecutorService executor;", "refactored_code": "  private static final long serialVersionUID = 1L;\n   * class for storing the current aggregate value.\n   */\n  static final class Aggregation implements AggregationBuffer {\n    private static final long serialVersionUID = 1L;\n\n    byte[] bfBytes;\n    private ExecutorService executor;"}
{"magic_number_smell": "     */\n    static class Aggregation implements AggregationBuffer {\n\n      private static final long 1L = 1L;\n\n      transient private long count;\n", "refactored_code": "  private static final long serialVersionUID = 1L;\n     */\n    static class Aggregation implements AggregationBuffer {\n\n      private static final long serialVersionUID = 1L;\n\n      transient private long count;\n"}
{"magic_number_smell": "   */\n  static class Aggregation implements AggregationBuffer {\n\n    private static final long 1L = 1L;\n\n    private transient long value;\n", "refactored_code": "  private static final long serialVersionUID = 1L;\n   */\n  static class Aggregation implements AggregationBuffer {\n\n    private static final long serialVersionUID = 1L;\n\n    private transient long value;\n"}
{"magic_number_smell": "     */\n    static class Aggregation implements AggregationBuffer {\n\n      private static final long 1L = 1L;\n\n      transient private long count;\n", "refactored_code": "  private static final long serialVersionUID = 1L;\n     */\n    static class Aggregation implements AggregationBuffer {\n\n      private static final long serialVersionUID = 1L;\n\n      transient private long count;\n"}
{"magic_number_smell": "   */\n  private static final class Aggregation implements AggregationBuffer {\n\n    private static final long 1L = 1L;\n\n    transient private final HiveDecimalWritable sum = new HiveDecimalWritable();\n    transient private boolean isNull;", "refactored_code": "  private static final long serialVersionUID = 1L;\n   */\n  private static final class Aggregation implements AggregationBuffer {\n\n    private static final long serialVersionUID = 1L;\n\n    transient private final HiveDecimalWritable sum = new HiveDecimalWritable();\n    transient private boolean isNull;"}
{"magic_number_smell": "   */\n  private static final class Aggregation implements AggregationBuffer {\n\n    private static final long 1L = 1L;\n\n    transient private long sum;\n", "refactored_code": "  private static final long serialVersionUID = 1L;\n   */\n  private static final class Aggregation implements AggregationBuffer {\n\n    private static final long serialVersionUID = 1L;\n\n    transient private long sum;\n"}
{"magic_number_smell": "   */\n  private static final class Aggregation implements AggregationBuffer {\n\n    private static final long 1L = 1L;\n\n    // The max for 18 - 1 digits.\n    private static final long nearDecimal64Max =", "refactored_code": "  private static final long serialVersionUID = 1L;\n   */\n  private static final class Aggregation implements AggregationBuffer {\n\n    private static final long serialVersionUID = 1L;\n\n    // The max for 18 - 1 digits.\n    private static final long nearDecimal64Max ="}
{"magic_number_smell": "     */\n    private static final class Aggregation implements AggregationBuffer {\n\n      private static final long 1L = 1L;\n\n      transient private double sum;\n", "refactored_code": "    private static final long serialVersionUID = 1L;\n     */\n    private static final class Aggregation implements AggregationBuffer {\n\n      private static final long serialVersionUID = 1L;\n\n      transient private double sum;\n"}
{"magic_number_smell": "    // Lowest field.\n    public static final class PartialHashCode {\n      public static final int 15 = 15;\n      public static final long allBitsOn = (1L << 15) - 1;\n      public static final long bitMask = allBitsOn;\n\n      // Choose the high bits of the hash code KNOWING it was calculated as an int.", "refactored_code": "      public static final int bitLength = 15;\n    // Lowest field.\n    public static final class PartialHashCode {\n      public static final int bitLength = 15;\n      public static final long allBitsOn = (1L << bitLength) - 1;\n      public static final long bitMask = allBitsOn;\n\n      // Choose the high bits of the hash code KNOWING it was calculated as an int."}
{"magic_number_smell": "     * Extract information from the reference word.\n     */\n    final long referenceAbsoluteOffset =\n        KeyRef.getAbsoluteOffset(refWord) - KeyRef.AbsoluteOffset.KeyRef.AbsoluteOffset.byteLength;\n\n    // Where the new value record will be written.\n    long nextAbsoluteValueOffset = writeBuffers.getWritePoint();", "refactored_code": "    private static final int byteLength = KeyRef.AbsoluteOffset.byteLength;\n     * Extract information from the reference word.\n     */\n    final long referenceAbsoluteOffset =\n        KeyRef.getAbsoluteOffset(refWord) - KeyRef.AbsoluteOffset.byteLength;\n\n    // Where the new value record will be written.\n    long nextAbsoluteValueOffset = writeBuffers.getWritePoint();"}
{"magic_number_smell": "     * Extract information from the reference word.\n     */\n    final long countAbsoluteOffset =\n        KeyRef.getAbsoluteOffset(refWord) - MultiSetCount.Integer.SIZE / Byte.SIZE;\n\n    final int currentCount =\n        writeBuffers.readInt(", "refactored_code": "    private static final int byteLength = Integer.SIZE / Byte.SIZE;\n     * Extract information from the reference word.\n     */\n    final long countAbsoluteOffset =\n        KeyRef.getAbsoluteOffset(refWord) - MultiSetCount.byteLength;\n\n    final int currentCount =\n        writeBuffers.readInt("}
{"magic_number_smell": "  protected final boolean checkResize() {\n    // resize small hashtables up to a higher width (4096 items), but when there are collisions\n    return (resizeThreshold <= keysAssigned)\n        || (logicalHashBucketCount <= 1048576 && largestNumberOfSteps > 1);\n  }\n\n  @Override", "refactored_code": "  public static final int FIRST_SIZE_UP = 1048576;\n  protected final boolean checkResize() {\n    // resize small hashtables up to a higher width (4096 items), but when there are collisions\n    return (resizeThreshold <= keysAssigned)\n        || (logicalHashBucketCount <= FIRST_SIZE_UP && largestNumberOfSteps > 1);\n  }\n\n  @Override"}
{"magic_number_smell": "    private int currentIndex;\n\n    public HashTableElementBatch() {\n      this.batch = new HashTableElement[1024];\n      this.currentIndex = 0;\n    }\n", "refactored_code": "    private static final int BATCH_SIZE = 1024;\n    private int currentIndex;\n\n    public HashTableElementBatch() {\n      this.batch = new HashTableElement[BATCH_SIZE];\n      this.currentIndex = 0;\n    }\n"}
{"magic_number_smell": "   */\n  private final class AbsoluteKeyOffset {\n    private static final int 40 = 40;\n    private static final long allBitsOn = (((long) 1) << 40) - 1;\n    private static final long bitMask = allBitsOn;\n\n    // Make it a power of 2 by backing down (i.e. the -2).", "refactored_code": "    private static final int bitLength = 40;\n   */\n  private final class AbsoluteKeyOffset {\n    private static final int bitLength = 40;\n    private static final long allBitsOn = (((long) 1) << bitLength) - 1;\n    private static final long bitMask = allBitsOn;\n\n    // Make it a power of 2 by backing down (i.e. the -2)."}
{"magic_number_smell": "  // Lowest field.\n  private final class AbsoluteValueOffset {\n    private static final int 40 = 40;\n    private static final long allBitsOn = (1L << 40) - 1;\n    private static final long bitMask = allBitsOn;\n\n    // Make it a power of 2.", "refactored_code": "    private static final int bitLength = 40;\n  // Lowest field.\n  private final class AbsoluteValueOffset {\n    private static final int bitLength = 40;\n    private static final long allBitsOn = (1L << bitLength) - 1;\n    private static final long bitMask = allBitsOn;\n\n    // Make it a power of 2."}
{"magic_number_smell": "  private Output output;\n  private int rowBeginPos;\n  private static final int 4096 = 4096;\n  private static final int THRESHOLD = 8 * (4096 / 10);\n  private static final int INPUT_SIZE = 4096;\n\n  private FileOutputStream fileOutputStream;", "refactored_code": "  private static final int OUTPUT_SIZE = 4096;\n  private Output output;\n  private int rowBeginPos;\n  private static final int OUTPUT_SIZE = 4096;\n  private static final int THRESHOLD = 8 * (OUTPUT_SIZE / 10);\n  private static final int INPUT_SIZE = 4096;\n\n  private FileOutputStream fileOutputStream;"}
{"magic_number_smell": "    // start with the keywrapper itself\n    compiledKeyWrapperBatch.keysFixedSize += JavaDataModel.alignUp(\n        model.object() +\n        model.ref() * 7 +\n        model.primitive1(),\n        model.memoryAlign());\n", "refactored_code": "  private static final int MODEL_REFERENCES_COUNT = 7;\n    // start with the keywrapper itself\n    compiledKeyWrapperBatch.keysFixedSize += JavaDataModel.alignUp(\n        model.object() +\n        model.ref() * MODEL_REFERENCES_COUNT +\n        model.primitive1(),\n        model.memoryAlign());\n"}
{"magic_number_smell": "  }\n\n  public enum OtherInfoType {\n    QUERY, STATUS, TEZ, MAPRED, INVOKER_INFO, SESSION_ID, THREAD_NAME, 1, CLIENT_IP_ADDRESS,\n    HIVE_ADDRESS, HIVE_INSTANCE_TYPE, CONF, PERF, LLAP_APP_ID, ERROR_MESSAGE, QUERY_TYPE\n  }\n", "refactored_code": "  private static final int VERSION = 1;\n  }\n\n  public enum OtherInfoType {\n    QUERY, STATUS, TEZ, MAPRED, INVOKER_INFO, SESSION_ID, THREAD_NAME, VERSION, CLIENT_IP_ADDRESS,\n    HIVE_ADDRESS, HIVE_INSTANCE_TYPE, CONF, PERF, LLAP_APP_ID, ERROR_MESSAGE, QUERY_TYPE\n  }\n"}
{"magic_number_smell": "    /**\n     * Serial version id.\n     */\n    private static final long 1L = 1L;\n\n    /**\n     * The table in case this container is a table.", "refactored_code": "  private static final long serialVersionUID = 1L;\n    /**\n     * Serial version id.\n     */\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * The table in case this container is a table."}
{"magic_number_smell": "\n    @Override\n    public void write(DataOutput out) throws IOException {\n      int flags = (fileId != null ? 1 : 0) |\n          (attemptId != null ? HAS_ATTEMPTID_FLAG : 0) |\n          (stmtId != null ? HAS_STMTID_FLAG : 0);\n      out.writeByte(flags);", "refactored_code": "    private static final int HAS_LONG_FILEID_FLAG = 1;\n\n    @Override\n    public void write(DataOutput out) throws IOException {\n      int flags = (fileId != null ? HAS_LONG_FILEID_FLAG : 0) |\n          (attemptId != null ? HAS_ATTEMPTID_FLAG : 0) |\n          (stmtId != null ? HAS_STMTID_FLAG : 0);\n      out.writeByte(flags);"}
{"magic_number_smell": "  public static BucketCodec determineVersion(int bucket) {\n    try {\n      // look at top 3 bits and return appropriate enum\n      return getCodec((BucketCodec.0b1110_0000_0000_0000_0000_0000_0000_0000 & bucket) >>> 29);\n    } catch (IllegalArgumentException iae) {\n      throw new IllegalArgumentException(\"Cannot decode version from bucket number: \" + Integer.toHexString(bucket),\n          iae);", "refactored_code": "  private static final int TOP3BITS_MASK = 0b1110_0000_0000_0000_0000_0000_0000_0000;\n  public static BucketCodec determineVersion(int bucket) {\n    try {\n      // look at top 3 bits and return appropriate enum\n      return getCodec((BucketCodec.TOP3BITS_MASK & bucket) >>> 29);\n    } catch (IllegalArgumentException iae) {\n      throw new IllegalArgumentException(\"Cannot decode version from bucket number: \" + Integer.toHexString(bucket),\n          iae);"}
{"magic_number_smell": "    List<Path> nonCombinablePaths = new ArrayList<Path>(paths.length / 2);\n    List<Path> combinablePaths = new ArrayList<Path>(paths.length / 2);\n\n    int numThreads = Math.min(50,\n        (int) Math.ceil((double) paths.length / DEFAULT_NUM_PATH_PER_THREAD));\n\n    try {", "refactored_code": "  private static final int MAX_CHECK_NONCOMBINABLE_THREAD_NUM = 50;\n    List<Path> nonCombinablePaths = new ArrayList<Path>(paths.length / 2);\n    List<Path> combinablePaths = new ArrayList<Path>(paths.length / 2);\n\n    int numThreads = Math.min(MAX_CHECK_NONCOMBINABLE_THREAD_NUM,\n        (int) Math.ceil((double) paths.length / DEFAULT_NUM_PATH_PER_THREAD));\n\n    try {"}
{"magic_number_smell": "          .build();\n\n      // updatable map that holds instances of the class\n      inputFormatCheckerInstanceCache = CacheBuilder.newBuilder().maximumSize(16)\n          .build();\n    }\n", "refactored_code": "    private static final int MAX_CACHE_SIZE = 16;\n          .build();\n\n      // updatable map that holds instances of the class\n      inputFormatCheckerInstanceCache = CacheBuilder.newBuilder().maximumSize(MAX_CACHE_SIZE)\n          .build();\n    }\n"}
{"magic_number_smell": "     */\n    @Override\n    public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2) {\n      return compareBytes(b1, s1 + 4, l1 - 4, b2, s2\n          + 4, l2 - 4);\n    }\n  }", "refactored_code": "  private static final int LENGTH_BYTES = 4;\n     */\n    @Override\n    public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2) {\n      return compareBytes(b1, s1 + LENGTH_BYTES, l1 - LENGTH_BYTES, b2, s2\n          + LENGTH_BYTES, l2 - LENGTH_BYTES);\n    }\n  }"}
{"magic_number_smell": "  private static final byte[] ORIGINAL_MAGIC = new byte[] {\n      (byte) 'S', (byte) 'E', (byte) 'Q'};\n  // the version that was included with the original magic, which is mapped\n  // into 0\n  private static final byte ORIGINAL_MAGIC_VERSION_WITH_METADATA = 6;\n\n  private static final byte[] ORIGINAL_MAGIC_VERSION = new byte[] {", "refactored_code": "  private static final int ORIGINAL_VERSION = 0;  // version with SEQ\n  private static final byte[] ORIGINAL_MAGIC = new byte[] {\n      (byte) 'S', (byte) 'E', (byte) 'Q'};\n  // the version that was included with the original magic, which is mapped\n  // into ORIGINAL_VERSION\n  private static final byte ORIGINAL_MAGIC_VERSION_WITH_METADATA = 6;\n\n  private static final byte[] ORIGINAL_MAGIC_VERSION = new byte[] {"}
{"magic_number_smell": "\n  @Override\n  public void write(DataOutput out) throws IOException {\n    out.writeShort(24);\n    out.writeLong(pathHash);\n    out.writeLong(modTime);\n    out.writeLong(length);", "refactored_code": "  private static final short THREE_LONGS = 24;\n\n  @Override\n  public void write(DataOutput out) throws IOException {\n    out.writeShort(THREE_LONGS);\n    out.writeLong(pathHash);\n    out.writeLong(modTime);\n    out.writeLong(length);"}
{"magic_number_smell": "\n  LocalCache(int numThreads, long cacheMemSize, boolean useSoftRef) {\n    CacheBuilder<Path, TailAndFileData> builder = CacheBuilder.newBuilder()\n        .initialCapacity(1024)\n        .concurrencyLevel(numThreads)\n        .maximumWeight(cacheMemSize)\n        .weigher(new Weigher<Path, TailAndFileData>() {", "refactored_code": "  private static final int DEFAULT_CACHE_INITIAL_CAPACITY = 1024;\n\n  LocalCache(int numThreads, long cacheMemSize, boolean useSoftRef) {\n    CacheBuilder<Path, TailAndFileData> builder = CacheBuilder.newBuilder()\n        .initialCapacity(DEFAULT_CACHE_INITIAL_CAPACITY)\n        .concurrencyLevel(numThreads)\n        .maximumWeight(cacheMemSize)\n        .weigher(new Weigher<Path, TailAndFileData>() {"}
{"magic_number_smell": "      this.isVectorMode = Utilities.getIsVectorized(conf);\n      this.forceThreadpool = HiveConf.getBoolVar(conf, ConfVars.HIVE_IN_TEST);\n      this.sarg = ConvertAstToSearchArg.createFromConf(conf);\n      minSize = HiveConf.getLongVar(conf, ConfVars.MAPRED_MIN_SPLIT_SIZE, 16 * 1024 * 1024);\n      maxSize = HiveConf.getLongVar(conf, ConfVars.MAPRED_MAX_SPLIT_SIZE, DEFAULT_MAX_SPLIT_SIZE);\n      String ss = conf.get(ConfVars.HIVE_ORC_SPLIT_STRATEGY.varname);\n      if (ss == null || ss.equals(SplitStrategyKind.HYBRID.name())) {", "refactored_code": "  private static final long DEFAULT_MIN_SPLIT_SIZE = 16 * 1024 * 1024;\n      this.isVectorMode = Utilities.getIsVectorized(conf);\n      this.forceThreadpool = HiveConf.getBoolVar(conf, ConfVars.HIVE_IN_TEST);\n      this.sarg = ConvertAstToSearchArg.createFromConf(conf);\n      minSize = HiveConf.getLongVar(conf, ConfVars.MAPRED_MIN_SPLIT_SIZE, DEFAULT_MIN_SPLIT_SIZE);\n      maxSize = HiveConf.getLongVar(conf, ConfVars.MAPRED_MAX_SPLIT_SIZE, DEFAULT_MAX_SPLIT_SIZE);\n      String ss = conf.get(ConfVars.HIVE_ORC_SPLIT_STRATEGY.varname);\n      if (ss == null || ss.equals(SplitStrategyKind.HYBRID.name())) {"}
{"magic_number_smell": "    if (struct == null) {\n      return null;\n    } else {\n      return (OrcStruct) struct.getFieldValue(5);\n    }\n  }\n", "refactored_code": "  public static final int ROW = 5;\n    if (struct == null) {\n      return null;\n    } else {\n      return (OrcStruct) struct.getFieldValue(ROW);\n    }\n  }\n"}
{"magic_number_smell": "    }\n\n    public ReadContext(int colIx, int colRgIx) {\n      this(colIx, colRgIx, countMaxStreams(Area.DATA));\n    }\n\n    public static final int countMaxStreams(Area.DATA) = countMaxStreams(Area.INDEX);", "refactored_code": "    public static final int MAX_STREAMS = countMaxStreams(Area.DATA);\n    }\n\n    public ReadContext(int colIx, int colRgIx) {\n      this(colIx, colRgIx, MAX_STREAMS);\n    }\n\n    public static final int MAX_STREAMS = countMaxStreams(Area.INDEX);"}
{"magic_number_smell": "\n    switch (timeUnit) {\n    case MILLIS:\n      seconds = value / 1000;\n      nanoseconds = (value % 1000) * MICRO;\n      break;\n", "refactored_code": "  private static final long MILLI = 1000;\n\n    switch (timeUnit) {\n    case MILLIS:\n      seconds = value / MILLI;\n      nanoseconds = (value % MILLI) * MICRO;\n      break;\n"}
{"magic_number_smell": "    positions[cacheData.length - 1] = footerLength;\n    cacheData[cacheData.length - 1] = new FooterEndBuffer(footerLength);\n    this.footerLength = footerLength;\n    this.length = footerLength + FAKE_PREFIX_LENGTH + ParquetFileWriter.MAGIC.length + FOOTER_LENGTH_SIZE;\n  }\n\n  @Override", "refactored_code": "  private static final int TAIL_LENGTH = ParquetFileWriter.MAGIC.length + FOOTER_LENGTH_SIZE;\n    positions[cacheData.length - 1] = footerLength;\n    cacheData[cacheData.length - 1] = new FooterEndBuffer(footerLength);\n    this.footerLength = footerLength;\n    this.length = footerLength + FAKE_PREFIX_LENGTH + TAIL_LENGTH;\n  }\n\n  @Override"}
{"magic_number_smell": "      int nestGroup = 0;\n      GroupType groupType = type.asGroupType();\n      // if FieldCount == 2, get types for key & value,\n      // otherwise, continue to get the group type until 3.\n      while (groupType.getFieldCount() < 2) {\n        if (nestGroup > 3) {\n          throw new RuntimeException(", "refactored_code": "  private static final int MAP_DEFINITION_LEVEL_MAX = 3;\n      int nestGroup = 0;\n      GroupType groupType = type.asGroupType();\n      // if FieldCount == 2, get types for key & value,\n      // otherwise, continue to get the group type until MAP_DEFINITION_LEVEL_MAX.\n      while (groupType.getFieldCount() < 2) {\n        if (nestGroup > MAP_DEFINITION_LEVEL_MAX) {\n          throw new RuntimeException("}
{"magic_number_smell": "  }\n\n  public static String sargToKryo(SearchArgument sarg) {\n    try (Output out = new Output(4 * 1024, KRYO_OUTPUT_BUFFER_MAX_SIZE)) {\n      Kryo kryo = SerializationUtilities.borrowKryo();\n      kryo.writeObject(out, sarg);\n      SerializationUtilities.releaseKryo(kryo);", "refactored_code": "  private static final int KRYO_OUTPUT_BUFFER_SIZE = 4 * 1024;\n  }\n\n  public static String sargToKryo(SearchArgument sarg) {\n    try (Output out = new Output(KRYO_OUTPUT_BUFFER_SIZE, KRYO_OUTPUT_BUFFER_MAX_SIZE)) {\n      Kryo kryo = SerializationUtilities.borrowKryo();\n      kryo.writeObject(out, sarg);\n      SerializationUtilities.releaseKryo(kryo);"}
{"magic_number_smell": "                }\n              });\n      ((ScheduledThreadPoolExecutor) heartbeatExecutorService).setRemoveOnCancelPolicy(true);\n      ShutdownHookManager.addShutdownHook(DbTxnManager::shutdownHeartbeatExecutorService, 0);\n  }\n\n  private synchronized static void shutdownHeartbeatExecutorService() {", "refactored_code": "  private static final int SHUTDOWN_HOOK_PRIORITY = 0;\n                }\n              });\n      ((ScheduledThreadPoolExecutor) heartbeatExecutorService).setRemoveOnCancelPolicy(true);\n      ShutdownHookManager.addShutdownHook(DbTxnManager::shutdownHeartbeatExecutorService, SHUTDOWN_HOOK_PRIORITY);\n  }\n\n  private synchronized static void shutdownHeartbeatExecutorService() {"}
{"magic_number_smell": "\n  @InterfaceAudience.Private\n  public static long getFatal() {\n    return counts.get(0);\n  }\n\n  @InterfaceAudience.Private", "refactored_code": "  private static final int FATAL = 0;\n\n  @InterfaceAudience.Private\n  public static long getFatal() {\n    return counts.get(FATAL);\n  }\n\n  @InterfaceAudience.Private"}
{"magic_number_smell": "  // 2019-10-13 10:15:35.100 -> 2019-10-13 10:15:00.000\n  private Timestamp roundupToMinuteFloor(final Timestamp ts) {\n    long millis = ts.getTime();\n    long newMillis = 60 * 1000L * (millis / 60 * 1000L);\n    return new Timestamp(newMillis);\n  }\n", "refactored_code": "  private static final long MILLISECONDS_PER_MINUTE = 60 * 1000L;\n  // 2019-10-13 10:15:35.100 -> 2019-10-13 10:15:00.000\n  private Timestamp roundupToMinuteFloor(final Timestamp ts) {\n    long millis = ts.getTime();\n    long newMillis = MILLISECONDS_PER_MINUTE * (millis / MILLISECONDS_PER_MINUTE);\n    return new Timestamp(newMillis);\n  }\n"}
{"magic_number_smell": "      if (sqlState != null) {\n        out.write(sqlState.getBytes(\"UTF-8\")); //this breaks all the tests in .q files\n      }\n      out.write(Utilities.newLineCode);\n    } catch (Exception e) {\n      throw new HiveException(e);\n    }", "refactored_code": "  private static final int TERMINATOR = Utilities.newLineCode;\n      if (sqlState != null) {\n        out.write(sqlState.getBytes(\"UTF-8\")); //this breaks all the tests in .q files\n      }\n      out.write(TERMINATOR);\n    } catch (Exception e) {\n      throw new HiveException(e);\n    }"}
{"magic_number_smell": "    int maxExecutorsPerQuery = conf.getIntVar(ConfVars.LLAP_MEMORY_OVERSUBSCRIPTION_MAX_EXECUTORS_PER_QUERY);\n    if (maxExecutorsPerQuery == -1) {\n      if (llapInfo == null) {\n        maxExecutorsPerQuery = 3;\n      } else {\n        maxExecutorsPerQuery = Math.min(Math.max(1, llapInfo.getNumExecutorsPerNode() / 3), 8);\n      }", "refactored_code": "  private static final int DEFAULT_MAX_EXECUTORS_PER_QUERY_CONTAINER_MODE = 3;\n    int maxExecutorsPerQuery = conf.getIntVar(ConfVars.LLAP_MEMORY_OVERSUBSCRIPTION_MAX_EXECUTORS_PER_QUERY);\n    if (maxExecutorsPerQuery == -1) {\n      if (llapInfo == null) {\n        maxExecutorsPerQuery = DEFAULT_MAX_EXECUTORS_PER_QUERY_CONTAINER_MODE;\n      } else {\n        maxExecutorsPerQuery = Math.min(Math.max(1, llapInfo.getNumExecutorsPerNode() / 3), 8);\n      }"}
{"magic_number_smell": "\n  @Override\n  public int getMaxNumericPrecision() {\n    return 38;\n  }\n\n  @Override", "refactored_code": "  private static final int MAX_DECIMAL_PRECISION     = 38;\n\n  @Override\n  public int getMaxNumericPrecision() {\n    return MAX_DECIMAL_PRECISION;\n  }\n\n  @Override"}
{"magic_number_smell": "      int rightPrec) {\n    final SqlWriter.Frame frame =\n        writer.startList(SqlWriter.FrameTypeEnum.create(\"BETWEEN\"), \"\", \"\");\n    call.operand(1).unparse(writer, getLeftPrec(), 0);\n    writer.sep(super.getName());\n\n    // If the expression for the lower bound contains a call to an AND", "refactored_code": "  public static final int VALUE_OPERAND = 1;\n      int rightPrec) {\n    final SqlWriter.Frame frame =\n        writer.startList(SqlWriter.FrameTypeEnum.create(\"BETWEEN\"), \"\", \"\");\n    call.operand(VALUE_OPERAND).unparse(writer, getLeftPrec(), 0);\n    writer.sep(super.getName());\n\n    // If the expression for the lower bound contains a call to an AND"}
{"magic_number_smell": "      super();\n    }\n\n    private static final long 1L = 1L;\n    // Equivalent aliases for the column\n    private List<String> names = new ArrayList<String>();\n    // Indexes of those equivalent columns", "refactored_code": "    private static final long serialVersionUID = 1L;\n      super();\n    }\n\n    private static final long serialVersionUID = 1L;\n    // Equivalent aliases for the column\n    private List<String> names = new ArrayList<String>();\n    // Indexes of those equivalent columns"}
{"magic_number_smell": "      @Override\n      public LlapClusterStateForCompile call() throws Exception {\n        LOG.info(\"Creating cluster info for \" + userName + \":\" + nodes);\n        return new LlapClusterStateForCompile(conf, 120 * 1000L);\n      }\n    };\n    try {", "refactored_code": "  private static final long CLUSTER_UPDATE_INTERVAL_MS = 120 * 1000L; // 2 minutes.\n      @Override\n      public LlapClusterStateForCompile call() throws Exception {\n        LOG.info(\"Creating cluster info for \" + userName + \":\" + nodes);\n        return new LlapClusterStateForCompile(conf, CLUSTER_UPDATE_INTERVAL_MS);\n      }\n    };\n    try {"}
{"magic_number_smell": "  }\n\n  public int getNumJoins() {\n    return 0;\n  }\n\n  public Set<String> getSubqAliases() {", "refactored_code": "  private final int numJoins = 0;\n  }\n\n  public int getNumJoins() {\n    return numJoins;\n  }\n\n  public Set<String> getSubqAliases() {"}
{"magic_number_smell": "      String expr_formatted = expr_no_tok.replaceAll(\"\\\\W\", \" \").trim().replaceAll(\"\\\\s+\", \"_\");\n\n      // limit length to 20 chars\n      if (expr_formatted.length() > 20) {\n        expr_formatted = expr_formatted.substring(0, 20);\n      }\n", "refactored_code": "  private static final int AUTOGEN_COLALIAS_PRFX_MAXLENGTH = 20;\n      String expr_formatted = expr_no_tok.replaceAll(\"\\\\W\", \" \").trim().replaceAll(\"\\\\s+\", \"_\");\n\n      // limit length to 20 chars\n      if (expr_formatted.length() > AUTOGEN_COLALIAS_PRFX_MAXLENGTH) {\n        expr_formatted = expr_formatted.substring(0, AUTOGEN_COLALIAS_PRFX_MAXLENGTH);\n      }\n"}
{"magic_number_smell": "    }\n\n    public boolean isBounded() {\n      return this.amt != Integer.MAX_VALUE;\n    }\n\n    /**", "refactored_code": "    public static final int UNBOUNDED_AMOUNT = Integer.MAX_VALUE;\n    }\n\n    public boolean isBounded() {\n      return this.amt != UNBOUNDED_AMOUNT;\n    }\n\n    /**"}
{"magic_number_smell": "    int repeat = 0;\n    boolean isCopyError = false;\n    List<Path> pathList = Lists.transform(srcFileList, ReplChangeManager.FileInfo::getEffectivePath);\n    while (!pathList.isEmpty() && (repeat < 5)) {\n      try {\n        // if its retrying, first regenerate the path list.\n        if (repeat > 0) {", "refactored_code": "  private static final int MAX_IO_RETRY = 5;\n    int repeat = 0;\n    boolean isCopyError = false;\n    List<Path> pathList = Lists.transform(srcFileList, ReplChangeManager.FileInfo::getEffectivePath);\n    while (!pathList.isEmpty() && (repeat < MAX_IO_RETRY)) {\n      try {\n        // if its retrying, first regenerate the path list.\n        if (repeat > 0) {"}
{"magic_number_smell": "      isServiceRunning.set(false);\n      return;\n    }\n    if (nDumpThreads > 100) {\n      LOG.warn(\"Thread pool size for ExportService (REPL_TABLE_DUMP_PARALLELISM) is specified higher than limit. \" +\n              \"Choosing thread pool size as 100\");\n      nDumpThreads = 100;", "refactored_code": "  private final int threadPoolSizeLimit = 100;\n      isServiceRunning.set(false);\n      return;\n    }\n    if (nDumpThreads > threadPoolSizeLimit) {\n      LOG.warn(\"Thread pool size for ExportService (REPL_TABLE_DUMP_PARALLELISM) is specified higher than limit. \" +\n              \"Choosing thread pool size as 100\");\n      nDumpThreads = threadPoolSizeLimit;"}
{"magic_number_smell": "        try {\n          long bytesWritten;\n          fos = fs.create(exportFilePath);\n          byte[] buffer = new byte[8 * 1024];\n          int bytesRead;\n          while ((bytesRead = is.read(buffer)) != -1) {\n            fos.write(buffer, 0, bytesRead);", "refactored_code": "  private static final int DEF_BUF_SIZE = 8 * 1024;\n        try {\n          long bytesWritten;\n          fos = fs.create(exportFilePath);\n          byte[] buffer = new byte[DEF_BUF_SIZE];\n          int bytesRead;\n          while ((bytesRead = is.read(buffer)) != -1) {\n            fos.write(buffer, 0, bytesRead);"}
{"magic_number_smell": "  private Tuple extract(Context context) throws SemanticException {\n    try {\n      String tableType = null;\n      long writeId = 0L;\n      switch (context.dmd.getDumpType()) {\n      case EVENT_CREATE_TABLE:\n      case EVENT_ADD_PARTITION:", "refactored_code": "  private static final long DEFAULT_WRITE_ID = 0L;\n  private Tuple extract(Context context) throws SemanticException {\n    try {\n      String tableType = null;\n      long writeId = DEFAULT_WRITE_ID;\n      switch (context.dmd.getDumpType()) {\n      case EVENT_CREATE_TABLE:\n      case EVENT_ADD_PARTITION:"}
{"magic_number_smell": "   *\n   */\n  public static class ConditionalResolverCommonJoinCtx implements Serializable {\n    private static final long 1L = 1L;\n\n    private HashMap<Task<?>, Set<String>> taskToAliases;\n    Map<Path, List<String>> pathToAliases;", "refactored_code": "  private static final long serialVersionUID = 1L;\n   *\n   */\n  public static class ConditionalResolverCommonJoinCtx implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n    private HashMap<Task<?>, Set<String>> taskToAliases;\n    Map<Path, List<String>> pathToAliases;"}
{"magic_number_smell": "   *\n   */\n  public static class ConditionalResolverMergeFilesCtx implements Serializable {\n    private static final long 1L = 1L;\n    List<Task<?>> listTasks;\n    private String dir;\n    private DynamicPartitionCtx dpCtx; // merge task could be after dynamic partition insert", "refactored_code": "  private static final long serialVersionUID = 1L;\n   *\n   */\n  public static class ConditionalResolverMergeFilesCtx implements Serializable {\n    private static final long serialVersionUID = 1L;\n    List<Task<?>> listTasks;\n    private String dir;\n    private DynamicPartitionCtx dpCtx; // merge task could be after dynamic partition insert"}
{"magic_number_smell": "   *\n   */\n  public static class ConditionalResolverSkewJoinCtx implements Serializable {\n    private static final long 1L = 1L;\n    // we store big keys in one table into one dir, and same keys in other\n    // tables into corresponding different dirs (one dir per table).\n    // this map stores mapping from \"big key dir\" to its corresponding mapjoin", "refactored_code": "  private static final long serialVersionUID = 1L;\n   *\n   */\n  public static class ConditionalResolverSkewJoinCtx implements Serializable {\n    private static final long serialVersionUID = 1L;\n    // we store big keys in one table into one dir, and same keys in other\n    // tables into corresponding different dirs (one dir per table).\n    // this map stores mapping from \"big key dir\" to its corresponding mapjoin"}
{"magic_number_smell": "\n  @Explain(displayName = \"Sampling\", explainLevels = { Level.EXTENDED })\n  public String getSamplingTypeString() {\n    return samplingType == 1 ? \"1\" :\n        samplingType == 2 ? \"SAMPLING_ON_START\" : null;\n  }\n", "refactored_code": "  public static final int SAMPLING_ON_PREV_MR = 1;  // todo HIVE-3841\n\n  @Explain(displayName = \"Sampling\", explainLevels = { Level.EXTENDED })\n  public String getSamplingTypeString() {\n    return samplingType == 1 ? \"SAMPLING_ON_PREV_MR\" :\n        samplingType == 2 ? \"SAMPLING_ON_START\" : null;\n  }\n"}
{"magic_number_smell": "    } else if (colTypeLowerCase.equals(serdeConstants.DATE_TYPE_NAME)) {\n      cs.setAvgColLen(JavaDataModel.get().lengthOfDate());\n      // epoch, days since epoch\n      cs.setRange(10593, DATE_RANGE_UPPER_LIMIT);\n    } else {\n      cs.setAvgColLen(getSizeOfComplexTypes(conf, cinfo.getObjectInspector()));\n    }", "refactored_code": "  private static final int DATE_RANGE_LOWER_LIMIT = 10593;\n    } else if (colTypeLowerCase.equals(serdeConstants.DATE_TYPE_NAME)) {\n      cs.setAvgColLen(JavaDataModel.get().lengthOfDate());\n      // epoch, days since epoch\n      cs.setRange(DATE_RANGE_LOWER_LIMIT, DATE_RANGE_UPPER_LIMIT);\n    } else {\n      cs.setAvgColLen(getSizeOfComplexTypes(conf, cinfo.getObjectInspector()));\n    }"}
{"magic_number_smell": "\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {\n      return size() > 16;\n    }\n\n  }", "refactored_code": "    private static final int CACHE_SIZE = 16;\n\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {\n      return size() > CACHE_SIZE;\n    }\n\n  }"}
{"magic_number_smell": "    if (a.get() <= 0.0) {\n      return null;\n    } else {\n      result.set(StrictMath.log(a.get()) / StrictMath.log(2.0));\n      return result;\n    }\n  }", "refactored_code": "  private static final double LOG_2 = StrictMath.log(2.0);\n    if (a.get() <= 0.0) {\n      return null;\n    } else {\n      result.set(StrictMath.log(a.get()) / LOG_2);\n      return result;\n    }\n  }"}
{"magic_number_smell": "   * @return OGCType set in the 5th byte of the hive geometry bytes\n   */\n  public static OGCType getType(BytesWritable geomref) {\n    // 4 is the offset to the byte that stores the type information\n    return OGCTypeLookup[geomref.getBytes()[4]];\n  }\n", "refactored_code": "  private static final int SIZE_WKID = 4;\n   * @return OGCType set in the 5th byte of the hive geometry bytes\n   */\n  public static OGCType getType(BytesWritable geomref) {\n    // SIZE_WKID is the offset to the byte that stores the type information\n    return OGCTypeLookup[geomref.getBytes()[SIZE_WKID]];\n  }\n"}
{"magic_number_smell": "   */\n  public static void Log_SRIDMismatch(Logger logger, BytesWritable geomref1, BytesWritable geomref2) {\n    logger.error(\n        String.format(messages[0], GeometryUtils.getWKID(geomref1), GeometryUtils.getWKID(geomref2)));\n  }\n\n  public static void Log_SRIDMismatch(Logger logger, BytesWritable geomref1, int wkid2) {", "refactored_code": "  private static final int MSG_SRID_MISMATCH = 0;\n   */\n  public static void Log_SRIDMismatch(Logger logger, BytesWritable geomref1, BytesWritable geomref2) {\n    logger.error(\n        String.format(messages[MSG_SRID_MISMATCH], GeometryUtils.getWKID(geomref1), GeometryUtils.getWKID(geomref2)));\n  }\n\n  public static void Log_SRIDMismatch(Logger logger, BytesWritable geomref1, int wkid2) {"}
{"magic_number_smell": "  public static class AggrConvexHullBinaryEvaluator implements UDAFEvaluator {\n\n    private final int 1000 = 1000;\n    private final ArrayList<Geometry> geometries = new ArrayList<Geometry>(1000);\n    SpatialReference spatialRef = null;\n    int firstWKID = -2;\n", "refactored_code": "    private final int MAX_BUFFER_SIZE = 1000;\n  public static class AggrConvexHullBinaryEvaluator implements UDAFEvaluator {\n\n    private final int MAX_BUFFER_SIZE = 1000;\n    private final ArrayList<Geometry> geometries = new ArrayList<Geometry>(MAX_BUFFER_SIZE);\n    SpatialReference spatialRef = null;\n    int firstWKID = -2;\n"}
{"magic_number_smell": "\n    opSimpleRelation = getRelationOperator();\n\n    if (OIs.length != 2) {\n      throw new UDFArgumentException(\"The \" + opSimpleRelation.getType().toString().toLowerCase()\n          + \" relationship operator takes exactly two arguments\");\n    }", "refactored_code": "  private static final int NUM_ARGS = 2;\n\n    opSimpleRelation = getRelationOperator();\n\n    if (OIs.length != NUM_ARGS) {\n      throw new UDFArgumentException(\"The \" + opSimpleRelation.getType().toString().toLowerCase()\n          + \" relationship operator takes exactly two arguments\");\n    }"}
{"magic_number_smell": "      // 10b rows. The scale is the same as the input.\n      DecimalTypeInfo outputTypeInfo = null;\n      if (mode == Mode.PARTIAL1 || mode == Mode.COMPLETE) {\n        int precision = Math.min(HiveDecimal.MAX_PRECISION, inputPrecision + 10);\n        outputTypeInfo = TypeInfoFactory.getDecimalTypeInfo(precision, inputScale);\n      } else {\n        outputTypeInfo = TypeInfoFactory.getDecimalTypeInfo(inputPrecision, inputScale);", "refactored_code": "  public static final int SUM_RESULT_PRECISION_INCREASE = 10;\n      // 10b rows. The scale is the same as the input.\n      DecimalTypeInfo outputTypeInfo = null;\n      if (mode == Mode.PARTIAL1 || mode == Mode.COMPLETE) {\n        int precision = Math.min(HiveDecimal.MAX_PRECISION, inputPrecision + SUM_RESULT_PRECISION_INCREASE);\n        outputTypeInfo = TypeInfoFactory.getDecimalTypeInfo(precision, inputScale);\n      } else {\n        outputTypeInfo = TypeInfoFactory.getDecimalTypeInfo(inputPrecision, inputScale);"}
{"magic_number_smell": "              + ARG_COUNT + \" arguments.\");\n    }\n\n    // Check if 0 argument is of category LIST\n    if (!arguments[0].getCategory().equals(Category.LIST)) {\n      throw new UDFArgumentTypeException(0,\n          \"\\\"\" + org.apache.hadoop.hive.serde.serdeConstants.LIST_TYPE_NAME + \"\\\" \"", "refactored_code": "  private static final int ARRAY_IDX = 0;\n              + ARG_COUNT + \" arguments.\");\n    }\n\n    // Check if ARRAY_IDX argument is of category LIST\n    if (!arguments[ARRAY_IDX].getCategory().equals(Category.LIST)) {\n      throw new UDFArgumentTypeException(ARRAY_IDX,\n          \"\\\"\" + org.apache.hadoop.hive.serde.serdeConstants.LIST_TYPE_NAME + \"\\\" \""}
{"magic_number_smell": "    }\n\n    List<?> retArray = ((ListObjectInspector) argumentOIs[ARRAY_IDX]).getList(array);\n    String separator = arguments[1].get().toString();\n    if (arguments.length > REPLACE_NULL_IDX && arguments[REPLACE_NULL_IDX].get() != null) {\n      result.set(Joiner.on(separator).useForNull(arguments[REPLACE_NULL_IDX].get().toString()).join(retArray));\n    } else {", "refactored_code": "  private static final int SEPARATOR_IDX = 1;\n    }\n\n    List<?> retArray = ((ListObjectInspector) argumentOIs[ARRAY_IDX]).getList(array);\n    String separator = arguments[SEPARATOR_IDX].get().toString();\n    if (arguments.length > REPLACE_NULL_IDX && arguments[REPLACE_NULL_IDX].get() != null) {\n      result.set(Joiner.on(separator).useForNull(arguments[REPLACE_NULL_IDX].get().toString()).join(retArray));\n    } else {"}
{"magic_number_smell": "  @Override\n  public ObjectInspector initialize(ObjectInspector[] arguments) throws UDFArgumentException {\n    super.initialize(arguments);\n    valueOI = arguments[1];\n    checkValueAndListElementTypes(arrayElementOI, FUNC_NAME, valueOI,1);\n    return PrimitiveObjectInspectorFactory.writableIntObjectInspector;\n  }", "refactored_code": "  private static final int ELEMENT_IDX = 1;\n  @Override\n  public ObjectInspector initialize(ObjectInspector[] arguments) throws UDFArgumentException {\n    super.initialize(arguments);\n    valueOI = arguments[ELEMENT_IDX];\n    checkValueAndListElementTypes(arrayElementOI, FUNC_NAME, valueOI,ELEMENT_IDX);\n    return PrimitiveObjectInspectorFactory.writableIntObjectInspector;\n  }"}
{"magic_number_smell": "    ObjectInspector defaultOI = super.initialize(arguments);\n    ObjectInspector arrayElementOI = arrayOI.getListElementObjectInspector();\n\n    ObjectInspector valueOI = arguments[1];\n\n    // Check if list element and value are of same type\n    if (!ObjectInspectorUtils.compareTypes(arrayElementOI, valueOI)) {", "refactored_code": "  private static final int VALUE_IDX = 1;\n    ObjectInspector defaultOI = super.initialize(arguments);\n    ObjectInspector arrayElementOI = arrayOI.getListElementObjectInspector();\n\n    ObjectInspector valueOI = arguments[VALUE_IDX];\n\n    // Check if list element and value are of same type\n    if (!ObjectInspectorUtils.compareTypes(arrayElementOI, valueOI)) {"}
{"magic_number_smell": "  @Override public ObjectInspector initialize(ObjectInspector[] arguments) throws UDFArgumentException {\n    ObjectInspector defaultOI = super.initialize(arguments);\n    // Check whether start and length inputs are of integer type\n    checkArgIntPrimitiveCategory((PrimitiveObjectInspector) arguments[1], FUNC_NAME, 1);\n    checkArgIntPrimitiveCategory((PrimitiveObjectInspector) arguments[LENGTH_IDX], FUNC_NAME, LENGTH_IDX);\n    return defaultOI;\n  }", "refactored_code": "  private static final int START_IDX = 1;\n  @Override public ObjectInspector initialize(ObjectInspector[] arguments) throws UDFArgumentException {\n    ObjectInspector defaultOI = super.initialize(arguments);\n    // Check whether start and length inputs are of integer type\n    checkArgIntPrimitiveCategory((PrimitiveObjectInspector) arguments[START_IDX], FUNC_NAME, START_IDX);\n    checkArgIntPrimitiveCategory((PrimitiveObjectInspector) arguments[LENGTH_IDX], FUNC_NAME, LENGTH_IDX);\n    return defaultOI;\n  }"}
{"magic_number_smell": "    // See https://blogs.msdn.microsoft.com/sqlprogrammability/2006/03/29/multiplication-and-division-with-numerics/\n    int intDigits = precision - scale;\n    // If original scale less than 6, use original scale value; otherwise preserve at least 6 fractional digits\n    int minScaleValue = Math.min(scale, 6);\n    int adjustedScale = HiveDecimal.MAX_PRECISION - intDigits;\n    adjustedScale = Math.max(adjustedScale, minScaleValue);\n", "refactored_code": "  public static final int MINIMUM_ADJUSTED_SCALE = 6;\n    // See https://blogs.msdn.microsoft.com/sqlprogrammability/2006/03/29/multiplication-and-division-with-numerics/\n    int intDigits = precision - scale;\n    // If original scale less than 6, use original scale value; otherwise preserve at least 6 fractional digits\n    int minScaleValue = Math.min(scale, MINIMUM_ADJUSTED_SCALE);\n    int adjustedScale = HiveDecimal.MAX_PRECISION - intDigits;\n    adjustedScale = Math.max(adjustedScale, minScaleValue);\n"}
{"magic_number_smell": "    @Override\n    public ObjectInspector initialize(ObjectInspector[] arguments)\n            throws UDFArgumentException {\n        if (arguments.length != 2) {\n            throw new UDFArgumentException(\"The function \" + FUNC_NAME + \" accepts \" + 2 + \" arguments.\");\n        }\n        for (ObjectInspector arg: arguments) {", "refactored_code": "    private static final int ARG_COUNT = 2; // Number of arguments to this UDF\n    @Override\n    public ObjectInspector initialize(ObjectInspector[] arguments)\n            throws UDFArgumentException {\n        if (arguments.length != ARG_COUNT) {\n            throw new UDFArgumentException(\"The function \" + FUNC_NAME + \" accepts \" + ARG_COUNT + \" arguments.\");\n        }\n        for (ObjectInspector arg: arguments) {"}
{"magic_number_smell": "  private final ObjectInspectorConverter objectInspectorConverter;\n  private final ValueConverter valueConverter;\n\n  private int tag = -1;\n  private UnionObjectInspector unionOI;\n  private ObjectInspector sourceOI;\n", "refactored_code": "  private static final int ALL_TAGS = -1;\n  private final ObjectInspectorConverter objectInspectorConverter;\n  private final ValueConverter valueConverter;\n\n  private int tag = ALL_TAGS;\n  private UnionObjectInspector unionOI;\n  private ObjectInspector sourceOI;\n"}
{"magic_number_smell": "  @Override\n  public ObjectInspector initialize(ObjectInspector[] arguments) throws UDFArgumentException {\n    if (arguments.length == 0) {\n      writeIdBits = 24;\n      taskIdBits = DEFAULT_TASK_ID_BITS;\n      rowIdBits = DEFAULT_ROW_ID_BITS;\n    } else if (arguments.length == 2) {", "refactored_code": "  private static final int DEFAULT_WRITE_ID_BITS = 24;\n  @Override\n  public ObjectInspector initialize(ObjectInspector[] arguments) throws UDFArgumentException {\n    if (arguments.length == 0) {\n      writeIdBits = DEFAULT_WRITE_ID_BITS;\n      taskIdBits = DEFAULT_TASK_ID_BITS;\n      rowIdBits = DEFAULT_ROW_ID_BITS;\n    } else if (arguments.length == 2) {"}
{"magic_number_smell": "\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {\n      return size() > 16;\n    }\n\n  }", "refactored_code": "    private static final int CACHE_SIZE = 16;\n\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {\n      return size() > CACHE_SIZE;\n    }\n\n  }"}
{"magic_number_smell": "  public static final int DESCENDING_CODE = 0;\n\n  private static final ImmutableMap<String, Object> ASCENDING_DATA = ImmutableMap.of(\n      \"code\", 1,\n      \"sign\", '+',\n      \"text\", \"ASC\",\n      \"direction\", Direction.ASCENDING,", "refactored_code": "  public static final int ASCENDING_CODE = 1;\n  public static final int DESCENDING_CODE = 0;\n\n  private static final ImmutableMap<String, Object> ASCENDING_DATA = ImmutableMap.of(\n      \"code\", ASCENDING_CODE,\n      \"sign\", '+',\n      \"text\", \"ASC\",\n      \"direction\", Direction.ASCENDING,"}
{"magic_number_smell": "      //now that we know it can be made acid, rename files as needed\n      //process in batches in case there is a huge # of partitions\n      List<String> partNames = hms.listPartitionNames(t.getDbName(), t.getTableName(), (short)-1);\n      int batchSize = 10000;\n      int numWholeBatches = partNames.size()/batchSize;\n      for(int i = 0; i < numWholeBatches; i++) {\n        List<Partition> partitionList = hms.getPartitionsByNames(t.getDbName(), t.getTableName(),", "refactored_code": "  private static final int PARTITION_BATCH_SIZE = 10000;\n      //now that we know it can be made acid, rename files as needed\n      //process in batches in case there is a huge # of partitions\n      List<String> partNames = hms.listPartitionNames(t.getDbName(), t.getTableName(), (short)-1);\n      int batchSize = PARTITION_BATCH_SIZE;\n      int numWholeBatches = partNames.size()/batchSize;\n      for(int i = 0; i < numWholeBatches; i++) {\n        List<Partition> partitionList = hms.getPartitionsByNames(t.getDbName(), t.getTableName(),"}
{"magic_number_smell": "    for (int i = 0; i < size; i++) {\n      if (nulls && (repeating || i % nullFrequency == 0)) {\n        lcv.isNull[i] = true;\n        lcv.vector[i] = 1;\n\n      } else {\n        lcv.isNull[i] = false;", "refactored_code": "  private static final long LONG_VECTOR_NULL_VALUE = 1;\n    for (int i = 0; i < size; i++) {\n      if (nulls && (repeating || i % nullFrequency == 0)) {\n        lcv.isNull[i] = true;\n        lcv.vector[i] = LONG_VECTOR_NULL_VALUE;\n\n      } else {\n        lcv.isNull[i] = false;"}
{"magic_number_smell": "\n        } catch (ExecutionException ex) {\n          responseList.add(ex.getCause() instanceof CommandProcessorException ?\n                ErrorMsg.COMPILE_LOCK_TIMED_OUT.getErrorCode() : 15151);\n        }\n      }\n    } finally {", "refactored_code": "  private static final int CONCURRENT_COMPILATION = 15151;\n\n        } catch (ExecutionException ex) {\n          responseList.add(ex.getCause() instanceof CommandProcessorException ?\n                ErrorMsg.COMPILE_LOCK_TIMED_OUT.getErrorCode() : CONCURRENT_COMPILATION);\n        }\n      }\n    } finally {"}
{"magic_number_smell": "  }\n\n  public static class DummyOperator extends TableScanOperator {\n    private static final long 1L = 1L;\n\n    public DummyOperator(TableScanDesc conf) {\n      super();", "refactored_code": "    private static final long serialVersionUID = 1L;\n  }\n\n  public static class DummyOperator extends TableScanOperator {\n    private static final long serialVersionUID = 1L;\n\n    public DummyOperator(TableScanDesc conf) {\n      super();"}
{"magic_number_smell": "  }\n\n  private void runDropPartitions(int partCount, int batchSize) throws Exception {\n    runDropPartitions(partCount, batchSize, 0, 1);\n  }\n\n  /**", "refactored_code": "  private final int noException = 1;\n  }\n\n  private void runDropPartitions(int partCount, int batchSize) throws Exception {\n    runDropPartitions(partCount, batchSize, 0, noException);\n  }\n\n  /**"}
{"magic_number_smell": "  @Test\n  public void testRemoveTempOrDuplicateFilesOnMrNoDp() throws Exception {\n    List<Path> paths = runRemoveTempOrDuplicateFilesTestCase(\"mr\", false);\n    assertEquals(3, paths.size());\n  }\n\n  @Test", "refactored_code": "  private static final int NUM_BUCKETS = 3;\n  @Test\n  public void testRemoveTempOrDuplicateFilesOnMrNoDp() throws Exception {\n    List<Path> paths = runRemoveTempOrDuplicateFilesTestCase(\"mr\", false);\n    assertEquals(NUM_BUCKETS, paths.size());\n  }\n\n  @Test"}
{"magic_number_smell": "\n  @Test\n  public void testCapacityValidation() {\n    BytesBytesMultiHashMap map = new BytesBytesMultiHashMap(CAPACITY, 0.75f, WB_SIZE);\n    assertEquals(CAPACITY, map.getCapacity());\n    map = new BytesBytesMultiHashMap(9, 0.75f, WB_SIZE);\n    assertEquals(16, map.getCapacity());", "refactored_code": "  private static final float LOAD_FACTOR = 0.75f;\n\n  @Test\n  public void testCapacityValidation() {\n    BytesBytesMultiHashMap map = new BytesBytesMultiHashMap(CAPACITY, LOAD_FACTOR, WB_SIZE);\n    assertEquals(CAPACITY, map.getCapacity());\n    map = new BytesBytesMultiHashMap(9, LOAD_FACTOR, WB_SIZE);\n    assertEquals(16, map.getCapacity());"}
{"magic_number_smell": "      assertTrue(e.getMessage().contains(ABORT_TASK_ERROR_MSG));\n    }\n\n    assertEquals(2, commitTaskCounter);\n    assertEquals(2, abortTaskCounter);\n    assertEquals(0, commitJobCounter);\n    assertEquals(1, abortJobCounter);", "refactored_code": "  private static final int MAX_TASK_ATTEMPTS = 2;\n      assertTrue(e.getMessage().contains(ABORT_TASK_ERROR_MSG));\n    }\n\n    assertEquals(MAX_TASK_ATTEMPTS, commitTaskCounter);\n    assertEquals(MAX_TASK_ATTEMPTS, abortTaskCounter);\n    assertEquals(0, commitJobCounter);\n    assertEquals(1, abortJobCounter);"}
{"magic_number_smell": "     */\n    @Override\n    public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2) {\n      int c = -1 * WritableComparator.compareBytes(b1, s1 + 4, l1 - 4, b2,\n          s2 + 4, l2 - 4);\n      return c;\n    }", "refactored_code": "  private static final int LENGTH_BYTES = 4;\n     */\n    @Override\n    public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2) {\n      int c = -1 * WritableComparator.compareBytes(b1, s1 + LENGTH_BYTES, l1 - LENGTH_BYTES, b2,\n          s2 + LENGTH_BYTES, l2 - LENGTH_BYTES);\n      return c;\n    }"}
{"magic_number_smell": "\n    public FakeDataReader(int size, int numCols, FakeDataSampleType fakeDataSampleType) {\n      this.size = size;\n      vrg = new VectorizedRowBatch(numCols, 1024);\n      for (int i = 0; i < numCols; i++) {\n        try {\n          Thread.sleep(2);", "refactored_code": "    private final int len = 1024;\n\n    public FakeDataReader(int size, int numCols, FakeDataSampleType fakeDataSampleType) {\n      this.size = size;\n      vrg = new VectorizedRowBatch(numCols, len);\n      for (int i = 0; i < numCols; i++) {\n        try {\n          Thread.sleep(2);"}
{"magic_number_smell": "        /* allowNull */ false, /* isUnicodeOk */ true,\n        mergeDataTypePhysicalVariationList);\n\n    Object[][] mergeRandomRows = mergeRowSource.randomRows(100000);\n\n    // Reduce the key range to cause there to be work for each PARTIAL2 key.\n    final int mergeMaxKeyCount = dataAggrMaxKeyCount / reductionFactor;", "refactored_code": "  private static final int TEST_ROW_COUNT = 100000;\n        /* allowNull */ false, /* isUnicodeOk */ true,\n        mergeDataTypePhysicalVariationList);\n\n    Object[][] mergeRandomRows = mergeRowSource.randomRows(TEST_ROW_COUNT);\n\n    // Reduce the key range to cause there to be work for each PARTIAL2 key.\n    final int mergeMaxKeyCount = dataAggrMaxKeyCount / reductionFactor;"}
{"magic_number_smell": "\n  private void testWriterDouble(TypeInfo type) throws HiveException {\n    DoubleColumnVector dcv = VectorizedRowGroupGenUtil.generateDoubleColumnVector(true, false,\n        this.5, new Random(10));\n    dcv.isNull[2] = true;\n    VectorExpressionWriter vew = getWriter(type);\n    for (int i = 0; i < 5; i++) {", "refactored_code": "  private final int vectorSize = 5;\n\n  private void testWriterDouble(TypeInfo type) throws HiveException {\n    DoubleColumnVector dcv = VectorizedRowGroupGenUtil.generateDoubleColumnVector(true, false,\n        this.vectorSize, new Random(10));\n    dcv.isNull[2] = true;\n    VectorExpressionWriter vew = getWriter(type);\n    for (int i = 0; i < vectorSize; i++) {"}
{"magic_number_smell": "    v2.isRepeating = true; // this value should get over-written with correct value\n    v2.noNulls = true; // ditto\n\n    batch.size = 9;\n    return batch;\n  }\n", "refactored_code": "  private static final int BOOLEAN_COLUMN_TEST_SIZE = 9;\n    v2.isRepeating = true; // this value should get over-written with correct value\n    v2.noNulls = true; // ditto\n\n    batch.size = BOOLEAN_COLUMN_TEST_SIZE;\n    return batch;\n  }\n"}
{"magic_number_smell": "\n  private static final double 1.0e-7 = 1.0e-7;\n  private static boolean equalsWithinTolerance(double a, double b) {\n    return Math.abs(a - b) < 1.0e-7;\n  }\n\n  @Test", "refactored_code": "  private static final double eps = 1.0e-7;\n\n  private static final double eps = 1.0e-7;\n  private static boolean equalsWithinTolerance(double a, double b) {\n    return Math.abs(a - b) < eps;\n  }\n\n  @Test"}
{"magic_number_smell": "  }\n\n  private boolean equalsWithinTolerance(double a, double b) {\n    return Math.abs(a - b) < 1e-7d;\n  }\n\n  @Test", "refactored_code": "  private final double EPS = 1e-7d;\n  }\n\n  private boolean equalsWithinTolerance(double a, double b) {\n    return Math.abs(a - b) < EPS;\n  }\n\n  @Test"}
{"magic_number_smell": "        // No nanos.\n        break;\n      case 1:\n        optionalNanos = r.nextInt((int) TimeUnit.SECONDS.toNanos(1));\n        break;\n      case 2:\n        // Limit to milliseconds only...", "refactored_code": "  public static final long NANOSECONDS_PER_SECOND = TimeUnit.SECONDS.toNanos(1);\n        // No nanos.\n        break;\n      case 1:\n        optionalNanos = r.nextInt((int) NANOSECONDS_PER_SECOND);\n        break;\n      case 2:\n        // Limit to milliseconds only..."}
{"magic_number_smell": "            writeBufferSize,\n            estimatedKeyCount,\n            tableDesc,\n            2);\n\n    addToHashMap(hashMapContainer, keyA, properties);\n    addToHashMap(hashMapContainer, keyB, properties);", "refactored_code": "  private static final int numHashTable = 2;\n            writeBufferSize,\n            estimatedKeyCount,\n            tableDesc,\n            numHashTable);\n\n    addToHashMap(hashMapContainer, keyA, properties);\n    addToHashMap(hashMapContainer, keyB, properties);"}
{"magic_number_smell": "    for(int i = 0; i < size; i++) {\n      if(nulls && (repeating || i % nullFrequency == 0)) {\n        lcv.isNull[i] = true;\n        lcv.vector[i] = 1;\n\n      }else {\n        lcv.isNull[i] = false;", "refactored_code": "  private static final long LONG_VECTOR_NULL_VALUE = 1;\n    for(int i = 0; i < size; i++) {\n      if(nulls && (repeating || i % nullFrequency == 0)) {\n        lcv.isNull[i] = true;\n        lcv.vector[i] = LONG_VECTOR_NULL_VALUE;\n\n      }else {\n        lcv.isNull[i] = false;"}
{"magic_number_smell": "    return HiveHookEvents.HiveHookEventProto\n            .newBuilder()\n            .setEventType(HiveProtoLoggingHook.EventType.QUERY_SUBMITTED.name())\n            .setTimestamp(System.currentTimeMillis())\n            .setHiveQueryId(QUERY_1)\n            .setUser(HIVE)\n            .setRequestUser(HIVE)", "refactored_code": "  private static final long TIMESTAMP = System.currentTimeMillis();\n    return HiveHookEvents.HiveHookEventProto\n            .newBuilder()\n            .setEventType(HiveProtoLoggingHook.EventType.QUERY_SUBMITTED.name())\n            .setTimestamp(TIMESTAMP)\n            .setHiveQueryId(QUERY_1)\n            .setUser(HIVE)\n            .setRequestUser(HIVE)"}
{"magic_number_smell": "\n    private String path;\n    public static final long 1024 * 1024 = 1024 * 1024;\n    private long defaultSplitSize = 1024 * 1024;\n    private final List<HiveInputSplit> splits = new ArrayList<>();\n    private final List<HiveInputSplit> selectedSplits = new ArrayList<>();\n    private long position = 0;", "refactored_code": "    public static final long DEFAULT_SPLIT_SIZE = 1024 * 1024;\n\n    private String path;\n    public static final long DEFAULT_SPLIT_SIZE = 1024 * 1024;\n    private long defaultSplitSize = DEFAULT_SPLIT_SIZE;\n    private final List<HiveInputSplit> splits = new ArrayList<>();\n    private final List<HiveInputSplit> selectedSplits = new ArrayList<>();\n    private long position = 0;"}
{"magic_number_smell": "      throws IOException {\n    r.setSeed(seed);\n    for (int i = 0; i < iter; ++i) {\n      switch (r.nextInt(14)) {\n        case 0:\n          assertEquals((byte)(r.nextInt() & 0xFF), in.readByte()); break;\n        case 1:", "refactored_code": "  private static final int numCases = 14; \n      throws IOException {\n    r.setSeed(seed);\n    for (int i = 0; i < iter; ++i) {\n      switch (r.nextInt(numCases)) {\n        case 0:\n          assertEquals((byte)(r.nextInt() & 0xFF), in.readByte()); break;\n        case 1:"}
{"magic_number_smell": "    key = new OrcFileKeyWrapper();\n    value = new OrcFileValueWrapper();\n    tmpPath  = prepareTmpPath();\n    createOrcFile(5000, 5000 + 1);\n  }\n\n  @After", "refactored_code": "  private static final int TEST_STRIPE_SIZE = 5000;\n    key = new OrcFileKeyWrapper();\n    value = new OrcFileValueWrapper();\n    tmpPath  = prepareTmpPath();\n    createOrcFile(TEST_STRIPE_SIZE, TEST_STRIPE_SIZE + 1);\n  }\n\n  @After"}
{"magic_number_smell": "    RecordUpdater updater = new OrcRecordUpdater(root, options);\n    // Create a single insert delta with 150,000 rows, with 15000 rowIds per original transaction id.\n    for (long i = 1; i <= NUM_OWID; ++i) {\n      for (long j = 0; j < 15000L; ++j) {\n        long payload = (i-1) * 15000L + j;\n        updater.insert(i, new DummyRow(payload, j, i, bucket));\n      }", "refactored_code": "  private static final long NUM_ROWID_PER_OWID = 15000L;\n    RecordUpdater updater = new OrcRecordUpdater(root, options);\n    // Create a single insert delta with 150,000 rows, with 15000 rowIds per original transaction id.\n    for (long i = 1; i <= NUM_OWID; ++i) {\n      for (long j = 0; j < NUM_ROWID_PER_OWID; ++j) {\n        long payload = (i-1) * NUM_ROWID_PER_OWID + j;\n        updater.insert(i, new DummyRow(payload, j, i, bucket));\n      }"}
{"magic_number_smell": "    long minute = calendar.get(Calendar.MINUTE);\n    long second = calendar.get(Calendar.SECOND);\n    long nanos = ts.getNanos();\n    long nanosOfDay = nanos + NANOS_PER_SECOND * second + NANOS_PER_MINUTE * minute + TimeUnit.HOURS.toNanos(1) * hour;\n\n    return new NanoTime(days, nanosOfDay);\n  }", "refactored_code": "  private static final long NANOS_PER_HOUR = TimeUnit.HOURS.toNanos(1);\n    long minute = calendar.get(Calendar.MINUTE);\n    long second = calendar.get(Calendar.SECOND);\n    long nanos = ts.getNanos();\n    long nanosOfDay = nanos + NANOS_PER_SECOND * second + NANOS_PER_MINUTE * minute + NANOS_PER_HOUR * hour;\n\n    return new NanoTime(days, nanosOfDay);\n  }"}
{"magic_number_smell": "    testLockExpiration(txnMgr, 5, true);\n\n    //create a lot of locks\n    for(int i = 0; i < 1000 + 17; i++) {\n      ((DbTxnManager)txnMgr).acquireLocks(qp, ctx, \"PeterI\" + i, true); // No heartbeat\n    }\n    testLockExpiration(txnMgr, 1000 + 17, true);", "refactored_code": "  private static final int TEST_TIMED_OUT_TXN_ABORT_BATCH_SIZE = 1000;\n    testLockExpiration(txnMgr, 5, true);\n\n    //create a lot of locks\n    for(int i = 0; i < TEST_TIMED_OUT_TXN_ABORT_BATCH_SIZE + 17; i++) {\n      ((DbTxnManager)txnMgr).acquireLocks(qp, ctx, \"PeterI\" + i, true); // No heartbeat\n    }\n    testLockExpiration(txnMgr, TEST_TIMED_OUT_TXN_ABORT_BATCH_SIZE + 17, true);"}
{"magic_number_smell": "\n  @Test\n  public void testLessThanSelectivity() {\n    Assert.assertEquals(0.6153846153846154, lessThanSelectivity(KLL, 3), Float.MIN_VALUE);\n  }\n\n  @Test", "refactored_code": "  private static final float DELTA = Float.MIN_VALUE;\n\n  @Test\n  public void testLessThanSelectivity() {\n    Assert.assertEquals(0.6153846153846154, lessThanSelectivity(KLL, 3), DELTA);\n  }\n\n  @Test"}
{"magic_number_smell": "  }\n\n  static class SampleOperator extends Operator<SampleDesc> {\n    private static final long 1L = 1L;\n\n    @Override\n    public void process(Object row, int tag) throws HiveException {", "refactored_code": "    private static final long serialVersionUID = 1L;\n  }\n\n  static class SampleOperator extends Operator<SampleDesc> {\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void process(Object row, int tag) throws HiveException {"}
{"magic_number_smell": "\n  @Test\n  public void testGetTargetSizeTotalLength() {\n    splitSample = new SplitSample(TOTAL_LENGTH, 123);\n    assertEquals(TOTAL_LENGTH, splitSample.getTargetSize(1000));\n    assertEquals(TOTAL_LENGTH, splitSample.getTargetSize(100));\n  }", "refactored_code": "  private static final int SEED_NUM = 123;\n\n  @Test\n  public void testGetTargetSizeTotalLength() {\n    splitSample = new SplitSample(TOTAL_LENGTH, SEED_NUM);\n    assertEquals(TOTAL_LENGTH, splitSample.getTargetSize(1000));\n    assertEquals(TOTAL_LENGTH, splitSample.getTargetSize(100));\n  }"}
{"magic_number_smell": "\npublic class TestReplStateLogTimeFormat {\n  private static final long 1659367078L = 1659367078L;\n  private static final String UTCString = Instant.ofEpochSecond(1659367078L).toString();\n  private static final Set<Class<? extends ReplState>> DUMP_LOG_EXEMPTED_CLASSES;\n  private static final Set<Class<? extends ReplState>> LOAD_LOG_EXEMPTED_CLASSES;\n", "refactored_code": "  private static final long randomDate = 1659367078L;\n\npublic class TestReplStateLogTimeFormat {\n  private static final long randomDate = 1659367078L;\n  private static final String UTCString = Instant.ofEpochSecond(randomDate).toString();\n  private static final Set<Class<? extends ReplState>> DUMP_LOG_EXEMPTED_CLASSES;\n  private static final Set<Class<? extends ReplState>> LOAD_LOG_EXEMPTED_CLASSES;\n"}
{"magic_number_smell": "  }\n\n  private void configureAndSubmitTasks() throws HiveException {\n    when(conf.getIntVar(HiveConf.ConfVars.REPL_TABLE_DUMP_PARALLELISM)).thenReturn(50);\n    exportService = new ExportService(conf);\n    taskNumber = 0;\n    sem = new Semaphore(totalTask);", "refactored_code": "  private final int nThreads = 50;\n  }\n\n  private void configureAndSubmitTasks() throws HiveException {\n    when(conf.getIntVar(HiveConf.ConfVars.REPL_TABLE_DUMP_PARALLELISM)).thenReturn(nThreads);\n    exportService = new ExportService(conf);\n    taskNumber = 0;\n    sem = new Semaphore(totalTask);"}
{"magic_number_smell": "  private static final int NUM_TBL = TEST? 100 : 10000;\n  private static final int NLOOPS = TEST? 1 : 40;\n\n  private final List<TestTable> tables = createTables(TEST? 2 : 20, NUM_TBL);\n  // lookup some\n  private final List<TestTable> filtered = tables.stream()\n      .filter(t -> t.getTableName().endsWith(\"0\"))", "refactored_code": "  private static final int NUM_DB = TEST? 2 : 20;\n  private static final int NUM_TBL = TEST? 100 : 10000;\n  private static final int NLOOPS = TEST? 1 : 40;\n\n  private final List<TestTable> tables = createTables(NUM_DB, NUM_TBL);\n  // lookup some\n  private final List<TestTable> filtered = tables.stream()\n      .filter(t -> t.getTableName().endsWith(\"0\"))"}
{"magic_number_smell": "   * {@link AcidUtils#DELTA_SIDE_FILE_SUFFIX} side file.\n   * @param dataFile - ORC acid data file\n   * @return version property from file if there,\n   *          {@link #0} otherwise\n   */\n  private static int getAcidVersionFromDataFile(Path dataFile, FileSystem fs) throws IOException {\n    FileStatus fileStatus = fs.getFileStatus(dataFile);", "refactored_code": "  private static final int ORC_ACID_VERSION_DEFAULT = 0;\n   * {@link AcidUtils#DELTA_SIDE_FILE_SUFFIX} side file.\n   * @param dataFile - ORC acid data file\n   * @return version property from file if there,\n   *          {@link #ORC_ACID_VERSION_DEFAULT} otherwise\n   */\n  private static int getAcidVersionFromDataFile(Path dataFile, FileSystem fs) throws IOException {\n    FileStatus fileStatus = fs.getFileStatus(dataFile);"}
{"magic_number_smell": "    testCast(STRING, inputOI, date(\"2009-07-30\"), \"yyyy\", \"2009\");\n    testCast(STRING, inputOI, date(\"1969-07-30\"), \"dd\", \"30\");\n\n    testCast(HiveParser.TOK_CHAR, 3, inputOI, date(\"2009-07-30\"), \"yyyy-MM-dd\", \"200\");\n    testCast(HiveParser.TOK_CHAR, 3, inputOI, date(\"2009-07-30\"), \"yyyy\", \"200\");\n    testCast(HiveParser.TOK_CHAR, 3, inputOI, date(\"1969-07-30\"), \"dd\", \"30 \");\n", "refactored_code": "  public static final int CHAR = HiveParser.TOK_CHAR;\n    testCast(STRING, inputOI, date(\"2009-07-30\"), \"yyyy\", \"2009\");\n    testCast(STRING, inputOI, date(\"1969-07-30\"), \"dd\", \"30\");\n\n    testCast(CHAR, 3, inputOI, date(\"2009-07-30\"), \"yyyy-MM-dd\", \"200\");\n    testCast(CHAR, 3, inputOI, date(\"2009-07-30\"), \"yyyy\", \"200\");\n    testCast(CHAR, 3, inputOI, date(\"1969-07-30\"), \"dd\", \"30 \");\n"}
{"magic_number_smell": "    PrimitiveObjectInspector oi = (PrimitiveObjectInspector) udf.initialize(inputOIs);\n    Assert.assertEquals(oi.getTypeInfo(), TypeInfoFactory.doubleTypeInfo);\n    DoubleWritable res = (DoubleWritable) udf.evaluate(args);\n    Assert.assertEquals(123.0 / 456.0, res.get(), 1E-6);\n  }\n\n  @Test", "refactored_code": "  private static final double EPSILON = 1E-6;\n    PrimitiveObjectInspector oi = (PrimitiveObjectInspector) udf.initialize(inputOIs);\n    Assert.assertEquals(oi.getTypeInfo(), TypeInfoFactory.doubleTypeInfo);\n    DoubleWritable res = (DoubleWritable) udf.evaluate(args);\n    Assert.assertEquals(123.0 / 456.0, res.get(), EPSILON);\n  }\n\n  @Test"}
{"magic_number_smell": "    PrimitiveObjectInspector oi = (PrimitiveObjectInspector) udf.initialize(inputOIs);\n    Assert.assertEquals(oi.getTypeInfo(), TypeInfoFactory.doubleTypeInfo);\n    DoubleWritable res = (DoubleWritable) udf.evaluate(args);\n    Assert.assertEquals(-333.0, res.get(), 1E-6);\n  }\n\n  @Test", "refactored_code": "  private static final double EPSILON = 1E-6;\n    PrimitiveObjectInspector oi = (PrimitiveObjectInspector) udf.initialize(inputOIs);\n    Assert.assertEquals(oi.getTypeInfo(), TypeInfoFactory.doubleTypeInfo);\n    DoubleWritable res = (DoubleWritable) udf.evaluate(args);\n    Assert.assertEquals(-333.0, res.get(), EPSILON);\n  }\n\n  @Test"}
{"magic_number_smell": "    PrimitiveObjectInspector oi = (PrimitiveObjectInspector) udf.initialize(inputOIs);\n    Assert.assertEquals(oi.getTypeInfo(), TypeInfoFactory.doubleTypeInfo);\n    DoubleWritable res = (DoubleWritable) udf.evaluate(args);\n    Assert.assertEquals(123 * 456, res.get(), 1E-6);\n  }\n\n  @Test", "refactored_code": "  private static final double EPSILON = 1E-6;\n    PrimitiveObjectInspector oi = (PrimitiveObjectInspector) udf.initialize(inputOIs);\n    Assert.assertEquals(oi.getTypeInfo(), TypeInfoFactory.doubleTypeInfo);\n    DoubleWritable res = (DoubleWritable) udf.evaluate(args);\n    Assert.assertEquals(123 * 456, res.get(), EPSILON);\n  }\n\n  @Test"}
{"magic_number_smell": "    PrimitiveObjectInspector oi = (PrimitiveObjectInspector) udf.initialize(inputOIs);\n    Assert.assertEquals(TypeInfoFactory.floatTypeInfo, oi.getTypeInfo());\n    FloatWritable res = (FloatWritable) udf.evaluate(args);\n    Assert.assertEquals(-323.4747f, res.get(), 1E-6);\n  }\n\n  @Test", "refactored_code": "  private static final double EPSILON = 1E-6;\n    PrimitiveObjectInspector oi = (PrimitiveObjectInspector) udf.initialize(inputOIs);\n    Assert.assertEquals(TypeInfoFactory.floatTypeInfo, oi.getTypeInfo());\n    FloatWritable res = (FloatWritable) udf.evaluate(args);\n    Assert.assertEquals(-323.4747f, res.get(), EPSILON);\n  }\n\n  @Test"}
{"magic_number_smell": "    PrimitiveObjectInspector oi = (PrimitiveObjectInspector) udf.initialize(inputOIs);\n    Assert.assertEquals(oi.getTypeInfo(), TypeInfoFactory.doubleTypeInfo);\n    DoubleWritable res = (DoubleWritable) udf.evaluate(args);\n    Assert.assertEquals(579.0, res.get(), 1E-6);\n  }\n\n  @Test", "refactored_code": "  private static final double EPSILON = 1E-6;\n    PrimitiveObjectInspector oi = (PrimitiveObjectInspector) udf.initialize(inputOIs);\n    Assert.assertEquals(oi.getTypeInfo(), TypeInfoFactory.doubleTypeInfo);\n    DoubleWritable res = (DoubleWritable) udf.evaluate(args);\n    Assert.assertEquals(579.0, res.get(), EPSILON);\n  }\n\n  @Test"}
{"magic_number_smell": "    PrimitiveObjectInspector oi = (PrimitiveObjectInspector) udf.initialize(inputOIs);\n    Assert.assertEquals(TypeInfoFactory.floatTypeInfo, oi.getTypeInfo());\n    FloatWritable res = (FloatWritable) udf.evaluate(args);\n    Assert.assertEquals(323.4747, res.get(), 1E-6);\n  }\n\n  @Test", "refactored_code": "  private static final double EPSILON = 1E-6;\n    PrimitiveObjectInspector oi = (PrimitiveObjectInspector) udf.initialize(inputOIs);\n    Assert.assertEquals(TypeInfoFactory.floatTypeInfo, oi.getTypeInfo());\n    FloatWritable res = (FloatWritable) udf.evaluate(args);\n    Assert.assertEquals(323.4747, res.get(), EPSILON);\n  }\n\n  @Test"}
{"magic_number_smell": "    PrimitiveObjectInspector oi = (PrimitiveObjectInspector) udf.initialize(inputOIs);\n    Assert.assertEquals(TypeInfoFactory.doubleTypeInfo, oi.getTypeInfo());\n    DoubleWritable res = (DoubleWritable) udf.evaluate(args);\n    Assert.assertEquals(16, res.get(), 1E-10);\n  }\n\n  @Test", "refactored_code": "  private static final double EPSILON = 1E-10;\n    PrimitiveObjectInspector oi = (PrimitiveObjectInspector) udf.initialize(inputOIs);\n    Assert.assertEquals(TypeInfoFactory.doubleTypeInfo, oi.getTypeInfo());\n    DoubleWritable res = (DoubleWritable) udf.evaluate(args);\n    Assert.assertEquals(16, res.get(), EPSILON);\n  }\n\n  @Test"}
{"magic_number_smell": "          LOG.info(\"Cache: \" + cacheSize + \" order: \" + order);\n          BoundaryCache cache = cacheSize == null ? null : new BoundaryCache(cacheSize);\n          Pair<PTFPartition, ValueBoundaryScanner> mocks = setupMocks(partition,\n                  2, startBoundary, endBoundary, order, cache, readCounter);\n          PTFPartition ptfPartition = mocks.getLeft();\n          ValueBoundaryScanner scanner = mocks.getRight();\n          for (int i = 0; i < partition.size(); ++i) {", "refactored_code": "  private static final int ORDER_BY_COL = 2;\n          LOG.info(\"Cache: \" + cacheSize + \" order: \" + order);\n          BoundaryCache cache = cacheSize == null ? null : new BoundaryCache(cacheSize);\n          Pair<PTFPartition, ValueBoundaryScanner> mocks = setupMocks(partition,\n                  ORDER_BY_COL, startBoundary, endBoundary, order, cache, readCounter);\n          PTFPartition ptfPartition = mocks.getLeft();\n          ValueBoundaryScanner scanner = mocks.getRight();\n          for (int i = 0; i < partition.size(); ++i) {"}
{"magic_number_smell": "      if (this.tickTime > 0) {\n        tickTimeToUse = this.tickTime;\n      } else {\n        tickTimeToUse = 2000;\n      }\n\n      // Set up client port - if we have already had a list of valid ports, use it.", "refactored_code": "  private static final int TICK_TIME = 2000;\n      if (this.tickTime > 0) {\n        tickTimeToUse = this.tickTime;\n      } else {\n        tickTimeToUse = TICK_TIME;\n      }\n\n      // Set up client port - if we have already had a list of valid ports, use it."}
{"magic_number_smell": "  }\n\n  public void unsetField0() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field field0 is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __FIELD0_ISSET_ID = 0;\n  }\n\n  public void unsetField0() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __FIELD0_ISSET_ID);\n  }\n\n  /** Returns true if field field0 is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetField1() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field field1 is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __FIELD1_ISSET_ID = 0;\n  }\n\n  public void unsetField1() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __FIELD1_ISSET_ID);\n  }\n\n  /** Returns true if field field1 is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetAint() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field aint is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __AINT_ISSET_ID = 0;\n  }\n\n  public void unsetAint() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __AINT_ISSET_ID);\n  }\n\n  /** Returns true if field aint is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetMyint() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field myint is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __MYINT_ISSET_ID = 0;\n  }\n\n  public void unsetMyint() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __MYINT_ISSET_ID);\n  }\n\n  /** Returns true if field myint is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetMy_bool() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field my_bool is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __MY_BOOL_ISSET_ID = 0;\n  }\n\n  public void unsetMy_bool() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __MY_BOOL_ISSET_ID);\n  }\n\n  /** Returns true if field my_bool is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "      break;\n    case 1:\n      optionalNanos = String.format(\".%09d\",\n          Integer.valueOf(r.nextInt((int) TimeUnit.SECONDS.toNanos(1))));\n      break;\n    case 2:\n      // Limit to milliseconds only...", "refactored_code": "  public static final long NANOSECONDS_PER_SECOND = TimeUnit.SECONDS.toNanos(1);\n      break;\n    case 1:\n      optionalNanos = String.format(\".%09d\",\n          Integer.valueOf(r.nextInt((int) NANOSECONDS_PER_SECOND)));\n      break;\n    case 2:\n      // Limit to milliseconds only..."}
{"magic_number_smell": "\n    int firstInt = (int) seconds;\n    if (hasDecimal || hasSecondVInt) {\n      firstInt |= 1 << 31;\n    }\n    intToBytes(firstInt, internalBytes, offset);\n    if (hasSecondVInt) {", "refactored_code": "  private static final int DECIMAL_OR_SECOND_VINT_FLAG = 1 << 31;\n\n    int firstInt = (int) seconds;\n    if (hasDecimal || hasSecondVInt) {\n      firstInt |= DECIMAL_OR_SECOND_VINT_FLAG;\n    }\n    intToBytes(firstInt, internalBytes, offset);\n    if (hasSecondVInt) {"}
{"magic_number_smell": "    int firstInt = (int) seconds;\n    boolean hasSecondVInt = seconds < 0 || seconds > Integer.MAX_VALUE;\n    if (nanos != 0 || hasSecondVInt) {\n      firstInt |= 0x80000000;\n    } else {\n      firstInt &= LOWEST_31_BITS_OF_SEC_MASK;\n    }", "refactored_code": "  private static final int DECIMAL_OR_SECOND_VINT_FLAG = 0x80000000;\n    int firstInt = (int) seconds;\n    boolean hasSecondVInt = seconds < 0 || seconds > Integer.MAX_VALUE;\n    if (nanos != 0 || hasSecondVInt) {\n      firstInt |= DECIMAL_OR_SECOND_VINT_FLAG;\n    } else {\n      firstInt &= LOWEST_31_BITS_OF_SEC_MASK;\n    }"}
{"magic_number_smell": "    int firstInt = (int) seconds;\n    boolean hasSecondVInt = seconds < 0 || seconds > Integer.MAX_VALUE;\n    if (nanos != 0 || hasSecondVInt) {\n      firstInt |= 0x80000000;\n    } else {\n      firstInt &= LOWEST_31_BITS_OF_SEC_MASK;\n    }", "refactored_code": "  private static final int DECIMAL_OR_SECOND_VINT_FLAG = 0x80000000;\n    int firstInt = (int) seconds;\n    boolean hasSecondVInt = seconds < 0 || seconds > Integer.MAX_VALUE;\n    if (nanos != 0 || hasSecondVInt) {\n      firstInt |= DECIMAL_OR_SECOND_VINT_FLAG;\n    } else {\n      firstInt &= LOWEST_31_BITS_OF_SEC_MASK;\n    }"}
{"magic_number_smell": "  private static ThreadLocal<byte[]> vLongBytesThreadLocal = new ThreadLocal<byte[]>() {\n    @Override\n    public byte[] initialValue() {\n      return new byte[9];\n    }\n  };\n", "refactored_code": "  public static final int VLONG_BYTES_LEN = 9;\n  private static ThreadLocal<byte[]> vLongBytesThreadLocal = new ThreadLocal<byte[]>() {\n    @Override\n    public byte[] initialValue() {\n      return new byte[VLONG_BYTES_LEN];\n    }\n  };\n"}
{"magic_number_smell": "      return null;\n    }\n    String dateString = String.valueOf(di + 19000000);\n    if (dateString.length() < 8) {\n      dateString = StringUtils.leftPad(dateString, 8, '0');\n    }\n    Date date = new Date();", "refactored_code": "  private static final int DATE_STRING_LENGTH = 8;\n      return null;\n    }\n    String dateString = String.valueOf(di + 19000000);\n    if (dateString.length() < DATE_STRING_LENGTH) {\n      dateString = StringUtils.leftPad(dateString, DATE_STRING_LENGTH, '0');\n    }\n    Date date = new Date();"}
{"magic_number_smell": "    }\n    write(sTimeStamp.getBytes(\"UTF8\"));\n    String pad;\n    if (sTimeStamp.length() == 19) {\n      pad = \".\" + join(\"\", Collections.nCopies(byteNum - sTimeStamp.length() - 1, \"0\"));\n    } else {\n      pad = join(\"\", Collections.nCopies(byteNum - sTimeStamp.length(), \"0\"));", "refactored_code": "  private static final int TIMESTAMP_NO_NANOS_BYTE_NUM = 19;\n    }\n    write(sTimeStamp.getBytes(\"UTF8\"));\n    String pad;\n    if (sTimeStamp.length() == TIMESTAMP_NO_NANOS_BYTE_NUM) {\n      pad = \".\" + join(\"\", Collections.nCopies(byteNum - sTimeStamp.length() - 1, \"0\"));\n    } else {\n      pad = join(\"\", Collections.nCopies(byteNum - sTimeStamp.length(), \"0\"));"}
{"magic_number_smell": "\n  private int getTimeStampByteNum(int precision) {\n    if (precision == 0) {\n      return 19;\n    } else {\n      return precision + 1 + 19;\n    }", "refactored_code": "  private static final int DEFAULT_TIMESTAMP_BYTE_NUM = 19;\n\n  private int getTimeStampByteNum(int precision) {\n    if (precision == 0) {\n      return DEFAULT_TIMESTAMP_BYTE_NUM;\n    } else {\n      return precision + 1 + DEFAULT_TIMESTAMP_BYTE_NUM;\n    }"}
{"magic_number_smell": "    nulls = new BitSet();\n    switch (type) {\n      case BOOLEAN_TYPE:\n        boolVars = new boolean[100];\n        break;\n      case TINYINT_TYPE:\n        byteVars = new byte[100];", "refactored_code": "  private static final int DEFAULT_SIZE = 100;\n    nulls = new BitSet();\n    switch (type) {\n      case BOOLEAN_TYPE:\n        boolVars = new boolean[DEFAULT_SIZE];\n        break;\n      case TINYINT_TYPE:\n        byteVars = new byte[DEFAULT_SIZE];"}
{"magic_number_smell": "  private static final int 4 = 4;\n  private static final int SCALE = 2;\n  private static final TypeInfo DECIMAL = TypeInfoFactory.getPrimitiveTypeInfo(\n      new DecimalTypeInfo(4, SCALE).getQualifiedName());\n  private static final int CHAR_LEN = 5;\n  private static final TypeInfo CHAR = TypeInfoFactory.getPrimitiveTypeInfo(\n      new CharTypeInfo(CHAR_LEN).getQualifiedName());", "refactored_code": "  private static final int PRECISION = 4;\n  private static final int PRECISION = 4;\n  private static final int SCALE = 2;\n  private static final TypeInfo DECIMAL = TypeInfoFactory.getPrimitiveTypeInfo(\n      new DecimalTypeInfo(PRECISION, SCALE).getQualifiedName());\n  private static final int CHAR_LEN = 5;\n  private static final TypeInfo CHAR = TypeInfoFactory.getPrimitiveTypeInfo(\n      new CharTypeInfo(CHAR_LEN).getQualifiedName());"}
{"magic_number_smell": "\n      int nanos = reverseNanos(ts.getNanos());\n      assertEquals(ts,\n        fromIntAndVInts((int) timeSeconds | (nanos != 0 ? 0x80000000 : 0),\n          nanos).getTimestamp());\n    }\n", "refactored_code": "  private static final int HAS_DECIMAL_MASK = 0x80000000;\n\n      int nanos = reverseNanos(ts.getNanos());\n      assertEquals(ts,\n        fromIntAndVInts((int) timeSeconds | (nanos != 0 ? HAS_DECIMAL_MASK : 0),\n          nanos).getTimestamp());\n    }\n"}
{"magic_number_smell": "    this.type = type;\n    switch (type) {\n      case BOOLEAN_TYPE:\n        vars = new boolean[100];\n        break;\n      case TINYINT_TYPE:\n        vars = new byte[100];", "refactored_code": "  private static final int NUM_VARS = 100;\n    this.type = type;\n    switch (type) {\n      case BOOLEAN_TYPE:\n        vars = new boolean[NUM_VARS];\n        break;\n      case TINYINT_TYPE:\n        vars = new byte[NUM_VARS];"}
{"magic_number_smell": "\n  @Override\n  public long getStartTime() {\n    return System.currentTimeMillis();\n  }\n\n}", "refactored_code": "  private final long startTime = System.currentTimeMillis();\n\n  @Override\n  public long getStartTime() {\n    return startTime;\n  }\n\n}"}
{"magic_number_smell": "    boolean terminated = operation.isDone();\n    try {\n      while ((sessionState.getProgressMonitor() == null) && !terminated) {\n        long remainingMs = (30 * 1000000000l - (System.nanoTime() - startTime)) / 1000000l;\n        if (remainingMs <= 0) {\n          LOG.debug(\"timed out and hence returning progress log as NULL\");\n          return new JobProgressUpdate(ProgressMonitor.NULL);", "refactored_code": "  private static final long PROGRESS_MAX_WAIT_NS = 30 * 1000000000l;\n    boolean terminated = operation.isDone();\n    try {\n      while ((sessionState.getProgressMonitor() == null) && !terminated) {\n        long remainingMs = (PROGRESS_MAX_WAIT_NS - (System.nanoTime() - startTime)) / 1000000l;\n        if (remainingMs <= 0) {\n          LOG.debug(\"timed out and hence returning progress log as NULL\");\n          return new JobProgressUpdate(ProgressMonitor.NULL);"}
{"magic_number_smell": "  private void shutdownExecutor(final ExecutorService leaderActionsExecutorService) {\n    leaderActionsExecutorService.shutdown();\n    try {\n      if (!leaderActionsExecutorService.awaitTermination(60, TimeUnit.SECONDS)) {\n        LOG.warn(\"Executor service did not terminate in the specified time {} sec\", 60);\n        List<Runnable> droppedTasks = leaderActionsExecutorService.shutdownNow();\n        LOG.warn(\"Executor service was abruptly shut down. \" + droppedTasks.size() + \" tasks will not be executed.\");", "refactored_code": "  private static final int SHUTDOWN_TIME = 60;\n  private void shutdownExecutor(final ExecutorService leaderActionsExecutorService) {\n    leaderActionsExecutorService.shutdown();\n    try {\n      if (!leaderActionsExecutorService.awaitTermination(SHUTDOWN_TIME, TimeUnit.SECONDS)) {\n        LOG.warn(\"Executor service did not terminate in the specified time {} sec\", SHUTDOWN_TIME);\n        List<Runnable> droppedTasks = leaderActionsExecutorService.shutdownNow();\n        LOG.warn(\"Executor service was abruptly shut down. \" + droppedTasks.size() + \" tasks will not be executed.\");"}
{"magic_number_smell": "    try {\n      barrier.setBarrier(queryIdOrTag, hiveServer2.getServerInstanceURI(), doAs, doAsAdmin);\n      LOG.info(\"Created kill query barrier in path: {} for queryId: {}\", barrier.getBarrierPath(), queryIdOrTag);\n      result = barrier.waitOnBarrier(serverHosts.size() - 1, 30,\n          MAX_WAIT_ON_KILL_SECONDS, TimeUnit.SECONDS);\n\n    } catch (Exception e) {", "refactored_code": "  public static final int MAX_WAIT_ON_CONFIRMATION_SECONDS = 30;\n    try {\n      barrier.setBarrier(queryIdOrTag, hiveServer2.getServerInstanceURI(), doAs, doAsAdmin);\n      LOG.info(\"Created kill query barrier in path: {} for queryId: {}\", barrier.getBarrierPath(), queryIdOrTag);\n      result = barrier.waitOnBarrier(serverHosts.size() - 1, MAX_WAIT_ON_CONFIRMATION_SECONDS,\n          MAX_WAIT_ON_KILL_SECONDS, TimeUnit.SECONDS);\n\n    } catch (Exception e) {"}
{"magic_number_smell": "\n    boolean allComplete = false;\n    final long step = 200;\n    final long timeout = System.currentTimeMillis() + 600000;\n\n    while (!allComplete) {\n      allComplete = true;", "refactored_code": "  private static final long ASYNC_QUERY_TIMEOUT_MS = 600000;\n\n    boolean allComplete = false;\n    final long step = 200;\n    final long timeout = System.currentTimeMillis() + ASYNC_QUERY_TIMEOUT_MS;\n\n    while (!allComplete) {\n      allComplete = true;"}
{"magic_number_smell": "\n    @Override\n    public long getNoOperationTime() {\n      return 0xbeef0001;\n    }\n  }\n", "refactored_code": "    public static final int MAGIC_RETURN_VALUE = 0xbeef0001;\n\n    @Override\n    public long getNoOperationTime() {\n      return MAGIC_RETURN_VALUE;\n    }\n  }\n"}
{"magic_number_smell": "  private static CodahaleMetrics metrics;\n  private static final int 30 = 30;\n  private static final String FAIL_TO_START_MSG = \"The tasks could not be started within \"\n      + 30 + \" seconds before the %s metrics verification.\";\n  private static final String FAIL_TO_COMPLETE_MSG = \"The tasks could not be completed within \"\n      + 30 + \" seconds after the %s metrics verification.\";\n", "refactored_code": "  private static final int BARRIER_AWAIT_TIMEOUT = 30;\n  private static CodahaleMetrics metrics;\n  private static final int BARRIER_AWAIT_TIMEOUT = 30;\n  private static final String FAIL_TO_START_MSG = \"The tasks could not be started within \"\n      + BARRIER_AWAIT_TIMEOUT + \" seconds before the %s metrics verification.\";\n  private static final String FAIL_TO_COMPLETE_MSG = \"The tasks could not be completed within \"\n      + BARRIER_AWAIT_TIMEOUT + \" seconds after the %s metrics verification.\";\n"}
{"magic_number_smell": "  }\n\n  public void unsetObjectTypePtr() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field objectTypePtr is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __OBJECTTYPEPTR_ISSET_ID = 0;\n  }\n\n  public void unsetObjectTypePtr() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __OBJECTTYPEPTR_ISSET_ID);\n  }\n\n  /** Returns true if field objectTypePtr is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetValue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field value is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __VALUE_ISSET_ID = 0;\n  }\n\n  public void unsetValue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __VALUE_ISSET_ID);\n  }\n\n  /** Returns true if field value is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetValue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field value is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __VALUE_ISSET_ID = 0;\n  }\n\n  public void unsetValue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __VALUE_ISSET_ID);\n  }\n\n  /** Returns true if field value is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetPosition() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field position is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __POSITION_ISSET_ID = 0;\n  }\n\n  public void unsetPosition() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __POSITION_ISSET_ID);\n  }\n\n  /** Returns true if field position is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetValue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field value is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __VALUE_ISSET_ID = 0;\n  }\n\n  public void unsetValue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __VALUE_ISSET_ID);\n  }\n\n  /** Returns true if field value is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetRunAsync() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field runAsync is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __RUNASYNC_ISSET_ID = 0;\n  }\n\n  public void unsetRunAsync() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __RUNASYNC_ISSET_ID);\n  }\n\n  /** Returns true if field runAsync is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetMaxRows() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field maxRows is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __MAXROWS_ISSET_ID = 0;\n  }\n\n  public void unsetMaxRows() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __MAXROWS_ISSET_ID);\n  }\n\n  /** Returns true if field maxRows is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetHasMoreRows() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field hasMoreRows is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __HASMOREROWS_ISSET_ID = 0;\n  }\n\n  public void unsetHasMoreRows() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __HASMOREROWS_ISSET_ID);\n  }\n\n  /** Returns true if field hasMoreRows is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetGetProgressUpdate() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field getProgressUpdate is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __GETPROGRESSUPDATE_ISSET_ID = 0;\n  }\n\n  public void unsetGetProgressUpdate() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __GETPROGRESSUPDATE_ISSET_ID);\n  }\n\n  /** Returns true if field getProgressUpdate is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetErrorCode() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field errorCode is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ERRORCODE_ISSET_ID = 0;\n  }\n\n  public void unsetErrorCode() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ERRORCODE_ISSET_ID);\n  }\n\n  /** Returns true if field errorCode is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetValue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field value is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __VALUE_ISSET_ID = 0;\n  }\n\n  public void unsetValue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __VALUE_ISSET_ID);\n  }\n\n  /** Returns true if field value is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetValue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field value is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __VALUE_ISSET_ID = 0;\n  }\n\n  public void unsetValue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __VALUE_ISSET_ID);\n  }\n\n  /** Returns true if field value is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetValue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field value is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __VALUE_ISSET_ID = 0;\n  }\n\n  public void unsetValue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __VALUE_ISSET_ID);\n  }\n\n  /** Returns true if field value is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetKeyTypePtr() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field keyTypePtr is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __KEYTYPEPTR_ISSET_ID = 0;\n  }\n\n  public void unsetKeyTypePtr() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __KEYTYPEPTR_ISSET_ID);\n  }\n\n  /** Returns true if field keyTypePtr is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetHasResultSet() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field hasResultSet is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __HASRESULTSET_ISSET_ID = 0;\n  }\n\n  public void unsetHasResultSet() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __HASRESULTSET_ISSET_ID);\n  }\n\n  /** Returns true if field hasResultSet is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetProgressedPercentage() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field progressedPercentage is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __PROGRESSEDPERCENTAGE_ISSET_ID = 0;\n  }\n\n  public void unsetProgressedPercentage() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __PROGRESSEDPERCENTAGE_ISSET_ID);\n  }\n\n  /** Returns true if field progressedPercentage is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetStartRowOffset() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field startRowOffset is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __STARTROWOFFSET_ISSET_ID = 0;\n  }\n\n  public void unsetStartRowOffset() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __STARTROWOFFSET_ISSET_ID);\n  }\n\n  /** Returns true if field startRowOffset is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetErrorCode() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field errorCode is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ERRORCODE_ISSET_ID = 0;\n  }\n\n  public void unsetErrorCode() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ERRORCODE_ISSET_ID);\n  }\n\n  /** Returns true if field errorCode is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetCompactionId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field compactionId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __COMPACTIONID_ISSET_ID = 0;\n  }\n\n  public void unsetCompactionId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __COMPACTIONID_ISSET_ID);\n  }\n\n  /** Returns true if field compactionId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTxnid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field txnid is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TXNID_ISSET_ID = 0;\n  }\n\n  public void unsetTxnid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TXNID_ISSET_ID);\n  }\n\n  /** Returns true if field txnid is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetErrorCode() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field errorCode is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ERRORCODE_ISSET_ID = 0;\n  }\n\n  public void unsetErrorCode() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ERRORCODE_ISSET_ID);\n  }\n\n  /** Returns true if field errorCode is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTxnid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field txnid is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TXNID_ISSET_ID = 0;\n  }\n\n  public void unsetTxnid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TXNID_ISSET_ID);\n  }\n\n  /** Returns true if field txnid is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetIfNotExists() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field ifNotExists is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __IFNOTEXISTS_ISSET_ID = 0;\n  }\n\n  public void unsetIfNotExists() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __IFNOTEXISTS_ISSET_ID);\n  }\n\n  /** Returns true if field ifNotExists is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetIsStatsCompliant() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field isStatsCompliant is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ISSTATSCOMPLIANT_ISSET_ID = 0;\n  }\n\n  public void unsetIsStatsCompliant() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ISSTATSCOMPLIANT_ISSET_ID);\n  }\n\n  /** Returns true if field isStatsCompliant is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetPartsFound() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field partsFound is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __PARTSFOUND_ISSET_ID = 0;\n  }\n\n  public void unsetPartsFound() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __PARTSFOUND_ISSET_ID);\n  }\n\n  /** Returns true if field partsFound is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetReallocate() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field reallocate is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __REALLOCATE_ISSET_ID = 0;\n  }\n\n  public void unsetReallocate() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __REALLOCATE_ISSET_ID);\n  }\n\n  /** Returns true if field reallocate is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TABLEID_ISSET_ID = 0;\n  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TABLEID_ISSET_ID);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetWriteId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field writeId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __WRITEID_ISSET_ID = 0;\n  }\n\n  public void unsetWriteId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __WRITEID_ISSET_ID);\n  }\n\n  /** Returns true if field writeId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetWriteId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field writeId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __WRITEID_ISSET_ID = 0;\n  }\n\n  public void unsetWriteId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __WRITEID_ISSET_ID);\n  }\n\n  /** Returns true if field writeId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetIsnull() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field isnull is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ISNULL_ISSET_ID = 0;\n  }\n\n  public void unsetIsnull() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ISNULL_ISSET_ID);\n  }\n\n  /** Returns true if field isnull is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetMaxColLen() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field maxColLen is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __MAXCOLLEN_ISSET_ID = 0;\n  }\n\n  public void unsetMaxColLen() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __MAXCOLLEN_ISSET_ID);\n  }\n\n  /** Returns true if field maxColLen is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetNumTrues() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field numTrues is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __NUMTRUES_ISSET_ID = 0;\n  }\n\n  public void unsetNumTrues() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __NUMTRUES_ISSET_ID);\n  }\n\n  /** Returns true if field numTrues is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetIsAllParts() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field isAllParts is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ISALLPARTS_ISSET_ID = 0;\n  }\n\n  public void unsetIsAllParts() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ISALLPARTS_ISSET_ID);\n  }\n\n  /** Returns true if field isAllParts is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetIsSupported() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field isSupported is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ISSUPPORTED_ISSET_ID = 0;\n  }\n\n  public void unsetIsSupported() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ISSUPPORTED_ISSET_ID);\n  }\n\n  /** Returns true if field isSupported is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __CREATETIME_ISSET_ID = 0;\n  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __CREATETIME_ISSET_ID);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TABLEID_ISSET_ID = 0;\n  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TABLEID_ISSET_ID);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetLockid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field lockid is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __LOCKID_ISSET_ID = 0;\n  }\n\n  public void unsetLockid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __LOCKID_ISSET_ID);\n  }\n\n  /** Returns true if field lockid is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetPurge() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field purge is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __PURGE_ISSET_ID = 0;\n  }\n\n  public void unsetPurge() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __PURGE_ISSET_ID);\n  }\n\n  /** Returns true if field purge is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetIsStatsCompliant() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field isStatsCompliant is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ISSTATSCOMPLIANT_ISSET_ID = 0;\n  }\n\n  public void unsetIsStatsCompliant() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ISSTATSCOMPLIANT_ISSET_ID);\n  }\n\n  /** Returns true if field isStatsCompliant is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetIsTblLevel() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field isTblLevel is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ISTBLLEVEL_ISSET_ID = 0;\n  }\n\n  public void unsetIsTblLevel() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ISTBLLEVEL_ISSET_ID);\n  }\n\n  /** Returns true if field isTblLevel is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TABLEID_ISSET_ID = 0;\n  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TABLEID_ISSET_ID);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTxnid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field txnid is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TXNID_ISSET_ID = 0;\n  }\n\n  public void unsetTxnid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TXNID_ISSET_ID);\n  }\n\n  /** Returns true if field txnid is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field id is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ID_ISSET_ID = 0;\n  }\n\n  public void unsetId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ID_ISSET_ID);\n  }\n\n  /** Returns true if field id is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetMetricvalue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field metricvalue is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __METRICVALUE_ISSET_ID = 0;\n  }\n\n  public void unsetMetricvalue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __METRICVALUE_ISSET_ID);\n  }\n\n  /** Returns true if field metricvalue is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetNumberOfBuckets() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field numberOfBuckets is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __NUMBEROFBUCKETS_ISSET_ID = 0;\n  }\n\n  public void unsetNumberOfBuckets() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __NUMBEROFBUCKETS_ISSET_ID);\n  }\n\n  /** Returns true if field numberOfBuckets is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field id is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ID_ISSET_ID = 0;\n  }\n\n  public void unsetId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ID_ISSET_ID);\n  }\n\n  /** Returns true if field id is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __CREATETIME_ISSET_ID = 0;\n  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __CREATETIME_ISSET_ID);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetMaterializationTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field materializationTime is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __MATERIALIZATIONTIME_ISSET_ID = 0;\n  }\n\n  public void unsetMaterializationTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __MATERIALIZATIONTIME_ISSET_ID);\n  }\n\n  /** Returns true if field materializationTime is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetEventId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field eventId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __EVENTID_ISSET_ID = 0;\n  }\n\n  public void unsetEventId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __EVENTID_ISSET_ID);\n  }\n\n  /** Returns true if field eventId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __CREATETIME_ISSET_ID = 0;\n  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __CREATETIME_ISSET_ID);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __CREATETIME_ISSET_ID = 0;\n  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __CREATETIME_ISSET_ID);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetDaysSinceEpoch() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field daysSinceEpoch is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __DAYSSINCEEPOCH_ISSET_ID = 0;\n  }\n\n  public void unsetDaysSinceEpoch() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __DAYSSINCEEPOCH_ISSET_ID);\n  }\n\n  /** Returns true if field daysSinceEpoch is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetNumNulls() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field numNulls is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __NUMNULLS_ISSET_ID = 0;\n  }\n\n  public void unsetNumNulls() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __NUMNULLS_ISSET_ID);\n  }\n\n  /** Returns true if field numNulls is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetScale() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field scale is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __SCALE_ISSET_ID = 0;\n  }\n\n  public void unsetScale() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __SCALE_ISSET_ID);\n  }\n\n  /** Returns true if field scale is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetNumNulls() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field numNulls is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __NUMNULLS_ISSET_ID = 0;\n  }\n\n  public void unsetNumNulls() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __NUMNULLS_ISSET_ID);\n  }\n\n  /** Returns true if field numNulls is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TABLEID_ISSET_ID = 0;\n  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TABLEID_ISSET_ID);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetLowValue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field lowValue is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __LOWVALUE_ISSET_ID = 0;\n  }\n\n  public void unsetLowValue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __LOWVALUE_ISSET_ID);\n  }\n\n  /** Returns true if field lowValue is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetIgnoreUnknownDb() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field ignoreUnknownDb is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __IGNOREUNKNOWNDB_ISSET_ID = 0;\n  }\n\n  public void unsetIgnoreUnknownDb() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __IGNOREUNKNOWNDB_ISSET_ID);\n  }\n\n  /** Returns true if field ignoreUnknownDb is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetPartArchiveLevel() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field partArchiveLevel is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __PARTARCHIVELEVEL_ISSET_ID = 0;\n  }\n\n  public void unsetPartArchiveLevel() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __PARTARCHIVELEVEL_ISSET_ID);\n  }\n\n  /** Returns true if field partArchiveLevel is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetDeleteData() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field deleteData is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __DELETEDATA_ISSET_ID = 0;\n  }\n\n  public void unsetDeleteData() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __DELETEDATA_ISSET_ID);\n  }\n\n  /** Returns true if field deleteData is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetAccessType() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field accessType is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ACCESSTYPE_ISSET_ID = 0;\n  }\n\n  public void unsetAccessType() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ACCESSTYPE_ISSET_ID);\n  }\n\n  /** Returns true if field accessType is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetType() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field type is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TYPE_ISSET_ID = 0;\n  }\n\n  public void unsetType() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TYPE_ISSET_ID);\n  }\n\n  /** Returns true if field type is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetSuccessful() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field successful is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __SUCCESSFUL_ISSET_ID = 0;\n  }\n\n  public void unsetSuccessful() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __SUCCESSFUL_ISSET_ID);\n  }\n\n  /** Returns true if field successful is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TABLEID_ISSET_ID = 0;\n  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TABLEID_ISSET_ID);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __CREATETIME_ISSET_ID = 0;\n  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __CREATETIME_ISSET_ID);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTxnId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field txnId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TXNID_ISSET_ID = 0;\n  }\n\n  public void unsetTxnId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TXNID_ISSET_ID);\n  }\n\n  /** Returns true if field txnId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field id is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ID_ISSET_ID = 0;\n  }\n\n  public void unsetId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ID_ISSET_ID);\n  }\n\n  /** Returns true if field id is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetDoGetFooters() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field doGetFooters is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __DOGETFOOTERS_ISSET_ID = 0;\n  }\n\n  public void unsetDoGetFooters() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __DOGETFOOTERS_ISSET_ID);\n  }\n\n  /** Returns true if field doGetFooters is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetIsSupported() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field isSupported is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ISSUPPORTED_ISSET_ID = 0;\n  }\n\n  public void unsetIsSupported() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ISSUPPORTED_ISSET_ID);\n  }\n\n  /** Returns true if field isSupported is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetIsSupported() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field isSupported is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ISSUPPORTED_ISSET_ID = 0;\n  }\n\n  public void unsetIsSupported() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ISSUPPORTED_ISSET_ID);\n  }\n\n  /** Returns true if field isSupported is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetLastCompactionId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field lastCompactionId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __LASTCOMPACTIONID_ISSET_ID = 0;\n  }\n\n  public void unsetLastCompactionId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __LASTCOMPACTIONID_ISSET_ID);\n  }\n\n  /** Returns true if field lastCompactionId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTxn_high_water_mark() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field txn_high_water_mark is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TXN_HIGH_WATER_MARK_ISSET_ID = 0;\n  }\n\n  public void unsetTxn_high_water_mark() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TXN_HIGH_WATER_MARK_ISSET_ID);\n  }\n\n  /** Returns true if field txn_high_water_mark is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTxn_high_water_mark() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field txn_high_water_mark is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TXN_HIGH_WATER_MARK_ISSET_ID = 0;\n  }\n\n  public void unsetTxn_high_water_mark() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TXN_HIGH_WATER_MARK_ISSET_ID);\n  }\n\n  /** Returns true if field txn_high_water_mark is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetMaxParts() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field maxParts is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __MAXPARTS_ISSET_ID = 0;\n  }\n\n  public void unsetMaxParts() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __MAXPARTS_ISSET_ID);\n  }\n\n  /** Returns true if field maxParts is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field id is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ID_ISSET_ID = 0;\n  }\n\n  public void unsetId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ID_ISSET_ID);\n  }\n\n  /** Returns true if field id is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetMaxParts() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field maxParts is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __MAXPARTS_ISSET_ID = 0;\n  }\n\n  public void unsetMaxParts() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __MAXPARTS_ISSET_ID);\n  }\n\n  /** Returns true if field maxParts is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetGet_col_stats() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field get_col_stats is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __GET_COL_STATS_ISSET_ID = 0;\n  }\n\n  public void unsetGet_col_stats() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __GET_COL_STATS_ISSET_ID);\n  }\n\n  /** Returns true if field get_col_stats is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetMaxParts() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field maxParts is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __MAXPARTS_ISSET_ID = 0;\n  }\n\n  public void unsetMaxParts() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __MAXPARTS_ISSET_ID);\n  }\n\n  /** Returns true if field maxParts is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetWithAuth() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field withAuth is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __WITHAUTH_ISSET_ID = 0;\n  }\n\n  public void unsetWithAuth() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __WITHAUTH_ISSET_ID);\n  }\n\n  /** Returns true if field withAuth is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetScheduledExecutionId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field scheduledExecutionId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __SCHEDULEDEXECUTIONID_ISSET_ID = 0;\n  }\n\n  public void unsetScheduledExecutionId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __SCHEDULEDEXECUTIONID_ISSET_ID);\n  }\n\n  /** Returns true if field scheduledExecutionId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetMaxWeight() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field maxWeight is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __MAXWEIGHT_ISSET_ID = 0;\n  }\n\n  public void unsetMaxWeight() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __MAXWEIGHT_ISSET_ID);\n  }\n\n  /** Returns true if field maxWeight is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field id is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ID_ISSET_ID = 0;\n  }\n\n  public void unsetId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ID_ISSET_ID);\n  }\n\n  /** Returns true if field id is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetGetColumnStats() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field getColumnStats is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __GETCOLUMNSTATS_ISSET_ID = 0;\n  }\n\n  public void unsetGetColumnStats() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __GETCOLUMNSTATS_ISSET_ID);\n  }\n\n  /** Returns true if field getColumnStats is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetIsStatsCompliant() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field isStatsCompliant is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ISSTATSCOMPLIANT_ISSET_ID = 0;\n  }\n\n  public void unsetIsStatsCompliant() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ISSTATSCOMPLIANT_ISSET_ID);\n  }\n\n  /** Returns true if field isStatsCompliant is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetRequestedFields() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field requestedFields is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __REQUESTEDFIELDS_ISSET_ID = 0;\n  }\n\n  public void unsetRequestedFields() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __REQUESTEDFIELDS_ISSET_ID);\n  }\n\n  /** Returns true if field requestedFields is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetWriteId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field writeId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __WRITEID_ISSET_ID = 0;\n  }\n\n  public void unsetWriteId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __WRITEID_ISSET_ID);\n  }\n\n  /** Returns true if field writeId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetRevokeGrantOption() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field revokeGrantOption is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __REVOKEGRANTOPTION_ISSET_ID = 0;\n  }\n\n  public void unsetRevokeGrantOption() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __REVOKEGRANTOPTION_ISSET_ID);\n  }\n\n  /** Returns true if field revokeGrantOption is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetSuccess() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field success is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __SUCCESS_ISSET_ID = 0;\n  }\n\n  public void unsetSuccess() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __SUCCESS_ISSET_ID);\n  }\n\n  /** Returns true if field success is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetGrantOption() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field grantOption is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __GRANTOPTION_ISSET_ID = 0;\n  }\n\n  public void unsetGrantOption() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __GRANTOPTION_ISSET_ID);\n  }\n\n  /** Returns true if field grantOption is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetSuccess() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field success is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __SUCCESS_ISSET_ID = 0;\n  }\n\n  public void unsetSuccess() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __SUCCESS_ISSET_ID);\n  }\n\n  /** Returns true if field success is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetLockid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field lockid is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __LOCKID_ISSET_ID = 0;\n  }\n\n  public void unsetLockid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __LOCKID_ISSET_ID);\n  }\n\n  /** Returns true if field lockid is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetMin() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field min is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __MIN_ISSET_ID = 0;\n  }\n\n  public void unsetMin() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __MIN_ISSET_ID);\n  }\n\n  /** Returns true if field min is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetReplace() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field replace is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __REPLACE_ISSET_ID = 0;\n  }\n\n  public void unsetReplace() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __REPLACE_ISSET_ID);\n  }\n\n  /** Returns true if field replace is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetCanEvolve() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field canEvolve is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __CANEVOLVE_ISSET_ID = 0;\n  }\n\n  public void unsetCanEvolve() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __CANEVOLVE_ISSET_ID);\n  }\n\n  /** Returns true if field canEvolve is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetIsTransactional() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field isTransactional is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ISTRANSACTIONAL_ISSET_ID = 0;\n  }\n\n  public void unsetIsTransactional() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ISTRANSACTIONAL_ISSET_ID);\n  }\n\n  /** Returns true if field isTransactional is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTxnid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field txnid is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TXNID_ISSET_ID = 0;\n  }\n\n  public void unsetTxnid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TXNID_ISSET_ID);\n  }\n\n  /** Returns true if field txnid is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetLockid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field lockid is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __LOCKID_ISSET_ID = 0;\n  }\n\n  public void unsetLockid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __LOCKID_ISSET_ID);\n  }\n\n  /** Returns true if field lockid is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetLowValue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field lowValue is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __LOWVALUE_ISSET_ID = 0;\n  }\n\n  public void unsetLowValue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __LOWVALUE_ISSET_ID);\n  }\n\n  /** Returns true if field lowValue is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetSourceTablesUpdateDeleteModified() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field sourceTablesUpdateDeleteModified is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __SOURCETABLESUPDATEDELETEMODIFIED_ISSET_ID = 0;\n  }\n\n  public void unsetSourceTablesUpdateDeleteModified() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __SOURCETABLESUPDATEDELETEMODIFIED_ISSET_ID);\n  }\n\n  /** Returns true if field sourceTablesUpdateDeleteModified is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetMaxWriteId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field maxWriteId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __MAXWRITEID_ISSET_ID = 0;\n  }\n\n  public void unsetMaxWriteId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __MAXWRITEID_ISSET_ID);\n  }\n\n  /** Returns true if field maxWriteId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetEventId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field eventId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __EVENTID_ISSET_ID = 0;\n  }\n\n  public void unsetEventId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __EVENTID_ISSET_ID);\n  }\n\n  /** Returns true if field eventId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetLastEvent() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field lastEvent is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __LASTEVENT_ISSET_ID = 0;\n  }\n\n  public void unsetLastEvent() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __LASTEVENT_ISSET_ID);\n  }\n\n  /** Returns true if field lastEvent is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetFromEventId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field fromEventId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __FROMEVENTID_ISSET_ID = 0;\n  }\n\n  public void unsetFromEventId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __FROMEVENTID_ISSET_ID);\n  }\n\n  /** Returns true if field fromEventId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetEventsCount() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field eventsCount is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __EVENTSCOUNT_ISSET_ID = 0;\n  }\n\n  public void unsetEventsCount() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __EVENTSCOUNT_ISSET_ID);\n  }\n\n  /** Returns true if field eventsCount is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TABLEID_ISSET_ID = 0;\n  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TABLEID_ISSET_ID);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetNum_txns() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field num_txns is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __NUM_TXNS_ISSET_ID = 0;\n  }\n\n  public void unsetNum_txns() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __NUM_TXNS_ISSET_ID);\n  }\n\n  /** Returns true if field num_txns is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetOrder() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field order is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ORDER_ISSET_ID = 0;\n  }\n\n  public void unsetOrder() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ORDER_ISSET_ID);\n  }\n\n  /** Returns true if field order is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __CREATETIME_ISSET_ID = 0;\n  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __CREATETIME_ISSET_ID);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetMaxParts() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field maxParts is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __MAXPARTS_ISSET_ID = 0;\n  }\n\n  public void unsetMaxParts() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __MAXPARTS_ISSET_ID);\n  }\n\n  /** Returns true if field maxParts is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetHasUnknownPartitions() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field hasUnknownPartitions is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __HASUNKNOWNPARTITIONS_ISSET_ID = 0;\n  }\n\n  public void unsetHasUnknownPartitions() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __HASUNKNOWNPARTITIONS_ISSET_ID);\n  }\n\n  /** Returns true if field hasUnknownPartitions is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetWriteId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field writeId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __WRITEID_ISSET_ID = 0;\n  }\n\n  public void unsetWriteId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __WRITEID_ISSET_ID);\n  }\n\n  /** Returns true if field writeId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetMaxParts() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field maxParts is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __MAXPARTS_ISSET_ID = 0;\n  }\n\n  public void unsetMaxParts() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __MAXPARTS_ISSET_ID);\n  }\n\n  /** Returns true if field maxParts is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetHasUnknownPartitions() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field hasUnknownPartitions is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __HASUNKNOWNPARTITIONS_ISSET_ID = 0;\n  }\n\n  public void unsetHasUnknownPartitions() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __HASUNKNOWNPARTITIONS_ISSET_ID);\n  }\n\n  /** Returns true if field hasUnknownPartitions is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetIsStatsCompliant() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field isStatsCompliant is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ISSTATSCOMPLIANT_ISSET_ID = 0;\n  }\n\n  public void unsetIsStatsCompliant() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ISSTATSCOMPLIANT_ISSET_ID);\n  }\n\n  /** Returns true if field isStatsCompliant is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetApplyDistinct() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field applyDistinct is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __APPLYDISTINCT_ISSET_ID = 0;\n  }\n\n  public void unsetApplyDistinct() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __APPLYDISTINCT_ISSET_ID);\n  }\n\n  /** Returns true if field applyDistinct is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __CREATETIME_ISSET_ID = 0;\n  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __CREATETIME_ISSET_ID);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TABLEID_ISSET_ID = 0;\n  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TABLEID_ISSET_ID);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __CREATETIME_ISSET_ID = 0;\n  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __CREATETIME_ISSET_ID);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTxnId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field txnId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TXNID_ISSET_ID = 0;\n  }\n\n  public void unsetTxnId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TXNID_ISSET_ID);\n  }\n\n  /** Returns true if field txnId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetScheduledExecutionId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field scheduledExecutionId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __SCHEDULEDEXECUTIONID_ISSET_ID = 0;\n  }\n\n  public void unsetScheduledExecutionId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __SCHEDULEDEXECUTIONID_ISSET_ID);\n  }\n\n  /** Returns true if field scheduledExecutionId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetLastReplId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field lastReplId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __LASTREPLID_ISSET_ID = 0;\n  }\n\n  public void unsetLastReplId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __LASTREPLID_ISSET_ID);\n  }\n\n  /** Returns true if field lastReplId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __CREATETIME_ISSET_ID = 0;\n  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __CREATETIME_ISSET_ID);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetGrantOption() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field grantOption is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __GRANTOPTION_ISSET_ID = 0;\n  }\n\n  public void unsetGrantOption() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __GRANTOPTION_ISSET_ID);\n  }\n\n  /** Returns true if field grantOption is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __CREATETIME_ISSET_ID = 0;\n  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __CREATETIME_ISSET_ID);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetEnabled() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field enabled is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ENABLED_ISSET_ID = 0;\n  }\n\n  public void unsetEnabled() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ENABLED_ISSET_ID);\n  }\n\n  /** Returns true if field enabled is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetExecutionId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field executionId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __EXECUTIONID_ISSET_ID = 0;\n  }\n\n  public void unsetExecutionId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __EXECUTIONID_ISSET_ID);\n  }\n\n  /** Returns true if field executionId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetScheduledExecutionId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field scheduledExecutionId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __SCHEDULEDEXECUTIONID_ISSET_ID = 0;\n  }\n\n  public void unsetScheduledExecutionId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __SCHEDULEDEXECUTIONID_ISSET_ID);\n  }\n\n  /** Returns true if field scheduledExecutionId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetVersion() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field version is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __VERSION_ISSET_ID = 0;\n  }\n\n  public void unsetVersion() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __VERSION_ISSET_ID);\n  }\n\n  /** Returns true if field version is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetVersion() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field version is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __VERSION_ISSET_ID = 0;\n  }\n\n  public void unsetVersion() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __VERSION_ISSET_ID);\n  }\n\n  /** Returns true if field version is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetSeedWriteId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field seedWriteId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __SEEDWRITEID_ISSET_ID = 0;\n  }\n\n  public void unsetSeedWriteId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __SEEDWRITEID_ISSET_ID);\n  }\n\n  /** Returns true if field seedWriteId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetSeedTxnId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field seedTxnId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __SEEDTXNID_ISSET_ID = 0;\n  }\n\n  public void unsetSeedTxnId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __SEEDTXNID_ISSET_ID);\n  }\n\n  /** Returns true if field seedTxnId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetNeedMerge() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field needMerge is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __NEEDMERGE_ISSET_ID = 0;\n  }\n\n  public void unsetNeedMerge() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __NEEDMERGE_ISSET_ID);\n  }\n\n  /** Returns true if field needMerge is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetResult() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field result is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __RESULT_ISSET_ID = 0;\n  }\n\n  public void unsetResult() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __RESULT_ISSET_ID);\n  }\n\n  /** Returns true if field result is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field id is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ID_ISSET_ID = 0;\n  }\n\n  public void unsetId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ID_ISSET_ID);\n  }\n\n  /** Returns true if field id is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetStart() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field start is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __START_ISSET_ID = 0;\n  }\n\n  public void unsetStart() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __START_ISSET_ID);\n  }\n\n  /** Returns true if field start is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetIsExtended() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field isExtended is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ISEXTENDED_ISSET_ID = 0;\n  }\n\n  public void unsetIsExtended() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ISEXTENDED_ISSET_ID);\n  }\n\n  /** Returns true if field isExtended is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetLockid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field lockid is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __LOCKID_ISSET_ID = 0;\n  }\n\n  public void unsetLockid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __LOCKID_ISSET_ID);\n  }\n\n  /** Returns true if field lockid is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetInsertedCount() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field insertedCount is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __INSERTEDCOUNT_ISSET_ID = 0;\n  }\n\n  public void unsetInsertedCount() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __INSERTEDCOUNT_ISSET_ID);\n  }\n\n  /** Returns true if field insertedCount is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetEnable_cstr() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field enable_cstr is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ENABLE_CSTR_ISSET_ID = 0;\n  }\n\n  public void unsetEnable_cstr() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ENABLE_CSTR_ISSET_ID);\n  }\n\n  /** Returns true if field enable_cstr is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetEnable_cstr() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field enable_cstr is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ENABLE_CSTR_ISSET_ID = 0;\n  }\n\n  public void unsetEnable_cstr() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ENABLE_CSTR_ISSET_ID);\n  }\n\n  /** Returns true if field enable_cstr is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetKey_seq() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field key_seq is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __KEY_SEQ_ISSET_ID = 0;\n  }\n\n  public void unsetKey_seq() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __KEY_SEQ_ISSET_ID);\n  }\n\n  /** Returns true if field key_seq is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetEnable_cstr() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field enable_cstr is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ENABLE_CSTR_ISSET_ID = 0;\n  }\n\n  public void unsetEnable_cstr() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ENABLE_CSTR_ISSET_ID);\n  }\n\n  /** Returns true if field enable_cstr is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetKey_seq() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field key_seq is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __KEY_SEQ_ISSET_ID = 0;\n  }\n\n  public void unsetKey_seq() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __KEY_SEQ_ISSET_ID);\n  }\n\n  /** Returns true if field key_seq is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetKey_seq() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field key_seq is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __KEY_SEQ_ISSET_ID = 0;\n  }\n\n  public void unsetKey_seq() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __KEY_SEQ_ISSET_ID);\n  }\n\n  /** Returns true if field key_seq is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetCompressed() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field compressed is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __COMPRESSED_ISSET_ID = 0;\n  }\n\n  public void unsetCompressed() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __COMPRESSED_ISSET_ID);\n  }\n\n  /** Returns true if field compressed is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetMaxColLen() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field maxColLen is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __MAXCOLLEN_ISSET_ID = 0;\n  }\n\n  public void unsetMaxColLen() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __MAXCOLLEN_ISSET_ID);\n  }\n\n  /** Returns true if field maxColLen is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __CREATETIME_ISSET_ID = 0;\n  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __CREATETIME_ISSET_ID);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field id is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ID_ISSET_ID = 0;\n  }\n\n  public void unsetId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ID_ISSET_ID);\n  }\n\n  /** Returns true if field id is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetIsStatsCompliant() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field isStatsCompliant is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ISSTATSCOMPLIANT_ISSET_ID = 0;\n  }\n\n  public void unsetIsStatsCompliant() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ISSTATSCOMPLIANT_ISSET_ID);\n  }\n\n  /** Returns true if field isStatsCompliant is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetWriteIdHighWaterMark() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field writeIdHighWaterMark is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __WRITEIDHIGHWATERMARK_ISSET_ID = 0;\n  }\n\n  public void unsetWriteIdHighWaterMark() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __WRITEIDHIGHWATERMARK_ISSET_ID);\n  }\n\n  /** Returns true if field writeIdHighWaterMark is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "    }\n\n    public void unsetDeleteData() {\n      __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n    }\n\n    /** Returns true if field deleteData is set (has been assigned a value) and false otherwise */", "refactored_code": "    private static final int __DELETEDATA_ISSET_ID = 0;\n    }\n\n    public void unsetDeleteData() {\n      __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __DELETEDATA_ISSET_ID);\n    }\n\n    /** Returns true if field deleteData is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetSecondsSinceEpoch() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field secondsSinceEpoch is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __SECONDSSINCEEPOCH_ISSET_ID = 0;\n  }\n\n  public void unsetSecondsSinceEpoch() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __SECONDSSINCEEPOCH_ISSET_ID);\n  }\n\n  /** Returns true if field secondsSinceEpoch is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetNumNulls() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field numNulls is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __NUMNULLS_ISSET_ID = 0;\n  }\n\n  public void unsetNumNulls() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __NUMNULLS_ISSET_ID);\n  }\n\n  /** Returns true if field numNulls is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetWriteId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field writeId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __WRITEID_ISSET_ID = 0;\n  }\n\n  public void unsetWriteId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __WRITEID_ISSET_ID);\n  }\n\n  /** Returns true if field writeId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field id is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ID_ISSET_ID = 0;\n  }\n\n  public void unsetId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ID_ISSET_ID);\n  }\n\n  /** Returns true if field id is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTxnId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field txnId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TXNID_ISSET_ID = 0;\n  }\n\n  public void unsetTxnId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TXNID_ISSET_ID);\n  }\n\n  /** Returns true if field txnId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TABLEID_ISSET_ID = 0;\n  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TABLEID_ISSET_ID);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetLockid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field lockid is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __LOCKID_ISSET_ID = 0;\n  }\n\n  public void unsetLockid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __LOCKID_ISSET_ID);\n  }\n\n  /** Returns true if field lockid is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TABLEID_ISSET_ID = 0;\n  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TABLEID_ISSET_ID);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetIsEnableAndActivate() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field isEnableAndActivate is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ISENABLEANDACTIVATE_ISSET_ID = 0;\n  }\n\n  public void unsetIsEnableAndActivate() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ISENABLEANDACTIVATE_ISSET_ID);\n  }\n\n  /** Returns true if field isEnableAndActivate is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetDrop() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field drop is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __DROP_ISSET_ID = 0;\n  }\n\n  public void unsetDrop() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __DROP_ISSET_ID);\n  }\n\n  /** Returns true if field drop is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetUpdate() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field update is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __UPDATE_ISSET_ID = 0;\n  }\n\n  public void unsetUpdate() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __UPDATE_ISSET_ID);\n  }\n\n  /** Returns true if field update is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetOrdering() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field ordering is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ORDERING_ISSET_ID = 0;\n  }\n\n  public void unsetOrdering() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ORDERING_ISSET_ID);\n  }\n\n  /** Returns true if field ordering is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetAllocFraction() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field allocFraction is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ALLOCFRACTION_ISSET_ID = 0;\n  }\n\n  public void unsetAllocFraction() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ALLOCFRACTION_ISSET_ID);\n  }\n\n  /** Returns true if field allocFraction is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetQueryParallelism() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field queryParallelism is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __QUERYPARALLELISM_ISSET_ID = 0;\n  }\n\n  public void unsetQueryParallelism() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __QUERYPARALLELISM_ISSET_ID);\n  }\n\n  /** Returns true if field queryParallelism is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetAllocFraction() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field allocFraction is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ALLOCFRACTION_ISSET_ID = 0;\n  }\n\n  public void unsetAllocFraction() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ALLOCFRACTION_ISSET_ID);\n  }\n\n  /** Returns true if field allocFraction is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetQueryParallelism() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field queryParallelism is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __QUERYPARALLELISM_ISSET_ID = 0;\n  }\n\n  public void unsetQueryParallelism() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __QUERYPARALLELISM_ISSET_ID);\n  }\n\n  /** Returns true if field queryParallelism is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetIsInUnmanaged() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field isInUnmanaged is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ISINUNMANAGED_ISSET_ID = 0;\n  }\n\n  public void unsetIsInUnmanaged() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ISINUNMANAGED_ISSET_ID);\n  }\n\n  /** Returns true if field isInUnmanaged is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetWriteId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field writeId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __WRITEID_ISSET_ID = 0;\n  }\n\n  public void unsetWriteId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __WRITEID_ISSET_ID);\n  }\n\n  /** Returns true if field writeId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTxnId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field txnId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TXNID_ISSET_ID = 0;\n  }\n\n  public void unsetTxnId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TXNID_ISSET_ID);\n  }\n\n  /** Returns true if field txnId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  public PropertyMap(DataInput input, Function<String, PropertySchema> getSchema) throws IOException {\n    // serial\n    long serial = input.readLong();\n    if (serial != 202212291759L) {\n      throw new InvalidObjectException(\"serial mismatch\");\n    }\n    // schema as string", "refactored_code": "  private static final long serialVersionUID = 202212291759L;\n  public PropertyMap(DataInput input, Function<String, PropertySchema> getSchema) throws IOException {\n    // serial\n    long serial = input.readLong();\n    if (serial != serialVersionUID) {\n      throw new InvalidObjectException(\"serial mismatch\");\n    }\n    // schema as string"}
{"magic_number_smell": "  public PropertySchema(DataInput input) throws IOException {\n    // serial\n    long serial = input.readLong();\n    if (serial != 202212301459L) {\n      throw new InvalidObjectException(\"serial mismatch\");\n    }\n    // name", "refactored_code": "  private static final long serialVersionUID = 202212301459L;\n  public PropertySchema(DataInput input) throws IOException {\n    // serial\n    long serial = input.readLong();\n    if (serial != serialVersionUID) {\n      throw new InvalidObjectException(\"serial mismatch\");\n    }\n    // name"}
{"magic_number_smell": "  @Override\n  public void readExternal(ObjectInput in) throws IOException {\n    long serial = in.readLong();\n    if (serial != 202212281757L) {\n      throw new ProxyException(\"invalid serial version, got \" + serial +\", expected \" + 202212281757L);\n    }\n    type = readType(in);", "refactored_code": "  private static final long serialVersionUID = 202212281757L;\n  @Override\n  public void readExternal(ObjectInput in) throws IOException {\n    long serial = in.readLong();\n    if (serial != serialVersionUID) {\n      throw new ProxyException(\"invalid serial version, got \" + serial +\", expected \" + serialVersionUID);\n    }\n    type = readType(in);"}
{"magic_number_smell": "     * Creates a new instance of a soft cache.\n     */\n    public SoftCache() {\n        this(64);\n    }\n\n    /**", "refactored_code": "    private static final int CACHE_CAPACITY = 64;\n     * Creates a new instance of a soft cache.\n     */\n    public SoftCache() {\n        this(CACHE_CAPACITY);\n    }\n\n    /**"}
{"magic_number_smell": "    } catch(Exception e) {\n      if (e.getClass().equals(retryExceptionType)){\n        tries++;\n        if (4 == tries) {\n          throw e;\n        } else {\n          return run();", "refactored_code": "  public static final int MAX_RETRIES = 4;\n    } catch(Exception e) {\n      if (e.getClass().equals(retryExceptionType)){\n        tries++;\n        if (MAX_RETRIES == tries) {\n          throw e;\n        } else {\n          return run();"}
{"magic_number_smell": "    assertNull(time);\n\n    assertSame(fooScope, metrics.getStoredScope(scopeName));\n    Thread.sleep(50L+ 1);\n    // 1st close:\n    // closing of open scope should be ok:\n    metrics.endStoredScope(scopeName);", "refactored_code": "  private static final long periodMs = 50L;\n    assertNull(time);\n\n    assertSame(fooScope, metrics.getStoredScope(scopeName));\n    Thread.sleep(periodMs+ 1);\n    // 1st close:\n    // closing of open scope should be ok:\n    metrics.endStoredScope(scopeName);"}
{"magic_number_smell": "        \"org.apache.hadoop.hive.common.metrics.metrics2.JsonFileMetricsReporter, \"\n            + \"org.apache.hadoop.hive.common.metrics.metrics2.JmxMetricsReporter\");\n    conf.set(MetastoreConf.ConfVars.METRICS_JSON_FILE_LOCATION.getHiveName(), jsonReportFile.getAbsolutePath());\n    conf.setTimeDuration(MetastoreConf.ConfVars.METRICS_JSON_FILE_INTERVAL.getHiveName(), 2000,\n        TimeUnit.MILLISECONDS);\n\n    MetricsFactory.init(conf);", "refactored_code": "  private static final long REPORT_INTERVAL_MS = 2000;\n        \"org.apache.hadoop.hive.common.metrics.metrics2.JsonFileMetricsReporter, \"\n            + \"org.apache.hadoop.hive.common.metrics.metrics2.JmxMetricsReporter\");\n    conf.set(MetastoreConf.ConfVars.METRICS_JSON_FILE_LOCATION.getHiveName(), jsonReportFile.getAbsolutePath());\n    conf.setTimeDuration(MetastoreConf.ConfVars.METRICS_JSON_FILE_INTERVAL.getHiveName(), REPORT_INTERVAL_MS,\n        TimeUnit.MILLISECONDS);\n\n    MetricsFactory.init(conf);"}
{"magic_number_smell": "    protected final int anInt;\n\n    public PocExternal(ObjectInput in) throws IOException {\n        this(202212281714L, in);\n    }\n\n    public void write(ObjectOutput out) throws IOException {", "refactored_code": "    private static final long serialVersionUID = 202212281714L;\n    protected final int anInt;\n\n    public PocExternal(ObjectInput in) throws IOException {\n        this(serialVersionUID, in);\n    }\n\n    public void write(ObjectOutput out) throws IOException {"}
{"magic_number_smell": "        }\n\n        public PocExternalDerive(ObjectInput in) throws IOException {\n            this(202212281720L, in);\n        }\n\n        protected PocExternalDerive(long version, DataInput in) throws IOException {", "refactored_code": "        private static final long serialVersionUID = 202212281720L;\n        }\n\n        public PocExternalDerive(ObjectInput in) throws IOException {\n            this(serialVersionUID, in);\n        }\n\n        protected PocExternalDerive(long version, DataInput in) throws IOException {"}
{"magic_number_smell": "    Assert.assertNull(DOUBLE.cast(null));\n    Assert.assertNull(DOUBLE.format(null));\n    Assert.assertNull(DOUBLE.parse(null));\n    Assert.assertEquals(42.0d, (double) DOUBLE.cast(\"42\"), 1e-9);\n    Assert.assertEquals(42.0d, (double) DOUBLE.cast(42), 1e-9);\n    Assert.assertNull(DOUBLE.cast(\"foobar\"));\n    Assert.assertEquals(\"42.0\", DOUBLE.format(42.0d));", "refactored_code": "  private static final double EPSILON = 1e-9;\n    Assert.assertNull(DOUBLE.cast(null));\n    Assert.assertNull(DOUBLE.format(null));\n    Assert.assertNull(DOUBLE.parse(null));\n    Assert.assertEquals(42.0d, (double) DOUBLE.cast(\"42\"), EPSILON);\n    Assert.assertEquals(42.0d, (double) DOUBLE.cast(42), EPSILON);\n    Assert.assertNull(DOUBLE.cast(\"foobar\"));\n    Assert.assertEquals(\"42.0\", DOUBLE.format(42.0d));"}
{"magic_number_smell": "    this.numBitVectors = numBitVectors;\n    bitVector = new FastBitSet[numBitVectors];\n    for (int i=0; i< numBitVectors; i++) {\n      bitVector[i] = new FastBitSet(31);\n    }\n\n    a = new int[numBitVectors];", "refactored_code": "  public static final int BIT_VECTOR_SIZE = 31;\n    this.numBitVectors = numBitVectors;\n    bitVector = new FastBitSet[numBitVectors];\n    for (int i=0; i< numBitVectors; i++) {\n      bitVector[i] = new FastBitSet(BIT_VECTOR_SIZE);\n    }\n\n    a = new int[numBitVectors];"}
{"magic_number_smell": "        // cardinality estimate from normalized bias corrected harmonic mean on\n        // the registers\n        cachedCount = (long) (alphaMM * (1.0 / sum));\n        long pow = (long) Math.pow(2, DEFAULT_HASH_BITS);\n\n        // when bias correction is enabled\n        if (noBias) {", "refactored_code": "  private final int chosenHashBits = DEFAULT_HASH_BITS;\n        // cardinality estimate from normalized bias corrected harmonic mean on\n        // the registers\n        cachedCount = (long) (alphaMM * (1.0 / sum));\n        long pow = (long) Math.pow(2, chosenHashBits);\n\n        // when bias correction is enabled\n        if (noBias) {"}
{"magic_number_smell": "      return Collections.emptyList();\n    }\n    try {\n      if (batchSize == -1 || batchSize >= input.size()) {\n        return runnable.run(input);\n      }\n      List<R> result = new ArrayList<>(input.size());", "refactored_code": "  public static final int NO_BATCHING = -1;\n      return Collections.emptyList();\n    }\n    try {\n      if (batchSize == NO_BATCHING || batchSize >= input.size()) {\n        return runnable.run(input);\n      }\n      List<R> result = new ArrayList<>(input.size());"}
{"magic_number_smell": "\n  private void check() throws MetaException{\n    try {\n      if (startTime == Long.MIN_VALUE) {\n        throw new DeadlineException(\"Should execute startTimer() method before \" +\n            \"checkTimeout. Error happens in method: \" + method);\n      }", "refactored_code": "  private static final long NO_DEADLINE = Long.MIN_VALUE;\n\n  private void check() throws MetaException{\n    try {\n      if (startTime == NO_DEADLINE) {\n        throw new DeadlineException(\"Should execute startTimer() method before \" +\n            \"checkTimeout. Error happens in method: \" + method);\n      }"}
{"magic_number_smell": "    int batchSize = MetastoreConf.getIntVar(conf, ConfVars.DIRECT_SQL_PARTITION_BATCH_SIZE);\n    this.directSqlInsertPart = new DirectSqlInsertPart(pm, dbType, batchSize);\n    if (batchSize == DETECT_BATCHING) {\n      batchSize = dbType.needsInBatching() ? 1000 : -1, DETECT_BATCHING = 0;\n    }\n    this.batchSize = batchSize;\n    this.isTxnStatsEnabled = MetastoreConf.getBoolVar(conf, ConfVars.HIVE_TXN_STATS_ENABLED);", "refactored_code": "  private static final int NO_BATCHING = -1, DETECT_BATCHING = 0;\n    int batchSize = MetastoreConf.getIntVar(conf, ConfVars.DIRECT_SQL_PARTITION_BATCH_SIZE);\n    this.directSqlInsertPart = new DirectSqlInsertPart(pm, dbType, batchSize);\n    if (batchSize == DETECT_BATCHING) {\n      batchSize = dbType.needsInBatching() ? 1000 : NO_BATCHING;\n    }\n    this.batchSize = batchSize;\n    this.isTxnStatsEnabled = MetastoreConf.getBoolVar(conf, ConfVars.HIVE_TXN_STATS_ENABLED);"}
{"magic_number_smell": "\n      out.write(msg);\n      for (Object entry : result) {\n        out.write(9);\n        out.write(entry.toString());\n      }\n      return true;", "refactored_code": "  public static final int separator = 9; // tabCode\n\n      out.write(msg);\n      for (Object entry : result) {\n        out.write(separator);\n        out.write(entry.toString());\n      }\n      return true;"}
{"magic_number_smell": "              if (!node.isMultiValued) {\n                // in case of serdeid and sdId node we just collect the sdIds for further processing\n                if (node.equals(sdIdNode)) {\n                  ids[0] = extractSqlLong(value);\n                } else if (node.equals(serdeIdNode)) {\n                  ids[SERDE_INDEX] = extractSqlLong(value);\n                } else if (node.equals(cdIdNode)) {", "refactored_code": "  private static final int SD_INDEX = 0;\n              if (!node.isMultiValued) {\n                // in case of serdeid and sdId node we just collect the sdIds for further processing\n                if (node.equals(sdIdNode)) {\n                  ids[SD_INDEX] = extractSqlLong(value);\n                } else if (node.equals(serdeIdNode)) {\n                  ids[SERDE_INDEX] = extractSqlLong(value);\n                } else if (node.equals(cdIdNode)) {"}
{"magic_number_smell": "\n    if (tableCache == null) {\n      CacheBuilder<String, TableWrapper> b = CacheBuilder.newBuilder()\n          .maximumWeight(maxCacheSizeInBytes > 0 ? maxCacheSizeInBytes : 1024 * 1024)\n          .weigher(new Weigher<String, TableWrapper>() {\n            @Override\n            public int weigh(String key, TableWrapper value) {", "refactored_code": "  private static final long MAX_DEFAULT_CACHE_SIZE = 1024 * 1024;\n\n    if (tableCache == null) {\n      CacheBuilder<String, TableWrapper> b = CacheBuilder.newBuilder()\n          .maximumWeight(maxCacheSizeInBytes > 0 ? maxCacheSizeInBytes : MAX_DEFAULT_CACHE_SIZE)\n          .weigher(new Weigher<String, TableWrapper>() {\n            @Override\n            public int weigh(String key, TableWrapper value) {"}
{"magic_number_smell": "    super();\n    this.status = status;\n    this.handler = handler;\n    this.parameters = new HashMap<>(1);\n    updateUnmodifiableParameters();\n  }\n", "refactored_code": "  private static final int PARAMETERS_INITIAL_CAPACITY = 1;\n    super();\n    this.status = status;\n    this.handler = handler;\n    this.parameters = new HashMap<>(PARAMETERS_INITIAL_CAPACITY);\n    updateUnmodifiableParameters();\n  }\n"}
{"magic_number_smell": "      while (shouldRun) {\n        sw.reset().start();\n        try {\n          Thread.sleep(500);\n        } catch (InterruptedException ie) {\n          return;\n        }", "refactored_code": "  private static final long SLEEP_INTERVAL_MS = 500;\n      while (shouldRun) {\n        sw.reset().start();\n        try {\n          Thread.sleep(SLEEP_INTERVAL_MS);\n        } catch (InterruptedException ie) {\n          return;\n        }"}
{"magic_number_smell": "  }\n\n  public void setHeader(String header) throws MetaException {\n    if (header.length() > 1073741823) {\n      throw new MetaException(\"Header is too long: \" + header.length() + \" max size: \" + 1073741823);\n    }\n    this.header = header;", "refactored_code": "  public static final int MAX_HEADER_SIZE = 1073741823;\n  }\n\n  public void setHeader(String header) throws MetaException {\n    if (header.length() > MAX_HEADER_SIZE) {\n      throw new MetaException(\"Header is too long: \" + header.length() + \" max size: \" + MAX_HEADER_SIZE);\n    }\n    this.header = header;"}
{"magic_number_smell": "  }\n\n  public void setSource(String source) throws MetaException {\n    if (source.length() > 1073741823) {\n      throw new MetaException(\"Source code is too long: \" + source.length() + \" max size: \" + 1073741823);\n    }\n    this.source = source;", "refactored_code": "  public static final int MAX_SOURCE_SIZE = 1073741823;\n  }\n\n  public void setSource(String source) throws MetaException {\n    if (source.length() > MAX_SOURCE_SIZE) {\n      throw new MetaException(\"Source code is too long: \" + source.length() + \" max size: \" + MAX_SOURCE_SIZE);\n    }\n    this.source = source;"}
{"magic_number_smell": "  private Predicate<DelegationTokenIdentifier> selectForDeletion = Predicates.alwaysTrue();\n\n  private static final int 100 = 100;\n  private int batchSize = 100; // Number of tokens to drop, between sleep intervals;\n  private static final long SLEEP_TIME_MILLIS_DEFAULT = 10 * 1000;\n  private long sleepTimeMillis = SLEEP_TIME_MILLIS_DEFAULT; // Sleep-time in milliseconds, between batches of delegation tokens dropped.\n", "refactored_code": "  private static final int BATCH_SIZE_DEFAULT = 100;\n  private Predicate<DelegationTokenIdentifier> selectForDeletion = Predicates.alwaysTrue();\n\n  private static final int BATCH_SIZE_DEFAULT = 100;\n  private int batchSize = BATCH_SIZE_DEFAULT; // Number of tokens to drop, between sleep intervals;\n  private static final long SLEEP_TIME_MILLIS_DEFAULT = 10 * 1000;\n  private long sleepTimeMillis = SLEEP_TIME_MILLIS_DEFAULT; // Sleep-time in milliseconds, between batches of delegation tokens dropped.\n"}
{"magic_number_smell": "      try (PreparedStatement pStmt = conn.prepareStatement(tabLocQuery)) {\n        while (minID <= maxID) {\n          pStmt.setLong(1, minID);\n          pStmt.setLong(2, minID + 2000);\n          try (ResultSet res = pStmt.executeQuery()) {\n            while (res.next()) {\n              String locValue = res.getString(3);", "refactored_code": "  private static final int TAB_LOC_CHECK_SIZE = 2000;\n      try (PreparedStatement pStmt = conn.prepareStatement(tabLocQuery)) {\n        while (minID <= maxID) {\n          pStmt.setLong(1, minID);\n          pStmt.setLong(2, minID + TAB_LOC_CHECK_SIZE);\n          try (ResultSet res = pStmt.executeQuery()) {\n            while (res.next()) {\n              String locValue = res.getString(3);"}
{"magic_number_smell": "  }\n\n  boolean canCreateContext() {\n    return (1 & flag) == 1;\n  }\n\n  boolean canJoinContext() {", "refactored_code": "  private static final int CREATE_FLAG = 1;\n  }\n\n  boolean canCreateContext() {\n    return (CREATE_FLAG & flag) == CREATE_FLAG;\n  }\n\n  boolean canJoinContext() {"}
{"magic_number_smell": "    }\n    properties\n        .setRetryCount(retryLimit)\n        .setDeadlockCount(10);\n    \n    try {\n      if (properties.isLockInternally()) {", "refactored_code": "  private static final int ALLOWED_REPEATED_DEADLOCKS = 10;\n    }\n    properties\n        .setRetryCount(retryLimit)\n        .setDeadlockCount(ALLOWED_REPEATED_DEADLOCKS);\n    \n    try {\n      if (properties.isLockInternally()) {"}
{"magic_number_smell": "      isAliveCounter++;\n      txnHandler.countOpenTxns();\n      long now = System.currentTimeMillis();\n      if (now - lastLogTime > 60 * 1000) {\n        LOG.info(\"Open txn counter ran for {} seconds. isAliveCounter: {}\", (now - start) / 1000, isAliveCounter);\n        lastLogTime = now;\n      }", "refactored_code": "  private static final int LOG_INTERVAL_MS = 60 * 1000;\n      isAliveCounter++;\n      txnHandler.countOpenTxns();\n      long now = System.currentTimeMillis();\n      if (now - lastLogTime > LOG_INTERVAL_MS) {\n        LOG.info(\"Open txn counter ran for {} seconds. isAliveCounter: {}\", (now - start) / 1000, isAliveCounter);\n        lastLogTime = now;\n      }"}
{"magic_number_smell": "  @Test\n  public void testHLLSparseSerialization() throws IOException {\n    HyperLogLog hll = HyperLogLog.builder().setEncoding(EncodingType.SPARSE).build();\n    Random rand = new Random(100);\n    for (int i = 0; i < size; i++) {\n      hll.addLong(rand.nextLong());\n    }", "refactored_code": "  private static final int SEED = 100;\n  @Test\n  public void testHLLSparseSerialization() throws IOException {\n    HyperLogLog hll = HyperLogLog.builder().setEncoding(EncodingType.SPARSE).build();\n    Random rand = new Random(SEED);\n    for (int i = 0; i < size; i++) {\n      hll.addLong(rand.nextLong());\n    }"}
{"magic_number_smell": "    Exception metaStoreException = null;\n    String warehouseDir = MetastoreConf.getVar(conf, ConfVars.WAREHOUSE);\n\n    for (int tryCount = 0; tryCount < MetaStoreTestUtils.10; tryCount++) {\n      try {\n        int metaStorePort = findFreePort();\n        if (!keepWarehousePath) {", "refactored_code": "  public static final int RETRY_COUNT = 10;\n    Exception metaStoreException = null;\n    String warehouseDir = MetastoreConf.getVar(conf, ConfVars.WAREHOUSE);\n\n    for (int tryCount = 0; tryCount < MetaStoreTestUtils.RETRY_COUNT; tryCount++) {\n      try {\n        int metaStorePort = findFreePort();\n        if (!keepWarehousePath) {"}
{"magic_number_smell": "    conf.set(\"hive.in.test\", \"true\");\n\n    MetastoreConf.setLongVar(conf, ConfVars.BATCH_RETRIEVE_MAX, 2);\n    MetastoreConf.setLongVar(conf, ConfVars.LIMIT_PARTITION_REQUEST, 100);\n    MetastoreConf.setVar(conf, ConfVars.STORAGE_SCHEMA_READER_IMPL, \"no.such.class\");\n    MetaStoreTestUtils.setConfForStandloneMode(conf);\n", "refactored_code": "  private static final int DEFAULT_LIMIT_PARTITION_REQUEST = 100;\n    conf.set(\"hive.in.test\", \"true\");\n\n    MetastoreConf.setLongVar(conf, ConfVars.BATCH_RETRIEVE_MAX, 2);\n    MetastoreConf.setLongVar(conf, ConfVars.LIMIT_PARTITION_REQUEST, DEFAULT_LIMIT_PARTITION_REQUEST);\n    MetastoreConf.setVar(conf, ConfVars.STORAGE_SCHEMA_READER_IMPL, \"no.such.class\");\n    MetaStoreTestUtils.setConfForStandloneMode(conf);\n"}
{"magic_number_smell": "\n    MetaStoreTestUtils.setConfForStandloneMode(conf);\n    MetastoreConf.setLongVar(conf, ConfVars.BATCH_RETRIEVE_MAX, 2);\n    MetastoreConf.setLongVar(conf, ConfVars.LIMIT_PARTITION_REQUEST, 100);\n    MetastoreConf.setVar(conf, ConfVars.STORAGE_SCHEMA_READER_IMPL, \"no.such.class\");\n    MetastoreConf.setBoolVar(conf, ConfVars.INTEGER_JDO_PUSHDOWN, true);\n  }", "refactored_code": "  private static final int DEFAULT_LIMIT_PARTITION_REQUEST = 100;\n\n    MetaStoreTestUtils.setConfForStandloneMode(conf);\n    MetastoreConf.setLongVar(conf, ConfVars.BATCH_RETRIEVE_MAX, 2);\n    MetastoreConf.setLongVar(conf, ConfVars.LIMIT_PARTITION_REQUEST, DEFAULT_LIMIT_PARTITION_REQUEST);\n    MetastoreConf.setVar(conf, ConfVars.STORAGE_SCHEMA_READER_IMPL, \"no.such.class\");\n    MetastoreConf.setBoolVar(conf, ConfVars.INTEGER_JDO_PUSHDOWN, true);\n  }"}
{"magic_number_smell": "    conf.set(\"hive.in.test\", \"true\");\n\n    MetastoreConf.setLongVar(conf, ConfVars.BATCH_RETRIEVE_MAX, 2);\n    MetastoreConf.setLongVar(conf, ConfVars.LIMIT_PARTITION_REQUEST, 100);\n    MetastoreConf.setVar(conf, ConfVars.STORAGE_SCHEMA_READER_IMPL, \"no.such.class\");\n    MetastoreConf.setBoolVar(conf, ConfVars.METASTORE_CLIENT_FILTER_ENABLED, false);\n    MetastoreConf.setBoolVar(conf, ConfVars.METASTORE_SERVER_FILTER_ENABLED, false);", "refactored_code": "  private static final int DEFAULT_LIMIT_PARTITION_REQUEST = 100;\n    conf.set(\"hive.in.test\", \"true\");\n\n    MetastoreConf.setLongVar(conf, ConfVars.BATCH_RETRIEVE_MAX, 2);\n    MetastoreConf.setLongVar(conf, ConfVars.LIMIT_PARTITION_REQUEST, DEFAULT_LIMIT_PARTITION_REQUEST);\n    MetastoreConf.setVar(conf, ConfVars.STORAGE_SCHEMA_READER_IMPL, \"no.such.class\");\n    MetastoreConf.setBoolVar(conf, ConfVars.METASTORE_CLIENT_FILTER_ENABLED, false);\n    MetastoreConf.setBoolVar(conf, ConfVars.METASTORE_SERVER_FILTER_ENABLED, false);"}
{"magic_number_smell": "\n  private static final int 8089 = 8089;\n  @ClassRule\n  public static final WireMockRule MOCK_JWKS_SERVER = new WireMockRule(8089);\n\n  /**\n   * This is a hack to make environment variables modifiable.", "refactored_code": "  private static final int MOCK_JWKS_SERVER_PORT = 8089;\n\n  private static final int MOCK_JWKS_SERVER_PORT = 8089;\n  @ClassRule\n  public static final WireMockRule MOCK_JWKS_SERVER = new WireMockRule(MOCK_JWKS_SERVER_PORT);\n\n  /**\n   * This is a hack to make environment variables modifiable."}
{"magic_number_smell": "    conf = MetastoreConf.newMetastoreConf();\n    MetastoreConf.setVar(conf, ConfVars.HMS_HANDLER_PROXY_CLASS,\n        MetastoreConf.METASTORE_RETRYING_HANDLER_CLASS);\n    MetastoreConf.setLongVar(conf, ConfVars.HMS_HANDLER_ATTEMPTS, 3);\n    MetastoreConf.setTimeVar(conf, ConfVars.HMS_HANDLER_INTERVAL, 10, TimeUnit.MILLISECONDS);\n    MetastoreConf.setBoolVar(conf, ConfVars.HMS_HANDLER_FORCE_RELOAD_CONF, false);\n  }", "refactored_code": "  private static final int RETRY_ATTEMPTS = 3;\n    conf = MetastoreConf.newMetastoreConf();\n    MetastoreConf.setVar(conf, ConfVars.HMS_HANDLER_PROXY_CLASS,\n        MetastoreConf.METASTORE_RETRYING_HANDLER_CLASS);\n    MetastoreConf.setLongVar(conf, ConfVars.HMS_HANDLER_ATTEMPTS, RETRY_ATTEMPTS);\n    MetastoreConf.setTimeVar(conf, ConfVars.HMS_HANDLER_INTERVAL, 10, TimeUnit.MILLISECONDS);\n    MetastoreConf.setBoolVar(conf, ConfVars.HMS_HANDLER_FORCE_RELOAD_CONF, false);\n  }"}
{"magic_number_smell": "    MetastoreConf.setLongVar(conf, MetastoreConf.ConfVars.BATCH_RETRIEVE_MAX, 2);\n    MetastoreConf.setLongVar(conf, MetastoreConf.ConfVars.BATCH_RETRIEVE_OBJECTS_MAX, 2);\n    MetastoreConf.setLongVar(conf, MetastoreConf.ConfVars.LIMIT_PARTITION_REQUEST,\n        100);\n    MetaStoreTestUtils.setConfForStandloneMode(conf);\n\n    // Do this only on your own peril, and never in the production code", "refactored_code": "  private static final int DEFAULT_LIMIT_PARTITION_REQUEST = 100;\n    MetastoreConf.setLongVar(conf, MetastoreConf.ConfVars.BATCH_RETRIEVE_MAX, 2);\n    MetastoreConf.setLongVar(conf, MetastoreConf.ConfVars.BATCH_RETRIEVE_OBJECTS_MAX, 2);\n    MetastoreConf.setLongVar(conf, MetastoreConf.ConfVars.LIMIT_PARTITION_REQUEST,\n        DEFAULT_LIMIT_PARTITION_REQUEST);\n    MetaStoreTestUtils.setConfForStandloneMode(conf);\n\n    // Do this only on your own peril, and never in the production code"}
{"magic_number_smell": "      System.out.println(e);\n    }\n\n    List<String> partitionNames = client.listPartitionNames(DB_NAME, tableName, -1);\n    Assert.assertNotNull(partitionNames);\n    Assert.assertTrue(partitionNames.isEmpty());\n  }", "refactored_code": "  private static final short MAX = -1;\n      System.out.println(e);\n    }\n\n    List<String> partitionNames = client.listPartitionNames(DB_NAME, tableName, MAX);\n    Assert.assertNotNull(partitionNames);\n    Assert.assertTrue(partitionNames.isEmpty());\n  }"}
{"magic_number_smell": "        .setSerdeName(\"partserde\" + index)\n        .addStorageDescriptorParam(\"partsdkey\" + index, \"partsdvalue\" + index)\n        .setCols(partCols)\n        .setCreateTime(123456)\n        .setLastAccessTime(123456)\n        .addCol(\"test_id\", \"int\", \"test col id\")\n        .addCol(\"test_value\", \"string\", \"test col value\")", "refactored_code": "  protected static final int DEFAULT_CREATE_TIME = 123456;\n        .setSerdeName(\"partserde\" + index)\n        .addStorageDescriptorParam(\"partsdkey\" + index, \"partsdvalue\" + index)\n        .setCols(partCols)\n        .setCreateTime(DEFAULT_CREATE_TIME)\n        .setLastAccessTime(DEFAULT_CREATE_TIME)\n        .addCol(\"test_id\", \"int\", \"test col id\")\n        .addCol(\"test_value\", \"string\", \"test col value\")"}
{"magic_number_smell": "\n  protected static void makeTestChangesOnPartition(Partition partition) {\n    partition.getParameters().put(\"hmsTestParam001\", \"testValue001\");\n    partition.setCreateTime(123456789);\n    partition.setLastAccessTime(123456789);\n    partition.getSd().setLocation(partition.getSd().getLocation()+\"/hh=01\");\n    partition.getSd().getCols().add(new FieldSchema(\"newcol\", \"string\", \"\"));", "refactored_code": "  protected static final int NEW_CREATE_TIME = 123456789;\n\n  protected static void makeTestChangesOnPartition(Partition partition) {\n    partition.getParameters().put(\"hmsTestParam001\", \"testValue001\");\n    partition.setCreateTime(NEW_CREATE_TIME);\n    partition.setLastAccessTime(NEW_CREATE_TIME);\n    partition.getSd().setLocation(partition.getSd().getLocation()+\"/hh=01\");\n    partition.getSd().getCols().add(new FieldSchema(\"newcol\", \"string\", \"\"));"}
{"magic_number_smell": "        getYearAndMonthPartCols(), partParams);\n\n    client.dropPartition(DB_NAME, TABLE_NAME, Lists.newArrayList(\"2016\", \"may\"), true);\n    List<Partition> partitionsAfterDelete = client.listPartitions(DB_NAME, TABLE_NAME, -1);\n    Assert.assertFalse(partitionsAfterDelete.contains(partition));\n    Assert.assertTrue(\"The location '\" + location + \"' should exist.\",\n        metaStore.isPathExists(new Path(location)));", "refactored_code": "  protected static final short MAX = -1;\n        getYearAndMonthPartCols(), partParams);\n\n    client.dropPartition(DB_NAME, TABLE_NAME, Lists.newArrayList(\"2016\", \"may\"), true);\n    List<Partition> partitionsAfterDelete = client.listPartitions(DB_NAME, TABLE_NAME, MAX);\n    Assert.assertFalse(partitionsAfterDelete.contains(partition));\n    Assert.assertTrue(\"The location '\" + location + \"' should exist.\",\n        metaStore.isPathExists(new Path(location)));"}
{"magic_number_smell": "        Lists.newArrayList(partitions[0], partitions[2], partitions[3], partitions[4]));\n    // Check the original partitions of the dest table\n    List<String> partitionNames =\n        client.listPartitionNames(destTable.getDbName(), destTable.getTableName(), -1);\n    Assert.assertEquals(3, partitionNames.size());\n    Assert.assertTrue(partitionNames.containsAll(\n        Lists.newArrayList(\"year=2019/month=march/day=15\", \"year=2019/month=march/day=22\")));", "refactored_code": "  protected static final short MAX = -1;\n        Lists.newArrayList(partitions[0], partitions[2], partitions[3], partitions[4]));\n    // Check the original partitions of the dest table\n    List<String> partitionNames =\n        client.listPartitionNames(destTable.getDbName(), destTable.getTableName(), MAX);\n    Assert.assertEquals(3, partitionNames.size());\n    Assert.assertTrue(partitionNames.containsAll(\n        Lists.newArrayList(\"year=2019/month=march/day=15\", \"year=2019/month=march/day=22\")));"}
{"magic_number_smell": "\n    createDB(DB_NAME);\n    createTable(DB_NAME, TABLE_NAME);\n    notificationLog = insertTxnWriteNotificationLog(1, WRITE_ID, DB_NAME, TABLE_NAME);\n  }\n\n  @After", "refactored_code": "  private static final long TXN_ID = 1;\n\n    createDB(DB_NAME);\n    createTable(DB_NAME, TABLE_NAME);\n    notificationLog = insertTxnWriteNotificationLog(TXN_ID, WRITE_ID, DB_NAME, TABLE_NAME);\n  }\n\n  @After"}
{"magic_number_smell": "        printDockerEvents();\n        throw new RuntimeException(\"Failed to get docker logs\");\n      }\n    } while (startTime + 5 * 60 * 1000 >= System.currentTimeMillis() && !isContainerReady(pr));\n    if (startTime + 5 * 60 * 1000 < System.currentTimeMillis()) {\n      printDockerEvents();\n      throw new RuntimeException(", "refactored_code": "  private static final int MAX_STARTUP_WAIT = 5 * 60 * 1000;\n        printDockerEvents();\n        throw new RuntimeException(\"Failed to get docker logs\");\n      }\n    } while (startTime + MAX_STARTUP_WAIT >= System.currentTimeMillis() && !isContainerReady(pr));\n    if (startTime + MAX_STARTUP_WAIT < System.currentTimeMillis()) {\n      printDockerEvents();\n      throw new RuntimeException("}
{"magic_number_smell": "\n  @Test\n  public void testCollectWorkerVersionsEmptyLists() {\n    assertThat(CompactionMetricData.of(Collections.emptyList()).allWorkerVersionsSince(0L),\n\n        is(Collections.emptyList()));\n  }", "refactored_code": "  private static final long SINCE_EPOCH = 0L;\n\n  @Test\n  public void testCollectWorkerVersionsEmptyLists() {\n    assertThat(CompactionMetricData.of(Collections.emptyList()).allWorkerVersionsSince(SINCE_EPOCH),\n\n        is(Collections.emptyList()));\n  }"}
{"magic_number_smell": "    Configuration conf = MetastoreConf.newMetastoreConf();\n    MetastoreConf.setVar(conf, MetastoreConf.ConfVars.METRICS_REPORTERS, \"slf4j\");\n    MetastoreConf.setTimeVar(conf,\n        MetastoreConf.ConfVars.METRICS_SLF4J_LOG_FREQUENCY_MINS, 1, TimeUnit.SECONDS);\n\n    // 1. Verify the default level (INFO)\n    MetastoreConf.setVar(conf, MetastoreConf.ConfVars.METRICS_SLF4J_LOG_LEVEL, \"INFO\");", "refactored_code": "  private static final long REPORT_INTERVAL = 1;\n    Configuration conf = MetastoreConf.newMetastoreConf();\n    MetastoreConf.setVar(conf, MetastoreConf.ConfVars.METRICS_REPORTERS, \"slf4j\");\n    MetastoreConf.setTimeVar(conf,\n        MetastoreConf.ConfVars.METRICS_SLF4J_LOG_FREQUENCY_MINS, REPORT_INTERVAL, TimeUnit.SECONDS);\n\n    // 1. Verify the default level (INFO)\n    MetastoreConf.setVar(conf, MetastoreConf.ConfVars.METRICS_SLF4J_LOG_LEVEL, \"INFO\");"}
{"magic_number_smell": "\n  protected static final int 8089 = 8089;\n  @ClassRule\n  public static final WireMockRule MOCK_JWKS_SERVER = new WireMockRule(8089);\n  // the url part\n  /**\n   * Abstract the property client access on a given namespace.", "refactored_code": "  protected static final int MOCK_JWKS_SERVER_PORT = 8089;\n\n  protected static final int MOCK_JWKS_SERVER_PORT = 8089;\n  @ClassRule\n  public static final WireMockRule MOCK_JWKS_SERVER = new WireMockRule(MOCK_JWKS_SERVER_PORT);\n  // the url part\n  /**\n   * Abstract the property client access on a given namespace."}
{"magic_number_smell": "   */\n  private static DescriptiveStatistics sanitize(@NotNull DescriptiveStatistics data) {\n    double meanValue = data.getMean();\n    double delta = 2 * meanValue;\n    double minVal = meanValue - delta;\n    double maxVal = meanValue + delta;\n    return new DescriptiveStatistics(Arrays.stream(data.getValues())", "refactored_code": "  private static final double MARGIN = 2;\n   */\n  private static DescriptiveStatistics sanitize(@NotNull DescriptiveStatistics data) {\n    double meanValue = data.getMean();\n    double delta = MARGIN * meanValue;\n    double minVal = meanValue - delta;\n    double maxVal = meanValue + delta;\n    return new DescriptiveStatistics(Arrays.stream(data.getValues())"}
{"magic_number_smell": "   * Create default micro benchmark measurer\n   */\n  public MicroBenchmark() {\n    this(15, ITERATIONS_DEFAULT, SCALE_DEFAULT);\n  }\n\n  /**", "refactored_code": "  private static final int WARMUP_DEFAULT = 15;\n   * Create default micro benchmark measurer\n   */\n  public MicroBenchmark() {\n    this(WARMUP_DEFAULT, ITERATIONS_DEFAULT, SCALE_DEFAULT);\n  }\n\n  /**"}
{"magic_number_smell": "      }\n      if (txnMin == txnMax) {\n        builder.append(txnMin);\n      } else if (txnMin + 5 - 1 > txnMax) {\n        // If the range is small the overhead is not worth it\n        for (long txn = txnMin; txn <= txnMax; txn++) {\n          builder.append(txn);", "refactored_code": "  private static final int MIN_RANGE_LENGTH = 5;\n      }\n      if (txnMin == txnMax) {\n        builder.append(txnMin);\n      } else if (txnMin + MIN_RANGE_LENGTH - 1 > txnMax) {\n        // If the range is small the overhead is not worth it\n        for (long txn = txnMin; txn <= txnMax; txn++) {\n          builder.append(txn);"}
{"magic_number_smell": "  private static final int FOUR_X_LONGWORD_DECIMAL_DIGITS = 4 * LONGWORD_DECIMAL_DIGITS;\n\n  // 38 decimal maximum - 32 digits in 2 lower longs (6 digits here).\n  private static final int HIGHWORD_DECIMAL_DIGITS = 38 - TWO_X_LONGWORD_DECIMAL_DIGITS;\n  private static final long MAX_HIGHWORD_DECIMAL =\n      powerOfTenTable[HIGHWORD_DECIMAL_DIGITS] - 1;\n", "refactored_code": "  public static final int MAX_DECIMAL_DIGITS = 38;\n  private static final int FOUR_X_LONGWORD_DECIMAL_DIGITS = 4 * LONGWORD_DECIMAL_DIGITS;\n\n  // 38 decimal maximum - 32 digits in 2 lower longs (6 digits here).\n  private static final int HIGHWORD_DECIMAL_DIGITS = MAX_DECIMAL_DIGITS - TWO_X_LONGWORD_DECIMAL_DIGITS;\n  private static final long MAX_HIGHWORD_DECIMAL =\n      powerOfTenTable[HIGHWORD_DECIMAL_DIGITS] - 1;\n"}
{"magic_number_smell": "   *\n   * A BigDecimal object has a decimal scale.\n   *\n   * We will have overflow if BigDecimal's integer part exceed 38 digits or\n   * 99,999,999,999,999,999,999,999,999,999,999,999,999 or 10^38 - 1.\n   *\n   * When the BigDecimal value's precision exceeds 38 and there are fractional digits", "refactored_code": "  public static final int MAX_PRECISION = 38;\n   *\n   * A BigDecimal object has a decimal scale.\n   *\n   * We will have overflow if BigDecimal's integer part exceed MAX_PRECISION digits or\n   * 99,999,999,999,999,999,999,999,999,999,999,999,999 or 10^38 - 1.\n   *\n   * When the BigDecimal value's precision exceeds MAX_PRECISION and there are fractional digits"}
{"magic_number_smell": "\n    int intDigits = bd.precision() - bd.scale();\n\n    if (intDigits > 38) {\n      return null;\n    }\n", "refactored_code": "  public static final int MAX_PRECISION = 38;\n\n    int intDigits = bd.precision() - bd.scale();\n\n    if (intDigits > MAX_PRECISION) {\n      return null;\n    }\n"}
{"magic_number_smell": "    switch (r.nextInt(4)) {\n    case 1:\n      optionalNanos = String.format(\".%09d\",\n          Integer.valueOf(r.nextInt((int) TimeUnit.SECONDS.toNanos(1))));\n      break;\n    case 2:\n      // Limit to milliseconds only...", "refactored_code": "  public static final long NANOSECONDS_PER_SECOND = TimeUnit.SECONDS.toNanos(1);\n    switch (r.nextInt(4)) {\n    case 1:\n      optionalNanos = String.format(\".%09d\",\n          Integer.valueOf(r.nextInt((int) NANOSECONDS_PER_SECOND)));\n      break;\n    case 2:\n      // Limit to milliseconds only..."}
{"magic_number_smell": "  public void fillWithNulls() {\n    noNulls = false;\n    isRepeating = true;\n    vector[0] = Double.NaN;\n    isNull[0] = true;\n  }\n", "refactored_code": "  public static final double NULL_VALUE = Double.NaN;\n  public void fillWithNulls() {\n    noNulls = false;\n    isRepeating = true;\n    vector[0] = NULL_VALUE;\n    isNull[0] = true;\n  }\n"}
{"magic_number_smell": "  public LongColumnVector fillWithNulls() {\n    noNulls = false;\n    isRepeating = true;\n    vector[0] = 1;\n    isNull[0] = true;\n\n    return this;", "refactored_code": "  public static final long NULL_VALUE = 1;\n  public LongColumnVector fillWithNulls() {\n    noNulls = false;\n    isRepeating = true;\n    vector[0] = NULL_VALUE;\n    isNull[0] = true;\n\n    return this;"}
{"magic_number_smell": "   * @param numCols the number of columns to include in the batch\n   */\n  public VectorizedRowBatch(int numCols) {\n    this(numCols, 1024);\n  }\n\n  /**", "refactored_code": "  public static final int DEFAULT_SIZE = 1024;\n   * @param numCols the number of columns to include in the batch\n   */\n  public VectorizedRowBatch(int numCols) {\n    this(numCols, DEFAULT_SIZE);\n  }\n\n  /**"}
{"magic_number_smell": "   */\n  private static class BoyerMooreHorspool implements Finder {\n    private static final int 0xff = 0xff;\n    private final long[] shift = new long[0xff];\n    private final byte[] pattern;\n    private final int plen;\n", "refactored_code": "    private static final int MAX_BYTE = 0xff;\n   */\n  private static class BoyerMooreHorspool implements Finder {\n    private static final int MAX_BYTE = 0xff;\n    private final long[] shift = new long[MAX_BYTE];\n    private final byte[] pattern;\n    private final int plen;\n"}
{"magic_number_smell": "      int numComb = 1;\n      for (ExpressionTree tree : andList) {\n        numComb *= tree.getChildren().size();\n        if (numComb > 256) {\n          return false;\n        }\n      }", "refactored_code": "    private static final int CNF_COMBINATIONS_THRESHOLD = 256;\n      int numComb = 1;\n      for (ExpressionTree tree : andList) {\n        numComb *= tree.getChildren().size();\n        if (numComb > CNF_COMBINATIONS_THRESHOLD) {\n          return false;\n        }\n      }"}
{"magic_number_smell": "  public static final int 12 = 12;\n  public static final int JAVA32_ARRAY_META = 16;\n  public static final int JAVA32_REF = 4;\n  public static final int JAVA32_OBJECT = 16;   // 12 + JAVA32_REF\n  public static final int JAVA32_ARRAY = 20;    // JAVA32_ARRAY_META + JAVA32_REF\n\n  public static final int JAVA64_META = 24;", "refactored_code": "  public static final int JAVA32_META = 12;\n  public static final int JAVA32_META = 12;\n  public static final int JAVA32_ARRAY_META = 16;\n  public static final int JAVA32_REF = 4;\n  public static final int JAVA32_OBJECT = 16;   // JAVA32_META + JAVA32_REF\n  public static final int JAVA32_ARRAY = 20;    // JAVA32_ARRAY_META + JAVA32_REF\n\n  public static final int JAVA64_META = 24;"}
{"magic_number_smell": "    // What we are trying to get is the equivalent of new Date(ymd).getTime() in the local tz,\n    // where ymd is whatever d represents. How it \"works\" is this.\n    // First we get the UTC midnight for that day (which always exists, a small island of sanity).\n    long utcMidnight = d * TimeUnit.DAYS.toMillis(1);\n    // Now we take a local TZ offset at midnight UTC. Say we are in -4; that means (surprise\n    // surprise) that at midnight UTC it was 20:00 in local. So far we are on firm ground.\n    long utcMidnightOffset = LOCAL_TIMEZONE.get().getOffset(utcMidnight);", "refactored_code": "  private static final long MILLIS_PER_DAY = TimeUnit.DAYS.toMillis(1);\n    // What we are trying to get is the equivalent of new Date(ymd).getTime() in the local tz,\n    // where ymd is whatever d represents. How it \"works\" is this.\n    // First we get the UTC midnight for that day (which always exists, a small island of sanity).\n    long utcMidnight = d * MILLIS_PER_DAY;\n    // Now we take a local TZ offset at midnight UTC. Say we are in -4; that means (surprise\n    // surprise) that at midnight UTC it was 20:00 in local. So far we are on firm ground.\n    long utcMidnightOffset = LOCAL_TIMEZONE.get().getOffset(utcMidnight);"}
{"magic_number_smell": "   */\n  @HiveDecimalWritableVersionV2\n  public static boolean isPrecisionDecimal64(int precision) {\n    return (precision <= FastHiveDecimalImpl.DECIMAL64_DECIMAL_DIGITS);\n  }\n\n  /*", "refactored_code": "  public static final int DECIMAL64_DECIMAL_DIGITS = FastHiveDecimalImpl.DECIMAL64_DECIMAL_DIGITS;\n   */\n  @HiveDecimalWritableVersionV2\n  public static boolean isPrecisionDecimal64(int precision) {\n    return (precision <= DECIMAL64_DECIMAL_DIGITS);\n  }\n\n  /*"}
{"magic_number_smell": "  }\n\n  public BloomFilter(long expectedEntries) {\n    this(expectedEntries, 0.05);\n  }\n\n  static void checkArgument(boolean expression, String message) {", "refactored_code": "  public static final double DEFAULT_FPP = 0.05;\n  }\n\n  public BloomFilter(long expectedEntries) {\n    this(expectedEntries, DEFAULT_FPP);\n  }\n\n  static void checkArgument(boolean expression, String message) {"}
{"magic_number_smell": "\n  public BloomKFilter(long maxNumEntries) {\n    checkArgument(maxNumEntries > 0, \"expectedEntries should be > 0\");\n    long numBits = optimalNumOfBits(maxNumEntries, 0.05f);\n    this.k = optimalNumOfHashFunctions(maxNumEntries, numBits);\n    long nLongs = (long) Math.ceil((double) numBits / (double) Long.SIZE);\n    // additional bits to pad long array to block size", "refactored_code": "  public static final float DEFAULT_FPP = 0.05f;\n\n  public BloomKFilter(long maxNumEntries) {\n    checkArgument(maxNumEntries > 0, \"expectedEntries should be > 0\");\n    long numBits = optimalNumOfBits(maxNumEntries, DEFAULT_FPP);\n    this.k = optimalNumOfHashFunctions(maxNumEntries, numBits);\n    long nLongs = (long) Math.ceil((double) numBits / (double) Long.SIZE);\n    // additional bits to pad long array to block size"}
{"magic_number_smell": "\n  public static final int 1000000000 = 1000000000;\n  public static final BigDecimal MAX_INT_BD = new BigDecimal(Integer.MAX_VALUE);\n  public static final BigDecimal NANOS_PER_SEC_BD = new BigDecimal(1000000000);\n\n  public static int parseNumericValueWithRange(String fieldName,\n      String strVal, int minValue, int maxValue) throws IllegalArgumentException {", "refactored_code": "  public static final int NANOS_PER_SEC = 1000000000;\n\n  public static final int NANOS_PER_SEC = 1000000000;\n  public static final BigDecimal MAX_INT_BD = new BigDecimal(Integer.MAX_VALUE);\n  public static final BigDecimal NANOS_PER_SEC_BD = new BigDecimal(NANOS_PER_SEC);\n\n  public static int parseNumericValueWithRange(String fieldName,\n      String strVal, int minValue, int maxValue) throws IllegalArgumentException {"}
{"magic_number_smell": "    assertTrue( bf.test(val2));\n    assertTrue( bf.test(val3));\n\n    byte[] randVal = new byte[100];\n    for (int i = 0; i < 100; i++) {\n      rand.nextBytes(randVal);\n      bf.add(randVal);", "refactored_code": "  private static final int COUNT = 100;\n    assertTrue( bf.test(val2));\n    assertTrue( bf.test(val3));\n\n    byte[] randVal = new byte[COUNT];\n    for (int i = 0; i < COUNT; i++) {\n      rand.nextBytes(randVal);\n      bf.add(randVal);"}
{"magic_number_smell": "    assertTrue(bf.test(val2));\n    assertTrue(bf.test(val3));\n\n    byte[] randVal = new byte[100];\n    for (int i = 0; i < 100; i++) {\n      rand.nextBytes(randVal);\n      bf.add(randVal);", "refactored_code": "  private static final int COUNT = 100;\n    assertTrue(bf.test(val2));\n    assertTrue(bf.test(val3));\n\n    byte[] randVal = new byte[COUNT];\n    for (int i = 0; i < COUNT; i++) {\n      rand.nextBytes(randVal);\n      bf.add(randVal);"}
{"magic_number_smell": "    private List<String> staticPartitionValues;\n    private String agentInfo;\n    private HiveConf hiveConf;\n    private int transactionBatchSize = 1;\n    private boolean streamingOptimizations = DEFAULT_STREAMING_OPTIMIZATIONS_ENABLED;\n    private RecordWriter recordWriter;\n    private long writeId = -1;", "refactored_code": "  private static final int DEFAULT_TRANSACTION_BATCH_SIZE = 1;\n    private List<String> staticPartitionValues;\n    private String agentInfo;\n    private HiveConf hiveConf;\n    private int transactionBatchSize = DEFAULT_TRANSACTION_BATCH_SIZE;\n    private boolean streamingOptimizations = DEFAULT_STREAMING_OPTIMIZATIONS_ENABLED;\n    private RecordWriter recordWriter;\n    private long writeId = -1;"}
{"magic_number_smell": "      // if HIVE_TXN_TIMEOUT is defined, heartbeat interval will be HIVE_TXN_TIMEOUT/2\n      heartBeatInterval = DbTxnManager.getHeartbeatInterval(conn.getConf());\n    } catch (LockException e) {\n      heartBeatInterval = 60 * 1000;\n    }\n    // to introduce some randomness and to avoid hammering the metastore at the same time (same logic as DbTxnManager)\n    initialDelay = (long) (heartBeatInterval * 0.75 * Math.random());", "refactored_code": "  private static final int DEFAULT_HEARTBEAT_INTERVAL = 60 * 1000;\n      // if HIVE_TXN_TIMEOUT is defined, heartbeat interval will be HIVE_TXN_TIMEOUT/2\n      heartBeatInterval = DbTxnManager.getHeartbeatInterval(conn.getConf());\n    } catch (LockException e) {\n      heartBeatInterval = DEFAULT_HEARTBEAT_INTERVAL;\n    }\n    // to introduce some randomness and to avoid hammering the metastore at the same time (same logic as DbTxnManager)\n    initialDelay = (long) (heartBeatInterval * 0.75 * Math.random());"}
{"magic_number_smell": "   */\n  public static void main(String[] args) throws SQLException, ClassNotFoundException {\n    Class.forName(driverName);\n    int numberOfQueryIterations = 80000;\n\n    if (args.length > 0) {\n      numberOfQueryIterations = Integer.parseInt(args[0]);", "refactored_code": "  private static final int NUM_QUERY_ITERATIONS = 80000;\n   */\n  public static void main(String[] args) throws SQLException, ClassNotFoundException {\n    Class.forName(driverName);\n    int numberOfQueryIterations = NUM_QUERY_ITERATIONS;\n\n    if (args.length > 0) {\n      numberOfQueryIterations = Integer.parseInt(args[0]);"}
