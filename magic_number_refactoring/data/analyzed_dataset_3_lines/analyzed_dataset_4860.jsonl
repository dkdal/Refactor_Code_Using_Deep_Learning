{"magic_number_smell": "\t\tif (firstByte <= 250) {\n\t\t\treturn firstByte;\n\t\t}\n\tif (firstByte == 0xfb) {\n\t\treturn -1;\n\t}\n\tif (firstByte == 252) {", "refactored_code": "\tpublic static final int NULL_VALUE = 0xfb;\n\t\tif (firstByte <= 250) {\n\t\t\treturn firstByte;\n\t\t}\n\tif (firstByte == NULL_VALUE) {\n\t\treturn -1;\n\t}\n\tif (firstByte == 252) {"}
{"magic_number_smell": "\t}\n\n\tpublic int getMaxPacketSize() {\n\t\treturn 0x00ffffff; // TODO Make MySQL max packet size configurable\n\t}\n\n\tpublic MysqlCharacterSet getCharSet() {", "refactored_code": "\tpublic static final int MAX_PACKET_SIZE = 0x00ffffff;\n\t}\n\n\tpublic int getMaxPacketSize() {\n\t\treturn MAX_PACKET_SIZE; // TODO Make MySQL max packet size configurable\n\t}\n\n\tpublic MysqlCharacterSet getCharSet() {"}
{"magic_number_smell": "\t\tString version = IoUtils.readString(in, \"ASCII\");\n\t\tint threadId = IoUtils.readInt(in);\n\n\t\tbyte[] salt = new byte[8 + SALT2_SIZE];\n\t\tin.read(salt, 0, 8);\n\t\tin.read(); // Throw away 0 byte\n", "refactored_code": "\tpublic static final int SALT_SIZE = 8;\n\t\tString version = IoUtils.readString(in, \"ASCII\");\n\t\tint threadId = IoUtils.readInt(in);\n\n\t\tbyte[] salt = new byte[SALT_SIZE + SALT2_SIZE];\n\t\tin.read(salt, 0, SALT_SIZE);\n\t\tin.read(); // Throw away 0 byte\n"}
{"magic_number_smell": "\t\t\tString host = uri.getHost();\n\t\t\tint port = uri.getPort();\n\t\t\tif (port < 0) {\n\t\t\t\tport = 3306;\n\t\t\t}\n\t\t\tString schema = uri.getPath().substring(1);\n", "refactored_code": "\tpublic static final int DEFAULT_PORT = 3306;\n\t\t\tString host = uri.getHost();\n\t\t\tint port = uri.getPort();\n\t\t\tif (port < 0) {\n\t\t\t\tport = DEFAULT_PORT;\n\t\t\t}\n\t\t\tString schema = uri.getPath().substring(1);\n"}
{"magic_number_smell": "\t\t\tString host = uri.getHost();\n\t\t\tint port = uri.getPort();\n\t\t\tif (port < 0) {\n\t\t\t\tport = 3306;\n\t\t\t}\n\t\t\tString path = uri.getPath().trim();\n\t\t\tif (path.length() == 0 || \"/\".equals(path)) {", "refactored_code": "\tpublic static final int DEFAULT_PORT = 3306;\n\t\t\tString host = uri.getHost();\n\t\t\tint port = uri.getPort();\n\t\t\tif (port < 0) {\n\t\t\t\tport = DEFAULT_PORT;\n\t\t\t}\n\t\t\tString path = uri.getPath().trim();\n\t\t\tif (path.length() == 0 || \"/\".equals(path)) {"}
{"magic_number_smell": "\tprivate AbstractBackendMessage doDecode(DecoderInputStream input, boolean block) throws IOException {\n\t\tlogger.trace(\"Decoding message\");\n\t\t// If we're in non-blocking mode and we don't have the minimum amount of data to read in a backend message, return null\n\t\tif (!block && input.available() < 5) {\n\t\t\treturn null;\n\t\t}\n", "refactored_code": "\tprivate static final int MESSAGE_MIN_SIZE = 5;\n\tprivate AbstractBackendMessage doDecode(DecoderInputStream input, boolean block) throws IOException {\n\t\tlogger.trace(\"Decoding message\");\n\t\t// If we're in non-blocking mode and we don't have the minimum amount of data to read in a backend message, return null\n\t\tif (!block && input.available() < MESSAGE_MIN_SIZE) {\n\t\t\treturn null;\n\t\t}\n"}
{"magic_number_smell": "\t\t\tString host = uri.getHost();\n\t\t\tint port = uri.getPort();\n\t\t\tif (port < 0) {\n\t\t\t\tport = 5432;\n\t\t\t}\n\t\t\tString schema = uri.getPath().substring(1);\n", "refactored_code": "\tpublic static final int DEFAULT_PORT = 5432; \n\t\t\tString host = uri.getHost();\n\t\t\tint port = uri.getPort();\n\t\t\tif (port < 0) {\n\t\t\t\tport = DEFAULT_PORT;\n\t\t\t}\n\t\t\tString schema = uri.getPath().substring(1);\n"}
{"magic_number_smell": "\t\t\tString host = uri.getHost();\n\t\t\tint port = uri.getPort();\n\t\t\tif (port < 0) {\n\t\t\t\tport = 5432;\n\t\t\t}\n\t\t\tString schema = uri.getPath().substring(1);\n", "refactored_code": "\tpublic static final int DEFAULT_PORT = 5432;\n\t\t\tString host = uri.getHost();\n\t\t\tint port = uri.getPort();\n\t\t\tif (port < 0) {\n\t\t\t\tport = DEFAULT_PORT;\n\t\t\t}\n\t\t\tString schema = uri.getPath().substring(1);\n"}
{"magic_number_smell": "        glyphIndex = (short)(bais.read()<<8 | bais.read());\n\n        // Get the arguments as just their raw values\n        if ((flags & 0x0001) != 0) {\n            argument1 = (short)(bais.read()<<8 | bais.read());\n            argument2 = (short)(bais.read()<<8 | bais.read());\n        } else {", "refactored_code": "    public static final short ARG_1_AND_2_ARE_WORDS = 0x0001;\n        glyphIndex = (short)(bais.read()<<8 | bais.read());\n\n        // Get the arguments as just their raw values\n        if ((flags & ARG_1_AND_2_ARE_WORDS) != 0) {\n            argument1 = (short)(bais.read()<<8 | bais.read());\n            argument2 = (short)(bais.read()<<8 | bais.read());\n        } else {"}
{"magic_number_smell": "  \n  // Maximum precision for floats\n  private static final double 2.2204460492503131e-016 = 2.2204460492503131e-016;\n  //private static final float 2.2204460492503131e-016 = 1.192092896e-07F;\n  static final String GPC_VERSION = \"2.31\";\n  \n  private static final int LEFT  = 0;", "refactored_code": "  private static final double GPC_EPSILON = 2.2204460492503131e-016;\n  \n  // Maximum precision for floats\n  private static final double GPC_EPSILON = 2.2204460492503131e-016;\n  //private static final float GPC_EPSILON = 1.192092896e-07F;\n  static final String GPC_VERSION = \"2.31\";\n  \n  private static final int LEFT  = 0;"}
{"magic_number_smell": "  \n  // Maximum precision for floats\n  private static final double 2.2204460492503131e-016 = 2.2204460492503131e-016 ;\n  //private static final float 2.2204460492503131e-016 = 1.192092896e-07F;\n  static final String GPC_VERSION = \"2.31\";\n  \n  private static final int LEFT  = 0 ;", "refactored_code": "  private static final double GPC_EPSILON = 2.2204460492503131e-016 ;\n  \n  // Maximum precision for floats\n  private static final double GPC_EPSILON = 2.2204460492503131e-016 ;\n  //private static final float GPC_EPSILON = 1.192092896e-07F;\n  static final String GPC_VERSION = \"2.31\";\n  \n  private static final int LEFT  = 0 ;"}
{"magic_number_smell": "    RCommand result = new RCommand();\n    result.startPoint = start;\n    result.endPoint = end;\n    result.commandType = 0;\n    return result;\n  }\n", "refactored_code": "  public static final int LINETO = 0;\n    RCommand result = new RCommand();\n    result.startPoint = start;\n    result.endPoint = end;\n    result.commandType = LINETO;\n    return result;\n  }\n"}
{"magic_number_smell": "   * @invisible\n   */\n  public static class FontNotLoadedException extends NullPointerException{\n    private static final long -3710605630786298671L = -3710605630786298672L;\n\n    FontNotLoadedException(){\n      super(\"Use RG.loadFont(filename) and RG.textFont(font, size) to load and set fonts first.\");", "refactored_code": "    private static final long serialVersionUID = -3710605630786298671L;\n   * @invisible\n   */\n  public static class FontNotLoadedException extends NullPointerException{\n    private static final long serialVersionUID = -3710605630786298672L;\n\n    FontNotLoadedException(){\n      super(\"Use RG.loadFont(filename) and RG.textFont(font, size) to load and set fonts first.\");"}
{"magic_number_smell": "        int i;\n        // First check to see if need to allocate a new StringBuilder\n        for (i = 0; i < chars.length; i++) {\n            if (chars[i] < Chars.SP) {\n                break;\n            }\n        }", "refactored_code": "    private static final int FIRST_VALID_CHAR = Chars.SP;\n        int i;\n        // First check to see if need to allocate a new StringBuilder\n        for (i = 0; i < chars.length; i++) {\n            if (chars[i] < FIRST_VALID_CHAR) {\n                break;\n            }\n        }"}
{"magic_number_smell": "            this.maxLineLength = INIT_MAX_LINE_LENGTH;\n            this.maxHeaderCount = INIT_MAX_HEADER_COUNT;\n            this.maxEmptyLineCount = INIT_MAX_EMPTY_LINE_COUNT;\n            this.initialWindowSize = 65535;\n        }\n\n        /**", "refactored_code": "    private static final int INIT_WINDOW_SIZE = 65535;\n            this.maxLineLength = INIT_MAX_LINE_LENGTH;\n            this.maxHeaderCount = INIT_MAX_HEADER_COUNT;\n            this.maxEmptyLineCount = INIT_MAX_EMPTY_LINE_COUNT;\n            this.initialWindowSize = INIT_WINDOW_SIZE;\n        }\n\n        /**"}
{"magic_number_smell": "        this.lineParser = lineParser != null ? lineParser : LazyLineParser.INSTANCE;\n        this.headerLines = new ArrayList<>();\n        this.headLine = new CharArrayBuffer(128);\n        this.state = 0;\n    }\n\n    /**", "refactored_code": "    private static final int HEAD_LINE    = 0;\n        this.lineParser = lineParser != null ? lineParser : LazyLineParser.INSTANCE;\n        this.headerLines = new ArrayList<>();\n        this.headLine = new CharArrayBuffer(128);\n        this.state = HEAD_LINE;\n    }\n\n    /**"}
{"magic_number_smell": "                        return;\n                    }\n                    // read and discard the remainder of the message\n                    final byte[] buff = new byte[2048];\n                    while (read(buff) >= 0) {\n                    }\n                }", "refactored_code": "    private static final int BUFFER_SIZE = 2048;\n                        return;\n                    }\n                    // read and discard the remainder of the message\n                    final byte[] buff = new byte[BUFFER_SIZE];\n                    while (read(buff) >= 0) {\n                    }\n                }"}
{"magic_number_smell": "        if (!closed) {\n            try {\n                if (pos < contentLength) {\n                    final byte[] buffer = new byte[2048];\n                    while (read(buffer) >= 0) {\n                        // keep reading\n                    }", "refactored_code": "    private static final int BUFFER_SIZE = 2048;\n        if (!closed) {\n            try {\n                if (pos < contentLength) {\n                    final byte[] buffer = new byte[BUFFER_SIZE];\n                    while (read(buffer) >= 0) {\n                        // keep reading\n                    }"}
{"magic_number_smell": "     * Instantiates a default {@link MonitoringResponseOutOfOrderStrategy}. {@link #INSTANCE} may be used instead.\n     */\n    public MonitoringResponseOutOfOrderStrategy() {\n        this(8 * 1024);\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_CHUNK_SIZE = 8 * 1024;\n     * Instantiates a default {@link MonitoringResponseOutOfOrderStrategy}. {@link #INSTANCE} may be used instead.\n     */\n    public MonitoringResponseOutOfOrderStrategy() {\n        this(DEFAULT_CHUNK_SIZE);\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    public static String toString(\n            final HttpEntity entity, final Charset defaultCharset) throws IOException, ParseException {\n        return toString(entity, defaultCharset, Integer.MAX_VALUE);\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_ENTITY_RETURN_MAX_LENGTH = Integer.MAX_VALUE;\n     */\n    public static String toString(\n            final HttpEntity entity, final Charset defaultCharset) throws IOException, ParseException {\n        return toString(entity, defaultCharset, DEFAULT_ENTITY_RETURN_MAX_LENGTH);\n    }\n\n    /**"}
{"magic_number_smell": "    }\n\n    public AbstractCharDataConsumer() {\n        this(8192, CharCodingConfig.DEFAULT);\n    }\n    /**\n     * Triggered to obtain the capacity increment.", "refactored_code": "    protected static final int DEF_BUF_SIZE = 8192;\n    }\n\n    public AbstractCharDataConsumer() {\n        this(DEF_BUF_SIZE, CharCodingConfig.DEFAULT);\n    }\n    /**\n     * Triggered to obtain the capacity increment."}
{"magic_number_smell": "\n    public PathEntityProducer(final Path file, final ContentType contentType, final boolean chunked,\n            final OpenOption... openOptions) throws IOException {\n        this(file, 8192, contentType, chunked, openOptions);\n    }\n\n    public PathEntityProducer(final Path file, final ContentType contentType, final OpenOption... openOptions)", "refactored_code": "    private static final int BUFFER_SIZE = 8192;\n\n    public PathEntityProducer(final Path file, final ContentType contentType, final boolean chunked,\n            final OpenOption... openOptions) throws IOException {\n        this(file, BUFFER_SIZE, contentType, chunked, openOptions);\n    }\n\n    public PathEntityProducer(final Path file, final ContentType contentType, final OpenOption... openOptions)"}
{"magic_number_smell": "        lock.lock();\n        try {\n            final long now = System.currentTimeMillis();\n            if (now - this.dateAsMillis > 1000) {\n                // Generate new date string\n                dateAsText = dateTimeFormatter.format(Instant.now().atZone(zoneId));\n                dateAsMillis = now;", "refactored_code": "    private static final int GRANULARITY_MILLIS = 1000;\n        lock.lock();\n        try {\n            final long now = System.currentTimeMillis();\n            if (now - this.dateAsMillis > GRANULARITY_MILLIS) {\n                // Generate new date string\n                dateAsText = dateTimeFormatter.format(Instant.now().atZone(zoneId));\n                dateAsMillis = now;"}
{"magic_number_smell": "                buf.append(\"+\");\n            } else {\n                buf.append(\"%\");\n                final char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n                final char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n                buf.append(hex1);\n                buf.append(hex2);", "refactored_code": "    private static final int RADIX = 16;\n                buf.append(\"+\");\n            } else {\n                buf.append(\"%\");\n                final char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));\n                final char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));\n                buf.append(hex1);\n                buf.append(hex2);"}
{"magic_number_smell": "    /**\n     * Interest in data input/output.\n     */\n    public static final int READ_WRITE = SelectionKey.OP_READ | WRITE;\n\n}\n", "refactored_code": "    public static final int READ = SelectionKey.OP_READ;\n    /**\n     * Interest in data input/output.\n     */\n    public static final int READ_WRITE = READ | WRITE;\n\n}\n"}
{"magic_number_smell": "\n    private void processPendingChannels() throws IOException {\n        ChannelEntry entry;\n        for (int i = 0; i < 10000 && (entry = this.channelQueue.poll()) != null; i++) {\n            final SocketChannel socketChannel = entry.channel;\n            final Object attachment = entry.attachment;\n            try {", "refactored_code": "    private static final int MAX_CHANNEL_REQUESTS = 10000;\n\n    private void processPendingChannels() throws IOException {\n        ChannelEntry entry;\n        for (int i = 0; i < MAX_CHANNEL_REQUESTS && (entry = this.channelQueue.poll()) != null; i++) {\n            final SocketChannel socketChannel = entry.channel;\n            final Object attachment = entry.attachment;\n            try {"}
{"magic_number_smell": "\n    private static final int 255 = 255;\n\n    private static final int MAX_COMMAND_CONNECT_LENGTH = 6 + 255 + 1;\n\n    private static final byte CLIENT_VERSION = 5;\n", "refactored_code": "    private static final int MAX_DNS_NAME_LENGTH = 255;\n\n    private static final int MAX_DNS_NAME_LENGTH = 255;\n\n    private static final int MAX_COMMAND_CONNECT_LENGTH = 6 + MAX_DNS_NAME_LENGTH + 1;\n\n    private static final byte CLIENT_VERSION = 5;\n"}
{"magic_number_smell": "    /**\n     * The maximum (longest-lived) deadline.\n     */\n    public static Deadline MAX_VALUE = new Deadline(Long.MAX_VALUE);\n\n    /**\n     * The minimum (shortest-lived) deadline.", "refactored_code": "    private static final long INTERNAL_MAX_VALUE = Long.MAX_VALUE;\n    /**\n     * The maximum (longest-lived) deadline.\n     */\n    public static Deadline MAX_VALUE = new Deadline(INTERNAL_MAX_VALUE);\n\n    /**\n     * The minimum (shortest-lived) deadline."}
{"magic_number_smell": "    public static final int HT = 9;  // <US-ASCII HT, horizontal-tab (9)>\n\n    public static boolean isWhitespace(final char ch) {\n        return ch == SP || ch == HT || ch == 13 || ch == LF;\n    }\n\n    /**", "refactored_code": "    public static final int CR = 13; // <US-ASCII CR, carriage return (13)>\n    public static final int HT = 9;  // <US-ASCII HT, horizontal-tab (9)>\n\n    public static boolean isWhitespace(final char ch) {\n        return ch == SP || ch == HT || ch == CR || ch == LF;\n    }\n\n    /**"}
{"magic_number_smell": "            lock.lock();\n            try {\n                exchangeState.requestCapacityChannel = capacityChannel;\n                final int capacity = exchangeState.inBuf != null ? exchangeState.inBuf.capacity() : 4096;\n                if (capacity > 0) {\n                    println(\"[client<-proxy] \" + exchangeState.id + \" input capacity: \" + capacity);\n                    capacityChannel.update(capacity);", "refactored_code": "    private static final int INIT_BUFFER_SIZE = 4096;\n            lock.lock();\n            try {\n                exchangeState.requestCapacityChannel = capacityChannel;\n                final int capacity = exchangeState.inBuf != null ? exchangeState.inBuf.capacity() : INIT_BUFFER_SIZE;\n                if (capacity > 0) {\n                    println(\"[client<-proxy] \" + exchangeState.id + \" input capacity: \" + capacity);\n                    capacityChannel.update(capacity);"}
{"magic_number_smell": "\n    public static H2Config.Builder initial() {\n        return new Builder()\n                .setHeaderTableSize(4096)\n                .setPushEnabled(INIT_ENABLE_PUSH)\n                .setMaxConcurrentStreams(Integer.MAX_VALUE) // no limit\n                .setMaxFrameSize(INIT_MAX_FRAME_SIZE)", "refactored_code": "    private static final int      INIT_HEADER_TABLE_SIZE   = 4096;\n\n    public static H2Config.Builder initial() {\n        return new Builder()\n                .setHeaderTableSize(INIT_HEADER_TABLE_SIZE)\n                .setPushEnabled(INIT_ENABLE_PUSH)\n                .setMaxConcurrentStreams(Integer.MAX_VALUE) // no limit\n                .setMaxFrameSize(INIT_MAX_FRAME_SIZE)"}
{"magic_number_smell": "    }\n\n    public int getTotalSize() {\n        return nameLen + valueLen + 32;\n    }\n\n    @Override", "refactored_code": "    static private final int ENTRY_SIZE_OVERHEAD = 32;\n    }\n\n    public int getTotalSize() {\n        return nameLen + valueLen + ENTRY_SIZE_OVERHEAD;\n    }\n\n    @Override"}
{"magic_number_smell": "                    return false;\n                }\n                localEndStream = true;\n                deadline = System.currentTimeMillis() + 1000;\n                if (!idle) {\n                    final RawFrame resetStream = frameFactory.createResetStream(id, code);\n                    commitFrameInternal(resetStream);", "refactored_code": "    private static final long LINGER_TIME = 1000; // 1 second\n                    return false;\n                }\n                localEndStream = true;\n                deadline = System.currentTimeMillis() + LINGER_TIME;\n                if (!idle) {\n                    final RawFrame resetStream = frameFactory.createResetStream(id, code);\n                    commitFrameInternal(resetStream);"}
{"magic_number_smell": "            throw new IllegalStateException(\"Already subscribed\");\n        }\n\n        subscription.request(5);\n    }\n\n    @Override", "refactored_code": "    private static final int BUFFER_WINDOW_SIZE = 5;\n            throw new IllegalStateException(\"Already subscribed\");\n        }\n\n        subscription.request(BUFFER_WINDOW_SIZE);\n    }\n\n    @Override"}
{"magic_number_smell": "        final Flowable<ByteBuffer> publisher = Flowable.just(\n                ByteBuffer.wrap(new byte[]{'1', '2', '3'}),\n                ByteBuffer.wrap(new byte[]{'4', '5', '6'}));\n        final ReactiveEntityProducer entityProducer = new ReactiveEntityProducer(publisher, 1, CONTENT_TYPE, GZIP_CONTENT_ENCODING);\n\n        final WritableByteChannelMock byteChannel = new WritableByteChannelMock(1024);\n        final DataStreamChannel streamChannel = new BasicDataStreamChannel(byteChannel);", "refactored_code": "    private static final long CONTENT_LENGTH = 1;\n        final Flowable<ByteBuffer> publisher = Flowable.just(\n                ByteBuffer.wrap(new byte[]{'1', '2', '3'}),\n                ByteBuffer.wrap(new byte[]{'4', '5', '6'}));\n        final ReactiveEntityProducer entityProducer = new ReactiveEntityProducer(publisher, CONTENT_LENGTH, CONTENT_TYPE, GZIP_CONTENT_ENCODING);\n\n        final WritableByteChannelMock byteChannel = new WritableByteChannelMock(1024);\n        final DataStreamChannel streamChannel = new BasicDataStreamChannel(byteChannel);"}
{"magic_number_smell": "\n                private Socket establishConnection(final DataInputStream input, final DataOutputStream output) throws IOException {\n                    final int clientVersion = input.readUnsignedByte();\n                    if (clientVersion != 5) {\n                        throw new IOException(\"SOCKS implementation only supports version 5\");\n                    }\n                    final int nMethods = input.readUnsignedByte();", "refactored_code": "        public static final int VERSION_5 = 5;\n\n                private Socket establishConnection(final DataInputStream input, final DataOutputStream output) throws IOException {\n                    final int clientVersion = input.readUnsignedByte();\n                    if (clientVersion != VERSION_5) {\n                        throw new IOException(\"SOCKS implementation only supports version 5\");\n                    }\n                    final int nMethods = input.readUnsignedByte();"}
{"magic_number_smell": "        this.serverResource = new HttpServerResource(scheme, bootstrap -> bootstrap\n                .setSocketConfig(SocketConfig.custom()\n                        .setSoTimeout(TIMEOUT)\n                        .setSndBufSize(16 * 1024)\n                        .setRcvBufSize(16 * 1024)\n                        .setSoKeepAlive(false)\n                        .build())", "refactored_code": "    private static final int BUFFER_SIZE = 16 * 1024;\n        this.serverResource = new HttpServerResource(scheme, bootstrap -> bootstrap\n                .setSocketConfig(SocketConfig.custom()\n                        .setSoTimeout(TIMEOUT)\n                        .setSndBufSize(BUFFER_SIZE)\n                        .setRcvBufSize(BUFFER_SIZE)\n                        .setSoKeepAlive(false)\n                        .build())"}
{"magic_number_smell": "                \"localhost\", serverEndpoint.getPort(), TIMEOUT);\n        final ClientSessionEndpoint streamEndpoint = connectFuture.get();\n\n        for (int i = 0; i < 25; i++) {\n            final Future<Message<HttpResponse, String>> future = streamEndpoint.execute(\n                    new BasicRequestProducer(Method.GET, createRequestURI(serverEndpoint, \"/hello\")),\n                    new BasicResponseConsumer<>(new StringAsyncEntityConsumer()), null);", "refactored_code": "    private static final int REQ_NUM = 25;\n                \"localhost\", serverEndpoint.getPort(), TIMEOUT);\n        final ClientSessionEndpoint streamEndpoint = connectFuture.get();\n\n        for (int i = 0; i < REQ_NUM; i++) {\n            final Future<Message<HttpResponse, String>> future = streamEndpoint.execute(\n                    new BasicRequestProducer(Method.GET, createRequestURI(serverEndpoint, \"/hello\")),\n                    new BasicResponseConsumer<>(new StringAsyncEntityConsumer()), null);"}
{"magic_number_smell": "   * @param tc the Transcoder to use\n   */\n  public CASMutator(MemcachedClientIF c, Transcoder<T> tc) {\n    this(c, tc, 8192);\n  }\n\n  /**", "refactored_code": "  private static final int MAX_TRIES = 8192;\n   * @param tc the Transcoder to use\n   */\n  public CASMutator(MemcachedClientIF c, Transcoder<T> tc) {\n    this(c, tc, MAX_TRIES);\n  }\n\n  /**"}
{"magic_number_smell": "   * Create a DefaultConnectionFactory with the default parameters.\n   */\n  public DefaultConnectionFactory() {\n    this(16384, DEFAULT_READ_BUFFER_SIZE);\n  }\n\n  public MemcachedNode createMemcachedNode(SocketAddress sa, SocketChannel c,", "refactored_code": "  public static final int DEFAULT_OP_QUEUE_LEN = 16384;\n   * Create a DefaultConnectionFactory with the default parameters.\n   */\n  public DefaultConnectionFactory() {\n    this(DEFAULT_OP_QUEUE_LEN, DEFAULT_READ_BUFFER_SIZE);\n  }\n\n  public MemcachedNode createMemcachedNode(SocketAddress sa, SocketChannel c,"}
{"magic_number_smell": "      break;\n    case FNV1_64_HASH:\n      // Thanks to pierre@demartines.com for the pointer\n      rv = 0xcbf29ce484222325L;\n      for (int i = 0; i < len; i++) {\n        rv *= FNV_64_PRIME;\n        rv ^= k.charAt(i);", "refactored_code": "  private static final long FNV_64_INIT = 0xcbf29ce484222325L;\n      break;\n    case FNV1_64_HASH:\n      // Thanks to pierre@demartines.com for the pointer\n      rv = FNV_64_INIT;\n      for (int i = 0; i < len; i++) {\n        rv *= FNV_64_PRIME;\n        rv ^= k.charAt(i);"}
{"magic_number_smell": "    getLogger().debug(\"No selectors ready, interrupted: %b\",\n      Thread.interrupted());\n\n    if (++emptySelects > 256) {\n      for (SelectionKey sk : selector.keys()) {\n        getLogger().debug(\"%s has %s, interested in %s\", sk, sk.readyOps(),\n          sk.interestOps());", "refactored_code": "  private static final int DOUBLE_CHECK_EMPTY = 256;\n    getLogger().debug(\"No selectors ready, interrupted: %b\",\n      Thread.interrupted());\n\n    if (++emptySelects > DOUBLE_CHECK_EMPTY) {\n      for (SelectionKey sk : selector.keys()) {\n        getLogger().debug(\"%s has %s, interested in %s\", sk, sk.readyOps(),\n          sk.interestOps());"}
{"magic_number_smell": "    String msg = String.format(\"SASL List Mechanisms took %dms on %s\",\n      mechsDiff, node.toString());\n    Level level = mechsDiff\n      >= 250 ? Level.WARN : Level.DEBUG;\n    getLogger().log(level, msg);\n\n    if (supportedMechs == null || supportedMechs.length == 0) {", "refactored_code": "  public static final int AUTH_ROUNDTRIP_THRESHOLD = 250;\n    String msg = String.format(\"SASL List Mechanisms took %dms on %s\",\n      mechsDiff, node.toString());\n    Level level = mechsDiff\n      >= AUTH_ROUNDTRIP_THRESHOLD ? Level.WARN : Level.DEBUG;\n    getLogger().log(level, msg);\n\n    if (supportedMechs == null || supportedMechs.length == 0) {"}
{"magic_number_smell": "  @Override\n  public void initialize() {\n    ByteBuffer bb = ByteBuffer.allocate(data.length\n        + KeyUtil.getKeyBytes(key).length + 32);\n    setArguments(bb, type, key, flags, exp, data.length);\n    assert bb.remaining() >= data.length + 2 : \"Not enough room in buffer,\"\n        + \" need another \" + (2 + data.length - bb.remaining());", "refactored_code": "  private static final int OVERHEAD = 32;\n  @Override\n  public void initialize() {\n    ByteBuffer bb = ByteBuffer.allocate(data.length\n        + KeyUtil.getKeyBytes(key).length + OVERHEAD);\n    setArguments(bb, type, key, flags, exp, data.length);\n    assert bb.remaining() >= data.length + 2 : \"Not enough room in buffer,\"\n        + \" need another \" + (2 + data.length - bb.remaining());"}
{"magic_number_smell": "  @Override\n  public void initialize() {\n    ByteBuffer bb = ByteBuffer.allocate(data.length\n        + KeyUtil.getKeyBytes(key).length + 64);\n    setArguments(bb, \"cas\", key, flags, exp, data.length, casValue);\n    assert bb.remaining() >= data.length + 2 : \"Not enough room in buffer,\"\n        + \" need another \" + (2 + data.length - bb.remaining());", "refactored_code": "  private static final int OVERHEAD = 64;\n  @Override\n  public void initialize() {\n    ByteBuffer bb = ByteBuffer.allocate(data.length\n        + KeyUtil.getKeyBytes(key).length + OVERHEAD);\n    setArguments(bb, \"cas\", key, flags, exp, data.length, casValue);\n    assert bb.remaining() >= data.length + 2 : \"Not enough room in buffer,\"\n        + \" need another \" + (2 + data.length - bb.remaining());"}
{"magic_number_smell": "  @Override\n  public void initialize() {\n    ByteBuffer b = ByteBuffer.allocate(KeyUtil.getKeyBytes(key).length\n        + 32);\n    setArguments(b, \"delete\", key);\n    b.flip();\n    setBuffer(b);", "refactored_code": "  private static final int OVERHEAD = 32;\n  @Override\n  public void initialize() {\n    ByteBuffer b = ByteBuffer.allocate(KeyUtil.getKeyBytes(key).length\n        + OVERHEAD);\n    setArguments(b, \"delete\", key);\n    b.flip();\n    setBuffer(b);"}
{"magic_number_smell": "\n  @Override\n  public void initialize() {\n    int size = KeyUtil.getKeyBytes(key).length + 32;\n    ByteBuffer b = ByteBuffer.allocate(size);\n    setArguments(b, mutator.name(), key, amount);\n    b.flip();", "refactored_code": "  public static final int OVERHEAD = 32;\n\n  @Override\n  public void initialize() {\n    int size = KeyUtil.getKeyBytes(key).length + OVERHEAD;\n    ByteBuffer b = ByteBuffer.allocate(size);\n    setArguments(b, mutator.name(), key, amount);\n    b.flip();"}
{"magic_number_smell": "  public void initialize() {\n    ByteBuffer b = null;\n    b = ByteBuffer.allocate(KeyUtil.getKeyBytes(key).length\n      + String.valueOf(exp).length() + 9);\n    b.put((\"touch \" + key + \" \" + exp + \"\\r\\n\").getBytes());\n    b.flip();\n    setBuffer(b);", "refactored_code": "  private static final int OVERHEAD = 9;\n  public void initialize() {\n    ByteBuffer b = null;\n    b = ByteBuffer.allocate(KeyUtil.getKeyBytes(key).length\n      + String.valueOf(exp).length() + OVERHEAD);\n    b.put((\"touch \" + key + \" \" + exp + \"\\r\\n\").getBytes());\n    b.flip();\n    setBuffer(b);"}
{"magic_number_smell": "  @Override\n  public void initialize() {\n    ByteBuffer b = ByteBuffer.allocate(KeyUtil.getKeyBytes(key).length\n        + 32);\n    setArguments(b, CMD, key, cas);\n    b.flip();\n    setBuffer(b);", "refactored_code": "  private static final int OVERHEAD = 32;\n  @Override\n  public void initialize() {\n    ByteBuffer b = ByteBuffer.allocate(KeyUtil.getKeyBytes(key).length\n        + OVERHEAD);\n    setArguments(b, CMD, key, cas);\n    b.flip();\n    setBuffer(b);"}
{"magic_number_smell": "      optimizedOp = og;\n\n      while (writeQ.peek() instanceof GetOperation\n          && og.size() < 4096) {\n        GetOperation o = (GetOperation) writeQ.remove();\n        if (!o.isCancelled()) {\n          og.addOperation(o);", "refactored_code": "  private static final int MAX_GET_OPTIMIZATION_COUNT = 4096;\n      optimizedOp = og;\n\n      while (writeQ.peek() instanceof GetOperation\n          && og.size() < MAX_GET_OPTIMIZATION_COUNT) {\n        GetOperation o = (GetOperation) writeQ.remove();\n        if (!o.isCancelled()) {\n          og.addOperation(o);"}
{"magic_number_smell": "    byte rv;\n    switch (t) {\n    case append:\n      rv = 0x0e;\n      break;\n    case prepend:\n      rv = PREPEND;", "refactored_code": "  private static final int APPEND = 0x0e;\n    byte rv;\n    switch (t) {\n    case append:\n      rv = APPEND;\n      break;\n    case prepend:\n      rv = PREPEND;"}
{"magic_number_smell": "  }\n\n  public DeleteOperationImpl(String k, long c, DeleteOperation.Callback cb) {\n    super(0x04, generateOpaque(), k, cb);\n    cas = c;\n  }\n", "refactored_code": "  private static final byte CMD = 0x04;\n  }\n\n  public DeleteOperationImpl(String k, long c, DeleteOperation.Callback cb) {\n    super(CMD, generateOpaque(), k, cb);\n    cas = c;\n  }\n"}
{"magic_number_smell": "  }\n\n  public FlushOperationImpl(int d, OperationCallback cb) {\n    super(0x08, generateOpaque(), cb);\n    delay = d;\n  }\n", "refactored_code": "  private static final byte CMD = 0x08;\n  }\n\n  public FlushOperationImpl(int d, OperationCallback cb) {\n    super(CMD, generateOpaque(), cb);\n    delay = d;\n  }\n"}
{"magic_number_smell": "  private static final byte 0x10 = 0x10;\n\n  public KeyStatsOperationImpl(String key, StatsOperation.Callback c) {\n    super(0x10, generateOpaque(), key, c);\n  }\n\n  @Override", "refactored_code": "  private static final byte CMD = 0x10;\n  private static final byte CMD = 0x10;\n\n  public KeyStatsOperationImpl(String key, StatsOperation.Callback c) {\n    super(CMD, generateOpaque(), key, c);\n  }\n\n  @Override"}
{"magic_number_smell": "\n      // Custom header\n      bb.put(REQ_MAGIC);\n      bb.put(0x09);\n      bb.putShort((short) keyBytes.length);\n      bb.put((byte) 0); // extralen\n      bb.put((byte) 0); // data type", "refactored_code": "  private static final byte CMD_GETQ = 0x09;\n\n      // Custom header\n      bb.put(REQ_MAGIC);\n      bb.put(CMD_GETQ);\n      bb.putShort((short) keyBytes.length);\n      bb.put((byte) 0); // extralen\n      bb.put((byte) 0); // data type"}
{"magic_number_smell": "\n  public MutatorOperationImpl(Mutator m, String k, long b, long d, int e,\n      OperationCallback cb) {\n    super(m == Mutator.incr ? 0x05 : CMD_DECR, generateOpaque(), k, cb);\n    assert d >= 0 : \"Default value is below zero\";\n    mutator = m;\n    by = b;", "refactored_code": "  private static final byte CMD_INCR = 0x05;\n\n  public MutatorOperationImpl(Mutator m, String k, long b, long d, int e,\n      OperationCallback cb) {\n    super(m == Mutator.incr ? CMD_INCR : CMD_DECR, generateOpaque(), k, cb);\n    assert d >= 0 : \"Default value is below zero\";\n    mutator = m;\n    by = b;"}
{"magic_number_smell": "    bb.put((byte) 0); // data type\n    bb.putShort((short) 0); // reserved\n    bb.putInt(0);\n    bb.putInt(generateOpaque());\n    bb.putLong(0); // cas\n\n    bb.flip();", "refactored_code": "  private final int terminalOpaque = generateOpaque();\n    bb.put((byte) 0); // data type\n    bb.putShort((short) 0); // reserved\n    bb.putInt(0);\n    bb.putInt(terminalOpaque);\n    bb.putLong(0); // cas\n\n    bb.flip();"}
{"magic_number_smell": "\n  public SASLAuthOperationImpl(String[] m, String s, Map<String, ?> p,\n      CallbackHandler h, OperationCallback c) {\n    super(0x21, m, EMPTY_BYTES, s, p, h, c);\n  }\n\n  @Override", "refactored_code": "  private static final byte CMD = 0x21;\n\n  public SASLAuthOperationImpl(String[] m, String s, Map<String, ?> p,\n      CallbackHandler h, OperationCallback c) {\n    super(CMD, m, EMPTY_BYTES, s, p, h, c);\n  }\n\n  @Override"}
{"magic_number_smell": "\n  @Override\n  protected void finishedPayload(byte[] pl) throws IOException {\n    if (errorCode == 0x21) {\n      getCallback().receivedStatus(new OperationStatus(true, new String(pl),\n        StatusCode.SUCCESS));\n      transitionState(OperationState.COMPLETE);", "refactored_code": "  private static final byte SASL_CONTINUE = 0x21;\n\n  @Override\n  protected void finishedPayload(byte[] pl) throws IOException {\n    if (errorCode == SASL_CONTINUE) {\n      getCallback().receivedStatus(new OperationStatus(true, new String(pl),\n        StatusCode.SUCCESS));\n      transitionState(OperationState.COMPLETE);"}
{"magic_number_smell": "  private static final byte 0x20 = 0x20;\n\n  public SASLMechsOperationImpl(OperationCallback cb) {\n    super(0x20, generateOpaque(), cb);\n  }\n\n  @Override", "refactored_code": "  private static final byte CMD = 0x20;\n  private static final byte CMD = 0x20;\n\n  public SASLMechsOperationImpl(OperationCallback cb) {\n    super(CMD, generateOpaque(), cb);\n  }\n\n  @Override"}
{"magic_number_smell": "\n  public SASLStepOperationImpl(String[] m, byte[] ch, String s,\n      Map<String, ?> p, CallbackHandler h, OperationCallback c) {\n    super(0x22, m, ch, s, p, h, c);\n  }\n\n  @Override", "refactored_code": "  private static final byte CMD = 0x22;\n\n  public SASLStepOperationImpl(String[] m, byte[] ch, String s,\n      Map<String, ?> p, CallbackHandler h, OperationCallback c) {\n    super(CMD, m, ch, s, p, h, c);\n  }\n\n  @Override"}
{"magic_number_smell": "  private final String key;\n\n  public StatsOperationImpl(String arg, StatsOperation.Callback c) {\n    super(0x10, generateOpaque(), c);\n    key = (arg == null) ? \"\" : arg;\n  }\n", "refactored_code": "  private static final byte CMD = 0x10;\n  private final String key;\n\n  public StatsOperationImpl(String arg, StatsOperation.Callback c) {\n    super(CMD, generateOpaque(), c);\n    key = (arg == null) ? \"\" : arg;\n  }\n"}
{"magic_number_smell": "    byte rv;\n    switch (t) {\n    case set:\n      rv = 0x01;\n      break;\n    case add:\n      rv = ADD;", "refactored_code": "  private static final byte SET = 0x01;\n    byte rv;\n    switch (t) {\n    case set:\n      rv = SET;\n      break;\n    case add:\n      rv = ADD;"}
{"magic_number_smell": "  private static final byte 0x0b = 0x0b;\n\n  public VersionOperationImpl(OperationCallback cb) {\n    super(0x0b, generateOpaque(), cb);\n  }\n\n  @Override", "refactored_code": "  private static final byte CMD = 0x0b;\n  private static final byte CMD = 0x0b;\n\n  public VersionOperationImpl(OperationCallback cb) {\n    super(CMD, generateOpaque(), cb);\n  }\n\n  @Override"}
{"magic_number_smell": "  }\n\n  protected BaseMessage(byte[] b) {\n    magic = TapMagic.getMagicByByte(b[0]);\n    opcode = TapOpcode.getOpcodeByByte(b[OPCODE_OFFSET]);\n    keylength = decodeShort(b, KEYLENGTH_OFFSET);\n    extralength = b[EXTRALENGTH_OFFSET];", "refactored_code": "  private static final int MAGIC_OFFSET = 0;\n  }\n\n  protected BaseMessage(byte[] b) {\n    magic = TapMagic.getMagicByByte(b[MAGIC_OFFSET]);\n    opcode = TapOpcode.getOpcodeByByte(b[OPCODE_OFFSET]);\n    keylength = decodeShort(b, KEYLENGTH_OFFSET);\n    extralength = b[EXTRALENGTH_OFFSET];"}
{"magic_number_smell": "    // this should be split into mutiple classes.\n    super(b);\n    if (!opcode.equals(TapOpcode.NOOP)) {\n      engineprivate = decodeShort(b, 24);\n      flags = TapResponseFlag.getFlags(decodeShort(b, FLAGS_OFFSET));\n      ttl = b[TTL_OFFSET];\n      reserved1 = b[RESERVED1_OFFSET];", "refactored_code": "  private static final int ENGINE_PRIVATE_OFFSET = 24;\n    // this should be split into mutiple classes.\n    super(b);\n    if (!opcode.equals(TapOpcode.NOOP)) {\n      engineprivate = decodeShort(b, ENGINE_PRIVATE_OFFSET);\n      flags = TapResponseFlag.getFlags(decodeShort(b, FLAGS_OFFSET));\n      ttl = b[TTL_OFFSET];\n      reserved1 = b[RESERVED1_OFFSET];"}
{"magic_number_smell": "\n  private static final String DEFAULT_CHARSET = \"UTF-8\";\n\n  protected int compressionThreshold = 16384;\n  protected String charset = DEFAULT_CHARSET;\n\n  private final int maxSize;", "refactored_code": "  public static final int DEFAULT_COMPRESSION_THRESHOLD = 16384;\n\n  private static final String DEFAULT_CHARSET = \"UTF-8\";\n\n  protected int compressionThreshold = DEFAULT_COMPRESSION_THRESHOLD;\n  protected String charset = DEFAULT_CHARSET;\n\n  private final int maxSize;"}
{"magic_number_smell": "  }\n\n  public CachedData encode(java.lang.Integer l) {\n    return new CachedData(SerializingTranscoder.SPECIAL_INT, tu.encodeInt(l), getMaxSize());\n  }\n\n  public Integer decode(CachedData d) {", "refactored_code": "  private static final int FLAGS = SerializingTranscoder.SPECIAL_INT;\n  }\n\n  public CachedData encode(java.lang.Integer l) {\n    return new CachedData(FLAGS, tu.encodeInt(l), getMaxSize());\n  }\n\n  public Integer decode(CachedData d) {"}
{"magic_number_smell": "  }\n\n  public CachedData encode(java.lang.Long l) {\n    return new CachedData(SerializingTranscoder.SPECIAL_LONG, tu.encodeLong(l), getMaxSize());\n  }\n\n  public Long decode(CachedData d) {", "refactored_code": "  private static final int FLAGS = SerializingTranscoder.SPECIAL_LONG;\n  }\n\n  public CachedData encode(java.lang.Long l) {\n    return new CachedData(FLAGS, tu.encodeLong(l), getMaxSize());\n  }\n\n  public Long decode(CachedData d) {"}
{"magic_number_smell": "    if ((d.getFlags() & COMPRESSED) != 0) {\n      data = decompress(d.getData());\n    }\n    int flags = d.getFlags() & 0xff00;\n    if ((d.getFlags() & SERIALIZED) != 0 && data != null) {\n      rv = deserialize(data);\n    } else if (flags != 0 && data != null) {", "refactored_code": "  private static final int SPECIAL_MASK = 0xff00;\n    if ((d.getFlags() & COMPRESSED) != 0) {\n      data = decompress(d.getData());\n    }\n    int flags = d.getFlags() & SPECIAL_MASK;\n    if ((d.getFlags() & SERIALIZED) != 0 && data != null) {\n      rv = deserialize(data);\n    } else if (flags != 0 && data != null) {"}
{"magic_number_smell": "      case SPECIAL_DATE:\n        rv = new Date(decodeLong(data));\n        break;\n      case 1:\n        rv = decodeByte(data);\n        break;\n      case SPECIAL_FLOAT:", "refactored_code": "  public static final int SPECIAL_BYTE = 1;\n      case SPECIAL_DATE:\n        rv = new Date(decodeLong(data));\n        break;\n      case SPECIAL_BYTE:\n        rv = decodeByte(data);\n        break;\n      case SPECIAL_FLOAT:"}
{"magic_number_smell": "   * @return NUM_REPS repetitions.\n   */\n  public int getNodeRepetitions() {\n    return 160;\n  }\n\n  /**", "refactored_code": "  private final int numReps = 160;\n   * @return NUM_REPS repetitions.\n   */\n  public int getNodeRepetitions() {\n    return numReps;\n  }\n\n  /**"}
{"magic_number_smell": "   */\n  private static final IllegalArgumentException KEY_TOO_LONG_EXCEPTION =\n    new IllegalArgumentException(\"Key is too long (maxlen = \"\n      + MemcachedClientIF.MAX_KEY_LENGTH + ')');\n\n  /**\n   * Exception thrown if the input key is empty.", "refactored_code": "  private static final int MAX_KEY_LENGTH = MemcachedClientIF.MAX_KEY_LENGTH;\n   */\n  private static final IllegalArgumentException KEY_TOO_LONG_EXCEPTION =\n    new IllegalArgumentException(\"Key is too long (maxlen = \"\n      + MAX_KEY_LENGTH + ')');\n\n  /**\n   * Exception thrown if the input key is empty."}
{"magic_number_smell": "    clientMock.expects(once()).method(\"getTranscoder\")\n        .will(returnValue(transcoder));\n    client = (MemcachedClientIF) clientMock.proxy();\n    cacheMap = new CacheMap(client, 8175, \"blah\");\n  }\n\n  private void expectGetAndReturn(String k, Object value) {", "refactored_code": "  private static final int EXP = 8175;\n    clientMock.expects(once()).method(\"getTranscoder\")\n        .will(returnValue(transcoder));\n    client = (MemcachedClientIF) clientMock.proxy();\n    cacheMap = new CacheMap(client, EXP, \"blah\");\n  }\n\n  private void expectGetAndReturn(String k, Object value) {"}
{"magic_number_smell": "    client = new MemcachedClient(new ConnectionFactoryBuilder()\n        .setProtocol(Protocol.BINARY).setOpTimeout(15000).build(),\n        AddrUtil.getAddresses(\"127.0.0.1:11211\"));\n    keys = new ArrayList<String>(25000);\n    new Random().nextBytes(value);\n  }\n", "refactored_code": "  private static final int N = 25000;\n    client = new MemcachedClient(new ConnectionFactoryBuilder()\n        .setProtocol(Protocol.BINARY).setOpTimeout(15000).build(),\n        AddrUtil.getAddresses(\"127.0.0.1:11211\"));\n    keys = new ArrayList<String>(N);\n    new Random().nextBytes(value);\n  }\n"}
{"magic_number_smell": "      long begin = System.currentTimeMillis();\n      for (int i = stat.start; i < stat.start + stat.runs; i++) {\n        mc.set(\"\" + i + keyBase, 3600, object);\n        if (TOTAL.incrementAndGet() >= 10000) {\n          flush();\n        }\n      }", "refactored_code": "    private static final int MAX_QUEUE = 10000;\n      long begin = System.currentTimeMillis();\n      for (int i = stat.start; i < stat.start + stat.runs; i++) {\n        mc.set(\"\" + i + keyBase, 3600, object);\n        if (TOTAL.incrementAndGet() >= MAX_QUEUE) {\n          flush();\n        }\n      }"}
{"magic_number_smell": "    }\n\n    if (!updaterStarted) {\n      TimerHandler updateTimer = new TimerHandler(UpdateManager.getInstance(), 24 * MINUTES_IN_HOUR * Constants.ONE_MINUTE);\n      updateTimer.setName(\"VersionChecker\");\n      updateTimer.start();\n    }", "refactored_code": "  private static final int HOURS_IN_DAY = 24;\n    }\n\n    if (!updaterStarted) {\n      TimerHandler updateTimer = new TimerHandler(UpdateManager.getInstance(), HOURS_IN_DAY * MINUTES_IN_HOUR * Constants.ONE_MINUTE);\n      updateTimer.setName(\"VersionChecker\");\n      updateTimer.start();\n    }"}
{"magic_number_smell": "    buttons.add(\"Ignore\");\n\n    final UpdaterEntry ue = UpdateManager.getInstance().getUpdateInfo();\n    StringBuffer fullMsg = new StringBuffer(4 * 1024);\n    String icon = JConfig.getResource(\"/jbidwatch64.jpg\").toString();\n    fullMsg.append(\"<html><body><table><tr><td><img src=\\\"\").append(icon).append(\"\\\"></td>\");\n    fullMsg.append(\"<td valign=\\\"top\\\"><span class=\\\"banner\\\"><b>A new version of \" + Constants.PROGRAM_NAME + \" is available!</b></span><br>\");", "refactored_code": "  private static final int ONEK = 1024;\n    buttons.add(\"Ignore\");\n\n    final UpdaterEntry ue = UpdateManager.getInstance().getUpdateInfo();\n    StringBuffer fullMsg = new StringBuffer(4 * ONEK);\n    String icon = JConfig.getResource(\"/jbidwatch64.jpg\").toString();\n    fullMsg.append(\"<html><body><table><tr><td><img src=\\\"\").append(icon).append(\"\\\"></td>\");\n    fullMsg.append(\"<td valign=\\\"top\\\"><span class=\\\"banner\\\"><b>A new version of \" + Constants.PROGRAM_NAME + \" is available!</b></span><br>\");"}
{"magic_number_smell": "   */\n  //  Construct a standard HTML 'bgcolor=\"#ffffff\"' style color string.\n  public static String makeRGB(Color groupColor) {\n    String red = Integer.toString(groupColor.getRed(), 16);\n    if (red.length() == 1) red = '0' + red;\n    String green = Integer.toString(groupColor.getGreen(), 16);\n    if (green.length() == 1) green = '0' + green;", "refactored_code": "  private static final int HEX_BASE = 16;\n   */\n  //  Construct a standard HTML 'bgcolor=\"#ffffff\"' style color string.\n  public static String makeRGB(Color groupColor) {\n    String red = Integer.toString(groupColor.getRed(), HEX_BASE);\n    if (red.length() == 1) red = '0' + red;\n    String green = Integer.toString(groupColor.getGreen(), HEX_BASE);\n    if (green.length() == 1) green = '0' + green;"}
{"magic_number_smell": "\n    mEntry.snipeCompleted();\n    UpdateBlocker.endBlocking();\n    return 3;\n  }\n\n  private int preSnipe() {", "refactored_code": "  public static final int DONE = 3;\n\n    mEntry.snipeCompleted();\n    UpdateBlocker.endBlocking();\n    return DONE;\n  }\n\n  private int preSnipe() {"}
{"magic_number_smell": "      // Determine the type of URL\n      // Remove paging information if exists so we can add our own when needed\n      if (url.indexOf(URLSTYLE_HTTP_STR) != -1) {\n        urlStyle = 0;\n        removePattern(\"&frpp=[0-9]*\");\n        removePattern(\"&skip=[0-9]*\");\n      } else {", "refactored_code": "\tprivate static final int URLSTYLE_HTTP = 0;\n      // Determine the type of URL\n      // Remove paging information if exists so we can add our own when needed\n      if (url.indexOf(URLSTYLE_HTTP_STR) != -1) {\n        urlStyle = URLSTYLE_HTTP;\n        removePattern(\"&frpp=[0-9]*\");\n        removePattern(\"&skip=[0-9]*\");\n      } else {"}
{"magic_number_smell": "          ItemResults rval = addAllItemsOnPage(htmlDocument, label, !((Searcher) searcher).shouldSkipDeleted());\n          int pageResults = rval.getLast().size();\n          if (pageResults != 0) {\n            if (pageResults >= 100) {\n              skipCount += 100;\n              fullSearch = baseSearch + \"&skip=\" + skipCount;\n              done = false;", "refactored_code": "  private static final int ITEMS_PER_PAGE = 100;\n          ItemResults rval = addAllItemsOnPage(htmlDocument, label, !((Searcher) searcher).shouldSkipDeleted());\n          int pageResults = rval.getLast().size();\n          if (pageResults != 0) {\n            if (pageResults >= ITEMS_PER_PAGE) {\n              skipCount += ITEMS_PER_PAGE;\n              fullSearch = baseSearch + \"&skip=\" + skipCount;\n              done = false;"}
{"magic_number_smell": "        _etqm.add(\"TIMECHECK\", \"auction_manager\", (endDate.getTime() - snipeDelta) - FIVE_MINUTES);\n        _etqm.add(auctionId, mSnipeQueue.getQueueName(), (endDate.getTime() - snipeDelta) - TWO_MINUTES);\n        _etqm.add(auctionId, mSnipeQueue.getQueueName(), (endDate.getTime() - snipeDelta));\n        _etqm.add(auctionId, \"drop\",       endDate.getTime() + 30 * Constants.ONE_SECOND);\n      } else {\n        JConfig.log().logMessage(\"Failing to set snipe for \" + auctionId + \", endDate is null or in the far future (\" + endDate + \")\");\n      }", "refactored_code": "  private static final int THIRTY_SECONDS = 30 * Constants.ONE_SECOND;\n        _etqm.add(\"TIMECHECK\", \"auction_manager\", (endDate.getTime() - snipeDelta) - FIVE_MINUTES);\n        _etqm.add(auctionId, mSnipeQueue.getQueueName(), (endDate.getTime() - snipeDelta) - TWO_MINUTES);\n        _etqm.add(auctionId, mSnipeQueue.getQueueName(), (endDate.getTime() - snipeDelta));\n        _etqm.add(auctionId, \"drop\",       endDate.getTime() + THIRTY_SECONDS);\n      } else {\n        JConfig.log().logMessage(\"Failing to set snipe for \" + auctionId + \", endDate is null or in the far future (\" + endDate + \")\");\n      }"}
{"magic_number_smell": "    this.tabManager = tabManager;\n    this.serverManager = serverManager;\n    this.pasteListener = pasteListener;\n    mFilterBox = new SearchField(\"Search\", 20);\n    if(Platform.isMac()) {\n      mFilterBox.putClientProperty(\"Quaqua.TextField.style\", \"search\");\n    }", "refactored_code": "  private static final int FILTER_BOX_SIZE = 20;\n    this.tabManager = tabManager;\n    this.serverManager = serverManager;\n    this.pasteListener = pasteListener;\n    mFilterBox = new SearchField(\"Search\", FILTER_BOX_SIZE);\n    if(Platform.isMac()) {\n      mFilterBox.putClientProperty(\"Quaqua.TextField.style\", \"search\");\n    }"}
{"magic_number_smell": "    if(dragaction != 0) {\n      dtde.acceptDrag(dragaction);\n    } else {\n      dtde.acceptDrag(DnDConstants.ACTION_COPY_OR_MOVE | DnDConstants.ACTION_LINK);\n    }\n  }\n", "refactored_code": "  private static final int ALL_ACTIONS = DnDConstants.ACTION_COPY_OR_MOVE | DnDConstants.ACTION_LINK;\n    if(dragaction != 0) {\n      dtde.acceptDrag(dragaction);\n    } else {\n      dtde.acceptDrag(ALL_ACTIONS);\n    }\n  }\n"}
{"magic_number_smell": "\n  private void doSingle(Searcher s, int cmd) {\n    switch(cmd) {\n      case 0, ENABLE=1, DISABLE=2, EDIT=3, NEW=4:\n        s.execute();\n        break;\n      case ENABLE:", "refactored_code": "  private static final int EXECUTE=0, ENABLE=1, DISABLE=2, EDIT=3, NEW=4;\n\n  private void doSingle(Searcher s, int cmd) {\n    switch(cmd) {\n      case EXECUTE:\n        s.execute();\n        break;\n      case ENABLE:"}
{"magic_number_smell": "   */\n  @MenuCommand(params = 2)\n  public void DoCopyURL(Component src, AuctionEntry ae) {\n    DoCopySomething(src, ae, 0, \"No auctions selected to copy URLs of!\", \"\\n\");\n  }\n\n  /**", "refactored_code": "  private static final int DO_COPY_URL  = 0;\n   */\n  @MenuCommand(params = 2)\n  public void DoCopyURL(Component src, AuctionEntry ae) {\n    DoCopySomething(src, ae, DO_COPY_URL, \"No auctions selected to copy URLs of!\", \"\\n\");\n  }\n\n  /**"}
{"magic_number_smell": "  private TableColumnController() {\n    m_column_map = new HashMap<>(columnCount * 3);\n\n    m_column_map.put(0, \"Number\");\n    m_column_map.put(CUR_BID, \"Current\");\n    m_column_map.put(SNIPE_OR_MAX, \"Max\");\n    m_column_map.put(TIME_LEFT, \"Time left\");", "refactored_code": "  public static final int ID=0;\n  private TableColumnController() {\n    m_column_map = new HashMap<>(columnCount * 3);\n\n    m_column_map.put(ID, \"Number\");\n    m_column_map.put(CUR_BID, \"Current\");\n    m_column_map.put(SNIPE_OR_MAX, \"Max\");\n    m_column_map.put(TIME_LEFT, \"Time left\");"}
{"magic_number_smell": "   private String getMemoryUse()\n   {\n     long bytesUsed = getBytesUsed();\n     double megabytesUsed = bytesUsed / 1024.0 * 1024.0;\n     return myValueFormatter.format(megabytesUsed) + \" MB\";\n   }\n", "refactored_code": "   private static final double BYTES_PER_MB = 1024.0 * 1024.0;\n   private String getMemoryUse()\n   {\n     long bytesUsed = getBytesUsed();\n     double megabytesUsed = bytesUsed / BYTES_PER_MB;\n     return myValueFormatter.format(megabytesUsed) + \" MB\";\n   }\n"}
{"magic_number_smell": "/** One second in microseconds.\n */\n  public static final int 1000 = 1000;\n  public static final int THREE_SECONDS = 3 * 1000;\n  /** Thirty seconds in microseconds.\n */\n  public static final int THIRTY_SECONDS= (30 * 1000);", "refactored_code": "  public static final int ONE_SECOND = 1000;\n/** One second in microseconds.\n */\n  public static final int ONE_SECOND = 1000;\n  public static final int THREE_SECONDS = 3 * ONE_SECOND;\n  /** Thirty seconds in microseconds.\n */\n  public static final int THIRTY_SECONDS= (30 * ONE_SECOND);"}
{"magic_number_smell": "   * invalid currency.\n   */\n  public static Currency NoValue() {\n    if(_noValue == null) _noValue = new Currency(0, US_DOLLAR=1, UK_POUND=2, JP_YEN=3, CAN_DOLLAR=6, 0.0);\n\n    return _noValue;\n  }", "refactored_code": "  public static final int NONE=0, US_DOLLAR=1, UK_POUND=2, JP_YEN=3, CAN_DOLLAR=6;\n   * invalid currency.\n   */\n  public static Currency NoValue() {\n    if(_noValue == null) _noValue = new Currency(NONE, 0.0);\n\n    return _noValue;\n  }"}
{"magic_number_smell": "\npublic class StringTools {\n  private static final int 1990 = 1990;\n  private static GregorianCalendar sMidpointDate = new GregorianCalendar(1990, Calendar.JANUARY, 1);\n  private static final int HIGHBIT_ASCII = 0x80;\n\n  public static String decode(String original, String charset) {", "refactored_code": "  private static final int YEAR_BASE = 1990;\n\npublic class StringTools {\n  private static final int YEAR_BASE = 1990;\n  private static GregorianCalendar sMidpointDate = new GregorianCalendar(YEAR_BASE, Calendar.JANUARY, 1);\n  private static final int HIGHBIT_ASCII = 0x80;\n\n  public static String decode(String original, String charset) {"}
{"magic_number_smell": "            try {\n                double version = Double.valueOf(majorMRJVersion);\n                if (version == 2) {\n                    jvm = 0;\n                } else if (version >= 2.1 && version < 3) {\n                    // Assume that all 2.x versions of MRJ work the same.  MRJ 2.1 actually\n                    // works via Runtime.exec() and 2.2 supports that but has an openURL() method", "refactored_code": "    private static final int MRJ_2_0 = 0;\n            try {\n                double version = Double.valueOf(majorMRJVersion);\n                if (version == 2) {\n                    jvm = MRJ_2_0;\n                } else if (version >= 2.1 && version < 3) {\n                    // Assume that all 2.x versions of MRJ work the same.  MRJ 2.1 actually\n                    // works via Runtime.exec() and 2.2 supports that but has an openURL() method"}
{"magic_number_smell": "\npublic class JHTMLOutput {\n  private static final int 4096 = 4096;\n  private StringBuffer _page = new StringBuffer(4096);\n\n  public JHTMLOutput(String title, String body) {\n    buildPage(title, new StringBuffer(body));", "refactored_code": "  private static final int FOURK = 4096;\n\npublic class JHTMLOutput {\n  private static final int FOURK = 4096;\n  private StringBuffer _page = new StringBuffer(FOURK);\n\n  public JHTMLOutput(String title, String body) {\n    buildPage(title, new StringBuffer(body));"}
{"magic_number_smell": "  private static final int 990 = 990;\n  private WakeupProcess _toWake = null;\n  private volatile boolean _remainAsleep = false;\n  private long _sleep_ms = 990;\n\n  public interface WakeupProcess {\n    boolean check() throws InterruptedException;", "refactored_code": "  private static final int ALMOST_A_SECOND = 990;\n  private static final int ALMOST_A_SECOND = 990;\n  private WakeupProcess _toWake = null;\n  private volatile boolean _remainAsleep = false;\n  private long _sleep_ms = ALMOST_A_SECOND;\n\n  public interface WakeupProcess {\n    boolean check() throws InterruptedException;"}
{"magic_number_smell": "  private static ActivityMonitor sInstance;\n\n  public ActivityMonitor() {\n    mBuffer = new ScrollingBuffer(4096);\n  }\n\n  public StringBuffer getLog() {", "refactored_code": "  private static final int MAX_BUFFER=4096;\n  private static ActivityMonitor sInstance;\n\n  public ActivityMonitor() {\n    mBuffer = new ScrollingBuffer(MAX_BUFFER);\n  }\n\n  public StringBuffer getLog() {"}
{"magic_number_smell": "  public void testGetFlags() throws Exception {\n    //  1 (Not fixed price), 2 (is High Bidder), 4 (Will win), 8 (Has BIN price),\n    // 16 (Reserve & Reserve is met), 32 (Reserve & Reserve not met), 64 (Has PayPal)\n    assertEquals(HAS_PAYPAL | HAS_BIN | 1, mAE.getFlags());\n  }\n\n  public void testGetCurBid() throws Exception {", "refactored_code": "  private static final int NOT_FIXED_PRICE=1;\n  public void testGetFlags() throws Exception {\n    //  1 (Not fixed price), 2 (is High Bidder), 4 (Will win), 8 (Has BIN price),\n    // 16 (Reserve & Reserve is met), 32 (Reserve & Reserve not met), 64 (Has PayPal)\n    assertEquals(HAS_PAYPAL | HAS_BIN | NOT_FIXED_PRICE, mAE.getFlags());\n  }\n\n  public void testGetCurBid() throws Exception {"}
{"magic_number_smell": "\n    private ArArchiveEntry createArArchiveEntry(String pName, long contentLength) {\n        if (outputTimestampMs != null) {\n            return new ArArchiveEntry(pName, contentLength, 0, 0, 33188, outputTimestampMs / TimeUnit.SECONDS.toMillis(1));\n        }\n\n        return new ArArchiveEntry(pName, contentLength);", "refactored_code": "    private static final int DEFAULT_MODE = 33188;\n\n    private ArArchiveEntry createArArchiveEntry(String pName, long contentLength) {\n        if (outputTimestampMs != null) {\n            return new ArArchiveEntry(pName, contentLength, 0, 0, DEFAULT_MODE, outputTimestampMs / TimeUnit.SECONDS.toMillis(1));\n        }\n\n        return new ArArchiveEntry(pName, contentLength);"}
{"magic_number_smell": "        DataProducer linkProducer = new DataProducerLink(\"pomLink.xml\", \"/usr/share/myapp/pom.xml\", true, null, null, null);\n        File archive = prepareArchive();\n\n        DataBuilder builder = new DataBuilder(new NullConsole(), 1609455600000L);\n        builder.buildData(Arrays.asList(fileProducer, linkProducer, dirProducer), archive, new StringBuilder(), new TarOptions().compression(Compression.NONE));\n\n        assertExpectedModTimeInArchive(archive);", "refactored_code": "    private static final long EXPECTED_MODIFIED_TIME = 1609455600000L;\n        DataProducer linkProducer = new DataProducerLink(\"pomLink.xml\", \"/usr/share/myapp/pom.xml\", true, null, null, null);\n        File archive = prepareArchive();\n\n        DataBuilder builder = new DataBuilder(new NullConsole(), EXPECTED_MODIFIED_TIME);\n        builder.buildData(Arrays.asList(fileProducer, linkProducer, dirProducer), archive, new StringBuilder(), new TarOptions().compression(Compression.NONE));\n\n        assertExpectedModTimeInArchive(archive);"}
{"magic_number_smell": "        DebMaker maker = new DebMaker(new NullConsole(), Arrays.asList(data), confFileProducers);\n        maker.setControl(new File(getClass().getResource(\"deb/control\").toURI()));\n        maker.setDeb(deb);\n        maker.setOutputTimestampMs(1609455600000L);\n\n        BinaryPackageControlFile packageControlFile = maker.createDeb(Compression.GZIP);\n", "refactored_code": "    private static final long EXPECTED_MODIFIED_TIME = 1609455600000L;\n        DebMaker maker = new DebMaker(new NullConsole(), Arrays.asList(data), confFileProducers);\n        maker.setControl(new File(getClass().getResource(\"deb/control\").toURI()));\n        maker.setDeb(deb);\n        maker.setOutputTimestampMs(EXPECTED_MODIFIED_TIME);\n\n        BinaryPackageControlFile packageControlFile = maker.createDeb(Compression.GZIP);\n"}
{"magic_number_smell": "                        Map<File, StatusInfo> value = readValue(dis, path);\n                        for (File f : value.keySet()) {\n                            StatusInfo info = value.get(f);\n                            if ((info.getStatus() & DiskMapTurboProvider.StatusInfo.STATUS_MANAGED & ~StatusInfo.STATUS_VERSIONED_UPTODATE) != 0) {\n                                cachedValues.put(f, info);\n                            }\n                        }", "refactored_code": "    private static final int STATUS_VALUABLE = StatusInfo.STATUS_MANAGED & ~StatusInfo.STATUS_VERSIONED_UPTODATE;\n                        Map<File, StatusInfo> value = readValue(dis, path);\n                        for (File f : value.keySet()) {\n                            StatusInfo info = value.get(f);\n                            if ((info.getStatus() & DiskMapTurboProvider.STATUS_VALUABLE) != 0) {\n                                cachedValues.put(f, info);\n                            }\n                        }"}
{"magic_number_smell": "        boolean onlyFolders = onlyFolders(files);\n        boolean onlyProjects = onlyProjects(nodes);\n\n        List<Action> actions = new ArrayList<Action>(25);\n        if (destination == VCSAnnotator.ActionDestination.MainMenu) {\n            actions.add(new InitAction(loc.getString(\"CTL_MenuItem_Create\"), ctx)); // NOI18N\n            actions.add(null);", "refactored_code": "    private static final int INITIAL_ACTION_ARRAY_LENGTH = 25;\n        boolean onlyFolders = onlyFolders(files);\n        boolean onlyProjects = onlyProjects(nodes);\n\n        List<Action> actions = new ArrayList<Action>(INITIAL_ACTION_ARRAY_LENGTH);\n        if (destination == VCSAnnotator.ActionDestination.MainMenu) {\n            actions.add(new InitAction(loc.getString(\"CTL_MenuItem_Create\"), ctx)); // NOI18N\n            actions.add(null);"}
{"magic_number_smell": "                OutputWriter out = log.getOut();\n\n                int lines = list.size();\n                if (lines > 500) {\n                    out.println(list.get(1));\n                    out.println(list.get(2));\n                    out.println(list.get(3));", "refactored_code": "    public static final int MAX_LINES_TO_PRINT = 500;\n                OutputWriter out = log.getOut();\n\n                int lines = list.size();\n                if (lines > MAX_LINES_TO_PRINT) {\n                    out.println(list.get(1));\n                    out.println(list.get(2));\n                    out.println(list.get(3));"}
{"magic_number_smell": "    }\n\n    protected boolean enable(VCSContext ctx) {\n        return getActionStatus(ctx) != -1;\n    }\n\n    protected int getFileEnabledStatus() {", "refactored_code": "    public static final int UNDEFINED = -1;\n    }\n\n    protected boolean enable(VCSContext ctx) {\n        return getActionStatus(ctx) != UNDEFINED;\n    }\n\n    protected int getFileEnabledStatus() {"}
{"magic_number_smell": "        // the first source\n\n        switch (type) {\n            case 0:\n\n                // from-BASE\n", "refactored_code": "    public static final int DIFFTYPE_LOCAL = 0;\n        // the first source\n\n        switch (type) {\n            case DIFFTYPE_LOCAL:\n\n                // from-BASE\n"}
{"magic_number_smell": "            repaint();\n        }\n        if (e.getID() == MouseEvent.MOUSE_CLICKED) {\n            listener.actionPerformed(new ActionEvent(this, 1, \"\"));\n        }\n    }\n", "refactored_code": "    public static final int DIVIDER_CLICKED = 1;\n            repaint();\n        }\n        if (e.getID() == MouseEvent.MOUSE_CLICKED) {\n            listener.actionPerformed(new ActionEvent(this, DIVIDER_CLICKED, \"\"));\n        }\n    }\n"}
{"magic_number_smell": "        }\n\n        public Color darker(Color c) {\n            return new Color(Math.max((int) (c.getRed() * 0.95), 0),\n                    Math.max((int) (c.getGreen() * 0.95), 0),\n                    Math.max((int) (c.getBlue() * 0.95), 0));\n        }", "refactored_code": "        private static final double DARKEN_FACTOR = 0.95;\n        }\n\n        public Color darker(Color c) {\n            return new Color(Math.max((int) (c.getRed() * DARKEN_FACTOR), 0),\n                    Math.max((int) (c.getGreen() * DARKEN_FACTOR), 0),\n                    Math.max((int) (c.getBlue() * DARKEN_FACTOR), 0));\n        }"}
{"magic_number_smell": "\n    final static class ResolvableHelper implements Serializable {\n\n        private static final long 1L = 1L;\n\n        public Object readResolve() {\n            return GitVersioningTopComponent.getDefault();", "refactored_code": "    private static final long serialVersionUID = 1L;\n\n    final static class ResolvableHelper implements Serializable {\n\n        private static final long serialVersionUID = 1L;\n\n        public Object readResolve() {\n            return GitVersioningTopComponent.getDefault();"}
{"magic_number_smell": "\n    private void refreshRevisions()\n    {\n        revisionMap = GitCommand.getRevisionsForFile(repository, revertFiles, 100);\n\n        Set<String> targetRevsSet = new LinkedHashSet<String>();\n", "refactored_code": "    private static final int GIT_REVERT_TARGET_LIMIT = 100;\n\n    private void refreshRevisions()\n    {\n        revisionMap = GitCommand.getRevisionsForFile(repository, revertFiles, GIT_REVERT_TARGET_LIMIT);\n\n        Set<String> targetRevsSet = new LinkedHashSet<String>();\n"}
{"magic_number_smell": "\n    private void refreshRevisions()\n    {\n        revisionMap = GitCommand.getRevisions(repository, 100);\n\n        Set<String> targetRevsSet = new LinkedHashSet<String>();\n", "refactored_code": "    private static final int GIT_REVERT_TARGET_LIMIT = 100;\n\n    private void refreshRevisions()\n    {\n        revisionMap = GitCommand.getRevisions(repository, GIT_REVERT_TARGET_LIMIT);\n\n        Set<String> targetRevsSet = new LinkedHashSet<String>();\n"}
{"magic_number_smell": "                    }\n\n                    int result = matchRange(pattern, patternPos, string.charAt(stringPos), flags);\n                    if (result == -1) /* not a good range, treat as normal text */ {\n                        break;\n                    }\n", "refactored_code": "    private static final int RANGE_ERROR = -1;\n                    }\n\n                    int result = matchRange(pattern, patternPos, string.charAt(stringPos), flags);\n                    if (result == RANGE_ERROR) /* not a good range, treat as normal text */ {\n                        break;\n                    }\n"}
{"magic_number_smell": "        repository.create();\n        loggerMessages = new ArrayList<String>();\n        logger = MockOutputLogger.create(loggerMessages);\n        time = 1112911993L;\n\n        copyRepositoryFiles(\"default\", repository);\n        repository.getConfig().load();", "refactored_code": "    private final long TIME_INITIAL = 1112911993L;\n        repository.create();\n        loggerMessages = new ArrayList<String>();\n        logger = MockOutputLogger.create(loggerMessages);\n        time = TIME_INITIAL;\n\n        copyRepositoryFiles(\"default\", repository);\n        repository.getConfig().load();"}
{"magic_number_smell": "                Integer var = new Integer(cr.readUnsignedShort(p));\n                p += 2;\n                if ((t = (YType) vars.get(var)) == null)\n                    vars.put(var, t = new YType(1));\n                if (tv == TAINTED)\n                    t.flags |= YetiType.FL_TAINTED_VAR;\n                return t;", "refactored_code": "        private static final int VAR_DEPTH = 1;\n                Integer var = new Integer(cr.readUnsignedShort(p));\n                p += 2;\n                if ((t = (YType) vars.get(var)) == null)\n                    vars.put(var, t = new YType(VAR_DEPTH));\n                if (tv == TAINTED)\n                    t.flags |= YetiType.FL_TAINTED_VAR;\n                return t;"}
{"magic_number_smell": "            int i = 0;\n            while (OPS[i][0] != op)\n                ++i;\n            return i + 3;\n        }\n\n        Parser(String sourceName, char[] src, int flags) {", "refactored_code": "        private static final int FIRST_OP_LEVEL = 3;\n            int i = 0;\n            while (OPS[i][0] != op)\n                ++i;\n            return i + FIRST_OP_LEVEL;\n        }\n\n        Parser(String sourceName, char[] src, int flags) {"}
{"magic_number_smell": "        if (type.seen)\n            return;\n        if (type.field >= FIELD_NON_POLYMORPHIC)\n            flags |= (flags & 1) == 0\n                        ? RESTRICT_ALL : RESTRICT_CONTRA;\n        YType t = type.deref();\n        int tt = t.type;", "refactored_code": "    private static final int RESTRICT_PROTECT = 1;\n        if (type.seen)\n            return;\n        if (type.field >= FIELD_NON_POLYMORPHIC)\n            flags |= (flags & RESTRICT_PROTECT) == 0\n                        ? RESTRICT_ALL : RESTRICT_CONTRA;\n        YType t = type.deref();\n        int tt = t.type;"}
{"magic_number_smell": "            case 0:\n                switch (c) {\n                case '[':\n                    state = 1;\n                    array = new MList();\n                    stack.result.add(array);\n                    continue;", "refactored_code": "    private static final int ARRAY_FST = 1;\n            case 0:\n                switch (c) {\n                case '[':\n                    state = ARRAY_FST;\n                    array = new MList();\n                    stack.result.add(array);\n                    continue;"}
{"magic_number_smell": "\n        String keyString = concatenateKey(regionName, clearIndex, transformKeyObject(key));\n\n        if (keyString.length() > 250) {\n            throw new IllegalArgumentException(\"Key is longer than \" + 250 + \" characters, try using the Sha1KeyStrategy: \" + keyString);\n        }\n", "refactored_code": "    public static final int MAX_KEY_LENGTH = 250;\n\n        String keyString = concatenateKey(regionName, clearIndex, transformKeyObject(key));\n\n        if (keyString.length() > MAX_KEY_LENGTH) {\n            throw new IllegalArgumentException(\"Key is longer than \" + MAX_KEY_LENGTH + \" characters, try using the Sha1KeyStrategy: \" + keyString);\n        }\n"}
{"magic_number_smell": "\n    public int getCacheTimeSeconds(String cacheRegion) {\n        int globalCacheTimeSeconds = props.getInt(PROP_CACHE_TIME_SECONDS,\n                300);\n        return props.getInt(cacheRegionPrefix(cacheRegion) + CACHE_TIME_SECONDS,\n                globalCacheTimeSeconds);\n    }", "refactored_code": "    public static final int DEFAULT_CACHE_TIME_SECONDS = 300;\n\n    public int getCacheTimeSeconds(String cacheRegion) {\n        int globalCacheTimeSeconds = props.getInt(PROP_CACHE_TIME_SECONDS,\n                DEFAULT_CACHE_TIME_SECONDS);\n        return props.getInt(cacheRegionPrefix(cacheRegion) + CACHE_TIME_SECONDS,\n                globalCacheTimeSeconds);\n    }"}
{"magic_number_smell": "    }\n\n    public int getInitConn() {\n        return properties.getInt(PROP_INIT_CONN, 1);\n    }\n\n    public int getMinConn() {", "refactored_code": "    public static final int DEFAULT_INIT_CONN = 1;\n    }\n\n    public int getInitConn() {\n        return properties.getInt(PROP_INIT_CONN, DEFAULT_INIT_CONN);\n    }\n\n    public int getMinConn() {"}
{"magic_number_smell": "  private void makeupMissedUpdates()\n  {\n    long missedUpdates = nanosSinceLastUpdate() / delayNanos;\n    for (int i = 1; i < missedUpdates && i < (5 + 1); i++)\n    {\n      doUpdate();\n    }", "refactored_code": "  private static final int MaxMakeups = 5;\n  private void makeupMissedUpdates()\n  {\n    long missedUpdates = nanosSinceLastUpdate() / delayNanos;\n    for (int i = 1; i < missedUpdates && i < (MaxMakeups + 1); i++)\n    {\n      doUpdate();\n    }"}
{"magic_number_smell": "  public void setDefault(StyleAttribute attribute, Object value)\n  {\n    if(defaults == null)\n      defaults = new StyleValue[Style.STYLE_LIST.size()];\n\n    StyleValue compiledValue = attribute.compile(value);\n    defaults[attribute.index] = compiledValue;", "refactored_code": "  protected static final int STYLE_COUNT = STYLE_LIST.size();\n  public void setDefault(StyleAttribute attribute, Object value)\n  {\n    if(defaults == null)\n      defaults = new StyleValue[Style.STYLE_COUNT];\n\n    StyleValue compiledValue = attribute.compile(value);\n    defaults[attribute.index] = compiledValue;"}
{"magic_number_smell": "\n  public boolean isShiftDown()\n  {\n    return (modifiers & 1) != 0;\n  }\n\n  public boolean isControlDown()", "refactored_code": "  public static final int SHIFT_MASK = 1;\n\n  public boolean isShiftDown()\n  {\n    return (modifiers & SHIFT_MASK) != 0;\n  }\n\n  public boolean isControlDown()"}
{"magic_number_smell": "\n  public boolean isButton1()\n  {\n    return (getModifiers() & 1 << 4) != 0;\n  }\n\n  public boolean isButton2()", "refactored_code": "  public static final int BUTTON1_MASK = 1 << 4;\n\n  public boolean isButton1()\n  {\n    return (getModifiers() & BUTTON1_MASK) != 0;\n  }\n\n  public boolean isButton2()"}
{"magic_number_smell": "  public ScrollBarPanel(int orientation)\n  {\n    this.orientation = orientation;\n    if(getOrientation() == 0)\n    {\n      preferredGirth = width = GIRTH;\n      setSize(preferredGirth, 50);", "refactored_code": "  public static final int VERTICAL = 0;\n  public ScrollBarPanel(int orientation)\n  {\n    this.orientation = orientation;\n    if(getOrientation() == VERTICAL)\n    {\n      preferredGirth = width = GIRTH;\n      setSize(preferredGirth, 50);"}
{"magic_number_smell": "\n  public int getMinSliderSize()\n  {\n    return 16;\n  }\n\n  public void paintOn(Graphics2D graphics, ScrollBarPanel scrollBar)", "refactored_code": "  private static final int MIN_GEM_SIZE = 16;\n\n  public int getMinSliderSize()\n  {\n    return MIN_GEM_SIZE;\n  }\n\n  public void paintOn(Graphics2D graphics, ScrollBarPanel scrollBar)"}
{"magic_number_smell": "  @Test\n  public void getOptimalSleepNanos() throws Exception\n  {\n    assertEquals(1000000000 / 100, animation.getDelayNanos());\n  }\n\n  @Test", "refactored_code": "  public static final int oneSecond = 1000000000;\n  @Test\n  public void getOptimalSleepNanos() throws Exception\n  {\n    assertEquals(oneSecond / 100, animation.getDelayNanos());\n  }\n\n  @Test"}
{"magic_number_smell": "      executions += 1;\n    }\n\n    protected void 0()\n    {\n      try\n      {", "refactored_code": "    public final long delay = 0;\n      executions += 1;\n    }\n\n    protected void delay()\n    {\n      try\n      {"}
{"magic_number_smell": "  public void backSpace()\n  {\n    setupSingleLine(\"Here are four words\").withCaretAt(0, 1);\n    processor.processKey(new KeyPressedEvent(0, KeyEvent.KEY_BACK_SPACE, 0), model);\n\n    assertEquals(TextLocation.origin, model.getCaretLocation());\n    assertEquals(\"ere are four words\", model.getText());", "refactored_code": "  public static final int NO_MODIFIERS = 0;\n  public void backSpace()\n  {\n    setupSingleLine(\"Here are four words\").withCaretAt(0, 1);\n    processor.processKey(new KeyPressedEvent(NO_MODIFIERS, KeyEvent.KEY_BACK_SPACE, 0), model);\n\n    assertEquals(TextLocation.origin, model.getCaretLocation());\n    assertEquals(\"ere are four words\", model.getText());"}
{"magic_number_smell": "public class NanoTimerTest extends Assert\n{\n  private final int 1000000 = 1000000;\n  private final int TEN_MILLION = 10 * 1000000;\n  private final int NINE_MILLION = 9 * 1000000;\n  private final int ELEVEN_MILLION = 11 * 1000000;\n  private final int TWENTY_MILLION = 20 * 1000000;", "refactored_code": "  private final int ONE_MILLION = 1000000;\npublic class NanoTimerTest extends Assert\n{\n  private final int ONE_MILLION = 1000000;\n  private final int TEN_MILLION = 10 * ONE_MILLION;\n  private final int NINE_MILLION = 9 * ONE_MILLION;\n  private final int ELEVEN_MILLION = 11 * ONE_MILLION;\n  private final int TWENTY_MILLION = 20 * ONE_MILLION;"}
{"magic_number_smell": "    \n    // load the vst\n    try {\n      vst = JVstHost2.newInstance(vstFile, 44100f, BLOCK_SIZE);\n    } catch (FileNotFoundException fnfe) {\n      fnfe.printStackTrace(System.err);\n      System.exit(1);", "refactored_code": "  private static final float SAMPLE_RATE = 44100f;\n    \n    // load the vst\n    try {\n      vst = JVstHost2.newInstance(vstFile, SAMPLE_RATE, BLOCK_SIZE);\n    } catch (FileNotFoundException fnfe) {\n      fnfe.printStackTrace(System.err);\n      System.exit(1);"}
{"magic_number_smell": "  public RandomMiniHost(File vstFile) {\n    vst = null;\n    try {\n      vst = JVstHost2.newInstance(vstFile, 44100f, BLOCK_SIZE);\n    } catch (FileNotFoundException fnfe) {\n      fnfe.printStackTrace(System.err);\n      System.exit(1);", "refactored_code": "  private static final float SAMPLE_RATE = 44100f;\n  public RandomMiniHost(File vstFile) {\n    vst = null;\n    try {\n      vst = JVstHost2.newInstance(vstFile, SAMPLE_RATE, BLOCK_SIZE);\n    } catch (FileNotFoundException fnfe) {\n      fnfe.printStackTrace(System.err);\n      System.exit(1);"}
{"magic_number_smell": "            }\n        }\n\n        if (maxOptionLength > 35)\n            maxOptionLength = 35;\n\n        // Now, print the options.", "refactored_code": "    private static final int MAX_OPTION_STRING_LENGTH = 35;\n            }\n        }\n\n        if (maxOptionLength > MAX_OPTION_STRING_LENGTH)\n            maxOptionLength = MAX_OPTION_STRING_LENGTH;\n\n        // Now, print the options."}
{"magic_number_smell": "        throws IOException,\n               ConfigurationException\n    {\n        if (parseContext.includeFileNestingLevel >= 50)\n        {\n            throw new ConfigurationException\n                                (Package.BUNDLE_NAME,", "refactored_code": "    private static final int    MAX_INCLUDE_NESTING_LEVEL  = 50;\n        throws IOException,\n               ConfigurationException\n    {\n        if (parseContext.includeFileNestingLevel >= MAX_INCLUDE_NESTING_LEVEL)\n        {\n            throw new ConfigurationException\n                                (Package.BUNDLE_NAME,"}
{"magic_number_smell": "    /**\n     * The line length to use.\n     */\n    private int lineLength = 80;\n\n    /**\n     * Current string being assembled. <code>flush</code> clears this", "refactored_code": "    public static final int DEFAULT_LINE_LENGTH = 80;\n    /**\n     * The line length to use.\n     */\n    private int lineLength = DEFAULT_LINE_LENGTH;\n\n    /**\n     * Current string being assembled. <code>flush</code> clears this"}
{"magic_number_smell": "        ZipEntry zipEntry = getZipEntry (name);\n        zipStream.putNextEntry (zipEntry);\n\n        byte buf[] = new byte[8192];\n        int total;\n\n        while ( (total = istream.read (buf, 0, buf.length)) > 0 )", "refactored_code": "    private static final int OUTPUT_BUF_SIZE = 8192;\n        ZipEntry zipEntry = getZipEntry (name);\n        zipStream.putNextEntry (zipEntry);\n\n        byte buf[] = new byte[OUTPUT_BUF_SIZE];\n        int total;\n\n        while ( (total = istream.read (buf, 0, buf.length)) > 0 )"}
{"magic_number_smell": "     * Constructor flag value: If specified, the on-disk hash table is\n     * considered to be transient and will be removed when this object is\n     * closed or finalized. Note that this flag cannot be combined with\n     * {@link #0x01}. Also, if <tt>TRANSIENT</tt> is specified to the\n     * constructor, but the on-disk files already exist, the constructor\n     * will throw an exception unless {@link #FORCE_OVERWRITE} is also\n     * specified.", "refactored_code": "    public static final int NO_CREATE = 0x01;\n     * Constructor flag value: If specified, the on-disk hash table is\n     * considered to be transient and will be removed when this object is\n     * closed or finalized. Note that this flag cannot be combined with\n     * {@link #NO_CREATE}. Also, if <tt>TRANSIENT</tt> is specified to the\n     * constructor, but the on-disk files already exist, the constructor\n     * will throw an exception unless {@link #FORCE_OVERWRITE} is also\n     * specified."}
{"magic_number_smell": "     */\n    public LRUMap (int maxCapacity)\n    {\n        this (DEFAULT_INITIAL_CAPACITY, 0.75f, maxCapacity);\n    }\n\n    /**", "refactored_code": "    public static final float DEFAULT_LOAD_FACTOR      = 0.75f;\n     */\n    public LRUMap (int maxCapacity)\n    {\n        this (DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, maxCapacity);\n    }\n\n    /**"}
{"magic_number_smell": "    \\*----------------------------------------------------------------------*/\n\n    private static final long 1000 = 1000;\n    private static final long MINUTE_MS = 1000 * 60;\n    private static final long HOUR_MS   = MINUTE_MS * 60;\n    private static final long DAY_MS    = HOUR_MS * 24;\n    private static final long WEEK_MS   = DAY_MS * 7;", "refactored_code": "    private static final long SECOND_MS = 1000;\n    \\*----------------------------------------------------------------------*/\n\n    private static final long SECOND_MS = 1000;\n    private static final long MINUTE_MS = SECOND_MS * 60;\n    private static final long HOUR_MS   = MINUTE_MS * 60;\n    private static final long DAY_MS    = HOUR_MS * 24;\n    private static final long WEEK_MS   = DAY_MS * 7;"}
{"magic_number_smell": "\n    static class EmptyVisitor extends ClassVisitor {\n\n        private static final AnnotationVisitor av = new AnnotationVisitor(Opcodes.ASM9) {\n            @Override\n            public AnnotationVisitor visitAnnotation(String name, String desc) {\n                return this;", "refactored_code": "    private static final int OPCODES = Opcodes.ASM9;\n\n    static class EmptyVisitor extends ClassVisitor {\n\n        private static final AnnotationVisitor av = new AnnotationVisitor(OPCODES) {\n            @Override\n            public AnnotationVisitor visitAnnotation(String name, String desc) {\n                return this;"}
{"magic_number_smell": "            }\n        }\n\n        if (maxOptionLength > 35)\n            maxOptionLength = 35;\n\n        // Now, print the options.", "refactored_code": "    private static final int MAX_OPTION_STRING_LENGTH = 35;\n            }\n        }\n\n        if (maxOptionLength > MAX_OPTION_STRING_LENGTH)\n            maxOptionLength = MAX_OPTION_STRING_LENGTH;\n\n        // Now, print the options."}
{"magic_number_smell": "        throws IOException,\n               ConfigurationException\n    {\n        if (parseContext.includeFileNestingLevel >= 50)\n        {\n            throw new ConfigurationException\n                                (Package.BUNDLE_NAME,", "refactored_code": "    private static final int    MAX_INCLUDE_NESTING_LEVEL  = 50;\n        throws IOException,\n               ConfigurationException\n    {\n        if (parseContext.includeFileNestingLevel >= MAX_INCLUDE_NESTING_LEVEL)\n        {\n            throw new ConfigurationException\n                                (Package.BUNDLE_NAME,"}
{"magic_number_smell": "    /**\n     * The line length to use.\n     */\n    private int lineLength = 80;\n\n    /**\n     * Current string being assembled. <code>flush</code> clears this", "refactored_code": "    public static final int DEFAULT_LINE_LENGTH = 80;\n    /**\n     * The line length to use.\n     */\n    private int lineLength = DEFAULT_LINE_LENGTH;\n\n    /**\n     * Current string being assembled. <code>flush</code> clears this"}
{"magic_number_smell": "        ZipEntry zipEntry = getZipEntry (name);\n        zipStream.putNextEntry (zipEntry);\n\n        byte buf[] = new byte[8192];\n        int total;\n\n        while ( (total = istream.read (buf, 0, buf.length)) > 0 )", "refactored_code": "    private static final int OUTPUT_BUF_SIZE = 8192;\n        ZipEntry zipEntry = getZipEntry (name);\n        zipStream.putNextEntry (zipEntry);\n\n        byte buf[] = new byte[OUTPUT_BUF_SIZE];\n        int total;\n\n        while ( (total = istream.read (buf, 0, buf.length)) > 0 )"}
{"magic_number_smell": "     * Constructor flag value: If specified, the on-disk hash table is\n     * considered to be transient and will be removed when this object is\n     * closed or finalized. Note that this flag cannot be combined with\n     * {@link #0x01}. Also, if <tt>TRANSIENT</tt> is specified to the\n     * constructor, but the on-disk files already exist, the constructor\n     * will throw an exception unless {@link #FORCE_OVERWRITE} is also\n     * specified.", "refactored_code": "    public static final int NO_CREATE = 0x01;\n     * Constructor flag value: If specified, the on-disk hash table is\n     * considered to be transient and will be removed when this object is\n     * closed or finalized. Note that this flag cannot be combined with\n     * {@link #NO_CREATE}. Also, if <tt>TRANSIENT</tt> is specified to the\n     * constructor, but the on-disk files already exist, the constructor\n     * will throw an exception unless {@link #FORCE_OVERWRITE} is also\n     * specified."}
{"magic_number_smell": "     */\n    public LRUMap (int maxCapacity)\n    {\n        this (DEFAULT_INITIAL_CAPACITY, 0.75f, maxCapacity);\n    }\n\n    /**", "refactored_code": "    public static final float DEFAULT_LOAD_FACTOR      = 0.75f;\n     */\n    public LRUMap (int maxCapacity)\n    {\n        this (DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, maxCapacity);\n    }\n\n    /**"}
{"magic_number_smell": "    \\*----------------------------------------------------------------------*/\n\n    private static final long 1000 = 1000;\n    private static final long MINUTE_MS = 1000 * 60;\n    private static final long HOUR_MS   = MINUTE_MS * 60;\n    private static final long DAY_MS    = HOUR_MS * 24;\n    private static final long WEEK_MS   = DAY_MS * 7;", "refactored_code": "    private static final long SECOND_MS = 1000;\n    \\*----------------------------------------------------------------------*/\n\n    private static final long SECOND_MS = 1000;\n    private static final long MINUTE_MS = SECOND_MS * 60;\n    private static final long HOUR_MS   = MINUTE_MS * 60;\n    private static final long DAY_MS    = HOUR_MS * 24;\n    private static final long WEEK_MS   = DAY_MS * 7;"}
{"magic_number_smell": "\n    static class EmptyVisitor extends ClassVisitor {\n\n        private static final AnnotationVisitor av = new AnnotationVisitor(Opcodes.ASM9) {\n            @Override\n            public AnnotationVisitor visitAnnotation(String name, String desc) {\n                return this;", "refactored_code": "    private static final int OPCODES = Opcodes.ASM9;\n\n    static class EmptyVisitor extends ClassVisitor {\n\n        private static final AnnotationVisitor av = new AnnotationVisitor(OPCODES) {\n            @Override\n            public AnnotationVisitor visitAnnotation(String name, String desc) {\n                return this;"}
{"magic_number_smell": "     */\n    @Override\n    public String getMessage() {\n        return new ComparisonCompactor(20, fExpected, fActual).compact(super.getMessage());\n    }\n\n    /**", "refactored_code": "    private static final int MAX_CONTEXT_LENGTH = 20;\n     */\n    @Override\n    public String getMessage() {\n        return new ComparisonCompactor(MAX_CONTEXT_LENGTH, fExpected, fActual).compact(super.getMessage());\n    }\n\n    /**"}
{"magic_number_smell": "            if (!r.wasSuccessful()) {\n                System.exit(FAILURE_EXIT);\n            }\n            System.exit(0);\n        } catch (Exception e) {\n            System.err.println(e.getMessage());\n            System.exit(EXCEPTION_EXIT);", "refactored_code": "    public static final int SUCCESS_EXIT = 0;\n            if (!r.wasSuccessful()) {\n                System.exit(FAILURE_EXIT);\n            }\n            System.exit(SUCCESS_EXIT);\n        } catch (Exception e) {\n            System.err.println(e.getMessage());\n            System.exit(EXCEPTION_EXIT);"}
{"magic_number_smell": "     */\n    @Override\n    public String getMessage() {\n        return new ComparisonCompactor(20, fExpected, fActual).compact(super.getMessage());\n    }\n\n    /**", "refactored_code": "    private static final int MAX_CONTEXT_LENGTH = 20;\n     */\n    @Override\n    public String getMessage() {\n        return new ComparisonCompactor(MAX_CONTEXT_LENGTH, fExpected, fActual).compact(super.getMessage());\n    }\n\n    /**"}
{"magic_number_smell": "\n    private static File createTemporaryFolderWithFileApi(File parentFolder) throws IOException {\n        File createdFolder = null;\n        for (int i = 0; i < 10000; ++i) {\n            // Use createTempFile to get a suitable folder name.\n            String suffix = \".tmp\";\n            File tmpFile = File.createTempFile(TMP_PREFIX, suffix, parentFolder);", "refactored_code": "    private static final int TEMP_DIR_ATTEMPTS = 10000;\n\n    private static File createTemporaryFolderWithFileApi(File parentFolder) throws IOException {\n        File createdFolder = null;\n        for (int i = 0; i < TEMP_DIR_ATTEMPTS; ++i) {\n            // Use createTempFile to get a suitable folder name.\n            String suffix = \".tmp\";\n            File tmpFile = File.createTempFile(TMP_PREFIX, suffix, parentFolder);"}
{"magic_number_smell": "     * class match the files that {@code Result} had in JUnit 4.11.\n     */\n    private static class SerializedForm implements Serializable {\n        private static final long 1L = 1L;\n        private final AtomicInteger fCount;\n        private final AtomicInteger fIgnoreCount;\n        private final AtomicInteger assumptionFailureCount;", "refactored_code": "    private static final long serialVersionUID = 1L;\n     * class match the files that {@code Result} had in JUnit 4.11.\n     */\n    private static class SerializedForm implements Serializable {\n        private static final long serialVersionUID = 1L;\n        private final AtomicInteger fCount;\n        private final AtomicInteger fIgnoreCount;\n        private final AtomicInteger assumptionFailureCount;"}
{"magic_number_smell": "            });\n        }\n        pool.shutdown();\n        assertTrue(pool.awaitTermination(3, TimeUnit.SECONDS));\n\n        fNotifier.removeListener(listener1);\n        fNotifier.removeListener(listener2);", "refactored_code": "    private static final long TIMEOUT = 3;\n            });\n        }\n        pool.shutdown();\n        assertTrue(pool.awaitTermination(TIMEOUT, TimeUnit.SECONDS));\n\n        fNotifier.removeListener(listener1);\n        fNotifier.removeListener(listener2);"}
{"magic_number_smell": "        @Test\n        public void one() throws InterruptedException {\n            fSynchronizer.countDown();\n            assertTrue(fSynchronizer.await(15, TimeUnit.SECONDS));\n            fExample1One = Thread.currentThread();\n        }\n", "refactored_code": "    private static final long TIMEOUT = 15;\n        @Test\n        public void one() throws InterruptedException {\n            fSynchronizer.countDown();\n            assertTrue(fSynchronizer.await(TIMEOUT, TimeUnit.SECONDS));\n            fExample1One = Thread.currentThread();\n        }\n"}
{"magic_number_smell": "        @Test\n        public void one() throws InterruptedException {\n            fSynchronizer.countDown();\n            assertTrue(fSynchronizer.await(15, TimeUnit.SECONDS));\n            fOne = Thread.currentThread();\n        }\n", "refactored_code": "    private static final long TIMEOUT = 15;\n        @Test\n        public void one() throws InterruptedException {\n            fSynchronizer.countDown();\n            assertTrue(fSynchronizer.await(TIMEOUT, TimeUnit.SECONDS));\n            fOne = Thread.currentThread();\n        }\n"}
{"magic_number_smell": "    @RunWith(Theories.class)\n    public static class PositiveIntsWithNegativeField {\n        @DataPoint\n        public static final int 1 = 1;\n        @DataPoint\n        public static final int NEGONE = -1;\n", "refactored_code": "        public static final int ONE = 1;\n    @RunWith(Theories.class)\n    public static class PositiveIntsWithNegativeField {\n        @DataPoint\n        public static final int ONE = 1;\n        @DataPoint\n        public static final int NEGONE = -1;\n"}
{"magic_number_smell": "\n    static public class Exit {\n        public static void main(String[] args) {\n            System.exit(5);\n        }\n    }\n", "refactored_code": "    private static final int EXIT_CODE = 5;\n\n    static public class Exit {\n        public static void main(String[] args) {\n            System.exit(EXIT_CODE);\n        }\n    }\n"}
{"magic_number_smell": "\n        token = consumeToken();\n        if (token.getType() == Token.NAME) {\n            if (mode == 1) {\n                // Get the name of the function and declare it in the current scope.\n                symbol = token.getValue();\n                if (currentScope.getIdentifier(symbol) != null) {", "refactored_code": "    private static final int BUILDING_SYMBOL_TREE = 1;\n\n        token = consumeToken();\n        if (token.getType() == Token.NAME) {\n            if (mode == BUILDING_SYMBOL_TREE) {\n                // Get the name of the function and declare it in the current scope.\n                symbol = token.getValue();\n                if (currentScope.getIdentifier(symbol) != null) {"}
{"magic_number_smell": "        if (caseGap < 0) throw new IllegalArgumentException();\n\n        StringBuffer result = new StringBuffer();\n        boolean justFunctionBody = (0 != (flags & Decompiler.1 << 0));\n        boolean toSource = (0 != (flags & Decompiler.TO_SOURCE_FLAG));\n\n        // Spew tokens in source, for debugging.", "refactored_code": "    public static final int ONLY_BODY_FLAG = 1 << 0;\n        if (caseGap < 0) throw new IllegalArgumentException();\n\n        StringBuffer result = new StringBuffer();\n        boolean justFunctionBody = (0 != (flags & Decompiler.ONLY_BODY_FLAG));\n        boolean toSource = (0 != (flags & Decompiler.TO_SOURCE_FLAG));\n\n        // Spew tokens in source, for debugging."}
{"magic_number_smell": "    private static final int[] FLAG_LOOKUP = new int[Character.MAX_VALUE];\n\n    static {\n        FLAG_LOOKUP['g'] = 256;\n        FLAG_LOOKUP['i'] = Pattern.CASE_INSENSITIVE;\n        FLAG_LOOKUP['m'] = Pattern.MULTILINE;\n        FLAG_LOOKUP['s'] = Pattern.DOTALL;", "refactored_code": "    private static final int FLAG_GLOBAL = 256;\n    private static final int[] FLAG_LOOKUP = new int[Character.MAX_VALUE];\n\n    static {\n        FLAG_LOOKUP['g'] = FLAG_GLOBAL;\n        FLAG_LOOKUP['i'] = Pattern.CASE_INSENSITIVE;\n        FLAG_LOOKUP['m'] = Pattern.MULTILINE;\n        FLAG_LOOKUP['s'] = Pattern.DOTALL;"}
{"magic_number_smell": "    }\n\n    private static class SerializationProxy implements Serializable {\n        private static final long 1L = 1L;\n\n        private final byte[] bytes;\n", "refactored_code": "    private static final long serialVersionUID = 1L;\n    }\n\n    private static class SerializationProxy implements Serializable {\n        private static final long serialVersionUID = 1L;\n\n        private final byte[] bytes;\n"}
{"magic_number_smell": "\n    @Override\n    public int decode(final InputStream in, final BSONCallback callback) throws IOException {\n        byte[] documentSizeBuffer = new byte[4];\n        int documentSize = Bits.readInt(in, documentSizeBuffer);\n        byte[] documentBytes = Arrays.copyOf(documentSizeBuffer, documentSize);\n        Bits.readFully(in, documentBytes, 4, documentSize - 4);", "refactored_code": "    private static final int BYTES_IN_INTEGER = 4;\n\n    @Override\n    public int decode(final InputStream in, final BSONCallback callback) throws IOException {\n        byte[] documentSizeBuffer = new byte[BYTES_IN_INTEGER];\n        int documentSize = Bits.readInt(in, documentSizeBuffer);\n        byte[] documentBytes = Arrays.copyOf(documentSizeBuffer, documentSize);\n        Bits.readFully(in, documentBytes, BYTES_IN_INTEGER, documentSize - BYTES_IN_INTEGER);"}
{"magic_number_smell": "    }\n\n    private static class SerializationProxy implements Serializable {\n        private static final long 2L = 1L;\n\n        private final byte[] bytes;\n", "refactored_code": "    private static final long serialVersionUID = 2L;\n    }\n\n    private static class SerializationProxy implements Serializable {\n        private static final long serialVersionUID = 1L;\n\n        private final byte[] bytes;\n"}
{"magic_number_smell": "    }\n\n    private static class SerializationProxy implements Serializable {\n        private static final long 1L = 1L;\n\n        private final byte[] bytes;\n", "refactored_code": "    private static final long serialVersionUID = 1L;\n    }\n\n    private static class SerializationProxy implements Serializable {\n        private static final long serialVersionUID = 1L;\n\n        private final byte[] bytes;\n"}
{"magic_number_smell": "    private enum RegexFlag {\n        CANON_EQ(Pattern.CANON_EQ, 'c', \"Pattern.CANON_EQ\"),\n        UNIX_LINES(Pattern.UNIX_LINES, 'd', \"Pattern.UNIX_LINES\"),\n        GLOBAL(256, 'g', null),\n        CASE_INSENSITIVE(Pattern.CASE_INSENSITIVE, 'i', null),\n        MULTILINE(Pattern.MULTILINE, 'm', null),\n        DOTALL(Pattern.DOTALL, 's', \"Pattern.DOTALL\"),", "refactored_code": "    private static final int GLOBAL_FLAG = 256;\n    private enum RegexFlag {\n        CANON_EQ(Pattern.CANON_EQ, 'c', \"Pattern.CANON_EQ\"),\n        UNIX_LINES(Pattern.UNIX_LINES, 'd', \"Pattern.UNIX_LINES\"),\n        GLOBAL(GLOBAL_FLAG, 'g', null),\n        CASE_INSENSITIVE(Pattern.CASE_INSENSITIVE, 'i', null),\n        MULTILINE(Pattern.MULTILINE, 'm', null),\n        DOTALL(Pattern.DOTALL, 's', \"Pattern.DOTALL\"),"}
{"magic_number_smell": "            @Override\n            public void reset() {\n                ensureOpen();\n                buffer.position(buffer.position());\n            }\n        };\n    }", "refactored_code": "            private final int mark = buffer.position();\n            @Override\n            public void reset() {\n                ensureOpen();\n                buffer.position(mark);\n            }\n        };\n    }"}
{"magic_number_smell": "\n    static long parse(final String dateTimeString) {\n        // ISO_OFFSET_DATE_TIME will not parse date strings consisting of just year-month-day, so use ISO_LOCAL_DATE for those\n        if (dateTimeString.length() == \"1970-01-01\".length()) {\n            return LocalDate.parse(dateTimeString, ISO_LOCAL_DATE).atStartOfDay().toInstant(ZoneOffset.UTC).toEpochMilli();\n        } else {\n            return ISO_OFFSET_DATE_TIME.parse(dateTimeString, temporal -> Instant.from(temporal)).toEpochMilli();", "refactored_code": "    private static final int DATE_STRING_LENGTH = \"1970-01-01\".length();\n\n    static long parse(final String dateTimeString) {\n        // ISO_OFFSET_DATE_TIME will not parse date strings consisting of just year-month-day, so use ISO_LOCAL_DATE for those\n        if (dateTimeString.length() == DATE_STRING_LENGTH) {\n            return LocalDate.parse(dateTimeString, ISO_LOCAL_DATE).atStartOfDay().toInstant(ZoneOffset.UTC).toEpochMilli();\n        } else {\n            return ISO_OFFSET_DATE_TIME.parse(dateTimeString, temporal -> Instant.from(temporal)).toEpochMilli();"}
{"magic_number_smell": "\n    @Override\n    public void convert(final Long value, final StrictJsonWriter writer) {\n        if (value < 0 || value > 253402300799999L) {\n            FALLBACK_CONVERTER.convert(value, writer);\n        } else {\n            writer.writeStartObject();", "refactored_code": "    private static final long LAST_MS_OF_YEAR_9999 = 253402300799999L;\n\n    @Override\n    public void convert(final Long value, final StrictJsonWriter writer) {\n        if (value < 0 || value > LAST_MS_OF_YEAR_9999) {\n            FALLBACK_CONVERTER.convert(value, writer);\n        } else {\n            writer.writeStartObject();"}
{"magic_number_smell": "    }\n\n    private static class SerializationProxy implements Serializable {\n        private static final long 1L = 1L;\n\n        private final byte[] bytes;\n", "refactored_code": "    private static final long serialVersionUID = 1L;\n    }\n\n    private static class SerializationProxy implements Serializable {\n        private static final long serialVersionUID = 1L;\n\n        private final byte[] bytes;\n"}
{"magic_number_smell": "\n    private static void runBenchmark(final Benchmark benchmark) throws Exception {\n        long startTime = System.currentTimeMillis();\n        BenchmarkResult benchmarkResult = new BenchmarkRunner(benchmark, 1, NUM_ITERATIONS, MIN_TIME_SECONDS,\n                MAX_TIME_SECONDS).run();\n        long endTime = System.currentTimeMillis();\n        System.out.println(benchmarkResult.getName() + \": \" + (endTime - startTime) / 1000.0);", "refactored_code": "    private static final int NUM_WARMUP_ITERATIONS = 1;\n\n    private static void runBenchmark(final Benchmark benchmark) throws Exception {\n        long startTime = System.currentTimeMillis();\n        BenchmarkResult benchmarkResult = new BenchmarkRunner(benchmark, NUM_WARMUP_ITERATIONS, NUM_ITERATIONS, MIN_TIME_SECONDS,\n                MAX_TIME_SECONDS).run();\n        long endTime = System.currentTimeMillis();\n        System.out.println(benchmarkResult.getName() + \": \" + (endTime - startTime) / 1000.0);"}
{"magic_number_smell": "    @Override\n    public void write(final BenchmarkResult benchmarkResult) {\n        printStream.printf(\"%s: %.3f%n\", benchmarkResult.getName(),\n                benchmarkResult.getElapsedTimeNanosAtPercentile(50) / 1000000000.0);\n    }\n\n    @Override", "refactored_code": "    public static final double ONE_BILLION = 1000000000.0; // To convert nanoseconds to seconds\n    @Override\n    public void write(final BenchmarkResult benchmarkResult) {\n        printStream.printf(\"%s: %.3f%n\", benchmarkResult.getName(),\n                benchmarkResult.getElapsedTimeNanosAtPercentile(50) / ONE_BILLION);\n    }\n\n    @Override"}
{"magic_number_smell": "        printStream.println(benchmarkResult.getName());\n        printStream.println(benchmarkResult.getNumIterations() + \" iterations\");\n\n        double megabytesPerIteration = benchmarkResult.getBytesPerIteration() / 1000000.0;\n\n        for (int percentile : percentiles) {\n            double secondsPerIteration = benchmarkResult.getElapsedTimeNanosAtPercentile(percentile) / ONE_BILLION;", "refactored_code": "    public static final double ONE_MEGABYTE = 1000000.0;   // Intentionally in base 10\n        printStream.println(benchmarkResult.getName());\n        printStream.println(benchmarkResult.getNumIterations() + \" iterations\");\n\n        double megabytesPerIteration = benchmarkResult.getBytesPerIteration() / ONE_MEGABYTE;\n\n        for (int percentile : percentiles) {\n            double secondsPerIteration = benchmarkResult.getElapsedTimeNanosAtPercentile(percentile) / ONE_BILLION;"}
{"magic_number_smell": "\n        long heartbeatFrequencyMS = clusterDescription.getServerSettings().getHeartbeatFrequency(MILLISECONDS);\n\n        if (maxStaleness < Math.max(90000, heartbeatFrequencyMS + IDLE_WRITE_PERIOD_MS)) {\n            if (90000 > heartbeatFrequencyMS + IDLE_WRITE_PERIOD_MS){\n                throw new MongoConfigurationException(format(\"Max staleness (%d sec) must be at least 90 seconds\",\n                        getMaxStaleness(SECONDS)));", "refactored_code": "    private static final int SMALLEST_MAX_STALENESS_MS = 90000;\n\n        long heartbeatFrequencyMS = clusterDescription.getServerSettings().getHeartbeatFrequency(MILLISECONDS);\n\n        if (maxStaleness < Math.max(SMALLEST_MAX_STALENESS_MS, heartbeatFrequencyMS + IDLE_WRITE_PERIOD_MS)) {\n            if (SMALLEST_MAX_STALENESS_MS > heartbeatFrequencyMS + IDLE_WRITE_PERIOD_MS){\n                throw new MongoConfigurationException(format(\"Max staleness (%d sec) must be at least 90 seconds\",\n                        getMaxStaleness(SECONDS)));"}
{"magic_number_smell": "     */\n    public ConnectionDescription(final ServerId serverId) {\n        this(new ConnectionId(serverId), 0, ServerType.UNKNOWN, DEFAULT_MAX_WRITE_BATCH_SIZE,\n             getDefaultMaxDocumentSize(), 0x2000000, Collections.emptyList());\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_MAX_MESSAGE_SIZE = 0x2000000;   // 32MB\n     */\n    public ConnectionDescription(final ServerId serverId) {\n        this(new ConnectionId(serverId), 0, ServerType.UNKNOWN, DEFAULT_MAX_WRITE_BATCH_SIZE,\n             getDefaultMaxDocumentSize(), DEFAULT_MAX_MESSAGE_SIZE, Collections.emptyList());\n    }\n\n    /**"}
{"magic_number_smell": "     * Gets the SOCKS5 proxy port.\n     *\n     * @return The port number of the SOCKS5 proxy. If a custom port has been set using {@link Builder#port(int)},\n     * that custom port value is returned. Otherwise, the default SOCKS5 port {@value #1080} is returned.\n     * @see Builder#port(int)\n     */\n    public int getPort() {", "refactored_code": "    private static final int DEFAULT_PORT = 1080;\n     * Gets the SOCKS5 proxy port.\n     *\n     * @return The port number of the SOCKS5 proxy. If a custom port has been set using {@link Builder#port(int)},\n     * that custom port value is returned. Otherwise, the default SOCKS5 port {@value #DEFAULT_PORT} is returned.\n     * @see Builder#port(int)\n     */\n    public int getPort() {"}
{"magic_number_smell": "     * @since 3.6\n     */\n    public boolean isIncompatiblyOlderThanDriver() {\n        return ok && type != LOAD_BALANCER && maxWireVersion < 6;\n    }\n\n    /**", "refactored_code": "    public static final int MIN_DRIVER_WIRE_VERSION = 6;\n     * @since 3.6\n     */\n    public boolean isIncompatiblyOlderThanDriver() {\n        return ok && type != LOAD_BALANCER && maxWireVersion < MIN_DRIVER_WIRE_VERSION;\n    }\n\n    /**"}
{"magic_number_smell": "\n    private static class AwsSaslClient implements SaslClient {\n        private final MongoCredential credential;\n        private final byte[] clientNonce = new byte[32];\n        private int step = -1;\n\n        AwsSaslClient(final MongoCredential credential) {", "refactored_code": "    private static final int RANDOM_LENGTH = 32;\n\n    private static class AwsSaslClient implements SaslClient {\n        private final MongoCredential credential;\n        private final byte[] clientNonce = new byte[RANDOM_LENGTH];\n        private int step = -1;\n\n        AwsSaslClient(final MongoCredential credential) {"}
{"magic_number_smell": "\n        @Nullable\n        Long getRemainingTime() {\n            return maxWaitTimeNanos == null ? null : maxWaitTimeNanos - (System.nanoTime() - System.nanoTime());\n        }\n    }\n", "refactored_code": "        private final long startTimeNanos = System.nanoTime();\n\n        @Nullable\n        Long getRemainingTime() {\n            return maxWaitTimeNanos == null ? null : maxWaitTimeNanos - (System.nanoTime() - startTimeNanos);\n        }\n    }\n"}
{"magic_number_smell": "        MessageSettings payloadMessageSettings = settings;\n        if (type != SplittablePayload.Type.INSERT) {\n            payloadMessageSettings = createMessageSettingsBuilder(settings)\n                    .maxDocumentSize(settings.getMaxDocumentSize() + 1024 * 16)\n                    .build();\n        }\n        return payloadMessageSettings;", "refactored_code": "    private static final int DOCUMENT_HEADROOM = 1024 * 16;\n        MessageSettings payloadMessageSettings = settings;\n        if (type != SplittablePayload.Type.INSERT) {\n            payloadMessageSettings = createMessageSettingsBuilder(settings)\n                    .maxDocumentSize(settings.getMaxDocumentSize() + DOCUMENT_HEADROOM)\n                    .build();\n        }\n        return payloadMessageSettings;"}
{"magic_number_smell": "\n    private ByteBuf getByteBufferAtIndex(final int index) {\n        if (bufferList.size() < index + 1) {\n            bufferList.add(bufferProvider.getBuffer(index >= (31 - INITIAL_SHIFT)\n                                                            ? MAX_BUFFER_SIZE\n                                                            : Math.min(INITIAL_BUFFER_SIZE << index, MAX_BUFFER_SIZE)));\n        }", "refactored_code": "    private static final int MAX_SHIFT = 31;\n\n    private ByteBuf getByteBufferAtIndex(final int index) {\n        if (bufferList.size() < index + 1) {\n            bufferList.add(bufferProvider.getBuffer(index >= (MAX_SHIFT - INITIAL_SHIFT)\n                                                            ? MAX_BUFFER_SIZE\n                                                            : Math.min(INITIAL_BUFFER_SIZE << index, MAX_BUFFER_SIZE)));\n        }"}
{"magic_number_smell": "    }\n\n    static boolean clientMetadataDocumentTooLarge(final BsonDocument document) {\n        BasicOutputBuffer buffer = new BasicOutputBuffer(512);\n        new BsonDocumentCodec().encode(new BsonBinaryWriter(buffer), document, EncoderContext.builder().build());\n        return buffer.getPosition() > 512;\n    }", "refactored_code": "    private static final int MAXIMUM_CLIENT_METADATA_ENCODED_SIZE = 512;\n    }\n\n    static boolean clientMetadataDocumentTooLarge(final BsonDocument document) {\n        BasicOutputBuffer buffer = new BasicOutputBuffer(MAXIMUM_CLIENT_METADATA_ENCODED_SIZE);\n        new BsonDocumentCodec().encode(new BsonBinaryWriter(buffer), document, EncoderContext.builder().build());\n        return buffer.getPosition() > MAXIMUM_CLIENT_METADATA_ENCODED_SIZE;\n    }"}
{"magic_number_smell": "    /**\n     * The length of the OP_COMPRESSED header plus the length of the standard message header\n     */\n    public static final int TOTAL_COMPRESSED_HEADER_LENGTH = 9 + MESSAGE_HEADER_LENGTH;\n\n    private final int originalOpcode;\n    private final int uncompressedSize;", "refactored_code": "    public static final int COMPRESSED_HEADER_LENGTH = 9;\n    /**\n     * The length of the OP_COMPRESSED header plus the length of the standard message header\n     */\n    public static final int TOTAL_COMPRESSED_HEADER_LENGTH = COMPRESSED_HEADER_LENGTH + MESSAGE_HEADER_LENGTH;\n\n    private final int originalOpcode;\n    private final int uncompressedSize;"}
{"magic_number_smell": "    }\n\n    /**\n     * @return {@link Integer#toString()} if {@code size} is not {@link #Integer.MAX_VALUE}, otherwise returns {@code \"infinite\"}.\n     */\n    static String sizeToString(final int size) {\n        return size == Integer.MAX_VALUE ? \"infinite\" : Integer.toString(size);", "refactored_code": "    public static final int INFINITE_SIZE = Integer.MAX_VALUE;\n    }\n\n    /**\n     * @return {@link Integer#toString()} if {@code size} is not {@link #INFINITE_SIZE}, otherwise returns {@code \"infinite\"}.\n     */\n    static String sizeToString(final int size) {\n        return size == INFINITE_SIZE ? \"infinite\" : Integer.toString(size);"}
{"magic_number_smell": "\n    @Override\n    public DnsSrvRecordMonitor create(final String hostName, final String srvServiceName, final DnsSrvRecordInitializer dnsSrvRecordInitializer) {\n        return new DefaultDnsSrvRecordMonitor(hostName, srvServiceName, 60000, noRecordsRescanFrequency,\n                dnsSrvRecordInitializer, clusterId, new DefaultDnsResolver(dnsClient));\n    }\n}", "refactored_code": "    private static final long DEFAULT_RESCAN_FREQUENCY_MILLIS = 60000;\n\n    @Override\n    public DnsSrvRecordMonitor create(final String hostName, final String srvServiceName, final DnsSrvRecordInitializer dnsSrvRecordInitializer) {\n        return new DefaultDnsSrvRecordMonitor(hostName, srvServiceName, DEFAULT_RESCAN_FREQUENCY_MILLIS, noRecordsRescanFrequency,\n                dnsSrvRecordInitializer, clusterId, new DefaultDnsResolver(dnsClient));\n    }\n}"}
{"magic_number_smell": "    ExponentiallyWeightedMovingAverage(final double alpha) {\n        isTrueArgument(\"alpha >= 0.0 and <= 1.0\", alpha >= 0.0 && alpha <= 1.0);\n        this.alpha = alpha;\n        average = new AtomicLong(-1);\n    }\n\n    void reset() {", "refactored_code": "    private static final long EMPTY = -1;\n    ExponentiallyWeightedMovingAverage(final double alpha) {\n        isTrueArgument(\"alpha >= 0.0 and <= 1.0\", alpha >= 0.0 && alpha <= 1.0);\n        this.alpha = alpha;\n        average = new AtomicLong(EMPTY);\n    }\n\n    void reset() {"}
{"magic_number_smell": "        }\n\n        long getRemainingTime(final long curTimeNanos) {\n            return System.nanoTime() + maxWaitTimeNanos - curTimeNanos;\n        }\n\n        public void onSuccess(final ServerTuple serverTuple) {", "refactored_code": "        private final long startTimeNanos = System.nanoTime();\n        }\n\n        long getRemainingTime(final long curTimeNanos) {\n            return startTimeNanos + maxWaitTimeNanos - curTimeNanos;\n        }\n\n        public void onSuccess(final ServerTuple serverTuple) {"}
{"magic_number_smell": "                    entries -> {\n                        entries.add(new Entry(COMMAND_NAME, commandName));\n                        entries.add(new Entry(DATABASE_NAME, message.getNamespace().getDatabaseName()));\n                        entries.add(new Entry(DURATION_MS, elapsedTimeNanos / 1_000_000.0d));\n                    },\n                    entries -> entries.add(new Entry(COMMAND_CONTENT, null)));\n        }", "refactored_code": "    private static final double NANOS_PER_MILLI = 1_000_000.0d;\n                    entries -> {\n                        entries.add(new Entry(COMMAND_NAME, commandName));\n                        entries.add(new Entry(DATABASE_NAME, message.getNamespace().getDatabaseName()));\n                        entries.add(new Entry(DURATION_MS, elapsedTimeNanos / NANOS_PER_MILLI));\n                    },\n                    entries -> entries.add(new Entry(COMMAND_CONTENT, null)));\n        }"}
{"magic_number_smell": "     */\n    @NotThreadSafe\n    public static final class Builder {\n        private int maxDocumentSize = 0x1000000;\n        private int maxMessageSize = DEFAULT_MAX_MESSAGE_SIZE;\n        private int maxBatchCount = DEFAULT_MAX_BATCH_COUNT;\n        private int maxWireVersion;", "refactored_code": "    private static final int DEFAULT_MAX_DOCUMENT_SIZE = 0x1000000;  // 16MB\n     */\n    @NotThreadSafe\n    public static final class Builder {\n        private int maxDocumentSize = DEFAULT_MAX_DOCUMENT_SIZE;\n        private int maxMessageSize = DEFAULT_MAX_MESSAGE_SIZE;\n        private int maxBatchCount = DEFAULT_MAX_BATCH_COUNT;\n        private int maxWireVersion;"}
{"magic_number_smell": "\n    private static boolean isNotPrimaryError(final int errorCode, final String errorMessage) {\n        return NOT_PRIMARY_CODES.contains(errorCode)\n                || (errorCode == -1 && NOT_PRIMARY_MESSAGES.stream().anyMatch(errorMessage::contains));\n    }\n\n    private static boolean isNodeIsRecoveringError(final int errorCode, final String errorMessage) {", "refactored_code": "    private static final int NO_ERROR_CODE = -1;\n\n    private static boolean isNotPrimaryError(final int errorCode, final String errorMessage) {\n        return NOT_PRIMARY_CODES.contains(errorCode)\n                || (errorCode == NO_ERROR_CODE && NOT_PRIMARY_MESSAGES.stream().anyMatch(errorMessage::contains));\n    }\n\n    private static boolean isNodeIsRecoveringError(final int errorCode, final String errorMessage) {"}
{"magic_number_smell": "    /**\n     * The length of the OP_REPLY header plus the length of the standard message header\n     */\n    public static final int TOTAL_REPLY_HEADER_LENGTH = 20 + MESSAGE_HEADER_LENGTH;\n\n    private final int messageLength;\n    private final int requestId;", "refactored_code": "    public static final int REPLY_HEADER_LENGTH = 20;\n    /**\n     * The length of the OP_REPLY header plus the length of the standard message header\n     */\n    public static final int TOTAL_REPLY_HEADER_LENGTH = REPLY_HEADER_LENGTH + MESSAGE_HEADER_LENGTH;\n\n    private final int messageLength;\n    private final int requestId;"}
{"magic_number_smell": "    protected void addDocument(final BsonDocument document, final BsonOutput bsonOutput,\n                               final FieldNameValidator validator, @Nullable final List<BsonElement> extraElements) {\n        addDocument(document, getCodec(document), EncoderContext.builder().build(), bsonOutput, validator,\n                settings.getMaxDocumentSize() + 16 * 1024, extraElements);\n    }\n\n    /**", "refactored_code": "    private static final int DOCUMENT_HEADROOM = 16 * 1024;\n    protected void addDocument(final BsonDocument document, final BsonOutput bsonOutput,\n                               final FieldNameValidator validator, @Nullable final List<BsonElement> extraElements) {\n        addDocument(document, getCodec(document), EncoderContext.builder().build(), bsonOutput, validator,\n                settings.getMaxDocumentSize() + DOCUMENT_HEADROOM, extraElements);\n    }\n\n    /**"}
{"magic_number_smell": "\n            String salt = map.get(\"s\");\n            int iterationCount = Integer.parseInt(map.get(\"i\"));\n            if (iterationCount < 4096) {\n                throw new SaslException(\"Invalid iteration count.\");\n            }\n", "refactored_code": "    private static final int MINIMUM_ITERATION_COUNT = 4096;\n\n            String salt = map.get(\"s\");\n            int iterationCount = Integer.parseInt(map.get(\"i\"));\n            if (iterationCount < MINIMUM_ITERATION_COUNT) {\n                throw new SaslException(\"Invalid iteration count.\");\n            }\n"}
{"magic_number_smell": "                    SET_OPTION_METHOD.invoke(socket, KEEP_COUNT_OPTION, TCP_KEEPCOUNT_LIMIT);\n                }\n                if (KEEP_IDLE_OPTION != null) {\n                    SET_OPTION_METHOD.invoke(socket, KEEP_IDLE_OPTION, 120);\n                }\n                if (KEEP_INTERVAL_OPTION != null) {\n                    SET_OPTION_METHOD.invoke(socket, KEEP_INTERVAL_OPTION, TCP_KEEPINTERVAL_DURATION);", "refactored_code": "    private static final int TCP_KEEPIDLE_DURATION = 120;\n                    SET_OPTION_METHOD.invoke(socket, KEEP_COUNT_OPTION, TCP_KEEPCOUNT_LIMIT);\n                }\n                if (KEEP_IDLE_OPTION != null) {\n                    SET_OPTION_METHOD.invoke(socket, KEEP_IDLE_OPTION, TCP_KEEPIDLE_DURATION);\n                }\n                if (KEEP_INTERVAL_OPTION != null) {\n                    SET_OPTION_METHOD.invoke(socket, KEEP_INTERVAL_OPTION, TCP_KEEPINTERVAL_DURATION);"}
{"magic_number_smell": "            addressType = determineAddressType(ipAddress);\n        }\n        byte[] bufferSent = createBuffer(addressType, hostLength);\n        bufferSent[0] = 0x05;\n        bufferSent[1] = SocksCommand.CONNECT.getCommandNumber();\n        bufferSent[2] = RESERVED;\n        switch (addressType) {", "refactored_code": "    private static final byte SOCKS_VERSION = 0x05;\n            addressType = determineAddressType(ipAddress);\n        }\n        byte[] bufferSent = createBuffer(addressType, hostLength);\n        bufferSent[0] = SOCKS_VERSION;\n        bufferSent[1] = SocksCommand.CONNECT.getCommandNumber();\n        bufferSent[2] = RESERVED;\n        switch (addressType) {"}
{"magic_number_smell": "     * these fields can be plain.*/\n    @Nullable\n    private ReadTimeoutTask readTimeoutTask;\n    private long readTimeoutMillis = 0;\n\n    NettyStream(final ServerAddress address, final InetAddressResolver inetAddressResolver, final SocketSettings settings,\n            final SslSettings sslSettings, final EventLoopGroup workerGroup,", "refactored_code": "    private static final byte NO_SCHEDULE_TIME = 0;\n     * these fields can be plain.*/\n    @Nullable\n    private ReadTimeoutTask readTimeoutTask;\n    private long readTimeoutMillis = NO_SCHEDULE_TIME;\n\n    NettyStream(final ServerAddress address, final InetAddressResolver inetAddressResolver, final SocketSettings settings,\n            final SslSettings sslSettings, final EventLoopGroup workerGroup,"}
{"magic_number_smell": "                        nThreads,\n                        0,\n                        TimeUnit.MILLISECONDS,\n                        new LinkedBlockingQueue<>(nThreads * 32),\n                        runnable ->\n                                new Thread(runnable, format(\"async-channel-group-%d-handler-executor\", id)),\n                        new ThreadPoolExecutor.CallerRunsPolicy());", "refactored_code": "    private static final int queueLengthMultiplier = 32;\n                        nThreads,\n                        0,\n                        TimeUnit.MILLISECONDS,\n                        new LinkedBlockingQueue<>(nThreads * queueLengthMultiplier),\n                        runnable ->\n                                new Thread(runnable, format(\"async-channel-group-%d-handler-executor\", id)),\n                        new ThreadPoolExecutor.CallerRunsPolicy());"}
{"magic_number_smell": "                    \"inEncrypted\",\n                    Optional.empty(),\n                    encryptedBufAllocator,\n                    4096,\n                    maxTlsPacketSize,\n                    false /* plainData */,\n                    releaseBuffers));", "refactored_code": "  public static final int buffersInitialSize = 4096;\n                    \"inEncrypted\",\n                    Optional.empty(),\n                    encryptedBufAllocator,\n                    buffersInitialSize,\n                    maxTlsPacketSize,\n                    false /* plainData */,\n                    releaseBuffers));"}
{"magic_number_smell": "   * @return the required size\n   */\n  public static int getRequiredSize(ByteBuffer source) {\n    if (source.remaining() < 5) throw new BufferUnderflowException();\n    ((Buffer) source).mark();\n    try {\n      byte firstByte = source.get();", "refactored_code": "  public static final int RECORD_HEADER_SIZE = 5;\n   * @return the required size\n   */\n  public static int getRequiredSize(ByteBuffer source) {\n    if (source.remaining() < RECORD_HEADER_SIZE) throw new BufferUnderflowException();\n    ((Buffer) source).mark();\n    try {\n      byte firstByte = source.get();"}
{"magic_number_smell": "                new CommandReadOperation<>(\"admin\", failPointDocument, new BsonDocumentCodec())\n                        .execute(getBinding());\n            } catch (MongoCommandException e) {\n                if (e.getErrorCode() == 59) {\n                    failsPointsSupported = false;\n                }\n            }", "refactored_code": "    private static final int COMMAND_NOT_FOUND_ERROR_CODE = 59;\n                new CommandReadOperation<>(\"admin\", failPointDocument, new BsonDocumentCodec())\n                        .execute(getBinding());\n            } catch (MongoCommandException e) {\n                if (e.getErrorCode() == COMMAND_NOT_FOUND_ERROR_CODE) {\n                    failsPointsSupported = false;\n                }\n            }"}
{"magic_number_smell": "    @Override\n    public R get() {\n        try {\n            return future.get(1, TimeUnit.MINUTES);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(e);", "refactored_code": "    public static final long TIMEOUT_MINUTES = 1;\n    @Override\n    public R get() {\n        try {\n            return future.get(TIMEOUT_MINUTES, TimeUnit.MINUTES);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(e);"}
{"magic_number_smell": "                ConnectionPoolSettings.builder()\n                    .minSize(minSize)\n                    .maxSize(maxSize)\n                    .maxWaitTime(SECONDS.toMillis(5), MILLISECONDS)\n                    .maintenanceInitialDelay(0, NANOSECONDS)\n                    .maintenanceFrequency(100, MILLISECONDS)\n                    .maxConnectionLifeTime(limitConnectionLifeIdleTime ? 350 : 0, MILLISECONDS)", "refactored_code": "    private static final long TEST_WAIT_TIMEOUT_MILLIS = SECONDS.toMillis(5);\n                ConnectionPoolSettings.builder()\n                    .minSize(minSize)\n                    .maxSize(maxSize)\n                    .maxWaitTime(TEST_WAIT_TIMEOUT_MILLIS, MILLISECONDS)\n                    .maintenanceInitialDelay(0, NANOSECONDS)\n                    .maintenanceFrequency(100, MILLISECONDS)\n                    .maxConnectionLifeTime(limitConnectionLifeIdleTime ? 350 : 0, MILLISECONDS)"}
{"magic_number_smell": "    static Stream<Arguments> shouldThrowExceptionWhenProxySettingsAreInInvalid() {\n        return Stream.of(\n                Arguments.of(ProxySettings.builder()\n                        .port(1080), \"state should be: proxyPort can only be specified with proxyHost\"),\n                Arguments.of(ProxySettings.builder()\n                        .port(1080)\n                        .username(USERNAME)", "refactored_code": "    private static final int VALID_PORT = 1080;\n    static Stream<Arguments> shouldThrowExceptionWhenProxySettingsAreInInvalid() {\n        return Stream.of(\n                Arguments.of(ProxySettings.builder()\n                        .port(VALID_PORT), \"state should be: proxyPort can only be specified with proxyHost\"),\n                Arguments.of(ProxySettings.builder()\n                        .port(VALID_PORT)\n                        .username(USERNAME)"}
{"magic_number_smell": "                                   .ok(true)\n                                   .type(ServerType.REPLICA_SET_PRIMARY)\n                                   .tagSet(tags1)\n                                   .maxDocumentSize(4 * 1024 * 1024).build();\n\n        secondary = ServerDescription.builder().state(CONNECTED).address(new ServerAddress(HOST, 27018))\n                                     .roundTripTime(bestRoundTripTime * 1000000L, NANOSECONDS)", "refactored_code": "    private static final int FOUR_MEG = 4 * 1024 * 1024;\n                                   .ok(true)\n                                   .type(ServerType.REPLICA_SET_PRIMARY)\n                                   .tagSet(tags1)\n                                   .maxDocumentSize(FOUR_MEG).build();\n\n        secondary = ServerDescription.builder().state(CONNECTED).address(new ServerAddress(HOST, 27018))\n                                     .roundTripTime(bestRoundTripTime * 1000000L, NANOSECONDS)"}
{"magic_number_smell": "        }\n\n        public boolean isWithinDepthLimit() {\n            return invocationOptionSequence.size() < 50;\n        }\n    }\n}", "refactored_code": "        public static final int DEPTH_LIMIT = 50;\n        }\n\n        public boolean isWithinDepthLimit() {\n            return invocationOptionSequence.size() < DEPTH_LIMIT;\n        }\n    }\n}"}
{"magic_number_smell": "                        new ServerAddress(expectedAddress), actualAddress);\n            }\n        } else if (expectedEvent.containsKey(addressKey)) {\n            assertEquals(\"Unsupported value\", 42, expectedEvent.getInt32(addressKey).intValue());\n        }\n    }\n", "refactored_code": "    private static final int ANY_INT = 42;\n                        new ServerAddress(expectedAddress), actualAddress);\n            }\n        } else if (expectedEvent.containsKey(addressKey)) {\n            assertEquals(\"Unsupported value\", ANY_INT, expectedEvent.getInt32(addressKey).intValue());\n        }\n    }\n"}
{"magic_number_smell": "    }\n\n    public static class TopLevelDBObject extends BasicDBObject {\n        private static final long 3352369936048544621L = 7029929727222305692L;\n    }\n\n    public static class NestedOneDBObject extends BasicDBObject {", "refactored_code": "        private static final long serialVersionUID = 3352369936048544621L;\n    }\n\n    public static class TopLevelDBObject extends BasicDBObject {\n        private static final long serialVersionUID = 7029929727222305692L;\n    }\n\n    public static class NestedOneDBObject extends BasicDBObject {"}
{"magic_number_smell": "    @Before\n    public void setUp() {\n        super.setUp();\n        for (int i = 0; i < 10; i++) {\n            collection.insert(new BasicDBObject(\"_id\", i).append(\"x\", i));\n        }\n        collection.createIndex(new BasicDBObject(\"x\", 1));", "refactored_code": "    private static final int NUMBER_OF_DOCUMENTS = 10;\n    @Before\n    public void setUp() {\n        super.setUp();\n        for (int i = 0; i < NUMBER_OF_DOCUMENTS; i++) {\n            collection.insert(new BasicDBObject(\"_id\", i).append(\"x\", i));\n        }\n        collection.createIndex(new BasicDBObject(\"x\", 1));"}
{"magic_number_smell": "    }\n\n    public static class NestedOneDBObject extends BasicDBObject {\n        private static final long 7029929727222305692L = -5821458746671670383L;\n    }\n\n    public static class NestedTwoDBObject extends BasicDBObject {", "refactored_code": "        private static final long serialVersionUID = 7029929727222305692L;\n    }\n\n    public static class NestedOneDBObject extends BasicDBObject {\n        private static final long serialVersionUID = -5821458746671670383L;\n    }\n\n    public static class NestedTwoDBObject extends BasicDBObject {"}
{"magic_number_smell": "            BsonWriter writer = payload == null\n                    ? bsonBinaryWriter\n                    : new SplittablePayloadBsonWriter(bsonBinaryWriter, bsonOutput, createSplittablePayloadMessageSettings(), payload,\n                                                      2097152);\n\n            getEncoder(command).encode(writer, command, EncoderContext.builder().build());\n            crypt.encrypt(database, new RawBsonDocument(bsonOutput.getInternalBuffer(), 0, bsonOutput.getSize()))", "refactored_code": "    private static final int MAX_SPLITTABLE_DOCUMENT_SIZE = 2097152;\n            BsonWriter writer = payload == null\n                    ? bsonBinaryWriter\n                    : new SplittablePayloadBsonWriter(bsonBinaryWriter, bsonOutput, createSplittablePayloadMessageSettings(), payload,\n                                                      MAX_SPLITTABLE_DOCUMENT_SIZE);\n\n            getEncoder(command).encode(writer, command, EncoderContext.builder().build());\n            crypt.encrypt(database, new RawBsonDocument(bsonOutput.getInternalBuffer(), 0, bsonOutput.getSize()))"}
{"magic_number_smell": "    }\n\n    public GridFSBucketImpl(final MongoDatabase database, final String bucketName) {\n        this(notNull(\"bucketName\", bucketName), 255 * 1024,\n             getFilesCollection(notNull(\"database\", database), bucketName),\n             getChunksCollection(database, bucketName));\n    }", "refactored_code": "    private static final int DEFAULT_CHUNKSIZE_BYTES = 255 * 1024;\n    }\n\n    public GridFSBucketImpl(final MongoDatabase database, final String bucketName) {\n        this(notNull(\"bucketName\", bucketName), DEFAULT_CHUNKSIZE_BYTES,\n             getFilesCollection(notNull(\"database\", database), bucketName),\n             getChunksCollection(database, bucketName));\n    }"}
{"magic_number_smell": "    }\n\n    GridFSBucketImpl(final MongoDatabase database, final String bucketName) {\n        this(notNull(\"bucketName\", bucketName), 255 * 1024,\n                getFilesCollection(notNull(\"database\", database), bucketName),\n                getChunksCollection(database, bucketName));\n    }", "refactored_code": "    private static final int DEFAULT_CHUNKSIZE_BYTES = 255 * 1024;\n    }\n\n    GridFSBucketImpl(final MongoDatabase database, final String bucketName) {\n        this(notNull(\"bucketName\", bucketName), DEFAULT_CHUNKSIZE_BYTES,\n                getFilesCollection(notNull(\"database\", database), bucketName),\n                getChunksCollection(database, bucketName));\n    }"}
{"magic_number_smell": "                }\n                if (e instanceof MongoException) {\n                    if (((MongoException) e).hasErrorLabel(TRANSIENT_TRANSACTION_ERROR_LABEL)\n                            && ClientSessionClock.INSTANCE.now() - startTime < 120000) {\n                        continue;\n                    }\n                }", "refactored_code": "    private static final int MAX_RETRY_TIME_LIMIT_MS = 120000;\n                }\n                if (e instanceof MongoException) {\n                    if (((MongoException) e).hasErrorLabel(TRANSIENT_TRANSACTION_ERROR_LABEL)\n                            && ClientSessionClock.INSTANCE.now() - startTime < MAX_RETRY_TIME_LIMIT_MS) {\n                        continue;\n                    }\n                }"}
{"magic_number_smell": "        BsonWriter writer = payload == null\n                ? bsonBinaryWriter\n                : new SplittablePayloadBsonWriter(bsonBinaryWriter, bsonOutput, createSplittablePayloadMessageSettings(), payload,\n                2097152);\n\n        getEncoder(command).encode(writer, command, EncoderContext.builder().build());\n", "refactored_code": "    private static final int MAX_SPLITTABLE_DOCUMENT_SIZE = 2097152;\n        BsonWriter writer = payload == null\n                ? bsonBinaryWriter\n                : new SplittablePayloadBsonWriter(bsonBinaryWriter, bsonOutput, createSplittablePayloadMessageSettings(), payload,\n                MAX_SPLITTABLE_DOCUMENT_SIZE);\n\n        getEncoder(command).encode(writer, command, EncoderContext.builder().build());\n"}
{"magic_number_smell": "\n\n    private void assertIndexDeleted() throws InterruptedException {\n        int attempts = 70;\n        while (collection.listSearchIndexes().first() != null && checkAttempt(attempts--)) {\n            await();\n        }", "refactored_code": "    private static final int MAX_WAIT_ATTEMPTS = 70;\n\n\n    private void assertIndexDeleted() throws InterruptedException {\n        int attempts = MAX_WAIT_ATTEMPTS;\n        while (collection.listSearchIndexes().first() != null && checkAttempt(attempts--)) {\n            await();\n        }"}
{"magic_number_smell": "    private static MongoClientSettings.Builder getMongocryptdMongoClientSettingsBuilder() {\n        return MongoClientSettings.builder()\n                .applyToClusterSettings(builder ->\n                        builder.hosts(singletonList(new ServerAddress(\"localhost\", 47017))));\n    }\n\n    private static Process startMongocryptdProcess() throws IOException {", "refactored_code": "    private static final int MONGOCRYPTD_PORT = 47017;\n    private static MongoClientSettings.Builder getMongocryptdMongoClientSettingsBuilder() {\n        return MongoClientSettings.builder()\n                .applyToClusterSettings(builder ->\n                        builder.hosts(singletonList(new ServerAddress(\"localhost\", MONGOCRYPTD_PORT))));\n    }\n\n    private static Process startMongocryptdProcess() throws IOException {"}
{"magic_number_smell": "                })\n                .applyToServerSettings(builder12 -> {\n                    builder12.heartbeatFrequency(50, MILLISECONDS);\n                    builder12.minHeartbeatFrequency(50L, MILLISECONDS);\n                    builder12.addServerListener(serverListener);\n                });\n        if (clientOptions.containsKey(\"heartbeatFrequencyMS\")) {", "refactored_code": "    private static final long MIN_HEARTBEAT_FREQUENCY_MS = 50L;\n                })\n                .applyToServerSettings(builder12 -> {\n                    builder12.heartbeatFrequency(50, MILLISECONDS);\n                    builder12.minHeartbeatFrequency(MIN_HEARTBEAT_FREQUENCY_MS, MILLISECONDS);\n                    builder12.addServerListener(serverListener);\n                });\n        if (clientOptions.containsKey(\"heartbeatFrequencyMS\")) {"}
{"magic_number_smell": "                    socketSettingsBuilder.readTimeout(5, TimeUnit.MINUTES);\n                })\n                .applyToServerSettings(serverSettingsBuilder -> {\n                    serverSettingsBuilder.minHeartbeatFrequency(50L, TimeUnit.MILLISECONDS);\n                });\n        if (getServerApi() != null) {\n            builder.serverApi(getServerApi());", "refactored_code": "    private static final long MIN_HEARTBEAT_FREQUENCY_MS = 50L;\n                    socketSettingsBuilder.readTimeout(5, TimeUnit.MINUTES);\n                })\n                .applyToServerSettings(serverSettingsBuilder -> {\n                    serverSettingsBuilder.minHeartbeatFrequency(MIN_HEARTBEAT_FREQUENCY_MS, TimeUnit.MILLISECONDS);\n                });\n        if (getServerApi() != null) {\n            builder.serverApi(getServerApi());"}
{"magic_number_smell": "\n    private static void assertPoll(final BlockingQueue<?> queue, @Nullable final Class<?> allowed, final Set<Class<?>> required)\n            throws InterruptedException {\n        assertPoll(queue, allowed, required, Timeout.startNow(SECONDS.toMillis(5), MILLISECONDS));\n    }\n\n    private static void assertPoll(final BlockingQueue<?> queue, @Nullable final Class<?> allowed, final Set<Class<?>> required,", "refactored_code": "    private static final long TEST_WAIT_TIMEOUT_MILLIS = SECONDS.toMillis(5);\n\n    private static void assertPoll(final BlockingQueue<?> queue, @Nullable final Class<?> allowed, final Set<Class<?>> required)\n            throws InterruptedException {\n        assertPoll(queue, allowed, required, Timeout.startNow(TEST_WAIT_TIMEOUT_MILLIS, MILLISECONDS));\n    }\n\n    private static void assertPoll(final BlockingQueue<?> queue, @Nullable final Class<?> allowed, final Set<Class<?>> required,"}
{"magic_number_smell": "        } else {\n            format = uriPrefix + \"/?\" + uriParameters;\n        }\n        return new ConnectionString(format(format, Integer.parseInt(System.getProperty(\"org.mongodb.test.uri.proxyPort\"))));\n    }\n\n    private static MongoClientSettings buildMongoClientSettings(final ConnectionString connectionString) {", "refactored_code": "    private static final int PROXY_PORT = Integer.parseInt(System.getProperty(\"org.mongodb.test.uri.proxyPort\"));\n        } else {\n            format = uriPrefix + \"/?\" + uriParameters;\n        }\n        return new ConnectionString(format(format, PROXY_PORT));\n    }\n\n    private static MongoClientSettings buildMongoClientSettings(final ConnectionString connectionString) {"}
{"magic_number_smell": "        final String errorMessage = \"transient transaction error\";\n\n        try (ClientSession session = client.startSession()) {\n            ClientSessionClock.INSTANCE.setTime(1L);\n            session.withTransaction((TransactionBody<Void>) () -> {\n                ClientSessionClock.INSTANCE.setTime(ERROR_GENERATING_INTERVAL);\n                MongoException e = new MongoException(112, errorMessage);", "refactored_code": "    private static final long START_TIME_MS = 1L;\n        final String errorMessage = \"transient transaction error\";\n\n        try (ClientSession session = client.startSession()) {\n            ClientSessionClock.INSTANCE.setTime(START_TIME_MS);\n            session.withTransaction((TransactionBody<Void>) () -> {\n                ClientSessionClock.INSTANCE.setTime(ERROR_GENERATING_INTERVAL);\n                MongoException e = new MongoException(112, errorMessage);"}
{"magic_number_smell": "\tprivate void hideAndShowSoftKeyboard() {\n\t\tonView(withId(R.id.console_flip)).perform(closeSoftKeyboard());\n\t\tonView(withContentDescription(R.string.image_description_show_keyboard)).perform(click());\n\t\tonView(withId(R.id.console_flip)).perform(loopMainThreadFor(1000L));\n\t\tonView(withContentDescription(R.string.image_description_hide_keyboard)).perform(click());\n\t\tonView(withId(R.id.console_flip)).perform(loopMainThreadFor(1000L));\n\t\tonView(withContentDescription(R.string.image_description_show_keyboard)).perform(click());", "refactored_code": "\tprivate static final long KEYBOARD_DISMISSAL_DELAY_MILLIS = 1000L;\n\tprivate void hideAndShowSoftKeyboard() {\n\t\tonView(withId(R.id.console_flip)).perform(closeSoftKeyboard());\n\t\tonView(withContentDescription(R.string.image_description_show_keyboard)).perform(click());\n\t\tonView(withId(R.id.console_flip)).perform(loopMainThreadFor(KEYBOARD_DISMISSAL_DELAY_MILLIS));\n\t\tonView(withContentDescription(R.string.image_description_hide_keyboard)).perform(click());\n\t\tonView(withId(R.id.console_flip)).perform(loopMainThreadFor(KEYBOARD_DISMISSAL_DELAY_MILLIS));\n\t\tonView(withContentDescription(R.string.image_description_show_keyboard)).perform(click());"}
{"magic_number_smell": "\t\tint max = precompositions.length - 1;\n\t\tint mid;\n\n\t\tlong sought = base << 21 | comb;\n\t\tlong that;\n\n\t\twhile (max >= min) {", "refactored_code": "\tprivate static final int UNICODE_SHIFT = 21;\n\t\tint max = precompositions.length - 1;\n\t\tint mid;\n\n\t\tlong sought = base << UNICODE_SHIFT | comb;\n\t\tlong that;\n\n\t\twhile (max >= min) {"}
{"magic_number_smell": "\t\t@Override\n\t\tpublic void getItemOffsets(Rect outRect, View view, RecyclerView parent,\n\t\t\t\tRecyclerView.State state) {\n\t\t\tint top = parent.getChildAdapterPosition(view) == 0 ? 8 : 0;\n\t\t\toutRect.set(0, top, 0, mDivider.getIntrinsicHeight());\n\t\t}\n\t}", "refactored_code": "\t\tprivate final int TOP_LIST_OFFSET = 8;\n\t\t@Override\n\t\tpublic void getItemOffsets(Rect outRect, View view, RecyclerView parent,\n\t\t\t\tRecyclerView.State state) {\n\t\t\tint top = parent.getChildAdapterPosition(view) == 0 ? TOP_LIST_OFFSET : 0;\n\t\t\toutRect.set(0, top, 0, mDivider.getIntrinsicHeight());\n\t\t}\n\t}"}
{"magic_number_smell": "\n\t\t\tmTextPaint = new Paint();\n\t\t\tmTextPaint.setAntiAlias(true);\n\t\t\tmTextPaint.setTextSize((int) (metrics.density * 20f + 0.5f));\n\t\t\tmTextPaint.setColor(0xFFFFFFFF);\n\t\t\tmTextPaint.setTextAlign(Paint.Align.CENTER);\n", "refactored_code": "\t\tprivate static final float FONT_SIZE_DP = 20f;\n\n\t\t\tmTextPaint = new Paint();\n\t\t\tmTextPaint.setAntiAlias(true);\n\t\t\tmTextPaint.setTextSize((int) (metrics.density * FONT_SIZE_DP + 0.5f));\n\t\t\tmTextPaint.setColor(0xFFFFFFFF);\n\t\t\tmTextPaint.setTextAlign(Paint.Align.CENTER);\n"}
{"magic_number_smell": "\n\t\t\t\tIntent intent = new Intent(ConsoleActivity.this, PortForwardListActivity.class);\n\t\t\t\tintent.putExtra(Intent.EXTRA_TITLE, bridge.host.getId());\n\t\t\t\tConsoleActivity.this.startActivityForResult(intent, 1);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});", "refactored_code": "\tprotected static final int REQUEST_EDIT = 1;\n\n\t\t\t\tIntent intent = new Intent(ConsoleActivity.this, PortForwardListActivity.class);\n\t\t\t\tintent.putExtra(Intent.EXTRA_TITLE, bridge.host.getId());\n\t\t\t\tConsoleActivity.this.startActivityForResult(intent, REQUEST_EDIT);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});"}
{"magic_number_smell": "\t}\n\n\tpublic static Intent createIntentForNewHost(Context context) {\n\t\treturn createIntentForExistingHost(context, -1);\n\t}\n\n\t@Override", "refactored_code": "\tprivate static final long NO_HOST_ID = -1;\n\t}\n\n\tpublic static Intent createIntentForNewHost(Context context) {\n\t\treturn createIntentForExistingHost(context, NO_HOST_ID);\n\t}\n\n\t@Override"}
{"magic_number_smell": "\t\tmFontSizeSeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {\n\t\t\t@Override\n\t\t\tpublic void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {\n\t\t\t\tsetFontSize(8 + progress);\n\t\t\t}\n\n\t\t\t@Override", "refactored_code": "\tprivate static final int MINIMUM_FONT_SIZE = 8;\n\t\tmFontSizeSeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {\n\t\t\t@Override\n\t\t\tpublic void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {\n\t\t\t\tsetFontSize(MINIMUM_FONT_SIZE + progress);\n\t\t\t}\n\n\t\t\t@Override"}
{"magic_number_smell": "\t\t\t\t\t\t\t\t\t\t\t\t\thostBridge.enablePortForward(portForward);\n\t\t\t\t\t\t\t\t\t\t\t\t\tupdateHandler.sendEmptyMessage(-1);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}, 500);\n\n\n\t\t\t\t\t\t\t\t\t\tif (!hostdb.savePortForward(portForward)) {", "refactored_code": "\tprivate static final int LISTENER_CYCLE_TIME = 500;\n\t\t\t\t\t\t\t\t\t\t\t\t\thostBridge.enablePortForward(portForward);\n\t\t\t\t\t\t\t\t\t\t\t\t\tupdateHandler.sendEmptyMessage(-1);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}, LISTENER_CYCLE_TIME);\n\n\n\t\t\t\t\t\t\t\t\t\tif (!hostdb.savePortForward(portForward)) {"}
{"magic_number_smell": "\t\tbyte[] keyData;\n\t\ttry {\n\t\t\tContentResolver resolver = getContentResolver();\n\t\t\tkeyData = getBytesFromInputStream(resolver.openInputStream(uri), 32768);\n\t\t} catch (IOException e) {\n\t\t\tToast.makeText(PubkeyListActivity.this,\n\t\t\t\t\tR.string.pubkey_import_parse_problem,", "refactored_code": "\tprivate static final int MAX_KEYFILE_SIZE = 32768;\n\t\tbyte[] keyData;\n\t\ttry {\n\t\t\tContentResolver resolver = getContentResolver();\n\t\t\tkeyData = getBytesFromInputStream(resolver.openInputStream(uri), MAX_KEYFILE_SIZE);\n\t\t} catch (IOException e) {\n\t\t\tToast.makeText(PubkeyListActivity.this,\n\t\t\t\t\tR.string.pubkey_import_parse_problem,"}
{"magic_number_smell": "\t\t\t\t\tmEventSender = new AccessibilityEventSender();\n\t\t\t\t}\n\n\t\t\t\tpostDelayed(mEventSender, 1000);\n\t\t\t}\n\t\t}\n", "refactored_code": "\tprivate static final int ACCESSIBILITY_EVENT_THRESHOLD = 1000;\n\t\t\t\t\tmEventSender = new AccessibilityEventSender();\n\t\t\t\t}\n\n\t\t\t\tpostDelayed(mEventSender, ACCESSIBILITY_EVENT_THRESHOLD);\n\t\t\t}\n\t\t}\n"}
{"magic_number_smell": "\tprivate long pubkeyId = HostDatabase.PUBKEYID_ANY;\n\tprivate boolean wantSession = true;\n\tprivate String delKey = HostDatabase.DELKEY_DEL;\n\tprivate int fontSize = 10;\n\tprivate boolean compression = false;\n\tprivate String encoding = HostDatabase.ENCODING_DEFAULT;\n\tprivate boolean stayConnected = false;", "refactored_code": "\tpublic static final int DEFAULT_FONT_SIZE = 10;\n\tprivate long pubkeyId = HostDatabase.PUBKEYID_ANY;\n\tprivate boolean wantSession = true;\n\tprivate String delKey = HostDatabase.DELKEY_DEL;\n\tprivate int fontSize = DEFAULT_FONT_SIZE;\n\tprivate boolean compression = false;\n\tprivate String encoding = HostDatabase.ENCODING_DEFAULT;\n\tprivate boolean stayConnected = false;"}
{"magic_number_smell": "\t\tbuilder.setOngoing(true);\n\t\tbuilder.setWhen(0);\n\n\t\tbuilder.setContentIntent(PendingIntent.getActivity(context, 1, new Intent(context, ConsoleActivity.class), pendingIntentFlags));\n\n\t\tResources res = context.getResources();\n\t\tbuilder.setContentTitle(res.getString(R.string.app_name));", "refactored_code": "\tprivate static final int ONLINE_NOTIFICATION = 1;\n\t\tbuilder.setOngoing(true);\n\t\tbuilder.setWhen(0);\n\n\t\tbuilder.setContentIntent(PendingIntent.getActivity(context, ONLINE_NOTIFICATION, new Intent(context, ConsoleActivity.class), pendingIntentFlags));\n\n\t\tResources res = context.getResources();\n\t\tbuilder.setContentTitle(res.getString(R.string.app_name));"}
{"magic_number_smell": "\n\t@Override\n\tpublic void run() {\n\t\tbyteBuffer = ByteBuffer.allocate(4096);\n\t\tcharBuffer = CharBuffer.allocate(4096);\n\n\t\t/* for East Asian character widths */", "refactored_code": "\tprivate static final int BUFFER_SIZE = 4096;\n\n\t@Override\n\tpublic void run() {\n\t\tbyteBuffer = ByteBuffer.allocate(BUFFER_SIZE);\n\t\tcharBuffer = CharBuffer.allocate(BUFFER_SIZE);\n\n\t\t/* for East Asian character widths */"}
{"magic_number_smell": "\t\t\t\tif (idleTimer == null)\n\t\t\t\t\tidleTimer = new Timer(\"idleTimer\", true);\n\n\t\t\t\tidleTimer.schedule(new IdleTask(), 300000);\n\t\t\t}\n\t\t} else {\n\t\t\tLog.d(TAG, \"Stopping service immediately\");", "refactored_code": "\tprivate final long IDLE_TIMEOUT = 300000; // 5 minutes\n\t\t\t\tif (idleTimer == null)\n\t\t\t\t\tidleTimer = new Timer(\"idleTimer\", true);\n\n\t\t\t\tidleTimer.schedule(new IdleTask(), IDLE_TIMEOUT);\n\t\t\t}\n\t\t} else {\n\t\t\tLog.d(TAG, \"Stopping service immediately\");"}
{"magic_number_smell": "\n\t@Override\n\tpublic int getDefaultPort() {\n\t\treturn 22;\n\t}\n\n\t@Override", "refactored_code": "\tprivate static final int DEFAULT_PORT = 22;\n\n\t@Override\n\tpublic int getDefaultPort() {\n\t\treturn DEFAULT_PORT;\n\t}\n\n\t@Override"}
{"magic_number_smell": "\n\t@Override\n\tpublic int getDefaultPort() {\n\t\treturn 23;\n\t}\n\n\t@Override", "refactored_code": "\tprivate static final int DEFAULT_PORT = 23;\n\n\t@Override\n\tpublic int getDefaultPort() {\n\t\treturn DEFAULT_PORT;\n\t}\n\n\t@Override"}
{"magic_number_smell": "\t\tmPaint.setColor(Color.WHITE);\n\t\tmFontMetrics = mPaint.getFontMetrics();\n\n\t\tmEntropy = new byte[20];\n\t\tmEntropyByteIndex = 0;\n\t\tmEntropyBitIndex = 0;\n", "refactored_code": "\tpublic static final int SHA1_MAX_BYTES = 20;\n\t\tmPaint.setColor(Color.WHITE);\n\t\tmFontMetrics = mPaint.getFontMetrics();\n\n\t\tmEntropy = new byte[SHA1_MAX_BYTES];\n\t\tmEntropyByteIndex = 0;\n\t\tmEntropyBitIndex = 0;\n"}
{"magic_number_smell": "\n\t@Override\n\tpublic void setGlobalColor(int number, int value) {\n\t\tsetColorForScheme(0, number, value);\n\t}\n\n\t@Override", "refactored_code": "\tpublic static final int DEFAULT_COLOR_SCHEME = 0;\n\n\t@Override\n\tpublic void setGlobalColor(int number, int value) {\n\t\tsetColorForScheme(DEFAULT_COLOR_SCHEME, number, value);\n\t}\n\n\t@Override"}
{"magic_number_smell": "\t}\n\n\tprivate static byte[] encrypt(byte[] cleartext, String secret) throws Exception {\n\t\tbyte[] salt = new byte[8];\n\n\t\tbyte[] ciphertext = Encryptor.encrypt(salt, ITERATIONS, secret, cleartext);\n", "refactored_code": "\tprivate static final int SALT_SIZE = 8;\n\t}\n\n\tprivate static byte[] encrypt(byte[] cleartext, String secret) throws Exception {\n\t\tbyte[] salt = new byte[SALT_SIZE];\n\n\t\tbyte[] ciphertext = Encryptor.encrypt(salt, ITERATIONS, secret, cleartext);\n"}
{"magic_number_smell": "\n\t\t\tmenu.clear();\n\n\t\t\tmenu.add(0, 0, 0, R.string.console_menu_copy)\n\t\t\t\t\t.setIcon(R.drawable.ic_action_copy)\n\t\t\t\t\t.setShowAsAction(MenuItem.SHOW_AS_ACTION_WITH_TEXT | MenuItem.SHOW_AS_ACTION_IF_ROOM);\n\t\t\tmenu.add(0, PASTE, 1, R.string.console_menu_paste)", "refactored_code": "\t\tprivate static final int COPY = 0;\n\n\t\t\tmenu.clear();\n\n\t\t\tmenu.add(0, COPY, 0, R.string.console_menu_copy)\n\t\t\t\t\t.setIcon(R.drawable.ic_action_copy)\n\t\t\t\t\t.setShowAsAction(MenuItem.SHOW_AS_ACTION_WITH_TEXT | MenuItem.SHOW_AS_ACTION_IF_ROOM);\n\t\t\tmenu.add(0, PASTE, 1, R.string.console_menu_paste)"}
{"magic_number_smell": "\t\tprivate static final int SWATCH_WIDTH_LANDSCAPE_DP = 110;\n\t\tprivate static final int SWATCH_HEIGHT_DP = 60;\n\n\t\tprivate static final int PALETTE_DIM_DP = 95 * 2;\n\n\t\tprivate static final int SLIDER_THICKNESS_DP = 40;\n", "refactored_code": "\t\tprivate static final int SWATCH_WIDTH_PORTRAIT_DP = 95;\n\t\tprivate static final int SWATCH_WIDTH_LANDSCAPE_DP = 110;\n\t\tprivate static final int SWATCH_HEIGHT_DP = 60;\n\n\t\tprivate static final int PALETTE_DIM_DP = SWATCH_WIDTH_PORTRAIT_DP * 2;\n\n\t\tprivate static final int SLIDER_THICKNESS_DP = 40;\n"}
{"magic_number_smell": "\tpublic void checkMovement() {\n\t\tSelectionArea sa = new SelectionArea();\n\n\t\tsa.setBounds(80, HEIGHT);\n\n\t\tsa.incrementColumn();\n", "refactored_code": "\tprivate static final int WIDTH = 80;\n\tpublic void checkMovement() {\n\t\tSelectionArea sa = new SelectionArea();\n\n\t\tsa.setBounds(WIDTH, HEIGHT);\n\n\t\tsa.incrementColumn();\n"}
{"magic_number_smell": "\tprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n\t\tsuper.onActivityResult(requestCode, resultCode, data);\n\t\t\n\t\tif (resultCode == 0) {\n\t\t\tfinish();\n\t\t}\n\t}", "refactored_code": "\tpublic static final int EXIT_NORMAL = 0;\n\tprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n\t\tsuper.onActivityResult(requestCode, resultCode, data);\n\t\t\n\t\tif (resultCode == EXIT_NORMAL) {\n\t\t\tfinish();\n\t\t}\n\t}"}
{"magic_number_smell": "\t\tif ( mEntry.getUsername().length() > 0 ) {\n\t\t\t// only show notification if username is available\n\t\t\tNotification username = getNotification(Intents.COPY_USERNAME, R.string.copy_username);\n\t\t\tmNM.notify(1, username);\n\t\t}\n\t\t\t\n\t\tmIntentReceiver = new BroadcastReceiver() {", "refactored_code": "\tpublic static final int NOTIFY_USERNAME = 1;\n\t\tif ( mEntry.getUsername().length() > 0 ) {\n\t\t\t// only show notification if username is available\n\t\t\tNotification username = getNotification(Intents.COPY_USERNAME, R.string.copy_username);\n\t\t\tmNM.notify(NOTIFY_USERNAME, username);\n\t\t}\n\t\t\t\n\t\tmIntentReceiver = new BroadcastReceiver() {"}
{"magic_number_smell": "\tpublic static final String KEY_PARENT = \"parent\";\n\n\tpublic static final int 1000 = 1000;\n\tpublic static final int RESULT_OK_PASSWORD_GENERATOR = 1000 + 1;\n\n\tprotected PwEntry mEntry;\n\tprivate boolean mShowPassword = false;", "refactored_code": "\tpublic static final int RESULT_OK_ICON_PICKER = 1000;\n\tpublic static final String KEY_PARENT = \"parent\";\n\n\tpublic static final int RESULT_OK_ICON_PICKER = 1000;\n\tpublic static final int RESULT_OK_PASSWORD_GENERATOR = RESULT_OK_ICON_PICKER + 1;\n\n\tprotected PwEntry mEntry;\n\tprivate boolean mShowPassword = false;"}
{"magic_number_smell": "        VariantDictionary d = new VariantDictionary();\n\n        int version = lis.readUShort();\n        if ((version & VdmCritical) > (0x0100 & VdmCritical)) {\n            throw new IOException(\"Invalid format\");\n        }\n", "refactored_code": "    private static final int VdVersion = 0x0100;\n        VariantDictionary d = new VariantDictionary();\n\n        int version = lis.readUShort();\n        if ((version & VdmCritical) > (VdVersion & VdmCritical)) {\n            throw new IOException(\"Invalid format\");\n        }\n"}
{"magic_number_smell": "\n\t@Override\n\tprotected int engineGetBlockSize() {\n\t\treturn 16;\n\t}\n\n\t@Override", "refactored_code": "\tprivate final int AES_BLOCK_SIZE = 16;\n\n\t@Override\n\tprotected int engineGetBlockSize() {\n\t\treturn AES_BLOCK_SIZE;\n\t}\n\n\t@Override"}
{"magic_number_smell": "\tprivate byte[] cDate;\n\t\n\tpublic PwDate(byte[] buf, int offset) {\n\t\tcDate = new byte[5];\n\t\tSystem.arraycopy(buf, offset, cDate, 0, 5);\n\t\tcDateBuilt = true;\n\t}", "refactored_code": "\tprivate static final int DATE_SIZE = 5; \n\tprivate byte[] cDate;\n\t\n\tpublic PwDate(byte[] buf, int offset) {\n\t\tcDate = new byte[DATE_SIZE];\n\t\tSystem.arraycopy(buf, offset, cDate, 0, DATE_SIZE);\n\t\tcDateBuilt = true;\n\t}"}
{"magic_number_smell": "\tpublic byte transformSeed[] = new byte[32];\n\n\tpublic int              signature1;                  // = PWM_DBSIG_1\n\tpublic int              signature2;                  // = 0xB54BFB65\n\tpublic int              flags;\n\tpublic int              version;\n", "refactored_code": "\tpublic static final int DBSIG_2               = 0xB54BFB65;\n\tpublic byte transformSeed[] = new byte[32];\n\n\tpublic int              signature1;                  // = PWM_DBSIG_1\n\tpublic int              signature2;                  // = DBSIG_2\n\tpublic int              flags;\n\tpublic int              version;\n"}
{"magic_number_smell": "\t}\n\n\tpublic static boolean matchesHeader(int sig1, int sig2) {\n\t\treturn (sig1 == PWM_DBSIG_1) && ( (sig2 == 0xB54BFB66) || (sig2 == DBSIG_2) );\n\t}\n\n\tpublic static byte[] computeHeaderHmac(byte[] header, byte[] key) throws IOException{", "refactored_code": "\tpublic static final int DBSIG_PRE2            = 0xB54BFB66;\n\t}\n\n\tpublic static boolean matchesHeader(int sig1, int sig2) {\n\t\treturn (sig1 == PWM_DBSIG_1) && ( (sig2 == DBSIG_PRE2) || (sig2 == DBSIG_2) );\n\t}\n\n\tpublic static byte[] computeHeaderHmac(byte[] header, byte[] key) throws IOException{"}
{"magic_number_smell": "\t\tprivate static final long 0 = 0;\n\t\t\n\t\tpublic boolean enabled = true;\n\t\tpublic long obfuscationOptions = 0;\n\t\tpublic String defaultSequence = \"\";\n\t\t\n\t\tprivate HashMap<String, String> windowSeqPairs = new HashMap<String, String>();", "refactored_code": "\t\tprivate static final long OBF_OPT_NONE = 0;\n\t\tprivate static final long OBF_OPT_NONE = 0;\n\t\t\n\t\tpublic boolean enabled = true;\n\t\tpublic long obfuscationOptions = OBF_OPT_NONE;\n\t\tpublic String defaultSequence = \"\";\n\t\t\n\t\tprivate HashMap<String, String> windowSeqPairs = new HashMap<String, String>();"}
{"magic_number_smell": "\t\t\n\t\twhile (!found) {\n            switch (current) {\n            case 0:\n                found = sp.searchInTitles;\n                break;\n            ", "refactored_code": "\tprivate static final int title = 0;\n\t\t\n\t\twhile (!found) {\n            switch (current) {\n            case title:\n                found = sp.searchInTitles;\n                break;\n            "}
{"magic_number_smell": "\t\t\t\t// TODO: Add support to interpret the color if we want to allow changing the database color\n\t\t\t\tdb.color = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbMntncHistoryDays) ) {\n\t\t\t\tdb.maintenanceHistoryDays = ReadUInt(xpp, 365);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbKeyChanged) ) {\n\t\t\t\tdb.keyLastChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbKeyChangeRec) ) {", "refactored_code": "    private static final long DEFAULT_HISTORY_DAYS = 365;\n\t\t\t\t// TODO: Add support to interpret the color if we want to allow changing the database color\n\t\t\t\tdb.color = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbMntncHistoryDays) ) {\n\t\t\t\tdb.maintenanceHistoryDays = ReadUInt(xpp, DEFAULT_HISTORY_DAYS);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbKeyChanged) ) {\n\t\t\t\tdb.keyLastChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbKeyChangeRec) ) {"}
{"magic_number_smell": "\t\tprivate final Context mCtx;\n\t\t\n\t\tDatabaseHelper(Context ctx) {\n\t\t\tsuper(ctx, DATABASE_NAME, null, 1);\n\t\t\tmCtx = ctx;\n\t\t}\n", "refactored_code": "\tprivate static final int DATABASE_VERSION = 1;\n\t\tprivate final Context mCtx;\n\t\t\n\t\tDatabaseHelper(Context ctx) {\n\t\t\tsuper(ctx, DATABASE_NAME, null, DATABASE_VERSION);\n\t\t\tmCtx = ctx;\n\t\t}\n"}
{"magic_number_smell": "            ContextMenuInfo menuInfo) {\n        super.onCreateContextMenu(menu, v, menuInfo);\n        \n        menu.add(0, Menu.FIRST, 0, R.string.remove_from_filelist);\n    }\n\n    @Override", "refactored_code": "    private static final int CMENU_CLEAR = Menu.FIRST;\n            ContextMenuInfo menuInfo) {\n        super.onCreateContextMenu(menu, v, menuInfo);\n        \n        menu.add(0, CMENU_CLEAR, 0, R.string.remove_from_filelist);\n    }\n\n    @Override"}
{"magic_number_smell": "                activity.finish();\n                App.getDB().clear(activity.getApplicationContext());\n                break;\n            case 256:\n                if (resultCode == Activity.RESULT_OK) {\n                    String filename = data.getDataString();\n                    if (filename != null) {", "refactored_code": "    private static final int FILE_BROWSE = 256;\n                activity.finish();\n                App.getDB().clear(activity.getApplicationContext());\n                break;\n            case FILE_BROWSE:\n                if (resultCode == Activity.RESULT_OK) {\n                    String filename = data.getDataString();\n                    if (filename != null) {"}
{"magic_number_smell": "     *            the cipher to process the data with.\n     */\n    public BetterCipherInputStream(InputStream is, Cipher c) {\n    \tthis(is, c, 8 * 1024);\n    }\n\n    /**", "refactored_code": "    private static final int I_DEFAULT_BUFFER_SIZE = 8 * 1024;\n     *            the cipher to process the data with.\n     */\n    public BetterCipherInputStream(InputStream is, Cipher c) {\n    \tthis(is, c, I_DEFAULT_BUFFER_SIZE);\n    }\n\n    /**"}
{"magic_number_smell": "    private LEDataOutputStream baseStream;\n    private byte[] key;\n\n    private byte[] buffer = new byte[1024 * 1024];\n    private int bufferPos = 0;\n    private long blockIndex = 0;\n", "refactored_code": "    private static final int DEFAULT_BUFFER_SIZE = 1024 * 1024;\n    private LEDataOutputStream baseStream;\n    private byte[] key;\n\n    private byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];\n    private int bufferPos = 0;\n    private long blockIndex = 0;\n"}
{"magic_number_smell": "\t}\n\n\tpublic static long readUInt( byte buf[], int offset ) {\n\t\t  return (readInt(buf, offset) & 0xffffffffL);\n\t  }\n\n\tpublic static int readInt(InputStream is) throws IOException {", "refactored_code": "\tpublic static final long INT_TO_LONG_MASK = 0xffffffffL;\n\t}\n\n\tpublic static long readUInt( byte buf[], int offset ) {\n\t\t  return (readInt(buf, offset) & INT_TO_LONG_MASK);\n\t  }\n\n\tpublic static int readInt(InputStream is) throws IOException {"}
{"magic_number_smell": "\t\ttry {\n\t\t\ttimeout = Long.parseLong(sTimeout);\n\t\t} catch (NumberFormatException e) {\n\t\t\ttimeout = 5 * 60 * 1000;\n\t\t}\n\n\t\treturn timeout;", "refactored_code": "\tprivate static final long DEFAULT_TIMEOUT = 5 * 60 * 1000;  // 5 minutes\n\t\ttry {\n\t\t\ttimeout = Long.parseLong(sTimeout);\n\t\t} catch (NumberFormatException e) {\n\t\t\ttimeout = DEFAULT_TIMEOUT;\n\t\t}\n\n\t\treturn timeout;"}
{"magic_number_smell": "\t\tif (Build.VERSION.SDK_INT >= 23) {\n\t\t\tflags |= PendingIntent.FLAG_IMMUTABLE;\n\t\t}\n\t\tPendingIntent sender = PendingIntent.getBroadcast(ctx, 0, intent, flags);\n\n\t\treturn sender;\n\t}", "refactored_code": "\tprivate static final int REQUEST_ID = 0;\n\t\tif (Build.VERSION.SDK_INT >= 23) {\n\t\t\tflags |= PendingIntent.FLAG_IMMUTABLE;\n\t\t}\n\t\tPendingIntent sender = PendingIntent.getBroadcast(ctx, REQUEST_ID, intent, flags);\n\n\t\treturn sender;\n\t}"}
{"magic_number_smell": "\tprivate String compileInternal(String text, SprContextV4 ctx, int recursionLevel) {\n\t\tif (text == null) { return \"\"; }\n\t\tif (ctx == null) { return \"\"; }\n\t\tif (recursionLevel >= 12) { return \"\"; }\n\t\t\n\t\treturn fillRefPlaceholders(text, ctx, recursionLevel);\n\t}", "refactored_code": "\tprivate final int MAX_RECURSION_DEPTH = 12;\n\tprivate String compileInternal(String text, SprContextV4 ctx, int recursionLevel) {\n\t\tif (text == null) { return \"\"; }\n\t\tif (ctx == null) { return \"\"; }\n\t\tif (recursionLevel >= MAX_RECURSION_DEPTH) { return \"\"; }\n\t\t\n\t\treturn fillRefPlaceholders(text, ctx, recursionLevel);\n\t}"}
{"magic_number_smell": "\n\tprivate static final int 1024 = 1024;\n\tpublic static void copyStream(InputStream in, OutputStream out) throws IOException {\n\t\tbyte[] buf = new byte[1024];\n\t\tint read;\n\t\twhile ((read = in.read(buf)) != -1) {\n\t\t\tout.write(buf, 0, read);", "refactored_code": "\tprivate static final int MAX_BUF_SIZE = 1024;\n\n\tprivate static final int MAX_BUF_SIZE = 1024;\n\tpublic static void copyStream(InputStream in, OutputStream out) throws IOException {\n\t\tbyte[] buf = new byte[MAX_BUF_SIZE];\n\t\tint read;\n\t\twhile ((read = in.read(buf)) != -1) {\n\t\t\tout.write(buf, 0, read);"}
{"magic_number_smell": "\tprivate int mPos;\n\t\n\tprotected static final int Menu.FIRST = Menu.FIRST;\n\tprivate static final int MENU_DELETE = Menu.FIRST + 1;\n\t\n\tpublic static PwEntryView getInstance(GroupBaseActivity act, PwEntry pw, int pos) {\n\t\treturn new PwEntryView(act, pw, pos);", "refactored_code": "\tprotected static final int MENU_OPEN = Menu.FIRST;\n\tprivate int mPos;\n\t\n\tprotected static final int MENU_OPEN = Menu.FIRST;\n\tprivate static final int MENU_DELETE = MENU_OPEN + 1;\n\t\n\tpublic static PwEntryView getInstance(GroupBaseActivity act, PwEntry pw, int pos) {\n\t\treturn new PwEntryView(act, pw, pos);"}
{"magic_number_smell": "\n\t@Override\n\tpublic void onCreateMenu(ContextMenu menu, ContextMenuInfo menuInfo) {\n\t\tmenu.add(0, Menu.FIRST, 0, R.string.menu_open);\n\t}\n\n\t@Override", "refactored_code": "\tprotected static final int MENU_OPEN = Menu.FIRST;\n\n\t@Override\n\tpublic void onCreateMenu(ContextMenu menu, ContextMenuInfo menuInfo) {\n\t\tmenu.add(0, MENU_OPEN, 0, R.string.menu_open);\n\t}\n\n\t@Override"}
{"magic_number_smell": "\t\tsuper.onCreateMenu(menu, menuInfo);\n\t\t\n\t\tif (!readOnly) {\n\t\t    menu.add(0, MENU_OPEN + 1, 0, R.string.menu_delete);\n\t\t}\n\n\t}", "refactored_code": "\tprivate static final int MENU_DELETE = MENU_OPEN + 1;\n\t\tsuper.onCreateMenu(menu, menuInfo);\n\t\t\n\t\tif (!readOnly) {\n\t\t    menu.add(0, MENU_DELETE, 0, R.string.menu_delete);\n\t\t}\n\n\t}"}
{"magic_number_smell": "     * @throws NullPointerException if the map is null\n     */\n    protected AbstractHashedMap(Map map) {\n        this(Math.max(2 * map.size(), 16), DEFAULT_LOAD_FACTOR);\n        putAll(map);\n    }\n", "refactored_code": "    protected static final int DEFAULT_CAPACITY = 16;\n     * @throws NullPointerException if the map is null\n     */\n    protected AbstractHashedMap(Map map) {\n        this(Math.max(2 * map.size(), DEFAULT_CAPACITY), DEFAULT_LOAD_FACTOR);\n        putAll(map);\n    }\n"}
{"magic_number_smell": "    public static final int WEAK = 2;\n\n    /**\n     * The reference type for keys.  Must be 0, SOFT, WEAK.\n     * @serial\n     */\n    protected int keyType;", "refactored_code": "    public static final int HARD = 0;\n    public static final int WEAK = 2;\n\n    /**\n     * The reference type for keys.  Must be HARD, SOFT, WEAK.\n     * @serial\n     */\n    protected int keyType;"}
{"magic_number_smell": "\t\n\t@Before\n\tpublic void setup(){\n\t\trandomHashes = new String[1000000];\n\t\tRandom rand = new Random();\n\t\tfor(int i = 0; i < 1000000; i++){\n\t\t\t// at least two chars", "refactored_code": "\tprivate static final int NUMBER_OF_HASHES = 1000000;\n\t\n\t@Before\n\tpublic void setup(){\n\t\trandomHashes = new String[NUMBER_OF_HASHES];\n\t\tRandom rand = new Random();\n\t\tfor(int i = 0; i < NUMBER_OF_HASHES; i++){\n\t\t\t// at least two chars"}
{"magic_number_smell": "\n\t@Before\n\tpublic void setupBenchmark() {\n\t\thashes = new GeoHash[1000000];\n\t}\n\n\t@Benchmark(times = 10)", "refactored_code": "\tprivate static final int NUMBER_OF_HASHES = 1000000;\n\n\t@Before\n\tpublic void setupBenchmark() {\n\t\thashes = new GeoHash[NUMBER_OF_HASHES];\n\t}\n\n\t@Benchmark(times = 10)"}
{"magic_number_smell": "\t\tif (numberOfBits < 0) {\n\t\t\tthrow new IllegalArgumentException(\"A Geohash can't be of negative bits long!\");\n\t\t}\n\t\tif (numberOfBits > 64) {\n\t\t\tthrow new IllegalArgumentException(\"A Geohash can only be \" + 64 + \" bits long!\");\n\t\t}\n\t\tif (Math.abs(latitude) > 90.0 || Math.abs(longitude) > 180.0) {", "refactored_code": "\tpublic static final int MAX_BIT_PRECISION = 64;\n\t\tif (numberOfBits < 0) {\n\t\t\tthrow new IllegalArgumentException(\"A Geohash can't be of negative bits long!\");\n\t\t}\n\t\tif (numberOfBits > MAX_BIT_PRECISION) {\n\t\t\tthrow new IllegalArgumentException(\"A Geohash can only be \" + MAX_BIT_PRECISION + \" bits long!\");\n\t\t}\n\t\tif (Math.abs(latitude) > 90.0 || Math.abs(longitude) > 180.0) {"}
{"magic_number_smell": "\npublic class GeoHashSizeTable {\n\tprivate static final int 64 = 64;\n\tprivate static final double[] dLat = new double[64];\n\tprivate static final double[] dLon = new double[64];\n\n\tstatic {", "refactored_code": "\tprivate static final int NUM_BITS = 64;\n\npublic class GeoHashSizeTable {\n\tprivate static final int NUM_BITS = 64;\n\tprivate static final double[] dLat = new double[NUM_BITS];\n\tprivate static final double[] dLon = new double[NUM_BITS];\n\n\tstatic {"}
{"magic_number_smell": "\n\tpublic static final int commonPrefixLength(long a, long b) {\n\t\tint result = 0;\n\t\twhile (result < 64 && (a & 0x8000000000000000l) == (b & 0x8000000000000000l)) {\n\t\t\tresult++;\n\t\t\ta <<= 1;\n\t\t\tb <<= 1;", "refactored_code": "\tpublic static final long FIRST_BIT = 0x8000000000000000l;\n\n\tpublic static final int commonPrefixLength(long a, long b) {\n\t\tint result = 0;\n\t\twhile (result < 64 && (a & FIRST_BIT) == (b & FIRST_BIT)) {\n\t\t\tresult++;\n\t\t\ta <<= 1;\n\t\t\tb <<= 1;"}
{"magic_number_smell": "\n\t\tdouble a = 6378137, b = 6356752.3142, f = 1 / 298.257223563; // WGS-84\n\t\t// ellipsiod\n\t\tdouble alpha1 = bearingInDegrees * 0.0174532925199433;\n\t\tdouble sinAlpha1 = Math.sin(alpha1), cosAlpha1 = Math.cos(alpha1);\n\n\t\tdouble tanU1 = (1 - f) * Math.tan(point.getLatitude() * 0.0174532925199433);", "refactored_code": "\tpublic static final double degToRad = 0.0174532925199433;\n\n\t\tdouble a = 6378137, b = 6356752.3142, f = 1 / 298.257223563; // WGS-84\n\t\t// ellipsiod\n\t\tdouble alpha1 = bearingInDegrees * degToRad;\n\t\tdouble sinAlpha1 = Math.sin(alpha1), cosAlpha1 = Math.cos(alpha1);\n\n\t\tdouble tanU1 = (1 - f) * Math.tan(point.getLatitude() * degToRad);"}
{"magic_number_smell": "\t}\n\n\tprivate void assertWidthIs(BoundingBox bbox, double width) {\n\t\tassertEquals(width, bbox.getLongitudeSize(), 1e-12);\n\t}\n\n\tprivate void assertHeightIs(BoundingBox bbox, double height) {", "refactored_code": "\tprivate static final double DELTA = 1e-12;\n\t}\n\n\tprivate void assertWidthIs(BoundingBox bbox, double width) {\n\t\tassertEquals(width, bbox.getLongitudeSize(), DELTA);\n\t}\n\n\tprivate void assertHeightIs(BoundingBox bbox, double height) {"}
{"magic_number_smell": "\t\tint distanceInMeters = 10000;\n\t\tWGS84Point result = VincentyGeodesy.moveInDirection(startPoint, 120,\n\t\t\t\tdistanceInMeters);\n\t\tassertEquals(40.10134882, result.getLongitude(), 0.00001);\n\t\tassertEquals(39.9549245, result.getLatitude(), 0.00001);\n\n\t\tassertEquals(distanceInMeters, VincentyGeodesy.distanceInMeters(", "refactored_code": "\tprivate static final double DELTA = 0.00001;\n\t\tint distanceInMeters = 10000;\n\t\tWGS84Point result = VincentyGeodesy.moveInDirection(startPoint, 120,\n\t\t\t\tdistanceInMeters);\n\t\tassertEquals(40.10134882, result.getLongitude(), DELTA);\n\t\tassertEquals(39.9549245, result.getLatitude(), DELTA);\n\n\t\tassertEquals(distanceInMeters, VincentyGeodesy.distanceInMeters("}
{"magic_number_smell": "\t\t@Override\n\t\tpublic BoundingBox generate(int bits) {\n\t\t\t// make the bounding box a little smaller than dLat/dLon\n\t\t\tdouble dLat = GeoHashSizeTable.dLat(bits) - 1e-10;\n\t\t\tdouble dLon = GeoHashSizeTable.dLon(bits) - 1e-10;\n\t\t\treturn new BoundingBox(45 - dLat, 45, 30 - dLon, 30);\n\t\t}", "refactored_code": "\tprivate static final double DELTA = 1e-10;\n\t\t@Override\n\t\tpublic BoundingBox generate(int bits) {\n\t\t\t// make the bounding box a little smaller than dLat/dLon\n\t\t\tdouble dLat = GeoHashSizeTable.dLat(bits) - DELTA;\n\t\t\tdouble dLon = GeoHashSizeTable.dLon(bits) - DELTA;\n\t\t\treturn new BoundingBox(45 - dLat, 45, 30 - dLon, 30);\n\t\t}"}
{"magic_number_smell": "                break;\n            }\n            try {\n                Thread.sleep(30 * 1000);\n            } catch (InterruptedException ignored) {\n            }\n        } while (true);", "refactored_code": "    private static final int SECONDS = 1000;\n                break;\n            }\n            try {\n                Thread.sleep(30 * SECONDS);\n            } catch (InterruptedException ignored) {\n            }\n        } while (true);"}
{"magic_number_smell": "        public void paintIcon(Component component, Graphics g, int x, int y) {\n            g.setColor(color);\n            g.translate(x, y);\n            if (direction == 0) {\n                g.drawLine(3, 1, 3, 1);\n                g.drawLine(2, 2, 4, 2);\n                g.drawLine(1, 3, 5, 3);", "refactored_code": "        public static final int NORTH = 0;\n        public void paintIcon(Component component, Graphics g, int x, int y) {\n            g.setColor(color);\n            g.translate(x, y);\n            if (direction == NORTH) {\n                g.drawLine(3, 1, 3, 1);\n                g.drawLine(2, 2, 4, 2);\n                g.drawLine(1, 3, 5, 3);"}
{"magic_number_smell": "\n    public AnimationBar(final NodeBoxDocument document) {\n        super(new FlowLayout(FlowLayout.LEADING, 5, 0));\n        setPreferredSize(new Dimension(100, 27));\n        setMinimumSize(new Dimension(100, 27));\n        setMaximumSize(new Dimension(100, 27));\n", "refactored_code": "    private static final int ANIMATION_BAR_HEIGHT = 27;\n\n    public AnimationBar(final NodeBoxDocument document) {\n        super(new FlowLayout(FlowLayout.LEADING, 5, 0));\n        setPreferredSize(new Dimension(100, ANIMATION_BAR_HEIGHT));\n        setMinimumSize(new Dimension(100, ANIMATION_BAR_HEIGHT));\n        setMaximumSize(new Dimension(100, ANIMATION_BAR_HEIGHT));\n"}
{"magic_number_smell": "\n        public String objectToString(Object o) {\n            String s = o == null ? \"<null>\" : o.toString();\n            if (s.length() <= 100) {\n                return s;\n            } else {\n                return s.substring(0, 100) + \"...\";", "refactored_code": "        public static final int MAX_VALUE_LENGTH = 100;\n\n        public String objectToString(Object o) {\n            String s = o == null ? \"<null>\" : o.toString();\n            if (s.length() <= MAX_VALUE_LENGTH) {\n                return s;\n            } else {\n                return s.substring(0, MAX_VALUE_LENGTH) + \"...\";"}
{"magic_number_smell": "    public static final int 48 = 48;\n    public static final int NODE_MARGIN = 6;\n    public static final int NODE_PADDING = 5;\n    public static final int NODE_WIDTH = 48 * 3 - NODE_MARGIN * 2;\n    public static final int NODE_HEIGHT = 48 - NODE_MARGIN * 2;\n    public static final int NODE_ICON_SIZE = 26;\n    public static final int GRID_OFFSET = 6;", "refactored_code": "    public static final int GRID_CELL_SIZE = 48;\n    public static final int GRID_CELL_SIZE = 48;\n    public static final int NODE_MARGIN = 6;\n    public static final int NODE_PADDING = 5;\n    public static final int NODE_WIDTH = GRID_CELL_SIZE * 3 - NODE_MARGIN * 2;\n    public static final int NODE_HEIGHT = GRID_CELL_SIZE - NODE_MARGIN * 2;\n    public static final int NODE_ICON_SIZE = 26;\n    public static final int GRID_OFFSET = 6;"}
{"magic_number_smell": "        notesLabel = new JLabel(notes);\n        notesLabel.setFont(Theme.SMALL_FONT);\n        notesLabel.setForeground(Theme.TEXT_NORMAL_COLOR);\n        notesLabel.setBorder(BorderFactory.createEmptyBorder(2, 0, BOTTOM_PADDING, 0));\n\n        add(Box.createHorizontalStrut(PortView.LABEL_WIDTH + 10));\n        add(this.notesLabel);", "refactored_code": "    private static final int TOP_PADDING = 2;\n        notesLabel = new JLabel(notes);\n        notesLabel.setFont(Theme.SMALL_FONT);\n        notesLabel.setForeground(Theme.TEXT_NORMAL_COLOR);\n        notesLabel.setBorder(BorderFactory.createEmptyBorder(TOP_PADDING, 0, BOTTOM_PADDING, 0));\n\n        add(Box.createHorizontalStrut(PortView.LABEL_WIDTH + 10));\n        add(this.notesLabel);"}
{"magic_number_smell": "        label.setMinimumSize(labelSize);\n\n        this.control = control;\n        control.setBorder(BorderFactory.createEmptyBorder(2, 0, BOTTOM_PADDING, 0));\n\n        popupMenu = new JPopupMenu();\n        popupMenu.add(new RevertToDefaultAction());", "refactored_code": "    private static final int TOP_PADDING = 2;\n        label.setMinimumSize(labelSize);\n\n        this.control = control;\n        control.setBorder(BorderFactory.createEmptyBorder(TOP_PADDING, 0, BOTTOM_PADDING, 0));\n\n        popupMenu = new JPopupMenu();\n        popupMenu.add(new RevertToDefaultAction());"}
{"magic_number_smell": "                int height = getHeight();\n                int width = getWidth();\n                g.setColor(Theme.PORT_LABEL_BACKGROUND);\n                g.fillRect(0, 0, 114 - 3, height);\n                g.setColor(new Color(146, 146, 146));\n                g.fillRect(114 - 3, 0, 1, height);\n                g.setColor(new Color(133, 133, 133));", "refactored_code": "    public static final int LABEL_WIDTH = 114;\n                int height = getHeight();\n                int width = getWidth();\n                g.setColor(Theme.PORT_LABEL_BACKGROUND);\n                g.fillRect(0, 0, LABEL_WIDTH - 3, height);\n                g.setColor(new Color(146, 146, 146));\n                g.fillRect(LABEL_WIDTH - 3, 0, 1, height);\n                g.setColor(new Color(133, 133, 133));"}
{"magic_number_smell": "    private final JButton stopButton;\n\n    public ProgressPanel(final NodeBoxDocument document) {\n        setMinimumSize(new Dimension(0, AddressBar.ADDRESS_BAR_HEIGHT));\n        setMaximumSize(new Dimension(PROGRESS_PANEL_WIDTH, AddressBar.ADDRESS_BAR_HEIGHT));\n        setPreferredSize(new Dimension(PROGRESS_PANEL_WIDTH, AddressBar.ADDRESS_BAR_HEIGHT));\n        setLayout(new FlowLayout(FlowLayout.LEADING, 0, 0));", "refactored_code": "    private static final int PROGRESS_PANEL_HEIGHT = AddressBar.ADDRESS_BAR_HEIGHT;\n    private final JButton stopButton;\n\n    public ProgressPanel(final NodeBoxDocument document) {\n        setMinimumSize(new Dimension(0, PROGRESS_PANEL_HEIGHT));\n        setMaximumSize(new Dimension(PROGRESS_PANEL_WIDTH, PROGRESS_PANEL_HEIGHT));\n        setPreferredSize(new Dimension(PROGRESS_PANEL_WIDTH, PROGRESS_PANEL_HEIGHT));\n        setLayout(new FlowLayout(FlowLayout.LEADING, 0, 0));"}
{"magic_number_smell": "    private Visualizer currentVisualizer = VisualizerFactory.getDefaultVisualizer();\n\n    public Viewer() {\n        super(0.01, MAX_ZOOM);\n        addMouseListener(this);\n        addMouseMotionListener(this);\n        setFocusable(true);", "refactored_code": "    public static final double MIN_ZOOM = 0.01;\n    private Visualizer currentVisualizer = VisualizerFactory.getDefaultVisualizer();\n\n    public Viewer() {\n        super(MIN_ZOOM, MAX_ZOOM);\n        addMouseListener(this);\n        addMouseMotionListener(this);\n        setFocusable(true);"}
{"magic_number_smell": "    private static final int 30 = 30;\n    public static final int COLOR_MARGIN = 10;\n    public static final int MAX_WIDTH = 500;\n    public static final int COLORS_PER_ROW = (MAX_WIDTH / (30 + COLOR_MARGIN)) + 1;\n    private static final int COLOR_TOTAL_SIZE = 30 + COLOR_MARGIN;\n\n    private ColorVisualizer() {", "refactored_code": "    private static final int COLOR_SIZE = 30;\n    private static final int COLOR_SIZE = 30;\n    public static final int COLOR_MARGIN = 10;\n    public static final int MAX_WIDTH = 500;\n    public static final int COLORS_PER_ROW = (MAX_WIDTH / (COLOR_SIZE + COLOR_MARGIN)) + 1;\n    private static final int COLOR_TOTAL_SIZE = COLOR_SIZE + COLOR_MARGIN;\n\n    private ColorVisualizer() {"}
{"magic_number_smell": "        GeneralPath onCurves = new GeneralPath();\n        GeneralPath offCurves = new GeneralPath();\n        for (Point point : points) {\n            Shape s = new Ellipse2D.Double(point.x - 2, point.y - 2, POINT_SIZE, POINT_SIZE);\n            if (point.isOnCurve()) {\n                onCurves.append(s, false);\n            } else {", "refactored_code": "    public static final double HALF_POINT_SIZE = 2;\n        GeneralPath onCurves = new GeneralPath();\n        GeneralPath offCurves = new GeneralPath();\n        for (Point point : points) {\n            Shape s = new Ellipse2D.Double(point.x - HALF_POINT_SIZE, point.y - HALF_POINT_SIZE, POINT_SIZE, POINT_SIZE);\n            if (point.isOnCurve()) {\n                onCurves.append(s, false);\n            } else {"}
{"magic_number_smell": "    private ArrayList<Grob> items = new ArrayList<Grob>();\n\n    public Canvas() {\n        this(1000, DEFAULT_HEIGHT);\n    }\n\n    public Canvas(double width, double height) {", "refactored_code": "    public static final double DEFAULT_WIDTH = 1000;\n    private ArrayList<Grob> items = new ArrayList<Grob>();\n\n    public Canvas() {\n        this(DEFAULT_WIDTH, DEFAULT_HEIGHT);\n    }\n\n    public Canvas(double width, double height) {"}
{"magic_number_smell": "    //// Initialization ////\n\n    public CanvasContext() {\n        canvas = new Canvas(1000, DEFAULT_HEIGHT);\n        resetContext(true);\n    }\n", "refactored_code": "    public static final double DEFAULT_WIDTH = 1000;\n    //// Initialization ////\n\n    public CanvasContext() {\n        canvas = new Canvas(DEFAULT_WIDTH, DEFAULT_HEIGHT);\n        resetContext(true);\n    }\n"}
{"magic_number_smell": "                double length = Path.curveLength(pt0.x, pt0.y,\n                        c1.x, c1.y,\n                        c2.x, c2.y,\n                        pt.x, pt.y, 20);\n                segmentLengths.add(length);\n                totalLength += length;\n            }", "refactored_code": "    private static final int SEGMENT_ACCURACY = 20;\n                double length = Path.curveLength(pt0.x, pt0.y,\n                        c1.x, c1.y,\n                        c2.x, c2.y,\n                        pt.x, pt.y, SEGMENT_ACCURACY);\n                segmentLengths.add(length);\n                totalLength += length;\n            }"}
{"magic_number_smell": "        moveto(left + dx, top);\n        if (dx < width * 0.5)\n            lineto(right - rx, top);\n        curveto(right - dx * 1.0 - 0.552, top, right, top + dy * 1.0 - 0.552, right, top + dy);\n        if (dy < height * 0.5)\n            lineto(right, bottom - dy);\n        curveto(right, bottom - dy * 1.0 - 0.552, right - dx * 1.0 - 0.552, bottom, right - dx, bottom);", "refactored_code": "    private static final double ONE_MINUS_QUARTER = 1.0 - 0.552;\n        moveto(left + dx, top);\n        if (dx < width * 0.5)\n            lineto(right - rx, top);\n        curveto(right - dx * ONE_MINUS_QUARTER, top, right, top + dy * ONE_MINUS_QUARTER, right, top + dy);\n        if (dy < height * 0.5)\n            lineto(right, bottom - dy);\n        curveto(right, bottom - dy * ONE_MINUS_QUARTER, right - dx * ONE_MINUS_QUARTER, bottom, right - dx, bottom);"}
{"magic_number_smell": "    private final Point point, control1, control2;\n\n    public PathElement() {\n        this(0, Point.ZERO, Point.ZERO, Point.ZERO);\n    }\n\n    public PathElement(int command) {", "refactored_code": "    public static final int MOVETO = 0;\n    private final Point point, control1, control2;\n\n    public PathElement() {\n        this(MOVETO, Point.ZERO, Point.ZERO, Point.ZERO);\n    }\n\n    public PathElement(int command) {"}
{"magic_number_smell": "    public transient int hashCode;\n\n    public Point() {\n        this(0, 0, 1);\n    }\n\n    public Point(double x, double y) {", "refactored_code": "    public static final int LINE_TO = 1;\n    public transient int hashCode;\n\n    public Point() {\n        this(0, 0, LINE_TO);\n    }\n\n    public Point(double x, double y) {"}
{"magic_number_smell": "public abstract class AbstractHandle implements Handle {\n\n    public static final int 6 = 6;\n    public static final int HALF_HANDLE_SIZE = 6 / 2;\n    public static final Color HANDLE_COLOR = new Color(0.41, 0.39, 0.68);\n\n    public static final int SHIFT_DOWN = KeyEvent.SHIFT_DOWN_MASK;", "refactored_code": "    public static final int HANDLE_SIZE = 6;\npublic abstract class AbstractHandle implements Handle {\n\n    public static final int HANDLE_SIZE = 6;\n    public static final int HALF_HANDLE_SIZE = HANDLE_SIZE / 2;\n    public static final Color HANDLE_COLOR = new Color(0.41, 0.39, 0.68);\n\n    public static final int SHIFT_DOWN = KeyEvent.SHIFT_DOWN_MASK;"}
{"magic_number_smell": "public class PointHandle extends AbstractHandle {\n\n    public static final int 6 = 6;\n    public static final int HALF_HANDLE_SIZE = 6 / 2;\n    public static final Color HANDLE_COLOR = new Color(0.41, 0.39, 0.68);\n\n    private String positionName;", "refactored_code": "    public static final int HANDLE_SIZE = 6;\npublic class PointHandle extends AbstractHandle {\n\n    public static final int HANDLE_SIZE = 6;\n    public static final int HALF_HANDLE_SIZE = HANDLE_SIZE / 2;\n    public static final Color HANDLE_COLOR = new Color(0.41, 0.39, 0.68);\n\n    private String positionName;"}
{"magic_number_smell": "\n    private String angleName, positionName;\n    private double pa, ca, oa;\n    private float handleLength = 50;\n    private DragState dragState = DragState.NONE;\n\n    public RotateHandle() {", "refactored_code": "    public static final int HANDLE_LENGTH = 50;\n\n    private String angleName, positionName;\n    private double pa, ca, oa;\n    private float handleLength = HANDLE_LENGTH;\n    private DragState dragState = DragState.NONE;\n\n    public RotateHandle() {"}
{"magic_number_smell": "    private String scaleName;\n    private double px, py;\n    private double ox, oy;\n    private double handleWidth = 100;\n    private double handleHeight = HANDLE_HEIGHT;\n    private boolean scaleHorizontal = true;\n    private boolean scaleVertical = true;", "refactored_code": "    public static final int HANDLE_WIDTH = 100;\n    private String scaleName;\n    private double px, py;\n    private double ox, oy;\n    private double handleWidth = HANDLE_WIDTH;\n    private double handleHeight = HANDLE_HEIGHT;\n    private boolean scaleHorizontal = true;\n    private boolean scaleVertical = true;"}
{"magic_number_smell": "    private String translateName;\n    private double px, py;\n    private double ox, oy;\n    private float handleLength = 100;\n    private DragState dragState = DragState.NONE;\n\n    public TranslateHandle() {", "refactored_code": "    public static final int HANDLE_LENGTH = 100;\n    private String translateName;\n    private double px, py;\n    private double ox, oy;\n    private float handleLength = HANDLE_LENGTH;\n    private DragState dragState = DragState.NONE;\n\n    public TranslateHandle() {"}
{"magic_number_smell": "\n    public AddressBar() {\n        addMouseListener(this);\n        setMinimumSize(new Dimension(0, 25));\n        setMaximumSize(new Dimension(Integer.MAX_VALUE, 25));\n        setPreferredSize(new Dimension(Integer.MAX_VALUE, 25));\n        setLayout(null);", "refactored_code": "    public static final int ADDRESS_BAR_HEIGHT = 25;\n\n    public AddressBar() {\n        addMouseListener(this);\n        setMinimumSize(new Dimension(0, ADDRESS_BAR_HEIGHT));\n        setMaximumSize(new Dimension(Integer.MAX_VALUE, ADDRESS_BAR_HEIGHT));\n        setPreferredSize(new Dimension(Integer.MAX_VALUE, ADDRESS_BAR_HEIGHT));\n        setLayout(null);"}
{"magic_number_smell": "    public class ColorSlider extends JComponent {\n        private ColorPanel panel;\n        private final int 8 = 8;\n        private final int HALF_WIDTH_OFFSET = 8 / 2;\n        private final int HEIGHT_OFFSET = 10;\n        private final int ARROW_HEIGHT = 6;\n", "refactored_code": "        private final int WIDTH_OFFSET = 8;\n    public class ColorSlider extends JComponent {\n        private ColorPanel panel;\n        private final int WIDTH_OFFSET = 8;\n        private final int HALF_WIDTH_OFFSET = WIDTH_OFFSET / 2;\n        private final int HEIGHT_OFFSET = 10;\n        private final int ARROW_HEIGHT = 6;\n"}
{"magic_number_smell": "        public void paintIcon(Component component, Graphics g, int x, int y) {\n            g.setColor(color);\n            g.translate(x, y);\n            if (direction == 0) {\n                g.drawLine(3, 1, 3, 1);\n                g.drawLine(2, 2, 4, 2);\n                g.drawLine(1, 3, 5, 3);", "refactored_code": "        public static final int NORTH = 0;\n        public void paintIcon(Component component, Graphics g, int x, int y) {\n            g.setColor(color);\n            g.translate(x, y);\n            if (direction == NORTH) {\n                g.drawLine(3, 1, 3, 1);\n                g.drawLine(2, 2, 4, 2);\n                g.drawLine(1, 3, 5, 3);"}
{"magic_number_smell": "        this.normalImage = normalImage;\n        this.checkedImage = checkedImage;\n        int width = measureWidth();\n        Dimension d = new Dimension(width, 21);\n        setSize(d);\n        setPreferredSize(d);\n        setMinimumSize(d);", "refactored_code": "    public static final int BUTTON_HEIGHT = 21;\n        this.normalImage = normalImage;\n        this.checkedImage = checkedImage;\n        int width = measureWidth();\n        Dimension d = new Dimension(width, BUTTON_HEIGHT);\n        setSize(d);\n        setPreferredSize(d);\n        setMinimumSize(d);"}
{"magic_number_smell": "    static {\n        platformSpecificModifier = Toolkit.getDefaultToolkit().getMenuShortcutKeyMaskEx();\n        if (com.sun.jna.Platform.isWindows()) {\n            current_platform = 1;\n            JNA_OPTIONS.put(Library.OPTION_TYPE_MAPPER, W32APITypeMapper.UNICODE);\n            JNA_OPTIONS.put(Library.OPTION_FUNCTION_MAPPER, W32APIFunctionMapper.UNICODE);\n            COMMAND_DOWN_MASK = InputEvent.CTRL_DOWN_MASK;", "refactored_code": "    public static final int WIN = 1;\n    static {\n        platformSpecificModifier = Toolkit.getDefaultToolkit().getMenuShortcutKeyMaskEx();\n        if (com.sun.jna.Platform.isWindows()) {\n            current_platform = WIN;\n            JNA_OPTIONS.put(Library.OPTION_TYPE_MAPPER, W32APITypeMapper.UNICODE);\n            JNA_OPTIONS.put(Library.OPTION_FUNCTION_MAPPER, W32APIFunctionMapper.UNICODE);\n            COMMAND_DOWN_MASK = InputEvent.CTRL_DOWN_MASK;"}
{"magic_number_smell": "        public void paintBorder(Component c, Graphics g, int x, int y, int width, int height) {\n            // Draw border on the side of the label\n            g.setColor(LABEL_UP_COLOR);\n            g.fillRect(x, y + height - 2, 114 - 2, 1);\n            g.setColor(LABEL_DOWN_COLOR);\n            g.fillRect(x, y + height - 1, 114 - 2, 1);\n            // Draw border on port side", "refactored_code": "    public static final int LABEL_WIDTH = 114;\n        public void paintBorder(Component c, Graphics g, int x, int y, int width, int height) {\n            // Draw border on the side of the label\n            g.setColor(LABEL_UP_COLOR);\n            g.fillRect(x, y + height - 2, LABEL_WIDTH - 2, 1);\n            g.setColor(LABEL_DOWN_COLOR);\n            g.fillRect(x, y + height - 1, LABEL_WIDTH - 2, 1);\n            // Draw border on port side"}
{"magic_number_smell": "public abstract class AbstractWave {\n\n    public static final float 3.14159265358979323846f = 3.14159265358979323846f;\n    public static final float TWO_PI = 2 * 3.14159265358979323846f;\n\n    public static enum Type {SINE, TRIANGLE, SQUARE, SAWTOOTH}\n", "refactored_code": "    public static final float PI = 3.14159265358979323846f;\npublic abstract class AbstractWave {\n\n    public static final float PI = 3.14159265358979323846f;\n    public static final float TWO_PI = 2 * PI;\n\n    public static enum Type {SINE, TRIANGLE, SQUARE, SAWTOOTH}\n"}
{"magic_number_smell": "    public boolean shouldCheckForUpdate() {\n        long lastTime = getPreferences().getLong(LAST_UPDATE_CHECK, 0);\n        long deltaTime = System.currentTimeMillis() - lastTime;\n        return deltaTime > 1000 * 60 * 60 * 24;\n    }\n\n    public Preferences getPreferences() {", "refactored_code": "    public static final long UPDATE_INTERVAL = 1000 * 60 * 60 * 24; // 1000 milliseconds * 60 seconds * 60 minutes * 24 hours = Every day\n    public boolean shouldCheckForUpdate() {\n        long lastTime = getPreferences().getLong(LAST_UPDATE_CHECK, 0);\n        long deltaTime = System.currentTimeMillis() - lastTime;\n        return deltaTime > UPDATE_INTERVAL;\n    }\n\n    public Preferences getPreferences() {"}
{"magic_number_smell": "            if (thisPartInt != null && otherPartInt != null) {\n                // Two numbers, can compare.\n                if (thisPartInt > otherPartInt) {\n                    return 1;\n                } else if (thisPartInt < otherPartInt) {\n                    return SMALLER_THAN;\n                }", "refactored_code": "    private static final int LARGER_THAN = 1;\n            if (thisPartInt != null && otherPartInt != null) {\n                // Two numbers, can compare.\n                if (thisPartInt > otherPartInt) {\n                    return LARGER_THAN;\n                } else if (thisPartInt < otherPartInt) {\n                    return SMALLER_THAN;\n                }"}
{"magic_number_smell": "    public void testPointAtClosed() {\n        Contour c = new Contour();\n        c.addPoint(0, 0);\n        c.addPoint(GraphicsTestUtils.SIDE, 0);\n        c.addPoint(GraphicsTestUtils.SIDE, GraphicsTestUtils.SIDE);\n        c.addPoint(0, GraphicsTestUtils.SIDE);\n        assertEquals(GraphicsTestUtils.SIDE * 3, c.getLength());", "refactored_code": "    public static final double SIDE = GraphicsTestUtils.SIDE;\n    public void testPointAtClosed() {\n        Contour c = new Contour();\n        c.addPoint(0, 0);\n        c.addPoint(SIDE, 0);\n        c.addPoint(SIDE, SIDE);\n        c.addPoint(0, SIDE);\n        assertEquals(SIDE * 3, c.getLength());"}
{"magic_number_smell": "\n    private void testLength(float x, float y) {\n        Path p = new Path();\n        addRect(p, x, y, GraphicsTestUtils.SIDE, GraphicsTestUtils.SIDE);\n        assertEquals(GraphicsTestUtils.SIDE * 3, p.getLength());\n        p.close();\n        assertEquals(GraphicsTestUtils.SIDE * 4, p.getLength());", "refactored_code": "    public static final double SIDE = GraphicsTestUtils.SIDE;\n\n    private void testLength(float x, float y) {\n        Path p = new Path();\n        addRect(p, x, y, SIDE, SIDE);\n        assertEquals(SIDE * 3, p.getLength());\n        p.close();\n        assertEquals(SIDE * 4, p.getLength());"}
{"magic_number_smell": "    }\n\n    public String getAppcastURL() {\n        return \"http://localhost:\" + 41555 + \"/appcast.xml\";\n    }\n\n}", "refactored_code": "    public static final int APPCAST_SERVER_PORT = 41555;\n    }\n\n    public String getAppcastURL() {\n        return \"http://localhost:\" + APPCAST_SERVER_PORT + \"/appcast.xml\";\n    }\n\n}"}
{"magic_number_smell": "    @Test\n    public void testBasic() {\n        Version v1 = new Version(\"2.0\");\n        assertEquals(1, v1.compareTo(new Version(\"1.0\")));\n        assertEquals(SMALLER_THAN, v1.compareTo(new Version(\"3.0\")));\n        assertEquals(1, v1.compareTo(new Version(\"1.9.9\")));\n        assertEquals(SMALLER_THAN, v1.compareTo(new Version(\"2.1\")));", "refactored_code": "    private static final int LARGER_THAN = 1;\n    @Test\n    public void testBasic() {\n        Version v1 = new Version(\"2.0\");\n        assertEquals(LARGER_THAN, v1.compareTo(new Version(\"1.0\")));\n        assertEquals(SMALLER_THAN, v1.compareTo(new Version(\"3.0\")));\n        assertEquals(LARGER_THAN, v1.compareTo(new Version(\"1.9.9\")));\n        assertEquals(SMALLER_THAN, v1.compareTo(new Version(\"2.1\")));"}
{"magic_number_smell": "     */\n    public static PositionList make(DalvInsnList insns, int howMuch) {\n        switch (howMuch) {\n            case 1: {\n                return EMPTY;\n            }\n            case LINES:", "refactored_code": "    public static final int NONE = 1;\n     */\n    public static PositionList make(DalvInsnList insns, int howMuch) {\n        switch (howMuch) {\n            case NONE: {\n                return EMPTY;\n            }\n            case LINES:"}
{"magic_number_smell": "        int startAddress = addresses.getLast(start).getAddress();\n        int endAddress = addresses.getEnd(end).getAddress();\n\n        return (endAddress - startAddress) <= 65535;\n    }\n}\n", "refactored_code": "    private static final int MAX_CATCH_RANGE = 65535;\n        int startAddress = addresses.getLast(start).getAddress();\n        int endAddress = addresses.getEnd(end).getAddress();\n\n        return (endAddress - startAddress) <= MAX_CATCH_RANGE;\n    }\n}\n"}
{"magic_number_smell": "    private static int wordCount(RegisterSpecList regs) {\n        int sz = regs.size();\n\n        if (sz > 5) {\n            // It can't possibly fit.\n            return -1;\n        }", "refactored_code": "    private static final int MAX_NUM_OPS = 5;\n    private static int wordCount(RegisterSpecList regs) {\n        int sz = regs.size();\n\n        if (sz > MAX_NUM_OPS) {\n            // It can't possibly fit.\n            return -1;\n        }"}
{"magic_number_smell": "    private static int wordCount(RegisterSpecList regs) {\n        int sz = regs.size();\n\n        if (sz > 5) {\n            // It can't possibly fit.\n            return -1;\n        }", "refactored_code": "    private static final int MAX_NUM_OPS = 5;\n    private static int wordCount(RegisterSpecList regs) {\n        int sz = regs.size();\n\n        if (sz > MAX_NUM_OPS) {\n            // It can't possibly fit.\n            return -1;\n        }"}
{"magic_number_smell": "        }\n\n        switch (visibility) {\n            case BUILD:   out.writeByte(0); break;\n            case RUNTIME: out.writeByte(VISIBILITY_RUNTIME); break;\n            case SYSTEM:  out.writeByte(VISIBILITY_SYSTEM); break;\n            default: {", "refactored_code": "    private static final int VISIBILITY_BUILD = 0;\n        }\n\n        switch (visibility) {\n            case BUILD:   out.writeByte(VISIBILITY_BUILD); break;\n            case RUNTIME: out.writeByte(VISIBILITY_RUNTIME); break;\n            case SYSTEM:  out.writeByte(VISIBILITY_SYSTEM); break;\n            default: {"}
{"magic_number_smell": "     * Constructs an empty instance.\n     */\n    public AnnotationsDirectoryItem() {\n        super(4, -1);\n\n        classAnnotations = null;\n        fieldAnnotations = null;", "refactored_code": "    private static final int ALIGNMENT = 4;\n     * Constructs an empty instance.\n     */\n    public AnnotationsDirectoryItem() {\n        super(ALIGNMENT, -1);\n\n        classAnnotations = null;\n        fieldAnnotations = null;"}
{"magic_number_smell": "     * @param annotations {@code non-null;} set of annotations\n     */\n    public AnnotationSetItem(Annotations annotations) {\n        super(4, writeSize(annotations));\n\n        this.annotations = annotations;\n        this.items = new AnnotationItem[annotations.size()];", "refactored_code": "    private static final int ALIGNMENT = 4;\n     * @param annotations {@code non-null;} set of annotations\n     */\n    public AnnotationSetItem(Annotations annotations) {\n        super(ALIGNMENT, writeSize(annotations));\n\n        this.annotations = annotations;\n        this.items = new AnnotationItem[annotations.size()];"}
{"magic_number_smell": "     * @param annotations {@code non-null;} the annotation set to refer to\n     */\n    public AnnotationSetRefItem(AnnotationSetItem annotations) {\n        super(4, WRITE_SIZE);\n\n        if (annotations == null) {\n            throw new NullPointerException(\"annotations == null\");", "refactored_code": "    private static final int ALIGNMENT = 4;\n     * @param annotations {@code non-null;} the annotation set to refer to\n     */\n    public AnnotationSetRefItem(AnnotationSetItem annotations) {\n        super(ALIGNMENT, WRITE_SIZE);\n\n        if (annotations == null) {\n            throw new NullPointerException(\"annotations == null\");"}
{"magic_number_smell": "     * @return {@code >= 0;} the write size\n     */\n    public int writeSize() {\n        return (triesSize() * 4 + (2 * 2)) +\n                + encodedHandlers.length;\n    }\n", "refactored_code": "    private static final int TRY_ITEM_WRITE_SIZE = 4 + (2 * 2);\n     * @return {@code >= 0;} the write size\n     */\n    public int writeSize() {\n        return (triesSize() * TRY_ITEM_WRITE_SIZE) +\n                + encodedHandlers.length;\n    }\n"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    @Override\n    public int writeSize() {\n        return 32;\n    }\n\n    /** {@inheritDoc} */", "refactored_code": "    public static final int WRITE_SIZE = 32;\n    /** {@inheritDoc} */\n    @Override\n    public int writeSize() {\n        return WRITE_SIZE;\n    }\n\n    /** {@inheritDoc} */"}
{"magic_number_smell": "     */\n    public CodeItem(CstMethodRef ref, DalvCode code, boolean isStatic,\n            TypeList throwsList) {\n        super(4, -1);\n\n        if (ref == null) {\n            throw new NullPointerException(\"ref == null\");", "refactored_code": "    private static final int ALIGNMENT = 4;\n     */\n    public CodeItem(CstMethodRef ref, DalvCode code, boolean isStatic,\n            TypeList throwsList) {\n        super(ALIGNMENT, -1);\n\n        if (ref == null) {\n            throw new NullPointerException(\"ref == null\");"}
{"magic_number_smell": "\n    public DebugInfoItem(DalvCode code, boolean isStatic, CstMethodRef ref) {\n        // We don't know the write size yet.\n        super (1, -1);\n\n        if (code == null) {\n            throw new NullPointerException(\"code == null\");", "refactored_code": "    private static final int ALIGNMENT = 1;\n\n    public DebugInfoItem(DalvCode code, boolean isStatic, CstMethodRef ref) {\n        // We don't know the write size yet.\n        super (ALIGNMENT, -1);\n\n        if (code == null) {\n            throw new NullPointerException(\"code == null\");"}
{"magic_number_smell": "         * The write size isn't known up-front because (the variable-lengthed)\n         * leb128 type is used to represent some things.\n         */\n        super(1, -1);\n\n        if (array == null) {\n            throw new NullPointerException(\"array == null\");", "refactored_code": "    private static final int ALIGNMENT = 1;\n         * The write size isn't known up-front because (the variable-lengthed)\n         * leb128 type is used to represent some things.\n         */\n        super(ALIGNMENT, -1);\n\n        if (array == null) {\n            throw new NullPointerException(\"array == null\");"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    @Override\n    public int writeSize() {\n        return 0x70;\n    }\n\n    /** {@inheritDoc} */", "refactored_code": "    private static final int HEADER_SIZE = 0x70;\n    /** {@inheritDoc} */\n    @Override\n    public int writeSize() {\n        return HEADER_SIZE;\n    }\n\n    /** {@inheritDoc} */"}
{"magic_number_smell": "     */\n    private MapItem(ItemType type, Section section, Item firstItem,\n            Item lastItem, int itemCount) {\n        super(4, WRITE_SIZE);\n\n        if (type == null) {\n            throw new NullPointerException(\"type == null\");", "refactored_code": "    private static final int ALIGNMENT = 4;\n     */\n    private MapItem(ItemType type, Section section, Item firstItem,\n            Item lastItem, int itemCount) {\n        super(ALIGNMENT, WRITE_SIZE);\n\n        if (type == null) {\n            throw new NullPointerException(\"type == null\");"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    @Override\n    public int writeSize() {\n        return 8;\n    }\n\n    /** {@inheritDoc} */", "refactored_code": "    public static final int WRITE_SIZE = 8;\n    /** {@inheritDoc} */\n    @Override\n    public int writeSize() {\n        return WRITE_SIZE;\n    }\n\n    /** {@inheritDoc} */"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    @Override\n    public int writeSize() {\n        return 12;\n    }\n\n    /** {@inheritDoc} */", "refactored_code": "    public static final int WRITE_SIZE = 12;\n    /** {@inheritDoc} */\n    @Override\n    public int writeSize() {\n        return WRITE_SIZE;\n    }\n\n    /** {@inheritDoc} */"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    @Override\n    public int writeSize() {\n        return 4;\n    }\n\n    /** {@inheritDoc} */", "refactored_code": "    public static final int WRITE_SIZE = 4;\n    /** {@inheritDoc} */\n    @Override\n    public int writeSize() {\n        return WRITE_SIZE;\n    }\n\n    /** {@inheritDoc} */"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    @Override\n    public int writeSize() {\n        return 4;\n    }\n\n    /** {@inheritDoc} */", "refactored_code": "    public static final int WRITE_SIZE = 4;\n    /** {@inheritDoc} */\n    @Override\n    public int writeSize() {\n        return WRITE_SIZE;\n    }\n\n    /** {@inheritDoc} */"}
{"magic_number_smell": "     * @param list {@code non-null;} the actual list\n     */\n    public TypeListItem(TypeList list) {\n        super(4, (list.size() * ELEMENT_SIZE) + HEADER_SIZE);\n\n        this.list = list;\n    }", "refactored_code": "    private static final int ALIGNMENT = 4;\n     * @param list {@code non-null;} the actual list\n     */\n    public TypeListItem(TypeList list) {\n        super(ALIGNMENT, (list.size() * ELEMENT_SIZE) + HEADER_SIZE);\n\n        this.list = list;\n    }"}
{"magic_number_smell": "    private static int getAlignment(List<? extends OffsettedItem> items) {\n        try {\n            // Since they all must have the same alignment, any one will do.\n            return Math.max(4, items.get(0).getAlignment());\n        } catch (IndexOutOfBoundsException ex) {\n            // Translate the exception.\n            throw new IllegalArgumentException(\"items.size() == 0\");", "refactored_code": "    private static final int HEADER_SIZE = 4;\n    private static int getAlignment(List<? extends OffsettedItem> items) {\n        try {\n            // Since they all must have the same alignment, any one will do.\n            return Math.max(HEADER_SIZE, items.get(0).getAlignment());\n        } catch (IndexOutOfBoundsException ex) {\n            // Translate the exception.\n            throw new IllegalArgumentException(\"items.size() == 0\");"}
{"magic_number_smell": "        int arg;\n\n        switch (type) {\n            case 0x00:\n            case VALUE_SHORT:\n            case VALUE_INT:\n            case VALUE_LONG: {", "refactored_code": "    private static final int VALUE_BYTE = 0x00;\n        int arg;\n\n        switch (type) {\n            case VALUE_BYTE:\n            case VALUE_SHORT:\n            case VALUE_INT:\n            case VALUE_LONG: {"}
{"magic_number_smell": "\n    /** flags defined on classes */\n    public static final int CLASS_FLAGS =\n        0x0001 | ACC_FINAL | ACC_SUPER | ACC_INTERFACE | ACC_ABSTRACT |\n        ACC_SYNTHETIC | ACC_ANNOTATION | ACC_ENUM;\n\n    /** flags defined on inner classes */", "refactored_code": "    public static final int ACC_PUBLIC = 0x0001;\n\n    /** flags defined on classes */\n    public static final int CLASS_FLAGS =\n        ACC_PUBLIC | ACC_FINAL | ACC_SUPER | ACC_INTERFACE | ACC_ABSTRACT |\n        ACC_SYNTHETIC | ACC_ANNOTATION | ACC_ENUM;\n\n    /** flags defined on inner classes */"}
{"magic_number_smell": "            RegisterSpecList sources) {\n\n        return !disableSourcesInOrder && opcode.isCallLike()\n                && totalRopWidth(sources) >= 6;\n    }\n\n    /**", "refactored_code": "    private static final int MIN_INVOKE_IN_ORDER = 6;\n            RegisterSpecList sources) {\n\n        return !disableSourcesInOrder && opcode.isCallLike()\n                && totalRopWidth(sources) >= MIN_INVOKE_IN_ORDER;\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    public static String opName(int opcode) {\n        switch (opcode) {\n            case 1: return \"nop\";\n            case MOVE: return \"move\";\n            case MOVE_PARAM: return \"move-param\";\n            case MOVE_EXCEPTION: return \"move-exception\";", "refactored_code": "    public static final int NOP = 1;\n     */\n    public static String opName(int opcode) {\n        switch (opcode) {\n            case NOP: return \"nop\";\n            case MOVE: return \"move\";\n            case MOVE_PARAM: return \"move-param\";\n            case MOVE_EXCEPTION: return \"move-exception\";"}
{"magic_number_smell": "            throw new NullPointerException(\"exceptions == null\");\n        }\n\n        if ((branchingness < 1) || (branchingness > BRANCH_MAX)) {\n            throw new IllegalArgumentException(\"bogus branchingness\");\n        }\n", "refactored_code": "    public static final int BRANCH_MIN = 1;\n            throw new NullPointerException(\"exceptions == null\");\n        }\n\n        if ((branchingness < BRANCH_MIN) || (branchingness > BRANCH_MAX)) {\n            throw new IllegalArgumentException(\"bogus branchingness\");\n        }\n"}
{"magic_number_smell": "    public static final Type SHORT = new Type(\"S\", BT_SHORT);\n\n    /** {@code non-null;} instance representing {@code void} */\n    public static final Type VOID = new Type(\"V\", 0);\n\n    /** {@code non-null;} instance representing a known-{@code null} */\n    public static final Type KNOWN_NULL = new Type(\"<null>\", BT_OBJECT);", "refactored_code": "    public static final int BT_VOID = 0;\n    public static final Type SHORT = new Type(\"S\", BT_SHORT);\n\n    /** {@code non-null;} instance representing {@code void} */\n    public static final Type VOID = new Type(\"V\", BT_VOID);\n\n    /** {@code non-null;} instance representing a known-{@code null} */\n    public static final Type KNOWN_NULL = new Type(\"<null>\", BT_OBJECT);"}
{"magic_number_smell": "     * by default.\n     */\n    public ByteArrayAnnotatedOutput() {\n        this(new byte[1000], true);\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_SIZE = 1000;\n     * by default.\n     */\n    public ByteArrayAnnotatedOutput() {\n        this(new byte[DEFAULT_SIZE], true);\n    }\n\n    /**"}
{"magic_number_smell": "\n        StringBuilder result = new StringBuilder();\n        result.append(buffer.typeNames().get(typeIndex));\n        if (supertypeIndex != -1) {\n            result.append(\" extends \").append(buffer.typeNames().get(supertypeIndex));\n        }\n        return result.toString();", "refactored_code": "    public static final int NO_INDEX = -1;\n\n        StringBuilder result = new StringBuilder();\n        result.append(buffer.typeNames().get(typeIndex));\n        if (supertypeIndex != NO_INDEX) {\n            result.append(\" extends \").append(buffer.typeNames().get(supertypeIndex));\n        }\n        return result.toString();"}
{"magic_number_smell": "public final class Dex {\n    private static final int 8 = 8;\n    private static final int CHECKSUM_SIZE = 4;\n    private static final int SIGNATURE_OFFSET = 8 + CHECKSUM_SIZE;\n    private static final int SIGNATURE_SIZE = 20;\n    // Provided as a convenience to avoid a memory allocation to benefit Dalvik.\n    // Note: libcore.util.EmptyArray cannot be accessed when this code isn't run on Dalvik.", "refactored_code": "    private static final int CHECKSUM_OFFSET = 8;\npublic final class Dex {\n    private static final int CHECKSUM_OFFSET = 8;\n    private static final int CHECKSUM_SIZE = 4;\n    private static final int SIGNATURE_OFFSET = CHECKSUM_OFFSET + CHECKSUM_SIZE;\n    private static final int SIGNATURE_SIZE = 20;\n    // Provided as a convenience to avoid a memory allocation to benefit Dalvik.\n    // Note: libcore.util.EmptyArray cannot be accessed when this code isn't run on Dalvik."}
{"magic_number_smell": "        } else if (version.equals(VERSION_FOR_API_28)) {\n            return API_CONST_METHOD_HANDLE;\n        } else if (version.equals(VERSION_FOR_API_10000)) {\n            return 10000;\n        } else if (version.equals(VERSION_CURRENT)) {\n            return API_CURRENT;\n        }", "refactored_code": "    public static final int API_SPACES_IN_SIMPLE_NAME = 10000;\n        } else if (version.equals(VERSION_FOR_API_28)) {\n            return API_CONST_METHOD_HANDLE;\n        } else if (version.equals(VERSION_FOR_API_10000)) {\n            return API_SPACES_IN_SIMPLE_NAME;\n        } else if (version.equals(VERSION_CURRENT)) {\n            return API_CURRENT;\n        }"}
{"magic_number_smell": "    }\n\n    public byte readByte() {\n        checkType(0x00);\n        type = MUST_READ;\n        return (byte) EncodedValueCodec.readSignedInt(in, arg);\n    }", "refactored_code": "    public static final int ENCODED_BYTE = 0x00;\n    }\n\n    public byte readByte() {\n        checkType(ENCODED_BYTE);\n        type = MUST_READ;\n        return (byte) EncodedValueCodec.readSignedInt(in, arg);\n    }"}
{"magic_number_smell": "    public static final int USHORT = 2;\n    public static final int UINT = 4;\n\n    public static final int SIGNATURE = 1 * 20;\n\n    /**\n     * magic ubyte[8]", "refactored_code": "    public static final int UBYTE = 1;\n    public static final int USHORT = 2;\n    public static final int UINT = 4;\n\n    public static final int SIGNATURE = UBYTE * 20;\n\n    /**\n     * magic ubyte[8]"}
{"magic_number_smell": "        super(ATTRIBUTE_NAME);\n        this.bootstrapMethods = bootstrapMethods;\n\n        int bytes = 8 + bootstrapMethods.size() * BOOTSTRAP_METHOD_BYTES;\n        for (int i = 0; i < bootstrapMethods.size(); ++i) {\n            int numberOfArguments = bootstrapMethods.get(i).getBootstrapMethodArguments().size();\n            bytes += numberOfArguments * BOOTSTRAP_ARGUMENT_BYTES;", "refactored_code": "    private static final int ATTRIBUTE_HEADER_BYTES = 8;\n        super(ATTRIBUTE_NAME);\n        this.bootstrapMethods = bootstrapMethods;\n\n        int bytes = ATTRIBUTE_HEADER_BYTES + bootstrapMethods.size() * BOOTSTRAP_METHOD_BYTES;\n        for (int i = 0; i < bootstrapMethods.size(); ++i) {\n            int numberOfArguments = bootstrapMethods.get(i).getBootstrapMethodArguments().size();\n            bytes += numberOfArguments * BOOTSTRAP_ARGUMENT_BYTES;"}
{"magic_number_smell": "         * that should be executed, hence the second argument to the\n         * constructor.\n         */\n        return new RopMethod(bbl, getSpecialLabel(-1));\n    }\n\n    /**", "refactored_code": "    private static final int PARAM_ASSIGNMENT = -1;\n         * that should be executed, hence the second argument to the\n         * constructor.\n         */\n        return new RopMethod(bbl, getSpecialLabel(PARAM_ASSIGNMENT));\n    }\n\n    /**"}
{"magic_number_smell": "     * @return true if the magic is valid\n     */\n    private boolean isGoodMagic(int magic) {\n        return magic == 0xcafebabe;\n    }\n\n    /**", "refactored_code": "    private static final int CLASS_FILE_MAGIC = 0xcafebabe;\n     * @return true if the magic is valid\n     */\n    private boolean isGoodMagic(int magic) {\n        return magic == CLASS_FILE_MAGIC;\n    }\n\n    /**"}
{"magic_number_smell": "\n                int constantPoolSize = cf.getConstantPool().size();\n                maxMethodIdsInClass = constantPoolSize + cf.getMethods().size()\n                        + 2;\n                maxFieldIdsInClass = constantPoolSize + cf.getFields().size()\n                        + MAX_FIELD_ADDED_DURING_DEX_CREATION;\n                synchronized(dexRotationLock) {", "refactored_code": "    private static final int MAX_METHOD_ADDED_DURING_DEX_CREATION = 2;\n\n                int constantPoolSize = cf.getConstantPool().size();\n                maxMethodIdsInClass = constantPoolSize + cf.getMethods().size()\n                        + MAX_METHOD_ADDED_DURING_DEX_CREATION;\n                maxFieldIdsInClass = constantPoolSize + cf.getFields().size()\n                        + MAX_FIELD_ADDED_DURING_DEX_CREATION;\n                synchronized(dexRotationLock) {"}
{"magic_number_smell": "    private final Constant[] constants;\n\n    /**\n     * {@code >= -1;} the constant pool indicies for {@link #constants}, or\n     * {@code -1} if not yet set\n     */\n    private final int[] index;", "refactored_code": "    private static final int NOT_SET = -1;\n    private final Constant[] constants;\n\n    /**\n     * {@code >= NOT_SET;} the constant pool indicies for {@link #constants}, or\n     * {@code NOT_SET} if not yet set\n     */\n    private final int[] index;"}
{"magic_number_smell": "     */\n    public static PositionList make(DalvInsnList insns, int howMuch) {\n        switch (howMuch) {\n            case 1: {\n                return EMPTY;\n            }\n            case LINES:", "refactored_code": "    public static final int NONE = 1;\n     */\n    public static PositionList make(DalvInsnList insns, int howMuch) {\n        switch (howMuch) {\n            case NONE: {\n                return EMPTY;\n            }\n            case LINES:"}
{"magic_number_smell": "        int startAddress = addresses.getLast(start).getAddress();\n        int endAddress = addresses.getEnd(end).getAddress();\n\n        return (endAddress - startAddress) <= 65535;\n    }\n}\n", "refactored_code": "    private static final int MAX_CATCH_RANGE = 65535;\n        int startAddress = addresses.getLast(start).getAddress();\n        int endAddress = addresses.getEnd(end).getAddress();\n\n        return (endAddress - startAddress) <= MAX_CATCH_RANGE;\n    }\n}\n"}
{"magic_number_smell": "    private static int wordCount(RegisterSpecList regs) {\n        int sz = regs.size();\n\n        if (sz > 5) {\n            // It can't possibly fit.\n            return -1;\n        }", "refactored_code": "    private static final int MAX_NUM_OPS = 5;\n    private static int wordCount(RegisterSpecList regs) {\n        int sz = regs.size();\n\n        if (sz > MAX_NUM_OPS) {\n            // It can't possibly fit.\n            return -1;\n        }"}
{"magic_number_smell": "    private static int wordCount(RegisterSpecList regs) {\n        int sz = regs.size();\n\n        if (sz > 5) {\n            // It can't possibly fit.\n            return -1;\n        }", "refactored_code": "    private static final int MAX_NUM_OPS = 5;\n    private static int wordCount(RegisterSpecList regs) {\n        int sz = regs.size();\n\n        if (sz > MAX_NUM_OPS) {\n            // It can't possibly fit.\n            return -1;\n        }"}
{"magic_number_smell": "        }\n\n        switch (visibility) {\n            case BUILD:   out.writeByte(0); break;\n            case RUNTIME: out.writeByte(VISIBILITY_RUNTIME); break;\n            case SYSTEM:  out.writeByte(VISIBILITY_SYSTEM); break;\n            default: {", "refactored_code": "    private static final int VISIBILITY_BUILD = 0;\n        }\n\n        switch (visibility) {\n            case BUILD:   out.writeByte(VISIBILITY_BUILD); break;\n            case RUNTIME: out.writeByte(VISIBILITY_RUNTIME); break;\n            case SYSTEM:  out.writeByte(VISIBILITY_SYSTEM); break;\n            default: {"}
{"magic_number_smell": "     * Constructs an empty instance.\n     */\n    public AnnotationsDirectoryItem() {\n        super(4, -1);\n\n        classAnnotations = null;\n        fieldAnnotations = null;", "refactored_code": "    private static final int ALIGNMENT = 4;\n     * Constructs an empty instance.\n     */\n    public AnnotationsDirectoryItem() {\n        super(ALIGNMENT, -1);\n\n        classAnnotations = null;\n        fieldAnnotations = null;"}
{"magic_number_smell": "     * @param dexFile {@code non-null;} dex output\n     */\n    public AnnotationSetItem(Annotations annotations, DexFile dexFile) {\n        super(4, writeSize(annotations));\n\n        this.annotations = annotations;\n        this.items = new AnnotationItem[annotations.size()];", "refactored_code": "    private static final int ALIGNMENT = 4;\n     * @param dexFile {@code non-null;} dex output\n     */\n    public AnnotationSetItem(Annotations annotations, DexFile dexFile) {\n        super(ALIGNMENT, writeSize(annotations));\n\n        this.annotations = annotations;\n        this.items = new AnnotationItem[annotations.size()];"}
{"magic_number_smell": "     * @param annotations {@code non-null;} the annotation set to refer to\n     */\n    public AnnotationSetRefItem(AnnotationSetItem annotations) {\n        super(4, WRITE_SIZE);\n\n        if (annotations == null) {\n            throw new NullPointerException(\"annotations == null\");", "refactored_code": "    private static final int ALIGNMENT = 4;\n     * @param annotations {@code non-null;} the annotation set to refer to\n     */\n    public AnnotationSetRefItem(AnnotationSetItem annotations) {\n        super(ALIGNMENT, WRITE_SIZE);\n\n        if (annotations == null) {\n            throw new NullPointerException(\"annotations == null\");"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    @Override\n    public int writeSize() {\n        return 4;\n    }\n\n    /** {@inheritDoc} */", "refactored_code": "    private static final int ITEM_SIZE = 4;\n    /** {@inheritDoc} */\n    @Override\n    public int writeSize() {\n        return ITEM_SIZE;\n    }\n\n    /** {@inheritDoc} */"}
{"magic_number_smell": "     * @return {@code >= 0;} the write size\n     */\n    public int writeSize() {\n        return (triesSize() * 4 + (2 * 2)) +\n                + encodedHandlers.length;\n    }\n", "refactored_code": "    private static final int TRY_ITEM_WRITE_SIZE = 4 + (2 * 2);\n     * @return {@code >= 0;} the write size\n     */\n    public int writeSize() {\n        return (triesSize() * TRY_ITEM_WRITE_SIZE) +\n                + encodedHandlers.length;\n    }\n"}
{"magic_number_smell": "     */\n    public CodeItem(CstMethodRef ref, DalvCode code, boolean isStatic,\n            TypeList throwsList) {\n        super(4, -1);\n\n        if (ref == null) {\n            throw new NullPointerException(\"ref == null\");", "refactored_code": "    private static final int ALIGNMENT = 4;\n     */\n    public CodeItem(CstMethodRef ref, DalvCode code, boolean isStatic,\n            TypeList throwsList) {\n        super(ALIGNMENT, -1);\n\n        if (ref == null) {\n            throw new NullPointerException(\"ref == null\");"}
{"magic_number_smell": "\n    public DebugInfoItem(DalvCode code, boolean isStatic, CstMethodRef ref) {\n        // We don't know the write size yet.\n        super (1, -1);\n\n        if (code == null) {\n            throw new NullPointerException(\"code == null\");", "refactored_code": "    private static final int ALIGNMENT = 1;\n\n    public DebugInfoItem(DalvCode code, boolean isStatic, CstMethodRef ref) {\n        // We don't know the write size yet.\n        super (ALIGNMENT, -1);\n\n        if (code == null) {\n            throw new NullPointerException(\"code == null\");"}
{"magic_number_smell": "         * The write size isn't known up-front because (the variable-lengthed)\n         * leb128 type is used to represent some things.\n         */\n        super(1, -1);\n\n        if (array == null) {\n            throw new NullPointerException(\"array == null\");", "refactored_code": "    private static final int ALIGNMENT = 1;\n         * The write size isn't known up-front because (the variable-lengthed)\n         * leb128 type is used to represent some things.\n         */\n        super(ALIGNMENT, -1);\n\n        if (array == null) {\n            throw new NullPointerException(\"array == null\");"}
{"magic_number_smell": "     */\n    private MapItem(ItemType type, Section section, Item firstItem,\n            Item lastItem, int itemCount) {\n        super(4, WRITE_SIZE);\n\n        if (type == null) {\n            throw new NullPointerException(\"type == null\");", "refactored_code": "    private static final int ALIGNMENT = 4;\n     */\n    private MapItem(ItemType type, Section section, Item firstItem,\n            Item lastItem, int itemCount) {\n        super(ALIGNMENT, WRITE_SIZE);\n\n        if (type == null) {\n            throw new NullPointerException(\"type == null\");"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    @Override\n    public int writeSize() {\n        return 8;\n    }\n\n    /** {@inheritDoc} */", "refactored_code": "    private final int ITEM_SIZE = 8;\n    /** {@inheritDoc} */\n    @Override\n    public int writeSize() {\n        return ITEM_SIZE;\n    }\n\n    /** {@inheritDoc} */"}
{"magic_number_smell": "     * @param list {@code non-null;} the actual list\n     */\n    public TypeListItem(TypeList list) {\n        super(4, (list.size() * ELEMENT_SIZE) + HEADER_SIZE);\n\n        this.list = list;\n    }", "refactored_code": "    private static final int ALIGNMENT = 4;\n     * @param list {@code non-null;} the actual list\n     */\n    public TypeListItem(TypeList list) {\n        super(ALIGNMENT, (list.size() * ELEMENT_SIZE) + HEADER_SIZE);\n\n        this.list = list;\n    }"}
{"magic_number_smell": "    private static int getAlignment(List<? extends OffsettedItem> items) {\n        try {\n            // Since they all must have the same alignment, any one will do.\n            return Math.max(4, items.get(0).getAlignment());\n        } catch (IndexOutOfBoundsException ex) {\n            // Translate the exception.\n            throw new IllegalArgumentException(\"items.size() == 0\");", "refactored_code": "    private static final int HEADER_SIZE = 4;\n    private static int getAlignment(List<? extends OffsettedItem> items) {\n        try {\n            // Since they all must have the same alignment, any one will do.\n            return Math.max(HEADER_SIZE, items.get(0).getAlignment());\n        } catch (IndexOutOfBoundsException ex) {\n            // Translate the exception.\n            throw new IllegalArgumentException(\"items.size() == 0\");"}
{"magic_number_smell": "        int arg;\n\n        switch (type) {\n            case 0x00:\n            case VALUE_SHORT:\n            case VALUE_INT:\n            case VALUE_LONG: {", "refactored_code": "    private static final int VALUE_BYTE = 0x00;\n        int arg;\n\n        switch (type) {\n            case VALUE_BYTE:\n            case VALUE_SHORT:\n            case VALUE_INT:\n            case VALUE_LONG: {"}
{"magic_number_smell": "     * valid. This includes the range {@code 0x01..0xfe}, the range\n     * {@code 0x00ff..0xffff} where the low-order byte is either\n     * {@code 0} or {@code 0xff}, and the special opcode values {@code\n     * -1} and {@code NO_NEXT}. Note that not all of the\n     * opcode values that pass this test are in fact used. This method\n     * is meant to perform a quick check to reject blatantly wrong\n     * values (e.g. when validating arguments).", "refactored_code": "    public static final int SPECIAL_FORMAT = -1;\n     * valid. This includes the range {@code 0x01..0xfe}, the range\n     * {@code 0x00ff..0xffff} where the low-order byte is either\n     * {@code 0} or {@code 0xff}, and the special opcode values {@code\n     * SPECIAL_FORMAT} and {@code NO_NEXT}. Note that not all of the\n     * opcode values that pass this test are in fact used. This method\n     * is meant to perform a quick check to reject blatantly wrong\n     * values (e.g. when validating arguments)."}
{"magic_number_smell": "            debugInfoOut.writeByte(opcode);\n\n            switch (opcode) {\n            case 0x00:\n                return;\n\n            case DBG_ADVANCE_PC:", "refactored_code": "    private static final byte DBG_END_SEQUENCE = 0x00;\n            debugInfoOut.writeByte(opcode);\n\n            switch (opcode) {\n            case DBG_END_SEQUENCE:\n                return;\n\n            case DBG_ADVANCE_PC:"}
{"magic_number_smell": "\n    /** flags defined on classes */\n    public static final int CLASS_FLAGS =\n        0x0001 | ACC_FINAL | ACC_SUPER | ACC_INTERFACE | ACC_ABSTRACT |\n        ACC_SYNTHETIC | ACC_ANNOTATION | ACC_ENUM;\n\n    /** flags defined on inner classes */", "refactored_code": "    public static final int ACC_PUBLIC = 0x0001;\n\n    /** flags defined on classes */\n    public static final int CLASS_FLAGS =\n        ACC_PUBLIC | ACC_FINAL | ACC_SUPER | ACC_INTERFACE | ACC_ABSTRACT |\n        ACC_SYNTHETIC | ACC_ANNOTATION | ACC_ENUM;\n\n    /** flags defined on inner classes */"}
{"magic_number_smell": "            RegisterSpecList sources) {\n\n        return !disableSourcesInOrder && opcode.isCallLike()\n                && totalRopWidth(sources) >= 6;\n    }\n\n    /**", "refactored_code": "    private static final int MIN_INVOKE_IN_ORDER = 6;\n            RegisterSpecList sources) {\n\n        return !disableSourcesInOrder && opcode.isCallLike()\n                && totalRopWidth(sources) >= MIN_INVOKE_IN_ORDER;\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    public static String opName(int opcode) {\n        switch (opcode) {\n            case 1: return \"nop\";\n            case MOVE: return \"move\";\n            case MOVE_PARAM: return \"move-param\";\n            case MOVE_EXCEPTION: return \"move-exception\";", "refactored_code": "    public static final int NOP = 1;\n     */\n    public static String opName(int opcode) {\n        switch (opcode) {\n            case NOP: return \"nop\";\n            case MOVE: return \"move\";\n            case MOVE_PARAM: return \"move-param\";\n            case MOVE_EXCEPTION: return \"move-exception\";"}
{"magic_number_smell": "            throw new NullPointerException(\"exceptions == null\");\n        }\n\n        if ((branchingness < 1) || (branchingness > BRANCH_MAX)) {\n            throw new IllegalArgumentException(\"invalid branchingness: \" + branchingness);\n        }\n", "refactored_code": "    public static final int BRANCH_MIN = 1;\n            throw new NullPointerException(\"exceptions == null\");\n        }\n\n        if ((branchingness < BRANCH_MIN) || (branchingness > BRANCH_MAX)) {\n            throw new IllegalArgumentException(\"invalid branchingness: \" + branchingness);\n        }\n"}
{"magic_number_smell": "     */\n    public static boolean isAccessor(int type) {\n        switch (type) {\n            case 0:\n            case METHOD_HANDLE_TYPE_STATIC_GET:\n            case METHOD_HANDLE_TYPE_INSTANCE_PUT:\n            case METHOD_HANDLE_TYPE_INSTANCE_GET:", "refactored_code": "    public static final int METHOD_HANDLE_TYPE_STATIC_PUT = 0;\n     */\n    public static boolean isAccessor(int type) {\n        switch (type) {\n            case METHOD_HANDLE_TYPE_STATIC_PUT:\n            case METHOD_HANDLE_TYPE_STATIC_GET:\n            case METHOD_HANDLE_TYPE_INSTANCE_PUT:\n            case METHOD_HANDLE_TYPE_INSTANCE_GET:"}
{"magic_number_smell": "    public static final Type SHORT = new Type(\"S\", BT_SHORT);\n\n    /** {@code non-null;} instance representing {@code void} */\n    public static final Type VOID = new Type(\"V\", 0);\n\n    /** {@code non-null;} instance representing a known-{@code null} */\n    public static final Type KNOWN_NULL = new Type(\"<null>\", BT_OBJECT);", "refactored_code": "    public static final int BT_VOID = 0;\n    public static final Type SHORT = new Type(\"S\", BT_SHORT);\n\n    /** {@code non-null;} instance representing {@code void} */\n    public static final Type VOID = new Type(\"V\", BT_VOID);\n\n    /** {@code non-null;} instance representing a known-{@code null} */\n    public static final Type KNOWN_NULL = new Type(\"<null>\", BT_OBJECT);"}
{"magic_number_smell": "        ArrayList<TypedConstant> constantList\n                = getConstsSortedByCountUse();\n\n        int toCollect = Math.min(constantList.size(), 5);\n\n        SsaBasicBlock start = ssaMeth.getEntryBlock();\n", "refactored_code": "    private static final int MAX_COLLECTED_CONSTANTS = 5;\n        ArrayList<TypedConstant> constantList\n                = getConstsSortedByCountUse();\n\n        int toCollect = Math.min(constantList.size(), MAX_COLLECTED_CONSTANTS);\n\n        SsaBasicBlock start = ssaMeth.getEntryBlock();\n"}
{"magic_number_smell": "        this.varyingWorklist = new ArrayList<SsaInsn>();\n        this.branchWorklist = new ArrayList<SsaInsn>();\n        for (int i = 0; i < this.regCount; i++) {\n            latticeValues[i] = 0;\n            latticeConstants[i] = null;\n        }\n    }", "refactored_code": "    private static final int TOP = 0;\n        this.varyingWorklist = new ArrayList<SsaInsn>();\n        this.branchWorklist = new ArrayList<SsaInsn>();\n        for (int i = 0; i < this.regCount; i++) {\n            latticeValues[i] = TOP;\n            latticeConstants[i] = null;\n        }\n    }"}
{"magic_number_smell": "     * @return {@code non-null;} appropriate set\n     */\n    /*package*/ static IntSet makeDomFrontSet(int szBlocks) {\n        return szBlocks <= 3072\n                ? new BitIntSet(szBlocks)\n                : new ListIntSet();\n    }", "refactored_code": "    private static final int DOMFRONT_SET_THRESHOLD_SIZE = 3072;\n     * @return {@code non-null;} appropriate set\n     */\n    /*package*/ static IntSet makeDomFrontSet(int szBlocks) {\n        return szBlocks <= DOMFRONT_SET_THRESHOLD_SIZE\n                ? new BitIntSet(szBlocks)\n                : new ListIntSet();\n    }"}
{"magic_number_smell": "     * by default.\n     */\n    public ByteArrayAnnotatedOutput() {\n        this(1000);\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_SIZE = 1000;\n     * by default.\n     */\n    public ByteArrayAnnotatedOutput() {\n        this(DEFAULT_SIZE);\n    }\n\n    /**"}
{"magic_number_smell": "            } else {\n                System.err.println(\"Invalid option \" + args[argIndex]);\n                printUsage();\n                System.exit(1);\n            }\n            argIndex++;\n        }", "refactored_code": "    private static final int STATUS_ERROR = 1;\n            } else {\n                System.err.println(\"Invalid option \" + args[argIndex]);\n                printUsage();\n                System.exit(STATUS_ERROR);\n            }\n            argIndex++;\n        }"}
{"magic_number_smell": "    public static final long e = 4660046610375530309L;\n    public static final float f = 0.5f;\n    public static final double g = -0.25;\n    public static final String h = \"this is 1 String\";\n    public static final Class<?> i = String.class;\n    public static final int[] j = { 0, 1 };\n    public static final String k = null;", "refactored_code": "    public static final byte a = 1;\n    public static final long e = 4660046610375530309L;\n    public static final float f = 0.5f;\n    public static final double g = -0.25;\n    public static final String h = \"this is a String\";\n    public static final Class<?> i = String.class;\n    public static final int[] j = { 0, 1 };\n    public static final String k = null;"}
{"magic_number_smell": "    Random random = new Random();\n    HashSet<Integer> seen = new HashSet<>();\n    for (int pass = 0; pass < 2; pass++) {\n      for (int i = 0; i < 1000; i++) {\n        // On the first pass only do 2-way merges, then do from 3 to 10 way merges\n        // but not more to avoid dex index overflow.\n        int numDex = pass == 0 ? 2 : random.nextInt(8) + 3;", "refactored_code": "  private static final int NUMBER_OF_TRIES = 1000;\n    Random random = new Random();\n    HashSet<Integer> seen = new HashSet<>();\n    for (int pass = 0; pass < 2; pass++) {\n      for (int i = 0; i < NUMBER_OF_TRIES; i++) {\n        // On the first pass only do 2-way merges, then do from 3 to 10 way merges\n        // but not more to avoid dex index overflow.\n        int numDex = pass == 0 ? 2 : random.nextInt(8) + 3;"}
{"magic_number_smell": "    private static final int MIN_PIN_LENGTH = 4;\n    private static final int MAX_PIN_LENGTH = 8;\n    // Which dialog to show next when popped up\n    private int mDialogState = 0;\n\n    private String mPin;\n    private String mOldPin;", "refactored_code": "    private static final int OFF_MODE = 0;\n    private static final int MIN_PIN_LENGTH = 4;\n    private static final int MAX_PIN_LENGTH = 8;\n    // Which dialog to show next when popped up\n    private int mDialogState = OFF_MODE;\n\n    private String mPin;\n    private String mOldPin;"}
{"magic_number_smell": "\n    @Override\n    public Dialog onCreateDialog(int id) {\n        if (id == 0) {\n            String hostname = mHostnameField.getText().toString().trim();\n            String portStr = mPortField.getText().toString().trim();\n            String exclList = mExclusionListField.getText().toString().trim();", "refactored_code": "    private static final int ERROR_DIALOG_ID = 0;\n\n    @Override\n    public Dialog onCreateDialog(int id) {\n        if (id == ERROR_DIALOG_ID) {\n            String hostname = mHostnameField.getText().toString().trim();\n            String portStr = mPortField.getText().toString().trim();\n            String exclList = mExclusionListField.getText().toString().trim();"}
{"magic_number_smell": "\n        @Override\n        public void onClick(View v) {\n            if (!runKeyguardConfirmation(55)) {\n                showFinalConfirmation();\n            }\n        }", "refactored_code": "    private static final int KEYGUARD_REQUEST = 55;\n\n        @Override\n        public void onClick(View v) {\n            if (!runKeyguardConfirmation(KEYGUARD_REQUEST)) {\n                showFinalConfirmation();\n            }\n        }"}
{"magic_number_smell": "    @VisibleForTesting\n    protected static final String KEY_APN_SUBID = \"resetApnSubId\";\n\n    private int mResetOptions = 0x00;\n    private String mResetEsimPackageName;\n    private int mResetTelephonyManager = INVALID_SUBSCRIPTION_ID;\n    private int mResetApn = INVALID_SUBSCRIPTION_ID;", "refactored_code": "    public static final int RESET_NONE = 0x00;\n    @VisibleForTesting\n    protected static final String KEY_APN_SUBID = \"resetApnSubId\";\n\n    private int mResetOptions = RESET_NONE;\n    private String mResetEsimPackageName;\n    private int mResetTelephonyManager = INVALID_SUBSCRIPTION_ID;\n    private int mResetApn = INVALID_SUBSCRIPTION_ID;"}
{"magic_number_smell": "    }\n\n    private void showHtmlFromDefaultXmlFiles() {\n        getSupportLoaderManager().initLoader(0, Bundle.EMPTY, this);\n    }\n\n    @VisibleForTesting", "refactored_code": "    private static final int LOADER_ID_LICENSE_HTML_LOADER = 0;\n    }\n\n    private void showHtmlFromDefaultXmlFiles() {\n        getSupportLoaderManager().initLoader(LOADER_ID_LICENSE_HTML_LOADER, Bundle.EMPTY, this);\n    }\n\n    @VisibleForTesting"}
{"magic_number_smell": "    }\n\n    private void addPreferenceToTop(LayoutPreference preference) {\n        preference.setOrder(-1);\n        if (getPreferenceScreen() != null) {\n            getPreferenceScreen().addPreference(preference);\n        }", "refactored_code": "    private static final int ORDER_FIRST = -1;\n    }\n\n    private void addPreferenceToTop(LayoutPreference preference) {\n        preference.setOrder(ORDER_FIRST);\n        if (getPreferenceScreen() != null) {\n            getPreferenceScreen().addPreference(preference);\n        }"}
{"magic_number_smell": "            // Fade out\n            mCurrentCertLayout.animate()\n                    .alpha(0)\n                    .setDuration(300)\n                    .setInterpolator(AnimationUtils.loadInterpolator(mActivity,\n                            android.R.interpolator.fast_out_linear_in))\n                    .withEndAction(callback)", "refactored_code": "        private static final long OUT_DURATION_MS = 300;\n            // Fade out\n            mCurrentCertLayout.animate()\n                    .alpha(0)\n                    .setDuration(OUT_DURATION_MS)\n                    .setInterpolator(AnimationUtils.loadInterpolator(mActivity,\n                            android.R.interpolator.fast_out_linear_in))\n                    .withEndAction(callback)"}
{"magic_number_smell": "\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        if (requestCode == 1) {\n            int userId = mConfirmingCredentialUser;\n            IntConsumer listener = mConfirmingCredentialListener;\n            // reset them before calling the listener because the listener may call back to start", "refactored_code": "    private static final int REQUEST_CONFIRM_CREDENTIALS = 1;\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        if (requestCode == REQUEST_CONFIRM_CREDENTIALS) {\n            int userId = mConfirmingCredentialUser;\n            IntConsumer listener = mConfirmingCredentialListener;\n            // reset them before calling the listener because the listener may call back to start"}
{"magic_number_smell": "        @Override\n        public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n            final LayoutInflater inflater = LayoutInflater.from(parent.getContext());\n            return new ViewHolder(inflater.inflate(R.layout.user_credential_preference, parent, false));\n        }\n\n        @Override", "refactored_code": "        private static final int LAYOUT_RESOURCE = R.layout.user_credential_preference;\n        @Override\n        public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n            final LayoutInflater inflater = LayoutInflater.from(parent.getContext());\n            return new ViewHolder(inflater.inflate(LAYOUT_RESOURCE, parent, false));\n        }\n\n        @Override"}
{"magic_number_smell": "                    Settings.Secure.ACCESSIBILITY_FLOATING_MENU_SIZE, DEFAULT_SIZE);\n            final int opacity = (int) (Settings.Secure.getFloat(mContentResolver,\n                    Settings.Secure.ACCESSIBILITY_FLOATING_MENU_OPACITY, DEFAULT_OPACITY) * 100);\n            final int floatingMenuIconId = (size == 0)\n                    ? R.drawable.a11y_button_preview_small_floating_menu\n                    : R.drawable.a11y_button_preview_large_floating_menu;\n            mIllustrationPreference.setImageDrawable(", "refactored_code": "    private static final int SMALL_SIZE = 0;\n                    Settings.Secure.ACCESSIBILITY_FLOATING_MENU_SIZE, DEFAULT_SIZE);\n            final int opacity = (int) (Settings.Secure.getFloat(mContentResolver,\n                    Settings.Secure.ACCESSIBILITY_FLOATING_MENU_OPACITY, DEFAULT_OPACITY) * 100);\n            final int floatingMenuIconId = (size == SMALL_SIZE)\n                    ? R.drawable.a11y_button_preview_small_floating_menu\n                    : R.drawable.a11y_button_preview_large_floating_menu;\n            mIllustrationPreference.setImageDrawable("}
{"magic_number_smell": "        final View view = super.onCreateView(inflater, container, savedInstanceState);\n        final PreferenceCategory controlCategory = findPreference(KEY_HEARING_OPTIONS_CATEGORY);\n        // To move the shortcut preference under controlCategory need to remove the original added.\n        mShortcutPreference.setOrder(20);\n        getPreferenceScreen().removePreference(mShortcutPreference);\n        controlCategory.addPreference(mShortcutPreference);\n        return view;", "refactored_code": "    private static final int SHORTCUT_PREFERENCE_IN_CATEGORY_INDEX = 20;\n        final View view = super.onCreateView(inflater, container, savedInstanceState);\n        final PreferenceCategory controlCategory = findPreference(KEY_HEARING_OPTIONS_CATEGORY);\n        // To move the shortcut preference under controlCategory need to remove the original added.\n        mShortcutPreference.setOrder(SHORTCUT_PREFERENCE_IN_CATEGORY_INDEX);\n        getPreferenceScreen().removePreference(mShortcutPreference);\n        controlCategory.addPreference(mShortcutPreference);\n        return view;"}
{"magic_number_smell": "        }\n\n        private void sendUpdate() {\n            mHandler.postDelayed(mUpdateRunnable, 1000);\n        }\n    };\n", "refactored_code": "    private static final long DELAY_UPDATE_SERVICES_MILLIS = 1000;\n        }\n\n        private void sendUpdate() {\n            mHandler.postDelayed(mUpdateRunnable, DELAY_UPDATE_SERVICES_MILLIS);\n        }\n    };\n"}
{"magic_number_smell": "    protected static final String KEY_SAVED_QS_TOOLTIP_RESHOW = \"qs_tooltip_reshow\";\n    protected static final int -1 = -1;\n    // Save user's shortcutType value when savedInstance has value (e.g. device rotated).\n    protected int mSavedCheckBoxValue = -1;\n\n    protected ShortcutPreference mShortcutPreference;\n    protected Dialog mDialog;", "refactored_code": "    protected static final int NOT_SET = -1;\n    protected static final String KEY_SAVED_QS_TOOLTIP_RESHOW = \"qs_tooltip_reshow\";\n    protected static final int NOT_SET = -1;\n    // Save user's shortcutType value when savedInstance has value (e.g. device rotated).\n    protected int mSavedCheckBoxValue = NOT_SET;\n\n    protected ShortcutPreference mShortcutPreference;\n    protected Dialog mDialog;"}
{"magic_number_smell": "                0.f /* default */, UserHandle.USER_CURRENT);\n        // Rescale balance to range 0-BALANCE_MAX_VALUE centered at BALANCE_MAX_VALUE / 2.\n        mSeekBar.setMax(BALANCE_MAX_VALUE);\n        mSeekBar.setProgress((int) (balance * 100.f) + 100);\n        mSeekBar.setEnabled(isEnabled());\n    }\n}", "refactored_code": "    private static final int BALANCE_CENTER_VALUE = 100;\n                0.f /* default */, UserHandle.USER_CURRENT);\n        // Rescale balance to range 0-BALANCE_MAX_VALUE centered at BALANCE_MAX_VALUE / 2.\n        mSeekBar.setMax(BALANCE_MAX_VALUE);\n        mSeekBar.setProgress((int) (balance * 100.f) + BALANCE_CENTER_VALUE);\n        mSeekBar.setEnabled(isEnabled());\n    }\n}"}
{"magic_number_smell": "    protected void onBindListItem(View view, int index) {\n        final SubtitleView preview = (SubtitleView) view.findViewById(R.id.preview);\n\n        preview.setForegroundColor(Color.WHITE);\n        preview.setBackgroundColor(DEFAULT_BACKGROUND_COLOR);\n\n        final float density = getContext().getResources().getDisplayMetrics().density;", "refactored_code": "    private static final int DEFAULT_FOREGROUND_COLOR = Color.WHITE;\n    protected void onBindListItem(View view, int index) {\n        final SubtitleView preview = (SubtitleView) view.findViewById(R.id.preview);\n\n        preview.setForegroundColor(DEFAULT_FOREGROUND_COLOR);\n        preview.setBackgroundColor(DEFAULT_BACKGROUND_COLOR);\n\n        final float density = getContext().getResources().getDisplayMetrics().density;"}
{"magic_number_smell": "    private void putFloatingMenuFadeValue(boolean isEnabled) {\n        Settings.Secure.putInt(mContentResolver,\n                Settings.Secure.ACCESSIBILITY_FLOATING_MENU_FADE_ENABLED,\n                isEnabled ? ON : 0);\n    }\n}\n", "refactored_code": "    private static final int OFF = 0;\n    private void putFloatingMenuFadeValue(boolean isEnabled) {\n        Settings.Secure.putInt(mContentResolver,\n                Settings.Secure.ACCESSIBILITY_FLOATING_MENU_FADE_ENABLED,\n                isEnabled ? ON : OFF);\n    }\n}\n"}
{"magic_number_smell": "\n    private void updateAvailabilityStatus() {\n        final boolean fadeEnabled = Settings.Secure.getInt(mContentResolver,\n                Settings.Secure.ACCESSIBILITY_FLOATING_MENU_FADE_ENABLED, 1)\n                == 1;\n\n        mPreference.setEnabled(AccessibilityUtil.isFloatingMenuEnabled(mContext) && fadeEnabled);", "refactored_code": "    private static final int FADE_ENABLED = 1;\n\n    private void updateAvailabilityStatus() {\n        final boolean fadeEnabled = Settings.Secure.getInt(mContentResolver,\n                Settings.Secure.ACCESSIBILITY_FLOATING_MENU_FADE_ENABLED, FADE_ENABLED)\n                == FADE_ENABLED;\n\n        mPreference.setEnabled(AccessibilityUtil.isFloatingMenuEnabled(mContext) && fadeEnabled);"}
{"magic_number_smell": "        final ContentResolver resolver = getContext().getContentResolver();\n        final List<String> strEntryValues =\n                Arrays.asList(resources.getStringArray(R.array.entryvalues_font_size));\n        setDefaultValue(1.0f);\n        final float currentScale =\n                Settings.System.getFloat(resolver, Settings.System.FONT_SCALE, getDefaultValue());\n        setInitialIndex(fontSizeValueToIndex(currentScale, strEntryValues.toArray(new String[0])));", "refactored_code": "    private static final float FONT_SCALE_DEF_VALUE = 1.0f;\n        final ContentResolver resolver = getContext().getContentResolver();\n        final List<String> strEntryValues =\n                Arrays.asList(resources.getStringArray(R.array.entryvalues_font_size));\n        setDefaultValue(FONT_SCALE_DEF_VALUE);\n        final float currentScale =\n                Settings.System.getFloat(resolver, Settings.System.FONT_SCALE, getDefaultValue());\n        setInitialIndex(fontSizeValueToIndex(currentScale, strEntryValues.toArray(new String[0])));"}
{"magic_number_smell": "    static final String PREF_KEY = \"screen_magnification_mode\";\n    private static final int 10 = 10;\n    @VisibleForTesting\n    static final int DIALOG_MAGNIFICATION_MODE = 10 + 1;\n    @VisibleForTesting\n    static final int DIALOG_MAGNIFICATION_TRIPLE_TAP_WARNING = 10 + 2;\n    @VisibleForTesting", "refactored_code": "    private static final int DIALOG_ID_BASE = 10;\n    static final String PREF_KEY = \"screen_magnification_mode\";\n    private static final int DIALOG_ID_BASE = 10;\n    @VisibleForTesting\n    static final int DIALOG_MAGNIFICATION_MODE = DIALOG_ID_BASE + 1;\n    @VisibleForTesting\n    static final int DIALOG_MAGNIFICATION_TRIPLE_TAP_WARNING = DIALOG_ID_BASE + 2;\n    @VisibleForTesting"}
{"magic_number_smell": "        mCaptionHelper.applyCaptionProperties(previewText, previewViewport, value);\n\n        final float density = getContext().getResources().getDisplayMetrics().density;\n        previewText.setTextSize(32f * density);\n\n        final CharSequence title = getTitleAt(index);\n        if (title != null) {", "refactored_code": "    private static final float DEFAULT_FONT_SIZE = 32f;\n        mCaptionHelper.applyCaptionProperties(previewText, previewViewport, value);\n\n        final float density = getContext().getResources().getDisplayMetrics().density;\n        previewText.setTextSize(DEFAULT_FONT_SIZE * density);\n\n        final CharSequence title = getTitleAt(index);\n        if (title != null) {"}
{"magic_number_smell": "\n    @Override\n    public int getSliderPosition() {\n        return 100 - mColorDisplayManager.getReduceBrightColorsStrength();\n    }\n\n    @Override", "refactored_code": "    private static final int INVERSE_PERCENTAGE_BASE = 100;\n\n    @Override\n    public int getSliderPosition() {\n        return INVERSE_PERCENTAGE_BASE - mColorDisplayManager.getReduceBrightColorsStrength();\n    }\n\n    @Override"}
{"magic_number_smell": "        preference.setFragment(fragment);\n        preference.setIconSize(ICON_SIZE_MEDIUM);\n        preference.setPersistent(false); // Disable SharedPreferences.\n        preference.setOrder(-1);\n\n        return preference;\n    }", "refactored_code": "    private static final int FIRST_PREFERENCE_IN_CATEGORY_INDEX = -1;\n        preference.setFragment(fragment);\n        preference.setIconSize(ICON_SIZE_MEDIUM);\n        preference.setPersistent(false); // Disable SharedPreferences.\n        preference.setOrder(FIRST_PREFERENCE_IN_CATEGORY_INDEX);\n\n        return preference;\n    }"}
{"magic_number_smell": "            }\n            mTimer.schedule(getStartTask(), startDelay);\n            mTimer.schedule(getStopTask(),\n                    startDelay + 5000 + MARGIN_FOR_STOP_DELAY_MS);\n        }\n    }\n", "refactored_code": "    private static final int PREVIEW_LONG_TIME_MS = 5000;\n            }\n            mTimer.schedule(getStartTask(), startDelay);\n            mTimer.schedule(getStopTask(),\n                    startDelay + PREVIEW_LONG_TIME_MS + MARGIN_FOR_STOP_DELAY_MS);\n        }\n    }\n"}
{"magic_number_smell": "        final int initialPagerIndex =\n                mLastFontProgress * mDisplaySizeData.getValues().size() + mLastDisplayProgress;\n        mPreviewPreference.setLastLayerIndex(initialPagerIndex);\n        pagerAdapter.setPreviewLayer(initialPagerIndex, 0,\n                FRAME_INITIAL_INDEX, /* animate= */ false);\n    }\n", "refactored_code": "    private static final int LAYER_INITIAL_INDEX = 0;\n        final int initialPagerIndex =\n                mLastFontProgress * mDisplaySizeData.getValues().size() + mLastDisplayProgress;\n        mPreviewPreference.setLastLayerIndex(initialPagerIndex);\n        pagerAdapter.setPreviewLayer(initialPagerIndex, LAYER_INITIAL_INDEX,\n                FRAME_INITIAL_INDEX, /* animate= */ false);\n    }\n"}
{"magic_number_smell": "    public void onRadioButtonClicked(SelectorWithWidgetPreference preference) {\n        final int mode = getAutoclickModeToKeyMap().get(mPreferenceKey);\n        Settings.Secure.putInt(mContentResolver, Settings.Secure.ACCESSIBILITY_AUTOCLICK_ENABLED,\n                (mode != 0) ? ON : OFF);\n        mSharedPreferences.edit().putInt(KEY_DELAY_MODE, mode).apply();\n        if (mode != AUTOCLICK_CUSTOM_MODE) {\n            Settings.Secure.putInt(mContentResolver, Settings.Secure.ACCESSIBILITY_AUTOCLICK_DELAY,", "refactored_code": "    private static final int AUTOCLICK_OFF_MODE = 0;\n    public void onRadioButtonClicked(SelectorWithWidgetPreference preference) {\n        final int mode = getAutoclickModeToKeyMap().get(mPreferenceKey);\n        Settings.Secure.putInt(mContentResolver, Settings.Secure.ACCESSIBILITY_AUTOCLICK_ENABLED,\n                (mode != AUTOCLICK_OFF_MODE) ? ON : OFF);\n        mSharedPreferences.edit().putInt(KEY_DELAY_MODE, mode).apply();\n        if (mode != AUTOCLICK_CUSTOM_MODE) {\n            Settings.Secure.putInt(mContentResolver, Settings.Secure.ACCESSIBILITY_AUTOCLICK_DELAY,"}
{"magic_number_smell": "    protected CharSequence mHtmlDescription;\n    protected CharSequence mTopIntroTitle;\n    // Save user's shortcutType value when savedInstance has value (e.g. device rotated).\n    protected int mSavedCheckBoxValue = -1;\n    private CharSequence mDescription;\n    private TouchExplorationStateChangeListener mTouchExplorationStateChangeListener;\n    private AccessibilitySettingsContentObserver mSettingsContentObserver;", "refactored_code": "    public static final int NOT_SET = -1;\n    protected CharSequence mHtmlDescription;\n    protected CharSequence mTopIntroTitle;\n    // Save user's shortcutType value when savedInstance has value (e.g. device rotated).\n    protected int mSavedCheckBoxValue = NOT_SET;\n    private CharSequence mDescription;\n    private TouchExplorationStateChangeListener mTouchExplorationStateChangeListener;\n    private AccessibilitySettingsContentObserver mSettingsContentObserver;"}
{"magic_number_smell": "    public boolean onActivityResult(int requestCode, int resultCode, Intent data) {\n        // If back from BONDED device page, then no need to show scan result again.\n        // Finish the fragment.\n        if (requestCode == 270 && resultCode == RESULT_OK) {\n            mFragment.finish();\n        }\n        return false;", "refactored_code": "    private static final int REQUEST_CODE_BONDED_DEVICE = 270;\n    public boolean onActivityResult(int requestCode, int resultCode, Intent data) {\n        // If back from BONDED device page, then no need to show scan result again.\n        // Finish the fragment.\n        if (requestCode == REQUEST_CODE_BONDED_DEVICE && resultCode == RESULT_OK) {\n            mFragment.finish();\n        }\n        return false;"}
{"magic_number_smell": "    private int getSyncStatusMessage(int status) {\n        int res;\n        switch (status) {\n            case 0:\n                res = R.string.sync_enabled;\n                break;\n            case SYNC_DISABLED:", "refactored_code": "    public static final int SYNC_ENABLED = 0; // all know sync adapters are enabled and OK\n    private int getSyncStatusMessage(int status) {\n        int res;\n        switch (status) {\n            case SYNC_ENABLED:\n                res = R.string.sync_enabled;\n                break;\n            case SYNC_DISABLED:"}
{"magic_number_smell": "    private String[] mAuthorities;\n    private int mAuthoritiesCount = 0;\n    private DashboardFragment mFragment;\n    private int mAccountProfileOrder = 101;\n    private AccountRestrictionHelper mHelper;\n    private MetricsFeatureProvider mMetricsFeatureProvider;\n    private @ProfileSelectFragment.ProfileType int mType;", "refactored_code": "    private static final int ORDER_ACCOUNT_PROFILES = 101;\n    private String[] mAuthorities;\n    private int mAuthoritiesCount = 0;\n    private DashboardFragment mFragment;\n    private int mAccountProfileOrder = ORDER_ACCOUNT_PROFILES;\n    private AccountRestrictionHelper mHelper;\n    private MetricsFeatureProvider mMetricsFeatureProvider;\n    private @ProfileSelectFragment.ProfileType int mType;"}
{"magic_number_smell": "\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        MenuItem syncNow = menu.add(0, Menu.FIRST, 0,\n                getString(R.string.sync_menu_sync_now));\n        MenuItem syncCancel = menu.add(0, MENU_SYNC_CANCEL_ID, 0,\n                getString(R.string.sync_menu_sync_cancel));", "refactored_code": "    private static final int MENU_SYNC_NOW_ID = Menu.FIRST;\n\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        MenuItem syncNow = menu.add(0, MENU_SYNC_NOW_ID, 0,\n                getString(R.string.sync_menu_sync_now));\n        MenuItem syncCancel = menu.add(0, MENU_SYNC_CANCEL_ID, 0,\n                getString(R.string.sync_menu_sync_cancel));"}
{"magic_number_smell": "                finish();\n            }\n            break;\n        case 1:\n            if (resultCode == RESULT_CANCELED) {\n                if (data != null) {\n                    startActivityAsUser(data, mUserHandle);", "refactored_code": "    private static final int CHOOSE_ACCOUNT_REQUEST = 1;\n                finish();\n            }\n            break;\n        case CHOOSE_ACCOUNT_REQUEST:\n            if (resultCode == RESULT_CANCELED) {\n                if (data != null) {\n                    startActivityAsUser(data, mUserHandle);"}
{"magic_number_smell": "\n    /** Get the smallest width dp of the window when the split should be used. */\n    public static int getMinCurrentScreenSplitWidthDp() {\n        return 720;\n    }\n\n    /**", "refactored_code": "    private static final int MIN_CURRENT_SCREEN_SPLIT_WIDTH_DP = 720;\n\n    /** Get the smallest width dp of the window when the split should be used. */\n    public static int getMinCurrentScreenSplitWidthDp() {\n        return MIN_CURRENT_SCREEN_SPLIT_WIDTH_DP;\n    }\n\n    /**"}
{"magic_number_smell": "    @VisibleForTesting\n    List<RecentAppStatsMixin.UsageStatsWrapper> loadRecentApps() {\n        final RecentAppStatsMixin recentAppStatsMixin = new RecentAppStatsMixin(mContext,\n                4);\n        recentAppStatsMixin.loadDisplayableRecentApps(4);\n        return recentAppStatsMixin.mRecentApps;\n    }", "refactored_code": "    public static final int SHOW_RECENT_APP_COUNT = 4;\n    @VisibleForTesting\n    List<RecentAppStatsMixin.UsageStatsWrapper> loadRecentApps() {\n        final RecentAppStatsMixin recentAppStatsMixin = new RecentAppStatsMixin(mContext,\n                SHOW_RECENT_APP_COUNT);\n        recentAppStatsMixin.loadDisplayableRecentApps(SHOW_RECENT_APP_COUNT);\n        return recentAppStatsMixin.mRecentApps;\n    }"}
{"magic_number_smell": "        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case 1:\n                    mCallback.onExtraInfoUpdated();\n                    break;\n            }", "refactored_code": "        private static final int MSG_INFO_UPDATED = 1;\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MSG_INFO_UPDATED:\n                    mCallback.onExtraInfoUpdated();\n                    break;\n            }"}
{"magic_number_smell": "\n    private void calculateAvgSentCounts(NotificationsSentState stats) {\n        if (stats != null) {\n            stats.avgSentDaily = Math.round((float) stats.sentCount / 7);\n            if (stats.sentCount < 7) {\n                stats.avgSentWeekly = stats.sentCount;\n            }", "refactored_code": "    private static final int DAYS_TO_CHECK = 7;\n\n    private void calculateAvgSentCounts(NotificationsSentState stats) {\n        if (stats != null) {\n            stats.avgSentDaily = Math.round((float) stats.sentCount / DAYS_TO_CHECK);\n            if (stats.sentCount < DAYS_TO_CHECK) {\n                stats.avgSentWeekly = stats.sentCount;\n            }"}
{"magic_number_smell": "    };\n\n    public AppStateOverlayBridge(Context context, ApplicationsState appState, Callback callback) {\n        super(context, appState, callback, AppOpsManager.OP_SYSTEM_ALERT_WINDOW, PM_PERMISSION);\n    }\n\n    @Override", "refactored_code": "    private static final int APP_OPS_OP_CODE = AppOpsManager.OP_SYSTEM_ALERT_WINDOW;\n    };\n\n    public AppStateOverlayBridge(Context context, ApplicationsState appState, Callback callback) {\n        super(context, appState, callback, APP_OPS_OP_CODE, PM_PERMISSION);\n    }\n\n    @Override"}
{"magic_number_smell": "    private static final int AppOpsManager.OP_GET_USAGE_STATS = AppOpsManager.OP_GET_USAGE_STATS;\n    private static final int APP_OPS_LOADER_STATS = AppOpsManager.OP_LOADER_USAGE_STATS;\n    private static final int[] APP_OPS_OP_CODES = {\n            AppOpsManager.OP_GET_USAGE_STATS,\n            APP_OPS_LOADER_STATS,\n    };\n    private static final String[] PM_PERMISSIONS = {", "refactored_code": "    private static final int APP_OPS_USAGE_STATS = AppOpsManager.OP_GET_USAGE_STATS;\n    private static final int APP_OPS_USAGE_STATS = AppOpsManager.OP_GET_USAGE_STATS;\n    private static final int APP_OPS_LOADER_STATS = AppOpsManager.OP_LOADER_USAGE_STATS;\n    private static final int[] APP_OPS_OP_CODES = {\n            APP_OPS_USAGE_STATS,\n            APP_OPS_LOADER_STATS,\n    };\n    private static final String[] PM_PERMISSIONS = {"}
{"magic_number_smell": "\n    public AppStateWriteSettingsBridge(Context context, ApplicationsState appState, Callback\n            callback) {\n        super(context, appState, callback, AppOpsManager.OP_WRITE_SETTINGS, PM_PERMISSIONS);\n    }\n\n    @Override", "refactored_code": "    private static final int APP_OPS_OP_CODE = AppOpsManager.OP_WRITE_SETTINGS;\n\n    public AppStateWriteSettingsBridge(Context context, ApplicationsState appState, Callback\n            callback) {\n        super(context, appState, callback, APP_OPS_OP_CODE, PM_PERMISSIONS);\n    }\n\n    @Override"}
{"magic_number_smell": "        mButtonsPref\n                .setButton1Text(R.string.clear_user_data_text)\n                .setButton1Icon(R.drawable.ic_settings_delete);\n        if (result == 1) {\n            Log.i(TAG, \"Cleared user data for package : \" + packageName);\n            updateSize();\n        } else {", "refactored_code": "    private static final int OP_SUCCESSFUL = 1;\n        mButtonsPref\n                .setButton1Text(R.string.clear_user_data_text)\n                .setButton1Icon(R.drawable.ic_settings_delete);\n        if (result == OP_SUCCESSFUL) {\n            Log.i(TAG, \"Cleared user data for package : \" + packageName);\n            updateSize();\n        } else {"}
{"magic_number_smell": "    public static boolean includeInCount(int installReason, PackageManager pm,\n            ApplicationInfo info) {\n        final int userId = UserHandle.getUserId(info.uid);\n        if (installReason != -1\n                && pm.getInstallReason(info.packageName,\n                        new UserHandle(userId)) != installReason) {\n            return false;", "refactored_code": "    public static final int IGNORE_INSTALL_REASON = -1;\n    public static boolean includeInCount(int installReason, PackageManager pm,\n            ApplicationInfo info) {\n        final int userId = UserHandle.getUserId(info.uid);\n        if (installReason != IGNORE_INSTALL_REASON\n                && pm.getInstallReason(info.packageName,\n                        new UserHandle(userId)) != installReason) {\n            return false;"}
{"magic_number_smell": "    private int linkStateToIndex(int state) {\n        switch (state) {\n            case INTENT_FILTER_DOMAIN_VERIFICATION_STATUS_ALWAYS:\n                return 0;\n            case INTENT_FILTER_DOMAIN_VERIFICATION_STATUS_NEVER:\n                return NOT_ALLOWED_OPENING;\n            default:", "refactored_code": "    private static final int ALLOW_ALWAYS_OPENING = 0;\n    private int linkStateToIndex(int state) {\n        switch (state) {\n            case INTENT_FILTER_DOMAIN_VERIFICATION_STATUS_ALWAYS:\n                return ALLOW_ALWAYS_OPENING;\n            case INTENT_FILTER_DOMAIN_VERIFICATION_STATUS_NEVER:\n                return NOT_ALLOWED_OPENING;\n            default:"}
{"magic_number_smell": "        mFilterSpinner = (Spinner) mSpinnerHeader.findViewById(R.id.filter_spinner);\n        mFilterAdapter = new SettingsSpinnerAdapter<String>(mFilterSpinner.getContext());\n\n        for (int i = 0; i < 4; i++) {\n            mFilterAdapter.add(getString(sDurationLabels[i]));\n        }\n        mFilterSpinner.setAdapter(mFilterAdapter);", "refactored_code": "    protected static final int NUM_DURATIONS = 4;\n        mFilterSpinner = (Spinner) mSpinnerHeader.findViewById(R.id.filter_spinner);\n        mFilterAdapter = new SettingsSpinnerAdapter<String>(mFilterSpinner.getContext());\n\n        for (int i = 0; i < NUM_DURATIONS; i++) {\n            mFilterAdapter.add(getString(sDurationLabels[i]));\n        }\n        mFilterSpinner.setAdapter(mFilterAdapter);"}
{"magic_number_smell": "\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        mForceStop = menu.add(0, 1, 0, R.string.force_stop);\n        checkForceStop();\n    }\n", "refactored_code": "    public static final int MENU_FORCE_STOP = 1;\n\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        mForceStop = menu.add(0, MENU_FORCE_STOP, 0, R.string.force_stop);\n        checkForceStop();\n    }\n"}
{"magic_number_smell": "    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        super.onCreateOptionsMenu(menu, inflater);\n        mMenuAvg = menu.add(0, Menu.FIRST, 0, R.string.sort_avg_use);\n        mMenuMax = menu.add(0, MENU_SHOW_MAX, 0, R.string.sort_max_use);\n        updateMenu();\n    }", "refactored_code": "    private static final int MENU_SHOW_AVG = Menu.FIRST;\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        super.onCreateOptionsMenu(menu, inflater);\n        mMenuAvg = menu.add(0, MENU_SHOW_AVG, 0, R.string.sort_avg_use);\n        mMenuMax = menu.add(0, MENU_SHOW_MAX, 0, R.string.sort_max_use);\n        updateMenu();\n    }"}
{"magic_number_smell": "\n    // TODO: Find better place for this.\n    public static CharSequence getFrequency(float amount, Context context) {\n        if (amount > .95f) {\n            return context.getString(R.string.always_running,\n                    Utils.formatPercentage((int) (amount * 100)));\n        } else if (amount > SOMETIMES_THRESHOLD) {", "refactored_code": "    private static final float ALWAYS_THRESHOLD = .95f;\n\n    // TODO: Find better place for this.\n    public static CharSequence getFrequency(float amount, Context context) {\n        if (amount > ALWAYS_THRESHOLD) {\n            return context.getString(R.string.always_running,\n                    Utils.formatPercentage((int) (amount * 100)));\n        } else if (amount > SOMETIMES_THRESHOLD) {"}
{"magic_number_smell": "    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        mOptionsMenu = menu;\n        menu.add(0, 1, 1, R.string.show_running_services)\n                .setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);\n        menu.add(0, SHOW_BACKGROUND_PROCESSES, 2, R.string.show_background_processes)\n                .setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);", "refactored_code": "    private static final int SHOW_RUNNING_SERVICES = 1;\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        mOptionsMenu = menu;\n        menu.add(0, SHOW_RUNNING_SERVICES, 1, R.string.show_running_services)\n                .setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);\n        menu.add(0, SHOW_BACKGROUND_PROCESSES, 2, R.string.show_background_processes)\n                .setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);"}
{"magic_number_smell": "        controllers.add(mInstantAppButtonPreferenceController);\n        mAppButtonsPreferenceController = new AppButtonsPreferenceController(\n                (SettingsActivity) getActivity(), this, lifecycle, packageName, mState,\n                REQUEST_UNINSTALL, 5);\n        controllers.add(mAppButtonsPreferenceController);\n        controllers.add(new AppBatteryPreferenceController(\n                context, this, packageName, getUid(), lifecycle));", "refactored_code": "    private static final int REQUEST_REMOVE_DEVICE_ADMIN = 5;\n        controllers.add(mInstantAppButtonPreferenceController);\n        mAppButtonsPreferenceController = new AppButtonsPreferenceController(\n                (SettingsActivity) getActivity(), this, lifecycle, packageName, mState,\n                REQUEST_UNINSTALL, REQUEST_REMOVE_DEVICE_ADMIN);\n        controllers.add(mAppButtonsPreferenceController);\n        controllers.add(new AppBatteryPreferenceController(\n                context, this, packageName, getUid(), lifecycle));"}
{"magic_number_smell": "        if (intent != null) {\n            String action = intent.getAction();\n            long sessionId = intent.getLongExtra(\n                    Intent.ACTION_AUTO_REVOKE_PERMISSIONS, 0);\n            if ((action != null && action.equals(Intent.ACTION_AUTO_REVOKE_PERMISSIONS))\n                    || sessionId != 0) {\n                // If intent is Auto revoke, and we don't already have a session ID, make one", "refactored_code": "    private static final long INVALID_SESSION_ID = 0;\n        if (intent != null) {\n            String action = intent.getAction();\n            long sessionId = intent.getLongExtra(\n                    Intent.ACTION_AUTO_REVOKE_PERMISSIONS, INVALID_SESSION_ID);\n            if ((action != null && action.equals(Intent.ACTION_AUTO_REVOKE_PERMISSIONS))\n                    || sessionId != INVALID_SESSION_ID) {\n                // If intent is Auto revoke, and we don't already have a session ID, make one"}
{"magic_number_smell": "     */\n    @VisibleForTesting\n    public boolean togglePackageNameEnabled(String packageName) {\n        if (mEnabledPackageNames.size() >= 5) {\n            return false;\n        } else {\n            mEnabledPackageNames.add(packageName);", "refactored_code": "    private static final int MAX_SELECTABLE_PROVIDERS = 5;\n     */\n    @VisibleForTesting\n    public boolean togglePackageNameEnabled(String packageName) {\n        if (mEnabledPackageNames.size() >= MAX_SELECTABLE_PROVIDERS) {\n            return false;\n        } else {\n            mEnabledPackageNames.add(packageName);"}
{"magic_number_smell": "\n    @Override\n    protected AlertDialog createDialog(int id, int errorCode) {\n        if (id == DLG_BASE + 1) {\n            return createVerifiedLinksDialog();\n        }\n        return null;", "refactored_code": "    private static final int DLG_VERIFIED_LINKS = DLG_BASE + 1;\n\n    @Override\n    protected AlertDialog createDialog(int id, int errorCode) {\n        if (id == DLG_VERIFIED_LINKS) {\n            return createVerifiedLinksDialog();\n        }\n        return null;"}
{"magic_number_smell": "                }\n            });\n            if (ownerSet.size() == 0) {\n                SystemClock.sleep(20);\n            }\n        }\n        IntentPickerUtils.logd(\"queryLinksInBackground : SupportedLinkWrapperList size=\"", "refactored_code": "    private static final int PROGRESS_BAR_STEPPING_TIME = 20;\n                }\n            });\n            if (ownerSet.size() == 0) {\n                SystemClock.sleep(PROGRESS_BAR_STEPPING_TIME);\n            }\n        }\n        IntentPickerUtils.logd(\"queryLinksInBackground : SupportedLinkWrapperList size=\""}
{"magic_number_smell": "        mFilters = new AppFilterItem[NUM_FILTER_ENTRIES];\n\n        // High power allowlist, on\n        mFilters[0] = new AppFilterItem(\n                new ApplicationsState.CompoundFilter(\n                        AppStatePowerBridge.FILTER_POWER_ALLOWLISTED,\n                        ApplicationsState.FILTER_ALL_ENABLED),", "refactored_code": "    public static final int FILTER_APPS_POWER_ALLOWLIST = 0;\n        mFilters = new AppFilterItem[NUM_FILTER_ENTRIES];\n\n        // High power allowlist, on\n        mFilters[FILTER_APPS_POWER_ALLOWLIST] = new AppFilterItem(\n                new ApplicationsState.CompoundFilter(\n                        AppStatePowerBridge.FILTER_POWER_ALLOWLISTED,\n                        ApplicationsState.FILTER_ALL_ENABLED),"}
{"magic_number_smell": "        if (ManageApplications.DEBUG) {\n            Log.i(TAG, \"Package \" + packageName + \" cloned successfully.\");\n        }\n        return 0;\n    }\n\n    public int getCloneUserId() {", "refactored_code": "    public static final int SUCCESS = 0;\n        if (ManageApplications.DEBUG) {\n            Log.i(TAG, \"Package \" + packageName + \" cloned successfully.\");\n        }\n        return SUCCESS;\n    }\n\n    public int getCloneUserId() {"}
{"magic_number_smell": "\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        if (requestCode == 1 && mCurrentPkgName != null) {\n            if (mListType == LIST_TYPE_NOTIFICATION || mListType == LIST_TYPE_HIGH_POWER\n                    || mListType == LIST_TYPE_OVERLAY || mListType == LIST_TYPE_WRITE_SETTINGS\n                    || mListType == LIST_TYPE_NFC_TAG_APPS) {", "refactored_code": "    private static final int INSTALLED_APP_DETAILS = 1;\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        if (requestCode == INSTALLED_APP_DETAILS && mCurrentPkgName != null) {\n            if (mListType == LIST_TYPE_NOTIFICATION || mListType == LIST_TYPE_HIGH_POWER\n                    || mListType == LIST_TYPE_OVERLAY || mListType == LIST_TYPE_WRITE_SETTINGS\n                    || mListType == LIST_TYPE_NFC_TAG_APPS) {"}
{"magic_number_smell": "            AppInfoBase.startAppInfoFragment(AppLaunchSettings.class,\n                    mContext.getString(R.string.auto_launch_label),\n                    entry.info.packageName, entry.info.uid, mFragment,\n                    1, mMetricsCategory);\n            return true;\n        }\n        return false;", "refactored_code": "    private static final int INSTALLED_APP_DETAILS = 1;\n            AppInfoBase.startAppInfoFragment(AppLaunchSettings.class,\n                    mContext.getString(R.string.auto_launch_label),\n                    entry.info.packageName, entry.info.uid, mFragment,\n                    INSTALLED_APP_DETAILS, mMetricsCategory);\n            return true;\n        }\n        return false;"}
{"magic_number_smell": "                    .getDefaultDisplay();\n\n        return d.getHeight() > d.getWidth() ?\n            5 : MAX_ADD_MSG_LINES_LANDSCAPE;\n    }\n\n    /**", "refactored_code": "    private static final int MAX_ADD_MSG_LINES_PORTRAIT = 5;\n                    .getDefaultDisplay();\n\n        return d.getHeight() > d.getWidth() ?\n            MAX_ADD_MSG_LINES_PORTRAIT : MAX_ADD_MSG_LINES_LANDSCAPE;\n    }\n\n    /**"}
{"magic_number_smell": "\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        menu.add(Menu.NONE, Menu.FIRST + 42, Menu.NONE,\n                mShowSystem ? R.string.menu_hide_system : R.string.menu_show_system);\n        super.onCreateOptionsMenu(menu, inflater);\n    }", "refactored_code": "    private static final int MENU_SHOW_SYSTEM = Menu.FIRST + 42;\n\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        menu.add(Menu.NONE, MENU_SHOW_SYSTEM, Menu.NONE,\n                mShowSystem ? R.string.menu_hide_system : R.string.menu_show_system);\n        super.onCreateOptionsMenu(menu, inflater);\n    }"}
{"magic_number_smell": "                ParcelFileDescriptor newState) {\n\n            try (FileOutputStream out = new FileOutputStream(newState.getFileDescriptor())) {\n                if (getVersionCode(oldState) != 1) {\n                    data.writeEntityHeader(\"placeholder\", 1);\n                    data.writeEntityData(new byte[1], 1);\n                }", "refactored_code": "        private final int VERSION_CODE = 1;\n                ParcelFileDescriptor newState) {\n\n            try (FileOutputStream out = new FileOutputStream(newState.getFileDescriptor())) {\n                if (getVersionCode(oldState) != VERSION_CODE) {\n                    data.writeEntityHeader(\"placeholder\", 1);\n                    data.writeEntityData(new byte[1], 1);\n                }"}
{"magic_number_smell": "                com.google.android.setupdesign.R.anim.sud_slide_next_out);\n\n        switch (requestCode) {\n            case 1:\n            case REQUEST_CONFIRM_LOCK:\n                mConfirmingCredentials = false;\n                if (isSuccessfulConfirmOrChooseCredential(requestCode, resultCode)) {", "refactored_code": "    private static final int REQUEST_CHOOSE_LOCK = 1;\n                com.google.android.setupdesign.R.anim.sud_slide_next_out);\n\n        switch (requestCode) {\n            case REQUEST_CHOOSE_LOCK:\n            case REQUEST_CONFIRM_LOCK:\n                mConfirmingCredentials = false;\n                if (isSuccessfulConfirmOrChooseCredential(requestCode, resultCode)) {"}
{"magic_number_smell": "    public static final int RESULT_SKIP = RESULT_FIRST_USER + 1;\n\n    /**\n     * Like {@link #RESULT_FIRST_USER} except this one indicates enrollment failed because the\n     * device was left idle. This is used to clear the credential token to require the user to\n     * re-enter their pin/pattern/password before continuing.\n     */", "refactored_code": "    public static final int RESULT_FINISHED = RESULT_FIRST_USER;\n    public static final int RESULT_SKIP = RESULT_FIRST_USER + 1;\n\n    /**\n     * Like {@link #RESULT_FINISHED} except this one indicates enrollment failed because the\n     * device was left idle. This is used to clear the credential token to require the user to\n     * re-enter their pin/pattern/password before continuing.\n     */"}
{"magic_number_smell": "        mLockPatternUtils = FeatureFactory.getFeatureFactory()\n                .getSecurityFeatureProvider()\n                .getLockPatternUtils(context);\n        mProfileChallengeUserId = Utils.getManagedProfileId(mUm, UserHandle.myUserId());\n        mBiometricNavigationUtils = new BiometricNavigationUtils(getUserId());\n        mActiveUnlockStatusUtils = new ActiveUnlockStatusUtils(context);\n    }", "refactored_code": "    private final int mUserId = UserHandle.myUserId();\n        mLockPatternUtils = FeatureFactory.getFeatureFactory()\n                .getSecurityFeatureProvider()\n                .getLockPatternUtils(context);\n        mProfileChallengeUserId = Utils.getManagedProfileId(mUm, mUserId);\n        mBiometricNavigationUtils = new BiometricNavigationUtils(getUserId());\n        mActiveUnlockStatusUtils = new ActiveUnlockStatusUtils(context);\n    }"}
{"magic_number_smell": "    public static final int DEVICE_POSTURE_OPENED = 3;\n    public static final int DEVICE_POSTURE_FLIPPED = 4;\n\n    public static int sAllowEnrollPosture = 0;\n\n    /**\n     * Request was sent for starting another enrollment of a previously", "refactored_code": "    public static final int DEVICE_POSTURE_UNKNOWN = 0;\n    public static final int DEVICE_POSTURE_OPENED = 3;\n    public static final int DEVICE_POSTURE_FLIPPED = 4;\n\n    public static int sAllowEnrollPosture = DEVICE_POSTURE_UNKNOWN;\n\n    /**\n     * Request was sent for starting another enrollment of a previously"}
{"magic_number_smell": "            mFaceEnrollIntroductionIntent.putExtra(\n                    BiometricEnrollBase.EXTRA_KEY_CHALLENGE, challenge);\n            BiometricUtils.launchEnrollForResult(mActivity, mFaceEnrollIntroductionIntent,\n                    3000, hardwareAuthToken, mGkPwHandle, mUserId);\n        });\n    }\n", "refactored_code": "    private static final int REQUEST_FACE_ENROLL = 3000;\n            mFaceEnrollIntroductionIntent.putExtra(\n                    BiometricEnrollBase.EXTRA_KEY_CHALLENGE, challenge);\n            BiometricUtils.launchEnrollForResult(mActivity, mFaceEnrollIntroductionIntent,\n                    REQUEST_FACE_ENROLL, hardwareAuthToken, mGkPwHandle, mUserId);\n        });\n    }\n"}
{"magic_number_smell": "            if (combinedBiometricStatusUtils.hasEnrolled()) {\n                Intent activeUnlockIntent = mActiveUnlockStatusUtils.getIntent();\n                if (activeUnlockIntent != null) {\n                    startActivityForResult(activeUnlockIntent, 1002);\n                }\n            }\n        }", "refactored_code": "    private static final int ACTIVE_UNLOCK_REQUEST = 1002;\n            if (combinedBiometricStatusUtils.hasEnrolled()) {\n                Intent activeUnlockIntent = mActiveUnlockStatusUtils.getIntent();\n                if (activeUnlockIntent != null) {\n                    startActivityForResult(activeUnlockIntent, ACTIVE_UNLOCK_REQUEST);\n                }\n            }\n        }"}
{"magic_number_smell": "public class BiometricSettingsAppPreferenceController extends TogglePreferenceController {\n    private static final int 1 = 1;\n    private static final int OFF = 0;\n    private static final int DEFAULT = 1;\n\n    private int mUserId;\n    private FaceManager mFaceManager;", "refactored_code": "    private static final int ON = 1;\npublic class BiometricSettingsAppPreferenceController extends TogglePreferenceController {\n    private static final int ON = 1;\n    private static final int OFF = 0;\n    private static final int DEFAULT = ON;\n\n    private int mUserId;\n    private FaceManager mFaceManager;"}
{"magic_number_smell": "public class BiometricSettingsKeyguardPreferenceController extends TogglePreferenceController {\n    private static final int 1 = 1;\n    private static final int OFF = 0;\n    private static final int DEFAULT = 1;\n\n    private int mUserId;\n", "refactored_code": "    private static final int ON = 1;\npublic class BiometricSettingsKeyguardPreferenceController extends TogglePreferenceController {\n    private static final int ON = 1;\n    private static final int OFF = 0;\n    private static final int DEFAULT = ON;\n\n    private int mUserId;\n"}
{"magic_number_smell": "    @Override\n    public void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n        if (requestCode == CONFIRM_REQUEST || requestCode == 2002) {\n            mConfirmCredential = false;\n            mDoNotFinishActivity = false;\n            if (resultCode == RESULT_FINISHED || resultCode == RESULT_OK) {", "refactored_code": "    private static final int CHOOSE_LOCK_REQUEST = 2002;\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n        if (requestCode == CONFIRM_REQUEST || requestCode == CHOOSE_LOCK_REQUEST) {\n            mConfirmCredential = false;\n            mDoNotFinishActivity = false;\n            if (resultCode == RESULT_FINISHED || resultCode == RESULT_OK) {"}
{"magic_number_smell": "\n    private int mLastAnimationState;\n    private int mAnimationState;\n    private float mCurrentSize = 10;\n    private float mCurrentAngle; // 0 is to the right, in radians\n    private float mRotationSpeed = ROTATION_SPEED_NORMAL; // speed of dot rotation\n    private float mSweepAngle = 0; // ring sweep, degrees per second", "refactored_code": "    private static final int MIN_STROKE_WIDTH = 10;\n\n    private int mLastAnimationState;\n    private int mAnimationState;\n    private float mCurrentSize = MIN_STROKE_WIDTH;\n    private float mCurrentAngle; // 0 is to the right, in radians\n    private float mRotationSpeed = ROTATION_SPEED_NORMAL; // speed of dot rotation\n    private float mSweepAngle = 0; // ring sweep, degrees per second"}
{"magic_number_smell": "    protected void onBoundsChange(Rect bounds) {\n        mBounds = bounds;\n        mParticleCollection =\n                new ParticleCollection(mContext, mAnimationListener, bounds, 20);\n\n        if (mTimeAnimator == null) {\n            mTimeAnimator = new TimeAnimator();", "refactored_code": "    private static final int BORDER_BOUNDS = 20;\n    protected void onBoundsChange(Rect bounds) {\n        mBounds = bounds;\n        mParticleCollection =\n                new ParticleCollection(mContext, mAnimationListener, bounds, BORDER_BOUNDS);\n\n        if (mTimeAnimator == null) {\n            mTimeAnimator = new TimeAnimator();"}
{"magic_number_smell": "    private Size chooseOptimalSize(Size[] choices) {\n        for (int i = 0; i < choices.length; i++) {\n            if (choices[i].getHeight() == MAX_PREVIEW_HEIGHT\n                    && choices[i].getWidth() == 1920) {\n                return choices[i];\n            }\n        }", "refactored_code": "    private static final int MAX_PREVIEW_WIDTH = 1920;\n    private Size chooseOptimalSize(Size[] choices) {\n        for (int i = 0; i < choices.length; i++) {\n            if (choices[i].getHeight() == MAX_PREVIEW_HEIGHT\n                    && choices[i].getWidth() == MAX_PREVIEW_WIDTH) {\n                return choices[i];\n            }\n        }"}
{"magic_number_smell": "\n    private static final int 1 = 1;\n    private static final int OFF = 0;\n    private static final int DEFAULT = 1;  // face unlock is enabled for BiometricPrompt by default\n\n    private FaceManager mFaceManager;\n", "refactored_code": "    private static final int ON = 1;\n\n    private static final int ON = 1;\n    private static final int OFF = 0;\n    private static final int DEFAULT = ON;  // face unlock is enabled for BiometricPrompt by default\n\n    private FaceManager mFaceManager;\n"}
{"magic_number_smell": "    @Override\n    public boolean isChecked() {\n        return Settings.Secure.getIntForUser(mContext.getContentResolver(),\n                FACE_UNLOCK_ALWAYS_REQUIRE_CONFIRMATION, DEFAULT, getUserId()) == 1;\n    }\n\n    @Override", "refactored_code": "    private static final int ON = 1;\n    @Override\n    public boolean isChecked() {\n        return Settings.Secure.getIntForUser(mContext.getContentResolver(),\n                FACE_UNLOCK_ALWAYS_REQUIRE_CONFIRMATION, DEFAULT, getUserId()) == ON;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    private static final int 1 = 1;\n    private static final int OFF = 0;\n    private static final int DEFAULT = 1;  // face unlock is enabled on keyguard by default\n\n    private FaceManager mFaceManager;\n", "refactored_code": "    private static final int ON = 1;\n\n    private static final int ON = 1;\n    private static final int OFF = 0;\n    private static final int DEFAULT = ON;  // face unlock is enabled on keyguard by default\n\n    private FaceManager mFaceManager;\n"}
{"magic_number_smell": "        // the correct behavior.\n        final int[] order = {3, 7, 11, 2, 6, 10, 1, 5, 9, 0, 4, 8};\n\n        for (int i = 0; i < 12; i++) {\n            AnimationParticle particle = new AnimationParticle(context, mParticleListener, bounds,\n                    borderWidth, order[i], 12, colors);\n            if (mPrimariesInProgress.contains(order[i])) {", "refactored_code": "    private static final int NUM_PARTICLES = 12;\n        // the correct behavior.\n        final int[] order = {3, 7, 11, 2, 6, 10, 1, 5, 9, 0, 4, 8};\n\n        for (int i = 0; i < NUM_PARTICLES; i++) {\n            AnimationParticle particle = new AnimationParticle(context, mParticleListener, bounds,\n                    borderWidth, order[i], NUM_PARTICLES, colors);\n            if (mPrimariesInProgress.contains(order[i])) {"}
{"magic_number_smell": "    private void animateProgress(int progress) {\n        if (mCanAssumeUdfps) {\n            // UDFPS animations are owned by SystemUI\n            if (progress >= 10000) {\n                // Wait for any animations in SysUI to finish, then proceed to next page\n                getMainThreadHandler().postDelayed(mDelayedFinishRunnable, getFinishDelay());\n            }", "refactored_code": "    private static final int PROGRESS_BAR_MAX = 10000;\n    private void animateProgress(int progress) {\n        if (mCanAssumeUdfps) {\n            // UDFPS animations are owned by SystemUI\n            if (progress >= PROGRESS_BAR_MAX) {\n                // Wait for any animations in SysUI to finish, then proceed to next page\n                getMainThreadHandler().postDelayed(mDelayedFinishRunnable, getFinishDelay());\n            }"}
{"magic_number_smell": "    }\n\n    private void startAlphaAnimation() {\n        mPulsePaint.setAlpha((int) (255f * 0.15f));\n        ValueAnimator animator = ValueAnimator.ofFloat(0.15f, 0f);\n        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n            @Override", "refactored_code": "    private static final float MAX_PULSE_ALPHA = 0.15f;\n    }\n\n    private void startAlphaAnimation() {\n        mPulsePaint.setAlpha((int) (255f * MAX_PULSE_ALPHA));\n        ValueAnimator animator = ValueAnimator.ofFloat(MAX_PULSE_ALPHA, 0f);\n        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n            @Override"}
{"magic_number_smell": "                    // We've been locked out.  Reset after 30s.\n                    if (!mHandler.hasCallbacks(mFingerprintLockoutReset)) {\n                        mHandler.postDelayed(mFingerprintLockoutReset,\n                                30000);\n                    }\n                    break;\n                case FingerprintManager.FINGERPRINT_ERROR_LOCKOUT_PERMANENT:", "refactored_code": "    private static final long LOCKOUT_DURATION = 30000; // time we have to wait for fp to reset, ms\n                    // We've been locked out.  Reset after 30s.\n                    if (!mHandler.hasCallbacks(mFingerprintLockoutReset)) {\n                        mHandler.postDelayed(mFingerprintLockoutReset,\n                                LOCKOUT_DURATION);\n                    }\n                    break;\n                case FingerprintManager.FINGERPRINT_ERROR_LOCKOUT_PERMANENT:"}
{"magic_number_smell": "                final boolean isMovingToCenter = point.x == 0f && point.y == 0f;\n                final long duration = isMovingToCenter\n                        ? TARGET_ANIM_DURATION_SHORT\n                        : 800L;\n\n                final ValueAnimator scale = ValueAnimator.ofFloat(0, (float) Math.PI);\n                scale.setDuration(duration);", "refactored_code": "    private static final long TARGET_ANIM_DURATION_LONG = 800L;\n                final boolean isMovingToCenter = point.x == 0f && point.y == 0f;\n                final long duration = isMovingToCenter\n                        ? TARGET_ANIM_DURATION_SHORT\n                        : TARGET_ANIM_DURATION_LONG;\n\n                final ValueAnimator scale = ValueAnimator.ofFloat(0, (float) Math.PI);\n                scale.setDuration(duration);"}
{"magic_number_smell": "            return new PointF(0f, 0f);\n        }\n\n        float scale = 0.5f;\n        if (Build.IS_ENG || Build.IS_USERDEBUG) {\n            scale = Settings.Secure.getFloatForUser(mContext.getContentResolver(),\n                    SCALE_OVERRIDE, 0.5f,", "refactored_code": "    private static final float SCALE = 0.5f;\n            return new PointF(0f, 0f);\n        }\n\n        float scale = SCALE;\n        if (Build.IS_ENG || Build.IS_USERDEBUG) {\n            scale = Settings.Secure.getFloatForUser(mContext.getContentResolver(),\n                    SCALE_OVERRIDE, SCALE,"}
{"magic_number_smell": "        }\n\n        mCheckmarkAnimator = ValueAnimator.ofFloat(mCheckmarkScale, 1f);\n        mCheckmarkAnimator.setStartDelay(200L);\n        mCheckmarkAnimator.setDuration(CHECKMARK_ANIMATION_DURATION_MS);\n        mCheckmarkAnimator.setInterpolator(mCheckmarkInterpolator);\n        mCheckmarkAnimator.addUpdateListener(mCheckmarkUpdateListener);", "refactored_code": "    private static final long CHECKMARK_ANIMATION_DELAY_MS = 200L;\n        }\n\n        mCheckmarkAnimator = ValueAnimator.ofFloat(mCheckmarkScale, 1f);\n        mCheckmarkAnimator.setStartDelay(CHECKMARK_ANIMATION_DELAY_MS);\n        mCheckmarkAnimator.setDuration(CHECKMARK_ANIMATION_DURATION_MS);\n        mCheckmarkAnimator.setInterpolator(mCheckmarkInterpolator);\n        mCheckmarkAnimator.addUpdateListener(mCheckmarkUpdateListener);"}
{"magic_number_smell": "    public static final int FINGERPRINT_ENROLL_ENROLLING_CANCELED_BECAUSE_BACK_PRESSED = 3;\n\n    @IntDef(prefix = { \"FINGERPRINT_ENROLL_ENROLLING_ACTION_\" }, value = {\n            0,\n            FINGERPRINT_ENROLL_ENROLLING_ACTION_SHOW_ICON_TOUCH_DIALOG,\n            FINGERPRINT_ENROLL_ENROLLING_CANCELED_BECAUSE_USER_SKIP\n    })", "refactored_code": "    public static final int FINGERPRINT_ENROLL_ENROLLING_ACTION_DONE = 0;\n    public static final int FINGERPRINT_ENROLL_ENROLLING_CANCELED_BECAUSE_BACK_PRESSED = 3;\n\n    @IntDef(prefix = { \"FINGERPRINT_ENROLL_ENROLLING_ACTION_\" }, value = {\n            FINGERPRINT_ENROLL_ENROLLING_ACTION_DONE,\n            FINGERPRINT_ENROLL_ENROLLING_ACTION_SHOW_ICON_TOUCH_DIALOG,\n            FINGERPRINT_ENROLL_ENROLLING_CANCELED_BECAUSE_USER_SKIP\n    })"}
{"magic_number_smell": "    public static final int FINGERPRINT_ENROLL_FIND_SENSOR_ACTION_START = 2;\n\n    @IntDef(prefix = { \"FINGERPRINT_ENROLL_FIND_SENSOR_ACTION_\" }, value = {\n            0,\n            FINGERPRINT_ENROLL_FIND_SENSOR_ACTION_DIALOG,\n            FINGERPRINT_ENROLL_FIND_SENSOR_ACTION_START\n    })", "refactored_code": "    public static final int FINGERPRINT_ENROLL_FIND_SENSOR_ACTION_SKIP = 0;\n    public static final int FINGERPRINT_ENROLL_FIND_SENSOR_ACTION_START = 2;\n\n    @IntDef(prefix = { \"FINGERPRINT_ENROLL_FIND_SENSOR_ACTION_\" }, value = {\n            FINGERPRINT_ENROLL_FIND_SENSOR_ACTION_SKIP,\n            FINGERPRINT_ENROLL_FIND_SENSOR_ACTION_DIALOG,\n            FINGERPRINT_ENROLL_FIND_SENSOR_ACTION_START\n    })"}
{"magic_number_smell": "    public static final int FINGERPRINT_ENROLL_FINISH_ACTION_NEXT_BUTTON_CLICK = 1;\n\n    @IntDef(prefix = { \"FINGERPRINT_ENROLL_FINISH_ACTION_\" }, value = {\n            0,\n            FINGERPRINT_ENROLL_FINISH_ACTION_NEXT_BUTTON_CLICK\n    })\n    @Retention(RetentionPolicy.SOURCE)", "refactored_code": "    public static final int FINGERPRINT_ENROLL_FINISH_ACTION_ADD_BUTTON_CLICK = 0;\n    public static final int FINGERPRINT_ENROLL_FINISH_ACTION_NEXT_BUTTON_CLICK = 1;\n\n    @IntDef(prefix = { \"FINGERPRINT_ENROLL_FINISH_ACTION_\" }, value = {\n            FINGERPRINT_ENROLL_FINISH_ACTION_ADD_BUTTON_CLICK,\n            FINGERPRINT_ENROLL_FINISH_ACTION_NEXT_BUTTON_CLICK\n    })\n    @Retention(RetentionPolicy.SOURCE)"}
{"magic_number_smell": "                final boolean isMovingToCenter = point.x == 0f && point.y == 0f;\n                final long duration = isMovingToCenter\n                        ? TARGET_ANIM_DURATION_SHORT\n                        : 800L;\n\n                final ValueAnimator scale = ValueAnimator.ofFloat(0, (float) Math.PI);\n                scale.setDuration(duration);", "refactored_code": "    private static final long TARGET_ANIM_DURATION_LONG = 800L;\n                final boolean isMovingToCenter = point.x == 0f && point.y == 0f;\n                final long duration = isMovingToCenter\n                        ? TARGET_ANIM_DURATION_SHORT\n                        : TARGET_ANIM_DURATION_LONG;\n\n                final ValueAnimator scale = ValueAnimator.ofFloat(0, (float) Math.PI);\n                scale.setDuration(duration);"}
{"magic_number_smell": "        }\n\n        mCheckmarkAnimator = ValueAnimator.ofFloat(mCheckmarkScale, 1f);\n        mCheckmarkAnimator.setStartDelay(200L);\n        mCheckmarkAnimator.setDuration(CHECKMARK_ANIMATION_DURATION_MS);\n        mCheckmarkAnimator.setInterpolator(mCheckmarkInterpolator);\n        mCheckmarkAnimator.addUpdateListener(mCheckmarkUpdateListener);", "refactored_code": "    private static final long CHECKMARK_ANIMATION_DELAY_MS = 200L;\n        }\n\n        mCheckmarkAnimator = ValueAnimator.ofFloat(mCheckmarkScale, 1f);\n        mCheckmarkAnimator.setStartDelay(CHECKMARK_ANIMATION_DELAY_MS);\n        mCheckmarkAnimator.setDuration(CHECKMARK_ANIMATION_DURATION_MS);\n        mCheckmarkAnimator.setInterpolator(mCheckmarkInterpolator);\n        mCheckmarkAnimator.addUpdateListener(mCheckmarkUpdateListener);"}
{"magic_number_smell": "            if (batteryMetaKey == BluetoothDevice.METADATA_UNTETHERED_CASE_BATTERY) {\n                lowBatteryLevel = CASE_LOW_BATTERY_LEVEL;\n            } else {\n                lowBatteryLevel = 15;\n            }\n        }\n", "refactored_code": "    private static final int LOW_BATTERY_LEVEL = 15;\n            if (batteryMetaKey == BluetoothDevice.METADATA_UNTETHERED_CASE_BATTERY) {\n                lowBatteryLevel = CASE_LOW_BATTERY_LEVEL;\n            } else {\n                lowBatteryLevel = LOW_BATTERY_LEVEL;\n            }\n        }\n"}
{"magic_number_smell": "    private void initUi() {\n        setLayoutResource(com.android.settingslib.R.layout.preference_access_point);\n        setWidgetLayoutResource(com.android.settingslib.R.layout.access_point_friction_widget);\n        mTitle = getContext().getString(R.string.device_info_default);\n        mStatus = false;\n        final Drawable drawable = getContext().getDrawable(RESOURCE_ID_ICON);\n        if (drawable != null) {", "refactored_code": "    private static final int RESOURCE_ID_UNKNOWN_PROGRAM_INFO = R.string.device_info_default;\n    private void initUi() {\n        setLayoutResource(com.android.settingslib.R.layout.preference_access_point);\n        setWidgetLayoutResource(com.android.settingslib.R.layout.access_point_friction_widget);\n        mTitle = getContext().getString(RESOURCE_ID_UNKNOWN_PROGRAM_INFO);\n        mStatus = false;\n        final Drawable drawable = getContext().getDrawable(RESOURCE_ID_ICON);\n        if (drawable != null) {"}
{"magic_number_smell": "    @VisibleForTesting\n    PreferenceCategory mPreferenceCategory;\n    @VisibleForTesting\n    int mAssociationId = -1;\n\n    private CachedBluetoothDevice mCachedDevice;\n    private CompanionDeviceManager mCompanionDeviceManager;", "refactored_code": "    private static final int DUMMY_ASSOCIATION_ID = -1;\n    @VisibleForTesting\n    PreferenceCategory mPreferenceCategory;\n    @VisibleForTesting\n    int mAssociationId = DUMMY_ASSOCIATION_ID;\n\n    private CachedBluetoothDevice mCachedDevice;\n    private CompanionDeviceManager mCompanionDeviceManager;"}
{"magic_number_smell": "            preference.setLayoutResource(R.layout.preference_bluetooth_profile_category);\n            preference.setEnabled(false);\n            preference.setKey(KEY_BOTTOM_PREFERENCE);\n            preference.setOrder(99);\n            preference.setSelectable(false);\n            mProfilesContainer.addPreference(preference);\n        }", "refactored_code": "    private static final int ORDINAL = 99;\n            preference.setLayoutResource(R.layout.preference_bluetooth_profile_category);\n            preference.setEnabled(false);\n            preference.setKey(KEY_BOTTOM_PREFERENCE);\n            preference.setOrder(ORDINAL);\n            preference.setSelectable(false);\n            mProfilesContainer.addPreference(preference);\n        }"}
{"magic_number_smell": "                .collect(Collectors.toList());\n\n        for (RestrictedPreference preference : preferences) {\n            preference.setOrder(99);\n            mPreferenceCategory.addPreference(preference);\n        }\n    }", "refactored_code": "    private static final int ORDINAL = 99;\n                .collect(Collectors.toList());\n\n        for (RestrictedPreference preference : preferences) {\n            preference.setOrder(ORDINAL);\n            mPreferenceCategory.addPreference(preference);\n        }\n    }"}
{"magic_number_smell": "    private static final String VALUE_DISCOVERABLE_TIMEOUT_ONE_HOUR = \"onehour\";\n    private static final String VALUE_DISCOVERABLE_TIMEOUT_NEVER = \"never\";\n\n    static final int DEFAULT_DISCOVERABLE_TIMEOUT = 120;\n\n    private Context mContext;\n    private final Handler mUiHandler;", "refactored_code": "    private static final int DISCOVERABLE_TIMEOUT_TWO_MINUTES = 120;\n    private static final String VALUE_DISCOVERABLE_TIMEOUT_ONE_HOUR = \"onehour\";\n    private static final String VALUE_DISCOVERABLE_TIMEOUT_NEVER = \"never\";\n\n    static final int DEFAULT_DISCOVERABLE_TIMEOUT = DISCOVERABLE_TIMEOUT_TWO_MINUTES;\n\n    private Context mContext;\n    private final Handler mUiHandler;"}
{"magic_number_smell": "    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n        Log.d(TAG, \"onActivityResult: \" + requestCode + \", resultCode: \" + resultCode);\n        if (requestCode == 0) {\n            if (resultCode == Activity.RESULT_OK) {\n\n                //Get BroadcastMetadata", "refactored_code": "    public static final int REQUEST_SCAN_BT_BROADCAST_QR_CODE = 0;\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n        Log.d(TAG, \"onActivityResult: \" + requestCode + \", resultCode: \" + resultCode);\n        if (requestCode == REQUEST_SCAN_BT_BROADCAST_QR_CODE) {\n            if (resultCode == Activity.RESULT_OK) {\n\n                //Get BroadcastMetadata"}
{"magic_number_smell": "    private static final int 248 = 248;\n\n    public BluetoothLengthDeviceNameFilter() {\n        super(248);\n    }\n}\n", "refactored_code": "    private static final int BLUETOOTH_NAME_MAX_LENGTH_BYTES = 248;\n    private static final int BLUETOOTH_NAME_MAX_LENGTH_BYTES = 248;\n\n    public BluetoothLengthDeviceNameFilter() {\n        super(BLUETOOTH_NAME_MAX_LENGTH_BYTES);\n    }\n}\n"}
{"magic_number_smell": "                return DISPLAY_PASSKEY_DIALOG;\n\n            default:\n                return -1;\n        }\n    }\n", "refactored_code": "    public static final int INVALID_DIALOG_TYPE = -1;\n                return DISPLAY_PASSKEY_DIALOG;\n\n            default:\n                return INVALID_DIALOG_TYPE;\n        }\n    }\n"}
{"magic_number_smell": "\n                notification.flags |= Notification.FLAG_NO_CLEAR; // Cannot be set with the builder.\n\n                notificationManager.notify(getNotificationTag(mRequestType), android.R.drawable.stat_sys_data_bluetooth,\n                        notification);\n            }\n        } else if (action.equals(BluetoothDevice.ACTION_CONNECTION_ACCESS_CANCEL)) {", "refactored_code": "    private static final int NOTIFICATION_ID = android.R.drawable.stat_sys_data_bluetooth;\n\n                notification.flags |= Notification.FLAG_NO_CLEAR; // Cannot be set with the builder.\n\n                notificationManager.notify(getNotificationTag(mRequestType), NOTIFICATION_ID,\n                        notification);\n            }\n        } else if (action.equals(BluetoothDevice.ACTION_CONNECTION_ACCESS_CANCEL)) {"}
{"magic_number_smell": "        // If the device was in discoverABLE mode recently\n        long lastDiscoverableEndTime = sharedPreferences.getLong(\n                KEY_DISCOVERABLE_END_TIMESTAMP, 0);\n        if ((lastDiscoverableEndTime + 60 * 1000)\n                > currentTimeMillis) {\n            return true;\n        }", "refactored_code": "    private static final int GRACE_PERIOD_TO_SHOW_DIALOGS_IN_FOREGROUND = 60 * 1000;\n        // If the device was in discoverABLE mode recently\n        long lastDiscoverableEndTime = sharedPreferences.getLong(\n                KEY_DISCOVERABLE_END_TIMESTAMP, 0);\n        if ((lastDiscoverableEndTime + GRACE_PERIOD_TO_SHOW_DIALOGS_IN_FOREGROUND)\n                > currentTimeMillis) {\n            return true;\n        }"}
{"magic_number_smell": "        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case 1:\n                    mErrorMessage.setVisibility(View.INVISIBLE);\n                    break;\n", "refactored_code": "    private static final int MESSAGE_HIDE_ERROR_MESSAGE = 1;\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MESSAGE_HIDE_ERROR_MESSAGE:\n                    mErrorMessage.setVisibility(View.INVISIBLE);\n                    break;\n"}
{"magic_number_smell": "\n            Log.d(TAG, \"Setting Bluetooth Discoverable Timeout = \" + mTimeout);\n\n            if (mTimeout < 1 || mTimeout > 3600) {\n                mTimeout = BluetoothDiscoverableEnabler.DEFAULT_DISCOVERABLE_TIMEOUT;\n            }\n        } else {", "refactored_code": "    private static final int MAX_DISCOVERABLE_TIMEOUT = 3600; // 1 hr\n\n            Log.d(TAG, \"Setting Bluetooth Discoverable Timeout = \" + mTimeout);\n\n            if (mTimeout < 1 || mTimeout > MAX_DISCOVERABLE_TIMEOUT) {\n                mTimeout = BluetoothDiscoverableEnabler.DEFAULT_DISCOVERABLE_TIMEOUT;\n            }\n        } else {"}
{"magic_number_smell": "            mPreferenceGroup.addPreference(mDevicesList.get(i));\n        }\n        if (mDockDevicesList.size() > 0) {\n            for (int i = 0; i < getDockDeviceListSize(3 - size); i++) {\n                if (DEBUG) {\n                    Log.d(TAG, \"addPreference() add dock device : \"\n                            + mDockDevicesList.get(i).getTitle());", "refactored_code": "    private static final int MAX_DEVICE_NUM = 3;\n            mPreferenceGroup.addPreference(mDevicesList.get(i));\n        }\n        if (mDockDevicesList.size() > 0) {\n            for (int i = 0; i < getDockDeviceListSize(MAX_DEVICE_NUM - size); i++) {\n                if (DEBUG) {\n                    Log.d(TAG, \"addPreference() add dock device : \"\n                            + mDockDevicesList.get(i).getTitle());"}
{"magic_number_smell": "     */\n    public void initialize() {\n        setMax(MAX_VOLUME);\n        setMin(0);\n    }\n}\n", "refactored_code": "    public static final int MIN_VOLUME = 0;\n     */\n    public void initialize() {\n        setMax(MAX_VOLUME);\n        setMin(MIN_VOLUME);\n    }\n}\n"}
{"magic_number_smell": "                @Override\n                public void handleMessage(Message msg) {\n                    switch (msg.what) {\n                        case 1:\n                            mErrorMessage.setVisibility(View.INVISIBLE);\n                            break;\n", "refactored_code": "    private static final int MESSAGE_HIDE_ERROR_MESSAGE = 1;\n                @Override\n                public void handleMessage(Message msg) {\n                    switch (msg.what) {\n                        case MESSAGE_HIDE_ERROR_MESSAGE:\n                            mErrorMessage.setVisibility(View.INVISIBLE);\n                            break;\n"}
{"magic_number_smell": "            return;\n        }\n\n        // Keep showing the latest 3 devices.\n        // The preference for the latest device has top preference order.\n        int idx = Collections.binarySearch(mPreferenceList, preference);\n        // Binary search returns the index of the search key if it is contained in the list;", "refactored_code": "    private static final int MAX_DEVICE_NUM = 3;\n            return;\n        }\n\n        // Keep showing the latest MAX_DEVICE_NUM devices.\n        // The preference for the latest device has top preference order.\n        int idx = Collections.binarySearch(mPreferenceList, preference);\n        // Binary search returns the index of the search key if it is contained in the list;"}
{"magic_number_smell": "     * @return {@code true} when the controller can be changed on the device.\n     *\n     * <p>\n     * Will return true for {@link #0} and {@link #DISABLED_DEPENDENT_SETTING}.\n     * <p>\n     * When the availability status returned by {@link #getAvailabilityStatus()} is\n     * {@link #DISABLED_DEPENDENT_SETTING}, then the setting will be disabled by default in the", "refactored_code": "    public static final int AVAILABLE = 0;\n     * @return {@code true} when the controller can be changed on the device.\n     *\n     * <p>\n     * Will return true for {@link #AVAILABLE} and {@link #DISABLED_DEPENDENT_SETTING}.\n     * <p>\n     * When the availability status returned by {@link #getAvailabilityStatus()} is\n     * {@link #DISABLED_DEPENDENT_SETTING}, then the setting will be disabled by default in the"}
{"magic_number_smell": "\n    private static boolean isAppended(TypedArray styledAttributes) {\n        return styledAttributes.getInt(R.styleable.PreferenceScreen_staticPreferenceLocation,\n                0) == APPEND_VALUE;\n    }\n\n    private static String getUnavailableSliceSubtitle(TypedArray styledAttributes) {", "refactored_code": "    public static final int PREPEND_VALUE = 0;\n\n    private static boolean isAppended(TypedArray styledAttributes) {\n        return styledAttributes.getInt(R.styleable.PreferenceScreen_staticPreferenceLocation,\n                PREPEND_VALUE) == APPEND_VALUE;\n    }\n\n    private static String getUnavailableSliceSubtitle(TypedArray styledAttributes) {"}
{"magic_number_smell": "\n    private void awaitObserverLatch(CountDownLatch latch) {\n        try {\n            latch.await(50L, TimeUnit.MILLISECONDS);\n        } catch (InterruptedException e) {\n            // Do nothing\n        }", "refactored_code": "    private static final long TIMEOUT_MILLIS = 50L;\n\n    private void awaitObserverLatch(CountDownLatch latch) {\n        try {\n            latch.await(TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n        } catch (InterruptedException e) {\n            // Do nothing\n        }"}
{"magic_number_smell": "\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        if (requestCode == 12309) {\n            if (resultCode == Activity.RESULT_OK) {\n                mChallengeSucceeded = true;\n                mChallengeRequested = false;", "refactored_code": "    private static final int REQUEST_PIN_CHALLENGE = 12309;\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        if (requestCode == REQUEST_PIN_CHALLENGE) {\n            if (resultCode == Activity.RESULT_OK) {\n                mChallengeSucceeded = true;\n                mChallengeRequested = false;"}
{"magic_number_smell": "    private long mTimeoutMillis;\n\n    public UiBlockerController(@NonNull List<String> keys) {\n        this(keys, 300);\n    }\n\n    public UiBlockerController(@NonNull List<String> keys, long timeout) {", "refactored_code": "    private static final int TIMEOUT_MILLIS = 300;\n    private long mTimeoutMillis;\n\n    public UiBlockerController(@NonNull List<String> keys) {\n        this(keys, TIMEOUT_MILLIS);\n    }\n\n    public UiBlockerController(@NonNull List<String> keys, long timeout) {"}
{"magic_number_smell": "            return PRIVATE_TAB;\n        }\n\n        return 0;\n    }\n\n    private CharSequence getPageTitle(int position) {", "refactored_code": "    public static final int PERSONAL_TAB = 0;\n            return PRIVATE_TAB;\n        }\n\n        return PERSONAL_TAB;\n    }\n\n    private CharSequence getPageTitle(int position) {"}
{"magic_number_smell": "    private static final String TAG = \"BillingCycleSettings\";\n    private static final boolean LOGD = false;\n    public static final long 1024 * 1024 = 1024 * 1024;\n    public static final long GIB_IN_BYTES = 1024 * 1024 * 1024;\n\n    private static final long MAX_DATA_LIMIT_BYTES = 50000 * GIB_IN_BYTES;\n", "refactored_code": "    public static final long MIB_IN_BYTES = 1024 * 1024;\n    private static final String TAG = \"BillingCycleSettings\";\n    private static final boolean LOGD = false;\n    public static final long MIB_IN_BYTES = 1024 * 1024;\n    public static final long GIB_IN_BYTES = MIB_IN_BYTES * 1024;\n\n    private static final long MAX_DATA_LIMIT_BYTES = 50000 * GIB_IN_BYTES;\n"}
{"magic_number_smell": "                mNetworkCycleChartData != null ? mNetworkCycleChartData.getTotal().getUsage() : 0;\n        final long policyMax =\n            mPolicy != null ? Math.max(mPolicy.limitBytes, mPolicy.warningBytes) : 0;\n        return (int) (Math.max(totalData, policyMax) / DataUnit.MEBIBYTES.toBytes(1) / 2);\n    }\n\n    @VisibleForTesting", "refactored_code": "    private static final long RESOLUTION = DataUnit.MEBIBYTES.toBytes(1) / 2;\n                mNetworkCycleChartData != null ? mNetworkCycleChartData.getTotal().getUsage() : 0;\n        final long policyMax =\n            mPolicy != null ? Math.max(mPolicy.limitBytes, mPolicy.warningBytes) : 0;\n        return (int) (Math.max(totalData, policyMax) / RESOLUTION);\n    }\n\n    @VisibleForTesting"}
{"magic_number_smell": "        if (millisLeft <= 0) {\n            cycleTime.setText(getContext().getString(R.string.billing_cycle_none_left));\n        } else {\n            int daysLeft = (int) (millisLeft / TimeUnit.DAYS.toMillis(1));\n            MessageFormat msgFormat = new MessageFormat(\n                    getContext().getResources().getString(R.string.billing_cycle_days_left),\n                    Locale.getDefault());", "refactored_code": "    private static final long MILLIS_IN_A_DAY = TimeUnit.DAYS.toMillis(1);\n        if (millisLeft <= 0) {\n            cycleTime.setText(getContext().getString(R.string.billing_cycle_none_left));\n        } else {\n            int daysLeft = (int) (millisLeft / MILLIS_IN_A_DAY);\n            MessageFormat msgFormat = new MessageFormat(\n                    getContext().getResources().getString(R.string.billing_cycle_days_left),\n                    Locale.getDefault());"}
{"magic_number_smell": "    }\n\n    private static boolean validSize(long value) {\n        return value >= 0L && value < 1000000000000000L;\n    }\n\n    public static boolean unlimited(long size) {", "refactored_code": "    private static final long PETA = 1000000000000000L;\n    }\n\n    private static boolean validSize(long value) {\n        return value >= 0L && value < PETA;\n    }\n\n    public static boolean unlimited(long size) {"}
{"magic_number_smell": "\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        menu.add(Menu.NONE, Menu.FIRST + 42, Menu.NONE,\n                mShowSystem ? R.string.menu_hide_system : R.string.menu_show_system);\n        super.onCreateOptionsMenu(menu, inflater);\n    }", "refactored_code": "    private static final int MENU_SHOW_SYSTEM = Menu.FIRST + 42;\n\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        menu.add(Menu.NONE, MENU_SHOW_SYSTEM, Menu.NONE,\n                mShowSystem ? R.string.menu_hide_system : R.string.menu_show_system);\n        super.onCreateOptionsMenu(menu, inflater);\n    }"}
{"magic_number_smell": "                new Date());\n        final List<TimeZoneInfo> timeZoneInfos = new ArrayList<>();\n        timeZoneInfos.add(formatter.format(TimeZone.getFrozenTimeZone(\"Etc/UTC\")));\n        for (int hoursOffset = MAX_HOURS_OFFSET; hoursOffset >= -14; --hoursOffset) {\n            if (hoursOffset == 0) {\n                // UTC is handled above, so don't add GMT +/-0 again.\n                continue;", "refactored_code": "    private static final int MIN_HOURS_OFFSET = -14;\n                new Date());\n        final List<TimeZoneInfo> timeZoneInfos = new ArrayList<>();\n        timeZoneInfos.add(formatter.format(TimeZone.getFrozenTimeZone(\"Etc/UTC\")));\n        for (int hoursOffset = MAX_HOURS_OFFSET; hoursOffset >= MIN_HOURS_OFFSET; --hoursOffset) {\n            if (hoursOffset == 0) {\n                // UTC is handled above, so don't add GMT +/-0 again.\n                continue;"}
{"magic_number_smell": "                    .setDestination(RegionZonePicker.class.getCanonicalName())\n                    .setArguments(args)\n                    .setSourceMetricsCategory(getMetricsCategory())\n                    .setResultListener(this, 1)\n                    .launch();\n        }\n    }", "refactored_code": "    private static final int REQUEST_CODE_ZONE_PICKER = 1;\n                    .setDestination(RegionZonePicker.class.getCanonicalName())\n                    .setArguments(args)\n                    .setSourceMetricsCategory(getMetricsCategory())\n                    .setResultListener(this, REQUEST_CODE_ZONE_PICKER)\n                    .launch();\n        }\n    }"}
{"magic_number_smell": "\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        menu.add(0, Menu.FIRST, 0, R.string.zone_menu_by_region);\n        menu.add(0, MENU_BY_OFFSET, 0, R.string.zone_menu_by_offset);\n        super.onCreateOptionsMenu(menu, inflater);\n    }", "refactored_code": "    private static final int MENU_BY_REGION = Menu.FIRST;\n\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        menu.add(0, MENU_BY_REGION, 0, R.string.zone_menu_by_region);\n        menu.add(0, MENU_BY_OFFSET, 0, R.string.zone_menu_by_offset);\n        super.onCreateOptionsMenu(menu, inflater);\n    }"}
{"magic_number_smell": "        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case 1:\n                    mErrorMessage.setVisibility(View.INVISIBLE);\n                    break;\n", "refactored_code": "    private static final int MESSAGE_HIDE_ERROR_MESSAGE = 1;\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MESSAGE_HIDE_ERROR_MESSAGE:\n                    mErrorMessage.setVisibility(View.INVISIBLE);\n                    break;\n"}
{"magic_number_smell": "    public void onClick(DialogInterface dialogInterface, int id) {\n        if (mListener != null) {\n            switch (id) {\n                case DialogInterface.BUTTON_NEGATIVE:\n                    mListener.onCancel();\n                    break;\n            }", "refactored_code": "    private static final int BUTTON_CANCEL = DialogInterface.BUTTON_NEGATIVE;\n    public void onClick(DialogInterface dialogInterface, int id) {\n        if (mListener != null) {\n            switch (id) {\n                case BUTTON_CANCEL:\n                    mListener.onCancel();\n                    break;\n            }"}
{"magic_number_smell": "\n        mAdapter = new AppListAdapter(this);\n        if (mAdapter.getCount() <= 0) {\n            setResult(-2);\n            finish();\n        } else {\n            setListAdapter(mAdapter);", "refactored_code": "    public static final int RESULT_NO_MATCHING_APPS = -2;\n\n        mAdapter = new AppListAdapter(this);\n        if (mAdapter.getCount() <= 0) {\n            setResult(RESULT_NO_MATCHING_APPS);\n            finish();\n        } else {\n            setListAdapter(mAdapter);"}
{"magic_number_smell": "        final boolean isEnabled = (Boolean) newValue;\n        Settings.Secure.putInt(mContext.getContentResolver(),\n                Settings.Global.ENABLE_AUTOMATIC_SYSTEM_SERVER_HEAP_DUMPS,\n                isEnabled ? SETTING_VALUE_ON : 0);\n        return true;\n    }\n", "refactored_code": "    private static final int SETTING_VALUE_OFF = 0;\n        final boolean isEnabled = (Boolean) newValue;\n        Settings.Secure.putInt(mContext.getContentResolver(),\n                Settings.Global.ENABLE_AUTOMATIC_SYSTEM_SERVER_HEAP_DUMPS,\n                isEnabled ? SETTING_VALUE_ON : SETTING_VALUE_OFF);\n        return true;\n    }\n"}
{"magic_number_smell": "        final boolean isEnabled = (Boolean) newValue;\n        Settings.Global.putInt(mContext.getContentResolver(),\n                Settings.Global.ENABLE_BACK_ANIMATION,\n                isEnabled ? SETTING_VALUE_ON : 0);\n        if (mFragment != null && isEnabled) {\n            BackAnimationPreferenceDialog.show(mFragment);\n        }", "refactored_code": "    private static final int SETTING_VALUE_OFF = 0;\n        final boolean isEnabled = (Boolean) newValue;\n        Settings.Global.putInt(mContext.getContentResolver(),\n                Settings.Global.ENABLE_BACK_ANIMATION,\n                isEnabled ? SETTING_VALUE_ON : SETTING_VALUE_OFF);\n        if (mFragment != null && isEnabled) {\n            BackAnimationPreferenceDialog.show(mFragment);\n        }"}
{"magic_number_smell": "\n        int getDeviceVndk() {\n            if (DEBUG) {\n                return 28;\n            }\n            return dessertNumber(SystemProperties.get(PROPERTY_KEY_VNDK), 28);\n        }", "refactored_code": "    private static final int Q_VNDK_BASE = 28;\n\n        int getDeviceVndk() {\n            if (DEBUG) {\n                return Q_VNDK_BASE;\n            }\n            return dessertNumber(SystemProperties.get(PROPERTY_KEY_VNDK), Q_VNDK_BASE);\n        }"}
{"magic_number_smell": "                Settings.Global.getInt(\n                        mContext.getContentResolver(),\n                        Settings.Global.ENABLE_16K_PAGES,\n                        0 /* default */);\n\n        ((SwitchPreference) mPreference).setChecked(optionValue == ENABLE_16K_PAGE_SIZE);\n    }", "refactored_code": "    private static final int ENABLE_4K_PAGE_SIZE = 0;\n                Settings.Global.getInt(\n                        mContext.getContentResolver(),\n                        Settings.Global.ENABLE_16K_PAGES,\n                        ENABLE_4K_PAGE_SIZE /* default */);\n\n        ((SwitchPreference) mPreference).setChecked(optionValue == ENABLE_16K_PAGE_SIZE);\n    }"}
{"magic_number_smell": "\n    public EnableVerboseVendorLoggingPreferenceController(Context context) {\n        super(context);\n        mDumpstateHalVersion = -1;\n    }\n\n    @Override", "refactored_code": "    private static final int DUMPSTATE_HAL_VERSION_UNKNOWN = -1;\n\n    public EnableVerboseVendorLoggingPreferenceController(Context context) {\n        super(context);\n        mDumpstateHalVersion = DUMPSTATE_HAL_VERSION_UNKNOWN;\n    }\n\n    @Override"}
{"magic_number_smell": "    private final int mDefault;\n\n    public GlobalSettingSwitchPreferenceController(Context context, String globalSettingsKey) {\n        this(context, globalSettingsKey, SETTING_VALUE_ON, 0, 0);\n    }\n\n    /**", "refactored_code": "    private static final int SETTING_VALUE_OFF = 0;\n    private final int mDefault;\n\n    public GlobalSettingSwitchPreferenceController(Context context, String globalSettingsKey) {\n        this(context, globalSettingsKey, SETTING_VALUE_ON, SETTING_VALUE_OFF, SETTING_VALUE_OFF);\n    }\n\n    /**"}
{"magic_number_smell": "        try {\n            final Parcel data = Parcel.obtain();\n            data.writeInterfaceToken(SURFACE_COMPOSER_INTERFACE_KEY);\n            final int disableOverlays = isEnabled ? 1 : SETTING_VALUE_OFF;\n            data.writeInt(disableOverlays);\n            mSurfaceFlinger.transact(SURFACE_FLINGER_DISABLE_OVERLAYS_CODE, data,\n                    null /* reply */, 0 /* flags */);", "refactored_code": "    private static final int SETTING_VALUE_ON = 1;\n        try {\n            final Parcel data = Parcel.obtain();\n            data.writeInterfaceToken(SURFACE_COMPOSER_INTERFACE_KEY);\n            final int disableOverlays = isEnabled ? SETTING_VALUE_ON : SETTING_VALUE_OFF;\n            data.writeInt(disableOverlays);\n            mSurfaceFlinger.transact(SURFACE_FLINGER_DISABLE_OVERLAYS_CODE, data,\n                    null /* reply */, 0 /* flags */);"}
{"magic_number_smell": "        super.onDeveloperOptionsSwitchDisabled();\n        // disable rate limiting when developer options are disabled\n        ConnectivitySettingsManager.setIngressRateLimitInBytesPerSecond(mContext,\n                -1);\n        ((ListPreference) mPreference).setValue(String.valueOf(-1));\n    }\n}", "refactored_code": "    private static final int RATE_LIMIT_DISABLED = -1;\n        super.onDeveloperOptionsSwitchDisabled();\n        // disable rate limiting when developer options are disabled\n        ConnectivitySettingsManager.setIngressRateLimitInBytesPerSecond(mContext,\n                RATE_LIMIT_DISABLED);\n        ((ListPreference) mPreference).setValue(String.valueOf(RATE_LIMIT_DISABLED));\n    }\n}"}
{"magic_number_smell": "    public boolean onPreferenceChange(Preference preference, Object newValue) {\n        final boolean isEnabled = (Boolean) newValue;\n        Settings.Secure.putInt(mContext.getContentResolver(), mSettingsKey,\n            isEnabled ? SETTING_VALUE_ON : 0);\n        return true;\n    }\n", "refactored_code": "    private static final int SETTING_VALUE_OFF = 0;\n    public boolean onPreferenceChange(Preference preference, Object newValue) {\n        final boolean isEnabled = (Boolean) newValue;\n        Settings.Secure.putInt(mContext.getContentResolver(), mSettingsKey,\n            isEnabled ? SETTING_VALUE_ON : SETTING_VALUE_OFF);\n        return true;\n    }\n"}
{"magic_number_smell": "                final Parcel data = Parcel.obtain();\n                final Parcel reply = Parcel.obtain();\n                data.writeInterfaceToken(SURFACE_COMPOSER_INTERFACE_KEY);\n                data.writeInt(2);\n                mSurfaceFlinger.transact(SURFACE_FLINGER_CODE, data, reply, 0 /* flags */);\n                final boolean enabled = reply.readBoolean();\n                ((TwoStatePreference) mPreference).setChecked(enabled);", "refactored_code": "    private static final int SETTING_VALUE_QUERY = 2;\n                final Parcel data = Parcel.obtain();\n                final Parcel reply = Parcel.obtain();\n                data.writeInterfaceToken(SURFACE_COMPOSER_INTERFACE_KEY);\n                data.writeInt(SETTING_VALUE_QUERY);\n                mSurfaceFlinger.transact(SURFACE_FLINGER_CODE, data, reply, 0 /* flags */);\n                final boolean enabled = reply.readBoolean();\n                ((TwoStatePreference) mPreference).setChecked(enabled);"}
{"magic_number_smell": "                final Parcel data = Parcel.obtain();\n                final Parcel reply = Parcel.obtain();\n                data.writeInterfaceToken(SURFACE_COMPOSER_INTERFACE_KEY);\n                data.writeInt(2);\n                mSurfaceFlinger.transact(SURFACE_FLINGER_CODE, data, reply, 0 /* flags */);\n                final boolean enabled = reply.readBoolean();\n                ((TwoStatePreference) mPreference).setChecked(enabled);", "refactored_code": "    private static final int SETTING_VALUE_QUERY = 2;\n                final Parcel data = Parcel.obtain();\n                final Parcel reply = Parcel.obtain();\n                data.writeInterfaceToken(SURFACE_COMPOSER_INTERFACE_KEY);\n                data.writeInt(SETTING_VALUE_QUERY);\n                mSurfaceFlinger.transact(SURFACE_FLINGER_CODE, data, reply, 0 /* flags */);\n                final boolean enabled = reply.readBoolean();\n                ((TwoStatePreference) mPreference).setChecked(enabled);"}
{"magic_number_smell": "            if (mSurfaceFlinger != null) {\n                final Parcel data = Parcel.obtain();\n                data.writeInterfaceToken(SURFACE_COMPOSER_INTERFACE_KEY);\n                final int showUpdates = isEnabled ? 1 : SETTING_VALUE_OFF;\n                data.writeInt(showUpdates);\n                mSurfaceFlinger.transact(SURFACE_FLINGER_WRITE_SURFACE_UPDATES_CODE, data,\n                        null /* reply */, 0 /* flags */);", "refactored_code": "    private static final int SETTING_VALUE_ON = 1;\n            if (mSurfaceFlinger != null) {\n                final Parcel data = Parcel.obtain();\n                data.writeInterfaceToken(SURFACE_COMPOSER_INTERFACE_KEY);\n                final int showUpdates = isEnabled ? SETTING_VALUE_ON : SETTING_VALUE_OFF;\n                data.writeInt(showUpdates);\n                mSurfaceFlinger.transact(SURFACE_FLINGER_WRITE_SURFACE_UPDATES_CODE, data,\n                        null /* reply */, 0 /* flags */);"}
{"magic_number_smell": "            Toast.makeText(mContext, R.string.capturing_system_heap_dump_message,\n                    Toast.LENGTH_SHORT).show();\n            ActivityManager.getService().requestSystemServerHeapDump();\n            mHandler.postDelayed(() -> preference.setEnabled(true), 5000L);\n            return true;\n        } catch (RemoteException e) {\n            Log.e(TAG, \"error taking system heap dump\", e);", "refactored_code": "    private static final long ENABLE_TIMEOUT_MILLIS = 5000L;\n            Toast.makeText(mContext, R.string.capturing_system_heap_dump_message,\n                    Toast.LENGTH_SHORT).show();\n            ActivityManager.getService().requestSystemServerHeapDump();\n            mHandler.postDelayed(() -> preference.setEnabled(true), ENABLE_TIMEOUT_MILLIS);\n            return true;\n        } catch (RemoteException e) {\n            Log.e(TAG, \"error taking system heap dump\", e);"}
{"magic_number_smell": "    public boolean onPreferenceChange(Preference preference, Object newValue) {\n        final boolean isEnabled = (Boolean) newValue;\n        Settings.System.putInt(mContext.getContentResolver(), mSettingsKey,\n            isEnabled ? SETTING_VALUE_ON : 0);\n        return true;\n    }\n", "refactored_code": "    private static final int SETTING_VALUE_OFF = 0;\n    public boolean onPreferenceChange(Preference preference, Object newValue) {\n        final boolean isEnabled = (Boolean) newValue;\n        Settings.System.putInt(mContext.getContentResolver(), mSettingsKey,\n            isEnabled ? SETTING_VALUE_ON : SETTING_VALUE_OFF);\n        return true;\n    }\n"}
{"magic_number_smell": "                // is called first - hence, it's possible that the state didn't change here yet.\n                mHandler.postDelayed(\n                        () -> mPreference.notifyDependencyChange(shouldDisableDependents()),\n                        2000);\n            }\n        };\n        mContentResolver = context.getContentResolver();", "refactored_code": "    private static final long DELAYED_MESSAGE_TIME_MS = 2000;\n                // is called first - hence, it's possible that the state didn't change here yet.\n                mHandler.postDelayed(\n                        () -> mPreference.notifyDependencyChange(shouldDisableDependents()),\n                        DELAYED_MESSAGE_TIME_MS);\n            }\n        };\n        mContentResolver = context.getContentResolver();"}
{"magic_number_smell": "        return DevelopmentSettingsEnabler.isDevelopmentSettingsEnabled(mContext)\n                        && (Settings.Global.getInt(mContentResolver,\n                                    Settings.Global.UPDATABLE_DRIVER_ALL_APPS,\n                                    0)\n                                != UPDATABLE_DRIVER_OFF)\n                ? AVAILABLE\n                : CONDITIONALLY_UNAVAILABLE;", "refactored_code": "    public static final int UPDATABLE_DRIVER_DEFAULT = 0;\n        return DevelopmentSettingsEnabler.isDevelopmentSettingsEnabled(mContext)\n                        && (Settings.Global.getInt(mContentResolver,\n                                    Settings.Global.UPDATABLE_DRIVER_ALL_APPS,\n                                    UPDATABLE_DRIVER_DEFAULT)\n                                != UPDATABLE_DRIVER_OFF)\n                ? AVAILABLE\n                : CONDITIONALLY_UNAVAILABLE;"}
{"magic_number_smell": "        @Override\n        protected boolean isEnabled() {\n            return Settings.System.getInt(mContext.getContentResolver(),\n                Settings.System.SHOW_TOUCHES, SETTING_VALUE_OFF) == 1;\n        }\n\n        @Override", "refactored_code": "        private static final int SETTING_VALUE_ON = 1;\n        @Override\n        protected boolean isEnabled() {\n            return Settings.System.getInt(mContext.getContentResolver(),\n                Settings.System.SHOW_TOUCHES, SETTING_VALUE_OFF) == SETTING_VALUE_ON;\n        }\n\n        @Override"}
{"magic_number_smell": "        mSearchView.setOnCloseListener(this);\n        mSearchView.setIconifiedByDefault(true);\n\n        menu.add(Menu.NONE, Menu.FIRST + 42, Menu.NONE, R.string.search_settings)\n                .setIcon(R.drawable.ic_find_in_page_24px)\n                .setActionView(mSearchView)\n                .setOnActionExpandListener(this)", "refactored_code": "    private static final int MENU_SEARCH_APPS = Menu.FIRST + 42;\n        mSearchView.setOnCloseListener(this);\n        mSearchView.setIconifiedByDefault(true);\n\n        menu.add(Menu.NONE, MENU_SEARCH_APPS, Menu.NONE, R.string.search_settings)\n                .setIcon(R.drawable.ic_find_in_page_24px)\n                .setActionView(mSearchView)\n                .setOnActionExpandListener(this)"}
{"magic_number_smell": "\n        // Determines what policy fragment to open up to\n        Intent intent = getIntent();\n        int policy = intent.getIntExtra(EXTRA_POLICY, POLICY_ALARM_MANAGER);\n\n        mSpinner = findViewById(R.id.spinner);\n        mAlarmManagerFragment = new AlarmManagerFragment();", "refactored_code": "    private static final int DEFAULT_POLICY = POLICY_ALARM_MANAGER;\n\n        // Determines what policy fragment to open up to\n        Intent intent = getIntent();\n        int policy = intent.getIntExtra(EXTRA_POLICY, DEFAULT_POLICY);\n\n        mSpinner = findViewById(R.id.spinner);\n        mAlarmManagerFragment = new AlarmManagerFragment();"}
{"magic_number_smell": "        mAlarmManagerMap.put(EconomyManager.KEY_AM_MIN_SATIATED_BALANCE_EXEMPTED,\n                new TareFactorData(mResources.getString(R.string.tare_min_balance_exempted),\n                        EconomyManager.DEFAULT_AM_MIN_SATIATED_BALANCE_EXEMPTED_CAKES,\n                        0));\n        mAlarmManagerMap.put(EconomyManager.KEY_AM_MIN_SATIATED_BALANCE_HEADLESS_SYSTEM_APP,\n                new TareFactorData(mResources.getString(R.string.tare_min_balance_headless_app),\n                        EconomyManager.DEFAULT_AM_MIN_SATIATED_BALANCE_HEADLESS_SYSTEM_APP_CAKES,", "refactored_code": "    private static final int POLICY_ALARM_MANAGER = 0;\n        mAlarmManagerMap.put(EconomyManager.KEY_AM_MIN_SATIATED_BALANCE_EXEMPTED,\n                new TareFactorData(mResources.getString(R.string.tare_min_balance_exempted),\n                        EconomyManager.DEFAULT_AM_MIN_SATIATED_BALANCE_EXEMPTED_CAKES,\n                        POLICY_ALARM_MANAGER));\n        mAlarmManagerMap.put(EconomyManager.KEY_AM_MIN_SATIATED_BALANCE_HEADLESS_SYSTEM_APP,\n                new TareFactorData(mResources.getString(R.string.tare_min_balance_headless_app),\n                        EconomyManager.DEFAULT_AM_MIN_SATIATED_BALANCE_HEADLESS_SYSTEM_APP_CAKES,"}
{"magic_number_smell": "                    long newVal = mFactorValue;\n                    try {\n                        newVal = Long.parseLong(stringValue);\n                        if (mUnitSpinner.getSelectedItemPosition() == 0) {\n                            // Convert ARC to cake\n                            newVal *= CAKE_IN_ARC;\n                        }", "refactored_code": "    private static final int UNIT_IDX_ARC = 0;\n                    long newVal = mFactorValue;\n                    try {\n                        newVal = Long.parseLong(stringValue);\n                        if (mUnitSpinner.getSelectedItemPosition() == UNIT_IDX_ARC) {\n                            // Convert ARC to cake\n                            newVal *= CAKE_IN_ARC;\n                        }"}
{"magic_number_smell": "        mOnSwitch.setOnCheckedChangeListener(new OnCheckedChangeListener() {\n            @Override\n            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n                if (mConfigObserver.mEnableTareSetting == -1\n                        && isChecked == mConfigObserver.getDefaultEnabledStatus()) {\n                    // Don't bother writing something that's not new information. It would make\n                    // it hard to use DeviceConfig if we did.", "refactored_code": "    private static final int SETTING_VALUE_DEFAULT = -1;\n        mOnSwitch.setOnCheckedChangeListener(new OnCheckedChangeListener() {\n            @Override\n            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\n                if (mConfigObserver.mEnableTareSetting == SETTING_VALUE_DEFAULT\n                        && isChecked == mConfigObserver.getDefaultEnabledStatus()) {\n                    // Don't bother writing something that's not new information. It would make\n                    // it hard to use DeviceConfig if we did."}
{"magic_number_smell": "    @Override\n    protected void onPostExecute(Long result) {\n        mSizeBytes = result;\n        long timeMillis = (mSizeBytes * DateUtils.SECOND_IN_MILLIS) / DataUnit.MEBIBYTES.toBytes(10);\n        timeMillis = Math.max(timeMillis, DateUtils.SECOND_IN_MILLIS);\n\n        final String size = Formatter.formatFileSize(mContext, mSizeBytes);", "refactored_code": "    private static final long SPEED_ESTIMATE_BPS = DataUnit.MEBIBYTES.toBytes(10);\n    @Override\n    protected void onPostExecute(Long result) {\n        mSizeBytes = result;\n        long timeMillis = (mSizeBytes * DateUtils.SECOND_IN_MILLIS) / SPEED_ESTIMATE_BPS;\n        timeMillis = Math.max(timeMillis, DateUtils.SECOND_IN_MILLIS);\n\n        final String size = Formatter.formatFileSize(mContext, mSizeBytes);"}
{"magic_number_smell": "            }\n\n            // Stats data is only available on private volumes.\n            getLoaderManager().restartLoader(0, Bundle.EMPTY, this);\n            getLoaderManager()\n                 .restartLoader(VOLUME_SIZE_JOB_ID, Bundle.EMPTY, new VolumeSizeCallbacks());\n            getLoaderManager().restartLoader(ICON_JOB_ID, Bundle.EMPTY, new IconLoaderCallbacks());", "refactored_code": "    private static final int STORAGE_JOB_ID = 0;\n            }\n\n            // Stats data is only available on private volumes.\n            getLoaderManager().restartLoader(STORAGE_JOB_ID, Bundle.EMPTY, this);\n            getLoaderManager()\n                 .restartLoader(VOLUME_SIZE_JOB_ID, Bundle.EMPTY, new VolumeSizeCallbacks());\n            getLoaderManager().restartLoader(ICON_JOB_ID, Bundle.EMPTY, new IconLoaderCallbacks());"}
{"magic_number_smell": "                mPreferenceController.setVolume(null);\n            }\n            // Stats data is only available on private volumes.\n            getLoaderManager().restartLoader(0, Bundle.EMPTY, this);\n            getLoaderManager()\n                 .restartLoader(VOLUME_SIZE_JOB_ID, Bundle.EMPTY, new VolumeSizeCallbacks());\n            getLoaderManager().restartLoader(ICON_JOB_ID, Bundle.EMPTY, new IconLoaderCallbacks());", "refactored_code": "    private static final int STORAGE_JOB_ID = 0;\n                mPreferenceController.setVolume(null);\n            }\n            // Stats data is only available on private volumes.\n            getLoaderManager().restartLoader(STORAGE_JOB_ID, Bundle.EMPTY, this);\n            getLoaderManager()\n                 .restartLoader(VOLUME_SIZE_JOB_ID, Bundle.EMPTY, new VolumeSizeCallbacks());\n            getLoaderManager().restartLoader(ICON_JOB_ID, Bundle.EMPTY, new IconLoaderCallbacks());"}
{"magic_number_smell": "\n    private ProgressBar mProgressBar;\n    private static final int PROGRESS_MAX = 100;\n    private int mProgressPercent = -1;\n    private long mStorageSize;\n\n    public StorageItemPreference(Context context) {", "refactored_code": "    private static final int UNINITIALIZED = -1;\n\n    private ProgressBar mProgressBar;\n    private static final int PROGRESS_MAX = 100;\n    private int mProgressPercent = UNINITIALIZED;\n    private long mStorageSize;\n\n    public StorageItemPreference(Context context) {"}
{"magic_number_smell": "                            getText(R.string.storage_wizard_move_unlock), user.name);\n                    final ChooseLockSettingsHelper.Builder builder =\n                            new ChooseLockSettingsHelper.Builder(this);\n                    builder.setRequestCode(100)\n                            .setDescription(description)\n                            .setUserId(user.id)\n                            .setAllowAnyUserId(true)", "refactored_code": "    private static final int REQUEST_CREDENTIAL = 100;\n                            getText(R.string.storage_wizard_move_unlock), user.name);\n                    final ChooseLockSettingsHelper.Builder builder =\n                            new ChooseLockSettingsHelper.Builder(this);\n                    builder.setRequestCode(REQUEST_CREDENTIAL)\n                            .setDescription(description)\n                            .setUserId(user.id)\n                            .setAllowAnyUserId(true)"}
{"magic_number_smell": "                            getText(R.string.storage_wizard_move_unlock), user.name);\n                    final ChooseLockSettingsHelper.Builder builder =\n                            new ChooseLockSettingsHelper.Builder(this);\n                    builder.setRequestCode(100)\n                            .setDescription(description)\n                            .setUserId(user.id)\n                            .setForceVerifyPath(true)", "refactored_code": "    private static final int REQUEST_CREDENTIAL = 100;\n                            getText(R.string.storage_wizard_move_unlock), user.name);\n                    final ChooseLockSettingsHelper.Builder builder =\n                            new ChooseLockSettingsHelper.Builder(this);\n                    builder.setRequestCode(REQUEST_CREDENTIAL)\n                            .setDescription(description)\n                            .setUserId(user.id)\n                            .setForceVerifyPath(true)"}
{"magic_number_smell": "        }\n        arrayCopy();\n        mHits[mHits.length - 1] = SystemClock.uptimeMillis();\n        if (mHits[0] >= (SystemClock.uptimeMillis() - 500)) {\n            if (mUserManager.hasUserRestriction(UserManager.DISALLOW_FUN)) {\n                if (mFunDisallowedAdmin != null && !mFunDisallowedBySystem) {\n                    RestrictedLockUtils.sendShowAdminSupportDetailsIntent(mContext,", "refactored_code": "    private static final int DELAY_TIMER_MILLIS = 500;\n        }\n        arrayCopy();\n        mHits[mHits.length - 1] = SystemClock.uptimeMillis();\n        if (mHits[0] >= (SystemClock.uptimeMillis() - DELAY_TIMER_MILLIS)) {\n            if (mUserManager.hasUserRestriction(UserManager.DISALLOW_FUN)) {\n                if (mFunDisallowedAdmin != null && !mFunDisallowedBySystem) {\n                    RestrictedLockUtils.sendShowAdminSupportDetailsIntent(mContext,"}
{"magic_number_smell": "                : \"\");\n\n        if (res.getBoolean(R.bool.config_msid_enable)) {\n            mDialog.setText(R.id.min_number_label,\n                    res.getString(R.string.status_msid_number));\n        }\n", "refactored_code": "    private static final int ID_MIN_NUMBER_LABEL = R.id.min_number_label;\n                : \"\");\n\n        if (res.getBoolean(R.bool.config_msid_enable)) {\n            mDialog.setText(ID_MIN_NUMBER_LABEL,\n                    res.getString(R.string.status_msid_number));\n        }\n"}
{"magic_number_smell": "    NonCurrentUserController(Context context, @NonNull UserInfo info, @NonNull int[] profiles) {\n        super(context);\n        mUser = info;\n        mSize = -1;\n        mStorageCacheHelper = new StorageCacheHelper(context, info.id);\n        mProfiles = profiles;\n    }", "refactored_code": "    private static final int SIZE_NOT_SET = -1;\n    NonCurrentUserController(Context context, @NonNull UserInfo info, @NonNull int[] profiles) {\n        super(context);\n        mUser = info;\n        mSize = SIZE_NOT_SET;\n        mStorageCacheHelper = new StorageCacheHelper(context, info.id);\n        mProfiles = profiles;\n    }"}
{"magic_number_smell": "        // Sort display order by size.\n        Collections.sort(mPrivateStorageItemPreferences,\n                Comparator.comparingLong(StorageItemPreference::getStorageSize));\n        int orderIndex = 200;\n        for (StorageItemPreference preference : mPrivateStorageItemPreferences) {\n            preference.setOrder(orderIndex--);\n            mScreen.addPreference(preference);", "refactored_code": "    private static final int LAST_STORAGE_CATEGORY_PREFERENCE_ORDER = 200;\n        // Sort display order by size.\n        Collections.sort(mPrivateStorageItemPreferences,\n                Comparator.comparingLong(StorageItemPreference::getStorageSize));\n        int orderIndex = LAST_STORAGE_CATEGORY_PREFERENCE_ORDER;\n        for (StorageItemPreference preference : mPrivateStorageItemPreferences) {\n            preference.setOrder(orderIndex--);\n            mScreen.addPreference(preference);"}
{"magic_number_smell": "                        SettingsEnums.ACTION_SCREEN_ATTENTION_CHANGED,\n                        isChecked);\n                Settings.Secure.putInt(mContext.getContentResolver(),\n                        Settings.Secure.ADAPTIVE_SLEEP, isChecked ? 1 : 0);\n                return true;\n            });\n        }", "refactored_code": "    private static final int DEFAULT_VALUE = 0;\n                        SettingsEnums.ACTION_SCREEN_ATTENTION_CHANGED,\n                        isChecked);\n                Settings.Secure.putInt(mContext.getContentResolver(),\n                        Settings.Secure.ADAPTIVE_SLEEP, isChecked ? 1 : DEFAULT_VALUE);\n                return true;\n            });\n        }"}
{"magic_number_smell": "\n    @Override\n    public Slice getSlice() {\n        if (!mConfig.alwaysOnAvailableForUser(UserHandle.myUserId())) {\n            return null;\n        }\n", "refactored_code": "    private static final int MY_USER = UserHandle.myUserId();\n\n    @Override\n    public Slice getSlice() {\n        if (!mConfig.alwaysOnAvailableForUser(MY_USER)) {\n            return null;\n        }\n"}
{"magic_number_smell": "\n    @Override\n    public boolean setChecked(boolean isChecked) {\n        int enabled = isChecked ? 1 : OFF;\n        Settings.Secure.putInt(\n                mContext.getContentResolver(), Settings.Secure.DOZE_ALWAYS_ON, enabled);\n        return true;", "refactored_code": "    private final int ON = 1;\n\n    @Override\n    public boolean setChecked(boolean isChecked) {\n        int enabled = isChecked ? ON : OFF;\n        Settings.Secure.putInt(\n                mContext.getContentResolver(), Settings.Secure.DOZE_ALWAYS_ON, enabled);\n        return true;"}
{"magic_number_smell": "\n    @Override\n    public boolean setChecked(boolean isChecked) {\n        Settings.Secure.putInt(mContext.getContentResolver(), DOZE_ENABLED, isChecked ? 1 : OFF);\n        return true;\n    }\n", "refactored_code": "    private final int ON = 1;\n\n    @Override\n    public boolean setChecked(boolean isChecked) {\n        Settings.Secure.putInt(mContext.getContentResolver(), DOZE_ENABLED, isChecked ? ON : OFF);\n        return true;\n    }\n"}
{"magic_number_smell": "    private static final String TAG = \"AppGridView\";\n\n    private static final int 6 = 6;\n    private int mAppCount = 6;\n\n    public AppGridView(Context context) {\n        super(context);", "refactored_code": "    private static final int APP_COUNT_DEF_VALUE = 6;\n    private static final String TAG = \"AppGridView\";\n\n    private static final int APP_COUNT_DEF_VALUE = 6;\n    private int mAppCount = APP_COUNT_DEF_VALUE;\n\n    public AppGridView(Context context) {\n        super(context);"}
{"magic_number_smell": "    @Override\n    public boolean isChecked() {\n        return Settings.System.getInt(mContext.getContentResolver(),\n                SYSTEM_KEY, SCREEN_BRIGHTNESS_MODE_MANUAL) != SCREEN_BRIGHTNESS_MODE_MANUAL;\n    }\n\n    @Override", "refactored_code": "    private final int DEFAULT_VALUE = SCREEN_BRIGHTNESS_MODE_MANUAL;\n    @Override\n    public boolean isChecked() {\n        return Settings.System.getInt(mContext.getContentResolver(),\n                SYSTEM_KEY, DEFAULT_VALUE) != DEFAULT_VALUE;\n    }\n\n    @Override"}
{"magic_number_smell": "        if (isValidColorMode(colorMode)) {\n            return getKeyForColorMode(colorMode);\n        }\n        return getKeyForColorMode(COLOR_MODE_NATURAL);\n    }\n\n    @Override", "refactored_code": "    private static final int COLOR_MODE_FALLBACK = COLOR_MODE_NATURAL;\n        if (isValidColorMode(colorMode)) {\n            return getKeyForColorMode(colorMode);\n        }\n        return getKeyForColorMode(COLOR_MODE_FALLBACK);\n    }\n\n    @Override"}
{"magic_number_smell": "            return true;\n        } else if (\"night_display_start_time\".equals(preference.getKey())) {\n            writePreferenceClickMetric(preference);\n            showDialog(0);\n            return true;\n        }\n        return super.onPreferenceTreeClick(preference);", "refactored_code": "    private static final int DIALOG_START_TIME = 0;\n            return true;\n        } else if (\"night_display_start_time\".equals(preference.getKey())) {\n            writePreferenceClickMetric(preference);\n            showDialog(DIALOG_START_TIME);\n            return true;\n        }\n        return super.onPreferenceTreeClick(preference);"}
{"magic_number_smell": "                    DeviceConfig.getFloat(\n                            DeviceConfig.NAMESPACE_DISPLAY_MANAGER,\n                            DisplayManager.DeviceConfig.KEY_PEAK_REFRESH_RATE_DEFAULT,\n                            -1f);\n            Log.d(TAG, \"DeviceConfig getDefaultPeakRefreshRate : \" + defaultPeakRefreshRate);\n\n            return defaultPeakRefreshRate;", "refactored_code": "    private static final float INVALIDATE_REFRESH_RATE = -1f;\n                    DeviceConfig.getFloat(\n                            DeviceConfig.NAMESPACE_DISPLAY_MANAGER,\n                            DisplayManager.DeviceConfig.KEY_PEAK_REFRESH_RATE_DEFAULT,\n                            INVALIDATE_REFRESH_RATE);\n            Log.d(TAG, \"DeviceConfig getDefaultPeakRefreshRate : \" + defaultPeakRefreshRate);\n\n            return defaultPeakRefreshRate;"}
{"magic_number_smell": "                view.animate()\n                        .alpha(alpha)\n                        .setInterpolator(FADE_IN_INTERPOLATOR)\n                        .setDuration(400)\n                        .setListener(new PreviewFrameAnimatorListener())\n                        .withStartAction(new Runnable() {\n                            @Override", "refactored_code": "    private static final long CROSS_FADE_DURATION_MS = 400;\n                view.animate()\n                        .alpha(alpha)\n                        .setInterpolator(FADE_IN_INTERPOLATOR)\n                        .setDuration(CROSS_FADE_DURATION_MS)\n                        .setListener(new PreviewFrameAnimatorListener())\n                        .withStartAction(new Runnable() {\n                            @Override"}
{"magic_number_smell": "\n    private String getCurrentSystemScreenTimeout(Context context) {\n        if (context == null) {\n            return Long.toString(30000);\n        } else {\n            return Long.toString(Settings.System.getLong(context.getContentResolver(),\n                    SCREEN_OFF_TIMEOUT, 30000));", "refactored_code": "    public static final int FALLBACK_SCREEN_TIMEOUT_VALUE = 30000;\n\n    private String getCurrentSystemScreenTimeout(Context context) {\n        if (context == null) {\n            return Long.toString(FALLBACK_SCREEN_TIMEOUT_VALUE);\n        } else {\n            return Long.toString(Settings.System.getLong(context.getContentResolver(),\n                    SCREEN_OFF_TIMEOUT, FALLBACK_SCREEN_TIMEOUT_VALUE));"}
{"magic_number_smell": "            showDialog(DIALOG_END_TIME);\n            return true;\n        } else if (DARK_THEME_START_TIME.equals(preference.getKey())) {\n            showDialog(0);\n            return true;\n        }\n        return super.onPreferenceTreeClick(preference);", "refactored_code": "    private static final int DIALOG_START_TIME = 0;\n            showDialog(DIALOG_END_TIME);\n            return true;\n        } else if (DARK_THEME_START_TIME.equals(preference.getKey())) {\n            showDialog(DIALOG_START_TIME);\n            return true;\n        }\n        return super.onPreferenceTreeClick(preference);"}
{"magic_number_smell": "\n\n    @Retention(RetentionPolicy.SOURCE)\n    @IntDef({DreamItemViewTypes.0, DreamItemViewTypes.NO_DREAM_ITEM})\n    public @interface ViewType {}\n}\n", "refactored_code": "    public static final int DREAM_ITEM = 0;\n\n\n    @Retention(RetentionPolicy.SOURCE)\n    @IntDef({DreamItemViewTypes.DREAM_ITEM, DreamItemViewTypes.NO_DREAM_ITEM})\n    public @interface ViewType {}\n}\n"}
{"magic_number_smell": "\n    @Override\n    public boolean isAlwaysOnVpnSetInCurrentUser() {\n        return VpnUtils.isAlwaysOnVpnSet(mVm, UserHandle.myUserId());\n    }\n\n    @Override", "refactored_code": "    private static final int MY_USER_ID = UserHandle.myUserId();\n\n    @Override\n    public boolean isAlwaysOnVpnSetInCurrentUser() {\n        return VpnUtils.isAlwaysOnVpnSet(mVm, MY_USER_ID);\n    }\n\n    @Override"}
{"magic_number_smell": "                        getSettingsLifecycle(),\n                        packageName,\n                        mState,\n                        0,\n                        REQUEST_REMOVE_DEVICE_ADMIN);\n        if (bundle.getBoolean(EXTRA_SHOW_TIME_INFO, false)) {\n            mPowerUsageTimeController = new PowerUsageTimeController(getContext());", "refactored_code": "    private static final int REQUEST_UNINSTALL = 0;\n                        getSettingsLifecycle(),\n                        packageName,\n                        mState,\n                        REQUEST_UNINSTALL,\n                        REQUEST_REMOVE_DEVICE_ADMIN);\n        if (bundle.getBoolean(EXTRA_SHOW_TIME_INFO, false)) {\n            mPowerUsageTimeController = new PowerUsageTimeController(getContext());"}
{"magic_number_smell": "                Settings.Global.getInt(\n                                mContext.getContentResolver(),\n                                Settings.Global.APP_AUTO_RESTRICTION_ENABLED,\n                                1)\n                        == 1;\n        ((TwoStatePreference) preference).setChecked(smartBatteryOn);\n    }", "refactored_code": "    private static final int ON = 1;\n                Settings.Global.getInt(\n                                mContext.getContentResolver(),\n                                Settings.Global.APP_AUTO_RESTRICTION_ENABLED,\n                                ON)\n                        == ON;\n        ((TwoStatePreference) preference).setChecked(smartBatteryOn);\n    }"}
{"magic_number_smell": "    private final Context mContext;\n    // Device information map from the restoreEntity() method.\n    private final ArrayMap<String, String> mDeviceBuildInfoMap =\n            new ArrayMap<>(6);\n\n    public BatteryBackupHelper(Context context) {\n        mContext = context.getApplicationContext();", "refactored_code": "    private static final int DEVICE_BUILD_INFO_SIZE = 6;\n    private final Context mContext;\n    // Device information map from the restoreEntity() method.\n    private final ArrayMap<String, String> mDeviceBuildInfoMap =\n            new ArrayMap<>(DEVICE_BUILD_INFO_SIZE);\n\n    public BatteryBackupHelper(Context context) {\n        mContext = context.getApplicationContext();"}
{"magic_number_smell": "\n        mBatteryUsageProgressBarPref.setUsageSummary(\n                formatBatteryPercentageText(info.batteryLevel));\n        mBatteryUsageProgressBarPref.setPercent(info.batteryLevel, 100);\n    }\n\n    /** Callback which receives text for the summary line. */", "refactored_code": "    private static final int BATTERY_MAX_LEVEL = 100;\n\n        mBatteryUsageProgressBarPref.setUsageSummary(\n                formatBatteryPercentageText(info.batteryLevel));\n        mBatteryUsageProgressBarPref.setPercent(info.batteryLevel, BATTERY_MAX_LEVEL);\n    }\n\n    /** Callback which receives text for the summary line. */"}
{"magic_number_smell": "    public BatterySaverDrawable(Context context, int frameColor) {\n        super(context, frameColor);\n        // Show as full so it's always uniform color\n        setBatteryLevel(100);\n        setPowerSave(true);\n        setCharging(false);\n        setPowerSaveAsColorError(false);", "refactored_code": "    private static final int MAX_BATTERY = 100;\n    public BatterySaverDrawable(Context context, int frameColor) {\n        super(context, frameColor);\n        // Show as full so it's always uniform color\n        setBatteryLevel(MAX_BATTERY);\n        setPowerSave(true);\n        setCharging(false);\n        setPowerSaveAsColorError(false);"}
{"magic_number_smell": "                            return false;\n                        });\n\n                final long timestamp = timestampArray.get(appInfo.uid, -1);\n                if (timestamp != -1) {\n                    checkBoxPreference.setSummary(\n                            getString(", "refactored_code": "    private static final long TIME_NULL = -1;\n                            return false;\n                        });\n\n                final long timestamp = timestampArray.get(appInfo.uid, TIME_NULL);\n                if (timestamp != TIME_NULL) {\n                    checkBoxPreference.setSummary(\n                            getString("}
{"magic_number_smell": "                Settings.Global.getInt(\n                                mContext.getContentResolver(),\n                                Settings.Global.ADAPTIVE_BATTERY_MANAGEMENT_ENABLED,\n                                1)\n                        == 1;\n        ((TwoStatePreference) preference).setChecked(smartBatteryOn);\n    }", "refactored_code": "    private static final int ON = 1;\n                Settings.Global.getInt(\n                                mContext.getContentResolver(),\n                                Settings.Global.ADAPTIVE_BATTERY_MANAGEMENT_ENABLED,\n                                ON)\n                        == ON;\n        ((TwoStatePreference) preference).setChecked(smartBatteryOn);\n    }"}
{"magic_number_smell": "\n    @Override\n    public void onPowerSaveModeChanged() {\n        mHandler.postDelayed(() -> onPowerSaveModeChangedInternal(), 350L);\n    }\n\n    private void onPowerSaveModeChangedInternal() {", "refactored_code": "    private static final long SWITCH_ANIMATION_DURATION = 350L;\n\n    @Override\n    public void onPowerSaveModeChanged() {\n        mHandler.postDelayed(() -> onPowerSaveModeChangedInternal(), SWITCH_ANIMATION_DURATION);\n    }\n\n    private void onPowerSaveModeChangedInternal() {"}
{"magic_number_smell": "            case KEY_NO_SCHEDULE:\n                break;\n            case KEY_PERCENTAGE:\n                triggerLevel = 10;\n                confirmationExtras.putBoolean(BatterySaverUtils.EXTRA_CONFIRM_TEXT_ONLY, true);\n                confirmationExtras.putInt(\n                        BatterySaverUtils.EXTRA_POWER_SAVE_MODE_TRIGGER,", "refactored_code": "    public static final int TRIGGER_LEVEL_MIN = 10;\n            case KEY_NO_SCHEDULE:\n                break;\n            case KEY_PERCENTAGE:\n                triggerLevel = TRIGGER_LEVEL_MIN;\n                confirmationExtras.putBoolean(BatterySaverUtils.EXTRA_CONFIRM_TEXT_ONLY, true);\n                confirmationExtras.putInt(\n                        BatterySaverUtils.EXTRA_POWER_SAVE_MODE_TRIGGER,"}
{"magic_number_smell": "        mSeekBarPreference.setOnPreferenceChangeListener(this);\n        mSeekBarPreference.setOnSeekBarChangeListener(this);\n        mSeekBarPreference.setContinuousUpdates(true);\n        mSeekBarPreference.setMax(15);\n        mSeekBarPreference.setMin(MIN_SEEKBAR_VALUE);\n        mSeekBarPreference.setKey(KEY_BATTERY_SAVER_SEEK_BAR);\n        mSeekBarPreference.setHapticFeedbackMode(SeekBarPreference.HAPTIC_FEEDBACK_MODE_ON_TICKS);", "refactored_code": "    public static final int MAX_SEEKBAR_VALUE = 15;\n        mSeekBarPreference.setOnPreferenceChangeListener(this);\n        mSeekBarPreference.setOnSeekBarChangeListener(this);\n        mSeekBarPreference.setContinuousUpdates(true);\n        mSeekBarPreference.setMax(MAX_SEEKBAR_VALUE);\n        mSeekBarPreference.setMin(MIN_SEEKBAR_VALUE);\n        mSeekBarPreference.setKey(KEY_BATTERY_SAVER_SEEK_BAR);\n        mSeekBarPreference.setHapticFeedbackMode(SeekBarPreference.HAPTIC_FEEDBACK_MODE_ON_TICKS);"}
{"magic_number_smell": "                Settings.Global.getInt(\n                        mContext.getContentResolver(),\n                        Global.LOW_POWER_MODE_STICKY_AUTO_DISABLE_LEVEL,\n                        90);\n        final String formatPercentage = Utils.formatPercentage(stickyShutoffLevel);\n        preference.setTitle(\n                mContext.getString(", "refactored_code": "    private static final int DEFAULT_STICKY_SHUTOFF_LEVEL = 90;\n                Settings.Global.getInt(\n                        mContext.getContentResolver(),\n                        Global.LOW_POWER_MODE_STICKY_AUTO_DISABLE_LEVEL,\n                        DEFAULT_STICKY_SHUTOFF_LEVEL);\n        final String formatPercentage = Utils.formatPercentage(stickyShutoffLevel);\n        preference.setTitle(\n                mContext.getString("}
{"magic_number_smell": "        final SharedPreferences sharedPreferences =\n                getSharedPreferences(PREF_DB, Context.MODE_PRIVATE);\n        final int currentVersion =\n                sharedPreferences.getInt(KEY_ANOMALY_CONFIG_VERSION, 0);\n        final int newVersion =\n                Settings.Global.getInt(\n                        getContentResolver(),", "refactored_code": "    private static final int DEFAULT_VERSION = 0;\n        final SharedPreferences sharedPreferences =\n                getSharedPreferences(PREF_DB, Context.MODE_PRIVATE);\n        final int currentVersion =\n                sharedPreferences.getInt(KEY_ANOMALY_CONFIG_VERSION, DEFAULT_VERSION);\n        final int newVersion =\n                Settings.Global.getInt(\n                        getContentResolver(),"}
{"magic_number_smell": "    }\n\n    private AnomalyDatabaseHelper(Context context) {\n        super(context, DATABASE_NAME, null, 5);\n    }\n\n    @Override", "refactored_code": "    private static final int DATABASE_VERSION = 5;\n    }\n\n    private AnomalyDatabaseHelper(Context context) {\n        super(context, DATABASE_NAME, null, DATABASE_VERSION);\n    }\n\n    @Override"}
{"magic_number_smell": "                            ? Settings.Global.getInt(\n                                            contentResolver,\n                                            Settings.Global.ADAPTIVE_BATTERY_MANAGEMENT_ENABLED,\n                                            1)\n                                    == 1\n                            : Settings.Global.getInt(\n                                            contentResolver,", "refactored_code": "    private static final int ON = 1;\n                            ? Settings.Global.getInt(\n                                            contentResolver,\n                                            Settings.Global.ADAPTIVE_BATTERY_MANAGEMENT_ENABLED,\n                                            ON)\n                                    == ON\n                            : Settings.Global.getInt(\n                                            contentResolver,"}
{"magic_number_smell": "                BatteryTipDialogFragment dialogFragment =\n                        BatteryTipDialogFragment.newInstance(\n                                batteryTip, mFragment.getMetricsCategory());\n                dialogFragment.setTargetFragment(mFragment, 0);\n                dialogFragment.show(mFragment.getFragmentManager(), TAG);\n            } else {\n                final BatteryTipAction action =", "refactored_code": "    private static final int REQUEST_ANOMALY_ACTION = 0;\n                BatteryTipDialogFragment dialogFragment =\n                        BatteryTipDialogFragment.newInstance(\n                                batteryTip, mFragment.getMetricsCategory());\n                dialogFragment.setTargetFragment(mFragment, REQUEST_ANOMALY_ACTION);\n                dialogFragment.show(mFragment.getFragmentManager(), TAG);\n            } else {\n                final BatteryTipAction action ="}
{"magic_number_smell": "        final PendingIntent pendingIntent =\n                PendingIntent.getBroadcast(\n                        context,\n                        0,\n                        extraIntent,\n                        PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_MUTABLE);\n        statsManager.setBroadcastSubscriber(", "refactored_code": "    private static final int REQUEST_CODE = 0;\n        final PendingIntent pendingIntent =\n                PendingIntent.getBroadcast(\n                        context,\n                        REQUEST_CODE,\n                        extraIntent,\n                        PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_MUTABLE);\n        statsManager.setBroadcastSubscriber("}
{"magic_number_smell": "                                1)\n                        == 0;\n        final boolean isUnderExpectedBatteryLevel =\n                mBatteryInfo.batteryLevel <= 30;\n        // Show it if in test or smart battery is off.\n        final boolean enableSmartBatteryTip =\n                smartBatteryOff && !mIsPowerSaveMode && isUnderExpectedBatteryLevel", "refactored_code": "    private static final int EXPECTED_BATTERY_LEVEL = 30;\n                                1)\n                        == 0;\n        final boolean isUnderExpectedBatteryLevel =\n                mBatteryInfo.batteryLevel <= EXPECTED_BATTERY_LEVEL;\n        // Show it if in test or smart battery is off.\n        final boolean enableSmartBatteryTip =\n                smartBatteryOff && !mIsPowerSaveMode && isUnderExpectedBatteryLevel"}
{"magic_number_smell": "            mBatteryChartViewGroup\n                    .animate()\n                    .alpha(1f)\n                    .setDuration(400L)\n                    .start();\n        }\n    }", "refactored_code": "    private static final long FADE_IN_ANIMATION_DURATION = 400L;\n            mBatteryChartViewGroup\n                    .animate()\n                    .alpha(1f)\n                    .setDuration(FADE_IN_ANIMATION_DURATION)\n                    .start();\n        }\n    }"}
{"magic_number_smell": "        mDividerHeight = resources.getDimensionPixelSize(R.dimen.chartview_divider_height);\n        mDividerPaint = new Paint();\n        mDividerPaint.setAntiAlias(true);\n        mDividerPaint.setColor(Color.parseColor(\"#CDCCC5\"));\n        mDividerPaint.setStyle(Paint.Style.STROKE);\n        mDividerPaint.setStrokeWidth(mDividerWidth);\n        Log.i(TAG, \"mDividerWidth:\" + mDividerWidth);", "refactored_code": "    private static final int DIVIDER_COLOR = Color.parseColor(\"#CDCCC5\");\n        mDividerHeight = resources.getDimensionPixelSize(R.dimen.chartview_divider_height);\n        mDividerPaint = new Paint();\n        mDividerPaint.setAntiAlias(true);\n        mDividerPaint.setColor(DIVIDER_COLOR);\n        mDividerPaint.setStyle(Paint.Style.STROKE);\n        mDividerPaint.setStrokeWidth(mDividerWidth);\n        Log.i(TAG, \"mDividerWidth:\" + mDividerWidth);"}
{"magic_number_smell": "    private final String[] mTexts;\n    private final String[] mFullTexts;\n\n    private int mSelectedIndex = -1;\n    private int mHighlightSlotIndex = SELECTED_INDEX_INVALID;\n\n    BatteryChartViewModel(", "refactored_code": "    public static final int SELECTED_INDEX_ALL = -1;\n    private final String[] mTexts;\n    private final String[] mFullTexts;\n\n    private int mSelectedIndex = SELECTED_INDEX_ALL;\n    private int mHighlightSlotIndex = SELECTED_INDEX_INVALID;\n\n    BatteryChartViewModel("}
{"magic_number_smell": "\n    public BatteryLevelData(@NonNull Map<Long, Integer> batteryLevelMap) {\n        final int mapSize = batteryLevelMap.size();\n        Preconditions.checkArgument(mapSize >= 2, \"batteryLevelMap size:\" + mapSize);\n\n        final List<Long> timestampList = new ArrayList<>(batteryLevelMap.keySet());\n        Collections.sort(timestampList);", "refactored_code": "    private static final long MIN_SIZE = 2;\n\n    public BatteryLevelData(@NonNull Map<Long, Integer> batteryLevelMap) {\n        final int mapSize = batteryLevelMap.size();\n        Preconditions.checkArgument(mapSize >= MIN_SIZE, \"batteryLevelMap size:\" + mapSize);\n\n        final List<Long> timestampList = new ArrayList<>(batteryLevelMap.keySet());\n        Collections.sort(timestampList);"}
{"magic_number_smell": "        sUriMatcher.addURI(\n                DatabaseUtils.AUTHORITY,\n                /* path= */ DatabaseUtils.BATTERY_STATE_TABLE,\n                /* code= */ 1);\n        sUriMatcher.addURI(\n                DatabaseUtils.AUTHORITY,\n                /* path= */ DatabaseUtils.APP_USAGE_LATEST_TIMESTAMP_PATH,", "refactored_code": "    private static final int BATTERY_STATE_CODE = 1;\n        sUriMatcher.addURI(\n                DatabaseUtils.AUTHORITY,\n                /* path= */ DatabaseUtils.BATTERY_STATE_TABLE,\n                /* code= */ BATTERY_STATE_CODE);\n        sUriMatcher.addURI(\n                DatabaseUtils.AUTHORITY,\n                /* path= */ DatabaseUtils.APP_USAGE_LATEST_TIMESTAMP_PATH,"}
{"magic_number_smell": "    }\n\n    private static void clearMemory() {\n        if (SystemClock.uptimeMillis() > Duration.ofMinutes(5).toMillis()) {\n            return;\n        }\n        final Handler mainHandler = new Handler(Looper.getMainLooper());", "refactored_code": "    private static final long CLEAR_MEMORY_THRESHOLD_MS = Duration.ofMinutes(5).toMillis();\n    }\n\n    private static void clearMemory() {\n        if (SystemClock.uptimeMillis() > CLEAR_MEMORY_THRESHOLD_MS) {\n            return;\n        }\n        final Handler mainHandler = new Handler(Looper.getMainLooper());"}
{"magic_number_smell": "                            componentId,\n                            deviceConsumer.getConsumedPower(componentId),\n                            deviceConsumer.getUsageDurationMillis(componentId),\n                            componentId == 7\n                                    || componentId == POWER_COMPONENT_WAKELOCK));\n        }\n", "refactored_code": "    private static final int POWER_COMPONENT_SYSTEM_SERVICES = 7;\n                            componentId,\n                            deviceConsumer.getConsumedPower(componentId),\n                            deviceConsumer.getUsageDurationMillis(componentId),\n                            componentId == POWER_COMPONENT_SYSTEM_SERVICES\n                                    || componentId == POWER_COMPONENT_WAKELOCK));\n        }\n"}
{"magic_number_smell": "                        .setAction(PeriodicJobReceiver.ACTION_PERIODIC_JOB_UPDATE);\n        return PendingIntent.getBroadcast(\n                mContext.getApplicationContext(),\n                TAG.hashCode(),\n                broadcastIntent,\n                PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE);\n    }", "refactored_code": "    private static final int ALARM_MANAGER_REQUEST_CODE = TAG.hashCode();\n                        .setAction(PeriodicJobReceiver.ACTION_PERIODIC_JOB_UPDATE);\n        return PendingIntent.getBroadcast(\n                mContext.getApplicationContext(),\n                ALARM_MANAGER_REQUEST_CODE,\n                broadcastIntent,\n                PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE);\n    }"}
{"magic_number_smell": "        final boolean isNightMode = Utils.isNightMode(getContext());\n        final float alpha =\n                isSelectable()\n                        ? 1f\n                        : (isNightMode\n                                ? UNSELECTABLE_ALPHA_DARK_MODE\n                                : UNSELECTABLE_ALPHA_LIGHT_MODE);", "refactored_code": "    private static final float SELECTABLE_ALPHA = 1f;\n        final boolean isNightMode = Utils.isNightMode(getContext());\n        final float alpha =\n                isSelectable()\n                        ? SELECTABLE_ALPHA\n                        : (isNightMode\n                                ? UNSELECTABLE_ALPHA_DARK_MODE\n                                : UNSELECTABLE_ALPHA_LIGHT_MODE);"}
{"magic_number_smell": "        @Override\n        public void handleMessage(Message msg) {\n            switch(msg.what) {\n                case 1:\n                    mTimeAnimator.end();\n                    mFinalWidth = msg.arg1;\n                    mWidthChangePerMs = Math.abs(mCurrentWidth - mFinalWidth)", "refactored_code": "    private static final int MSG_SET_INDICATOR_WIDTH = 1;\n        @Override\n        public void handleMessage(Message msg) {\n            switch(msg.what) {\n                case MSG_SET_INDICATOR_WIDTH:\n                    mTimeAnimator.end();\n                    mFinalWidth = msg.arg1;\n                    mWidthChangePerMs = Math.abs(mCurrentWidth - mFinalWidth)"}
{"magic_number_smell": "    @Override\n    public boolean setChecked(boolean isChecked) {\n        return Settings.Secure.putInt(mContext.getContentResolver(), SECURE_KEY,\n                isChecked ? 1 : OFF);\n    }\n\n    @Override", "refactored_code": "    private final int ON = 1;\n    @Override\n    public boolean setChecked(boolean isChecked) {\n        return Settings.Secure.putInt(mContext.getContentResolver(), SECURE_KEY,\n                isChecked ? ON : OFF);\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public boolean setChecked(boolean isChecked) {\n        setDoubleTwistPreference(mContext, mUserManager, isChecked ? 1 : OFF);\n        return true;\n    }\n", "refactored_code": "    private final int ON = 1;\n\n    @Override\n    public boolean setChecked(boolean isChecked) {\n        setDoubleTwistPreference(mContext, mUserManager, isChecked ? ON : OFF);\n        return true;\n    }\n"}
{"magic_number_smell": "    @Override\n    public boolean setChecked(boolean isChecked) {\n        return Settings.Secure.putInt(mContext.getContentResolver(), SECURE_KEY,\n                isChecked ? 1 : OFF);\n    }\n\n    private AmbientDisplayConfiguration getAmbientConfig() {", "refactored_code": "    private static final int ON = 1;\n    @Override\n    public boolean setChecked(boolean isChecked) {\n        return Settings.Secure.putInt(mContext.getContentResolver(), SECURE_KEY,\n                isChecked ? ON : OFF);\n    }\n\n    private AmbientDisplayConfiguration getAmbientConfig() {"}
{"magic_number_smell": "    }\n\n    public static boolean isSwipeToNotificationOn(Context context) {\n        return Settings.Secure.getInt(context.getContentResolver(), SECURE_KEY, OFF) == 1;\n    }\n\n    public static boolean setSwipeToNotification(Context context, boolean isEnabled) {", "refactored_code": "    private static final int ON = 1;\n    }\n\n    public static boolean isSwipeToNotificationOn(Context context) {\n        return Settings.Secure.getInt(context.getContentResolver(), SECURE_KEY, OFF) == ON;\n    }\n\n    public static boolean setSwipeToNotification(Context context, boolean isEnabled) {"}
{"magic_number_smell": "        mVideoPreference = new IllustrationPreference(context);\n        Context windowContext = context.createWindowContext(TYPE_APPLICATION_OVERLAY, null);\n        if (windowContext.getResources()\n                .getConfiguration().smallestScreenWidthDp >= 600) {\n            mVideoPreference.applyDynamicColor();\n        }\n        setIllustrationVideo(mVideoPreference, getDefaultKey());", "refactored_code": "    private static final int MIN_LARGESCREEN_WIDTH_DP = 600;\n        mVideoPreference = new IllustrationPreference(context);\n        Context windowContext = context.createWindowContext(TYPE_APPLICATION_OVERLAY, null);\n        if (windowContext.getResources()\n                .getConfiguration().smallestScreenWidthDp >= MIN_LARGESCREEN_WIDTH_DP) {\n            mVideoPreference.applyDynamicColor();\n        }\n        setIllustrationVideo(mVideoPreference, getDefaultKey());"}
{"magic_number_smell": "        mHomepageView.setVisibility(scrollNeeded ? View.INVISIBLE : View.GONE);\n        // Schedule a timer to show the homepage and hide the suggestion on timeout.\n        mHomepageView.postDelayed(() -> showHomepageWithSuggestion(false),\n                300);\n        showFragment(new SuggestionFragCreator(fragmentClass, /* isTwoPaneLayout= */ false),\n                R.id.suggestion_content);\n        if (mIsEmbeddingActivityEnabled) {", "refactored_code": "    private static final long HOMEPAGE_LOADING_TIMEOUT_MS = 300;\n        mHomepageView.setVisibility(scrollNeeded ? View.INVISIBLE : View.GONE);\n        // Schedule a timer to show the homepage and hide the suggestion on timeout.\n        mHomepageView.postDelayed(() -> showHomepageWithSuggestion(false),\n                HOMEPAGE_LOADING_TIMEOUT_MS);\n        showFragment(new SuggestionFragCreator(fragmentClass, /* isTwoPaneLayout= */ false),\n                R.id.suggestion_content);\n        if (mIsEmbeddingActivityEnabled) {"}
{"magic_number_smell": "    private static final int 100 = 100;\n\n    static {\n        URI_MATCHER.addURI(CARD_AUTHORITY, CardDatabaseHelper.CARD_TABLE, 100);\n    }\n\n    @Override", "refactored_code": "    private static final int MATCH_CARDS = 100;\n    private static final int MATCH_CARDS = 100;\n\n    static {\n        URI_MATCHER.addURI(CARD_AUTHORITY, CardDatabaseHelper.CARD_TABLE, MATCH_CARDS);\n    }\n\n    @Override"}
{"magic_number_smell": "                    + \");\";\n\n    public CardDatabaseHelper(Context context) {\n        super(context, DATABASE_NAME, null, 7);\n    }\n\n    @Override", "refactored_code": "    private static final int DATABASE_VERSION = 7;\n                    + \");\";\n\n    public CardDatabaseHelper(Context context) {\n        super(context, DATABASE_NAME, null, DATABASE_VERSION);\n    }\n\n    @Override"}
{"magic_number_smell": "                .map(card -> new EligibleCardChecker(mContext, card))\n                .collect(Collectors.toList());\n        try {\n            eligibleCards = executor.invokeAll(checkers, 400,\n                    TimeUnit.MILLISECONDS);\n        } catch (InterruptedException e) {\n            Log.w(TAG, \"Failed to get eligible states for all cards\", e);", "refactored_code": "    private static final long ELIGIBILITY_CHECKER_TIMEOUT_MS = 400;\n                .map(card -> new EligibleCardChecker(mContext, card))\n                .collect(Collectors.toList());\n        try {\n            eligibleCards = executor.invokeAll(checkers, ELIGIBILITY_CHECKER_TIMEOUT_MS,\n                    TimeUnit.MILLISECONDS);\n        } catch (InterruptedException e) {\n            Log.w(TAG, \"Failed to get eligible states for all cards\", e);"}
{"magic_number_smell": "                    final int viewType = mContextualCards.get(position).getViewType();\n                    if (viewType == ConditionContextualCardRenderer.VIEW_TYPE_HALF_WIDTH\n                            || viewType == SliceContextualCardRenderer.VIEW_TYPE_HALF_WIDTH) {\n                        return 1;\n                    }\n                    return FULL_WIDTH;\n                }", "refactored_code": "    private static final int HALF_WIDTH = 1;\n                    final int viewType = mContextualCards.get(position).getViewType();\n                    if (viewType == ConditionContextualCardRenderer.VIEW_TYPE_HALF_WIDTH\n                            || viewType == SliceContextualCardRenderer.VIEW_TYPE_HALF_WIDTH) {\n                        return HALF_WIDTH;\n                    }\n                    return FULL_WIDTH;\n                }"}
{"magic_number_smell": "    }\n\n    private List<ContextualCard> getExpandedConditionalCards(List<ContextualCard> conditionCards) {\n        if (conditionCards.isEmpty() || (conditionCards.size() > 0\n                && !mIsExpanded)) {\n            return Collections.EMPTY_LIST;\n        }", "refactored_code": "    public static final int EXPANDING_THRESHOLD = 0;\n    }\n\n    private List<ContextualCard> getExpandedConditionalCards(List<ContextualCard> conditionCards) {\n        if (conditionCards.isEmpty() || (conditionCards.size() > EXPANDING_THRESHOLD\n                && !mIsExpanded)) {\n            return Collections.EMPTY_LIST;\n        }"}
{"magic_number_smell": "        for (Future<ContextualCard> cardFuture : displayableCards) {\n            try {\n                final ContextualCard card = cardFuture.get(\n                        20, TimeUnit.MILLISECONDS);\n                if (card != null) {\n                    cards.add(card);\n                }", "refactored_code": "    private static final long DISPLAYABLE_CHECKER_TIMEOUT_MS = 20;\n        for (Future<ContextualCard> cardFuture : displayableCards) {\n            try {\n                final ContextualCard card = cardFuture.get(\n                        DISPLAYABLE_CHECKER_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n                if (card != null) {\n                    cards.add(card);\n                }"}
{"magic_number_smell": "    @Override\n    public Slice getSlice() {\n        final long setupTime = mContext.getSharedPreferences(PREF, Context.MODE_PRIVATE).getLong(\n                PREF_KEY_SETUP_TIME, 0);\n        if (setupTime == 0) {\n            // Set the first setup time.\n            mContext.getSharedPreferences(PREF, Context.MODE_PRIVATE)", "refactored_code": "    private static final long DEFAULT_SETUP_TIME = 0;\n    @Override\n    public Slice getSlice() {\n        final long setupTime = mContext.getSharedPreferences(PREF, Context.MODE_PRIVATE).getLong(\n                PREF_KEY_SETUP_TIME, DEFAULT_SETUP_TIME);\n        if (setupTime == DEFAULT_SETUP_TIME) {\n            // Set the first setup time.\n            mContext.getSharedPreferences(PREF, Context.MODE_PRIVATE)"}
{"magic_number_smell": "        final BatteryManager batteryManager = context.getSystemService(BatteryManager.class);\n        final int level = batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY);\n        Log.d(TAG, \"battery level = \" + level);\n        return level <= 50;\n    }\n\n    private void resetValue(boolean preChecked, boolean clicked) {", "refactored_code": "    private static final int BATTERY_LEVEL_THRESHOLD = 50;\n        final BatteryManager batteryManager = context.getSystemService(BatteryManager.class);\n        final int level = batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY);\n        Log.d(TAG, \"battery level = \" + level);\n        return level <= BATTERY_LEVEL_THRESHOLD;\n    }\n\n    private void resetValue(boolean preChecked, boolean clicked) {"}
{"magic_number_smell": "\n    public static int getReEnrollSetting(Context context, int userId) {\n        return Settings.Secure.getIntForUser(context.getContentResolver(),\n                Settings.Secure.FACE_UNLOCK_RE_ENROLL, 0, userId);\n    }\n\n}", "refactored_code": "    public static final int FACE_NO_RE_ENROLL_REQUIRED = 0;\n\n    public static int getReEnrollSetting(Context context, int userId) {\n        return Settings.Secure.getIntForUser(context.getContentResolver(),\n                Settings.Secure.FACE_UNLOCK_RE_ENROLL, FACE_NO_RE_ENROLL_REQUIRED, userId);\n    }\n\n}"}
{"magic_number_smell": "                Utils.getColorAccentDefaultColor(mContext));\n        final IconCompat icon = IconCompat.createWithResource(mContext, R.drawable.ic_storage);\n\n        if (usedPercentage < 0.85) {\n            // For clients that ignore error checking, a generic storage slice will be given.\n            final CharSequence titleStorage = mContext.getText(R.string.storage_settings);\n            final String summaryStorage = mContext.getString(R.string.storage_summary,", "refactored_code": "    private static final double LOW_STORAGE_THRESHOLD = 0.85;\n                Utils.getColorAccentDefaultColor(mContext));\n        final IconCompat icon = IconCompat.createWithResource(mContext, R.drawable.ic_storage);\n\n        if (usedPercentage < LOW_STORAGE_THRESHOLD) {\n            // For clients that ignore error checking, a generic storage slice will be given.\n            final CharSequence titleStorage = mContext.getText(R.string.storage_settings);\n            final String summaryStorage = mContext.getString(R.string.storage_summary,"}
{"magic_number_smell": "                    if (mInputManager != null && mKeyboardLayoutPreview != null) {\n                        Drawable previewDrawable = mInputManager.getKeyboardLayoutPreview(\n                                keyboardLayout,\n                                1630, DEFAULT_KEYBOARD_PREVIEW_HEIGHT);\n                        mKeyboardLayoutPreview.setVisibility(\n                                previewDrawable == null ? GONE : VISIBLE);\n                        if (previewDrawable != null) {", "refactored_code": "    private static final int DEFAULT_KEYBOARD_PREVIEW_WIDTH = 1630;\n                    if (mInputManager != null && mKeyboardLayoutPreview != null) {\n                        Drawable previewDrawable = mInputManager.getKeyboardLayoutPreview(\n                                keyboardLayout,\n                                DEFAULT_KEYBOARD_PREVIEW_WIDTH, DEFAULT_KEYBOARD_PREVIEW_HEIGHT);\n                        mKeyboardLayoutPreview.setVisibility(\n                                previewDrawable == null ? GONE : VISIBLE);\n                        if (previewDrawable != null) {"}
{"magic_number_smell": "        builder.setTitle(R.string.phone_language);\n        final int subtypeCount = currentSci.getSubtypeCount();\n        final CharSequence[] items = new CharSequence[subtypeCount + 1 /* default */];\n        items[0] = getSpellCheckerSubtypeLabel(currentSci, null);\n        int checkedItemId = 0;\n        for (int index = 0; index < subtypeCount; ++index) {\n            final SpellCheckerSubtype subtype = currentSci.getSubtypeAt(index);", "refactored_code": "    private static final int ITEM_ID_USE_SYSTEM_LANGUAGE = 0;\n        builder.setTitle(R.string.phone_language);\n        final int subtypeCount = currentSci.getSubtypeCount();\n        final CharSequence[] items = new CharSequence[subtypeCount + 1 /* default */];\n        items[ITEM_ID_USE_SYSTEM_LANGUAGE] = getSpellCheckerSubtypeLabel(currentSci, null);\n        int checkedItemId = ITEM_ID_USE_SYSTEM_LANGUAGE;\n        for (int index = 0; index < subtypeCount; ++index) {\n            final SpellCheckerSubtype subtype = currentSci.getSubtypeAt(index);"}
{"magic_number_smell": "                .isEnabled(mContext, FeatureFlagUtils.SETTINGS_NEW_KEYBOARD_TRACKPAD_GESTURE);\n        if (getPreferenceKey().equals(PREFERENCE_KEY)) {\n            if (touchGestureDeveloperMode) {\n                buttonPreference.setOrder(0);\n            } else {\n                buttonPreference.setOrder(ORDER_BOTTOM);\n            }", "refactored_code": "    private static final int ORDER_TOP = 0;\n                .isEnabled(mContext, FeatureFlagUtils.SETTINGS_NEW_KEYBOARD_TRACKPAD_GESTURE);\n        if (getPreferenceKey().equals(PREFERENCE_KEY)) {\n            if (touchGestureDeveloperMode) {\n                buttonPreference.setOrder(ORDER_TOP);\n            } else {\n                buttonPreference.setOrder(ORDER_BOTTOM);\n            }"}
{"magic_number_smell": "        for (int i = 0; i < mPageList.size(); i++) {\n            final ImageView imageView = new ImageView(mContext);\n            final ViewGroup.MarginLayoutParams lp =\n                    new ViewGroup.MarginLayoutParams(12, 12);\n            lp.setMargins(DOT_INDICATOR_LEFT_PADDING, 0, DOT_INDICATOR_RIGHT_PADDING, 0);\n            imageView.setLayoutParams(lp);\n            mDotIndicators[i] = imageView;", "refactored_code": "    private static final int DOT_INDICATOR_SIZE = 12;\n        for (int i = 0; i < mPageList.size(); i++) {\n            final ImageView imageView = new ImageView(mContext);\n            final ViewGroup.MarginLayoutParams lp =\n                    new ViewGroup.MarginLayoutParams(DOT_INDICATOR_SIZE, DOT_INDICATOR_SIZE);\n            lp.setMargins(DOT_INDICATOR_LEFT_PADDING, 0, DOT_INDICATOR_RIGHT_PADDING, 0);\n            imageView.setLayoutParams(lp);\n            mDotIndicators[i] = imageView;"}
{"magic_number_smell": "\n    private static final int FREQUENCY_FOR_USER_DICTIONARY_ADDS = 250;\n\n    private final int mMode; // Either 0 or MODE_INSERT\n    private final EditText mWordEditText;\n    private final EditText mShortcutEditText;\n    private String mLocale;", "refactored_code": "    public static final int MODE_EDIT = 0;\n\n    private static final int FREQUENCY_FOR_USER_DICTIONARY_ADDS = 250;\n\n    private final int mMode; // Either MODE_EDIT or MODE_INSERT\n    private final EditText mWordEditText;\n    private final EditText mShortcutEditText;\n    private String mLocale;"}
{"magic_number_smell": "\n    @Override\n    public void onCreateOptionsMenu(final Menu menu, final MenuInflater inflater) {\n        MenuItem actionItem = menu.add(0, Menu.FIRST, 0, R.string.delete)\n                .setIcon(R.drawable.ic_delete);\n        actionItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM |\n                MenuItem.SHOW_AS_ACTION_WITH_TEXT);", "refactored_code": "    private static final int OPTIONS_MENU_DELETE = Menu.FIRST;\n\n    @Override\n    public void onCreateOptionsMenu(final Menu menu, final MenuInflater inflater) {\n        MenuItem actionItem = menu.add(0, OPTIONS_MENU_DELETE, 0, R.string.delete)\n                .setIcon(R.drawable.ic_delete);\n        actionItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM |\n                MenuItem.SHOW_AS_ACTION_WITH_TEXT);"}
{"magic_number_smell": "    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        MenuItem actionItem =\n                menu.add(0, Menu.FIRST, 0, R.string.user_dict_settings_add_menu_title)\n                        .setIcon(R.drawable.ic_add_24dp);\n        actionItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM |\n                MenuItem.SHOW_AS_ACTION_WITH_TEXT);", "refactored_code": "    private static final int OPTIONS_MENU_ADD = Menu.FIRST;\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        MenuItem actionItem =\n                menu.add(0, OPTIONS_MENU_ADD, 0, R.string.user_dict_settings_add_menu_title)\n                        .setIcon(R.drawable.ic_add_24dp);\n        actionItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM |\n                MenuItem.SHOW_AS_ACTION_WITH_TEXT);"}
{"magic_number_smell": "            localeSource |= IME_LOCALE;\n        }\n        if (hasSuggestionType(localeInfo, LocaleStore.LocaleInfo.SUGGESTION_TYPE_SIM)) {\n            localeSource |= 1 << 0;\n        }\n        mMetricsFeatureProvider.action(this,\n                SettingsEnums.ACTION_CHANGE_APP_LANGUAGE_FROM_SUGGESTED, localeSource);", "refactored_code": "    private static final int SIM_LOCALE = 1 << 0;\n            localeSource |= IME_LOCALE;\n        }\n        if (hasSuggestionType(localeInfo, LocaleStore.LocaleInfo.SUGGESTION_TYPE_SIM)) {\n            localeSource |= SIM_LOCALE;\n        }\n        mMetricsFeatureProvider.action(this,\n                SettingsEnums.ACTION_CHANGE_APP_LANGUAGE_FROM_SUGGESTED, localeSource);"}
{"magic_number_smell": "                // We change the elevation if selection changed\n                if (mSelectionStatus != SELECTION_UNCHANGED) {\n                    viewHolder.itemView.setElevation(\n                            mSelectionStatus == 1 ? dragElevation : 0);\n                    mSelectionStatus = SELECTION_UNCHANGED;\n                }\n            }", "refactored_code": "            private static final int SELECTION_GAINED = 1;\n                // We change the elevation if selection changed\n                if (mSelectionStatus != SELECTION_UNCHANGED) {\n                    viewHolder.itemView.setElevation(\n                            mSelectionStatus == SELECTION_GAINED ? dragElevation : 0);\n                    mSelectionStatus = SELECTION_UNCHANGED;\n                }\n            }"}
{"magic_number_smell": "    @Override\n    public boolean onOptionsItemSelected(MenuItem menuItem) {\n        switch (menuItem.getItemId()) {\n            case Menu.FIRST + 1:\n                if (mRemoveMode) {\n                    showRemoveLocaleWarningDialog();\n                } else {", "refactored_code": "    private static final int MENU_ID_REMOVE = Menu.FIRST + 1;\n    @Override\n    public boolean onOptionsItemSelected(MenuItem menuItem) {\n        switch (menuItem.getItemId()) {\n            case MENU_ID_REMOVE:\n                if (mRemoveMode) {\n                    showRemoveLocaleWarningDialog();\n                } else {"}
{"magic_number_smell": "    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        Intent intent = getIntent();\n        int notificationId = intent.getIntExtra(EXTRA_NOTIFICATION_ID, -1);\n        String appLocale = intent.getStringExtra(EXTRA_APP_LOCALE);\n        if (TextUtils.isEmpty(appLocale) || notificationId == -1) {\n            finish();", "refactored_code": "    private static final int INVALID_NOTIFICATION_ID = -1;\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        Intent intent = getIntent();\n        int notificationId = intent.getIntExtra(EXTRA_NOTIFICATION_ID, INVALID_NOTIFICATION_ID);\n        String appLocale = intent.getStringExtra(EXTRA_APP_LOCALE);\n        if (TextUtils.isEmpty(appLocale) || notificationId == INVALID_NOTIFICATION_ID) {\n            finish();"}
{"magic_number_smell": "\n        // Add the uid into the locale's uid list\n        uidSet.add(uid);\n        if (dismissCount < 2\n                && notificationCount < NOTIFICATION_COUNT_THRESHOLD\n                // Notification should fire on multiples of 2 apps using the locale.\n                && uidSet.size() % MULTIPLE_BASE == 0", "refactored_code": "    private static final int DISMISS_COUNT_THRESHOLD = 2;\n\n        // Add the uid into the locale's uid list\n        uidSet.add(uid);\n        if (dismissCount < DISMISS_COUNT_THRESHOLD\n                && notificationCount < NOTIFICATION_COUNT_THRESHOLD\n                // Notification should fire on multiples of 2 apps using the locale.\n                && uidSet.size() % MULTIPLE_BASE == 0"}
{"magic_number_smell": "        for (RecentAppOpsAccess.Access access : mRecentLocationApps.getAppListSorted(mShowSystem)) {\n            if (isRequestMatchesProfileType(userManager, access, mType)) {\n                recentLocationAccesses.add(access);\n                if (recentLocationAccesses.size() == 3) {\n                    break;\n                }\n            }", "refactored_code": "    public static final int MAX_APPS = 3;\n        for (RecentAppOpsAccess.Access access : mRecentLocationApps.getAppListSorted(mShowSystem)) {\n            if (isRequestMatchesProfileType(userManager, access, mType)) {\n                recentLocationAccesses.add(access);\n                if (recentLocationAccesses.size() == MAX_APPS) {\n                    break;\n                }\n            }"}
{"magic_number_smell": "    @Override\n    public boolean onOptionsItemSelected(MenuItem menuItem) {\n        switch (menuItem.getItemId()) {\n            case Menu.FIRST + 1:\n            case MENU_HIDE_SYSTEM:\n                mShowSystem = menuItem.getItemId() == Menu.FIRST + 1;\n                Settings.Secure.putInt(getContentResolver(),", "refactored_code": "    private static final int MENU_SHOW_SYSTEM = Menu.FIRST + 1;\n    @Override\n    public boolean onOptionsItemSelected(MenuItem menuItem) {\n        switch (menuItem.getItemId()) {\n            case MENU_SHOW_SYSTEM:\n            case MENU_HIDE_SYSTEM:\n                mShowSystem = menuItem.getItemId() == MENU_SHOW_SYSTEM;\n                Settings.Secure.putInt(getContentResolver(),"}
{"magic_number_smell": "                showSystem)) {\n            if (isRequestMatchesProfileType(userManager, request, mType)) {\n                recentLocationRequests.add(request);\n                if (recentLocationRequests.size() == 3) {\n                    break;\n                }\n            }", "refactored_code": "    public static final int MAX_APPS = 3;\n                showSystem)) {\n            if (isRequestMatchesProfileType(userManager, request, mType)) {\n                recentLocationRequests.add(request);\n                if (recentLocationRequests.size() == MAX_APPS) {\n                    break;\n                }\n            }"}
{"magic_number_smell": "        mContext = context;\n        mTargetSubscriptionId = subscriptionId;\n\n        mCacheState = new AtomicInteger(0);\n        mMaxActiveSubscriptionInfos = new AtomicInteger(MAX_SUBSCRIPTION_UNKNOWN);\n\n        mSubscriptionChangeIntentFilter = new IntentFilter();", "refactored_code": "    private static final int STATE_NOT_LISTENING = 0;\n        mContext = context;\n        mTargetSubscriptionId = subscriptionId;\n\n        mCacheState = new AtomicInteger(STATE_NOT_LISTENING);\n        mMaxActiveSubscriptionInfos = new AtomicInteger(MAX_SUBSCRIPTION_UNKNOWN);\n\n        mSubscriptionChangeIntentFilter = new IntentFilter();"}
{"magic_number_smell": "            if (mFragment != null) {\n                mFragment.startActivityForResult(\n                        new Intent(TelephonyManager.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS, null),\n                        1);\n            }\n            return true;\n        }", "refactored_code": "    public static final int REQUEST_CODE_EXIT_ECM = 1;\n            if (mFragment != null) {\n                mFragment.startActivityForResult(\n                        new Intent(TelephonyManager.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS, null),\n                        REQUEST_CODE_EXIT_ECM);\n            }\n            return true;\n        }"}
{"magic_number_smell": "                    Settings.Global.getLong(\n                            getContext().getContentResolver(),\n                            Settings.Global.ENABLE_MULTI_SLOT_TIMEOUT_MILLIS,\n                            40 * 1000L);\n            if (mSimCardStateChangedLatch.await(waitingTimeMillis, TimeUnit.MILLISECONDS)) {\n                Log.i(TAG, \"Multi SIM were successfully enabled.\");\n                return true;", "refactored_code": "    private static final long DEFAULT_ENABLE_MULTI_SIM_TIMEOUT_MILLS = 40 * 1000L;\n                    Settings.Global.getLong(\n                            getContext().getContentResolver(),\n                            Settings.Global.ENABLE_MULTI_SLOT_TIMEOUT_MILLIS,\n                            DEFAULT_ENABLE_MULTI_SIM_TIMEOUT_MILLS);\n            if (mSimCardStateChangedLatch.await(waitingTimeMillis, TimeUnit.MILLISECONDS)) {\n                Log.i(TAG, \"Multi SIM were successfully enabled.\");\n                return true;"}
{"magic_number_smell": "\n    protected void showResettingAndSendTimeoutChecks() {\n        suspendPreferences();\n        mHandlerInjector.postDelayed(mTimeoutRunnable, 15_000);\n    }\n\n    /** Restart connectivity for all requested subsystems. */", "refactored_code": "    public static final long RESTART_TIMEOUT_MS = 15_000; // 15 seconds\n\n    protected void showResettingAndSendTimeoutChecks() {\n        suspendPreferences();\n        mHandlerInjector.postDelayed(mTimeoutRunnable, RESTART_TIMEOUT_MS);\n    }\n\n    /** Restart connectivity for all requested subsystems. */"}
{"magic_number_smell": "\n    @Retention(RetentionPolicy.SOURCE)\n    @android.annotation.IntDef(prefix = { \"INTERNET_\" }, value = {\n            0,\n            INTERNET_NETWORKS_AVAILABLE,\n            INTERNET_WIFI,\n            INTERNET_CELLULAR,", "refactored_code": "    public static final int INTERNET_OFF = 0;\n\n    @Retention(RetentionPolicy.SOURCE)\n    @android.annotation.IntDef(prefix = { \"INTERNET_\" }, value = {\n            INTERNET_OFF,\n            INTERNET_NETWORKS_AVAILABLE,\n            INTERNET_WIFI,\n            INTERNET_CELLULAR,"}
{"magic_number_smell": "                    lifecycle,\n                    this,\n                    PREF_KEY_PROVIDER_MOBILE_NETWORK,\n                    10);\n        }\n        return mSubscriptionsController;\n    }", "refactored_code": "    private static final int PREFERENCE_START_ORDER = 10;\n                    lifecycle,\n                    this,\n                    PREF_KEY_PROVIDER_MOBILE_NETWORK,\n                    PREFERENCE_START_ORDER);\n        }\n        return mSubscriptionsController;\n    }"}
{"magic_number_smell": "        } else if (requestCode == ADD_NETWORK_REQUEST) {\n            handleAddNetworkRequest(resultCode, data);\n            return;\n        } else if (requestCode == 0) {\n            if (resultCode == Activity.RESULT_OK) {\n                if (mDialog != null) {\n                    mDialog.dismiss();", "refactored_code": "    private static final int REQUEST_CODE_WIFI_DPP_ENROLLEE_QR_CODE_SCANNER = 0;\n        } else if (requestCode == ADD_NETWORK_REQUEST) {\n            handleAddNetworkRequest(resultCode, data);\n            return;\n        } else if (requestCode == REQUEST_CODE_WIFI_DPP_ENROLLEE_QR_CODE_SCANNER) {\n            if (resultCode == Activity.RESULT_OK) {\n                if (mDialog != null) {\n                    mDialog.dismiss();"}
{"magic_number_smell": "    public void addActiveSubscriptionsListener(OnActiveSubscriptionChangedListener listener) {\n        removeSpecificListenerAndCleanList(listener, mPendingNotifyListeners);\n        removeSpecificListenerAndCleanList(listener, mActiveSubscriptionsListeners);\n        if ((listener == null) || (getListenerState(listener) == -1)) {\n            return;\n        }\n        mActiveSubscriptionsListeners.add(listener);", "refactored_code": "    private static final int LISTENER_END_OF_LIFE = -1;\n    public void addActiveSubscriptionsListener(OnActiveSubscriptionChangedListener listener) {\n        removeSpecificListenerAndCleanList(listener, mPendingNotifyListeners);\n        removeSpecificListenerAndCleanList(listener, mActiveSubscriptionsListeners);\n        if ((listener == null) || (getListenerState(listener) == LISTENER_END_OF_LIFE)) {\n            return;\n        }\n        mActiveSubscriptionsListeners.add(listener);"}
{"magic_number_smell": "        if (DEBUG) {\n            Log.d(TAG, \"updateState: \" + state);\n        }\n        setSwitchCheckedInternal(state != 0);\n        setSwitchEnabled(true);\n        for (int i = 0, size = mListeners.size(); i < size; ++i) {\n            mListeners.get(i).onTetherStateUpdated(state);", "refactored_code": "    public static final int TETHERING_OFF = 0;\n        if (DEBUG) {\n            Log.d(TAG, \"updateState: \" + state);\n        }\n        setSwitchCheckedInternal(state != TETHERING_OFF);\n        setSwitchEnabled(true);\n        for (int i = 0, size = mListeners.size(); i < size; ++i) {\n            mListeners.get(i).onTetherStateUpdated(state);"}
{"magic_number_smell": "                Settings.Global.getLong(\n                        context.getContentResolver(),\n                        Settings.Global.EUICC_SWITCH_SLOT_TIMEOUT_MILLIS,\n                        25 * 1000L);\n        Log.d(TAG, \"Set waitingTime as \" + waitingTimeMillis);\n\n        try {", "refactored_code": "    private static final long DEFAULT_WAIT_AFTER_SWITCH_TIMEOUT_MILLIS = 25 * 1000L;\n                Settings.Global.getLong(\n                        context.getContentResolver(),\n                        Settings.Global.EUICC_SWITCH_SLOT_TIMEOUT_MILLIS,\n                        DEFAULT_WAIT_AFTER_SWITCH_TIMEOUT_MILLIS);\n        Log.d(TAG, \"Set waitingTime as \" + waitingTimeMillis);\n\n        try {"}
{"magic_number_smell": "                .setIcon(R.drawable.ic_delete);\n        }\n        if (!mReadOnlyApn) {\n            menu.add(0, Menu.FIRST + 1, 0, R.string.menu_save)\n                .setIcon(android.R.drawable.ic_menu_save);\n        }\n        menu.add(0, MENU_CANCEL, 0, R.string.menu_cancel)", "refactored_code": "    private static final int MENU_SAVE = Menu.FIRST + 1;\n                .setIcon(R.drawable.ic_delete);\n        }\n        if (!mReadOnlyApn) {\n            menu.add(0, MENU_SAVE, 0, R.string.menu_save)\n                .setIcon(android.R.drawable.ic_menu_save);\n        }\n        menu.add(0, MENU_CANCEL, 0, R.string.menu_cancel)"}
{"magic_number_smell": "            while (!cursor.isAfterLast()) {\n                final String name = cursor.getString(NAME_INDEX);\n                final String apn = cursor.getString(APN_INDEX);\n                final String key = cursor.getString(0);\n                final String type = cursor.getString(TYPES_INDEX);\n                final int edited = cursor.getInt(EDITED_INDEX);\n                mMvnoType = cursor.getString(MVNO_TYPE_INDEX);", "refactored_code": "    private static final int ID_INDEX = 0;\n            while (!cursor.isAfterLast()) {\n                final String name = cursor.getString(NAME_INDEX);\n                final String apn = cursor.getString(APN_INDEX);\n                final String key = cursor.getString(ID_INDEX);\n                final String type = cursor.getString(TYPES_INDEX);\n                final int edited = cursor.getInt(EDITED_INDEX);\n                mMvnoType = cursor.getString(MVNO_TYPE_INDEX);"}
{"magic_number_smell": "        final BooleanConsumer booleanResult = new BooleanConsumer();\n        imsMmTelManager.isSupported(mCapability, mTransportType, executor, booleanResult);\n        // get() will be blocked until end of execution(isSupported()) within thread(executor)\n        // or timeout after 2000 milliseconds\n        return booleanResult.get(2000);\n    }\n", "refactored_code": "    private static final long TIMEOUT_MILLIS = 2000;\n        final BooleanConsumer booleanResult = new BooleanConsumer();\n        imsMmTelManager.isSupported(mCapability, mTransportType, executor, booleanResult);\n        // get() will be blocked until end of execution(isSupported()) within thread(executor)\n        // or timeout after TIMEOUT_MILLIS milliseconds\n        return booleanResult.get(TIMEOUT_MILLIS);\n    }\n"}
{"magic_number_smell": "        }\n\n        switch (tag) {\n            case 1:\n                Log.i(TAG, \"Subscription deletion confirmed\");\n                showProgressDialog(getString(R.string.erasing_sim));\n                mDeleteEuiccSubscriptionSidecar.run(mSubscriptionsToBeDeleted);", "refactored_code": "    private static final int DIALOG_TAG_DELETE_SIM_CONFIRMATION = 1;\n        }\n\n        switch (tag) {\n            case DIALOG_TAG_DELETE_SIM_CONFIRMATION:\n                Log.i(TAG, \"Subscription deletion confirmed\");\n                showProgressDialog(getString(R.string.erasing_sim));\n                mDeleteEuiccSubscriptionSidecar.run(mSubscriptionsToBeDeleted);"}
{"magic_number_smell": "    protected static final int MODE_VOLTE = 0;\n    protected static final int MODE_ADVANCED_CALL = 1;\n    protected static final int MODE_4G_CALLING = 2;\n    private int m4gCurrentMode = -1;\n\n    public Enhanced4gBasePreferenceController(Context context, String key) {\n        super(context, key);", "refactored_code": "    protected static final int MODE_NONE = -1;\n    protected static final int MODE_VOLTE = 0;\n    protected static final int MODE_ADVANCED_CALL = 1;\n    protected static final int MODE_4G_CALLING = 2;\n    private int m4gCurrentMode = MODE_NONE;\n\n    public Enhanced4gBasePreferenceController(Context context, String key) {\n        super(context, key);"}
{"magic_number_smell": "                .getTextArray(R.array.enhanced_4g_lte_mode_title_variant);\n        int index = MODE_ADVANCED_CALL;\n        if (variant4gLteTitleIndex != MODE_ADVANCED_CALL) {\n            index = show4GForLTE ? MODE_4G_CALLING : 0;\n        }\n        return variantTitles[index];\n    }", "refactored_code": "    private static final int MODE_VOLTE = 0;\n                .getTextArray(R.array.enhanced_4g_lte_mode_title_variant);\n        int index = MODE_ADVANCED_CALL;\n        if (variant4gLteTitleIndex != MODE_ADVANCED_CALL) {\n            index = show4GForLTE ? MODE_4G_CALLING : MODE_VOLTE;\n        }\n        return variantTitles[index];\n    }"}
{"magic_number_smell": "        Intent intent = new Intent(getReceiverAction());\n        intent.putExtra(EXTRA_OP_ID, mOpId);\n        return PendingIntent.getBroadcast(\n                getContext(), 0, intent,\n                PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE);\n    }\n", "refactored_code": "    private static final int REQUEST_CODE = 0;\n        Intent intent = new Intent(getReceiverAction());\n        intent.putExtra(EXTRA_OP_ID, mOpId);\n        return PendingIntent.getBroadcast(\n                getContext(), REQUEST_CODE, intent,\n                PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE);\n    }\n"}
{"magic_number_smell": "        mSubId = bundle.getInt(ARG_SUB_ID);\n\n        switch (mType) {\n            case 0:\n                return new AlertDialog.Builder(context)\n                        .setMessage(R.string.data_usage_disable_mobile)\n                        .setPositiveButton(android.R.string.ok, this)", "refactored_code": "    public static final int TYPE_DISABLE_DIALOG = 0;\n        mSubId = bundle.getInt(ARG_SUB_ID);\n\n        switch (mType) {\n            case TYPE_DISABLE_DIALOG:\n                return new AlertDialog.Builder(context)\n                        .setMessage(R.string.data_usage_disable_mobile)\n                        .setPositiveButton(android.R.string.ok, this)"}
{"magic_number_smell": "            if (mTelephonyManager.getEmergencyCallbackMode()) {\n                startActivityForResult(\n                        new Intent(TelephonyManager.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS, null),\n                        17);\n                mClickedPrefKey = key;\n            }\n            return true;", "refactored_code": "    public static final int REQUEST_CODE_EXIT_ECM = 17;\n            if (mTelephonyManager.getEmergencyCallbackMode()) {\n                startActivityForResult(\n                        new Intent(TelephonyManager.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS, null),\n                        REQUEST_CODE_EXIT_ECM);\n                mClickedPrefKey = key;\n            }\n            return true;"}
{"magic_number_smell": "\n        // Make the network type drawable\n        final Drawable networkDrawable =\n                iconType == 0\n                        ? EMPTY_DRAWABLE\n                        : context.getResources().getDrawable(iconType, context.getTheme());\n", "refactored_code": "    public static final int NO_CELL_DATA_TYPE_ICON = 0;\n\n        // Make the network type drawable\n        final Drawable networkDrawable =\n                iconType == NO_CELL_DATA_TYPE_ICON\n                        ? EMPTY_DRAWABLE\n                        : context.getResources().getDrawable(iconType, context.getTheme());\n"}
{"magic_number_smell": "    private CellInfo mCellInfo;\n    private CellIdentity mCellId;\n    private List<String> mForbiddenPlmns;\n    private int mLevel = -1;\n    private boolean mShow4GForLTE;\n    private boolean mUseNewApi;\n", "refactored_code": "    private static final int LEVEL_NONE = -1;\n    private CellInfo mCellInfo;\n    private CellIdentity mCellId;\n    private List<String> mForbiddenPlmns;\n    private int mLevel = LEVEL_NONE;\n    private boolean mShow4GForLTE;\n    private boolean mUseNewApi;\n"}
{"magic_number_smell": "    }\n\n    private void setSubscriptionInfoForPreference(Map<Integer, Preference> toRemovePreferences) {\n        int order = 10;\n        for (SubscriptionInfo info : mSubInfoListForWfc) {\n            final int subId = info.getSubscriptionId();\n", "refactored_code": "    private static final int PREF_START_ORDER = 10;\n    }\n\n    private void setSubscriptionInfoForPreference(Map<Integer, Preference> toRemovePreferences) {\n        int order = PREF_START_ORDER;\n        for (SubscriptionInfo info : mSubInfoListForWfc) {\n            final int subId = info.getSubscriptionId();\n"}
{"magic_number_smell": "\n    @Override\n    public int getApRowCount() {\n        return 6;\n    }\n\n    /**", "refactored_code": "    private static final int PROVIDER_MODEL_DEFAULT_EXPANDED_ROW_COUNT = 6;\n\n    @Override\n    public int getApRowCount() {\n        return PROVIDER_MODEL_DEFAULT_EXPANDED_ROW_COUNT;\n    }\n\n    /**"}
{"magic_number_smell": "     * @param type used to tell which network scan API should be used.\n     */\n    public void startNetworkScan(@NetworkQueryType int type) {\n        if (type == 1) {\n            mNetworkScanFuture = SettableFuture.create();\n            Futures.addCallback(mNetworkScanFuture, new FutureCallback<List<CellInfo>>() {\n                @Override", "refactored_code": "    public static final int NETWORK_SCAN_TYPE_WAIT_FOR_ALL_RESULTS = 1;\n     * @param type used to tell which network scan API should be used.\n     */\n    public void startNetworkScan(@NetworkQueryType int type) {\n        if (type == NETWORK_SCAN_TYPE_WAIT_FOR_ALL_RESULTS) {\n            mNetworkScanFuture = SettableFuture.create();\n            Futures.addCallback(mNetworkScanFuture, new FutureCallback<List<CellInfo>>() {\n                @Override"}
{"magic_number_smell": "        final OperatorInfo operator = mSelectedPreference.getOperatorInfo();\n        ThreadUtils.postOnBackgroundThread(() -> {\n            final Message msg = mHandler.obtainMessage(\n                    1);\n            msg.obj = mTelephonyManager.setNetworkSelectionModeManual(\n                    operator, true /* persistSelection */);\n            msg.sendToTarget();", "refactored_code": "    private static final int EVENT_SET_NETWORK_SELECTION_MANUALLY_DONE = 1;\n        final OperatorInfo operator = mSelectedPreference.getOperatorInfo();\n        ThreadUtils.postOnBackgroundThread(() -> {\n            final Message msg = mHandler.obtainMessage(\n                    EVENT_SET_NETWORK_SELECTION_MANUALLY_DONE);\n            msg.obj = mTelephonyManager.setNetworkSelectionModeManual(\n                    operator, true /* persistSelection */);\n            msg.sendToTarget();"}
{"magic_number_smell": "        super.onCreate(savedInstanceState);\n\n        mSubscriptionManager = getSystemService(SubscriptionManager.class);\n        setProgressState(0);\n    }\n\n", "refactored_code": "    public static final int PROGRESS_IS_NOT_SHOWING = 0;\n        super.onCreate(savedInstanceState);\n\n        mSubscriptionManager = getSystemService(SubscriptionManager.class);\n        setProgressState(PROGRESS_IS_NOT_SHOWING);\n    }\n\n"}
{"magic_number_smell": "\n        SubscriptionInfo removedSubInfo = null;\n        switch (tag) {\n            case 1:\n                if (mIsEsimOperation) {\n                    Log.i(TAG, \"Disabling the eSIM profile.\");\n                    showProgressDialog(", "refactored_code": "    private static final int DIALOG_TAG_DISABLE_SIM_CONFIRMATION = 1;\n\n        SubscriptionInfo removedSubInfo = null;\n        switch (tag) {\n            case DIALOG_TAG_DISABLE_SIM_CONFIRMATION:\n                if (mIsEsimOperation) {\n                    Log.i(TAG, \"Disabling the eSIM profile.\");\n                    showProgressDialog("}
{"magic_number_smell": "                        dismissProgressBar();\n                    });\n                });\n            }, Math.max(TimeUnit.SECONDS.toMillis(1) - durationMillis, 0));\n        });\n    }\n", "refactored_code": "    private static final long MINIMUM_DIALOG_TIME_MILLIS = TimeUnit.SECONDS.toMillis(1);\n                        dismissProgressBar();\n                    });\n                });\n            }, Math.max(MINIMUM_DIALOG_TIME_MILLIS - durationMillis, 0));\n        });\n    }\n"}
{"magic_number_smell": "            @Override\n            public void onReceive(Context context, Intent intent) {\n                final int nfcStateExtra = intent.getIntExtra(NfcAdapter.EXTRA_ADAPTER_STATE,\n                        -1);\n\n                // Do nothing if state change is empty, or an intermediate step.\n                if ((nfcStateExtra == -1)", "refactored_code": "            private final int NO_EXTRA = -1;\n            @Override\n            public void onReceive(Context context, Intent intent) {\n                final int nfcStateExtra = intent.getIntExtra(NfcAdapter.EXTRA_ADAPTER_STATE,\n                        NO_EXTRA);\n\n                // Do nothing if state change is empty, or an intermediate step.\n                if ((nfcStateExtra == NO_EXTRA)"}
{"magic_number_smell": "        String sanitizedString = input.replace('\\n', ' ').replace('\\r', ' ').trim();\n\n\n        if (sanitizedString.length() > 40) {\n            return sanitizedString.substring(0, 40);\n        }\n", "refactored_code": "    private static final int PAYMENT_APP_MAX_CAPTION_LENGTH = 40;\n        String sanitizedString = input.replace('\\n', ' ').replace('\\r', ' ').trim();\n\n\n        if (sanitizedString.length() > PAYMENT_APP_MAX_CAPTION_LENGTH) {\n            return sanitizedString.substring(0, PAYMENT_APP_MAX_CAPTION_LENGTH);\n        }\n"}
{"magic_number_smell": "            return false;\n        }\n        return Settings.Secure.getInt(context.getContentResolver(), NOTIFICATION_BUBBLES,\n                1) == 1;\n    }\n}\n", "refactored_code": "    public static final int SYSTEM_WIDE_ON = 1;\n            return false;\n        }\n        return Settings.Secure.getInt(context.getContentResolver(), NOTIFICATION_BUBBLES,\n                SYSTEM_WIDE_ON) == SYSTEM_WIDE_ON;\n    }\n}\n"}
{"magic_number_smell": "            mRequestPreference.onPrepareRingtonePickerIntent(mRequestPreference.getIntent());\n            getActivity().startActivityForResultAsUser(\n                    mRequestPreference.getIntent(),\n                    200,\n                    null,\n                    UserHandle.of(mRequestPreference.getUserId()));\n            return true;", "refactored_code": "    private static final int REQUEST_CODE = 200;\n            mRequestPreference.onPrepareRingtonePickerIntent(mRequestPreference.getIntent());\n            getActivity().startActivityForResultAsUser(\n                    mRequestPreference.getIntent(),\n                    REQUEST_CODE,\n                    null,\n                    UserHandle.of(mRequestPreference.getUserId()));\n            return true;"}
{"magic_number_smell": "\n    private static final int 0 = 0;\n    private static final int DOCK_AUDIO_MEDIA_ENABLED = 1;\n    private static final int DEFAULT_DOCK_AUDIO_MEDIA = 0;\n\n    public DockAudioMediaPreferenceController(Context context, SettingsPreferenceFragment parent,\n            Lifecycle lifecycle) {", "refactored_code": "    private static final int DOCK_AUDIO_MEDIA_DISABLED = 0;\n\n    private static final int DOCK_AUDIO_MEDIA_DISABLED = 0;\n    private static final int DOCK_AUDIO_MEDIA_ENABLED = 1;\n    private static final int DEFAULT_DOCK_AUDIO_MEDIA = DOCK_AUDIO_MEDIA_DISABLED;\n\n    public DockAudioMediaPreferenceController(Context context, SettingsPreferenceFragment parent,\n            Lifecycle lifecycle) {"}
{"magic_number_smell": "    private static final int 0 = 0;\n    private static final int EMERGENCY_TONE_ALERT = 1;\n    private static final int EMERGENCY_TONE_VIBRATE = 2;\n    private static final int DEFAULT_EMERGENCY_TONE = 0;\n\n    public EmergencyTonePreferenceController(Context context, SettingsPreferenceFragment parent,\n            Lifecycle lifecycle) {", "refactored_code": "    private static final int EMERGENCY_TONE_SILENT = 0;\n    private static final int EMERGENCY_TONE_SILENT = 0;\n    private static final int EMERGENCY_TONE_ALERT = 1;\n    private static final int EMERGENCY_TONE_VIBRATE = 2;\n    private static final int DEFAULT_EMERGENCY_TONE = EMERGENCY_TONE_SILENT;\n\n    public EmergencyTonePreferenceController(Context context, SettingsPreferenceFragment parent,\n            Lifecycle lifecycle) {"}
{"magic_number_smell": "\n    protected void recordAggregatedUsageEvents(Context context, AppRow appRow) {\n        long now = System.currentTimeMillis();\n        long startTime = now - (DateUtils.DAY_IN_MILLIS * 7);\n        UsageEvents events = null;\n        try {\n            events = sUsageStatsManager.queryEventsForPackageForUser(", "refactored_code": "    private static final int DAYS_TO_CHECK = 7;\n\n    protected void recordAggregatedUsageEvents(Context context, AppRow appRow) {\n        long now = System.currentTimeMillis();\n        long startTime = now - (DateUtils.DAY_IN_MILLIS * DAYS_TO_CHECK);\n        UsageEvents events = null;\n        try {\n            events = sUsageStatsManager.queryEventsForPackageForUser("}
{"magic_number_smell": "        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case 1:\n                    updateEffectsSuppressor();\n                    break;\n                case UPDATE_RINGER_MODE:", "refactored_code": "        private static final int UPDATE_EFFECTS_SUPPRESSOR = 1;\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case UPDATE_EFFECTS_SUPPRESSOR:\n                    updateEffectsSuppressor();\n                    break;\n                case UPDATE_RINGER_MODE:"}
{"magic_number_smell": "        if (isPoliteNotifDisabled()) {\n            pref.setValue(Integer.toString(POLITE_NOTIFICATIONS_DISABLED));\n        } else if (shouldApplyForAllApps()) {\n            pref.setValue(Integer.toString(0));\n        } else {\n            pref.setValue(Integer.toString(POLITE_NOTIFICATIONS_CONVERSATIONS));\n        }", "refactored_code": "    private static final int POLITE_NOTIFICATIONS_ALL = 0;\n        if (isPoliteNotifDisabled()) {\n            pref.setValue(Integer.toString(POLITE_NOTIFICATIONS_DISABLED));\n        } else if (shouldApplyForAllApps()) {\n            pref.setValue(Integer.toString(POLITE_NOTIFICATIONS_ALL));\n        } else {\n            pref.setValue(Integer.toString(POLITE_NOTIFICATIONS_CONVERSATIONS));\n        }"}
{"magic_number_smell": "    @Override\n    public boolean isChecked() {\n        return Settings.System.getInt(mContext.getContentResolver(), NOTIFICATION_LIGHT_PULSE, OFF)\n                == 1;\n    }\n\n    @Override", "refactored_code": "    private static final int ON = 1;\n    @Override\n    public boolean isChecked() {\n        return Settings.System.getInt(mContext.getContentResolver(), NOTIFICATION_LIGHT_PULSE, OFF)\n                == ON;\n    }\n\n    @Override"}
{"magic_number_smell": "        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case 1:\n                    updateEffectsSuppressor();\n                    break;\n                case UPDATE_RINGER_MODE:", "refactored_code": "        private static final int UPDATE_EFFECTS_SUPPRESSOR = 1;\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case UPDATE_EFFECTS_SUPPRESSOR:\n                    updateEffectsSuppressor();\n                    break;\n                case UPDATE_RINGER_MODE:"}
{"magic_number_smell": "        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case 1:\n                    updateEffectsSuppressor();\n                    break;\n                case UPDATE_RINGER_MODE:", "refactored_code": "        private static final int UPDATE_EFFECTS_SUPPRESSOR = 1;\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case UPDATE_EFFECTS_SUPPRESSOR:\n                    updateEffectsSuppressor();\n                    break;\n                case UPDATE_RINGER_MODE:"}
{"magic_number_smell": "\n    private static Uri getUriFor(int type, String setting) {\n        switch(type) {\n            case 1:\n                return Global.getUriFor(setting);\n            case TYPE_SYSTEM:\n                return System.getUriFor(setting);", "refactored_code": "    public static final int TYPE_GLOBAL = 1;\n\n    private static Uri getUriFor(int type, String setting) {\n        switch(type) {\n            case TYPE_GLOBAL:\n                return Global.getUriFor(setting);\n            case TYPE_SYSTEM:\n                return System.getUriFor(setting);"}
{"magic_number_smell": "    @Override\n    public boolean isChecked() {\n        return Settings.Secure.getInt(mContext.getContentResolver(),\n                LOCK_SCREEN_SHOW_ONLY_UNSEEN_NOTIFICATIONS, 0) == ON;\n    }\n\n    @Override", "refactored_code": "    private static final int UNSET = 0;\n    @Override\n    public boolean isChecked() {\n        return Settings.Secure.getInt(mContext.getContentResolver(),\n                LOCK_SCREEN_SHOW_ONLY_UNSEEN_NOTIFICATIONS, UNSET) == ON;\n    }\n\n    @Override"}
{"magic_number_smell": "            mRequestPreference.onPrepareRingtonePickerIntent(mRequestPreference.getIntent());\n            getActivity().startActivityForResultAsUser(\n                    mRequestPreference.getIntent(),\n                    200,\n                    null,\n                    UserHandle.of(mRequestPreference.getUserId()));\n            return true;", "refactored_code": "    private static final int REQUEST_CODE = 200;\n            mRequestPreference.onPrepareRingtonePickerIntent(mRequestPreference.getIntent());\n            getActivity().startActivityForResultAsUser(\n                    mRequestPreference.getIntent(),\n                    REQUEST_CODE,\n                    null,\n                    UserHandle.of(mRequestPreference.getUserId()));\n            return true;"}
{"magic_number_smell": "            mRequestPreference.onPrepareRingtonePickerIntent(mRequestPreference.getIntent());\n            getActivity().startActivityForResultAsUser(\n                    mRequestPreference.getIntent(),\n                    200,\n                    /* options= */ null,\n                    UserHandle.of(mRequestPreference.getUserId()));\n            return true;", "refactored_code": "    private static final int REQUEST_CODE = 200;\n            mRequestPreference.onPrepareRingtonePickerIntent(mRequestPreference.getIntent());\n            getActivity().startActivityForResultAsUser(\n                    mRequestPreference.getIntent(),\n                    REQUEST_CODE,\n                    /* options= */ null,\n                    UserHandle.of(mRequestPreference.getUserId()));\n            return true;"}
{"magic_number_smell": "            FragmentManager fm = parent.getFragmentManager();\n            if (fm.findFragmentByTag(TAG) == null) {\n                UnifyWorkDialogFragment fragment = new UnifyWorkDialogFragment();\n                fragment.setTargetFragment(parent, 200);\n                fragment.show(fm, TAG);\n            }\n        }", "refactored_code": "        private static final int REQUEST_CODE = 200;\n            FragmentManager fm = parent.getFragmentManager();\n            if (fm.findFragmentByTag(TAG) == null) {\n                UnifyWorkDialogFragment fragment = new UnifyWorkDialogFragment();\n                fragment.setTargetFragment(parent, REQUEST_CODE);\n                fragment.show(fm, TAG);\n            }\n        }"}
{"magic_number_smell": "            return false;\n        }\n        if (Settings.Secure.getInt(mContext.getContentResolver(),\n                NOTIFICATION_BADGING, 1) == SYSTEM_WIDE_OFF) {\n            return false;\n        }\n        if (mChannel != null) {", "refactored_code": "    private static final int SYSTEM_WIDE_ON = 1;\n            return false;\n        }\n        if (Settings.Secure.getInt(mContext.getContentResolver(),\n                NOTIFICATION_BADGING, SYSTEM_WIDE_ON) == SYSTEM_WIDE_OFF) {\n            return false;\n        }\n        if (mChannel != null) {"}
{"magic_number_smell": "            boolean fromUser) {\n        if (fromUser) {\n            AutoTransition transition = new AutoTransition();\n            transition.setDuration(100);\n            TransitionManager.beginDelayedTransition(parent, transition);\n        }\n", "refactored_code": "    private static final int BUTTON_ANIM_TIME_MS = 100;\n            boolean fromUser) {\n        if (fromUser) {\n            AutoTransition transition = new AutoTransition();\n            transition.setDuration(BUTTON_ANIM_TIME_MS);\n            TransitionManager.beginDelayedTransition(parent, transition);\n        }\n"}
{"magic_number_smell": "    void setImportanceSummary(ViewGroup parent, int importance, boolean fromUser) {\n        if (fromUser) {\n            AutoTransition transition = new AutoTransition();\n            transition.setDuration(100);\n            TransitionManager.beginDelayedTransition(parent, transition);\n        }\n", "refactored_code": "    private static final int BUTTON_ANIM_TIME_MS = 100;\n    void setImportanceSummary(ViewGroup parent, int importance, boolean fromUser) {\n        if (fromUser) {\n            AutoTransition transition = new AutoTransition();\n            transition.setDuration(BUTTON_ANIM_TIME_MS);\n            TransitionManager.beginDelayedTransition(parent, transition);\n        }\n"}
{"magic_number_smell": "        final AnimatorSet animatorSet = buildAnimatorSet(mLayoutView,\n                mLayoutView.getHeight() /* startY */, 0.0f /* endY */,\n                0.0f /* startAlpha */, 1.0f /* endAlpha */,\n                250);\n        final ValueAnimator animator = new ValueAnimator();\n        animator.setFloatValues(0.0f, 1.0f);\n        animatorSet.play(animator);", "refactored_code": "    private static final int DURATION_ANIMATE_PANEL_EXPAND_MS = 250;\n        final AnimatorSet animatorSet = buildAnimatorSet(mLayoutView,\n                mLayoutView.getHeight() /* startY */, 0.0f /* endY */,\n                0.0f /* startAlpha */, 1.0f /* endAlpha */,\n                DURATION_ANIMATE_PANEL_EXPAND_MS);\n        final ValueAnimator animator = new ValueAnimator();\n        animator.setFloatValues(0.0f, 1.0f);\n        animatorSet.play(animator);"}
{"magic_number_smell": "                }\n            }\n            pref.onPrepareRingtonePickerIntent(pref.getIntent());\n            mFragment.startActivityForResult(preference.getIntent(), 200);\n            return true;\n        }\n        return false;", "refactored_code": "    protected static final int CODE = 200;\n                }\n            }\n            pref.onPrepareRingtonePickerIntent(pref.getIntent());\n            mFragment.startActivityForResult(preference.getIntent(), CODE);\n            return true;\n        }\n        return false;"}
{"magic_number_smell": "                dismissed = mNm.getHistoricalNotificationsWithAttribution(\n                        NotificationHistoryActivity.this.getPackageName(),\n                        NotificationHistoryActivity.this.getAttributionTag(),\n                        50, false);\n            } catch (SecurityException | RemoteException e) {\n                Log.d(TAG, \"OnPaused called while trying to retrieve notifications\");\n            }", "refactored_code": "    private static final int MAX_RECENT_DISMISS_ITEM_COUNT = 50;\n                dismissed = mNm.getHistoricalNotificationsWithAttribution(\n                        NotificationHistoryActivity.this.getPackageName(),\n                        NotificationHistoryActivity.this.getAttributionTag(),\n                        MAX_RECENT_DISMISS_ITEM_COUNT, false);\n            } catch (SecurityException | RemoteException e) {\n                Log.d(TAG, \"OnPaused called while trying to retrieve notifications\");\n            }"}
{"magic_number_smell": "\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        menu.add(Menu.NONE, 1, Menu.NONE, R.string.zen_mode_delete_automatic_rules);\n        super.onCreateOptionsMenu(menu, inflater);\n    }\n", "refactored_code": "    private final int DELETE_RULES = 1;\n\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        menu.add(Menu.NONE, DELETE_RULES, Menu.NONE, R.string.zen_mode_delete_automatic_rules);\n        super.onCreateOptionsMenu(menu, inflater);\n    }\n"}
{"magic_number_smell": "            return mPolicy.priorityCallSenders;\n        }\n\n        return -1;\n    }\n\n    protected int getPriorityMessageSenders() {", "refactored_code": "    protected static final int SOURCE_NONE = -1;\n            return mPolicy.priorityCallSenders;\n        }\n\n        return SOURCE_NONE;\n    }\n\n    protected int getPriorityMessageSenders() {"}
{"magic_number_smell": "            return getString(indefinite);\n        }\n\n        long time = System.currentTimeMillis() + minutes * 60 * 1000;\n        String skeleton = DateFormat.is24HourFormat(this, UserHandle.myUserId()) ? \"Hm\" : \"hma\";\n        String pattern = DateFormat.getBestDateTimePattern(Locale.getDefault(), skeleton);\n        CharSequence formattedTime = DateFormat.format(pattern, time);", "refactored_code": "    private static final int MINUTES_MS = 60 * 1000;\n            return getString(indefinite);\n        }\n\n        long time = System.currentTimeMillis() + minutes * MINUTES_MS;\n        String skeleton = DateFormat.is24HourFormat(this, UserHandle.myUserId()) ? \"Hm\" : \"hma\";\n        String pattern = DateFormat.getBestDateTimePattern(Locale.getDefault(), skeleton);\n        CharSequence formattedTime = DateFormat.format(pattern, time);"}
{"magic_number_smell": "        final AnimatorSet animatorSet = buildAnimatorSet(mLayoutView,\n                panelContent.getHeight() /* startY */, 0.0f /* endY */,\n                0.0f /* startAlpha */, 1.0f /* endAlpha */,\n                250);\n        final ValueAnimator animator = new ValueAnimator();\n        animator.setFloatValues(0.0f, 1.0f);\n        animatorSet.play(animator);", "refactored_code": "    private static final int DURATION_ANIMATE_PANEL_EXPAND_MS = 250;\n        final AnimatorSet animatorSet = buildAnimatorSet(mLayoutView,\n                panelContent.getHeight() /* startY */, 0.0f /* endY */,\n                0.0f /* startAlpha */, 1.0f /* endAlpha */,\n                DURATION_ANIMATE_PANEL_EXPAND_MS);\n        final ValueAnimator animator = new ValueAnimator();\n        animator.setFloatValues(0.0f, 1.0f);\n        animatorSet.play(animator);"}
{"magic_number_smell": "                return;\n            }\n\n            final LinearLayout llRow = sliceView.findViewById(androidx.slice.view.R.id.row_view);\n            if (llRow != null) {\n                // Just set the label for the row. if is already laid out, there is no need for\n                // listening to future changes.", "refactored_code": "        private static final int ROW_VIEW_ID = androidx.slice.view.R.id.row_view;\n                return;\n            }\n\n            final LinearLayout llRow = sliceView.findViewById(ROW_VIEW_ID);\n            if (llRow != null) {\n                // Just set the label for the row. if is already laid out, there is no need for\n                // listening to future changes."}
{"magic_number_smell": "                                        : R.string.lockpassword_pin_too_short);\n                        if (LockPatternUtils.isAutoPinConfirmFeatureAvailable()\n                                && !mIsAlphaMode\n                                && error.requirement < 6) {\n                            Map<String, Object> arguments = new HashMap<>();\n                            arguments.put(\"count\", error.requirement);\n                            arguments.put(\"minAutoConfirmLen\", 6);", "refactored_code": "        private static final int MIN_AUTO_PIN_REQUIREMENT_LENGTH = 6;\n                                        : R.string.lockpassword_pin_too_short);\n                        if (LockPatternUtils.isAutoPinConfirmFeatureAvailable()\n                                && !mIsAlphaMode\n                                && error.requirement < MIN_AUTO_PIN_REQUIREMENT_LENGTH) {\n                            Map<String, Object> arguments = new HashMap<>();\n                            arguments.put(\"count\", error.requirement);\n                            arguments.put(\"minAutoConfirmLen\", MIN_AUTO_PIN_REQUIREMENT_LENGTH);"}
{"magic_number_smell": "            switch (requestCode) {\n                case CONFIRM_EXISTING_REQUEST:\n                    if (resultCode != Activity.RESULT_OK) {\n                        getActivity().setResult(RESULT_FIRST_USER);\n                        getActivity().finish();\n                    } else {\n                        mCurrentCredential = data.getParcelableExtra(", "refactored_code": "    public static final int RESULT_FINISHED = RESULT_FIRST_USER;\n            switch (requestCode) {\n                case CONFIRM_EXISTING_REQUEST:\n                    if (resultCode != Activity.RESULT_OK) {\n                        getActivity().setResult(RESULT_FINISHED);\n                        getActivity().finish();\n                    } else {\n                        mCurrentCredential = data.getParcelableExtra("}
{"magic_number_smell": "        final UserInfo userToBeWiped = mUserManager.getUserInfo(\n                mDevicePolicyManager.getProfileWithMinimumFailedPasswordsForWipe(mEffectiveUserId));\n        if (userToBeWiped == null || userToBeWiped.isPrimary()) {\n            return 1;\n        } else if (userToBeWiped.isManagedProfile()) {\n            return USER_TYPE_MANAGED_PROFILE;\n        } else {", "refactored_code": "    protected static final int USER_TYPE_PRIMARY = 1;\n        final UserInfo userToBeWiped = mUserManager.getUserInfo(\n                mDevicePolicyManager.getProfileWithMinimumFailedPasswordsForWipe(mEffectiveUserId));\n        if (userToBeWiped == null || userToBeWiped.isPrimary()) {\n            return USER_TYPE_PRIMARY;\n        } else if (userToBeWiped.isManagedProfile()) {\n            return USER_TYPE_MANAGED_PROFILE;\n        } else {"}
{"magic_number_smell": "        Activity activity = getActivity();\n        switch (button) {\n            case DialogInterface.BUTTON_POSITIVE:\n                activity.setResult(Activity.RESULT_FIRST_USER + 10);\n                activity.finish();\n                break;\n            case DialogInterface.BUTTON_NEGATIVE:", "refactored_code": "    public static final int RESULT_SKIP = Activity.RESULT_FIRST_USER + 10;\n        Activity activity = getActivity();\n        switch (button) {\n            case DialogInterface.BUTTON_POSITIVE:\n                activity.setResult(RESULT_SKIP);\n                activity.finish();\n                break;\n            case DialogInterface.BUTTON_NEGATIVE:"}
{"magic_number_smell": "        }\n\n        if (!printJob.getInfo().isCancelling()) {\n            MenuItem cancel = menu.add(0, 1, Menu.NONE,\n                    getString(R.string.print_cancel));\n            cancel.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);\n        }", "refactored_code": "    private static final int MENU_ITEM_ID_CANCEL = 1;\n        }\n\n        if (!printJob.getInfo().isCancelling()) {\n            MenuItem cancel = menu.add(0, MENU_ITEM_ID_CANCEL, Menu.NONE,\n                    getString(R.string.print_cancel));\n            cancel.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);\n        }"}
{"magic_number_smell": "        private CharSequence mLastSearchString;\n\n        public void enable() {\n            getLoaderManager().initLoader(1, null, this);\n        }\n\n        public void disable() {", "refactored_code": "    private static final int LOADER_ID_PRINTERS_LOADER = 1;\n        private CharSequence mLastSearchString;\n\n        public void enable() {\n            getLoaderManager().initLoader(LOADER_ID_PRINTERS_LOADER, null, this);\n        }\n\n        public void disable() {"}
{"magic_number_smell": "        getPreferenceScreen().removePreference(mActivePrintJobsCategory);\n\n        mPrintJobsController = new PrintJobsController();\n        getLoaderManager().initLoader(1, null, mPrintJobsController);\n\n        mPrintServicesController = new PrintServicesController();\n        getLoaderManager().initLoader(LOADER_ID_PRINT_SERVICES, null, mPrintServicesController);", "refactored_code": "    private static final int LOADER_ID_PRINT_JOBS_LOADER = 1;\n        getPreferenceScreen().removePreference(mActivePrintJobsCategory);\n\n        mPrintJobsController = new PrintJobsController();\n        getLoaderManager().initLoader(LOADER_ID_PRINT_JOBS_LOADER, null, mPrintJobsController);\n\n        mPrintServicesController = new PrintServicesController();\n        getLoaderManager().initLoader(LOADER_ID_PRINT_SERVICES, null, mPrintServicesController);"}
{"magic_number_smell": "                    if (getActivity() != null) {\n                        if (++mScreenTitleIndex < HEADER_IMAGE_PAIRS.size()) {\n                            startFadeOutAnimation();\n                            mHandler.postDelayed(mUpdateScreenResources, 5000);\n                        } else if (PrivateSpaceMaintainer.getInstance(getActivity())\n                                .doesPrivateSpaceExist()) {\n                            mMetricsFeatureProvider.action(", "refactored_code": "    private static final int DELAY_BETWEEN_SCREENS = 5000; // 5 seconds in millis\n                    if (getActivity() != null) {\n                        if (++mScreenTitleIndex < HEADER_IMAGE_PAIRS.size()) {\n                            startFadeOutAnimation();\n                            mHandler.postDelayed(mUpdateScreenResources, DELAY_BETWEEN_SCREENS);\n                        } else if (PrivateSpaceMaintainer.getInstance(getActivity())\n                                .doesPrivateSpaceExist()) {\n                            mMetricsFeatureProvider.action("}
{"magic_number_smell": "        return Settings.Secure.getInt(\n                mContext.getContentResolver(),\n                HIDE_PRIVATESPACE_ENTRY_POINT,\n                0);\n    }\n\n    /**", "refactored_code": "    public static final int HIDE_PRIVATE_SPACE_ENTRY_POINT_DISABLED_VAL = 0;\n        return Settings.Secure.getInt(\n                mContext.getContentResolver(),\n                HIDE_PRIVATESPACE_ENTRY_POINT,\n                HIDE_PRIVATE_SPACE_ENTRY_POINT_DISABLED_VAL);\n    }\n\n    /**"}
{"magic_number_smell": "\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {\n        if (requestCode == 1 && resultCode == RESULT_OK) {\n            /* Start new activity in private profile to add an account to private profile */\n            UserHandle userHandle =\n                    PrivateSpaceMaintainer.getInstance(this).getPrivateProfileHandle();", "refactored_code": "    public static final int SET_LOCK_ACTION = 1;\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {\n        if (requestCode == SET_LOCK_ACTION && resultCode == RESULT_OK) {\n            /* Start new activity in private profile to add an account to private profile */\n            UserHandle userHandle =\n                    PrivateSpaceMaintainer.getInstance(this).getPrivateProfileHandle();"}
{"magic_number_smell": "                                    combinedBiometricStatusUtils.getSettingsClassName(),\n                                    disablingAdmin,\n                                    Bundle.EMPTY),\n                            10),\n                    disablingAdmin == null /* enabled */,\n                    combinedBiometricStatusUtils.hasEnrolled(),\n                    safetyEvent);", "refactored_code": "    private static final int REQUEST_CODE_COMBINED_BIOMETRIC_SETTING = 10;\n                                    combinedBiometricStatusUtils.getSettingsClassName(),\n                                    disablingAdmin,\n                                    Bundle.EMPTY),\n                            REQUEST_CODE_COMBINED_BIOMETRIC_SETTING),\n                    disablingAdmin == null /* enabled */,\n                    combinedBiometricStatusUtils.hasEnrolled(),\n                    safetyEvent);"}
{"magic_number_smell": "                        context,\n                        screenLockPreferenceDetailsUtils.getLaunchChooseLockGenericFragmentIntent(\n                                SettingsEnums.SAFETY_CENTER),\n                        1);\n        final IconAction gearMenuIconAction =\n                createGearMenuIconAction(context, screenLockPreferenceDetailsUtils);\n        final boolean lockScreenAllowedByAdmin =", "refactored_code": "    private static final int REQUEST_CODE_SCREEN_LOCK = 1;\n                        context,\n                        screenLockPreferenceDetailsUtils.getLaunchChooseLockGenericFragmentIntent(\n                                SettingsEnums.SAFETY_CENTER),\n                        REQUEST_CODE_SCREEN_LOCK);\n        final IconAction gearMenuIconAction =\n                createGearMenuIconAction(context, screenLockPreferenceDetailsUtils);\n        final boolean lockScreenAllowedByAdmin ="}
{"magic_number_smell": "            return;\n        }\n        // menu contains search item, skip it\n        if (menu.findItem(Menu.FIRST + 10) != null) {\n            return;\n        }\n        final MenuItem searchItem = menu.add(Menu.NONE, Menu.FIRST + 10, 0 /* order */,", "refactored_code": "    public static final int MENU_SEARCH = Menu.FIRST + 10;\n            return;\n        }\n        // menu contains search item, skip it\n        if (menu.findItem(MENU_SEARCH) != null) {\n            return;\n        }\n        final MenuItem searchItem = menu.add(Menu.NONE, MENU_SEARCH, 0 /* order */,"}
{"magic_number_smell": "                .getSecurityFeatureProvider()\n                .getLockPatternUtils(context);\n        mHost = host;\n        mProfileChallengeUserId = Utils.getManagedProfileId(mUm, UserHandle.myUserId());\n        mMetricsFeatureProvider = FeatureFactory.getFeatureFactory().getMetricsFeatureProvider();\n        mScreenLockPreferenceDetailUtils = new ScreenLockPreferenceDetailsUtils(context);\n    }", "refactored_code": "    protected final int mUserId = UserHandle.myUserId();\n                .getSecurityFeatureProvider()\n                .getLockPatternUtils(context);\n        mHost = host;\n        mProfileChallengeUserId = Utils.getManagedProfileId(mUm, mUserId);\n        mMetricsFeatureProvider = FeatureFactory.getFeatureFactory().getMetricsFeatureProvider();\n        mScreenLockPreferenceDetailUtils = new ScreenLockPreferenceDetailsUtils(context);\n    }"}
{"magic_number_smell": "    @Override\n    public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int viewType) {\n        View view;\n        if (viewType == 1) {\n            view = LayoutInflater.from(viewGroup.getContext())\n                    .inflate(R.layout.request_manage_credentials_header, viewGroup, false);\n            view.setEnabled(false);", "refactored_code": "    private static final int HEADER_VIEW = 1;\n    @Override\n    public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int viewType) {\n        View view;\n        if (viewType == HEADER_VIEW) {\n            view = LayoutInflater.from(viewGroup.getContext())\n                    .inflate(R.layout.request_manage_credentials_header, viewGroup, false);\n            view.setEnabled(false);"}
{"magic_number_smell": "        mLockPatternUtils = FeatureFactory.getFeatureFactory()\n                .getSecurityFeatureProvider()\n                .getLockPatternUtils(context);\n        mProfileUserId = Utils.getManagedProfileId(mUm, UserHandle.myUserId());\n        mCurrentDevicePassword = LockscreenCredential.createNone();\n        mCurrentProfilePassword = LockscreenCredential.createNone();\n        this.mPreferenceKey = key;", "refactored_code": "    private static final int MY_USER_ID = UserHandle.myUserId();\n        mLockPatternUtils = FeatureFactory.getFeatureFactory()\n                .getSecurityFeatureProvider()\n                .getLockPatternUtils(context);\n        mProfileUserId = Utils.getManagedProfileId(mUm, MY_USER_ID);\n        mCurrentDevicePassword = LockscreenCredential.createNone();\n        mCurrentProfilePassword = LockscreenCredential.createNone();\n        this.mPreferenceKey = key;"}
{"magic_number_smell": "            mOwnerInfoPref.setDisabledByAdmin(admin);\n        } else {\n            mOwnerInfoPref.setDisabledByAdmin(null);\n            mOwnerInfoPref.setEnabled(!mLockPatternUtils.isLockScreenDisabled(UserHandle.myUserId()));\n        }\n    }\n", "refactored_code": "    private static final int MY_USER_ID = UserHandle.myUserId();\n            mOwnerInfoPref.setDisabledByAdmin(admin);\n        } else {\n            mOwnerInfoPref.setDisabledByAdmin(null);\n            mOwnerInfoPref.setEnabled(!mLockPatternUtils.isLockScreenDisabled(MY_USER_ID));\n        }\n    }\n"}
{"magic_number_smell": "        mLockPatternUtils = FeatureFactory.getFeatureFactory()\n                .getSecurityFeatureProvider()\n                .getLockPatternUtils(context);\n        mProfileChallengeUserId = Utils.getManagedProfileId(mUm, UserHandle.myUserId());\n    }\n\n    /**", "refactored_code": "    private final int mUserId = UserHandle.myUserId();\n        mLockPatternUtils = FeatureFactory.getFeatureFactory()\n                .getSecurityFeatureProvider()\n                .getLockPatternUtils(context);\n        mProfileChallengeUserId = Utils.getManagedProfileId(mUm, mUserId);\n    }\n\n    /**"}
{"magic_number_smell": "                chooseLockIntent.putExtra(\n                        ChooseLockGeneric.ChooseLockGenericFragment.HIDE_INSECURE_OPTIONS,\n                        true);\n                startActivityForResult(chooseLockIntent, 43);\n                return false;\n            }\n        }  else {", "refactored_code": "    private static final int CHANGE_LOCK_METHOD_REQUEST = 43;\n                chooseLockIntent.putExtra(\n                        ChooseLockGeneric.ChooseLockGenericFragment.HIDE_INSECURE_OPTIONS,\n                        true);\n                startActivityForResult(chooseLockIntent, CHANGE_LOCK_METHOD_REQUEST);\n                return false;\n            }\n        }  else {"}
{"magic_number_smell": "        mLockPatternUtils = FeatureFactory.getFeatureFactory()\n                .getSecurityFeatureProvider()\n                .getLockPatternUtils(context);\n        mProfileChallengeUserId = Utils.getManagedProfileId(mUm, UserHandle.myUserId());\n        if (lifecycle != null) {\n            lifecycle.addObserver(this);\n        }", "refactored_code": "    private final int mUserId = UserHandle.myUserId();\n        mLockPatternUtils = FeatureFactory.getFeatureFactory()\n                .getSecurityFeatureProvider()\n                .getLockPatternUtils(context);\n        mProfileChallengeUserId = Utils.getManagedProfileId(mUm, mUserId);\n        if (lifecycle != null) {\n            lifecycle.addObserver(this);\n        }"}
{"magic_number_smell": "\n        final List<AbstractPreferenceController> controllers = new ArrayList<>();\n        controllers.add(new PatternVisiblePreferenceController(\n                context, UserHandle.myUserId(), lockPatternUtils));\n        controllers.add(new PinPrivacyPreferenceController(\n                context, UserHandle.myUserId(), lockPatternUtils));\n        controllers.add(new PowerButtonInstantLockPreferenceController(", "refactored_code": "    private static final int MY_USER_ID = UserHandle.myUserId();\n\n        final List<AbstractPreferenceController> controllers = new ArrayList<>();\n        controllers.add(new PatternVisiblePreferenceController(\n                context, MY_USER_ID, lockPatternUtils));\n        controllers.add(new PinPrivacyPreferenceController(\n                context, MY_USER_ID, lockPatternUtils));\n        controllers.add(new PowerButtonInstantLockPreferenceController("}
{"magic_number_smell": "    @Override\n    public void updateState(Preference preference) {\n        final int numberOfTrustAgent = getTrustAgentCount();\n        if (!mLockPatternUtils.isSecure(UserHandle.myUserId())) {\n            preference.setEnabled(false);\n            preference.setSummary(R.string.disabled_because_no_backup_security);\n        } else if (numberOfTrustAgent > 0) {", "refactored_code": "    private static final int MY_USER_ID = UserHandle.myUserId();\n    @Override\n    public void updateState(Preference preference) {\n        final int numberOfTrustAgent = getTrustAgentCount();\n        if (!mLockPatternUtils.isSecure(MY_USER_ID)) {\n            preference.setEnabled(false);\n            preference.setSummary(R.string.disabled_because_no_backup_security);\n        } else if (numberOfTrustAgent > 0) {"}
{"magic_number_smell": "        mTrustAgentsKeyList.clear();\n\n        // Then add new ones.\n        final boolean hasSecurity = mLockPatternUtils.isSecure(UserHandle.myUserId());\n        for (int i = 0, size = agents.size(); i < size; i++) {\n            final RestrictedPreference trustAgentPreference =\n                    new RestrictedPreference(mSecurityCategory.getContext());", "refactored_code": "    private static final int MY_USER_ID = UserHandle.myUserId();\n        mTrustAgentsKeyList.clear();\n\n        // Then add new ones.\n        final boolean hasSecurity = mLockPatternUtils.isSecure(MY_USER_ID);\n        for (int i = 0, size = agents.size(); i < size; i++) {\n            final RestrictedPreference trustAgentPreference =\n                    new RestrictedPreference(mSecurityCategory.getContext());"}
{"magic_number_smell": "        Item subItem = (Item) item;\n        subItem.setSummary(getString(R.string.choose_sim_activating));\n        mSelectedItemIndex = subItem.getId();\n        if (mSelectedItemIndex == -1) {\n            Log.i(TAG, \"Ready to switch to pSIM slot.\");\n            mSwitchToRemovableSlotSidecar.run(UiccSlotUtil.INVALID_PHYSICAL_SLOT_ID, null);\n        } else {", "refactored_code": "    private static final int INDEX_PSIM = -1;\n        Item subItem = (Item) item;\n        subItem.setSummary(getString(R.string.choose_sim_activating));\n        mSelectedItemIndex = subItem.getId();\n        if (mSelectedItemIndex == INDEX_PSIM) {\n            Log.i(TAG, \"Ready to switch to pSIM slot.\");\n            mSwitchToRemovableSlotSidecar.run(UiccSlotUtil.INVALID_PHYSICAL_SLOT_ID, null);\n        } else {"}
{"magic_number_smell": "\n        TelephonyManager telephonyManager = getSystemService(TelephonyManager.class);\n        switch (tag) {\n            case 1:\n                if (telephonyManager.doesSwitchMultiSimConfigTriggerReboot()) {\n                    Log.i(TAG, \"Device does not support reboot free DSDS.\");\n                    showRebootConfirmDialog();", "refactored_code": "    private static final int DIALOG_TAG_ENABLE_DSDS_CONFIRMATION = 1;\n\n        TelephonyManager telephonyManager = getSystemService(TelephonyManager.class);\n        switch (tag) {\n            case DIALOG_TAG_ENABLE_DSDS_CONFIRMATION:\n                if (telephonyManager.doesSwitchMultiSimConfigTriggerReboot()) {\n                    Log.i(TAG, \"Device does not support reboot free DSDS.\");\n                    showRebootConfirmDialog();"}
{"magic_number_smell": "                        .setContentIntent(contentIntent)\n                        .setSmallIcon(R.drawable.ic_sim_alert)\n                        .setAutoCancel(true);\n        mNotificationManager.notify(1, builder.build());\n    }\n\n    /** Sends a push notification for switching to the removable slot. */", "refactored_code": "    public static final int SIM_ACTIVATION_NOTIFICATION_ID = 1;\n                        .setContentIntent(contentIntent)\n                        .setSmallIcon(R.drawable.ic_sim_alert)\n                        .setAutoCancel(true);\n        mNotificationManager.notify(SIM_ACTIVATION_NOTIFICATION_ID, builder.build());\n    }\n\n    /** Sends a push notification for switching to the removable slot. */"}
{"magic_number_smell": "    }\n\n    private void showOrUpdateDialog() {\n        final int dialogType = getIntent().getIntExtra(DIALOG_TYPE_KEY, -1);\n\n        if (dialogType == PICK_DISMISS) {\n            finishAndRemoveTask();", "refactored_code": "    public static final int INVALID_PICK = -1;\n    }\n\n    private void showOrUpdateDialog() {\n        final int dialogType = getIntent().getIntExtra(DIALOG_TYPE_KEY, INVALID_PICK);\n\n        if (dialogType == PICK_DISMISS) {\n            finishAndRemoveTask();"}
{"magic_number_smell": "        NotificationManager notificationManager =\n                (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);\n        notificationManager.createNotificationChannel(notificationChannel);\n        notificationManager.notify(1, builder.build());\n    }\n\n    public static void cancelSimSelectNotification(Context context) {", "refactored_code": "    public static final int SIM_SELECT_NOTIFICATION_ID = 1;\n        NotificationManager notificationManager =\n                (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);\n        notificationManager.createNotificationChannel(notificationChannel);\n        notificationManager.notify(SIM_SELECT_NOTIFICATION_ID, builder.build());\n    }\n\n    public static void cancelSimSelectNotification(Context context) {"}
{"magic_number_smell": "            ConfirmDialogFragment.show(\n                    this,\n                    ConfirmDialogFragment.OnConfirmListener.class,\n                    1,\n                    getString(R.string.switch_sim_dialog_title, mSubToEnabled.getDisplayName()),\n                    getString(R.string.switch_sim_dialog_text, mSubToEnabled.getDisplayName()),\n                    getString(R.string.okay),", "refactored_code": "    private static final int TAG_CONFIRM = 1;\n            ConfirmDialogFragment.show(\n                    this,\n                    ConfirmDialogFragment.OnConfirmListener.class,\n                    TAG_CONFIRM,\n                    getString(R.string.switch_sim_dialog_title, mSubToEnabled.getDisplayName()),\n                    getString(R.string.switch_sim_dialog_text, mSubToEnabled.getDisplayName()),\n                    getString(R.string.okay),"}
{"magic_number_smell": "\n        boolean embeddedSimExist = getGroupedEmbeddedSubscriptions().size() != 0;\n        int removableSlotAction = getSuwRemovableSlotAction(mContext);\n        setSuwRemovableSlotAction(mContext, 0);\n\n        if (embeddedSimExist\n                && removableSlotInfo.getCardStateInfo() == UiccSlotInfo.CARD_STATE_INFO_PRESENT) {", "refactored_code": "    private static final int LAST_USER_ACTION_IN_SUW_NONE = 0;\n\n        boolean embeddedSimExist = getGroupedEmbeddedSubscriptions().size() != 0;\n        int removableSlotAction = getSuwRemovableSlotAction(mContext);\n        setSuwRemovableSlotAction(mContext, LAST_USER_ACTION_IN_SUW_NONE);\n\n        if (embeddedSimExist\n                && removableSlotInfo.getCardStateInfo() == UiccSlotInfo.CARD_STATE_INFO_PRESENT) {"}
{"magic_number_smell": "            client.set(mResult);\n        }\n\n        return client.get(20, TimeUnit.SECONDS);\n    }\n\n    class FlowController {", "refactored_code": "    private static final int TIMEOUT = 20;\n            client.set(mResult);\n        }\n\n        return client.get(TIMEOUT, TimeUnit.SECONDS);\n    }\n\n    class FlowController {"}
{"magic_number_smell": "            if (lastUpdateTime == 0L) {\n                // Postpone the first update triggering by onSlicePinned() to avoid being too close\n                // to the first Slice bind.\n                sendMessageDelayed(message, 300L);\n            } else if (SystemClock.uptimeMillis() - lastUpdateTime\n                    > 300L) {\n                sendMessage(message);", "refactored_code": "    private static final long SLICE_UPDATE_THROTTLE_INTERVAL = 300L;\n            if (lastUpdateTime == 0L) {\n                // Postpone the first update triggering by onSlicePinned() to avoid being too close\n                // to the first Slice bind.\n                sendMessageDelayed(message, SLICE_UPDATE_THROTTLE_INTERVAL);\n            } else if (SystemClock.uptimeMillis() - lastUpdateTime\n                    > SLICE_UPDATE_THROTTLE_INTERVAL) {\n                sendMessage(message);"}
{"magic_number_smell": "    }\n\n    private SlicesDatabaseHelper(Context context) {\n        super(context, DATABASE_NAME, null /* CursorFactor */, 10);\n        mContext = context;\n    }\n", "refactored_code": "    private static final int DATABASE_VERSION = 10;\n    }\n\n    private SlicesDatabaseHelper(Context context) {\n        super(context, DATABASE_NAME, null /* CursorFactor */, DATABASE_VERSION);\n        mContext = context;\n    }\n"}
{"magic_number_smell": "        } else {\n            // Switch to BT device which address is hardware address\n            final int connectedDeviceIndex = getConnectedDeviceIndex(address);\n            if (connectedDeviceIndex == -1) {\n                return false;\n            }\n            final BluetoothDevice btDevice = mConnectedDevices.get(connectedDeviceIndex);", "refactored_code": "    private static final int INVALID_INDEX = -1;\n        } else {\n            // Switch to BT device which address is hardware address\n            final int connectedDeviceIndex = getConnectedDeviceIndex(address);\n            if (connectedDeviceIndex == INVALID_INDEX) {\n                return false;\n            }\n            final BluetoothDevice btDevice = mConnectedDevices.get(connectedDeviceIndex);"}
{"magic_number_smell": "\n        try {\n            if (DBG) Log.d(TAG, \"Getting sample text: \" + intent.toUri(0));\n            startActivityForResult(intent, 1983);\n        } catch (ActivityNotFoundException ex) {\n            Log.e(TAG, \"Failed to get sample text, no activity found for \" + intent + \")\");\n        }", "refactored_code": "    private static final int GET_SAMPLE_TEXT = 1983;\n\n        try {\n            if (DBG) Log.d(TAG, \"Getting sample text: \" + intent.toUri(0));\n            startActivityForResult(intent, GET_SAMPLE_TEXT);\n        } catch (ActivityNotFoundException ex) {\n            Log.e(TAG, \"Failed to get sample text, no activity found for \" + intent + \")\");\n        }"}
{"magic_number_smell": "                p.setImmutable(true);\n                p.setChecked(mHelper.isPackageSelected(packageName));\n            }\n            p.setOrder(100 * (mAppList.getPreferenceCount() + 2));\n            mHelper.setPackageSelected(packageName, p.isChecked());\n            mAppList.addPreference(p);\n        }", "refactored_code": "    private static final int MAX_APP_RESTRICTIONS = 100;\n                p.setImmutable(true);\n                p.setChecked(mHelper.isPackageSelected(packageName));\n            }\n            p.setOrder(MAX_APP_RESTRICTIONS * (mAppList.getPreferenceCount() + 2));\n            mHelper.setPackageSelected(packageName, p.isChecked());\n            mAppList.addPreference(p);\n        }"}
{"magic_number_smell": "\n    private boolean isChecked() {\n        return Settings.Global.getInt(mContext.getContentResolver(),\n                Settings.Global.REMOVE_GUEST_ON_EXIT, 1) != 0;\n    }\n\n    private static boolean setChecked(Context context, boolean isChecked) {", "refactored_code": "    private static final int REMOVE_GUEST_ON_EXIT_DEFAULT = 1;\n\n    private boolean isChecked() {\n        return Settings.Global.getInt(mContext.getContentResolver(),\n                Settings.Global.REMOVE_GUEST_ON_EXIT, REMOVE_GUEST_ON_EXIT_DEFAULT) != 0;\n    }\n\n    private static boolean setChecked(Context context, boolean isChecked) {"}
{"magic_number_smell": "    protected String getDefaultKey() {\n        final String defaultKey = Settings.Secure.getStringForUser(\n                getContext().getContentResolver(), TIMEOUT_TO_DOCK_USER, UserHandle.myUserId());\n        return defaultKey != null ? defaultKey : mValues[1];\n    }\n\n    @Override", "refactored_code": "    public static final int DEFAULT_TIMEOUT_SETTING_VALUE_INDEX = 1;\n    protected String getDefaultKey() {\n        final String defaultKey = Settings.Secure.getStringForUser(\n                getContext().getContentResolver(), TIMEOUT_TO_DOCK_USER, UserHandle.myUserId());\n        return defaultKey != null ? defaultKey : mValues[DEFAULT_TIMEOUT_SETTING_VALUE_INDEX];\n    }\n\n    @Override"}
{"magic_number_smell": "                if (mUserInfo.isGuest()) {\n                    showDialog(DIALOG_CONFIRM_RESET_GUEST);\n                } else {\n                    showDialog(1);\n                }\n                return true;\n            }", "refactored_code": "    private static final int DIALOG_CONFIRM_REMOVE = 1;\n                if (mUserInfo.isGuest()) {\n                    showDialog(DIALOG_CONFIRM_RESET_GUEST);\n                } else {\n                    showDialog(DIALOG_CONFIRM_REMOVE);\n                }\n                return true;\n            }"}
{"magic_number_smell": "    private void dimIcon(boolean dimmed) {\n        Drawable icon = getIcon();\n        if (icon != null) {\n            icon.mutate().setAlpha(dimmed ? ALPHA_DISABLED : 255);\n            setIcon(icon);\n        }\n    }", "refactored_code": "    private static final int ALPHA_ENABLED = 255;\n    private void dimIcon(boolean dimmed) {\n        Drawable icon = getIcon();\n        if (icon != null) {\n            icon.mutate().setAlpha(dimmed ? ALPHA_DISABLED : ALPHA_ENABLED);\n            setIcon(icon);\n        }\n    }"}
{"magic_number_smell": "        int pos = 0;\n        if (!isCurrentUserAdmin() && canSwitchUserNow() && !isCurrentUserGuest()) {\n            String nickname = mUserManager.getUserName();\n            MenuItem removeThisUser = menu.add(0, Menu.FIRST, pos++,\n                    getResources().getString(R.string.user_remove_user_menu, nickname));\n            removeThisUser.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);\n", "refactored_code": "    private static final int MENU_REMOVE_USER = Menu.FIRST;\n        int pos = 0;\n        if (!isCurrentUserAdmin() && canSwitchUserNow() && !isCurrentUserGuest()) {\n            String nickname = mUserManager.getUserName();\n            MenuItem removeThisUser = menu.add(0, MENU_REMOVE_USER, pos++,\n                    getResources().getString(R.string.user_remove_user_menu, nickname));\n            removeThisUser.setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);\n"}
{"magic_number_smell": "\n    public static boolean isEnabledForUser(@NonNull Context context) {\n        boolean enabled = Settings.Secure.getIntForUser(context.getContentResolver(),\n                Settings.Secure.CONTENT_CAPTURE_ENABLED, 1, UserHandle.myUserId()) == 1;\n        return enabled;\n    }\n", "refactored_code": "    private static final int MY_USER_ID = UserHandle.myUserId();\n\n    public static boolean isEnabledForUser(@NonNull Context context) {\n        boolean enabled = Settings.Secure.getIntForUser(context.getContentResolver(),\n                Settings.Secure.CONTENT_CAPTURE_ENABLED, 1, MY_USER_ID) == 1;\n        return enabled;\n    }\n"}
{"magic_number_smell": " */\npublic final class FileSizeFormatter {\n    public static final long 1000 = 1000;\n    public static final long MEGABYTE_IN_BYTES = 1000 * 1000;\n    public static final long GIGABYTE_IN_BYTES = MEGABYTE_IN_BYTES * 1000;\n\n    private static class RoundedBytesResult {", "refactored_code": "    public static final long KILOBYTE_IN_BYTES = 1000;\n */\npublic final class FileSizeFormatter {\n    public static final long KILOBYTE_IN_BYTES = 1000;\n    public static final long MEGABYTE_IN_BYTES = KILOBYTE_IN_BYTES * 1000;\n    public static final long GIGABYTE_IN_BYTES = MEGABYTE_IN_BYTES * 1000;\n\n    private static class RoundedBytesResult {"}
{"magic_number_smell": "            return false;\n        }\n        // Only clear legacy lockdown vpn in system user.\n        if (UserHandle.myUserId() == UserHandle.USER_SYSTEM) {\n            VpnUtils.clearLockdownVpn(getContext());\n        }\n        final boolean success = setAlwaysOnVpn(isEnabled, isLockdown);", "refactored_code": "    private final int mUserId = UserHandle.myUserId();\n            return false;\n        }\n        // Only clear legacy lockdown vpn in system user.\n        if (mUserId == UserHandle.USER_SYSTEM) {\n            VpnUtils.clearLockdownVpn(getContext());\n        }\n        final boolean success = setAlwaysOnVpn(isEnabled, isLockdown);"}
{"magic_number_smell": "        mUpdaterThread = new HandlerThread(\"Refresh VPN list in background\");\n        mUpdaterThread.start();\n        mUpdater = new Handler(mUpdaterThread.getLooper(), this);\n        mUpdater.sendEmptyMessage(0);\n    }\n\n    @Override", "refactored_code": "    private static final int RESCAN_MESSAGE = 0;\n        mUpdaterThread = new HandlerThread(\"Refresh VPN list in background\");\n        mUpdaterThread.start();\n        mUpdater = new Handler(mUpdaterThread.getLooper(), this);\n        mUpdater.sendEmptyMessage(RESCAN_MESSAGE);\n    }\n\n    @Override"}
{"magic_number_smell": "        if (getResources().getBoolean(R.bool.config_show_wifi_display_enable_menu)\n                && mWifiDisplayStatus != null && mWifiDisplayStatus.getFeatureState()\n                        != WifiDisplayStatus.FEATURE_STATE_UNAVAILABLE) {\n            MenuItem item = menu.add(Menu.NONE, Menu.FIRST, 0,\n                    R.string.wifi_display_enable_menu_item);\n            item.setCheckable(true);\n            item.setChecked(mWifiDisplayOnSetting);", "refactored_code": "    private static final int MENU_ID_ENABLE_WIFI_DISPLAY = Menu.FIRST;\n        if (getResources().getBoolean(R.bool.config_show_wifi_display_enable_menu)\n                && mWifiDisplayStatus != null && mWifiDisplayStatus.getFeatureState()\n                        != WifiDisplayStatus.FEATURE_STATE_UNAVAILABLE) {\n            MenuItem item = menu.add(Menu.NONE, MENU_ID_ENABLE_WIFI_DISPLAY, 0,\n                    R.string.wifi_display_enable_menu_item);\n            item.setCheckable(true);\n            item.setChecked(mWifiDisplayOnSetting);"}
{"magic_number_smell": "        }\n        final float viewAspectRatio = (float) width / height;\n        final float aspectRatioDiff = mAspectRatio - viewAspectRatio;\n        if (Math.abs(aspectRatioDiff) <= 0.01f) {\n            // Close enough, skip.\n            return;\n        }", "refactored_code": "    private static final float ASPECT_RATIO_CHANGE_THREASHOLD = 0.01f;\n        }\n        final float viewAspectRatio = (float) width / height;\n        final float aspectRatioDiff = mAspectRatio - viewAspectRatio;\n        if (Math.abs(aspectRatioDiff) <= ASPECT_RATIO_CHANGE_THREASHOLD) {\n            // Close enough, skip.\n            return;\n        }"}
{"magic_number_smell": "    }\n\n    private float getTouchDistanceFromTarget(MotionEvent eventInParent) {\n        if (mFollowAxis == 0) {\n            return Math.abs(eventInParent.getX() - (getX() + getTargetInset()));\n        } else {\n            return Math.abs(eventInParent.getY() - (getY() + getTargetInset()));", "refactored_code": "    public static final int HORIZONTAL = 0;\n    }\n\n    private float getTouchDistanceFromTarget(MotionEvent eventInParent) {\n        if (mFollowAxis == HORIZONTAL) {\n            return Math.abs(eventInParent.getX() - (getX() + getTargetInset()));\n        } else {\n            return Math.abs(eventInParent.getY() - (getY() + getTargetInset()));"}
{"magic_number_smell": "            parentRect.bottom = parentRect.top;\n            parentRect.left += sweepMargins.left;\n            parentRect.right += sweepMargins.right;\n            Gravity.apply(Gravity.TOP | Gravity.START, parentRect.width(), sweep.getMeasuredHeight(),\n                    parentRect, childRect);\n\n        } else {", "refactored_code": "    private static final int SWEEP_GRAVITY = Gravity.TOP | Gravity.START;\n            parentRect.bottom = parentRect.top;\n            parentRect.left += sweepMargins.left;\n            parentRect.right += sweepMargins.right;\n            Gravity.apply(SWEEP_GRAVITY, parentRect.width(), sweep.getMeasuredHeight(),\n                    parentRect, childRect);\n\n        } else {"}
{"magic_number_smell": "        final TypedArray typedArray = getContext().obtainStyledAttributes(\n                attrs, R.styleable.DotsPageIndicator, defStyle, 0);\n        dotDiameter = typedArray.getDimensionPixelSize(R.styleable.DotsPageIndicator_dotDiameter,\n                8 * scaledDensity);\n        dotRadius = dotDiameter / 2;\n        halfDotRadius = dotRadius / 2;\n        gap = typedArray.getDimensionPixelSize(R.styleable.DotsPageIndicator_dotGap,", "refactored_code": "    private static final int DEFAULT_DOT_SIZE = 8;                      // dp\n        final TypedArray typedArray = getContext().obtainStyledAttributes(\n                attrs, R.styleable.DotsPageIndicator, defStyle, 0);\n        dotDiameter = typedArray.getDimensionPixelSize(R.styleable.DotsPageIndicator_dotDiameter,\n                DEFAULT_DOT_SIZE * scaledDensity);\n        dotRadius = dotDiameter / 2;\n        halfDotRadius = dotRadius / 2;\n        gap = typedArray.getDimensionPixelSize(R.styleable.DotsPageIndicator_dotGap,"}
{"magic_number_smell": "        v.postDelayed(() -> {\n            mHighlightPosition = RecyclerView.NO_POSITION;\n            removeHighlightBackground(holder, true /* animate */);\n        }, 15000L);\n    }\n\n    private void addHighlightBackground(PreferenceViewHolder holder, boolean animate) {", "refactored_code": "    private static final long HIGHLIGHT_DURATION = 15000L;\n        v.postDelayed(() -> {\n            mHighlightPosition = RecyclerView.NO_POSITION;\n            removeHighlightBackground(holder, true /* animate */);\n        }, HIGHLIGHT_DURATION);\n    }\n\n    private void addHighlightBackground(PreferenceViewHolder holder, boolean animate) {"}
{"magic_number_smell": "\n    public void showLoadingViewDelayed() {\n        mFgHandler.postDelayed(\n                mShowLoadingContainerRunnable, 100L);\n    }\n\n    private void handleLoadingContainer(boolean showContent, boolean showEmpty, boolean animate) {", "refactored_code": "    private static final long DELAY_SHOW_LOADING_CONTAINER_THRESHOLD_MS = 100L;\n\n    public void showLoadingViewDelayed() {\n        mFgHandler.postDelayed(\n                mShowLoadingContainerRunnable, DELAY_SHOW_LOADING_CONTAINER_THRESHOLD_MS);\n    }\n\n    private void handleLoadingContainer(boolean showContent, boolean showEmpty, boolean animate) {"}
{"magic_number_smell": "\n    /**\n     * Measures the children when the orientation of this LinearLayout is set\n     * to {@link #0}.\n     *\n     * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.\n     * @param heightMeasureSpec Vertical space requirements as imposed by the parent.", "refactored_code": "    public static final int HORIZONTAL = 0;\n\n    /**\n     * Measures the children when the orientation of this LinearLayout is set\n     * to {@link #HORIZONTAL}.\n     *\n     * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.\n     * @param heightMeasureSpec Vertical space requirements as imposed by the parent."}
{"magic_number_smell": "    public MutableGearPreference(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        mContext = context;\n        mDisabledAlphaValue = (int) (ColorUtil.getDisabledAlpha(context) * 255);\n    }\n\n    @Override", "refactored_code": "    private static final int VALUE_ENABLED_ALPHA = 255;\n    public MutableGearPreference(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        mContext = context;\n        mDisabledAlphaValue = (int) (ColorUtil.getDisabledAlpha(context) * VALUE_ENABLED_ALPHA);\n    }\n\n    @Override"}
{"magic_number_smell": "    private boolean mTrackingTouch;\n\n    private boolean mContinuousUpdates;\n    private int mHapticFeedbackMode = 0;\n    private int mDefaultProgress = -1;\n\n    private SeekBar mSeekBar;", "refactored_code": "    public static final int HAPTIC_FEEDBACK_MODE_NONE = 0;\n    private boolean mTrackingTouch;\n\n    private boolean mContinuousUpdates;\n    private int mHapticFeedbackMode = HAPTIC_FEEDBACK_MODE_NONE;\n    private int mDefaultProgress = -1;\n\n    private SeekBar mSeekBar;"}
{"magic_number_smell": "            paths.put(points.keyAt(i), points.valueAt(i));\n        }\n        // Add a delimiting value immediately after the last point.\n        paths.put(points.keyAt(points.size() - 1) + 1, -1);\n        calculateLocalPaths(paths, localPaths);\n        postInvalidate();\n        BatteryUtils.logRuntime(LOG_TAG, \"addPathAndUpdate\", startTime);", "refactored_code": "    private static final int PATH_DELIM = -1;\n            paths.put(points.keyAt(i), points.valueAt(i));\n        }\n        // Add a delimiting value immediately after the last point.\n        paths.put(points.keyAt(points.size() - 1) + 1, PATH_DELIM);\n        calculateLocalPaths(paths, localPaths);\n        postInvalidate();\n        BatteryUtils.logRuntime(LOG_TAG, \"addPathAndUpdate\", startTime);"}
{"magic_number_smell": "            // Launch QR code scanner to join a network.\n            startActivityForResult(\n                    WifiDppUtils.getEnrolleeQrCodeScannerIntent(view.getContext(), ssid),\n                    0);\n        }\n    }\n", "refactored_code": "    private static final int REQUEST_CODE_WIFI_DPP_ENROLLEE_QR_CODE_SCANNER = 0;\n            // Launch QR code scanner to join a network.\n            startActivityForResult(\n                    WifiDppUtils.getEnrolleeQrCodeScannerIntent(view.getContext(), ssid),\n                    REQUEST_CODE_WIFI_DPP_ENROLLEE_QR_CODE_SCANNER);\n        }\n    }\n"}
{"magic_number_smell": "\n    public AppStateChangeWifiStateBridge(Context context, ApplicationsState appState, Callback\n            callback) {\n        super(context, appState, callback, AppOpsManager.OP_CHANGE_WIFI_STATE, PM_PERMISSIONS);\n    }\n\n    @Override", "refactored_code": "    private static final int APP_OPS_OP_CODE = AppOpsManager.OP_CHANGE_WIFI_STATE;\n\n    public AppStateChangeWifiStateBridge(Context context, ApplicationsState appState, Callback\n            callback) {\n        super(context, appState, callback, APP_OPS_OP_CODE, PM_PERMISSIONS);\n    }\n\n    @Override"}
{"magic_number_smell": "            neutral.setVisibility(View.GONE);\n        }\n\n        mSubmitBtn = rootView.findViewById(android.R.id.button1);\n        mCancelBtn = rootView.findViewById(CANCEL_BUTTON_ID);\n        mSubmitBtn.setOnClickListener(view -> handleSubmitAction());\n        mCancelBtn.setOnClickListener(view -> handleCancelAction());", "refactored_code": "    private static final int SUBMIT_BUTTON_ID = android.R.id.button1;\n            neutral.setVisibility(View.GONE);\n        }\n\n        mSubmitBtn = rootView.findViewById(SUBMIT_BUTTON_ID);\n        mCancelBtn = rootView.findViewById(CANCEL_BUTTON_ID);\n        mSubmitBtn.setOnClickListener(view -> handleSubmitAction());\n        mCancelBtn.setOnClickListener(view -> handleCancelAction());"}
{"magic_number_smell": "\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        if (mWifiWakeupPreferenceController != null && requestCode == 600) {\n            mWifiWakeupPreferenceController.onActivityResult(requestCode, resultCode);\n            return;\n        }", "refactored_code": "    public static final int WIFI_WAKEUP_REQUEST_CODE = 600;\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        if (mWifiWakeupPreferenceController != null && requestCode == WIFI_WAKEUP_REQUEST_CODE) {\n            mWifiWakeupPreferenceController.onActivityResult(requestCode, resultCode);\n            return;\n        }"}
{"magic_number_smell": "            wifiManager.registerNetworkRequestMatchCallback(new HandlerExecutor(mHandler), this);\n        }\n        // Sets time-out to stop scanning.\n        mHandler.sendEmptyMessageDelayed(0, DELAY_TIME_STOP_SCAN_MS);\n    }\n\n    @Override", "refactored_code": "    private static final int MESSAGE_STOP_SCAN_WIFI_LIST = 0;\n            wifiManager.registerNetworkRequestMatchCallback(new HandlerExecutor(mHandler), this);\n        }\n        // Sets time-out to stop scanning.\n        mHandler.sendEmptyMessageDelayed(MESSAGE_STOP_SCAN_WIFI_LIST, DELAY_TIME_STOP_SCAN_MS);\n    }\n\n    @Override"}
{"magic_number_smell": "        mFilteredWifiEntries.clear();\n        mFilteredWifiEntries.addAll(wifiEntries.stream()\n                .filter(entry -> isMatchedWifiEntry(entry, connectedSsid))\n                .limit(mShowLimitedItem ? 5 : Long.MAX_VALUE)\n                .toList());\n    }\n", "refactored_code": "    private static final int MAX_NUMBER_LIST_ITEM = 5;\n        mFilteredWifiEntries.clear();\n        mFilteredWifiEntries.addAll(wifiEntries.stream()\n                .filter(entry -> isMatchedWifiEntry(entry, connectedSsid))\n                .limit(mShowLimitedItem ? MAX_NUMBER_LIST_ITEM : Long.MAX_VALUE)\n                .toList());\n    }\n"}
{"magic_number_smell": "    }\n\n    private void scheduleToggleTimeout() {\n        getWindow().getDecorView().postDelayed(mTimeoutCommand, 10000);\n    }\n\n    private void unscheduleToggleTimeout() {", "refactored_code": "    private static final long TOGGLE_TIMEOUT_MILLIS = 10000; // 10 sec\n    }\n\n    private void scheduleToggleTimeout() {\n        getWindow().getDecorView().postDelayed(mTimeoutCommand, TOGGLE_TIMEOUT_MILLIS);\n    }\n\n    private void unscheduleToggleTimeout() {"}
{"magic_number_smell": "                                staticConfig.getIpAddress().getAddress().getHostAddress());\n                    }\n                } else {\n                    mIpSettingsSpinner.setSelection(0);\n                }\n\n                mSharedCheckBox.setEnabled(config.shared);", "refactored_code": "    private static final int DHCP = 0;\n                                staticConfig.getIpAddress().getAddress().getHostAddress());\n                    }\n                } else {\n                    mIpSettingsSpinner.setSelection(DHCP);\n                }\n\n                mSharedCheckBox.setEnabled(config.shared);"}
{"magic_number_smell": "                                staticConfig.getIpAddress().getAddress().getHostAddress());\n                    }\n                } else {\n                    mIpSettingsSpinner.setSelection(0);\n                }\n\n                mSharedCheckBox.setEnabled(config.shared);", "refactored_code": "    private static final int DHCP = 0;\n                                staticConfig.getIpAddress().getAddress().getHostAddress());\n                    }\n                } else {\n                    mIpSettingsSpinner.setSelection(DHCP);\n                }\n\n                mSharedCheckBox.setEnabled(config.shared);"}
{"magic_number_smell": "                        new Handler(Looper.getMainLooper()),\n                        mWorkerThread.getThreadHandler(),\n                        elapsedRealtimeClock,\n                        15_000,\n                        SCAN_INTERVAL_MILLIS,\n                        this);\n    }", "refactored_code": "    private static final long MAX_SCAN_AGE_MILLIS = 15_000;\n                        new Handler(Looper.getMainLooper()),\n                        mWorkerThread.getThreadHandler(),\n                        elapsedRealtimeClock,\n                        MAX_SCAN_AGE_MILLIS,\n                        SCAN_INTERVAL_MILLIS,\n                        this);\n    }"}
{"magic_number_smell": "    public void onClick(DialogInterface dialogInterface, int id) {\n        if (mListener != null) {\n            switch (id) {\n                case DialogInterface.BUTTON_POSITIVE:\n                    mListener.onSubmit(this);\n                    break;\n                case BUTTON_FORGET:", "refactored_code": "    private static final int BUTTON_SUBMIT = DialogInterface.BUTTON_POSITIVE;\n    public void onClick(DialogInterface dialogInterface, int id) {\n        if (mListener != null) {\n            switch (id) {\n                case BUTTON_SUBMIT:\n                    mListener.onSubmit(this);\n                    break;\n                case BUTTON_FORGET:"}
{"magic_number_smell": "            wifiEntry.forget(null /* callback */);\n        }\n\n        setResult(RESULT_FIRST_USER + 1);\n        finish();\n    }\n", "refactored_code": "    private static final int RESULT_FORGET = RESULT_FIRST_USER + 1;\n            wifiEntry.forget(null /* callback */);\n        }\n\n        setResult(RESULT_FORGET);\n        finish();\n    }\n"}
{"magic_number_smell": "                new Handler(Looper.getMainLooper()),\n                mWorkerThread.getThreadHandler(),\n                ELAPSED_REALTIME_CLOCK,\n                15_000,\n                SCAN_INTERVAL_MILLIS,\n                listener);\n", "refactored_code": "    private static final long MAX_SCAN_AGE_MILLIS = 15_000;\n                new Handler(Looper.getMainLooper()),\n                mWorkerThread.getThreadHandler(),\n                ELAPSED_REALTIME_CLOCK,\n                MAX_SCAN_AGE_MILLIS,\n                SCAN_INTERVAL_MILLIS,\n                listener);\n"}
{"magic_number_smell": "        if (TextUtils.isEmpty(ssid)) {\n            return true;\n        }\n        return ssid.length() < 1;\n    }\n\n    /**", "refactored_code": "    private static final int SSID_ASCII_MIN_LENGTH = 1;\n        if (TextUtils.isEmpty(ssid)) {\n            return true;\n        }\n        return ssid.length() < SSID_ASCII_MIN_LENGTH;\n    }\n\n    /**"}
{"magic_number_smell": "            public void onFailure(int reason) {\n                // Set result code of this network to be failed in the return list.\n                mResultCodeArrayList.set(mUiToRequestedList.get(mSavingIndex).mIndex,\n                        1);\n\n                if (saveNextNetwork()) {\n                    return;", "refactored_code": "    private static final int RESULT_NETWORK_ADD_ERROR = 1;\n            public void onFailure(int reason) {\n                // Set result code of this network to be failed in the return list.\n                mResultCodeArrayList.set(mUiToRequestedList.get(mSavingIndex).mIndex,\n                        RESULT_NETWORK_ADD_ERROR);\n\n                if (saveNextNetwork()) {\n                    return;"}
{"magic_number_smell": "    boolean shouldShow() {\n        final int notificationDelay = getCarrierConfig().getInt(\n                CarrierConfigManager.KEY_EMERGENCY_NOTIFICATION_DELAY_INT);\n        if (notificationDelay == -1) {\n            logd(\"shouldShow: false due to carrier config is default(-1).\");\n            return false;\n        }", "refactored_code": "    private static final int UNINITIALIZED_DELAY_VALUE = -1;\n    boolean shouldShow() {\n        final int notificationDelay = getCarrierConfig().getInt(\n                CarrierConfigManager.KEY_EMERGENCY_NOTIFICATION_DELAY_INT);\n        if (notificationDelay == UNINITIALIZED_DELAY_VALUE) {\n            logd(\"shouldShow: false due to carrier config is default(-1).\");\n            return false;\n        }"}
{"magic_number_smell": "                    // Call address management activity before turning on WFC\n                    final Intent carrierAppIntent = getCarrierActivityIntent();\n                    if (carrierAppIntent != null) {\n                        carrierAppIntent.putExtra(EXTRA_LAUNCH_CARRIER_APP, 0);\n                        startActivityForResult(carrierAppIntent,\n                                REQUEST_CHECK_WFC_EMERGENCY_ADDRESS);\n                    } else {", "refactored_code": "    public static final int LAUNCH_APP_ACTIVATE = 0;\n                    // Call address management activity before turning on WFC\n                    final Intent carrierAppIntent = getCarrierActivityIntent();\n                    if (carrierAppIntent != null) {\n                        carrierAppIntent.putExtra(EXTRA_LAUNCH_CARRIER_APP, LAUNCH_APP_ACTIVATE);\n                        startActivityForResult(carrierAppIntent,\n                                REQUEST_CHECK_WFC_EMERGENCY_ADDRESS);\n                    } else {"}
{"magic_number_smell": "        });\n        final ExecutorService executor = Executors.newSingleThreadExecutor();\n        executor.execute(wfcModeTask);\n        return wfcModeTask.get(2000, TimeUnit.MILLISECONDS);\n    }\n\n    /**", "refactored_code": "    private static final int TIMEOUT_MILLIS = 2000;\n        });\n        final ExecutorService executor = Executors.newSingleThreadExecutor();\n        executor.execute(wfcModeTask);\n        return wfcModeTask.get(TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n    }\n\n    /**"}
{"magic_number_smell": "                        new Handler(Looper.getMainLooper()),\n                        mWorkerThread.getThreadHandler(),\n                        elapsedRealtimeClock,\n                        15_000,\n                        SCAN_INTERVAL_MILLIS,\n                        getArguments().getString(KEY_CHOSEN_WIFIENTRY_KEY));\n    }", "refactored_code": "    private static final long MAX_SCAN_AGE_MILLIS = 15_000;\n                        new Handler(Looper.getMainLooper()),\n                        mWorkerThread.getThreadHandler(),\n                        elapsedRealtimeClock,\n                        MAX_SCAN_AGE_MILLIS,\n                        SCAN_INTERVAL_MILLIS,\n                        getArguments().getString(KEY_CHOSEN_WIFIENTRY_KEY));\n    }"}
{"magic_number_smell": "\n        @Override\n        protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n            if (token == 1) {\n                if (mContext == null || cursor == null || !cursor.moveToFirst()) {\n                    if (cursor != null) {\n                        cursor.close();", "refactored_code": "    private static final int TOKEN_QUERY_CARRIER_ID_AND_UPDATE_SIM_SUMMARY = 1;\n\n        @Override\n        protected void onQueryComplete(int token, Object cookie, Cursor cursor) {\n            if (token == TOKEN_QUERY_CARRIER_ID_AND_UPDATE_SIM_SUMMARY) {\n                if (mContext == null || cursor == null || !cursor.moveToFirst()) {\n                    if (cursor != null) {\n                        cursor.close();"}
{"magic_number_smell": "     */\n    public static int translateMacRandomizedValueToPrefValue(int macRandomized) {\n        return (macRandomized == WifiEntry.PRIVACY_RANDOMIZED_MAC)\n            ? 0 : PREF_RANDOMIZATION_NONE;\n    }\n\n    /**", "refactored_code": "    private static final int PREF_RANDOMIZATION_PERSISTENT = 0;\n     */\n    public static int translateMacRandomizedValueToPrefValue(int macRandomized) {\n        return (macRandomized == WifiEntry.PRIVACY_RANDOMIZED_MAC)\n            ? PREF_RANDOMIZATION_PERSISTENT : PREF_RANDOMIZATION_NONE;\n    }\n\n    /**"}
{"magic_number_smell": "                        getText(R.string.wifi_dpp_lockscreen_title), null, getUserId());\n        if (authIntent == null\n                || WifiDppUtils.isUnlockedWithinSeconds(\n                        WIFI_SHARING_KEY_ALIAS, 60)) {\n            startQrCodeActivity();\n            finish();\n        } else {", "refactored_code": "    private static final int MAX_UNLOCK_SECONDS = 60;\n                        getText(R.string.wifi_dpp_lockscreen_title), null, getUserId());\n        if (authIntent == null\n                || WifiDppUtils.isUnlockedWithinSeconds(\n                        WIFI_SHARING_KEY_ALIAS, MAX_UNLOCK_SECONDS)) {\n            startQrCodeActivity();\n            finish();\n        } else {"}
{"magic_number_smell": "        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case 1:\n                    mErrorMessage.setVisibility(View.INVISIBLE);\n                    break;\n", "refactored_code": "    private static final int MESSAGE_HIDE_ERROR_MESSAGE = 1;\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n                case MESSAGE_HIDE_ERROR_MESSAGE:\n                    mErrorMessage.setVisibility(View.INVISIBLE);\n                    break;\n"}
{"magic_number_smell": "                new Handler(Looper.getMainLooper()),\n                mWorkerThread.getThreadHandler(),\n                elapsedRealtimeClock,\n                15_000,\n                SCAN_INTERVAL_MILLIS,\n                this);\n    }", "refactored_code": "    private static final long MAX_SCAN_AGE_MILLIS = 15_000;\n                new Handler(Looper.getMainLooper()),\n                mWorkerThread.getThreadHandler(),\n                elapsedRealtimeClock,\n                MAX_SCAN_AGE_MILLIS,\n                SCAN_INTERVAL_MILLIS,\n                this);\n    }"}
{"magic_number_smell": "        super(context);\n        device = dev;\n        setWidgetLayoutResource(R.layout.preference_widget_wifi_signal);\n        mRssi = 60; //TODO: fix\n        if (TextUtils.isEmpty(device.deviceName)) {\n            setTitle(device.deviceAddress);\n        } else {", "refactored_code": "    private static final int FIXED_RSSI = 60;\n        super(context);\n        device = dev;\n        setWidgetLayoutResource(R.layout.preference_widget_wifi_signal);\n        mRssi = FIXED_RSSI; //TODO: fix\n        if (TextUtils.isEmpty(device.deviceName)) {\n            setTitle(device.deviceAddress);\n        } else {"}
{"magic_number_smell": "        mAppContext.getMainThreadHandler().postDelayed(() -> {\n            setRestarting(true);\n            stopTethering();\n        }, 100);\n    }\n\n    private void startTethering() {", "refactored_code": "    private static final int RESTART_INTERVAL_MS = 100;\n        mAppContext.getMainThreadHandler().postDelayed(() -> {\n            setRestarting(true);\n            stopTethering();\n        }, RESTART_INTERVAL_MS);\n    }\n\n    private void startTethering() {"}
{"magic_number_smell": "                new Handler(Looper.getMainLooper()),\n                mWorkerThread.getThreadHandler(),\n                elapsedRealtimeClock,\n                15_000,\n                SCAN_INTERVAL_MILLIS,\n                this);\n    }", "refactored_code": "    private static final long MAX_SCAN_AGE_MILLIS = 15_000;\n                new Handler(Looper.getMainLooper()),\n                mWorkerThread.getThreadHandler(),\n                elapsedRealtimeClock,\n                MAX_SCAN_AGE_MILLIS,\n                SCAN_INTERVAL_MILLIS,\n                this);\n    }"}
{"magic_number_smell": "            }\n            int checkType = mCurrentTethers.get(mCurrentTypeIndex);\n            mInProvisionCheck = false;\n            int result = intent.getIntExtra(EXTRA_RESULT, Activity.RESULT_CANCELED);\n            if (result != RESULT_OK) disableTethering(checkType);\n            fireCallbacksForType(checkType, result);\n", "refactored_code": "    private static final int RESULT_DEFAULT = Activity.RESULT_CANCELED;\n            }\n            int checkType = mCurrentTethers.get(mCurrentTypeIndex);\n            mInProvisionCheck = false;\n            int result = intent.getIntExtra(EXTRA_RESULT, RESULT_DEFAULT);\n            if (result != RESULT_OK) disableTethering(checkType);\n            fireCallbacksForType(checkType, result);\n"}
{"magic_number_smell": "        instrumentation.startActivitySync(new Intent(BATTERY_INTENT));\n        assertWithMessage(\"Doesn't have bluetooth anomaly\").that(\n                mDevice.wait(Until.findObject(By.text(\"AnomalyTester draining battery\")),\n                        3000)).isNotNull();\n    }\n\n    @Test", "refactored_code": "    private static final long TIME_OUT = 3000;\n        instrumentation.startActivitySync(new Intent(BATTERY_INTENT));\n        assertWithMessage(\"Doesn't have bluetooth anomaly\").that(\n                mDevice.wait(Until.findObject(By.text(\"AnomalyTester draining battery\")),\n                        TIME_OUT)).isNotNull();\n    }\n\n    @Test"}
{"magic_number_smell": "        final Intent intent = context.getPackageManager().getLaunchIntentForPackage(PACKAGE_NAME);\n        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);\n        context.startActivity(intent);\n        uiDevice.wait(Until.hasObject(By.pkg(PACKAGE_NAME).depth(0)), 3000);\n    }\n\n    /**", "refactored_code": "    private static final long TIME_OUT = 3000;\n        final Intent intent = context.getPackageManager().getLaunchIntentForPackage(PACKAGE_NAME);\n        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);\n        context.startActivity(intent);\n        uiDevice.wait(Until.hasObject(By.pkg(PACKAGE_NAME).depth(0)), TIME_OUT);\n    }\n\n    /**"}
{"magic_number_smell": "        // Wait for its running\n        mDevice.pressHome();\n        // Sleeping time less than running time, so the app still holding wakelock when we check\n        TestUtils.wait(mDevice, durationMs - 3000);\n\n        // Check it in battery main page\n        Instrumentation instrumentation = InstrumentationRegistry.getInstrumentation();", "refactored_code": "    private static final long TIME_OUT = 3000;\n        // Wait for its running\n        mDevice.pressHome();\n        // Sleeping time less than running time, so the app still holding wakelock when we check\n        TestUtils.wait(mDevice, durationMs - TIME_OUT);\n\n        // Check it in battery main page\n        Instrumentation instrumentation = InstrumentationRegistry.getInstrumentation();"}
{"magic_number_smell": "    public void teardown() throws Exception {\n        Intents.release();\n        AdbUtils.checkStringInAdbCommandOutput(TAG, \"locksettings clear --old \" + TEST_PIN,\n                \"\", \"\", 5000);\n    }\n\n    @Test", "refactored_code": "    private static final int ADB_TIMEOUT_MS = 5000;\n    public void teardown() throws Exception {\n        Intents.release();\n        AdbUtils.checkStringInAdbCommandOutput(TAG, \"locksettings clear --old \" + TEST_PIN,\n                \"\", \"\", ADB_TIMEOUT_MS);\n    }\n\n    @Test"}
{"magic_number_smell": "                    ((FragmentActivity) activity).getSupportFragmentManager().getFragments().get(0);\n            DarkModeSettingsFragment fragment = (DarkModeSettingsFragment) f;\n\n            setCustomTime(fragment, 0, LocalTime.now().plusMinutes(startTimeDiff));\n            setCustomTime(fragment, DIALOG_END_TIME, LocalTime.now().plusMinutes(endTimeDiff));\n\n            // The night mode need to reopen the screen to trigger UI change after mode change.", "refactored_code": "    private static final int DIALOG_START_TIME = 0;\n                    ((FragmentActivity) activity).getSupportFragmentManager().getFragments().get(0);\n            DarkModeSettingsFragment fragment = (DarkModeSettingsFragment) f;\n\n            setCustomTime(fragment, DIALOG_START_TIME, LocalTime.now().plusMinutes(startTimeDiff));\n            setCustomTime(fragment, DIALOG_END_TIME, LocalTime.now().plusMinutes(endTimeDiff));\n\n            // The night mode need to reopen the screen to trigger UI change after mode change."}
{"magic_number_smell": "        if (is_airplane_mode_on() != mOriginAirplaneModeIsOn) {\n            Settings.Global.putInt(mInstrumentation.getTargetContext().getContentResolver(),\n                    Settings.Global.AIRPLANE_MODE_ON, (\n                            mOriginAirplaneModeIsOn ? 1 : OFF));\n        }\n    }\n}", "refactored_code": "    private static final int ON = 1;\n        if (is_airplane_mode_on() != mOriginAirplaneModeIsOn) {\n            Settings.Global.putInt(mInstrumentation.getTargetContext().getContentResolver(),\n                    Settings.Global.AIRPLANE_MODE_ON, (\n                            mOriginAirplaneModeIsOn ? ON : OFF));\n        }\n    }\n}"}
{"magic_number_smell": "        System.setProperty(\"dexmaker.dexcache\", getContext().getCacheDir().toString());\n\n        MockitoAnnotations.initMocks(this);\n        when(mUserManager.getUserHandle()).thenReturn(10);\n        UserInfo primaryUser = new UserInfo(10, null,\n                UserInfo.FLAG_INITIALIZED | UserInfo.FLAG_PRIMARY);\n        when(mUserManager.getUserInfo(10)).thenReturn(primaryUser);", "refactored_code": "    private static final int TEST_PRIMARY_USER_ID = 10;\n        System.setProperty(\"dexmaker.dexcache\", getContext().getCacheDir().toString());\n\n        MockitoAnnotations.initMocks(this);\n        when(mUserManager.getUserHandle()).thenReturn(TEST_PRIMARY_USER_ID);\n        UserInfo primaryUser = new UserInfo(TEST_PRIMARY_USER_ID, null,\n                UserInfo.FLAG_INITIALIZED | UserInfo.FLAG_PRIMARY);\n        when(mUserManager.getUserInfo(TEST_PRIMARY_USER_ID)).thenReturn(primaryUser);"}
{"magic_number_smell": "        // Scroll to bottom\n        final UiObject2 view = mDevice.wait(\n                Until.findObject(By.res(mTargetPackage, \"main_content\")),\n                2000);\n        view.scroll(Direction.DOWN, 100f);\n\n        assertThat(mDevice.wait(Until.findObject(By.text(footerText)), 2000))", "refactored_code": "    private static final long TIMEOUT = 2000;\n        // Scroll to bottom\n        final UiObject2 view = mDevice.wait(\n                Until.findObject(By.res(mTargetPackage, \"main_content\")),\n                TIMEOUT);\n        view.scroll(Direction.DOWN, 100f);\n\n        assertThat(mDevice.wait(Until.findObject(By.text(footerText)), TIMEOUT))"}
{"magic_number_smell": "\n        // Return true if all jobs done\n        mSyncableController.countDown(KEY_2);\n        assertThat(latch.await(600, TimeUnit.MILLISECONDS)).isTrue();\n        assertThat(mSyncableController.isBlockerFinished()).isTrue();\n    }\n}", "refactored_code": "    private static final long TIMEOUT = 600;\n\n        // Return true if all jobs done\n        mSyncableController.countDown(KEY_2);\n        assertThat(latch.await(TIMEOUT, TimeUnit.MILLISECONDS)).isTrue();\n        assertThat(mSyncableController.isBlockerFinished()).isTrue();\n    }\n}"}
{"magic_number_smell": "        setScreenTimeOut(SCREEN_TIME_OUT);\n        setAirplaneMode();\n        mDevice.pressHome();\n        mDevice.waitForIdle(5000);\n\n        for (Page page : PAGES) {\n            mResult.put(page.title, new ArrayList<Integer>());", "refactored_code": "    private static final int TIME_OUT = 5000;\n        setScreenTimeOut(SCREEN_TIME_OUT);\n        setAirplaneMode();\n        mDevice.pressHome();\n        mDevice.waitForIdle(TIME_OUT);\n\n        for (Page page : PAGES) {\n            mResult.put(page.title, new ArrayList<Integer>());"}
{"magic_number_smell": "\n        AttributeSet attributeSet = Robolectric.buildAttributeSet().build();\n        mPreference = new RestrictedListPreference(mActivity, attributeSet);\n        mPreference.setProfileUserId(11);\n        ReflectionHelpers.setField(mPreference, \"mHelper\", mMockHelper);\n    }\n", "refactored_code": "    private static final int PROFILE_USER_ID = 11;\n\n        AttributeSet attributeSet = Robolectric.buildAttributeSet().build();\n        mPreference = new RestrictedListPreference(mActivity, attributeSet);\n        mPreference.setProfileUserId(PROFILE_USER_ID);\n        ReflectionHelpers.setField(mPreference, \"mHelper\", mMockHelper);\n    }\n"}
{"magic_number_smell": "\n    @Test\n    public void testGetMetrics_shouldGetMetricFromDialogCreatable() {\n        when(mDialogCreatable.getDialogMetricsCategory(15)).thenReturn(1);\n\n        mDialogFragment = SettingsPreferenceFragment.SettingsDialogFragment.newInstance(\n                mDialogCreatable, 15);", "refactored_code": "    private static final int DIALOG_ID = 15;\n\n    @Test\n    public void testGetMetrics_shouldGetMetricFromDialogCreatable() {\n        when(mDialogCreatable.getDialogMetricsCategory(DIALOG_ID)).thenReturn(1);\n\n        mDialogFragment = SettingsPreferenceFragment.SettingsDialogFragment.newInstance(\n                mDialogCreatable, DIALOG_ID);"}
{"magic_number_smell": "                RuntimeEnvironment.application.getSharedPreferences(AnomalyConfigJobService.PREF_DB,\n                        Context.MODE_PRIVATE);\n        SharedPreferences.Editor editor = sharedPreferences.edit();\n        editor.putInt(AnomalyConfigJobService.KEY_ANOMALY_CONFIG_VERSION, 2);\n        editor.commit();\n        doReturn(sharedPreferences).when(mTestService).getSharedPreferences(anyString(), anyInt());\n", "refactored_code": "    private static final int ANOMALY_VERSION = 2;\n                RuntimeEnvironment.application.getSharedPreferences(AnomalyConfigJobService.PREF_DB,\n                        Context.MODE_PRIVATE);\n        SharedPreferences.Editor editor = sharedPreferences.edit();\n        editor.putInt(AnomalyConfigJobService.KEY_ANOMALY_CONFIG_VERSION, ANOMALY_VERSION);\n        editor.commit();\n        doReturn(sharedPreferences).when(mTestService).getSharedPreferences(anyString(), anyInt());\n"}
{"magic_number_smell": "        mEmptyView = new View(mContext);\n        ReflectionHelpers.setField(mFragment, \"mEmptyView\", mEmptyView);\n\n        doReturn(5).when(mPreferenceScreen).getPreferenceCount();\n\n        mInitDeviceProvisionedValue = Settings.Global.getInt(mContext.getContentResolver(),\n                Settings.Global.DEVICE_PROVISIONED, 0);", "refactored_code": "    private static final int ITEM_COUNT = 5;\n        mEmptyView = new View(mContext);\n        ReflectionHelpers.setField(mFragment, \"mEmptyView\", mEmptyView);\n\n        doReturn(ITEM_COUNT).when(mPreferenceScreen).getPreferenceCount();\n\n        mInitDeviceProvisionedValue = Settings.Global.getInt(mContext.getContentResolver(),\n                Settings.Global.DEVICE_PROVISIONED, 0);"}
{"magic_number_smell": " */\npublic class TestUtils {\n    public static final long 1024L = 1024L; // TODO: Change to 1000 in O Robolectric.\n    public static final long MEGABYTE = 1024L * 1024L;\n    public static final long GIGABYTE = 1024L * MEGABYTE;\n\n    public static void setScheduledLevel(Context context, int scheduledLevel) {", "refactored_code": "    public static final long KILOBYTE = 1024L; // TODO: Change to 1000 in O Robolectric.\n */\npublic class TestUtils {\n    public static final long KILOBYTE = 1024L; // TODO: Change to 1000 in O Robolectric.\n    public static final long MEGABYTE = KILOBYTE * KILOBYTE;\n    public static final long GIGABYTE = KILOBYTE * MEGABYTE;\n\n    public static void setScheduledLevel(Context context, int scheduledLevel) {"}
{"magic_number_smell": "    public void getBadgedIcon_usePackageNameAndUserId()\n        throws PackageManager.NameNotFoundException {\n        doReturn(mApplicationInfo).when(mPackageManager).getApplicationInfoAsUser(\n                PACKAGE_NAME, PackageManager.GET_META_DATA, 1);\n\n        Utils.getBadgedIcon(mIconDrawableFactory, mPackageManager, PACKAGE_NAME, 1);\n", "refactored_code": "    private static final int USER_ID = 1;\n    public void getBadgedIcon_usePackageNameAndUserId()\n        throws PackageManager.NameNotFoundException {\n        doReturn(mApplicationInfo).when(mPackageManager).getApplicationInfoAsUser(\n                PACKAGE_NAME, PackageManager.GET_META_DATA, USER_ID);\n\n        Utils.getBadgedIcon(mIconDrawableFactory, mPackageManager, PACKAGE_NAME, USER_ID);\n"}
{"magic_number_smell": "\n    @Test\n    public void setupHelpLink_setCorrectHelpLinkAndLearnMoreText() {\n        mController.setupHelpLink(12345, TEST_CONTENT_DESCRIPTION);\n\n        assertThat(mController.getHelpResource()).isEqualTo(12345);\n        assertThat(mController.getLearnMoreText())", "refactored_code": "    private static final int TEST_HELP_ID = 12345;\n\n    @Test\n    public void setupHelpLink_setCorrectHelpLinkAndLearnMoreText() {\n        mController.setupHelpLink(TEST_HELP_ID, TEST_CONTENT_DESCRIPTION);\n\n        assertThat(mController.getHelpResource()).isEqualTo(TEST_HELP_ID);\n        assertThat(mController.getLearnMoreText())"}
{"magic_number_smell": "    public void initTooltipView_atMostAvailableTextWidth() {\n        final String quickSettingsTooltipsContent = mContext.getString(\n                R.string.accessibility_service_qs_tooltip_content, TEST_PACKAGE_NAME);\n        mTooltipView.setup(quickSettingsTooltipsContent, 1234);\n\n        final int getMaxWidth = mTooltipView.getAvailableWindowWidth();\n        assertThat(mTooltipView.getWidth()).isAtMost(getMaxWidth);", "refactored_code": "    private static final int TEST_RES_ID = 1234;\n    public void initTooltipView_atMostAvailableTextWidth() {\n        final String quickSettingsTooltipsContent = mContext.getString(\n                R.string.accessibility_service_qs_tooltip_content, TEST_PACKAGE_NAME);\n        mTooltipView.setup(quickSettingsTooltipsContent, TEST_RES_ID);\n\n        final int getMaxWidth = mTooltipView.getAvailableWindowWidth();\n        assertThat(mTooltipView.getWidth()).isAtMost(getMaxWidth);"}
{"magic_number_smell": "        mController.setChecked(false);\n\n        assertThat(Settings.Secure.getInt(\n            mContext.getContentResolver(), KEY_AUDIO_DESCRIPTION, -1)).isEqualTo(OFF);\n    }\n\n    @Test", "refactored_code": "    private static final int UNKNOWN = -1;\n        mController.setChecked(false);\n\n        assertThat(Settings.Secure.getInt(\n            mContext.getContentResolver(), KEY_AUDIO_DESCRIPTION, UNKNOWN)).isEqualTo(OFF);\n    }\n\n    @Test"}
{"magic_number_smell": "        mSeekBarPreference.onBindViewHolder(mHolder);\n\n        assertThat(mSeekBar.getMax()).isEqualTo(BALANCE_MAX_VALUE);\n        assertThat(mSeekBar.getProgress()).isEqualTo(100);\n    }\n}\n", "refactored_code": "    private static final int BALANCE_CENTER_VALUE = 100;\n        mSeekBarPreference.onBindViewHolder(mHolder);\n\n        assertThat(mSeekBar.getMax()).isEqualTo(BALANCE_MAX_VALUE);\n        assertThat(mSeekBar.getProgress()).isEqualTo(BALANCE_CENTER_VALUE);\n    }\n}\n"}
{"magic_number_smell": "    @Test\n    public void onProgressChanged_shouldInvokeMethod() {\n        // Assign the test value of SeekBar progress\n        mProxySeekBarListener.onProgressChanged(mSeekBar, 200, true);\n\n        verify(mockSeekBarChangeListener, times(1)).onProgressChanged(eq(mSeekBar),\n                eq(200), eq(true));", "refactored_code": "    private static final int MAX_PROGRESS_VALUE = 200;\n    @Test\n    public void onProgressChanged_shouldInvokeMethod() {\n        // Assign the test value of SeekBar progress\n        mProxySeekBarListener.onProgressChanged(mSeekBar, MAX_PROGRESS_VALUE, true);\n\n        verify(mockSeekBarChangeListener, times(1)).onProgressChanged(eq(mSeekBar),\n                eq(MAX_PROGRESS_VALUE), eq(true));"}
{"magic_number_smell": "    @Test\n    public void getSummary_noScale_shouldReturnDefaultSummary() {\n        final String expectedSummary =\n                getSummaryCombo(DEFAULT_FONT_SCALE_INDEX, 1);\n        assertThat(mController.getSummary().toString()).isEqualTo(expectedSummary);\n    }\n", "refactored_code": "    private static final int DEFAULT_PRESET_INDEX = 1;\n    @Test\n    public void getSummary_noScale_shouldReturnDefaultSummary() {\n        final String expectedSummary =\n                getSummaryCombo(DEFAULT_FONT_SCALE_INDEX, DEFAULT_PRESET_INDEX);\n        assertThat(mController.getSummary().toString()).isEqualTo(expectedSummary);\n    }\n"}
{"magic_number_smell": "    private static final String COLOR_WHITE = \"WHITE\";\n    private static final String COLOR_BLACK = \"BLACK\";\n    private final int[] mColorValues =\n            {0, COLOR_WHITE_VALUE, COLOR_BLACK_VALUE};\n    private final String[] mColorTitles = {COLOR_TRANSPARENT, COLOR_WHITE, COLOR_BLACK};\n    private View mRootView;\n    private ImageView mImageView;", "refactored_code": "    private static final int COLOR_TRANSPARENT_VALUE = 0;\n    private static final String COLOR_WHITE = \"WHITE\";\n    private static final String COLOR_BLACK = \"BLACK\";\n    private final int[] mColorValues =\n            {COLOR_TRANSPARENT_VALUE, COLOR_WHITE_VALUE, COLOR_BLACK_VALUE};\n    private final String[] mColorTitles = {COLOR_TRANSPARENT, COLOR_WHITE, COLOR_BLACK};\n    private View mRootView;\n    private ImageView mImageView;"}
{"magic_number_smell": "\n    private void setColorCorrectionEnabled(boolean enabled) {\n        Settings.Secure.putInt(mContext.getContentResolver(),\n                Settings.Secure.ACCESSIBILITY_DISPLAY_DALTONIZER_ENABLED, enabled ? 1 : OFF);\n    }\n\n    private void setColorCorrectionShortcutEnabled(boolean enabled) {", "refactored_code": "    private static final int ON = 1;\n\n    private void setColorCorrectionEnabled(boolean enabled) {\n        Settings.Secure.putInt(mContext.getContentResolver(),\n                Settings.Secure.ACCESSIBILITY_DISPLAY_DALTONIZER_ENABLED, enabled ? ON : OFF);\n    }\n\n    private void setColorCorrectionShortcutEnabled(boolean enabled) {"}
{"magic_number_smell": "    @Test\n    public void updateState_keyFloatingMenuFadeDisabled_fadeIsDisabled() {\n        Settings.Secure.putInt(mContentResolver,\n                Settings.Secure.ACCESSIBILITY_FLOATING_MENU_FADE_ENABLED, 0);\n\n        mController.updateState(mSwitchPreference);\n", "refactored_code": "    private static final int OFF = 0;\n    @Test\n    public void updateState_keyFloatingMenuFadeDisabled_fadeIsDisabled() {\n        Settings.Secure.putInt(mContentResolver,\n                Settings.Secure.ACCESSIBILITY_FLOATING_MENU_FADE_ENABLED, OFF);\n\n        mController.updateState(mSwitchPreference);\n"}
{"magic_number_smell": "\n    @Test\n    public void updateState_hapticFeedbackDisabled_shouldDisplayAlwaysOff() {\n        updateSetting(Settings.System.HAPTIC_FEEDBACK_ENABLED, 0);\n\n        updateSetting(Settings.System.HAPTIC_FEEDBACK_INTENSITY, Vibrator.VIBRATION_INTENSITY_HIGH);\n        mController.updateState(mPreference);", "refactored_code": "    private static final int OFF = 0;\n\n    @Test\n    public void updateState_hapticFeedbackDisabled_shouldDisplayAlwaysOff() {\n        updateSetting(Settings.System.HAPTIC_FEEDBACK_ENABLED, OFF);\n\n        updateSetting(Settings.System.HAPTIC_FEEDBACK_INTENSITY, Vibrator.VIBRATION_INTENSITY_HIGH);\n        mController.updateState(mPreference);"}
{"magic_number_smell": "\n    @Test\n    public void updateState_hapticFeedbackDisabled_shouldDisplayAlwaysOff() {\n        updateSetting(Settings.System.HAPTIC_FEEDBACK_ENABLED, 0);\n\n        updateSetting(Settings.System.HAPTIC_FEEDBACK_INTENSITY, Vibrator.VIBRATION_INTENSITY_HIGH);\n        mController.updateState(mPreference);", "refactored_code": "    private static final int OFF = 0;\n\n    @Test\n    public void updateState_hapticFeedbackDisabled_shouldDisplayAlwaysOff() {\n        updateSetting(Settings.System.HAPTIC_FEEDBACK_ENABLED, OFF);\n\n        updateSetting(Settings.System.HAPTIC_FEEDBACK_INTENSITY, Vibrator.VIBRATION_INTENSITY_HIGH);\n        mController.updateState(mPreference);"}
{"magic_number_smell": "    @Before\n    public void setUp() {\n        setupEnvironment();\n        setupDialog(SettingsEnums.SETTINGS_CONNECTED_DEVICE_CATEGORY);\n    }\n\n    @Test", "refactored_code": "    private static final int TEST_LAUNCH_PAGE = SettingsEnums.SETTINGS_CONNECTED_DEVICE_CATEGORY;\n    @Before\n    public void setUp() {\n        setupEnvironment();\n        setupDialog(TEST_LAUNCH_PAGE);\n    }\n\n    @Test"}
{"magic_number_smell": "        when(mCachedBluetoothDevice.isConnectedAshaHearingAidDevice()).thenReturn(false);\n\n        HearingAidUtils.launchHearingAidPairingDialog(mFragmentManager, mCachedBluetoothDevice,\n                1);\n\n        shadowMainLooper().idle();\n        final AlertDialog dialog = ShadowAlertDialogCompat.getLatestAlertDialog();", "refactored_code": "    private static final int TEST_LAUNCH_PAGE = 1;\n        when(mCachedBluetoothDevice.isConnectedAshaHearingAidDevice()).thenReturn(false);\n\n        HearingAidUtils.launchHearingAidPairingDialog(mFragmentManager, mCachedBluetoothDevice,\n                TEST_LAUNCH_PAGE);\n\n        shadowMainLooper().idle();\n        final AlertDialog dialog = ShadowAlertDialogCompat.getLatestAlertDialog();"}
{"magic_number_smell": "        mModePreference = new Preference(mContext);\n        mModePreference.setKey(PREF_KEY);\n        mScreen.addPreference(mModePreference);\n        MagnificationCapabilities.setCapabilities(mContext, MagnificationMode.ALL);\n        mController = new MagnificationModePreferenceController(mContext, PREF_KEY);\n        showPreferenceOnTheScreen(null);\n    }", "refactored_code": "    private static final int MAGNIFICATION_MODE_DEFAULT = MagnificationMode.ALL;\n        mModePreference = new Preference(mContext);\n        mModePreference.setKey(PREF_KEY);\n        mScreen.addPreference(mModePreference);\n        MagnificationCapabilities.setCapabilities(mContext, MAGNIFICATION_MODE_DEFAULT);\n        mController = new MagnificationModePreferenceController(mContext, PREF_KEY);\n        showPreferenceOnTheScreen(null);\n    }"}
{"magic_number_smell": "        mController.setChecked(true);\n\n        assertThat(Settings.Secure.getInt(mContext.getContentResolver(),\n                Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR, -1))\n                .isEqualTo(Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_HANGUP);\n    }\n", "refactored_code": "    private static final int UNKNOWN = -1;\n        mController.setChecked(true);\n\n        assertThat(Settings.Secure.getInt(mContext.getContentResolver(),\n                Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR, UNKNOWN))\n                .isEqualTo(Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_HANGUP);\n    }\n"}
{"magic_number_smell": "    @Test\n    public void updateState_vibrateWhenRingingAndRampingRingerOff_shouldDisplayRingIntensity() {\n        when(mAudioManager.isRampingRingerEnabled()).thenReturn(false);\n        updateSetting(Settings.System.VIBRATE_WHEN_RINGING, 0);\n\n        updateSetting(Settings.System.RING_VIBRATION_INTENSITY, Vibrator.VIBRATION_INTENSITY_HIGH);\n        mController.updateState(mPreference);", "refactored_code": "    private static final int OFF = 0;\n    @Test\n    public void updateState_vibrateWhenRingingAndRampingRingerOff_shouldDisplayRingIntensity() {\n        when(mAudioManager.isRampingRingerEnabled()).thenReturn(false);\n        updateSetting(Settings.System.VIBRATE_WHEN_RINGING, OFF);\n\n        updateSetting(Settings.System.RING_VIBRATION_INTENSITY, Vibrator.VIBRATION_INTENSITY_HIGH);\n        mController.updateState(mPreference);"}
{"magic_number_smell": "        // VIBRATE_WHEN_RINGING is deprecated and should have no effect on the ring vibration\n        // setting. The ramping ringer is also independent now, instead of a 3-state setting.\n        when(mAudioManager.isRampingRingerEnabled()).thenReturn(false);\n        updateSetting(Settings.System.VIBRATE_WHEN_RINGING, 0);\n\n        updateSetting(Settings.System.RING_VIBRATION_INTENSITY, Vibrator.VIBRATION_INTENSITY_HIGH);\n        mController.updateState(mPreference);", "refactored_code": "    private static final int OFF = 0;\n        // VIBRATE_WHEN_RINGING is deprecated and should have no effect on the ring vibration\n        // setting. The ramping ringer is also independent now, instead of a 3-state setting.\n        when(mAudioManager.isRampingRingerEnabled()).thenReturn(false);\n        updateSetting(Settings.System.VIBRATE_WHEN_RINGING, OFF);\n\n        updateSetting(Settings.System.RING_VIBRATION_INTENSITY, Vibrator.VIBRATION_INTENSITY_HIGH);\n        mController.updateState(mPreference);"}
{"magic_number_smell": "\n    @Test\n    public void colorInt_assertNotTranslucent() {\n        assertThat(mColor.mColorInt & 0xFF000000).isNotEqualTo(0);\n    }\n\n    @Test", "refactored_code": "    private static final int OPAQUE_COLOR_MASK = 0xFF000000;\n\n    @Test\n    public void colorInt_assertNotTranslucent() {\n        assertThat(mColor.mColorInt & OPAQUE_COLOR_MASK).isNotEqualTo(0);\n    }\n\n    @Test"}
{"magic_number_smell": "    @Test\n    public void updateState_toShortTimeout_shouldReturnShortSummary() {\n        Settings.Secure.putInt(mContext.getContentResolver(),\n                Settings.Secure.LONG_PRESS_TIMEOUT, 400);\n        mController.updateState(mPreference);\n\n        assertThat(mPreference.getSummary().toString()).isEqualTo(\"Short\");", "refactored_code": "    private static final int SHORT_VALUE = 400;\n    @Test\n    public void updateState_toShortTimeout_shouldReturnShortSummary() {\n        Settings.Secure.putInt(mContext.getContentResolver(),\n                Settings.Secure.LONG_PRESS_TIMEOUT, SHORT_VALUE);\n        mController.updateState(mPreference);\n\n        assertThat(mPreference.getSummary().toString()).isEqualTo(\"Short\");"}
{"magic_number_smell": "\n    private static class TestToggleAccessibilityServicePreferenceFragment\n            extends ToggleAccessibilityServicePreferenceFragment {\n        int mLastShownDialogId = -1;\n\n        @Override\n        protected ComponentName getTileComponentName() {", "refactored_code": "    private static final int NO_DIALOG = -1;\n\n    private static class TestToggleAccessibilityServicePreferenceFragment\n            extends ToggleAccessibilityServicePreferenceFragment {\n        int mLastShownDialogId = NO_DIALOG;\n\n        @Override\n        protected ComponentName getTileComponentName() {"}
{"magic_number_smell": "\n        TestPreferenceController(Context context, int supportedIntensityLevels) {\n            super(context, \"preference_key\",\n                    new VibrationPreferenceConfig(context, SETTING_KEY, VibrationAttributes.USAGE_NOTIFICATION) {},\n                    supportedIntensityLevels);\n        }\n", "refactored_code": "    private static final int VIBRATION_USAGE = VibrationAttributes.USAGE_NOTIFICATION;\n\n        TestPreferenceController(Context context, int supportedIntensityLevels) {\n            super(context, \"preference_key\",\n                    new VibrationPreferenceConfig(context, SETTING_KEY, VIBRATION_USAGE) {},\n                    supportedIntensityLevels);\n        }\n"}
{"magic_number_smell": "\n    @Test\n    public void getSummary_vibrateSettingOff_returnsOffText() {\n        Settings.System.putInt(mContext.getContentResolver(), Settings.System.VIBRATE_ON, 0);\n        VibrationPreferenceController controller = createPreferenceController();\n        controller.updateState(mPreference);\n", "refactored_code": "    private static final int OFF = 0;\n\n    @Test\n    public void getSummary_vibrateSettingOff_returnsOffText() {\n        Settings.System.putInt(mContext.getContentResolver(), Settings.System.VIBRATE_ON, OFF);\n        VibrationPreferenceController controller = createPreferenceController();\n        controller.updateState(mPreference);\n"}
{"magic_number_smell": "\n        TestPreferenceController(Context context) {\n            super(context, \"preference_key\",\n                    new VibrationPreferenceConfig(context, SETTING_KEY, VibrationAttributes.USAGE_NOTIFICATION) {});\n        }\n\n        @Override", "refactored_code": "    private static final int VIBRATION_USAGE = VibrationAttributes.USAGE_NOTIFICATION;\n\n        TestPreferenceController(Context context) {\n            super(context, \"preference_key\",\n                    new VibrationPreferenceConfig(context, SETTING_KEY, VIBRATION_USAGE) {});\n        }\n\n        @Override"}
{"magic_number_smell": "    @Test\n    public void searchIndexProvider_hasManagedProfile_shouldNotIndex() {\n        final List<UserInfo> infos = new ArrayList<>();\n        infos.add(new UserInfo(10, PROFILE_NAME, UserInfo.FLAG_MANAGED_PROFILE));\n        doReturn(infos).when(mUserManager).getProfiles(anyInt());\n\n        final List<SearchIndexableRaw> indexRaws =", "refactored_code": "    private static final int PROFILE_ID = 10;\n    @Test\n    public void searchIndexProvider_hasManagedProfile_shouldNotIndex() {\n        final List<UserInfo> infos = new ArrayList<>();\n        infos.add(new UserInfo(PROFILE_ID, PROFILE_NAME, UserInfo.FLAG_MANAGED_PROFILE));\n        doReturn(infos).when(mUserManager).getProfiles(anyInt());\n\n        final List<SearchIndexableRaw> indexRaws ="}
{"magic_number_smell": "        when(mUserManager.getUserInfo(anyInt())).thenReturn(mUserInfo);\n        when(mUserManager.getProcessUserId()).thenReturn(0);\n        when(mUserManager.getUserProfiles()).thenReturn(Collections.singletonList(mManagedUser));\n        when(mManagedUser.getIdentifier()).thenReturn(10);\n        mController = new ContactSearchPreferenceController(mContext, PREF_KEY);\n    }\n", "refactored_code": "    private static final int MANAGED_USER_ID = 10;\n        when(mUserManager.getUserInfo(anyInt())).thenReturn(mUserInfo);\n        when(mUserManager.getProcessUserId()).thenReturn(0);\n        when(mUserManager.getUserProfiles()).thenReturn(Collections.singletonList(mManagedUser));\n        when(mManagedUser.getIdentifier()).thenReturn(MANAGED_USER_ID);\n        mController = new ContactSearchPreferenceController(mContext, PREF_KEY);\n    }\n"}
{"magic_number_smell": "        mPreference = spy(new RestrictedSwitchPreference(mContext));\n        dpm = ShadowDevicePolicyManager.getShadow();\n\n        when(mManagedUser.getIdentifier()).thenReturn(10);\n        doReturn(mContext).when(mContext).createPackageContextAsUser(\n                any(String.class), anyInt(), any(UserHandle.class));\n    }", "refactored_code": "    private static final int MANAGED_USER_ID = 10;\n        mPreference = spy(new RestrictedSwitchPreference(mContext));\n        dpm = ShadowDevicePolicyManager.getShadow();\n\n        when(mManagedUser.getIdentifier()).thenReturn(MANAGED_USER_ID);\n        doReturn(mContext).when(mContext).createPackageContextAsUser(\n                any(String.class), anyInt(), any(UserHandle.class));\n    }"}
{"magic_number_smell": "        when(mUserInfo.isManagedProfile()).thenReturn(true);\n        when(mUserManager.getUserInfo(anyInt())).thenReturn(mUserInfo);\n        when(mUserManager.getProcessUserId()).thenReturn(0);\n        when(mManagedUser.getIdentifier()).thenReturn(10);\n        when(mUserManager.getUserProfiles()).thenReturn(Collections.singletonList(mManagedUser));\n        mQuietModeEnabler = new ManagedProfileQuietModeEnabler(mContext,\n                mOnQuietModeChangeListener);", "refactored_code": "    private static final int MANAGED_USER_ID = 10;\n        when(mUserInfo.isManagedProfile()).thenReturn(true);\n        when(mUserManager.getUserInfo(anyInt())).thenReturn(mUserInfo);\n        when(mUserManager.getProcessUserId()).thenReturn(0);\n        when(mManagedUser.getIdentifier()).thenReturn(MANAGED_USER_ID);\n        when(mUserManager.getUserProfiles()).thenReturn(Collections.singletonList(mManagedUser));\n        mQuietModeEnabler = new ManagedProfileQuietModeEnabler(mContext,\n                mOnQuietModeChangeListener);"}
{"magic_number_smell": "        when(mUserManager.getUserInfo(anyInt())).thenReturn(mUserInfo);\n        when(mUserManager.getProcessUserId()).thenReturn(0);\n        when(mUserManager.getUserProfiles()).thenReturn(Collections.singletonList(mManagedUser));\n        when(mManagedUser.getIdentifier()).thenReturn(10);\n        when(mScreen.findPreference(anyString())).thenReturn(mPreference);\n        mController = new WorkModePreferenceController(mContext, PREF_KEY);\n        mController.displayPreference(mScreen);", "refactored_code": "    private static final int MANAGED_USER_ID = 10;\n        when(mUserManager.getUserInfo(anyInt())).thenReturn(mUserInfo);\n        when(mUserManager.getProcessUserId()).thenReturn(0);\n        when(mUserManager.getUserProfiles()).thenReturn(Collections.singletonList(mManagedUser));\n        when(mManagedUser.getIdentifier()).thenReturn(MANAGED_USER_ID);\n        when(mScreen.findPreference(anyString())).thenReturn(mPreference);\n        mController = new WorkModePreferenceController(mContext, PREF_KEY);\n        mController.displayPreference(mScreen);"}
{"magic_number_smell": "    private final int MANAGED_PROFILE_ID = 10;\n\n    private final int PER_USER_UID_RANGE = 100000;\n    private final int APP_1_UID = 0 * PER_USER_UID_RANGE + 1;\n    private final int APP_2_UID = MANAGED_PROFILE_ID * PER_USER_UID_RANGE + 1;\n\n    private final String APP_1 = \"app1\";", "refactored_code": "    private final int MAIN_USER_ID = 0;\n    private final int MANAGED_PROFILE_ID = 10;\n\n    private final int PER_USER_UID_RANGE = 100000;\n    private final int APP_1_UID = MAIN_USER_ID * PER_USER_UID_RANGE + 1;\n    private final int APP_2_UID = MANAGED_PROFILE_ID * PER_USER_UID_RANGE + 1;\n\n    private final String APP_1 = \"app1\";"}
{"magic_number_smell": "    private final int MANAGED_PROFILE_ID = 10;\n\n    private final int PER_USER_UID_RANGE = 100000;\n    private final int APP_1_UID = 0 * PER_USER_UID_RANGE + 1;\n    private final int APP_2_UID = 0 * PER_USER_UID_RANGE + 2;\n    private final int APP_3_UID = 0 * PER_USER_UID_RANGE + 3;\n    private final int APP_4_UID = 0 * PER_USER_UID_RANGE + 4;", "refactored_code": "    private final int MAIN_USER_ID = 0;\n    private final int MANAGED_PROFILE_ID = 10;\n\n    private final int PER_USER_UID_RANGE = 100000;\n    private final int APP_1_UID = MAIN_USER_ID * PER_USER_UID_RANGE + 1;\n    private final int APP_2_UID = MAIN_USER_ID * PER_USER_UID_RANGE + 2;\n    private final int APP_3_UID = MAIN_USER_ID * PER_USER_UID_RANGE + 3;\n    private final int APP_4_UID = MAIN_USER_ID * PER_USER_UID_RANGE + 4;"}
{"magic_number_smell": "    private final int MANAGED_PROFILE_ID = 10;\n\n    private final int PER_USER_UID_RANGE = 100000;\n    private final int APP_1_UID = 0 * PER_USER_UID_RANGE + 1;\n    private final int APP_2_UID = 0 * PER_USER_UID_RANGE + 2;\n    private final int APP_3_UID = 0 * PER_USER_UID_RANGE + 3;\n    private final int APP_4_UID = 0 * PER_USER_UID_RANGE + 4;", "refactored_code": "    private final int MAIN_USER_ID = 0;\n    private final int MANAGED_PROFILE_ID = 10;\n\n    private final int PER_USER_UID_RANGE = 100000;\n    private final int APP_1_UID = MAIN_USER_ID * PER_USER_UID_RANGE + 1;\n    private final int APP_2_UID = MAIN_USER_ID * PER_USER_UID_RANGE + 2;\n    private final int APP_3_UID = MAIN_USER_ID * PER_USER_UID_RANGE + 3;\n    private final int APP_4_UID = MAIN_USER_ID * PER_USER_UID_RANGE + 4;"}
{"magic_number_smell": "    private final int MANAGED_PROFILE_ID = 10;\n\n    private final int PER_USER_UID_RANGE = 100000;\n    private final int MAIN_USER_APP_UID = 0 * PER_USER_UID_RANGE;\n    private final int MANAGED_PROFILE_APP_UID = MANAGED_PROFILE_ID * PER_USER_UID_RANGE;\n\n    @Mock", "refactored_code": "    private final int MAIN_USER_ID = 0;\n    private final int MANAGED_PROFILE_ID = 10;\n\n    private final int PER_USER_UID_RANGE = 100000;\n    private final int MAIN_USER_APP_UID = MAIN_USER_ID * PER_USER_UID_RANGE;\n    private final int MANAGED_PROFILE_APP_UID = MANAGED_PROFILE_ID * PER_USER_UID_RANGE;\n\n    @Mock"}
{"magic_number_smell": "    private final int MANAGED_PROFILE_ID = 10;\n\n    private final int PER_USER_UID_RANGE = 100000;\n    private final int MAIN_USER_APP_UID = 0 * PER_USER_UID_RANGE;\n    private final int MANAGED_PROFILE_APP_UID = MANAGED_PROFILE_ID * PER_USER_UID_RANGE;\n\n    @Mock", "refactored_code": "    private final int MAIN_USER_ID = 0;\n    private final int MANAGED_PROFILE_ID = 10;\n\n    private final int PER_USER_UID_RANGE = 100000;\n    private final int MAIN_USER_APP_UID = MAIN_USER_ID * PER_USER_UID_RANGE;\n    private final int MANAGED_PROFILE_APP_UID = MANAGED_PROFILE_ID * PER_USER_UID_RANGE;\n\n    @Mock"}
{"magic_number_smell": "\n        mBatteryPreference = spy(new Preference(RuntimeEnvironment.application));\n\n        when(mUidBatteryConsumer.getUid()).thenReturn(111);\n        when(mOtherUidBatteryConsumer.getUid()).thenReturn(OTHER_UID);\n\n        mController = spy(new AppBatteryPreferenceController(", "refactored_code": "    private static final int TARGET_UID = 111;\n\n        mBatteryPreference = spy(new Preference(RuntimeEnvironment.application));\n\n        when(mUidBatteryConsumer.getUid()).thenReturn(TARGET_UID);\n        when(mOtherUidBatteryConsumer.getUid()).thenReturn(OTHER_UID);\n\n        mController = spy(new AppBatteryPreferenceController("}
{"magic_number_smell": "        when(mSettingsActivity.getResources().getString(anyInt())).thenReturn(RESOURCE_STRING);\n\n        mController = spy(new AppButtonsPreferenceController(mSettingsActivity, mFragment,\n                mLifecycle, PACKAGE_NAME, mState, 0, REQUEST_REMOVE_DEVICE_ADMIN));\n\n        mAppEntry.info = mAppInfo;\n        mAppInfo.packageName = PACKAGE_NAME;", "refactored_code": "    private static final int REQUEST_UNINSTALL = 0;\n        when(mSettingsActivity.getResources().getString(anyInt())).thenReturn(RESOURCE_STRING);\n\n        mController = spy(new AppButtonsPreferenceController(mSettingsActivity, mFragment,\n                mLifecycle, PACKAGE_NAME, mState, REQUEST_UNINSTALL, REQUEST_REMOVE_DEVICE_ADMIN));\n\n        mAppEntry.info = mAppInfo;\n        mAppInfo.packageName = PACKAGE_NAME;"}
{"magic_number_smell": "        MockitoAnnotations.initMocks(this);\n        mShadowContext = RuntimeEnvironment.application;\n\n        mFragment = spy(ButtonActionDialogFragment.newInstance(ButtonActionDialogFragment.DialogType.FORCE_STOP));\n        doReturn(mShadowContext).when(mFragment).getContext();\n        mFragment.setTargetFragment(mTargetFragment, 0);\n    }", "refactored_code": "    private static final int FORCE_STOP_ID = ButtonActionDialogFragment.DialogType.FORCE_STOP;\n        MockitoAnnotations.initMocks(this);\n        mShadowContext = RuntimeEnvironment.application;\n\n        mFragment = spy(ButtonActionDialogFragment.newInstance(FORCE_STOP_ID));\n        doReturn(mShadowContext).when(mFragment).getContext();\n        mFragment.setTargetFragment(mTargetFragment, 0);\n    }"}
{"magic_number_smell": "                mPicker, \"mUserId\", MAIN_PROFILE_UID * UserHandle.PER_USER_RANGE);\n        assertThat(mPicker.setDefaultKey(MAIN_APP_KEY)).isTrue();\n        ReflectionHelpers.setField(\n                mPicker, \"mUserId\", 10 * UserHandle.PER_USER_RANGE);\n        assertThat(mPicker.setDefaultKey(MANAGED_APP_KEY)).isTrue();\n\n        ReflectionHelpers.setField(", "refactored_code": "    private static final int MANAGED_PROFILE_UID = 10;\n                mPicker, \"mUserId\", MAIN_PROFILE_UID * UserHandle.PER_USER_RANGE);\n        assertThat(mPicker.setDefaultKey(MAIN_APP_KEY)).isTrue();\n        ReflectionHelpers.setField(\n                mPicker, \"mUserId\", MANAGED_PROFILE_UID * UserHandle.PER_USER_RANGE);\n        assertThat(mPicker.setDefaultKey(MANAGED_APP_KEY)).isTrue();\n\n        ReflectionHelpers.setField("}
{"magic_number_smell": "        mFeatureFactory = FakeFeatureFactory.setupForTest();\n        mDeviceAdminAdd = Robolectric.buildActivity(DeviceAdminAdd.class).get();\n\n        doReturn(12345).when(mBatteryUtils).getPackageUid(PACKAGE_NAME);\n        when(mDeviceAdmin.getComponent().getPackageName()).thenReturn(PACKAGE_NAME);\n        mDeviceAdminAdd.mDeviceAdmin = mDeviceAdmin;\n    }", "refactored_code": "    private static final int UID = 12345;\n        mFeatureFactory = FakeFeatureFactory.setupForTest();\n        mDeviceAdminAdd = Robolectric.buildActivity(DeviceAdminAdd.class).get();\n\n        doReturn(UID).when(mBatteryUtils).getPackageUid(PACKAGE_NAME);\n        when(mDeviceAdmin.getComponent().getPackageName()).thenReturn(PACKAGE_NAME);\n        mDeviceAdminAdd.mDeviceAdmin = mDeviceAdmin;\n    }"}
{"magic_number_smell": "    @Test\n    public void getAvailabilityStatus_multipleProfiles_returnsAvailable() {\n        shadowOf(mUserManager).addUser(\n                0, \"personal-profile\"/* name */, 0/* flags */);\n        shadowOf(mUserManager).addProfile(\n                0,\n                WORK_PROFILE_ID,", "refactored_code": "    private static final int PERSONAL_PROFILE_ID = 0;\n    @Test\n    public void getAvailabilityStatus_multipleProfiles_returnsAvailable() {\n        shadowOf(mUserManager).addUser(\n                PERSONAL_PROFILE_ID, \"personal-profile\"/* name */, 0/* flags */);\n        shadowOf(mUserManager).addProfile(\n                PERSONAL_PROFILE_ID,\n                WORK_PROFILE_ID,"}
{"magic_number_smell": "    @Test\n    public void getPreferenceSummary_appOpAllowed_returnsAllowed() {\n        mShadowUserManager.addUser(\n                0, \"personal-profile\"/* name */, 0/* flags */);\n        mShadowUserManager.addProfile(\n                0, WORK_PROFILE_ID,\n                \"work-profile\"/* profileName */, UserInfo.FLAG_MANAGED_PROFILE);", "refactored_code": "    private static final int PERSONAL_PROFILE_ID = 0;\n    @Test\n    public void getPreferenceSummary_appOpAllowed_returnsAllowed() {\n        mShadowUserManager.addUser(\n                PERSONAL_PROFILE_ID, \"personal-profile\"/* name */, 0/* flags */);\n        mShadowUserManager.addProfile(\n                PERSONAL_PROFILE_ID, WORK_PROFILE_ID,\n                \"work-profile\"/* profileName */, UserInfo.FLAG_MANAGED_PROFILE);"}
{"magic_number_smell": "    public void getAvailabilityStatus_requestedCrossProfilePermission_returnsAvailable() {\n        mController.setPackageName(CROSS_PROFILE_PACKAGE_NAME);\n        mShadowPackageManager.setInstalledPackagesForUserId(\n                0, ImmutableList.of(CROSS_PROFILE_PACKAGE_NAME));\n        ShadowCrossProfileApps shadowCrossProfileApps = (ShadowCrossProfileApps) shadowOf(\n                mContext.getSystemService(CrossProfileApps.class)\n        );", "refactored_code": "    private static final int PROFILE_ID = 0;\n    public void getAvailabilityStatus_requestedCrossProfilePermission_returnsAvailable() {\n        mController.setPackageName(CROSS_PROFILE_PACKAGE_NAME);\n        mShadowPackageManager.setInstalledPackagesForUserId(\n                PROFILE_ID, ImmutableList.of(CROSS_PROFILE_PACKAGE_NAME));\n        ShadowCrossProfileApps shadowCrossProfileApps = (ShadowCrossProfileApps) shadowOf(\n                mContext.getSystemService(CrossProfileApps.class)\n        );"}
{"magic_number_smell": "    @Test\n    public void collectConfigurableApps_fromPersonal_returnsCombinedPackages() {\n        mShadowUserManager.addUser(\n                0, \"personal-profile\"/* name */, 0/* flags */);\n        mShadowUserManager.addProfile(\n                0, WORK_PROFILE_ID,\n                \"work-profile\"/* profileName */, UserInfo.FLAG_MANAGED_PROFILE);", "refactored_code": "    private static final int PERSONAL_PROFILE_ID = 0;\n    @Test\n    public void collectConfigurableApps_fromPersonal_returnsCombinedPackages() {\n        mShadowUserManager.addUser(\n                PERSONAL_PROFILE_ID, \"personal-profile\"/* name */, 0/* flags */);\n        mShadowUserManager.addProfile(\n                PERSONAL_PROFILE_ID, WORK_PROFILE_ID,\n                \"work-profile\"/* profileName */, UserInfo.FLAG_MANAGED_PROFILE);"}
{"magic_number_smell": "        mFragment = new PictureInPictureSettings(mPackageManager, mUserManager);\n        mPrimaryUserPackages = new ArrayList<>();\n        mProfileUserPackages = new ArrayList<>();\n        when(mPackageManager.getInstalledPackagesAsUser(anyInt(), eq(0)))\n                .thenReturn(mPrimaryUserPackages);\n        when(mPackageManager.getInstalledPackagesAsUser(anyInt(), eq(PROFILE_USER_ID)))\n                .thenReturn(mProfileUserPackages);", "refactored_code": "    private static final int PRIMARY_USER_ID = 0;\n        mFragment = new PictureInPictureSettings(mPackageManager, mUserManager);\n        mPrimaryUserPackages = new ArrayList<>();\n        mProfileUserPackages = new ArrayList<>();\n        when(mPackageManager.getInstalledPackagesAsUser(anyInt(), eq(PRIMARY_USER_ID)))\n                .thenReturn(mPrimaryUserPackages);\n        when(mPackageManager.getInstalledPackagesAsUser(anyInt(), eq(PROFILE_USER_ID)))\n                .thenReturn(mProfileUserPackages);"}
{"magic_number_smell": "        mFingerprintIntent = new Intent(mContext, FingerprintEnrollIntroduction.class);\n        mFaceIntent = new Intent(mContext, FaceEnrollIntroduction.class);\n        mMultiBiometricEnrollHelper = new MultiBiometricEnrollHelper(\n                mActivity, 10, true /* enrollFace */, true /* enrollFingerprint */,\n                mGkPwHandle, mFingerprintManager, mFaceManager, mFingerprintIntent, mFaceIntent,\n                (challenge) -> null);\n    }", "refactored_code": "    private final int mUserId = 10;\n        mFingerprintIntent = new Intent(mContext, FingerprintEnrollIntroduction.class);\n        mFaceIntent = new Intent(mContext, FaceEnrollIntroduction.class);\n        mMultiBiometricEnrollHelper = new MultiBiometricEnrollHelper(\n                mActivity, mUserId, true /* enrollFace */, true /* enrollFingerprint */,\n                mGkPwHandle, mFingerprintManager, mFaceManager, mFingerprintIntent, mFaceIntent,\n                (challenge) -> null);\n    }"}
{"magic_number_smell": "\n        mActivity.onEnrollmentProgressChange(initStageSteps, initStageRemaining);\n\n        when(mSidecar.getEnrollmentSteps()).thenReturn(25);\n\n        for (int remaining = 25; remaining > 0; remaining--) {\n            when(mSidecar.getEnrollmentRemaining()).thenReturn(remaining);", "refactored_code": "    private static final int TOTAL_ENROLL_STEPS = 25;\n\n        mActivity.onEnrollmentProgressChange(initStageSteps, initStageRemaining);\n\n        when(mSidecar.getEnrollmentSteps()).thenReturn(TOTAL_ENROLL_STEPS);\n\n        for (int remaining = TOTAL_ENROLL_STEPS; remaining > 0; remaining--) {\n            when(mSidecar.getEnrollmentRemaining()).thenReturn(remaining);"}
{"magic_number_smell": "        mActivityController.pause().stop();\n\n        // onStop shall not change default activity result\n        assertThat(Shadows.shadowOf(mActivity).getResultCode()).isEqualTo(Activity.RESULT_CANCELED);\n\n        gotEnrollingResult_resumeActivityAndVerifyResultThenForward(RESULT_FINISHED);\n    }", "refactored_code": "    private static final int DEFAULT_ACTIVITY_RESULT = Activity.RESULT_CANCELED;\n        mActivityController.pause().stop();\n\n        // onStop shall not change default activity result\n        assertThat(Shadows.shadowOf(mActivity).getResultCode()).isEqualTo(DEFAULT_ACTIVITY_RESULT);\n\n        gotEnrollingResult_resumeActivityAndVerifyResultThenForward(RESULT_FINISHED);\n    }"}
{"magic_number_smell": "                new FingerprintSensorPropertiesInternal(\n                        0 /* sensorId */,\n                        SensorProperties.STRENGTH_STRONG,\n                        5 /* maxEnrollmentsPerUser */,\n                        componentInfo,\n                        FingerprintSensorProperties.TYPE_REAR,\n                        true /* resetLockoutRequiresHardwareAuthToken */);", "refactored_code": "    private static final int MAX_ENROLLMENTS = 5;\n                new FingerprintSensorPropertiesInternal(\n                        0 /* sensorId */,\n                        SensorProperties.STRENGTH_STRONG,\n                        MAX_ENROLLMENTS /* maxEnrollmentsPerUser */,\n                        componentInfo,\n                        FingerprintSensorProperties.TYPE_REAR,\n                        true /* resetLockoutRequiresHardwareAuthToken */);"}
{"magic_number_smell": "\n    @Test\n    public void getUserId_shouldReturnProfileId() {\n        assertThat(mController.getUserId()).isEqualTo(1234);\n    }\n\n    @Test", "refactored_code": "    private static final int FAKE_PROFILE_USER_ID = 1234;\n\n    @Test\n    public void getUserId_shouldReturnProfileId() {\n        assertThat(mController.getUserId()).isEqualTo(FAKE_PROFILE_USER_ID);\n    }\n\n    @Test"}
{"magic_number_smell": "                mContext.getContentResolver(),\n                Settings.Secure.SFPS_PERFORMANT_AUTH_ENABLED,\n                0,\n                UserHandle.of(0).getIdentifier());\n\n        Settings.Secure.putIntForUser(\n                mContext.getContentResolver(),", "refactored_code": "    private static final int PRIMARY_USER_ID = 0;\n                mContext.getContentResolver(),\n                Settings.Secure.SFPS_PERFORMANT_AUTH_ENABLED,\n                0,\n                UserHandle.of(PRIMARY_USER_ID).getIdentifier());\n\n        Settings.Secure.putIntForUser(\n                mContext.getContentResolver(),"}
{"magic_number_smell": "\n    @Test\n    public void showsHelpMessageAfterCollectTime() {\n        when(mClock.millis()).thenReturn(0L);\n\n        mMessageDisplayController.onEnrollmentHelp(HELP_ID, HELP_MESSAGE);\n        when(mClock.millis()).thenReturn((long) COLLECT_TIME);", "refactored_code": "    private static final long START_TIME = 0L;\n\n    @Test\n    public void showsHelpMessageAfterCollectTime() {\n        when(mClock.millis()).thenReturn(START_TIME);\n\n        mMessageDisplayController.onEnrollmentHelp(HELP_ID, HELP_MESSAGE);\n        when(mClock.millis()).thenReturn((long) COLLECT_TIME);"}
{"magic_number_smell": "\n    @Test\n    public void createBatteryIcon_hasCorrectInfo() {\n        final Drawable drawable = mController.createBtBatteryIcon(mContext, 30,\n                true /* charging */);\n        assertThat(drawable).isInstanceOf(BatteryMeterView.BatteryMeterDrawable.class);\n", "refactored_code": "    private static final int BATTERY_LEVEL_MAIN = 30;\n\n    @Test\n    public void createBatteryIcon_hasCorrectInfo() {\n        final Drawable drawable = mController.createBtBatteryIcon(mContext, BATTERY_LEVEL_MAIN,\n                true /* charging */);\n        assertThat(drawable).isInstanceOf(BatteryMeterView.BatteryMeterDrawable.class);\n"}
{"magic_number_smell": "\n    @Test\n    public void isAvailable_noAssociations_returnsFalse() {\n        mController.mAssociationId = -1;\n        assertThat(mController.isAvailable()).isFalse();\n    }\n", "refactored_code": "    private static final int DUMMY_ASSOCIATION_ID = -1;\n\n    @Test\n    public void isAvailable_noAssociations_returnsFalse() {\n        mController.mAssociationId = DUMMY_ASSOCIATION_ID;\n        assertThat(mController.isAvailable()).isFalse();\n    }\n"}
{"magic_number_smell": "    @Test\n    public void testCreateBluetoothDeviceNamePreference() {\n        Preference preference =\n            mController.createBluetoothDeviceNamePreference(mPreferenceScreen, 1);\n\n        assertThat(preference.getKey()).isEqualTo(mController.getPreferenceKey());\n        assertThat(preference.getOrder()).isEqualTo(1);", "refactored_code": "    private static final int ORDER = 1;\n    @Test\n    public void testCreateBluetoothDeviceNamePreference() {\n        Preference preference =\n            mController.createBluetoothDeviceNamePreference(mPreferenceScreen, ORDER);\n\n        assertThat(preference.getKey()).isEqualTo(mController.getPreferenceKey());\n        assertThat(preference.getOrder()).isEqualTo(ORDER);"}
{"magic_number_smell": "\n    @Test\n    public void getBluetoothDeviceControlUri_returnsCorrectUri() {\n        when(mBluetoothDevice.getMetadata(25)).thenReturn(\n                CONTROL_METADATA.getBytes());\n        assertThat(\n                mBluetoothFeatureProvider.getBluetoothDeviceControlUri(mBluetoothDevice)).isEqualTo(", "refactored_code": "    private static final int METADATA_FAST_PAIR_CUSTOMIZED_FIELDS = 25;\n\n    @Test\n    public void getBluetoothDeviceControlUri_returnsCorrectUri() {\n        when(mBluetoothDevice.getMetadata(METADATA_FAST_PAIR_CUSTOMIZED_FIELDS)).thenReturn(\n                CONTROL_METADATA.getBytes());\n        assertThat(\n                mBluetoothFeatureProvider.getBluetoothDeviceControlUri(mBluetoothDevice)).isEqualTo("}
{"magic_number_smell": "\n    @Test\n    public void testCreateBluetoothPairingPreference() {\n        Preference pref = mController.createBluetoothPairingPreference(1);\n\n        assertThat(pref.getKey()).isEqualTo(BluetoothPairingPreferenceController.KEY_PAIRING);\n        DrawableTestHelper.assertDrawableResId(pref.getIcon(), R.drawable.ic_add_24dp);", "refactored_code": "    private static final int ORDER = 1;\n\n    @Test\n    public void testCreateBluetoothPairingPreference() {\n        Preference pref = mController.createBluetoothPairingPreference(ORDER);\n\n        assertThat(pref.getKey()).isEqualTo(BluetoothPairingPreferenceController.KEY_PAIRING);\n        DrawableTestHelper.assertDrawableResId(pref.getIcon(), R.drawable.ic_add_24dp);"}
{"magic_number_smell": "    private void testClickingItemSuccess() {\n        when(mBugReportHandlerUtil.getValidBugReportHandlerInfos(any()))\n                .thenReturn(Collections.singletonList(Pair.create(\n                        createApplicationInfo(PACKAGE_NAME), 0)));\n        when(mBugReportHandlerUtil.setCurrentBugReportHandlerAppAndUser(any(), eq(PACKAGE_NAME),\n                eq(0))).thenReturn(true);\n", "refactored_code": "    private static final int USER_ID = 0;\n    private void testClickingItemSuccess() {\n        when(mBugReportHandlerUtil.getValidBugReportHandlerInfos(any()))\n                .thenReturn(Collections.singletonList(Pair.create(\n                        createApplicationInfo(PACKAGE_NAME), USER_ID)));\n        when(mBugReportHandlerUtil.setCurrentBugReportHandlerAppAndUser(any(), eq(PACKAGE_NAME),\n                eq(USER_ID))).thenReturn(true);\n"}
{"magic_number_smell": "\n        @Override\n        public int getMax() {\n            return 2112;\n        }\n\n        @Override", "refactored_code": "        private final int MAX_STEPS = 2112;\n\n        @Override\n        public int getMax() {\n            return MAX_STEPS;\n        }\n\n        @Override"}
{"magic_number_smell": "    @Before\n    public void setUp() {\n        when(mContext.getSystemService(UserManager.class)).thenReturn(mUserManager);\n        when(mUserManager.getUserInfo(UserHandle.myUserId())).thenReturn(mPersonalUserInfo);\n        when(mUserManager.getUserInfo(WORK_USER_ID)).thenReturn(mWorkUserInfo);\n    }\n", "refactored_code": "    private final int mPersonalUserId = UserHandle.myUserId();\n    @Before\n    public void setUp() {\n        when(mContext.getSystemService(UserManager.class)).thenReturn(mUserManager);\n        when(mUserManager.getUserInfo(mPersonalUserId)).thenReturn(mPersonalUserInfo);\n        when(mUserManager.getUserInfo(WORK_USER_ID)).thenReturn(mWorkUserInfo);\n    }\n"}
{"magic_number_smell": "        when(mMockBillingCycleSettings.getPreferenceManager()).thenReturn(mMockPreferenceManager);\n        when(mMockPreferenceManager.getSharedPreferences()).thenReturn(mSharedPreferences);\n        final Bundle args = new Bundle();\n        args.putLong(BillingCycleSettings.ConfirmLimitFragment.EXTRA_LIMIT_BYTES, 123);\n        mConfirmLimitFragment.setArguments(args);\n        mSharedPreferences.edit().putBoolean(\n                BillingCycleSettings.KEY_SET_DATA_LIMIT, false).apply();", "refactored_code": "    private static final int LIMIT_BYTES = 123;\n        when(mMockBillingCycleSettings.getPreferenceManager()).thenReturn(mMockPreferenceManager);\n        when(mMockPreferenceManager.getSharedPreferences()).thenReturn(mSharedPreferences);\n        final Bundle args = new Bundle();\n        args.putLong(BillingCycleSettings.ConfirmLimitFragment.EXTRA_LIMIT_BYTES, LIMIT_BYTES);\n        mConfirmLimitFragment.setArguments(args);\n        mSharedPreferences.edit().putBoolean(\n                BillingCycleSettings.KEY_SET_DATA_LIMIT, false).apply();"}
{"magic_number_smell": "        mNetworkCycleData.add(new NetworkUsageData(1521676800000L, 1521678800000L, 29947L));\n\n        mNetworkCycleChartData = new NetworkCycleChartData(\n                new NetworkUsageData(1521583200000L, TIMESTAMP_END, 0),\n                mNetworkCycleData\n        );\n    }", "refactored_code": "    private static final long TIMESTAMP_START = 1521583200000L;\n        mNetworkCycleData.add(new NetworkUsageData(1521676800000L, 1521678800000L, 29947L));\n\n        mNetworkCycleChartData = new NetworkCycleChartData(\n                new NetworkUsageData(TIMESTAMP_START, TIMESTAMP_END, 0),\n                mNetworkCycleData\n        );\n    }"}
{"magic_number_smell": "        final DataUsageController.DataUsageInfo info = createTestDataUsageInfo(now);\n\n        doReturn(info).when(mDataUsageController).getDataUsageInfo(any());\n        setupTestDataUsage(LIMIT1, USAGE1, now - TimeUnit.MINUTES.toMillis(13));\n        createTestDataPlan(info.cycleStart, info.cycleEnd);\n\n        mController.updateState(mSummaryPreference);", "refactored_code": "    private static final long UPDATE_BACKOFF_MS = TimeUnit.MINUTES.toMillis(13);\n        final DataUsageController.DataUsageInfo info = createTestDataUsageInfo(now);\n\n        doReturn(info).when(mDataUsageController).getDataUsageInfo(any());\n        setupTestDataUsage(LIMIT1, USAGE1, now - UPDATE_BACKOFF_MS);\n        createTestDataPlan(info.cycleStart, info.cycleEnd);\n\n        mController.updateState(mSummaryPreference);"}
{"magic_number_smell": "            super.onCreate(bundle);\n\n            FragmentContainerView contentView = new FragmentContainerView(this);\n            contentView.setId(1234);\n            setContentView(contentView);\n        }\n    }", "refactored_code": "        private static final int CONTAINER_VIEW_ID = 1234;\n            super.onCreate(bundle);\n\n            FragmentContainerView contentView = new FragmentContainerView(this);\n            contentView.setId(CONTAINER_VIEW_ID);\n            setContentView(contentView);\n        }\n    }"}
{"magic_number_smell": "    @Test\n    public void updateState_settingEnabled_preferenceShouldBeChecked() {\n        Settings.Global.putInt(mContext.getContentResolver(),\n                Settings.Global.ALWAYS_FINISH_ACTIVITIES, 1);\n        mController.updateState(mPreference);\n\n        verify(mPreference).setChecked(true);", "refactored_code": "    private static final int SETTING_VALUE_ON = 1;\n    @Test\n    public void updateState_settingEnabled_preferenceShouldBeChecked() {\n        Settings.Global.putInt(mContext.getContentResolver(),\n                Settings.Global.ALWAYS_FINISH_ACTIVITIES, SETTING_VALUE_ON);\n        mController.updateState(mPreference);\n\n        verify(mPreference).setChecked(true);"}
{"magic_number_smell": "    public void onPreferenceChange_off() throws Exception {\n        mHelper.setLoggingLevel(108);\n\n        mController.onPreferenceChange(mPreference, mListValues[0]);\n\n        assertThat(mHelper.getLoggingLevel()).isEqualTo(AutofillManager.NO_LOGGING);\n    }", "refactored_code": "    private static final int IDX_OFF = 0;\n    public void onPreferenceChange_off() throws Exception {\n        mHelper.setLoggingLevel(108);\n\n        mController.onPreferenceChange(mPreference, mListValues[IDX_OFF]);\n\n        assertThat(mHelper.getLoggingLevel()).isEqualTo(AutofillManager.NO_LOGGING);\n    }"}
{"magic_number_smell": "        mContext = RuntimeEnvironment.application;\n        mPreference = spy(new BaseBluetoothDialogPreferenceImpl(mContext));\n        mRadioButton1 = new RadioButton(mContext);\n        mRadioButton1.setId(99);\n        mRadioButton2 = new RadioButton(mContext);\n        mRadioButton2.setId(ID2);\n        mRadioGroup = new RadioGroup(mContext);", "refactored_code": "    private static final int ID1 = 99;\n        mContext = RuntimeEnvironment.application;\n        mPreference = spy(new BaseBluetoothDialogPreferenceImpl(mContext));\n        mRadioButton1 = new RadioButton(mContext);\n        mRadioButton1.setId(ID1);\n        mRadioButton2 = new RadioButton(mContext);\n        mRadioButton2.setId(ID2);\n        mRadioGroup = new RadioGroup(mContext);"}
{"magic_number_smell": "        assertThat(preference.getDialogTitle()).isEqualTo(mDialogTitle);\n        assertThat(preference.getEntries()).isEqualTo(mValueList);\n        assertThat(preference.getEntryValues()).isEqualTo(mValueList);\n        assertThat(preference.getEntry()).isEqualTo(mValueList[0]);\n        assertThat(preference.getValue()).isEqualTo(mValueList[0]);\n        assertThat(preference.getSummary()).isEqualTo(mValueList[0]);\n    }", "refactored_code": "    private static final int DEFAULT = 0;\n        assertThat(preference.getDialogTitle()).isEqualTo(mDialogTitle);\n        assertThat(preference.getEntries()).isEqualTo(mValueList);\n        assertThat(preference.getEntryValues()).isEqualTo(mValueList);\n        assertThat(preference.getEntry()).isEqualTo(mValueList[DEFAULT]);\n        assertThat(preference.getValue()).isEqualTo(mValueList[DEFAULT]);\n        assertThat(preference.getSummary()).isEqualTo(mValueList[DEFAULT]);\n    }"}
{"magic_number_smell": "        final PackageManager packageManager = mock(PackageManager.class);\n        doReturn(packageManager).when(userContext).getPackageManager();\n\n        final AppEntry entry = createAppEntry(TEST_PACKAGE, 1234, TEST_USER_ID);\n        final QuarantinedAppPreference preference = new QuarantinedAppPreference(mContext, entry);\n\n        mController.onPreferenceChange(preference, true);", "refactored_code": "    private static final int TEST_APP_ID = 1234;\n        final PackageManager packageManager = mock(PackageManager.class);\n        doReturn(packageManager).when(userContext).getPackageManager();\n\n        final AppEntry entry = createAppEntry(TEST_PACKAGE, TEST_APP_ID, TEST_USER_ID);\n        final QuarantinedAppPreference preference = new QuarantinedAppPreference(mContext, entry);\n\n        mController.onPreferenceChange(preference, true);"}
{"magic_number_smell": "        stm.setTelephonyManagerForSubscriptionId(SUB_ID, mTelephonyManager);\n        when(mDialog.getContext()).thenReturn(mContext);\n\n        mController = spy(new ImeiInfoDialogController(mDialog, 0));\n\n        when(mTelephonyManager.getCdmaPrlVersion()).thenReturn(PRL_VERSION);\n        when(mTelephonyManager.getMeid(anyInt())).thenReturn(MEID_NUMBER);", "refactored_code": "    private static final int SLOT_ID = 0;\n        stm.setTelephonyManagerForSubscriptionId(SUB_ID, mTelephonyManager);\n        when(mDialog.getContext()).thenReturn(mContext);\n\n        mController = spy(new ImeiInfoDialogController(mDialog, SLOT_ID));\n\n        when(mTelephonyManager.getCdmaPrlVersion()).thenReturn(PRL_VERSION);\n        when(mTelephonyManager.getMeid(anyInt())).thenReturn(MEID_NUMBER);"}
{"magic_number_smell": "\n        StorageCacheHelper.StorageCache storageCache = mHelper.retrieveCachedSize();\n\n        assertThat(storageCache.imagesSize).isEqualTo(7000L);\n        assertThat(storageCache.totalSize).isEqualTo(0);\n    }\n", "refactored_code": "    private static final long FAKE_IMAGES_SIZE = 7000L;\n\n        StorageCacheHelper.StorageCache storageCache = mHelper.retrieveCachedSize();\n\n        assertThat(storageCache.imagesSize).isEqualTo(FAKE_IMAGES_SIZE);\n        assertThat(storageCache.totalSize).isEqualTo(0);\n    }\n"}
{"magic_number_smell": "\n        @Override\n        int getCurrentUserId() {\n            return 10;\n        }\n    }\n}", "refactored_code": "        private static final int CURRENT_USER_ID = 10;\n\n        @Override\n        int getCurrentUserId() {\n            return CURRENT_USER_ID;\n        }\n    }\n}"}
{"magic_number_smell": "    @Test\n    public void createPreferenceControllers_settableDeviceStates_returnsDeviceStateControllers() {\n        enableDeviceStateSettableRotationStates(\n                new String[]{0 + \":\" + DEVICE_STATE_ROTATION_LOCK_LOCKED,\n                        UNFOLDED_STATE + \":\" + DEVICE_STATE_ROTATION_LOCK_LOCKED},\n                new String[]{\"Folded\", \"Unfolded\"});\n", "refactored_code": "    private static final int FOLDED_STATE = 0;\n    @Test\n    public void createPreferenceControllers_settableDeviceStates_returnsDeviceStateControllers() {\n        enableDeviceStateSettableRotationStates(\n                new String[]{FOLDED_STATE + \":\" + DEVICE_STATE_ROTATION_LOCK_LOCKED,\n                        UNFOLDED_STATE + \":\" + DEVICE_STATE_ROTATION_LOCK_LOCKED},\n                new String[]{\"Folded\", \"Unfolded\"});\n"}
{"magic_number_smell": "\n        mController = new DeviceStateAutoRotateSettingController(\n                mContext,\n                1,\n                DEFAULT_DEVICE_STATE_DESCRIPTION,\n                DEFAULT_ORDER,\n                mMetricsFeatureProvider", "refactored_code": "    private static final int DEFAULT_DEVICE_STATE = 1;\n\n        mController = new DeviceStateAutoRotateSettingController(\n                mContext,\n                DEFAULT_DEVICE_STATE,\n                DEFAULT_DEVICE_STATE_DESCRIPTION,\n                DEFAULT_ORDER,\n                mMetricsFeatureProvider"}
{"magic_number_smell": "                .thenReturn(mRotateMainSwitchPreference);\n\n        when(mResources.getIntArray(com.android.internal.R.array.config_foldedDeviceStates))\n                .thenReturn(new int[] {0});\n        when(mResources.getIntArray(com.android.internal.R.array.config_halfFoldedDeviceStates))\n                .thenReturn(new int[] {STATE_HALF_FOLDED});\n        when(mResources.getIntArray(com.android.internal.R.array.config_openDeviceStates))", "refactored_code": "    private static final int STATE_FOLDED = 0;\n                .thenReturn(mRotateMainSwitchPreference);\n\n        when(mResources.getIntArray(com.android.internal.R.array.config_foldedDeviceStates))\n                .thenReturn(new int[] {STATE_FOLDED});\n        when(mResources.getIntArray(com.android.internal.R.array.config_halfFoldedDeviceStates))\n                .thenReturn(new int[] {STATE_HALF_FOLDED});\n        when(mResources.getIntArray(com.android.internal.R.array.config_openDeviceStates))"}
{"magic_number_smell": "            new ComponentName(\"some.package.name\", \"some.package.name.SomeClass\");\n    private static final int 123 = 123;\n    private static final EnforcedAdmin ENFORCED_ADMIN =\n            new EnforcedAdmin(ADMIN_COMPONENT, new UserHandle(123));\n    private ActionDisabledByAdminDialogHelper mHelper;\n    private Activity mActivity;\n    private org.robolectric.shadows.ShadowActivity mActivityShadow;", "refactored_code": "    private static final int USER_ID = 123;\n            new ComponentName(\"some.package.name\", \"some.package.name.SomeClass\");\n    private static final int USER_ID = 123;\n    private static final EnforcedAdmin ENFORCED_ADMIN =\n            new EnforcedAdmin(ADMIN_COMPONENT, new UserHandle(USER_ID));\n    private ActionDisabledByAdminDialogHelper mHelper;\n    private Activity mActivity;\n    private org.robolectric.shadows.ShadowActivity mActivityShadow;"}
{"magic_number_smell": "        @Override\n        public void buildApplicationList(Context context,\n                ApplicationFeatureProvider.ListOfAppsCallback callback) {\n            final UserInfo user = new UserInfo(0, \"main\", UserInfo.FLAG_ADMIN);\n            final List<UserAppInfo> apps = new ArrayList<>();\n            apps.add(new UserAppInfo(user, buildInfo(USER_APP_UID, APP, 0, 0)));\n            callback.onListOfAppsResult(apps);", "refactored_code": "    private static final int USER_ID = 0;\n        @Override\n        public void buildApplicationList(Context context,\n                ApplicationFeatureProvider.ListOfAppsCallback callback) {\n            final UserInfo user = new UserInfo(USER_ID, \"main\", UserInfo.FLAG_ADMIN);\n            final List<UserAppInfo> apps = new ArrayList<>();\n            apps.add(new UserAppInfo(user, buildInfo(USER_APP_UID, APP, 0, 0)));\n            callback.onListOfAppsResult(apps);"}
{"magic_number_smell": "\n    private static final int MANAGED_PROFILE_ID = 10;\n    private static final int PER_USER_UID_RANGE = 100000;\n    private static final int MAIN_USER_APP_UID = 0 * PER_USER_UID_RANGE;\n    private static final int MANAGED_PROFILE_APP_UID = MANAGED_PROFILE_ID * PER_USER_UID_RANGE;\n\n    private static final String APP_1 = \"APP_1\";", "refactored_code": "    private static final int MAIN_USER_ID = 0;\n\n    private static final int MANAGED_PROFILE_ID = 10;\n    private static final int PER_USER_UID_RANGE = 100000;\n    private static final int MAIN_USER_APP_UID = MAIN_USER_ID * PER_USER_UID_RANGE;\n    private static final int MANAGED_PROFILE_APP_UID = MANAGED_PROFILE_ID * PER_USER_UID_RANGE;\n\n    private static final String APP_1 = \"APP_1\";"}
{"magic_number_smell": "    private final ComponentName mAdmin2 = new ComponentName(\"mock\", \"admin2\");\n    private final Date mDate = new Date(2011, 11, 11);\n    private final int UserHandle.myUserId() = UserHandle.myUserId();\n    private final int mManagedProfileUserId = UserHandle.myUserId() + 1;\n\n    private List<UserInfo> mProfiles = new ArrayList<>();\n", "refactored_code": "    private final int mUserId = UserHandle.myUserId();\n    private final ComponentName mAdmin2 = new ComponentName(\"mock\", \"admin2\");\n    private final Date mDate = new Date(2011, 11, 11);\n    private final int mUserId = UserHandle.myUserId();\n    private final int mManagedProfileUserId = mUserId + 1;\n\n    private List<UserInfo> mProfiles = new ArrayList<>();\n"}
{"magic_number_smell": "            super.onCreate(bundle);\n\n            FrameLayout frameLayout = new FrameLayout(this);\n            frameLayout.setId(1234);\n\n            // Need to set the Theme.AppCompat theme (or descendant) with this activity, otherwise\n            // a {@link IllegalStateException} is thrown when setting the content view.", "refactored_code": "        private static final int CONTAINER_VIEW_ID = 1234;\n            super.onCreate(bundle);\n\n            FrameLayout frameLayout = new FrameLayout(this);\n            frameLayout.setId(CONTAINER_VIEW_ID);\n\n            // Need to set the Theme.AppCompat theme (or descendant) with this activity, otherwise\n            // a {@link IllegalStateException} is thrown when setting the content view."}
{"magic_number_smell": "\n    @Test\n    public void testMultipleAppsForOneTypeOfDefault() {\n        final UserInfo user = new UserInfo(0, \"main\", UserInfo.FLAG_ADMIN);\n        final ApplicationInfo appInfo1 = ApplicationTestUtils.buildInfo(APP_UID, APP_1, 0, 0);\n        final ApplicationInfo appInfo2 = ApplicationTestUtils.buildInfo(APP_UID, APP_2, 0, 0);\n", "refactored_code": "    private static final int USER_ID = 0;\n\n    @Test\n    public void testMultipleAppsForOneTypeOfDefault() {\n        final UserInfo user = new UserInfo(USER_ID, \"main\", UserInfo.FLAG_ADMIN);\n        final ApplicationInfo appInfo1 = ApplicationTestUtils.buildInfo(APP_UID, APP_1, 0, 0);\n        final ApplicationInfo appInfo2 = ApplicationTestUtils.buildInfo(APP_UID, APP_2, 0, 0);\n"}
{"magic_number_smell": "        when(mBatteryEntry.getTimeInForegroundMs()).thenReturn(FOREGROUND_TIME_MS);\n        when(mBatteryEntry.getTimeInForegroundServiceMs()).thenReturn(FOREGROUND_SERVICE_TIME_MS);\n        when(mBatteryEntry.getTimeInBackgroundMs()).thenReturn(BACKGROUND_TIME_MS);\n        mBatteryEntry.mIconId = 123;\n\n        mBatteryDiffEntry =\n                spy(", "refactored_code": "    private static final int ICON_ID = 123;\n        when(mBatteryEntry.getTimeInForegroundMs()).thenReturn(FOREGROUND_TIME_MS);\n        when(mBatteryEntry.getTimeInForegroundServiceMs()).thenReturn(FOREGROUND_SERVICE_TIME_MS);\n        when(mBatteryEntry.getTimeInBackgroundMs()).thenReturn(BACKGROUND_TIME_MS);\n        mBatteryEntry.mIconId = ICON_ID;\n\n        mBatteryDiffEntry =\n                spy("}
{"magic_number_smell": "\n        Context context = spy(RuntimeEnvironment.application);\n        BatteryUtils.getInstance(context).reset();\n        doReturn(12345)\n                .when(mMockPackageManager)\n                .getPackageUid(PACKAGE_NAME, PackageManager.GET_META_DATA);\n", "refactored_code": "    private static final int UID = 12345;\n\n        Context context = spy(RuntimeEnvironment.application);\n        BatteryUtils.getInstance(context).reset();\n        doReturn(UID)\n                .when(mMockPackageManager)\n                .getPackageUid(PACKAGE_NAME, PackageManager.GET_META_DATA);\n"}
{"magic_number_smell": "\n    @Test\n    public void testUpdateState_AutoRestrictionOn_preferenceChecked() {\n        putAutoRestrictionValue(1);\n\n        mController.updateState(mPreference);\n", "refactored_code": "    private static final int ON = 1;\n\n    @Test\n    public void testUpdateState_AutoRestrictionOn_preferenceChecked() {\n        putAutoRestrictionValue(ON);\n\n        mController.updateState(mPreference);\n"}
{"magic_number_smell": "    @Test\n    public void backupOptimizationMode_backupOptimizationMode() throws Exception {\n        final List<String> allowlistedApps = Arrays.asList(PACKAGE_NAME1);\n        createTestingData(PACKAGE_NAME1, 1, PACKAGE_NAME2, PACKAGE_NAME3);\n\n        mBatteryBackupHelper.backupOptimizationMode(mBackupDataOutput, allowlistedApps);\n", "refactored_code": "    private static final int UID1 = 1;\n    @Test\n    public void backupOptimizationMode_backupOptimizationMode() throws Exception {\n        final List<String> allowlistedApps = Arrays.asList(PACKAGE_NAME1);\n        createTestingData(PACKAGE_NAME1, UID1, PACKAGE_NAME2, PACKAGE_NAME3);\n\n        mBatteryBackupHelper.backupOptimizationMode(mBackupDataOutput, allowlistedApps);\n"}
{"magic_number_smell": "        mBatteryBroadcastReceiver.setBatteryChangedListener(mBatteryListener);\n\n        mChargingIntent = new Intent(Intent.ACTION_BATTERY_CHANGED);\n        mChargingIntent.putExtra(BatteryManager.EXTRA_LEVEL, 80);\n        mChargingIntent.putExtra(BatteryManager.EXTRA_SCALE, BATTERY_INTENT_SCALE);\n        mChargingIntent.putExtra(\n                BatteryManager.EXTRA_STATUS, BatteryManager.BATTERY_STATUS_CHARGING);", "refactored_code": "    private static final int BATTERY_INTENT_LEVEL = 80;\n        mBatteryBroadcastReceiver.setBatteryChangedListener(mBatteryListener);\n\n        mChargingIntent = new Intent(Intent.ACTION_BATTERY_CHANGED);\n        mChargingIntent.putExtra(BatteryManager.EXTRA_LEVEL, BATTERY_INTENT_LEVEL);\n        mChargingIntent.putExtra(BatteryManager.EXTRA_SCALE, BATTERY_INTENT_SCALE);\n        mChargingIntent.putExtra(\n                BatteryManager.EXTRA_STATUS, BatteryManager.BATTERY_STATUS_CHARGING);"}
{"magic_number_smell": "        ShadowEntityHeaderController.setUseMock(mEntityHeaderController);\n\n        mBatteryIntent = new Intent();\n        mBatteryIntent.putExtra(BatteryManager.EXTRA_LEVEL, 60);\n        mBatteryIntent.putExtra(BatteryManager.EXTRA_SCALE, 100);\n        mBatteryIntent.putExtra(BatteryManager.EXTRA_PLUGGED, 1);\n        doReturn(mBatteryIntent).when(mContext).registerReceiver(any(), any());", "refactored_code": "    private static final int BATTERY_LEVEL = 60;\n        ShadowEntityHeaderController.setUseMock(mEntityHeaderController);\n\n        mBatteryIntent = new Intent();\n        mBatteryIntent.putExtra(BatteryManager.EXTRA_LEVEL, BATTERY_LEVEL);\n        mBatteryIntent.putExtra(BatteryManager.EXTRA_SCALE, 100);\n        mBatteryIntent.putExtra(BatteryManager.EXTRA_PLUGGED, 1);\n        doReturn(mBatteryIntent).when(mContext).registerReceiver(any(), any());"}
{"magic_number_smell": "        doReturn(mContext).when(mContext).getApplicationContext();\n        when(mContext.getSystemService(eq(Context.BATTERY_STATS_SERVICE)))\n                .thenReturn(mBatteryStatsManager);\n        when(mBatteryUsageStats.getBatteryTimeRemainingMs()).thenReturn(1000L);\n        when(mBatteryStatsManager.getBatteryUsageStats(any(BatteryUsageStatsQuery.class)))\n                .thenReturn(mBatteryUsageStats);\n", "refactored_code": "    private static final long TEST_TIME_REMAINING = 1000L;\n        doReturn(mContext).when(mContext).getApplicationContext();\n        when(mContext.getSystemService(eq(Context.BATTERY_STATS_SERVICE)))\n                .thenReturn(mBatteryStatsManager);\n        when(mBatteryUsageStats.getBatteryTimeRemainingMs()).thenReturn(TEST_TIME_REMAINING);\n        when(mBatteryStatsManager.getBatteryUsageStats(any(BatteryUsageStatsQuery.class)))\n                .thenReturn(mBatteryUsageStats);\n"}
{"magic_number_smell": "\n    @Test\n    public void testGetBatteryInfo_hasStatusLabel() {\n        doReturn(-1).when(mBatteryUsageStats).getBatteryTimeRemainingMs();\n        BatteryInfo info =\n                BatteryInfo.getBatteryInfoOld(\n                        mContext,", "refactored_code": "    private static final long REMAINING_TIME_NULL = -1;\n\n    @Test\n    public void testGetBatteryInfo_hasStatusLabel() {\n        doReturn(REMAINING_TIME_NULL).when(mBatteryUsageStats).getBatteryTimeRemainingMs();\n        BatteryInfo info =\n                BatteryInfo.getBatteryInfoOld(\n                        mContext,"}
{"magic_number_smell": "\n    @Test\n    public void testSetBatteryInfo_setCorrectly() {\n        mBatteryMeterView.setBatteryLevel(100);\n\n        assertThat(mDrawable.getBatteryLevel()).isEqualTo(100);\n    }", "refactored_code": "    private static final int BATTERY_LEVEL = 100;\n\n    @Test\n    public void testSetBatteryInfo_setCorrectly() {\n        mBatteryMeterView.setBatteryLevel(BATTERY_LEVEL);\n\n        assertThat(mDrawable.getBatteryLevel()).isEqualTo(BATTERY_LEVEL);\n    }"}
{"magic_number_smell": "    public void setUp() {\n        MockitoAnnotations.initMocks(this);\n        mContext = spy(RuntimeEnvironment.application);\n        mBatteryOptimizeUtils = spy(new BatteryOptimizeUtils(mContext, 12345, PACKAGE_NAME));\n        mBatteryOptimizeUtils.mAppOpsManager = mMockAppOpsManager;\n        mBatteryOptimizeUtils.mBatteryUtils = mMockBatteryUtils;\n        mBatteryOptimizeUtils.mPowerAllowListBackend = mMockBackend;", "refactored_code": "    private static final int UID = 12345;\n    public void setUp() {\n        MockitoAnnotations.initMocks(this);\n        mContext = spy(RuntimeEnvironment.application);\n        mBatteryOptimizeUtils = spy(new BatteryOptimizeUtils(mContext, UID, PACKAGE_NAME));\n        mBatteryOptimizeUtils.mAppOpsManager = mMockAppOpsManager;\n        mBatteryOptimizeUtils.mBatteryUtils = mMockBatteryUtils;\n        mBatteryOptimizeUtils.mPowerAllowListBackend = mMockBackend;"}
{"magic_number_smell": "        BatteryUtils.getInstance(mContext).reset();\n        doReturn(mContext).when(mContext).getApplicationContext();\n        doReturn(mPackageManager).when(mContext).getPackageManager();\n        doReturn(2003)\n                .when(mPackageManager)\n                .getPackageUid(PACKAGE_NAME, PackageManager.GET_META_DATA);\n        BatterySettingsMigrateChecker.sBatteryOptimizeUtils = mBatteryOptimizeUtils;", "refactored_code": "    private static final int UID = 2003;\n        BatteryUtils.getInstance(mContext).reset();\n        doReturn(mContext).when(mContext).getApplicationContext();\n        doReturn(mPackageManager).when(mContext).getPackageManager();\n        doReturn(UID)\n                .when(mPackageManager)\n                .getPackageUid(PACKAGE_NAME, PackageManager.GET_META_DATA);\n        BatterySettingsMigrateChecker.sBatteryOptimizeUtils = mBatteryOptimizeUtils;"}
{"magic_number_smell": "\n    // unit that used to converted ms to us\n    private static final long 1000 = 1000;\n    private static final long TIME_STATE_TOP = 1500 * 1000;\n    private static final long TIME_STATE_FOREGROUND_SERVICE = 2000 * 1000;\n    private static final long TIME_STATE_TOP_SLEEPING = 2500 * 1000;\n    private static final long TIME_STATE_FOREGROUND = 3000 * 1000;", "refactored_code": "    private static final long UNIT = 1000;\n\n    // unit that used to converted ms to us\n    private static final long UNIT = 1000;\n    private static final long TIME_STATE_TOP = 1500 * UNIT;\n    private static final long TIME_STATE_FOREGROUND_SERVICE = 2000 * UNIT;\n    private static final long TIME_STATE_TOP_SLEEPING = 2500 * UNIT;\n    private static final long TIME_STATE_FOREGROUND = 3000 * UNIT;"}
{"magic_number_smell": "        mFragment = spy(new HighPowerDetail());\n        mFragment.mBackend = mPowerAllowlistBackend;\n        mFragment.mBatteryUtils = mBatteryUtils;\n        mFragment.mPackageUid = 12000;\n        mFragment.mPackageName = TEST_PACKAGE;\n    }\n", "refactored_code": "    private static final int TEST_UID = 12000;\n        mFragment = spy(new HighPowerDetail());\n        mFragment.mBackend = mPowerAllowlistBackend;\n        mFragment.mBatteryUtils = mBatteryUtils;\n        mFragment.mPackageUid = TEST_UID;\n        mFragment.mPackageName = TEST_PACKAGE;\n    }\n"}
{"magic_number_smell": "\n        Context context = spy(RuntimeEnvironment.application);\n        BatteryUtils.getInstance(context).reset();\n        doReturn(12345)\n                .when(mMockPackageManager)\n                .getPackageUid(PACKAGE_NAME, PackageManager.GET_META_DATA);\n", "refactored_code": "    private static final int UID = 12345;\n\n        Context context = spy(RuntimeEnvironment.application);\n        BatteryUtils.getInstance(context).reset();\n        doReturn(UID)\n                .when(mMockPackageManager)\n                .getPackageUid(PACKAGE_NAME, PackageManager.GET_META_DATA);\n"}
{"magic_number_smell": "\n        when(mBatteryEntry.getUid()).thenReturn(UID);\n        when(mBatteryEntry.getLabel()).thenReturn(APP_LABEL);\n        mBatteryEntry.mIconId = 123;\n\n        mFragment.mHeaderPreference = mHeaderPreference;\n        mFragment.mState = mState;", "refactored_code": "    private static final int ICON_ID = 123;\n\n        when(mBatteryEntry.getUid()).thenReturn(UID);\n        when(mBatteryEntry.getLabel()).thenReturn(APP_LABEL);\n        mBatteryEntry.mIconId = ICON_ID;\n\n        mFragment.mHeaderPreference = mHeaderPreference;\n        mFragment.mState = mState;"}
{"magic_number_smell": "\n    @Test\n    public void testIsTypeSystem_uidOther_returnFalse() {\n        assertThat(mPowerFeatureProvider.isTypeSystem(Process.FIRST_APPLICATION_UID + 2, null)).isFalse();\n    }\n\n    @Test", "refactored_code": "    private static final int UID_OTHER = Process.FIRST_APPLICATION_UID + 2;\n\n    @Test\n    public void testIsTypeSystem_uidOther_returnFalse() {\n        assertThat(mPowerFeatureProvider.isTypeSystem(UID_OTHER, null)).isFalse();\n    }\n\n    @Test"}
{"magic_number_smell": "                        AppOpsManager.MODE_IGNORED,\n                        Collections.emptyMap()));\n        mAllowedPackageOps =\n                new AppOpsManager.PackageOps(ALLOWED_PACKAGE_NAME, 111, allowOps);\n        mRestrictedPackageOps =\n                new AppOpsManager.PackageOps(\n                        RESTRICTED_PACKAGE_NAME, RESTRICTED_UID, restrictedOps);", "refactored_code": "    private static final int ALLOWED_UID = 111;\n                        AppOpsManager.MODE_IGNORED,\n                        Collections.emptyMap()));\n        mAllowedPackageOps =\n                new AppOpsManager.PackageOps(ALLOWED_PACKAGE_NAME, ALLOWED_UID, allowOps);\n        mRestrictedPackageOps =\n                new AppOpsManager.PackageOps(\n                        RESTRICTED_PACKAGE_NAME, RESTRICTED_UID, restrictedOps);"}
{"magic_number_smell": "\n    private static final String PACKAGE_NAME = \"com.android.app\";\n    private static final int 10 = 10;\n    private static final int UID = UserHandle.getUid(10, 234);\n    private static final String APP_NAME = \"app\";\n\n    @Mock private PackageManager mPackageManager;", "refactored_code": "    private static final int USER_ID = 10;\n\n    private static final String PACKAGE_NAME = \"com.android.app\";\n    private static final int USER_ID = 10;\n    private static final int UID = UserHandle.getUid(USER_ID, 234);\n    private static final String APP_NAME = \"app\";\n\n    @Mock private PackageManager mPackageManager;"}
{"magic_number_smell": "\n    @Test\n    public void testUpdateState_smartBatteryOn_preferenceChecked() {\n        putSmartBatteryValue(1);\n\n        mController.updateState(mPreference);\n", "refactored_code": "    private static final int ON = 1;\n\n    @Test\n    public void testUpdateState_smartBatteryOn_preferenceChecked() {\n        putSmartBatteryValue(ON);\n\n        mController.updateState(mPreference);\n"}
{"magic_number_smell": "\n        Context context = spy(RuntimeEnvironment.application);\n        BatteryUtils.getInstance(context).reset();\n        doReturn(12345)\n                .when(mMockPackageManager)\n                .getPackageUid(PACKAGE_NAME, PackageManager.GET_META_DATA);\n", "refactored_code": "    private static final int UID = 12345;\n\n        Context context = spy(RuntimeEnvironment.application);\n        BatteryUtils.getInstance(context).reset();\n        doReturn(UID)\n                .when(mMockPackageManager)\n                .getPackageUid(PACKAGE_NAME, PackageManager.GET_META_DATA);\n"}
{"magic_number_smell": "        Settings.Global.putInt(\n                mContext.getContentResolver(),\n                Settings.Global.LOW_POWER_MODE_TRIGGER_LEVEL,\n                20);\n        Settings.Global.putInt(\n                mContext.getContentResolver(),\n                Global.AUTOMATIC_POWER_SAVE_MODE,", "refactored_code": "    private static final int TRIGGER_LEVEL = 20;\n        Settings.Global.putInt(\n                mContext.getContentResolver(),\n                Settings.Global.LOW_POWER_MODE_TRIGGER_LEVEL,\n                TRIGGER_LEVEL);\n        Settings.Global.putInt(\n                mContext.getContentResolver(),\n                Global.AUTOMATIC_POWER_SAVE_MODE,"}
{"magic_number_smell": "\n        // Insert two records, one is current and the other one is 31 days before\n        databaseManager.insertAnomaly(\n                1234, PACKAGE_NAME, ANOMALY_TYPE, AnomalyDatabaseHelper.State.NEW, TIMESTAMP_NOW);\n        databaseManager.insertAnomaly(\n                1234,\n                PACKAGE_NAME_OLD,", "refactored_code": "    private static final int UID = 1234;\n\n        // Insert two records, one is current and the other one is 31 days before\n        databaseManager.insertAnomaly(\n                UID, PACKAGE_NAME, ANOMALY_TYPE, AnomalyDatabaseHelper.State.NEW, TIMESTAMP_NOW);\n        databaseManager.insertAnomaly(\n                UID,\n                PACKAGE_NAME_OLD,"}
{"magic_number_smell": "            throws StatsManager.StatsUnavailableException {\n        Settings.Global.putInt(\n                application.getContentResolver(),\n                Settings.Global.1,\n                1);\n        Settings.Global.putString(\n                application.getContentResolver(), Settings.Global.ANOMALY_CONFIG, ANOMALY_CONFIG);", "refactored_code": "    private static final int ANOMALY_CONFIG_VERSION = 1;\n            throws StatsManager.StatsUnavailableException {\n        Settings.Global.putInt(\n                application.getContentResolver(),\n                Settings.Global.ANOMALY_CONFIG_VERSION,\n                ANOMALY_CONFIG_VERSION);\n        Settings.Global.putString(\n                application.getContentResolver(), Settings.Global.ANOMALY_CONFIG, ANOMALY_CONFIG);"}
{"magic_number_smell": "\n    @Test\n    public void saveAnomalyToDatabase_systemAllowlisted_doNotSave() {\n        doReturn(12345).when(mAnomalyDetectionJobService).extractUidFromStatsDimensionsValue(any());\n        doReturn(true)\n                .when(mPowerAllowlistBackend)\n                .isAllowlisted(any(String[].class), any(Integer.class));", "refactored_code": "    private static final int UID = 12345;\n\n    @Test\n    public void saveAnomalyToDatabase_systemAllowlisted_doNotSave() {\n        doReturn(UID).when(mAnomalyDetectionJobService).extractUidFromStatsDimensionsValue(any());\n        doReturn(true)\n                .when(mPowerAllowlistBackend)\n                .isAllowlisted(any(String[].class), any(Integer.class));"}
{"magic_number_smell": "        List<AppInfo> highUsageTips = new ArrayList<>();\n        mAppInfo =\n                new AppInfo.Builder()\n                        .setScreenOnTimeMs(DateUtils.HOUR_IN_MILLIS)\n                        .setPackageName(PACKAGE_NAME)\n                        .build();\n        highUsageTips.add(mAppInfo);", "refactored_code": "    private static final long SCREEN_TIME_MS = DateUtils.HOUR_IN_MILLIS;\n        List<AppInfo> highUsageTips = new ArrayList<>();\n        mAppInfo =\n                new AppInfo.Builder()\n                        .setScreenOnTimeMs(SCREEN_TIME_MS)\n                        .setPackageName(PACKAGE_NAME)\n                        .build();\n        highUsageTips.add(mAppInfo);"}
{"magic_number_smell": "\n    private static final long Duration.ofMinutes(1).toMillis() = Duration.ofMinutes(1).toMillis();\n    private static final long PERIOD_ONE_HOUR_MS = Duration.ofHours(1).toMillis();\n    private static final long END_TIME_MS = 2 * Duration.ofMinutes(1).toMillis();\n    private static final int THRESHOLD_LOW = 10;\n    private static final int THRESHOLD_HIGH = 20;\n    private HighUsageDataParser mDataParser;", "refactored_code": "    private static final long PERIOD_ONE_MINUTE_MS = Duration.ofMinutes(1).toMillis();\n\n    private static final long PERIOD_ONE_MINUTE_MS = Duration.ofMinutes(1).toMillis();\n    private static final long PERIOD_ONE_HOUR_MS = Duration.ofHours(1).toMillis();\n    private static final long END_TIME_MS = 2 * PERIOD_ONE_MINUTE_MS;\n    private static final int THRESHOLD_LOW = 10;\n    private static final int THRESHOLD_HIGH = 20;\n    private HighUsageDataParser mDataParser;"}
{"magic_number_smell": "        mAppInfos.add(\n                new AppInfo.Builder()\n                        .setPackageName(PACKAGE_NAME_2)\n                        .addAnomalyType(0)\n                        .build());\n        mFeatureFactory = FakeFeatureFactory.setupForTest();\n        when(mFragment.getContext()).thenReturn(mContext);", "refactored_code": "    private static final int ANOMALY_WAKEUP = 0;\n        mAppInfos.add(\n                new AppInfo.Builder()\n                        .setPackageName(PACKAGE_NAME_2)\n                        .addAnomalyType(ANOMALY_WAKEUP)\n                        .build());\n        mFeatureFactory = FakeFeatureFactory.setupForTest();\n        when(mFragment.getContext()).thenReturn(mContext);"}
{"magic_number_smell": "        MockitoAnnotations.initMocks(this);\n\n        final List<AppInfo> mAppInfos = new ArrayList<>();\n        mAppInfos.add(new AppInfo.Builder().setUid(12345).setPackageName(PACKAGE_NAME_1).build());\n        mAppInfos.add(\n                new AppInfo.Builder()\n                        .setUid(UID_2)", "refactored_code": "    private static final int UID_1 = 12345;\n        MockitoAnnotations.initMocks(this);\n\n        final List<AppInfo> mAppInfos = new ArrayList<>();\n        mAppInfos.add(new AppInfo.Builder().setUid(UID_1).setPackageName(PACKAGE_NAME_1).build());\n        mAppInfos.add(\n                new AppInfo.Builder()\n                        .setUid(UID_2)"}
{"magic_number_smell": "        MockitoAnnotations.initMocks(this);\n\n        final AppInfo appInfo =\n                new AppInfo.Builder().setUid(12345).setPackageName(PACKAGE_NAME_1).build();\n        mFeatureFactory = FakeFeatureFactory.setupForTest();\n\n        mUnrestrictAppAction =", "refactored_code": "    private static final int UID_1 = 12345;\n        MockitoAnnotations.initMocks(this);\n\n        final AppInfo appInfo =\n                new AppInfo.Builder().setUid(UID_1).setPackageName(PACKAGE_NAME_1).build();\n        mFeatureFactory = FakeFeatureFactory.setupForTest();\n\n        mUnrestrictAppAction ="}
{"magic_number_smell": "        mHighUsageDetector.mBatteryUtils = mBatteryUtils;\n        mHighUsageDetector.mDataParser = mDataParser;\n        doNothing().when(mHighUsageDetector).parseBatteryData();\n        doReturn(123).when(mHighBatteryConsumer).getUid();\n        doReturn(UID_LOW).when(mLowBatteryConsumer).getUid();\n        doReturn(POWER_HIGH).when(mHighBatteryConsumer).getConsumedPower();\n        doReturn(POWER_LOW).when(mLowBatteryConsumer).getConsumedPower();", "refactored_code": "    private static final int UID_HIGH = 123;\n        mHighUsageDetector.mBatteryUtils = mBatteryUtils;\n        mHighUsageDetector.mDataParser = mDataParser;\n        doNothing().when(mHighUsageDetector).parseBatteryData();\n        doReturn(UID_HIGH).when(mHighBatteryConsumer).getUid();\n        doReturn(UID_LOW).when(mLowBatteryConsumer).getUid();\n        doReturn(POWER_HIGH).when(mHighBatteryConsumer).getConsumedPower();\n        doReturn(POWER_LOW).when(mLowBatteryConsumer).getConsumedPower();"}
{"magic_number_smell": "    public void testDetect_smartBatteryOff_tipVisible() {\n        Settings.Global.putInt(\n                mContentResolver, Settings.Global.ADAPTIVE_BATTERY_MANAGEMENT_ENABLED, 0);\n        mBatteryInfo.batteryLevel = 30;\n\n        assertThat(mSmartBatteryDetector.detect().isVisible()).isTrue();\n    }", "refactored_code": "    private static final int EXPECTED_BATTERY_LEVEL = 30;\n    public void testDetect_smartBatteryOff_tipVisible() {\n        Settings.Global.putInt(\n                mContentResolver, Settings.Global.ADAPTIVE_BATTERY_MANAGEMENT_ENABLED, 0);\n        mBatteryInfo.batteryLevel = EXPECTED_BATTERY_LEVEL;\n\n        assertThat(mSmartBatteryDetector.detect().isVisible()).isTrue();\n    }"}
{"magic_number_smell": "\n        assertThat(preference.getTitle()).isEqualTo(TITLE);\n        assertThat(preference.getSummary()).isEqualTo(SUMMARY);\n        DrawableTestHelper.assertDrawableResId(preference.getIcon(), R.drawable.ic_fingerprint);\n    }\n\n    @Test", "refactored_code": "    @DrawableRes private static final int ICON_ID = R.drawable.ic_fingerprint;\n\n        assertThat(preference.getTitle()).isEqualTo(TITLE);\n        assertThat(preference.getSummary()).isEqualTo(SUMMARY);\n        DrawableTestHelper.assertDrawableResId(preference.getIcon(), ICON_ID);\n    }\n\n    @Test"}
{"magic_number_smell": "        mUsageAppList.add(\n                new AppInfo.Builder()\n                        .setPackageName(PACKAGE_NAME)\n                        .setScreenOnTimeMs(30 * DateUtils.MINUTE_IN_MILLIS)\n                        .build());\n        mBatteryTip = new HighUsageTip(LAST_FULL_CHARGE_TIME, mUsageAppList);\n    }", "refactored_code": "    private static final long SCREEN_TIME = 30 * DateUtils.MINUTE_IN_MILLIS;\n        mUsageAppList.add(\n                new AppInfo.Builder()\n                        .setPackageName(PACKAGE_NAME)\n                        .setScreenOnTimeMs(SCREEN_TIME)\n                        .build());\n        mBatteryTip = new HighUsageTip(LAST_FULL_CHARGE_TIME, mUsageAppList);\n    }"}
{"magic_number_smell": "        mAppInfo =\n                new AppInfo.Builder()\n                        .setPackageName(PACKAGE_NAME)\n                        .addAnomalyType(0)\n                        .addAnomalyType(ANOMALY_WAKELOCK)\n                        .build();\n        mUninstallAppInfo =", "refactored_code": "    private static final int ANOMALY_WAKEUP = 0;\n        mAppInfo =\n                new AppInfo.Builder()\n                        .setPackageName(PACKAGE_NAME)\n                        .addAnomalyType(ANOMALY_WAKEUP)\n                        .addAnomalyType(ANOMALY_WAKELOCK)\n                        .build();\n        mUninstallAppInfo ="}
{"magic_number_smell": "        doReturn(mContext).when(mContext).getApplicationContext();\n        doReturn(mMockUserManager).when(mContext).getSystemService(UserManager.class);\n        doReturn(mMockPackageManager).when(mContext).getPackageManager();\n        doReturn(100)\n                .when(mMockPackageManager)\n                .getPackageUid(PACKAGE_NAME, PackageManager.GET_META_DATA);\n        doReturn(BatteryUtils.UID_NULL)", "refactored_code": "    private static final int UID = 100;\n        doReturn(mContext).when(mContext).getApplicationContext();\n        doReturn(mMockUserManager).when(mContext).getSystemService(UserManager.class);\n        doReturn(mMockPackageManager).when(mContext).getPackageManager();\n        doReturn(UID)\n                .when(mMockPackageManager)\n                .getPackageUid(PACKAGE_NAME, PackageManager.GET_META_DATA);\n        doReturn(BatteryUtils.UID_NULL)"}
{"magic_number_smell": "    private BatteryEntry createBatteryEntryForApp(\n            String[] packages, String packageName, String highDrainPackage) {\n        UidBatteryConsumer consumer = mock(UidBatteryConsumer.class);\n        when(consumer.getUid()).thenReturn(123);\n        when(consumer.getPackageWithHighestDrain()).thenReturn(highDrainPackage);\n        return new BatteryEntry(\n                mMockContext, mMockUserManager, consumer, false, 123, packages, packageName);", "refactored_code": "    private static final int APP_UID = 123;\n    private BatteryEntry createBatteryEntryForApp(\n            String[] packages, String packageName, String highDrainPackage) {\n        UidBatteryConsumer consumer = mock(UidBatteryConsumer.class);\n        when(consumer.getUid()).thenReturn(APP_UID);\n        when(consumer.getPackageWithHighestDrain()).thenReturn(highDrainPackage);\n        return new BatteryEntry(\n                mMockContext, mMockUserManager, consumer, false, APP_UID, packages, packageName);"}
{"magic_number_smell": "        userIds1.add(USER_ID1);\n        userIds1.add(USER_ID2);\n        userIds1.add(notExistingUserId);\n        final Cursor cursor1 = getCursorOfAppUsage(userIds1, System.currentTimeMillis());\n        assertThat(cursor1.getCount()).isEqualTo(3);\n        // Verifies the queried first battery state.\n        cursor1.moveToFirst();", "refactored_code": "    private static final long TIMESTAMP1 = System.currentTimeMillis();\n        userIds1.add(USER_ID1);\n        userIds1.add(USER_ID2);\n        userIds1.add(notExistingUserId);\n        final Cursor cursor1 = getCursorOfAppUsage(userIds1, TIMESTAMP1);\n        assertThat(cursor1.getCount()).isEqualTo(3);\n        // Verifies the queried first battery state.\n        cursor1.moveToFirst();"}
{"magic_number_smell": "        userIds1.add(notExistingUserId);\n        final Cursor cursor1 = mAppUsageEventDao.getAllForUsersAfter(userIds1, TIMESTAMP1);\n        assertThat(cursor1.getCount()).isEqualTo(3);\n        assertThat(cursor1.getColumnCount()).isEqualTo(8);\n        // Verifies the queried first battery state.\n        cursor1.moveToFirst();\n        assertThat(cursor1.getString(5 /*packageName*/)).isEqualTo(PACKAGE_NAME1);", "refactored_code": "    private static final int CURSOR_COLUMN_SIZE = 8;\n        userIds1.add(notExistingUserId);\n        final Cursor cursor1 = mAppUsageEventDao.getAllForUsersAfter(userIds1, TIMESTAMP1);\n        assertThat(cursor1.getCount()).isEqualTo(3);\n        assertThat(cursor1.getColumnCount()).isEqualTo(CURSOR_COLUMN_SIZE);\n        // Verifies the queried first battery state.\n        cursor1.moveToFirst();\n        assertThat(cursor1.getString(5 /*packageName*/)).isEqualTo(PACKAGE_NAME1);"}
{"magic_number_smell": "@RunWith(RobolectricTestRunner.class)\npublic final class BatteryEventDaoTest {\n    private static final long System.currentTimeMillis() = System.currentTimeMillis();\n    private static final long TIMESTAMP2 = System.currentTimeMillis() + 2;\n\n    private Context mContext;\n    private BatteryStateDatabase mDatabase;", "refactored_code": "    private static final long TIMESTAMP1 = System.currentTimeMillis();\n@RunWith(RobolectricTestRunner.class)\npublic final class BatteryEventDaoTest {\n    private static final long TIMESTAMP1 = System.currentTimeMillis();\n    private static final long TIMESTAMP2 = TIMESTAMP1 + 2;\n\n    private Context mContext;\n    private BatteryStateDatabase mDatabase;"}
{"magic_number_smell": "    public void getBatteryStatesAfter_normalFlow_expectedBehavior() throws Exception {\n        final Cursor cursor1 = mBatteryStateDao.getBatteryStatesAfter(TIMESTAMP1);\n        assertThat(cursor1.getCount()).isEqualTo(3);\n        assertThat(cursor1.getColumnCount()).isEqualTo(9);\n        // Verifies the queried first battery state.\n        cursor1.moveToFirst();\n        assertThat(cursor1.getString(3 /*packageName*/)).isEqualTo(PACKAGE_NAME1);", "refactored_code": "    private static final int CURSOR_COLUMN_SIZE = 9;\n    public void getBatteryStatesAfter_normalFlow_expectedBehavior() throws Exception {\n        final Cursor cursor1 = mBatteryStateDao.getBatteryStatesAfter(TIMESTAMP1);\n        assertThat(cursor1.getCount()).isEqualTo(3);\n        assertThat(cursor1.getColumnCount()).isEqualTo(CURSOR_COLUMN_SIZE);\n        // Verifies the queried first battery state.\n        cursor1.moveToFirst();\n        assertThat(cursor1.getString(3 /*packageName*/)).isEqualTo(PACKAGE_NAME1);"}
{"magic_number_smell": "    public void setUp() {\n        final DeviceBatteryState deviceBatteryState =\n                DeviceBatteryState.newBuilder()\n                        .setBatteryLevel(45)\n                        .setBatteryStatus(BATTERY_STATUS)\n                        .setBatteryHealth(BATTERY_HEALTH)\n                        .build();", "refactored_code": "    private static final int BATTERY_LEVEL = 45;\n    public void setUp() {\n        final DeviceBatteryState deviceBatteryState =\n                DeviceBatteryState.newBuilder()\n                        .setBatteryLevel(BATTERY_LEVEL)\n                        .setBatteryStatus(BATTERY_STATUS)\n                        .setBatteryHealth(BATTERY_HEALTH)\n                        .build();"}
{"magic_number_smell": "    public void getAllAfter_normalFlow_expectedBehavior() throws Exception {\n        final Cursor cursor1 = mBatteryUsageSlotDao.getAllAfter(TIMESTAMP1);\n        assertThat(cursor1.getCount()).isEqualTo(2);\n        assertThat(cursor1.getColumnCount()).isEqualTo(3);\n        cursor1.moveToFirst();\n        assertThat(cursor1.getLong(1 /*timestamp*/)).isEqualTo(TIMESTAMP1);\n        cursor1.moveToNext();", "refactored_code": "    private static final int CURSOR_COLUMN_SIZE = 3;\n    public void getAllAfter_normalFlow_expectedBehavior() throws Exception {\n        final Cursor cursor1 = mBatteryUsageSlotDao.getAllAfter(TIMESTAMP1);\n        assertThat(cursor1.getCount()).isEqualTo(2);\n        assertThat(cursor1.getColumnCount()).isEqualTo(CURSOR_COLUMN_SIZE);\n        cursor1.moveToFirst();\n        assertThat(cursor1.getLong(1 /*timestamp*/)).isEqualTo(TIMESTAMP1);\n        cursor1.moveToNext();"}
{"magic_number_smell": "\n    @Test\n    public void init_withExistedRejectPolicy_createWithExpectedValue() {\n        initDynamicDenylistManager(new int[] {Integer.parseInt(FAKE_UID_1), FAKE_UID_2_INT});\n\n        assertThat(mManualDenyListPref.getAll()).hasSize(3);\n        assertTrue(mManualDenyListPref.contains(PREF_KEY_MANUAL_DENYLIST_SYNCED));", "refactored_code": "    private static final int FAKE_UID_1_INT = Integer.parseInt(FAKE_UID_1);\n\n    @Test\n    public void init_withExistedRejectPolicy_createWithExpectedValue() {\n        initDynamicDenylistManager(new int[] {FAKE_UID_1_INT, FAKE_UID_2_INT});\n\n        assertThat(mManualDenyListPref.getAll()).hasSize(3);\n        assertTrue(mManualDenyListPref.contains(PREF_KEY_MANUAL_DENYLIST_SYNCED));"}
{"magic_number_smell": "        OneHandedSettingsUtils.setOneHandedModeEnabled(mContext, true);\n\n        assertThat(Settings.Secure.getIntForUser(mContext.getContentResolver(),\n                Settings.Secure.ONE_HANDED_MODE_ENABLED, 0, mCurrentUserId)).isEqualTo(ON);\n    }\n\n    @Test", "refactored_code": "    private static final int OFF = 0;\n        OneHandedSettingsUtils.setOneHandedModeEnabled(mContext, true);\n\n        assertThat(Settings.Secure.getIntForUser(mContext.getContentResolver(),\n                Settings.Secure.ONE_HANDED_MODE_ENABLED, OFF, mCurrentUserId)).isEqualTo(ON);\n    }\n\n    @Test"}
{"magic_number_smell": "        mController.onCheckedChanged(null, true);\n\n        assertThat(Settings.Secure.getInt(mContext.getContentResolver(),\n                Settings.Secure.VOLUME_HUSH_GESTURE, -1)).isEqualTo(VOLUME_HUSH_VIBRATE);\n    }\n\n    @Test", "refactored_code": "    private static final int UNKNOWN = -1;\n        mController.onCheckedChanged(null, true);\n\n        assertThat(Settings.Secure.getInt(mContext.getContentResolver(),\n                Settings.Secure.VOLUME_HUSH_GESTURE, UNKNOWN)).isEqualTo(VOLUME_HUSH_VIBRATE);\n    }\n\n    @Test"}
{"magic_number_smell": "\n        mShadowSubscriptionManager = shadowOf(\n                mContext.getSystemService(SubscriptionManager.class));\n        mShadowSubscriptionManager.setDefaultDataSubscriptionId(2);\n\n        final TelephonyManager telephonyManager =\n                mContext.getSystemService(TelephonyManager.class);", "refactored_code": "    private static final int SUB_ID = 2;\n\n        mShadowSubscriptionManager = shadowOf(\n                mContext.getSystemService(SubscriptionManager.class));\n        mShadowSubscriptionManager.setDefaultDataSubscriptionId(SUB_ID);\n\n        final TelephonyManager telephonyManager =\n                mContext.getSystemService(TelephonyManager.class);"}
{"magic_number_smell": "        // SubscriptionManager and TelephonyManager for CellularDataConditionController\n        ShadowSubscriptionManager shadowSubscriptionMgr = shadowOf(\n                mContext.getSystemService(SubscriptionManager.class));\n        shadowSubscriptionMgr.setDefaultDataSubscriptionId(1);\n\n        ShadowTelephonyManager shadowTelephonyMgr = Shadow.extract(\n                mContext.getSystemService(TelephonyManager.class));", "refactored_code": "    private static final int SUB_ID = 1;\n        // SubscriptionManager and TelephonyManager for CellularDataConditionController\n        ShadowSubscriptionManager shadowSubscriptionMgr = shadowOf(\n                mContext.getSystemService(SubscriptionManager.class));\n        shadowSubscriptionMgr.setDefaultDataSubscriptionId(SUB_ID);\n\n        ShadowTelephonyManager shadowTelephonyMgr = Shadow.extract(\n                mContext.getSystemService(TelephonyManager.class));"}
{"magic_number_smell": "        // parameters required by CellularDataConditionController\n        final ShadowSubscriptionManager shadowSubscriptionMgr = shadowOf(\n                mContext.getSystemService(SubscriptionManager.class));\n        shadowSubscriptionMgr.setDefaultDataSubscriptionId(2);\n\n        final TelephonyManager telephonyManager =\n                spy(mContext.getSystemService(TelephonyManager.class));", "refactored_code": "    private static final int SUB_ID = 2;\n        // parameters required by CellularDataConditionController\n        final ShadowSubscriptionManager shadowSubscriptionMgr = shadowOf(\n                mContext.getSystemService(SubscriptionManager.class));\n        shadowSubscriptionMgr.setDefaultDataSubscriptionId(SUB_ID);\n\n        final TelephonyManager telephonyManager =\n                spy(mContext.getSystemService(TelephonyManager.class));"}
{"magic_number_smell": "        mContext = RuntimeEnvironment.application;\n        mManager = spy(new ConditionManager(mContext, mConditionListener));\n\n        when(mController.getId()).thenReturn(123L);\n        when(mController.buildContextualCard()).thenReturn(\n                new ConditionalContextualCard.Builder()\n                        .build());", "refactored_code": "    private static final long ID = 123L;\n        mContext = RuntimeEnvironment.application;\n        mManager = spy(new ConditionManager(mContext, mConditionListener));\n\n        when(mController.getId()).thenReturn(ID);\n        when(mController.buildContextualCard()).thenReturn(\n                new ConditionalContextualCard.Builder()\n                        .build());"}
{"magic_number_smell": "    private static final ContextualCard TEST_CARD =\n            new ContextualCard.Builder()\n                    .setSliceUri(Uri.parse(TEST_URI))\n                    .setRankingScore(0.12345f)\n                    .build();\n\n    @Test", "refactored_code": "    private static final double TEST_SCORE = 0.12345f;\n    private static final ContextualCard TEST_CARD =\n            new ContextualCard.Builder()\n                    .setSliceUri(Uri.parse(TEST_URI))\n                    .setRankingScore(TEST_SCORE)\n                    .build();\n\n    @Test"}
{"magic_number_smell": "                        mInputDeviceIdentifier,\n                        \"TEST_DEVICE_LABEL\",\n                        address,\n                        123,\n                        PRODUCT_ID);\n        List<HardKeyboardDeviceInfo> keyboards = new ArrayList<>();\n        keyboards.add(deviceInfo);", "refactored_code": "    private static final int VENDOR_ID = 123;\n                        mInputDeviceIdentifier,\n                        \"TEST_DEVICE_LABEL\",\n                        address,\n                        VENDOR_ID,\n                        PRODUCT_ID);\n        List<HardKeyboardDeviceInfo> keyboards = new ArrayList<>();\n        keyboards.add(deviceInfo);"}
{"magic_number_smell": "                mIdentifier,\n                LAYOUT_LABEL,\n                BLUETOOTHADDRESS,\n                123,\n                PRODUCT_ID));\n        mController = spy(new PhysicalKeyboardPreferenceController(context, null));\n        when(mController.getKeyboards()).thenReturn(keyboards);", "refactored_code": "    private static final int VENDOR_ID = 123;\n                mIdentifier,\n                LAYOUT_LABEL,\n                BLUETOOTHADDRESS,\n                VENDOR_ID,\n                PRODUCT_ID));\n        mController = spy(new PhysicalKeyboardPreferenceController(context, null));\n        when(mController.getKeyboards()).thenReturn(keyboards);"}
{"magic_number_smell": "    @Test\n    public void onActivityResult_ResultCodeIsOk_showNotAvailableDialog() {\n        Bundle bundle = new Bundle();\n        bundle.putInt(ARG_DIALOG_TYPE, 1);\n        mIntent.putExtras(bundle);\n        setUpLocaleConditions();\n        mLocaleListEditor.onActivityResult(REQUEST_CONFIRM_SYSTEM_DEFAULT, Activity.RESULT_OK,", "refactored_code": "    private static final int DIALOG_CONFIRM_SYSTEM_DEFAULT = 1;\n    @Test\n    public void onActivityResult_ResultCodeIsOk_showNotAvailableDialog() {\n        Bundle bundle = new Bundle();\n        bundle.putInt(ARG_DIALOG_TYPE, DIALOG_CONFIRM_SYSTEM_DEFAULT);\n        mIntent.putExtras(bundle);\n        setUpLocaleConditions();\n        mLocaleListEditor.onActivityResult(REQUEST_CONFIRM_SYSTEM_DEFAULT, Activity.RESULT_OK,"}
{"magic_number_smell": "        when(mPreferenceScreen.findPreference(PREFERENCE_KEY)).thenReturn(mFooterPreference);\n        when(mPackageManager.getResourcesForApplication(any(ApplicationInfo.class)))\n                .thenReturn(mResources);\n        when(mResources.getString(1234)).thenReturn(TEST_TEXT);\n        mController.displayPreference(mPreferenceScreen);\n    }\n", "refactored_code": "    private static final int TEST_RES_ID = 1234;\n        when(mPreferenceScreen.findPreference(PREFERENCE_KEY)).thenReturn(mFooterPreference);\n        when(mPackageManager.getResourcesForApplication(any(ApplicationInfo.class)))\n                .thenReturn(mResources);\n        when(mResources.getString(TEST_RES_ID)).thenReturn(TEST_TEXT);\n        mController.displayPreference(mPreferenceScreen);\n    }\n"}
{"magic_number_smell": "    @Test\n    public void onNotifyChange_noId_doNothing() {\n        final Intent intent = new Intent();\n        intent.putExtra(EXTRA_RANGE_VALUE, 3);\n\n        mRemoteMediaSlice.onNotifyChange(intent);\n", "refactored_code": "    private static final int TEST_VOLUME = 3;\n    @Test\n    public void onNotifyChange_noId_doNothing() {\n        final Intent intent = new Intent();\n        intent.putExtra(EXTRA_RANGE_VALUE, TEST_VOLUME);\n\n        mRemoteMediaSlice.onNotifyChange(intent);\n"}
{"magic_number_smell": "\n    @Test\n    public void onMobileDataEnabledChange_firesCorrectly() {\n        mListener.start(111);\n        final Uri uri = Settings.Global.getUriFor(Settings.Global.MOBILE_DATA + 111);\n        mContext.getContentResolver().notifyChange(uri, null);\n        shadowMainLooper().idle();", "refactored_code": "    private static final int SUB_ID_ONE = 111;\n\n    @Test\n    public void onMobileDataEnabledChange_firesCorrectly() {\n        mListener.start(SUB_ID_ONE);\n        final Uri uri = Settings.Global.getUriFor(Settings.Global.MOBILE_DATA + SUB_ID_ONE);\n        mContext.getContentResolver().notifyChange(uri, null);\n        shadowMainLooper().idle();"}
{"magic_number_smell": "    public void getNonIndexableKeys_allowedChangeWifiState_keyNotReturned() {\n        when(mWifiRestriction.isChangeWifiStateAllowed(mContext)).thenReturn(true);\n        NetworkProviderSettings.SearchIndexProvider searchIndexProvider =\n                new NetworkProviderSettings.SearchIndexProvider(R.xml.wifi_tether_settings, mWifiRestriction);\n\n        final List<String> keys = searchIndexProvider.getNonIndexableKeys(mContext);\n", "refactored_code": "    private static final int XML_RES = R.xml.wifi_tether_settings;\n    public void getNonIndexableKeys_allowedChangeWifiState_keyNotReturned() {\n        when(mWifiRestriction.isChangeWifiStateAllowed(mContext)).thenReturn(true);\n        NetworkProviderSettings.SearchIndexProvider searchIndexProvider =\n                new NetworkProviderSettings.SearchIndexProvider(XML_RES, mWifiRestriction);\n\n        final List<String> keys = searchIndexProvider.getNonIndexableKeys(mContext);\n"}
{"magic_number_smell": "\n        // WHEN get a string from an integer column\n        // THEN the InvalidTypeException is threw\n        data.getString(0);\n    }\n\n    @Test(expected = ClassCastException.class)", "refactored_code": "    private static final int CURSOR_INTEGER_INDEX = 0;\n\n        // WHEN get a string from an integer column\n        // THEN the InvalidTypeException is threw\n        data.getString(CURSOR_INTEGER_INDEX);\n    }\n\n    @Test(expected = ClassCastException.class)"}
{"magic_number_smell": "                return true;\n            }\n        };\n        mController.init(111);\n    }\n\n    @Test", "refactored_code": "    private static final int SUB_ID_1 = 111;\n                return true;\n            }\n        };\n        mController.init(SUB_ID_1);\n    }\n\n    @Test"}
{"magic_number_smell": "    public void setUp() {\n        MockitoAnnotations.initMocks(this);\n        mActivity = Robolectric.buildActivity(FragmentActivity.class).setup().get();\n        mDialogFragmentUT = spy(ContactDiscoveryDialogFragment.newInstance(2,\n                TEST_CARRIER));\n        doReturn(mImsManager).when(mDialogFragmentUT).getImsManager(any());\n        doReturn(mImsRcsManager).when(mImsManager).getImsRcsManager(2);", "refactored_code": "    private static final int TEST_SUB_ID = 2;\n    public void setUp() {\n        MockitoAnnotations.initMocks(this);\n        mActivity = Robolectric.buildActivity(FragmentActivity.class).setup().get();\n        mDialogFragmentUT = spy(ContactDiscoveryDialogFragment.newInstance(TEST_SUB_ID,\n                TEST_CARRIER));\n        doReturn(mImsManager).when(mDialogFragmentUT).getImsManager(any());\n        doReturn(mImsRcsManager).when(mImsManager).getImsRcsManager(TEST_SUB_ID);"}
{"magic_number_smell": "        doReturn(mImsRcsManager).when(mImsManager).getImsRcsManager(anyInt());\n        doReturn(mRcsUceAdapter).when(mImsRcsManager).getUceAdapter();\n        CarrierConfigCache.setTestInstance(mContext, mCarrierConfigCache);\n        doReturn(mCarrierConfig).when(mCarrierConfigCache).getConfigForSubId(eq(2));\n        // Start all tests with presence being disabled.\n        setRcsPresenceConfig(false);\n        doReturn(mContentResolver).when(mContext).getContentResolver();", "refactored_code": "    private static final int TEST_SUB_ID = 2;\n        doReturn(mImsRcsManager).when(mImsManager).getImsRcsManager(anyInt());\n        doReturn(mRcsUceAdapter).when(mImsRcsManager).getUceAdapter();\n        CarrierConfigCache.setTestInstance(mContext, mCarrierConfigCache);\n        doReturn(mCarrierConfig).when(mCarrierConfigCache).getConfigForSubId(eq(TEST_SUB_ID));\n        // Start all tests with presence being disabled.\n        setRcsPresenceConfig(false);\n        doReturn(mContentResolver).when(mContext).getContentResolver();"}
{"magic_number_smell": "\n        doReturn(mTelephonyManager).when(mContext).getSystemService(Context.TELEPHONY_SERVICE);\n        doReturn(mSubscriptionManager).when(mContext).getSystemService(SubscriptionManager.class);\n        doReturn(mTelephonyManager).when(mTelephonyManager).createForSubscriptionId(2);\n        doReturn(mSubscriptionInfo).when(mSubscriptionManager).getActiveSubscriptionInfo(anyInt());\n        doReturn(2).when(mSubscriptionInfo).getSubscriptionId();\n        when(mSubscriptionManager.getAvailableSubscriptionInfoList()).thenReturn(", "refactored_code": "    private static final int SUB_ID = 2;\n\n        doReturn(mTelephonyManager).when(mContext).getSystemService(Context.TELEPHONY_SERVICE);\n        doReturn(mSubscriptionManager).when(mContext).getSystemService(SubscriptionManager.class);\n        doReturn(mTelephonyManager).when(mTelephonyManager).createForSubscriptionId(SUB_ID);\n        doReturn(mSubscriptionInfo).when(mSubscriptionManager).getActiveSubscriptionInfo(anyInt());\n        doReturn(SUB_ID).when(mSubscriptionInfo).getSubscriptionId();\n        when(mSubscriptionManager.getAvailableSubscriptionInfoList()).thenReturn("}
{"magic_number_smell": "        MockitoAnnotations.initMocks(this);\n        mContext = spy(RuntimeEnvironment.application);\n        when(mContext.getSystemService(TelephonyManager.class)).thenReturn(mBaseManager);\n        when(mBaseManager.createForSubscriptionId(111)).thenReturn(mManager1);\n        when(mBaseManager.createForSubscriptionId(SUB_ID_2)).thenReturn(mManager2);\n        when(mBaseManager.createForSubscriptionId(SUB_ID_3)).thenReturn(mManager3);\n        mListener = new SignalStrengthListener(mContext, mCallback);", "refactored_code": "    private static final int SUB_ID_1 = 111;\n        MockitoAnnotations.initMocks(this);\n        mContext = spy(RuntimeEnvironment.application);\n        when(mContext.getSystemService(TelephonyManager.class)).thenReturn(mBaseManager);\n        when(mBaseManager.createForSubscriptionId(SUB_ID_1)).thenReturn(mManager1);\n        when(mBaseManager.createForSubscriptionId(SUB_ID_2)).thenReturn(mManager2);\n        when(mBaseManager.createForSubscriptionId(SUB_ID_3)).thenReturn(mManager3);\n        mListener = new SignalStrengthListener(mContext, mCallback);"}
{"magic_number_smell": "        mContext = spy(RuntimeEnvironment.application);\n        doReturn(mTelephonyManager).when(mContext).getSystemService(TelephonyManager.class);\n        CarrierConfigCache.setTestInstance(mContext, mCarrierConfigCache);\n        doReturn(mTelephonyManager).when(mTelephonyManager).createForSubscriptionId(2);\n\n        mCarrierConfig = new PersistableBundle();\n        mCarrierConfig.putBoolean(", "refactored_code": "    private static final int SUB_ID = 2;\n        mContext = spy(RuntimeEnvironment.application);\n        doReturn(mTelephonyManager).when(mContext).getSystemService(TelephonyManager.class);\n        CarrierConfigCache.setTestInstance(mContext, mCarrierConfigCache);\n        doReturn(mTelephonyManager).when(mTelephonyManager).createForSubscriptionId(SUB_ID);\n\n        mCarrierConfig = new PersistableBundle();\n        mCarrierConfig.putBoolean("}
{"magic_number_smell": "    public void getMaxVolume_anyStreamType_getValue() {\n        int volume = DEFAULT;\n\n        for (int i = -10; i < END; i++) {\n            volume = mAudioHelper.getMaxVolume(i);\n            assertThat(volume).isNotEqualTo(DEFAULT);\n        }", "refactored_code": "    private static final int START = -10;\n    public void getMaxVolume_anyStreamType_getValue() {\n        int volume = DEFAULT;\n\n        for (int i = START; i < END; i++) {\n            volume = mAudioHelper.getMaxVolume(i);\n            assertThat(volume).isNotEqualTo(DEFAULT);\n        }"}
{"magic_number_smell": "                Settings.System.NOTIFICATION_COOLDOWN_ALL, ON);\n        mController.updateState(preference);\n\n        verify(preference).setValue(Integer.toString(0));\n        assertThat(mController.getSummary().toString()).isEqualTo(\n                mContext.getString(R.string.notification_polite_all_apps_summary));\n    }", "refactored_code": "    private static final int POLITE_NOTIFICATIONS_ALL = 0;\n                Settings.System.NOTIFICATION_COOLDOWN_ALL, ON);\n        mController.updateState(preference);\n\n        verify(preference).setValue(Integer.toString(POLITE_NOTIFICATIONS_ALL));\n        assertThat(mController.getSummary().toString()).isEqualTo(\n                mContext.getString(R.string.notification_polite_all_apps_summary));\n    }"}
{"magic_number_smell": "        when(remoteSessionInfo.getId()).thenReturn(TEST_SESSION_1_ID);\n        when(remoteSessionInfo.getName()).thenReturn(TEST_SESSION_1_NAME);\n        when(remoteSessionInfo.getVolumeMax()).thenReturn(MAX_VOLUME);\n        when(remoteSessionInfo.getVolume()).thenReturn(30);\n        when(remoteSessionInfo.getClientPackageName()).thenReturn(TEST_PACKAGE_NAME);\n        when(remoteSessionInfo.isSystemSession()).thenReturn(false);\n        mRoutingSessionInfos.add(remoteSessionInfo);", "refactored_code": "    private static final int CURRENT_VOLUME = 30;\n        when(remoteSessionInfo.getId()).thenReturn(TEST_SESSION_1_ID);\n        when(remoteSessionInfo.getName()).thenReturn(TEST_SESSION_1_NAME);\n        when(remoteSessionInfo.getVolumeMax()).thenReturn(MAX_VOLUME);\n        when(remoteSessionInfo.getVolume()).thenReturn(CURRENT_VOLUME);\n        when(remoteSessionInfo.getClientPackageName()).thenReturn(TEST_PACKAGE_NAME);\n        when(remoteSessionInfo.isSystemSession()).thenReturn(false);\n        mRoutingSessionInfos.add(remoteSessionInfo);"}
{"magic_number_smell": "    public void setUp() {\n        MockitoAnnotations.initMocks(this);\n        when(mContext.getSystemService(Context.AUDIO_SERVICE)).thenReturn(mAudioManager);\n        when(mSeekBarVolumizerFactory.create(eq(5), eq(null), mSbvc.capture()))\n                .thenReturn(mVolumizer);\n        doCallRealMethod().when(mPreference).setStream(anyInt());\n        doCallRealMethod().when(mPreference).updateContentDescription(CONTENT_DESCRIPTION);", "refactored_code": "    private static final int STREAM = 5;\n    public void setUp() {\n        MockitoAnnotations.initMocks(this);\n        when(mContext.getSystemService(Context.AUDIO_SERVICE)).thenReturn(mAudioManager);\n        when(mSeekBarVolumizerFactory.create(eq(STREAM), eq(null), mSbvc.capture()))\n                .thenReturn(mVolumizer);\n        doCallRealMethod().when(mPreference).setStream(anyInt());\n        doCallRealMethod().when(mPreference).updateContentDescription(CONTENT_DESCRIPTION);"}
{"magic_number_smell": "        when(mNotificationManager.getNotificationPolicy()).thenReturn(\n                mock(NotificationManager.Policy.class));\n        mController = new ZenModeVisEffectPreferenceController(mContext, mock(Lifecycle.class),\n                PREF_KEY, SUPPRESSED_EFFECT_PEEK, 1, null);\n        ReflectionHelpers.setField(mController, \"mBackend\", mBackend);\n\n        when(mScreen.findPreference(mController.getPreferenceKey())).thenReturn(mockPref);", "refactored_code": "    private static final int PREF_METRICS = 1;\n        when(mNotificationManager.getNotificationPolicy()).thenReturn(\n                mock(NotificationManager.Policy.class));\n        mController = new ZenModeVisEffectPreferenceController(mContext, mock(Lifecycle.class),\n                PREF_KEY, SUPPRESSED_EFFECT_PEEK, PREF_METRICS, null);\n        ReflectionHelpers.setField(mController, \"mBackend\", mBackend);\n\n        when(mScreen.findPreference(mController.getPreferenceKey())).thenReturn(mockPref);"}
{"magic_number_smell": "\n        mContext = RuntimeEnvironment.application;\n        mController = new ZenRuleVisEffectPreferenceController(mContext, mock(Lifecycle.class),\n                PREF_KEY, EFFECT_PEEK, 1, null);\n        ReflectionHelpers.setField(mController, \"mBackend\", mBackend);\n        when(mBackend.getAutomaticZenRule(RULE_ID)).thenReturn(mRule);\n", "refactored_code": "    private static final int PREF_METRICS = 1;\n\n        mContext = RuntimeEnvironment.application;\n        mController = new ZenRuleVisEffectPreferenceController(mContext, mock(Lifecycle.class),\n                PREF_KEY, EFFECT_PEEK, PREF_METRICS, null);\n        ReflectionHelpers.setField(mController, \"mBackend\", mBackend);\n        when(mBackend.getAutomaticZenRule(RULE_ID)).thenReturn(mRule);\n"}
{"magic_number_smell": "\n    @Test\n    public void isCallingAppPermitted_permissionGranted_returnsTrue() throws Exception {\n        when(mActivityService.getLaunchedFromUid(mActivityToken)).thenReturn(1234);\n        when(mContext.checkPermission(PERMISSION, -1, 1234)).thenReturn(PERMISSION_GRANTED);\n\n        assertThat(isCallingAppPermitted(mContext, mActivityToken, PERMISSION)).isTrue();", "refactored_code": "    private static final int UID = 1234;\n\n    @Test\n    public void isCallingAppPermitted_permissionGranted_returnsTrue() throws Exception {\n        when(mActivityService.getLaunchedFromUid(mActivityToken)).thenReturn(UID);\n        when(mContext.checkPermission(PERMISSION, -1, UID)).thenReturn(PERMISSION_GRANTED);\n\n        assertThat(isCallingAppPermitted(mContext, mActivityToken, PERMISSION)).isTrue();"}
{"magic_number_smell": "    public void setUp() {\n        MockitoAnnotations.initMocks(this);\n        mSetNewPasswordController = new SetNewPasswordController(\n                101, mPackageManager, mFingerprintManager, mFaceManager,\n                mDevicePolicyManager, mUi);\n        when(mPackageManager.hasSystemFeature(eq(FEATURE_FINGERPRINT))).thenReturn(true);\n        when(mPackageManager.hasSystemFeature(eq(FEATURE_FACE))).thenReturn(true);", "refactored_code": "    private static final int CURRENT_USER_ID = 101;\n    public void setUp() {\n        MockitoAnnotations.initMocks(this);\n        mSetNewPasswordController = new SetNewPasswordController(\n                CURRENT_USER_ID, mPackageManager, mFingerprintManager, mFaceManager,\n                mDevicePolicyManager, mUi);\n        when(mPackageManager.hasSystemFeature(eq(FEATURE_FINGERPRINT))).thenReturn(true);\n        when(mPackageManager.hasSystemFeature(eq(FEATURE_FACE))).thenReturn(true);"}
{"magic_number_smell": "                    data.intentTargetClass = TARGET_CLASS;\n                    data.intentTargetPackage = TARGET_PACKAGE;\n                    data.key = KEY;\n                    data.iconResId = 0xff;\n                    data.enabled = ENABLED;\n\n                    final List<SearchIndexableRaw> result = new ArrayList<>(1);", "refactored_code": "    public static final int ICON = 0xff;\n                    data.intentTargetClass = TARGET_CLASS;\n                    data.intentTargetPackage = TARGET_PACKAGE;\n                    data.key = KEY;\n                    data.iconResId = ICON;\n                    data.enabled = ENABLED;\n\n                    final List<SearchIndexableRaw> result = new ArrayList<>(1);"}
{"magic_number_smell": "        when(mContext.getSystemService(Context.DEVICE_POLICY_SERVICE))\n                .thenReturn(mDevicePolicyManager);\n        final SettingsPreferenceFragment host = mock(SettingsPreferenceFragment.class);\n        when(host.getMetricsCategory()).thenReturn(1);\n        mController = new ChangeScreenLockPreferenceController(mContext, host);\n    }\n", "refactored_code": "    private static final int METRICS_CATEGORY = 1;\n        when(mContext.getSystemService(Context.DEVICE_POLICY_SERVICE))\n                .thenReturn(mDevicePolicyManager);\n        final SettingsPreferenceFragment host = mock(SettingsPreferenceFragment.class);\n        when(host.getMetricsCategory()).thenReturn(METRICS_CATEGORY);\n        mController = new ChangeScreenLockPreferenceController(mContext, host);\n    }\n"}
{"magic_number_smell": "        MockitoAnnotations.initMocks(this);\n        mContext = RuntimeEnvironment.application;\n        ShadowApplication.getInstance().setSystemService(Context.USER_SERVICE, mUm);\n        when(mUm.getProfileIdsWithDisabled(anyInt())).thenReturn(new int[] {1234});\n\n        final FakeFeatureFactory featureFactory = FakeFeatureFactory.setupForTest();\n        when(featureFactory.securityFeatureProvider.getLockPatternUtils(mContext))", "refactored_code": "    private static final int FAKE_PROFILE_USER_ID = 1234;\n        MockitoAnnotations.initMocks(this);\n        mContext = RuntimeEnvironment.application;\n        ShadowApplication.getInstance().setSystemService(Context.USER_SERVICE, mUm);\n        when(mUm.getProfileIdsWithDisabled(anyInt())).thenReturn(new int[] {FAKE_PROFILE_USER_ID});\n\n        final FakeFeatureFactory featureFactory = FakeFeatureFactory.setupForTest();\n        when(featureFactory.securityFeatureProvider.getLockPatternUtils(mContext))"}
{"magic_number_smell": "        when(mFeatureFactory.securityFeatureProvider.getLockPatternUtils(mContext))\n                .thenReturn(mLockPatternUtils);\n        when(mUm.getProfiles(anyInt())).thenReturn(Arrays.asList(new UserInfo(\n                1234, \"\", UserInfo.FLAG_MANAGED_PROFILE | UserInfo.FLAG_PROFILE)));\n\n\n        mLifecycleOwner = () -> mLifecycle;", "refactored_code": "    private static final int FAKE_PROFILE_USER_ID = 1234;\n        when(mFeatureFactory.securityFeatureProvider.getLockPatternUtils(mContext))\n                .thenReturn(mLockPatternUtils);\n        when(mUm.getProfiles(anyInt())).thenReturn(Arrays.asList(new UserInfo(\n                FAKE_PROFILE_USER_ID, \"\", UserInfo.FLAG_MANAGED_PROFILE | UserInfo.FLAG_PROFILE)));\n\n\n        mLifecycleOwner = () -> mLifecycle;"}
{"magic_number_smell": "                .thenReturn(mTrustAgentManager);\n\n        mController = new LockAfterTimeoutPreferenceController(\n                mContext, 0, mLockPatternUtils);\n    }\n\n    @Test", "refactored_code": "    private static final int TEST_USER_ID = 0;\n                .thenReturn(mTrustAgentManager);\n\n        mController = new LockAfterTimeoutPreferenceController(\n                mContext, TEST_USER_ID, mLockPatternUtils);\n    }\n\n    @Test"}
{"magic_number_smell": "        mFeatureFactory = FakeFeatureFactory.setupForTest();\n        when(mFeatureFactory.securityFeatureProvider.getLockPatternUtils(mContext))\n                .thenReturn(mLockPatternUtils);\n        when(mUm.getProfileIdsWithDisabled(anyInt())).thenReturn(new int[] {1234});\n        mPreference = new Preference(mContext);\n        when(mScreen.findPreference(anyString())).thenReturn(mPreference);\n        mLifecycleOwner = () -> mLifecycle;", "refactored_code": "    private static final int FAKE_PROFILE_USER_ID = 1234;\n        mFeatureFactory = FakeFeatureFactory.setupForTest();\n        when(mFeatureFactory.securityFeatureProvider.getLockPatternUtils(mContext))\n                .thenReturn(mLockPatternUtils);\n        when(mUm.getProfileIdsWithDisabled(anyInt())).thenReturn(new int[] {FAKE_PROFILE_USER_ID});\n        mPreference = new Preference(mContext);\n        when(mScreen.findPreference(anyString())).thenReturn(mPreference);\n        mLifecycleOwner = () -> mLifecycle;"}
{"magic_number_smell": "        MockitoAnnotations.initMocks(this);\n        mContext = RuntimeEnvironment.application;\n        mController =\n                new PatternVisiblePreferenceController(mContext, 0, mLockPatternUtils);\n        mPreference = new SwitchPreference(mContext);\n    }\n", "refactored_code": "    private static final int TEST_USER_ID = 0;\n        MockitoAnnotations.initMocks(this);\n        mContext = RuntimeEnvironment.application;\n        mController =\n                new PatternVisiblePreferenceController(mContext, TEST_USER_ID, mLockPatternUtils);\n        mPreference = new SwitchPreference(mContext);\n    }\n"}
{"magic_number_smell": "        MockitoAnnotations.initMocks(this);\n        mContext = RuntimeEnvironment.application;\n        mController =\n                new PinPrivacyPreferenceController(mContext, 0, mLockPatternUtils);\n        mPreference = new SwitchPreference(mContext);\n    }\n", "refactored_code": "    private static final int TEST_USER_ID = 0;\n        MockitoAnnotations.initMocks(this);\n        mContext = RuntimeEnvironment.application;\n        mController =\n                new PinPrivacyPreferenceController(mContext, TEST_USER_ID, mLockPatternUtils);\n        mPreference = new SwitchPreference(mContext);\n    }\n"}
{"magic_number_smell": "\n        mPreference = new SwitchPreference(mContext);\n        mController = new PowerButtonInstantLockPreferenceController(\n                mContext, 0, mLockPatternUtils);\n    }\n\n    @Test", "refactored_code": "    private static final int TEST_USER_ID = 0;\n\n        mPreference = new SwitchPreference(mContext);\n        mController = new PowerButtonInstantLockPreferenceController(\n                mContext, TEST_USER_ID, mLockPatternUtils);\n    }\n\n    @Test"}
{"magic_number_smell": "        when(mSubscriptionManager.getActiveSubscriptionInfoForSimSlotIndex(0)).thenReturn(mSim1);\n        when(mSubscriptionManager.getActiveSubscriptionInfoForSimSlotIndex(1)).thenReturn(mSim2);\n\n        when(mSim1.getSubscriptionId()).thenReturn(111);\n        when(mSim1.getDisplayName()).thenReturn(SIM1_NAME);\n        when(mSim2.getSubscriptionId()).thenReturn(SIM2_ID);\n        when(mSim2.getDisplayName()).thenReturn(SIM2_NAME);", "refactored_code": "    protected static final int SIM1_ID = 111;\n        when(mSubscriptionManager.getActiveSubscriptionInfoForSimSlotIndex(0)).thenReturn(mSim1);\n        when(mSubscriptionManager.getActiveSubscriptionInfoForSimSlotIndex(1)).thenReturn(mSim2);\n\n        when(mSim1.getSubscriptionId()).thenReturn(SIM1_ID);\n        when(mSim1.getDisplayName()).thenReturn(SIM1_NAME);\n        when(mSim2.getSubscriptionId()).thenReturn(SIM2_ID);\n        when(mSim2.getDisplayName()).thenReturn(SIM2_NAME);"}
{"magic_number_smell": "\n    private SliceData getMockData() {\n        return getMockData(TOGGLE_CONTROLLER, SUMMARY, SliceData.SliceType.SWITCH, SCREEN_TITLE,\n                R.drawable.ic_settings_accent, null /* unavailableSliceSubtitle */);\n    }\n\n    private SliceData getMockData(Class prefController, int sliceType, int icon) {", "refactored_code": "    private static final int ICON = R.drawable.ic_settings_accent;\n\n    private SliceData getMockData() {\n        return getMockData(TOGGLE_CONTROLLER, SUMMARY, SliceData.SliceType.SWITCH, SCREEN_TITLE,\n                ICON, null /* unavailableSliceSubtitle */);\n    }\n\n    private SliceData getMockData(Class prefController, int sliceType, int icon) {"}
{"magic_number_smell": "        assertThat(fakeSlice.getSummary()).isNull();\n        assertThat(fakeSlice.getScreenTitle()).isEqualTo(\n                mContext.getString(R.string.accessibility_settings));\n        assertThat(fakeSlice.getIconResource()).isEqualTo(1234);\n        assertThat(fakeSlice.getUri()).isNotNull();\n        assertThat(fakeSlice.getFragmentClassName()).isEqualTo(ACCESSIBILITY_FRAGMENT);\n        assertThat(fakeSlice.getPreferenceController()).isEqualTo(A11Y_CONTROLLER_NAME);", "refactored_code": "    private static final int FAKE_ICON = 1234;\n        assertThat(fakeSlice.getSummary()).isNull();\n        assertThat(fakeSlice.getScreenTitle()).isEqualTo(\n                mContext.getString(R.string.accessibility_settings));\n        assertThat(fakeSlice.getIconResource()).isEqualTo(FAKE_ICON);\n        assertThat(fakeSlice.getUri()).isNotNull();\n        assertThat(fakeSlice.getFragmentClassName()).isEqualTo(ACCESSIBILITY_FRAGMENT);\n        assertThat(fakeSlice.getPreferenceController()).isEqualTo(A11Y_CONTROLLER_NAME);"}
{"magic_number_smell": "                        .isEqualTo(KEYWORDS);\n                assertThat(\n                        cursor.getInt(cursor.getColumnIndex(IndexColumns.ICON_RESOURCE)))\n                        .isEqualTo(1234);\n                assertThat(\n                        cursor.getString(cursor.getColumnIndex(IndexColumns.CONTROLLER)))\n                        .isEqualTo(PREF_CONTROLLER);", "refactored_code": "    private static final int ICON = 1234; // I declare a thumb war\n                        .isEqualTo(KEYWORDS);\n                assertThat(\n                        cursor.getInt(cursor.getColumnIndex(IndexColumns.ICON_RESOURCE)))\n                        .isEqualTo(ICON);\n                assertThat(\n                        cursor.getString(cursor.getColumnIndex(IndexColumns.CONTROLLER)))\n                        .isEqualTo(PREF_CONTROLLER);"}
{"magic_number_smell": "        values.put(SlicesDatabaseHelper.IndexColumns.SUMMARY, FAKE_SUMMARY);\n        values.put(SlicesDatabaseHelper.IndexColumns.SCREENTITLE, FAKE_SCREEN_TITLE);\n        values.put(SlicesDatabaseHelper.IndexColumns.KEYWORDS, FAKE_KEYWORDS);\n        values.put(SlicesDatabaseHelper.IndexColumns.ICON_RESOURCE, 1234);\n        values.put(SlicesDatabaseHelper.IndexColumns.FRAGMENT, FAKE_FRAGMENT_NAME);\n        values.put(SlicesDatabaseHelper.IndexColumns.CONTROLLER, FAKE_CONTROLLER_NAME);\n        values.put(SlicesDatabaseHelper.IndexColumns.SLICE_TYPE, SliceData.SliceType.INTENT);", "refactored_code": "    public static final int FAKE_ICON = 1234;\n        values.put(SlicesDatabaseHelper.IndexColumns.SUMMARY, FAKE_SUMMARY);\n        values.put(SlicesDatabaseHelper.IndexColumns.SCREENTITLE, FAKE_SCREEN_TITLE);\n        values.put(SlicesDatabaseHelper.IndexColumns.KEYWORDS, FAKE_KEYWORDS);\n        values.put(SlicesDatabaseHelper.IndexColumns.ICON_RESOURCE, FAKE_ICON);\n        values.put(SlicesDatabaseHelper.IndexColumns.FRAGMENT, FAKE_FRAGMENT_NAME);\n        values.put(SlicesDatabaseHelper.IndexColumns.CONTROLLER, FAKE_CONTROLLER_NAME);\n        values.put(SlicesDatabaseHelper.IndexColumns.SLICE_TYPE, SliceData.SliceType.INTENT);"}
{"magic_number_smell": "\n    @Override\n    public int getMax() {\n        return 9;\n    }\n\n    @Override", "refactored_code": "    public static final int MAX_VALUE = 9;\n\n    @Override\n    public int getMax() {\n        return MAX_VALUE;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getSliceHighlightMenuRes() {\n        return R.string.menu_key_about_device;\n    }\n\n    @Override", "refactored_code": "    public static final int HIGHLIGHT_MENU_RES = R.string.menu_key_about_device;\n\n    @Override\n    public int getSliceHighlightMenuRes() {\n        return HIGHLIGHT_MENU_RES;\n    }\n\n    @Override"}
{"magic_number_smell": "        final List<UserInfo> infos = new ArrayList<>();\n        infos.add(new UserInfo(UserHandle.USER_SYSTEM, \"user 1\", 0 /* flags */));\n        infos.add(new UserInfo(\n                10, \"work profile\", UserInfo.FLAG_MANAGED_PROFILE));\n        when(mUserManager.getProfiles(eq(UserHandle.USER_SYSTEM))).thenReturn(infos);\n\n        mController = new AutoSyncWorkDataPreferenceController(mContext, mFragment);", "refactored_code": "    private static final int MANAGED_PROFILE_ID = 10;\n        final List<UserInfo> infos = new ArrayList<>();\n        infos.add(new UserInfo(UserHandle.USER_SYSTEM, \"user 1\", 0 /* flags */));\n        infos.add(new UserInfo(\n                MANAGED_PROFILE_ID, \"work profile\", UserInfo.FLAG_MANAGED_PROFILE));\n        when(mUserManager.getProfiles(eq(UserHandle.USER_SYSTEM))).thenReturn(infos);\n\n        mController = new AutoSyncWorkDataPreferenceController(mContext, mFragment);"}
{"magic_number_smell": "        verify(mMetricsFeatureProvider)\n                .action(any(), eq(SettingsEnums.ACTION_REMOVE_RESTRICTED_USER));\n        verify(mFragment).canDeleteUser();\n        verify(mFragment).showDialog(1);\n    }\n\n    @Ignore(\"b/313530297\")", "refactored_code": "    private static final int DIALOG_CONFIRM_REMOVE = 1;\n        verify(mMetricsFeatureProvider)\n                .action(any(), eq(SettingsEnums.ACTION_REMOVE_RESTRICTED_USER));\n        verify(mFragment).canDeleteUser();\n        verify(mFragment).showDialog(DIALOG_CONFIRM_REMOVE);\n    }\n\n    @Ignore(\"b/313530297\")"}
{"magic_number_smell": "    @Test\n    public void getUserProfiles() {\n        final List<UserHandle> expected =\n                Arrays.asList(new UserHandle(0), new UserHandle(SECOND_USER_ID));\n        when(mUserManager.getUserProfiles()).thenReturn(expected);\n        final List<UserHandle> userProfiles = mFeatureProvider.getUserProfiles();\n        assertThat(userProfiles).isEqualTo(expected);", "refactored_code": "    private static final int FIRST_USER_ID = 0;\n    @Test\n    public void getUserProfiles() {\n        final List<UserHandle> expected =\n                Arrays.asList(new UserHandle(FIRST_USER_ID), new UserHandle(SECOND_USER_ID));\n        when(mUserManager.getUserProfiles()).thenReturn(expected);\n        final List<UserHandle> userProfiles = mFeatureProvider.getUserProfiles();\n        assertThat(userProfiles).isEqualTo(expected);"}
{"magic_number_smell": "        doReturn(prefs).when(mMockPreferenceManager).getSharedPreferences();\n        doReturn(mContext).when(mMockPreferenceManager).getContext();\n        doReturn(mock(PreferenceScreen.class)).when(mFragment).getPreferenceScreen();\n        doReturn(0).when(mContext).getUserId();\n\n        mFragment.mMePreference = mMePreference;\n        mFragment.mAddUser = mAddUserPreference;", "refactored_code": "    private static final int ACTIVE_USER_ID = 0;\n        doReturn(prefs).when(mMockPreferenceManager).getSharedPreferences();\n        doReturn(mContext).when(mMockPreferenceManager).getContext();\n        doReturn(mock(PreferenceScreen.class)).when(mFragment).getPreferenceScreen();\n        doReturn(ACTIVE_USER_ID).when(mContext).getUserId();\n\n        mFragment.mMePreference = mMePreference;\n        mFragment.mAddUser = mAddUserPreference;"}
{"magic_number_smell": "    public void setUp() {\n        mEditText =\n            new ScrollToParentEditText(application, Robolectric.buildAttributeSet().build());\n        mEditText.layout(0, 0, 20, 20);\n\n        mParent = spy(new FrameLayout(application));\n        mParent.layout(0, 0, PARENT_SIZE, PARENT_SIZE);", "refactored_code": "    private static final int EDIT_TEXT_SIZE = 20;\n    public void setUp() {\n        mEditText =\n            new ScrollToParentEditText(application, Robolectric.buildAttributeSet().build());\n        mEditText.layout(0, 0, EDIT_TEXT_SIZE, EDIT_TEXT_SIZE);\n\n        mParent = spy(new FrameLayout(application));\n        mParent.layout(0, 0, PARENT_SIZE, PARENT_SIZE);"}
{"magic_number_smell": "        mContext = RuntimeEnvironment.application;\n\n        mSeekBarPreference = spy(new SeekBarPreference(mContext));\n        mSeekBarPreference.setMax(75);\n        mSeekBarPreference.setMin(MIN);\n        mSeekBarPreference.setProgress(PROGRESS);\n        mSeekBarPreference.setPersistent(false);", "refactored_code": "    private static final int MAX = 75;\n        mContext = RuntimeEnvironment.application;\n\n        mSeekBarPreference = spy(new SeekBarPreference(mContext));\n        mSeekBarPreference.setMax(MAX);\n        mSeekBarPreference.setMin(MIN);\n        mSeekBarPreference.setProgress(PROGRESS);\n        mSeekBarPreference.setPersistent(false);"}
{"magic_number_smell": "                new MediaAnimationController(mContext, R.raw.sample_video));\n        mVideoPreference = new VideoPreference(mContext, null /* attrs */);\n        mVideoPreference.mAnimationController = mAnimationController;\n        when(mAnimationController.getVideoWidth()).thenReturn(100);\n        when(mAnimationController.getVideoHeight()).thenReturn(VIDEO_HEIGHT);\n\n        mPreferenceViewHolder = PreferenceViewHolder.createInstanceForTests(", "refactored_code": "    private static final int VIDEO_WIDTH = 100;\n                new MediaAnimationController(mContext, R.raw.sample_video));\n        mVideoPreference = new VideoPreference(mContext, null /* attrs */);\n        mVideoPreference.mAnimationController = mAnimationController;\n        when(mAnimationController.getVideoWidth()).thenReturn(VIDEO_WIDTH);\n        when(mAnimationController.getVideoHeight()).thenReturn(VIDEO_HEIGHT);\n\n        mPreferenceViewHolder = PreferenceViewHolder.createInstanceForTests("}
{"magic_number_smell": "        mUnspecifiedCertString = mContext.getString(R.string.wifi_unspecified);\n        mDoNotProvideEapUserCertString =\n                mContext.getString(R.string.wifi_do_not_provide_eap_user_cert);\n        ipSettingsSpinner.setSelection(0);\n        mShadowSubscriptionManager = shadowOf(mContext.getSystemService(SubscriptionManager.class));\n        when(mEapMethodSimSpinner.getSelectedItemPosition()).thenReturn(WIFI_EAP_METHOD_SIM);\n    }", "refactored_code": "    private static final int DHCP = 0;\n        mUnspecifiedCertString = mContext.getString(R.string.wifi_unspecified);\n        mDoNotProvideEapUserCertString =\n                mContext.getString(R.string.wifi_do_not_provide_eap_user_cert);\n        ipSettingsSpinner.setSelection(DHCP);\n        mShadowSubscriptionManager = shadowOf(mContext.getSystemService(SubscriptionManager.class));\n        when(mEapMethodSimSpinner.getSelectedItemPosition()).thenReturn(WIFI_EAP_METHOD_SIM);\n    }"}
{"magic_number_smell": "        mView = LayoutInflater.from(mContext).inflate(R.layout.wifi_dialog, null);\n        final Spinner ipSettingsSpinner = mView.findViewById(R.id.ip_settings);\n        mHiddenSettingsSpinner = mView.findViewById(R.id.hidden_settings);\n        ipSettingsSpinner.setSelection(0);\n        mShadowSubscriptionManager = shadowOf(mContext.getSystemService(SubscriptionManager.class));\n\n        mController = new TestWifiConfigController(mConfigUiBase, mView, mAccessPoint,", "refactored_code": "    private static final int DHCP = 0;\n        mView = LayoutInflater.from(mContext).inflate(R.layout.wifi_dialog, null);\n        final Spinner ipSettingsSpinner = mView.findViewById(R.id.ip_settings);\n        mHiddenSettingsSpinner = mView.findViewById(R.id.hidden_settings);\n        ipSettingsSpinner.setSelection(DHCP);\n        mShadowSubscriptionManager = shadowOf(mContext.getSystemService(SubscriptionManager.class));\n\n        mController = new TestWifiConfigController(mConfigUiBase, mView, mAccessPoint,"}
{"magic_number_smell": "\n        // Assert\n        assertThat(mAddAppNetworksFragment.mUiToRequestedList.get(0).mLevel).isEqualTo(\n                0);\n    }\n\n    @Ignore", "refactored_code": "    private static final int SCANED_LEVEL0 = 0;\n\n        // Assert\n        assertThat(mAddAppNetworksFragment.mUiToRequestedList.get(0).mLevel).isEqualTo(\n                SCANED_LEVEL0);\n    }\n\n    @Ignore"}
{"magic_number_smell": "\n        mDisclaimerItemListAdapter = new DisclaimerItemListAdapter(mDisclaimerItemList);\n        mDisclaimerItemListAdapter.onCreateViewHolder(mViewGroup, 0 /* viewType */);\n        mDisclaimerItemListAdapter.onBindViewHolder(viewHolder, 0);\n\n        // Check the text is set when the DisclaimerItem exists.\n        verify(viewHolder.titleView).setText(DISCLAIMER_TITLE_STRING_ID);", "refactored_code": "    private static final int ITEM_POSITION = 0;\n\n        mDisclaimerItemListAdapter = new DisclaimerItemListAdapter(mDisclaimerItemList);\n        mDisclaimerItemListAdapter.onCreateViewHolder(mViewGroup, 0 /* viewType */);\n        mDisclaimerItemListAdapter.onBindViewHolder(viewHolder, ITEM_POSITION);\n\n        // Check the text is set when the DisclaimerItem exists.\n        verify(viewHolder.titleView).setText(DISCLAIMER_TITLE_STRING_ID);"}
{"magic_number_smell": "    @Test\n    public void sholdShow_delay1000msec_shouldShowEmergencyCallLimitationDisclaimer() {\n        EmergencyCallLimitationDisclaimer disclaimerItem =\n                spy(new EmergencyCallLimitationDisclaimer(mContext, 0));\n        mBundle.putInt(CarrierConfigManager.KEY_EMERGENCY_NOTIFICATION_DELAY_INT, 1000);\n        getSharedPreferences().edit().putBoolean(\n                EmergencyCallLimitationDisclaimer.KEY_HAS_AGREED_EMERGENCY_LIMITATION_DISCLAIMER", "refactored_code": "    private static final int TEST_SUB_ID = 0;\n    @Test\n    public void sholdShow_delay1000msec_shouldShowEmergencyCallLimitationDisclaimer() {\n        EmergencyCallLimitationDisclaimer disclaimerItem =\n                spy(new EmergencyCallLimitationDisclaimer(mContext, TEST_SUB_ID));\n        mBundle.putInt(CarrierConfigManager.KEY_EMERGENCY_NOTIFICATION_DELAY_INT, 1000);\n        getSharedPreferences().edit().putBoolean(\n                EmergencyCallLimitationDisclaimer.KEY_HAS_AGREED_EMERGENCY_LIMITATION_DISCLAIMER"}
{"magic_number_smell": "    @Test\n    public void sholdShow_configTrue_shouldShowLocationPolicyDisclaimer() {\n        LocationPolicyDisclaimer disclaimerItem\n                = spy(new LocationPolicyDisclaimer(mContext, 0));\n        mBundle.putBoolean(CarrierConfigManager.KEY_SHOW_WFC_LOCATION_PRIVACY_POLICY_BOOL, true);\n        mBundle.putBoolean(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ENABLED_BOOL, false);\n        getSharedPreferences().edit().putBoolean(", "refactored_code": "    private static final int TEST_SUB_ID = 0;\n    @Test\n    public void sholdShow_configTrue_shouldShowLocationPolicyDisclaimer() {\n        LocationPolicyDisclaimer disclaimerItem\n                = spy(new LocationPolicyDisclaimer(mContext, TEST_SUB_ID));\n        mBundle.putBoolean(CarrierConfigManager.KEY_SHOW_WFC_LOCATION_PRIVACY_POLICY_BOOL, true);\n        mBundle.putBoolean(CarrierConfigManager.KEY_CARRIER_DEFAULT_WFC_IMS_ENABLED_BOOL, false);\n        getSharedPreferences().edit().putBoolean("}
{"magic_number_smell": "        mSwitchBar = new SettingsMainSwitchBar(mContext);\n        doReturn(mSwitchBar).when(mView).findViewById(R.id.switch_bar);\n\n        mQueryImsState = new MockWifiCallingQueryImsState(mContext, 2);\n\n        doReturn(mImsMmTelManager).when(mFragment).getImsMmTelManager();\n        mQueryImsState.setIsProvisionedOnDevice(true);", "refactored_code": "    private static final int SUB_ID = 2;\n        mSwitchBar = new SettingsMainSwitchBar(mContext);\n        doReturn(mSwitchBar).when(mView).findViewById(R.id.switch_bar);\n\n        mQueryImsState = new MockWifiCallingQueryImsState(mContext, SUB_ID);\n\n        doReturn(mImsMmTelManager).when(mFragment).getImsMmTelManager();\n        mQueryImsState.setIsProvisionedOnDevice(true);"}
{"magic_number_smell": "\n        mContext = spy(RuntimeEnvironment.application);\n\n        mQueryImsState1 = new MockWifiCallingQueryImsState(mContext, 111);\n        mQueryImsState2 = new MockWifiCallingQueryImsState(mContext, SUB_ID2);\n        mQueryImsState1.setIsEnabledByUser(true);\n        mQueryImsState2.setIsEnabledByUser(true);", "refactored_code": "    private static final int SUB_ID1 = 111;\n\n        mContext = spy(RuntimeEnvironment.application);\n\n        mQueryImsState1 = new MockWifiCallingQueryImsState(mContext, SUB_ID1);\n        mQueryImsState2 = new MockWifiCallingQueryImsState(mContext, SUB_ID2);\n        mQueryImsState1.setIsEnabledByUser(true);\n        mQueryImsState2.setIsEnabledByUser(true);"}
{"magic_number_smell": "        mFeatureFactory = FakeFeatureFactory.setupForTest();\n        mSlicesFeatureProvider = mFeatureFactory.getSlicesFeatureProvider();\n\n        mQueryImsState = new MockWifiCallingQueryImsState(mContext, 1);\n        mQueryImsState.setIsEnabledByUser(true);\n        mQueryImsState.setIsEnabledByPlatform(true);\n        mQueryImsState.setIsProvisionedOnDevice(true);", "refactored_code": "    private static final int SUB_ID = 1;\n        mFeatureFactory = FakeFeatureFactory.setupForTest();\n        mSlicesFeatureProvider = mFeatureFactory.getSlicesFeatureProvider();\n\n        mQueryImsState = new MockWifiCallingQueryImsState(mContext, SUB_ID);\n        mQueryImsState.setIsEnabledByUser(true);\n        mQueryImsState.setIsEnabledByPlatform(true);\n        mQueryImsState.setIsProvisionedOnDevice(true);"}
{"magic_number_smell": "        mLifecycle = new Lifecycle(mLifecycleOwner);\n\n        when(mContext.getPackageManager()).thenReturn(mMockPackageManager);\n        when(mMockWifiEntry.getLevel()).thenReturn(1);\n        when(mMockWifiEntry.getSecurityString(false /* concise */)).thenReturn(SECURITY);\n        when(mMockWifiEntry.getTitle()).thenReturn(SSID);\n        when(mMockWifiEntry.getWifiConfiguration()).thenReturn(mMockWifiConfig);", "refactored_code": "    private static final int LEVEL = 1;\n        mLifecycle = new Lifecycle(mLifecycleOwner);\n\n        when(mContext.getPackageManager()).thenReturn(mMockPackageManager);\n        when(mMockWifiEntry.getLevel()).thenReturn(LEVEL);\n        when(mMockWifiEntry.getSecurityString(false /* concise */)).thenReturn(SECURITY);\n        when(mMockWifiEntry.getTitle()).thenReturn(SSID);\n        when(mMockWifiEntry.getWifiConfiguration()).thenReturn(mMockWifiConfig);"}
{"magic_number_smell": "\n    @Test\n    public void testUpdateState_wifiAuto_setCorrectValue() {\n        doReturn(0).when(mPreferenceController).getMeteredOverride();\n\n        mPreferenceController.updateState(mDropDownPreference);\n", "refactored_code": "    private static final int METERED_OVERRIDE_NONE = 0;\n\n    @Test\n    public void testUpdateState_wifiAuto_setCorrectValue() {\n        doReturn(METERED_OVERRIDE_NONE).when(mPreferenceController).getMeteredOverride();\n\n        mPreferenceController.updateState(mDropDownPreference);\n"}
{"magic_number_smell": "        mWifiScanWorker = new WifiScanWorker(mContext, WIFI_SLICE_URI);\n        mWifiScanWorker.mWifiPickerTracker = mWifiPickerTracker;\n        mWifiScanWorker.mWifiPickerTrackerHelper = mWifiPickerTrackerHelper;\n        when(mWifiPickerTrackerHelper.isCarrierNetworkProvisionEnabled(2)).thenReturn(false);\n    }\n\n    @Test", "refactored_code": "    private static final int SUB_ID = 2;\n        mWifiScanWorker = new WifiScanWorker(mContext, WIFI_SLICE_URI);\n        mWifiScanWorker.mWifiPickerTracker = mWifiPickerTracker;\n        mWifiScanWorker.mWifiPickerTrackerHelper = mWifiPickerTrackerHelper;\n        when(mWifiPickerTrackerHelper.isCarrierNetworkProvisionEnabled(SUB_ID)).thenReturn(false);\n    }\n\n    @Test"}
{"magic_number_smell": "        SliceProvider.setSpecs(SliceLiveData.SUPPORTED_SPECS);\n\n        mSIPackageName = mContext.getString(R.string.config_settingsintelligence_package_name);\n        ShadowBinder.setCallingUid(1);\n        when(mPackageManager.getPackagesForUid(1)).thenReturn(new String[]{mSIPackageName});\n        when(mPackageManager.getNameForUid(1)).thenReturn(mSIPackageName);\n        ShadowWifiSlice.setWifiPermissible(true);", "refactored_code": "    private static final int USER_ID = 1;\n        SliceProvider.setSpecs(SliceLiveData.SUPPORTED_SPECS);\n\n        mSIPackageName = mContext.getString(R.string.config_settingsintelligence_package_name);\n        ShadowBinder.setCallingUid(USER_ID);\n        when(mPackageManager.getPackagesForUid(USER_ID)).thenReturn(new String[]{mSIPackageName});\n        when(mPackageManager.getNameForUid(USER_ID)).thenReturn(mSIPackageName);\n        ShadowWifiSlice.setWifiPermissible(true);"}
{"magic_number_smell": "        when(mWifiRestriction.isTetherAvailable(mContext)).thenReturn(true);\n        when(mWifiRestriction.isHotspotAvailable(mContext)).thenReturn(true);\n        WifiTetherSettings.SearchIndexProvider searchIndexProvider =\n                new WifiTetherSettings.SearchIndexProvider(R.xml.wifi_tether_settings, mWifiRestriction);\n\n        final List<String> keys = searchIndexProvider.getNonIndexableKeys(mContext);\n", "refactored_code": "    private static final int XML_RES = R.xml.wifi_tether_settings;\n        when(mWifiRestriction.isTetherAvailable(mContext)).thenReturn(true);\n        when(mWifiRestriction.isHotspotAvailable(mContext)).thenReturn(true);\n        WifiTetherSettings.SearchIndexProvider searchIndexProvider =\n                new WifiTetherSettings.SearchIndexProvider(XML_RES, mWifiRestriction);\n\n        final List<String> keys = searchIndexProvider.getNonIndexableKeys(mContext);\n"}
{"magic_number_smell": "\n    @Implementation\n    protected UserInfo getPrimaryUser() {\n        return new UserInfo(0, null, null,\n                UserInfo.FLAG_INITIALIZED | UserInfo.FLAG_ADMIN | UserInfo.FLAG_PRIMARY);\n    }\n", "refactored_code": "    private static final int PRIMARY_USER_ID = 0;\n\n    @Implementation\n    protected UserInfo getPrimaryUser() {\n        return new UserInfo(PRIMARY_USER_ID, null, null,\n                UserInfo.FLAG_INITIALIZED | UserInfo.FLAG_ADMIN | UserInfo.FLAG_PRIMARY);\n    }\n"}
{"magic_number_smell": "            } catch (Throwable t) {\n                throw new RuntimeException(t);\n            }\n            SystemClock.sleep(100);\n        }\n\n        // Check once more before failing.", "refactored_code": "    private static final int SLEEP_MS = 100;\n            } catch (Throwable t) {\n                throw new RuntimeException(t);\n            }\n            SystemClock.sleep(SLEEP_MS);\n        }\n\n        // Check once more before failing."}
{"magic_number_smell": "        helper.scrollVert(true);\n        // Tap on location\n        UiObject2 settingsPanel = mDevice.wait(Until.findObject\n                (By.res(SETTINGS_PACKAGE, \"main_content\")), 2000);\n        int count = 0;\n        UiObject2 locationTitle = null;\n        while(count < 6 && locationTitle == null) {", "refactored_code": "    private static final int TIMEOUT = 2000;\n        helper.scrollVert(true);\n        // Tap on location\n        UiObject2 settingsPanel = mDevice.wait(Until.findObject\n                (By.res(SETTINGS_PACKAGE, \"main_content\")), TIMEOUT);\n        int count = 0;\n        UiObject2 locationTitle = null;\n        while(count < 6 && locationTitle == null) {"}
{"magic_number_smell": "    @Override\n    protected void tearDown() throws Exception {\n        // Exit all settings sub-menus.\n        for (int i = 0; i < 5; ++i) {\n            mDevice.pressBack();\n        }\n        mDevice.pressHome();", "refactored_code": "    private static final int NUM_BACK_BUTTON_PRESSES = 5;\n    @Override\n    protected void tearDown() throws Exception {\n        // Exit all settings sub-menus.\n        for (int i = 0; i < NUM_BACK_BUTTON_PRESSES; ++i) {\n            mDevice.pressBack();\n        }\n        mDevice.pressHome();"}
{"magic_number_smell": "        SettingsHelper.launchSettingsPage(getInstrumentation().getContext(),\n                Settings.ACTION_WIRELESS_SETTINGS);\n        mDevice.wait(Until\n                 .findObject(By.text(\"Hotspot & tethering\")), 2000)\n                 .click();\n        Thread.sleep(2000);\n        UiObject2 usbTethering = mDevice.wait(Until", "refactored_code": "    private static final int TIMEOUT = 2000;\n        SettingsHelper.launchSettingsPage(getInstrumentation().getContext(),\n                Settings.ACTION_WIRELESS_SETTINGS);\n        mDevice.wait(Until\n                 .findObject(By.text(\"Hotspot & tethering\")), TIMEOUT)\n                 .click();\n        Thread.sleep(TIMEOUT);\n        UiObject2 usbTethering = mDevice.wait(Until"}
{"magic_number_smell": "\n        // make sure we are in a clean state before starting the test\n        mDevice.pressHome();\n        Thread.sleep(2000 * 2);\n        launchAppsSettings();\n    }\n", "refactored_code": "    private static final int TIMEOUT = 2000;\n\n        // make sure we are in a clean state before starting the test\n        mDevice.pressHome();\n        Thread.sleep(TIMEOUT * 2);\n        launchAppsSettings();\n    }\n"}
{"magic_number_smell": "    private void verifyRingtone(RingtoneSetting r, String settingName) throws Exception {\n        findRingtoneInList(r.getName()).click();\n        if (mDevice.getProductName().equals(\"walleye\") || mDevice.getProductName().equals(\"taimen\")) {\n            mDevice.wait(Until.findObject(By.text(\"SAVE\")), 2000).click();\n        }\n        else {\n            mDevice.wait(Until.findObject(By.text(\"OK\")), 2000).click();", "refactored_code": "    private static final int TIMEOUT = 2000;\n    private void verifyRingtone(RingtoneSetting r, String settingName) throws Exception {\n        findRingtoneInList(r.getName()).click();\n        if (mDevice.getProductName().equals(\"walleye\") || mDevice.getProductName().equals(\"taimen\")) {\n            mDevice.wait(Until.findObject(By.text(\"SAVE\")), TIMEOUT).click();\n        }\n        else {\n            mDevice.wait(Until.findObject(By.text(\"OK\")), TIMEOUT).click();"}
{"magic_number_smell": "        mDevice.pressBack();\n        mDevice.pressBack();\n        mDevice.pressHome();\n        mDevice.waitForIdle(5000);\n\n        mDevice.executeShellCommand(\"setprop sys.debug.storage_slow 0\");\n        mDevice.executeShellCommand(\"sm set-virtual-disk false\");", "refactored_code": "    private static final int TIMEOUT = 5000;\n        mDevice.pressBack();\n        mDevice.pressBack();\n        mDevice.pressHome();\n        mDevice.waitForIdle(TIMEOUT);\n\n        mDevice.executeShellCommand(\"setprop sys.debug.storage_slow 0\");\n        mDevice.executeShellCommand(\"sm set-virtual-disk false\");"}
{"magic_number_smell": "    @After\n    public void tearDown() {\n        // Exit all settings sub-menus.\n        for (int i = 0; i < 5; ++i) {\n            mDevice.pressBack();\n        }\n        mDevice.pressHome();", "refactored_code": "    private static final int NUM_BACK_BUTTON_PRESSES = 5;\n    @After\n    public void tearDown() {\n        // Exit all settings sub-menus.\n        for (int i = 0; i < NUM_BACK_BUTTON_PRESSES; ++i) {\n            mDevice.pressBack();\n        }\n        mDevice.pressHome();"}
{"magic_number_smell": "     */\n    private static void waitAndAssertTimeGetDefault(String expectedTimeZoneId)\n            throws InterruptedException {\n        for (int i = 0; i < CHECK_DEFAULT_TIMEZONE_TIMEOUT / 200L; i++) {\n            if (expectedTimeZoneId.equals(TimeZone.getDefault().getID())) {\n                return;\n            }", "refactored_code": "    private static final long CHECK_DEFAULT_TIMEZONE_INTERVAL = 200L;\n     */\n    private static void waitAndAssertTimeGetDefault(String expectedTimeZoneId)\n            throws InterruptedException {\n        for (int i = 0; i < CHECK_DEFAULT_TIMEZONE_TIMEOUT / CHECK_DEFAULT_TIMEZONE_INTERVAL; i++) {\n            if (expectedTimeZoneId.equals(TimeZone.getDefault().getID())) {\n                return;\n            }"}
{"magic_number_smell": "        when(mDefaultRingtonePreference.getRingtoneType())\n                .thenReturn(INVALID_RINGTONE_TYPE);\n\n        mDefaultRingtonePreference.setUserId(1);\n        mDefaultRingtonePreference.mUserContext = context;\n        when(mDefaultRingtonePreference.isDefaultRingtone(any(Uri.class))).thenReturn(false);\n", "refactored_code": "    private static final int OWNER_USER_ID = 1;\n        when(mDefaultRingtonePreference.getRingtoneType())\n                .thenReturn(INVALID_RINGTONE_TYPE);\n\n        mDefaultRingtonePreference.setUserId(OWNER_USER_ID);\n        mDefaultRingtonePreference.mUserContext = context;\n        when(mDefaultRingtonePreference.isDefaultRingtone(any(Uri.class))).thenReturn(false);\n"}
{"magic_number_smell": "\n    @Test\n    public void getAnyMissingSubscriptionId_returnNull_whenNoSubscriptionChange() {\n        mRequestArgs.setResetTelephonyAndNetworkPolicyManager(3);\n        doReturn(mSubscriptionInfo1).when(mSubscriptionManager)\n                .getActiveSubscriptionInfo(3);\n        mRequestArgs.setResetApn(SUB_ID_2);", "refactored_code": "    private static final int SUB_ID_1 = 3;\n\n    @Test\n    public void getAnyMissingSubscriptionId_returnNull_whenNoSubscriptionChange() {\n        mRequestArgs.setResetTelephonyAndNetworkPolicyManager(SUB_ID_1);\n        doReturn(mSubscriptionInfo1).when(mSubscriptionManager)\n                .getActiveSubscriptionInfo(SUB_ID_1);\n        mRequestArgs.setResetApn(SUB_ID_2);"}
{"magic_number_smell": " */\npublic class TestUtils {\n    public static final long 1024L = 1024L; // TODO: Change to 1000 in O Robolectric.\n    public static final long MEGABYTE = 1024L * 1024L;\n    public static final long GIGABYTE = 1024L * MEGABYTE;\n\n    public static List<String> getAllXmlKeys(", "refactored_code": "    public static final long KILOBYTE = 1024L; // TODO: Change to 1000 in O Robolectric.\n */\npublic class TestUtils {\n    public static final long KILOBYTE = 1024L; // TODO: Change to 1000 in O Robolectric.\n    public static final long MEGABYTE = KILOBYTE * KILOBYTE;\n    public static final long GIGABYTE = KILOBYTE * MEGABYTE;\n\n    public static List<String> getAllXmlKeys("}
{"magic_number_smell": "    @Test\n    public void isChecked_enabledBoldText_shouldReturnTrue() {\n        Settings.Secure.putInt(mContext.getContentResolver(),\n                Settings.Secure.FONT_WEIGHT_ADJUSTMENT, FontWeightAdjustmentPreferenceController.BOLD_TEXT_ADJUSTMENT);\n\n        mController.updateState(mPreference);\n", "refactored_code": "    private static final int ON = FontWeightAdjustmentPreferenceController.BOLD_TEXT_ADJUSTMENT;\n    @Test\n    public void isChecked_enabledBoldText_shouldReturnTrue() {\n        Settings.Secure.putInt(mContext.getContentResolver(),\n                Settings.Secure.FONT_WEIGHT_ADJUSTMENT, ON);\n\n        mController.updateState(mPreference);\n"}
{"magic_number_smell": "    @Test\n    public void isChecked_enabledTextContrast_shouldReturnTrue() {\n        Settings.Secure.putInt(mContext.getContentResolver(),\n                Settings.Secure.ACCESSIBILITY_HIGH_TEXT_CONTRAST_ENABLED, 1);\n\n        mController.updateState(mPreference);\n", "refactored_code": "    private static final int ON = 1;\n    @Test\n    public void isChecked_enabledTextContrast_shouldReturnTrue() {\n        Settings.Secure.putInt(mContext.getContentResolver(),\n                Settings.Secure.ACCESSIBILITY_HIGH_TEXT_CONTRAST_ENABLED, ON);\n\n        mController.updateState(mPreference);\n"}
{"magic_number_smell": "        mController.setChecked(true);\n\n        assertThat(Settings.Secure.getInt(mContext.getContentResolver(),\n                Settings.Secure.ACCESSIBILITY_LARGE_POINTER_ICON, -1)).isEqualTo(ON);\n    }\n\n    @Test", "refactored_code": "    private static final int UNKNOWN = -1;\n        mController.setChecked(true);\n\n        assertThat(Settings.Secure.getInt(mContext.getContentResolver(),\n                Settings.Secure.ACCESSIBILITY_LARGE_POINTER_ICON, UNKNOWN)).isEqualTo(ON);\n    }\n\n    @Test"}
{"magic_number_smell": "\n    @Test\n    public void fromString_matchMemberObject() {\n        final String preferredShortcutString = STUB_COMPONENT_NAME + \":\" + 3;\n\n        final PreferredShortcut shortcut = PreferredShortcut.fromString(preferredShortcutString);\n", "refactored_code": "    private static final int STUB_TYPE = 3;\n\n    @Test\n    public void fromString_matchMemberObject() {\n        final String preferredShortcutString = STUB_COMPONENT_NAME + \":\" + STUB_TYPE;\n\n        final PreferredShortcut shortcut = PreferredShortcut.fromString(preferredShortcutString);\n"}
{"magic_number_smell": "    @Test\n    public void isChecked_enabledMonoAudio_shouldReturnTrue() {\n        Settings.System.putIntForUser(mContext.getContentResolver(),\n                Settings.System.MASTER_MONO, 1, UserHandle.USER_CURRENT);\n\n        mController.updateState(mPreference);\n", "refactored_code": "    private static final int ON = 1;\n    @Test\n    public void isChecked_enabledMonoAudio_shouldReturnTrue() {\n        Settings.System.putIntForUser(mContext.getContentResolver(),\n                Settings.System.MASTER_MONO, ON, UserHandle.USER_CURRENT);\n\n        mController.updateState(mPreference);\n"}
{"magic_number_smell": "\n    @Test\n    public void isChecked_enabledRbc_shouldReturnTrue() {\n        Settings.Secure.putInt(mContext.getContentResolver(), RBC_PERSIST, 1);\n\n        mController.updateState(mPreference);\n", "refactored_code": "    private static final int ON = 1;\n\n    @Test\n    public void isChecked_enabledRbc_shouldReturnTrue() {\n        Settings.Secure.putInt(mContext.getContentResolver(), RBC_PERSIST, ON);\n\n        mController.updateState(mPreference);\n"}
{"magic_number_smell": "        bridge.mPowerExemptionManager = mPowerExemptionManager;\n\n        doReturn(true).when(mAlarmManager).hasScheduleExactAlarm(TEST_PACKAGE,\n                UserHandle.getUserId(12345));\n        doReturn(createPackageInfoWithPermissions(Manifest.permission.SCHEDULE_EXACT_ALARM))\n                .when(mPackageManager).getPackageInfoAsUser(eq(TEST_PACKAGE), anyInt(), anyInt());\n        doReturn(false).when(mPowerExemptionManager).isAllowListed(TEST_PACKAGE, true);", "refactored_code": "    private static final int TEST_UID = 12345;\n        bridge.mPowerExemptionManager = mPowerExemptionManager;\n\n        doReturn(true).when(mAlarmManager).hasScheduleExactAlarm(TEST_PACKAGE,\n                UserHandle.getUserId(TEST_UID));\n        doReturn(createPackageInfoWithPermissions(Manifest.permission.SCHEDULE_EXACT_ALARM))\n                .when(mPackageManager).getPackageInfoAsUser(eq(TEST_PACKAGE), anyInt(), anyInt());\n        doReturn(false).when(mPowerExemptionManager).isAllowListed(TEST_PACKAGE, true);"}
{"magic_number_smell": "\n  @Test\n  public void updateExtraInfo_updatesRestricted() {\n    when(mPowerAllowlistBackend.isAllowlisted(TEST_PACKAGE_1, 12345)).thenReturn(false);\n    when(mAppOpsManager.checkOpNoThrow(AppOpsManager.OP_RUN_ANY_IN_BACKGROUND,\n            12345, TEST_PACKAGE_1)).thenReturn(AppOpsManager.MODE_IGNORED);\n    AppStateAppBatteryUsageBridge bridge =", "refactored_code": "  private static final int UID_1 = 12345;\n\n  @Test\n  public void updateExtraInfo_updatesRestricted() {\n    when(mPowerAllowlistBackend.isAllowlisted(TEST_PACKAGE_1, UID_1)).thenReturn(false);\n    when(mAppOpsManager.checkOpNoThrow(AppOpsManager.OP_RUN_ANY_IN_BACKGROUND,\n            UID_1, TEST_PACKAGE_1)).thenReturn(AppOpsManager.MODE_IGNORED);\n    AppStateAppBatteryUsageBridge bridge ="}
{"magic_number_smell": "        when(mContext.getSystemService(AppHibernationManager.class))\n                .thenReturn(mAppHibernationManager);\n        when(mPackageManager.getPackageUid(eq(VALID_PACKAGE_NAME), anyInt()))\n                .thenReturn(1);\n        when(mPackageManager.getPackageUid(eq(INVALID_PACKAGE_NAME), anyInt()))\n                .thenThrow(new PackageManager.NameNotFoundException());\n        when(mPackageManager.getTargetSdkVersion(eq(EXEMPTED_PACKAGE_NAME)))", "refactored_code": "    private static final int PACKAGE_UID = 1;\n        when(mContext.getSystemService(AppHibernationManager.class))\n                .thenReturn(mAppHibernationManager);\n        when(mPackageManager.getPackageUid(eq(VALID_PACKAGE_NAME), anyInt()))\n                .thenReturn(PACKAGE_UID);\n        when(mPackageManager.getPackageUid(eq(INVALID_PACKAGE_NAME), anyInt()))\n                .thenThrow(new PackageManager.NameNotFoundException());\n        when(mPackageManager.getTargetSdkVersion(eq(EXEMPTED_PACKAGE_NAME)))"}
{"magic_number_smell": "    public void getBiometricSettingsIntent_whenDisabledByAdmin_quietMode_returnsBlockedIntent() {\n        when(mUserManager.isQuietModeEnabled(any())).thenReturn(true);\n        final EnforcedAdmin enforcedAdmin = new EnforcedAdmin(\n                COMPONENT_NAME, UserHandle.of(2));\n\n        final Intent intent = mBiometricNavigationUtils.getBiometricSettingsIntent(\n                mContext, SETTINGS_CLASS_NAME, enforcedAdmin, Bundle.EMPTY);", "refactored_code": "    private static final int ADMIN_USER_ID = 2;\n    public void getBiometricSettingsIntent_whenDisabledByAdmin_quietMode_returnsBlockedIntent() {\n        when(mUserManager.isQuietModeEnabled(any())).thenReturn(true);\n        final EnforcedAdmin enforcedAdmin = new EnforcedAdmin(\n                COMPONENT_NAME, UserHandle.of(ADMIN_USER_ID));\n\n        final Intent intent = mBiometricNavigationUtils.getBiometricSettingsIntent(\n                mContext, SETTINGS_CLASS_NAME, enforcedAdmin, Bundle.EMPTY);"}
{"magic_number_smell": "        for (int i = 0; i <= expectedLaunches.size(); i++) {\n            final Pair<String, Boolean> expected = i > 0 ? expectedLaunches.get(i - 1) : null;\n            final boolean launchedNext = i == 0\n                    ? helper.launchNext(mRootActivity, 12)\n                    : helper.launchNext(mRootActivity, 12,\n                            expected.second ? RESULT_CONSENT_GRANTED : RESULT_CONSENT_DENIED,\n                            getResultIntent(getStartedModality(expected.first)));", "refactored_code": "    private static final int REQUEST_CODE = 12;\n        for (int i = 0; i <= expectedLaunches.size(); i++) {\n            final Pair<String, Boolean> expected = i > 0 ? expectedLaunches.get(i - 1) : null;\n            final boolean launchedNext = i == 0\n                    ? helper.launchNext(mRootActivity, REQUEST_CODE)\n                    : helper.launchNext(mRootActivity, REQUEST_CODE,\n                            expected.second ? RESULT_CONSENT_GRANTED : RESULT_CONSENT_DENIED,\n                            getResultIntent(getStartedModality(expected.first)));"}
{"magic_number_smell": "    private static final ComponentName COMPONENT_NAME =\n            new ComponentName(\"package\", \"class\");\n    private static final int UserHandle.myUserId() = UserHandle.myUserId();\n    private static final UserHandle USER_HANDLE = new UserHandle(UserHandle.myUserId());\n\n    @Mock\n    private PackageManager mPackageManager;", "refactored_code": "    private static final int USER_ID = UserHandle.myUserId();\n    private static final ComponentName COMPONENT_NAME =\n            new ComponentName(\"package\", \"class\");\n    private static final int USER_ID = UserHandle.myUserId();\n    private static final UserHandle USER_HANDLE = new UserHandle(USER_ID);\n\n    @Mock\n    private PackageManager mPackageManager;"}
{"magic_number_smell": "    private static final ComponentName COMPONENT_NAME =\n            new ComponentName(\"package\", \"class\");\n    private static final int UserHandle.myUserId() = UserHandle.myUserId();\n    private static final UserHandle USER_HANDLE = new UserHandle(UserHandle.myUserId());\n\n\n    @Mock", "refactored_code": "    private static final int USER_ID = UserHandle.myUserId();\n    private static final ComponentName COMPONENT_NAME =\n            new ComponentName(\"package\", \"class\");\n    private static final int USER_ID = UserHandle.myUserId();\n    private static final UserHandle USER_HANDLE = new UserHandle(USER_ID);\n\n\n    @Mock"}
{"magic_number_smell": "    public void enroll_firstVersion_onEnrollmentCallbacks_triggerGivenCallback() {\n        ArgumentCaptor<FaceManager.EnrollmentCallback> callbackCaptor =\n                ArgumentCaptor.forClass(FaceManager.EnrollmentCallback.class);\n        mFaceUpdater.enroll(0, HARDWARE_AUTH_TOKEN, CANCELLATION_SIGNAL, mEnrollmentCallback,\n                DISABLED_FEATURES);\n        verify(mFaceManager).enroll(\n                eq(0),", "refactored_code": "    private static final int USER_ID = 0;\n    public void enroll_firstVersion_onEnrollmentCallbacks_triggerGivenCallback() {\n        ArgumentCaptor<FaceManager.EnrollmentCallback> callbackCaptor =\n                ArgumentCaptor.forClass(FaceManager.EnrollmentCallback.class);\n        mFaceUpdater.enroll(USER_ID, HARDWARE_AUTH_TOKEN, CANCELLATION_SIGNAL, mEnrollmentCallback,\n                DISABLED_FEATURES);\n        verify(mFaceManager).enroll(\n                eq(USER_ID),"}
{"magic_number_smell": "    private static final ComponentName COMPONENT_NAME =\n            new ComponentName(\"package\", \"class\");\n    private static final int UserHandle.myUserId() = UserHandle.myUserId();\n    private static final UserHandle USER_HANDLE = new UserHandle(UserHandle.myUserId());\n\n\n    @Mock", "refactored_code": "    private static final int USER_ID = UserHandle.myUserId();\n    private static final ComponentName COMPONENT_NAME =\n            new ComponentName(\"package\", \"class\");\n    private static final int USER_ID = UserHandle.myUserId();\n    private static final UserHandle USER_HANDLE = new UserHandle(USER_ID);\n\n\n    @Mock"}
{"magic_number_smell": "    public void enroll_onEnrollmentCallbacks_triggerGivenCallback() {\n        ArgumentCaptor<FingerprintManager.EnrollmentCallback> callbackCaptor =\n                ArgumentCaptor.forClass(FingerprintManager.EnrollmentCallback.class);\n        mFingerprintUpdater.enroll(HARDWARE_AUTH_TOKEN, CANCELLATION_SIGNAL, 0,\n                mEnrollmentCallback, ENROLL_REASON);\n        verify(mFingerprintManager).enroll(\n                same(HARDWARE_AUTH_TOKEN),", "refactored_code": "    private static final int USER_ID = 0;\n    public void enroll_onEnrollmentCallbacks_triggerGivenCallback() {\n        ArgumentCaptor<FingerprintManager.EnrollmentCallback> callbackCaptor =\n                ArgumentCaptor.forClass(FingerprintManager.EnrollmentCallback.class);\n        mFingerprintUpdater.enroll(HARDWARE_AUTH_TOKEN, CANCELLATION_SIGNAL, USER_ID,\n                mEnrollmentCallback, ENROLL_REASON);\n        verify(mFingerprintManager).enroll(\n                same(HARDWARE_AUTH_TOKEN),"}
{"magic_number_smell": "        mApplication = ApplicationProvider.getApplicationContext();\n        mViewModel = new FingerprintEnrollEnrollingViewModel(\n                mApplication,\n                33,\n                newFingerprintRepository(mFingerprintManager, TYPE_UDFPS_OPTICAL,  5)\n            );\n    }", "refactored_code": "    private static final int TEST_USER_ID = 33;\n        mApplication = ApplicationProvider.getApplicationContext();\n        mViewModel = new FingerprintEnrollEnrollingViewModel(\n                mApplication,\n                TEST_USER_ID,\n                newFingerprintRepository(mFingerprintManager, TYPE_UDFPS_OPTICAL,  5)\n            );\n    }"}
{"magic_number_smell": "    public void setUp() {\n        mApplication = ApplicationProvider.getApplicationContext();\n        mRequest = new EnrollmentRequest(new Intent(), mApplication, true);\n        mViewModel = new FingerprintEnrollFinishViewModel(mApplication, 334, mRequest,\n                newFingerprintRepository(mFingerprintManager, TYPE_UDFPS_OPTICAL, MAX_ENROLLABLE));\n    }\n", "refactored_code": "    private static final int USER_ID = 334;\n    public void setUp() {\n        mApplication = ApplicationProvider.getApplicationContext();\n        mRequest = new EnrollmentRequest(new Intent(), mApplication, true);\n        mViewModel = new FingerprintEnrollFinishViewModel(mApplication, USER_ID, mRequest,\n                newFingerprintRepository(mFingerprintManager, TYPE_UDFPS_OPTICAL, MAX_ENROLLABLE));\n    }\n"}
{"magic_number_smell": "        // Not use MessageDisplayController by default\n        when(mResources.getBoolean(mEnrollmentMessageDisplayControllerFlagResId)).thenReturn(false);\n        mViewModel = new FingerprintEnrollProgressViewModel(mApplication, mFingerprintUpdater,\n                334);\n\n        mCancellationSignalWrapper.mValue = null;\n        mCallbackWrapper.mValue = null;", "refactored_code": "    private static final int TEST_USER_ID = 334;\n        // Not use MessageDisplayController by default\n        when(mResources.getBoolean(mEnrollmentMessageDisplayControllerFlagResId)).thenReturn(false);\n        mViewModel = new FingerprintEnrollProgressViewModel(mApplication, mFingerprintUpdater,\n                TEST_USER_ID);\n\n        mCancellationSignalWrapper.mValue = null;\n        mCallbackWrapper.mValue = null;"}
{"magic_number_smell": "\n        @Override\n        public int getMax() {\n            return 2112;\n        }\n\n        @Override", "refactored_code": "        private static final int MAX_STEPS = 2112;\n\n        @Override\n        public int getMax() {\n            return MAX_STEPS;\n        }\n\n        @Override"}
{"magic_number_smell": "    @Test\n    public void getSummaryLimit_NoLimitNoUsage_WarningUsed() {\n        info.warningLevel = POSITIVE_LARGE;\n        info.limitLevel = 0;\n        info.usageLevel = 0;\n\n        assertThat(mInfoController.getSummaryLimit(info)).isEqualTo(info.warningLevel);", "refactored_code": "    private static final int ZERO = 0;\n    @Test\n    public void getSummaryLimit_NoLimitNoUsage_WarningUsed() {\n        info.warningLevel = POSITIVE_LARGE;\n        info.limitLevel = ZERO;\n        info.usageLevel = ZERO;\n\n        assertThat(mInfoController.getSummaryLimit(info)).isEqualTo(info.warningLevel);"}
{"magic_number_smell": "        assertThat(mSummaryPreference.getDataUsed(mHolder)).isNotNull();\n\n        final long now = System.currentTimeMillis();\n        mCycleEnd = now + 1000000000L;\n        mUpdateTime = now - UPDATE_LAG_MILLIS;\n    }\n", "refactored_code": "    private static final long CYCLE_DURATION_MILLIS = 1000000000L;\n        assertThat(mSummaryPreference.getDataUsed(mHolder)).isNotNull();\n\n        final long now = System.currentTimeMillis();\n        mCycleEnd = now + CYCLE_DURATION_MILLIS;\n        mUpdateTime = now - UPDATE_LAG_MILLIS;\n    }\n"}
{"magic_number_smell": "\n        final int mode = Settings.Global.getInt(mContext.getContentResolver(),\n                Settings.Global.ENABLE_BACK_ANIMATION, -1 /* default */);\n        assertThat(mode).isEqualTo(0);\n    }\n\n    @Test", "refactored_code": "    private static final int SETTING_VALUE_OFF = 0;\n\n        final int mode = Settings.Global.getInt(mContext.getContentResolver(),\n                Settings.Global.ENABLE_BACK_ANIMATION, -1 /* default */);\n        assertThat(mode).isEqualTo(SETTING_VALUE_OFF);\n    }\n\n    @Test"}
{"magic_number_smell": "                new QuarantinedAppStateBridge(mContext, null, null);\n        final AppEntry entry = mock(AppEntry.class);\n\n        bridge.updateExtraInfo(entry, TEST_PACKAGE, UserHandle.getUid(TEST_USER_ID_2, 1234));\n        assertThat(entry.extraInfo).isEqualTo(true);\n    }\n", "refactored_code": "    private static final int TEST_APP_ID = 1234;\n                new QuarantinedAppStateBridge(mContext, null, null);\n        final AppEntry entry = mock(AppEntry.class);\n\n        bridge.updateExtraInfo(entry, TEST_PACKAGE, UserHandle.getUid(TEST_USER_ID_2, TEST_APP_ID));\n        assertThat(entry.extraInfo).isEqualTo(true);\n    }\n"}
{"magic_number_smell": "\n    @Test\n    public void getSubscriptionInfo_returnSubscriptionInfo_whenActive() {\n        doReturn(3).when(mSubscriptionInfo1).getSubscriptionId();\n        doReturn(0).when(mSubscriptionInfo1).getSimSlotIndex();\n        doReturn(SUB_ID_2).when(mSubscriptionInfo2).getSubscriptionId();\n        doReturn(1).when(mSubscriptionInfo2).getSimSlotIndex();", "refactored_code": "    private static final int SUB_ID_1 = 3;\n\n    @Test\n    public void getSubscriptionInfo_returnSubscriptionInfo_whenActive() {\n        doReturn(SUB_ID_1).when(mSubscriptionInfo1).getSubscriptionId();\n        doReturn(0).when(mSubscriptionInfo1).getSimSlotIndex();\n        doReturn(SUB_ID_2).when(mSubscriptionInfo2).getSubscriptionId();\n        doReturn(1).when(mSubscriptionInfo2).getSimSlotIndex();"}
{"magic_number_smell": "        mContext = spy(ApplicationProvider.getApplicationContext());\n        mInfo = new ArrayList<>();\n        mLoader = new StorageAsyncLoader(mContext, mUserManager, \"id\", mSource, mPackageManager);\n        when(mPackageManager.getInstalledApplicationsAsUser(eq(0), anyInt()))\n                .thenReturn(mInfo);\n        UserInfo info = new UserInfo();\n        mUsers = new ArrayList<>();", "refactored_code": "    private static final int PRIMARY_USER_ID = 0;\n        mContext = spy(ApplicationProvider.getApplicationContext());\n        mInfo = new ArrayList<>();\n        mLoader = new StorageAsyncLoader(mContext, mUserManager, \"id\", mSource, mPackageManager);\n        when(mPackageManager.getInstalledApplicationsAsUser(eq(PRIMARY_USER_ID), anyInt()))\n                .thenReturn(mInfo);\n        UserInfo info = new UserInfo();\n        mUsers = new ArrayList<>();"}
{"magic_number_smell": "\n        synchronized (mController.mLock) {\n            mController.setSelectedStorageEntry(defaultInternalStorageEntry);\n            mController.waitUpdateState(10_000L);\n        }\n\n        assertThat(mController.mUsedBytes).isEqualTo(USAGE_BYTES);", "refactored_code": "    private static final long WAIT_TIMEOUT = 10_000L;\n\n        synchronized (mController.mLock) {\n            mController.setSelectedStorageEntry(defaultInternalStorageEntry);\n            mController.waitUpdateState(WAIT_TIMEOUT);\n        }\n\n        assertThat(mController.mUsedBytes).isEqualTo(USAGE_BYTES);"}
{"magic_number_smell": "public class ActionDisabledLearnMoreButtonLauncherImplTest {\n\n    private static final int 123 = 123;\n    private static final UserHandle ENFORCED_ADMIN_USER = UserHandle.of(123);\n\n    private static final int CONTEXT_USER_ID = -123;\n    private static final UserHandle CONTEXT_USER = UserHandle.of(CONTEXT_USER_ID);", "refactored_code": "    private static final int ENFORCED_ADMIN_USER_ID = 123;\npublic class ActionDisabledLearnMoreButtonLauncherImplTest {\n\n    private static final int ENFORCED_ADMIN_USER_ID = 123;\n    private static final UserHandle ENFORCED_ADMIN_USER = UserHandle.of(ENFORCED_ADMIN_USER_ID);\n\n    private static final int CONTEXT_USER_ID = -ENFORCED_ADMIN_USER_ID;\n    private static final UserHandle CONTEXT_USER = UserHandle.of(CONTEXT_USER_ID);"}
{"magic_number_smell": "\n    @Test\n    public void getCardControllerClass_hasUnsupportedCardType_shouldAlwaysGetNull() {\n        assertThat(ContextualCardLookupTable.getCardControllerClass(-99999))\n                .isNull();\n    }\n", "refactored_code": "    private static final int UNSUPPORTED_CARD_TYPE = -99999;\n\n    @Test\n    public void getCardControllerClass_hasUnsupportedCardType_shouldAlwaysGetNull() {\n        assertThat(ContextualCardLookupTable.getCardControllerClass(UNSUPPORTED_CARD_TYPE))\n                .isNull();\n    }\n"}
{"magic_number_smell": "        when(mContext.getSystemService(SubscriptionManager.class)).thenReturn(mSubscriptionManager);\n\n        mActiveSubscriptions = new ArrayList<SubscriptionInfo>();\n        addMockSubscription(3);\n        addMockSubscription(SUB_ID2);\n        doReturn(mActiveSubscriptions).when(mSubscriptionManager).getActiveSubscriptionInfoList();\n", "refactored_code": "    private static final int SUB_ID1 = 3;\n        when(mContext.getSystemService(SubscriptionManager.class)).thenReturn(mSubscriptionManager);\n\n        mActiveSubscriptions = new ArrayList<SubscriptionInfo>();\n        addMockSubscription(SUB_ID1);\n        addMockSubscription(SUB_ID2);\n        doReturn(mActiveSubscriptions).when(mSubscriptionManager).getActiveSubscriptionInfoList();\n"}
{"magic_number_smell": "\n    @Test\n    public void setChecked_setAirplaneModeEnabler_setCheckedTrue() {\n        // Set airplane mode 1 by setChecked\n        mController.setAirplaneModeEnabler(mAirplaneModeEnabler);\n\n        assertThat(mController.setChecked(true)).isTrue();", "refactored_code": "    private static final int ON = 1;\n\n    @Test\n    public void setChecked_setAirplaneModeEnabler_setCheckedTrue() {\n        // Set airplane mode ON by setChecked\n        mController.setAirplaneModeEnabler(mAirplaneModeEnabler);\n\n        assertThat(mController.setChecked(true)).isTrue();"}
{"magic_number_smell": "        MockitoAnnotations.initMocks(this);\n        mContext = spy(ApplicationProvider.getApplicationContext());\n        when(mContext.getSystemService(TelephonyManager.class)).thenReturn(mTelephonyManager);\n        doReturn(mTelephonyManager).when(mTelephonyManager).createForSubscriptionId(1);\n\n        mAllowedNetworkTypesListener =\n                spy(new AllowedNetworkTypesListener(mContext.getMainExecutor()));", "refactored_code": "    private static final int SUB_ID = 1;\n        MockitoAnnotations.initMocks(this);\n        mContext = spy(ApplicationProvider.getApplicationContext());\n        when(mContext.getSystemService(TelephonyManager.class)).thenReturn(mTelephonyManager);\n        doReturn(mTelephonyManager).when(mTelephonyManager).createForSubscriptionId(SUB_ID);\n\n        mAllowedNetworkTypesListener =\n                spy(new AllowedNetworkTypesListener(mContext.getMainExecutor()));"}
{"magic_number_smell": "\n        mController = new CarrierWifiTogglePreferenceController(mContext,\n                CarrierWifiTogglePreferenceController.CARRIER_WIFI_TOGGLE_PREF_KEY);\n        mController.init(mock(Lifecycle.class), 2);\n        mController.mIsCarrierProvisionWifiEnabled = true;\n        doReturn(true).when(mWifiPickerTrackerHelper).isCarrierNetworkActive();\n        doReturn(SSID).when(mWifiPickerTrackerHelper).getCarrierNetworkSsid();", "refactored_code": "    private static final int SUB_ID = 2;\n\n        mController = new CarrierWifiTogglePreferenceController(mContext,\n                CarrierWifiTogglePreferenceController.CARRIER_WIFI_TOGGLE_PREF_KEY);\n        mController.init(mock(Lifecycle.class), SUB_ID);\n        mController.mIsCarrierProvisionWifiEnabled = true;\n        doReturn(true).when(mWifiPickerTrackerHelper).isCarrierNetworkActive();\n        doReturn(SSID).when(mWifiPickerTrackerHelper).getCarrierNetworkSsid();"}
{"magic_number_smell": "    @Test\n    public void convertSubscriptionId_fromIntentExtra_copyToBundleArgument() {\n        Intent intent = new Intent(ACTIONS_ALLOWED[0]);\n        intent.putExtra(Settings.EXTRA_SUB_ID, 3);\n\n        Intent convertedIntent = mIntentConverter.apply(intent);\n", "refactored_code": "    private static final int TEST_SUBSCRIPTION_ID = 3;\n    @Test\n    public void convertSubscriptionId_fromIntentExtra_copyToBundleArgument() {\n        Intent intent = new Intent(ACTIONS_ALLOWED[0]);\n        intent.putExtra(Settings.EXTRA_SUB_ID, TEST_SUBSCRIPTION_ID);\n\n        Intent convertedIntent = mIntentConverter.apply(intent);\n"}
{"magic_number_smell": "\n        mPreferenceManager = new PreferenceManager(mContext);\n        mPreferenceScreen = mPreferenceManager.createPreferenceScreen(mContext);\n        mPreferenceScreen.setInitialExpandedChildrenCount(3);\n        mPreferenceScreen.addPreference(mPreferenceCategory);\n    }\n", "refactored_code": "    private static final int EXPANDED_CHILDREN_COUNT = 3;\n\n        mPreferenceManager = new PreferenceManager(mContext);\n        mPreferenceScreen = mPreferenceManager.createPreferenceScreen(mContext);\n        mPreferenceScreen.setInitialExpandedChildrenCount(EXPANDED_CHILDREN_COUNT);\n        mPreferenceScreen.addPreference(mPreferenceCategory);\n    }\n"}
{"magic_number_smell": "        when(mockWifiItem.getTitle()).thenReturn(title);\n        when(mockWifiItem.getSummary()).thenReturn(summary);\n        when(mockWifiItem.getConnectedState()).thenReturn(connectedState);\n        when(mockWifiItem.getLevel()).thenReturn(3);\n        when(mockWifiItem.getKey()).thenReturn(key);\n        when(mockWifiItem.shouldEditBeforeConnect()).thenReturn(shouldEditBeforeConnect);\n    }", "refactored_code": "    private static final int MOCK_SLICE_LEVEL = 3;\n        when(mockWifiItem.getTitle()).thenReturn(title);\n        when(mockWifiItem.getSummary()).thenReturn(summary);\n        when(mockWifiItem.getConnectedState()).thenReturn(connectedState);\n        when(mockWifiItem.getLevel()).thenReturn(MOCK_SLICE_LEVEL);\n        when(mockWifiItem.getKey()).thenReturn(key);\n        when(mockWifiItem.shouldEditBeforeConnect()).thenReturn(shouldEditBeforeConnect);\n    }"}
{"magic_number_smell": "        when(mWifiPickerTrackerHelper.isCarrierNetworkActive()).thenReturn(false);\n        when(mWifiPickerTrackerHelper.getCarrierNetworkLevel()).thenReturn(WIFI_LEVEL_MAX);\n\n        mController.getIcon(1);\n\n        verify(sInjector).getIcon(any(), eq(SIGNAL_STRENGTH_GOOD), anyInt(), anyBoolean(),\n                anyBoolean());", "refactored_code": "    private static final int SUB_ID = 1;\n        when(mWifiPickerTrackerHelper.isCarrierNetworkActive()).thenReturn(false);\n        when(mWifiPickerTrackerHelper.getCarrierNetworkLevel()).thenReturn(WIFI_LEVEL_MAX);\n\n        mController.getIcon(SUB_ID);\n\n        verify(sInjector).getIcon(any(), eq(SIGNAL_STRENGTH_GOOD), anyInt(), anyBoolean(),\n                anyBoolean());"}
{"magic_number_smell": "        // Each subscription's default display name is unique.\n        final SubscriptionInfo info1 = mock(SubscriptionInfo.class);\n        final SubscriptionInfo info2 = mock(SubscriptionInfo.class);\n        when(info1.getSubscriptionId()).thenReturn(1);\n        when(info2.getSubscriptionId()).thenReturn(SUBID_2);\n        when(info1.getDisplayName()).thenReturn(CARRIER_1);\n        when(info2.getDisplayName()).thenReturn(CARRIER_2);", "refactored_code": "    private static final int SUBID_1 = 1;\n        // Each subscription's default display name is unique.\n        final SubscriptionInfo info1 = mock(SubscriptionInfo.class);\n        final SubscriptionInfo info2 = mock(SubscriptionInfo.class);\n        when(info1.getSubscriptionId()).thenReturn(SUBID_1);\n        when(info2.getSubscriptionId()).thenReturn(SUBID_2);\n        when(info1.getDisplayName()).thenReturn(CARRIER_1);\n        when(info2.getDisplayName()).thenReturn(CARRIER_2);"}
{"magic_number_smell": "        int removedLogicalSlotIndex = 0;\n\n        Collection<UiccSlotMapping> testUiccSlotMappings = UiccSlotUtil.prepareUiccSlotMappings(\n                uiccSlotMappings, false, 0, 0, removedLogicalSlotIndex);\n\n        compareTwoUiccSlotMappings(testUiccSlotMappings, verifyUiccSlotMappings);\n    }", "refactored_code": "    private static final int ESIM_PHYSICAL_SLOT = 0;\n        int removedLogicalSlotIndex = 0;\n\n        Collection<UiccSlotMapping> testUiccSlotMappings = UiccSlotUtil.prepareUiccSlotMappings(\n                uiccSlotMappings, false, ESIM_PHYSICAL_SLOT, 0, removedLogicalSlotIndex);\n\n        compareTwoUiccSlotMappings(testUiccSlotMappings, verifyUiccSlotMappings);\n    }"}
{"magic_number_smell": "        when(mContext.getSystemService(Context.TELEPHONY_SERVICE)).thenReturn(mTelephonyManager);\n        when(mContext.getSystemService(SubscriptionManager.class)).thenReturn(mSubscriptionManager);\n        CarrierConfigCache.setTestInstance(mContext, mCarrierConfigCache);\n        doReturn(mTelephonyManager).when(mTelephonyManager).createForSubscriptionId(2);\n        doReturn(mInvalidTelephonyManager).when(mTelephonyManager).createForSubscriptionId(\n                SubscriptionManager.INVALID_SUBSCRIPTION_ID);\n", "refactored_code": "    private static final int SUB_ID = 2;\n        when(mContext.getSystemService(Context.TELEPHONY_SERVICE)).thenReturn(mTelephonyManager);\n        when(mContext.getSystemService(SubscriptionManager.class)).thenReturn(mSubscriptionManager);\n        CarrierConfigCache.setTestInstance(mContext, mCarrierConfigCache);\n        doReturn(mTelephonyManager).when(mTelephonyManager).createForSubscriptionId(SUB_ID);\n        doReturn(mInvalidTelephonyManager).when(mTelephonyManager).createForSubscriptionId(\n                SubscriptionManager.INVALID_SUBSCRIPTION_ID);\n"}
{"magic_number_smell": "        mContext = spy(ApplicationProvider.getApplicationContext());\n        when(mContext.getSystemService(Context.TELEPHONY_SERVICE)).thenReturn(mTelephonyManager);\n        when(mContext.getSystemService(SubscriptionManager.class)).thenReturn(mSubscriptionManager);\n        doReturn(mTelephonyManager).when(mTelephonyManager).createForSubscriptionId(2);\n        doReturn(mInvalidTelephonyManager).when(mTelephonyManager).createForSubscriptionId(\n                SubscriptionManager.INVALID_SUBSCRIPTION_ID);\n        CarrierConfigCache.setTestInstance(mContext, mCarrierConfigCache);", "refactored_code": "    private static final int SUB_ID = 2;\n        mContext = spy(ApplicationProvider.getApplicationContext());\n        when(mContext.getSystemService(Context.TELEPHONY_SERVICE)).thenReturn(mTelephonyManager);\n        when(mContext.getSystemService(SubscriptionManager.class)).thenReturn(mSubscriptionManager);\n        doReturn(mTelephonyManager).when(mTelephonyManager).createForSubscriptionId(SUB_ID);\n        doReturn(mInvalidTelephonyManager).when(mTelephonyManager).createForSubscriptionId(\n                SubscriptionManager.INVALID_SUBSCRIPTION_ID);\n        CarrierConfigCache.setTestInstance(mContext, mCarrierConfigCache);"}
{"magic_number_smell": "        mContext = spy(ApplicationProvider.getApplicationContext());\n        when(mContext.getSystemService(TelephonyManager.class)).thenReturn(mTelephonyManager);\n        CarrierConfigCache.setTestInstance(mContext, mCarrierConfigCache);\n        doReturn(mTelephonyManager).when(mTelephonyManager).createForSubscriptionId(2);\n        doReturn(mInvalidTelephonyManager).when(mTelephonyManager).createForSubscriptionId(\n                SubscriptionManager.INVALID_SUBSCRIPTION_ID);\n        Settings.Global.putString(mContext.getContentResolver(),", "refactored_code": "    private static final int SUB_ID = 2;\n        mContext = spy(ApplicationProvider.getApplicationContext());\n        when(mContext.getSystemService(TelephonyManager.class)).thenReturn(mTelephonyManager);\n        CarrierConfigCache.setTestInstance(mContext, mCarrierConfigCache);\n        doReturn(mTelephonyManager).when(mTelephonyManager).createForSubscriptionId(SUB_ID);\n        doReturn(mInvalidTelephonyManager).when(mTelephonyManager).createForSubscriptionId(\n                SubscriptionManager.INVALID_SUBSCRIPTION_ID);\n        Settings.Global.putString(mContext.getContentResolver(),"}
{"magic_number_smell": "        mScreen.addPreference(mCategory);\n\n        mController = new DisabledSubscriptionController(mContext, KEY);\n        mController.init(111);\n    }\n\n    @Test", "refactored_code": "    private static final int SUB_ID = 111;\n        mScreen.addPreference(mCategory);\n\n        mController = new DisabledSubscriptionController(mContext, KEY);\n        mController.init(SUB_ID);\n    }\n\n    @Test"}
{"magic_number_smell": "        MockitoAnnotations.initMocks(this);\n        mContext = spy(ApplicationProvider.getApplicationContext());\n        when(mContext.getSystemService(SubscriptionManager.class)).thenReturn(mSubscriptionManager);\n        when(mInfo.getSubscriptionId()).thenReturn(111);\n        SubscriptionUtil.setAvailableSubscriptionsForTesting(Arrays.asList(mInfo));\n        mController = new DisableSimFooterPreferenceController(mContext, PREF_KEY);\n    }", "refactored_code": "    private static final int SUB_ID = 111;\n        MockitoAnnotations.initMocks(this);\n        mContext = spy(ApplicationProvider.getApplicationContext());\n        when(mContext.getSystemService(SubscriptionManager.class)).thenReturn(mSubscriptionManager);\n        when(mInfo.getSubscriptionId()).thenReturn(SUB_ID);\n        SubscriptionUtil.setAvailableSubscriptionsForTesting(Arrays.asList(mInfo));\n        mController = new DisableSimFooterPreferenceController(mContext, PREF_KEY);\n    }"}
{"magic_number_smell": "        when(mContext.getSystemService(TelephonyManager.class)).thenReturn(mTelephonyManager);\n        CarrierConfigCache.setTestInstance(mContext, mCarrierConfigCache);\n\n        doReturn(mTelephonyManager).when(mTelephonyManager).createForSubscriptionId(2);\n        doReturn(mInvalidTelephonyManager).when(mTelephonyManager).createForSubscriptionId(\n                SubscriptionManager.INVALID_SUBSCRIPTION_ID);\n", "refactored_code": "    private static final int SUB_ID = 2;\n        when(mContext.getSystemService(TelephonyManager.class)).thenReturn(mTelephonyManager);\n        CarrierConfigCache.setTestInstance(mContext, mCarrierConfigCache);\n\n        doReturn(mTelephonyManager).when(mTelephonyManager).createForSubscriptionId(SUB_ID);\n        doReturn(mInvalidTelephonyManager).when(mTelephonyManager).createForSubscriptionId(\n                SubscriptionManager.INVALID_SUBSCRIPTION_ID);\n"}
{"magic_number_smell": "        CarrierConfigCache.setTestInstance(mContext, mCarrierConfigCache);\n        when(mContext.getSystemService(Context.TELEPHONY_SERVICE)).thenReturn(mTelephonyManager);\n        when(mContext.getSystemService(TelephonyManager.class)).thenReturn(mTelephonyManager);\n        doReturn(mTelephonyManager).when(mTelephonyManager).createForSubscriptionId(2);\n        doReturn(mInvalidTelephonyManager).when(mTelephonyManager).createForSubscriptionId(\n                SubscriptionManager.INVALID_SUBSCRIPTION_ID);\n        doReturn(mServiceState).when(mTelephonyManager).getServiceState();", "refactored_code": "    private static final int SUB_ID = 2;\n        CarrierConfigCache.setTestInstance(mContext, mCarrierConfigCache);\n        when(mContext.getSystemService(Context.TELEPHONY_SERVICE)).thenReturn(mTelephonyManager);\n        when(mContext.getSystemService(TelephonyManager.class)).thenReturn(mTelephonyManager);\n        doReturn(mTelephonyManager).when(mTelephonyManager).createForSubscriptionId(SUB_ID);\n        doReturn(mInvalidTelephonyManager).when(mTelephonyManager).createForSubscriptionId(\n                SubscriptionManager.INVALID_SUBSCRIPTION_ID);\n        doReturn(mServiceState).when(mTelephonyManager).getServiceState();"}
{"magic_number_smell": "        when(mContext.getSystemService(SubscriptionManager.class)).thenReturn(mSubscriptionManager);\n        CarrierConfigCache.setTestInstance(mContext, mCarrierConfigCache);\n\n        doReturn(mTelephonyManager).when(mTelephonyManager).createForSubscriptionId(2);\n        doReturn(mInvalidTelephonyManager).when(mTelephonyManager).createForSubscriptionId(\n                SubscriptionManager.INVALID_SUBSCRIPTION_ID);\n", "refactored_code": "    private static final int SUB_ID = 2;\n        when(mContext.getSystemService(SubscriptionManager.class)).thenReturn(mSubscriptionManager);\n        CarrierConfigCache.setTestInstance(mContext, mCarrierConfigCache);\n\n        doReturn(mTelephonyManager).when(mTelephonyManager).createForSubscriptionId(SUB_ID);\n        doReturn(mInvalidTelephonyManager).when(mTelephonyManager).createForSubscriptionId(\n                SubscriptionManager.INVALID_SUBSCRIPTION_ID);\n"}
{"magic_number_smell": "        //setup for SliceBroadcastReceiver test\n        mReceiver = spy(new SliceBroadcastReceiver());\n\n        mQueryImsState = spy(new MockVolteQueryImsState(mContext, 1));\n        mQueryImsState.setEnabledByPlatform(true);\n        mQueryImsState.setIsProvisionedOnDevice(true);\n        mQueryImsState.setIsTtyOnVolteEnabled(true);", "refactored_code": "    private static final int SUB_ID = 1;\n        //setup for SliceBroadcastReceiver test\n        mReceiver = spy(new SliceBroadcastReceiver());\n\n        mQueryImsState = spy(new MockVolteQueryImsState(mContext, SUB_ID));\n        mQueryImsState.setEnabledByPlatform(true);\n        mQueryImsState.setIsProvisionedOnDevice(true);\n        mQueryImsState.setIsTtyOnVolteEnabled(true);"}
{"magic_number_smell": "\n        mContext = spy(ApplicationProvider.getApplicationContext());\n        when(mContext.getSystemService(TelephonyManager.class)).thenReturn(mTelephonyManager);\n        when(mTelephonyManager.createForSubscriptionId(2)).thenReturn(mTelephonyManager);\n\n        mPreference = new Preference(mContext);\n        mController = new EuiccPreferenceController(mContext, \"euicc\");", "refactored_code": "    private static final int SUB_ID = 2;\n\n        mContext = spy(ApplicationProvider.getApplicationContext());\n        when(mContext.getSystemService(TelephonyManager.class)).thenReturn(mTelephonyManager);\n        when(mTelephonyManager.createForSubscriptionId(SUB_ID)).thenReturn(mTelephonyManager);\n\n        mPreference = new Preference(mContext);\n        mController = new EuiccPreferenceController(mContext, \"euicc\");"}
{"magic_number_smell": "        doReturn(mTelephonyManager).when(mContext).getSystemService(Context.TELEPHONY_SERVICE);\n\n        when(mContext.getSystemService(SubscriptionManager.class)).thenReturn(mSubscriptionManager);\n        doReturn(mTelephonyManager).when(mTelephonyManager).createForSubscriptionId(2);\n        doReturn(mInvalidTelephonyManager).when(mTelephonyManager).createForSubscriptionId(\n                SubscriptionManager.INVALID_SUBSCRIPTION_ID);\n        doReturn(mFragmentTransaction).when(mFragmentManager).beginTransaction();", "refactored_code": "    private static final int SUB_ID = 2;\n        doReturn(mTelephonyManager).when(mContext).getSystemService(Context.TELEPHONY_SERVICE);\n\n        when(mContext.getSystemService(SubscriptionManager.class)).thenReturn(mSubscriptionManager);\n        doReturn(mTelephonyManager).when(mTelephonyManager).createForSubscriptionId(SUB_ID);\n        doReturn(mInvalidTelephonyManager).when(mTelephonyManager).createForSubscriptionId(\n                SubscriptionManager.INVALID_SUBSCRIPTION_ID);\n        doReturn(mFragmentTransaction).when(mFragmentManager).beginTransaction();"}
{"magic_number_smell": "        mContext = spy(ApplicationProvider.getApplicationContext());\n        when(mContext.getSystemService(SubscriptionManager.class)).thenReturn(mSubscriptionManager);\n        when(mContext.getSystemService(TelephonyManager.class)).thenReturn(mTelephonyManager);\n        when(mTelephonyManager.createForSubscriptionId(1)).thenReturn(mTelephonyManager);\n        when(mTelephonyManager.createForSubscriptionId(SUB_ID_2)).thenReturn(mTelephonyManager2);\n        when(mContext.getPackageManager()).thenReturn(mPackageManager);\n", "refactored_code": "    private static final int SUB_ID_1 = 1;\n        mContext = spy(ApplicationProvider.getApplicationContext());\n        when(mContext.getSystemService(SubscriptionManager.class)).thenReturn(mSubscriptionManager);\n        when(mContext.getSystemService(TelephonyManager.class)).thenReturn(mTelephonyManager);\n        when(mTelephonyManager.createForSubscriptionId(SUB_ID_1)).thenReturn(mTelephonyManager);\n        when(mTelephonyManager.createForSubscriptionId(SUB_ID_2)).thenReturn(mTelephonyManager2);\n        when(mContext.getPackageManager()).thenReturn(mPackageManager);\n"}
{"magic_number_smell": "        when(mContext.getSystemService(SubscriptionManager.class)).thenReturn(mSubscriptionManager);\n        when(mContext.getSystemService(TelecomManager.class)).thenReturn(mTelecomManager);\n        when(mContext.getSystemService(TelephonyManager.class)).thenReturn(mTelephonyManager);\n        when(mTelephonyManager.createForSubscriptionId(1)).thenReturn(mTelephonyManager);\n        when(mContext.getPackageManager()).thenReturn(mPackageManager);\n\n        when(mSubscriptionInfo.getSubscriptionId()).thenReturn(1);", "refactored_code": "    private static final int SUB_ID = 1;\n        when(mContext.getSystemService(SubscriptionManager.class)).thenReturn(mSubscriptionManager);\n        when(mContext.getSystemService(TelecomManager.class)).thenReturn(mTelecomManager);\n        when(mContext.getSystemService(TelephonyManager.class)).thenReturn(mTelephonyManager);\n        when(mTelephonyManager.createForSubscriptionId(SUB_ID)).thenReturn(mTelephonyManager);\n        when(mContext.getPackageManager()).thenReturn(mPackageManager);\n\n        when(mSubscriptionInfo.getSubscriptionId()).thenReturn(SUB_ID);"}
{"magic_number_smell": "\n        PersistableBundle config = new PersistableBundle();\n        config.putBoolean(CarrierConfigManager.KEY_SHOW_4G_FOR_LTE_DATA_ICON_BOOL, true);\n        doReturn(config).when(mCarrierConfigManager).getConfigForSubId(2);\n\n        doReturn(TelephonyManager.DATA_CONNECTED).when(mTelephonyManager).getDataState();\n    }", "refactored_code": "    private static final int SUB_ID = 2;\n\n        PersistableBundle config = new PersistableBundle();\n        config.putBoolean(CarrierConfigManager.KEY_SHOW_4G_FOR_LTE_DATA_ICON_BOOL, true);\n        doReturn(config).when(mCarrierConfigManager).getConfigForSubId(SUB_ID);\n\n        doReturn(TelephonyManager.DATA_CONNECTED).when(mTelephonyManager).getDataState();\n    }"}
{"magic_number_smell": "        when(mContext.getSystemService(SubscriptionManager.class)).thenReturn(mSubscriptionManager);\n        CarrierConfigCache.setTestInstance(mContext, mCarrierConfigCache);\n\n        doReturn(mTelephonyManager).when(mTelephonyManager).createForSubscriptionId(2);\n        doReturn(mInvalidTelephonyManager).when(mTelephonyManager).createForSubscriptionId(\n                SubscriptionManager.INVALID_SUBSCRIPTION_ID);\n        doReturn(TelephonyManager.NETWORK_TYPE_BITMASK_NR).when(", "refactored_code": "    private static final int SUB_ID = 2;\n        when(mContext.getSystemService(SubscriptionManager.class)).thenReturn(mSubscriptionManager);\n        CarrierConfigCache.setTestInstance(mContext, mCarrierConfigCache);\n\n        doReturn(mTelephonyManager).when(mTelephonyManager).createForSubscriptionId(SUB_ID);\n        doReturn(mInvalidTelephonyManager).when(mTelephonyManager).createForSubscriptionId(\n                SubscriptionManager.INVALID_SUBSCRIPTION_ID);\n        doReturn(TelephonyManager.NETWORK_TYPE_BITMASK_NR).when("}
{"magic_number_smell": "                .thenReturn(TelephonyManager.NETWORK_TYPE_BITMASK_NR);\n        when(mSubscriptionManager.getActiveSubscriptionIdList()).thenReturn(new int[] {1, 2});\n        when(mTelephonyManager.isDataEnabled()).thenReturn(true);\n        mController.init(111);\n        assertThat(mController.isAvailable()).isTrue();\n    }\n", "refactored_code": "    private static final int SUB_ID = 111;\n                .thenReturn(TelephonyManager.NETWORK_TYPE_BITMASK_NR);\n        when(mSubscriptionManager.getActiveSubscriptionIdList()).thenReturn(new int[] {1, 2});\n        when(mTelephonyManager.isDataEnabled()).thenReturn(true);\n        mController.init(SUB_ID);\n        assertThat(mController.isAvailable()).isTrue();\n    }\n"}
{"magic_number_smell": "        mContext = spy(ApplicationProvider.getApplicationContext());\n        when(mContext.getSystemService(TelephonyManager.class)).thenReturn(mTelephonyManager);\n\n        doReturn(mTelephonyManager).when(mTelephonyManager).createForSubscriptionId(2);\n\n        mController = new NullAlgorithmsPreferenceController(mContext, PREFERENCE_KEY);\n", "refactored_code": "    private static final int SUB_ID = 2;\n        mContext = spy(ApplicationProvider.getApplicationContext());\n        when(mContext.getSystemService(TelephonyManager.class)).thenReturn(mTelephonyManager);\n\n        doReturn(mTelephonyManager).when(mTelephonyManager).createForSubscriptionId(SUB_ID);\n\n        mController = new NullAlgorithmsPreferenceController(mContext, PREFERENCE_KEY);\n"}
{"magic_number_smell": "        when(mContext.getSystemService(TelephonyManager.class)).thenReturn(mTelephonyManager);\n        CarrierConfigCache.setTestInstance(mContext, mCarrierConfigCache);\n\n        doReturn(mTelephonyManager).when(mTelephonyManager).createForSubscriptionId(2);\n        doReturn(mInvalidTelephonyManager).when(mTelephonyManager).createForSubscriptionId(\n                SubscriptionManager.INVALID_SUBSCRIPTION_ID);\n        doReturn(mServiceState).when(mTelephonyManager).getServiceState();", "refactored_code": "    private static final int SUB_ID = 2;\n        when(mContext.getSystemService(TelephonyManager.class)).thenReturn(mTelephonyManager);\n        CarrierConfigCache.setTestInstance(mContext, mCarrierConfigCache);\n\n        doReturn(mTelephonyManager).when(mTelephonyManager).createForSubscriptionId(SUB_ID);\n        doReturn(mInvalidTelephonyManager).when(mTelephonyManager).createForSubscriptionId(\n                SubscriptionManager.INVALID_SUBSCRIPTION_ID);\n        doReturn(mServiceState).when(mTelephonyManager).getServiceState();"}
{"magic_number_smell": "\n        doReturn(mCarrierConfigManager).when(mContext).getSystemService(\n                Context.CARRIER_CONFIG_SERVICE);\n        doReturn(mTelephonyManager).when(mTelephonyManager).createForSubscriptionId(2);\n        doReturn(mInvalidTelephonyManager).when(mTelephonyManager).createForSubscriptionId(\n                SubscriptionManager.INVALID_SUBSCRIPTION_ID);\n        doReturn(mFragmentTransaction).when(mFragmentManager).beginTransaction();", "refactored_code": "    private static final int SUB_ID = 2;\n\n        doReturn(mCarrierConfigManager).when(mContext).getSystemService(\n                Context.CARRIER_CONFIG_SERVICE);\n        doReturn(mTelephonyManager).when(mTelephonyManager).createForSubscriptionId(SUB_ID);\n        doReturn(mInvalidTelephonyManager).when(mTelephonyManager).createForSubscriptionId(\n                SubscriptionManager.INVALID_SUBSCRIPTION_ID);\n        doReturn(mFragmentTransaction).when(mFragmentManager).beginTransaction();"}
{"magic_number_smell": "        mContext = spy(ApplicationProvider.getApplicationContext());\n        when(mContext.getSystemService(SubscriptionManager.class))\n                .thenReturn(mSubscriptionManager);\n        when(mSubscriptionInfo.getSubscriptionId()).thenReturn(1);\n        mPreferenceController = new TestPreferenceController(mContext, \"prefKey\");\n    }\n", "refactored_code": "    private static final int VALID_SUB_ID = 1;\n        mContext = spy(ApplicationProvider.getApplicationContext());\n        when(mContext.getSystemService(SubscriptionManager.class))\n                .thenReturn(mSubscriptionManager);\n        when(mSubscriptionInfo.getSubscriptionId()).thenReturn(VALID_SUB_ID);\n        mPreferenceController = new TestPreferenceController(mContext, \"prefKey\");\n    }\n"}
{"magic_number_smell": "        mContext = spy(ApplicationProvider.getApplicationContext());\n        when(mContext.getSystemService(SubscriptionManager.class)).thenReturn(mSubscriptionManager);\n\n        mQueryImsState = new MockWifiCallingQueryImsState(mContext, 2);\n        mQueryImsState.setIsEnabledByUser(true);\n        mQueryImsState.setIsProvisionedOnDevice(true);\n", "refactored_code": "    private static final int SUB_ID = 2;\n        mContext = spy(ApplicationProvider.getApplicationContext());\n        when(mContext.getSystemService(SubscriptionManager.class)).thenReturn(mSubscriptionManager);\n\n        mQueryImsState = new MockWifiCallingQueryImsState(mContext, SUB_ID);\n        mQueryImsState.setIsEnabledByUser(true);\n        mQueryImsState.setIsProvisionedOnDevice(true);\n"}
{"magic_number_smell": "\n        mContext = spy(ApplicationProvider.getApplicationContext());\n        when(mContext.getSystemService(TelephonyManager.class)).thenReturn(mTelephonyManager);\n        when(mTelephonyManager.createForSubscriptionId(2)).thenReturn(mTelephonyManager);\n        mPreference = spy(new CdmaListPreference(mContext, null));\n        mPreference.setSubId(2);\n    }", "refactored_code": "    private static final int SUB_ID = 2;\n\n        mContext = spy(ApplicationProvider.getApplicationContext());\n        when(mContext.getSystemService(TelephonyManager.class)).thenReturn(mTelephonyManager);\n        when(mTelephonyManager.createForSubscriptionId(SUB_ID)).thenReturn(mTelephonyManager);\n        mPreference = spy(new CdmaListPreference(mContext, null));\n        mPreference.setSubId(SUB_ID);\n    }"}
{"magic_number_smell": "\n        mContext = spy(ApplicationProvider.getApplicationContext());\n        when(mContext.getSystemService(TelephonyManager.class)).thenReturn(mTelephonyManager);\n        doReturn(mTelephonyManager).when(mTelephonyManager).createForSubscriptionId(2);\n\n        mPreference = new ListPreference(mContext);\n        mController = spy(new CdmaSubscriptionPreferenceController(mContext, \"mobile_data\"));", "refactored_code": "    private static final int SUB_ID = 2;\n\n        mContext = spy(ApplicationProvider.getApplicationContext());\n        when(mContext.getSystemService(TelephonyManager.class)).thenReturn(mTelephonyManager);\n        doReturn(mTelephonyManager).when(mTelephonyManager).createForSubscriptionId(SUB_ID);\n\n        mPreference = new ListPreference(mContext);\n        mController = spy(new CdmaSubscriptionPreferenceController(mContext, \"mobile_data\"));"}
{"magic_number_smell": "\n        mContext = spy(ApplicationProvider.getApplicationContext());\n        when(mContext.getSystemService(TelephonyManager.class)).thenReturn(mTelephonyManager);\n        doReturn(mTelephonyManager).when(mTelephonyManager).createForSubscriptionId(2);\n\n        mPreference = new ListPreference(mContext);\n        mController = new CdmaSystemSelectPreferenceController(mContext, \"mobile_data\");", "refactored_code": "    private static final int SUB_ID = 2;\n\n        mContext = spy(ApplicationProvider.getApplicationContext());\n        when(mContext.getSystemService(TelephonyManager.class)).thenReturn(mTelephonyManager);\n        doReturn(mTelephonyManager).when(mTelephonyManager).createForSubscriptionId(SUB_ID);\n\n        mPreference = new ListPreference(mContext);\n        mController = new CdmaSystemSelectPreferenceController(mContext, \"mobile_data\");"}
{"magic_number_smell": "        when(mContext.getSystemService(TelephonyManager.class)).thenReturn(mTelephonyManager);\n        when(mContext.getSystemService(SubscriptionManager.class)).thenReturn(mSubscriptionManager);\n        CarrierConfigCache.setTestInstance(mContext, mCarrierConfigCache);\n        when(mTelephonyManager.createForSubscriptionId(2)).thenReturn(mTelephonyManager);\n\n        mCarrierConfig = new PersistableBundle();\n        mCarrierConfig.putBoolean(CarrierConfigManager.KEY_ONLY_AUTO_SELECT_IN_HOME_NETWORK_BOOL,", "refactored_code": "    private static final int SUB_ID = 2;\n        when(mContext.getSystemService(TelephonyManager.class)).thenReturn(mTelephonyManager);\n        when(mContext.getSystemService(SubscriptionManager.class)).thenReturn(mSubscriptionManager);\n        CarrierConfigCache.setTestInstance(mContext, mCarrierConfigCache);\n        when(mTelephonyManager.createForSubscriptionId(SUB_ID)).thenReturn(mTelephonyManager);\n\n        mCarrierConfig = new PersistableBundle();\n        mCarrierConfig.putBoolean(CarrierConfigManager.KEY_ONLY_AUTO_SELECT_IN_HOME_NETWORK_BOOL,"}
{"magic_number_smell": "        when(mContext.getSystemService(SubscriptionManager.class)).thenReturn(mSubscriptionManager);\n        when(mContext.getSystemService(CarrierConfigManager.class)).thenReturn(\n                mCarrierConfigManager);\n        when(mTelephonyManager.createForSubscriptionId(2)).thenReturn(mTelephonyManager);\n        when(mTelephonyManager.getServiceState()).thenReturn(mServiceState);\n\n        mCarrierConfig = new PersistableBundle();", "refactored_code": "    private static final int SUB_ID = 2;\n        when(mContext.getSystemService(SubscriptionManager.class)).thenReturn(mSubscriptionManager);\n        when(mContext.getSystemService(CarrierConfigManager.class)).thenReturn(\n                mCarrierConfigManager);\n        when(mTelephonyManager.createForSubscriptionId(SUB_ID)).thenReturn(mTelephonyManager);\n        when(mTelephonyManager.getServiceState()).thenReturn(mServiceState);\n\n        mCarrierConfig = new PersistableBundle();"}
{"magic_number_smell": "                    data.intentTargetClass = TARGET_CLASS;\n                    data.intentTargetPackage = TARGET_PACKAGE;\n                    data.key = KEY;\n                    data.iconResId = 0xff;\n                    data.enabled = ENABLED;\n\n                    final List<SearchIndexableRaw> result = new ArrayList<>(1);", "refactored_code": "    public static final int ICON = 0xff;\n                    data.intentTargetClass = TARGET_CLASS;\n                    data.intentTargetPackage = TARGET_PACKAGE;\n                    data.key = KEY;\n                    data.iconResId = ICON;\n                    data.enabled = ENABLED;\n\n                    final List<SearchIndexableRaw> result = new ArrayList<>(1);"}
{"magic_number_smell": "\n    @Test\n    public void openScreenLockSettings_shouldSendIntent() {\n        mScreenLockPreferenceDetailsUtils.openScreenLockSettings(10);\n\n        assertFragmentLaunchRequested(ScreenLockSettings.class.getName());\n    }", "refactored_code": "    private static final int SOURCE_METRICS_CATEGORY = 10;\n\n    @Test\n    public void openScreenLockSettings_shouldSendIntent() {\n        mScreenLockPreferenceDetailsUtils.openScreenLockSettings(SOURCE_METRICS_CATEGORY);\n\n        assertFragmentLaunchRequested(ScreenLockSettings.class.getName());\n    }"}
{"magic_number_smell": "                .setSummary(SUMMARY)\n                .setScreenTitle(SCREEN_TITLE)\n                .setKeywords(KEYWORDS)\n                .setIcon(1234)\n                .setFragmentName(FRAGMENT_NAME)\n                .setUri(URI)\n                .setPreferenceControllerClassName(PREF_CONTROLLER)", "refactored_code": "    private static final int ICON = 1234; // I declare a thumb war\n                .setSummary(SUMMARY)\n                .setScreenTitle(SCREEN_TITLE)\n                .setKeywords(KEYWORDS)\n                .setIcon(ICON)\n                .setFragmentName(FRAGMENT_NAME)\n                .setUri(URI)\n                .setPreferenceControllerClassName(PREF_CONTROLLER)"}
{"magic_number_smell": "\n    @Override\n    public int getMax() {\n        return 9;\n    }\n\n    @Override", "refactored_code": "    public static final int MAX_VALUE = 9;\n\n    @Override\n    public int getMax() {\n        return MAX_VALUE;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getSliceHighlightMenuRes() {\n        return R.string.menu_key_about_device;\n    }\n\n    @Override", "refactored_code": "    public static final int HIGHLIGHT_MENU_RES = R.string.menu_key_about_device;\n\n    @Override\n    public int getSliceHighlightMenuRes() {\n        return HIGHLIGHT_MENU_RES;\n    }\n\n    @Override"}
{"magic_number_smell": "    public void getPackageName_returnsAccuratePackageName() {\n        doReturn(DIFFERENT_PACKAGE_NAME).when(mDevicePolicyManager).getAlwaysOnVpnPackage();\n\n        mAppPreference = spy(new AppPreference(mContext, UserHandle.USER_NULL, PACKAGE_NAME));\n        assertThat(mAppPreference.getPackageName()).isEqualTo(PACKAGE_NAME);\n    }\n", "refactored_code": "    private static final int USER_ID = UserHandle.USER_NULL;\n    public void getPackageName_returnsAccuratePackageName() {\n        doReturn(DIFFERENT_PACKAGE_NAME).when(mDevicePolicyManager).getAlwaysOnVpnPackage();\n\n        mAppPreference = spy(new AppPreference(mContext, USER_ID, PACKAGE_NAME));\n        assertThat(mAppPreference.getPackageName()).isEqualTo(PACKAGE_NAME);\n    }\n"}
{"magic_number_smell": "\n    @Test\n    public void setState_accuratelySet() {\n        mManageablePreference.setState(0);\n        assertThat(mManageablePreference.getState()).isEqualTo(0);\n    }\n", "refactored_code": "    private static final int STATE_DISCONNECTED = 0;\n\n    @Test\n    public void setState_accuratelySet() {\n        mManageablePreference.setState(STATE_DISCONNECTED);\n        assertThat(mManageablePreference.getState()).isEqualTo(STATE_DISCONNECTED);\n    }\n"}
{"magic_number_smell": "    public void setShownAdvancedPreferences_hasGeneralVpn_returnsVpnCountAs1() {\n        Set<Preference> updates = new ArraySet<>();\n        AppPreference pref =\n                spy(new AppPreference(mContext, UserHandle.USER_NULL, VPN_PACKAGE_NAME));\n        updates.add(pref);\n\n        mVpnSettings.setShownAdvancedPreferences(updates);", "refactored_code": "    private static final int USER_ID_1 = UserHandle.USER_NULL;\n    public void setShownAdvancedPreferences_hasGeneralVpn_returnsVpnCountAs1() {\n        Set<Preference> updates = new ArraySet<>();\n        AppPreference pref =\n                spy(new AppPreference(mContext, USER_ID_1, VPN_PACKAGE_NAME));\n        updates.add(pref);\n\n        mVpnSettings.setShownAdvancedPreferences(updates);"}
{"magic_number_smell": "\n        @Override\n        public int getCount() {\n            return 2;\n        }\n\n        @Override", "refactored_code": "        private static final int ITEM_COUNT = 2;\n\n        @Override\n        public int getCount() {\n            return ITEM_COUNT;\n        }\n\n        @Override"}
{"magic_number_smell": "    public void setUp() {\n        when(mContext.getSystemService(WifiManager.class)).thenReturn(mWifiManager);\n        mCarrierConfig = new PersistableBundle();\n        when(mCarrierConfigCache.getConfigForSubId(2)).thenReturn(mCarrierConfig);\n        CarrierConfigCache.setTestInstance(mContext, mCarrierConfigCache);\n\n        mFeatureFactory = FakeFeatureFactory.setupForTest();", "refactored_code": "    private static final int SUB_ID = 2;\n    public void setUp() {\n        when(mContext.getSystemService(WifiManager.class)).thenReturn(mWifiManager);\n        mCarrierConfig = new PersistableBundle();\n        when(mCarrierConfigCache.getConfigForSubId(SUB_ID)).thenReturn(mCarrierConfig);\n        CarrierConfigCache.setTestInstance(mContext, mCarrierConfigCache);\n\n        mFeatureFactory = FakeFeatureFactory.setupForTest();"}
{"magic_number_smell": "  @Override\n  public void logInfo( String message, Object... arguments )\n    {\n    LOG.info( \"[\" + Util.truncate( getName(), 25 ) + \"] \" + message, arguments );\n    }\n\n  @Override", "refactored_code": "  private static final int LOG_FLOW_NAME_MAX = 25;\n  @Override\n  public void logInfo( String message, Object... arguments )\n    {\n    LOG.info( \"[\" + Util.truncate( getName(), LOG_FLOW_NAME_MAX ) + \"] \" + message, arguments );\n    }\n\n  @Override"}
{"magic_number_smell": "    t2inLen = 0;\n    t2outLen = 0;\n\n    addedNode1 = -1;\n\n    core1 = new int[ n1 ];\n    core2 = new int[ n2 ];", "refactored_code": "  public static final int NULL_NODE = -1;\n    t2inLen = 0;\n    t2outLen = 0;\n\n    addedNode1 = NULL_NODE;\n\n    core1 = new int[ n1 ];\n    core2 = new int[ n2 ];"}
{"magic_number_smell": "  @Override\n  public Transformed<E> transform( PlannerContext plannerContext, E rootGraph )\n    {\n    int maxDepth = plannerContext.getIntProperty( TRANSFORM_RECURSION_DEPTH_MAX, 1000 );\n\n    Transformed<E> transformed = new Transformed<>( plannerContext, this, expressionGraph, rootGraph );\n", "refactored_code": "  public static final int DEFAULT_TRANSFORM_RECURSION_DEPTH_MAX = 1000;\n  @Override\n  public Transformed<E> transform( PlannerContext plannerContext, E rootGraph )\n    {\n    int maxDepth = plannerContext.getIntProperty( TRANSFORM_RECURSION_DEPTH_MAX, DEFAULT_TRANSFORM_RECURSION_DEPTH_MAX );\n\n    Transformed<E> transformed = new Transformed<>( plannerContext, this, expressionGraph, rootGraph );\n"}
{"magic_number_smell": "\n    ProcessLogger logger = plannerContext.getLogger();\n    int size = flowElementGraph.vertexSet().size();\n    boolean logAsInfo = size >= 600;\n\n    if( logAsInfo )\n      logger.logInfo( \"elements in graph: {}, info logging threshold: {}, logging planner execution status\", size, 600 );", "refactored_code": "  private static final int ELEMENT_THRESHOLD = 600;\n\n    ProcessLogger logger = plannerContext.getLogger();\n    int size = flowElementGraph.vertexSet().size();\n    boolean logAsInfo = size >= ELEMENT_THRESHOLD;\n\n    if( logAsInfo )\n      logger.logInfo( \"elements in graph: {}, info logging threshold: {}, logging planner execution status\", size, ELEMENT_THRESHOLD );"}
{"magic_number_smell": "    long duration = end - begin;\n\n    // print these as we go\n    if( duration > 10 * 1000 )\n      LOG.info( \"rule: {}, took longer than {} seconds: {}\", rule.getRuleName(), 10, formatDurationFromMillis( duration ) );\n\n    durations.put( rule.getRuleName(), duration );", "refactored_code": "  public static final int THRESHOLD_SECONDS = 10;\n    long duration = end - begin;\n\n    // print these as we go\n    if( duration > THRESHOLD_SECONDS * 1000 )\n      LOG.info( \"rule: {}, took longer than {} seconds: {}\", rule.getRuleName(), THRESHOLD_SECONDS, formatDurationFromMillis( duration ) );\n\n    durations.put( rule.getRuleName(), duration );"}
{"magic_number_smell": "\n  protected Set<Future<RuleResult>> submitCallables( List<Callable<RuleResult>> callables )\n    {\n    int size = Math.min( 5, callables.size() );\n\n    ExecutorService executor = Executors.newFixedThreadPool( size );\n    ExecutorCompletionService<RuleResult> completionService = new ExecutorCompletionService<>( executor );", "refactored_code": "  public static final int MAX_CONCURRENT_PLANNERS = 5;\n\n  protected Set<Future<RuleResult>> submitCallables( List<Callable<RuleResult>> callables )\n    {\n    int size = Math.min( MAX_CONCURRENT_PLANNERS, callables.size() );\n\n    ExecutorService executor = Executors.newFixedThreadPool( size );\n    ExecutorCompletionService<RuleResult> completionService = new ExecutorCompletionService<>( executor );"}
{"magic_number_smell": "    this.stats = stats;\n    this.configuration = configuration;\n\n    this.timeout = getIntProperty( COUNTER_TIMEOUT_PROPERTY, 0 );\n    this.maxFetchAttempts = getIntProperty( COUNTER_FETCH_RETRIES_PROPERTY, DEFAULT_FETCH_RETRIES );\n\n    if( stats.getType() == CascadingStats.Type.NODE )", "refactored_code": "  public static final int DEFAULT_TIMEOUT_TIMEOUT_SEC = 0; // zero means making the call synchronously\n    this.stats = stats;\n    this.configuration = configuration;\n\n    this.timeout = getIntProperty( COUNTER_TIMEOUT_PROPERTY, DEFAULT_TIMEOUT_TIMEOUT_SEC );\n    this.maxFetchAttempts = getIntProperty( COUNTER_FETCH_RETRIES_PROPERTY, DEFAULT_FETCH_RETRIES );\n\n    if( stats.getType() == CascadingStats.Type.NODE )"}
{"magic_number_smell": "  /** Field keepParentOnDelete */\n  protected boolean keepParentOnDelete = false;\n  /** Field openTapsThreshold */\n  protected int openWritesThreshold = 300;\n\n  /** Field openedCollectors */\n  private long openedCollectors = 0;", "refactored_code": "  protected static final int OPEN_WRITES_THRESHOLD_DEFAULT = 300;\n  /** Field keepParentOnDelete */\n  protected boolean keepParentOnDelete = false;\n  /** Field openTapsThreshold */\n  protected int openWritesThreshold = OPEN_WRITES_THRESHOLD_DEFAULT;\n\n  /** Field openedCollectors */\n  private long openedCollectors = 0;"}
{"magic_number_smell": "  boolean compressSpill = true;\n  List<String> codecs = new ArrayList<String>();\n\n  int listSpillThreshold = 10 * 1000;\n\n  int mapSpillThreshold = defaultMapThreshold;\n  int mapInitialCapacity = defaultMapInitialCapacity;", "refactored_code": "  public static final int defaultListThreshold = 10 * 1000;\n  boolean compressSpill = true;\n  List<String> codecs = new ArrayList<String>();\n\n  int listSpillThreshold = defaultListThreshold;\n\n  int mapSpillThreshold = defaultMapThreshold;\n  int mapInitialCapacity = defaultMapInitialCapacity;"}
{"magic_number_smell": "\n  public static int mixK1( int k1 )\n    {\n    k1 *= 0xcc9e2d51;\n    k1 = Integer.rotateLeft( k1, 15 );\n    k1 *= C2;\n    return k1;", "refactored_code": "  private static final int C1 = 0xcc9e2d51;\n\n  public static int mixK1( int k1 )\n    {\n    k1 *= C1;\n    k1 = Integer.rotateLeft( k1, 15 );\n    k1 *= C2;\n    return k1;"}
{"magic_number_smell": "  /** TODO: doc me */\n  protected static class Euclidean extends CrossTabOperation<Double[]>\n    {\n    private static final long 1L = 1L;\n\n    public Euclidean()\n      {", "refactored_code": "  private static final long serialVersionUID = 1L;\n  /** TODO: doc me */\n  protected static class Euclidean extends CrossTabOperation<Double[]>\n    {\n    private static final long serialVersionUID = 1L;\n\n    public Euclidean()\n      {"}
{"magic_number_smell": "\n  static class PartitionFilter extends BaseOperation implements Filter\n    {\n    private static final long 1L = 1L;\n\n    private final List<String> partitions;\n", "refactored_code": "    private static final long serialVersionUID = 1L;\n\n  static class PartitionFilter extends BaseOperation implements Filter\n    {\n    private static final long serialVersionUID = 1L;\n\n    private final List<String> partitions;\n"}
{"magic_number_smell": "    if( fetchLimit > -1 )\n      return;\n\n    fetchLimit = PropertyUtil.getIntProperty( HadoopUtil.createProperties( configuration ), TIMELINE_FETCH_LIMIT, 500 );\n\n    if( fetchLimit < 2 )\n      {", "refactored_code": "  public static final int DEFAULT_FETCH_LIMIT = 500;\n    if( fetchLimit > -1 )\n      return;\n\n    fetchLimit = PropertyUtil.getIntProperty( HadoopUtil.createProperties( configuration ), TIMELINE_FETCH_LIMIT, DEFAULT_FETCH_LIMIT );\n\n    if( fetchLimit < 2 )\n      {"}
{"magic_number_smell": "  /** Field groupID */\n  String groupID = Tap.id( this );\n  /** Field pollTimeout */\n  long pollTimeout = 10_000L;\n\n  /**\n   * Method makeURI creates a kafka URI for use with the KafkaTap.", "refactored_code": "  public static final long DEFAULT_POLL_TIMEOUT = 10_000L;\n  /** Field groupID */\n  String groupID = Tap.id( this );\n  /** Field pollTimeout */\n  long pollTimeout = DEFAULT_POLL_TIMEOUT;\n\n  /**\n   * Method makeURI creates a kafka URI for use with the KafkaTap."}
{"magic_number_smell": "  @ClassRule\n  public static GenericContainer neo4jRule =\n    new GenericContainer( \"neo4j:3.5.2\" )\n      .withExposedPorts( 7474, BOLT_PORT )\n      .withLogConsumer( new Slf4jLogConsumer( LOG ) )\n      .withEnv( \"NEO4J_AUTH\", \"none\" )\n      .withStartupTimeout( Duration.ofMinutes( 3 ) );", "refactored_code": "  public static final int PORTAL_PORT = 7474;\n  @ClassRule\n  public static GenericContainer neo4jRule =\n    new GenericContainer( \"neo4j:3.5.2\" )\n      .withExposedPorts( PORTAL_PORT, BOLT_PORT )\n      .withLogConsumer( new Slf4jLogConsumer( LOG ) )\n      .withEnv( \"NEO4J_AUTH\", \"none\" )\n      .withStartupTimeout( Duration.ofMinutes( 3 ) );"}
{"magic_number_smell": "\n  public void actionPerformed(ActionEvent e) {\n    if (e.getSource() == btnOk)\n      selection = 1;\n    else\n      selection = CANCELLED;\n    setVisible(false);", "refactored_code": "  public static final int SELECTED = 1;\n\n  public void actionPerformed(ActionEvent e) {\n    if (e.getSource() == btnOk)\n      selection = SELECTED;\n    else\n      selection = CANCELLED;\n    setVisible(false);"}
{"magic_number_smell": "  }\n\n  public int getColumnCount() {\n    return 5;\n  }\n\n  public int getRowCount() {", "refactored_code": "  private static final int MAX_COLUMNS = 5;\n  }\n\n  public int getColumnCount() {\n    return MAX_COLUMNS;\n  }\n\n  public int getRowCount() {"}
{"magic_number_smell": "    StringBuilder sb = new StringBuilder();\n    sb.append(ConstantPool.getTagName(tagByte));\n    sb.append(\",\");\n    if (ptr1 == -1) {\n      sb.append(\" - \");\n    } else {\n      sb.append(ptr1);", "refactored_code": "  public static final int INVALID_CONSTANT_POOL_POINTER = -1;\n    StringBuilder sb = new StringBuilder();\n    sb.append(ConstantPool.getTagName(tagByte));\n    sb.append(\",\");\n    if (ptr1 == INVALID_CONSTANT_POOL_POINTER) {\n      sb.append(\" - \");\n    } else {\n      sb.append(ptr1);"}
{"magic_number_smell": "    }\n\n    for (String argType : methodArguments) {\n      addEntry(symIndex++, -1, argType);\n      if (argType.equals(String.valueOf(JVMConstants.JVM_TYPE_LONG))\n          || argType.equals(String.valueOf(JVMConstants.JVM_TYPE_DOUBLE))) {\n        // Since both long and double take two entries.", "refactored_code": "  public static final int ARG_BYTECODE_REFERRED_INDEX = -1;\n    }\n\n    for (String argType : methodArguments) {\n      addEntry(symIndex++, ARG_BYTECODE_REFERRED_INDEX, argType);\n      if (argType.equals(String.valueOf(JVMConstants.JVM_TYPE_LONG))\n          || argType.equals(String.valueOf(JVMConstants.JVM_TYPE_DOUBLE))) {\n        // Since both long and double take two entries."}
{"magic_number_smell": "    private String tableName = \"COM_AUDIT_TRAIL\";\n\n    @Min(50)\n    private int columnLength = 100;\n\n    /**\n     * ExecutorService that has one thread to asynchronously save requests.", "refactored_code": "    private static final int DEFAULT_COLUMN_LENGTH = 100;\n    private String tableName = \"COM_AUDIT_TRAIL\";\n\n    @Min(50)\n    private int columnLength = DEFAULT_COLUMN_LENGTH;\n\n    /**\n     * ExecutorService that has one thread to asynchronously save requests."}
{"magic_number_smell": "\n    @Override\n    public boolean onCreate() {\n        mOpenHelper = new OpenHelper(getContext(), DB_NAME, null, 1);\n        return true;\n    }\n", "refactored_code": "    private static final int VERSION = 1;\n\n    @Override\n    public boolean onCreate() {\n        mOpenHelper = new OpenHelper(getContext(), DB_NAME, null, VERSION);\n        return true;\n    }\n"}
{"magic_number_smell": "                int version) {\n            super(context, name, factory, version);\n            // Memory optimization - close idle connections after 30s of inactivity\n            setIdleConnectionTimeout(30000);\n        }\n\n        @Override", "refactored_code": "    private static final int IDLE_CONNECTION_TIMEOUT_MS = 30000;\n                int version) {\n            super(context, name, factory, version);\n            // Memory optimization - close idle connections after 30s of inactivity\n            setIdleConnectionTimeout(IDLE_CONNECTION_TIMEOUT_MS);\n        }\n\n        @Override"}
{"magic_number_smell": "            }\n        };\n\n        mTaskScheduler.scheduleTask(0, null);\n\n        mSubscriptionManager = context.getSystemService(SubscriptionManager.class);\n", "refactored_code": "    protected static final int BACKGROUND_TASK_INITIALIZE = 0;\n            }\n        };\n\n        mTaskScheduler.scheduleTask(BACKGROUND_TASK_INITIALIZE, null);\n\n        mSubscriptionManager = context.getSystemService(SubscriptionManager.class);\n"}
{"magic_number_smell": "        deleteWhereArgs.add(String.valueOf(Directory.LOCAL_INVISIBLE));\n        final String wherePart = \"(\" + Directory.PACKAGE_NAME + \"=? AND \"\n                + Directory.DIRECTORY_AUTHORITY + \"=? AND \"\n                + Directory.0 + \"=? AND \"\n                + Directory.ACCOUNT_TYPE + \"=?)\";\n\n        final Set<String> directoryProviderPackages = getDirectoryProviderPackages(mPackageManager);", "refactored_code": "        public static final int ACCOUNT_NAME = 0;\n        deleteWhereArgs.add(String.valueOf(Directory.LOCAL_INVISIBLE));\n        final String wherePart = \"(\" + Directory.PACKAGE_NAME + \"=? AND \"\n                + Directory.DIRECTORY_AUTHORITY + \"=? AND \"\n                + Directory.ACCOUNT_NAME + \"=? AND \"\n                + Directory.ACCOUNT_TYPE + \"=?)\";\n\n        final Set<String> directoryProviderPackages = getDirectoryProviderPackages(mPackageManager);"}
{"magic_number_smell": "\n            // Parse segment type\n            if (c == 'i') {\n                lookupType = 0;\n                escaped = false;\n            } else if (c == 'e') {\n                lookupType = 0;", "refactored_code": "    public static final int LOOKUP_TYPE_SOURCE_ID = 0;\n\n            // Parse segment type\n            if (c == 'i') {\n                lookupType = LOOKUP_TYPE_SOURCE_ID;\n                escaped = false;\n            } else if (c == 'e') {\n                lookupType = LOOKUP_TYPE_SOURCE_ID;"}
{"magic_number_smell": "    protected ContactsDatabaseHelper(\n            Context context, String databaseName, boolean optimizationEnabled,\n            boolean isTestInstance) {\n        super(context, databaseName, null, DATABASE_VERSION, 700, null);\n        mPhoneAccountHandleMigrationUtils = new PhoneAccountHandleMigrationUtils(\n                context, PhoneAccountHandleMigrationUtils.TYPE_CONTACTS);\n        boolean enableWal = android.provider.Settings.Global.getInt(context.getContentResolver(),", "refactored_code": "    private static final int MINIMUM_SUPPORTED_VERSION = 700;\n    protected ContactsDatabaseHelper(\n            Context context, String databaseName, boolean optimizationEnabled,\n            boolean isTestInstance) {\n        super(context, databaseName, null, DATABASE_VERSION, MINIMUM_SUPPORTED_VERSION, null);\n        mPhoneAccountHandleMigrationUtils = new PhoneAccountHandleMigrationUtils(\n                context, PhoneAccountHandleMigrationUtils.TYPE_CONTACTS);\n        boolean enableWal = android.provider.Settings.Global.getInt(context.getContentResolver(),"}
{"magic_number_smell": "            @Override\n            public void onPerformTask(int taskId, Object arg) {\n                switch (taskId) {\n                    case 0:\n                        onPackageChanged((PackageEventArg) arg);\n                        break;\n                }", "refactored_code": "    private static final int BACKGROUND_TASK_PACKAGE_EVENT = 0;\n            @Override\n            public void onPerformTask(int taskId, Object arg) {\n                switch (taskId) {\n                    case BACKGROUND_TASK_PACKAGE_EVENT:\n                        onPackageChanged((PackageEventArg) arg);\n                        break;\n                }"}
{"magic_number_smell": "        // Initialize the pre-authorized URI duration.\n        mPreAuthorizedUriDuration = DEFAULT_PREAUTHORIZED_URI_EXPIRATION;\n\n        scheduleBackgroundTask(0);\n        scheduleBackgroundTask(BACKGROUND_TASK_UPDATE_ACCOUNTS);\n        scheduleBackgroundTask(BACKGROUND_TASK_MIGRATE_PHONE_ACCOUNT_HANDLES);\n        scheduleBackgroundTask(BACKGROUND_TASK_UPDATE_LOCALE);", "refactored_code": "    private static final int BACKGROUND_TASK_INITIALIZE = 0;\n        // Initialize the pre-authorized URI duration.\n        mPreAuthorizedUriDuration = DEFAULT_PREAUTHORIZED_URI_EXPIRATION;\n\n        scheduleBackgroundTask(BACKGROUND_TASK_INITIALIZE);\n        scheduleBackgroundTask(BACKGROUND_TASK_UPDATE_ACCOUNTS);\n        scheduleBackgroundTask(BACKGROUND_TASK_MIGRATE_PHONE_ACCOUNT_HANDLES);\n        scheduleBackgroundTask(BACKGROUND_TASK_UPDATE_LOCALE);"}
{"magic_number_smell": "    private final int mShutdownTimeoutSeconds;\n\n    public ContactsTaskScheduler(String name) {\n        this(name, 60);\n    }\n\n    /** With explicit timeout seconds, for testing. */", "refactored_code": "    private static final int SHUTDOWN_TIMEOUT_SECONDS = 60;\n    private final int mShutdownTimeoutSeconds;\n\n    public ContactsTaskScheduler(String name) {\n        this(name, SHUTDOWN_TIMEOUT_SECONDS);\n    }\n\n    /** With explicit timeout seconds, for testing. */"}
{"magic_number_smell": "    }\n\n    public interface DataUpdateQuery {\n        String[] COLUMNS = { Data.0, Data.RAW_CONTACT_ID, Data.MIMETYPE };\n\n        int 0 = 0;\n        int RAW_CONTACT_ID = 1;", "refactored_code": "        public static final int _ID = 0;\n    }\n\n    public interface DataUpdateQuery {\n        String[] COLUMNS = { Data._ID, Data.RAW_CONTACT_ID, Data.MIMETYPE };\n\n        int _ID = 0;\n        int RAW_CONTACT_ID = 1;"}
{"magic_number_smell": "                DbQueryUtils.concatenateClauses(NON_NULL_SOURCE_PACKAGE_SELECTION, whereClause),\n                whereArgs, null, null, null);\n        while (cursor.moveToNext()) {\n            modifiedPackages.add(cursor.getString(0));\n        }\n        MoreCloseables.closeQuietly(cursor);\n        return modifiedPackages;", "refactored_code": "    private static final int SOURCE_PACKAGE_COLUMN_INDEX = 0;\n                DbQueryUtils.concatenateClauses(NON_NULL_SOURCE_PACKAGE_SELECTION, whereClause),\n                whereArgs, null, null, null);\n        while (cursor.moveToNext()) {\n            modifiedPackages.add(cursor.getString(SOURCE_PACKAGE_COLUMN_INDEX));\n        }\n        MoreCloseables.closeQuietly(cursor);\n        return modifiedPackages;"}
{"magic_number_smell": "        if (haveFilter) {\n            mContactsProvider.appendSearchIndexJoin(sb, filter, true,\n                    String.valueOf(SNIPPET_START_MATCH), String.valueOf(SNIPPET_END_MATCH),\n                    SNIPPET_ELLIPSIS, 5, false);\n        }\n        sb.append(\" WHERE \" + Contacts.LOOKUP_KEY + \" IS NOT NULL\");\n        if (selection != null) {", "refactored_code": "    private static final int SNIPPET_MAX_TOKENS = 5;\n        if (haveFilter) {\n            mContactsProvider.appendSearchIndexJoin(sb, filter, true,\n                    String.valueOf(SNIPPET_START_MATCH), String.valueOf(SNIPPET_END_MATCH),\n                    SNIPPET_ELLIPSIS, SNIPPET_MAX_TOKENS, false);\n        }\n        sb.append(\" WHERE \" + Contacts.LOOKUP_KEY + \" IS NOT NULL\");\n        if (selection != null) {"}
{"magic_number_smell": "\n        // ASCII\n        if (character < 128) {\n            token.type = Token.1;\n            token.target = token.source;\n            return;\n        }", "refactored_code": "        public static final int LATIN = 1;\n\n        // ASCII\n        if (character < 128) {\n            token.type = Token.LATIN;\n            token.target = token.source;\n            return;\n        }"}
{"magic_number_smell": "    private String[] mSelectionArgs2 = new String[2];\n\n    public interface LegacyTables {\n        public static final String 1 = \"view_v1_people\";\n        public static final String PEOPLE_JOIN_PRESENCE = \"view_v1_people people \" + PRESENCE_JOINS;\n        public static final String GROUPS = \"view_v1_groups\";\n        public static final String ORGANIZATIONS = \"view_v1_organizations\";", "refactored_code": "    private static final int PEOPLE = 1;\n    private String[] mSelectionArgs2 = new String[2];\n\n    public interface LegacyTables {\n        public static final String PEOPLE = \"view_v1_people\";\n        public static final String PEOPLE_JOIN_PRESENCE = \"view_v1_people people \" + PRESENCE_JOINS;\n        public static final String GROUPS = \"view_v1_groups\";\n        public static final String ORGANIZATIONS = \"view_v1_organizations\";"}
{"magic_number_smell": "    private static final int 4 = 4;\n\n    private final NameSplitter mSplitter;\n    private String[][] mNicknameClusters = new String[4][];\n    private StringBuilder mStringBuilder = new StringBuilder();\n    private String[] mNames = new String[NameSplitter.MAX_TOKENS];\n", "refactored_code": "    private static final int MAX_NAME_TOKENS = 4;\n    private static final int MAX_NAME_TOKENS = 4;\n\n    private final NameSplitter mSplitter;\n    private String[][] mNicknameClusters = new String[MAX_NAME_TOKENS][];\n    private StringBuilder mStringBuilder = new StringBuilder();\n    private String[] mNames = new String[NameSplitter.MAX_TOKENS];\n"}
{"magic_number_smell": "        public NameTokenizer(String fullName) {\n            super(fullName, \" .,\", true);\n\n            mTokens = new String[10];\n\n            // Iterate over tokens, skipping over empty ones and marking tokens that\n            // are followed by dots.", "refactored_code": "    public static final int MAX_TOKENS = 10;\n        public NameTokenizer(String fullName) {\n            super(fullName, \" .,\", true);\n\n            mTokens = new String[MAX_TOKENS];\n\n            // Iterate over tokens, skipping over empty ones and marking tokens that\n            // are followed by dots."}
{"magic_number_smell": "     */\n    public synchronized int getPhotoPriority(String accountType) {\n        if (accountType == null) {\n            return 7;\n        }\n\n        Integer priority = mPhotoPriorities.get(accountType);", "refactored_code": "    public static final int DEFAULT_PRIORITY = 7;\n     */\n    public synchronized int getPhotoPriority(String accountType) {\n        if (accountType == null) {\n            return DEFAULT_PRIORITY;\n        }\n\n        Integer priority = mPhotoPriorities.get(accountType);"}
{"magic_number_smell": "     * Retrieves the compressed display photo as a byte array.\n     */\n    public byte[] getDisplayPhotoBytes() throws IOException {\n        return getCompressedBytes(mDisplayPhoto, 75);\n    }\n\n    /**", "refactored_code": "    private static final int COMPRESSION_DISPLAY_PHOTO = 75;\n     * Retrieves the compressed display photo as a byte array.\n     */\n    public byte[] getDisplayPhotoBytes() throws IOException {\n        return getCompressedBytes(mDisplayPhoto, COMPRESSION_DISPLAY_PHOTO);\n    }\n\n    /**"}
{"magic_number_smell": "        public static final int SEPARATOR_SLASH = 2;\n        public static final int SEPARATOR_COMMA = 3;\n\n        private CappedStringBuilder mSbContent = new CappedStringBuilder(1024 * 10);\n        private CappedStringBuilder mSbName = new CappedStringBuilder(1024 * 10);\n        private CappedStringBuilder mSbTokens = new CappedStringBuilder(1024 * 10);\n        private CappedStringBuilder mSbElementContent = new CappedStringBuilder(", "refactored_code": "    private static final int MAX_STRING_BUILDER_SIZE = 1024 * 10;\n        public static final int SEPARATOR_SLASH = 2;\n        public static final int SEPARATOR_COMMA = 3;\n\n        private CappedStringBuilder mSbContent = new CappedStringBuilder(MAX_STRING_BUILDER_SIZE);\n        private CappedStringBuilder mSbName = new CappedStringBuilder(MAX_STRING_BUILDER_SIZE);\n        private CappedStringBuilder mSbTokens = new CappedStringBuilder(MAX_STRING_BUILDER_SIZE);\n        private CappedStringBuilder mSbElementContent = new CappedStringBuilder("}
{"magic_number_smell": "\n    @VisibleForTesting\n    void scheduleScanStalePackages() {\n        scheduleTask(0, null);\n    }\n\n    @VisibleForTesting", "refactored_code": "    private static final int BACKGROUND_TASK_SCAN_STALE_PACKAGES = 0;\n\n    @VisibleForTesting\n    void scheduleScanStalePackages() {\n        scheduleTask(BACKGROUND_TASK_SCAN_STALE_PACKAGES, null);\n    }\n\n    @VisibleForTesting"}
{"magic_number_smell": "            if (uri != null) {\n                count++;\n            }\n            if((count % 50) == 0){\n                modifier.yieldBulkOperation();\n            }\n        }", "refactored_code": "    private static final int BULK_INSERTS_PER_YIELD_POINT = 50;\n            if (uri != null) {\n                count++;\n            }\n            if((count % BULK_INSERTS_PER_YIELD_POINT) == 0){\n                modifier.yieldBulkOperation();\n            }\n        }"}
{"magic_number_smell": "                }\n                if (intentAction.equals(VoicemailContract.ACTION_NEW_VOICEMAIL)) {\n                    BroadcastOptions bopts = BroadcastOptions.makeBasic();\n                    bopts.setTemporaryAppWhitelistDuration(10000);\n                    Log.i(TAG, String.format(\"sendNotification: allowMillis=%d, pkg=%s\",\n                            10000, component.getPackageName()));\n                    mContext.sendBroadcast(intent, android.Manifest.permission.READ_VOICEMAIL,", "refactored_code": "    private final long VOICEMAIL_ALLOW_LIST_DURATION_MILLIS = 10000;\n                }\n                if (intentAction.equals(VoicemailContract.ACTION_NEW_VOICEMAIL)) {\n                    BroadcastOptions bopts = BroadcastOptions.makeBasic();\n                    bopts.setTemporaryAppWhitelistDuration(VOICEMAIL_ALLOW_LIST_DURATION_MILLIS);\n                    Log.i(TAG, String.format(\"sendNotification: allowMillis=%d, pkg=%s\",\n                            VOICEMAIL_ALLOW_LIST_DURATION_MILLIS, component.getPackageName()));\n                    mContext.sendBroadcast(intent, android.Manifest.permission.READ_VOICEMAIL,"}
{"magic_number_smell": "\n    // If we encounter more than this many contacts with matching names, aggregate only this many\n    protected static final int 15 = 15;\n    protected static final String PRIMARY_HIT_LIMIT_STRING = String.valueOf(15);\n\n    // If we encounter more than this many contacts with matching phone number or email,\n    // don't attempt to aggregate - this is likely an error or a shared corporate data element.", "refactored_code": "    protected static final int PRIMARY_HIT_LIMIT = 15;\n\n    // If we encounter more than this many contacts with matching names, aggregate only this many\n    protected static final int PRIMARY_HIT_LIMIT = 15;\n    protected static final String PRIMARY_HIT_LIMIT_STRING = String.valueOf(PRIMARY_HIT_LIMIT);\n\n    // If we encounter more than this many contacts with matching phone number or email,\n    // don't attempt to aggregate - this is likely an error or a shared corporate data element."}
{"magic_number_smell": "                        Data.IS_SUPER_PRIMARY + \" =1 AND \" +\n                        Data.RAW_CONTACT_ID + \" IN (SELECT \" + RawContacts._ID + \" FROM \" +\n                        Tables.RAW_CONTACTS + \" WHERE \" + RawContacts.CONTACT_ID + \"=?1)) AS a\" +\n                \" 1  (SELECT \" + DataColumns.MIMETYPE_ID + \" FROM \" + Tables.DATA + \" WHERE \" +\n                        Data.IS_SUPER_PRIMARY + \" =1 AND \" +\n                        Data.RAW_CONTACT_ID + \"=?2) AS b\" +\n                \" ON a.\" + DataColumns.MIMETYPE_ID + \"=b.\" + DataColumns.MIMETYPE_ID,", "refactored_code": "    private static final int JOIN = 1;\n                        Data.IS_SUPER_PRIMARY + \" =1 AND \" +\n                        Data.RAW_CONTACT_ID + \" IN (SELECT \" + RawContacts._ID + \" FROM \" +\n                        Tables.RAW_CONTACTS + \" WHERE \" + RawContacts.CONTACT_ID + \"=?1)) AS a\" +\n                \" JOIN  (SELECT \" + DataColumns.MIMETYPE_ID + \" FROM \" + Tables.DATA + \" WHERE \" +\n                        Data.IS_SUPER_PRIMARY + \" =1 AND \" +\n                        Data.RAW_CONTACT_ID + \"=?2) AS b\" +\n                \" ON a.\" + DataColumns.MIMETYPE_ID + \"=b.\" + DataColumns.MIMETYPE_ID,"}
{"magic_number_smell": "                    || aggregationMode == RawContacts.AGGREGATION_MODE_SUSPENDED)) {\n                operation = KEEP_INTACT;\n            } else {\n                operation = 1;\n            }\n        }\n", "refactored_code": "    private static final int CREATE_NEW_CONTACT = 1;\n                    || aggregationMode == RawContacts.AGGREGATION_MODE_SUSPENDED)) {\n                operation = KEEP_INTACT;\n            } else {\n                operation = CREATE_NEW_CONTACT;\n            }\n        }\n"}
{"magic_number_smell": "     * prevent around 98-99% of unnecessary queries from running.\n     */\n    private void preloadNicknameBloomFilter() {\n        mNicknameBloomFilter = new BitSet(0x1FFF + 1);\n        Cursor cursor = mDb.query(NicknameLookupPreloadQuery.TABLE,\n                NicknameLookupPreloadQuery.COLUMNS,\n                null, null, null, null, null);", "refactored_code": "    private static final int NICKNAME_BLOOM_FILTER_SIZE = 0x1FFF;   // =long[128]\n     * prevent around 98-99% of unnecessary queries from running.\n     */\n    private void preloadNicknameBloomFilter() {\n        mNicknameBloomFilter = new BitSet(NICKNAME_BLOOM_FILTER_SIZE + 1);\n        Cursor cursor = mDb.query(NicknameLookupPreloadQuery.TABLE,\n                NicknameLookupPreloadQuery.COLUMNS,\n                null, null, null, null, null);"}
{"magic_number_smell": "\n        // Ensure that of two contacts with the same match score the one with more matching\n        // data elements wins.\n        return score * 1000 + mMatchCount;\n    }\n\n    public boolean isKeepIn() {", "refactored_code": "    public static final int SCORE_SCALE = 1000;\n\n        // Ensure that of two contacts with the same match score the one with more matching\n        // data elements wins.\n        return score * SCORE_SCALE + mMatchCount;\n    }\n\n    public boolean isKeepIn() {"}
{"magic_number_smell": "        float m = matches;\n        float jaro = ((m / length1 + m / length2 + (m - (transpositions / 2f)) / m)) / 3;\n\n        if (jaro < 0.7f) {\n            return jaro;\n        }\n", "refactored_code": "    private static final float WINKLER_BONUS_THRESHOLD = 0.7f;\n        float m = matches;\n        float jaro = ((m / length1 + m / length2 + (m - (transpositions / 2f)) / m)) / 3;\n\n        if (jaro < WINKLER_BONUS_THRESHOLD) {\n            return jaro;\n        }\n"}
{"magic_number_smell": "    // atom (frameworks/proto_logging/stats/atoms.proto) definition.\n    public static void log(LogFields logFields) {\n        StatsLog.write(StatsEvent.newBuilder()\n                .setAtomId(301)\n                .writeInt(logFields.getApiType())\n                .writeInt(logFields.getUriType())\n                .writeInt(getCallerType(logFields.isCallerIsSyncAdapter()))", "refactored_code": "    private static final int STATSD_LOG_ATOM_ID = 301;\n    // atom (frameworks/proto_logging/stats/atoms.proto) definition.\n    public static void log(LogFields logFields) {\n        StatsLog.write(StatsEvent.newBuilder()\n                .setAtomId(STATSD_LOG_ATOM_ID)\n                .writeInt(logFields.getApiType())\n                .writeInt(logFields.getUriType())\n                .writeInt(getCallerType(logFields.isCallerIsSyncAdapter()))"}
{"magic_number_smell": "        assertTrue(insertCallLog(db, PhoneAccountHandleMigrationUtils.TELEPHONY_COMPONENT_NAME));\n        assertTrue(insertCallLog(db, NO_MIGRATION_COMPONENT_NAME));\n\n        openHelper.onUpgrade(db, 10, DATABASE_VERSION);\n\n        // Check each entry in the CALLS has a new coloumn of\n        // Calls.IS_PHONE_ACCOUNT_MIGRATION_PENDING that has a value of either 0 or 1", "refactored_code": "    public static final int DATABASE_VERSION_NEED_MIGRATION = 10;\n        assertTrue(insertCallLog(db, PhoneAccountHandleMigrationUtils.TELEPHONY_COMPONENT_NAME));\n        assertTrue(insertCallLog(db, NO_MIGRATION_COMPONENT_NAME));\n\n        openHelper.onUpgrade(db, DATABASE_VERSION_NEED_MIGRATION, DATABASE_VERSION);\n\n        // Check each entry in the CALLS has a new coloumn of\n        // Calls.IS_PHONE_ACCOUNT_MIGRATION_PENDING that has a value of either 0 or 1"}
{"magic_number_smell": "        // Query.\n        Cursor cursor = mResolver.query(Calls.CONTENT_URI, null, null, null, null);\n        List<String> columnNames = Arrays.asList(cursor.getColumnNames());\n        assertEquals(41, columnNames.size());\n        // None of the voicemail provider specific columns should be present.\n        for (String voicemailColumn : VOICEMAIL_PROVIDER_SPECIFIC_COLUMNS) {\n            assertFalse(\"Unexpected column: '\" + voicemailColumn + \"' returned.\",", "refactored_code": "    private static final int NUM_CALLLOG_FIELDS = 41;\n        // Query.\n        Cursor cursor = mResolver.query(Calls.CONTENT_URI, null, null, null, null);\n        List<String> columnNames = Arrays.asList(cursor.getColumnNames());\n        assertEquals(NUM_CALLLOG_FIELDS, columnNames.size());\n        // None of the voicemail provider specific columns should be present.\n        for (String voicemailColumn : VOICEMAIL_PROVIDER_SPECIFIC_COLUMNS) {\n            assertFalse(\"Unexpected column: '\" + voicemailColumn + \"' returned.\","}
{"magic_number_smell": "                UserInfo.FLAG_PROFILE);\n\n        /** \"My\" user.  Set it to change the current user. */\n        public int myUser = 0;\n\n        private ArrayList<UserInfo> mUsers = new ArrayList<>();\n", "refactored_code": "    private static final int DEFAULT_USER_ID = 0;\n                UserInfo.FLAG_PROFILE);\n\n        /** \"My\" user.  Set it to change the current user. */\n        public int myUser = DEFAULT_USER_ID;\n\n        private ArrayList<UserInfo> mUsers = new ArrayList<>();\n"}
{"magic_number_smell": "\n            // Check each entry in the Data has a new coloumn of\n            // Data.IS_PHONE_ACCOUNT_MIGRATION_PENDING that has a value of either 0 or 1\n            assertEquals(11 /** preconfigured entries */,\n                    DatabaseUtils.longForQuery(sqLiteDatabase,\n                            \"select count(*) from \" + ContactsDatabaseHelper.Tables.DATA\n                                    + \" where \" + Data.IS_PHONE_ACCOUNT_MIGRATION_PENDING", "refactored_code": "    public static final int NUM_ENTRIES_CONTACTS_DB_OLD_VERSION = 11;\n\n            // Check each entry in the Data has a new coloumn of\n            // Data.IS_PHONE_ACCOUNT_MIGRATION_PENDING that has a value of either 0 or 1\n            assertEquals(NUM_ENTRIES_CONTACTS_DB_OLD_VERSION /** preconfigured entries */,\n                    DatabaseUtils.longForQuery(sqLiteDatabase,\n                            \"select count(*) from \" + ContactsDatabaseHelper.Tables.DATA\n                                    + \" where \" + Data.IS_PHONE_ACCOUNT_MIGRATION_PENDING"}
{"magic_number_smell": "        mBroadcastReceiver = mContactsProvider2.getBroadcastReceiverForTest();\n        mOldMinMatch1 = PhoneNumberUtils.getMinMatchForTest();\n        mOldMinMatch2 = mDbHelper.getMinMatchForTest();\n        PhoneNumberUtils.setMinMatchForTest(7);\n        mDbHelper.setMinMatchForTest(7);\n    }\n", "refactored_code": "    private static final int MIN_MATCH = 7;\n        mBroadcastReceiver = mContactsProvider2.getBroadcastReceiverForTest();\n        mOldMinMatch1 = PhoneNumberUtils.getMinMatchForTest();\n        mOldMinMatch2 = mDbHelper.getMinMatchForTest();\n        PhoneNumberUtils.setMinMatchForTest(MIN_MATCH);\n        mDbHelper.setMinMatchForTest(MIN_MATCH);\n    }\n"}
{"magic_number_smell": "        final List<String> executed = new ArrayList<>();\n\n        public MyContactsTaskScheduler(int numExpectedTasks) {\n            super(\"Test\", 3);\n            latch = new CountDownLatch(numExpectedTasks);\n        }\n", "refactored_code": "    private static final int SHUTDOWN_SECONDS = 3;\n        final List<String> executed = new ArrayList<>();\n\n        public MyContactsTaskScheduler(int numExpectedTasks) {\n            super(\"Test\", SHUTDOWN_SECONDS);\n            latch = new CountDownLatch(numExpectedTasks);\n        }\n"}
{"magic_number_smell": "        // Query.\n        Cursor cursor = mResolver.query(voicemailUri(), null, null, null, null);\n        List<String> columnNames = Arrays.asList(cursor.getColumnNames());\n        assertEquals(25, columnNames.size());\n        // None of the call_log provider specific columns should be present.\n        for (String callLogColumn : CALLLOG_PROVIDER_SPECIFIC_COLUMNS) {\n            assertFalse(\"Unexpected column: '\" + callLogColumn + \"' returned.\",", "refactored_code": "    private static final int NUM_VOICEMAIL_FIELDS = 25;\n        // Query.\n        Cursor cursor = mResolver.query(voicemailUri(), null, null, null, null);\n        List<String> columnNames = Arrays.asList(cursor.getColumnNames());\n        assertEquals(NUM_VOICEMAIL_FIELDS, columnNames.size());\n        // None of the call_log provider specific columns should be present.\n        for (String callLogColumn : CALLLOG_PROVIDER_SPECIFIC_COLUMNS) {\n            assertFalse(\"Unexpected column: '\" + callLogColumn + \"' returned.\","}
{"magic_number_smell": "        final ContactsDatabaseHelper dbHelper = cp.getThreadActiveDatabaseHelperForTest();\n        mOldMinMatch1 = PhoneNumberUtils.getMinMatchForTest();\n        mOldMinMatch2 = dbHelper.getMinMatchForTest();\n        PhoneNumberUtils.setMinMatchForTest(7);\n        dbHelper.setMinMatchForTest(7);\n    }\n", "refactored_code": "    private static final int MIN_MATCH = 7;\n        final ContactsDatabaseHelper dbHelper = cp.getThreadActiveDatabaseHelperForTest();\n        mOldMinMatch1 = PhoneNumberUtils.getMinMatchForTest();\n        mOldMinMatch2 = dbHelper.getMinMatchForTest();\n        PhoneNumberUtils.setMinMatchForTest(MIN_MATCH);\n        dbHelper.setMinMatchForTest(MIN_MATCH);\n    }\n"}
{"magic_number_smell": "        final ContactsDatabaseHelper dbHelper = cp.getThreadActiveDatabaseHelperForTest();\n        mOldMinMatch1 = PhoneNumberUtils.getMinMatchForTest();\n        mOldMinMatch2 = dbHelper.getMinMatchForTest();\n        PhoneNumberUtils.setMinMatchForTest(7);\n        dbHelper.setMinMatchForTest(7);\n    }\n", "refactored_code": "    private static final int MIN_MATCH = 7;\n        final ContactsDatabaseHelper dbHelper = cp.getThreadActiveDatabaseHelperForTest();\n        mOldMinMatch1 = PhoneNumberUtils.getMinMatchForTest();\n        mOldMinMatch2 = dbHelper.getMinMatchForTest();\n        PhoneNumberUtils.setMinMatchForTest(MIN_MATCH);\n        dbHelper.setMinMatchForTest(MIN_MATCH);\n    }\n"}
{"magic_number_smell": "            connectedRawContactSets.add(rawContactSet);\n        }\n\n        rawContactsToAccounts.put(100l, 1);\n        rawContactsToAccounts.put(101l, 1);\n        rawContactsToAccounts.put(102l, 1);\n        rawContactsToAccounts.put(103l, ACCOUNT_2);", "refactored_code": "    private static final long ACCOUNT_1 = 1;\n            connectedRawContactSets.add(rawContactSet);\n        }\n\n        rawContactsToAccounts.put(100l, ACCOUNT_1);\n        rawContactsToAccounts.put(101l, ACCOUNT_1);\n        rawContactsToAccounts.put(102l, ACCOUNT_1);\n        rawContactsToAccounts.put(103l, ACCOUNT_2);"}
{"magic_number_smell": "    private static final String CALLING_PACKAGE = \"package\";\n\n    private static final Uri URI_CONTACTS_ID_PHOTO =\n            Uri.parse(\"content://com.android.contacts/contacts/\" + 10 + \"/photo\");\n    private static final Uri URI_CONTACTS_ID_DISPLAY_PHOTO = Uri\n            .parse(\"content://com.android.contacts/contacts/\" + 10 + \"/display_photo\");\n    private static final Uri URI_CONTACTS_FILTER =", "refactored_code": "    private static final int CONTACT_ID = 10;\n    private static final String CALLING_PACKAGE = \"package\";\n\n    private static final Uri URI_CONTACTS_ID_PHOTO =\n            Uri.parse(\"content://com.android.contacts/contacts/\" + CONTACT_ID + \"/photo\");\n    private static final Uri URI_CONTACTS_ID_DISPLAY_PHOTO = Uri\n            .parse(\"content://com.android.contacts/contacts/\" + CONTACT_ID + \"/display_photo\");\n    private static final Uri URI_CONTACTS_FILTER ="}
{"magic_number_smell": "            final int type = getNotificationTagType(tag);\n\n            final Notification.Builder builder;\n            if (type == 1) {\n                builder = new Notification.Builder(mContext, CHANNEL_ACTIVE);\n                builder.setSmallIcon(android.R.drawable.stat_sys_download);\n            } else if (type == TYPE_WAITING) {", "refactored_code": "    private static final int TYPE_ACTIVE = 1;\n            final int type = getNotificationTagType(tag);\n\n            final Notification.Builder builder;\n            if (type == TYPE_ACTIVE) {\n                builder = new Notification.Builder(mContext, CHANNEL_ACTIVE);\n                builder.setSmallIcon(android.R.drawable.stat_sys_download);\n            } else if (type == TYPE_WAITING) {"}
{"magic_number_smell": "     */\n    private final class DatabaseHelper extends SQLiteOpenHelper {\n        public DatabaseHelper(final Context context) {\n            super(context, DB_NAME, null, 114);\n            setIdleConnectionTimeout(IDLE_CONNECTION_TIMEOUT_MS);\n        }\n", "refactored_code": "    private static final int DB_VERSION = 114;\n     */\n    private final class DatabaseHelper extends SQLiteOpenHelper {\n        public DatabaseHelper(final Context context) {\n            super(context, DB_NAME, null, DB_VERSION);\n            setIdleConnectionTimeout(IDLE_CONNECTION_TIMEOUT_MS);\n        }\n"}
{"magic_number_smell": "        scanner.mLatch = new CountDownLatch(1);\n        scanner.requestScan(new ScanRequest(id, path, mimeType));\n        try {\n            scanner.mLatch.await(MINUTE_IN_MILLIS, TimeUnit.MILLISECONDS);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        } finally {", "refactored_code": "    private static final long SCAN_TIMEOUT = MINUTE_IN_MILLIS;\n        scanner.mLatch = new CountDownLatch(1);\n        scanner.requestScan(new ScanRequest(id, path, mimeType));\n        try {\n            scanner.mLatch.await(SCAN_TIMEOUT, TimeUnit.MILLISECONDS);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        } finally {"}
{"magic_number_smell": "            if (isMediaStoreDownloadDir(documentId)) {\n                includeDownloadsFromMediaStore(result, null /* queryArgs */,\n                        null /* filePaths */, notificationUris,\n                        getMediaStoreIdString(documentId), -1, includeHidden);\n            } else {\n                assert (DOC_ID_ROOT.equals(documentId));\n                if (includeHidden) {", "refactored_code": "    private static final int NO_LIMIT = -1;\n            if (isMediaStoreDownloadDir(documentId)) {\n                includeDownloadsFromMediaStore(result, null /* queryArgs */,\n                        null /* filePaths */, notificationUris,\n                        getMediaStoreIdString(documentId), NO_LIMIT, includeHidden);\n            } else {\n                assert (DOC_ID_ROOT.equals(documentId));\n                if (includeHidden) {"}
{"magic_number_smell": "                        throw new StopRequestException(\n                                STATUS_CANNOT_RESUME, \"Precondition failed\");\n\n                    case 416:\n                        throw new StopRequestException(\n                                STATUS_CANNOT_RESUME, \"Requested range not satisfiable\");\n", "refactored_code": "    private static final int HTTP_REQUESTED_RANGE_NOT_SATISFIABLE = 416;\n                        throw new StopRequestException(\n                                STATUS_CANNOT_RESUME, \"Precondition failed\");\n\n                    case HTTP_REQUESTED_RANGE_NOT_SATISFIABLE:\n                        throw new StopRequestException(\n                                STATUS_CANNOT_RESUME, \"Requested range not satisfiable\");\n"}
{"magic_number_smell": "        boolean runUntilProgress(int progress) throws InterruptedException {\n            startDownload(mId);\n\n            int sleepCounter = 5 * 1000 / TIME_TO_SLEEP;\n            int numBytesReceivedSoFar = 0;\n            int totalBytes = 0;\n            for (int i = 0; i < sleepCounter; i++) {", "refactored_code": "        private static final int MAX_TIME_TO_WAIT_FOR_OPERATION = 5;\n        boolean runUntilProgress(int progress) throws InterruptedException {\n            startDownload(mId);\n\n            int sleepCounter = MAX_TIME_TO_WAIT_FOR_OPERATION * 1000 / TIME_TO_SLEEP;\n            int numBytesReceivedSoFar = 0;\n            int totalBytes = 0;\n            for (int i = 0; i < sleepCounter; i++) {"}
{"magic_number_smell": "    @Suppress\n    public void testExtremelyLarge() throws Exception {\n        // NOTE: suppressed since this takes several minutes to run\n        final long length = 3 * 1024 * 1024 * 1024;\n        final InputStream body = new FakeInputStream(length);\n\n        enqueueResponse(new MockResponse().setResponseCode(HTTP_OK).setBody(body, length)", "refactored_code": "    private static final long GB_IN_BYTES = 1024 * 1024 * 1024;\n    @Suppress\n    public void testExtremelyLarge() throws Exception {\n        // NOTE: suppressed since this takes several minutes to run\n        final long length = 3 * GB_IN_BYTES;\n        final InputStream body = new FakeInputStream(length);\n\n        enqueueResponse(new MockResponse().setResponseCode(HTTP_OK).setBody(body, length)"}
{"magic_number_smell": "    public static final int RECORDING_STATE = 1;\n    public static final int PLAYING_STATE = 2;\n    \n    int mState = 0;\n\n    public static final int NO_ERROR = 0;\n    public static final int SDCARD_ACCESS_ERROR = 1;", "refactored_code": "    public static final int IDLE_STATE = 0;\n    public static final int RECORDING_STATE = 1;\n    public static final int PLAYING_STATE = 2;\n    \n    int mState = IDLE_STATE;\n\n    public static final int NO_ERROR = 0;\n    public static final int SDCARD_ACCESS_ERROR = 1;"}
{"magic_number_smell": "    public static final int DISK_SPACE_LIMIT = 2;\n    \n    // which of the two limits we will hit (or have fit) first\n    private int mCurrentLowerLimit = 0;\n    \n    private File mSDCardDirectory;\n    ", "refactored_code": "    public static final int UNKNOWN_LIMIT = 0;\n    public static final int DISK_SPACE_LIMIT = 2;\n    \n    // which of the two limits we will hit (or have fit) first\n    private int mCurrentLowerLimit = UNKNOWN_LIMIT;\n    \n    private File mSDCardDirectory;\n    "}
{"magic_number_smell": "     * @param context of the user.\n     */\n    public CarrierDatabaseHelper(Context context) {\n        super(context, DATABASE_NAME, null, 3);\n        setWriteAheadLoggingEnabled(false);\n    }\n", "refactored_code": "    private static final int DATABASE_VERSION = 3;\n     * @param context of the user.\n     */\n    public CarrierDatabaseHelper(Context context) {\n        super(context, DATABASE_NAME, null, DATABASE_VERSION);\n        setWriteAheadLoggingEnabled(false);\n    }\n"}
{"magic_number_smell": "         * @param context of the user.\n         */\n        public CarrierIdDatabaseHelper(Context context) {\n            super(context, DATABASE_NAME, null, 5);\n            Log.d(TAG, \"CarrierIdDatabaseHelper: \" + 5);\n            setWriteAheadLoggingEnabled(false);\n        }", "refactored_code": "    private static final int DATABASE_VERSION = 5;\n         * @param context of the user.\n         */\n        public CarrierIdDatabaseHelper(Context context) {\n            super(context, DATABASE_NAME, null, DATABASE_VERSION);\n            Log.d(TAG, \"CarrierIdDatabaseHelper: \" + DATABASE_VERSION);\n            setWriteAheadLoggingEnabled(false);\n        }"}
{"magic_number_smell": "     * @param context of the user.\n     */\n    public HbpcdLookupDatabaseHelper(Context context) {\n        super(context, DATABASE_NAME, null, 1);\n\n        mContext = context;\n        // Memory optimization - close idle connections after 30s of inactivity", "refactored_code": "    private static final int DATABASE_VERSION = 1;\n     * @param context of the user.\n     */\n    public HbpcdLookupDatabaseHelper(Context context) {\n        super(context, DATABASE_NAME, null, DATABASE_VERSION);\n\n        mContext = context;\n        // Memory optimization - close idle connections after 30s of inactivity"}
{"magic_number_smell": "    private static final HashMap<String, String> sArbitraryProjectionMap;\n\n    static {\n        sURIMatcher.addURI(HbpcdLookup.AUTHORITY, HbpcdLookup.PATH_MCC_IDD, 1);\n        sURIMatcher.addURI(HbpcdLookup.AUTHORITY,\n                HbpcdLookup.PATH_MCC_LOOKUP_TABLE, MCC_LOOKUP_TABLE);\n        // following URI is a joint table of MCC_LOOKUP_TABLE and MCC_SID_CONFLIct.", "refactored_code": "    private static final int MCC_IDD = 1;\n    private static final HashMap<String, String> sArbitraryProjectionMap;\n\n    static {\n        sURIMatcher.addURI(HbpcdLookup.AUTHORITY, HbpcdLookup.PATH_MCC_IDD, MCC_IDD);\n        sURIMatcher.addURI(HbpcdLookup.AUTHORITY,\n                HbpcdLookup.PATH_MCC_LOOKUP_TABLE, MCC_LOOKUP_TABLE);\n        // following URI is a joint table of MCC_LOOKUP_TABLE and MCC_SID_CONFLIct."}
{"magic_number_smell": "            sURLMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n\n    static {\n        sURLMatcher.addURI(\"mms\", null,         0);\n        sURLMatcher.addURI(\"mms\", \"#\",          MMS_ALL_ID);\n        sURLMatcher.addURI(\"mms\", \"inbox\",      MMS_INBOX);\n        sURLMatcher.addURI(\"mms\", \"inbox/#\",    MMS_INBOX_ID);", "refactored_code": "    private static final int MMS_ALL                      = 0;\n            sURLMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n\n    static {\n        sURLMatcher.addURI(\"mms\", null,         MMS_ALL);\n        sURLMatcher.addURI(\"mms\", \"#\",          MMS_ALL_ID);\n        sURLMatcher.addURI(\"mms\", \"inbox\",      MMS_INBOX);\n        sURLMatcher.addURI(\"mms\", \"inbox/#\",    MMS_INBOX_ID);"}
{"magic_number_smell": "     */\n    public static boolean isAccessRestricted(Context context, String packageName, int uid) {\n        return (uid != Process.SYSTEM_UID\n                && uid != Process.1001\n                && !SmsApplication.isDefaultSmsApplication(context, packageName));\n    }\n", "refactored_code": "    private static final int PHONE_UID = 1001;\n     */\n    public static boolean isAccessRestricted(Context context, String packageName, int uid) {\n        return (uid != Process.SYSTEM_UID\n                && uid != Process.PHONE_UID\n                && !SmsApplication.isDefaultSmsApplication(context, packageName));\n    }\n"}
{"magic_number_smell": "     * @param context of the user.\n     */\n    public SatelliteDatabaseHelper(Context context) {\n        super(context, DATABASE_NAME, null, 1);\n        setWriteAheadLoggingEnabled(false);\n    }\n", "refactored_code": "    private static final int DATABASE_VERSION = 1;\n     * @param context of the user.\n     */\n    public SatelliteDatabaseHelper(Context context) {\n        super(context, DATABASE_NAME, null, DATABASE_VERSION);\n        setWriteAheadLoggingEnabled(false);\n    }\n"}
{"magic_number_smell": "            new UriMatcher(UriMatcher.NO_MATCH);\n\n    static {\n        sURLMatcher.addURI(\"sms-changes\", null, 0);\n    }\n}\n", "refactored_code": "    private static final int SMSCHANGES_URL = 0;\n            new UriMatcher(UriMatcher.NO_MATCH);\n\n    static {\n        sURLMatcher.addURI(\"sms-changes\", null, SMSCHANGES_URL);\n    }\n}\n"}
{"magic_number_smell": "                                null, null, null);\n\n                        if (cursor != null && cursor.moveToFirst()) {\n                            Long id = Long.valueOf(cursor.getLong(0));\n                            values.put(Sms.PERSON, id);\n                        }\n                    } catch (Exception ex) {", "refactored_code": "    private static final int PERSON_ID_COLUMN = 0;\n                                null, null, null);\n\n                        if (cursor != null && cursor.moveToFirst()) {\n                            Long id = Long.valueOf(cursor.getLong(PERSON_ID_COLUMN));\n                            values.put(Sms.PERSON, id);\n                        }\n                    } catch (Exception ex) {"}
{"magic_number_smell": "    // Copied from packages/apps/Messaging/src/com/android/messaging/sms/MmsUtils.java.\n    @VisibleForTesting\n    static final String sSmilTextPart =\n            \"<par dur=\\\"\" + 5000 + \"ms\\\">\" +\n                \"<text src=\\\"%s\\\" region=\\\"Text\\\" />\" +\n            \"</par>\";\n", "refactored_code": "    private static final int DEFAULT_DURATION = 5000; //ms\n    // Copied from packages/apps/Messaging/src/com/android/messaging/sms/MmsUtils.java.\n    @VisibleForTesting\n    static final String sSmilTextPart =\n            \"<par dur=\\\"\" + DEFAULT_DURATION + \"ms\\\">\" +\n                \"<text src=\\\"%s\\\" region=\\\"Text\\\" />\" +\n            \"</par>\";\n"}
{"magic_number_smell": "            super(context, DATABASE_NAME, null, getVersion(context));\n            mContext = context;\n            // Memory optimization - close idle connections after 30s of inactivity\n            setIdleConnectionTimeout(30000);\n            setWriteAheadLoggingEnabled(false);\n        }\n", "refactored_code": "    private static final int IDLE_CONNECTION_TIMEOUT_MS = 30000;\n            super(context, DATABASE_NAME, null, getVersion(context));\n            mContext = context;\n            // Memory optimization - close idle connections after 30s of inactivity\n            setIdleConnectionTimeout(IDLE_CONNECTION_TIMEOUT_MS);\n            setWriteAheadLoggingEnabled(false);\n        }\n"}
{"magic_number_smell": "        }\n        assertEquals(1, findEntry.getCount());\n        findEntry.moveToFirst();\n        assertEquals(0, findEntry.getInt(0));\n        assertEquals(test_iccid_prefix, findEntry.getString(1));\n    }\n", "refactored_code": "    private static final int test_cid = 0;\n        }\n        assertEquals(1, findEntry.getCount());\n        findEntry.moveToFirst();\n        assertEquals(test_cid, findEntry.getInt(0));\n        assertEquals(test_iccid_prefix, findEntry.getString(1));\n    }\n"}
{"magic_number_smell": "    public void testInsertCertificates() {\n        int count = -1;\n        ContentValues contentValues = new ContentValues();\n        contentValues.put(CarrierDatabaseHelper.KEY_TYPE, 1);\n        contentValues.put(CarrierDatabaseHelper.MCC, test_mcc);\n        contentValues.put(CarrierDatabaseHelper.MNC, test_mnc);\n        contentValues.put(CarrierDatabaseHelper.CARRIER_ID, TEST_CARRIER_ID_1);", "refactored_code": "    public static final int test_type = 1;\n    public void testInsertCertificates() {\n        int count = -1;\n        ContentValues contentValues = new ContentValues();\n        contentValues.put(CarrierDatabaseHelper.KEY_TYPE, test_type);\n        contentValues.put(CarrierDatabaseHelper.MCC, test_mcc);\n        contentValues.put(CarrierDatabaseHelper.MNC, test_mnc);\n        contentValues.put(CarrierDatabaseHelper.CARRIER_ID, TEST_CARRIER_ID_1);"}
{"magic_number_smell": "    public void testDBHelperOnUpgrade_hasSubIdField() {\n        Log.d(TAG, \"databaseHelperOnUpgrade_hasSubIdField\");\n        SQLiteDatabase db = mInMemoryDbHelper.getWritableDatabase();\n        mMmsSmsDatabaseHelper.onUpgrade(db, 40,\n                MmsSmsDatabaseHelper.DATABASE_VERSION);\n\n        // Following tables must have sub_id column in the upgraded DB.", "refactored_code": "    private static final int BASE_DATABASE_VERSION = 40;\n    public void testDBHelperOnUpgrade_hasSubIdField() {\n        Log.d(TAG, \"databaseHelperOnUpgrade_hasSubIdField\");\n        SQLiteDatabase db = mInMemoryDbHelper.getWritableDatabase();\n        mMmsSmsDatabaseHelper.onUpgrade(db, BASE_DATABASE_VERSION,\n                MmsSmsDatabaseHelper.DATABASE_VERSION);\n\n        // Following tables must have sub_id column in the upgraded DB."}
{"magic_number_smell": "        assertEquals(mFakeMessageBody, cursor.getString(cursor.getColumnIndex(\"message_body\")));\n        assertEquals(mDate, cursor.getInt(cursor.getColumnIndex(\"date\")));\n        assertEquals(mFakePort, cursor.getInt(cursor.getColumnIndex(\"destination_port\")));\n        assertEquals(123, cursor.getInt(cursor.getColumnIndex(\"reference_number\")));\n        assertEquals(mFakeSequence, cursor.getInt(cursor.getColumnIndex(\"sequence\")));\n        assertEquals(mFakeCount, cursor.getInt(cursor.getColumnIndex(\"count\")));\n        assertEquals(0, cursor.getInt(cursor.getColumnIndex(\"deleted\")));", "refactored_code": "    private final int mFakeRefNumber = 123;\n        assertEquals(mFakeMessageBody, cursor.getString(cursor.getColumnIndex(\"message_body\")));\n        assertEquals(mDate, cursor.getInt(cursor.getColumnIndex(\"date\")));\n        assertEquals(mFakePort, cursor.getInt(cursor.getColumnIndex(\"destination_port\")));\n        assertEquals(mFakeRefNumber, cursor.getInt(cursor.getColumnIndex(\"reference_number\")));\n        assertEquals(mFakeSequence, cursor.getInt(cursor.getColumnIndex(\"sequence\")));\n        assertEquals(mFakeCount, cursor.getInt(cursor.getColumnIndex(\"count\")));\n        assertEquals(0, cursor.getInt(cursor.getColumnIndex(\"deleted\")));"}
{"magic_number_smell": "                    .isActiveSubscriptionId(anyInt());\n            doReturn(mTelephonyManager).when(mTelephonyManager).createForSubscriptionId(anyInt());\n            doReturn(TEST_OPERATOR).when(mTelephonyManager).getSimOperator();\n            doReturn(1).when(mTelephonyManager).getSimSpecificCarrierId();\n\n            // Add authority=\"telephony\" to given telephonyProvider\n            ProviderInfo providerInfo = new ProviderInfo();", "refactored_code": "    private static final int TEST_CARRIERID = 1;\n                    .isActiveSubscriptionId(anyInt());\n            doReturn(mTelephonyManager).when(mTelephonyManager).createForSubscriptionId(anyInt());\n            doReturn(TEST_OPERATOR).when(mTelephonyManager).getSimOperator();\n            doReturn(TEST_CARRIERID).when(mTelephonyManager).getSimSpecificCarrierId();\n\n            // Add authority=\"telephony\" to given telephonyProvider\n            ProviderInfo providerInfo = new ProviderInfo();"}
{"magic_number_smell": "\n    private static String poll(BlockingQueue<String> queue) {\n        try {\n            String value = queue.poll(5000, TimeUnit.MILLISECONDS);\n            assertNotNull(value, \"Event poll timed out\");\n            return value;\n        } catch (InterruptedException e) {", "refactored_code": "    private static final int TIMEOUT_MS = 5000;\n\n    private static String poll(BlockingQueue<String> queue) {\n        try {\n            String value = queue.poll(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n            assertNotNull(value, \"Event poll timed out\");\n            return value;\n        } catch (InterruptedException e) {"}
{"magic_number_smell": "\t    while (line != null) {\n\t\tm = timep.matcher(line);\n\t\tif (m.lookingAt()) {\n\t\t    if (size % 10000 == 0) {\n\t\t\tlong time = timestampFromText(dateformat, m.group(1));\n\t\t\tskiplist.addMark(time, lastFp, size);\n\t\t    }", "refactored_code": "    private static final int skipN = 10000;\n\t    while (line != null) {\n\t\tm = timep.matcher(line);\n\t\tif (m.lookingAt()) {\n\t\t    if (size % skipN == 0) {\n\t\t\tlong time = timestampFromText(dateformat, m.group(1));\n\t\t\tskiplist.addMark(time, lastFp, size);\n\t\t    }"}
{"magic_number_smell": "\npublic class MeasureThroughput {\n    private static final int 1000 = 1000;\n    private static final int MS_PER_MIN = 1000*60;\n    private static final int MS_PER_HOUR = MS_PER_MIN*60;\n    \n    public static void main(String[] args) throws IOException {\t", "refactored_code": "    private static final int MS_PER_SEC = 1000;\n\npublic class MeasureThroughput {\n    private static final int MS_PER_SEC = 1000;\n    private static final int MS_PER_MIN = MS_PER_SEC*60;\n    private static final int MS_PER_HOUR = MS_PER_MIN*60;\n    \n    public static void main(String[] args) throws IOException {\t"}
{"magic_number_smell": "\t    }\n\t}\n\n\tbuffer = new byte[512*1024];\n\tbuffersize = 0;\n\tbufferoffset = 0;\n\tfileoffset = 0;", "refactored_code": "    private static final int DEFAULT_BUFFER_SIZE = 512*1024; // 512k\n\t    }\n\t}\n\n\tbuffer = new byte[DEFAULT_BUFFER_SIZE];\n\tbuffersize = 0;\n\tbufferoffset = 0;\n\tfileoffset = 0;"}
{"magic_number_smell": "\t\t}\n\t\tendtime = hdr.getTime();\n\n\t\tif (size % 10000 == 0) {\n\t\t    skiplist.addMark(hdr.getTime(), lastFp, size);\n\t\t}\n\t\tsize++;", "refactored_code": "    private static final int skipN = 10000;\n\t\t}\n\t\tendtime = hdr.getTime();\n\n\t\tif (size % skipN == 0) {\n\t\t    skiplist.addMark(hdr.getTime(), lastFp, size);\n\t\t}\n\t\tsize++;"}
{"magic_number_smell": "\t    if (period > 0) {\n\t\tendtime = starttime + period;\n\t    } else {\n\t\tendtime = starttime + 1000; \n\t    }\n\t}\n", "refactored_code": "    private static final int DEFAULT_PERIOD = 1000;\n\t    if (period > 0) {\n\t\tendtime = starttime + period;\n\t    } else {\n\t\tendtime = starttime + DEFAULT_PERIOD; \n\t    }\n\t}\n"}
{"magic_number_smell": "public class Throughput extends JsonServlet\n{\n    private static final int 1000 = 1000;\n    private static final int MS_PER_MIN = 1000*60;\n    private static final int MS_PER_HOUR = MS_PER_MIN*60;\n\n    private LogSource source = null;", "refactored_code": "    private static final int MS_PER_SEC = 1000;\npublic class Throughput extends JsonServlet\n{\n    private static final int MS_PER_SEC = 1000;\n    private static final int MS_PER_MIN = MS_PER_SEC*60;\n    private static final int MS_PER_HOUR = MS_PER_MIN*60;\n\n    private LogSource source = null;"}
{"magic_number_smell": "   protected static final String CONTEXT_PATH = \"/zk\";\n   protected static final int 10104 = 10104;\n   protected static final String BASEURI = String.format(\n           \"http://localhost:%d%s\", 10104, CONTEXT_PATH);\n   protected static final String ZKHOSTPORT = \"localhost:22182\";\n   protected Client client;\n   protected WebResource znodesr, sessionsr;", "refactored_code": "   protected static final int GRIZZLY_PORT = 10104;\n   protected static final String CONTEXT_PATH = \"/zk\";\n   protected static final int GRIZZLY_PORT = 10104;\n   protected static final String BASEURI = String.format(\n           \"http://localhost:%d%s\", GRIZZLY_PORT, CONTEXT_PATH);\n   protected static final String ZKHOSTPORT = \"localhost:22182\";\n   protected Client client;\n   protected WebResource znodesr, sessionsr;"}
{"magic_number_smell": "\t */\n\tclass SingleToaster extends javax.swing.JWindow\n\t{\n\t\tprivate static final long 1L = 1L;\n\n\t\t// Label to store Icon\n\t\tprivate JLabel iconLabel = new JLabel();", "refactored_code": "\tprivate static final long serialVersionUID = 1L;\n\t */\n\tclass SingleToaster extends javax.swing.JWindow\n\t{\n\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t// Label to store Icon\n\t\tprivate JLabel iconLabel = new JLabel();"}
{"magic_number_smell": "            }\n        });\n        JScrollPane treeScroller = new JScrollPane(treeViewer);\n        treeScroller.getVerticalScrollBar().setUnitIncrement(16);\n        JSplitPane splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,\n                treeScroller, nodeViewersPanel);\n        splitPane.setResizeWeight(0.25);", "refactored_code": "    private static final int TREE_SCROLL_UNIT_INCREMENT = 16;\n            }\n        });\n        JScrollPane treeScroller = new JScrollPane(treeViewer);\n        treeScroller.getVerticalScrollBar().setUnitIncrement(TREE_SCROLL_UNIT_INCREMENT);\n        JSplitPane splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,\n                treeScroller, nodeViewersPanel);\n        splitPane.setResizeWeight(0.25);"}
{"magic_number_smell": "    public NodesCache(ZooKeeper zooKeeper) {\n        this.zooKeeper = zooKeeper;\n        this.nodes = CacheBuilder.newBuilder()\n                .maximumSize(40000)\n                .expireAfterWrite(ENTRY_EXPIRATION_TIME_MILLIS, TimeUnit.MILLISECONDS)\n                .build(new CacheLoader<String, List<String>>() {\n                           @Override", "refactored_code": "    public static final int CACHE_SIZE = 40000;\n    public NodesCache(ZooKeeper zooKeeper) {\n        this.zooKeeper = zooKeeper;\n        this.nodes = CacheBuilder.newBuilder()\n                .maximumSize(CACHE_SIZE)\n                .expireAfterWrite(ENTRY_EXPIRATION_TIME_MILLIS, TimeUnit.MILLISECONDS)\n                .build(new CacheLoader<String, List<String>>() {\n                           @Override"}
{"magic_number_smell": "        defaultEncryptionManager = props.getProperty(DATA_ENCRYPTION_MANAGER) == null ?\n            DEFAULT_ENCRYPTION_MANAGER : props.getProperty(DATA_ENCRYPTION_MANAGER);\n        defaultTimeout = props.getProperty(SESSION_TIMEOUT) == null ?\n            Integer.toString(5000) : props.getProperty(SESSION_TIMEOUT);\n        defaultHosts = props.getProperty(CONNECT_STRING) == null ?\n            DEFAULT_HOSTS : props.getProperty(CONNECT_STRING);\n        defaultAuthScheme = props.getProperty(AUTH_SCHEME_KEY) == null ?", "refactored_code": "    private static final int DEFAULT_TIMEOUT = 5000;\n        defaultEncryptionManager = props.getProperty(DATA_ENCRYPTION_MANAGER) == null ?\n            DEFAULT_ENCRYPTION_MANAGER : props.getProperty(DATA_ENCRYPTION_MANAGER);\n        defaultTimeout = props.getProperty(SESSION_TIMEOUT) == null ?\n            Integer.toString(DEFAULT_TIMEOUT) : props.getProperty(SESSION_TIMEOUT);\n        defaultHosts = props.getProperty(CONNECT_STRING) == null ?\n            DEFAULT_HOSTS : props.getProperty(CONNECT_STRING);\n        defaultAuthScheme = props.getProperty(AUTH_SCHEME_KEY) == null ?"}
{"magic_number_smell": "        this.assignmentsNode = prefix + '/' + this.assignmentsNode;\n        this.reportsNode = prefix + '/' + this.reportsNode;\n        this.statusNode = prefix + '/' + this.statusNode;\n        for(int i = 0; i < 3; i++) {\n            try {\n                setupNodes(zk);\n                break;", "refactored_code": "    private static final int maxTries = 3;\n        this.assignmentsNode = prefix + '/' + this.assignmentsNode;\n        this.reportsNode = prefix + '/' + this.reportsNode;\n        this.statusNode = prefix + '/' + this.statusNode;\n        for(int i = 0; i < maxTries; i++) {\n            try {\n                setupNodes(zk);\n                break;"}
{"magic_number_smell": "                    return;\n                }\n                System.err.println(\"SnapDir = \" + snapDir + \" LogDir = \" + logDir);\n                peer = new QuorumPeer(peers, snapDir, logDir, clientAddr.getPort(), 3, serverId, tickTime, initLimit, 3, connectToLearnerMasterLimit);\n                peer.start();\n                for(int i = 0; i < 5; i++) {\n                    Thread.sleep(500);", "refactored_code": "    private static final int syncLimit = 3;\n                    return;\n                }\n                System.err.println(\"SnapDir = \" + snapDir + \" LogDir = \" + logDir);\n                peer = new QuorumPeer(peers, snapDir, logDir, clientAddr.getPort(), 3, serverId, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);\n                peer.start();\n                for(int i = 0; i < 5; i++) {\n                    Thread.sleep(500);"}
{"magic_number_smell": "\n    static {\n        final Integer configuredExtraMaxBuffer =\n            Integer.getInteger(\"zookeeper.jute.maxbuffer.extrasize\", Integer.getInteger(\"jute.maxbuffer\", 0xfffff));\n        if (configuredExtraMaxBuffer < 1024) {\n            // Earlier hard coded value was 1024, So the value should not be less than that value\n            extraMaxBuffer = 1024;", "refactored_code": "    public static final int maxBuffer = Integer.getInteger(\"jute.maxbuffer\", 0xfffff);\n\n    static {\n        final Integer configuredExtraMaxBuffer =\n            Integer.getInteger(\"zookeeper.jute.maxbuffer.extrasize\", maxBuffer);\n        if (configuredExtraMaxBuffer < 1024) {\n            // Earlier hard coded value was 1024, So the value should not be less than that value\n            extraMaxBuffer = 1024;"}
{"magic_number_smell": "    protected Object retryOperation(ZooKeeperOperation operation)\n        throws KeeperException, InterruptedException {\n        KeeperException exception = null;\n        for (int i = 0; i < 10; i++) {\n            try {\n                return operation.execute();\n            } catch (KeeperException.SessionExpiredException e) {", "refactored_code": "    private static final int RETRY_COUNT = 10;\n    protected Object retryOperation(ZooKeeperOperation operation)\n        throws KeeperException, InterruptedException {\n        KeeperException exception = null;\n        for (int i = 0; i < RETRY_COUNT; i++) {\n            try {\n                return operation.execute();\n            } catch (KeeperException.SessionExpiredException e) {"}
{"magic_number_smell": "\n                        // Note, we may exceed our max length by a bit when we add the last\n                        // watch in the batch. This isn't ideal, but it makes the code simpler.\n                        while (batchLength < 128 * 1024) {\n                            final String watch;\n                            if (dataWatchesIter.hasNext()) {\n                                watch = dataWatchesIter.next();", "refactored_code": "    private static final int SET_WATCHES_MAX_LENGTH = 128 * 1024;\n\n                        // Note, we may exceed our max length by a bit when we add the last\n                        // watch in the batch. This isn't ideal, but it makes the code simpler.\n                        while (batchLength < SET_WATCHES_MAX_LENGTH) {\n                            final String watch;\n                            if (dataWatchesIter.hasNext()) {\n                                watch = dataWatchesIter.next();"}
{"magic_number_smell": "     */\n    private static final float TICKET_RENEW_JITTER = 0.05f;\n\n    // Regardless of 0.80f setting above and the ticket expiry time,\n    // thread will not sleep between refresh attempts any less than 1 minute (60*1000 milliseconds = 1 minute).\n    // Change the '1' to e.g. 5, to change this to 5 minutes.\n    private static final long DEFAULT_MIN_TIME_BEFORE_RELOGIN = 1 * 60 * 1000L;", "refactored_code": "    private static final float TICKET_RENEW_WINDOW = 0.80f;\n     */\n    private static final float TICKET_RENEW_JITTER = 0.05f;\n\n    // Regardless of TICKET_RENEW_WINDOW setting above and the ticket expiry time,\n    // thread will not sleep between refresh attempts any less than 1 minute (60*1000 milliseconds = 1 minute).\n    // Change the '1' to e.g. 5, to change this to 5 minutes.\n    private static final long DEFAULT_MIN_TIME_BEFORE_RELOGIN = 1 * 60 * 1000L;"}
{"magic_number_smell": "     * Create a WatchedEvent with specified type, state and path\n     */\n    public WatchedEvent(EventType eventType, KeeperState keeperState, String path) {\n        this(eventType, keeperState, path, -1L);\n    }\n\n    /**", "refactored_code": "    public static final long NO_ZXID = -1L;\n     * Create a WatchedEvent with specified type, state and path\n     */\n    public WatchedEvent(EventType eventType, KeeperState keeperState, String path) {\n        this(eventType, keeperState, path, NO_ZXID);\n    }\n\n    /**"}
{"magic_number_smell": "    protected static final int 1 = 1;\n\n    public CliException(String message) {\n        this(message, 1);\n    }\n\n    public CliException(String message, int exitCode) {", "refactored_code": "    protected static final int DEFAULT_EXCEPTION_EXIT_CODE = 1;\n    protected static final int DEFAULT_EXCEPTION_EXIT_CODE = 1;\n\n    public CliException(String message) {\n        this(message, DEFAULT_EXCEPTION_EXIT_CODE);\n    }\n\n    public CliException(String message, int exitCode) {"}
{"magic_number_smell": "        try {\n            zk.sync(path, (rc, path1, ctx) -> cf.complete(rc), null);\n\n            int resultCode = cf.get(TimeUnit.SECONDS.toMillis(30L), TimeUnit.MILLISECONDS);\n            if (resultCode == 0) {\n                out.println(\"Sync is OK\");\n            } else {", "refactored_code": "    public static final long SYNC_TIMEOUT = TimeUnit.SECONDS.toMillis(30L);\n        try {\n            zk.sync(path, (rc, path1, ctx) -> cf.complete(rc), null);\n\n            int resultCode = cf.get(SYNC_TIMEOUT, TimeUnit.MILLISECONDS);\n            if (resultCode == 0) {\n                out.println(\"Sync is OK\");\n            } else {"}
{"magic_number_smell": "\n        List<String> hostsList = split(connectString, \",\");\n        for (String host : hostsList) {\n            int port = 2181;\n            String[] hostAndPort = NetUtils.getIPV6HostAndPort(host);\n            if (hostAndPort.length != 0) {\n                host = hostAndPort[0];", "refactored_code": "    private static final int DEFAULT_PORT = 2181;\n\n        List<String> hostsList = split(connectString, \",\");\n        for (String host : hostsList) {\n            int port = DEFAULT_PORT;\n            String[] hostAndPort = NetUtils.getIPV6HostAndPort(host);\n            if (hostAndPort.length != 0) {\n                host = hostAndPort[0];"}
{"magic_number_smell": "     * @throws SSLContextException\n     */\n    public static String send4LetterWord(String host, int port, String cmd) throws IOException, SSLContextException {\n        return send4LetterWord(host, port, cmd, false, 5000);\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_SOCKET_TIMEOUT = 5000;\n     * @throws SSLContextException\n     */\n    public static String send4LetterWord(String host, int port, String cmd) throws IOException, SSLContextException {\n        return send4LetterWord(host, port, cmd, false, DEFAULT_SOCKET_TIMEOUT);\n    }\n\n    /**"}
{"magic_number_smell": "                }\n            }\n            LOG.debug(\"Detected {} local network addresses: {}\", validInetAddresses.size(), validInetAddresses);\n            return !validInetAddresses.isEmpty() ? validInetAddresses.size() : 1;\n        } catch (SocketException ex) {\n            LOG.warn(\"Failed to list all network interfaces, assuming 1\", ex);\n            return 1;", "refactored_code": "    private static final int DEFAULT_INET_ADDRESS_COUNT = 1;\n                }\n            }\n            LOG.debug(\"Detected {} local network addresses: {}\", validInetAddresses.size(), validInetAddresses);\n            return !validInetAddresses.isEmpty() ? validInetAddresses.size() : DEFAULT_INET_ADDRESS_COUNT;\n        } catch (SocketException ex) {\n            LOG.warn(\"Failed to list all network interfaces, assuming 1\", ex);\n            return DEFAULT_INET_ADDRESS_COUNT;"}
{"magic_number_smell": "    /**\n     * Returns the max amount of time, in milliseconds, that the first UnifiedServerSocket read() operation should\n     * block for when trying to detect the client mode (TLS or PLAINTEXT).\n     * Defaults to {@link X509Util#5000}.\n     *\n     * @return the handshake detection timeout, in milliseconds.\n     */", "refactored_code": "    public static final int DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS = 5000;\n    /**\n     * Returns the max amount of time, in milliseconds, that the first UnifiedServerSocket read() operation should\n     * block for when trying to detect the client mode (TLS or PLAINTEXT).\n     * Defaults to {@link X509Util#DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS}.\n     *\n     * @return the handshake detection timeout, in milliseconds.\n     */"}
{"magic_number_smell": "     * Returns with the current digest version.\n     */\n    int getDigestVersion() {\n        return 2;\n    }\n\n}", "refactored_code": "    private static final int DIGEST_VERSION = 2;\n     * Returns with the current digest version.\n     */\n    int getDigestVersion() {\n        return DIGEST_VERSION;\n    }\n\n}"}
{"magic_number_smell": "                return ephemeralType;\n            }\n        }\n        if (ephemeralOwner == Long.MIN_VALUE) {\n            return CONTAINER;\n        }\n        return (ephemeralOwner == 0) ? VOID : NORMAL;", "refactored_code": "    public static final long CONTAINER_EPHEMERAL_OWNER = Long.MIN_VALUE;\n                return ephemeralType;\n            }\n        }\n        if (ephemeralOwner == CONTAINER_EPHEMERAL_OWNER) {\n            return CONTAINER;\n        }\n        return (ephemeralOwner == 0) ? VOID : NORMAL;"}
{"magic_number_smell": "    public static final long TTL_MASK = 0x8000000000000000L;\n\n    public static EphemeralTypeEmulate353 get(long ephemeralOwner) {\n        if (ephemeralOwner == Long.MIN_VALUE) {\n            return CONTAINER;\n        }\n        if (ephemeralOwner < 0) {", "refactored_code": "    public static final long CONTAINER_EPHEMERAL_OWNER = Long.MIN_VALUE;\n    public static final long TTL_MASK = 0x8000000000000000L;\n\n    public static EphemeralTypeEmulate353 get(long ephemeralOwner) {\n        if (ephemeralOwner == CONTAINER_EPHEMERAL_OWNER) {\n            return CONTAINER;\n        }\n        if (ephemeralOwner < 0) {"}
{"magic_number_smell": "                // It requires 5 bytes to detect a proper ssl connection. In the\n                // case that the server receives fewer, check if we can fail to plaintext.\n                // This will occur when for any four letter work commands.\n                if (0x16 != in.getByte(0)) {\n                    LOG.debug(\"first byte {} does not match TLS handshake, failing to plaintext\", in.getByte(0));\n                    handleNonSsl(context);\n                }", "refactored_code": "    private static final byte TLS_HANDSHAKE_RECORD_TYPE = 0x16;\n                // It requires 5 bytes to detect a proper ssl connection. In the\n                // case that the server receives fewer, check if we can fail to plaintext.\n                // This will occur when for any four letter work commands.\n                if (TLS_HANDSHAKE_RECORD_TYPE != in.getByte(0)) {\n                    LOG.debug(\"first byte {} does not match TLS handshake, failing to plaintext\", in.getByte(0));\n                    handleNonSsl(context);\n                }"}
{"magic_number_smell": "     */\n    public synchronized Long convertAcls(List<ACL> acls) {\n        if (acls == null) {\n            return -1L;\n        }\n\n        // get the value from the map", "refactored_code": "    private static final long OPEN_UNSAFE_ACL_ID = -1L;\n     */\n    public synchronized Long convertAcls(List<ACL> acls) {\n        if (acls == null) {\n            return OPEN_UNSAFE_ACL_ID;\n        }\n\n        // get the value from the map"}
{"magic_number_smell": "            // If the request latency is higher than session timeout, consider\n            // the request stale.\n            long currentTime = Time.currentElapsedTime();\n            return (currentTime - Time.currentElapsedTime()) > cnxn.getSessionTimeout();\n        }\n\n        return false;", "refactored_code": "    public final long createTime = Time.currentElapsedTime();\n            // If the request latency is higher than session timeout, consider\n            // the request stale.\n            long currentTime = Time.currentElapsedTime();\n            return (currentTime - createTime) > cnxn.getSessionTimeout();\n        }\n\n        return false;"}
{"magic_number_smell": "    }\n\n    protected void initMaxCnxns() {\n        maxCnxns = Integer.getInteger(ZOOKEEPER_MAX_CONNECTION, 0);\n        if (maxCnxns < 0) {\n            maxCnxns = 0;\n            LOG.warn(\"maxCnxns should be greater than or equal to 0, using default value {}.\",", "refactored_code": "    public static final int ZOOKEEPER_MAX_CONNECTION_DEFAULT = 0;\n    }\n\n    protected void initMaxCnxns() {\n        maxCnxns = Integer.getInteger(ZOOKEEPER_MAX_CONNECTION, ZOOKEEPER_MAX_CONNECTION_DEFAULT);\n        if (maxCnxns < 0) {\n            maxCnxns = ZOOKEEPER_MAX_CONNECTION_DEFAULT;\n            LOG.warn(\"maxCnxns should be greater than or equal to 0, using default value {}.\","}
{"magic_number_smell": "    }\n\n    public long getUptime() {\n        return Time.currentElapsedTime() - Time.currentElapsedTime();\n    }\n\n    public boolean isProviderNull() {", "refactored_code": "    private final long startTime = Time.currentElapsedTime();\n    }\n\n    public long getUptime() {\n        return Time.currentElapsedTime() - startTime;\n    }\n\n    public boolean isProviderNull() {"}
{"magic_number_smell": "        try {\n            snapshotSizeFactor = Double.parseDouble(\n                    System.getProperty(SNAPSHOT_SIZE_FACTOR,\n                            Double.toString(0.33)));\n            if (snapshotSizeFactor > 1) {\n                snapshotSizeFactor = 0.33;\n                LOG.warn(", "refactored_code": "    public static final double DEFAULT_SNAPSHOT_SIZE_FACTOR = 0.33;\n        try {\n            snapshotSizeFactor = Double.parseDouble(\n                    System.getProperty(SNAPSHOT_SIZE_FACTOR,\n                            Double.toString(DEFAULT_SNAPSHOT_SIZE_FACTOR)));\n            if (snapshotSizeFactor > 1) {\n                snapshotSizeFactor = DEFAULT_SNAPSHOT_SIZE_FACTOR;\n                LOG.warn("}
{"magic_number_smell": "    protected DataTreeBean jmxDataTreeBean;\n\n    public static final int 3000 = 3000;\n    protected int tickTime = 3000;\n    public static final int DEFAULT_THROTTLED_OP_WAIT_TIME = 0; // disabled\n    protected static volatile int throttledOpWaitTime =\n        Integer.getInteger(\"zookeeper.throttled_op_wait_time\", DEFAULT_THROTTLED_OP_WAIT_TIME);", "refactored_code": "    public static final int DEFAULT_TICK_TIME = 3000;\n    protected DataTreeBean jmxDataTreeBean;\n\n    public static final int DEFAULT_TICK_TIME = 3000;\n    protected int tickTime = DEFAULT_TICK_TIME;\n    public static final int DEFAULT_THROTTLED_OP_WAIT_TIME = 0; // disabled\n    protected static volatile int throttledOpWaitTime =\n        Integer.getInteger(\"zookeeper.throttled_op_wait_time\", DEFAULT_THROTTLED_OP_WAIT_TIME);"}
{"magic_number_smell": "    @Deprecated\n    public static final long JMX_TRACE_MASK = 1 << 9;\n\n    private static long traceMask = 1 << 1 | SERVER_PACKET_TRACE_MASK | SESSION_TRACE_MASK | WARNING_TRACE_MASK;\n\n    public static synchronized long getTextTraceLevel() {\n        return traceMask;", "refactored_code": "    public static final long CLIENT_REQUEST_TRACE_MASK = 1 << 1;\n    @Deprecated\n    public static final long JMX_TRACE_MASK = 1 << 9;\n\n    private static long traceMask = CLIENT_REQUEST_TRACE_MASK | SERVER_PACKET_TRACE_MASK | SESSION_TRACE_MASK | WARNING_TRACE_MASK;\n\n    public static synchronized long getTextTraceLevel() {\n        return traceMask;"}
{"magic_number_smell": "\n        public RestoreCommand() {\n            super(Arrays.asList(\"restore\", \"rest\"), true, new AuthRequest(ZooDefs.Perms.ALL, ROOT_PATH));\n            rateLimiter = new RateLimiter(1, Integer.parseInt(System.getProperty(ADMIN_RATE_LIMITER_INTERVAL, \"300000\")), TimeUnit.MILLISECONDS);\n        }\n\n        @Override", "refactored_code": "    private static final long rateLimiterInterval = Integer.parseInt(System.getProperty(ADMIN_RATE_LIMITER_INTERVAL, \"300000\"));\n\n        public RestoreCommand() {\n            super(Arrays.asList(\"restore\", \"rest\"), true, new AuthRequest(ZooDefs.Perms.ALL, ROOT_PATH));\n            rateLimiter = new RateLimiter(1, rateLimiterInterval, TimeUnit.MILLISECONDS);\n        }\n\n        @Override"}
{"magic_number_smell": "    public JettyAdminServer() throws AdminServerException, IOException, GeneralSecurityException {\n        this(\n            System.getProperty(\"zookeeper.admin.serverAddress\", DEFAULT_ADDRESS),\n            Integer.getInteger(\"zookeeper.admin.serverPort\", 8080),\n            Integer.getInteger(\"zookeeper.admin.idleTimeout\", DEFAULT_IDLE_TIMEOUT),\n            System.getProperty(\"zookeeper.admin.commandURL\", DEFAULT_COMMAND_URL),\n            Integer.getInteger(\"zookeeper.admin.httpVersion\", DEFAULT_HTTP_VERSION),", "refactored_code": "    public static final int DEFAULT_PORT = 8080;\n    public JettyAdminServer() throws AdminServerException, IOException, GeneralSecurityException {\n        this(\n            System.getProperty(\"zookeeper.admin.serverAddress\", DEFAULT_ADDRESS),\n            Integer.getInteger(\"zookeeper.admin.serverPort\", DEFAULT_PORT),\n            Integer.getInteger(\"zookeeper.admin.idleTimeout\", DEFAULT_IDLE_TIMEOUT),\n            System.getProperty(\"zookeeper.admin.commandURL\", DEFAULT_COMMAND_URL),\n            Integer.getInteger(\"zookeeper.admin.httpVersion\", DEFAULT_HTTP_VERSION),"}
{"magic_number_smell": "        }\n\n        long currentTime = System.currentTimeMillis();\n        if (lastFailureLogged + 1000 < currentTime) {\n            String id = cnxn.getRemoteSocketAddress().getAddress().getHostAddress();\n            LOG.warn(\"Unexpected ensemble name: ensemble name: {} client ip: {}\", receivedEnsembleName, id);\n            lastFailureLogged = currentTime;", "refactored_code": "    private static final int MIN_LOGGING_INTERVAL_MS = 1000;\n        }\n\n        long currentTime = System.currentTimeMillis();\n        if (lastFailureLogged + MIN_LOGGING_INTERVAL_MS < currentTime) {\n            String id = cnxn.getRemoteSocketAddress().getAddress().getHostAddress();\n            LOG.warn(\"Unexpected ensemble name: ensemble name: {} client ip: {}\", receivedEnsembleName, id);\n            lastFailureLogged = currentTime;"}
{"magic_number_smell": "\n    // specify all of the commands that are available\n    static {\n        cmd2String.put(ByteBuffer.wrap(\"conf\".getBytes()).getInt(), \"conf\");\n        cmd2String.put(consCmd, \"cons\");\n        cmd2String.put(crstCmd, \"crst\");\n        cmd2String.put(dirsCmd, \"dirs\");", "refactored_code": "    public static final int confCmd = ByteBuffer.wrap(\"conf\".getBytes()).getInt();\n\n    // specify all of the commands that are available\n    static {\n        cmd2String.put(confCmd, \"conf\");\n        cmd2String.put(consCmd, \"cons\");\n        cmd2String.put(crstCmd, \"crst\");\n        cmd2String.put(dirsCmd, \"dirs\");"}
{"magic_number_smell": "    }\n\n    public CommandClient(int localhostPort) {\n        this(localhostPort, 10000);\n    }\n\n    public synchronized void close() {", "refactored_code": "    private static final int DEFAULT_TIMEOUT = 10000;\n    }\n\n    public CommandClient(int localhostPort) {\n        this(localhostPort, DEFAULT_TIMEOUT);\n    }\n\n    public synchronized void close() {"}
{"magic_number_smell": "                break;\n            case ADDDELAY:\n                cnxnFactory.delayResponses(command.getParameter() == null\n                        ? 1000 : Long.decode(command.getParameter()));\n                break;\n            case NORESPONSE:\n                if (command.getParameter() == null) {", "refactored_code": "    private static final long DEFAULT_DELAY_MS = 1000;\n                break;\n            case ADDDELAY:\n                cnxnFactory.delayResponses(command.getParameter() == null\n                        ? DEFAULT_DELAY_MS : Long.decode(command.getParameter()));\n                break;\n            case NORESPONSE:\n                if (command.getParameter() == null) {"}
{"magic_number_smell": "        private static final int BITS_PER_LONG = 63;\n\n        private final AtomicLong count = new AtomicLong();\n        private volatile AtomicLongArray values = new AtomicLongArray(4096);\n\n        @Override\n        public int size() {", "refactored_code": "        private static final int DEFAULT_SIZE = 4096;\n        private static final int BITS_PER_LONG = 63;\n\n        private final AtomicLong count = new AtomicLong();\n        private volatile AtomicLongArray values = new AtomicLongArray(DEFAULT_SIZE);\n\n        @Override\n        public int size() {"}
{"magic_number_smell": "        if (!close) {\n            try (CheckedOutputStream snapOS = SnapStream.getOutputStream(snapShot, fsync)) {\n                OutputArchive oa = BinaryOutputArchive.getArchive(snapOS);\n                FileHeader header = new FileHeader(SNAP_MAGIC, 2, dbId);\n                serialize(dt, sessions, oa, header);\n                SnapStream.sealStream(snapOS, oa);\n", "refactored_code": "    private static final int VERSION = 2;\n        if (!close) {\n            try (CheckedOutputStream snapOS = SnapStream.getOutputStream(snapShot, fsync)) {\n                OutputArchive oa = BinaryOutputArchive.getArchive(snapOS);\n                FileHeader header = new FileHeader(SNAP_MAGIC, VERSION, dbId);\n                serialize(dt, sessions, oa, header);\n                SnapStream.sealStream(snapOS, oa);\n"}
{"magic_number_smell": "            fos = new FileOutputStream(logFileWrite);\n            logStream = new BufferedOutputStream(fos);\n            oa = BinaryOutputArchive.getArchive(logStream);\n            FileHeader fhdr = new FileHeader(ByteBuffer.wrap(\"ZKLG\".getBytes()).getInt(), VERSION, dbId);\n            long dataSize = oa.getDataSize();\n            fhdr.serialize(oa, \"fileheader\");\n            // Make sure that the magic number is written before padding.", "refactored_code": "    public static final int TXNLOG_MAGIC = ByteBuffer.wrap(\"ZKLG\".getBytes()).getInt();\n            fos = new FileOutputStream(logFileWrite);\n            logStream = new BufferedOutputStream(fos);\n            oa = BinaryOutputArchive.getArchive(logStream);\n            FileHeader fhdr = new FileHeader(TXNLOG_MAGIC, VERSION, dbId);\n            long dataSize = oa.getDataSize();\n            fhdr.serialize(oa, \"fileheader\");\n            // Make sure that the magic number is written before padding."}
{"magic_number_smell": "    public FileTxnSnapLog(File dataDir, File snapDir) throws IOException {\n        LOG.debug(\"Opening datadir:{} snapDir:{}\", dataDir, snapDir);\n\n        this.dataDir = new File(dataDir, version + 2);\n        this.snapDir = new File(snapDir, version + 2);\n\n        // by default create snap/log dirs, but otherwise complain instead", "refactored_code": "    public static final int VERSION = 2;\n    public FileTxnSnapLog(File dataDir, File snapDir) throws IOException {\n        LOG.debug(\"Opening datadir:{} snapDir:{}\", dataDir, snapDir);\n\n        this.dataDir = new File(dataDir, version + VERSION);\n        this.snapDir = new File(snapDir, version + VERSION);\n\n        // by default create snap/log dirs, but otherwise complain instead"}
{"magic_number_smell": "\n    static class TxnLogToolkitParseException extends TxnLogToolkitException {\n\n        private static final long 1L = 1L;\n        private Options options;\n\n        TxnLogToolkitParseException(Options options, int exitCode, String message, Object... params) {", "refactored_code": "        private static final long serialVersionUID = 1L;\n\n    static class TxnLogToolkitParseException extends TxnLogToolkitException {\n\n        private static final long serialVersionUID = 1L;\n        private Options options;\n\n        TxnLogToolkitParseException(Options options, int exitCode, String message, Object... params) {"}
{"magic_number_smell": "    /**\n     * Size of the last buffer usage.\n     */\n    private int lastBufferSize = -1;\n\n    /**\n     * Size of the smallest buffer usage.", "refactored_code": "    public static final int INIT_VALUE = -1;\n    /**\n     * Size of the last buffer usage.\n     */\n    private int lastBufferSize = INIT_VALUE;\n\n    /**\n     * Size of the smallest buffer usage."}
{"magic_number_smell": "        requestBuffer.putLong(zxid);\n        requestBuffer.putLong(electionEpoch);\n        requestBuffer.putLong(epoch);\n        requestBuffer.putInt(Notification.0x2);\n        requestBuffer.putInt(configData.length);\n        requestBuffer.put(configData);\n", "refactored_code": "        public static final int CURRENTVERSION = 0x2;\n        requestBuffer.putLong(zxid);\n        requestBuffer.putLong(electionEpoch);\n        requestBuffer.putLong(epoch);\n        requestBuffer.putInt(Notification.CURRENTVERSION);\n        requestBuffer.putInt(configData.length);\n        requestBuffer.put(configData);\n"}
{"magic_number_smell": "            return \"FOLLOWERINFO\";\n        case UPTODATE:\n            return \"UPTODATE\";\n        case 17:\n            return \"17\";\n        case ACKEPOCH:\n            return \"ACKEPOCH\";", "refactored_code": "    public static final int LEADERINFO = 17;\n            return \"FOLLOWERINFO\";\n        case UPTODATE:\n            return \"UPTODATE\";\n        case LEADERINFO:\n            return \"LEADERINFO\";\n        case ACKEPOCH:\n            return \"ACKEPOCH\";"}
{"magic_number_smell": "    protected int leaderProtocolVersion = 0x01;\n\n    private static final int 10 = 10;\n    protected final MessageTracker messageTracker = new MessageTracker(10);\n\n    protected static final Logger LOG = LoggerFactory.getLogger(Learner.class);\n", "refactored_code": "    private static final int BUFFERED_MESSAGE_SIZE = 10;\n    protected int leaderProtocolVersion = 0x01;\n\n    private static final int BUFFERED_MESSAGE_SIZE = 10;\n    protected final MessageTracker messageTracker = new MessageTracker(BUFFERED_MESSAGE_SIZE);\n\n    protected static final Logger LOG = LoggerFactory.getLogger(Learner.class);\n"}
{"magic_number_smell": "    void queuePacket(QuorumPacket p) {\n        queuedPackets.add(p);\n        // Add a MarkerQuorumPacket at regular intervals.\n        if (shouldSendMarkerPacketForLogging() && packetCounter.getAndIncrement() % 1000 == 0) {\n            queuedPackets.add(new MarkerQuorumPacket(System.nanoTime()));\n        }\n        queuedPacketsSize.addAndGet(packetSize(p));", "refactored_code": "    private final int markerPacketInterval = 1000;\n    void queuePacket(QuorumPacket p) {\n        queuedPackets.add(p);\n        // Add a MarkerQuorumPacket at regular intervals.\n        if (shouldSendMarkerPacketForLogging() && packetCounter.getAndIncrement() % markerPacketInterval == 0) {\n            queuedPackets.add(new MarkerQuorumPacket(System.nanoTime()));\n        }\n        queuedPacketsSize.addAndGet(packetSize(p));"}
{"magic_number_smell": "     * to keeping recent txns.\n     */\n    private static final int 32 * 1024 * 1024 = 32 * 1024 * 1024;\n    private static volatile int pktsSizeLimit = Integer.getInteger(\"zookeeper.observerMaster.sizeLimit\", 32 * 1024 * 1024);\n    private ConcurrentLinkedQueue<QuorumPacket> proposedPkts = new ConcurrentLinkedQueue<>();\n    private ConcurrentLinkedQueue<QuorumPacket> committedPkts = new ConcurrentLinkedQueue<>();\n    private int pktsSize = 0;", "refactored_code": "    private static final int PKTS_SIZE_LIMIT = 32 * 1024 * 1024;\n     * to keeping recent txns.\n     */\n    private static final int PKTS_SIZE_LIMIT = 32 * 1024 * 1024;\n    private static volatile int pktsSizeLimit = Integer.getInteger(\"zookeeper.observerMaster.sizeLimit\", PKTS_SIZE_LIMIT);\n    private ConcurrentLinkedQueue<QuorumPacket> proposedPkts = new ConcurrentLinkedQueue<>();\n    private ConcurrentLinkedQueue<QuorumPacket> committedPkts = new ConcurrentLinkedQueue<>();\n    private int pktsSize = 0;"}
{"magic_number_smell": "        public static InitialMessage parse(Long protocolVersion, DataInputStream din) throws InitialMessageException, IOException {\n            Long sid;\n\n            if (protocolVersion != -65536L && protocolVersion != PROTOCOL_VERSION_V2) {\n                throw new InitialMessageException(\"Got unrecognized protocol version %s\", protocolVersion);\n            }\n", "refactored_code": "    public static final long PROTOCOL_VERSION_V1 = -65536L;\n        public static InitialMessage parse(Long protocolVersion, DataInputStream din) throws InitialMessageException, IOException {\n            Long sid;\n\n            if (protocolVersion != PROTOCOL_VERSION_V1 && protocolVersion != PROTOCOL_VERSION_V2) {\n                throw new InitialMessageException(\"Got unrecognized protocol version %s\", protocolVersion);\n            }\n"}
{"magic_number_smell": "     * The maximum number of threads to allow in the connectionExecutors thread\n     * pool which will be used to initiate quorum server connections.\n     */\n    protected int quorumCnxnThreadsSize = 20;\n\n    public static final String QUORUM_CNXN_TIMEOUT_MS = \"zookeeper.quorumCnxnTimeoutMs\";\n    private static int quorumCnxnTimeoutMs;", "refactored_code": "    private static final int QUORUM_CNXN_THREADS_SIZE_DEFAULT_VALUE = 20;\n     * The maximum number of threads to allow in the connectionExecutors thread\n     * pool which will be used to initiate quorum server connections.\n     */\n    protected int quorumCnxnThreadsSize = QUORUM_CNXN_THREADS_SIZE_DEFAULT_VALUE;\n\n    public static final String QUORUM_CNXN_TIMEOUT_MS = \"zookeeper.quorumCnxnTimeoutMs\";\n    private static int quorumCnxnTimeoutMs;"}
{"magic_number_smell": "    protected int electionPort = 2182;\n    protected boolean quorumListenOnAllIPs = false;\n\n    protected long serverId = -1;\n\n    protected QuorumVerifier quorumVerifier = null, lastSeenQuorumVerifier = null;\n    protected int snapRetainCount = 3;", "refactored_code": "    private static final int UNSET_SERVERID = -1;\n    protected int electionPort = 2182;\n    protected boolean quorumListenOnAllIPs = false;\n\n    protected long serverId = UNSET_SERVERID;\n\n    protected QuorumVerifier quorumVerifier = null, lastSeenQuorumVerifier = null;\n    protected int snapRetainCount = 3;"}
{"magic_number_smell": "    }\n\n    public static QuorumAuthPacket createPacket(Status status, byte[] response) {\n        return new QuorumAuthPacket(-0xa0dbcafecafe1234L, status.status(), response);\n    }\n\n    public static boolean nextPacketIsAuth(DataInputStream din) throws IOException {", "refactored_code": "    public static final long QUORUM_AUTH_MAGIC_NUMBER = -0xa0dbcafecafe1234L;\n    }\n\n    public static QuorumAuthPacket createPacket(Status status, byte[] response) {\n        return new QuorumAuthPacket(QUORUM_AUTH_MAGIC_NUMBER, status.status(), response);\n    }\n\n    public static boolean nextPacketIsAuth(DataInputStream din) throws IOException {"}
{"magic_number_smell": "                challenge = ss.evaluateResponse(token);\n                if (!ss.isComplete()) {\n                    // limited number of retries.\n                    if (++tries > 5) {\n                        send(dout, challenge, QuorumAuth.Status.ERROR);\n                        LOG.warn(\n                            \"Failed to authenticate using SASL, server addr: {}, retries={} exceeded.\",", "refactored_code": "    private static final int MAX_RETRIES = 5;\n                challenge = ss.evaluateResponse(token);\n                if (!ss.isComplete()) {\n                    // limited number of retries.\n                    if (++tries > MAX_RETRIES) {\n                        send(dout, challenge, QuorumAuth.Status.ERROR);\n                        LOG.warn(\n                            \"Failed to authenticate using SASL, server addr: {}, retries={} exceeded.\","}
{"magic_number_smell": "        System.setProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET,\n                FragileClientCnxnSocketNIO.class.getName());\n        System.setProperty(ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT, \"1000\");\n        final int[] clientPorts = new int[3];\n        StringBuilder sb = new StringBuilder();\n        String server;\n", "refactored_code": "    private static final int SERVER_COUNT = 3;\n        System.setProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET,\n                FragileClientCnxnSocketNIO.class.getName());\n        System.setProperty(ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT, \"1000\");\n        final int[] clientPorts = new int[SERVER_COUNT];\n        StringBuilder sb = new StringBuilder();\n        String server;\n"}
{"magic_number_smell": "    public void testClientRequestTimeout() throws Exception {\n        int requestTimeOut = 15000;\n        System.setProperty(\"zookeeper.request.timeout\", Integer.toString(requestTimeOut));\n        final int[] clientPorts = new int[3];\n        StringBuilder sb = new StringBuilder();\n        String server;\n", "refactored_code": "    private static final int SERVER_COUNT = 3;\n    public void testClientRequestTimeout() throws Exception {\n        int requestTimeOut = 15000;\n        System.setProperty(\"zookeeper.request.timeout\", Integer.toString(requestTimeOut));\n        final int[] clientPorts = new int[SERVER_COUNT];\n        StringBuilder sb = new StringBuilder();\n        String server;\n"}
{"magic_number_smell": "        super.setUp();\n\n        zk = createClient();\n        generatePaths(2, EPHEMERAL_CNT);\n    }\n\n    @AfterEach", "refactored_code": "    private static final int PERSISTENT_CNT = 2;\n        super.setUp();\n\n        zk = createClient();\n        generatePaths(PERSISTENT_CNT, EPHEMERAL_CNT);\n    }\n\n    @AfterEach"}
{"magic_number_smell": "        super.setUp();\n\n        zk = createClient();\n        expected = generatePaths(2, EPHEMERAL_CNT);\n    }\n\n    @AfterEach", "refactored_code": "    private static final int PERSISTENT_CNT = 2;\n        super.setUp();\n\n        zk = createClient();\n        expected = generatePaths(PERSISTENT_CNT, EPHEMERAL_CNT);\n    }\n\n    @AfterEach"}
{"magic_number_smell": "            // Use these values to calculate the valid range for port assignments\n            // within this test process.  We lose a few possible ports to the\n            // remainder, but that's acceptable.\n            int portRangeSize = (GLOBAL_MAX_PORT - 11221) / processCount;\n            int minPort = 11221 + ((threadId - 1) * portRangeSize);\n            int maxPort = minPort + portRangeSize - 1;\n            newPortRange = new PortRange(minPort, maxPort);", "refactored_code": "    private static final int GLOBAL_BASE_PORT = 11221;\n            // Use these values to calculate the valid range for port assignments\n            // within this test process.  We lose a few possible ports to the\n            // remainder, but that's acceptable.\n            int portRangeSize = (GLOBAL_MAX_PORT - GLOBAL_BASE_PORT) / processCount;\n            int minPort = GLOBAL_BASE_PORT + ((threadId - 1) * portRangeSize);\n            int maxPort = minPort + portRangeSize - 1;\n            newPortRange = new PortRange(minPort, maxPort);"}
{"magic_number_smell": "    }\n\n    public static <T> void waitForMetric(String metricKey, Matcher<T> matcher) throws InterruptedException {\n        waitForMetric(metricKey, matcher, 30);\n    }\n\n    public static <T> void waitForMetric(String metricKey, Matcher<T> matcher, int timeoutInSeconds) throws InterruptedException {", "refactored_code": "    public static final int DEFAULT_METRIC_TIMEOUT = 30;\n    }\n\n    public static <T> void waitForMetric(String metricKey, Matcher<T> matcher) throws InterruptedException {\n        waitForMetric(metricKey, matcher, DEFAULT_METRIC_TIMEOUT);\n    }\n\n    public static <T> void waitForMetric(String metricKey, Matcher<T> matcher, int timeoutInSeconds) throws InterruptedException {"}
{"magic_number_smell": "                FileUtils.writeStringToFile(tempFile, \"Hello world \" + i + \"\\n\", StandardCharsets.UTF_8, true);\n                synchronized (events) {\n                    if (events.size() < i + 1) {\n                        events.wait(30000L);\n                    }\n                    assertEquals(i + 1, events.size(), \"Wrong number of events\");\n                    WatchEvent<?> event = events.get(i);", "refactored_code": "    private static final long FS_TIMEOUT = 30000L;\n                FileUtils.writeStringToFile(tempFile, \"Hello world \" + i + \"\\n\", StandardCharsets.UTF_8, true);\n                synchronized (events) {\n                    if (events.size() < i + 1) {\n                        events.wait(FS_TIMEOUT);\n                    }\n                    assertEquals(i + 1, events.size(), \"Wrong number of events\");\n                    WatchEvent<?> event = events.get(i);"}
{"magic_number_smell": "    }\n\n    private static long discrepancy() {\n        return (System.currentTimeMillis() - System.currentTimeMillis()) - (Time.currentElapsedTime() - nt0);\n    }\n\n    @Test", "refactored_code": "    private static final long mt0 = System.currentTimeMillis();\n    }\n\n    private static long discrepancy() {\n        return (System.currentTimeMillis() - mt0) - (Time.currentElapsedTime() - nt0);\n    }\n\n    @Test"}
{"magic_number_smell": "        public Builder() {\n            trustStoreKeyType = X509KeyType.EC;\n            trustStorePassword = \"\";\n            trustStoreCertExpirationMillis = 1000L * 60 * 60 * 24;\n            keyStoreKeyType = X509KeyType.EC;\n            keyStorePassword = \"\";\n            keyStoreCertExpirationMillis = 1000L * 60 * 60 * 24;", "refactored_code": "        public static final long DEFAULT_CERT_EXPIRATION_MILLIS = 1000L * 60 * 60 * 24; // 1 day\n        public Builder() {\n            trustStoreKeyType = X509KeyType.EC;\n            trustStorePassword = \"\";\n            trustStoreCertExpirationMillis = DEFAULT_CERT_EXPIRATION_MILLIS;\n            keyStoreKeyType = X509KeyType.EC;\n            keyStorePassword = \"\";\n            keyStoreCertExpirationMillis = DEFAULT_CERT_EXPIRATION_MILLIS;"}
{"magic_number_smell": "     */\n    public static KeyPair generateRSAKeyPair() throws GeneralSecurityException {\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n        RSAKeyGenParameterSpec keyGenSpec = new RSAKeyGenParameterSpec(2048, DEFAULT_RSA_PUB_EXPONENT);\n        keyGen.initialize(keyGenSpec, PRNG);\n        return keyGen.generateKeyPair();\n    }", "refactored_code": "    private static final int DEFAULT_RSA_KEY_SIZE_BITS = 2048;\n     */\n    public static KeyPair generateRSAKeyPair() throws GeneralSecurityException {\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n        RSAKeyGenParameterSpec keyGenSpec = new RSAKeyGenParameterSpec(DEFAULT_RSA_KEY_SIZE_BITS, DEFAULT_RSA_PUB_EXPONENT);\n        keyGen.initialize(keyGenSpec, PRNG);\n        return keyGen.generateKeyPair();\n    }"}
{"magic_number_smell": "            watchers[i] = new ClientBase.CountdownWatcher();\n            zks[i] = new ZooKeeper(connStr, 3000, watchers[i]);\n            try {\n                watchers[i].waitForConnected(10000);\n                connected++;\n            } catch (TimeoutException e) {\n                LOG.info(\"Connection denied by the throttler due to insufficient tokens\");", "refactored_code": "    private static final int RAPID_TIMEOUT = 10000;\n            watchers[i] = new ClientBase.CountdownWatcher();\n            zks[i] = new ZooKeeper(connStr, 3000, watchers[i]);\n            try {\n                watchers[i].waitForConnected(RAPID_TIMEOUT);\n                connected++;\n            } catch (TimeoutException e) {\n                LOG.info(\"Connection denied by the throttler due to insufficient tokens\");"}
{"magic_number_smell": "\n        servcnxnf = ServerCnxnFactory.createFactory(PORT, -1);\n        servcnxnf.startup(zks);\n        assertTrue(ClientBase.waitForServerUp(HOSTPORT, 3000), \"waiting for server being up \");\n        zks.sessionTracker = new MySessionTracker();\n\n        isReconfigEnabledPreviously = QuorumPeerConfig.isReconfigEnabled();", "refactored_code": "    private static final int CONNECTION_TIMEOUT = 3000;\n\n        servcnxnf = ServerCnxnFactory.createFactory(PORT, -1);\n        servcnxnf.startup(zks);\n        assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up \");\n        zks.sessionTracker = new MySessionTracker();\n\n        isReconfigEnabledPreviously = QuorumPeerConfig.isReconfigEnabled();"}
{"magic_number_smell": "        final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n        ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n        f.startup(zks);\n        assertTrue(ClientBase.waitForServerUp(HOSTPORT, 3000), \"waiting for server being up \");\n        ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);\n        try {\n            for (int i = 0; i < 2000; i++) {", "refactored_code": "    private static final int CONNECTION_TIMEOUT = 3000;\n        final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n        ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n        f.startup(zks);\n        assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up \");\n        ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);\n        try {\n            for (int i = 0; i < 2000; i++) {"}
{"magic_number_smell": "\n        // no requests can go through the pipeline unless we raise the latch\n        resumeProcess = new CountDownLatch(1);\n        submitted = new CountDownLatch(5);\n        entered = new CountDownLatch(5);\n\n        // send 5 requests asynchronously", "refactored_code": "    private static final int TOTAL_REQUESTS = 5;\n\n        // no requests can go through the pipeline unless we raise the latch\n        resumeProcess = new CountDownLatch(1);\n        submitted = new CountDownLatch(TOTAL_REQUESTS);\n        entered = new CountDownLatch(TOTAL_REQUESTS);\n\n        // send 5 requests asynchronously"}
{"magic_number_smell": "        final AvgMinMaxCounter metric = new AvgMinMaxCounter(\"test\");\n        testAvgMinMaxCounter(metric, 0);\n        testAvgMinMaxCounter(metric, 1);\n        for (int i = 0; i < 100; ++i) {\n            testAvgMinMaxCounter(metric, RANDOM_SIZE);\n        }\n    }", "refactored_code": "    private static final int RANDOM_TRIALS = 100;\n        final AvgMinMaxCounter metric = new AvgMinMaxCounter(\"test\");\n        testAvgMinMaxCounter(metric, 0);\n        testAvgMinMaxCounter(metric, 1);\n        for (int i = 0; i < RANDOM_TRIALS; ++i) {\n            testAvgMinMaxCounter(metric, RANDOM_SIZE);\n        }\n    }"}
{"magic_number_smell": "        ZooKeeperServer zks = setupSessionTracker();\n\n        latch = new CountDownLatch(1);\n        zks.sessionTracker.trackSession(339900, sessionTimeout);\n        SessionTrackerImpl sessionTrackerImpl = (SessionTrackerImpl) zks.sessionTracker;\n        SessionImpl sessionImpl = sessionTrackerImpl.sessionsById.get(339900);\n        assertNotNull(sessionImpl, \"Sessionid:\" + 339900 + \" doesn't exists in sessiontracker\");", "refactored_code": "    private final long sessionId = 339900;\n        ZooKeeperServer zks = setupSessionTracker();\n\n        latch = new CountDownLatch(1);\n        zks.sessionTracker.trackSession(sessionId, sessionTimeout);\n        SessionTrackerImpl sessionTrackerImpl = (SessionTrackerImpl) zks.sessionTracker;\n        SessionImpl sessionImpl = sessionTrackerImpl.sessionsById.get(sessionId);\n        assertNotNull(sessionImpl, \"Sessionid:\" + sessionId + \" doesn't exists in sessiontracker\");"}
{"magic_number_smell": "\n    private ZooKeeper createZKClnt(String cxnString) throws Exception {\n        ClientBase.CountdownWatcher watcher = new ClientBase.CountdownWatcher();\n        ZooKeeper zk = new ZooKeeper(cxnString, 5000, watcher);\n        watcher.waitForConnected(CONNECTION_TIMEOUT);\n        return zk;\n    }", "refactored_code": "    public static final int TIMEOUT = 5000;\n\n    private ZooKeeper createZKClnt(String cxnString) throws Exception {\n        ClientBase.CountdownWatcher watcher = new ClientBase.CountdownWatcher();\n        ZooKeeper zk = new ZooKeeper(cxnString, TIMEOUT, watcher);\n        watcher.waitForConnected(CONNECTION_TIMEOUT);\n        return zk;\n    }"}
{"magic_number_smell": "\n            // zk1 create test data\n            zk1 = ClientBase.createZKClient(HOST_PORT);\n            for (int i = 0; i < 10; i++) {\n                final String path = BASE_PATH + \"-\" + i;\n                zk1.create(path, String.valueOf(i).getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n            }", "refactored_code": "    private static final int NODE_COUNT = 10;\n\n            // zk1 create test data\n            zk1 = ClientBase.createZKClient(HOST_PORT);\n            for (int i = 0; i < NODE_COUNT; i++) {\n                final String path = BASE_PATH + \"-\" + i;\n                zk1.create(path, String.valueOf(i).getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n            }"}
{"magic_number_smell": "            assertTrue(ClientBase.waitForServerUp(HOST_PORT, CONNECTION_TIMEOUT));\n\n            zk = ClientBase.createZKClient(HOST_PORT);\n            for (int i = 0; i < 10; i++) {\n                final String path = BASE_PATH + \"-\" + i;\n                zk.create(path, String.valueOf(i).getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n            }", "refactored_code": "    private static final int NODE_COUNT = 10;\n            assertTrue(ClientBase.waitForServerUp(HOST_PORT, CONNECTION_TIMEOUT));\n\n            zk = ClientBase.createZKClient(HOST_PORT);\n            for (int i = 0; i < NODE_COUNT; i++) {\n                final String path = BASE_PATH + \"-\" + i;\n                zk.create(path, String.valueOf(i).getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n            }"}
{"magic_number_smell": "\n        // start AdminServer\n        System.setProperty(\"zookeeper.admin.enableServer\", \"true\");\n        System.setProperty(\"zookeeper.admin.serverPort\", String.valueOf(PortAssignment.unique()));\n        adminServer = new JettyAdminServer();\n        adminServer.setZooKeeperServer(zks);\n        adminServer.start();", "refactored_code": "    private final int jettyAdminPort = PortAssignment.unique();\n\n        // start AdminServer\n        System.setProperty(\"zookeeper.admin.enableServer\", \"true\");\n        System.setProperty(\"zookeeper.admin.serverPort\", String.valueOf(jettyAdminPort));\n        adminServer = new JettyAdminServer();\n        adminServer.setZooKeeperServer(zks);\n        adminServer.start();"}
{"magic_number_smell": "    public void enableServer() {\n        // Override setting in ZKTestCase\n        System.setProperty(\"zookeeper.admin.enableServer\", \"true\");\n        System.setProperty(\"zookeeper.admin.serverPort\", \"\" + PortAssignment.unique());\n    }\n\n    @BeforeEach", "refactored_code": "    private final int jettyAdminPort = PortAssignment.unique();\n    public void enableServer() {\n        // Override setting in ZKTestCase\n        System.setProperty(\"zookeeper.admin.enableServer\", \"true\");\n        System.setProperty(\"zookeeper.admin.serverPort\", \"\" + jettyAdminPort);\n    }\n\n    @BeforeEach"}
{"magic_number_smell": "        addAuthInfoForDigest(zk);\n\n        // create test data\n        createData(zk, SNAPSHOT_TEST_PATH, 10);\n    }\n\n    @AfterAll", "refactored_code": "    private static final int NODE_COUNT = 10;\n        addAuthInfoForDigest(zk);\n\n        // create test data\n        createData(zk, SNAPSHOT_TEST_PATH, NODE_COUNT);\n    }\n\n    @AfterAll"}
{"magic_number_smell": "        FileWriter writer = new FileWriter(configFile);\n        writer.write(\"dataDir=somewhere\\n\");\n        writer.write(\"ignore=me\\n\");\n        writer.write(\"tickTime=\" + 1234 + \"\\n\");\n        writer.write(\"controllerPort=\" + portNumber + \"\\n\");\n        writer.write(\"clientPort=\" + portNumber + \"\\n\");\n        writer.flush();", "refactored_code": "    private static final int AnyTickTime = 1234;\n        FileWriter writer = new FileWriter(configFile);\n        writer.write(\"dataDir=somewhere\\n\");\n        writer.write(\"ignore=me\\n\");\n        writer.write(\"tickTime=\" + AnyTickTime + \"\\n\");\n        writer.write(\"controllerPort=\" + portNumber + \"\\n\");\n        writer.write(\"clientPort=\" + portNumber + \"\\n\");\n        writer.flush();"}
{"magic_number_smell": "        }\n\n        public void waitForEvent() throws InterruptedException, TimeoutException {\n            waitForEvent(10000);\n        }\n\n        public void waitForEvent(int waitDurationInMs) throws InterruptedException, TimeoutException {", "refactored_code": "        private final int DEFAULT_WAIT_DURATION = 10000;\n        }\n\n        public void waitForEvent() throws InterruptedException, TimeoutException {\n            waitForEvent(DEFAULT_WAIT_DURATION);\n        }\n\n        public void waitForEvent(int waitDurationInMs) throws InterruptedException, TimeoutException {"}
{"magic_number_smell": "\n    @Test\n    public void testInvalidPreallocSize() {\n        assertEquals(10 * 1024, FilePadding.calculateFileSizeWithPadding(7 * 1024, 10 * 1024, 0),\n                \"file should not be padded\");\n        assertEquals(10 * 1024, FilePadding.calculateFileSizeWithPadding(7 * 1024, 10 * 1024, -1),\n                \"file should not be padded\");", "refactored_code": "    private static final int KB = 1024;\n\n    @Test\n    public void testInvalidPreallocSize() {\n        assertEquals(10 * KB, FilePadding.calculateFileSizeWithPadding(7 * KB, 10 * KB, 0),\n                \"file should not be padded\");\n        assertEquals(10 * KB, FilePadding.calculateFileSizeWithPadding(7 * KB, 10 * KB, -1),\n                \"file should not be padded\");"}
{"magic_number_smell": "\n                Message m = null;\n                int numRetries = 1;\n                while ((m == null) && (numRetries++ <= 4)) {\n                    m = cnxManager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);\n                    if (m == null) {\n                        cnxManager.connectAll();", "refactored_code": "    protected static final int THRESHOLD = 4;\n\n                Message m = null;\n                int numRetries = 1;\n                while ((m == null) && (numRetries++ <= THRESHOLD)) {\n                    m = cnxManager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);\n                    if (m == null) {\n                        cnxManager.connectAll();"}
{"magic_number_smell": "\n    @BeforeEach\n    public void start() throws Exception {\n        clientPorts = new int[3];\n        mt = startQuorum(clientPorts);\n        zkClients = new ZooKeeper[3];\n    }", "refactored_code": "    private static final int SERVER_COUNT = 3;\n\n    @BeforeEach\n    public void start() throws Exception {\n        clientPorts = new int[SERVER_COUNT];\n        mt = startQuorum(clientPorts);\n        zkClients = new ZooKeeper[SERVER_COUNT];\n    }"}
{"magic_number_smell": "\n        /*\n         * Start mock server 1, send a message with an invalid configLength field\n         * (instead of sending CONFIG_BYTES.length, we send 10000)\n         */\n        startMockServer(1);\n        byte requestBytes[] = new byte[48 + CONFIG_BYTES.length];", "refactored_code": "    private static final int CONFIG_BYTES_LENGTH = CONFIG_BYTES.length;\n\n        /*\n         * Start mock server 1, send a message with an invalid configLength field\n         * (instead of sending CONFIG_BYTES_LENGTH, we send 10000)\n         */\n        startMockServer(1);\n        byte requestBytes[] = new byte[48 + CONFIG_BYTES_LENGTH];"}
{"magic_number_smell": "public class LearnerMetricsTest extends QuorumPeerTestBase {\n\n    private static final int 4 = 4; // 1 observer, 3 participants\n    private final QuorumPeerTestBase.MainThread[] mt = new QuorumPeerTestBase.MainThread[4];\n    private ZooKeeper zk_client;\n    private static boolean bakAsyncSending;\n", "refactored_code": "    private static final int SERVER_COUNT = 4; // 1 observer, 3 participants\npublic class LearnerMetricsTest extends QuorumPeerTestBase {\n\n    private static final int SERVER_COUNT = 4; // 1 observer, 3 participants\n    private final QuorumPeerTestBase.MainThread[] mt = new QuorumPeerTestBase.MainThread[SERVER_COUNT];\n    private ZooKeeper zk_client;\n    private static boolean bakAsyncSending;\n"}
{"magic_number_smell": "        List<InetSocketAddress> addresses = getAddressList();\n        MultipleAddresses multipleAddresses = new MultipleAddresses(addresses);\n\n        assertEquals(10, multipleAddresses.size());\n    }\n\n    public List<Integer> getPortList() {", "refactored_code": "    public static final int PORTS_AMOUNT = 10;\n        List<InetSocketAddress> addresses = getAddressList();\n        MultipleAddresses multipleAddresses = new MultipleAddresses(addresses);\n\n        assertEquals(PORTS_AMOUNT, multipleAddresses.size());\n    }\n\n    public List<Integer> getPortList() {"}
{"magic_number_smell": "    // we have three ZK servers, each server has two quorumPort and two electionPort registered\n    // in the config we misconfigure one of the addresses for each servers\n    QuorumServerConfigBuilder quorumConfig = new QuorumServerConfigBuilder(hostName, 3, 2)\n      .changeHostName(0, SECOND_ADDRESS, UNREACHABLE_HOST)\n      .changeHostName(SECOND_SERVER, SECOND_ADDRESS, UNREACHABLE_HOST)\n      .changeHostName(THIRD_SERVER, SECOND_ADDRESS, UNREACHABLE_HOST);\n", "refactored_code": "  private static final int FIRST_SERVER = 0;\n    // we have three ZK servers, each server has two quorumPort and two electionPort registered\n    // in the config we misconfigure one of the addresses for each servers\n    QuorumServerConfigBuilder quorumConfig = new QuorumServerConfigBuilder(hostName, 3, 2)\n      .changeHostName(FIRST_SERVER, SECOND_ADDRESS, UNREACHABLE_HOST)\n      .changeHostName(SECOND_SERVER, SECOND_ADDRESS, UNREACHABLE_HOST)\n      .changeHostName(THIRD_SERVER, SECOND_ADDRESS, UNREACHABLE_HOST);\n"}
{"magic_number_smell": "     */\n    @Test\n    public void testConfigFileBackwardCompatibility() throws Exception {\n        final int[] clientPorts = new int[3];\n        StringBuilder sb = new StringBuilder();\n        String server;\n        ArrayList<String> allServers = new ArrayList<>();", "refactored_code": "    private static final int SERVER_COUNT = 3;\n     */\n    @Test\n    public void testConfigFileBackwardCompatibility() throws Exception {\n        final int[] clientPorts = new int[SERVER_COUNT];\n        StringBuilder sb = new StringBuilder();\n        String server;\n        ArrayList<String> allServers = new ArrayList<>();"}
{"magic_number_smell": "        }\n\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT), \"waiting for server \" + i + \" being up\");\n        }\n    }\n", "refactored_code": "    public static final int CONNECTION_TIMEOUT = ClientBase.CONNECTION_TIMEOUT;\n        }\n\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + clientPorts[i], CONNECTION_TIMEOUT), \"waiting for server \" + i + \" being up\");\n        }\n    }\n"}
{"magic_number_smell": "        ClientBase.setupTestEnv();\n        QuorumPeerConfig.setStandaloneEnabled(false);\n        QuorumPeerConfig.setReconfigEnabled(true);\n        peers = new MainThread[5];\n        zkHandles = new ZooKeeper[5];\n        zkAdminHandles = new ZooKeeperAdmin[5];\n        clientPorts = new int[5];", "refactored_code": "    private final int NUM_SERVERS = 5;\n        ClientBase.setupTestEnv();\n        QuorumPeerConfig.setStandaloneEnabled(false);\n        QuorumPeerConfig.setReconfigEnabled(true);\n        peers = new MainThread[NUM_SERVERS];\n        zkHandles = new ZooKeeper[NUM_SERVERS];\n        zkAdminHandles = new ZooKeeperAdmin[NUM_SERVERS];\n        clientPorts = new int[NUM_SERVERS];"}
{"magic_number_smell": "    private SSLSocket connectWithSSL() throws IOException, X509Exception, InterruptedException {\n        SSLSocket sslSocket = null;\n        int retries = 0;\n        while (retries < 5) {\n            try {\n                sslSocket = x509Util.createSSLSocket();\n                sslSocket.addHandshakeCompletedListener(new HandshakeCompletedListener() {", "refactored_code": "    private static final int MAX_RETRIES = 5;\n    private SSLSocket connectWithSSL() throws IOException, X509Exception, InterruptedException {\n        SSLSocket sslSocket = null;\n        int retries = 0;\n        while (retries < MAX_RETRIES) {\n            try {\n                sslSocket = x509Util.createSSLSocket();\n                sslSocket.addHandshakeCompletedListener(new HandshakeCompletedListener() {"}
{"magic_number_smell": "     * @return a serialized connection request\n     */\n    private ByteBuffer createConnRequest() {\n        Random r = new Random(SESSION_ID ^ 0XB3415C00L);\n        byte[] p = new byte[16];\n        r.nextBytes(p);\n        ConnectRequest conReq = new ConnectRequest(0, 1L, 30000, SESSION_ID, p, false);", "refactored_code": "    private static final long superSecret = 0XB3415C00L;\n     * @return a serialized connection request\n     */\n    private ByteBuffer createConnRequest() {\n        Random r = new Random(SESSION_ID ^ superSecret);\n        byte[] p = new byte[16];\n        r.nextBytes(p);\n        ConnectRequest conReq = new ConnectRequest(0, 1L, 30000, SESSION_ID, p, false);"}
{"magic_number_smell": "    public static QuorumPeer createQuorumPeer(File tmpDir) throws IOException {\n        HashMap<Long, QuorumPeer.QuorumServer> peers = new HashMap<>();\n        QuorumPeer peer = QuorumPeer.testingQuorumPeer();\n        peer.syncLimit = 2;\n        peer.initLimit = 2;\n        peer.tickTime = 2000;\n", "refactored_code": "    public static final int SYNC_LIMIT = 2;\n    public static QuorumPeer createQuorumPeer(File tmpDir) throws IOException {\n        HashMap<Long, QuorumPeer.QuorumServer> peers = new HashMap<>();\n        QuorumPeer peer = QuorumPeer.testingQuorumPeer();\n        peer.syncLimit = SYNC_LIMIT;\n        peer.initLimit = 2;\n        peer.tickTime = 2000;\n"}
{"magic_number_smell": "    @Test\n    public void testTrackSend() throws InterruptedException {\n        long timestamp1 = System.currentTimeMillis();\n        MessageTracker messageTracker = new MessageTracker(5);\n\n        // First timestamp is added\n        messageTracker.trackSent(timestamp1);", "refactored_code": "    private static final int BUFFERED_MESSAGE_SIZE = 5;\n    @Test\n    public void testTrackSend() throws InterruptedException {\n        long timestamp1 = System.currentTimeMillis();\n        MessageTracker messageTracker = new MessageTracker(BUFFERED_MESSAGE_SIZE);\n\n        // First timestamp is added\n        messageTracker.trackSent(timestamp1);"}
{"magic_number_smell": "    @Test\n    public void testRecursiveQtyConcurrency() throws Exception {\n        WatchManager manager = new WatchManager();\n        ExecutorService threadPool = Executors.newFixedThreadPool(25);\n        List<Future<?>> tasks = null;\n        CountDownLatch completedLatch = new CountDownLatch(25);\n        try {", "refactored_code": "    private static final int clientQty = 25;\n    @Test\n    public void testRecursiveQtyConcurrency() throws Exception {\n        WatchManager manager = new WatchManager();\n        ExecutorService threadPool = Executors.newFixedThreadPool(clientQty);\n        List<Future<?>> tasks = null;\n        CountDownLatch completedLatch = new CountDownLatch(clientQty);\n        try {"}
{"magic_number_smell": "\n        private synchronized void incOutstanding() throws InterruptedException {\n            outstanding++;\n            while (outstanding > 30) {\n                wait();\n            }\n        }", "refactored_code": "        private static final int MAX_OUTSTANDING = 30;\n\n        private synchronized void incOutstanding() throws InterruptedException {\n            outstanding++;\n            while (outstanding > MAX_OUTSTANDING) {\n                wait();\n            }\n        }"}
{"magic_number_smell": "\n    @BeforeEach\n    public void setMaxBuffer() throws IOException, InterruptedException {\n        System.setProperty(\"jute.maxbuffer\", \"\" + 100);\n        assertEquals(100, BinaryInputArchive.maxBuffer, \"Can't set jute.maxbuffer!\");\n        zk = createClient();\n    }", "refactored_code": "    public static final int TEST_MAXBUFFER = 100;\n\n    @BeforeEach\n    public void setMaxBuffer() throws IOException, InterruptedException {\n        System.setProperty(\"jute.maxbuffer\", \"\" + TEST_MAXBUFFER);\n        assertEquals(TEST_MAXBUFFER, BinaryInputArchive.maxBuffer, \"Can't set jute.maxbuffer!\");\n        zk = createClient();\n    }"}
{"magic_number_smell": "            try {\n                for (; current < count; current++) {\n                    // Simulate a bit of network latency...\n                    Thread.sleep(5);\n                    zk.create(prefix + current, b, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n                }\n            } catch (Throwable t) {", "refactored_code": "    private static final long HAMMERTHREAD_LATENCY = 5;\n            try {\n                for (; current < count; current++) {\n                    // Simulate a bit of network latency...\n                    Thread.sleep(HAMMERTHREAD_LATENCY);\n                    zk.create(prefix + current, b, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n                }\n            } catch (Throwable t) {"}
{"magic_number_smell": "        String servers = \"10.10.10.1,10.10.10.2\";\n        ConnectStringParser parser = new ConnectStringParser(servers);\n        assertEquals(\"10.10.10.1\", parser.getServerAddresses().get(0).getHostString());\n        assertEquals(2181, parser.getServerAddresses().get(0).getPort());\n        assertEquals(\"10.10.10.2\", parser.getServerAddresses().get(1).getHostString());\n        assertEquals(2181, parser.getServerAddresses().get(1).getPort());\n", "refactored_code": "    private static final int DEFAULT_PORT = 2181;\n        String servers = \"10.10.10.1,10.10.10.2\";\n        ConnectStringParser parser = new ConnectStringParser(servers);\n        assertEquals(\"10.10.10.1\", parser.getServerAddresses().get(0).getHostString());\n        assertEquals(DEFAULT_PORT, parser.getServerAddresses().get(0).getPort());\n        assertEquals(\"10.10.10.2\", parser.getServerAddresses().get(1).getHostString());\n        assertEquals(DEFAULT_PORT, parser.getServerAddresses().get(1).getPort());\n"}
{"magic_number_smell": "        String[] hostPorts = qb.hostPort.split(\",\");\n\n        CountdownWatcher watcher = new CountdownWatcher();\n        ZooKeeper zk = qb.createClient(watcher, hostPorts[testPeerIdx], ClientBase.CONNECTION_TIMEOUT);\n        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n\n        final String firstPath = \"/first\";", "refactored_code": "    private static final int CONNECTION_TIMEOUT = ClientBase.CONNECTION_TIMEOUT;\n        String[] hostPorts = qb.hostPort.split(\",\");\n\n        CountdownWatcher watcher = new CountdownWatcher();\n        ZooKeeper zk = qb.createClient(watcher, hostPorts[testPeerIdx], CONNECTION_TIMEOUT);\n        watcher.waitForConnected(CONNECTION_TIMEOUT);\n\n        final String firstPath = \"/first\";"}
{"magic_number_smell": "        final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n        ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n        f.startup(zks);\n        assertTrue(ClientBase.waitForServerUp(HOSTPORT, 3000), \"waiting for server being up \");\n        ZooKeeper zk = new ZooKeeper(HOSTPORT, 3000, this);\n        try {\n            for (int i = 0; i < N_TRANSACTIONS; i++) {", "refactored_code": "    private static final int CONNECTION_TIMEOUT = 3000;\n        final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n        ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n        f.startup(zks);\n        assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up \");\n        ZooKeeper zk = new ZooKeeper(HOSTPORT, CONNECTION_TIMEOUT, this);\n        try {\n            for (int i = 0; i < N_TRANSACTIONS; i++) {"}
{"magic_number_smell": "         */\n        boolean waitForQuorum(long id) throws InterruptedException {\n            int loopCounter = 0;\n            while ((quora.get(id).size() <= count / 2) && (loopCounter < 300)) {\n                Thread.sleep(100);\n                loopCounter++;\n            }", "refactored_code": "    private final int MAX_LOOP_COUNTER = 300;\n         */\n        boolean waitForQuorum(long id) throws InterruptedException {\n            int loopCounter = 0;\n            while ((quora.get(id).size() <= count / 2) && (loopCounter < MAX_LOOP_COUNTER)) {\n                Thread.sleep(100);\n                loopCounter++;\n            }"}
{"magic_number_smell": "\n        qu.start(1);\n        qu.start(2);\n        assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + qu.getPeer(1).clientPort, ClientBase.ClientTest.CONNECTION_TIMEOUT),\n                \"Waiting for server up\");\n        assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + qu.getPeer(2).clientPort, ClientBase.ClientTest.CONNECTION_TIMEOUT),\n                \"Waiting for server up\");", "refactored_code": "    public static final long CONNECTION_TIMEOUT = ClientTest.CONNECTION_TIMEOUT;\n\n        qu.start(1);\n        qu.start(2);\n        assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + qu.getPeer(1).clientPort, ClientBase.CONNECTION_TIMEOUT),\n                \"Waiting for server up\");\n        assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + qu.getPeer(2).clientPort, ClientBase.CONNECTION_TIMEOUT),\n                \"Waiting for server up\");"}
{"magic_number_smell": "        final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n        ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n        f.startup(zks);\n        assertTrue(ClientBase.waitForServerUp(HOSTPORT, 3000), \"waiting for server being up \");\n        ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);\n\n        // Generate transaction so we will have some txnlog", "refactored_code": "    private static final int CONNECTION_TIMEOUT = 3000;\n        final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n        ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n        f.startup(zks);\n        assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up \");\n        ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);\n\n        // Generate transaction so we will have some txnlog"}
{"magic_number_smell": "\n    // setting up the quorum has a transaction overhead for creating and closing the session\n    private static final int TRANSACTION_OVERHEAD = 2;\n    private static final int TOTAL_TRANSACTIONS = 300 + TRANSACTION_OVERHEAD;\n\n    @BeforeEach\n    public void setUp() throws Exception {", "refactored_code": "    private static final int NUM_MESSAGES = 300;\n\n    // setting up the quorum has a transaction overhead for creating and closing the session\n    private static final int TRANSACTION_OVERHEAD = 2;\n    private static final int TOTAL_TRANSACTIONS = NUM_MESSAGES + TRANSACTION_OVERHEAD;\n\n    @BeforeEach\n    public void setUp() throws Exception {"}
{"magic_number_smell": "        String[] hostPorts = qb.hostPort.split(\",\");\n\n        CountdownWatcher watcher = new CountdownWatcher();\n        DisconnectableZooKeeper client = new DisconnectableZooKeeper(hostPorts[testPeerIdx], 4000, watcher);\n        watcher.waitForConnected(4000);\n\n        long localSessionId1 = client.getSessionId();", "refactored_code": "    public static final int CONNECTION_TIMEOUT = 4000;\n        String[] hostPorts = qb.hostPort.split(\",\");\n\n        CountdownWatcher watcher = new CountdownWatcher();\n        DisconnectableZooKeeper client = new DisconnectableZooKeeper(hostPorts[testPeerIdx], CONNECTION_TIMEOUT, watcher);\n        watcher.waitForConnected(CONNECTION_TIMEOUT);\n\n        long localSessionId1 = client.getSessionId();"}
{"magic_number_smell": "        String[] hostPorts = qb.hostPort.split(\",\");\n\n        CountdownWatcher watcher = new CountdownWatcher();\n        ZooKeeper zk = qb.createClient(watcher, hostPorts[testPeerIdx], ClientBase.CONNECTION_TIMEOUT);\n        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n\n        long localSessionId = zk.getSessionId();", "refactored_code": "    public static final int CONNECTION_TIMEOUT = ClientBase.CONNECTION_TIMEOUT;\n        String[] hostPorts = qb.hostPort.split(\",\");\n\n        CountdownWatcher watcher = new CountdownWatcher();\n        ZooKeeper zk = qb.createClient(watcher, hostPorts[testPeerIdx], CONNECTION_TIMEOUT);\n        watcher.waitForConnected(CONNECTION_TIMEOUT);\n\n        long localSessionId = zk.getSessionId();"}
{"magic_number_smell": "    @BeforeEach\n    @Override\n    public void setUp() throws Exception {\n        maxCnxns = 30;\n        super.setUp();\n    }\n", "refactored_code": "    private static final int numCnxns = 30;\n    @BeforeEach\n    @Override\n    public void setUp() throws Exception {\n        maxCnxns = numCnxns;\n        super.setUp();\n    }\n"}
{"magic_number_smell": "    public void testLeaderShutdown() throws IOException, InterruptedException, KeeperException {\n        ZooKeeper zk = new DisconnectableZooKeeper(\n            qb.hostPort,\n            ClientBase.ClientTest.CONNECTION_TIMEOUT,\n            DummyWatcher.INSTANCE);\n        zk.create(\"/blah\", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n        zk.create(\"/blah/blah\", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);", "refactored_code": "    public static final long CONNECTION_TIMEOUT = ClientTest.CONNECTION_TIMEOUT;\n    public void testLeaderShutdown() throws IOException, InterruptedException, KeeperException {\n        ZooKeeper zk = new DisconnectableZooKeeper(\n            qb.hostPort,\n            ClientBase.CONNECTION_TIMEOUT,\n            DummyWatcher.INSTANCE);\n        zk.create(\"/blah\", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n        zk.create(\"/blah/blah\", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);"}
{"magic_number_smell": "        final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n        ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n        f.startup(zks);\n        assertTrue(ClientBase.waitForServerUp(HOSTPORT, 3000), \"waiting for server being up \");\n        ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);\n        try {\n            for (int i = 0; i < totalTransactions; i++) {", "refactored_code": "    private static final int CONNECTION_TIMEOUT = 3000;\n        final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n        ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);\n        f.startup(zks);\n        assertTrue(ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT), \"waiting for server being up \");\n        ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);\n        try {\n            for (int i = 0; i < totalTransactions; i++) {"}
{"magic_number_smell": "        }\n\n        ClientBase.setupTestEnv();\n        zs = new ZooKeeperServer(tmpDir, tmpDir, 3000);\n\n        final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n        serverFactory = ServerCnxnFactory.createFactory(PORT, -1);", "refactored_code": "    private final int TICK_TIME = 3000;\n        }\n\n        ClientBase.setupTestEnv();\n        zs = new ZooKeeperServer(tmpDir, tmpDir, TICK_TIME);\n\n        final int PORT = Integer.parseInt(HOSTPORT.split(\":\")[1]);\n        serverFactory = ServerCnxnFactory.createFactory(PORT, -1);"}
{"magic_number_smell": "\n    protected static final Logger LOG = LoggerFactory.getLogger(SessionTrackerCheckTest.class);\n    public static final int 1000 = 1000;\n    public static final int CONNECTION_TIMEOUT = 1000 * 10;\n\n    private ConcurrentHashMap<Long, Integer> sessionsWithTimeouts = new ConcurrentHashMap<>();\n", "refactored_code": "    public static final int TICK_TIME = 1000;\n\n    protected static final Logger LOG = LoggerFactory.getLogger(SessionTrackerCheckTest.class);\n    public static final int TICK_TIME = 1000;\n    public static final int CONNECTION_TIMEOUT = TICK_TIME * 10;\n\n    private ConcurrentHashMap<Long, Integer> sessionsWithTimeouts = new ConcurrentHashMap<>();\n"}
{"magic_number_smell": "        int testPeerIdx = testLeader ? leaderIdx : followerIdx;\n        String[] hostPorts = qb.hostPort.split(\",\");\n        CountdownWatcher watcher = new CountdownWatcher();\n        DisconnectableZooKeeper zk = new DisconnectableZooKeeper(hostPorts[testPeerIdx], ClientBase.CONNECTION_TIMEOUT, watcher);\n        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n\n        // Try creating some data.", "refactored_code": "    public static final int CONNECTION_TIMEOUT = ClientBase.CONNECTION_TIMEOUT;\n        int testPeerIdx = testLeader ? leaderIdx : followerIdx;\n        String[] hostPorts = qb.hostPort.split(\",\");\n        CountdownWatcher watcher = new CountdownWatcher();\n        DisconnectableZooKeeper zk = new DisconnectableZooKeeper(hostPorts[testPeerIdx], CONNECTION_TIMEOUT, watcher);\n        watcher.waitForConnected(CONNECTION_TIMEOUT);\n\n        // Try creating some data."}
{"magic_number_smell": "        }\n        hostProvider.onConnected();\n\n        // should be numClients/10 in expectation, we test that its numClients/10 +- 10\n        assertTrue(numDisconnects < upperboundCPS(numClients, 10));\n    }\n", "refactored_code": "    private final double slackPercent = 10;\n        }\n        hostProvider.onConnected();\n\n        // should be numClients/10 in expectation, we test that its numClients/10 +- slackPercent\n        assertTrue(numDisconnects < upperboundCPS(numClients, 10));\n    }\n"}
{"magic_number_smell": "\n    private ZooKeeper createClient(QuorumUtil qu, int id, EventsWatcher watcher) throws IOException {\n        String hostPort = \"127.0.0.1:\" + qu.getPeer(id).clientPort;\n        ZooKeeper zk = new ZooKeeper(hostPort, 30000, watcher);\n        try {\n            watcher.waitForConnected(30000);\n        } catch (InterruptedException e) {", "refactored_code": "    private static final int TIMEOUT = 30000;\n\n    private ZooKeeper createClient(QuorumUtil qu, int id, EventsWatcher watcher) throws IOException {\n        String hostPort = \"127.0.0.1:\" + qu.getPeer(id).clientPort;\n        ZooKeeper zk = new ZooKeeper(hostPort, TIMEOUT, watcher);\n        try {\n            watcher.waitForConnected(TIMEOUT);\n        } catch (InterruptedException e) {"}
{"magic_number_smell": "        for (int i = 0; i < 5; i++) {\n            if (leaderSid != (i + 1)) {\n                String hp = list[i];\n                assertTrue(ClientBase.waitForServerUp(hp, ClientTest.CONNECTION_TIMEOUT), \"waiting for server up\");\n                LOG.info(\"{} is accepting client connections\", hp);\n            } else {\n                LOG.info(\"Skipping the leader\");", "refactored_code": "    public static final long CONNECTION_TIMEOUT = ClientTest.CONNECTION_TIMEOUT;\n        for (int i = 0; i < 5; i++) {\n            if (leaderSid != (i + 1)) {\n                String hp = list[i];\n                assertTrue(ClientBase.waitForServerUp(hp, CONNECTION_TIMEOUT), \"waiting for server up\");\n                LOG.info(\"{} is accepting client connections\", hp);\n            } else {\n                LOG.info(\"Skipping the leader\");"}
{"magic_number_smell": "\t\t @Path(value=\"/url\", priority=Path.HIGH)\n\t\t @Path(value=\"/url\", priority=Path.DEFAULT)\n\t\t @Path(value=\"/url\", priority=Path.LOW)\n\t\t @Path(value=\"/url\", priority=Path.Integer.MAX_VALUE)\n\t </pre>\n\t *\n\t */", "refactored_code": "\tpublic static final int LOWEST = Integer.MAX_VALUE;\n\t\t @Path(value=\"/url\", priority=Path.HIGH)\n\t\t @Path(value=\"/url\", priority=Path.DEFAULT)\n\t\t @Path(value=\"/url\", priority=Path.LOW)\n\t\t @Path(value=\"/url\", priority=Path.LOWEST)\n\t </pre>\n\t *\n\t */"}
{"magic_number_smell": "\n\tprivate MimeType convertToMimeType(String string) {\n\t\tif (string.contains(\"*/*\")) {\n\t\t\treturn new MimeType(\"text/html\", 0.01);\n\t\t} else if (string.contains(\";\")) {\n\t\t\tString type = string.substring(0, string.indexOf(';'));\n\t\t\treturn new MimeType(type, extractQualifier(string));", "refactored_code": "\tprivate static final double DEFAULT_QUALIFIER_VALUE = 0.01;\n\n\tprivate MimeType convertToMimeType(String string) {\n\t\tif (string.contains(\"*/*\")) {\n\t\t\treturn new MimeType(\"text/html\", DEFAULT_QUALIFIER_VALUE);\n\t\t} else if (string.contains(\";\")) {\n\t\t\tString type = string.substring(0, string.indexOf(';'));\n\t\t\treturn new MimeType(type, extractQualifier(string));"}
{"magic_number_smell": "\t\tStringTokenizer tokenizer = new StringTokenizer(strRep);\n\t\tint tokenCnt = tokenizer.countTokens();\n\n\t\tif (tokenCnt != 7)\n\t\t\tthrow new ProviderException(\n\t\t\t\t\t\"DEBUG OBJECT <key> response does not conform to expected format.  Got: [\"\n\t\t\t\t\t\t\t+ strRep + \"]\");", "refactored_code": "\tprivate static final long numTokens = 7;\n\t\tStringTokenizer tokenizer = new StringTokenizer(strRep);\n\t\tint tokenCnt = tokenizer.countTokens();\n\n\t\tif (tokenCnt != numTokens)\n\t\t\tthrow new ProviderException(\n\t\t\t\t\t\"DEBUG OBJECT <key> response does not conform to expected format.  Got: [\"\n\t\t\t\t\t\t\t+ strRep + \"]\");"}
{"magic_number_smell": "\tpublic static final long _specification.Version.major = _specification.Version.major;\n\n\t/**  */\n\tprivate static final long\tserialVersionUID = _specification.Version.major;\n\n\t/**  */\n\tprivate final Command command;", "refactored_code": "\tpublic static final long version = _specification.Version.major;\n\tpublic static final long version = _specification.Version.major;\n\n\t/**  */\n\tprivate static final long\tserialVersionUID = version;\n\n\t/**  */\n\tprivate final Command command;"}
{"magic_number_smell": "\t\t\tthis.bitmask = (int)Math.pow(2, ordinal());\n\t\t}\n\t\tstatic final public int bitset(Flag...flags){\n\t\t\treturn bitset(0x0000, flags);\n\t\t}\n\t\tstatic final public int bitset(final int bitsetin, Flag...flags){\n\t\t\tint bitset = bitsetin;", "refactored_code": "\t\tprivate static final int OPAQUE_BITMASK_32 = 0x0000;\n\t\t\tthis.bitmask = (int)Math.pow(2, ordinal());\n\t\t}\n\t\tstatic final public int bitset(Flag...flags){\n\t\t\treturn bitset(OPAQUE_BITMASK_32, flags);\n\t\t}\n\t\tstatic final public int bitset(final int bitsetin, Flag...flags){\n\t\t\tint bitset = bitsetin;"}
{"magic_number_smell": "\tstatic final int MTU_SIZE = 1488;\n\t\n\t/** chunk buffer size */\n\tstatic final int CHUNK_BUFF_SIZE = Math.min(MTU_SIZE * 2, 0xFFFF);\n\t\n\t/** minimum request size in bytes -- using PING e.g. 14 b */\n\tstatic final int MIN_REQ_SIZE = 14; ", "refactored_code": "\tprivate static final int MTU_FACTOR = 2; // TODO: ConnectionSpec me.\n\tstatic final int MTU_SIZE = 1488;\n\t\n\t/** chunk buffer size */\n\tstatic final int CHUNK_BUFF_SIZE = Math.min(MTU_SIZE * MTU_FACTOR, 0xFFFF);\n\t\n\t/** minimum request size in bytes -- using PING e.g. 14 b */\n\tstatic final int MIN_REQ_SIZE = 14; "}
{"magic_number_smell": "    \t\n    \t// tcp socket flags\n    \tsetSocketProperty(SO_TIMEOUT, DEFAULT_READ_TIMEOUT_MSEC);\n    \tsetSocketProperty(SO_RCVBUF, 1024 * 48);\n    \tsetSocketProperty(SO_SNDBUF, DEFAULT_SND_BUFF_SIZE);\n    \tsetSocketProperty(SO_PREF_BANDWIDTH, DEFAULT_SO_PREF_BANDWIDTH);\n    \tsetSocketProperty(SO_PREF_CONN_TIME, DEFAULT_SO_PREF_CONN_TIME);", "refactored_code": "\tprivate static final int DEFAULT_RCV_BUFF_SIZE = 1024 * 48;\n    \t\n    \t// tcp socket flags\n    \tsetSocketProperty(SO_TIMEOUT, DEFAULT_READ_TIMEOUT_MSEC);\n    \tsetSocketProperty(SO_RCVBUF, DEFAULT_RCV_BUFF_SIZE);\n    \tsetSocketProperty(SO_SNDBUF, DEFAULT_SND_BUFF_SIZE);\n    \tsetSocketProperty(SO_PREF_BANDWIDTH, DEFAULT_SO_PREF_BANDWIDTH);\n    \tsetSocketProperty(SO_PREF_CONN_TIME, DEFAULT_SO_PREF_CONN_TIME);"}
{"magic_number_smell": "\t\tbyte[] lineCntBytes = Convert.toBytes(args.length+1);\n\n\t\t// calculate the buffer size\n\t\tint bsize = 1 + lineCntBytes.length + CRLF.length + 1 + cmdLenBytes.length + CRLF.length + cmd.bytes.length + CRLF.length;\n\t\tfor(int i=0;i<args.length; i++){\n\t\t\tbyte[] argLenBytes = Convert.toBytes(Assert.notNull(args[i], i, ProviderException.class).length);\n\t\t\tint _bsize = 1 + argLenBytes.length + CRLF.length + args[i].length + CRLF.length;", "refactored_code": "\tpublic static final int \tCRLF_LEN = CRLF.length;\n\t\tbyte[] lineCntBytes = Convert.toBytes(args.length+1);\n\n\t\t// calculate the buffer size\n\t\tint bsize = 1 + lineCntBytes.length + CRLF_LEN + 1 + cmdLenBytes.length + CRLF_LEN + cmd.bytes.length + CRLF_LEN;\n\t\tfor(int i=0;i<args.length; i++){\n\t\t\tbyte[] argLenBytes = Convert.toBytes(Assert.notNull(args[i], i, ProviderException.class).length);\n\t\t\tint _bsize = 1 + argLenBytes.length + CRLF_LEN + args[i].length + CRLF_LEN;"}
{"magic_number_smell": "\t// ------------------------------------------------------------------------\n\t\n\tpublic SyncProtocol() {\n\t\tsharedRequestBuffer = new ByteArrayOutputStream (1024 * 48);\n\t\tsharedRequestObject = new StreamBufferRequest (sharedRequestBuffer);\n\t\tsharedResponseBuffer = new byte [PREFERRED_LINE_BUFFER_SIZE];\n", "refactored_code": "\tprotected static final int\t\t\tPREFERRED_REQUEST_BUFFER_SIZE\t= 1024 * 48;\n\t// ------------------------------------------------------------------------\n\t\n\tpublic SyncProtocol() {\n\t\tsharedRequestBuffer = new ByteArrayOutputStream (PREFERRED_REQUEST_BUFFER_SIZE);\n\t\tsharedRequestObject = new StreamBufferRequest (sharedRequestBuffer);\n\t\tsharedResponseBuffer = new byte [PREFERRED_LINE_BUFFER_SIZE];\n"}
{"magic_number_smell": "\t// Constants\n\t// ------------------------------------------------------------------------\n\tpublic static final int \t\t65535 = 65535;\n\tpublic static final int \t\tINT_N_65535 = 0 - 65535;\n\tprivate static final byte[][]   i2b_65535 = new byte[65535+1][];\n\tprivate static final byte       BYTE_MINUS = (byte) '-';\n\tprivate static final byte       BYTE_PLUS = (byte) '+';", "refactored_code": "\tpublic static final int \t\tINT_P_65535 = 65535;\n\t// Constants\n\t// ------------------------------------------------------------------------\n\tpublic static final int \t\tINT_P_65535 = 65535;\n\tpublic static final int \t\tINT_N_65535 = 0 - INT_P_65535;\n\tprivate static final byte[][]   i2b_65535 = new byte[INT_P_65535+1][];\n\tprivate static final byte       BYTE_MINUS = (byte) '-';\n\tprivate static final byte       BYTE_PLUS = (byte) '+';"}
{"magic_number_smell": "\tfinal ConnectionSpec spec;\n\tJRedisFuture jredis = null;\n\tpublic AdHocTestNoConnection() throws Throwable{\n\t\tspec = DefaultConnectionSpec.newSpec(\"localhost\", 9999, 11, \"jredis\".getBytes());\n\t\tjredis = new JRedisPipeline(spec);\n\t}\n\t/** this is not supposed to get called unless you actually run redis on port 9999 :P */", "refactored_code": "\tprivate static final int NOT_A_USUAL_REDIS_PORT = 9999;\n\tfinal ConnectionSpec spec;\n\tJRedisFuture jredis = null;\n\tpublic AdHocTestNoConnection() throws Throwable{\n\t\tspec = DefaultConnectionSpec.newSpec(\"localhost\", NOT_A_USUAL_REDIS_PORT, 11, \"jredis\".getBytes());\n\t\tjredis = new JRedisPipeline(spec);\n\t}\n\t/** this is not supposed to get called unless you actually run redis on port 9999 :P */"}
{"magic_number_smell": "\t}\n\n\tpublic boolean approve() {\n\t\treturn this.getStatus() == 0;\n\t}\n\n\tpublic boolean defer() {", "refactored_code": "\tpublic static final int APPROVE = 0;\n\t}\n\n\tpublic boolean approve() {\n\t\treturn this.getStatus() == APPROVE;\n\t}\n\n\tpublic boolean defer() {"}
{"magic_number_smell": "\t * @return <code>true</code> if the size is greater than quota's limit.\n\t */\n\tpublic boolean exceedsQuota(long size) {\n\t\tif (this.type == AttachmentQuota.1) {\n\t\t\treturn (size > this.size * 1024);\n\t\t}\n", "refactored_code": "\tpublic static final int KB = 1;\n\t * @return <code>true</code> if the size is greater than quota's limit.\n\t */\n\tpublic boolean exceedsQuota(long size) {\n\t\tif (this.type == AttachmentQuota.KB) {\n\t\t\treturn (size > this.size * 1024);\n\t\t}\n"}
{"magic_number_smell": "\t}\n\n\t/**\n\t * @return true if {@link #getType()} == {@link #0}\n\t */\n\tpublic boolean isNormal() {\n\t\treturn this.getType() == 0;", "refactored_code": "\tpublic static final int TYPE_NORMAL = 0;\n\t}\n\n\t/**\n\t * @return true if {@link #getType()} == {@link #TYPE_NORMAL}\n\t */\n\tpublic boolean isNormal() {\n\t\treturn this.getType() == TYPE_NORMAL;"}
{"magic_number_smell": "\t\t\t\tif (read(data, 0, 6) != 6) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tformat = 0;\n\t\t\t\tbitsPerPixel = (data[0] & 0xff) * (data[5] & 0xff);\n\t\t\t\tprogressive = marker == 0xffc2 || marker == 0xffc6 ||\n\t\t\t\t\tmarker == 0xffca || marker == 0xffce;", "refactored_code": "\tpublic static final int FORMAT_JPEG = 0;\n\t\t\t\tif (read(data, 0, 6) != 6) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tformat = FORMAT_JPEG;\n\t\t\t\tbitsPerPixel = (data[0] & 0xff) * (data[5] & 0xff);\n\t\t\t\tprogressive = marker == 0xffc2 || marker == 0xffc6 ||\n\t\t\t\t\tmarker == 0xffca || marker == 0xffce;"}
{"magic_number_smell": "\t\tthis.password = this.config.getValue(ConfigKeys.MAIL_SMTP_PASSWORD);\n\n\t\tmessageFormat = this.config.getValue(ConfigKeys.MAIL_MESSSAGE_FORMAT).equals(\"html\")\n\t\t\t? 0\n\t\t\t: MESSAGE_TEXT;\n\n\t\tthis.session = Session.getInstance(mailProperties);", "refactored_code": "\tprivate static final int MESSAGE_HTML = 0;\n\t\tthis.password = this.config.getValue(ConfigKeys.MAIL_SMTP_PASSWORD);\n\n\t\tmessageFormat = this.config.getValue(ConfigKeys.MAIL_MESSSAGE_FORMAT).equals(\"html\")\n\t\t\t? MESSAGE_HTML\n\t\t\t: MESSAGE_TEXT;\n\n\t\tthis.session = Session.getInstance(mailProperties);"}
{"magic_number_smell": "\t\tAssert.assertTrue(moderators.contains(new Group() {/**\n\t\t\t *\n\t\t\t */\n\t\t\tprivate static final long 1L = 1L;\n\n\t\t{ setId(2); }}));\n\t}", "refactored_code": "\t\t\tprivate static final long serialVersionUID = 1L;\n\t\tAssert.assertTrue(moderators.contains(new Group() {/**\n\t\t\t *\n\t\t\t */\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t{ setId(2); }}));\n\t}"}
{"magic_number_smell": "\t\tString tmaxString = (String) tmaxTable_.get(metricName);\n\t\tif (tmaxString == null)\n\t\t{\n\t\t\treturn 60;\n\t\t}\n\t\telse\n\t\t{", "refactored_code": "\tprivate static final int DEFAULT_TMAX = 60;\n\t\tString tmaxString = (String) tmaxTable_.get(metricName);\n\t\tif (tmaxString == null)\n\t\t{\n\t\t\treturn DEFAULT_TMAX;\n\t\t}\n\t\telse\n\t\t{"}
{"magic_number_smell": "        }\n        else\n        {\n            css.thriftPort = 9160;\n        }\n    }\n}", "refactored_code": "    private static final int    DEFAULT_THRIFT_PORT = 9160;\n        }\n        else\n        {\n            css.thriftPort = DEFAULT_THRIFT_PORT;\n        }\n    }\n}"}
{"magic_number_smell": "    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n    private final static ThreadLocal<IContinuable> tls_ = new ThreadLocal<IContinuable>();\n    private static final int Integer.SIZE - 3 = Integer.SIZE - 3;\n    private static final int CAPACITY = (1 << Integer.SIZE - 3) - 1;\n\n    // runState is stored in the high-order bits\n    private static final int RUNNING = -1 << Integer.SIZE - 3;", "refactored_code": "    private static final int COUNT_BITS = Integer.SIZE - 3;\n    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n    private final static ThreadLocal<IContinuable> tls_ = new ThreadLocal<IContinuable>();\n    private static final int COUNT_BITS = Integer.SIZE - 3;\n    private static final int CAPACITY = (1 << COUNT_BITS) - 1;\n\n    // runState is stored in the high-order bits\n    private static final int RUNNING = -1 << COUNT_BITS;"}
{"magic_number_smell": "                    // For each bucket if it has crossed the threshhold do the compaction\n                    // In case of range  compaction merge the counting bloom filters also.\n                    if( count == threshHold_)\n                        doFileCompaction(files, 128*1024*1024);\n\t    \t\t}\n\t    \t}\n        }", "refactored_code": "    private static final int bufSize_ = 128*1024*1024;\n                    // For each bucket if it has crossed the threshhold do the compaction\n                    // In case of range  compaction merge the counting bloom filters also.\n                    if( count == threshHold_)\n                        doFileCompaction(files, bufSize_);\n\t    \t\t}\n\t    \t}\n        }"}
{"magic_number_smell": "        {\n            /* Add this to the threshold */\n            int bufSize = 4*1024*1024;\n            return SequenceFile.fastWriter(file, CommitLog.128*1024*1024 + bufSize);\n        }\n        else\n            return SequenceFile.writer(file);", "refactored_code": "    private static final int bufSize_ = 128*1024*1024;\n        {\n            /* Add this to the threshold */\n            int bufSize = 4*1024*1024;\n            return SequenceFile.fastWriter(file, CommitLog.bufSize_ + bufSize);\n        }\n        else\n            return SequenceFile.writer(file);"}
{"magic_number_smell": "        ArrivalWindow hbWnd = arrivalSamples_.get(ep);\n        if ( hbWnd == null )\n        {\n            hbWnd = new ArrivalWindow(1000);\n            arrivalSamples_.put(ep, hbWnd);\n        }\n        hbWnd.add(now);  ", "refactored_code": "    private static final int sampleSize_ = 1000;\n        ArrivalWindow hbWnd = arrivalSamples_.get(ep);\n        if ( hbWnd == null )\n        {\n            hbWnd = new ArrivalWindow(sampleSize_);\n            arrivalSamples_.put(ep, hbWnd);\n        }\n        hbWnd.add(now);  "}
{"magic_number_smell": "\n            /* read the column family name */\n            String cfName = file_.readUTF();\n            dataSize -= (2 + cfName.length());\n            \n            /* read local deletion time */\n            int localDeletionTime = file_.readInt();", "refactored_code": "        private static final short utfPrefix_ = 2;\n\n            /* read the column family name */\n            String cfName = file_.readUTF();\n            dataSize -= (utfPrefix_ + cfName.length());\n            \n            /* read local deletion time */\n            int localDeletionTime = file_.readInt();"}
{"magic_number_smell": "    \n    public static int indexInterval()\n    {\n    \treturn 128;\n    }\n    \n    /*", "refactored_code": "    private static final int indexInterval_ = 128;\n    \n    public static int indexInterval()\n    {\n    \treturn indexInterval_;\n    }\n    \n    /*"}
{"magic_number_smell": "    public void read(SelectionKey key)\n    {        \n        key.interestOps( key.interestOps() & (~SelectionKey.OP_READ) );\n        ByteBuffer buffer = ByteBuffer.allocate(4096);\n        try\n        {\n            SocketAddress sa = socketChannel_.receive(buffer);", "refactored_code": "    private static final int BUFFER_SIZE = 4096;\n    public void read(SelectionKey key)\n    {        \n        key.interestOps( key.interestOps() & (~SelectionKey.OP_READ) );\n        ByteBuffer buffer = ByteBuffer.allocate(BUFFER_SIZE);\n        try\n        {\n            SocketAddress sa = socketChannel_.receive(buffer);"}
{"magic_number_smell": "         */\n        public void run()\n        {\n            ByteBuffer readBuffer = ByteBuffer.allocate(HTTPReader.256);\n            try\n            {\n                int bytesRead = httpChannel_.read(readBuffer);", "refactored_code": "        private static final int bufferSize_ = 256;\n         */\n        public void run()\n        {\n            ByteBuffer readBuffer = ByteBuffer.allocate(HTTPReader.bufferSize_);\n            try\n            {\n                int bytesRead = httpChannel_.read(readBuffer);"}
{"magic_number_smell": "  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(1, new FieldMetaData(\"table\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));\n    put(KEY, new FieldMetaData(\"key\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));", "refactored_code": "  public static final int TABLE = 1;\n  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(TABLE, new FieldMetaData(\"table\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));\n    put(KEY, new FieldMetaData(\"key\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));"}
{"magic_number_smell": "  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(1, new FieldMetaData(\"table\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));\n    put(KEY, new FieldMetaData(\"key\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));", "refactored_code": "  public static final int TABLE = 1;\n  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(TABLE, new FieldMetaData(\"table\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));\n    put(KEY, new FieldMetaData(\"key\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));"}
{"magic_number_smell": "    }\n\n    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n      put(-1, new FieldMetaData(\"tablename\", TFieldRequirementType.DEFAULT, \n          new FieldValueMetaData(TType.STRING)));\n      put(KEY, new FieldMetaData(\"key\", TFieldRequirementType.DEFAULT, \n          new FieldValueMetaData(TType.STRING)));", "refactored_code": "    public static final int TABLENAME = -1;\n    }\n\n    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n      put(TABLENAME, new FieldMetaData(\"tablename\", TFieldRequirementType.DEFAULT, \n          new FieldValueMetaData(TType.STRING)));\n      put(KEY, new FieldMetaData(\"key\", TFieldRequirementType.DEFAULT, \n          new FieldValueMetaData(TType.STRING)));"}
{"magic_number_smell": "  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(1, new FieldMetaData(\"error\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));\n  }});\n", "refactored_code": "  public static final int ERROR = 1;\n  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(ERROR, new FieldMetaData(\"error\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));\n  }});\n"}
{"magic_number_smell": "  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(1, new FieldMetaData(\"columnName\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));\n    put(VALUE, new FieldMetaData(\"value\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));", "refactored_code": "  public static final int COLUMNNAME = 1;\n  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(COLUMNNAME, new FieldMetaData(\"columnName\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));\n    put(VALUE, new FieldMetaData(\"value\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));"}
{"magic_number_smell": "  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(1, new FieldMetaData(\"errorCode\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.I32)));\n    put(ERRORTXT, new FieldMetaData(\"errorTxt\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));", "refactored_code": "  public static final int ERRORCODE = 1;\n  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(ERRORCODE, new FieldMetaData(\"errorCode\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.I32)));\n    put(ERRORTXT, new FieldMetaData(\"errorTxt\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));"}
{"magic_number_smell": "\n\t}\n\n\tprivate ICachetable<String, Message> readRepairTable_ = new Cachetable<String, Message>(2000, new ReadRepairManager.ReadRepairPerformer());\n\n\tprotected ReadRepairManager()\n\t{", "refactored_code": "\tprivate static final long expirationTimeInMillis = 2000;\n\n\t}\n\n\tprivate ICachetable<String, Message> readRepairTable_ = new Cachetable<String, Message>(expirationTimeInMillis, new ReadRepairManager.ReadRepairPerformer());\n\n\tprotected ReadRepairManager()\n\t{"}
{"magic_number_smell": "            if ( isHeavyNode() )\n            {\n                logger_.debug(StorageService.getLocalStorageEndPoint() + \" is a heavy node with load \" + localLoad());\n                // lb_.schedule( new LoadBalancer(), StorageLoadBalancer.5, TimeUnit.MINUTES );\n            }\n            */\n        }       ", "refactored_code": "    private static final int delay_ = 5;\n            if ( isHeavyNode() )\n            {\n                logger_.debug(StorageService.getLocalStorageEndPoint() + \" is a heavy node with load \" + localLoad());\n                // lb_.schedule( new LoadBalancer(), StorageLoadBalancer.delay_, TimeUnit.MINUTES );\n            }\n            */\n        }       "}
{"magic_number_smell": "        /* start the analytics context package */\n        AnalyticsContext.instance().start();\n        /* starts a load timer thread */\n        loadTimer_.schedule( new LoadDisseminator(), StorageService.5 * 60 * 1000L, StorageService.5 * 60 * 1000L);\n        \n        /* report our existence to ZooKeeper instance and start the leader election service */\n        ", "refactored_code": "    private static final long threshold_ = 5 * 60 * 1000L;\n        /* start the analytics context package */\n        AnalyticsContext.instance().start();\n        /* starts a load timer thread */\n        loadTimer_.schedule( new LoadDisseminator(), StorageService.threshold_, StorageService.threshold_);\n        \n        /* report our existence to ZooKeeper instance and start the leader election service */\n        "}
{"magic_number_smell": "  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(1, new FieldMetaData(\"name\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));\n    put(COLUMNS, new FieldMetaData(\"columns\", TFieldRequirementType.DEFAULT, \n        new ListMetaData(TType.LIST, ", "refactored_code": "  public static final int NAME = 1;\n  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(NAME, new FieldMetaData(\"name\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));\n    put(COLUMNS, new FieldMetaData(\"columns\", TFieldRequirementType.DEFAULT, \n        new ListMetaData(TType.LIST, "}
{"magic_number_smell": "\n    private static int getBlockCount(String dataFile) throws IOException\n    {\n        IFileReader dataReader = SequenceFile.bufferedReader(dataFile, 64*1024);\n        DataOutputBuffer bufOut = new DataOutputBuffer();\n        DataInputBuffer bufIn = new DataInputBuffer();\n        int blockCount = 0;", "refactored_code": "    private static final int bufferSize_ = 64*1024;\n\n    private static int getBlockCount(String dataFile) throws IOException\n    {\n        IFileReader dataReader = SequenceFile.bufferedReader(dataFile, bufferSize_);\n        DataOutputBuffer bufOut = new DataOutputBuffer();\n        DataInputBuffer bufIn = new DataInputBuffer();\n        int blockCount = 0;"}
{"magic_number_smell": "        RandomAccessFile raf = new RandomAccessFile( \"Missing-\" + FBUtilities.getHostName() + \".dat\", \"rw\");\n        \n        /* Start reading the file that contains the keys */\n        BufferedReader bufReader = new BufferedReader( new InputStreamReader( new FileInputStream(args[0]) ), KeyChecker.128*1024*1024 );\n        String key = null;\n        boolean bStarted = false;\n        ", "refactored_code": "    private static final int bufSize_ = 128*1024*1024;\n        RandomAccessFile raf = new RandomAccessFile( \"Missing-\" + FBUtilities.getHostName() + \".dat\", \"rw\");\n        \n        /* Start reading the file that contains the keys */\n        BufferedReader bufReader = new BufferedReader( new InputStreamReader( new FileInputStream(args[0]) ), KeyChecker.bufSize_ );\n        String key = null;\n        boolean bStarted = false;\n        "}
{"magic_number_smell": "\n    public static boolean extractKeyIntoFile(String keyToExtract, String dataFile, String outputFile) throws IOException\n    {\n\t\tIFileReader dataReader = SequenceFile.bufferedReader(dataFile, 64*1024);\n        DataOutputBuffer bufOut = new DataOutputBuffer();\n        DataInputBuffer bufIn = new DataInputBuffer();\n", "refactored_code": "    private static final int bufferSize_ = 64*1024;\n\n    public static boolean extractKeyIntoFile(String keyToExtract, String dataFile, String outputFile) throws IOException\n    {\n\t\tIFileReader dataReader = SequenceFile.bufferedReader(dataFile, bufferSize_);\n        DataOutputBuffer bufOut = new DataOutputBuffer();\n        DataInputBuffer bufIn = new DataInputBuffer();\n"}
{"magic_number_smell": "        DataOutputStream dos = new DataOutputStream(bos);\n        MembershipCleanerMessage.serializer().serialize(mcMessage, dos);\n        /* Construct the token update message to be sent */\n        Message mbrshipCleanerMessage = new Message( new EndPoint(FBUtilities.getHostName(), 7000), \"\", StorageService.mbrshipCleanerVerbHandler_, new Object[]{bos.toByteArray()} );\n        \n        BufferedReader bufReader = new BufferedReader( new InputStreamReader( new FileInputStream(file) ) );\n        String line = null;", "refactored_code": "    private static final int port_ = 7000;\n        DataOutputStream dos = new DataOutputStream(bos);\n        MembershipCleanerMessage.serializer().serialize(mcMessage, dos);\n        /* Construct the token update message to be sent */\n        Message mbrshipCleanerMessage = new Message( new EndPoint(FBUtilities.getHostName(), port_), \"\", StorageService.mbrshipCleanerVerbHandler_, new Object[]{bos.toByteArray()} );\n        \n        BufferedReader bufReader = new BufferedReader( new InputStreamReader( new FileInputStream(file) ) );\n        String line = null;"}
{"magic_number_smell": "        DataOutputStream dos = new DataOutputStream(bos);\n        TokenInfoMessage.serializer().serialize(tiMessage, dos);\n        /* Construct the token update message to be sent */\n        Message tokenUpdateMessage = new Message( new EndPoint(FBUtilities.getHostName(), 7000), \"\", StorageService.tokenVerbHandler_, new Object[]{bos.toByteArray()} );\n        \n        BufferedReader bufReader = new BufferedReader( new InputStreamReader( new FileInputStream(file) ) );\n        String line = null;", "refactored_code": "    private static final int port_ = 7000;\n        DataOutputStream dos = new DataOutputStream(bos);\n        TokenInfoMessage.serializer().serialize(tiMessage, dos);\n        /* Construct the token update message to be sent */\n        Message tokenUpdateMessage = new Message( new EndPoint(FBUtilities.getHostName(), port_), \"\", StorageService.tokenVerbHandler_, new Object[]{bos.toByteArray()} );\n        \n        BufferedReader bufReader = new BufferedReader( new InputStreamReader( new FileInputStream(file) ) );\n        String line = null;"}
{"magic_number_smell": "        int endWordIndex = wordIndex(toIndex - 1);\n        expandTo(endWordIndex);\n        \n        long firstWordMask = 0xffffffffffffffffL << fromIndex;\n        long lastWordMask = 0xffffffffffffffffL >>> -toIndex;\n        if (startWordIndex == endWordIndex)\n        {", "refactored_code": "    private static final long WORD_MASK = 0xffffffffffffffffL;\n        int endWordIndex = wordIndex(toIndex - 1);\n        expandTo(endWordIndex);\n        \n        long firstWordMask = WORD_MASK << fromIndex;\n        long lastWordMask = WORD_MASK >>> -toIndex;\n        if (startWordIndex == endWordIndex)\n        {"}
{"magic_number_smell": "        if(maxFalsePosProb >= probs[minBuckets][minK]) {\n            return new BloomSpecification(2, optKPerBuckets[2]);\n        }\n        if(maxFalsePosProb < probs[15][maxK]) {\n            return new BloomSpecification(maxK, 15);\n        }\n", "refactored_code": "    private static final int maxBuckets = 15;\n        if(maxFalsePosProb >= probs[minBuckets][minK]) {\n            return new BloomSpecification(2, optKPerBuckets[2]);\n        }\n        if(maxFalsePosProb < probs[maxBuckets][maxK]) {\n            return new BloomSpecification(maxK, maxBuckets);\n        }\n"}
{"magic_number_smell": "     */\n    public FastHash()\n    {\n        this(DEFAULT_INITIAL_CAPACITY, 0.5f);\n    }\n    \n    /**", "refactored_code": "    protected static final float DEFAULT_LOAD_FACTOR = 0.5f;\n     */\n    public FastHash()\n    {\n        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);\n    }\n    \n    /**"}
{"magic_number_smell": "            String val = df_.format(d);\n            return val + \" MB\";\n        }\n        else if ( value >= 1024d )\n        {\n            d = value / 1024d;\n            String val = df_.format(d);", "refactored_code": "    private static final double kb_ = 1024d;\n            String val = df_.format(d);\n            return val + \" MB\";\n        }\n        else if ( value >= kb_ )\n        {\n            d = value / kb_;\n            String val = df_.format(d);"}
{"magic_number_smell": "\n    private static final int[] primeCapacities = {\n    // chunk #0\n            Integer.MAX_VALUE,\n\n            // chunk #1\n            5, 11, 23, 47, 97, 197, 397, 797, 1597, 3203, 6421, 12853, 25717,", "refactored_code": "    public static final int largestPrime = Integer.MAX_VALUE; // yes, it is\n\n    private static final int[] primeCapacities = {\n    // chunk #0\n            largestPrime,\n\n            // chunk #1\n            5, 11, 23, 47, 97, 197, 397, 797, 1597, 3203, 6421, 12853, 25717,"}
{"magic_number_smell": "  @RequestMapping(\"/tagcloud.boxlet\")\n  protected ModelAndView getData(HttpServletRequest request) {\n\n    List<TagDTO> list = tagDao.getTags(75);\n    return new ModelAndView(\"boxlets/tagcloud\", \"tags\", list);\n  }\n}", "refactored_code": "  private static final int TAGS_IN_CLOUD = 75;\n  @RequestMapping(\"/tagcloud.boxlet\")\n  protected ModelAndView getData(HttpServletRequest request) {\n\n    List<TagDTO> list = tagDao.getTags(TAGS_IN_CLOUD);\n    return new ModelAndView(\"boxlets/tagcloud\", \"tags\", list);\n  }\n}"}
{"magic_number_smell": "  protected ModelAndView getData(HttpServletRequest request) {\n    ModelAndView mav = new ModelAndView();\n    mav.setViewName(\"boxlets/gallery\");\n    List<PreparedGalleryItem> list = imageService.prepareGalleryItem(imageService.getGalleryItems(3));\n    mav.addObject(\"items\", list);\n    return mav;\n  }", "refactored_code": "  private static final int COUNT_ITEMS = 3;\n  protected ModelAndView getData(HttpServletRequest request) {\n    ModelAndView mav = new ModelAndView();\n    mav.setViewName(\"boxlets/gallery\");\n    List<PreparedGalleryItem> list = imageService.prepareGalleryItem(imageService.getGalleryItems(COUNT_ITEMS));\n    mav.addObject(\"items\", list);\n    return mav;\n  }"}
{"magic_number_smell": "\n  public static class UpdateComments implements Serializable {\n    private final List<Integer> msgids;\n    private static final long 5080317225175809364L = 8277563519169476453L;\n\n    // force ArrayList to fix Scala serialization problems\n    public UpdateComments(ArrayList<Integer> msgids) {", "refactored_code": "    private static final long serialVersionUID = 5080317225175809364L;\n\n  public static class UpdateComments implements Serializable {\n    private final List<Integer> msgids;\n    private static final long serialVersionUID = 8277563519169476453L;\n\n    // force ArrayList to fix Scala serialization problems\n    public UpdateComments(ArrayList<Integer> msgids) {"}
{"magic_number_smell": "\n  @Scheduled(fixedDelay=HOUR, initialDelay = FIVE_MINS)\n  public void cleanEvents() {\n    userEventService.cleanupOldEvents(2000);\n  }\n}\n", "refactored_code": "  public static final int MAX_EVENTS = 2000;\n\n  @Scheduled(fixedDelay=HOUR, initialDelay = FIVE_MINS)\n  public void cleanEvents() {\n    userEventService.cleanupOldEvents(MAX_EVENTS);\n  }\n}\n"}
{"magic_number_smell": "  @Before\n  @After\n  public void fixUser() {\n    jdbcTemplate.update(\"UPDATE users SET blocked='f' WHERE id=?\", 7806);\n    jdbcTemplate.update(\"DELETE FROM ban_info WHERE userid=?\", 7806);\n  }\n", "refactored_code": "  public static final int TEST_ID = 7806;\n  @Before\n  @After\n  public void fixUser() {\n    jdbcTemplate.update(\"UPDATE users SET blocked='f' WHERE id=?\", TEST_ID);\n    jdbcTemplate.update(\"DELETE FROM ban_info WHERE userid=?\", TEST_ID);\n  }\n"}
{"magic_number_smell": "\n    /**\n     * Initializes a SOAP Envelope. The version parameter must be set to one of\n     * 100, VER11 or VER12\n     */\n    public SoapEnvelope(int version) {\n        this.version = version;", "refactored_code": "    public static final int VER10 = 100;\n\n    /**\n     * Initializes a SOAP Envelope. The version parameter must be set to one of\n     * VER10, VER11 or VER12\n     */\n    public SoapEnvelope(int version) {\n        this.version = version;"}
{"magic_number_smell": "\t\tmultiRef = new Vector();\n\t\tmultiRef.addElement(bodyOut);\n\t\tObject[] qName = getInfo(null, bodyOut);\n\t\twriter.startTag((dotNet) ? \"\" : (String) qName[QNAME_NAMESPACE], (String) qName[1]);\n\t\tif (dotNet)\n\t\t{\n\t\t\twriter.attribute(null, \"xmlns\", (String) qName[QNAME_NAMESPACE]);", "refactored_code": "\tprotected static final int QNAME_TYPE = 1;\n\t\tmultiRef = new Vector();\n\t\tmultiRef.addElement(bodyOut);\n\t\tObject[] qName = getInfo(null, bodyOut);\n\t\twriter.startTag((dotNet) ? \"\" : (String) qName[QNAME_NAMESPACE], (String) qName[QNAME_TYPE]);\n\t\tif (dotNet)\n\t\t{\n\t\t\twriter.attribute(null, \"xmlns\", (String) qName[QNAME_NAMESPACE]);"}
{"magic_number_smell": "    static final String BIND_NAME = \"FabanRegistry\";\n\n    private static int getPort() {\n        int port = 9998;\n        String portString = System.getProperty(\"faban.registry.port\");\n        if (portString != null)\n            try {", "refactored_code": "    public static final int DEFAULT_PORT = 9998;\n    static final String BIND_NAME = \"FabanRegistry\";\n\n    private static int getPort() {\n        int port = DEFAULT_PORT;\n        String portString = System.getProperty(\"faban.registry.port\");\n        if (portString != null)\n            try {"}
{"magic_number_smell": "    static {\n        String platform = System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH);\n        if ( platform.contains( \"windows\" )) {\n            EXECUTABLES[0] = \"javac.exe\";\n        } else  {\n            EXECUTABLES[0] = \"javac\";\n        }", "refactored_code": "    public static final int JAVAC = 0; //position\n    static {\n        String platform = System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH);\n        if ( platform.contains( \"windows\" )) {\n            EXECUTABLES[JAVAC] = \"javac.exe\";\n        } else  {\n            EXECUTABLES[JAVAC] = \"javac\";\n        }"}
{"magic_number_smell": "            cycle = op.cycle;\n\t\t}\n\n        long invokeTime = Long.MIN_VALUE;\n        delayTime[mixId] = cycle.getDelay(random);\n\n        switch (cycle.cycleType) {", "refactored_code": "    public static final long TIME_NOT_SET = Long.MIN_VALUE;\n            cycle = op.cycle;\n\t\t}\n\n        long invokeTime = TIME_NOT_SET;\n        delayTime[mixId] = cycle.getDelay(random);\n\n        switch (cycle.cycleType) {"}
{"magic_number_smell": "\n    static class Driver implements Serializable, Cloneable {\n\n\t\tprivate static final long 1L = 1L;\n\n\t\tString name;\n        String metric;", "refactored_code": "\tprivate static final long serialVersionUID = 1L;\n\n    static class Driver implements Serializable, Cloneable {\n\n\t\tprivate static final long serialVersionUID = 1L;\n\n\t\tString name;\n        String metric;"}
{"magic_number_smell": "     */\n    public static class AgentInfo implements Serializable {\n        \n\t\tprivate static final long 1L = 1L;\n\t\t/** Agent number. */\n\t\tpublic int agentNumber;\n        /** Starting thread number. */", "refactored_code": "\tprivate static final long serialVersionUID = 1L;\n     */\n    public static class AgentInfo implements Serializable {\n        \n\t\tprivate static final long serialVersionUID = 1L;\n\t\t/** Agent number. */\n\t\tpublic int agentNumber;\n        /** Starting thread number. */"}
{"magic_number_smell": "     */\n\tpublic Throttle(DriverContext ctx) {\n\t\tthis.ctx = ctx;\n\t\tcheckForChange(0);\n\t\tcheckForChange(DOWN);\n\t}\n", "refactored_code": "    public static final int UP = 0;\n     */\n\tpublic Throttle(DriverContext ctx) {\n\t\tthis.ctx = ctx;\n\t\tcheckForChange(UP);\n\t\tcheckForChange(DOWN);\n\t}\n"}
{"magic_number_smell": "        u.appendChild(tmp);\n        tmp = doc.createElementNS(RunInfo.DRIVERURI, \"cycleDeviation\");\n        tmp.setPrefix(\"\");\n        tmp.appendChild(doc.createTextNode(\"\" + 1));\n        u.appendChild(tmp);\n        rlt.appendChild(u);\n        dc.appendChild(rlt);", "refactored_code": "    private static final int CYCLE_DEVIATION = 1;\n        u.appendChild(tmp);\n        tmp = doc.createElementNS(RunInfo.DRIVERURI, \"cycleDeviation\");\n        tmp.setPrefix(\"\");\n        tmp.appendChild(doc.createTextNode(\"\" + CYCLE_DEVIATION));\n        u.appendChild(tmp);\n        rlt.appendChild(u);\n        dc.appendChild(rlt);"}
{"magic_number_smell": "    /**\n     * Open a file for reading and/or writing.\n     * @param file filename\n     * @param mode file open mode - 1, WRITE, APPEND\n     * @return FileService - reference to the FileService interface.\n     * @throws RemoteException A communications error occurred.\n     * @throws FileServiceException Error opening file", "refactored_code": "    public static final int READ = 1;\n    /**\n     * Open a file for reading and/or writing.\n     * @param file filename\n     * @param mode file open mode - READ, WRITE, APPEND\n     * @return FileService - reference to the FileService interface.\n     * @throws RemoteException A communications error occurred.\n     * @throws FileServiceException Error opening file"}
{"magic_number_smell": "\n\n    private static synchronized void checkMaps(boolean deploy) {\n        if (System.currentTimeMillis() - mapTimeStamp > 10000)\n            generateMaps(deploy);\n    }\n", "refactored_code": "    public static final int MAP_TIMEOUT = 10000;\n\n\n    private static synchronized void checkMaps(boolean deploy) {\n        if (System.currentTimeMillis() - mapTimeStamp > MAP_TIMEOUT)\n            generateMaps(deploy);\n    }\n"}
{"magic_number_smell": "\n    /** The status messages for each status. */\n    public static final String[] STATUS_MESSAGE =\n            { \"0\", \"RECEIVED\", \"COMPLETED\", \"FAILED\", \"KILLED\" };\n\n    private BenchmarkDescription benchDesc;\n    private String outdir;\t\t// output directory name for this run", "refactored_code": "    public static final int STARTED = 0;\n\n    /** The status messages for each status. */\n    public static final String[] STATUS_MESSAGE =\n            { \"STARTED\", \"RECEIVED\", \"COMPLETED\", \"FAILED\", \"KILLED\" };\n\n    private BenchmarkDescription benchDesc;\n    private String outdir;\t\t// output directory name for this run"}
{"magic_number_smell": "    public void setup(String[] serverMachines, String binDir) {\n        myServers = serverMachines;\n        for (int i = 0; i < serverMachines.length; i++) {\n            myPorts[i] = 11211;\n        }\n\n        memcachedctlCmd = binDir + File.separator + \"memcached -m 256\";", "refactored_code": "    private static final int DEFAULT_PORT = 11211;  // default port\n    public void setup(String[] serverMachines, String binDir) {\n        myServers = serverMachines;\n        for (int i = 0; i < serverMachines.length; i++) {\n            myPorts[i] = DEFAULT_PORT;\n        }\n\n        memcachedctlCmd = binDir + File.separator + \"memcached -m 256\";"}
{"magic_number_smell": "                    RunId runId = new RunId(list[i]);\n                    String benchName = runId.getBenchName();\n                    String runSeq = runId.getRunSeq();\n                    data[i][0] = runSeq;\n                    data[i][BENCHNAME] = benchName;\n                    String paramFile = Config.RUNQ_DIR + list[i]\n                            + File.separator + ((BenchmarkDescription)", "refactored_code": "    public static final int RUNSEQ = 0;\n                    RunId runId = new RunId(list[i]);\n                    String benchName = runId.getBenchName();\n                    String runSeq = runId.getRunSeq();\n                    data[i][RUNSEQ] = runSeq;\n                    data[i][BENCHNAME] = benchName;\n                    String paramFile = Config.RUNQ_DIR + list[i]\n                            + File.separator + ((BenchmarkDescription)"}
{"magic_number_smell": "            if (i == numBuffers - 1)\n                bufferLimit = lastIdx;\n            for (int j = cIdx; j < bufferLimit; j++) {\n                if (cBuffer[j] == '\r' || cBuffer[j] == LF)\n                    return i * initialSize + j;\n            }\n        }", "refactored_code": "    public static final byte CR = '\\r';\n            if (i == numBuffers - 1)\n                bufferLimit = lastIdx;\n            for (int j = cIdx; j < bufferLimit; j++) {\n                if (cBuffer[j] == CR || cBuffer[j] == LF)\n                    return i * initialSize + j;\n            }\n        }"}
{"magic_number_smell": "            // Reading step 1. Just read some data\n            // If we can still not read anything within 100ms from the\n            // select/poll, we return the thread to the pool.\n            int count = read(channel, 100 * 1);\n            if (count == 0)\n                throw new TimedOutException(\n                        \"Service thread read 0 bytes, timed out!\");", "refactored_code": "    private static final int TIMEOUT_FACTOR = 1;\n            // Reading step 1. Just read some data\n            // If we can still not read anything within 100ms from the\n            // select/poll, we return the thread to the pool.\n            int count = read(channel, 100 * TIMEOUT_FACTOR);\n            if (count == 0)\n                throw new TimedOutException(\n                        \"Service thread read 0 bytes, timed out!\");"}
{"magic_number_smell": "                // the number of columns is the stats that we gather\n                //set Header\n                outputTextTable.setHeader(0, \"Server\");\n                outputTextTable.setHeader(1, \"Time\");\n                outputTextTable.setHeader(CUR_ITMS, \"items\");\n                outputTextTable.setHeader(BYTES, \"cache_MB\");\n                outputTextTable.setHeader(CUR_CONNS, \"conns\");", "refactored_code": "    private static final int CURTIME = 1;\n                // the number of columns is the stats that we gather\n                //set Header\n                outputTextTable.setHeader(0, \"Server\");\n                outputTextTable.setHeader(CURTIME, \"Time\");\n                outputTextTable.setHeader(CUR_ITMS, \"items\");\n                outputTextTable.setHeader(BYTES, \"cache_MB\");\n                outputTextTable.setHeader(CUR_CONNS, \"conns\");"}
{"magic_number_smell": "            }\n        });\n        \n        // Then limit to 25 (25) items.\n        if (feedList.size() > 25)\n            return feedList.subList(0, 25);\n        return feedList;", "refactored_code": "    private static final int FEED_LIMIT = 25;\n            }\n        });\n        \n        // Then limit to FEED_LIMIT (25) items.\n        if (feedList.size() > FEED_LIMIT)\n            return feedList.subList(0, FEED_LIMIT);\n        return feedList;"}
{"magic_number_smell": "                        myHostPort.value);\n            } else {\n                startCmd = new Command(memcachedStartCmd + \" -p \" +\n                        11211);\n            }\n            startCmd.setLogLevel(Command.STDOUT, Level.INFO);\n            startCmd.setLogLevel(Command.STDERR, Level.INFO);", "refactored_code": "    private static final int DEFAULT_PORT = 11211;  // default port\n                        myHostPort.value);\n            } else {\n                startCmd = new Command(memcachedStartCmd + \" -p \" +\n                        DEFAULT_PORT);\n            }\n            startCmd.setLogLevel(Command.STDOUT, Level.INFO);\n            startCmd.setLogLevel(Command.STDERR, Level.INFO);"}
{"magic_number_smell": "                // the number of columns is the stats that we gather\n                //set Header\n                outputTextTable.setHeader(0, \"Server\");\n                outputTextTable.setHeader(1, \"Time\");\n                outputTextTable.setHeader(CUR_ITMS, \"items\");\n                outputTextTable.setHeader(BYTES, \"cache_MB\");\n                outputTextTable.setHeader(CUR_CONNS, \"conns\");", "refactored_code": "    private static final int CURTIME = 1;\n                // the number of columns is the stats that we gather\n                //set Header\n                outputTextTable.setHeader(0, \"Server\");\n                outputTextTable.setHeader(CURTIME, \"Time\");\n                outputTextTable.setHeader(CUR_ITMS, \"items\");\n                outputTextTable.setHeader(BYTES, \"cache_MB\");\n                outputTextTable.setHeader(CUR_CONNS, \"conns\");"}
{"magic_number_smell": "\n    /**\n     *  This is the generic version string you should use when printing out the version.  It is of\n     *  the form \"2.REVISION.MINORREVISION[-POSTFIX][-BUILD]\".\n     */\n    public static final String     VERSTR        = 2 + \".\" +\n                                                   REVISION + \".\" +", "refactored_code": "    public static final int        VERSION       = 2;\n\n    /**\n     *  This is the generic version string you should use when printing out the version.  It is of\n     *  the form \"VERSION.REVISION.MINORREVISION[-POSTFIX][-BUILD]\".\n     */\n    public static final String     VERSTR        = VERSION + \".\" +\n                                                   REVISION + \".\" +"}
{"magic_number_smell": "            cache = cacheManager.getCache( cacheName );\n        } else {\n            LOG.info( \"cache with name {} not found in ehcache configuration file, creating it with defaults.\", cacheName );\n            cache = new Cache( cacheName, 1_000, false, false, DEFAULT_CACHE_EXPIRY_PERIOD, DEFAULT_CACHE_EXPIRY_PERIOD );\n            cacheManager.addCache( cache );\n        }\n        cacheMap.put( cacheName, cache );", "refactored_code": "    private static final int DEFAULT_CACHE_SIZE = 1_000;\n            cache = cacheManager.getCache( cacheName );\n        } else {\n            LOG.info( \"cache with name {} not found in ehcache configuration file, creating it with defaults.\", cacheName );\n            cache = new Cache( cacheName, DEFAULT_CACHE_SIZE, false, false, DEFAULT_CACHE_EXPIRY_PERIOD, DEFAULT_CACHE_EXPIRY_PERIOD );\n            cacheManager.addCache( cache );\n        }\n        cacheMap.put( cacheName, cache );"}
{"magic_number_smell": "        private static final int 30 = 30;\n\n        public WatchDogThread( final Engine engine ) {\n            super( engine, 30 );\n            setName( \"WatchDog for '\" + engine.getApplicationName() + \"'\" );\n        }\n", "refactored_code": "        private static final int CHECK_INTERVAL = 30;\n        private static final int CHECK_INTERVAL = 30;\n\n        public WatchDogThread( final Engine engine ) {\n            super( engine, CHECK_INTERVAL );\n            setName( \"WatchDog for '\" + engine.getApplicationName() + \"'\" );\n        }\n"}
{"magic_number_smell": "                // LOG.debug( \"Running background task: \" + name + \".\" );\n                backgroundTask();\n                \n                // Sleep for the interval we're supposed to, but wake up every 1_000L to see if thread should die\n                boolean interrupted = false;\n                try {\n                    for( int i = 0; i < m_interval; i++ ) {", "refactored_code": "    private static final long POLLING_INTERVAL = 1_000L;\n                // LOG.debug( \"Running background task: \" + name + \".\" );\n                backgroundTask();\n                \n                // Sleep for the interval we're supposed to, but wake up every POLLING_INTERVAL to see if thread should die\n                boolean interrupted = false;\n                try {\n                    for( int i = 0; i < m_interval; i++ ) {"}
{"magic_number_smell": "     */\n    private void delayLogin( final String username ) {\n        try {\n            m_lastLoginAttempts.cleanup( 10 * 60 * 1_000L );\n            final int count = m_lastLoginAttempts.count( username );\n\n            final long delay = Math.min( 1L << count, MAX_LOGIN_DELAY );", "refactored_code": "    private static final long LASTLOGINS_CLEANUP_TIME = 10 * 60 * 1_000L; // Ten minutes\n     */\n    private void delayLogin( final String username ) {\n        try {\n            m_lastLoginAttempts.cleanup( LASTLOGINS_CLEANUP_TIME );\n            final int count = m_lastLoginAttempts.count( username );\n\n            final long delay = Math.min( 1L << count, MAX_LOGIN_DELAY );"}
{"magic_number_smell": "        //  Scrub away old files\n        final long now = System.currentTimeMillis();\n        if( now > ( c_lastScrubTime + SCRUB_PERIOD ) ) {\n            scrub( TextUtil.getIntegerProperty( engine.getWikiProperties(), PROP_LOGIN_EXPIRY_DAYS, 14 ), cookieDir );\n            c_lastScrubTime = now;\n        }\n", "refactored_code": "    private static final int DEFAULT_EXPIRY_DAYS = 14;\n        //  Scrub away old files\n        final long now = System.currentTimeMillis();\n        if( now > ( c_lastScrubTime + SCRUB_PERIOD ) ) {\n            scrub( TextUtil.getIntegerProperty( engine.getWikiProperties(), PROP_LOGIN_EXPIRY_DAYS, DEFAULT_EXPIRY_DAYS ), cookieDir );\n            c_lastScrubTime = now;\n        }\n"}
{"magic_number_smell": "        if( !m_stopAtFirstMatch ) {\n            final Integer score = context.getVariable( ATTR_SPAMFILTER_SCORE );\n\n            if( score != null && score >= 1 ) {\n                throw new RedirectException( \"Herb says you got too many points\", getRedirectPage( context ) );\n            }\n        }", "refactored_code": "    private final int             m_scoreLimit = 1;\n        if( !m_stopAtFirstMatch ) {\n            final Integer score = context.getVariable( ATTR_SPAMFILTER_SCORE );\n\n            if( score != null && score >= m_scoreLimit ) {\n                throw new RedirectException( \"Herb says you got too many points\", getRedirectPage( context ) );\n            }\n        }"}
{"magic_number_smell": "    public static final int HEADING_LARGE  = 3;\n\n    /**\n     *  Denotes the level of the heading. Either 1, HEADING_MEDIUM, or HEADING_LARGE.\n     */\n    public int    m_level;\n    ", "refactored_code": "    public static final int HEADING_SMALL  = 1;\n    public static final int HEADING_LARGE  = 3;\n\n    /**\n     *  Denotes the level of the heading. Either HEADING_SMALL, HEADING_MEDIUM, or HEADING_LARGE.\n     */\n    public int    m_level;\n    "}
{"magic_number_smell": "        final ResourceBundle rb = Preferences.getBundle( m_context, InternationalizationManager.CORE_BUNDLE );\n\n        switch( type ) {\n            case 0:\n                el = createAnchor( 0, m_context.getURL( ContextEnum.PAGE_VIEW.getRequestContext(), link), text, section );\n                break;\n", "refactored_code": "    protected static final int              READ          = 0;\n        final ResourceBundle rb = Preferences.getBundle( m_context, InternationalizationManager.CORE_BUNDLE );\n\n        switch( type ) {\n            case READ:\n                el = createAnchor( READ, m_context.getURL( ContextEnum.PAGE_VIEW.getRequestContext(), link), text, section );\n                break;\n"}
{"magic_number_smell": "    public Reader setInputReader( final Reader in ) {\n        final Reader old = m_in;\n        if( in != null ) {\n            m_in = new PushbackReader( new BufferedReader( in ), 10*1024 );\n        }\n\n        return old;", "refactored_code": "    protected static final int PUSHBACK_BUFFER_SIZE = 10*1024;\n    public Reader setInputReader( final Reader in ) {\n        final Reader old = m_in;\n        if( in != null ) {\n            m_in = new PushbackReader( new BufferedReader( in ), PUSHBACK_BUFFER_SIZE );\n        }\n\n        return old;"}
{"magic_number_smell": "        int count = 0;\n\n        //  The output will be B Item[1] A S B Item[2] A S B Item[3] A\n        while( it.hasNext() && ( (count < numItems) || ( numItems == -1 ) ) ) {\n            final String value = it.next();\n            if( count > 0 ) {\n                output.append( m_after );", "refactored_code": "    public static final int    ALL_ITEMS              = -1;\n        int count = 0;\n\n        //  The output will be B Item[1] A S B Item[2] A S B Item[3] A\n        while( it.hasNext() && ( (count < numItems) || ( numItems == ALL_ITEMS ) ) ) {\n            final String value = it.next();\n            if( count > 0 ) {\n                output.append( m_after );"}
{"magic_number_smell": "        } else {\n            //  Determine how much to increment\n            final String incrementObj = params.get( PARAM_INCREMENT );\n            int increment = 1;\n            if( incrementObj != null ) {\n                increment = Integer.parseInt( incrementObj );\n            }", "refactored_code": "    private static final int     DEFAULT_INCREMENT   = 1;\n        } else {\n            //  Determine how much to increment\n            final String incrementObj = params.get( PARAM_INCREMENT );\n            int increment = DEFAULT_INCREMENT;\n            if( incrementObj != null ) {\n                increment = Integer.parseInt( incrementObj );\n            }"}
{"magic_number_smell": "\n            // backup counters every 5 minutes\n            if( m_pageCountSaveThread == null ) {\n                m_pageCountSaveThread = new CounterSaveThread( engine, 5 * 60, this );\n                m_pageCountSaveThread.start();\n            }\n", "refactored_code": "    private static final int STORAGE_INTERVAL = 60;\n\n            // backup counters every 5 minutes\n            if( m_pageCountSaveThread == null ) {\n                m_pageCountSaveThread = new CounterSaveThread( engine, 5 * STORAGE_INTERVAL, this );\n                m_pageCountSaveThread.start();\n            }\n"}
{"magic_number_smell": "     */\n    @Override\n    public String execute( final Context context, final Map< String, String > params ) throws PluginException {\n        final int since = TextUtil.parseIntParameter( params.get( \"since\" ), 100*365 );\n        String spacing  = \"4\";\n        boolean showAuthor = true;\n        boolean showChangenote = true;", "refactored_code": "    private static final int   DEFAULT_DAYS = 100*365;\n     */\n    @Override\n    public String execute( final Context context, final Map< String, String > params ) throws PluginException {\n        final int since = TextUtil.parseIntParameter( params.get( \"since\" ), DEFAULT_DAYS );\n        String spacing  = \"4\";\n        boolean showAuthor = true;\n        boolean showChangenote = true;"}
{"magic_number_smell": "            m_formatSort = true  ;\n        }\n\n        m_depth = TextUtil.parseIntParameter( params.get( PARAM_DEPTH ), 1 );\n        if( m_depth > MAX_DEPTH ) {\n            m_depth = MAX_DEPTH;\n        }", "refactored_code": "    public static final int MIN_DEPTH = 1;\n            m_formatSort = true  ;\n        }\n\n        m_depth = TextUtil.parseIntParameter( params.get( PARAM_DEPTH ), MIN_DEPTH );\n        if( m_depth > MAX_DEPTH ) {\n            m_depth = MAX_DEPTH;\n        }"}
{"magic_number_smell": "\n        //  Find the first page that has no page lock.\n        int idx = max + 1;\n        while( idx < 10_000 ) {\n            final Page page = Wiki.contents().page( engine, WeblogPlugin.makeEntryPage( baseName, date, Integer.toString( idx ) ) );\n            final PageLock lock = engine.getManager( PageManager.class ).getCurrentLock(page);\n            if (lock == null) {", "refactored_code": "    private static final int MAX_BLOG_ENTRIES = 10_000; // Just a precaution.\n\n        //  Find the first page that has no page lock.\n        int idx = max + 1;\n        while( idx < MAX_BLOG_ENTRIES ) {\n            final Page page = Wiki.contents().page( engine, WeblogPlugin.makeEntryPage( baseName, date, Integer.toString( idx ) ) );\n            final PageLock lock = engine.getManager( PageManager.class ).getCurrentLock(page);\n            if (lock == null) {"}
{"magic_number_smell": "    public String execute( final Context context, final Map< String, String > params ) throws PluginException {\n        final Calendar   startTime;\n        final Calendar   stopTime;\n        int        numDays = 7;\n        final Engine engine = context.getEngine();\n        final AuthorizationManager mgr = engine.getManager( AuthorizationManager.class );\n", "refactored_code": "    private static final int     DEFAULT_DAYS = 7;\n    public String execute( final Context context, final Map< String, String > params ) throws PluginException {\n        final Calendar   startTime;\n        final Calendar   stopTime;\n        int        numDays = DEFAULT_DAYS;\n        final Engine engine = context.getEngine();\n        final AuthorizationManager mgr = engine.getManager( AuthorizationManager.class );\n"}
{"magic_number_smell": "    public static final int DEFAULT_MAX_PROPVALUELENGTH = 4096;\n\n    /** This parameter limits the number of custom page properties allowed on a page */\n    public static int MAX_PROPLIMIT = 200;\n\n    /**\n     * This number limits the length of a custom page property key length. The default value here designed with future JDBC providers in mind.", "refactored_code": "    public static final int DEFAULT_MAX_PROPLIMIT = 200;\n    public static final int DEFAULT_MAX_PROPVALUELENGTH = 4096;\n\n    /** This parameter limits the number of custom page properties allowed on a page */\n    public static int MAX_PROPLIMIT = DEFAULT_MAX_PROPLIMIT;\n\n    /**\n     * This number limits the length of a custom page property key length. The default value here designed with future JDBC providers in mind."}
{"magic_number_smell": "\n            final long ver = in.readLong();\n\n            if( ver != 4L ) {\n                throw new IOException(\"File format has changed; I need to recalculate references.\");\n            }\n", "refactored_code": "    private static final long serialVersionUID = 4L;\n\n            final long ver = in.readLong();\n\n            if( ver != serialVersionUID ) {\n                throw new IOException(\"File format has changed; I need to recalculate references.\");\n            }\n"}
{"magic_number_smell": "            //  Description\n            if( firstLine > 0 ) {\n                int maxlen = pageText.length();\n                if( maxlen > Integer.MAX_VALUE-1 ) {\n                    maxlen = Integer.MAX_VALUE-1;\n                }\n                pageText = m_engine.getManager( RenderingManager.class ).textToHTML( wikiContext, pageText.substring( firstLine + 1, maxlen ).trim() );", "refactored_code": "    private static final int MAX_CHARACTERS = Integer.MAX_VALUE-1;\n            //  Description\n            if( firstLine > 0 ) {\n                int maxlen = pageText.length();\n                if( maxlen > MAX_CHARACTERS ) {\n                    maxlen = MAX_CHARACTERS;\n                }\n                pageText = m_engine.getManager( RenderingManager.class ).textToHTML( wikiContext, pageText.substring( firstLine + 1, maxlen ).trim() );"}
{"magic_number_smell": "        public static final String AJAX_ACTION_SUGGESTIONS = \"suggestions\";\n        public static final String AJAX_ACTION_PAGES = \"pages\";\n        public static final int 20 = 20;\n        public int maxResults = 20;\n\n        /** {@inheritDoc} */\n        @Override", "refactored_code": "        public static final int DEFAULT_MAX_RESULTS = 20;\n        public static final String AJAX_ACTION_SUGGESTIONS = \"suggestions\";\n        public static final String AJAX_ACTION_PAGES = \"pages\";\n        public static final int DEFAULT_MAX_RESULTS = 20;\n        public int maxResults = DEFAULT_MAX_RESULTS;\n\n        /** {@inheritDoc} */\n        @Override"}
{"magic_number_smell": "                        String[] fragments = new String[ 0 ];\n                        if( text != null && highlighter != null ) {\n                            final TokenStream tokenStream = getLuceneAnalyzer().tokenStream( LUCENE_PAGE_CONTENTS, new StringReader( text ) );\n                            fragments = highlighter.getBestFragments( tokenStream, text, 3 );\n                        }\n\n                        final SearchResult result = new SearchResultImpl( page, score, fragments );", "refactored_code": "    private static final int MAX_FRAGMENTS = 3;\n                        String[] fragments = new String[ 0 ];\n                        if( text != null && highlighter != null ) {\n                            final TokenStream tokenStream = getLuceneAnalyzer().tokenStream( LUCENE_PAGE_CONTENTS, new StringReader( text ) );\n                            fragments = highlighter.getBestFragments( tokenStream, text, MAX_FRAGMENTS );\n                        }\n\n                        final SearchResult result = new SearchResultImpl( page, score, fragments );"}
{"magic_number_smell": "     */\n    public static class FixedQueue extends LinkedList< String > implements Serializable {\n        private final int m_size;\n        private static final long 0L = 0L;\n\n        FixedQueue( final int size ) {\n            m_size = size;", "refactored_code": "    private static final long serialVersionUID = 0L;\n     */\n    public static class FixedQueue extends LinkedList< String > implements Serializable {\n        private final int m_size;\n        private static final long serialVersionUID = 0L;\n\n        FixedQueue( final int size ) {\n            m_size = size;"}
{"magic_number_smell": "    }\n\n    /**\n     * Validates a string against the {@link #0} validator and additionally checks that the value is not <code>null</code> or blank.\n     *\n     * @param input the string to validate\n     * @param label the label for the string or field (\"E-mail address\")", "refactored_code": "    public static final int STANDARD = 0;\n    }\n\n    /**\n     * Validates a string against the {@link #STANDARD} validator and additionally checks that the value is not <code>null</code> or blank.\n     *\n     * @param input the string to validate\n     * @param label the label for the string or field (\"E-mail address\")"}
{"magic_number_smell": "\n        public JSPWikiServletResponseWrapper( final HttpServletResponse r, final String wikiEncoding, final boolean useEncoding ) throws UnsupportedEncodingException {\n            super( r );\n            m_output = new ByteArrayOutputStream( 0x8000 );\n            m_servletOut = new ByteArrayServletOutputStream( m_output );\n            m_writer = new PrintWriter( new OutputStreamWriter( m_servletOut, wikiEncoding ), true );\n            this.useEncoding = useEncoding;", "refactored_code": "        private static final int INIT_BUFFER_SIZE = 0x8000;\n\n        public JSPWikiServletResponseWrapper( final HttpServletResponse r, final String wikiEncoding, final boolean useEncoding ) throws UnsupportedEncodingException {\n            super( r );\n            m_output = new ByteArrayOutputStream( INIT_BUFFER_SIZE );\n            m_servletOut = new ByteArrayServletOutputStream( m_output );\n            m_writer = new PrintWriter( new OutputStreamWriter( m_servletOut, wikiEncoding ), true );\n            this.useEncoding = useEncoding;"}
{"magic_number_smell": "    /** Status: The PI is finished. */\n    public static final int FINISHED = 3;\n\n    protected int m_state = 0;\n\n    /**\n     *  Get the state of the ProgressItem.", "refactored_code": "    public static final int CREATED  = 0;\n    /** Status: The PI is finished. */\n    public static final int FINISHED = 3;\n\n    protected int m_state = CREATED;\n\n    /**\n     *  Get the state of the ProgressItem."}
{"magic_number_smell": "        sw.start();\n        try( final ObjectInputStream in = new ObjectInputStream( new BufferedInputStream( Files.newInputStream( f.toPath() ) ) ) ) {\n            final long ver = in.readLong();\n            if( ver != 6L ) {\n                LOG.warn( \"File format has changed; Unable to recover workflows and decision queue from disk.\" );\n            } else {\n                saved        = in.readLong();", "refactored_code": "    private static final long serialVersionUID = 6L;\n        sw.start();\n        try( final ObjectInputStream in = new ObjectInputStream( new BufferedInputStream( Files.newInputStream( f.toPath() ) ) ) ) {\n            final long ver = in.readLong();\n            if( ver != serialVersionUID ) {\n                LOG.warn( \"File format has changed; Unable to recover workflows and decision queue from disk.\" );\n            } else {\n                saved        = in.readLong();"}
{"magic_number_smell": "        // Create HTTP listener\n        final NetworkTrafficServerConnector connector = new NetworkTrafficServerConnector( server );\n        connector.setHost( \"localhost\" );\n        connector.setPort( 10024 );\n        connector.setIdleTimeout( 60_000 );\n\n        server.setConnectors( new Connector[] {connector} );", "refactored_code": "    public static final int HTTP_PORT = 10024;\n        // Create HTTP listener\n        final NetworkTrafficServerConnector connector = new NetworkTrafficServerConnector( server );\n        connector.setHost( \"localhost\" );\n        connector.setPort( HTTP_PORT );\n        connector.setIdleTimeout( 60_000 );\n\n        server.setConnectors( new Connector[] {connector} );"}
{"magic_number_smell": "    /** Sample Task that encounters an error during processing. */\n    public static class ErrorTask extends Task {\n\n        private static final long 1L = 1L;\n\n        public ErrorTask( final Workflow workflow ) {\n            super( workflow.getId(), workflow.getAttributes(), \"task.error\" );", "refactored_code": "        private static final long serialVersionUID = 1L;\n    /** Sample Task that encounters an error during processing. */\n    public static class ErrorTask extends Task {\n\n        private static final long serialVersionUID = 1L;\n\n        public ErrorTask( final Workflow workflow ) {\n            super( workflow.getId(), workflow.getAttributes(), \"task.error\" );"}
{"magic_number_smell": "     * Creates an RFC 2307-compliant salted, hashed password with the SHA1 or SHA-256\n     * MessageDigest algorithm. After the password is digested, the first 20 or 32\n     * bytes of the digest will be the actual password hash; the remaining bytes\n     * will be a randomly generated salt of length {@link #8},\n     * for example: <blockquote><code>{SSHA}3cGWem65NCEkF5Ew5AEk45ak8LHUWAwPVXAyyw==</code></blockquote>\n     * </p>\n     * <p>", "refactored_code": "    private static final int DEFAULT_SALT_SIZE = 8;\n     * Creates an RFC 2307-compliant salted, hashed password with the SHA1 or SHA-256\n     * MessageDigest algorithm. After the password is digested, the first 20 or 32\n     * bytes of the digest will be the actual password hash; the remaining bytes\n     * will be a randomly generated salt of length {@link #DEFAULT_SALT_SIZE},\n     * for example: <blockquote><code>{SSHA}3cGWem65NCEkF5Ew5AEk45ak8LHUWAwPVXAyyw==</code></blockquote>\n     * </p>\n     * <p>"}
{"magic_number_smell": "     *  @throws IOException If reading or writing failed.\n     */\n    public static void copyContents( final Reader in, final Writer out ) throws IOException {\n        final char[] buf = new char[8192];\n        int bytesRead;\n        while( ( bytesRead = in.read( buf ) ) > 0 ) {\n            out.write( buf, 0, bytesRead );", "refactored_code": "    private static final int      BUFFER_SIZE = 8192;\n     *  @throws IOException If reading or writing failed.\n     */\n    public static void copyContents( final Reader in, final Writer out ) throws IOException {\n        final char[] buf = new char[BUFFER_SIZE];\n        int bytesRead;\n        while( ( bytesRead = in.read( buf ) ) > 0 ) {\n            out.write( buf, 0, bytesRead );"}
{"magic_number_smell": "                return false;\n            }\n            final int ch = name.charAt( i );\n            final boolean isDigit = ch >= 48 && ch <= NINE;\n            final boolean isDot = ch == DOT;\n            if( !isDigit && !isDot ) {\n                return false;", "refactored_code": "    private static final int    ONE                   = 48;\n                return false;\n            }\n            final int ch = name.charAt( i );\n            final boolean isDigit = ch >= ONE && ch <= NINE;\n            final boolean isDot = ch == DOT;\n            if( !isDigit && !isDot ) {\n                return false;"}
{"magic_number_smell": "    @Override\n    public boolean add(final E o )\n    {\n        add( o, 0 );\n\n        return true;\n    }", "refactored_code": "    public static final int DEFAULT_PRIORITY = 0;\n    @Override\n    public boolean add(final E o )\n    {\n        add( o, DEFAULT_PRIORITY );\n\n        return true;\n    }"}
{"magic_number_smell": "     * @since 2.4\n     */\n    public static String generateRandomPassword() {\n        return IntStream.range(0, 8).map(i -> (int) (RANDOM.nextDouble() * PWD_BASE.length())).mapToObj(index -> String.valueOf(PWD_BASE.charAt(index))).collect(Collectors.joining());\n    }\n\n}", "refactored_code": "    public static final int PASSWORD_LENGTH = 8;\n     * @since 2.4\n     */\n    public static String generateRandomPassword() {\n        return IntStream.range(0, PASSWORD_LENGTH).map(i -> (int) (RANDOM.nextDouble() * PWD_BASE.length())).mapToObj(index -> String.valueOf(PWD_BASE.charAt(index))).collect(Collectors.joining());\n    }\n\n}"}
{"magic_number_smell": "\n    private static String versionString()\n    {\n        return join( Arrays.asList( Integer.toString( 1 ),\n                                    Integer.toString( MINOR ),\n                                    Integer.toString( TINY ) ),\n                     \".\" );", "refactored_code": "    public static final int MAJOR = 1;\n\n    private static String versionString()\n    {\n        return join( Arrays.asList( Integer.toString( MAJOR ),\n                                    Integer.toString( MINOR ),\n                                    Integer.toString( TINY ) ),\n                     \".\" );"}
{"magic_number_smell": "  public static double noise(double xin, double yin) {\n    double n0, n1, n2; // Noise contributions from the three corners\n    // Skew the input space to determine which simplex cell we're in\n    double s = (xin+yin)*0.5*(Math.sqrt(3.0)-1.0); // Hairy factor for 2D\n    int i = fastfloor(xin+s);\n    int j = fastfloor(yin+s);\n    double t = (i+j)*G2;", "refactored_code": "  private static final double F2 = 0.5*(Math.sqrt(3.0)-1.0);\n  public static double noise(double xin, double yin) {\n    double n0, n1, n2; // Noise contributions from the three corners\n    // Skew the input space to determine which simplex cell we're in\n    double s = (xin+yin)*F2; // Hairy factor for 2D\n    int i = fastfloor(xin+s);\n    int j = fastfloor(yin+s);\n    double t = (i+j)*G2;"}
{"magic_number_smell": "\tprivate Configuration.EnginePath installDirectory;\n\tprivate Configuration.DownloadPath downloadDirectory;\n\t\n\tprivate ExecutorService activeDownloaders = Executors.newFixedThreadPool(1);\n\tprivate ExecutorService activeInspectors = Executors.newFixedThreadPool(simultanousInspectors);\n\tprivate ExecutorService activeInstallers = Executors.newFixedThreadPool(simultanousInstalls);\n\tprivate ExecutorService activeWaiters = Executors.newFixedThreadPool(simultanousWaiters);", "refactored_code": "\tprivate static final int simultanousDownloads = 1;\n\tprivate Configuration.EnginePath installDirectory;\n\tprivate Configuration.DownloadPath downloadDirectory;\n\t\n\tprivate ExecutorService activeDownloaders = Executors.newFixedThreadPool(simultanousDownloads);\n\tprivate ExecutorService activeInspectors = Executors.newFixedThreadPool(simultanousInspectors);\n\tprivate ExecutorService activeInstallers = Executors.newFixedThreadPool(simultanousInstalls);\n\tprivate ExecutorService activeWaiters = Executors.newFixedThreadPool(simultanousWaiters);"}
{"magic_number_smell": "public class PackageTable extends JTable {\n\tprivate static final int 10 = 10;\n\tprivate static final Color NORMALROWCOLOR = UIManager.getColor(\"Table.background\");\n\tprivate static final Color ALTERNATINGROWCOLOR = createAlternatingColor(NORMALROWCOLOR, 10);\n\tprivate static final int CELLPADDING = 2;\n\n\tprivate final EmptyBorder border = new EmptyBorder(0, CELLPADDING, 0, CELLPADDING);", "refactored_code": "\tprivate static final int ALTERNATING = 10;\npublic class PackageTable extends JTable {\n\tprivate static final int ALTERNATING = 10;\n\tprivate static final Color NORMALROWCOLOR = UIManager.getColor(\"Table.background\");\n\tprivate static final Color ALTERNATINGROWCOLOR = createAlternatingColor(NORMALROWCOLOR, ALTERNATING);\n\tprivate static final int CELLPADDING = 2;\n\n\tprivate final EmptyBorder border = new EmptyBorder(0, CELLPADDING, 0, CELLPADDING);"}
{"magic_number_smell": "\t\tmenu = createMenuBar();\n\t\tsetJMenuBar(menu);\n\n\t\tsetMinimumSize(new Dimension(300, minHeight));\n\t\t\n\t\tConfiguration cfg = null;\n\t\ttry {", "refactored_code": "\tprivate static final int minWidth = 300;\n\t\tmenu = createMenuBar();\n\t\tsetJMenuBar(menu);\n\n\t\tsetMinimumSize(new Dimension(minWidth, minHeight));\n\t\t\n\t\tConfiguration cfg = null;\n\t\ttry {"}
{"magic_number_smell": "\t */\n\tpublic static long writeFile(final InputStream in,\n\t                       final File file,\n\t                       final int 4096,\n\t                       final ProgressListener progress) throws IOException {\n\t\tfinal BufferedOutputStream dest = new BufferedOutputStream(new FileOutputStream(file),\n\t\t                                                           4096);", "refactored_code": "\tpublic static final int BUFFERSIZE = 4096;\n\t */\n\tpublic static long writeFile(final InputStream in,\n\t                       final File file,\n\t                       final int BUFFERSIZE,\n\t                       final ProgressListener progress) throws IOException {\n\t\tfinal BufferedOutputStream dest = new BufferedOutputStream(new FileOutputStream(file),\n\t\t                                                           BUFFERSIZE);"}
{"magic_number_smell": "public class LookAndFeelDefaults extends JPanel {\n\tpublic static final int 7 = 7;\n\n\tpublic static final Border PADDINGBORDER = BorderFactory.createEmptyBorder(7,\n\t                                                                           7,\n\t                                                                           0,\n\t                                                                           7);", "refactored_code": "\tpublic static final int FRAMEPADDING = 7;\npublic class LookAndFeelDefaults extends JPanel {\n\tpublic static final int FRAMEPADDING = 7;\n\n\tpublic static final Border PADDINGBORDER = BorderFactory.createEmptyBorder(FRAMEPADDING,\n\t                                                                           FRAMEPADDING,\n\t                                                                           0,\n\t                                                                           FRAMEPADDING);"}
{"magic_number_smell": "\t\t\t\n\t\t\tEmptyBorder border = new EmptyBorder(0,0,0,0);\n\t\t\tsetBorder(border);\n\t\t\t((FlowLayout) getLayout()).setHgap(2);\n\t\t\t((FlowLayout) getLayout()).setVgap(4);\n\n\t\t\tfor (int i = 0; i < 5; ++i) {", "refactored_code": "\t\tprivate static final int HORIZONTALGAP = 2;\n\t\t\t\n\t\t\tEmptyBorder border = new EmptyBorder(0,0,0,0);\n\t\t\tsetBorder(border);\n\t\t\t((FlowLayout) getLayout()).setHgap(HORIZONTALGAP);\n\t\t\t((FlowLayout) getLayout()).setVgap(4);\n\n\t\t\tfor (int i = 0; i < 5; ++i) {"}
{"magic_number_smell": "\t\t\tposition++;\n\t\t\toffsets[i] = position;\n\t\t\tswitch (type) {\n\t\t\tcase 1:\n\t\t\t\tint length = readValue(position);\n\t\t\t\tposition += 2;\n\t\t\t\tutf8s[i] = decodeString(position, length);", "refactored_code": "\tprivate static final byte UTF8 = 1;\n\t\t\tposition++;\n\t\t\toffsets[i] = position;\n\t\t\tswitch (type) {\n\t\t\tcase UTF8:\n\t\t\t\tint length = readValue(position);\n\t\t\t\tposition += 2;\n\t\t\t\tutf8s[i] = decodeString(position, length);"}
{"magic_number_smell": "\tpublic static CheckerFrameworkVersion valueOf(String versionString) {\n\t\tif (versionString != null) versionString = versionString.trim();\n\t\tif (versionString == null || versionString.equalsIgnoreCase(\"false\") || versionString.equals(\"0\")) return new CheckerFrameworkVersion(0);\n\t\tif (versionString.equalsIgnoreCase(\"true\")) return new CheckerFrameworkVersion(3200);\n\t\tMatcher m = VERSION.matcher(versionString);\n\t\tif (!m.matches()) throw new IllegalArgumentException(\"Expected 'true' or 'false' or a major/minor version, such as '2.9'\");\n\t\tint major = Integer.parseInt(m.group(1));", "refactored_code": "\tprivate static final int DEFAULT = 3200;\n\tpublic static CheckerFrameworkVersion valueOf(String versionString) {\n\t\tif (versionString != null) versionString = versionString.trim();\n\t\tif (versionString == null || versionString.equalsIgnoreCase(\"false\") || versionString.equals(\"0\")) return new CheckerFrameworkVersion(0);\n\t\tif (versionString.equalsIgnoreCase(\"true\")) return new CheckerFrameworkVersion(DEFAULT);\n\t\tMatcher m = VERSION.matcher(versionString);\n\t\tif (!m.matches()) throw new IllegalArgumentException(\"Expected 'true' or 'false' or a major/minor version, such as '2.9'\");\n\t\tint major = Integer.parseInt(m.group(1));"}
{"magic_number_smell": "\t\t// Still, eventually that's going to cause a bit of a memory leak, so lets just completely clear them out every many minutes.\n\t\tlong now = System.currentTimeMillis();\n\t\tlong delta = now - lastCacheClear;\n\t\tif (delta > TimeUnit.MINUTES.toMillis(30)) {\n\t\t\tlastCacheClear = now;\n\t\t\tfileCache.clear();\n\t\t\turiCache.clear();", "refactored_code": "\tprivate static final long FULL_CACHE_CLEAR_INTERVAL = TimeUnit.MINUTES.toMillis(30);\n\t\t// Still, eventually that's going to cause a bit of a memory leak, so lets just completely clear them out every many minutes.\n\t\tlong now = System.currentTimeMillis();\n\t\tlong delta = now - lastCacheClear;\n\t\tif (delta > FULL_CACHE_CLEAR_INTERVAL) {\n\t\t\tlastCacheClear = now;\n\t\t\tfileCache.clear();\n\t\t\turiCache.clear();"}
{"magic_number_smell": "\t\tlong now = System.currentTimeMillis();\n\t\tlong delta = end - startToken;\n\t\tif (delta < 0L) delta = 0L;\n\t\tint interval = (int) (now / 1000 * 60);\n\t\tint[] currentInterval = {0};\n\t\tlong[] bars = this.bars.get(currentInterval);\n\t\tlong[] newBars;", "refactored_code": "\tprivate static final long REPORT_WINDOW = 1000 * 60;\n\t\tlong now = System.currentTimeMillis();\n\t\tlong delta = end - startToken;\n\t\tif (delta < 0L) delta = 0L;\n\t\tint interval = (int) (now / REPORT_WINDOW);\n\t\tint[] currentInterval = {0};\n\t\tlong[] bars = this.bars.get(currentInterval);\n\t\tlong[] newBars;"}
{"magic_number_smell": "\t\t\t\tif (squelchTimeout > now) return;\n\t\t\t\tsquelchTimeout = now + SQUELCH_TIMEOUT;\n\t\t\t\tprintSquelchWarning = true;\n\t\t\t} else if (ct >= 200) {\n\t\t\t\tsquelchTimeout = System.currentTimeMillis() + SQUELCH_TIMEOUT;\n\t\t\t\tprintSquelchWarning = true;\n\t\t\t}", "refactored_code": "\t\tprivate static final int MAX_LOG = 200;\n\t\t\t\tif (squelchTimeout > now) return;\n\t\t\t\tsquelchTimeout = now + SQUELCH_TIMEOUT;\n\t\t\t\tprintSquelchWarning = true;\n\t\t\t} else if (ct >= MAX_LOG) {\n\t\t\t\tsquelchTimeout = System.currentTimeMillis() + SQUELCH_TIMEOUT;\n\t\t\t\tprintSquelchWarning = true;\n\t\t\t}"}
{"magic_number_smell": "\t\t\tfilled = true;\n\t\t}\n\t\t\n\t\tif ((td.modifiers & ClassFileConstants.AccInterface | ClassFileConstants.AccStatic | ClassFileConstants.AccEnum | Eclipse.AccRecord) != 0) return filled; // Once we hit a static class, no further typeparams needed.\n\t\tboolean f2 = fillOuterTypeParams(rr, idx - 1, node.up(), p);\n\t\treturn f2 || filled;\n\t}", "refactored_code": "\tprivate static final int MODIFIERS_INDICATING_STATIC = ClassFileConstants.AccInterface | ClassFileConstants.AccStatic | ClassFileConstants.AccEnum | Eclipse.AccRecord;\n\t\t\tfilled = true;\n\t\t}\n\t\t\n\t\tif ((td.modifiers & MODIFIERS_INDICATING_STATIC) != 0) return filled; // Once we hit a static class, no further typeparams needed.\n\t\tboolean f2 = fillOuterTypeParams(rr, idx - 1, node.up(), p);\n\t\treturn f2 || filled;\n\t}"}
{"magic_number_smell": "\t\tthis.source = source;\n\t\tthis.sourceStart = this.source.sourceStart;\n\t\tthis.sourceEnd = this.source.sourceEnd;\n\t\tthis.sourcePos = (long)sourceStart << 32 | (sourceEnd & 0x00000000FFFFFFFFL);\n\t}\n\t\n\tprivate void fixPositions(JavadocAllocationExpression node) {", "refactored_code": "\tprivate static final long INT_TO_LONG_MASK = 0x00000000FFFFFFFFL;\n\t\tthis.source = source;\n\t\tthis.sourceStart = this.source.sourceStart;\n\t\tthis.sourceEnd = this.source.sourceEnd;\n\t\tthis.sourcePos = (long)sourceStart << 32 | (sourceEnd & INT_TO_LONG_MASK);\n\t}\n\t\n\tprivate void fixPositions(JavadocAllocationExpression node) {"}
{"magic_number_smell": "\t\tif ((v & SEALED) != 0) print(\"sealed \");\n\t\tif ((v & NON_SEALED) != 0) print(\"non-sealed \");\n\t\tif ((v & STRICTFP) != 0) print(\"strictfp \");\n\t\tif ((v & 1L<<43) != 0 && (v & INTERFACE) == 0) print(\"default \");\n\t}\n\t\n\t@Override public void visitSelect(JCFieldAccess tree) {", "refactored_code": "\tprivate static final long DEFAULT = 1L<<43;\n\t\tif ((v & SEALED) != 0) print(\"sealed \");\n\t\tif ((v & NON_SEALED) != 0) print(\"non-sealed \");\n\t\tif ((v & STRICTFP) != 0) print(\"strictfp \");\n\t\tif ((v & DEFAULT) != 0 && (v & INTERFACE) == 0) print(\"default \");\n\t}\n\t\n\t@Override public void visitSelect(JCFieldAccess tree) {"}
{"magic_number_smell": "\t\t\n\t\tpublic static boolean checkBit24(Object node) throws Exception {\n\t\t\tint bits = (Integer)(node.getClass().getField(\"bits\").get(node));\n\t\t\treturn (bits & 0x800000) != 0;\n\t\t}\n\t\t\n\t\tpublic static boolean skipRewritingGeneratedNodes(org.eclipse.jdt.core.dom.ASTNode node) throws Exception {", "refactored_code": "\t\tpublic static final int ALREADY_PROCESSED_FLAG = 0x800000;  //Bit 24\n\t\t\n\t\tpublic static boolean checkBit24(Object node) throws Exception {\n\t\t\tint bits = (Integer)(node.getClass().getField(\"bits\").get(node));\n\t\t\treturn (bits & ALREADY_PROCESSED_FLAG) != 0;\n\t\t}\n\t\t\n\t\tpublic static boolean skipRewritingGeneratedNodes(org.eclipse.jdt.core.dom.ASTNode node) throws Exception {"}
{"magic_number_smell": "\t\tconstraints.gridy = 2;\n\t\tcontainer.add(buttonBar, constraints);\n\t\t\n\t\tcontainer.setPreferredSize(new Dimension(662, 415));\n\t\tcontainer.setMinimumSize(new Dimension(662, 415));\n\t\treturn container;\n\t}", "refactored_code": "\tprivate static final int INSTALLER_WINDOW_WIDTH = 662;\n\t\tconstraints.gridy = 2;\n\t\tcontainer.add(buttonBar, constraints);\n\t\t\n\t\tcontainer.setPreferredSize(new Dimension(INSTALLER_WINDOW_WIDTH, 415));\n\t\tcontainer.setMinimumSize(new Dimension(INSTALLER_WINDOW_WIDTH, 415));\n\t\treturn container;\n\t}"}
{"magic_number_smell": "\t\t\tposition++;\n\t\t\toffsets[i] = position;\n\t\t\tswitch (type) {\n\t\t\tcase 1:\n\t\t\t\tint length = readValue(position);\n\t\t\t\tposition += 2;\n\t\t\t\tutf8s[i] = decodeString(position, length);", "refactored_code": "\tprivate static final byte UTF8 = 1;\n\t\t\tposition++;\n\t\t\toffsets[i] = position;\n\t\t\tswitch (type) {\n\t\t\tcase UTF8:\n\t\t\t\tint length = readValue(position);\n\t\t\t\tposition += 2;\n\t\t\t\tutf8s[i] = decodeString(position, length);"}
{"magic_number_smell": "\t\tint[] startPoints = new int[260];\n\t\tint maxStartPoints;\n\t\t\n\t\tfor (int offset : md.getOffsets(1)) {\n\t\t\tint len = readValue(b, offset);\n\t\t\toffset += 2;\n\t\t\tstartPoints[0] = offset;", "refactored_code": "\tprivate static final byte CONSTANTPOOLTYPE_UTF8 = 1;\n\t\tint[] startPoints = new int[260];\n\t\tint maxStartPoints;\n\t\t\n\t\tfor (int offset : md.getOffsets(CONSTANTPOOLTYPE_UTF8)) {\n\t\t\tint len = readValue(b, offset);\n\t\t\toffset += 2;\n\t\t\tstartPoints[0] = offset;"}
{"magic_number_smell": "\t}\n\t\n\tprivate void go(boolean open) throws Exception {\n\t\tport(4569);\n\t\tget(\"/\", serve(\"index.html\"));\n\t\tget(\"/setup/overview\", serve(\"setup/index.html\"));\n\t\tget(\"/setup\", serve(\"setup/index.html\"));", "refactored_code": "\tprivate static final int DEFAULT_PORT = 4569;\n\t}\n\t\n\tprivate void go(boolean open) throws Exception {\n\t\tport(DEFAULT_PORT);\n\t\tget(\"/\", serve(\"index.html\"));\n\t\tget(\"/setup/overview\", serve(\"setup/index.html\"));\n\t\tget(\"/setup\", serve(\"setup/index.html\"));"}
{"magic_number_smell": "\t}\n\t@java.lang.SuppressWarnings(\"all\")\n\tpublic int getZero() {\n\t\treturn this.0;\n\t}\n\t@java.lang.Override\n\t@java.lang.SuppressWarnings(\"all\")", "refactored_code": "\tprivate final int zero = 0;\n\t}\n\t@java.lang.SuppressWarnings(\"all\")\n\tpublic int getZero() {\n\t\treturn this.zero;\n\t}\n\t@java.lang.Override\n\t@java.lang.SuppressWarnings(\"all\")"}
{"magic_number_smell": "\t}\n\t@java.lang.SuppressWarnings(\"all\")\n\tpublic int getZero() {\n\t\treturn this.0;\n\t}\n\t@java.lang.Override\n\t@java.lang.SuppressWarnings(\"all\")", "refactored_code": "\tprivate final int zero = 0;\n\t}\n\t@java.lang.SuppressWarnings(\"all\")\n\tpublic int getZero() {\n\t\treturn this.zero;\n\t}\n\t@java.lang.Override\n\t@java.lang.SuppressWarnings(\"all\")"}
{"magic_number_smell": "\tprivate static final int 20 = 20;\n\tpublic void testComplex() {\n\t\tfinal char[] shouldBeCharArray = field.toCharArray();\n\t\tfinal int shouldBeInt = 20;\n\t\tfinal java.lang.Object lock = new Object();\n\t\tsynchronized (lock) {\n\t\t\tfinal int field = 20; //Shadowing", "refactored_code": "\tprivate static final int CONSTANT = 20;\n\tprivate static final int CONSTANT = 20;\n\tpublic void testComplex() {\n\t\tfinal char[] shouldBeCharArray = field.toCharArray();\n\t\tfinal int shouldBeInt = CONSTANT;\n\t\tfinal java.lang.Object lock = new Object();\n\t\tsynchronized (lock) {\n\t\t\tfinal int field = 20; //Shadowing"}
{"magic_number_smell": "\tprivate static final int 20 = 20;\n\tpublic void testComplex() {\n\t\tchar[] shouldBeCharArray = field.toCharArray();\n\t\tint shouldBeInt = 20;\n\t\tjava.lang.Object lock = new Object();\n\t\tsynchronized (lock) {\n\t\t\tint field = 20; //Shadowing", "refactored_code": "\tprivate static final int CONSTANT = 20;\n\tprivate static final int CONSTANT = 20;\n\tpublic void testComplex() {\n\t\tchar[] shouldBeCharArray = field.toCharArray();\n\t\tint shouldBeInt = CONSTANT;\n\t\tjava.lang.Object lock = new Object();\n\t\tsynchronized (lock) {\n\t\t\tint field = 20; //Shadowing"}
{"magic_number_smell": "    return new BuilderAndValue.BuilderAndValueBuilder();\n  }\n  public @java.lang.SuppressWarnings(\"all\") int getZero() {\n    return this.0;\n  }\n  public @java.lang.Override @java.lang.SuppressWarnings(\"all\") boolean equals(final java.lang.Object o) {\n    if ((o == this))", "refactored_code": "  private final int zero = 0;\n    return new BuilderAndValue.BuilderAndValueBuilder();\n  }\n  public @java.lang.SuppressWarnings(\"all\") int getZero() {\n    return this.zero;\n  }\n  public @java.lang.Override @java.lang.SuppressWarnings(\"all\") boolean equals(final java.lang.Object o) {\n    if ((o == this))"}
{"magic_number_smell": "    return new BuilderAndValueWithSetterPrefix.BuilderAndValueWithSetterPrefixBuilder();\n  }\n  public @java.lang.SuppressWarnings(\"all\") int getZero() {\n    return this.0;\n  }\n  public @java.lang.Override @java.lang.SuppressWarnings(\"all\") boolean equals(final java.lang.Object o) {\n    if ((o == this))", "refactored_code": "  private final int zero = 0;\n    return new BuilderAndValueWithSetterPrefix.BuilderAndValueWithSetterPrefixBuilder();\n  }\n  public @java.lang.SuppressWarnings(\"all\") int getZero() {\n    return this.zero;\n  }\n  public @java.lang.Override @java.lang.SuppressWarnings(\"all\") boolean equals(final java.lang.Object o) {\n    if ((o == this))"}
{"magic_number_smell": "    }\n  }\n  int field1;\n  int 5;\n  int thirdField;\n  FieldNameConstantsHandrolled3() {\n    super();", "refactored_code": "    public static final int alsoAField = 5;\n    }\n  }\n  int field1;\n  int alsoAField;\n  int thirdField;\n  FieldNameConstantsHandrolled3() {\n    super();"}
{"magic_number_smell": "  }\n  public void testComplex() {\n    final @val char[] shouldBeCharArray = field.toCharArray();\n    final @val int shouldBeInt = 20;\n    final @val java.lang.Object lock = new Object();\n    synchronized (lock)\n      {", "refactored_code": "  private static final int CONSTANT = 20;\n  }\n  public void testComplex() {\n    final @val char[] shouldBeCharArray = field.toCharArray();\n    final @val int shouldBeInt = CONSTANT;\n    final @val java.lang.Object lock = new Object();\n    synchronized (lock)\n      {"}
{"magic_number_smell": "  }\n  public void testComplex() {\n    @var char[] shouldBeCharArray = field.toCharArray();\n    @var int shouldBeInt = 20;\n    @var java.lang.Object lock = new Object();\n    synchronized (lock)\n      {", "refactored_code": "  private static final int CONSTANT = 20;\n  }\n  public void testComplex() {\n    @var char[] shouldBeCharArray = field.toCharArray();\n    @var int shouldBeInt = CONSTANT;\n    @var java.lang.Object lock = new Object();\n    synchronized (lock)\n      {"}
{"magic_number_smell": "\n@lombok.Builder @lombok.Data\nclass BuilderAndData {\n\tprivate final int 0 = 0;\n}\n", "refactored_code": "\tprivate final int zero = 0;\n\n@lombok.Builder @lombok.Data\nclass BuilderAndData {\n\tprivate final int zero = 0;\n}\n"}
{"magic_number_smell": "\n@lombok.Builder(setterPrefix = \"with\") @lombok.Data\nclass BuilderAndDataWithSetterPrefix {\n\tprivate final int 0 = 0;\n}\n", "refactored_code": "\tprivate final int zero = 0;\n\n@lombok.Builder(setterPrefix = \"with\") @lombok.Data\nclass BuilderAndDataWithSetterPrefix {\n\tprivate final int zero = 0;\n}\n"}
{"magic_number_smell": "\t\n\tpublic void testComplex() {\n\t\tval shouldBeCharArray = field.toCharArray();\n\t\tval shouldBeInt = 20;\n\t\tval lock = new Object();\n\t\tsynchronized (lock) {\n\t\t\tval field = 20; //Shadowing", "refactored_code": "\tprivate static final int CONSTANT = 20;\n\t\n\tpublic void testComplex() {\n\t\tval shouldBeCharArray = field.toCharArray();\n\t\tval shouldBeInt = CONSTANT;\n\t\tval lock = new Object();\n\t\tsynchronized (lock) {\n\t\t\tval field = 20; //Shadowing"}
{"magic_number_smell": "\n\tpublic void testComplex() {\n\t\tvar shouldBeCharArray = field.toCharArray();\n\t\tvar shouldBeInt = 20;\n\t\tvar lock = new Object();\n\t\tsynchronized (lock) {\n\t\t\tvar field = 20; //Shadowing", "refactored_code": "\tprivate static final int CONSTANT = 20;\n\n\tpublic void testComplex() {\n\t\tvar shouldBeCharArray = field.toCharArray();\n\t\tvar shouldBeInt = CONSTANT;\n\t\tvar lock = new Object();\n\t\tsynchronized (lock) {\n\t\t\tvar field = 20; //Shadowing"}
{"magic_number_smell": "\t\tString tmaxString = (String) tmaxTable_.get(metricName);\n\t\tif (tmaxString == null)\n\t\t{\n\t\t\treturn 60;\n\t\t}\n\t\telse\n\t\t{", "refactored_code": "\tprivate static final int DEFAULT_TMAX = 60;\n\t\tString tmaxString = (String) tmaxTable_.get(metricName);\n\t\tif (tmaxString == null)\n\t\t{\n\t\t\treturn DEFAULT_TMAX;\n\t\t}\n\t\telse\n\t\t{"}
{"magic_number_smell": "        }\n        else\n        {\n            css.thriftPort = 9160;\n        }\n    }\n}", "refactored_code": "    private static final int    DEFAULT_THRIFT_PORT = 9160;\n        }\n        else\n        {\n            css.thriftPort = DEFAULT_THRIFT_PORT;\n        }\n    }\n}"}
{"magic_number_smell": "    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n    private final static ThreadLocal<IContinuable> tls_ = new ThreadLocal<IContinuable>();\n    private static final int Integer.SIZE - 3 = Integer.SIZE - 3;\n    private static final int CAPACITY = (1 << Integer.SIZE - 3) - 1;\n\n    // runState is stored in the high-order bits\n    private static final int RUNNING = -1 << Integer.SIZE - 3;", "refactored_code": "    private static final int COUNT_BITS = Integer.SIZE - 3;\n    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n    private final static ThreadLocal<IContinuable> tls_ = new ThreadLocal<IContinuable>();\n    private static final int COUNT_BITS = Integer.SIZE - 3;\n    private static final int CAPACITY = (1 << COUNT_BITS) - 1;\n\n    // runState is stored in the high-order bits\n    private static final int RUNNING = -1 << COUNT_BITS;"}
{"magic_number_smell": "                    // For each bucket if it has crossed the threshhold do the compaction\n                    // In case of range  compaction merge the counting bloom filters also.\n                    if( count == threshHold_)\n                        doFileCompaction(files, 128*1024*1024);\n\t    \t\t}\n\t    \t}\n        }", "refactored_code": "    private static final int bufSize_ = 128*1024*1024;\n                    // For each bucket if it has crossed the threshhold do the compaction\n                    // In case of range  compaction merge the counting bloom filters also.\n                    if( count == threshHold_)\n                        doFileCompaction(files, bufSize_);\n\t    \t\t}\n\t    \t}\n        }"}
{"magic_number_smell": "        {\n            /* Add this to the threshold */\n            int bufSize = 4*1024*1024;\n            return SequenceFile.fastWriter(file, CommitLog.128*1024*1024 + bufSize);\n        }\n        else\n            return SequenceFile.writer(file);", "refactored_code": "    private static final int bufSize_ = 128*1024*1024;\n        {\n            /* Add this to the threshold */\n            int bufSize = 4*1024*1024;\n            return SequenceFile.fastWriter(file, CommitLog.bufSize_ + bufSize);\n        }\n        else\n            return SequenceFile.writer(file);"}
{"magic_number_smell": "        ArrivalWindow hbWnd = arrivalSamples_.get(ep);\n        if ( hbWnd == null )\n        {\n            hbWnd = new ArrivalWindow(1000);\n            arrivalSamples_.put(ep, hbWnd);\n        }\n        hbWnd.add(now);  ", "refactored_code": "    private static final int sampleSize_ = 1000;\n        ArrivalWindow hbWnd = arrivalSamples_.get(ep);\n        if ( hbWnd == null )\n        {\n            hbWnd = new ArrivalWindow(sampleSize_);\n            arrivalSamples_.put(ep, hbWnd);\n        }\n        hbWnd.add(now);  "}
{"magic_number_smell": "\n            /* read the column family name */\n            String cfName = file_.readUTF();\n            dataSize -= (2 + cfName.length());\n            \n            /* read local deletion time */\n            int localDeletionTime = file_.readInt();", "refactored_code": "        private static final short utfPrefix_ = 2;\n\n            /* read the column family name */\n            String cfName = file_.readUTF();\n            dataSize -= (utfPrefix_ + cfName.length());\n            \n            /* read local deletion time */\n            int localDeletionTime = file_.readInt();"}
{"magic_number_smell": "    \n    public static int indexInterval()\n    {\n    \treturn 128;\n    }\n    \n    /*", "refactored_code": "    private static final int indexInterval_ = 128;\n    \n    public static int indexInterval()\n    {\n    \treturn indexInterval_;\n    }\n    \n    /*"}
{"magic_number_smell": "    public void read(SelectionKey key)\n    {        \n        key.interestOps( key.interestOps() & (~SelectionKey.OP_READ) );\n        ByteBuffer buffer = ByteBuffer.allocate(4096);\n        try\n        {\n            SocketAddress sa = socketChannel_.receive(buffer);", "refactored_code": "    private static final int BUFFER_SIZE = 4096;\n    public void read(SelectionKey key)\n    {        \n        key.interestOps( key.interestOps() & (~SelectionKey.OP_READ) );\n        ByteBuffer buffer = ByteBuffer.allocate(BUFFER_SIZE);\n        try\n        {\n            SocketAddress sa = socketChannel_.receive(buffer);"}
{"magic_number_smell": "         */\n        public void run()\n        {\n            ByteBuffer readBuffer = ByteBuffer.allocate(HTTPReader.256);\n            try\n            {\n                int bytesRead = httpChannel_.read(readBuffer);", "refactored_code": "        private static final int bufferSize_ = 256;\n         */\n        public void run()\n        {\n            ByteBuffer readBuffer = ByteBuffer.allocate(HTTPReader.bufferSize_);\n            try\n            {\n                int bytesRead = httpChannel_.read(readBuffer);"}
{"magic_number_smell": "  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(1, new FieldMetaData(\"table\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));\n    put(KEY, new FieldMetaData(\"key\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));", "refactored_code": "  public static final int TABLE = 1;\n  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(TABLE, new FieldMetaData(\"table\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));\n    put(KEY, new FieldMetaData(\"key\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));"}
{"magic_number_smell": "  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(1, new FieldMetaData(\"table\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));\n    put(KEY, new FieldMetaData(\"key\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));", "refactored_code": "  public static final int TABLE = 1;\n  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(TABLE, new FieldMetaData(\"table\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));\n    put(KEY, new FieldMetaData(\"key\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));"}
{"magic_number_smell": "    }\n\n    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n      put(-1, new FieldMetaData(\"tablename\", TFieldRequirementType.DEFAULT, \n          new FieldValueMetaData(TType.STRING)));\n      put(KEY, new FieldMetaData(\"key\", TFieldRequirementType.DEFAULT, \n          new FieldValueMetaData(TType.STRING)));", "refactored_code": "    public static final int TABLENAME = -1;\n    }\n\n    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n      put(TABLENAME, new FieldMetaData(\"tablename\", TFieldRequirementType.DEFAULT, \n          new FieldValueMetaData(TType.STRING)));\n      put(KEY, new FieldMetaData(\"key\", TFieldRequirementType.DEFAULT, \n          new FieldValueMetaData(TType.STRING)));"}
{"magic_number_smell": "  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(1, new FieldMetaData(\"error\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));\n  }});\n", "refactored_code": "  public static final int ERROR = 1;\n  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(ERROR, new FieldMetaData(\"error\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));\n  }});\n"}
{"magic_number_smell": "  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(1, new FieldMetaData(\"columnName\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));\n    put(VALUE, new FieldMetaData(\"value\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));", "refactored_code": "  public static final int COLUMNNAME = 1;\n  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(COLUMNNAME, new FieldMetaData(\"columnName\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));\n    put(VALUE, new FieldMetaData(\"value\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));"}
{"magic_number_smell": "  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(1, new FieldMetaData(\"errorCode\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.I32)));\n    put(ERRORTXT, new FieldMetaData(\"errorTxt\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));", "refactored_code": "  public static final int ERRORCODE = 1;\n  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(ERRORCODE, new FieldMetaData(\"errorCode\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.I32)));\n    put(ERRORTXT, new FieldMetaData(\"errorTxt\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));"}
{"magic_number_smell": "\n\t}\n\n\tprivate ICachetable<String, Message> readRepairTable_ = new Cachetable<String, Message>(2000, new ReadRepairManager.ReadRepairPerformer());\n\n\tprotected ReadRepairManager()\n\t{", "refactored_code": "\tprivate static final long expirationTimeInMillis = 2000;\n\n\t}\n\n\tprivate ICachetable<String, Message> readRepairTable_ = new Cachetable<String, Message>(expirationTimeInMillis, new ReadRepairManager.ReadRepairPerformer());\n\n\tprotected ReadRepairManager()\n\t{"}
{"magic_number_smell": "            if ( isHeavyNode() )\n            {\n                logger_.debug(StorageService.getLocalStorageEndPoint() + \" is a heavy node with load \" + localLoad());\n                // lb_.schedule( new LoadBalancer(), StorageLoadBalancer.5, TimeUnit.MINUTES );\n            }\n            */\n        }       ", "refactored_code": "    private static final int delay_ = 5;\n            if ( isHeavyNode() )\n            {\n                logger_.debug(StorageService.getLocalStorageEndPoint() + \" is a heavy node with load \" + localLoad());\n                // lb_.schedule( new LoadBalancer(), StorageLoadBalancer.delay_, TimeUnit.MINUTES );\n            }\n            */\n        }       "}
{"magic_number_smell": "        /* start the analytics context package */\n        AnalyticsContext.instance().start();\n        /* starts a load timer thread */\n        loadTimer_.schedule( new LoadDisseminator(), StorageService.5 * 60 * 1000L, StorageService.5 * 60 * 1000L);\n        \n        /* report our existence to ZooKeeper instance and start the leader election service */\n        ", "refactored_code": "    private static final long threshold_ = 5 * 60 * 1000L;\n        /* start the analytics context package */\n        AnalyticsContext.instance().start();\n        /* starts a load timer thread */\n        loadTimer_.schedule( new LoadDisseminator(), StorageService.threshold_, StorageService.threshold_);\n        \n        /* report our existence to ZooKeeper instance and start the leader election service */\n        "}
{"magic_number_smell": "  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(1, new FieldMetaData(\"name\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));\n    put(COLUMNS, new FieldMetaData(\"columns\", TFieldRequirementType.DEFAULT, \n        new ListMetaData(TType.LIST, ", "refactored_code": "  public static final int NAME = 1;\n  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(NAME, new FieldMetaData(\"name\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));\n    put(COLUMNS, new FieldMetaData(\"columns\", TFieldRequirementType.DEFAULT, \n        new ListMetaData(TType.LIST, "}
{"magic_number_smell": "\n    private static int getBlockCount(String dataFile) throws IOException\n    {\n        IFileReader dataReader = SequenceFile.bufferedReader(dataFile, 64*1024);\n        DataOutputBuffer bufOut = new DataOutputBuffer();\n        DataInputBuffer bufIn = new DataInputBuffer();\n        int blockCount = 0;", "refactored_code": "    private static final int bufferSize_ = 64*1024;\n\n    private static int getBlockCount(String dataFile) throws IOException\n    {\n        IFileReader dataReader = SequenceFile.bufferedReader(dataFile, bufferSize_);\n        DataOutputBuffer bufOut = new DataOutputBuffer();\n        DataInputBuffer bufIn = new DataInputBuffer();\n        int blockCount = 0;"}
{"magic_number_smell": "        RandomAccessFile raf = new RandomAccessFile( \"Missing-\" + FBUtilities.getHostName() + \".dat\", \"rw\");\n        \n        /* Start reading the file that contains the keys */\n        BufferedReader bufReader = new BufferedReader( new InputStreamReader( new FileInputStream(args[0]) ), KeyChecker.128*1024*1024 );\n        String key = null;\n        boolean bStarted = false;\n        ", "refactored_code": "    private static final int bufSize_ = 128*1024*1024;\n        RandomAccessFile raf = new RandomAccessFile( \"Missing-\" + FBUtilities.getHostName() + \".dat\", \"rw\");\n        \n        /* Start reading the file that contains the keys */\n        BufferedReader bufReader = new BufferedReader( new InputStreamReader( new FileInputStream(args[0]) ), KeyChecker.bufSize_ );\n        String key = null;\n        boolean bStarted = false;\n        "}
{"magic_number_smell": "\n    public static boolean extractKeyIntoFile(String keyToExtract, String dataFile, String outputFile) throws IOException\n    {\n\t\tIFileReader dataReader = SequenceFile.bufferedReader(dataFile, 64*1024);\n        DataOutputBuffer bufOut = new DataOutputBuffer();\n        DataInputBuffer bufIn = new DataInputBuffer();\n", "refactored_code": "    private static final int bufferSize_ = 64*1024;\n\n    public static boolean extractKeyIntoFile(String keyToExtract, String dataFile, String outputFile) throws IOException\n    {\n\t\tIFileReader dataReader = SequenceFile.bufferedReader(dataFile, bufferSize_);\n        DataOutputBuffer bufOut = new DataOutputBuffer();\n        DataInputBuffer bufIn = new DataInputBuffer();\n"}
{"magic_number_smell": "        DataOutputStream dos = new DataOutputStream(bos);\n        MembershipCleanerMessage.serializer().serialize(mcMessage, dos);\n        /* Construct the token update message to be sent */\n        Message mbrshipCleanerMessage = new Message( new EndPoint(FBUtilities.getHostName(), 7000), \"\", StorageService.mbrshipCleanerVerbHandler_, new Object[]{bos.toByteArray()} );\n        \n        BufferedReader bufReader = new BufferedReader( new InputStreamReader( new FileInputStream(file) ) );\n        String line = null;", "refactored_code": "    private static final int port_ = 7000;\n        DataOutputStream dos = new DataOutputStream(bos);\n        MembershipCleanerMessage.serializer().serialize(mcMessage, dos);\n        /* Construct the token update message to be sent */\n        Message mbrshipCleanerMessage = new Message( new EndPoint(FBUtilities.getHostName(), port_), \"\", StorageService.mbrshipCleanerVerbHandler_, new Object[]{bos.toByteArray()} );\n        \n        BufferedReader bufReader = new BufferedReader( new InputStreamReader( new FileInputStream(file) ) );\n        String line = null;"}
{"magic_number_smell": "        DataOutputStream dos = new DataOutputStream(bos);\n        TokenInfoMessage.serializer().serialize(tiMessage, dos);\n        /* Construct the token update message to be sent */\n        Message tokenUpdateMessage = new Message( new EndPoint(FBUtilities.getHostName(), 7000), \"\", StorageService.tokenVerbHandler_, new Object[]{bos.toByteArray()} );\n        \n        BufferedReader bufReader = new BufferedReader( new InputStreamReader( new FileInputStream(file) ) );\n        String line = null;", "refactored_code": "    private static final int port_ = 7000;\n        DataOutputStream dos = new DataOutputStream(bos);\n        TokenInfoMessage.serializer().serialize(tiMessage, dos);\n        /* Construct the token update message to be sent */\n        Message tokenUpdateMessage = new Message( new EndPoint(FBUtilities.getHostName(), port_), \"\", StorageService.tokenVerbHandler_, new Object[]{bos.toByteArray()} );\n        \n        BufferedReader bufReader = new BufferedReader( new InputStreamReader( new FileInputStream(file) ) );\n        String line = null;"}
{"magic_number_smell": "        int endWordIndex = wordIndex(toIndex - 1);\n        expandTo(endWordIndex);\n        \n        long firstWordMask = 0xffffffffffffffffL << fromIndex;\n        long lastWordMask = 0xffffffffffffffffL >>> -toIndex;\n        if (startWordIndex == endWordIndex)\n        {", "refactored_code": "    private static final long WORD_MASK = 0xffffffffffffffffL;\n        int endWordIndex = wordIndex(toIndex - 1);\n        expandTo(endWordIndex);\n        \n        long firstWordMask = WORD_MASK << fromIndex;\n        long lastWordMask = WORD_MASK >>> -toIndex;\n        if (startWordIndex == endWordIndex)\n        {"}
{"magic_number_smell": "        if(maxFalsePosProb >= probs[minBuckets][minK]) {\n            return new BloomSpecification(2, optKPerBuckets[2]);\n        }\n        if(maxFalsePosProb < probs[15][maxK]) {\n            return new BloomSpecification(maxK, 15);\n        }\n", "refactored_code": "    private static final int maxBuckets = 15;\n        if(maxFalsePosProb >= probs[minBuckets][minK]) {\n            return new BloomSpecification(2, optKPerBuckets[2]);\n        }\n        if(maxFalsePosProb < probs[maxBuckets][maxK]) {\n            return new BloomSpecification(maxK, maxBuckets);\n        }\n"}
{"magic_number_smell": "     */\n    public FastHash()\n    {\n        this(DEFAULT_INITIAL_CAPACITY, 0.5f);\n    }\n    \n    /**", "refactored_code": "    protected static final float DEFAULT_LOAD_FACTOR = 0.5f;\n     */\n    public FastHash()\n    {\n        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);\n    }\n    \n    /**"}
{"magic_number_smell": "            String val = df_.format(d);\n            return val + \" MB\";\n        }\n        else if ( value >= 1024d )\n        {\n            d = value / 1024d;\n            String val = df_.format(d);", "refactored_code": "    private static final double kb_ = 1024d;\n            String val = df_.format(d);\n            return val + \" MB\";\n        }\n        else if ( value >= kb_ )\n        {\n            d = value / kb_;\n            String val = df_.format(d);"}
{"magic_number_smell": "\n    private static final int[] primeCapacities = {\n    // chunk #0\n            Integer.MAX_VALUE,\n\n            // chunk #1\n            5, 11, 23, 47, 97, 197, 397, 797, 1597, 3203, 6421, 12853, 25717,", "refactored_code": "    public static final int largestPrime = Integer.MAX_VALUE; // yes, it is\n\n    private static final int[] primeCapacities = {\n    // chunk #0\n            largestPrime,\n\n            // chunk #1\n            5, 11, 23, 47, 97, 197, 397, 797, 1597, 3203, 6421, 12853, 25717,"}
{"magic_number_smell": "\t\tString tmaxString = (String) tmaxTable_.get(metricName);\n\t\tif (tmaxString == null)\n\t\t{\n\t\t\treturn 60;\n\t\t}\n\t\telse\n\t\t{", "refactored_code": "\tprivate static final int DEFAULT_TMAX = 60;\n\t\tString tmaxString = (String) tmaxTable_.get(metricName);\n\t\tif (tmaxString == null)\n\t\t{\n\t\t\treturn DEFAULT_TMAX;\n\t\t}\n\t\telse\n\t\t{"}
{"magic_number_smell": "        }\n        else\n        {\n            css.thriftPort = 9160;\n        }\n    }\n}", "refactored_code": "    private static final int    DEFAULT_THRIFT_PORT = 9160;\n        }\n        else\n        {\n            css.thriftPort = DEFAULT_THRIFT_PORT;\n        }\n    }\n}"}
{"magic_number_smell": "    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n    private final static ThreadLocal<IContinuable> tls_ = new ThreadLocal<IContinuable>();\n    private static final int Integer.SIZE - 3 = Integer.SIZE - 3;\n    private static final int CAPACITY = (1 << Integer.SIZE - 3) - 1;\n\n    // runState is stored in the high-order bits\n    private static final int RUNNING = -1 << Integer.SIZE - 3;", "refactored_code": "    private static final int COUNT_BITS = Integer.SIZE - 3;\n    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n    private final static ThreadLocal<IContinuable> tls_ = new ThreadLocal<IContinuable>();\n    private static final int COUNT_BITS = Integer.SIZE - 3;\n    private static final int CAPACITY = (1 << COUNT_BITS) - 1;\n\n    // runState is stored in the high-order bits\n    private static final int RUNNING = -1 << COUNT_BITS;"}
{"magic_number_smell": "                    // For each bucket if it has crossed the threshhold do the compaction\n                    // In case of range  compaction merge the counting bloom filters also.\n                    if( count == threshHold_)\n                        doFileCompaction(files, 128*1024*1024);\n\t    \t\t}\n\t    \t}\n        }", "refactored_code": "    private static final int bufSize_ = 128*1024*1024;\n                    // For each bucket if it has crossed the threshhold do the compaction\n                    // In case of range  compaction merge the counting bloom filters also.\n                    if( count == threshHold_)\n                        doFileCompaction(files, bufSize_);\n\t    \t\t}\n\t    \t}\n        }"}
{"magic_number_smell": "        {\n            /* Add this to the threshold */\n            int bufSize = 4*1024*1024;\n            return SequenceFile.fastWriter(file, CommitLog.128*1024*1024 + bufSize);\n        }\n        else\n            return SequenceFile.writer(file);", "refactored_code": "    private static final int bufSize_ = 128*1024*1024;\n        {\n            /* Add this to the threshold */\n            int bufSize = 4*1024*1024;\n            return SequenceFile.fastWriter(file, CommitLog.bufSize_ + bufSize);\n        }\n        else\n            return SequenceFile.writer(file);"}
{"magic_number_smell": "        ArrivalWindow hbWnd = arrivalSamples_.get(ep);\n        if ( hbWnd == null )\n        {\n            hbWnd = new ArrivalWindow(1000);\n            arrivalSamples_.put(ep, hbWnd);\n        }\n        hbWnd.add(now);  ", "refactored_code": "    private static final int sampleSize_ = 1000;\n        ArrivalWindow hbWnd = arrivalSamples_.get(ep);\n        if ( hbWnd == null )\n        {\n            hbWnd = new ArrivalWindow(sampleSize_);\n            arrivalSamples_.put(ep, hbWnd);\n        }\n        hbWnd.add(now);  "}
{"magic_number_smell": "\n            /* read the column family name */\n            String cfName = file_.readUTF();\n            dataSize -= (2 + cfName.length());\n            \n            /* read local deletion time */\n            int localDeletionTime = file_.readInt();", "refactored_code": "        private static final short utfPrefix_ = 2;\n\n            /* read the column family name */\n            String cfName = file_.readUTF();\n            dataSize -= (utfPrefix_ + cfName.length());\n            \n            /* read local deletion time */\n            int localDeletionTime = file_.readInt();"}
{"magic_number_smell": "    \n    public static int indexInterval()\n    {\n    \treturn 128;\n    }\n    \n    /*", "refactored_code": "    private static final int indexInterval_ = 128;\n    \n    public static int indexInterval()\n    {\n    \treturn indexInterval_;\n    }\n    \n    /*"}
{"magic_number_smell": "    public void read(SelectionKey key)\n    {        \n        key.interestOps( key.interestOps() & (~SelectionKey.OP_READ) );\n        ByteBuffer buffer = ByteBuffer.allocate(4096);\n        try\n        {\n            SocketAddress sa = socketChannel_.receive(buffer);", "refactored_code": "    private static final int BUFFER_SIZE = 4096;\n    public void read(SelectionKey key)\n    {        \n        key.interestOps( key.interestOps() & (~SelectionKey.OP_READ) );\n        ByteBuffer buffer = ByteBuffer.allocate(BUFFER_SIZE);\n        try\n        {\n            SocketAddress sa = socketChannel_.receive(buffer);"}
{"magic_number_smell": "         */\n        public void run()\n        {\n            ByteBuffer readBuffer = ByteBuffer.allocate(HTTPReader.256);\n            try\n            {\n                int bytesRead = httpChannel_.read(readBuffer);", "refactored_code": "        private static final int bufferSize_ = 256;\n         */\n        public void run()\n        {\n            ByteBuffer readBuffer = ByteBuffer.allocate(HTTPReader.bufferSize_);\n            try\n            {\n                int bytesRead = httpChannel_.read(readBuffer);"}
{"magic_number_smell": "  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(1, new FieldMetaData(\"table\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));\n    put(KEY, new FieldMetaData(\"key\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));", "refactored_code": "  public static final int TABLE = 1;\n  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(TABLE, new FieldMetaData(\"table\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));\n    put(KEY, new FieldMetaData(\"key\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));"}
{"magic_number_smell": "  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(1, new FieldMetaData(\"table\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));\n    put(KEY, new FieldMetaData(\"key\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));", "refactored_code": "  public static final int TABLE = 1;\n  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(TABLE, new FieldMetaData(\"table\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));\n    put(KEY, new FieldMetaData(\"key\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));"}
{"magic_number_smell": "    }\n\n    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n      put(-1, new FieldMetaData(\"tablename\", TFieldRequirementType.DEFAULT, \n          new FieldValueMetaData(TType.STRING)));\n      put(KEY, new FieldMetaData(\"key\", TFieldRequirementType.DEFAULT, \n          new FieldValueMetaData(TType.STRING)));", "refactored_code": "    public static final int TABLENAME = -1;\n    }\n\n    public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n      put(TABLENAME, new FieldMetaData(\"tablename\", TFieldRequirementType.DEFAULT, \n          new FieldValueMetaData(TType.STRING)));\n      put(KEY, new FieldMetaData(\"key\", TFieldRequirementType.DEFAULT, \n          new FieldValueMetaData(TType.STRING)));"}
{"magic_number_smell": "  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(1, new FieldMetaData(\"error\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));\n  }});\n", "refactored_code": "  public static final int ERROR = 1;\n  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(ERROR, new FieldMetaData(\"error\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));\n  }});\n"}
{"magic_number_smell": "  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(1, new FieldMetaData(\"columnName\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));\n    put(VALUE, new FieldMetaData(\"value\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));", "refactored_code": "  public static final int COLUMNNAME = 1;\n  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(COLUMNNAME, new FieldMetaData(\"columnName\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));\n    put(VALUE, new FieldMetaData(\"value\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));"}
{"magic_number_smell": "  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(1, new FieldMetaData(\"errorCode\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.I32)));\n    put(ERRORTXT, new FieldMetaData(\"errorTxt\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));", "refactored_code": "  public static final int ERRORCODE = 1;\n  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(ERRORCODE, new FieldMetaData(\"errorCode\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.I32)));\n    put(ERRORTXT, new FieldMetaData(\"errorTxt\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));"}
{"magic_number_smell": "\n\t}\n\n\tprivate ICachetable<String, Message> readRepairTable_ = new Cachetable<String, Message>(2000, new ReadRepairManager.ReadRepairPerformer());\n\n\tprotected ReadRepairManager()\n\t{", "refactored_code": "\tprivate static final long expirationTimeInMillis = 2000;\n\n\t}\n\n\tprivate ICachetable<String, Message> readRepairTable_ = new Cachetable<String, Message>(expirationTimeInMillis, new ReadRepairManager.ReadRepairPerformer());\n\n\tprotected ReadRepairManager()\n\t{"}
{"magic_number_smell": "            if ( isHeavyNode() )\n            {\n                logger_.debug(StorageService.getLocalStorageEndPoint() + \" is a heavy node with load \" + localLoad());\n                // lb_.schedule( new LoadBalancer(), StorageLoadBalancer.5, TimeUnit.MINUTES );\n            }\n            */\n        }       ", "refactored_code": "    private static final int delay_ = 5;\n            if ( isHeavyNode() )\n            {\n                logger_.debug(StorageService.getLocalStorageEndPoint() + \" is a heavy node with load \" + localLoad());\n                // lb_.schedule( new LoadBalancer(), StorageLoadBalancer.delay_, TimeUnit.MINUTES );\n            }\n            */\n        }       "}
{"magic_number_smell": "        /* start the analytics context package */\n        AnalyticsContext.instance().start();\n        /* starts a load timer thread */\n        loadTimer_.schedule( new LoadDisseminator(), StorageService.5 * 60 * 1000L, StorageService.5 * 60 * 1000L);\n        \n        /* report our existence to ZooKeeper instance and start the leader election service */\n        ", "refactored_code": "    private static final long threshold_ = 5 * 60 * 1000L;\n        /* start the analytics context package */\n        AnalyticsContext.instance().start();\n        /* starts a load timer thread */\n        loadTimer_.schedule( new LoadDisseminator(), StorageService.threshold_, StorageService.threshold_);\n        \n        /* report our existence to ZooKeeper instance and start the leader election service */\n        "}
{"magic_number_smell": "  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(1, new FieldMetaData(\"name\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));\n    put(COLUMNS, new FieldMetaData(\"columns\", TFieldRequirementType.DEFAULT, \n        new ListMetaData(TType.LIST, ", "refactored_code": "  public static final int NAME = 1;\n  }\n\n  public static final Map<Integer, FieldMetaData> metaDataMap = Collections.unmodifiableMap(new HashMap<Integer, FieldMetaData>() {{\n    put(NAME, new FieldMetaData(\"name\", TFieldRequirementType.DEFAULT, \n        new FieldValueMetaData(TType.STRING)));\n    put(COLUMNS, new FieldMetaData(\"columns\", TFieldRequirementType.DEFAULT, \n        new ListMetaData(TType.LIST, "}
{"magic_number_smell": "\n    private static int getBlockCount(String dataFile) throws IOException\n    {\n        IFileReader dataReader = SequenceFile.bufferedReader(dataFile, 64*1024);\n        DataOutputBuffer bufOut = new DataOutputBuffer();\n        DataInputBuffer bufIn = new DataInputBuffer();\n        int blockCount = 0;", "refactored_code": "    private static final int bufferSize_ = 64*1024;\n\n    private static int getBlockCount(String dataFile) throws IOException\n    {\n        IFileReader dataReader = SequenceFile.bufferedReader(dataFile, bufferSize_);\n        DataOutputBuffer bufOut = new DataOutputBuffer();\n        DataInputBuffer bufIn = new DataInputBuffer();\n        int blockCount = 0;"}
{"magic_number_smell": "        RandomAccessFile raf = new RandomAccessFile( \"Missing-\" + FBUtilities.getHostName() + \".dat\", \"rw\");\n        \n        /* Start reading the file that contains the keys */\n        BufferedReader bufReader = new BufferedReader( new InputStreamReader( new FileInputStream(args[0]) ), KeyChecker.128*1024*1024 );\n        String key = null;\n        boolean bStarted = false;\n        ", "refactored_code": "    private static final int bufSize_ = 128*1024*1024;\n        RandomAccessFile raf = new RandomAccessFile( \"Missing-\" + FBUtilities.getHostName() + \".dat\", \"rw\");\n        \n        /* Start reading the file that contains the keys */\n        BufferedReader bufReader = new BufferedReader( new InputStreamReader( new FileInputStream(args[0]) ), KeyChecker.bufSize_ );\n        String key = null;\n        boolean bStarted = false;\n        "}
{"magic_number_smell": "\n    public static boolean extractKeyIntoFile(String keyToExtract, String dataFile, String outputFile) throws IOException\n    {\n\t\tIFileReader dataReader = SequenceFile.bufferedReader(dataFile, 64*1024);\n        DataOutputBuffer bufOut = new DataOutputBuffer();\n        DataInputBuffer bufIn = new DataInputBuffer();\n", "refactored_code": "    private static final int bufferSize_ = 64*1024;\n\n    public static boolean extractKeyIntoFile(String keyToExtract, String dataFile, String outputFile) throws IOException\n    {\n\t\tIFileReader dataReader = SequenceFile.bufferedReader(dataFile, bufferSize_);\n        DataOutputBuffer bufOut = new DataOutputBuffer();\n        DataInputBuffer bufIn = new DataInputBuffer();\n"}
{"magic_number_smell": "        DataOutputStream dos = new DataOutputStream(bos);\n        MembershipCleanerMessage.serializer().serialize(mcMessage, dos);\n        /* Construct the token update message to be sent */\n        Message mbrshipCleanerMessage = new Message( new EndPoint(FBUtilities.getHostName(), 7000), \"\", StorageService.mbrshipCleanerVerbHandler_, new Object[]{bos.toByteArray()} );\n        \n        BufferedReader bufReader = new BufferedReader( new InputStreamReader( new FileInputStream(file) ) );\n        String line = null;", "refactored_code": "    private static final int port_ = 7000;\n        DataOutputStream dos = new DataOutputStream(bos);\n        MembershipCleanerMessage.serializer().serialize(mcMessage, dos);\n        /* Construct the token update message to be sent */\n        Message mbrshipCleanerMessage = new Message( new EndPoint(FBUtilities.getHostName(), port_), \"\", StorageService.mbrshipCleanerVerbHandler_, new Object[]{bos.toByteArray()} );\n        \n        BufferedReader bufReader = new BufferedReader( new InputStreamReader( new FileInputStream(file) ) );\n        String line = null;"}
{"magic_number_smell": "        DataOutputStream dos = new DataOutputStream(bos);\n        TokenInfoMessage.serializer().serialize(tiMessage, dos);\n        /* Construct the token update message to be sent */\n        Message tokenUpdateMessage = new Message( new EndPoint(FBUtilities.getHostName(), 7000), \"\", StorageService.tokenVerbHandler_, new Object[]{bos.toByteArray()} );\n        \n        BufferedReader bufReader = new BufferedReader( new InputStreamReader( new FileInputStream(file) ) );\n        String line = null;", "refactored_code": "    private static final int port_ = 7000;\n        DataOutputStream dos = new DataOutputStream(bos);\n        TokenInfoMessage.serializer().serialize(tiMessage, dos);\n        /* Construct the token update message to be sent */\n        Message tokenUpdateMessage = new Message( new EndPoint(FBUtilities.getHostName(), port_), \"\", StorageService.tokenVerbHandler_, new Object[]{bos.toByteArray()} );\n        \n        BufferedReader bufReader = new BufferedReader( new InputStreamReader( new FileInputStream(file) ) );\n        String line = null;"}
{"magic_number_smell": "        int endWordIndex = wordIndex(toIndex - 1);\n        expandTo(endWordIndex);\n        \n        long firstWordMask = 0xffffffffffffffffL << fromIndex;\n        long lastWordMask = 0xffffffffffffffffL >>> -toIndex;\n        if (startWordIndex == endWordIndex)\n        {", "refactored_code": "    private static final long WORD_MASK = 0xffffffffffffffffL;\n        int endWordIndex = wordIndex(toIndex - 1);\n        expandTo(endWordIndex);\n        \n        long firstWordMask = WORD_MASK << fromIndex;\n        long lastWordMask = WORD_MASK >>> -toIndex;\n        if (startWordIndex == endWordIndex)\n        {"}
{"magic_number_smell": "        if(maxFalsePosProb >= probs[minBuckets][minK]) {\n            return new BloomSpecification(2, optKPerBuckets[2]);\n        }\n        if(maxFalsePosProb < probs[15][maxK]) {\n            return new BloomSpecification(maxK, 15);\n        }\n", "refactored_code": "    private static final int maxBuckets = 15;\n        if(maxFalsePosProb >= probs[minBuckets][minK]) {\n            return new BloomSpecification(2, optKPerBuckets[2]);\n        }\n        if(maxFalsePosProb < probs[maxBuckets][maxK]) {\n            return new BloomSpecification(maxK, maxBuckets);\n        }\n"}
{"magic_number_smell": "     */\n    public FastHash()\n    {\n        this(DEFAULT_INITIAL_CAPACITY, 0.5f);\n    }\n    \n    /**", "refactored_code": "    protected static final float DEFAULT_LOAD_FACTOR = 0.5f;\n     */\n    public FastHash()\n    {\n        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);\n    }\n    \n    /**"}
{"magic_number_smell": "            String val = df_.format(d);\n            return val + \" MB\";\n        }\n        else if ( value >= 1024d )\n        {\n            d = value / 1024d;\n            String val = df_.format(d);", "refactored_code": "    private static final double kb_ = 1024d;\n            String val = df_.format(d);\n            return val + \" MB\";\n        }\n        else if ( value >= kb_ )\n        {\n            d = value / kb_;\n            String val = df_.format(d);"}
{"magic_number_smell": "\n    private static final int[] primeCapacities = {\n    // chunk #0\n            Integer.MAX_VALUE,\n\n            // chunk #1\n            5, 11, 23, 47, 97, 197, 397, 797, 1597, 3203, 6421, 12853, 25717,", "refactored_code": "    public static final int largestPrime = Integer.MAX_VALUE; // yes, it is\n\n    private static final int[] primeCapacities = {\n    // chunk #0\n            largestPrime,\n\n            // chunk #1\n            5, 11, 23, 47, 97, 197, 397, 797, 1597, 3203, 6421, 12853, 25717,"}
{"magic_number_smell": "    public void configure() {\n        from(\"timer:foo\")\n                .toD(\"file:output?fileExist=\" + EXISTS\n                     + \"&chmod=\" + (770 + 6 + 1)\n                     + \"&allowNullBody=true\")\n                .to(\"log:b\");\n    }", "refactored_code": "    private static final int MOD = 770;\n    public void configure() {\n        from(\"timer:foo\")\n                .toD(\"file:output?fileExist=\" + EXISTS\n                     + \"&chmod=\" + (MOD + 6 + 1)\n                     + \"&allowNullBody=true\")\n                .to(\"log:b\");\n    }"}
{"magic_number_smell": "    public void retrieve() {\n        Exchange result = fluentTemplate.to(QDRANT_URI)\n                .withHeader(Qdrant.Headers.ACTION, QdrantAction.RETRIEVE)\n                .withBody(PointIdFactory.id(8))\n                .request(Exchange.class);\n\n        assertThat(result).isNotNull();", "refactored_code": "    public static final long POINT_ID = 8;\n    public void retrieve() {\n        Exchange result = fluentTemplate.to(QDRANT_URI)\n                .withHeader(Qdrant.Headers.ACTION, QdrantAction.RETRIEVE)\n                .withBody(PointIdFactory.id(POINT_ID))\n                .request(Exchange.class);\n\n        assertThat(result).isNotNull();"}
{"magic_number_smell": "        httpContext.setTargetHost(targetHost);\n\n        HttpClientConnection httpConnection = connectionPoolManager.requestConnection(route, null)\n                .get(5, TimeUnit.SECONDS);\n        if (!httpConnection.isOpen()) {\n            connectionPoolManager.connect(httpConnection, route, connectionTimeoutMilliseconds, httpContext);\n        }", "refactored_code": "    private static final int RETRIEVE_FROM_CONNECTION_POOL_TIMEOUT_SECONDS = 5;\n        httpContext.setTargetHost(targetHost);\n\n        HttpClientConnection httpConnection = connectionPoolManager.requestConnection(route, null)\n                .get(RETRIEVE_FROM_CONNECTION_POOL_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n        if (!httpConnection.isOpen()) {\n            connectionPoolManager.connect(httpConnection, route, connectionTimeoutMilliseconds, httpContext);\n        }"}
{"magic_number_smell": "\n        try {\n            InputStream is = new ByteArrayInputStream(content);\n            AS2SessionInputBuffer inbuffer = new AS2SessionInputBuffer(new HttpTransportMetricsImpl(), 8 * 1024);\n            inbuffer.bind(is);\n\n            // Read Text Report Body Part Headers", "refactored_code": "    private static final int DEFAULT_BUFFER_SIZE = 8 * 1024;\n\n        try {\n            InputStream is = new ByteArrayInputStream(content);\n            AS2SessionInputBuffer inbuffer = new AS2SessionInputBuffer(new HttpTransportMetricsImpl(), DEFAULT_BUFFER_SIZE);\n            inbuffer.bind(is);\n\n            // Read Text Report Body Part Headers"}
{"magic_number_smell": "                writeTo(out);\n                contentLength = out.toByteArray().length;\n            } catch (IOException e) {\n                contentLength = MimeEntity.-1;\n            }\n        }\n        return contentLength;", "refactored_code": "    protected static final long UNKNOWN_CONTENT_LENGTH = -1;\n                writeTo(out);\n                contentLength = out.toByteArray().length;\n            } catch (IOException e) {\n                contentLength = MimeEntity.UNKNOWN_CONTENT_LENGTH;\n            }\n        }\n        return contentLength;"}
{"magic_number_smell": "    private static final Integer HTTP_CONNECTION_POOL_SIZE = 5;\n    private static final Duration HTTP_CONNECTION_POOL_TTL = Duration.ofMinutes(15);\n    private static final Certificate[] VALIDATE_SIGNING_CERTIFICATE_CHAIN = null;\n    private static final String RECIPIENT_DELIVERY_ADDRESS = \"http://localhost:\" + AvailablePortFinder.getNextAvailable() + \"/handle-receipts\";\n    private static final String AS2_VERSION = \"1.1\";\n    private static final String USER_AGENT = \"Camel AS2 Endpoint\";\n    private static final String REQUEST_URI = \"/\";", "refactored_code": "    private static final int TARGET_PORT = AvailablePortFinder.getNextAvailable();\n    private static final Integer HTTP_CONNECTION_POOL_SIZE = 5;\n    private static final Duration HTTP_CONNECTION_POOL_TTL = Duration.ofMinutes(15);\n    private static final Certificate[] VALIDATE_SIGNING_CERTIFICATE_CHAIN = null;\n    private static final String RECIPIENT_DELIVERY_ADDRESS = \"http://localhost:\" + TARGET_PORT + \"/handle-receipts\";\n    private static final String AS2_VERSION = \"1.1\";\n    private static final String USER_AGENT = \"Camel AS2 Endpoint\";\n    private static final String REQUEST_URI = \"/\";"}
{"magic_number_smell": "        InputStream is = new ByteArrayInputStream(\n                DISPOSITION_NOTIFICATION_REPORT_CONTENT.getBytes(DISPOSITION_NOTIFICATION_REPORT_CONTENT_CHARSET_NAME));\n        AS2SessionInputBuffer inbuffer\n                = new AS2SessionInputBuffer(new HttpTransportMetricsImpl(), 8 * 1024, 8 * 1024, null);\n        inbuffer.bind(is);\n\n        DispositionNotificationMultipartReportEntity dispositionNotificationMultipartReportEntity = EntityParser", "refactored_code": "    private static final int DEFAULT_BUFFER_SIZE = 8 * 1024;\n        InputStream is = new ByteArrayInputStream(\n                DISPOSITION_NOTIFICATION_REPORT_CONTENT.getBytes(DISPOSITION_NOTIFICATION_REPORT_CONTENT_CHARSET_NAME));\n        AS2SessionInputBuffer inbuffer\n                = new AS2SessionInputBuffer(new HttpTransportMetricsImpl(), DEFAULT_BUFFER_SIZE, DEFAULT_BUFFER_SIZE, null);\n        inbuffer.bind(is);\n\n        DispositionNotificationMultipartReportEntity dispositionNotificationMultipartReportEntity = EntityParser"}
{"magic_number_smell": "    private static void receiveTestMessages() throws IOException {\n        serverConnection = new AS2ServerConnection(\n                AS2_VERSION, ORIGIN_SERVER_NAME,\n                SERVER_FQDN, 8888, AS2SignatureAlgorithm.SHA256WITHRSA,\n                new Certificate[] { serverCert }, serverKP.getPrivate(), serverKP.getPrivate(),\n                MDN_MESSAGE_TEMPLATE, new Certificate[] { clientCert }, null);\n        requestHandler = new RequestHandler();", "refactored_code": "    private static final int PARTNER_TARGET_PORT = 8888;\n    private static void receiveTestMessages() throws IOException {\n        serverConnection = new AS2ServerConnection(\n                AS2_VERSION, ORIGIN_SERVER_NAME,\n                SERVER_FQDN, PARTNER_TARGET_PORT, AS2SignatureAlgorithm.SHA256WITHRSA,\n                new Certificate[] { serverCert }, serverKP.getPrivate(), serverKP.getPrivate(),\n                MDN_MESSAGE_TEMPLATE, new Certificate[] { clientCert }, null);\n        requestHandler = new RequestHandler();"}
{"magic_number_smell": "    public void receivePlainEDIMessageTest() throws Exception {\n        AS2ClientConnection clientConnection\n                = new AS2ClientConnection(\n                        AS2_VERSION, USER_AGENT, CLIENT_FQDN, TARGET_HOST, 8888, HTTP_SOCKET_TIMEOUT,\n                        HTTP_CONNECTION_TIMEOUT, HTTP_CONNECTION_POOL_SIZE, HTTP_CONNECTION_POOL_TTL, clientSslContext,\n                        null);\n        AS2ClientManager clientManager = new AS2ClientManager(clientConnection);", "refactored_code": "    private static final int TARGET_PORT = 8888;\n    public void receivePlainEDIMessageTest() throws Exception {\n        AS2ClientConnection clientConnection\n                = new AS2ClientConnection(\n                        AS2_VERSION, USER_AGENT, CLIENT_FQDN, TARGET_HOST, TARGET_PORT, HTTP_SOCKET_TIMEOUT,\n                        HTTP_CONNECTION_TIMEOUT, HTTP_CONNECTION_POOL_SIZE, HTTP_CONNECTION_POOL_TTL, clientSslContext,\n                        null);\n        AS2ClientManager clientManager = new AS2ClientManager(clientConnection);"}
{"magic_number_smell": "    void setupJetty() {\n        final JettyConfiguration jettyConfiguration = JettyConfigurationBuilder\n                .emptyTemplate()\n                .withPort(AvailablePortFinder.getNextAvailable())\n                .withContextPath(JettyConfiguration.ROOT_CONTEXT_PATH)\n                .withWebSocketConfiguration()\n                .addServletConfiguration(new JettyConfiguration.WebSocketContextHandlerConfiguration.ServletConfiguration<>(", "refactored_code": "    protected static final int PORT = AvailablePortFinder.getNextAvailable();\n    void setupJetty() {\n        final JettyConfiguration jettyConfiguration = JettyConfigurationBuilder\n                .emptyTemplate()\n                .withPort(PORT)\n                .withContextPath(JettyConfiguration.ROOT_CONTEXT_PATH)\n                .withWebSocketConfiguration()\n                .addServletConfiguration(new JettyConfiguration.WebSocketContextHandlerConfiguration.ServletConfiguration<>("}
{"magic_number_smell": "\n        final JettyConfiguration jettyConfiguration = JettyConfigurationBuilder\n                .emptyTemplate()\n                .withPort(AvailablePortFinder.getNextAvailable())\n                .withContextPath(JettyConfiguration.ROOT_CONTEXT_PATH)\n                .withWebSocketConfiguration().addServletConfiguration(servletConfiguration).build()\n                .build();", "refactored_code": "    protected static final int PORT = AvailablePortFinder.getNextAvailable();\n\n        final JettyConfiguration jettyConfiguration = JettyConfigurationBuilder\n                .emptyTemplate()\n                .withPort(PORT)\n                .withContextPath(JettyConfiguration.ROOT_CONTEXT_PATH)\n                .withWebSocketConfiguration().addServletConfiguration(servletConfiguration).build()\n                .build();"}
{"magic_number_smell": "    @Test\n    public void testInOutReflectRequestor() throws Exception {\n        initializeTranceiver();\n        Object[] request = { 100 };\n        Object response = reflectRequestor.request(\"increaseAge\", request);\n        assertEquals(testReflection.getAge(), response);\n    }", "refactored_code": "    public static final int REFLECTION_TEST_AGE = 100;\n    @Test\n    public void testInOutReflectRequestor() throws Exception {\n        initializeTranceiver();\n        Object[] request = { REFLECTION_TEST_AGE };\n        Object response = reflectRequestor.request(\"increaseAge\", request);\n        assertEquals(testReflection.getAge(), response);\n    }"}
{"magic_number_smell": "    public void prepareEnvironment() {\n        createStream(client, streamName, 2);\n\n        putRecords(client, streamName, 20);\n    }\n\n    @DisplayName(\"Tests that the component can produce messages to AWS Kinesis\")", "refactored_code": "    private final int messageCount = 20;\n    public void prepareEnvironment() {\n        createStream(client, streamName, 2);\n\n        putRecords(client, streamName, messageCount);\n    }\n\n    @DisplayName(\"Tests that the component can produce messages to AWS Kinesis\")"}
{"magic_number_smell": "    private KinesisClient client;\n    private String streamName = AWSCommon.KINESIS_STREAM_BASE_NAME + \"-cons-\" + TestUtils.randomWithRange(0, 100);\n    private final int 20 = 20;\n    private final int expectedCount = 20 / 2;\n    private List<KinesisData> receivedMessages = new ArrayList<>();\n    private List<PutRecordsResponse> previousRecords;\n    private TestKinesisResumeAdapter adapter = new TestKinesisResumeAdapter(expectedCount);", "refactored_code": "    private final int messageCount = 20;\n    private KinesisClient client;\n    private String streamName = AWSCommon.KINESIS_STREAM_BASE_NAME + \"-cons-\" + TestUtils.randomWithRange(0, 100);\n    private final int messageCount = 20;\n    private final int expectedCount = messageCount / 2;\n    private List<KinesisData> receivedMessages = new ArrayList<>();\n    private List<PutRecordsResponse> previousRecords;\n    private TestKinesisResumeAdapter adapter = new TestKinesisResumeAdapter(expectedCount);"}
{"magic_number_smell": "                while (!entryQueue.isEmpty()) {\n                    List<ChangeMessageVisibilityBatchRequestEntry> batchEntries = new LinkedList<>();\n                    // up to 10 requests can be sent with each ChangeMessageVisibilityBatch action\n                    while (!entryQueue.isEmpty() && batchEntries.size() < 10) {\n                        batchEntries.add(entryQueue.poll());\n                    }\n", "refactored_code": "        private static final int MAX_REQUESTS = 10;\n                while (!entryQueue.isEmpty()) {\n                    List<ChangeMessageVisibilityBatchRequestEntry> batchEntries = new LinkedList<>();\n                    // up to 10 requests can be sent with each ChangeMessageVisibilityBatch action\n                    while (!entryQueue.isEmpty() && batchEntries.size() < MAX_REQUESTS) {\n                        batchEntries.add(entryQueue.poll());\n                    }\n"}
{"magic_number_smell": "\n    private static final int 10 = 10;\n    private static final String MAX_MESSAGE\n            = \"Number of message headers exceeded. At most \" + 10 + \" headers is allowed when sending to AWS SQS.\";\n\n    private transient String sqsProducerToString;\n", "refactored_code": "    private static final int MAX_ATTRIBUTES = 10;\n\n    private static final int MAX_ATTRIBUTES = 10;\n    private static final String MAX_MESSAGE\n            = \"Number of message headers exceeded. At most \" + MAX_ATTRIBUTES + \" headers is allowed when sending to AWS SQS.\";\n\n    private transient String sqsProducerToString;\n"}
{"magic_number_smell": "            @Override\n            public void process(Exchange exchange) throws Exception {\n                // Simulate message that takes a while to receive.\n                Thread.sleep(2 * 1500L); // 150% of 2.\n            }\n        });\n", "refactored_code": "    private static final int TIMEOUT = 2; // 2 seconds.\n            @Override\n            public void process(Exchange exchange) throws Exception {\n                // Simulate message that takes a while to receive.\n                Thread.sleep(TIMEOUT * 1500L); // 150% of TIMEOUT.\n            }\n        });\n"}
{"magic_number_smell": "            @Override\n            public void process(Exchange exchange) throws Exception {\n                // Simulate message that takes a while to receive.\n                Thread.sleep(4 * 1500L); // 150% of 4.\n            }\n        });\n", "refactored_code": "    private static final int TIMEOUT = 4; // 4 seconds.\n            @Override\n            public void process(Exchange exchange) throws Exception {\n                // Simulate message that takes a while to receive.\n                Thread.sleep(TIMEOUT * 1500L); // 150% of TIMEOUT.\n            }\n        });\n"}
{"magic_number_smell": "\n    @Override\n    protected void setDefaultPort() {\n        setPort(443);\n    }\n\n    @Override", "refactored_code": "    public static final int DEFAULT_HTTPS_PORT = 443;\n\n    @Override\n    protected void setDefaultPort() {\n        setPort(DEFAULT_HTTPS_PORT);\n    }\n\n    @Override"}
{"magic_number_smell": "            }\n            result = processBatch(CastUtils.cast(exchanges));\n        } catch (DataLakeStorageException e) {\n            if (404 == e.getStatusCode()) {\n                result = 0;\n            } else {\n                throw e;", "refactored_code": "    public static final int NOT_FOUND = 404;\n            }\n            result = processBatch(CastUtils.cast(exchanges));\n        } catch (DataLakeStorageException e) {\n            if (NOT_FOUND == e.getStatusCode()) {\n                result = 0;\n            } else {\n                throw e;"}
{"magic_number_smell": "    /**\n     * The width of the image.\n     */\n    private Integer width = 100;\n\n    /**\n     * The height of the image.", "refactored_code": "    public static final int WIDTH = 100;\n    /**\n     * The width of the image.\n     */\n    private Integer width = WIDTH;\n\n    /**\n     * The height of the image."}
{"magic_number_smell": "    private final Base64 codec;\n\n    public Base64PropertiesFunction() {\n        this.codec = new Base64(Base64.MIME_CHUNK_SIZE, lineSeparator, true);\n    }\n\n    @Override", "refactored_code": "    private final int lineLength = Base64.MIME_CHUNK_SIZE;\n    private final Base64 codec;\n\n    public Base64PropertiesFunction() {\n        this.codec = new Base64(lineLength, lineSeparator, true);\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @CsvRecord(separator = \",\", quote = \"'\", quoting = true, quotingEscaped = false)\n    public static class BindyCsvRowFormat75192 implements Serializable {\n        private static final long 1L = 1L;\n\n        @DataField(pos = 1)\n        private String firstField;", "refactored_code": "        private static final long serialVersionUID = 1L;\n\n    @CsvRecord(separator = \",\", quote = \"'\", quoting = true, quotingEscaped = false)\n    public static class BindyCsvRowFormat75192 implements Serializable {\n        private static final long serialVersionUID = 1L;\n\n        @DataField(pos = 1)\n        private String firstField;"}
{"magic_number_smell": "\n    @CsvRecord(separator = \",\", quote = \"'\", quoting = true, quotingEscaped = true)\n    public static class BindyCsvRowFormat75192 implements Serializable {\n        private static final long 1L = 1L;\n\n        @DataField(pos = 1)\n        private String firstField;", "refactored_code": "        private static final long serialVersionUID = 1L;\n\n    @CsvRecord(separator = \",\", quote = \"'\", quoting = true, quotingEscaped = true)\n    public static class BindyCsvRowFormat75192 implements Serializable {\n        private static final long serialVersionUID = 1L;\n\n        @DataField(pos = 1)\n        private String firstField;"}
{"magic_number_smell": "\n    @CsvRecord(separator = \",\", quoting = true, quote = \"'\", quotingEscaped = true, quotingOnlyWhenNeeded = true)\n    public static class BindyCsvRowFormat191432 implements Serializable {\n        private static final long 1L = 1L;\n        @DataField(pos = 1)\n        private String firstField;\n        @DataField(pos = 2)", "refactored_code": "        private static final long serialVersionUID = 1L;\n\n    @CsvRecord(separator = \",\", quoting = true, quote = \"'\", quotingEscaped = true, quotingOnlyWhenNeeded = true)\n    public static class BindyCsvRowFormat191432 implements Serializable {\n        private static final long serialVersionUID = 1L;\n        @DataField(pos = 1)\n        private String firstField;\n        @DataField(pos = 2)"}
{"magic_number_smell": "        String csv = Files.readString(filePath);\n        template.sendBody(begin, csv);\n        fail.expectedMessageCount(EXPECTED_FAILED_MESSAGE_COUNT);\n        end.expectedMessageCount(1500);\n        MockEndpoint.assertIsSatisfied(context, WAIT_TIMEOUT, SECONDS);\n        end.reset();\n        fail.reset();", "refactored_code": "    private static final int EXPECTED_SUCCESSFUL_MESSAGE_COUNT = 1500;\n        String csv = Files.readString(filePath);\n        template.sendBody(begin, csv);\n        fail.expectedMessageCount(EXPECTED_FAILED_MESSAGE_COUNT);\n        end.expectedMessageCount(EXPECTED_SUCCESSFUL_MESSAGE_COUNT);\n        MockEndpoint.assertIsSatisfied(context, WAIT_TIMEOUT, SECONDS);\n        end.reset();\n        fail.reset();"}
{"magic_number_smell": "            PartialCollection<BoxItem.Info> partialResult;\n            int offset = 0;\n            do {\n                partialResult = bs.searchRange(offset, 200, bsp);\n                offset += partialResult.size();\n                partialResult.stream().map(i -> (BoxItem) i.getResource()).forEachOrdered(result::add);\n            } while (partialResult.size() == partialResult.limit());", "refactored_code": "    private static final int SEARCH_MAX_LIMIT = 200;\n            PartialCollection<BoxItem.Info> partialResult;\n            int offset = 0;\n            do {\n                partialResult = bs.searchRange(offset, SEARCH_MAX_LIMIT, bsp);\n                offset += partialResult.size();\n                partialResult.stream().map(i -> (BoxItem) i.getResource()).forEachOrdered(result::add);\n            } while (partialResult.size() == partialResult.limit());"}
{"magic_number_smell": "    public void testGetEnterpriseEvents() {\n        Date before = new Date();\n        Date after = new Date();\n        after.setTime(before.getTime() - 1000 * 60);\n\n        final Map<String, Object> headers = new HashMap<>();\n        // parameter type is String", "refactored_code": "    private static final long ONE_MINUTE_OF_MILLISECONDS = 1000 * 60;\n    public void testGetEnterpriseEvents() {\n        Date before = new Date();\n        Date after = new Date();\n        after.setTime(before.getTime() - ONE_MINUTE_OF_MILLISECONDS);\n\n        final Map<String, Object> headers = new HashMap<>();\n        // parameter type is String"}
{"magic_number_smell": "            headers.put(\"CamelBox.action\", BoxTask.Action.REVIEW);\n            // parameter type is java.util.Date\n            Date now = new Date();\n            Date dueAt = new Date(now.getTime() + 600000);\n            headers.put(\"CamelBox.dueAt\", dueAt);\n            // parameter type is String\n            headers.put(\"CamelBox.message\", CAMEL_TEST_MESSAGE);", "refactored_code": "    private static final long TEN_MINUTES_IN_MILLIS = 600000;\n            headers.put(\"CamelBox.action\", BoxTask.Action.REVIEW);\n            // parameter type is java.util.Date\n            Date now = new Date();\n            Date dueAt = new Date(now.getTime() + TEN_MINUTES_IN_MILLIS);\n            headers.put(\"CamelBox.dueAt\", dueAt);\n            // parameter type is String\n            headers.put(\"CamelBox.message\", CAMEL_TEST_MESSAGE);"}
{"magic_number_smell": "            final String message = formatMessage(logRecord);\n\n            int level = logRecord.getLevel().intValue();\n            if (level <= Level.FINEST.intValue()) {\n                logger.trace(message, logRecord.getThrown());\n            } else if (level <= DEBUG_LEVEL_THRESHOLD) {\n                logger.debug(message, logRecord.getThrown());", "refactored_code": "    private static final int TRACE_LEVEL_THRESHOLD = Level.FINEST.intValue();\n            final String message = formatMessage(logRecord);\n\n            int level = logRecord.getLevel().intValue();\n            if (level <= TRACE_LEVEL_THRESHOLD) {\n                logger.trace(message, logRecord.getThrown());\n            } else if (level <= DEBUG_LEVEL_THRESHOLD) {\n                logger.debug(message, logRecord.getThrown());"}
{"magic_number_smell": "    @Test\n    void checkAggregationFromOneRoute() throws Exception {\n        mock.expectedMessageCount(VALUES.length);\n        mock.expectedBodiesReceived(IntStream.of(VALUES).reduce(0, (a, b) -> a + b));\n\n        IntStream.of(VALUES).forEach(\n                i -> producer.sendBodyAndHeader(i, CORRELATOR, CORRELATOR));", "refactored_code": "    private static final int SUM = IntStream.of(VALUES).reduce(0, (a, b) -> a + b);\n    @Test\n    void checkAggregationFromOneRoute() throws Exception {\n        mock.expectedMessageCount(VALUES.length);\n        mock.expectedBodiesReceived(SUM);\n\n        IntStream.of(VALUES).forEach(\n                i -> producer.sendBodyAndHeader(i, CORRELATOR, CORRELATOR));"}
{"magic_number_smell": "            public void configure() {\n                fromF(\"coap://localhost:%d/TestResource\", PORT).convertBodyTo(String.class).transform(body().prepend(\"Hello \"));\n\n                fromF(\"coap+tcp://localhost:%d/TestResource\", AvailablePortFinder.getNextAvailable()).convertBodyTo(String.class)\n                        .transform(body().prepend(\"Hello \"));\n\n                from(\"direct:start\").toF(\"coap://localhost:%d/TestResource\", PORT).to(\"mock:result\");", "refactored_code": "    protected static final int TCP_PORT = AvailablePortFinder.getNextAvailable();\n            public void configure() {\n                fromF(\"coap://localhost:%d/TestResource\", PORT).convertBodyTo(String.class).transform(body().prepend(\"Hello \"));\n\n                fromF(\"coap+tcp://localhost:%d/TestResource\", TCP_PORT).convertBodyTo(String.class)\n                        .transform(body().prepend(\"Hello \"));\n\n                from(\"direct:start\").toF(\"coap://localhost:%d/TestResource\", PORT).to(\"mock:result\");"}
{"magic_number_smell": "            @Override\n            public void configure() {\n\n                fromF(getProtocol() + \"://localhost:%d/TestResource?sslContextParameters=#serviceSSLContextParameters\", AvailablePortFinder.getNextAvailable())\n                        .transform(body().prepend(\"Hello \"));\n\n                fromF(getProtocol()", "refactored_code": "    private static final int PORT = AvailablePortFinder.getNextAvailable();\n            @Override\n            public void configure() {\n\n                fromF(getProtocol() + \"://localhost:%d/TestResource?sslContextParameters=#serviceSSLContextParameters\", PORT)\n                        .transform(body().prepend(\"Hello \"));\n\n                fromF(getProtocol()"}
{"magic_number_smell": "    }\n\n    protected CoapClient createClient(String path) {\n        return createClient(path, AvailablePortFinder.getNextAvailable());\n    }\n\n    protected CoapClient createClient(String path, int port) {", "refactored_code": "    protected static final int PORT = AvailablePortFinder.getNextAvailable();\n    }\n\n    protected CoapClient createClient(String path) {\n        return createClient(path, PORT);\n    }\n\n    protected CoapClient createClient(String path, int port) {"}
{"magic_number_smell": "    private static ConsulRegistry registry;\n\n    public class ConsulTestClass implements Serializable {\n        private static final long -3482971969351609265L = -4815945688487114891L;\n\n        public String hello(String name) {\n            return \"Hello \" + name;", "refactored_code": "    private static final long serialVersionUID = -3482971969351609265L;\n    private static ConsulRegistry registry;\n\n    public class ConsulTestClass implements Serializable {\n        private static final long serialVersionUID = -4815945688487114891L;\n\n        public String hello(String name) {\n            return \"Hello \" + name;"}
{"magic_number_smell": "\n        client = getConsul().agentClient();\n\n        registrations = new ArrayList<>(5);\n        expectedBodies = new ArrayList<>(5);\n\n        for (int i = 0; i < 5; i++) {", "refactored_code": "    private static final int SERVICE_COUNT = 5;\n\n        client = getConsul().agentClient();\n\n        registrations = new ArrayList<>(SERVICE_COUNT);\n        expectedBodies = new ArrayList<>(SERVICE_COUNT);\n\n        for (int i = 0; i < SERVICE_COUNT; i++) {"}
{"magic_number_smell": "        // check that service has been registered\n        List<CatalogService> services = catalog.getService(SERVICE_NAME).getResponse();\n        assertEquals(1, services.size());\n        assertEquals(AvailablePortFinder.getNextAvailable(), services.get(0).getServicePort());\n        assertEquals(\"localhost\", services.get(0).getServiceAddress());\n        assertTrue(services.get(0).getServiceTags().contains(ServiceDefinition.SERVICE_META_PROTOCOL + \"=http\"));\n        assertTrue(services.get(0).getServiceTags().contains(ServiceDefinition.SERVICE_META_PATH + \"=/service/endpoint\"));", "refactored_code": "    protected static final int SERVICE_PORT = AvailablePortFinder.getNextAvailable();\n        // check that service has been registered\n        List<CatalogService> services = catalog.getService(SERVICE_NAME).getResponse();\n        assertEquals(1, services.size());\n        assertEquals(SERVICE_PORT, services.get(0).getServicePort());\n        assertEquals(\"localhost\", services.get(0).getServiceAddress());\n        assertTrue(services.get(0).getServiceTags().contains(ServiceDefinition.SERVICE_META_PROTOCOL + \"=http\"));\n        assertTrue(services.get(0).getServiceTags().contains(ServiceDefinition.SERVICE_META_PATH + \"=/service/endpoint\"));"}
{"magic_number_smell": "    private boolean waitForStability(final String lastSequence) {\n        BlockingTask task = Tasks.foregroundTask()\n                .withBudget(Budgets.iterationBudget()\n                        .withMaxIterations(8)\n                        .withInterval(Duration.ofSeconds(3))\n                        .build())\n                .withName(\"couchdb-wait-for-stability\")", "refactored_code": "    private static final int MAX_DB_ERROR_REPEATS = 8;\n    private boolean waitForStability(final String lastSequence) {\n        BlockingTask task = Tasks.foregroundTask()\n                .withBudget(Budgets.iterationBudget()\n                        .withMaxIterations(MAX_DB_ERROR_REPEATS)\n                        .withInterval(Duration.ofSeconds(3))\n                        .build())\n                .withName(\"couchdb-wait-for-stability\")"}
{"magic_number_smell": "    private String username;\n    @UriParam(label = \"security\", secret = true)\n    private String password;\n    @UriParam(label = \"consumer\", defaultValue = \"\" + 30000, javaType = \"java.time.Duration\")\n    private long heartbeat = 30000;\n    @UriParam\n    private boolean createDatabase;", "refactored_code": "    public static final long DEFAULT_HEARTBEAT = 30000;\n    private String username;\n    @UriParam(label = \"security\", secret = true)\n    private String password;\n    @UriParam(label = \"consumer\", defaultValue = \"\" + DEFAULT_HEARTBEAT, javaType = \"java.time.Duration\")\n    private long heartbeat = DEFAULT_HEARTBEAT;\n    @UriParam\n    private boolean createDatabase;"}
{"magic_number_smell": "        for (PGPPublicKey key : keys) {\n            encGen.addMethod(new JcePublicKeyKeyEncryptionMethodGenerator(key));\n        }\n        OutputStream encOut = encGen.open(outputStream, new byte[16 * 1024]);\n\n        OutputStream comOut;\n        if (withCompressedDataPacket) {", "refactored_code": "    private static final int BUFFER_SIZE = 16 * 1024;\n        for (PGPPublicKey key : keys) {\n            encGen.addMethod(new JcePublicKeyKeyEncryptionMethodGenerator(key));\n        }\n        OutputStream encOut = encGen.open(outputStream, new byte[BUFFER_SIZE]);\n\n        OutputStream comOut;\n        if (withCompressedDataPacket) {"}
{"magic_number_smell": "    @Test\n    void testCsvUnMarshal() throws Exception {\n        result.reset();\n        result.expectedMessageCount(3);\n\n        String message = \"\";\n        for (int i = 0; i < 3; ++i) {", "refactored_code": "    public static final int EXPECTED_COUNT = 3;\n    @Test\n    void testCsvUnMarshal() throws Exception {\n        result.reset();\n        result.expectedMessageCount(EXPECTED_COUNT);\n\n        String message = \"\";\n        for (int i = 0; i < EXPECTED_COUNT; ++i) {"}
{"magic_number_smell": "     * @since         2.1\n     */\n    public ReaderInputStream(Reader reader, CharsetEncoder encoder) {\n        this(reader, encoder, 1024);\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_BUFFER_SIZE = 1024;\n     * @since         2.1\n     */\n    public ReaderInputStream(Reader reader, CharsetEncoder encoder) {\n        this(reader, encoder, DEFAULT_BUFFER_SIZE);\n    }\n\n    /**"}
{"magic_number_smell": "public class CxfRsConsumerClientDisconnectedTest extends CamelTestSupport {\n    private static final int CXFTestSupport.getPort1() = CXFTestSupport.getPort1();\n    private static final String CONTEXT = \"/CxfRsConsumerClientDisconnectedTest\";\n    private static final String CXT = CXFTestSupport.getPort1() + CONTEXT;\n\n    private String cxfRsEndpointUri = \"cxfrs://http://localhost:\" + CXT + \"/rest?synchronous=\" + isSynchronous()\n                                      + \"&dataFormat=PAYLOAD&resourceClasses=org.apache.camel.component.cxf.jaxrs.testbean.CustomerService\";", "refactored_code": "    private static final int PORT = CXFTestSupport.getPort1();\npublic class CxfRsConsumerClientDisconnectedTest extends CamelTestSupport {\n    private static final int PORT = CXFTestSupport.getPort1();\n    private static final String CONTEXT = \"/CxfRsConsumerClientDisconnectedTest\";\n    private static final String CXT = PORT + CONTEXT;\n\n    private String cxfRsEndpointUri = \"cxfrs://http://localhost:\" + CXT + \"/rest?synchronous=\" + isSynchronous()\n                                      + \"&dataFormat=PAYLOAD&resourceClasses=org.apache.camel.component.cxf.jaxrs.testbean.CustomerService\";"}
{"magic_number_smell": "public class CxfConsumerClientDisconnectedTest extends CamelTestSupport {\n    private static final int CXFTestSupport.getPort1() = CXFTestSupport.getPort1();\n    private static final String CONTEXT = \"/CxfConsumerClientDisconnectedTest\";\n    private static final String CXT = CXFTestSupport.getPort1() + CONTEXT;\n\n    private String cxfRsEndpointUri = \"cxf://http://localhost:\" + CXT + \"/rest?synchronous=\" + isSynchronous()\n                                      + \"&serviceClass=org.apache.camel.component.cxf.jaxws.ServiceProvider&dataFormat=PAYLOAD\";", "refactored_code": "    private static final int PORT = CXFTestSupport.getPort1();\npublic class CxfConsumerClientDisconnectedTest extends CamelTestSupport {\n    private static final int PORT = CXFTestSupport.getPort1();\n    private static final String CONTEXT = \"/CxfConsumerClientDisconnectedTest\";\n    private static final String CXT = PORT + CONTEXT;\n\n    private String cxfRsEndpointUri = \"cxf://http://localhost:\" + CXT + \"/rest?synchronous=\" + isSynchronous()\n                                      + \"&serviceClass=org.apache.camel.component.cxf.jaxws.ServiceProvider&dataFormat=PAYLOAD\";"}
{"magic_number_smell": "public class CxfPayLoadBareSoapTest extends CamelTestSupport {\n\n    private static final int AvailablePortFinder.getNextAvailable() = AvailablePortFinder.getNextAvailable();\n    private static final String ORIGINAL_URL = String.format(\"http://localhost:%s/original/Service\", AvailablePortFinder.getNextAvailable());\n    private static final String PROXY_URL = String.format(\"http://localhost:%s/proxy/Service\", AvailablePortFinder.getNextAvailable());\n    private static final BareSoapServiceImpl IMPLEMENTATION = new BareSoapServiceImpl();\n", "refactored_code": "    private static final int PORT = AvailablePortFinder.getNextAvailable();\npublic class CxfPayLoadBareSoapTest extends CamelTestSupport {\n\n    private static final int PORT = AvailablePortFinder.getNextAvailable();\n    private static final String ORIGINAL_URL = String.format(\"http://localhost:%s/original/Service\", PORT);\n    private static final String PROXY_URL = String.format(\"http://localhost:%s/proxy/Service\", PORT);\n    private static final BareSoapServiceImpl IMPLEMENTATION = new BareSoapServiceImpl();\n"}
{"magic_number_smell": "@TestInstance(TestInstance.Lifecycle.PER_CLASS)\npublic class CxfProducerSessionTest extends CamelTestSupport {\n    private static final int CXFTestSupport.getPort1() = CXFTestSupport.getPort1();\n    private static final String SIMPLE_SERVER_ADDRESS = \"http://127.0.0.1:\" + CXFTestSupport.getPort1() + \"/CxfProducerSessionTest/test\";\n    private static final String REQUEST_MESSAGE_EXPRESSION\n            = \"<ns1:echo xmlns:ns1=\\\"http://jaxws.cxf.component.camel.apache.org/\\\"><arg0>${in.body}</arg0></ns1:echo>\";\n    private static final Map<String, String> NAMESPACES", "refactored_code": "    private static final int PORT = CXFTestSupport.getPort1();\n@TestInstance(TestInstance.Lifecycle.PER_CLASS)\npublic class CxfProducerSessionTest extends CamelTestSupport {\n    private static final int PORT = CXFTestSupport.getPort1();\n    private static final String SIMPLE_SERVER_ADDRESS = \"http://127.0.0.1:\" + PORT + \"/CxfProducerSessionTest/test\";\n    private static final String REQUEST_MESSAGE_EXPRESSION\n            = \"<ns1:echo xmlns:ns1=\\\"http://jaxws.cxf.component.camel.apache.org/\\\"><arg0>${in.body}</arg0></ns1:echo>\";\n    private static final Map<String, String> NAMESPACES"}
{"magic_number_smell": "\n        // we cannot convert directly to Customer as we need camel-jaxb\n        assertThrows(CamelExecutionException.class, () -> template\n                .requestBodyAndHeader(\"cxfrs:http://localhost:\" + CXFTestSupport.getPort1()\n                                      + \"/CxfOperationExceptionTest/customerservice/customers?throwExceptionOnFailure=true\",\n                        input,\n                        Exchange.HTTP_METHOD, \"POST\", String.class));", "refactored_code": "    private static final int PORT1 = CXFTestSupport.getPort1();\n\n        // we cannot convert directly to Customer as we need camel-jaxb\n        assertThrows(CamelExecutionException.class, () -> template\n                .requestBodyAndHeader(\"cxfrs:http://localhost:\" + PORT1\n                                      + \"/CxfOperationExceptionTest/customerservice/customers?throwExceptionOnFailure=true\",\n                        input,\n                        Exchange.HTTP_METHOD, \"POST\", String.class));"}
{"magic_number_smell": "    private static final String POST_REQUEST = \"<Customer><name>Jack</name></Customer>\";\n\n    protected int getPort() {\n        return CXFTestSupport.getPort1();\n    }\n\n    @Override", "refactored_code": "    private static final int PORT = CXFTestSupport.getPort1();\n    private static final String POST_REQUEST = \"<Customer><name>Jack</name></Customer>\";\n\n    protected int getPort() {\n        return PORT;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    protected int getPort() {\n        return CXFTestSupport.getPort5();\n    }\n\n    @Override", "refactored_code": "    private static final int PORT2 = CXFTestSupport.getPort5();\n\n    @Override\n    protected int getPort() {\n        return PORT2;\n    }\n\n    @Override"}
{"magic_number_smell": "    private Undertow server;\n\n    static {\n        System.setProperty(\"CXFTestSupport.undertowPort\", Integer.toString(AvailablePortFinder.getNextAvailable()));\n    }\n\n    @Override", "refactored_code": "    private static final int UNDERTOW_PORT = AvailablePortFinder.getNextAvailable();\n    private Undertow server;\n\n    static {\n        System.setProperty(\"CXFTestSupport.undertowPort\", Integer.toString(UNDERTOW_PORT));\n    }\n\n    @Override"}
{"magic_number_smell": "    @Test\n    void camelShouldConsumeDebeziumMessages() throws Exception {\n        // add initial lines to the file\n        appendLinesToSource(5);\n\n        // assert exchanges\n        to.expectedMessageCount(linesAdded);", "refactored_code": "    private static final int NUMBER_OF_LINES = 5;\n    @Test\n    void camelShouldConsumeDebeziumMessages() throws Exception {\n        // add initial lines to the file\n        appendLinesToSource(NUMBER_OF_LINES);\n\n        // assert exchanges\n        to.expectedMessageCount(linesAdded);"}
{"magic_number_smell": "    }\n\n    private static long scanTimeUnits(final long timeInMillis, final StringBuilder timeBuilder) {\n        if (timeInMillis >= Duration.ofDays(1).toMillis()) {\n            final long proceededTime\n                    = processSingleTimeUnit(timeInMillis, Duration.ofDays(1).toMillis(), timeBuilder, \"d\");\n            return scanTimeUnits(proceededTime, timeBuilder);", "refactored_code": "    private static final int ONE_UNIT = 1;\n    }\n\n    private static long scanTimeUnits(final long timeInMillis, final StringBuilder timeBuilder) {\n        if (timeInMillis >= Duration.ofDays(ONE_UNIT).toMillis()) {\n            final long proceededTime\n                    = processSingleTimeUnit(timeInMillis, Duration.ofDays(ONE_UNIT).toMillis(), timeBuilder, \"d\");\n            return scanTimeUnits(proceededTime, timeBuilder);"}
{"magic_number_smell": "    }\n\n    protected void createJmxConnector(String host) throws IOException {\n        int registryPort = 1099;\n        String serviceUrlPath = DEFAULT_SERVICE_URL_PATH;\n        int connectorPort = DEFAULT_CONNECTION_PORT;\n", "refactored_code": "    public static final int DEFAULT_REGISTRY_PORT = 1099;\n    }\n\n    protected void createJmxConnector(String host) throws IOException {\n        int registryPort = DEFAULT_REGISTRY_PORT;\n        String serviceUrlPath = DEFAULT_SERVICE_URL_PATH;\n        int connectorPort = DEFAULT_CONNECTION_PORT;\n"}
{"magic_number_smell": "\n    private static final Logger LOGGER = LoggerFactory.getLogger(DisruptorComponent.class);\n\n    @Metadata(defaultValue = \"\" + 1024)\n    private int bufferSize = -1;\n    @Metadata(label = \"consumer\", defaultValue = \"1\")\n    private int defaultConcurrentConsumers = 1;", "refactored_code": "    public static final int DEFAULT_BUFFER_SIZE = 1024;\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(DisruptorComponent.class);\n\n    @Metadata(defaultValue = \"\" + DEFAULT_BUFFER_SIZE)\n    private int bufferSize = -1;\n    @Metadata(label = \"consumer\", defaultValue = \"1\")\n    private int defaultConcurrentConsumers = 1;"}
{"magic_number_smell": "\n    private static final String MOCK_URI = \"mock:blockWhenFullOutput\";\n\n    private static final String DEFAULT_URI = \"disruptor:foo?size=\" + 8;\n    private static final String EXCEPTION_WHEN_FULL_URI = \"disruptor:foo?blockWhenFull=false&size=\"\n                                                          + 8;\n", "refactored_code": "    private static final int QUEUE_SIZE = 8;\n\n    private static final String MOCK_URI = \"mock:blockWhenFullOutput\";\n\n    private static final String DEFAULT_URI = \"disruptor:foo?size=\" + QUEUE_SIZE;\n    private static final String EXCEPTION_WHEN_FULL_URI = \"disruptor:foo?blockWhenFull=false&size=\"\n                                                          + QUEUE_SIZE;\n"}
{"magic_number_smell": "    void testCompareToAndEqual() {\n        Mockito.when(endpoint.getEndpointUri()).thenReturn(TEST_URI);\n        Mockito.when(prioritizedFilter.id()).thenReturn(TEST_ID);\n        Mockito.when(prioritizedFilter.priority()).thenReturn(10);\n        PrioritizedFilter testProcessor\n                = new PrioritizedFilter(\n                        TEST_ID, 10, predicate, endpoint.getEndpointUri(), prioritizedFilterStatistics);", "refactored_code": "    public static final int TEST_PRIORITY = 10;\n    void testCompareToAndEqual() {\n        Mockito.when(endpoint.getEndpointUri()).thenReturn(TEST_URI);\n        Mockito.when(prioritizedFilter.id()).thenReturn(TEST_ID);\n        Mockito.when(prioritizedFilter.priority()).thenReturn(TEST_PRIORITY);\n        PrioritizedFilter testProcessor\n                = new PrioritizedFilter(\n                        TEST_ID, TEST_PRIORITY, predicate, endpoint.getEndpointUri(), prioritizedFilterStatistics);"}
{"magic_number_smell": "    @Test\n    void checkAggregationFromOneRoute() throws Exception {\n        mock.expectedMessageCount(VALUES.length);\n        mock.expectedBodiesReceived(IntStream.of(VALUES).reduce(0, (a, b) -> a + b));\n\n        IntStream.of(VALUES).forEach(\n                i -> producer.sendBodyAndHeader(i, CORRELATOR, CORRELATOR));", "refactored_code": "    private static final int SUM = IntStream.of(VALUES).reduce(0, (a, b) -> a + b);\n    @Test\n    void checkAggregationFromOneRoute() throws Exception {\n        mock.expectedMessageCount(VALUES.length);\n        mock.expectedBodiesReceived(SUM);\n\n        IntStream.of(VALUES).forEach(\n                i -> producer.sendBodyAndHeader(i, CORRELATOR, CORRELATOR));"}
{"magic_number_smell": "\n        final int batchSizePart2 = 13;\n        // Fill the vent backlog ( > 1000)\n        for (int i = 0; i < 2_345 + batchSizePart2; i++) {\n            client.getKVClient().put(ByteSequence.from(key.getBytes()), ByteSequence.from((\"v\" + i).getBytes())).get();\n            client.getKVClient().put(ByteSequence.from((key + \"/\" + i).getBytes()), ByteSequence.from(\"v\".getBytes())).get();\n        }", "refactored_code": "    private static final int BATCH_SIZE_PART_1 = 2_345;\n\n        final int batchSizePart2 = 13;\n        // Fill the vent backlog ( > 1000)\n        for (int i = 0; i < BATCH_SIZE_PART_1 + batchSizePart2; i++) {\n            client.getKVClient().put(ByteSequence.from(key.getBytes()), ByteSequence.from((\"v\" + i).getBytes())).get();\n            client.getKVClient().put(ByteSequence.from((key + \"/\" + i).getBytes()), ByteSequence.from(\"v\".getBytes())).get();\n        }"}
{"magic_number_smell": "\n    public ExecEndpoint(String uri, ExecComponent component) {\n        super(uri, component);\n        this.timeout = Long.MAX_VALUE;\n        this.binding = new DefaultExecBinding();\n    }\n", "refactored_code": "    public static final long NO_TIMEOUT = Long.MAX_VALUE;\n\n    public ExecEndpoint(String uri, ExecComponent component) {\n        super(uri, component);\n        this.timeout = NO_TIMEOUT;\n        this.binding = new DefaultExecBinding();\n    }\n"}
{"magic_number_smell": "        // sleep returns(observed on Windows XP)\n        int t = 0;\n        System.out.println(\"Sleeping every \" + String.valueOf(sleepInterval) + \" ms\");\n        for (; t < 60 * 1000 % sleepInterval; t += sleepInterval) {\n            Thread.sleep(sleepInterval);\n        }\n", "refactored_code": "    public static final int SLEEP_TIME = 60 * 1000;\n        // sleep returns(observed on Windows XP)\n        int t = 0;\n        System.out.println(\"Sleeping every \" + String.valueOf(sleepInterval) + \" ms\");\n        for (; t < SLEEP_TIME % sleepInterval; t += sleepInterval) {\n            Thread.sleep(sleepInterval);\n        }\n"}
{"magic_number_smell": "\n    @Override\n    protected void setDefaultPort() {\n        setPort(21);\n    }\n\n    public String getAccount() {", "refactored_code": "    public static final int DEFAULT_FTP_PORT = 21;\n\n    @Override\n    protected void setDefaultPort() {\n        setPort(DEFAULT_FTP_PORT);\n    }\n\n    public String getAccount() {"}
{"magic_number_smell": "\n    @Override\n    protected void setDefaultPort() {\n        setPort(22);\n    }\n\n    public String getKnownHostsFile() {", "refactored_code": "    public static final int DEFAULT_SFTP_PORT = 22;\n\n    @Override\n    protected void setDefaultPort() {\n        setPort(DEFAULT_SFTP_PORT);\n    }\n\n    public String getKnownHostsFile() {"}
{"magic_number_smell": "\n        // if exception is null, it means that result was ok\n        if (sftpException == null) {\n            exchange.getIn().setHeader(FtpConstants.FTP_REPLY_CODE, 0);\n            exchange.getIn().setHeader(FtpConstants.FTP_REPLY_STRING, OK_MESSAGE);\n        } else {\n            // store client reply information after the operation", "refactored_code": "    private static final int OK_STATUS = 0;\n\n        // if exception is null, it means that result was ok\n        if (sftpException == null) {\n            exchange.getIn().setHeader(FtpConstants.FTP_REPLY_CODE, OK_STATUS);\n            exchange.getIn().setHeader(FtpConstants.FTP_REPLY_STRING, OK_MESSAGE);\n        } else {\n            // store client reply information after the operation"}
{"magic_number_smell": "        // create big file\n        try (PrintWriter writer = new PrintWriter(\n                new FileOutputStream(testDirectory.toString() + \"/bigdata.txt\"), true, StandardCharsets.UTF_8)) {\n            for (int i = 0; i < 5_000; i++) {\n                writer.printf(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ%d%n\", i);\n            }\n        }", "refactored_code": "    private static final int SIZE = 5_000;\n        // create big file\n        try (PrintWriter writer = new PrintWriter(\n                new FileOutputStream(testDirectory.toString() + \"/bigdata.txt\"), true, StandardCharsets.UTF_8)) {\n            for (int i = 0; i < SIZE; i++) {\n                writer.printf(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ%d%n\", i);\n            }\n        }"}
{"magic_number_smell": "    @BeforeEach\n    public void setUp() throws Exception {\n        super.setUp();\n        for (int i = 0; i < 100; i++) {\n            template.sendBodyAndHeader(\"file://{{ftp.root.dir}}/filestress\", \"Hello World\", Exchange.FILE_NAME,\n                    i + \".txt\");\n        }", "refactored_code": "    private final int files = 100;\n    @BeforeEach\n    public void setUp() throws Exception {\n        super.setUp();\n        for (int i = 0; i < files; i++) {\n            template.sendBodyAndHeader(\"file://{{ftp.root.dir}}/filestress\", \"Hello World\", Exchange.FILE_NAME,\n                    i + \".txt\");\n        }"}
{"magic_number_smell": "    @BeforeAll\n    public void setupProxy() {\n        proxyServer = DefaultHttpProxyServer.bootstrap()\n                .withPort(AvailablePortFinder.getNextAvailable())\n                .withProxyAuthenticator(new ProxyAuthenticator() {\n                    @Override\n                    public boolean authenticate(String userName, String password) {", "refactored_code": "    private final int proxyPort = AvailablePortFinder.getNextAvailable();\n    @BeforeAll\n    public void setupProxy() {\n        proxyServer = DefaultHttpProxyServer.bootstrap()\n                .withPort(proxyPort)\n                .withProxyAuthenticator(new ProxyAuthenticator() {\n                    @Override\n                    public boolean authenticate(String userName, String password) {"}
{"magic_number_smell": "    @BeforeAll\n    public void setupProxy() {\n        proxyServer = DefaultHttpProxyServer.bootstrap()\n                .withPort(AvailablePortFinder.getNextAvailable())\n                .withProxyAuthenticator(new ProxyAuthenticator() {\n                    @Override\n                    public boolean authenticate(String userName, String password) {", "refactored_code": "    private final int proxyPort = AvailablePortFinder.getNextAvailable();\n    @BeforeAll\n    public void setupProxy() {\n        proxyServer = DefaultHttpProxyServer.bootstrap()\n                .withPort(proxyPort)\n                .withProxyAuthenticator(new ProxyAuthenticator() {\n                    @Override\n                    public boolean authenticate(String userName, String password) {"}
{"magic_number_smell": "    private final String startingSha;\n\n    // keep a chunk of the last 100 hashes, so we can filter out duplicates\n    private final Queue<String> commitHashes = new LinkedBlockingQueue<>(1000);\n    private volatile String lastSha;\n\n    public CommitConsumer(GitHubEndpoint endpoint, Processor processor, String branchName,", "refactored_code": "    private static final int CAPACITY = 1000; // in case there is a lot of commits and this runs not very frequently\n    private final String startingSha;\n\n    // keep a chunk of the last 100 hashes, so we can filter out duplicates\n    private final Queue<String> commitHashes = new LinkedBlockingQueue<>(CAPACITY);\n    private volatile String lastSha;\n\n    public CommitConsumer(GitHubEndpoint endpoint, Processor processor, String branchName,"}
{"magic_number_smell": "                if (range != null && !range.isEmpty()) {\n                    String rangeString = range.get(0).substring(\"range=\".length());\n                    if (\"0-\".equals(rangeString)) {\n                        resp.setStatusCode(200);\n                    } else if (rangeString.startsWith(\"-\")) {\n                        // we don't support negative offsets yet\n                        resp.setStatusCode(400);", "refactored_code": "    private static final int OK = 200;\n                if (range != null && !range.isEmpty()) {\n                    String rangeString = range.get(0).substring(\"range=\".length());\n                    if (\"0-\".equals(rangeString)) {\n                        resp.setStatusCode(OK);\n                    } else if (rangeString.startsWith(\"-\")) {\n                        // we don't support negative offsets yet\n                        resp.setStatusCode(400);"}
{"magic_number_smell": "\n    @BeforeEach\n    public void startGrpcChannels() {\n        syncRequestChannel = ManagedChannelBuilder.forAddress(\"localhost\", AvailablePortFinder.getNextAvailable()).usePlaintext().build();\n        asyncRequestChannel\n                = ManagedChannelBuilder.forAddress(\"localhost\", GRPC_ASYNC_REQUEST_TEST_PORT).usePlaintext().build();\n        blockingStub = PingPongGrpc.newBlockingStub(syncRequestChannel);", "refactored_code": "    private static final int GRPC_SYNC_REQUEST_TEST_PORT = AvailablePortFinder.getNextAvailable();\n\n    @BeforeEach\n    public void startGrpcChannels() {\n        syncRequestChannel = ManagedChannelBuilder.forAddress(\"localhost\", GRPC_SYNC_REQUEST_TEST_PORT).usePlaintext().build();\n        asyncRequestChannel\n                = ManagedChannelBuilder.forAddress(\"localhost\", GRPC_ASYNC_REQUEST_TEST_PORT).usePlaintext().build();\n        blockingStub = PingPongGrpc.newBlockingStub(syncRequestChannel);"}
{"magic_number_smell": "            public void run() {\n                final CountDownLatch latch = new CountDownLatch(1);\n                ManagedChannel asyncRequestChannel\n                        = NettyChannelBuilder.forAddress(\"localhost\", AvailablePortFinder.getNextAvailable()).usePlaintext().build();\n                PingPongGrpc.PingPongStub asyncNonBlockingStub = PingPongGrpc.newStub(asyncRequestChannel);\n\n                PongResponseStreamObserver responseObserver = new PongResponseStreamObserver(latch);", "refactored_code": "    private static final int GRPC_ASYNC_REQUEST_TEST_PORT = AvailablePortFinder.getNextAvailable();\n            public void run() {\n                final CountDownLatch latch = new CountDownLatch(1);\n                ManagedChannel asyncRequestChannel\n                        = NettyChannelBuilder.forAddress(\"localhost\", GRPC_ASYNC_REQUEST_TEST_PORT).usePlaintext().build();\n                PingPongGrpc.PingPongStub asyncNonBlockingStub = PingPongGrpc.newStub(asyncRequestChannel);\n\n                PongResponseStreamObserver responseObserver = new PongResponseStreamObserver(latch);"}
{"magic_number_smell": "\n    @BeforeEach\n    public void startGrpcChannels() {\n        syncRequestChannel = ManagedChannelBuilder.forAddress(\"localhost\", AvailablePortFinder.getNextAvailable()).usePlaintext().build();\n        blockingStub = PingPongGrpc.newBlockingStub(syncRequestChannel);\n        nonBlockingStub = PingPongGrpc.newStub(syncRequestChannel);\n    }", "refactored_code": "    private static final int GRPC_SYNC_REQUEST_TEST_PORT = AvailablePortFinder.getNextAvailable();\n\n    @BeforeEach\n    public void startGrpcChannels() {\n        syncRequestChannel = ManagedChannelBuilder.forAddress(\"localhost\", GRPC_SYNC_REQUEST_TEST_PORT).usePlaintext().build();\n        blockingStub = PingPongGrpc.newBlockingStub(syncRequestChannel);\n        nonBlockingStub = PingPongGrpc.newStub(syncRequestChannel);\n    }"}
{"magic_number_smell": "    @BeforeEach\n    public void startGrpcChannels() {\n        asyncOnNextChannel\n                = ManagedChannelBuilder.forAddress(\"localhost\", AvailablePortFinder.getNextAvailable()).usePlaintext().build();\n        asyncOnCompletedChannel\n                = ManagedChannelBuilder.forAddress(\"localhost\", GRPC_ASYNC_COMPLETED_REQUEST_TEST_PORT).usePlaintext().build();\n        asyncOnNextStub = PingPongGrpc.newStub(asyncOnNextChannel);", "refactored_code": "    private static final int GRPC_ASYNC_NEXT_REQUEST_TEST_PORT = AvailablePortFinder.getNextAvailable();\n    @BeforeEach\n    public void startGrpcChannels() {\n        asyncOnNextChannel\n                = ManagedChannelBuilder.forAddress(\"localhost\", GRPC_ASYNC_NEXT_REQUEST_TEST_PORT).usePlaintext().build();\n        asyncOnCompletedChannel\n                = ManagedChannelBuilder.forAddress(\"localhost\", GRPC_ASYNC_COMPLETED_REQUEST_TEST_PORT).usePlaintext().build();\n        asyncOnNextStub = PingPongGrpc.newStub(asyncOnNextChannel);"}
{"magic_number_smell": "\n        Assumptions.assumeTrue(sslContext instanceof OpenSslClientContext || sslContext instanceof JdkSslContext);\n\n        tlsChannel = NettyChannelBuilder.forAddress(\"localhost\", AvailablePortFinder.getNextAvailable())\n                .sslContext(sslContext)\n                .build();\n", "refactored_code": "    private static final int GRPC_TLS_TEST_PORT = AvailablePortFinder.getNextAvailable();\n\n        Assumptions.assumeTrue(sslContext instanceof OpenSslClientContext || sslContext instanceof JdkSslContext);\n\n        tlsChannel = NettyChannelBuilder.forAddress(\"localhost\", GRPC_TLS_TEST_PORT)\n                .sslContext(sslContext)\n                .build();\n"}
{"magic_number_smell": "    @BeforeEach\n    public void startGrpcChannels() {\n        interceptRequestChannel\n                = ManagedChannelBuilder.forAddress(\"localhost\", AvailablePortFinder.getNextAvailable()).usePlaintext().build();\n        nointerceptRequestChannel\n                = ManagedChannelBuilder.forAddress(\"localhost\", GRPC_REQUEST_NO_INTERCEPT_TEST_PORT).usePlaintext().build();\n        interceptBlockingStub = PingPongGrpc.newBlockingStub(interceptRequestChannel);", "refactored_code": "    private static final int GRPC_REQUEST_INTERCEPT_TEST_PORT = AvailablePortFinder.getNextAvailable();\n    @BeforeEach\n    public void startGrpcChannels() {\n        interceptRequestChannel\n                = ManagedChannelBuilder.forAddress(\"localhost\", GRPC_REQUEST_INTERCEPT_TEST_PORT).usePlaintext().build();\n        nointerceptRequestChannel\n                = ManagedChannelBuilder.forAddress(\"localhost\", GRPC_REQUEST_NO_INTERCEPT_TEST_PORT).usePlaintext().build();\n        interceptBlockingStub = PingPongGrpc.newBlockingStub(interceptRequestChannel);"}
{"magic_number_smell": "\n    @BeforeAll\n    public static void startGrpcServer() throws Exception {\n        grpcServer = ServerBuilder.forPort(AvailablePortFinder.getNextAvailable()).addService(new GrpcProducerClientInterceptorTest.PingPongImpl())\n                .build().start();\n        LOG.info(\"gRPC server started on port {}\", AvailablePortFinder.getNextAvailable());\n    }", "refactored_code": "    private static final int GRPC_TEST_PORT = AvailablePortFinder.getNextAvailable();\n\n    @BeforeAll\n    public static void startGrpcServer() throws Exception {\n        grpcServer = ServerBuilder.forPort(GRPC_TEST_PORT).addService(new GrpcProducerClientInterceptorTest.PingPongImpl())\n                .build().start();\n        LOG.info(\"gRPC server started on port {}\", GRPC_TEST_PORT);\n    }"}
{"magic_number_smell": "\n        Assumptions.assumeTrue(sslContext instanceof OpenSslClientContext || sslContext instanceof JdkSslContext);\n\n        grpcServerWithTLS = NettyServerBuilder.forPort(AvailablePortFinder.getNextAvailable())\n                .sslContext(sslContext)\n                .addService(new PingPongImpl()).build().start();\n", "refactored_code": "    private static final int GRPC_TLS_TEST_PORT = AvailablePortFinder.getNextAvailable();\n\n        Assumptions.assumeTrue(sslContext instanceof OpenSslClientContext || sslContext instanceof JdkSslContext);\n\n        grpcServerWithTLS = NettyServerBuilder.forPort(GRPC_TLS_TEST_PORT)\n                .sslContext(sslContext)\n                .addService(new PingPongImpl()).build().start();\n"}
{"magic_number_smell": "    @BeforeEach\n    public void startGrpcServer() throws Exception {\n        pingPongServer = new PingPongImpl();\n        grpcServer = ServerBuilder.forPort(AvailablePortFinder.getNextAvailable()).addService(pingPongServer).build().start();\n        LOG.info(\"gRPC server started on port {}\", AvailablePortFinder.getNextAvailable());\n    }\n", "refactored_code": "    private static final int GRPC_TEST_PORT = AvailablePortFinder.getNextAvailable();\n    @BeforeEach\n    public void startGrpcServer() throws Exception {\n        pingPongServer = new PingPongImpl();\n        grpcServer = ServerBuilder.forPort(GRPC_TEST_PORT).addService(pingPongServer).build().start();\n        LOG.info(\"gRPC server started on port {}\", GRPC_TEST_PORT);\n    }\n"}
{"magic_number_smell": "\n    @BeforeAll\n    public static void startGrpcServer() throws Exception {\n        grpcServer = ServerBuilder.forPort(AvailablePortFinder.getNextAvailable()).addService(new PingPongImpl()).build().start();\n        LOG.info(\"gRPC server started on port {}\", AvailablePortFinder.getNextAvailable());\n    }\n", "refactored_code": "    private static final int GRPC_TEST_PORT = AvailablePortFinder.getNextAvailable();\n\n    @BeforeAll\n    public static void startGrpcServer() throws Exception {\n        grpcServer = ServerBuilder.forPort(GRPC_TEST_PORT).addService(new PingPongImpl()).build().start();\n        LOG.info(\"gRPC server started on port {}\", GRPC_TEST_PORT);\n    }\n"}
{"magic_number_smell": "\n    @BeforeAll\n    public static void beforeAll() throws Exception {\n        grpcServer = ServerBuilder.forPort(AvailablePortFinder.getNextAvailable()).addService(new PingPongImpl()).build().start();\n        LOG.info(\"gRPC server started on port {}\", AvailablePortFinder.getNextAvailable());\n    }\n", "refactored_code": "    private static final int GRPC_STUB_PORT = AvailablePortFinder.getNextAvailable();\n\n    @BeforeAll\n    public static void beforeAll() throws Exception {\n        grpcServer = ServerBuilder.forPort(GRPC_STUB_PORT).addService(new PingPongImpl()).build().start();\n        LOG.info(\"gRPC server started on port {}\", GRPC_STUB_PORT);\n    }\n"}
{"magic_number_smell": "\n    @BeforeAll\n    public static void beforeAll() throws Exception {\n        grpcServer = ServerBuilder.forPort(AvailablePortFinder.getNextAvailable()).addService(new PingPongImpl()).build().start();\n        LOG.info(\"gRPC server started on port {}\", AvailablePortFinder.getNextAvailable());\n    }\n", "refactored_code": "    private static final int GRPC_STUB_PORT = AvailablePortFinder.getNextAvailable();\n\n    @BeforeAll\n    public static void beforeAll() throws Exception {\n        grpcServer = ServerBuilder.forPort(GRPC_STUB_PORT).addService(new PingPongImpl()).build().start();\n        LOG.info(\"gRPC server started on port {}\", GRPC_STUB_PORT);\n    }\n"}
{"magic_number_smell": "\n    @BeforeAll\n    public static void beforeAll() throws Exception {\n        grpcServer = ServerBuilder.forPort(AvailablePortFinder.getNextAvailable()).addService(new PingPongImpl()).build().start();\n        LOG.info(\"gRPC server started on port {}\", AvailablePortFinder.getNextAvailable());\n    }\n", "refactored_code": "    private static final int GRPC_STUB_PORT = AvailablePortFinder.getNextAvailable();\n\n    @BeforeAll\n    public static void beforeAll() throws Exception {\n        grpcServer = ServerBuilder.forPort(GRPC_STUB_PORT).addService(new PingPongImpl()).build().start();\n        LOG.info(\"gRPC server started on port {}\", GRPC_STUB_PORT);\n    }\n"}
{"magic_number_smell": "\n    @BeforeEach\n    public void startGrpcChannels() {\n        syncRequestChannel = ManagedChannelBuilder.forAddress(\"localhost\", AvailablePortFinder.getNextAvailable()).usePlaintext().build();\n        asyncRequestChannel\n                = ManagedChannelBuilder.forAddress(\"localhost\", GRPC_ASYNC_REQUEST_TEST_PORT).usePlaintext().build();\n        blockingStub = PingPongGrpc.newBlockingStub(syncRequestChannel);", "refactored_code": "    private static final int GRPC_SYNC_REQUEST_TEST_PORT = AvailablePortFinder.getNextAvailable();\n\n    @BeforeEach\n    public void startGrpcChannels() {\n        syncRequestChannel = ManagedChannelBuilder.forAddress(\"localhost\", GRPC_SYNC_REQUEST_TEST_PORT).usePlaintext().build();\n        asyncRequestChannel\n                = ManagedChannelBuilder.forAddress(\"localhost\", GRPC_ASYNC_REQUEST_TEST_PORT).usePlaintext().build();\n        blockingStub = PingPongGrpc.newBlockingStub(syncRequestChannel);"}
{"magic_number_smell": "     * @throws java.lang.NullPointerException is config is null\n     */\n    HL7MLLPNettyDecoder(HL7MLLPConfig config) {\n        super(Integer.MAX_VALUE, true, Unpooled.copiedBuffer(\n                new char[] { config.getEndByte1(), config.getEndByte2() },\n                Charset.defaultCharset()));\n        this.config = config;", "refactored_code": "    private static final int MAX_FRAME_LENGTH = Integer.MAX_VALUE;\n     * @throws java.lang.NullPointerException is config is null\n     */\n    HL7MLLPNettyDecoder(HL7MLLPConfig config) {\n        super(MAX_FRAME_LENGTH, true, Unpooled.copiedBuffer(\n                new char[] { config.getEndByte1(), config.getEndByte2() },\n                Charset.defaultCharset()));\n        this.config = config;"}
{"magic_number_smell": "\n    private final JettyConfiguration jettyConfiguration = JettyConfigurationBuilder\n            .emptyTemplate()\n            .withPort(AvailablePortFinder.getNextAvailable())\n            .withContextPath(\"/session\")\n            .withContextHandlerConfiguration()\n            .withCustomizer(HttpProducerSessionTest::customizer)", "refactored_code": "    private static final int PORT = AvailablePortFinder.getNextAvailable();\n\n    private final JettyConfiguration jettyConfiguration = JettyConfigurationBuilder\n            .emptyTemplate()\n            .withPort(PORT)\n            .withContextPath(\"/session\")\n            .withContextHandlerConfiguration()\n            .withCustomizer(HttpProducerSessionTest::customizer)"}
{"magic_number_smell": "                        .setProperty(DMSProperties.ENGINE, constant(\"kafka\"))\n                        .setProperty(DMSProperties.ENGINE_VERSION, constant(ENGINE_VERSION))\n                        .setProperty(DMSProperties.SPECIFICATION, constant(SPECIFICATION))\n                        .setProperty(DMSProperties.0/*replace_this_with_storage_space*/, constant(0/*replace_this_with_storage_space*/))\n                        .setProperty(DMSProperties.PARTITION_NUM, constant(PARTITION_NUM))\n                        .setProperty(DMSProperties.VPC_ID, constant(VPC_ID))\n                        .setProperty(DMSProperties.SECURITY_GROUP_ID, constant(SECURITY_GROUP_ID))", "refactored_code": "    private static final int STORAGE_SPACE = 0/*replace_this_with_storage_space*/;\n                        .setProperty(DMSProperties.ENGINE, constant(\"kafka\"))\n                        .setProperty(DMSProperties.ENGINE_VERSION, constant(ENGINE_VERSION))\n                        .setProperty(DMSProperties.SPECIFICATION, constant(SPECIFICATION))\n                        .setProperty(DMSProperties.STORAGE_SPACE, constant(STORAGE_SPACE))\n                        .setProperty(DMSProperties.PARTITION_NUM, constant(PARTITION_NUM))\n                        .setProperty(DMSProperties.VPC_ID, constant(VPC_ID))\n                        .setProperty(DMSProperties.SECURITY_GROUP_ID, constant(SECURITY_GROUP_ID))"}
{"magic_number_smell": "                        .setProperty(DMSProperties.NAME, constant(NAME))\n                        .setProperty(DMSProperties.ENGINE, constant(\"rabbitmq\"))\n                        .setProperty(DMSProperties.ENGINE_VERSION, constant(ENGINE_VERSION))\n                        .setProperty(DMSProperties.0, constant(0))\n                        .setProperty(DMSProperties.ACCESS_USER, constant(ACCESS_USER))\n                        .setProperty(DMSProperties.PASSWORD, constant(PASSWORD))\n                        .setProperty(DMSProperties.VPC_ID, constant(VPC_ID))", "refactored_code": "    private static final int STORAGE_SPACE = 0; // replace_this_with_storage_space\n                        .setProperty(DMSProperties.NAME, constant(NAME))\n                        .setProperty(DMSProperties.ENGINE, constant(\"rabbitmq\"))\n                        .setProperty(DMSProperties.ENGINE_VERSION, constant(ENGINE_VERSION))\n                        .setProperty(DMSProperties.STORAGE_SPACE, constant(STORAGE_SPACE))\n                        .setProperty(DMSProperties.ACCESS_USER, constant(ACCESS_USER))\n                        .setProperty(DMSProperties.PASSWORD, constant(PASSWORD))\n                        .setProperty(DMSProperties.VPC_ID, constant(VPC_ID))"}
{"magic_number_smell": "        faceDetailMap.put(\"y\", 100);\n\n        return new RunCelebrityRecognitionResponse().withResult(Collections\n                .singletonList(new CelebrityRecognitionResultBody().withConfidence(0.8f)\n                        .withFaceDetail(faceDetailMap)\n                        .withLabel(CELEBRITY_RECOGNITION_RESULT_LABEL)));\n    }", "refactored_code": "    public static final float CELEBRITY_RECOGNITION_RESULT_CONFIDENCE = 0.8f;\n        faceDetailMap.put(\"y\", 100);\n\n        return new RunCelebrityRecognitionResponse().withResult(Collections\n                .singletonList(new CelebrityRecognitionResultBody().withConfidence(CELEBRITY_RECOGNITION_RESULT_CONFIDENCE)\n                        .withFaceDetail(faceDetailMap)\n                        .withLabel(CELEBRITY_RECOGNITION_RESULT_LABEL)));\n    }"}
{"magic_number_smell": "    @Test\n    public void testListBuckets() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:download_objects_result\");\n        mock.expectedMinimumMessageCount(10);\n        mock.assertIsSatisfied();\n        List<Exchange> exchanges = mock.getExchanges();\n", "refactored_code": "    private static final int NUMBER_TO_CONSUME = 10;\n    @Test\n    public void testListBuckets() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:download_objects_result\");\n        mock.expectedMinimumMessageCount(NUMBER_TO_CONSUME);\n        mock.assertIsSatisfied();\n        List<Exchange> exchanges = mock.getExchanges();\n"}
{"magic_number_smell": "    @Test\n    public void testListBuckets() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:download_objects_result\");\n        mock.expectedMinimumMessageCount(10);\n        mock.assertIsSatisfied();\n        List<Exchange> exchanges = mock.getExchanges();\n", "refactored_code": "    private static final int NUMBER_TO_CONSUME = 10;\n    @Test\n    public void testListBuckets() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:download_objects_result\");\n        mock.expectedMinimumMessageCount(NUMBER_TO_CONSUME);\n        mock.assertIsSatisfied();\n        List<Exchange> exchanges = mock.getExchanges();\n"}
{"magic_number_smell": "    @Test\n    public void testListBuckets() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:download_objects_result\");\n        mock.expectedMinimumMessageCount(10);\n        mock.assertIsSatisfied();\n        List<Exchange> exchanges = mock.getExchanges();\n", "refactored_code": "    private static final int NUMBER_TO_CONSUME = 10;\n    @Test\n    public void testListBuckets() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:download_objects_result\");\n        mock.expectedMinimumMessageCount(NUMBER_TO_CONSUME);\n        mock.assertIsSatisfied();\n        List<Exchange> exchanges = mock.getExchanges();\n"}
{"magic_number_smell": "    @Test\n    public void testListBuckets() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:download_objects_result\");\n        mock.expectedMinimumMessageCount(10);\n        mock.assertIsSatisfied();\n        List<Exchange> exchanges = mock.getExchanges();\n", "refactored_code": "    private static final int NUMBER_TO_CONSUME = 10;\n    @Test\n    public void testListBuckets() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:download_objects_result\");\n        mock.expectedMinimumMessageCount(NUMBER_TO_CONSUME);\n        mock.assertIsSatisfied();\n        List<Exchange> exchanges = mock.getExchanges();\n"}
{"magic_number_smell": "\n    @BindToRegistry(\"query1\")\n    private ScanQuery<Integer, Person> scanQuery1 = new ScanQuery<>(new IgniteBiPredicate<Integer, Person>() {\n        private static final long 1L = 1L;\n\n        @Override\n        public boolean apply(Integer key, Person person) {", "refactored_code": "    private static final long serialVersionUID = 1L;\n\n    @BindToRegistry(\"query1\")\n    private ScanQuery<Integer, Person> scanQuery1 = new ScanQuery<>(new IgniteBiPredicate<Integer, Person>() {\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public boolean apply(Integer key, Person person) {"}
{"magic_number_smell": "\n    private void setupMessageListener(String topic, final List<Object> messages) {\n        uuid = ignite().message().remoteListen(topic, new IgniteBiPredicate<UUID, Object>() {\n            private static final long 3967738538216977749L = 1L;\n\n            @Override\n            public boolean apply(UUID uuid, Object message) {", "refactored_code": "    private static final long serialVersionUID = 3967738538216977749L;\n\n    private void setupMessageListener(String topic, final List<Object> messages) {\n        uuid = ignite().message().remoteListen(topic, new IgniteBiPredicate<UUID, Object>() {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            public boolean apply(UUID uuid, Object message) {"}
{"magic_number_smell": "    };\n\n    public static final IgniteRunnable TEST_RUNNABLE_COUNTER = new IgniteRunnable() {\n        private static final long -4961602602993218883L = 386219709871673366L;\n\n        @Override\n        public void run() {", "refactored_code": "        private static final long serialVersionUID = -4961602602993218883L;\n    };\n\n    public static final IgniteRunnable TEST_RUNNABLE_COUNTER = new IgniteRunnable() {\n        private static final long serialVersionUID = 386219709871673366L;\n\n        @Override\n        public void run() {"}
{"magic_number_smell": "                                return oldExchange;\n                            }\n                        })\n                        .completionSize(4)\n                        .to(\"mock:result\");\n            }\n        });", "refactored_code": "    public static final int COMPLETION_SIZE = 4;\n                                return oldExchange;\n                            }\n                        })\n                        .completionSize(COMPLETION_SIZE)\n                        .to(\"mock:result\");\n            }\n        });"}
{"magic_number_smell": "                                return oldExchange;\n                            }\n                        })\n                        .completionSize(4)\n                        .to(\"mock:result\");\n            }\n        });", "refactored_code": "    public static final int COMPLETION_SIZE = 4;\n                                return oldExchange;\n                            }\n                        })\n                        .completionSize(COMPLETION_SIZE)\n                        .to(\"mock:result\");\n            }\n        });"}
{"magic_number_smell": "\n        assertNull(getCache(1).get(key));\n        mockResultCreatedEvents.assertIsSatisfied();\n        mockResultExpiredEvents.assertIsSatisfied(5000);\n    }\n\n    @Override", "refactored_code": "    private static final long WAIT_TIMEOUT = 5000;\n\n        assertNull(getCache(1).get(key));\n        mockResultCreatedEvents.assertIsSatisfied();\n        mockResultExpiredEvents.assertIsSatisfied(WAIT_TIMEOUT);\n    }\n\n    @Override"}
{"magic_number_smell": "        StopWatch watch = new StopWatch();\n        int noOfBlocks = 0;\n        ArrayList<String> list = new ArrayList<>();\n        for (int i = 1; i <= 50000; i++) {\n            String payloadToSend = PAYLOAD.replace(\"#\", \"\" + i);\n            list.add(payloadToSend);\n            if (i % 100 == 0) {", "refactored_code": "    private static final int NO_OF_MESSAGES = 50000;\n        StopWatch watch = new StopWatch();\n        int noOfBlocks = 0;\n        ArrayList<String> list = new ArrayList<>();\n        for (int i = 1; i <= NO_OF_MESSAGES; i++) {\n            String payloadToSend = PAYLOAD.replace(\"#\", \"\" + i);\n            list.add(payloadToSend);\n            if (i % 100 == 0) {"}
{"magic_number_smell": "@XmlRootElement(name = \"twit\")\nclass Twit implements Serializable {\n\n    private static final long 1L = 1L;\n\n    @XmlElement(required = true)\n    protected String text;", "refactored_code": "    private static final long serialVersionUID = 1L;\n@XmlRootElement(name = \"twit\")\nclass Twit implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    @XmlElement(required = true)\n    protected String text;"}
{"magic_number_smell": "\n    @Test\n    public void testHttpProxy() {\n        LOG.info(\"Sending {} messages to a http endpoint which is proxied/bridged\", 10);\n\n        StopWatch watch = new StopWatch();\n        for (int i = 0; i < 10; i++) {", "refactored_code": "    private final int size = 10;\n\n    @Test\n    public void testHttpProxy() {\n        LOG.info(\"Sending {} messages to a http endpoint which is proxied/bridged\", size);\n\n        StopWatch watch = new StopWatch();\n        for (int i = 0; i < size; i++) {"}
{"magic_number_smell": "            LOG.debug(\"Filtering message {}.\", body);\n            if (body instanceof View) {\n                View view = (View) body;\n                Address coordinatorNodeAddress = view.getMembers().get(0);\n                Address channelAddress = exchange.getIn().getHeader(HEADER_JGROUPS_CHANNEL_ADDRESS, Address.class);\n                LOG.debug(\"Comparing endpoint channel address {} against the coordinator node address {}.\",\n                        channelAddress, coordinatorNodeAddress);", "refactored_code": "    private static final int COORDINATOR_NODE_INDEX = 0;\n            LOG.debug(\"Filtering message {}.\", body);\n            if (body instanceof View) {\n                View view = (View) body;\n                Address coordinatorNodeAddress = view.getMembers().get(COORDINATOR_NODE_INDEX);\n                Address channelAddress = exchange.getIn().getHeader(HEADER_JGROUPS_CHANNEL_ADDRESS, Address.class);\n                LOG.debug(\"Comparing endpoint channel address {} against the coordinator node address {}.\",\n                        channelAddress, coordinatorNodeAddress);"}
{"magic_number_smell": "    @Override\n    protected void doStart() throws Exception {\n        super.doStart();\n        List<Issue> issues = getIssues(getEndpoint().getJql(), SEARCH_START_AT, 50,\n                getEndpoint().getMaxResults());\n        initIssues(issues);\n    }", "refactored_code": "    private static final int SEARCH_MAX_PER_QUERY = 50;\n    @Override\n    protected void doStart() throws Exception {\n        super.doStart();\n        List<Issue> issues = getIssues(getEndpoint().getJql(), SEARCH_START_AT, SEARCH_MAX_PER_QUERY,\n                getEndpoint().getMaxResults());\n        initIssues(issues);\n    }"}
{"magic_number_smell": "        if (comment == null) {\n            throw new IllegalArgumentException(\"Missing exchange body, it should specify the string comment.\");\n        }\n        int minutesSpent = exchange.getIn().getHeader(MINUTES_SPENT, -1, int.class);\n        if (-1 == minutesSpent) {\n            throw new IllegalArgumentException(\"Missing exchange input header named \" + MINUTES_SPENT);\n        }", "refactored_code": "    private static final int DEFAULT_MINUTES_SPENT = -1;\n        if (comment == null) {\n            throw new IllegalArgumentException(\"Missing exchange body, it should specify the string comment.\");\n        }\n        int minutesSpent = exchange.getIn().getHeader(MINUTES_SPENT, DEFAULT_MINUTES_SPENT, int.class);\n        if (DEFAULT_MINUTES_SPENT == minutesSpent) {\n            throw new IllegalArgumentException(\"Missing exchange input header named \" + MINUTES_SPENT);\n        }"}
{"magic_number_smell": "            // the MessageListenerContainer which occurs asynchronously so we have to wait\n            // for that to happen before we can retrieve the reply to destination to be used\n            log.trace(\"Waiting for replyTo to be set\");\n            boolean done = replyToLatch.await(10000, TimeUnit.MILLISECONDS);\n            if (!done) {\n                log.warn(\"ReplyTo destination was not set and timeout occurred\");\n            } else {", "refactored_code": "    protected final long replyToTimeout = 10000;\n            // the MessageListenerContainer which occurs asynchronously so we have to wait\n            // for that to happen before we can retrieve the reply to destination to be used\n            log.trace(\"Waiting for replyTo to be set\");\n            boolean done = replyToLatch.await(replyToTimeout, TimeUnit.MILLISECONDS);\n            if (!done) {\n                log.warn(\"ReplyTo destination was not set and timeout occurred\");\n            } else {"}
{"magic_number_smell": "            final DefaultTaskExecutorType defaultTaskExecutorType)\n            throws Exception {\n        final ExecutorService executor = Executors.newFixedThreadPool(POOL_SIZE);\n        final CountDownLatch latch = new CountDownLatch(500);\n\n        try {\n            doSendMessages(queueName, 500, defaultTaskExecutorType, latch, executor);", "refactored_code": "    public static final int MESSAGE_COUNT = 500;\n            final DefaultTaskExecutorType defaultTaskExecutorType)\n            throws Exception {\n        final ExecutorService executor = Executors.newFixedThreadPool(POOL_SIZE);\n        final CountDownLatch latch = new CountDownLatch(MESSAGE_COUNT);\n\n        try {\n            doSendMessages(queueName, MESSAGE_COUNT, defaultTaskExecutorType, latch, executor);"}
{"magic_number_smell": "    protected ConsumerTemplate consumer;\n\n    private final int 100 = 100;\n    private final CountDownLatch latch = new CountDownLatch(100);\n    private ExecutorService executor;\n\n    @BeforeEach", "refactored_code": "    private final int size = 100;\n    protected ConsumerTemplate consumer;\n\n    private final int size = 100;\n    private final CountDownLatch latch = new CountDownLatch(size);\n    private ExecutorService executor;\n\n    @BeforeEach"}
{"magic_number_smell": "\n    @Override\n    protected RouteBuilder createRouteBuilder() {\n        startEndpointUri = componentName + \":queue:test.a.JmsRouteTest\" + ThreadLocalRandom.current().nextInt(10000);\n        endEndpointUri = componentName + \":queue:test.b.JmsRouteTest\" + ThreadLocalRandom.current().nextInt(10000);\n\n        return new RouteBuilder() {", "refactored_code": "    private final int endpointNum = ThreadLocalRandom.current().nextInt(10000);\n\n    @Override\n    protected RouteBuilder createRouteBuilder() {\n        startEndpointUri = componentName + \":queue:test.a.JmsRouteTest\" + endpointNum;\n        endEndpointUri = componentName + \":queue:test.b.JmsRouteTest\" + endpointNum;\n\n        return new RouteBuilder() {"}
{"magic_number_smell": "\n    @BeforeEach\n    void setupExecutor() {\n        executor = Executors.newFixedThreadPool(1);\n    }\n\n    @AfterEach", "refactored_code": "    public static final int POOL_SIZE = 1;\n\n    @BeforeEach\n    void setupExecutor() {\n        executor = Executors.newFixedThreadPool(POOL_SIZE);\n    }\n\n    @AfterEach"}
{"magic_number_smell": "public final class JmsRequestReplyTemporaryRefreshFailureOnStartupTest extends CamelTestSupport {\n\n    private static final int AvailablePortFinder.getNextAvailable() = AvailablePortFinder.getNextAvailable();\n    public static ArtemisService service = new ArtemisVMService.ReusableArtemisVMService(AvailablePortFinder.getNextAvailable());\n\n    private final Long recoveryInterval = 1000L;\n", "refactored_code": "    private static final int PORT = AvailablePortFinder.getNextAvailable();\npublic final class JmsRequestReplyTemporaryRefreshFailureOnStartupTest extends CamelTestSupport {\n\n    private static final int PORT = AvailablePortFinder.getNextAvailable();\n    public static ArtemisService service = new ArtemisVMService.ReusableArtemisVMService(PORT);\n\n    private final Long recoveryInterval = 1000L;\n"}
{"magic_number_smell": "    }\n\n    @Test\n    @AdditionalEndpointParameters(\"firstResult=\" + 5)\n    public void testFirstResultInUri() throws Exception {\n        final List<Customer> customers = runQueryTest();\n", "refactored_code": "    private static final int FIRST_RESULT = 5;\n    }\n\n    @Test\n    @AdditionalEndpointParameters(\"firstResult=\" + FIRST_RESULT)\n    public void testFirstResultInUri() throws Exception {\n        final List<Customer> customers = runQueryTest();\n"}
{"magic_number_smell": "\n    @Override\n    protected void setDefaultPort() {\n        setPort(22);\n    }\n\n    public String getKnownHostsFile() {", "refactored_code": "    public static final int DEFAULT_SFTP_PORT = 22;\n\n    @Override\n    protected void setDefaultPort() {\n        setPort(DEFAULT_SFTP_PORT);\n    }\n\n    public String getKnownHostsFile() {"}
{"magic_number_smell": "    @Test\n    public void testWithPlatformHttp() {\n        String result = RestAssured.given()\n                .port(AvailablePortFinder.getNextAvailable())\n                .contentType(ContentType.JSON)\n                .body(BODY)\n                .post(\"/getTemperature\")", "refactored_code": "    private static final int PORT = AvailablePortFinder.getNextAvailable();\n    @Test\n    public void testWithPlatformHttp() {\n        String result = RestAssured.given()\n                .port(PORT)\n                .contentType(ContentType.JSON)\n                .body(BODY)\n                .post(\"/getTemperature\")"}
{"magic_number_smell": "    private Jt400Type type;\n\n    @UriParam\n    private int ccsid = -1;\n\n    @UriParam(defaultValue = \"text\")\n    private Format format = Format.text;", "refactored_code": "    private static final int DEFAULT_SYSTEM_CCSID = -1;\n    private Jt400Type type;\n\n    @UriParam\n    private int ccsid = DEFAULT_SYSTEM_CCSID;\n\n    @UriParam(defaultValue = \"text\")\n    private Format format = Format.text;"}
{"magic_number_smell": "     */\n    @Test\n    public void testReceiveLong() {\n        assertTimeout(Duration.ofMillis(TIMEOUT_VALUE + 300L),\n                () -> consumer.receive(TIMEOUT_VALUE));\n    }\n", "refactored_code": "    private static final long TIMEOUT_TOLERANCE = 300L;\n     */\n    @Test\n    public void testReceiveLong() {\n        assertTimeout(Duration.ofMillis(TIMEOUT_VALUE + TIMEOUT_TOLERANCE),\n                () -> consumer.receive(TIMEOUT_VALUE));\n    }\n"}
{"magic_number_smell": "    private String topic;\n    @Metadata(description = \"The URL for the kafka brokers to use\", required = true)\n    private String bootstrapServers;\n    @Metadata(description = \"Sets the maximum size of the local key cache.\", defaultValue = \"\" + 1000)\n    private int maxCacheSize = 1000;\n    @Metadata(description = \"Sets the poll duration of the Kafka consumer. The local caches are updated immediately; this value will affect\"\n                            + \" how far behind other peers in the cluster are, which are updating their caches from the topic, relative to the\"", "refactored_code": "    private static final int DEFAULT_MAXIMUM_CACHE_SIZE = 1000;\n    private String topic;\n    @Metadata(description = \"The URL for the kafka brokers to use\", required = true)\n    private String bootstrapServers;\n    @Metadata(description = \"Sets the maximum size of the local key cache.\", defaultValue = \"\" + DEFAULT_MAXIMUM_CACHE_SIZE)\n    private int maxCacheSize = DEFAULT_MAXIMUM_CACHE_SIZE;\n    @Metadata(description = \"Sets the poll duration of the Kafka consumer. The local caches are updated immediately; this value will affect\"\n                            + \" how far behind other peers in the cluster are, which are updating their caches from the topic, relative to the\""}
{"magic_number_smell": "        to.assertIsSatisfied();\n\n        int heartbeatThreadCount = countHeartbeatThreads();\n        assertEquals(3, heartbeatThreadCount, \"Heartbeat-thread count should match consumer count\");\n        LOG.info(\"Number of heartbeat-threads is: {}\", heartbeatThreadCount);\n\n    }", "refactored_code": "    private static final int CONSUMER_COUNT = 3;\n        to.assertIsSatisfied();\n\n        int heartbeatThreadCount = countHeartbeatThreads();\n        assertEquals(CONSUMER_COUNT, heartbeatThreadCount, \"Heartbeat-thread count should match consumer count\");\n        LOG.info(\"Number of heartbeat-threads is: {}\", heartbeatThreadCount);\n\n    }"}
{"magic_number_smell": "        to.expectedBodiesReceivedInAnyOrder(\"message-0\", \"message-1\", \"message-2\", \"message-3\", \"message-4\");\n        to.expectedHeaderValuesReceivedInAnyOrder(KafkaConstants.LAST_RECORD_BEFORE_COMMIT, null, null, null, null, null);\n\n        Awaitility.await().atMost(1, TimeUnit.HOURS).untilAsserted(() -> Assert.assertEquals(Integer.valueOf(System.getProperty(\"kafka.manual.test.message.count\", \"5\")), receivedMessages));\n\n        to.assertIsSatisfied();\n    }", "refactored_code": "    private static final int MESSAGE_COUNT = Integer.valueOf(System.getProperty(\"kafka.manual.test.message.count\", \"5\"));\n        to.expectedBodiesReceivedInAnyOrder(\"message-0\", \"message-1\", \"message-2\", \"message-3\", \"message-4\");\n        to.expectedHeaderValuesReceivedInAnyOrder(KafkaConstants.LAST_RECORD_BEFORE_COMMIT, null, null, null, null, null);\n\n        Awaitility.await().atMost(1, TimeUnit.HOURS).untilAsserted(() -> Assert.assertEquals(MESSAGE_COUNT, receivedMessages));\n\n        to.assertIsSatisfied();\n    }"}
{"magic_number_smell": "    @BeforeEach\n    public void before() {\n        kafkaAdminClient.deleteTopics(Arrays.asList(TOPIC, \"TEST_IDEMPOTENT\")).all();\n        doSend(200, TOPIC);\n    }\n\n    @AfterEach", "refactored_code": "    private final int size = 200;\n    @BeforeEach\n    public void before() {\n        kafkaAdminClient.deleteTopics(Arrays.asList(TOPIC, \"TEST_IDEMPOTENT\")).all();\n        doSend(size, TOPIC);\n    }\n\n    @AfterEach"}
{"magic_number_smell": "    @BeforeEach\n    public void before() {\n        kafkaAdminClient.deleteTopics(Arrays.asList(TOPIC, \"TEST_IDEMPOTENT\")).all();\n        doSend(200, TOPIC);\n    }\n\n    @AfterEach", "refactored_code": "    private final int size = 200;\n    @BeforeEach\n    public void before() {\n        kafkaAdminClient.deleteTopics(Arrays.asList(TOPIC, \"TEST_IDEMPOTENT\")).all();\n        doSend(size, TOPIC);\n    }\n\n    @AfterEach"}
{"magic_number_smell": "    @BeforeEach\n    public void before() {\n        kafkaAdminClient.deleteTopics(Arrays.asList(TOPIC, \"TEST_IDEMPOTENT\")).all();\n        doSend(200, TOPIC);\n    }\n\n    @AfterEach", "refactored_code": "    private final int size = 200;\n    @BeforeEach\n    public void before() {\n        kafkaAdminClient.deleteTopics(Arrays.asList(TOPIC, \"TEST_IDEMPOTENT\")).all();\n        doSend(size, TOPIC);\n    }\n\n    @AfterEach"}
{"magic_number_smell": "    @BeforeEach\n    public void before() {\n        kafkaAdminClient.deleteTopics(Arrays.asList(TOPIC, \"TEST_IDEMPOTENT\")).all();\n        doSend(200, TOPIC);\n    }\n\n    @AfterEach", "refactored_code": "    private final int size = 200;\n    @BeforeEach\n    public void before() {\n        kafkaAdminClient.deleteTopics(Arrays.asList(TOPIC, \"TEST_IDEMPOTENT\")).all();\n        doSend(size, TOPIC);\n    }\n\n    @AfterEach"}
{"magic_number_smell": "\n    @Test\n    public void concurrencyProducedTransactionMessage() throws InterruptedException {\n        Thread[] threads = new Thread[5];\n        int messageInTopic = 5;\n\n        CountDownLatch messagesLatch = new CountDownLatch(messageInTopic * 5);", "refactored_code": "    private static final int THREAD_NUM = 5;\n\n    @Test\n    public void concurrencyProducedTransactionMessage() throws InterruptedException {\n        Thread[] threads = new Thread[THREAD_NUM];\n        int messageInTopic = 5;\n\n        CountDownLatch messagesLatch = new CountDownLatch(messageInTopic * THREAD_NUM);"}
{"magic_number_smell": "            return true;\n        }\n\n        if (count.intValue() >= 5) {\n            LOG.info(\"Count is {}, allowing processing to proceed because it's greater than retry count {}\",\n                    count.intValue(), 5);\n            return true;", "refactored_code": "    private static final int SIMULATED_FAILURES = 5;\n            return true;\n        }\n\n        if (count.intValue() >= SIMULATED_FAILURES) {\n            LOG.info(\"Count is {}, allowing processing to proceed because it's greater than retry count {}\",\n                    count.intValue(), SIMULATED_FAILURES);\n            return true;"}
{"magic_number_smell": "            return true;\n        }\n\n        if (count.intValue() >= 10) {\n            return true;\n        }\n", "refactored_code": "    private static final int RETRY_COUNT = 10;\n            return true;\n        }\n\n        if (count.intValue() >= RETRY_COUNT) {\n            return true;\n        }\n"}
{"magic_number_smell": "    /**\n     * A jitter factor to apply in order to prevent all pods to call Kubernetes APIs in the same instant.\n     */\n    private double jitterFactor = 1.2;\n\n    /**\n     * The default duration of the lease for the current leader.", "refactored_code": "    public static final double DEFAULT_JITTER_FACTOR = 1.2;\n    /**\n     * A jitter factor to apply in order to prevent all pods to call Kubernetes APIs in the same instant.\n     */\n    private double jitterFactor = DEFAULT_JITTER_FACTOR;\n\n    /**\n     * The default duration of the lease for the current leader."}
{"magic_number_smell": "        this.executor.execute(() -> checkAndNotify(version));\n        if (leader.isPresent()) {\n            long time = System.currentTimeMillis();\n            long delay = Math.max(timestamp + lease + 10 - time, 10);\n            LOG.debug(\"Setting expiration in {} millis for version {}\", delay, version);\n            this.executor.schedule(() -> expiration(version), delay, TimeUnit.MILLISECONDS);\n        }", "refactored_code": "    private static final long FIXED_DELAY = 10;\n        this.executor.execute(() -> checkAndNotify(version));\n        if (leader.isPresent()) {\n            long time = System.currentTimeMillis();\n            long delay = Math.max(timestamp + lease + FIXED_DELAY - time, FIXED_DELAY);\n            LOG.debug(\"Setting expiration in {} millis for version {}\", delay, version);\n            this.executor.schedule(() -> expiration(version), delay, TimeUnit.MILLISECONDS);\n        }"}
{"magic_number_smell": "        Long lossTimestamp = formerLeaderRecorder.getLastTimeOf(l -> l == null);\n        Long gainTimestamp = formerLoserRecorder.getLastTimeOf(secondLeader::equals);\n\n        assertTrue(gainTimestamp >= lossTimestamp + (2000 - RENEW_DEADLINE_MILLIS) / 2,\n                \"At least half distance must elapse from leadership loss and regain (see renewDeadlineSeconds)\");\n        checkLeadershipChangeDistance((2000 - RENEW_DEADLINE_MILLIS) / 2, TimeUnit.MILLISECONDS, mypod1, mypod2);\n    }", "refactored_code": "    private static final int LEASE_TIME_MILLIS = 2000;\n        Long lossTimestamp = formerLeaderRecorder.getLastTimeOf(l -> l == null);\n        Long gainTimestamp = formerLoserRecorder.getLastTimeOf(secondLeader::equals);\n\n        assertTrue(gainTimestamp >= lossTimestamp + (LEASE_TIME_MILLIS - RENEW_DEADLINE_MILLIS) / 2,\n                \"At least half distance must elapse from leadership loss and regain (see renewDeadlineSeconds)\");\n        checkLeadershipChangeDistance((LEASE_TIME_MILLIS - RENEW_DEADLINE_MILLIS) / 2, TimeUnit.MILLISECONDS, mypod1, mypod2);\n    }"}
{"magic_number_smell": "    @Test\n    public void testLoadAndRecoverLevelDBAggregate() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedMessageCount(200 / 10);\n        mock.setResultWaitTime(50 * 1000);\n\n        LOG.info(\"Starting to send {} messages.\", 200);", "refactored_code": "    private static final int SIZE = 200;\n    @Test\n    public void testLoadAndRecoverLevelDBAggregate() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedMessageCount(SIZE / 10);\n        mock.setResultWaitTime(50 * 1000);\n\n        LOG.info(\"Starting to send {} messages.\", SIZE);"}
{"magic_number_smell": "\n        ExecutorService executor = Executors.newFixedThreadPool(10);\n\n        LOG.info(\"Starting to send {} messages.\", 500);\n\n        for (int i = 0; i < 500; i++) {\n            final int value = 1;", "refactored_code": "    private static final int SIZE = 500;\n\n        ExecutorService executor = Executors.newFixedThreadPool(10);\n\n        LOG.info(\"Starting to send {} messages.\", SIZE);\n\n        for (int i = 0; i < SIZE; i++) {\n            final int value = 1;"}
{"magic_number_smell": "        mock.expectedMinimumMessageCount(1);\n        mock.setResultWaitTime(50 * 1000);\n\n        LOG.info(\"Starting to send {} messages.\", 500);\n\n        for (int i = 0; i < 500; i++) {\n            final int value = 1;", "refactored_code": "    private static final int SIZE = 500;\n        mock.expectedMinimumMessageCount(1);\n        mock.setResultWaitTime(50 * 1000);\n\n        LOG.info(\"Starting to send {} messages.\", SIZE);\n\n        for (int i = 0; i < SIZE; i++) {\n            final int value = 1;"}
{"magic_number_smell": "        mock.expectedMinimumMessageCount(1);\n        mock.setResultWaitTime(50 * 1000);\n\n        LOG.info(\"Starting to send {} messages.\", 500);\n\n        for (int i = 0; i < 500; i++) {\n            final int value = 1;", "refactored_code": "    private static final int SIZE = 500;\n        mock.expectedMinimumMessageCount(1);\n        mock.setResultWaitTime(50 * 1000);\n\n        LOG.info(\"Starting to send {} messages.\", SIZE);\n\n        for (int i = 0; i < SIZE; i++) {\n            final int value = 1;"}
{"magic_number_smell": "    @Test\n    public void testBigPayload() throws Exception {\n\n        log.info(\"Running test for {} millis.\", 60 * 1000);\n        Thread.sleep(60 * 1000);\n\n        // assert the file size of the repo is not big < 32mb", "refactored_code": "    private static final long TIME = 60 * 1000;\n    @Test\n    public void testBigPayload() throws Exception {\n\n        log.info(\"Running test for {} millis.\", TIME);\n        Thread.sleep(60 * 1000);\n\n        // assert the file size of the repo is not big < 32mb"}
{"magic_number_smell": "        // Create the group that will listen for incoming connections\n        bossGroup = new NioEventLoopGroup(1);\n        // Create the group that will process the connections\n        workerGroup = new NioEventLoopGroup(16);\n        // Create the executor service that will process the payloads without blocking netty threads\n        executorService = new DefaultEventExecutorGroup(16, threadFactory);\n", "refactored_code": "    private static final int WORKER_THREADS = 16;\n        // Create the group that will listen for incoming connections\n        bossGroup = new NioEventLoopGroup(1);\n        // Create the group that will process the connections\n        workerGroup = new NioEventLoopGroup(WORKER_THREADS);\n        // Create the executor service that will process the payloads without blocking netty threads\n        executorService = new DefaultEventExecutorGroup(WORKER_THREADS, threadFactory);\n"}
{"magic_number_smell": "        return new RouteBuilder() {\n            public void configure() {\n                // Lumberjack configured with a specific port\n                from(\"lumberjack:0.0.0.0:\" + AvailablePortFinder.getNextAvailable()).to(\"mock:output\");\n            }\n        };\n    }", "refactored_code": "    private static final int PORT = AvailablePortFinder.getNextAvailable();\n        return new RouteBuilder() {\n            public void configure() {\n                // Lumberjack configured with a specific port\n                from(\"lumberjack:0.0.0.0:\" + PORT).to(\"mock:output\");\n            }\n        };\n    }"}
{"magic_number_smell": "     * @return          the default port\n     */\n    public static int getDefaultPortForProtocol(final String protocol) {\n        int port = 25;\n\n        if (protocol != null) {\n            if (protocol.equalsIgnoreCase(PROTOCOL_IMAP)) {", "refactored_code": "    public static final int DEFAULT_PORT_SMTP = 25;\n     * @return          the default port\n     */\n    public static int getDefaultPortForProtocol(final String protocol) {\n        int port = DEFAULT_PORT_SMTP;\n\n        if (protocol != null) {\n            if (protocol.equalsIgnoreCase(PROTOCOL_IMAP)) {"}
{"magic_number_smell": "                .convertDurationsTo(TimeUnit.MILLISECONDS)\n                .withLoggingLevel(Slf4jReporter.LoggingLevel.DEBUG)\n                .build();\n        reporter.start(60L, TimeUnit.SECONDS);\n        return registry;\n    }\n", "refactored_code": "    public static final long DEFAULT_REPORTING_INTERVAL_SECONDS = 60L;\n                .convertDurationsTo(TimeUnit.MILLISECONDS)\n                .withLoggingLevel(Slf4jReporter.LoggingLevel.DEBUG)\n                .build();\n        reporter.start(DEFAULT_REPORTING_INTERVAL_SECONDS, TimeUnit.SECONDS);\n        return registry;\n    }\n"}
{"magic_number_smell": "                from(\"direct:in-1\")\n                        .setHeader(HEADER_METRIC_NAME, constant(\"B\"))\n                        .to(\"micrometer:timer:A?action=start\")\n                        .delay(20L)\n                        .setHeader(HEADER_METRIC_NAME, constant(\"B\"))\n                        .to(\"micrometer:timer:A?action=stop\")\n                        .to(\"mock:out\");", "refactored_code": "    private static final long DELAY = 20L;\n                from(\"direct:in-1\")\n                        .setHeader(HEADER_METRIC_NAME, constant(\"B\"))\n                        .to(\"micrometer:timer:A?action=start\")\n                        .delay(DELAY)\n                        .setHeader(HEADER_METRIC_NAME, constant(\"B\"))\n                        .to(\"micrometer:timer:A?action=stop\")\n                        .to(\"mock:out\");"}
{"magic_number_smell": "            @Override\n            public void configure() {\n                from(\"direct:foo\").routeId(\"foo\")\n                        .delay(20)\n                        .to(\"mock:result\");\n\n                from(\"direct:bar\").routeId(\"bar\")", "refactored_code": "    private static final long DELAY_FOO = 20;\n            @Override\n            public void configure() {\n                from(\"direct:foo\").routeId(\"foo\")\n                        .delay(DELAY_FOO)\n                        .to(\"mock:result\");\n\n                from(\"direct:bar\").routeId(\"bar\")"}
{"magic_number_smell": "        Timer fooTimer\n                = meterRegistry.find(formatMetricName(DEFAULT_CAMEL_ROUTE_POLICY_METER_NAME)).tag(ROUTE_ID_TAG, \"foo\").timer();\n        assertEquals(count / 2, fooTimer.count());\n        assertTrue(fooTimer.mean(TimeUnit.MILLISECONDS) > 20);\n        assertTrue(fooTimer.max(TimeUnit.MILLISECONDS) > 20);\n        assertTrue(fooTimer.totalTime(TimeUnit.MILLISECONDS) > 20 * count / 2);\n", "refactored_code": "    private static final long DELAY_FOO = 20;\n        Timer fooTimer\n                = meterRegistry.find(formatMetricName(DEFAULT_CAMEL_ROUTE_POLICY_METER_NAME)).tag(ROUTE_ID_TAG, \"foo\").timer();\n        assertEquals(count / 2, fooTimer.count());\n        assertTrue(fooTimer.mean(TimeUnit.MILLISECONDS) > DELAY_FOO);\n        assertTrue(fooTimer.max(TimeUnit.MILLISECONDS) > DELAY_FOO);\n        assertTrue(fooTimer.totalTime(TimeUnit.MILLISECONDS) > DELAY_FOO * count / 2);\n"}
{"magic_number_smell": "            @Override\n            public void configure() {\n                from(\"direct:foo\").routeId(\"foo\")\n                        .delay(20)\n                        .to(\"mock:result\");\n\n                from(\"direct:bar\").routeId(\"bar\")", "refactored_code": "    private static final long DELAY_FOO = 20;\n            @Override\n            public void configure() {\n                from(\"direct:foo\").routeId(\"foo\")\n                        .delay(DELAY_FOO)\n                        .to(\"mock:result\");\n\n                from(\"direct:bar\").routeId(\"bar\")"}
{"magic_number_smell": "    // Create the UDPServer before the test is run\n    @BeforeEach\n    public void setupUDPAcceptor() throws IOException {\n        server = new UDPServer(\"127.0.0.1\", AvailablePortFinder.getNextAvailable());\n        server.listen();\n    }\n", "refactored_code": "    private final int port = AvailablePortFinder.getNextAvailable();\n    // Create the UDPServer before the test is run\n    @BeforeEach\n    public void setupUDPAcceptor() throws IOException {\n        server = new UDPServer(\"127.0.0.1\", port);\n        server.listen();\n    }\n"}
{"magic_number_smell": "    }\n\n    protected void sendUdpMessages() {\n        for (int i = 0; i < 3; i++) {\n            template.sendBody(String.format(\"mina:udp://127.0.0.1:%1$s?sync=false\", getPort()), \"Hello Message: \" + i);\n        }\n    }", "refactored_code": "    private final int messageCount = 3;\n    }\n\n    protected void sendUdpMessages() {\n        for (int i = 0; i < messageCount; i++) {\n            template.sendBody(String.format(\"mina:udp://127.0.0.1:%1$s?sync=false\", getPort()), \"Hello Message: \" + i);\n        }\n    }"}
{"magic_number_smell": "        started = true;\n        try {\n            while (started && ++currentRun <= runCount) {\n                Thread.sleep(1000);\n                log.info(\"{}: Runnable {} running {} of {} runs\", threadName, id, currentRun, runCount);\n            }\n        } catch (InterruptedException e) {", "refactored_code": "    public static final long SLEEP_MILLIS = 1000;\n        started = true;\n        try {\n            while (started && ++currentRun <= runCount) {\n                Thread.sleep(SLEEP_MILLIS);\n                log.info(\"{}: Runnable {} running {} of {} runs\", threadName, id, currentRun, runCount);\n            }\n        } catch (InterruptedException e) {"}
{"magic_number_smell": "\n        MongoClientSettings.Builder optionsBuilder = MongoClientSettings.builder();\n        optionsBuilder.applyToSocketSettings(\n                socketBuilder -> socketBuilder.connectTimeout(2000, TimeUnit.MILLISECONDS));\n        optionsBuilder.applyToConnectionPoolSettings(\n                connectionPoolBuilder -> connectionPoolBuilder.maxWaitTime(2000, TimeUnit.MILLISECONDS));\n        optionsBuilder.applyToClusterSettings(", "refactored_code": "    private static final int CONNECTION_TIMEOUT = 2000;\n\n        MongoClientSettings.Builder optionsBuilder = MongoClientSettings.builder();\n        optionsBuilder.applyToSocketSettings(\n                socketBuilder -> socketBuilder.connectTimeout(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));\n        optionsBuilder.applyToConnectionPoolSettings(\n                connectionPoolBuilder -> connectionPoolBuilder.maxWaitTime(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));\n        optionsBuilder.applyToClusterSettings("}
{"magic_number_smell": "        mock.message(0).header(MyBatisConstants.MYBATIS_RESULT).isNull();\n\n        Account account = new Account();\n        account.setId(444);\n        account.setFirstName(\"Willem\");\n        account.setLastName(\"Jiang\");\n        account.setEmailAddress(\"Faraway@gmail.com\");", "refactored_code": "    private static final int TEST_ACCOUNT_ID = 444;\n        mock.message(0).header(MyBatisConstants.MYBATIS_RESULT).isNull();\n\n        Account account = new Account();\n        account.setId(TEST_ACCOUNT_ID);\n        account.setFirstName(\"Willem\");\n        account.setLastName(\"Jiang\");\n        account.setEmailAddress(\"Faraway@gmail.com\");"}
{"magic_number_smell": "        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedMessageCount(1);\n        mock.message(0).header(TEST_CASE_HEADER_NAME).isInstanceOf(Account.class);\n        mock.message(0).body().isEqualTo(456);\n        mock.message(0).header(MyBatisConstants.MYBATIS_RESULT).isNull();\n\n        template.sendBody(\"direct:start\", 456);", "refactored_code": "    private static final int TEST_ACCOUNT_ID = 456;\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedMessageCount(1);\n        mock.message(0).header(TEST_CASE_HEADER_NAME).isInstanceOf(Account.class);\n        mock.message(0).body().isEqualTo(TEST_ACCOUNT_ID);\n        mock.message(0).header(MyBatisConstants.MYBATIS_RESULT).isNull();\n\n        template.sendBody(\"direct:start\", TEST_ACCOUNT_ID);"}
{"magic_number_smell": "        mock.message(0).body().isEqualTo(TEST_ACCOUNT_ID_BAD);\n        mock.message(0).header(TEST_CASE_OUTPUT_HEADER_NAME).isInstanceOf(Account.class);\n\n        template.sendBodyAndHeader(\"direct:start\", TEST_ACCOUNT_ID_BAD, TEST_CASE_INPUT_HEADER_NAME, 456);\n\n        MockEndpoint.assertIsSatisfied(context);\n", "refactored_code": "    private static final int TEST_ACCOUNT_ID = 456;\n        mock.message(0).body().isEqualTo(TEST_ACCOUNT_ID_BAD);\n        mock.message(0).header(TEST_CASE_OUTPUT_HEADER_NAME).isInstanceOf(Account.class);\n\n        template.sendBodyAndHeader(\"direct:start\", TEST_ACCOUNT_ID_BAD, TEST_CASE_INPUT_HEADER_NAME, TEST_ACCOUNT_ID);\n\n        MockEndpoint.assertIsSatisfied(context);\n"}
{"magic_number_smell": "        mock.expectedMessageCount(1);\n        mock.message(0).body().isInstanceOf(Account.class);\n\n        template.sendBodyAndHeader(\"direct:start\", TEST_ACCOUNT_ID_BAD, TEST_CASE_HEADER_NAME, 456);\n\n        MockEndpoint.assertIsSatisfied(context);\n", "refactored_code": "    private static final int TEST_ACCOUNT_ID = 456;\n        mock.expectedMessageCount(1);\n        mock.message(0).body().isInstanceOf(Account.class);\n\n        template.sendBodyAndHeader(\"direct:start\", TEST_ACCOUNT_ID_BAD, TEST_CASE_HEADER_NAME, TEST_ACCOUNT_ID);\n\n        MockEndpoint.assertIsSatisfied(context);\n"}
{"magic_number_smell": "        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedMessageCount(1);\n        mock.message(0).header(TEST_CASE_HEADER_NAME).isInstanceOf(Account.class);\n        mock.message(0).body().isEqualTo(456);\n        mock.message(0).header(MyBatisConstants.MYBATIS_RESULT).isNull();\n\n        template.sendBody(\"direct:start\", 456);", "refactored_code": "    private static final int TEST_ACCOUNT_ID = 456;\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedMessageCount(1);\n        mock.message(0).header(TEST_CASE_HEADER_NAME).isInstanceOf(Account.class);\n        mock.message(0).body().isEqualTo(TEST_ACCOUNT_ID);\n        mock.message(0).header(MyBatisConstants.MYBATIS_RESULT).isNull();\n\n        template.sendBody(\"direct:start\", TEST_ACCOUNT_ID);"}
{"magic_number_smell": "        mock.expectedMessageCount(1);\n        mock.message(0).body().isInstanceOf(Account.class);\n\n        template.sendBodyAndHeader(\"direct:start\", TEST_ACCOUNT_ID_BAD, TEST_CASE_HEADER_NAME, 456);\n\n        MockEndpoint.assertIsSatisfied(context);\n", "refactored_code": "    private static final int TEST_ACCOUNT_ID = 456;\n        mock.expectedMessageCount(1);\n        mock.message(0).body().isInstanceOf(Account.class);\n\n        template.sendBodyAndHeader(\"direct:start\", TEST_ACCOUNT_ID_BAD, TEST_CASE_HEADER_NAME, TEST_ACCOUNT_ID);\n\n        MockEndpoint.assertIsSatisfied(context);\n"}
{"magic_number_smell": "        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedMessageCount(1);\n        mock.message(0).header(TEST_CASE_HEADER_NAME).isInstanceOf(Account.class);\n        mock.message(0).body().isEqualTo(456);\n        mock.message(0).header(MyBatisConstants.MYBATIS_RESULT).isNull();\n\n        template.sendBody(\"direct:start\", 456);", "refactored_code": "    private static final int TEST_ACCOUNT_ID = 456;\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedMessageCount(1);\n        mock.message(0).header(TEST_CASE_HEADER_NAME).isInstanceOf(Account.class);\n        mock.message(0).body().isEqualTo(TEST_ACCOUNT_ID);\n        mock.message(0).header(MyBatisConstants.MYBATIS_RESULT).isNull();\n\n        template.sendBody(\"direct:start\", TEST_ACCOUNT_ID);"}
{"magic_number_smell": "        return new RouteBuilder() {\n            @Override\n            public void configure() {\n                onException(Exception.class).maximumRedeliveries(2).retryAttemptedLogLevel(LoggingLevel.INFO)\n                        .retriesExhaustedLogLevel(LoggingLevel.ERROR)\n                        .redeliveryDelay(10).to(\"mock:exception\").handled(true);\n", "refactored_code": "    private static final int REDELIVERY_COUNT = 2;\n        return new RouteBuilder() {\n            @Override\n            public void configure() {\n                onException(Exception.class).maximumRedeliveries(REDELIVERY_COUNT).retryAttemptedLogLevel(LoggingLevel.INFO)\n                        .retriesExhaustedLogLevel(LoggingLevel.ERROR)\n                        .redeliveryDelay(10).to(\"mock:exception\").handled(true);\n"}
{"magic_number_smell": "            address = matchAddress(matcher);\n\n            /* Create a binary netmask from the number of bits specification /x */\n            int cidrPart = rangeCheck(Integer.parseInt(matcher.group(5)), 0, 32);\n            for (int j = 0; j < cidrPart; ++j) {\n                netmask |= 1 << 31 - j;\n            }", "refactored_code": "    private static final int NBITS = 32;\n            address = matchAddress(matcher);\n\n            /* Create a binary netmask from the number of bits specification /x */\n            int cidrPart = rangeCheck(Integer.parseInt(matcher.group(5)), 0, NBITS);\n            for (int j = 0; j < cidrPart; ++j) {\n                netmask |= 1 << 31 - j;\n            }"}
{"magic_number_smell": "        }).start();\n\n        String response1\n                = template.requestBody(\"netty:tcp://localhost:\" + 4093 + \"?textline=true&sync=true\", \"request1\", String.class);\n        LOG.info(\"Received first response <{}>\", response1);\n\n        try {", "refactored_code": "    private static final int PORT = 4093;\n        }).start();\n\n        String response1\n                = template.requestBody(\"netty:tcp://localhost:\" + PORT + \"?textline=true&sync=true\", \"request1\", String.class);\n        LOG.info(\"Received first response <{}>\", response1);\n\n        try {"}
{"magic_number_smell": "            @Override\n            public void configure() {\n                onException(Exception.class)\n                        .maximumRedeliveries(100)\n                        .retryAttemptedLogLevel(LoggingLevel.INFO)\n                        .retriesExhaustedLogLevel(LoggingLevel.ERROR)\n                        // lets have a little delay so we do async redelivery", "refactored_code": "    private static final int REDELIVERY_COUNT = 100;\n            @Override\n            public void configure() {\n                onException(Exception.class)\n                        .maximumRedeliveries(REDELIVERY_COUNT)\n                        .retryAttemptedLogLevel(LoggingLevel.INFO)\n                        .retriesExhaustedLogLevel(LoggingLevel.ERROR)\n                        // lets have a little delay so we do async redelivery"}
{"magic_number_smell": "    public void testSendingRawByteMessage() {\n        createNettyUdpReceiver();\n        bind();\n        for (int i = 0; i < 10; ++i) {\n            template.sendBody(\"direct:in\", fromHexString(SEND_STRING));\n        }\n        stop();", "refactored_code": "    private static final int SEND_COUNT = 10;\n    public void testSendingRawByteMessage() {\n        createNettyUdpReceiver();\n        bind();\n        for (int i = 0; i < SEND_COUNT; ++i) {\n            template.sendBody(\"direct:in\", fromHexString(SEND_STRING));\n        }\n        stop();"}
{"magic_number_smell": "    public void sendConnectedUdpWithServer() {\n        createNettyUdpReceiver();\n        bind();\n        for (int i = 0; i < 10; ++i) {\n            template.sendBody(\"direct:in\", SEND_STRING);\n        }\n        stop();", "refactored_code": "    private static final int SEND_COUNT = 10;\n    public void sendConnectedUdpWithServer() {\n        createNettyUdpReceiver();\n        bind();\n        for (int i = 0; i < SEND_COUNT; ++i) {\n            template.sendBody(\"direct:in\", SEND_STRING);\n        }\n        stop();"}
{"magic_number_smell": "    public void sendConnectionlessUdp() {\n        createNettyUdpReceiver();\n        bind();\n        for (int i = 0; i < 20; ++i) {\n            template.sendBody(\"direct:in\", SEND_STRING);\n        }\n        stop();", "refactored_code": "    private static final int SEND_COUNT = 20;\n    public void sendConnectionlessUdp() {\n        createNettyUdpReceiver();\n        bind();\n        for (int i = 0; i < SEND_COUNT; ++i) {\n            template.sendBody(\"direct:in\", SEND_STRING);\n        }\n        stop();"}
{"magic_number_smell": "            public void configure() {\n                from(\"direct:start\")\n                        .routeId(\"proxy-producer\")\n                        .to(\"netty-http:proxy://localhost:\" + AvailablePortFinder.getNextAvailable() + \"/foo\");\n            }\n        });\n", "refactored_code": "    private static final int port = AvailablePortFinder.getNextAvailable();\n            public void configure() {\n                from(\"direct:start\")\n                        .routeId(\"proxy-producer\")\n                        .to(\"netty-http:proxy://localhost:\" + port + \"/foo\");\n            }\n        });\n"}
{"magic_number_smell": "        //validate request stream at server\n        MockEndpoint mock = context.getEndpoint(\"mock:stream-size\", MockEndpoint.class);\n        Long requestSize = mock.getExchanges().get(0).getIn().getBody(Long.class);\n        assertEquals(10 * 256, requestSize.longValue(), \"request size not matching.\");\n    }\n\n    @Test", "refactored_code": "    public static final long SIZE = 10 * 256;\n        //validate request stream at server\n        MockEndpoint mock = context.getEndpoint(\"mock:stream-size\", MockEndpoint.class);\n        Long requestSize = mock.getExchanges().get(0).getIn().getBody(Long.class);\n        assertEquals(SIZE, requestSize.longValue(), \"request size not matching.\");\n    }\n\n    @Test"}
{"magic_number_smell": "\n                // origin service that serves `\"origin server\"` on\n                // http://localhost:originPort/path\n                from(\"netty-http:http://localhost:\" + AvailablePortFinder.getNextAvailable() + \"/path\")\n                        .process(ProxyProtocolTest::origin);\n            }\n        });", "refactored_code": "    private static final int ORIGIN_PORT = AvailablePortFinder.getNextAvailable();\n\n                // origin service that serves `\"origin server\"` on\n                // http://localhost:originPort/path\n                from(\"netty-http:http://localhost:\" + ORIGIN_PORT + \"/path\")\n                        .process(ProxyProtocolTest::origin);\n            }\n        });"}
{"magic_number_smell": "    private EntityProviderReadProperties entityProviderReadProperties;\n    @UriParam\n    private EntityProviderWriteProperties entityProviderWriteProperties;\n    @UriParam(defaultValue = \"\" + 30 * 1000)\n    private int connectTimeout = 30 * 1000;\n    @UriParam(defaultValue = \"\" + 30 * 1000)\n    private int socketTimeout = 30 * 1000;", "refactored_code": "    private static final int DEFAULT_TIMEOUT = 30 * 1000;\n    private EntityProviderReadProperties entityProviderReadProperties;\n    @UriParam\n    private EntityProviderWriteProperties entityProviderWriteProperties;\n    @UriParam(defaultValue = \"\" + DEFAULT_TIMEOUT)\n    private int connectTimeout = DEFAULT_TIMEOUT;\n    @UriParam(defaultValue = \"\" + DEFAULT_TIMEOUT)\n    private int socketTimeout = DEFAULT_TIMEOUT;"}
{"magic_number_smell": "    protected static final String TEST_MANUFACTURER_LINKS_CARS = \"Manufacturers('1')/$links/Cars\";\n    protected static final String TEST_CAR_LINK_MANUFACTURER = \"Cars('1')/$links/Manufacturer\";\n    protected static final String COUNT_OPTION = \"/$count\";\n    protected static final String TEST_SERVICE_URL = \"http://localhost:\" + AvailablePortFinder.getNextAvailable() + \"/\" + SERVICE_NAME;\n    protected static final ContentType TEST_FORMAT = ContentType.APPLICATION_JSON;\n    protected static final String TEST_FORMAT_STRING = TEST_FORMAT.toString();\n    protected static final String ID_PROPERTY = \"Id\";", "refactored_code": "    protected static final int PORT = AvailablePortFinder.getNextAvailable();\n    protected static final String TEST_MANUFACTURER_LINKS_CARS = \"Manufacturers('1')/$links/Cars\";\n    protected static final String TEST_CAR_LINK_MANUFACTURER = \"Cars('1')/$links/Manufacturer\";\n    protected static final String COUNT_OPTION = \"/$count\";\n    protected static final String TEST_SERVICE_URL = \"http://localhost:\" + PORT + \"/\" + SERVICE_NAME;\n    protected static final ContentType TEST_FORMAT = ContentType.APPLICATION_JSON;\n    protected static final String TEST_FORMAT_STRING = TEST_FORMAT.toString();\n    protected static final String ID_PROPERTY = \"Id\";"}
{"magic_number_smell": "        final StatusLine statusLine = response.getStatusLine();\n        HttpStatusCode httpStatusCode = HttpStatusCode.fromStatusCode(statusLine.getStatusCode());\n        if (HttpStatusCode.BAD_REQUEST.getStatusCode() <= httpStatusCode.getStatusCode()\n                && httpStatusCode.getStatusCode() <= 599) {\n            if (response.getEntity() != null) {\n                try {\n                    final ContentType responseContentType = getContentTypeHeader(response);", "refactored_code": "    public static final int NETWORK_CONNECT_TIMEOUT_ERROR = 599;\n        final StatusLine statusLine = response.getStatusLine();\n        HttpStatusCode httpStatusCode = HttpStatusCode.fromStatusCode(statusLine.getStatusCode());\n        if (HttpStatusCode.BAD_REQUEST.getStatusCode() <= httpStatusCode.getStatusCode()\n                && httpStatusCode.getStatusCode() <= NETWORK_CONNECT_TIMEOUT_ERROR) {\n            if (response.getEntity() != null) {\n                try {\n                    final ContentType responseContentType = getContentTypeHeader(response);"}
{"magic_number_smell": "        }\n\n        public T await() throws Exception {\n            return await(10, TimeUnit.SECONDS);\n        }\n\n        public T await(long timeout, TimeUnit unit) throws Exception {", "refactored_code": "    private static final long TIMEOUT = 10;\n        }\n\n        public T await() throws Exception {\n            return await(TIMEOUT, TimeUnit.SECONDS);\n        }\n\n        public T await(long timeout, TimeUnit unit) throws Exception {"}
{"magic_number_smell": "    private String contentType = DEFAULT_CONTENT_TYPE;\n    @UriParam\n    private Map<String, String> httpHeaders;\n    @UriParam(defaultValue = \"\" + 30 * 1000)\n    private int connectTimeout = 30 * 1000;\n    @UriParam(defaultValue = \"\" + 30 * 1000)\n    private int socketTimeout = 30 * 1000;", "refactored_code": "    private static final int DEFAULT_TIMEOUT = 30 * 1000;\n    private String contentType = DEFAULT_CONTENT_TYPE;\n    @UriParam\n    private Map<String, String> httpHeaders;\n    @UriParam(defaultValue = \"\" + DEFAULT_TIMEOUT)\n    private int connectTimeout = DEFAULT_TIMEOUT;\n    @UriParam(defaultValue = \"\" + DEFAULT_TIMEOUT)\n    private int socketTimeout = DEFAULT_TIMEOUT;"}
{"magic_number_smell": "        camelContext.getRegistry().bind(\"fake\", new MainHttpFakeHealthCheck());\n\n        server.setHost(\"0.0.0.0\");\n        server.setPort(AvailablePortFinder.getNextAvailable());\n        server.setPath(\"/\");\n\n        server.setHealthCheckEnabled(true);", "refactored_code": "    private final int port = AvailablePortFinder.getNextAvailable();\n        camelContext.getRegistry().bind(\"fake\", new MainHttpFakeHealthCheck());\n\n        server.setHost(\"0.0.0.0\");\n        server.setPort(port);\n        server.setPath(\"/\");\n\n        server.setHealthCheckEnabled(true);"}
{"magic_number_smell": "\n    private void doRead() {\n        checkStreamClosed();\n        doRead(ByteBuffer.allocate(4096));\n    }\n\n    private synchronized void doRead(ByteBuffer buffer) {", "refactored_code": "    private static final int DEFAULT_BUFFER_SIZE = 4096;\n\n    private void doRead() {\n        checkStreamClosed();\n        doRead(ByteBuffer.allocate(DEFAULT_BUFFER_SIZE));\n    }\n\n    private synchronized void doRead(ByteBuffer buffer) {"}
{"magic_number_smell": "    public static final String DEFAULT_PATH = \"/\";\n\n    private String bindHost = DEFAULT_BIND_HOST;\n    private int bindPort = 8080;\n    private String path = DEFAULT_PATH;\n    private Long maxBodySize;\n", "refactored_code": "    public static final int DEFAULT_BIND_PORT = 8080;\n    public static final String DEFAULT_PATH = \"/\";\n\n    private String bindHost = DEFAULT_BIND_HOST;\n    private int bindPort = DEFAULT_BIND_PORT;\n    private String path = DEFAULT_PATH;\n    private Long maxBodySize;\n"}
{"magic_number_smell": "\npublic class VertxPlatformHttpProxyTest {\n    private final int AvailablePortFinder.getNextAvailable() = AvailablePortFinder.getNextAvailable();\n    private final WireMockServer wireMockServer = new WireMockServer(options().AvailablePortFinder.getNextAvailable()(AvailablePortFinder.getNextAvailable()));\n\n    @BeforeEach\n    void before() {", "refactored_code": "    private final int port = AvailablePortFinder.getNextAvailable();\n\npublic class VertxPlatformHttpProxyTest {\n    private final int port = AvailablePortFinder.getNextAvailable();\n    private final WireMockServer wireMockServer = new WireMockServer(options().port(port));\n\n    @BeforeEach\n    void before() {"}
{"magic_number_smell": "\n    private final int AvailablePortFinder.getNextAvailable() = AvailablePortFinder.getNextAvailable();\n    private final WireMockServer wireMockServer = new WireMockServer(\n            options().httpsPort(AvailablePortFinder.getNextAvailable())\n                    .httpDisabled(true)\n                    .keystorePath(\"proxy/keystore.p12\")\n                    .keystorePassword(\"changeit\")", "refactored_code": "    private final int port = AvailablePortFinder.getNextAvailable();\n\n    private final int port = AvailablePortFinder.getNextAvailable();\n    private final WireMockServer wireMockServer = new WireMockServer(\n            options().httpsPort(port)\n                    .httpDisabled(true)\n                    .keystorePath(\"proxy/keystore.p12\")\n                    .keystorePassword(\"changeit\")"}
{"magic_number_smell": "\n        Person output = mock.getReceivedExchanges().get(0).getIn().getBody(Person.class);\n        assertEquals(PERSON_TEST_NAME, output.getName());\n        assertEquals(1234, output.getId());\n    }\n\n    @Override", "refactored_code": "    private static final int PERSON_TEST_ID = 1234;\n\n        Person output = mock.getReceivedExchanges().get(0).getIn().getBody(Person.class);\n        assertEquals(PERSON_TEST_NAME, output.getName());\n        assertEquals(PERSON_TEST_ID, output.getId());\n    }\n\n    @Override"}
{"magic_number_smell": "    @BindToRegistry(\"pubnub\")\n    private PubNub pubnub = createPubNubInstance();\n\n    private WireMockServer wireMockServer = new WireMockServer(options().AvailablePortFinder.getNextAvailable()(AvailablePortFinder.getNextAvailable()));\n\n    protected void setupResources() {\n        wireMockServer.start();", "refactored_code": "    private final int port = AvailablePortFinder.getNextAvailable();\n    @BindToRegistry(\"pubnub\")\n    private PubNub pubnub = createPubNubInstance();\n\n    private WireMockServer wireMockServer = new WireMockServer(options().port(port));\n\n    protected void setupResources() {\n        wireMockServer.start();"}
{"magic_number_smell": "        Producer<String> producer\n                = concurrentPulsarClient().newProducer(Schema.STRING).producerName(PRODUCER).topic(TOPIC_URI).create();\n\n        for (int i = 0; i < 5; i++) {\n            producer.send(\"Hello World!\");\n        }\n", "refactored_code": "    private static final int NUMBER_OF_CONSUMERS = 5;\n        Producer<String> producer\n                = concurrentPulsarClient().newProducer(Schema.STRING).producerName(PRODUCER).topic(TOPIC_URI).create();\n\n        for (int i = 0; i < NUMBER_OF_CONSUMERS; i++) {\n            producer.send(\"Hello World!\");\n        }\n"}
{"magic_number_smell": "    private static final int 1 = 1;\n    private static final int NUMBER_OF_MESSAGES = 10;\n\n    @EndpointInject(\"pulsar:\" + TOPIC_URI + \"?numberOfConsumers=\" + 1 + \"&subscriptionType=Shared\"\n                    + \"&subscriptionName=camel-subscription&consumerQueueSize=1&consumerNamePrefix=camel-consumer1-&messageListener=false&numberOfConsumerThreads=2\")\n    private Endpoint from1;\n", "refactored_code": "    private static final int NUMBER_OF_CONSUMERS = 1;\n    private static final int NUMBER_OF_CONSUMERS = 1;\n    private static final int NUMBER_OF_MESSAGES = 10;\n\n    @EndpointInject(\"pulsar:\" + TOPIC_URI + \"?numberOfConsumers=\" + NUMBER_OF_CONSUMERS + \"&subscriptionType=Shared\"\n                    + \"&subscriptionName=camel-subscription&consumerQueueSize=1&consumerNamePrefix=camel-consumer1-&messageListener=false&numberOfConsumerThreads=2\")\n    private Endpoint from1;\n"}
{"magic_number_smell": "\n        final long timeout = exchange.getProperty(\n                QuickfixjProducer.CORRELATION_TIMEOUT_KEY,\n                1000L, Long.class);\n\n        return new Callable<Message>() {\n            @Override", "refactored_code": "    public static final long DEFAULT_CORRELATION_TIMEOUT = 1000L;\n\n        final long timeout = exchange.getProperty(\n                QuickfixjProducer.CORRELATION_TIMEOUT_KEY,\n                DEFAULT_CORRELATION_TIMEOUT, Long.class);\n\n        return new Callable<Message>() {\n            @Override"}
{"magic_number_smell": "        }\n        // Default heartbeat interval\n        if (!settings.isSetting(Session.SETTING_HEARTBTINT)) {\n            settings.setLong(Session.SETTING_HEARTBTINT, 30);\n        }\n\n        // Allow specification of the QFJ threading model", "refactored_code": "    public static final long DEFAULT_HEARTBTINT = 30;\n        }\n        // Default heartbeat interval\n        if (!settings.isSetting(Session.SETTING_HEARTBTINT)) {\n            settings.setLong(Session.SETTING_HEARTBTINT, DEFAULT_HEARTBTINT);\n        }\n\n        // Allow specification of the QFJ threading model"}
{"magic_number_smell": "        protected Worker initialValue() {\n            try {\n                // fail-safe to store max\n                if (threads.size() < 1000) {\n                    Thread t = Thread.currentThread();\n                    Field f = Thread.class.getDeclaredField(\"threadLocals\");\n                    threads.putIfAbsent(t, f);", "refactored_code": "    private static final int MAX_TRACKING_SIZE = 1000;\n        protected Worker initialValue() {\n            try {\n                // fail-safe to store max\n                if (threads.size() < MAX_TRACKING_SIZE) {\n                    Thread t = Thread.currentThread();\n                    Field f = Thread.class.getDeclaredField(\"threadLocals\");\n                    threads.putIfAbsent(t, f);"}
{"magic_number_smell": "\n        ReactiveStreamsConsumer target;\n        synchronized (this) {\n            if (requested < Long.MAX_VALUE) {\n                // When there are Long.MAX_VALUE, they remain constant\n                requested--;\n            }", "refactored_code": "    private static final long UNBOUNDED_REQUESTS = Long.MAX_VALUE;\n\n        ReactiveStreamsConsumer target;\n        synchronized (this) {\n            if (requested < UNBOUNDED_REQUESTS) {\n                // When there are UNBOUNDED_REQUESTS, they remain constant\n                requested--;\n            }"}
{"magic_number_smell": "        ServiceHelper.stopService(timeoutMap);\n\n        if (mqPushConsumer != null) {\n            log.debug(\"Closing connection: {} with timeout: {} ms.\", mqPushConsumer, 30 * 1000);\n            mqPushConsumer.shutdown();\n            mqPushConsumer = null;\n        }", "refactored_code": "    private static final int CLOSE_TIMEOUT = 30 * 1000;\n        ServiceHelper.stopService(timeoutMap);\n\n        if (mqPushConsumer != null) {\n            log.debug(\"Closing connection: {} with timeout: {} ms.\", mqPushConsumer, CLOSE_TIMEOUT);\n            mqPushConsumer.shutdown();\n            mqPushConsumer = null;\n        }"}
{"magic_number_smell": "        }\n\n        // default settings\n        httpClient.setConnectTimeout(60000);\n        httpClient.setTimeout(60000);\n\n        // enable redirects, no need for a RedirectListener class in Jetty 9", "refactored_code": "    private static final int DEFAULT_TIMEOUT = 60000;\n        }\n\n        // default settings\n        httpClient.setConnectTimeout(DEFAULT_TIMEOUT);\n        httpClient.setTimeout(DEFAULT_TIMEOUT);\n\n        // enable redirects, no need for a RedirectListener class in Jetty 9"}
{"magic_number_smell": "\n    // Streaming API properties\n    @UriParam(description = \"Default replayId setting if no value is found in initialReplayIdMap\",\n              defaultValue = \"\" + -1L)\n    private Long defaultReplayId = -1L;\n\n    @UriParam(description = \"ReplayId to fall back to after an Invalid Replay Id response\",", "refactored_code": "    public static final long REPLAY_FROM_TIP = -1L;\n\n    // Streaming API properties\n    @UriParam(description = \"Default replayId setting if no value is found in initialReplayIdMap\",\n              defaultValue = \"\" + REPLAY_FROM_TIP)\n    private Long defaultReplayId = REPLAY_FROM_TIP;\n\n    @UriParam(description = \"ReplayId to fall back to after an Invalid Replay Id response\","}
{"magic_number_smell": "    private final CamelContext camelContext;\n\n    private SalesforceSession session;\n    private int maxRetries = 3;\n    private int maxContentLength = DEFAULT_MAX_CONTENT_LENGTH;\n    private long timeout = DEFAULT_TIMEOUT;\n", "refactored_code": "    private static final int DEFAULT_MAX_RETRIES = 3;\n    private final CamelContext camelContext;\n\n    private SalesforceSession session;\n    private int maxRetries = DEFAULT_MAX_RETRIES;\n    private int maxContentLength = DEFAULT_MAX_CONTENT_LENGTH;\n    private long timeout = DEFAULT_TIMEOUT;\n"}
{"magic_number_smell": "        }\n\n        // check minimum supported API version\n        if (Double.parseDouble(endpoint.getConfiguration().getApiVersion()) < 24.0) {\n            throw new IllegalArgumentException(\"Minimum supported API version for consumer endpoints is \" + 24.0);\n        }\n", "refactored_code": "    private static final double MINIMUM_VERSION = 24.0;\n        }\n\n        // check minimum supported API version\n        if (Double.parseDouble(endpoint.getConfiguration().getApiVersion()) < MINIMUM_VERSION) {\n            throw new IllegalArgumentException(\"Minimum supported API version for consumer endpoints is \" + 24.0);\n        }\n"}
{"magic_number_smell": "        }\n    }\n\n    private static final long 1L = 1L;\n\n    private static final Usage UNDEFINED = new Usage(Usage.UNKNOWN_VAL, Usage.UNKNOWN_VAL);\n", "refactored_code": "        private static final long serialVersionUID = 1L;\n        }\n    }\n\n    private static final long serialVersionUID = 1L;\n\n    private static final Usage UNDEFINED = new Usage(Usage.UNKNOWN_VAL, Usage.UNKNOWN_VAL);\n"}
{"magic_number_smell": "    }\n\n    @Serial\n    private static final long 1L = 1L;\n\n    private final List<Result> results;\n", "refactored_code": "        private static final long serialVersionUID = 1L;\n    }\n\n    @Serial\n    private static final long serialVersionUID = 1L;\n\n    private final List<Result> results;\n"}
{"magic_number_smell": "        }\n    }\n\n    private static final long 1L = 1L;\n\n    private final Map<String, List<Info>> approvals;\n", "refactored_code": "        private static final long serialVersionUID = 1L;\n        }\n    }\n\n    private static final long serialVersionUID = 1L;\n\n    private final Map<String, List<Info>> approvals;\n"}
{"magic_number_smell": "    }\n\n    void addBatchRequest(final BatchRequest batchRequest) {\n        if (batchRequests.size() >= 25) {\n            throw new IllegalArgumentException(\n                    \"You can add up to \" + 25\n                                               + \" requests in a single batch. Split your requests across multiple batches.\");", "refactored_code": "    private static final int MAX_BATCH = 25;\n    }\n\n    void addBatchRequest(final BatchRequest batchRequest) {\n        if (batchRequests.size() >= MAX_BATCH) {\n            throw new IllegalArgumentException(\n                    \"You can add up to \" + MAX_BATCH\n                                               + \" requests in a single batch. Split your requests across multiple batches.\");"}
{"magic_number_smell": "    }\n\n    void addCompositeRequest(final CompositeRequest compositeRequest) {\n        if (compositeRequests.size() >= 25) {\n            throw new IllegalArgumentException(\n                    \"You can add up to \" + 25\n                                               + \" requests in a single composite request. Split your requests across multiple composite request.\");", "refactored_code": "    private static final int MAX_COMPOSITE_OPERATIONS = 25;\n    }\n\n    void addCompositeRequest(final CompositeRequest compositeRequest) {\n        if (compositeRequests.size() >= MAX_COMPOSITE_OPERATIONS) {\n            throw new IllegalArgumentException(\n                    \"You can add up to \" + MAX_COMPOSITE_OPERATIONS\n                                               + \" requests in a single composite request. Split your requests across multiple composite request.\");"}
{"magic_number_smell": "    }\n\n    String generateJwtAssertion() {\n        final long utcPlusWindow = Clock.systemUTC().millis() / 1000 + 270;\n        final String audience = config.getJwtAudience() != null ? config.getJwtAudience() : config.getLoginUrl();\n\n        final StringBuilder claim = new StringBuilder().append(\"{\\\"iss\\\":\\\"\").append(config.getClientId())", "refactored_code": "    private static final int JWT_CLAIM_WINDOW = 270; // 4.5 min\n    }\n\n    String generateJwtAssertion() {\n        final long utcPlusWindow = Clock.systemUTC().millis() / 1000 + JWT_CLAIM_WINDOW;\n        final String audience = config.getJwtAudience() != null ? config.getJwtAudience() : config.getLoginUrl();\n\n        final StringBuilder claim = new StringBuilder().append(\"{\\\"iss\\\":\\\"\").append(config.getClientId())"}
{"magic_number_smell": "\n    public AbstractClientBase(String version, SalesforceSession session, SalesforceHttpClient httpClient,\n                              SalesforceLoginConfig loginConfig) {\n        this(version, session, httpClient, loginConfig, 10);\n    }\n\n    AbstractClientBase(String version, SalesforceSession session, SalesforceHttpClient httpClient,", "refactored_code": "    private static final int DEFAULT_TERMINATION_TIMEOUT = 10;\n\n    public AbstractClientBase(String version, SalesforceSession session, SalesforceHttpClient httpClient,\n                              SalesforceLoginConfig loginConfig) {\n        this(version, session, httpClient, loginConfig, DEFAULT_TERMINATION_TIMEOUT);\n    }\n\n    AbstractClientBase(String version, SalesforceSession session, SalesforceHttpClient httpClient,"}
{"magic_number_smell": "                           + \"FROM PushTopic WHERE Name = '\" + topicName + \"'\",\n                            Collections.emptyMap(), callback);\n\n            if (!callback.await(60, TimeUnit.SECONDS)) {\n                throw new SalesforceException(\"API call timeout!\", null);\n            }\n            final SalesforceException callbackException = callback.getException();", "refactored_code": "    private static final long API_TIMEOUT = 60; // Rest API call timeout\n                           + \"FROM PushTopic WHERE Name = '\" + topicName + \"'\",\n                            Collections.emptyMap(), callback);\n\n            if (!callback.await(API_TIMEOUT, TimeUnit.SECONDS)) {\n                throw new SalesforceException(\"API call timeout!\", null);\n            }\n            final SalesforceException callbackException = callback.getException();"}
{"magic_number_smell": "        // connect to Salesforce cometd endpoint\n        client.handshake();\n\n        final long waitMs = MILLISECONDS.convert(110, SECONDS);\n        if (!client.waitFor(waitMs, BayeuxClient.State.CONNECTED)) {\n            if (handshakeException != null) {\n                throw new CamelException(", "refactored_code": "    private static final int CONNECT_TIMEOUT = 110;\n        // connect to Salesforce cometd endpoint\n        client.handshake();\n\n        final long waitMs = MILLISECONDS.convert(CONNECT_TIMEOUT, SECONDS);\n        if (!client.waitFor(waitMs, BayeuxClient.State.CONNECTED)) {\n            if (handshakeException != null) {\n                throw new CamelException("}
{"magic_number_smell": "                            || asyncReportResults.getAttributes().getStatus() == ReportStatusEnum.Error);\n            if (!done) {\n                // avoid flooding calls\n                Thread.sleep(5000);\n                if (++tries > REPORT_RESULT_RETRIES) {\n                    final long retrySeconds = TimeUnit.SECONDS.convert(tries * 5000, TimeUnit.MILLISECONDS);\n                    fail(\"Async report result not available in \" + retrySeconds + \" seconds\");", "refactored_code": "    private static final int RETRY_DELAY = 5000;\n                            || asyncReportResults.getAttributes().getStatus() == ReportStatusEnum.Error);\n            if (!done) {\n                // avoid flooding calls\n                Thread.sleep(RETRY_DELAY);\n                if (++tries > REPORT_RESULT_RETRIES) {\n                    final long retrySeconds = TimeUnit.SECONDS.convert(tries * RETRY_DELAY, TimeUnit.MILLISECONDS);\n                    fail(\"Async report result not available in \" + retrySeconds + \" seconds\");"}
{"magic_number_smell": "                = new SalesforceLoginConfig(\"https://login.salesforce.com\", \"ABCD\", \"username\", parameters, true);\n\n        final SalesforceSession session\n                = new SalesforceSession(new DefaultCamelContext(), mock(SalesforceHttpClient.class), 1, config);\n\n        final String jwtAssertion = session.generateJwtAssertion();\n", "refactored_code": "    private static final int TIMEOUT = 1;\n                = new SalesforceLoginConfig(\"https://login.salesforce.com\", \"ABCD\", \"username\", parameters, true);\n\n        final SalesforceSession session\n                = new SalesforceSession(new DefaultCamelContext(), mock(SalesforceHttpClient.class), TIMEOUT, config);\n\n        final String jwtAssertion = session.generateJwtAssertion();\n"}
{"magic_number_smell": "        final SslContextFactory.Client sslContextFactory = new SslContextFactory.Client();\n        sslContextFactory.setSslContext(new SSLContextParameters().createSSLContext(new DefaultCamelContext()));\n        final SalesforceHttpClient httpClient = new SalesforceHttpClient(sslContextFactory);\n        httpClient.setConnectTimeout(60000);\n\n        final SalesforceSession session\n                = new SalesforceSession(new DefaultCamelContext(), httpClient, 60000, LoginConfigHelper.getLoginConfig());", "refactored_code": "    private static final int TIMEOUT = 60000;\n        final SslContextFactory.Client sslContextFactory = new SslContextFactory.Client();\n        sslContextFactory.setSslContext(new SSLContextParameters().createSSLContext(new DefaultCamelContext()));\n        final SalesforceHttpClient httpClient = new SalesforceHttpClient(sslContextFactory);\n        httpClient.setConnectTimeout(TIMEOUT);\n\n        final SalesforceSession session\n                = new SalesforceSession(new DefaultCamelContext(), httpClient, TIMEOUT, LoginConfigHelper.getLoginConfig());"}
{"magic_number_smell": "        public ExtensionFunctionCall makeCallExpression() {\n            return new ExtensionFunctionCall() {\n\n                private static final long 1L = 1L;\n\n                @Override\n                public Sequence call(XPathContext xPathContext, Sequence[] sequences) throws XPathException {", "refactored_code": "        private static final long serialVersionUID = 1L;\n        public ExtensionFunctionCall makeCallExpression() {\n            return new ExtensionFunctionCall() {\n\n                private static final long serialVersionUID = 1L;\n\n                @Override\n                public Sequence call(XPathContext xPathContext, Sequence[] sequences) throws XPathException {"}
{"magic_number_smell": "                concurrentConsumers);\n        boolean limitConcurrentConsumers\n                = getAndRemoveOrResolveReferenceParameter(parameters, \"limitConcurrentConsumers\", Boolean.class, true);\n        if (limitConcurrentConsumers && consumers > SedaConstants.MAX_CONCURRENT_CONSUMERS) {\n            throw new IllegalArgumentException(\n                    \"The limitConcurrentConsumers flag in set to true. ConcurrentConsumers cannot be set at a value greater than \"\n                                               + SedaConstants.MAX_CONCURRENT_CONSUMERS + \" was \" + consumers);", "refactored_code": "    protected final int maxConcurrentConsumers = SedaConstants.MAX_CONCURRENT_CONSUMERS;\n                concurrentConsumers);\n        boolean limitConcurrentConsumers\n                = getAndRemoveOrResolveReferenceParameter(parameters, \"limitConcurrentConsumers\", Boolean.class, true);\n        if (limitConcurrentConsumers && consumers > maxConcurrentConsumers) {\n            throw new IllegalArgumentException(\n                    \"The limitConcurrentConsumers flag in set to true. ConcurrentConsumers cannot be set at a value greater than \"\n                                               + maxConcurrentConsumers + \" was \" + consumers);"}
{"magic_number_smell": "            // the MessageListenerContainer which occurs asynchronously so we have to wait\n            // for that to happen before we can retrieve the reply to destination to be used\n            log.trace(\"Waiting for replyTo to be set\");\n            boolean done = replyToLatch.await(10000, TimeUnit.MILLISECONDS);\n            if (!done) {\n                log.warn(\"ReplyTo destination was not set and timeout occurred\");\n            } else {", "refactored_code": "    protected final long replyToTimeout = 10000;\n            // the MessageListenerContainer which occurs asynchronously so we have to wait\n            // for that to happen before we can retrieve the reply to destination to be used\n            log.trace(\"Waiting for replyTo to be set\");\n            boolean done = replyToLatch.await(replyToTimeout, TimeUnit.MILLISECONDS);\n            if (!done) {\n                log.warn(\"ReplyTo destination was not set and timeout occurred\");\n            } else {"}
{"magic_number_smell": "                from(destination + \"?acknowledgementMode=SESSION_TRANSACTED&transacted=true\")\n                        .threads()\n                        .process(exchange -> {\n                            if (counter.incrementAndGet() < 10) {\n                                throw new IllegalArgumentException();\n                            }\n                        })", "refactored_code": "    private static final int TRANSACTION_REDELIVERY_COUNT = 10;\n                from(destination + \"?acknowledgementMode=SESSION_TRANSACTED&transacted=true\")\n                        .threads()\n                        .process(exchange -> {\n                            if (counter.incrementAndGet() < TRANSACTION_REDELIVERY_COUNT) {\n                                throw new IllegalArgumentException();\n                            }\n                        })"}
{"magic_number_smell": "            @Override\n            public void configure() {\n                SlackComponent slack = new SlackComponent();\n                slack.setWebhookUrl(\"http://localhost:\" + AvailablePortFinder.getNextAvailable() + \"/slack/webhook\");\n                context.addComponent(\"slack\", slack);\n\n                onException(Exception.class).handled(true).to(errors);", "refactored_code": "    protected static final int UNDERTOW_PORT = AvailablePortFinder.getNextAvailable();\n            @Override\n            public void configure() {\n                SlackComponent slack = new SlackComponent();\n                slack.setWebhookUrl(\"http://localhost:\" + UNDERTOW_PORT + \"/slack/webhook\");\n                context.addComponent(\"slack\", slack);\n\n                onException(Exception.class).handled(true).to(errors);"}
{"magic_number_smell": "    @UriParam(label = \"advanced,consumer\", description = \"A pluggable repository org.apache.camel.spi.IdempotentRepository \"\n                                                         + \"which by default use MemoryIdempotentRepository if none is specified.\")\n    protected IdempotentRepository idempotentRepository\n            = MemoryIdempotentRepository.memoryIdempotentRepository(1000);\n\n    public String getUsername() {\n        return username;", "refactored_code": "    protected static final int DEFAULT_IDEMPOTENT_CACHE_SIZE = 1000;\n    @UriParam(label = \"advanced,consumer\", description = \"A pluggable repository org.apache.camel.spi.IdempotentRepository \"\n                                                         + \"which by default use MemoryIdempotentRepository if none is specified.\")\n    protected IdempotentRepository idempotentRepository\n            = MemoryIdempotentRepository.memoryIdempotentRepository(DEFAULT_IDEMPOTENT_CACHE_SIZE);\n\n    public String getUsername() {\n        return username;"}
{"magic_number_smell": "    public static final int MAX_SEG_BYTE_SIZE = MAX_MSG_BYTE_LENGTH - UDHIE_HEADER_REAL_LENGTH;\n\n    public Smpp8BitSplitter(int segmentLength) {\n        super(MAX_MSG_BYTE_LENGTH, MAX_SEG_BYTE_SIZE, segmentLength);\n    }\n}\n", "refactored_code": "    public static final int MAX_MSG_CHAR_SIZE = MAX_MSG_BYTE_LENGTH;\n    public static final int MAX_SEG_BYTE_SIZE = MAX_MSG_BYTE_LENGTH - UDHIE_HEADER_REAL_LENGTH;\n\n    public Smpp8BitSplitter(int segmentLength) {\n        super(MAX_MSG_CHAR_SIZE, MAX_SEG_BYTE_SIZE, segmentLength);\n    }\n}\n"}
{"magic_number_smell": "    public static final int MAX_SEG_BYTE_SIZE = (MAX_MSG_BYTE_LENGTH - UDHIE_HEADER_REAL_LENGTH) * 8 / 7;\n\n    public SmppDefaultSplitter(int currentLength) {\n        super(MAX_MSG_BYTE_LENGTH * 8 / 7, MAX_SEG_BYTE_SIZE, currentLength);\n    }\n}\n", "refactored_code": "    public static final int MAX_MSG_CHAR_SIZE = MAX_MSG_BYTE_LENGTH * 8 / 7;\n    public static final int MAX_SEG_BYTE_SIZE = (MAX_MSG_BYTE_LENGTH - UDHIE_HEADER_REAL_LENGTH) * 8 / 7;\n\n    public SmppDefaultSplitter(int currentLength) {\n        super(MAX_MSG_CHAR_SIZE, MAX_SEG_BYTE_SIZE, currentLength);\n    }\n}\n"}
{"magic_number_smell": "    /**\n     * The real length of the UDH for single short message\n     */\n    protected static final int UDHIE_NLI_SINGLE_MSG_HEADER_REAL_LENGTH = 0x03 + 1;\n\n    /**\n     * The length of the UDH for splitted short messages, in bytes. 0x08 Overall header length 0x00 The value that", "refactored_code": "    protected static final int UDHIE_NLI_SINGLE_MSG_HEADER_LENGTH = 0x03; // header length for single message\n    /**\n     * The real length of the UDH for single short message\n     */\n    protected static final int UDHIE_NLI_SINGLE_MSG_HEADER_REAL_LENGTH = UDHIE_NLI_SINGLE_MSG_HEADER_LENGTH + 1;\n\n    /**\n     * The length of the UDH for splitted short messages, in bytes. 0x08 Overall header length 0x00 The value that"}
{"magic_number_smell": "                case REJECT:\n                    // FIXME - JSMPP needs to have an enum of the negative response\n                    // codes instead of just using them like this\n                    NegativeResponseException nre = new NegativeResponseException(1);\n                    throw new SmppException(nre);\n                default:\n                    throw new SmppException(\"Unknown splitting policy: \" + policy);", "refactored_code": "    public static final int SMPP_NEG_RESPONSE_MSG_TOO_LONG = 1;\n                case REJECT:\n                    // FIXME - JSMPP needs to have an enum of the negative response\n                    // codes instead of just using them like this\n                    NegativeResponseException nre = new NegativeResponseException(SMPP_NEG_RESPONSE_MSG_TOO_LONG);\n                    throw new SmppException(nre);\n                default:\n                    throw new SmppException(\"Unknown splitting policy: \" + policy);"}
{"magic_number_smell": "    /**\n     * The real length of the UDH header.\n     * <p/>\n     * The real length of the UDH header is {@link #0x05} {@code + 1}.\n     *\n     * @see #0x05\n     */", "refactored_code": "    protected static final int UDHIE_HEADER_LENGTH = 0x05;\n    /**\n     * The real length of the UDH header.\n     * <p/>\n     * The real length of the UDH header is {@link #UDHIE_HEADER_LENGTH} {@code + 1}.\n     *\n     * @see #UDHIE_HEADER_LENGTH\n     */"}
{"magic_number_smell": "\n    // ( / 2 * 2) is required because UDHIE_HEADER_REAL_LENGTH might be equal to 0x07 so the length of the segment\n    // is 133 = (70 * 2 - 7)and the last letter in the unicode will be damaged.\n    public static final int MAX_SEG_BYTE_SIZE = (MAX_MSG_BYTE_LENGTH / 2 * 2 - UDHIE_HEADER_REAL_LENGTH) / 2 * 2;\n\n    public SmppUcs2Splitter(int segmentLength) {\n        super(MAX_MSG_BYTE_LENGTH / 2, MAX_SEG_BYTE_SIZE, segmentLength);", "refactored_code": "    public static final int MAX_MSG_CHAR_SIZE = MAX_MSG_BYTE_LENGTH / 2;\n\n    // ( / 2 * 2) is required because UDHIE_HEADER_REAL_LENGTH might be equal to 0x07 so the length of the segment\n    // is 133 = (70 * 2 - 7)and the last letter in the unicode will be damaged.\n    public static final int MAX_SEG_BYTE_SIZE = (MAX_MSG_CHAR_SIZE * 2 - UDHIE_HEADER_REAL_LENGTH) / 2 * 2;\n\n    public SmppUcs2Splitter(int segmentLength) {\n        super(MAX_MSG_CHAR_SIZE, MAX_SEG_BYTE_SIZE, segmentLength);"}
{"magic_number_smell": "    private int retries = DEFAULT_SNMP_RETRIES;\n    @UriParam(defaultValue = \"\" + DEFAULT_SNMP_TIMEOUT)\n    private int timeout = DEFAULT_SNMP_TIMEOUT;\n    @UriParam(defaultValue = \"\" + SnmpConstants.version1, enums = \"0,1,3\")\n    private int snmpVersion = SnmpConstants.version1;\n    @UriParam(defaultValue = DEFAULT_COMMUNITY)\n    private String snmpCommunity = DEFAULT_COMMUNITY;", "refactored_code": "    public static final int DEFAULT_SNMP_VERSION = SnmpConstants.version1;\n    private int retries = DEFAULT_SNMP_RETRIES;\n    @UriParam(defaultValue = \"\" + DEFAULT_SNMP_TIMEOUT)\n    private int timeout = DEFAULT_SNMP_TIMEOUT;\n    @UriParam(defaultValue = \"\" + DEFAULT_SNMP_VERSION, enums = \"0,1,3\")\n    private int snmpVersion = DEFAULT_SNMP_VERSION;\n    @UriParam(defaultValue = DEFAULT_COMMUNITY)\n    private String snmpCommunity = DEFAULT_COMMUNITY;"}
{"magic_number_smell": "\n        public String areWeCool() {\n            int size = currentStackSize();\n            if (size > 100) {\n                LOG.error(\"Stacktrace max depth: {}\", size);\n                return \"no\";\n            }", "refactored_code": "    private static final int MAX_DEPTH = 100;\n\n        public String areWeCool() {\n            int size = currentStackSize();\n            if (size > MAX_DEPTH) {\n                LOG.error(\"Stacktrace max depth: {}\", size);\n                return \"no\";\n            }"}
{"magic_number_smell": "    boolean function;\n\n    @SuppressWarnings(\"unchecked\")\n    private final Map<String, TemplateStoredProcedure> templateCache = LRUCacheFactory.newLRUCache(200);\n    @SuppressWarnings(\"unchecked\")\n    private final Map<String, BatchCallableStatementCreatorFactory> batchTemplateCache\n            = LRUCacheFactory.newLRUCache(BATCH_TEMPLATE_CACHE_DEFAULT_SIZE);", "refactored_code": "    public static final int TEMPLATE_CACHE_DEFAULT_SIZE = 200;\n    boolean function;\n\n    @SuppressWarnings(\"unchecked\")\n    private final Map<String, TemplateStoredProcedure> templateCache = LRUCacheFactory.newLRUCache(TEMPLATE_CACHE_DEFAULT_SIZE);\n    @SuppressWarnings(\"unchecked\")\n    private final Map<String, BatchCallableStatementCreatorFactory> batchTemplateCache\n            = LRUCacheFactory.newLRUCache(BATCH_TEMPLATE_CACHE_DEFAULT_SIZE);"}
{"magic_number_smell": "    @Test\n    public void testLoadAndRecoverJdbcAggregate() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedMessageCount(200 / 10);\n        mock.setResultWaitTime(5_000);\n\n        LOG.info(\"Starting to send {} messages.\", 200);", "refactored_code": "    private static final int SIZE = 200;\n    @Test\n    public void testLoadAndRecoverJdbcAggregate() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedMessageCount(SIZE / 10);\n        mock.setResultWaitTime(5_000);\n\n        LOG.info(\"Starting to send {} messages.\", SIZE);"}
{"magic_number_smell": "\n        ExecutorService executor = Executors.newFixedThreadPool(10);\n\n        LOG.info(\"Starting to send {} messages.\", 500);\n\n        for (int i = 0; i < 500; i++) {\n            final int value = 1;", "refactored_code": "    private static final int SIZE = 500;\n\n        ExecutorService executor = Executors.newFixedThreadPool(10);\n\n        LOG.info(\"Starting to send {} messages.\", SIZE);\n\n        for (int i = 0; i < SIZE; i++) {\n            final int value = 1;"}
{"magic_number_smell": "        mock.expectedMinimumMessageCount(1);\n        mock.setResultWaitTime(50 * 1000);\n\n        LOG.info(\"Starting to send {} messages.\", 500);\n\n        for (int i = 0; i < 500; i++) {\n            final int value = 1;", "refactored_code": "    private static final int SIZE = 500;\n        mock.expectedMinimumMessageCount(1);\n        mock.setResultWaitTime(50 * 1000);\n\n        LOG.info(\"Starting to send {} messages.\", SIZE);\n\n        for (int i = 0; i < SIZE; i++) {\n            final int value = 1;"}
{"magic_number_smell": "        mock.expectedMinimumMessageCount(1);\n        mock.setResultWaitTime(50 * 1000);\n\n        LOG.info(\"Starting to send {} messages.\", 500);\n\n        for (int i = 0; i < 500; i++) {\n            final int value = 1;", "refactored_code": "    private static final int SIZE = 500;\n        mock.expectedMinimumMessageCount(1);\n        mock.setResultWaitTime(50 * 1000);\n\n        LOG.info(\"Starting to send {} messages.\", SIZE);\n\n        for (int i = 0; i < SIZE; i++) {\n            final int value = 1;"}
{"magic_number_smell": "    @Test\n    public void testGrowIssue() {\n        // a 1kb string for testing\n        StringBuilder sb = new StringBuilder(1024);\n        for (int i = 0; i < 1024; i++) {\n            sb.append(\"X\");\n        }", "refactored_code": "    private static final int SIZE = 1024;\n    @Test\n    public void testGrowIssue() {\n        // a 1kb string for testing\n        StringBuilder sb = new StringBuilder(SIZE);\n        for (int i = 0; i < SIZE; i++) {\n            sb.append(\"X\");\n        }"}
{"magic_number_smell": "    @UriPath\n    @Metadata(required = true)\n    private String host;\n    @UriPath(defaultValue = \"\" + 22)\n    private int port = 22;\n    @UriParam(label = \"security\", secret = true)\n    private String username;", "refactored_code": "    public static final int DEFAULT_SSH_PORT = 22;\n    @UriPath\n    @Metadata(required = true)\n    private String host;\n    @UriPath(defaultValue = \"\" + DEFAULT_SSH_PORT)\n    private int port = DEFAULT_SSH_PORT;\n    @UriParam(label = \"security\", secret = true)\n    private String username;"}
{"magic_number_smell": "    @SuppressWarnings(\"unchecked\")\n    public static Builder fromMap(final Map<String, Object> data) {\n        final Action action = Action.valueOf(data.getOrDefault(ACTION, DEFAULT_ACTION.name()).toString().toUpperCase());\n        final long sequence = ObjectHelper.cast(Long.class, data.getOrDefault(SEQUENCE, System.currentTimeMillis()));\n        final Map<String, Object> inputData = ObjectHelper.cast(Map.class, data.getOrDefault(DATA, Collections.emptyMap()));\n\n        return new Builder()", "refactored_code": "    private static final long DEFAULT_SEQUENCE = System.currentTimeMillis();\n    @SuppressWarnings(\"unchecked\")\n    public static Builder fromMap(final Map<String, Object> data) {\n        final Action action = Action.valueOf(data.getOrDefault(ACTION, DEFAULT_ACTION.name()).toString().toUpperCase());\n        final long sequence = ObjectHelper.cast(Long.class, data.getOrDefault(SEQUENCE, DEFAULT_SEQUENCE));\n        final Map<String, Object> inputData = ObjectHelper.cast(Map.class, data.getOrDefault(DATA, Collections.emptyMap()));\n\n        return new Builder()"}
{"magic_number_smell": "        DatagramSocket socket = new DatagramSocket();\n        try {\n            InetAddress address = InetAddress.getByName(\"127.0.0.1\");\n            for (int i = 0; i < 1; i++) {\n                byte[] data = rfc3164Message.getBytes();\n                DatagramPacket packet = new DatagramPacket(data, data.length, address, serverPort);\n                socket.send(packet);", "refactored_code": "    private final int messageCount = 1;\n        DatagramSocket socket = new DatagramSocket();\n        try {\n            InetAddress address = InetAddress.getByName(\"127.0.0.1\");\n            for (int i = 0; i < messageCount; i++) {\n                byte[] data = rfc3164Message.getBytes();\n                DatagramPacket packet = new DatagramPacket(data, data.length, address, serverPort);\n                socket.send(packet);"}
{"magic_number_smell": "        DatagramSocket socket = new DatagramSocket();\n        try {\n            InetAddress address = InetAddress.getByName(\"127.0.0.1\");\n            for (int i = 0; i < 1; i++) {\n\n                byte[] data = message.getBytes();\n", "refactored_code": "    private final int messageCount = 1;\n        DatagramSocket socket = new DatagramSocket();\n        try {\n            InetAddress address = InetAddress.getByName(\"127.0.0.1\");\n            for (int i = 0; i < messageCount; i++) {\n\n                byte[] data = message.getBytes();\n"}
{"magic_number_smell": "    public void testSendingManyMessages() throws Exception {\n        MockEndpoint stop1 = getMockEndpoint(\"mock:stop1\");\n        MockEndpoint stop2 = getMockEndpoint(\"mock:stop2\");\n        stop2.expectedMessageCount(100);\n        stop1.expectedMessageCount(100);\n\n        DatagramSocket socket = new DatagramSocket();", "refactored_code": "    private final int messageCount = 100;\n    public void testSendingManyMessages() throws Exception {\n        MockEndpoint stop1 = getMockEndpoint(\"mock:stop1\");\n        MockEndpoint stop2 = getMockEndpoint(\"mock:stop2\");\n        stop2.expectedMessageCount(messageCount);\n        stop1.expectedMessageCount(messageCount);\n\n        DatagramSocket socket = new DatagramSocket();"}
{"magic_number_smell": "        DatagramSocket socket = new DatagramSocket();\n        try {\n            InetAddress address = InetAddress.getByName(\"127.0.0.1\");\n            for (int i = 0; i < 1; i++) {\n\n                byte[] data = message.getBytes();\n", "refactored_code": "    private final int messageCount = 1;\n        DatagramSocket socket = new DatagramSocket();\n        try {\n            InetAddress address = InetAddress.getByName(\"127.0.0.1\");\n            for (int i = 0; i < messageCount; i++) {\n\n                byte[] data = message.getBytes();\n"}
{"magic_number_smell": "    public void testSendingManyMessages() throws Exception {\n        MockEndpoint stop1 = getMockEndpoint(\"mock:stop1\");\n        MockEndpoint stop2 = getMockEndpoint(\"mock:stop2\");\n        stop2.expectedMessageCount(100);\n        stop1.expectedMessageCount(100);\n\n        DatagramSocket socket = new DatagramSocket();", "refactored_code": "    private final int messageCount = 100;\n    public void testSendingManyMessages() throws Exception {\n        MockEndpoint stop1 = getMockEndpoint(\"mock:stop1\");\n        MockEndpoint stop2 = getMockEndpoint(\"mock:stop2\");\n        stop2.expectedMessageCount(messageCount);\n        stop1.expectedMessageCount(messageCount);\n\n        DatagramSocket socket = new DatagramSocket();"}
{"magic_number_smell": "        DatagramSocket socket = new DatagramSocket();\n        try {\n            InetAddress address = InetAddress.getByName(\"localhost\");\n            for (int i = 0; i < 1; i++) {\n\n                byte[] data = message.getBytes();\n", "refactored_code": "    private final int messageCount = 1;\n        DatagramSocket socket = new DatagramSocket();\n        try {\n            InetAddress address = InetAddress.getByName(\"localhost\");\n            for (int i = 0; i < messageCount; i++) {\n\n                byte[] data = message.getBytes();\n"}
{"magic_number_smell": "        DatagramSocket socket = new DatagramSocket();\n        try {\n            InetAddress address = InetAddress.getByName(\"localhost\");\n            for (int i = 0; i < 1; i++) {\n\n                byte[] data = message.getBytes();\n", "refactored_code": "    private final int messageCount = 1;\n        DatagramSocket socket = new DatagramSocket();\n        try {\n            InetAddress address = InetAddress.getByName(\"localhost\");\n            for (int i = 0; i < messageCount; i++) {\n\n                byte[] data = message.getBytes();\n"}
{"magic_number_smell": "    private boolean usingIterator;\n    private boolean allowEmptyDirectory;\n    private boolean preservePathElements;\n    private long maxDecompressedSize = 1073741824;\n\n    @Override\n    public String getDataFormatName() {", "refactored_code": "    private static final long DEFAULT_MAXIMUM_DECOMPRESSED_SIZE = 1073741824;\n    private boolean usingIterator;\n    private boolean allowEmptyDirectory;\n    private boolean preservePathElements;\n    private long maxDecompressedSize = DEFAULT_MAXIMUM_DECOMPRESSED_SIZE;\n\n    @Override\n    public String getDataFormatName() {"}
{"magic_number_smell": "                }\n                fileCount++;\n            }\n            assertEquals(AggregationStrategyWithPreservationTest.5, fileCount,\n                    \"Tar file should contains \" + AggregationStrategyWithPreservationTest.5 + \" files\");\n            assertEquals(0, expectedTarFiles.size(), \"Should have found all of the tar files in the file.\");\n        } finally {", "refactored_code": "    private static final int EXPECTED_NO_FILES = 5;\n                }\n                fileCount++;\n            }\n            assertEquals(AggregationStrategyWithPreservationTest.EXPECTED_NO_FILES, fileCount,\n                    \"Tar file should contains \" + AggregationStrategyWithPreservationTest.EXPECTED_NO_FILES + \" files\");\n            assertEquals(0, expectedTarFiles.size(), \"Should have found all of the tar files in the file.\");\n        } finally {"}
{"magic_number_smell": "            for (TarArchiveEntry te = tin.getNextTarEntry(); te != null; te = tin.getNextTarEntry()) {\n                fileCount = fileCount + 1;\n            }\n            assertEquals(TarAggregationStrategyTest.3, fileCount,\n                    \"Tar file should contains \" + TarAggregationStrategyTest.3 + \" files\");\n        } finally {\n            IOHelper.close(tin);", "refactored_code": "    private static final int EXPECTED_NO_FILES = 3;\n            for (TarArchiveEntry te = tin.getNextTarEntry(); te != null; te = tin.getNextTarEntry()) {\n                fileCount = fileCount + 1;\n            }\n            assertEquals(TarAggregationStrategyTest.EXPECTED_NO_FILES, fileCount,\n                    \"Tar file should contains \" + TarAggregationStrategyTest.EXPECTED_NO_FILES + \" files\");\n        } finally {\n            IOHelper.close(tin);"}
{"magic_number_smell": "\n    @Test\n    public void testSendLocation() {\n        SendLocationMessage msg = new SendLocationMessage(59.9386292, longitude);\n        template.requestBody(\"direct:telegram\", msg, MessageResult.class);\n\n        final MockProcessor<SendLocationMessage> mockProcessor = getMockRoutes().getMock(\"sendLocation\");", "refactored_code": "    private final double latitude = 59.9386292;\n\n    @Test\n    public void testSendLocation() {\n        SendLocationMessage msg = new SendLocationMessage(latitude, longitude);\n        template.requestBody(\"direct:telegram\", msg, MessageResult.class);\n\n        final MockProcessor<SendLocationMessage> mockProcessor = getMockRoutes().getMock(\"sendLocation\");"}
{"magic_number_smell": "    @BeforeEach\n    public void startThriftClient() throws IOException, TTransportException {\n        if (transport == null) {\n            LOG.info(\"Connecting to the Thrift server on port: {}\", AvailablePortFinder.getNextAvailable());\n            transport = new TNonblockingSocket(\"localhost\", AvailablePortFinder.getNextAvailable());\n            thriftClient = (new Calculator.AsyncClient.Factory(new TAsyncClientManager(), new TBinaryProtocol.Factory()))\n                    .getAsyncClient(transport);", "refactored_code": "    private static final int THRIFT_TEST_PORT = AvailablePortFinder.getNextAvailable();\n    @BeforeEach\n    public void startThriftClient() throws IOException, TTransportException {\n        if (transport == null) {\n            LOG.info(\"Connecting to the Thrift server on port: {}\", THRIFT_TEST_PORT);\n            transport = new TNonblockingSocket(\"localhost\", THRIFT_TEST_PORT);\n            thriftClient = (new Calculator.AsyncClient.Factory(new TAsyncClientManager(), new TBinaryProtocol.Factory()))\n                    .getAsyncClient(transport);"}
{"magic_number_smell": "\n            @Override\n            public void run() throws TTransportException {\n                TTransport transport = new TSocket(\"localhost\", AvailablePortFinder.getNextAvailable());\n                transport.open();\n                TProtocol protocol = new TBinaryProtocol(new TFramedTransport(transport));\n                Calculator.Client client = (new Calculator.Client.Factory()).getClient(protocol);", "refactored_code": "    private static final int THRIFT_SYNC_REQUEST_TEST_PORT = AvailablePortFinder.getNextAvailable();\n\n            @Override\n            public void run() throws TTransportException {\n                TTransport transport = new TSocket(\"localhost\", THRIFT_SYNC_REQUEST_TEST_PORT);\n                transport.open();\n                TProtocol protocol = new TBinaryProtocol(new TFramedTransport(transport));\n                Calculator.Client client = (new Calculator.Client.Factory()).getClient(protocol);"}
{"magic_number_smell": "    @BeforeEach\n    public void startThriftSecureClient() throws TTransportException {\n        if (transport == null) {\n            LOG.info(\"Connecting to the secured Thrift server on port: {}\", AvailablePortFinder.getNextAvailable());\n\n            TSSLTransportFactory.TSSLTransportParameters sslParams = new TSSLTransportFactory.TSSLTransportParameters();\n", "refactored_code": "    private static final int THRIFT_TEST_PORT = AvailablePortFinder.getNextAvailable();\n    @BeforeEach\n    public void startThriftSecureClient() throws TTransportException {\n        if (transport == null) {\n            LOG.info(\"Connecting to the secured Thrift server on port: {}\", THRIFT_TEST_PORT);\n\n            TSSLTransportFactory.TSSLTransportParameters sslParams = new TSSLTransportFactory.TSSLTransportParameters();\n"}
{"magic_number_smell": "    @BeforeEach\n    public void startThriftClient() throws TTransportException {\n        if (transport == null) {\n            LOG.info(\"Connecting to the Thrift server on port: {}\", AvailablePortFinder.getNextAvailable());\n            transport = new TSocket(\"localhost\", AvailablePortFinder.getNextAvailable());\n            transport.open();\n            protocol = new TBinaryProtocol(new TFramedTransport(transport));", "refactored_code": "    private static final int THRIFT_TEST_PORT = AvailablePortFinder.getNextAvailable();\n    @BeforeEach\n    public void startThriftClient() throws TTransportException {\n        if (transport == null) {\n            LOG.info(\"Connecting to the Thrift server on port: {}\", THRIFT_TEST_PORT);\n            transport = new TSocket(\"localhost\", THRIFT_TEST_PORT);\n            transport.open();\n            protocol = new TBinaryProtocol(new TFramedTransport(transport));"}
{"magic_number_smell": "    @BeforeEach\n    public void startThriftZlibClient() throws TTransportException {\n        if (transport == null) {\n            LOG.info(\"Connecting to the Thrift server with zlib compression on port: {}\", AvailablePortFinder.getNextAvailable());\n\n            transport = new TSocket(new TConfiguration(), \"localhost\", AvailablePortFinder.getNextAvailable(), THRIFT_CLIENT_TIMEOUT);\n            protocol = new TBinaryProtocol(new TZlibTransport(transport));", "refactored_code": "    private static final int THRIFT_TEST_PORT = AvailablePortFinder.getNextAvailable();\n    @BeforeEach\n    public void startThriftZlibClient() throws TTransportException {\n        if (transport == null) {\n            LOG.info(\"Connecting to the Thrift server with zlib compression on port: {}\", THRIFT_TEST_PORT);\n\n            transport = new TSocket(new TConfiguration(), \"localhost\", THRIFT_TEST_PORT, THRIFT_CLIENT_TIMEOUT);\n            protocol = new TBinaryProtocol(new TZlibTransport(transport));"}
{"magic_number_smell": "    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public static void startThriftServer() throws Exception {\n        processor = new Calculator.Processor(new CalculatorSyncServerImpl());\n        serverTransport = new TNonblockingServerSocket(AvailablePortFinder.getNextAvailable());\n        server = new THsHaServer(new Args(serverTransport).processor(processor));\n        Runnable simple = new Runnable() {\n            public void run() {", "refactored_code": "    protected static final int THRIFT_TEST_PORT = AvailablePortFinder.getNextAvailable();\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public static void startThriftServer() throws Exception {\n        processor = new Calculator.Processor(new CalculatorSyncServerImpl());\n        serverTransport = new TNonblockingServerSocket(THRIFT_TEST_PORT);\n        server = new THsHaServer(new Args(serverTransport).processor(processor));\n        Runnable simple = new Runnable() {\n            public void run() {"}
{"magic_number_smell": "        TSSLTransportFactory.TSSLTransportParameters sslParams = new TSSLTransportFactory.TSSLTransportParameters();\n\n        sslParams.setKeyStore(KEY_STORE_SOURCE, SECURITY_STORE_PASSWORD);\n        serverTransport = TSSLTransportFactory.getServerSocket(AvailablePortFinder.getNextAvailable(), THRIFT_CLIENT_TIMEOUT,\n                InetAddress.getByName(\"localhost\"), sslParams);\n        TThreadPoolServer.Args args = new TThreadPoolServer.Args(serverTransport);\n        args.processor(processor);", "refactored_code": "    private static final int THRIFT_TEST_PORT = AvailablePortFinder.getNextAvailable();\n        TSSLTransportFactory.TSSLTransportParameters sslParams = new TSSLTransportFactory.TSSLTransportParameters();\n\n        sslParams.setKeyStore(KEY_STORE_SOURCE, SECURITY_STORE_PASSWORD);\n        serverTransport = TSSLTransportFactory.getServerSocket(THRIFT_TEST_PORT, THRIFT_CLIENT_TIMEOUT,\n                InetAddress.getByName(\"localhost\"), sslParams);\n        TThreadPoolServer.Args args = new TThreadPoolServer.Args(serverTransport);\n        args.processor(processor);"}
{"magic_number_smell": "        processor = new Calculator.Processor(new CalculatorSyncServerImpl());\n\n        serverTransport = new TServerSocket(\n                new InetSocketAddress(InetAddress.getByName(\"localhost\"), AvailablePortFinder.getNextAvailable()), THRIFT_CLIENT_TIMEOUT);\n        TThreadPoolServer.Args args = new TThreadPoolServer.Args(serverTransport);\n        args.processor(processor);\n        args.protocolFactory(new TBinaryProtocol.Factory());", "refactored_code": "    private static final int THRIFT_TEST_PORT = AvailablePortFinder.getNextAvailable();\n        processor = new Calculator.Processor(new CalculatorSyncServerImpl());\n\n        serverTransport = new TServerSocket(\n                new InetSocketAddress(InetAddress.getByName(\"localhost\"), THRIFT_TEST_PORT), THRIFT_CLIENT_TIMEOUT);\n        TThreadPoolServer.Args args = new TThreadPoolServer.Args(serverTransport);\n        args.processor(processor);\n        args.protocolFactory(new TBinaryProtocol.Factory());"}
{"magic_number_smell": "        }\n\n        public void unsetNum1() {\n            __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n        }\n\n        /** Returns true if field num1 is set (has been assigned a value) and false otherwise */", "refactored_code": "        private static final int __NUM1_ISSET_ID = 0;\n        }\n\n        public void unsetNum1() {\n            __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __NUM1_ISSET_ID);\n        }\n\n        /** Returns true if field num1 is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "    }\n\n    public void unsetWhatOp() {\n        __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n    }\n\n    /** Returns true if field whatOp is set (has been assigned a value) and false otherwise */", "refactored_code": "    private static final int __WHATOP_ISSET_ID = 0;\n    }\n\n    public void unsetWhatOp() {\n        __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __WHATOP_ISSET_ID);\n    }\n\n    /** Returns true if field whatOp is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "    }\n\n    public void unsetNum1() {\n        __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n    }\n\n    /** Returns true if field num1 is set (has been assigned a value) and false otherwise */", "refactored_code": "    private static final int __NUM1_ISSET_ID = 0;\n    }\n\n    public void unsetNum1() {\n        __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __NUM1_ISSET_ID);\n    }\n\n    /** Returns true if field num1 is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "        TSSLTransportFactory.TSSLTransportParameters sslParams = new TSSLTransportFactory.TSSLTransportParameters();\n\n        sslParams.setKeyStore(KEY_STORE_PATH, SECURITY_STORE_PASSWORD);\n        serverTransport = TSSLTransportFactory.getServerSocket(AvailablePortFinder.getNextAvailable(), THRIFT_CLIENT_TIMEOUT,\n                InetAddress.getByName(\"localhost\"), sslParams);\n        ThriftThreadPoolServer.Args args = new ThriftThreadPoolServer.Args(serverTransport);\n", "refactored_code": "    private static final int THRIFT_TEST_PORT = AvailablePortFinder.getNextAvailable();\n        TSSLTransportFactory.TSSLTransportParameters sslParams = new TSSLTransportFactory.TSSLTransportParameters();\n\n        sslParams.setKeyStore(KEY_STORE_PATH, SECURITY_STORE_PASSWORD);\n        serverTransport = TSSLTransportFactory.getServerSocket(THRIFT_TEST_PORT, THRIFT_CLIENT_TIMEOUT,\n                InetAddress.getByName(\"localhost\"), sslParams);\n        ThriftThreadPoolServer.Args args = new ThriftThreadPoolServer.Args(serverTransport);\n"}
{"magic_number_smell": "        MockEndpoint mock = getMockEndpoint(\"mock:reverse-sjson\");\n        mock.expectedMessageCount(1);\n\n        input.num1 = 1;\n        input.num2 = WORK_TEST_NUM2;\n        input.op = WORK_TEST_OPERATION;\n        input.comment = WORK_TEST_COMMENT;", "refactored_code": "    private static final int WORK_TEST_NUM1 = 1;\n        MockEndpoint mock = getMockEndpoint(\"mock:reverse-sjson\");\n        mock.expectedMessageCount(1);\n\n        input.num1 = WORK_TEST_NUM1;\n        input.num2 = WORK_TEST_NUM2;\n        input.op = WORK_TEST_OPERATION;\n        input.comment = WORK_TEST_COMMENT;"}
{"magic_number_smell": "    private void marshalAndUnmarshal(String inURI, String outURI) throws Exception {\n        Work input = new Work();\n\n        input.num1 = 1;\n        input.num2 = WORK_TEST_NUM2;\n        input.op = WORK_TEST_OPERATION;\n        input.comment = WORK_TEST_COMMENT;", "refactored_code": "    private static final int WORK_TEST_NUM1 = 1;\n    private void marshalAndUnmarshal(String inURI, String outURI) throws Exception {\n        Work input = new Work();\n\n        input.num1 = WORK_TEST_NUM1;\n        input.num2 = WORK_TEST_NUM2;\n        input.op = WORK_TEST_OPERATION;\n        input.comment = WORK_TEST_COMMENT;"}
{"magic_number_smell": "    private void marshalAndUnmarshal(String inURI, String outURI) throws Exception {\n        Work input = new Work();\n\n        input.num1 = 1;\n        input.num2 = WORK_TEST_NUM2;\n        input.op = WORK_TEST_OPERATION;\n        input.comment = WORK_TEST_COMMENT;", "refactored_code": "    private static final int WORK_TEST_NUM1 = 1;\n    private void marshalAndUnmarshal(String inURI, String outURI) throws Exception {\n        Work input = new Work();\n\n        input.num1 = WORK_TEST_NUM1;\n        input.num2 = WORK_TEST_NUM2;\n        input.op = WORK_TEST_OPERATION;\n        input.comment = WORK_TEST_COMMENT;"}
{"magic_number_smell": "    }\n\n    public void unsetNum1() {\n        __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n    }\n\n    /** Returns true if field num1 is set (has been assigned a value) and false otherwise */", "refactored_code": "    private static final int __NUM1_ISSET_ID = 0;\n    }\n\n    public void unsetNum1() {\n        __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __NUM1_ISSET_ID);\n    }\n\n    /** Returns true if field num1 is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "\n    public static final long 30 * 1000L = 30 * 1000L;\n\n    @UriParam(defaultValue = \"\" + 30 * 1000L, javaType = \"java.time.Duration\", label = \"consumer,scheduler\",\n              description = \"Milliseconds before the next poll.\")\n    private long delay = 30 * 1000L;\n", "refactored_code": "    public static final long DEFAULT_CONSUMER_DELAY = 30 * 1000L;\n\n    public static final long DEFAULT_CONSUMER_DELAY = 30 * 1000L;\n\n    @UriParam(defaultValue = \"\" + DEFAULT_CONSUMER_DELAY, javaType = \"java.time.Duration\", label = \"consumer,scheduler\",\n              description = \"Milliseconds before the next poll.\")\n    private long delay = DEFAULT_CONSUMER_DELAY;\n"}
{"magic_number_smell": "    public DefaultTwitterConsumer(AbstractTwitterEndpoint endpoint, Processor processor,\n                                  AbstractTwitterConsumerHandler handler) {\n        super(endpoint, processor);\n        setDelay(30 * 1000L);\n        this.endpoint = endpoint;\n        this.handler = handler;\n    }", "refactored_code": "    public static final long DEFAULT_CONSUMER_DELAY = 30 * 1000L;\n    public DefaultTwitterConsumer(AbstractTwitterEndpoint endpoint, Processor processor,\n                                  AbstractTwitterConsumerHandler handler) {\n        super(endpoint, processor);\n        setDelay(DEFAULT_CONSUMER_DELAY);\n        this.endpoint = endpoint;\n        this.handler = handler;\n    }"}
{"magic_number_smell": "\n    @Test\n    public void testTwoWayStreaming() throws Exception {\n        long expectedLength = LINE.length() * 1000;\n        MockEndpoint mock = getMockEndpoint(\"mock:length\");\n        mock.expectedMessageCount(1);\n        mock.expectedBodiesReceived(expectedLength);", "refactored_code": "    private static final long COUNT = 1000; // approx. 1MB\n\n    @Test\n    public void testTwoWayStreaming() throws Exception {\n        long expectedLength = LINE.length() * COUNT;\n        MockEndpoint mock = getMockEndpoint(\"mock:length\");\n        mock.expectedMessageCount(1);\n        mock.expectedBodiesReceived(expectedLength);"}
{"magic_number_smell": "                        .name(\"myService\")\n                        .component(\"undertow\")\n                        .staticServiceDiscovery()\n                        .servers(\"myService@localhost:\" + AvailablePortFinder.getNextAvailable())\n                        .servers(\"myService@localhost:\" + port2)\n                        .endParent();\n", "refactored_code": "    private final int port1 = AvailablePortFinder.getNextAvailable();\n                        .name(\"myService\")\n                        .component(\"undertow\")\n                        .staticServiceDiscovery()\n                        .servers(\"myService@localhost:\" + port1)\n                        .servers(\"myService@localhost:\" + port2)\n                        .endParent();\n"}
{"magic_number_smell": "    @Test\n    public void testProxyConfiguration() {\n        String result = template.requestBody(getProducerUri() + \"?proxyHost=localhost&proxyPort=\"\n                                             + AvailablePortFinder.getNextAvailable() + \"&proxyUsername=foo\"\n                                             + \"&proxyPassword=bar&proxyType=HTTP\",\n                null, String.class);\n        assertEquals(\"Hello Proxied World\", result);", "refactored_code": "    private final int port2 = AvailablePortFinder.getNextAvailable();\n    @Test\n    public void testProxyConfiguration() {\n        String result = template.requestBody(getProducerUri() + \"?proxyHost=localhost&proxyPort=\"\n                                             + port2 + \"&proxyUsername=foo\"\n                                             + \"&proxyPassword=bar&proxyType=HTTP\",\n                null, String.class);\n        assertEquals(\"Hello Proxied World\", result);"}
{"magic_number_smell": "    protected final int AvailablePortFinder.getNextAvailable() = AvailablePortFinder.getNextAvailable();\n\n    protected String getTestServerUrl() {\n        return String.format(\"http://localhost:%d\", AvailablePortFinder.getNextAvailable());\n    }\n\n    protected String getTestServerUri() {", "refactored_code": "    protected final int port = AvailablePortFinder.getNextAvailable();\n    protected final int port = AvailablePortFinder.getNextAvailable();\n\n    protected String getTestServerUrl() {\n        return String.format(\"http://localhost:%d\", port);\n    }\n\n    protected String getTestServerUri() {"}
{"magic_number_smell": "    @Test\n    public void testHttpClientOptions() {\n        VertxWebsocketEndpoint endpoint = context\n                .getEndpoint(\"vertx-websocket:localhost:\" + AvailablePortFinder.getNextAvailable() + \"/options/client?clientOptions=#clientOptions\",\n                        VertxWebsocketEndpoint.class);\n\n        assertSame(clientOptions, endpoint.getConfiguration().getClientOptions());", "refactored_code": "    private static final int PORT = AvailablePortFinder.getNextAvailable();\n    @Test\n    public void testHttpClientOptions() {\n        VertxWebsocketEndpoint endpoint = context\n                .getEndpoint(\"vertx-websocket:localhost:\" + PORT + \"/options/client?clientOptions=#clientOptions\",\n                        VertxWebsocketEndpoint.class);\n\n        assertSame(clientOptions, endpoint.getConfiguration().getClientOptions());"}
{"magic_number_smell": "    @Test\n    public void testInvalidOrigin() {\n        CamelExecutionException e = assertThrows(CamelExecutionException.class, () -> {\n            template.sendBody(\"vertx-websocket:localhost:\" + AvailablePortFinder.getNextAvailable() + \"/test\", \"world\");\n        });\n\n        UpgradeRejectedException upgradeRejectedException = unwrapException(e);", "refactored_code": "    private static final int PORT2 = AvailablePortFinder.getNextAvailable();\n    @Test\n    public void testInvalidOrigin() {\n        CamelExecutionException e = assertThrows(CamelExecutionException.class, () -> {\n            template.sendBody(\"vertx-websocket:localhost:\" + PORT2 + \"/test\", \"world\");\n        });\n\n        UpgradeRejectedException upgradeRejectedException = unwrapException(e);"}
{"magic_number_smell": "    protected final int port2 = AvailablePortFinder.getNextAvailable();\n\n    /**\n     * Returns the randomized AvailablePortFinder.getNextAvailable() used for the Vert.x server if no AvailablePortFinder.getNextAvailable() was provided to the consumer.\n     */\n    public int getVertxServerRandomPort() {\n        VertxWebsocketComponent component = context.getComponent(\"vertx-websocket\", VertxWebsocketComponent.class);", "refactored_code": "    protected final int port = AvailablePortFinder.getNextAvailable();\n    protected final int port2 = AvailablePortFinder.getNextAvailable();\n\n    /**\n     * Returns the randomized port used for the Vert.x server if no port was provided to the consumer.\n     */\n    public int getVertxServerRandomPort() {\n        VertxWebsocketComponent component = context.getComponent(\"vertx-websocket\", VertxWebsocketComponent.class);"}
{"magic_number_smell": "    static {\n        WA_DEFAULT_V1 = new Header(FORMAT_NAME, CURRENT_FILE_VERSION);\n\n        BYTES = 8 + Integer.BYTES;\n    }\n\n    Header(final String formatName, int fileVersion) {", "refactored_code": "    public static final int FORMAT_NAME_SIZE = 8;\n    static {\n        WA_DEFAULT_V1 = new Header(FORMAT_NAME, CURRENT_FILE_VERSION);\n\n        BYTES = FORMAT_NAME_SIZE + Integer.BYTES;\n    }\n\n    Header(final String formatName, int fileVersion) {"}
{"magic_number_smell": "     * @throws IOException in case of I/O errors\n     */\n    public LogReader(final File logFile) throws IOException {\n        this(logFile, 1024 * 512);\n    }\n\n    /**", "refactored_code": "    public static final int DEFAULT_CAPACITY = 1024 * 512;\n     * @throws IOException in case of I/O errors\n     */\n    public LogReader(final File logFile) throws IOException {\n        this(logFile, DEFAULT_CAPACITY);\n    }\n\n    /**"}
{"magic_number_smell": "    private long startOfRecords;\n\n    /**\n     * Constructs a new log writer with the default capacity {@link LogWriter#1024 * 512} (512 KiB). If the file\n     * already exists, it will be truncated.\n     *\n     * @param  logFile       the transaction log file", "refactored_code": "    public static final int DEFAULT_CAPACITY = 1024 * 512;\n    private long startOfRecords;\n\n    /**\n     * Constructs a new log writer with the default capacity {@link LogWriter#DEFAULT_CAPACITY} (512 KiB). If the file\n     * already exists, it will be truncated.\n     *\n     * @param  logFile       the transaction log file"}
{"magic_number_smell": "\n    protected List<Instant> generateDataFilePredictable(Consumer<EntryInfo.CachedEntryInfo> offsetConsumer, LogWriter logWriter)\n            throws IOException {\n        return generateDataFilePredictable(offsetConsumer, logWriter, TimeUnit.HOURS.toSeconds(1));\n    }\n\n    protected List<Instant> generateDataFilePredictable(Consumer<EntryInfo.CachedEntryInfo> offsetConsumer) throws IOException {", "refactored_code": "    protected static final long RECORD_COUNT = TimeUnit.HOURS.toSeconds(1);\n\n    protected List<Instant> generateDataFilePredictable(Consumer<EntryInfo.CachedEntryInfo> offsetConsumer, LogWriter logWriter)\n            throws IOException {\n        return generateDataFilePredictable(offsetConsumer, logWriter, RECORD_COUNT);\n    }\n\n    protected List<Instant> generateDataFilePredictable(Consumer<EntryInfo.CachedEntryInfo> offsetConsumer) throws IOException {"}
{"magic_number_smell": "        int i = 0;\n        while (true) {\n            try {\n                localServer = createServer(9009 + i);\n                localServer.start();\n                break;\n            } catch (BindException ex) {", "refactored_code": "    private static final int PORT = 9009;\n        int i = 0;\n        while (true) {\n            try {\n                localServer = createServer(PORT + i);\n                localServer.start();\n                break;\n            } catch (BindException ex) {"}
{"magic_number_smell": "    @Override\n    public ExtensionFunctionCall makeCallExpression() {\n        return new ExtensionFunctionCall() {\n            private static final long 1L = 1L;\n\n            @Override\n            public Sequence call(XPathContext xPathContext, Sequence[] arguments) throws XPathException {", "refactored_code": "    private static final long serialVersionUID = 1L;\n    @Override\n    public ExtensionFunctionCall makeCallExpression() {\n        return new ExtensionFunctionCall() {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            public Sequence call(XPathContext xPathContext, Sequence[] arguments) throws XPathException {"}
{"magic_number_smell": "    @Override\n    public ExtensionFunctionCall makeCallExpression() {\n        return new ExtensionFunctionCall() {\n            private static final long 1L = 1L;\n\n            @Override\n            public Sequence call(XPathContext xPathContext, Sequence[] arguments) throws XPathException {", "refactored_code": "    private static final long serialVersionUID = 1L;\n    @Override\n    public ExtensionFunctionCall makeCallExpression() {\n        return new ExtensionFunctionCall() {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            public Sequence call(XPathContext xPathContext, Sequence[] arguments) throws XPathException {"}
{"magic_number_smell": "    private boolean usingIterator;\n    private boolean allowEmptyDirectory;\n    private boolean preservePathElements;\n    private long maxDecompressedSize = 1073741824;\n\n    @Override\n    public String getDataFormatName() {", "refactored_code": "    private static final long DEFAULT_MAXIMUM_DECOMPRESSED_SIZE = 1073741824;\n    private boolean usingIterator;\n    private boolean allowEmptyDirectory;\n    private boolean preservePathElements;\n    private long maxDecompressedSize = DEFAULT_MAXIMUM_DECOMPRESSED_SIZE;\n\n    @Override\n    public String getDataFormatName() {"}
{"magic_number_smell": "                }\n            }\n\n            assertEquals(AggregationStrategyWithPreservationTest.5, fileCount,\n                    String.format(\"Zip file should contains %d files, got %d files\",\n                            AggregationStrategyWithPreservationTest.5, fileCount));\n            assertEquals(0, expectedZipFiles.size(),", "refactored_code": "    private static final int EXPECTED_NO_FILES = 5;\n                }\n            }\n\n            assertEquals(AggregationStrategyWithPreservationTest.EXPECTED_NO_FILES, fileCount,\n                    String.format(\"Zip file should contains %d files, got %d files\",\n                            AggregationStrategyWithPreservationTest.EXPECTED_NO_FILES, fileCount));\n            assertEquals(0, expectedZipFiles.size(),"}
{"magic_number_smell": "            for (ZipEntry ze = zin.getNextEntry(); ze != null; ze = zin.getNextEntry()) {\n                fileCount++;\n            }\n            assertEquals(ZipAggregationStrategyEmptyFileTest.3, fileCount,\n                    \"Zip file should contains \" + ZipAggregationStrategyEmptyFileTest.3 + \" files\");\n        } finally {\n            IOHelper.close(zin);", "refactored_code": "    private static final int EXPECTED_NO_FILES = 3;\n            for (ZipEntry ze = zin.getNextEntry(); ze != null; ze = zin.getNextEntry()) {\n                fileCount++;\n            }\n            assertEquals(ZipAggregationStrategyEmptyFileTest.EXPECTED_NO_FILES, fileCount,\n                    \"Zip file should contains \" + ZipAggregationStrategyEmptyFileTest.EXPECTED_NO_FILES + \" files\");\n        } finally {\n            IOHelper.close(zin);"}
{"magic_number_smell": "            for (ZipEntry ze = zin.getNextEntry(); ze != null; ze = zin.getNextEntry()) {\n                fileCount++;\n            }\n            assertEquals(ZipAggregationStrategySplitTest.3, fileCount,\n                    \"Zip file should contains \" + ZipAggregationStrategySplitTest.3 + \" files\");\n        } finally {\n            IOHelper.close(zin);", "refactored_code": "    private static final int EXPECTED_NO_FILES = 3;\n            for (ZipEntry ze = zin.getNextEntry(); ze != null; ze = zin.getNextEntry()) {\n                fileCount++;\n            }\n            assertEquals(ZipAggregationStrategySplitTest.EXPECTED_NO_FILES, fileCount,\n                    \"Zip file should contains \" + ZipAggregationStrategySplitTest.EXPECTED_NO_FILES + \" files\");\n        } finally {\n            IOHelper.close(zin);"}
{"magic_number_smell": "            for (ZipEntry ze = zin.getNextEntry(); ze != null; ze = zin.getNextEntry()) {\n                fileCount++;\n            }\n            assertEquals(ZipAggregationStrategyTest.3, fileCount,\n                    \"Zip file should contains \" + ZipAggregationStrategyTest.3 + \" files\");\n        } finally {\n            IOHelper.close(zin);", "refactored_code": "    private static final int EXPECTED_NO_FILES = 3;\n            for (ZipEntry ze = zin.getNextEntry(); ze != null; ze = zin.getNextEntry()) {\n                fileCount++;\n            }\n            assertEquals(ZipAggregationStrategyTest.EXPECTED_NO_FILES, fileCount,\n                    \"Zip file should contains \" + ZipAggregationStrategyTest.EXPECTED_NO_FILES + \" files\");\n        } finally {\n            IOHelper.close(zin);"}
{"magic_number_smell": "\n    private CharSequence getZooKeeperSequenceNumber(CharSequence sequencedNodeName) {\n        int len = sequencedNodeName.length();\n        return sequencedNodeName.subSequence(len - 10, len);\n    }\n}\n", "refactored_code": "    public static final int ZOOKEEPER_SEQUENCE_LENGTH = 10;\n\n    private CharSequence getZooKeeperSequenceNumber(CharSequence sequencedNodeName) {\n        int len = sequencedNodeName.length();\n        return sequencedNodeName.subSequence(len - ZOOKEEPER_SEQUENCE_LENGTH, len);\n    }\n}\n"}
{"magic_number_smell": "        curator.start();\n        discovery.start();\n\n        instances = new ArrayList<>(5);\n        expectedBodies = new ArrayList<>(5);\n\n        for (int i = 0; i < 5; i++) {", "refactored_code": "    private static final int SERVICE_COUNT = 5;\n        curator.start();\n        discovery.start();\n\n        instances = new ArrayList<>(SERVICE_COUNT);\n        expectedBodies = new ArrayList<>(SERVICE_COUNT);\n\n        for (int i = 0; i < SERVICE_COUNT; i++) {"}
{"magic_number_smell": "        Collection<ServiceInstance<MetaData>> services = discovery.queryForInstances(SERVICE_NAME);\n\n        ServiceInstance<MetaData> instance = services.iterator().next();\n        assertEquals(AvailablePortFinder.getNextRandomAvailable(), (int) instance.getPort());\n        assertEquals(\"localhost\", instance.getAddress());\n        assertEquals(\"http\", instance.getPayload().get(ServiceDefinition.SERVICE_META_PROTOCOL));\n        assertEquals(\"/service/endpoint\", instance.getPayload().get(ServiceDefinition.SERVICE_META_PATH));", "refactored_code": "    protected static final int SERVICE_PORT = AvailablePortFinder.getNextRandomAvailable();\n        Collection<ServiceInstance<MetaData>> services = discovery.queryForInstances(SERVICE_NAME);\n\n        ServiceInstance<MetaData> instance = services.iterator().next();\n        assertEquals(SERVICE_PORT, (int) instance.getPort());\n        assertEquals(\"localhost\", instance.getAddress());\n        assertEquals(\"http\", instance.getPayload().get(ServiceDefinition.SERVICE_META_PROTOCOL));\n        assertEquals(\"/service/endpoint\", instance.getPayload().get(ServiceDefinition.SERVICE_META_PATH));"}
{"magic_number_smell": "    protected static final byte FAILED = 12;\n\n    protected final Object lock = new Object();\n    protected volatile byte status = 0;\n\n    public void build() {\n        if (status == 0) {", "refactored_code": "    protected static final byte NEW = 0;\n    protected static final byte FAILED = 12;\n\n    protected final Object lock = new Object();\n    protected volatile byte status = NEW;\n\n    public void build() {\n        if (status == NEW) {"}
{"magic_number_smell": "     *\n     * OS environment variable mode is checked before JVM system property mode.\n     *\n     * @see #0\n     * @see #SYSTEM_PROPERTIES_MODE_FALLBACK\n     * @see #SYSTEM_PROPERTIES_MODE_OVERRIDE\n     */", "refactored_code": "    public static final int SYSTEM_PROPERTIES_MODE_NEVER = 0;\n     *\n     * OS environment variable mode is checked before JVM system property mode.\n     *\n     * @see #SYSTEM_PROPERTIES_MODE_NEVER\n     * @see #SYSTEM_PROPERTIES_MODE_FALLBACK\n     * @see #SYSTEM_PROPERTIES_MODE_OVERRIDE\n     */"}
{"magic_number_smell": "    private boolean standby;\n    private final AtomicLong traceCounter = new AtomicLong();\n    // use a queue with an upper limit to avoid storing too many messages\n    private final Queue<BacklogTracerEventMessage> queue = new LinkedBlockingQueue<>(10 * 1000);\n    // how many of the last messages to keep in the backlog at total\n    private int backlogSize = 1000;\n    private boolean removeOnDump = true;", "refactored_code": "    public static final int MAX_BACKLOG_SIZE = 10 * 1000;\n    private boolean standby;\n    private final AtomicLong traceCounter = new AtomicLong();\n    // use a queue with an upper limit to avoid storing too many messages\n    private final Queue<BacklogTracerEventMessage> queue = new LinkedBlockingQueue<>(MAX_BACKLOG_SIZE);\n    // how many of the last messages to keep in the backlog at total\n    private int backlogSize = 1000;\n    private boolean removeOnDump = true;"}
{"magic_number_smell": "    private final EventNotifier debugEventNotifier = new DebugEventNotifier();\n    private final List<BreakpointConditions> breakpoints = new CopyOnWriteArrayList<>();\n    private final int 1 = 1;\n    private final Map<String, Breakpoint> singleSteps = new HashMap<>(1);\n    private CamelContext camelContext;\n\n    /**", "refactored_code": "    private final int maxConcurrentSingleSteps = 1;\n    private final EventNotifier debugEventNotifier = new DebugEventNotifier();\n    private final List<BreakpointConditions> breakpoints = new CopyOnWriteArrayList<>();\n    private final int maxConcurrentSingleSteps = 1;\n    private final Map<String, Breakpoint> singleSteps = new HashMap<>(maxConcurrentSingleSteps);\n    private CamelContext camelContext;\n\n    /**"}
{"magic_number_smell": "    public ParallelExecutionConfiguration createConfiguration(ConfigurationParameters configurationParameters) {\n        Optional<Integer> parallelism = configurationParameters.get(CONFIG_CUSTOM_PARALLELISM_PROPERTY_NAME,\n                Integer::valueOf);\n        this.nbParallelExecutions = parallelism.orElse(2);\n        Optional<Integer> poolSize = configurationParameters.get(CONFIG_CUSTOM_MAXPOOLSIZE_PROPERTY_NAME,\n                Integer::valueOf);\n        this.maxPoolSize = poolSize.orElseGet(() -> nbParallelExecutions * 256);", "refactored_code": "    private static final int DEFAULT_PARALLELISM = 2;\n    public ParallelExecutionConfiguration createConfiguration(ConfigurationParameters configurationParameters) {\n        Optional<Integer> parallelism = configurationParameters.get(CONFIG_CUSTOM_PARALLELISM_PROPERTY_NAME,\n                Integer::valueOf);\n        this.nbParallelExecutions = parallelism.orElse(DEFAULT_PARALLELISM);\n        Optional<Integer> poolSize = configurationParameters.get(CONFIG_CUSTOM_MAXPOOLSIZE_PROPERTY_NAME,\n                Integer::valueOf);\n        this.maxPoolSize = poolSize.orElseGet(() -> nbParallelExecutions * 256);"}
{"magic_number_smell": "    }\n\n    public static class MyBusinessException extends MyBaseBusinessException {\n        private static final long 1L = 1L;\n    }\n\n    @Override", "refactored_code": "        private static final long serialVersionUID = 1L;\n    }\n\n    public static class MyBusinessException extends MyBaseBusinessException {\n        private static final long serialVersionUID = 1L;\n    }\n\n    @Override"}
{"magic_number_smell": "    public void testBeanPerformance() throws Exception {\n        StopWatch watch = new StopWatch();\n\n        log.info(\"Invoking a bean in a route {} 100000\", 100000);\n        for (int i = 0; i < 100000; i++) {\n            template.sendBody(\"direct:start\", \"Hello World\");\n        }", "refactored_code": "    private final int times = 100000;\n    public void testBeanPerformance() throws Exception {\n        StopWatch watch = new StopWatch();\n\n        log.info(\"Invoking a bean in a route {} times\", times);\n        for (int i = 0; i < times; i++) {\n            template.sendBody(\"direct:start\", \"Hello World\");\n        }"}
{"magic_number_smell": "    public void testProcessor() throws Exception {\n        StopWatch watch = new StopWatch();\n\n        for (int i = 0; i < 100000; i++) {\n            Object out = template.requestBody(\"direct:a\", \"\" + i);\n            assertEquals(\"Bye \" + i, out);\n        }", "refactored_code": "    private final int size = 100000;\n    public void testProcessor() throws Exception {\n        StopWatch watch = new StopWatch();\n\n        for (int i = 0; i < size; i++) {\n            Object out = template.requestBody(\"direct:a\", \"\" + i);\n            assertEquals(\"Bye \" + i, out);\n        }"}
{"magic_number_smell": "        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                String[] destinations = new String[10];\n                for (int i = 0; i < 10; i++) {\n                    destinations[i] = \"direct:file\" + i;\n", "refactored_code": "    private final int numFiles = 10;\n        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                String[] destinations = new String[numFiles];\n                for (int i = 0; i < numFiles; i++) {\n                    destinations[i] = \"direct:file\" + i;\n"}
{"magic_number_smell": "    void setUpData() {\n        // create file with many lines\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 100; i++) {\n            sb.append(\"Line \").append(i).append(LS);\n        }\n", "refactored_code": "    private final int size = 100;\n    void setUpData() {\n        // create file with many lines\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < size; i++) {\n            sb.append(\"Line \").append(i).append(LS);\n        }\n"}
{"magic_number_smell": "    public void testConcurrentAppend() throws Exception {\n        // create file with many lines\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 3; i++) {\n            sb.append(\"Block1 Line \").append(i).append(LS);\n        }\n        sb.append(comma);", "refactored_code": "    private final int size = 3;\n    public void testConcurrentAppend() throws Exception {\n        // create file with many lines\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < size; i++) {\n            sb.append(\"Block1 Line \").append(i).append(LS);\n        }\n        sb.append(comma);"}
{"magic_number_smell": "                                numberOfFilesProcessed.addAndGet(1);\n                                latch.countDown();\n                            }\n                        }).end().threads(5).to(fileUri(\"out\"), \"mock:result\");\n            }\n        };\n    }", "refactored_code": "    private static final int NUMBER_OF_THREADS = 5;\n                                numberOfFilesProcessed.addAndGet(1);\n                                latch.countDown();\n                            }\n                        }).end().threads(NUMBER_OF_THREADS).to(fileUri(\"out\"), \"mock:result\");\n            }\n        };\n    }"}
{"magic_number_smell": "        super.setUp();\n\n        // create files\n        for (int i = 0; i < 200; i++) {\n            template.sendBodyAndHeader(fileUri(), \"Message \" + i, Exchange.FILE_NAME, \"file-\" + i + \".txt\");\n        }\n    }", "refactored_code": "    private static final int FILES = 200;\n        super.setUp();\n\n        // create files\n        for (int i = 0; i < FILES; i++) {\n            template.sendBodyAndHeader(fileUri(), \"Message \" + i, Exchange.FILE_NAME, \"file-\" + i + \".txt\");\n        }\n    }"}
{"magic_number_smell": "    private static final String MOCK_URI = \"mock:blockWhenFullOutput\";\n    private static final String SIZE_PARAM = \"?size=%d\";\n    private static final String SEDA_WITH_OFFER_TIMEOUT_URI\n            = \"seda:blockingFoo\" + String.format(SIZE_PARAM, 1) + \"&blockWhenFull=true&offerTimeout=200\";\n    private static final String BLOCK_WHEN_FULL_URI\n            = \"seda:blockingBar\" + String.format(SIZE_PARAM, 1) + \"&blockWhenFull=true&timeout=0&offerTimeout=1000\";\n    private static final String DEFAULT_URI = \"seda:foo\" + String.format(SIZE_PARAM, 1);", "refactored_code": "    private static final int QUEUE_SIZE = 1;\n    private static final String MOCK_URI = \"mock:blockWhenFullOutput\";\n    private static final String SIZE_PARAM = \"?size=%d\";\n    private static final String SEDA_WITH_OFFER_TIMEOUT_URI\n            = \"seda:blockingFoo\" + String.format(SIZE_PARAM, QUEUE_SIZE) + \"&blockWhenFull=true&offerTimeout=200\";\n    private static final String BLOCK_WHEN_FULL_URI\n            = \"seda:blockingBar\" + String.format(SIZE_PARAM, QUEUE_SIZE) + \"&blockWhenFull=true&timeout=0&offerTimeout=1000\";\n    private static final String DEFAULT_URI = \"seda:foo\" + String.format(SIZE_PARAM, QUEUE_SIZE);"}
{"magic_number_smell": "    private static final int DELAY_LONG = 1000;\n    private static final String MOCK_URI = \"mock:blockWhenFullOutput\";\n    private static final String SIZE_PARAM = \"?size=%d\";\n    private static final String BLOCK_WHEN_FULL_URI = \"seda:blockingFoo\" + String.format(SIZE_PARAM, 1) + \"&timeout=0\";\n    private static final String DEFAULT_URI\n            = \"seda:foo\" + String.format(SIZE_PARAM, 1) + \"&blockWhenFull=false&timeout=0\";\n", "refactored_code": "    private static final int QUEUE_SIZE = 1;\n    private static final int DELAY_LONG = 1000;\n    private static final String MOCK_URI = \"mock:blockWhenFullOutput\";\n    private static final String SIZE_PARAM = \"?size=%d\";\n    private static final String BLOCK_WHEN_FULL_URI = \"seda:blockingFoo\" + String.format(SIZE_PARAM, QUEUE_SIZE) + \"&timeout=0\";\n    private static final String DEFAULT_URI\n            = \"seda:foo\" + String.format(SIZE_PARAM, QUEUE_SIZE) + \"&blockWhenFull=false&timeout=0\";\n"}
{"magic_number_smell": "\n    private static class SecondException extends Exception {\n\n        private static final long 1L = 1L;\n    }\n\n    private static class ExceptionThrowingProcessor implements Processor {", "refactored_code": "        private static final long serialVersionUID = 1L;\n\n    private static class SecondException extends Exception {\n\n        private static final long serialVersionUID = 1L;\n    }\n\n    private static class ExceptionThrowingProcessor implements Processor {"}
{"magic_number_smell": "    public void testThreadProcessor() throws Exception {\n        CamelContext context = new DefaultCamelContext();\n\n        final CountDownLatch latch = new CountDownLatch(50000);\n\n        context.addRoutes(new RouteBuilder() {\n", "refactored_code": "    private static final int ITERS = 50000;\n    public void testThreadProcessor() throws Exception {\n        CamelContext context = new DefaultCamelContext();\n\n        final CountDownLatch latch = new CountDownLatch(ITERS);\n\n        context.addRoutes(new RouteBuilder() {\n"}
{"magic_number_smell": "    }\n\n    public static class MyAnotherException extends Exception {\n        private static final long 1L = 1L;\n    }\n\n    public static class MyExceptionProcessor implements Processor {", "refactored_code": "        private static final long serialVersionUID = 1L;\n    }\n\n    public static class MyAnotherException extends Exception {\n        private static final long serialVersionUID = 1L;\n    }\n\n    public static class MyExceptionProcessor implements Processor {"}
{"magic_number_smell": "        context.stop();\n\n        int received = mock.getReceivedCounter();\n        assertThat(received, is(lessThan(100)));\n    }\n\n    @Override", "refactored_code": "    private static final int LOOP_COUNT = 100;\n        context.stop();\n\n        int received = mock.getReceivedCounter();\n        assertThat(received, is(lessThan(LOOP_COUNT)));\n    }\n\n    @Override"}
{"magic_number_smell": "    @Test\n    void testLoopNoBreakOnShutdown() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedMinimumMessageCount(100);\n\n        CompletableFuture<Object> future = template.asyncSendBody(\"seda:foo\", \"foo\");\n        await().atMost(1, SECONDS).until(future::isDone);", "refactored_code": "    private static final int LOOP_COUNT = 100;\n    @Test\n    void testLoopNoBreakOnShutdown() throws Exception {\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedMinimumMessageCount(LOOP_COUNT);\n\n        CompletableFuture<Object> future = template.asyncSendBody(\"seda:foo\", \"foo\");\n        await().atMost(1, SECONDS).until(future::isDone);"}
{"magic_number_smell": "            = SAFETY_TIMEOUT + (RandomSleepProcessor.MAX_PROCESS_TIME - RandomSleepProcessor.MIN_PROCESS_TIME);\n\n    // Resequencer capacity\n    public static final int CAPACITY = SAFETY_CAPACITY + (int) (10 * TIMEOUT / RandomSleepProcessor.MIN_PROCESS_TIME);\n\n    private static final int NUMBER_OF_MESSAGES = 10000;\n", "refactored_code": "    public static final int CONCURRENCY = 10;\n            = SAFETY_TIMEOUT + (RandomSleepProcessor.MAX_PROCESS_TIME - RandomSleepProcessor.MIN_PROCESS_TIME);\n\n    // Resequencer capacity\n    public static final int CAPACITY = SAFETY_CAPACITY + (int) (CONCURRENCY * TIMEOUT / RandomSleepProcessor.MIN_PROCESS_TIME);\n\n    private static final int NUMBER_OF_MESSAGES = 10000;\n"}
{"magic_number_smell": "    public void testAggregateConcurrentPerCorrelationKey() throws Exception {\n        ExecutorService service = Executors.newFixedThreadPool(20);\n        List<Callable<Object>> tasks = new ArrayList<>();\n        for (int i = 0; i < 200; i++) {\n            final int id = i % 5;\n            final int count = i;\n            tasks.add(new Callable<Object>() {", "refactored_code": "    private final int size = 200;\n    public void testAggregateConcurrentPerCorrelationKey() throws Exception {\n        ExecutorService service = Executors.newFixedThreadPool(20);\n        List<Callable<Object>> tasks = new ArrayList<>();\n        for (int i = 0; i < size; i++) {\n            final int id = i % 5;\n            final int count = i;\n            tasks.add(new Callable<Object>() {"}
{"magic_number_smell": "            String str = newExchange.getIn().getBody(String.class);\n\n            if (oldExchange == null) {\n                List<String> list = new ArrayList<>(1000);\n                list.add(str);\n                newExchange.getIn().setBody(list);\n                return newExchange;", "refactored_code": "        private final int batchSize = 1000;\n            String str = newExchange.getIn().getBody(String.class);\n\n            if (oldExchange == null) {\n                List<String> list = new ArrayList<>(batchSize);\n                list.add(str);\n                newExchange.getIn().setBody(list);\n                return newExchange;"}
{"magic_number_smell": "\n    @Test\n    public void testThreadNotUsedForEveryAggregatorWithCustomExecutorService() throws Exception {\n        assertTrue(aggregateThreadsCount(context.getName()) < 20,\n                \"There should not be a thread for every aggregator when using a shared thread pool\");\n\n        // sanity check to make sure were testing routes that work", "refactored_code": "    public static final int NUM_AGGREGATORS = 20;\n\n    @Test\n    public void testThreadNotUsedForEveryAggregatorWithCustomExecutorService() throws Exception {\n        assertTrue(aggregateThreadsCount(context.getName()) < NUM_AGGREGATORS,\n                \"There should not be a thread for every aggregator when using a shared thread pool\");\n\n        // sanity check to make sure were testing routes that work"}
{"magic_number_smell": "        int total = 0;\n        ExecutorService service = Executors.newFixedThreadPool(20);\n        List<Callable<Object>> tasks = new ArrayList<>();\n        for (int i = 0; i < 100; i++) {\n            final int count = i;\n            total += i;\n            tasks.add(new Callable<Object>() {", "refactored_code": "    private final int size = 100;\n        int total = 0;\n        ExecutorService service = Executors.newFixedThreadPool(20);\n        List<Callable<Object>> tasks = new ArrayList<>();\n        for (int i = 0; i < size; i++) {\n            final int count = i;\n            total += i;\n            tasks.add(new Callable<Object>() {"}
{"magic_number_smell": "    @RepeatedTest(100)\n    public void testConcurrentDynamicRouter() throws Exception {\n        final MockEndpoint mockA = getMockEndpoint(\"mock:a\");\n        mockA.expectedMessageCount(100);\n        final MockEndpoint mockB = getMockEndpoint(\"mock:b\");\n        mockB.expectedMessageCount(100);\n", "refactored_code": "    private static final int COUNT = 100;\n    @RepeatedTest(100)\n    public void testConcurrentDynamicRouter() throws Exception {\n        final MockEndpoint mockA = getMockEndpoint(\"mock:a\");\n        mockA.expectedMessageCount(COUNT);\n        final MockEndpoint mockB = getMockEndpoint(\"mock:b\");\n        mockB.expectedMessageCount(COUNT);\n"}
{"magic_number_smell": "    @RepeatedTest(100)\n    public void testConcurrentDynamicRouter() throws Exception {\n        final MockEndpoint mockA = getMockEndpoint(\"mock:a\");\n        mockA.expectedMessageCount(100);\n        final MockEndpoint mockB = getMockEndpoint(\"mock:b\");\n        mockB.expectedMessageCount(100);\n", "refactored_code": "    private static final int COUNT = 100;\n    @RepeatedTest(100)\n    public void testConcurrentDynamicRouter() throws Exception {\n        final MockEndpoint mockA = getMockEndpoint(\"mock:a\");\n        mockA.expectedMessageCount(COUNT);\n        final MockEndpoint mockB = getMockEndpoint(\"mock:b\");\n        mockB.expectedMessageCount(COUNT);\n"}
{"magic_number_smell": "    }\n\n    private static class ChildException extends ParentException {\n        private static final long 1L = 1L;\n    }\n\n    private static class ShuntErrorHandlerSupport extends ErrorHandlerSupport {", "refactored_code": "        private static final long serialVersionUID = 1L;\n    }\n\n    private static class ChildException extends ParentException {\n        private static final long serialVersionUID = 1L;\n    }\n\n    private static class ShuntErrorHandlerSupport extends ErrorHandlerSupport {"}
{"magic_number_smell": "        try {\n            MockEndpoint resultEndpoint = resolveMandatoryEndpoint(\"mock:result\", MockEndpoint.class);\n            sendMessagesWithHeaderExpression(executor, resultEndpoint, 2, MESSAGE_COUNT);\n            Thread.sleep(500); // sleep here to ensure the\n                                   // first throttle rate does not\n                                   // influence the next one.\n", "refactored_code": "    private static final int INTERVAL = 500;\n        try {\n            MockEndpoint resultEndpoint = resolveMandatoryEndpoint(\"mock:result\", MockEndpoint.class);\n            sendMessagesWithHeaderExpression(executor, resultEndpoint, 2, MESSAGE_COUNT);\n            Thread.sleep(INTERVAL); // sleep here to ensure the\n                                   // first throttle rate does not\n                                   // influence the next one.\n"}
{"magic_number_smell": "        return new RouteBuilder() {\n            public void configure() {\n                // START SNIPPET: ex\n                from(\"seda:a\").throttle(3).concurrentRequestsMode().delay(500).asyncDelayed().to(\"log:result\",\n                        \"mock:result\");\n                // END SNIPPET: ex\n", "refactored_code": "    private static final int INTERVAL = 500;\n        return new RouteBuilder() {\n            public void configure() {\n                // START SNIPPET: ex\n                from(\"seda:a\").throttle(3).concurrentRequestsMode().delay(INTERVAL).asyncDelayed().to(\"log:result\",\n                        \"mock:result\");\n                // END SNIPPET: ex\n"}
{"magic_number_smell": "        return new RouteBuilder() {\n            public void configure() {\n                from(\"direct:expressionMethod\").throttle(method(\"myBean\", \"getConcurrentMessages\")).concurrentRequestsMode()\n                        .delay(100)\n                        .to(\"log:result\", \"mock:result\");\n            }\n        };", "refactored_code": "    private static final int INTERVAL = 100;\n        return new RouteBuilder() {\n            public void configure() {\n                from(\"direct:expressionMethod\").throttle(method(\"myBean\", \"getConcurrentMessages\")).concurrentRequestsMode()\n                        .delay(INTERVAL)\n                        .to(\"log:result\", \"mock:result\");\n            }\n        };"}
{"magic_number_smell": "    @Test\n    public void testSendLotsOfMessagesSimultaneouslyButOnlyGetThroughAsConstantThrottleValue() throws Exception {\n        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(\"mock:gresult\", MockEndpoint.class);\n        sendMessagesAndAwaitDelivery(20, \"direct:ga\", resultEndpoint);\n    }\n\n    private void sendMessagesAndAwaitDelivery(", "refactored_code": "    private static final int MESSAGE_COUNT = 20;\n    @Test\n    public void testSendLotsOfMessagesSimultaneouslyButOnlyGetThroughAsConstantThrottleValue() throws Exception {\n        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(\"mock:gresult\", MockEndpoint.class);\n        sendMessagesAndAwaitDelivery(MESSAGE_COUNT, \"direct:ga\", resultEndpoint);\n    }\n\n    private void sendMessagesAndAwaitDelivery("}
{"magic_number_smell": "        return new RouteBuilder() {\n            public void configure() {\n                // START SNIPPET: ex\n                from(\"seda:a\").throttle(3).timePeriodMillis(500).asyncDelayed().to(\"log:result\", \"mock:result\");\n                // END SNIPPET: ex\n\n                from(\"direct:a\").throttle(3).timePeriodMillis(500).asyncDelayed().to(\"log:result\", \"mock:result\");", "refactored_code": "    private static final int INTERVAL = 500;\n        return new RouteBuilder() {\n            public void configure() {\n                // START SNIPPET: ex\n                from(\"seda:a\").throttle(3).timePeriodMillis(INTERVAL).asyncDelayed().to(\"log:result\", \"mock:result\");\n                // END SNIPPET: ex\n\n                from(\"direct:a\").throttle(3).timePeriodMillis(INTERVAL).asyncDelayed().to(\"log:result\", \"mock:result\");"}
{"magic_number_smell": "        resultEndpoint.assertIsSatisfied();\n\n        // now assert that they have actually been throttled\n        long minimumTime = (messageCount - 1) * 500;\n        // add a little slack\n        long delta = System.currentTimeMillis() - start + 200;\n        assertTrue(delta >= minimumTime, \"Should take at least \" + minimumTime + \"ms, was: \" + delta);", "refactored_code": "    private static final int INTERVAL = 500;\n        resultEndpoint.assertIsSatisfied();\n\n        // now assert that they have actually been throttled\n        long minimumTime = (messageCount - 1) * INTERVAL;\n        // add a little slack\n        long delta = System.currentTimeMillis() - start + 200;\n        assertTrue(delta >= minimumTime, \"Should take at least \" + minimumTime + \"ms, was: \" + delta);"}
{"magic_number_smell": "    public void testSendLotsOfMessagesSimultaneouslyButOnly3GetThrough() throws Exception {\n        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(\"mock:result\", MockEndpoint.class);\n        long elapsed = sendMessagesAndAwaitDelivery(MESSAGE_COUNT, \"direct:a\", MESSAGE_COUNT, resultEndpoint);\n        assertThrottlerTiming(elapsed, 5, 500, MESSAGE_COUNT);\n    }\n\n    @Test", "refactored_code": "    private static final int INTERVAL = 500;\n    public void testSendLotsOfMessagesSimultaneouslyButOnly3GetThrough() throws Exception {\n        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(\"mock:result\", MockEndpoint.class);\n        long elapsed = sendMessagesAndAwaitDelivery(MESSAGE_COUNT, \"direct:a\", MESSAGE_COUNT, resultEndpoint);\n        assertThrottlerTiming(elapsed, 5, INTERVAL, MESSAGE_COUNT);\n    }\n\n    @Test"}
{"magic_number_smell": "    public void testSendLotsOfMessagesSimultaneouslyButOnlyGetThroughAsConstantThrottleValue() throws Exception {\n        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(\"mock:gresult\", MockEndpoint.class);\n        long elapsed = sendMessagesAndAwaitDelivery(MESSAGE_COUNT, \"direct:ga\", MESSAGE_COUNT, resultEndpoint);\n        assertThrottlerTiming(elapsed, 5, 500, MESSAGE_COUNT);\n    }\n\n    @Test", "refactored_code": "    private static final int INTERVAL = 500;\n    public void testSendLotsOfMessagesSimultaneouslyButOnlyGetThroughAsConstantThrottleValue() throws Exception {\n        MockEndpoint resultEndpoint = resolveMandatoryEndpoint(\"mock:gresult\", MockEndpoint.class);\n        long elapsed = sendMessagesAndAwaitDelivery(MESSAGE_COUNT, \"direct:ga\", MESSAGE_COUNT, resultEndpoint);\n        assertThrottlerTiming(elapsed, 5, INTERVAL, MESSAGE_COUNT);\n    }\n\n    @Test"}
{"magic_number_smell": "        final HashMap<String, Object> properties = new HashMap<>();\n        final DefaultExchange exchange = DefaultExchange.newFromEndpoint(mock);\n        exchange.getIn().setHeader(PROPERTY_1, VALUE_1);\n        exchange.getIn().setHeader(PROPERTY_2, 2);\n        exchange.getIn().setHeader(PROPERTY_3, VALUE_3);\n        exchange.getIn().setHeader(PROPERTY_4, VALUE_4);\n        exchange.getIn().setHeader(PROPERTY_5, VALUE_5);", "refactored_code": "    private static final long VALUE_2 = 2;\n        final HashMap<String, Object> properties = new HashMap<>();\n        final DefaultExchange exchange = DefaultExchange.newFromEndpoint(mock);\n        exchange.getIn().setHeader(PROPERTY_1, VALUE_1);\n        exchange.getIn().setHeader(PROPERTY_2, VALUE_2);\n        exchange.getIn().setHeader(PROPERTY_3, VALUE_3);\n        exchange.getIn().setHeader(PROPERTY_4, VALUE_4);\n        exchange.getIn().setHeader(PROPERTY_5, VALUE_5);"}
{"magic_number_smell": "    // keep this number in sync with tokens list\n    private static final int 47 = 47;\n\n    private static final SimpleTokenType[] KNOWN_TOKENS = new SimpleTokenType[47];\n\n    // optimise to be able to quick check for start functions\n    private static final String[] FUNCTION_START = new String[] { \"${\", \"$simple{\" };", "refactored_code": "    private static final int NUMBER_OF_TOKENS = 47;\n    // keep this number in sync with tokens list\n    private static final int NUMBER_OF_TOKENS = 47;\n\n    private static final SimpleTokenType[] KNOWN_TOKENS = new SimpleTokenType[NUMBER_OF_TOKENS];\n\n    // optimise to be able to quick check for start functions\n    private static final String[] FUNCTION_START = new String[] { \"${\", \"$simple{\" };"}
{"magic_number_smell": "        public void release(final Exchange exchange) {\n            semaphore.release();\n            try {\n                ScheduledFuture<?> next = asyncExecutor.schedule(this::clean, 1000L * 10, TimeUnit.MILLISECONDS);\n                ScheduledFuture<?> prev = cleanFuture.getAndSet(next);\n                if (prev != null) {\n                    prev.cancel(false);", "refactored_code": "    private static final long CLEAN_PERIOD = 1000L * 10;\n        public void release(final Exchange exchange) {\n            semaphore.release();\n            try {\n                ScheduledFuture<?> next = asyncExecutor.schedule(this::clean, CLEAN_PERIOD, TimeUnit.MILLISECONDS);\n                ScheduledFuture<?> prev = cleanFuture.getAndSet(next);\n                if (prev != null) {\n                    prev.cancel(false);"}
{"magic_number_smell": "\n    private String id;\n    private String routeId;\n    private long batchTimeout = 1000L;\n    private int batchSize = DEFAULT_BATCH_SIZE;\n    private int outBatchSize;\n    private boolean groupExchanges;", "refactored_code": "    public static final long DEFAULT_BATCH_TIMEOUT = 1000L;\n\n    private String id;\n    private String routeId;\n    private long batchTimeout = DEFAULT_BATCH_TIMEOUT;\n    private int batchSize = DEFAULT_BATCH_SIZE;\n    private int outBatchSize;\n    private boolean groupExchanges;"}
{"magic_number_smell": "                    ? (retryDelay << retryCounter)\n                    : (randomBackOff\n                            ? ThreadLocalRandom.current()\n                                    .nextInt((int) (maximumRetryDelay > 0 ? maximumRetryDelay : 1000L))\n                            : retryDelay);\n            if (maximumRetryDelay > 0 && sleepFor > maximumRetryDelay) {\n                sleepFor = maximumRetryDelay;", "refactored_code": "    private static final long DEFAULT_MAXIMUM_RETRY_DELAY = 1000L;\n                    ? (retryDelay << retryCounter)\n                    : (randomBackOff\n                            ? ThreadLocalRandom.current()\n                                    .nextInt((int) (maximumRetryDelay > 0 ? maximumRetryDelay : DEFAULT_MAXIMUM_RETRY_DELAY))\n                            : retryDelay);\n            if (maximumRetryDelay > 0 && sleepFor > maximumRetryDelay) {\n                sleepFor = maximumRetryDelay;"}
{"magic_number_smell": "    protected static final int Integer.MIN_VALUE = Integer.MIN_VALUE;\n    protected static final int DEFAULT_EXIT_CODE = 0;\n\n    protected final AtomicInteger exitCode = new AtomicInteger(Integer.MIN_VALUE);\n    protected MainShutdownStrategy shutdownStrategy;\n\n    protected volatile ProducerTemplate camelTemplate;", "refactored_code": "    protected static final int UNINITIALIZED_EXIT_CODE = Integer.MIN_VALUE;\n    protected static final int UNINITIALIZED_EXIT_CODE = Integer.MIN_VALUE;\n    protected static final int DEFAULT_EXIT_CODE = 0;\n\n    protected final AtomicInteger exitCode = new AtomicInteger(UNINITIALIZED_EXIT_CODE);\n    protected MainShutdownStrategy shutdownStrategy;\n\n    protected volatile ProducerTemplate camelTemplate;"}
{"magic_number_smell": "     * @param currentReading the current reading\n     */\n    public void update(int currentReading) {\n        load01 = updateLoad(currentReading, Math.exp(-1 / (60.0 * 1.0)), load01);\n        load05 = updateLoad(currentReading, EXP_5, load05);\n        load15 = updateLoad(currentReading, EXP_15, load15);\n    }", "refactored_code": "    private static final double EXP_1 = Math.exp(-1 / (60.0 * 1.0));\n     * @param currentReading the current reading\n     */\n    public void update(int currentReading) {\n        load01 = updateLoad(currentReading, EXP_1, load01);\n        load05 = updateLoad(currentReading, EXP_5, load05);\n        load15 = updateLoad(currentReading, EXP_15, load15);\n    }"}
{"magic_number_smell": "\n        Thread.sleep(100);\n\n        if (counter++ > 1000) {\n            exchange.setProperty(\"EXIT\", \"PLEASE\");\n        }\n    }", "refactored_code": "    private static final int MAX_ITERATIONS = 1000;\n\n        Thread.sleep(100);\n\n        if (counter++ > MAX_ITERATIONS) {\n            exchange.setProperty(\"EXIT\", \"PLEASE\");\n        }\n    }"}
{"magic_number_smell": "        MyNotificationListener listener = new MyNotificationListener();\n        context.getManagementStrategy().getManagementAgent().getMBeanServer().addNotificationListener(on,\n                listener, new NotificationFilter() {\n                    private static final long 1L = 1L;\n\n                    public boolean isNotificationEnabled(Notification notification) {\n                        return true;", "refactored_code": "                    private static final long serialVersionUID = 1L;\n        MyNotificationListener listener = new MyNotificationListener();\n        context.getManagementStrategy().getManagementAgent().getMBeanServer().addNotificationListener(on,\n                listener, new NotificationFilter() {\n                    private static final long serialVersionUID = 1L;\n\n                    public boolean isNotificationEnabled(Notification notification) {\n                        return true;"}
{"magic_number_smell": "        myTimer.addTimerListener(test);\n        try {\n            await().atMost(5, TimeUnit.SECONDS).untilAsserted(() -> {\n                assertTrue(test.counter >= 2);\n                assertFalse(Double.isNaN(test.load.getLoad1()));\n                assertTrue(test.load.getLoad1() > 0.0d);\n                assertTrue(test.load.getLoad1() < 2);", "refactored_code": "    private static final int SAMPLES = 2;\n        myTimer.addTimerListener(test);\n        try {\n            await().atMost(5, TimeUnit.SECONDS).untilAsserted(() -> {\n                assertTrue(test.counter >= SAMPLES);\n                assertFalse(Double.isNaN(test.load.getLoad1()));\n                assertTrue(test.load.getLoad1() > 0.0d);\n                assertTrue(test.load.getLoad1() < SAMPLES);"}
{"magic_number_smell": "        MBeanServer mbeanServer = getMBeanServer();\n\n        Set<ObjectName> set = mbeanServer.queryNames(new ObjectName(\"*:type=services,*\"), null);\n        assertEquals(16 + 1, set.size());\n    }\n\n    @Test", "refactored_code": "    private static final int SERVICES = 16;\n        MBeanServer mbeanServer = getMBeanServer();\n\n        Set<ObjectName> set = mbeanServer.queryNames(new ObjectName(\"*:type=services,*\"), null);\n        assertEquals(SERVICES + 1, set.size());\n    }\n\n    @Test"}
{"magic_number_smell": "\n        // number of services\n        Set<ObjectName> names = mbeanServer.queryNames(on, null);\n        assertEquals(16, names.size());\n\n        // number of producers\n        ObjectName onP = getCamelObjectName(TYPE_PRODUCER, \"*\");", "refactored_code": "    private static final int SERVICES = 16;\n\n        // number of services\n        Set<ObjectName> names = mbeanServer.queryNames(on, null);\n        assertEquals(SERVICES, names.size());\n\n        // number of producers\n        ObjectName onP = getCamelObjectName(TYPE_PRODUCER, \"*\");"}
{"magic_number_smell": "\n        MBeanServer mbeanServer = getMBeanServer();\n\n        // number of 16\n        ObjectName on = getCamelObjectName(TYPE_SERVICE, \"*\");\n        Set<ObjectName> names = mbeanServer.queryNames(on, null);\n        assertEquals(16, names.size());", "refactored_code": "    private static final int SERVICES = 16;\n\n        MBeanServer mbeanServer = getMBeanServer();\n\n        // number of SERVICES\n        ObjectName on = getCamelObjectName(TYPE_SERVICE, \"*\");\n        Set<ObjectName> names = mbeanServer.queryNames(on, null);\n        assertEquals(SERVICES, names.size());"}
{"magic_number_smell": "\n    private ScheduledExecutorService executorService;\n\n    private int maxRetryAttempts = 5;\n\n    private long retryDelayInMilliseconds = DEFAULT_RETRY_DELAY_IN_MILLISECONDS;\n", "refactored_code": "    public static final int DEFAULT_MAX_RETRY_ATTEMPTS = 5;\n\n    private ScheduledExecutorService executorService;\n\n    private int maxRetryAttempts = DEFAULT_MAX_RETRY_ATTEMPTS;\n\n    private long retryDelayInMilliseconds = DEFAULT_RETRY_DELAY_IN_MILLISECONDS;\n"}
{"magic_number_smell": "        long currentInitialDelay;\n        if (initialDelay < 0) {\n            // compute the default initial delay that are millis to use current time unit\n            currentInitialDelay = timeUnit.convert(1000, TimeUnit.MILLISECONDS);\n        } else {\n            currentInitialDelay = initialDelay;\n        }", "refactored_code": "    private static final int DEFAULT_INITIAL_DELAY = 1000;\n        long currentInitialDelay;\n        if (initialDelay < 0) {\n            // compute the default initial delay that are millis to use current time unit\n            currentInitialDelay = timeUnit.convert(DEFAULT_INITIAL_DELAY, TimeUnit.MILLISECONDS);\n        } else {\n            currentInitialDelay = initialDelay;\n        }"}
{"magic_number_smell": "    @UriParam(defaultValue = \"true\", label = \"consumer,scheduler\",\n              description = \"Whether the scheduler should be auto started.\")\n    private boolean startScheduler = true;\n    @UriParam(defaultValue = \"\" + 1000, label = \"consumer,scheduler\",\n              description = \"Milliseconds before the first poll starts.\")\n    private long initialDelay = -1;\n    @UriParam(defaultValue = \"\" + DEFAULT_DELAY, label = \"consumer,scheduler\",", "refactored_code": "    private static final int DEFAULT_INITIAL_DELAY = 1000;\n    @UriParam(defaultValue = \"true\", label = \"consumer,scheduler\",\n              description = \"Whether the scheduler should be auto started.\")\n    private boolean startScheduler = true;\n    @UriParam(defaultValue = \"\" + DEFAULT_INITIAL_DELAY, label = \"consumer,scheduler\",\n              description = \"Milliseconds before the first poll starts.\")\n    private long initialDelay = -1;\n    @UriParam(defaultValue = \"\" + DEFAULT_DELAY, label = \"consumer,scheduler\","}
{"magic_number_smell": "     */\n    public static int determineResponseCode(Exchange camelExchange, Object body) {\n        boolean failed = camelExchange.isFailed();\n        int defaultCode = failed ? 500 : OK;\n\n        Message message = camelExchange.getMessage();\n        Integer currentCode = message.getHeader(Exchange.HTTP_RESPONSE_CODE, Integer.class);", "refactored_code": "    private static final int INTERNAL_SERVER_ERROR = 500;\n     */\n    public static int determineResponseCode(Exchange camelExchange, Object body) {\n        boolean failed = camelExchange.isFailed();\n        int defaultCode = failed ? INTERNAL_SERVER_ERROR : OK;\n\n        Message message = camelExchange.getMessage();\n        Integer currentCode = message.getHeader(Exchange.HTTP_RESPONSE_CODE, Integer.class);"}
{"magic_number_smell": "\n    private Map<String, Object> cache;\n\n    @Metadata(description = \"Maximum elements that can be stored in-memory\", defaultValue = \"\" + 1000)\n    private int cacheSize;\n\n    public MemoryIdempotentRepository() {", "refactored_code": "    private static final int MAX_CACHE_SIZE = 1000;\n\n    private Map<String, Object> cache;\n\n    @Metadata(description = \"Maximum elements that can be stored in-memory\", defaultValue = \"\" + MAX_CACHE_SIZE)\n    private int cacheSize;\n\n    public MemoryIdempotentRepository() {"}
{"magic_number_smell": "    public static class TimeBoundedBudgetBuilder {\n        private static final long DEFAULT_MAX_DURATION = 5000;\n\n        private long initialDelay = 0;\n        private long interval = DEFAULT_INTERVAL;\n        private long maxDuration = DEFAULT_MAX_DURATION;\n", "refactored_code": "    private static final long DEFAULT_INITIAL_DELAY = 0;\n    public static class TimeBoundedBudgetBuilder {\n        private static final long DEFAULT_MAX_DURATION = 5000;\n\n        private long initialDelay = DEFAULT_INITIAL_DELAY;\n        private long interval = DEFAULT_INTERVAL;\n        private long maxDuration = DEFAULT_MAX_DURATION;\n"}
{"magic_number_smell": "    @Override\n    public boolean next() {\n        if (canContinue()) {\n            if (iterations != -1) {\n                iterations++;\n            }\n", "refactored_code": "    public static final int UNLIMITED_ITERATIONS = -1;\n    @Override\n    public boolean next() {\n        if (canContinue()) {\n            if (iterations != UNLIMITED_ITERATIONS) {\n                iterations++;\n            }\n"}
{"magic_number_smell": "\n    protected long initialDelay = DEFAULT_INITIAL_DELAY;\n    protected long interval = DEFAULT_INTERVAL;\n    protected int maxIterations = Integer.MAX_VALUE;\n    protected BackOffStrategy backOffStrategy;\n\n    public IterationBoundedBudgetBuilder withInitialDelay(Duration duration) {", "refactored_code": "    private static final int DEFAULT_MAX_ITERATIONS = Integer.MAX_VALUE;\n\n    protected long initialDelay = DEFAULT_INITIAL_DELAY;\n    protected long interval = DEFAULT_INTERVAL;\n    protected int maxIterations = DEFAULT_MAX_ITERATIONS;\n    protected BackOffStrategy backOffStrategy;\n\n    public IterationBoundedBudgetBuilder withInitialDelay(Duration duration) {"}
{"magic_number_smell": "    private static final long DEFAULT_INITIAL_DELAY = 0;\n    private static final long DEFAULT_INTERVAL = 1000;\n\n    private long maxDuration = 5000;\n    private long initialDelay = DEFAULT_INITIAL_DELAY;\n    private long interval = DEFAULT_INTERVAL;\n    private int maxIterations = DEFAULT_MAX_ITERATIONS;", "refactored_code": "    private static final long DEFAULT_MAX_DURATION = 5000;\n    private static final long DEFAULT_INITIAL_DELAY = 0;\n    private static final long DEFAULT_INTERVAL = 1000;\n\n    private long maxDuration = DEFAULT_MAX_DURATION;\n    private long initialDelay = DEFAULT_INITIAL_DELAY;\n    private long interval = DEFAULT_INTERVAL;\n    private int maxIterations = DEFAULT_MAX_ITERATIONS;"}
{"magic_number_smell": "    @Override\n    public boolean canContinue() {\n        // ... unless running forever\n        if (maxDuration == -1) {\n            return true;\n        }\n", "refactored_code": "    public static final long UNLIMITED_DURATION = -1;\n    @Override\n    public boolean canContinue() {\n        // ... unless running forever\n        if (maxDuration == UNLIMITED_DURATION) {\n            return true;\n        }\n"}
{"magic_number_smell": "    // stateful information\n    private final AtomicInteger failures = new AtomicInteger();\n    private final AtomicInteger success = new AtomicInteger();\n    private final AtomicInteger state = new AtomicInteger(0);\n    private final AtomicBoolean keepOpen = new AtomicBoolean();\n    private volatile Timer halfOpenTimer;\n    private volatile long lastFailure;", "refactored_code": "    private static final int STATE_CLOSED = 0;\n    // stateful information\n    private final AtomicInteger failures = new AtomicInteger();\n    private final AtomicInteger success = new AtomicInteger();\n    private final AtomicInteger state = new AtomicInteger(STATE_CLOSED);\n    private final AtomicBoolean keepOpen = new AtomicBoolean();\n    private volatile Timer halfOpenTimer;\n    private volatile long lastFailure;"}
{"magic_number_smell": "        expectedEntries = Math.max(expectedEntries, 2);\n        int tableSize = Integer.highestOneBit(expectedEntries);\n        // Check to make sure that we will not exceed the maximum load factor.\n        if (expectedEntries > (int) (1.2 * tableSize)) {\n            tableSize <<= 1;\n            return (tableSize > 0) ? tableSize : MAX_TABLE_SIZE;\n        }", "refactored_code": "    private static final double MAX_LOAD_FACTOR = 1.2;\n        expectedEntries = Math.max(expectedEntries, 2);\n        int tableSize = Integer.highestOneBit(expectedEntries);\n        // Check to make sure that we will not exceed the maximum load factor.\n        if (expectedEntries > (int) (MAX_LOAD_FACTOR * tableSize)) {\n            tableSize <<= 1;\n            return (tableSize > 0) ? tableSize : MAX_TABLE_SIZE;\n        }"}
{"magic_number_smell": "    }\n\n    public static int copy(InputStream input, OutputStream output) throws IOException {\n        return copy(input, output, 1024 * 4);\n    }\n\n    public static int copy(final InputStream input, final OutputStream output, int bufferSize) throws IOException {", "refactored_code": "    public static final int DEFAULT_BUFFER_SIZE = 1024 * 4;\n    }\n\n    public static int copy(InputStream input, OutputStream output) throws IOException {\n        return copy(input, output, DEFAULT_BUFFER_SIZE);\n    }\n\n    public static int copy(final InputStream input, final OutputStream output, int bufferSize) throws IOException {"}
{"magic_number_smell": "    private Scanner(Readable source, Pattern pattern) {\n        this.source = source;\n        delimPattern = pattern != null ? pattern : WHITESPACE_PATTERN;\n        buf = CharBuffer.allocate(1024);\n        cast(buf).limit(0);\n        matcher = delimPattern.matcher(buf);\n        matcher.useTransparentBounds(true);", "refactored_code": "    private static final int BUFFER_SIZE = 1024;\n    private Scanner(Readable source, Pattern pattern) {\n        this.source = source;\n        delimPattern = pattern != null ? pattern : WHITESPACE_PATTERN;\n        buf = CharBuffer.allocate(BUFFER_SIZE);\n        cast(buf).limit(0);\n        matcher = delimPattern.matcher(buf);\n        matcher.useTransparentBounds(true);"}
{"magic_number_smell": "    protected int bufLoadFactor = 95; // 99%\n    // protected int bufHardLimit; // only matters when expanding\n\n    protected char[] buf = new char[Runtime.getRuntime().freeMemory() > 1000000L ? 8 * 1024 : 256];\n    protected int bufSoftLimit = (bufLoadFactor * buf.length) / 100; // desirable\n                                                                    // size of\n                                                                    // buffer", "refactored_code": "    protected static final int READ_CHUNK_SIZE = 8 * 1024; // max data chars in\n    protected int bufLoadFactor = 95; // 99%\n    // protected int bufHardLimit; // only matters when expanding\n\n    protected char[] buf = new char[Runtime.getRuntime().freeMemory() > 1000000L ? READ_CHUNK_SIZE : 256];\n    protected int bufSoftLimit = (bufLoadFactor * buf.length) / 100; // desirable\n                                                                    // size of\n                                                                    // buffer"}
{"magic_number_smell": "    }\n\n    private void doRawStream(final InputStream is, final boolean lenient) throws IOException {\n        final BufferedInputStream pis = new BufferedInputStream(is, 4096);\n        final String bomEnc = getBOMEncoding(pis);\n        final String xmlGuessEnc = getXMLGuessEncoding(pis);\n        final String xmlEnc = getXmlProlog(pis, xmlGuessEnc);", "refactored_code": "    private static final int BUFFER_SIZE = 4096;\n    }\n\n    private void doRawStream(final InputStream is, final boolean lenient) throws IOException {\n        final BufferedInputStream pis = new BufferedInputStream(is, BUFFER_SIZE);\n        final String bomEnc = getBOMEncoding(pis);\n        final String xmlGuessEnc = getXMLGuessEncoding(pis);\n        final String xmlEnc = getXmlProlog(pis, xmlGuessEnc);"}
{"magic_number_smell": "\n    XMLStreamReaderInputStream(XMLStreamReader reader, String charset, XMLOutputFactory outfactory) {\n        this.reader = reader;\n        this.buffer = new byte[4096];\n        this.chunk = new TrimmableByteArrayOutputStream();\n        this.charset = charset == null ? \"utf-8\" : charset;\n        try {", "refactored_code": "    private static final int BUFFER_SIZE = 4096;\n\n    XMLStreamReaderInputStream(XMLStreamReader reader, String charset, XMLOutputFactory outfactory) {\n        this.reader = reader;\n        this.buffer = new byte[BUFFER_SIZE];\n        this.chunk = new TrimmableByteArrayOutputStream();\n        this.charset = charset == null ? \"utf-8\" : charset;\n        try {"}
{"magic_number_smell": "\n    XMLStreamReaderReader(XMLStreamReader reader, XMLOutputFactory outfactory) {\n        this.reader = reader;\n        this.buffer = new char[4096];\n        this.chunk = new TrimmableCharArrayWriter();\n        try {\n            this.writer = outfactory.createXMLStreamWriter(chunk);", "refactored_code": "    private static final int BUFFER_SIZE = 4096;\n\n    XMLStreamReaderReader(XMLStreamReader reader, XMLOutputFactory outfactory) {\n        this.reader = reader;\n        this.buffer = new char[BUFFER_SIZE];\n        this.chunk = new TrimmableCharArrayWriter();\n        try {\n            this.writer = outfactory.createXMLStreamWriter(chunk);"}
{"magic_number_smell": "            jo.put(\"status\", \"success\");\n            // avoid double wrap\n            jo.put(\"message\", MessageHelper.dumpAsJSonObject(out.getMessage(), true, true, true, true, true, true,\n                    128 * 1024).getMap(\"message\"));\n            IOHelper.writeText(jo.toJson(), outputFile);\n        }\n        camelContext.getCamelContextExtension().getExchangeFactory().release(out);", "refactored_code": "    private static final int BODY_MAX_CHARS = 128 * 1024;\n            jo.put(\"status\", \"success\");\n            // avoid double wrap\n            jo.put(\"message\", MessageHelper.dumpAsJSonObject(out.getMessage(), true, true, true, true, true, true,\n                    BODY_MAX_CHARS).getMap(\"message\"));\n            IOHelper.writeText(jo.toJson(), outputFile);\n        }\n        camelContext.getCamelContextExtension().getExchangeFactory().release(out);"}
{"magic_number_smell": "                        if (len < NAME_MIN_WIDTH) {\n                            len = NAME_MIN_WIDTH;\n                        }\n                        if (len > 25) {\n                            len = 25;\n                        }\n                        if (len > nameMaxWidth) {", "refactored_code": "    private static final int NAME_MAX_WIDTH = 25;\n                        if (len < NAME_MIN_WIDTH) {\n                            len = NAME_MIN_WIDTH;\n                        }\n                        if (len > NAME_MAX_WIDTH) {\n                            len = NAME_MAX_WIDTH;\n                        }\n                        if (len > nameMaxWidth) {"}
{"magic_number_smell": "                        if (len < NAME_MIN_WIDTH) {\n                            len = NAME_MIN_WIDTH;\n                        }\n                        if (len > 25) {\n                            len = 25;\n                        }\n                        if (len > nameMaxWidth) {", "refactored_code": "    private static final int NAME_MAX_WIDTH = 25;\n                        if (len < NAME_MIN_WIDTH) {\n                            len = NAME_MIN_WIDTH;\n                        }\n                        if (len > NAME_MAX_WIDTH) {\n                            len = NAME_MAX_WIDTH;\n                        }\n                        if (len > nameMaxWidth) {"}
{"magic_number_smell": "    }\n\n    public static List<String> didYouMean(List<String> names, String unknown) {\n        String[] suggestions = LuceneSuggestionStrategy.suggestEndpointOptions(names, unknown, 5);\n        if (suggestions != null) {\n            return Arrays.asList(suggestions);\n        }", "refactored_code": "    private static final int MAX_SUGGESTIONS = 5; // lucene recommends 5 as minimum\n    }\n\n    public static List<String> didYouMean(List<String> names, String unknown) {\n        String[] suggestions = LuceneSuggestionStrategy.suggestEndpointOptions(names, unknown, MAX_SUGGESTIONS);\n        if (suggestions != null) {\n            return Arrays.asList(suggestions);\n        }"}
{"magic_number_smell": "                        \"org/apache/camel/test/infra/artemis/services/Dockerfile\")\n                .withBuildArg(FROM_IMAGE_ARG, TestUtils.prependHubImageNamePrefixIfNeeded(FROM_IMAGE_NAME)));\n\n        withExposedPorts(1883, DEFAULT_AMQP_PORT,\n                DEFAULT_ADMIN_PORT, DEFAULT_ACCEPTOR_PORT)\n                .waitingFor(Wait.forListeningPort());\n    }", "refactored_code": "    private static final int DEFAULT_MQTT_PORT = 1883;\n                        \"org/apache/camel/test/infra/artemis/services/Dockerfile\")\n                .withBuildArg(FROM_IMAGE_ARG, TestUtils.prependHubImageNamePrefixIfNeeded(FROM_IMAGE_NAME)));\n\n        withExposedPorts(DEFAULT_MQTT_PORT, DEFAULT_AMQP_PORT,\n                DEFAULT_ADMIN_PORT, DEFAULT_ACCEPTOR_PORT)\n                .waitingFor(Wait.forListeningPort());\n    }"}
{"magic_number_smell": "    }\n\n    protected void setupContainer() {\n        withExposedPorts(4566)\n                .waitingFor(Wait.forLogMessage(\".*Ready\\\\.\\n\", 1));\n    }\n", "refactored_code": "    private static final int SERVICE_PORT = 4566;\n    }\n\n    protected void setupContainer() {\n        withExposedPorts(SERVICE_PORT)\n                .waitingFor(Wait.forLogMessage(\".*Ready\\\\.\\n\", 1));\n    }\n"}
{"magic_number_smell": "            return Integer.parseInt(strPort);\n        }\n\n        return 9042;\n    }\n\n    @Override", "refactored_code": "    private static final int DEFAULT_CQL_PORT = 9042;\n            return Integer.parseInt(strPort);\n        }\n\n        return DEFAULT_CQL_PORT;\n    }\n\n    @Override"}
{"magic_number_smell": "                ChatScriptProperties.CHATSCRIPT_CONTAINER);\n\n        container = new GenericContainer<>(containerName)\n                .withExposedPorts(1024)\n                .withCreateContainerCmdModifier(createContainerCmd -> createContainerCmd.withTty(true));\n    }\n", "refactored_code": "    private static final int SERVICE_PORT = 1024;\n                ChatScriptProperties.CHATSCRIPT_CONTAINER);\n\n        container = new GenericContainer<>(containerName)\n                .withExposedPorts(SERVICE_PORT)\n                .withCreateContainerCmdModifier(createContainerCmd -> createContainerCmd.withTty(true));\n    }\n"}
{"magic_number_smell": "        if (keepContainerRunning) {\n            waitingFor(Wait.forLogMessage(\".*keep container running.*\", 1));\n        }\n        withExposedPorts(8080, SSH_PORT);\n        if (Objects.nonNull(extraHosts)) {\n            extraHosts.forEach((host, ip) -> withExtraHost(host, ip));\n        }", "refactored_code": "    protected static final int DEV_CONSOLE_PORT = 8080;\n        if (keepContainerRunning) {\n            waitingFor(Wait.forLogMessage(\".*keep container running.*\", 1));\n        }\n        withExposedPorts(DEV_CONSOLE_PORT, SSH_PORT);\n        if (Objects.nonNull(extraHosts)) {\n            extraHosts.forEach((host, ip) -> withExtraHost(host, ip));\n        }"}
{"magic_number_smell": "public class DefaultContextLifeCycleManager implements ContextLifeCycleManager {\n    public static final int 10 = 10;\n    private static final Logger LOG = LoggerFactory.getLogger(DefaultContextLifeCycleManager.class);\n    private int shutdownTimeout = 10;\n    private boolean reset = true;\n\n    /**", "refactored_code": "    public static final int DEFAULT_SHUTDOWN_TIMEOUT = 10;\npublic class DefaultContextLifeCycleManager implements ContextLifeCycleManager {\n    public static final int DEFAULT_SHUTDOWN_TIMEOUT = 10;\n    private static final Logger LOG = LoggerFactory.getLogger(DefaultContextLifeCycleManager.class);\n    private int shutdownTimeout = DEFAULT_SHUTDOWN_TIMEOUT;\n    private boolean reset = true;\n\n    /**"}
{"magic_number_smell": "                        \"org/apache/camel/test/infra/dispatch/router/services/Dockerfile\")\n                .withBuildArg(FROM_IMAGE_ARG, TestUtils.prependHubImageNamePrefixIfNeeded(FROM_IMAGE_NAME)));\n\n        withExposedPorts(5672)\n                .waitingFor(Wait.forListeningPort());\n    }\n", "refactored_code": "    private static final int DEFAULT_AMQP_PORT = 5672;\n                        \"org/apache/camel/test/infra/dispatch/router/services/Dockerfile\")\n                .withBuildArg(FROM_IMAGE_ARG, TestUtils.prependHubImageNamePrefixIfNeeded(FROM_IMAGE_NAME)));\n\n        withExposedPorts(DEFAULT_AMQP_PORT)\n                .waitingFor(Wait.forListeningPort());\n    }\n"}
{"magic_number_smell": "\n    @Override\n    public int getPort() {\n        return container.getMappedPort(9200);\n    }\n\n    @Override", "refactored_code": "    private static final int ELASTIC_SEARCH_PORT = 9200;\n\n    @Override\n    public int getPort() {\n        return container.getMappedPort(ELASTIC_SEARCH_PORT);\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getPort() {\n        String strPort = System.getProperty(ElasticSearchProperties.9200);\n\n        if (strPort != null) {\n            return Integer.parseInt(strPort);", "refactored_code": "    private static final int ELASTIC_SEARCH_PORT = 9200;\n\n    @Override\n    public int getPort() {\n        String strPort = System.getProperty(ElasticSearchProperties.ELASTIC_SEARCH_PORT);\n\n        if (strPort != null) {\n            return Integer.parseInt(strPort);"}
{"magic_number_smell": "        return new EtcdContainer(imageName, CONTAINER_NAME, List.of(CONTAINER_NAME))\n                .withNetworkAliases(containerName)\n                .withClusterToken(UUID.randomUUID().toString())\n                .withExposedPorts(2379, ETCD_PEER_PORT)\n                .waitingFor(Wait.forListeningPort())\n                .waitingFor(Wait.forLogMessage(\".*ready to serve client requests.*\", 1));\n    }", "refactored_code": "    public static final int ETCD_CLIENT_PORT = 2379;\n        return new EtcdContainer(imageName, CONTAINER_NAME, List.of(CONTAINER_NAME))\n                .withNetworkAliases(containerName)\n                .withClusterToken(UUID.randomUUID().toString())\n                .withExposedPorts(ETCD_CLIENT_PORT, ETCD_PEER_PORT)\n                .waitingFor(Wait.forListeningPort())\n                .waitingFor(Wait.forLogMessage(\".*ready to serve client requests.*\", 1));\n    }"}
{"magic_number_smell": "        super(containerName);\n\n        withEnv(\"LOG_DIR\", \"/tmp/logs\")\n                .withExposedPorts(9092)\n                .withEnv(\"KAFKA_ADVERTISED_LISTENERS\", String.format(\"PLAINTEXT://%s:9092\", getHost()))\n                .withEnv(\"KAFKA_LISTENERS\", \"PLAINTEXT://0.0.0.0:9092\")\n                .withEnv(\"KAFKA_ZOOKEEPER_CONNECT\", zookeeperInstanceName + \":2181\")", "refactored_code": "    private static final int KAFKA_PORT = 9092;\n        super(containerName);\n\n        withEnv(\"LOG_DIR\", \"/tmp/logs\")\n                .withExposedPorts(KAFKA_PORT)\n                .withEnv(\"KAFKA_ADVERTISED_LISTENERS\", String.format(\"PLAINTEXT://%s:9092\", getHost()))\n                .withEnv(\"KAFKA_LISTENERS\", \"PLAINTEXT://0.0.0.0:9092\")\n                .withEnv(\"KAFKA_ZOOKEEPER_CONNECT\", zookeeperInstanceName + \":2181\")"}
{"magic_number_smell": "        super(containerName);\n\n        withEnv(\"LOG_DIR\", \"/tmp/logs\")\n                .withExposedPorts(2181)\n                .withNetwork(network)\n                .withCreateContainerCmdModifier(createContainerCmd -> setupContainer(name, createContainerCmd))\n                .withCommand(\"sh\", \"-c\", \"bin/zookeeper-server-start.sh config/zookeeper.properties\")", "refactored_code": "    private static final int ZOOKEEPER_PORT = 2181;\n        super(containerName);\n\n        withEnv(\"LOG_DIR\", \"/tmp/logs\")\n                .withExposedPorts(ZOOKEEPER_PORT)\n                .withNetwork(network)\n                .withCreateContainerCmdModifier(createContainerCmd -> setupContainer(name, createContainerCmd))\n                .withCommand(\"sh\", \"-c\", \"bin/zookeeper-server-start.sh config/zookeeper.properties\")"}
{"magic_number_smell": "                .withEnv(\"MINIO_ACCESS_KEY\", accessKey())\n                .withEnv(\"MINIO_SECRET_KEY\", secretKey())\n                .withCommand(\"server /data\")\n                .withExposedPorts(9000)\n                .waitingFor(new HttpWaitStrategy()\n                        .forPath(\"/minio/health/live\")\n                        .forPort(9000)", "refactored_code": "    private static final int BROKER_PORT = 9000;\n                .withEnv(\"MINIO_ACCESS_KEY\", accessKey())\n                .withEnv(\"MINIO_SECRET_KEY\", secretKey())\n                .withCommand(\"server /data\")\n                .withExposedPorts(BROKER_PORT)\n                .waitingFor(new HttpWaitStrategy()\n                        .forPath(\"/minio/health/live\")\n                        .forPort(BROKER_PORT)"}
{"magic_number_smell": "    @Override\n    public String getReplicaSetUrl() {\n        return String.format(\"mongodb://%s:%s\", container.getHost(),\n                container.getMappedPort(27017));\n    }\n\n    @Override", "refactored_code": "    private static final int DEFAULT_MONGODB_PORT = 27017;\n    @Override\n    public String getReplicaSetUrl() {\n        return String.format(\"mongodb://%s:%s\", container.getHost(),\n                container.getMappedPort(DEFAULT_MONGODB_PORT));\n    }\n\n    @Override"}
{"magic_number_smell": "\n        if (port == null) {\n            ret = new GenericContainer(imageName)\n                    .withExposedPorts(1883);\n        } else {\n            @SuppressWarnings(\"deprecation\")\n            GenericContainer fixedPortContainer = new FixedHostPortGenericContainer(imageName)", "refactored_code": "    public static final int CONTAINER_PORT = 1883;\n\n        if (port == null) {\n            ret = new GenericContainer(imageName)\n                    .withExposedPorts(CONTAINER_PORT);\n        } else {\n            @SuppressWarnings(\"deprecation\")\n            GenericContainer fixedPortContainer = new FixedHostPortGenericContainer(imageName)"}
{"magic_number_smell": "    protected GenericContainer initContainer(String imageName, String containerName) {\n        return new GenericContainer(imageName)\n                .withNetworkAliases(containerName)\n                .withExposedPorts(4222)\n                .waitingFor(Wait.forLogMessage(\".*Listening.*for.*route.*connections.*\", 1));\n    }\n", "refactored_code": "    private static final int PORT = 4222;\n    protected GenericContainer initContainer(String imageName, String containerName) {\n        return new GenericContainer(imageName)\n                .withNetworkAliases(containerName)\n                .withExposedPorts(PORT)\n                .waitingFor(Wait.forLogMessage(\".*Listening.*for.*route.*connections.*\", 1));\n    }\n"}
{"magic_number_smell": "\n        if (port == null) {\n            ret = new GenericContainer(imageName)\n                    .withExposedPorts(389, CONTAINER_PORT_LDAP_OVER_SSL);\n        } else {\n            @SuppressWarnings(\"deprecation\")\n            FixedHostPortGenericContainer fixedPortContainer = new FixedHostPortGenericContainer(imageName)", "refactored_code": "    public static final int CONTAINER_PORT_LDAP = 389;\n\n        if (port == null) {\n            ret = new GenericContainer(imageName)\n                    .withExposedPorts(CONTAINER_PORT_LDAP, CONTAINER_PORT_LDAP_OVER_SSL);\n        } else {\n            @SuppressWarnings(\"deprecation\")\n            FixedHostPortGenericContainer fixedPortContainer = new FixedHostPortGenericContainer(imageName)"}
{"magic_number_smell": "\n    @Override\n    public int getPort() {\n        return container.getMappedPort(9200);\n    }\n\n    @Override", "refactored_code": "    private static final int OPEN_SEARCH_PORT = 9200;\n\n    @Override\n    public int getPort() {\n        return container.getMappedPort(OPEN_SEARCH_PORT);\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getPort() {\n        String strPort = System.getProperty(OpenSearchProperties.9200);\n\n        if (strPort != null) {\n            return Integer.parseInt(strPort);", "refactored_code": "    private static final int OPEN_SEARCH_PORT = 9200;\n\n    @Override\n    public int getPort() {\n        String strPort = System.getProperty(OpenSearchProperties.OPEN_SEARCH_PORT);\n\n        if (strPort != null) {\n            return Integer.parseInt(strPort);"}
{"magic_number_smell": "\n    @Override\n    public int getHttpPort() {\n        return container.getMappedPort(6333);\n    }\n\n    @Override", "refactored_code": "    public static final int HTTP_PORT = 6333;\n\n    @Override\n    public int getHttpPort() {\n        return container.getMappedPort(HTTP_PORT);\n    }\n\n    @Override"}
{"magic_number_smell": "                .withFileFromClasspath(\".\",\n                        \"org/apache/camel/test/infra/smb/services/\"));\n\n        super.withExposedPorts(445)\n                .waitingFor(Wait.forListeningPort());\n    }\n", "refactored_code": "    public static final int SMB_PORT_DEFAULT = 445;\n                .withFileFromClasspath(\".\",\n                        \"org/apache/camel/test/infra/smb/services/\"));\n\n        super.withExposedPorts(SMB_PORT_DEFAULT)\n                .waitingFor(Wait.forListeningPort());\n    }\n"}
{"magic_number_smell": "        setWaitStrategy(Wait.forListeningPort());\n\n        withNetworkAliases(name)\n                .withExposedPorts(2181)\n                .withLogConsumer(new Slf4jLogConsumer(LOGGER));\n    }\n", "refactored_code": "    public static final int CLIENT_PORT = 2181;\n        setWaitStrategy(Wait.forListeningPort());\n\n        withNetworkAliases(name)\n                .withExposedPorts(CLIENT_PORT)\n                .withLogConsumer(new Slf4jLogConsumer(LOGGER));\n    }\n"}
{"magic_number_smell": "    static {\n        //set them as system properties so Spring can use the property placeholder\n        //things to set them into the URL's in the spring contexts\n        System.setProperty(\"HttpTestServer.Port\", Integer.toString(AvailablePortFinder.getNextAvailable()));\n    }\n\n    /**", "refactored_code": "    public static final int PORT = AvailablePortFinder.getNextAvailable();\n    static {\n        //set them as system properties so Spring can use the property placeholder\n        //things to set them into the URL's in the spring contexts\n        System.setProperty(\"HttpTestServer.Port\", Integer.toString(PORT));\n    }\n\n    /**"}
{"magic_number_smell": "                    if (zzCurrentPosL < zzEndReadL) {\n                        zzInput = zzBufferL[zzCurrentPosL++];\n                    } else if (zzAtEOF) {\n                        zzInput = -1;\n                        break zzForAction;\n                    } else {\n                        // store back cached positions", "refactored_code": "    public static final int YYEOF = -1;\n                    if (zzCurrentPosL < zzEndReadL) {\n                        zzInput = zzBufferL[zzCurrentPosL++];\n                    } else if (zzAtEOF) {\n                        zzInput = YYEOF;\n                        break zzForAction;\n                    } else {\n                        // store back cached positions"}
{"magic_number_smell": "\n                long unused = model.getEndpointOptions().stream().map(BaseOptionModel::getLabel).filter(Strings::isNullOrEmpty)\n                        .count();\n                if (unused >= 15) {\n                    unlabeledOptions.add(name);\n                }\n", "refactored_code": "    private static final int UNUSED_LABELS_WARN = 15;\n\n                long unused = model.getEndpointOptions().stream().map(BaseOptionModel::getLabel).filter(Strings::isNullOrEmpty)\n                        .count();\n                if (unused >= UNUSED_LABELS_WARN) {\n                    unlabeledOptions.add(name);\n                }\n"}
{"magic_number_smell": "  }\n\n  public int getMaxIndexRows() {\n    return this.conf.getInt(MAX_INDEX_ROWS, 20000);\n  }\n\n  public final Set<String> getIndexColumns() {", "refactored_code": "  public static final int DEFAULT_MAX_ROWIDS = 20000;\n  }\n\n  public int getMaxIndexRows() {\n    return this.conf.getInt(MAX_INDEX_ROWS, DEFAULT_MAX_ROWIDS);\n  }\n\n  public final Set<String> getIndexColumns() {"}
{"magic_number_smell": "      // TODO: Make script output prefixing configurable. Had to disable this since\n      // it results in lots of test diffs.\n      for (String cmd : cmds) {\n        info(getColorBuffer().pad(SCRIPT_OUTPUT_PREFIX, 5).append(cmd));\n        // if we do not force script execution, abort\n        // when a failure occurs.\n        if (dispatch(cmd) || getOpts().getForce()) {", "refactored_code": "  private static final int SCRIPT_OUTPUT_PAD_SIZE = 5;\n      // TODO: Make script output prefixing configurable. Had to disable this since\n      // it results in lots of test diffs.\n      for (String cmd : cmds) {\n        info(getColorBuffer().pad(SCRIPT_OUTPUT_PREFIX, SCRIPT_OUTPUT_PAD_SIZE).append(cmd));\n        // if we do not force script execution, abort\n        // when a failure occurs.\n        if (dispatch(cmd) || getOpts().getForce()) {"}
{"magic_number_smell": "  private boolean entireLineAsCommand = false;\n  private String numberFormat = \"default\";\n  private final Terminal terminal = TerminalFactory.get();\n  private int maxWidth = 80;\n  private int maxHeight = DEFAULT_MAX_HEIGHT;\n  private int maxColumnWidth = DEFAULT_MAX_COLUMN_WIDTH;\n  int timeout = -1;", "refactored_code": "  public static final int DEFAULT_MAX_WIDTH = 80;\n  private boolean entireLineAsCommand = false;\n  private String numberFormat = \"default\";\n  private final Terminal terminal = TerminalFactory.get();\n  private int maxWidth = DEFAULT_MAX_WIDTH;\n  private int maxHeight = DEFAULT_MAX_HEIGHT;\n  private int maxColumnWidth = DEFAULT_MAX_COLUMN_WIDTH;\n  int timeout = -1;"}
{"magic_number_smell": "  private Runnable createLogRunnable(final Statement statement,\n      InPlaceUpdateStream.EventNotifier eventNotifier) {\n    if (statement instanceof HiveStatement) {\n      return new LogRunnable(this, (HiveStatement) statement, 1000,\n          eventNotifier);\n    } else {\n      beeLine.debug(", "refactored_code": "  private static final int DEFAULT_QUERY_PROGRESS_INTERVAL = 1000;\n  private Runnable createLogRunnable(final Statement statement,\n      InPlaceUpdateStream.EventNotifier eventNotifier) {\n    if (statement instanceof HiveStatement) {\n      return new LogRunnable(this, (HiveStatement) statement, DEFAULT_QUERY_PROGRESS_INTERVAL,\n          eventNotifier);\n    } else {\n      beeLine.debug("}
{"magic_number_smell": "\n  @Test\n  public void testCmd() {\n    verifyCMD(\"show tables;!ls;show tables;\\n\", \"src\", out, null, 0, true);\n  }\n\n  @Test", "refactored_code": "  private static final int ERRNO_OK = 0;\n\n  @Test\n  public void testCmd() {\n    verifyCMD(\"show tables;!ls;show tables;\\n\", \"src\", out, null, ERRNO_OK, true);\n  }\n\n  @Test"}
{"magic_number_smell": "\n    LongWritable key = new LongWritable();\n    BytesRefArrayWritable value = new BytesRefArrayWritable();\n    StringBuilder buf = new StringBuilder(16 * 1024); // extra capacity in case we overrun, to avoid resizing\n    while (recordReader.next(key, value)) {\n      printRecord(value, buf);\n      recordCount++;", "refactored_code": "  private static final int STRING_BUFFER_SIZE = 16 * 1024;\n\n    LongWritable key = new LongWritable();\n    BytesRefArrayWritable value = new BytesRefArrayWritable();\n    StringBuilder buf = new StringBuilder(STRING_BUFFER_SIZE); // extra capacity in case we overrun, to avoid resizing\n    while (recordReader.next(key, value)) {\n      printRecord(value, buf);\n      recordCount++;"}
{"magic_number_smell": "   * @param repeatNum number of retry done so far.\n   */\n  public static int getSleepTime(int repeatNum) {\n    return 100 * (int)(Math.pow(2.0, repeatNum));\n  }\n\n  /**", "refactored_code": "  public static final int IO_ERROR_SLEEP_TIME = 100;\n   * @param repeatNum number of retry done so far.\n   */\n  public static int getSleepTime(int repeatNum) {\n    return IO_ERROR_SLEEP_TIME * (int)(Math.pow(2.0, repeatNum));\n  }\n\n  /**"}
{"magic_number_smell": "  }\n\n  public HeapMemoryMonitor(double threshold) {\n    this.threshold = threshold <= 0.0d || threshold > 1.0d ? 0.7d : threshold;\n    setupTenuredGenPoolThreshold(tenuredGenPool);\n  }\n", "refactored_code": "  private static final double DEFAULT_THRESHOLD = 0.7d;\n  }\n\n  public HeapMemoryMonitor(double threshold) {\n    this.threshold = threshold <= 0.0d || threshold > 1.0d ? DEFAULT_THRESHOLD : threshold;\n    setupTenuredGenPoolThreshold(tenuredGenPool);\n  }\n"}
{"magic_number_smell": "      while (shouldRun) {\n        sw.reset().start();\n        try {\n          Thread.sleep(500);\n        } catch (InterruptedException ie) {\n          return;\n        }", "refactored_code": "  private static final long SLEEP_INTERVAL_MS = 500;\n      while (shouldRun) {\n        sw.reset().start();\n        try {\n          Thread.sleep(SLEEP_INTERVAL_MS);\n        } catch (InterruptedException ie) {\n          return;\n        }"}
{"magic_number_smell": "      int newCapacity = currentCapacity + (currentCapacity >> 1);\n\n      // Check for overflow scenarios\n      if (newCapacity < 0 || newCapacity > Integer.MAX_VALUE - 8) {\n        newCapacity = Integer.MAX_VALUE - 8;\n      } else if (newCapacity < requestCapacity) {\n        newCapacity = requestCapacity;", "refactored_code": "  private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n      int newCapacity = currentCapacity + (currentCapacity >> 1);\n\n      // Check for overflow scenarios\n      if (newCapacity < 0 || newCapacity > MAX_ARRAY_SIZE) {\n        newCapacity = MAX_ARRAY_SIZE;\n      } else if (newCapacity < requestCapacity) {\n        newCapacity = requestCapacity;"}
{"magic_number_smell": "  private static final String FOOTER_FORMAT = \"%-15s  %-30s %-4s  %-25s\";\n\n  private static final int PROGRESS_BAR_CHARS = 30;\n  private static final String SEPARATOR = new String(new char[94]).replace(\"\\0\", \"-\");\n\n  /* Pretty print the values */\n  private final DecimalFormat secondsFormatter = new DecimalFormat(\"#0.00\");", "refactored_code": "  public static final int MIN_TERMINAL_WIDTH = 94;\n  private static final String FOOTER_FORMAT = \"%-15s  %-30s %-4s  %-25s\";\n\n  private static final int PROGRESS_BAR_CHARS = 30;\n  private static final String SEPARATOR = new String(new char[MIN_TERMINAL_WIDTH]).replace(\"\\0\", \"-\");\n\n  /* Pretty print the values */\n  private final DecimalFormat secondsFormatter = new DecimalFormat(\"#0.00\");"}
{"magic_number_smell": "      while ((line = in.readLine()) != null) {\n        logger.info(line);\n        if (errLogs != null) {\n          if (numErrLogLines++ < 1000) {\n            errLogs.add(line);\n          }\n        }", "refactored_code": "  private static final long MAX_ERR_LOG_LINES_FOR_RPC = 1000;\n      while ((line = in.readLine()) != null) {\n        logger.info(line);\n        if (errLogs != null) {\n          if (numErrLogLines++ < MAX_ERR_LOG_LINES_FOR_RPC) {\n            errLogs.add(line);\n          }\n        }"}
{"magic_number_smell": "      throw new ArithmeticException(\n          \"Decimal128 does not support negative scaling\");\n    }\n    if (scale > 38) {\n      throw new ArithmeticException(\"Beyond possible Decimal128 scaling\");\n    }\n  }", "refactored_code": "  public static final short MAX_SCALE = 38;\n      throw new ArithmeticException(\n          \"Decimal128 does not support negative scaling\");\n    }\n    if (scale > MAX_SCALE) {\n      throw new ArithmeticException(\"Beyond possible Decimal128 scaling\");\n    }\n  }"}
{"magic_number_smell": "    if (positive) {\n      return val & FULLBITS_63;\n    }\n    return val | 0x8000000000000000L;\n  }\n\n  /**", "refactored_code": "  public static final long NEGATIVE_LONG_MASK = 0x8000000000000000L;\n    if (positive) {\n      return val & FULLBITS_63;\n    }\n    return val | NEGATIVE_LONG_MASK;\n  }\n\n  /**"}
{"magic_number_smell": "  public static Timestamp stringToTimestamp(final String text) {\n    final String s = Objects.requireNonNull(text).trim();\n    // Handle simpler cases directly avoiding exceptions\n    if (s.length() == \"YYYY-MM-DD\".length()) {\n      Date d = DateParser.parseDate(s);\n      if (d == null) {\n        throw new IllegalArgumentException(\"Cannot parse date: \" + text);", "refactored_code": "  private static final int DATE_LENGTH = \"YYYY-MM-DD\".length();\n  public static Timestamp stringToTimestamp(final String text) {\n    final String s = Objects.requireNonNull(text).trim();\n    // Handle simpler cases directly avoiding exceptions\n    if (s.length() == DATE_LENGTH) {\n      Date d = DateParser.parseDate(s);\n      if (d == null) {\n        throw new IllegalArgumentException(\"Cannot parse date: \" + text);"}
{"magic_number_smell": "  public static final int 4 = 4;\n\n  /** Number of bytes to store this object. */\n  public static final int BYTE_SIZE = 4 * 4;\n\n  /** Can hold up to 10^38. */\n  public static final int MAX_DIGITS = 38;", "refactored_code": "  public static final int INT_COUNT = 4;\n  public static final int INT_COUNT = 4;\n\n  /** Number of bytes to store this object. */\n  public static final int BYTE_SIZE = 4 * INT_COUNT;\n\n  /** Can hold up to 10^38. */\n  public static final int MAX_DIGITS = 38;"}
{"magic_number_smell": "        \"Expected inflation factor between disk/in memory representation of hash tables\"),\n    HIVE_LOG_TRACE_ID(\"hive.log.trace.id\", \"\",\n        \"Log tracing id that can be used by upstream clients for tracking respective logs. \" +\n        \"Truncated to \" + 64 + \" characters. Defaults to use auto-generated session id.\"),\n\n    HIVE_MM_AVOID_GLOBSTATUS_ON_S3(\"hive.mm.avoid.s3.globstatus\", true,\n        \"Whether to use listFiles (optimized on S3) instead of globStatus when on S3.\"),", "refactored_code": "  private static final int LOG_PREFIX_LENGTH = 64;\n        \"Expected inflation factor between disk/in memory representation of hash tables\"),\n    HIVE_LOG_TRACE_ID(\"hive.log.trace.id\", \"\",\n        \"Log tracing id that can be used by upstream clients for tracking respective logs. \" +\n        \"Truncated to \" + LOG_PREFIX_LENGTH + \" characters. Defaults to use auto-generated session id.\"),\n\n    HIVE_MM_AVOID_GLOBSTATUS_ON_S3(\"hive.mm.avoid.s3.globstatus\", true,\n        \"Whether to use listFiles (optimized on S3) instead of globStatus when on S3.\"),"}
{"magic_number_smell": "\n  public static final int 1000000000 = 1000000000;\n  public static final BigDecimal MAX_INT_BD = new BigDecimal(Integer.MAX_VALUE);\n  public static final BigDecimal NANOS_PER_SEC_BD = new BigDecimal(1000000000);\n\n  public static int parseNumericValueWithRange(String fieldName,\n      String strVal, int minValue, int maxValue) throws IllegalArgumentException {", "refactored_code": "  public static final int NANOS_PER_SEC = 1000000000;\n\n  public static final int NANOS_PER_SEC = 1000000000;\n  public static final BigDecimal MAX_INT_BD = new BigDecimal(Integer.MAX_VALUE);\n  public static final BigDecimal NANOS_PER_SEC_BD = new BigDecimal(NANOS_PER_SEC);\n\n  public static int parseNumericValueWithRange(String fieldName,\n      String strVal, int minValue, int maxValue) throws IllegalArgumentException {"}
{"magic_number_smell": "    int markerShift, deltaShift, rcShift;\n\n    public final long setMarker(long dest, long val) {\n      return setValue(dest, val, markerShift, 0xffffL, DELTA_MASK = 0xffL, RC_MASK = 0xffL);\n    }\n\n    public final long setDelta(long dest, long val) {", "refactored_code": "    private static final long MARKER_MASK = 0xffffL, DELTA_MASK = 0xffL, RC_MASK = 0xffL;\n    int markerShift, deltaShift, rcShift;\n\n    public final long setMarker(long dest, long val) {\n      return setValue(dest, val, markerShift, MARKER_MASK);\n    }\n\n    public final long setDelta(long dest, long val) {"}
{"magic_number_smell": "          LOG.info(toStartupShutdownString(\"SHUTDOWN_MSG: \", new String[]{\n            \"Shutting down \" + classname + \" at \" + hostname}));\n        }\n      }, 0);\n\n  }\n", "refactored_code": "  public static final int SHUTDOWN_HOOK_PRIORITY = 0;\n          LOG.info(toStartupShutdownString(\"SHUTDOWN_MSG: \", new String[]{\n            \"Shutting down \" + classname + \" at \" + hostname}));\n        }\n      }, SHUTDOWN_HOOK_PRIORITY);\n\n  }\n"}
{"magic_number_smell": "   * @param timeout timeout of the shutdownHook\n   */\n  public static void addGracefulShutDownHook(Runnable shutdownHook, long timeout) {\n    addShutdownHook(shutdownHook, 1000, timeout);\n  }\n\n  /**", "refactored_code": "  public static final int GRACEFUL_SHUTDOWN_HOOK_PRIORITY = 1000;\n   * @param timeout timeout of the shutdownHook\n   */\n  public static void addGracefulShutDownHook(Runnable shutdownHook, long timeout) {\n    addShutdownHook(shutdownHook, GRACEFUL_SHUTDOWN_HOOK_PRIORITY, timeout);\n  }\n\n  /**"}
{"magic_number_smell": "  }\n\n  public static class BadFormatException extends Exception {\n    private static final long 1L = 1L;\n\n    public BadFormatException(String msg) {\n      super(msg);", "refactored_code": "  private static final long serialVersionUID = 1L;\n  }\n\n  public static class BadFormatException extends Exception {\n    private static final long serialVersionUID = 1L;\n\n    public BadFormatException(String msg) {\n      super(msg);"}
{"magic_number_smell": "        JSON_MAPPER.writeValue(descriptorOut, segment);\n        descriptorOut.flush();\n      }\n    }, RetryPolicies.exponentialBackoffRetry(8, SECONDS_BETWEEN_RETRIES, TimeUnit.SECONDS));\n    descriptorPusher.push();\n  }\n", "refactored_code": "  private static final int NUM_RETRIES = 8;\n        JSON_MAPPER.writeValue(descriptorOut, segment);\n        descriptorOut.flush();\n      }\n    }, RetryPolicies.exponentialBackoffRetry(NUM_RETRIES, SECONDS_BETWEEN_RETRIES, TimeUnit.SECONDS));\n    descriptorPusher.push();\n  }\n"}
{"magic_number_smell": "\n  @Override\n  public LazyObjectBase createKey(ObjectInspector inspector) throws SerDeException {\n    return new FixedLengthed(10);\n  }\n\n  private final ByteStream.Output output = new ByteStream.Output();", "refactored_code": "  private static final int FIXED_LENGTH = 10;\n\n  @Override\n  public LazyObjectBase createKey(ObjectInspector inspector) throws SerDeException {\n    return new FixedLengthed(FIXED_LENGTH);\n  }\n\n  private final ByteStream.Output output = new ByteStream.Output();"}
{"magic_number_smell": "        String comparisonOp = condition.getComparisonOp();\n        String constantVal = String.valueOf(condition.getConstantDesc().getValue());\n\n        byte[] valueAsBytes = toBinary(constantVal, 10, false, false);\n\n        if (comparisonOp.endsWith(\"UDFOPEqualOrGreaterThan\")) {\n          filters.add(new RowFilter(CompareOp.GREATER_OR_EQUAL, new BinaryComparator(valueAsBytes)));", "refactored_code": "  private static final int FIXED_LENGTH = 10;\n        String comparisonOp = condition.getComparisonOp();\n        String constantVal = String.valueOf(condition.getConstantDesc().getValue());\n\n        byte[] valueAsBytes = toBinary(constantVal, FIXED_LENGTH, false, false);\n\n        if (comparisonOp.endsWith(\"UDFOPEqualOrGreaterThan\")) {\n          filters.add(new RowFilter(CompareOp.GREATER_OR_EQUAL, new BinaryComparator(valueAsBytes)));"}
{"magic_number_smell": "   */\n  public static byte findType(Object o) {\n    if (o == null) {\n      return 1;\n    }\n\n    Class<?> clazz = o.getClass();", "refactored_code": "  public static final byte NULL = 1;\n   */\n  public static byte findType(Object o) {\n    if (o == null) {\n      return NULL;\n    }\n\n    Class<?> clazz = o.getClass();"}
{"magic_number_smell": "\n  private final static Logger LOG = LoggerFactory.getLogger(HCatRecordObjectInspectorFactory.class);\n  private static final int 1024 = 1024;\n  private static final int MAX_CACHE_CAPACITY = 10 * 1024;\n\n  private static final CacheBuilder<Object, Object> boundedCache =\n      CacheBuilder.newBuilder()", "refactored_code": "  private static final int INITIAL_CACHE_CAPACITY = 1024;\n\n  private final static Logger LOG = LoggerFactory.getLogger(HCatRecordObjectInspectorFactory.class);\n  private static final int INITIAL_CACHE_CAPACITY = 1024;\n  private static final int MAX_CACHE_CAPACITY = 10 * INITIAL_CACHE_CAPACITY;\n\n  private static final CacheBuilder<Object, Object> boundedCache =\n      CacheBuilder.newBuilder()"}
{"magic_number_smell": "      customDynamicLocationUsed = false;\n    }\n\n    this.maxAppendAttempts = context.getConfiguration().getInt(HCatConstants.HCAT_APPEND_LIMIT, 1000);\n  }\n\n  @Override", "refactored_code": "  private static final int APPEND_COUNTER_WARN_THRESHOLD = 1000;\n      customDynamicLocationUsed = false;\n    }\n\n    this.maxAppendAttempts = context.getConfiguration().getInt(HCatConstants.HCAT_APPEND_LIMIT, APPEND_COUNTER_WARN_THRESHOLD);\n  }\n\n  @Override"}
{"magic_number_smell": "      System.setSecurityManager(new NoExitSecurityManager());\n      hiveConf = new HiveConf(TestHiveClientCache.class);\n      hiveConf.setVar(HiveConf.ConfVars.METASTORE_URIS, \"thrift://localhost:\"\n          + 20101);\n      hiveConf.setIntVar(HiveConf.ConfVars.METASTORE_THRIFT_CONNECTION_RETRIES, 3);\n      hiveConf.setIntVar(HiveConf.ConfVars.METASTORE_THRIFT_FAILURE_RETRIES, 3);\n      hiveConf.set(HiveConf.ConfVars.SEMANTIC_ANALYZER_HOOK.varname,", "refactored_code": "    public final int MS_PORT = 20101;\n      System.setSecurityManager(new NoExitSecurityManager());\n      hiveConf = new HiveConf(TestHiveClientCache.class);\n      hiveConf.setVar(HiveConf.ConfVars.METASTORE_URIS, \"thrift://localhost:\"\n          + MS_PORT);\n      hiveConf.setIntVar(HiveConf.ConfVars.METASTORE_THRIFT_CONNECTION_RETRIES, 3);\n      hiveConf.setIntVar(HiveConf.ConfVars.METASTORE_THRIFT_FAILURE_RETRIES, 3);\n      hiveConf.set(HiveConf.ConfVars.SEMANTIC_ANALYZER_HOOK.varname,"}
{"magic_number_smell": "  @Test\n  public void testGet() throws Exception {\n    HCatRecord r = new LazyHCatRecord(getHCatRecord(), getObjectInspector());\n    Assert.assertEquals(789, ((Integer) r.get(0)).intValue());\n    Assert.assertEquals(LONG_CONST, ((Long) r.get(1)).longValue());\n    Assert.assertEquals(DOUBLE_CONST, ((Double) r.get(2)).doubleValue(), 0);\n    Assert.assertEquals(STRING_CONST, r.get(3));", "refactored_code": "  private final int INT_CONST = 789;\n  @Test\n  public void testGet() throws Exception {\n    HCatRecord r = new LazyHCatRecord(getHCatRecord(), getObjectInspector());\n    Assert.assertEquals(INT_CONST, ((Integer) r.get(0)).intValue());\n    Assert.assertEquals(LONG_CONST, ((Long) r.get(1)).longValue());\n    Assert.assertEquals(DOUBLE_CONST, ((Double) r.get(2)).doubleValue(), 0);\n    Assert.assertEquals(STRING_CONST, r.get(3));"}
{"magic_number_smell": "      String outputFormatClass) throws Exception {\n    super(formatName, serdeClass, inputFormatClass, outputFormatClass);\n    tableName = \"testHCatDynamicPartitionedTable_\" + formatName;\n    generateWriteRecords(20, NUM_TOP_PARTITIONS, 0);\n    generateDataColumns();\n  }\n", "refactored_code": "  protected static final int NUM_RECORDS = 20;\n      String outputFormatClass) throws Exception {\n    super(formatName, serdeClass, inputFormatClass, outputFormatClass);\n    tableName = \"testHCatDynamicPartitionedTable_\" + formatName;\n    generateWriteRecords(NUM_RECORDS, NUM_TOP_PARTITIONS, 0);\n    generateDataColumns();\n  }\n"}
{"magic_number_smell": "   * @param topicName is the name on message broker on which message is sent.\n   */\n  protected void send(HCatEventMessage hCatEventMessage, String topicName) {\n    send(hCatEventMessage, topicName, 1);\n  }\n\n  /**", "refactored_code": "  public static final int NUM_RETRIES = 1;\n   * @param topicName is the name on message broker on which message is sent.\n   */\n  protected void send(HCatEventMessage hCatEventMessage, String topicName) {\n    send(hCatEventMessage, topicName, NUM_RETRIES);\n  }\n\n  /**"}
{"magic_number_smell": "  }\n\n  public void run() {\n    int port = conf.getInt(AppConfig.PORT, 8080);\n    try {\n      checkEnv();\n      runServer(port);", "refactored_code": "  public static final int DEFAULT_PORT = 8080;\n  }\n\n  public void run() {\n    int port = conf.getInt(AppConfig.PORT, DEFAULT_PORT);\n    try {\n      checkEnv();\n      runServer(port);"}
{"magic_number_smell": "    this.database = database;\n    this.tableName = table;\n    this.metadataRefreshMaxRetries =\n        conf.getInt(HIVE_ICEBERG_METADATA_REFRESH_MAX_RETRIES, 2);\n    this.maxHiveTablePropertySize = conf.getLong(HIVE_TABLE_PROPERTY_MAX_SIZE, HIVE_TABLE_PROPERTY_MAX_SIZE_DEFAULT);\n  }\n", "refactored_code": "  private static final int HIVE_ICEBERG_METADATA_REFRESH_MAX_RETRIES_DEFAULT = 2;\n    this.database = database;\n    this.tableName = table;\n    this.metadataRefreshMaxRetries =\n        conf.getInt(HIVE_ICEBERG_METADATA_REFRESH_MAX_RETRIES, HIVE_ICEBERG_METADATA_REFRESH_MAX_RETRIES_DEFAULT);\n    this.maxHiveTablePropertySize = conf.getLong(HIVE_TABLE_PROPERTY_MAX_SIZE, HIVE_TABLE_PROPERTY_MAX_SIZE_DEFAULT);\n  }\n"}
{"magic_number_smell": "    this.tableName = tableName;\n\n    this.lockAcquireTimeout =\n        conf.getLong(HIVE_ACQUIRE_LOCK_TIMEOUT_MS, 3 * 60 * 1000);\n    this.lockCheckMinWaitTime =\n        conf.getLong(HIVE_LOCK_CHECK_MIN_WAIT_MS, HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT);\n    this.lockCheckMaxWaitTime =", "refactored_code": "  private static final long HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT = 3 * 60 * 1000; // 3 minutes\n    this.tableName = tableName;\n\n    this.lockAcquireTimeout =\n        conf.getLong(HIVE_ACQUIRE_LOCK_TIMEOUT_MS, HIVE_ACQUIRE_LOCK_TIMEOUT_MS_DEFAULT);\n    this.lockCheckMinWaitTime =\n        conf.getLong(HIVE_LOCK_CHECK_MIN_WAIT_MS, HIVE_LOCK_CHECK_MIN_WAIT_MS_DEFAULT);\n    this.lockCheckMaxWaitTime ="}
{"magic_number_smell": "                CatalogUtil.ICEBERG_CATALOG_TYPE_HIVE,\n                ImmutableMap.of(\n                    CatalogProperties.CLIENT_POOL_CACHE_EVICTION_INTERVAL_MS,\n                    String.valueOf(TimeUnit.SECONDS.toMillis(10))),\n                hiveConfWithOverrides);\n  }\n", "refactored_code": "  protected static final long EVICTION_INTERVAL = TimeUnit.SECONDS.toMillis(10);\n                CatalogUtil.ICEBERG_CATALOG_TYPE_HIVE,\n                ImmutableMap.of(\n                    CatalogProperties.CLIENT_POOL_CACHE_EVICTION_INTERVAL_MS,\n                    String.valueOf(EVICTION_INTERVAL)),\n                hiveConfWithOverrides);\n  }\n"}
{"magic_number_smell": "   * Starts a TestHiveMetastore with the default connection pool size (5) and the default HiveConf.\n   */\n  public void start() {\n    start(new HiveConf(new Configuration(), TestHiveMetastore.class), 5);\n  }\n\n  /**", "refactored_code": "  private static final int DEFAULT_POOL_SIZE = 5;\n   * Starts a TestHiveMetastore with the default connection pool size (5) and the default HiveConf.\n   */\n  public void start() {\n    start(new HiveConf(new Configuration(), TestHiveMetastore.class), DEFAULT_POOL_SIZE);\n  }\n\n  /**"}
{"magic_number_smell": "    // It gets the config from the FileSinkOperator which has its own config for every target table\n    Table table = HiveIcebergStorageHandler.table(jc, jc.get(hive_metastoreConstants.META_TABLE_NAME));\n    String tableName = jc.get(Catalogs.NAME);\n    int poolSize = jc.getInt(DELETE_FILE_THREAD_POOL_SIZE, 10);\n\n    setWriterLevelConfiguration(jc, table);\n    return WriterBuilder.builderFor(table)", "refactored_code": "  private static final int DELETE_FILE_THREAD_POOL_SIZE_DEFAULT = 10;\n    // It gets the config from the FileSinkOperator which has its own config for every target table\n    Table table = HiveIcebergStorageHandler.table(jc, jc.get(hive_metastoreConstants.META_TABLE_NAME));\n    String tableName = jc.get(Catalogs.NAME);\n    int poolSize = jc.getInt(DELETE_FILE_THREAD_POOL_SIZE, DELETE_FILE_THREAD_POOL_SIZE_DEFAULT);\n\n    setWriterLevelConfiguration(jc, table);\n    return WriterBuilder.builderFor(table)"}
{"magic_number_smell": "        String[] row =\n            fetcher.convert(currSerDe.deserialize(value), currSerDe.getObjectInspector())\n                .toString().split(\"\\t\");\n        parts.add(HiveTableUtil.getParseData(row[PART_IDX], row[1], mapper, tbl.spec().specId()));\n      }\n    }\n    Collections.sort(parts);", "refactored_code": "  private static final int SPEC_IDX = 1;\n        String[] row =\n            fetcher.convert(currSerDe.deserialize(value), currSerDe.getObjectInspector())\n                .toString().split(\"\\t\");\n        parts.add(HiveTableUtil.getParseData(row[PART_IDX], row[SPEC_IDX], mapper, tbl.spec().specId()));\n      }\n    }\n    Collections.sort(parts);"}
{"magic_number_smell": "public final class ParquetFooterInputFromCache\n    extends SeekableInputStream implements InputFile {\n  public static final int 4 = 4; // For the file size check.\n  private static final int TAIL_LENGTH = ParquetFileWriter.MAGIC.length + 4;\n  private static final int FAKE_PREFIX_LENGTH = ParquetFileWriter.MAGIC.length;\n  private final int length;\n  private final int footerLength;", "refactored_code": "  public static final int FOOTER_LENGTH_SIZE = 4; // For the file size check.\npublic final class ParquetFooterInputFromCache\n    extends SeekableInputStream implements InputFile {\n  public static final int FOOTER_LENGTH_SIZE = 4; // For the file size check.\n  private static final int TAIL_LENGTH = ParquetFileWriter.MAGIC.length + FOOTER_LENGTH_SIZE;\n  private static final int FAKE_PREFIX_LENGTH = ParquetFileWriter.MAGIC.length;\n  private final int length;\n  private final int footerLength;"}
{"magic_number_smell": "    }\n\n    protected int getMaxEntries() {\n      return 20;\n    }\n\n    @Override", "refactored_code": "    private static final int MAX_ENTRIES = 20;\n    }\n\n    protected int getMaxEntries() {\n      return MAX_ENTRIES;\n    }\n\n    @Override"}
{"magic_number_smell": "   */\n  private List<Record> writeRecords(String name, int taskNum, int attemptNum, boolean commitTasks, boolean abortTasks,\n                                    JobConf conf, OutputCommitter committer) throws IOException {\n    List<Record> expected = Lists.newArrayListWithExpectedSize(5 * taskNum);\n\n    Table table = HiveIcebergStorageHandler.table(conf, name);\n    Schema schema = HiveIcebergStorageHandler.schema(conf);", "refactored_code": "  private static final int RECORD_NUM = 5;\n   */\n  private List<Record> writeRecords(String name, int taskNum, int attemptNum, boolean commitTasks, boolean abortTasks,\n                                    JobConf conf, OutputCommitter committer) throws IOException {\n    List<Record> expected = Lists.newArrayListWithExpectedSize(RECORD_NUM * taskNum);\n\n    Table table = HiveIcebergStorageHandler.table(conf, name);\n    Schema schema = HiveIcebergStorageHandler.schema(conf);"}
{"magic_number_smell": "        conf.setVar(HiveConf.ConfVars.METASTORE_RAW_STORE_IMPL, DummyRawStoreFailEvent.class.getName());\n        MetastoreConf.setVar(conf, MetastoreConf.ConfVars.EVENT_MESSAGE_FACTORY, JSONMessageEncoder.class.getName());\n        MetastoreConf.setTimeVar(conf, MetastoreConf.ConfVars.EVENT_DB_LISTENER_CLEAN_INTERVAL, CLEANUP_SLEEP_TIME, TimeUnit.SECONDS);\n        MetastoreConf.setTimeVar(conf, MetastoreConf.ConfVars.EVENT_DB_LISTENER_TTL, 30, TimeUnit.SECONDS);\n        MetastoreConf.setTimeVar(conf, EVENT_DB_LISTENER_CLEAN_STARTUP_WAIT_INTERVAL, 20, TimeUnit.SECONDS);\n        conf.setVar(HiveConf.ConfVars.HIVE_AUTHORIZATION_MANAGER,\n                \"org.apache.hadoop.hive.ql.security.authorization.plugin.sqlstd.SQLStdHiveAuthorizerFactory\");", "refactored_code": "    private static final int EVENTS_TTL = 30;\n        conf.setVar(HiveConf.ConfVars.METASTORE_RAW_STORE_IMPL, DummyRawStoreFailEvent.class.getName());\n        MetastoreConf.setVar(conf, MetastoreConf.ConfVars.EVENT_MESSAGE_FACTORY, JSONMessageEncoder.class.getName());\n        MetastoreConf.setTimeVar(conf, MetastoreConf.ConfVars.EVENT_DB_LISTENER_CLEAN_INTERVAL, CLEANUP_SLEEP_TIME, TimeUnit.SECONDS);\n        MetastoreConf.setTimeVar(conf, MetastoreConf.ConfVars.EVENT_DB_LISTENER_TTL, EVENTS_TTL, TimeUnit.SECONDS);\n        MetastoreConf.setTimeVar(conf, EVENT_DB_LISTENER_CLEAN_STARTUP_WAIT_INTERVAL, 20, TimeUnit.SECONDS);\n        conf.setVar(HiveConf.ConfVars.HIVE_AUTHORIZATION_MANAGER,\n                \"org.apache.hadoop.hive.ql.security.authorization.plugin.sqlstd.SQLStdHiveAuthorizerFactory\");"}
{"magic_number_smell": "    conf.setVar(HiveConf.ConfVars.METASTORE_TRANSACTIONAL_EVENT_LISTENERS,\n        DbNotificationListener.class.getName());\n    conf.setVar(HiveConf.ConfVars.METASTORE_EVENT_LISTENERS, MockMetaStoreEventListener.class.getName());\n    conf.setVar(HiveConf.ConfVars.METASTORE_EVENT_DB_LISTENER_TTL, String.valueOf(30) + \"s\");\n    conf.setBoolVar(HiveConf.ConfVars.HIVE_SUPPORT_CONCURRENCY, false);\n    conf.setBoolVar(HiveConf.ConfVars.FIRE_EVENTS_FOR_DML, true);\n    conf.setVar(HiveConf.ConfVars.METASTORE_RAW_STORE_IMPL, DummyRawStoreFailEvent.class.getName());", "refactored_code": "  private static final int EVENTS_TTL = 30;\n    conf.setVar(HiveConf.ConfVars.METASTORE_TRANSACTIONAL_EVENT_LISTENERS,\n        DbNotificationListener.class.getName());\n    conf.setVar(HiveConf.ConfVars.METASTORE_EVENT_LISTENERS, MockMetaStoreEventListener.class.getName());\n    conf.setVar(HiveConf.ConfVars.METASTORE_EVENT_DB_LISTENER_TTL, String.valueOf(EVENTS_TTL) + \"s\");\n    conf.setBoolVar(HiveConf.ConfVars.HIVE_SUPPORT_CONCURRENCY, false);\n    conf.setBoolVar(HiveConf.ConfVars.FIRE_EVENTS_FOR_DML, true);\n    conf.setVar(HiveConf.ConfVars.METASTORE_RAW_STORE_IMPL, DummyRawStoreFailEvent.class.getName());"}
{"magic_number_smell": "        throw new RuntimeException(\"timestamps are not equal in bench as expected\");\n      }\n\n      for (int j = 0; j < 50000L; j++) {\n        l1 = PrimitiveObjectInspectorUtils.getTimestamp(v1,\n            (PrimitiveObjectInspector) expressionDef.getOI());\n        l2 = PrimitiveObjectInspectorUtils.getTimestamp(v2,", "refactored_code": "  private static final long INNER_ITERATIONS = 50000L;\n        throw new RuntimeException(\"timestamps are not equal in bench as expected\");\n      }\n\n      for (int j = 0; j < INNER_ITERATIONS; j++) {\n        l1 = PrimitiveObjectInspectorUtils.getTimestamp(v1,\n            (PrimitiveObjectInspector) expressionDef.getOI());\n        l2 = PrimitiveObjectInspectorUtils.getTimestamp(v2,"}
{"magic_number_smell": "\n    public SizeOptimizedSparseStressN(int stressN) {\n      this.stressN = stressN;\n      numIterations = 1000000 / stressN;\n    }\n\n    @Override", "refactored_code": "  public static final int DEFAULT_ITER_TIME = 1000000;\n\n    public SizeOptimizedSparseStressN(int stressN) {\n      this.stressN = stressN;\n      numIterations = DEFAULT_ITER_TIME / stressN;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public void bench() {\n      for (int i = 0; i < 1000000; i++) {\n        obj.init(ref, offsets[i % sizes.length], sizes[i % sizes.length]);\n      }\n    }", "refactored_code": "  public static final int DEFAULT_ITER_TIME = 1000000;\n\n    @Override\n    public void bench() {\n      for (int i = 0; i < DEFAULT_ITER_TIME; i++) {\n        obj.init(ref, offsets[i % sizes.length], sizes[i % sizes.length]);\n      }\n    }"}
{"magic_number_smell": "  @Warmup(iterations = 2, time = 2, timeUnit = TimeUnit.MILLISECONDS)\n  @Measurement(iterations = 2, time = 2, timeUnit = TimeUnit.MILLISECONDS)\n  public void bench() throws HiveException {\n    for (int i = 0; i < 1000000; i++) {\n      rowBatch.selectedInUse = false;\n      rowBatch.size = VectorizedRowBatch.DEFAULT_SIZE;\n", "refactored_code": "  private static final int DEFAULT_ITER_TIME = 1000000;\n  @Warmup(iterations = 2, time = 2, timeUnit = TimeUnit.MILLISECONDS)\n  @Measurement(iterations = 2, time = 2, timeUnit = TimeUnit.MILLISECONDS)\n  public void bench() throws HiveException {\n    for (int i = 0; i < DEFAULT_ITER_TIME; i++) {\n      rowBatch.selectedInUse = false;\n      rowBatch.size = VectorizedRowBatch.DEFAULT_SIZE;\n"}
{"magic_number_smell": "  private static MiniHiveKdc miniHiveKdc = null;\n\n  @ClassRule\n  public static final WireMockRule MOCK_JWKS_SERVER = new WireMockRule(8089);\n\n  @BeforeClass\n  public static void setUpBeforeClass() throws Exception {", "refactored_code": "  private static final int MOCK_JWKS_SERVER_PORT = 8089;\n  private static MiniHiveKdc miniHiveKdc = null;\n\n  @ClassRule\n  public static final WireMockRule MOCK_JWKS_SERVER = new WireMockRule(MOCK_JWKS_SERVER_PORT);\n\n  @BeforeClass\n  public static void setUpBeforeClass() throws Exception {"}
{"magic_number_smell": "    new File(\"src/test/resources/auth.jwt/jwt-verification-jwks.json\");\n\n  @ClassRule\n  public static final WireMockRule MOCK_JWKS_SERVER = new WireMockRule(8089);\n\n  @Before\n  public void setUp() throws Exception {", "refactored_code": "  private static final int MOCK_JWKS_SERVER_PORT = 8089;\n    new File(\"src/test/resources/auth.jwt/jwt-verification-jwks.json\");\n\n  @ClassRule\n  public static final WireMockRule MOCK_JWKS_SERVER = new WireMockRule(MOCK_JWKS_SERVER_PORT);\n\n  @Before\n  public void setUp() throws Exception {"}
{"magic_number_smell": "  }\n\n  private void addHouseKeepingThreadConfigs() throws Exception {\n    conf.setTimeDuration(METASTORE_THREAD_TASK_FREQ_CONF, 1,\n                          TimeUnit.MILLISECONDS);\n    addStatsUpdaterThreadConfigs();\n    addReplChangeManagerConfigs();", "refactored_code": "  private static final long REMOTE_TASKS_INTERVAL = 1;\n  }\n\n  private void addHouseKeepingThreadConfigs() throws Exception {\n    conf.setTimeDuration(METASTORE_THREAD_TASK_FREQ_CONF, REMOTE_TASKS_INTERVAL,\n                          TimeUnit.MILLISECONDS);\n    addStatsUpdaterThreadConfigs();\n    addReplChangeManagerConfigs();"}
{"magic_number_smell": "      next = Integer.parseInt(ReplDumpWork.getTestInjectDumpDir()) + 1;\n      Path ackPath = new Path(dumpRoot, String.valueOf(next) + File.separator + ReplUtils.REPL_HIVE_BASE_DIR\n              + File.separator + ReplAck.LOAD_ACKNOWLEDGEMENT.toString());\n      waitForAck(fs, ackPath, 5 * 60 * 1000L);\n      replica.run(\"use \" + replicatedDbName)\n              .run(\"show tables like 't1'\")\n              .verifyResult(\"t1\")", "refactored_code": "  private static final long DEFAULT_PROBE_TIMEOUT = 5 * 60 * 1000L; // 5 minutes\n      next = Integer.parseInt(ReplDumpWork.getTestInjectDumpDir()) + 1;\n      Path ackPath = new Path(dumpRoot, String.valueOf(next) + File.separator + ReplUtils.REPL_HIVE_BASE_DIR\n              + File.separator + ReplAck.LOAD_ACKNOWLEDGEMENT.toString());\n      waitForAck(fs, ackPath, DEFAULT_PROBE_TIMEOUT);\n      replica.run(\"use \" + replicatedDbName)\n              .run(\"show tables like 't1'\")\n              .verifyResult(\"t1\")"}
{"magic_number_smell": "    // getXXX returns 0 for numeric types, false for boolean and null for other\n    assertEquals(0, res.getInt(1));\n    assertEquals(false, res.getBoolean(2));\n    assertEquals(0d, res.getDouble(3), 0.0001f);\n    assertEquals(null, res.getString(4));\n    assertEquals(null, res.getString(5));\n    assertEquals(null, res.getString(6));", "refactored_code": "  private static final float floatCompareDelta = 0.0001f;\n    // getXXX returns 0 for numeric types, false for boolean and null for other\n    assertEquals(0, res.getInt(1));\n    assertEquals(false, res.getBoolean(2));\n    assertEquals(0d, res.getDouble(3), floatCompareDelta);\n    assertEquals(null, res.getString(4));\n    assertEquals(null, res.getString(5));\n    assertEquals(null, res.getString(6));"}
{"magic_number_smell": "    // getXXX returns 0 for numeric types, false for boolean and null for other\n    assertEquals(0, res.getInt(1));\n    assertEquals(false, res.getBoolean(2));\n    assertEquals(0d, res.getDouble(3), 0.0001f);\n    assertEquals(null, res.getString(4));\n    assertEquals(null, res.getString(5));\n    assertEquals(null, res.getString(6));", "refactored_code": "  private static final float floatCompareDelta = 0.0001f;\n    // getXXX returns 0 for numeric types, false for boolean and null for other\n    assertEquals(0, res.getInt(1));\n    assertEquals(false, res.getBoolean(2));\n    assertEquals(0d, res.getDouble(3), floatCompareDelta);\n    assertEquals(null, res.getString(4));\n    assertEquals(null, res.getString(5));\n    assertEquals(null, res.getString(6));"}
{"magic_number_smell": "\n  private static final int 8089 = 8089;\n  @ClassRule\n  public static final WireMockRule MOCK_JWKS_SERVER = new WireMockRule(8089);\n\n  /**\n   * This is a hack to make environment variables modifiable.", "refactored_code": "  private static final int MOCK_JWKS_SERVER_PORT = 8089;\n\n  private static final int MOCK_JWKS_SERVER_PORT = 8089;\n  @ClassRule\n  public static final WireMockRule MOCK_JWKS_SERVER = new WireMockRule(MOCK_JWKS_SERVER_PORT);\n\n  /**\n   * This is a hack to make environment variables modifiable."}
{"magic_number_smell": "  }\n\n  private CuratorFramework getClient() {\n    return CuratorFrameworkFactory.builder().connectString(server.getConnectString()).sessionTimeoutMs(1000 * 100)\n        .connectionTimeoutMs(1000).retryPolicy(new RetryOneTime(1)).build();\n  }\n", "refactored_code": "  private static final int TIMEOUT = 1000;\n  }\n\n  private CuratorFramework getClient() {\n    return CuratorFrameworkFactory.builder().connectString(server.getConnectString()).sessionTimeoutMs(TIMEOUT * 100)\n        .connectionTimeoutMs(TIMEOUT).retryPolicy(new RetryOneTime(1)).build();\n  }\n"}
{"magic_number_smell": "\n  @Parameters(name = \"{0}\")\n  public static List<Object[]> getParameters() throws Exception {\n    return SplitSupport.process(adapter.getParameters(), TestCliDriver.class, 17);\n  }\n\n  @ClassRule", "refactored_code": "  private static final int N_SPLITS = 17;\n\n  @Parameters(name = \"{0}\")\n  public static List<Object[]> getParameters() throws Exception {\n    return SplitSupport.process(adapter.getParameters(), TestCliDriver.class, N_SPLITS);\n  }\n\n  @ClassRule"}
{"magic_number_smell": "\n  @Parameters(name = \"{0}\")\n  public static List<Object[]> getParameters() throws Exception {\n    return SplitSupport.process(adapter.getParameters(), TestEncryptedHDFSCliDriver.class, 3);\n  }\n\n  @ClassRule", "refactored_code": "  private static final int N_SPLITS = 3;\n\n  @Parameters(name = \"{0}\")\n  public static List<Object[]> getParameters() throws Exception {\n    return SplitSupport.process(adapter.getParameters(), TestEncryptedHDFSCliDriver.class, N_SPLITS);\n  }\n\n  @ClassRule"}
{"magic_number_smell": "\n  @Parameters(name = \"{0}\")\n  public static List<Object[]> getParameters() throws Exception {\n    return SplitSupport.process(adapter.getParameters(), TestMiniLlapCliDriver.class, 3);\n  }\n\n  @ClassRule", "refactored_code": "  private static final int N_SPLITS = 3;\n\n  @Parameters(name = \"{0}\")\n  public static List<Object[]> getParameters() throws Exception {\n    return SplitSupport.process(adapter.getParameters(), TestMiniLlapCliDriver.class, N_SPLITS);\n  }\n\n  @ClassRule"}
{"magic_number_smell": "   * @param port the port to check for availability\n   */\n  public static boolean available(int port) {\n    if (port < 60000 || port > MAX_PORT_NUMBER) {\n      throw new IllegalArgumentException(\"Invalid start port: \" + port);\n    }\n", "refactored_code": "  private static final int MIN_PORT_NUMBER = 60000;\n   * @param port the port to check for availability\n   */\n  public static boolean available(int port) {\n    if (port < MIN_PORT_NUMBER || port > MAX_PORT_NUMBER) {\n      throw new IllegalArgumentException(\"Invalid start port: \" + port);\n    }\n"}
{"magic_number_smell": "  public SingleNodeKafkaCluster(String name, String logDir, Integer zkPort, Integer brokerPort){\n    super(name);\n    Properties properties = new Properties();\n    this.brokerPort = brokerPort == null ? 9092 : brokerPort;\n    File dir = new File(logDir);\n    if (dir.exists()) {\n      // need to clean data directory to ensure that there is no interference from old runs", "refactored_code": "  private static final int BROKER_PORT = 9092;\n  public SingleNodeKafkaCluster(String name, String logDir, Integer zkPort, Integer brokerPort){\n    super(name);\n    Properties properties = new Properties();\n    this.brokerPort = brokerPort == null ? BROKER_PORT : brokerPort;\n    File dir = new File(logDir);\n    if (dir.exists()) {\n      // need to clean data directory to ensure that there is no interference from old runs"}
{"magic_number_smell": "    util = new HBaseTestingUtility(hbaseConf);\n\n    util.startMiniDFSCluster(1);\n    hbaseCluster = util.startMiniHBaseCluster(1, 1);\n    hbaseConn = util.getConnection();\n\n    // opening the META table ensures that cluster is running", "refactored_code": "  private static final int NUM_REGIONSERVERS = 1;\n    util = new HBaseTestingUtility(hbaseConf);\n\n    util.startMiniDFSCluster(1);\n    hbaseCluster = util.startMiniHBaseCluster(1, NUM_REGIONSERVERS);\n    hbaseConn = util.getConnection();\n\n    // opening the META table ensures that cluster is running"}
{"magic_number_smell": "  }\n\n  private String truncatefNeeded(String orig) {\n    if (orig.length() > 2000) {\n      return orig.substring(0, 2000) + \"\\r\\n\" + TRUNCATED_OUTPUT;\n    } else {\n      return orig;", "refactored_code": "  private static final short MAX_OUTPUT_CHAR_LENGTH = 2000;\n  }\n\n  private String truncatefNeeded(String orig) {\n    if (orig.length() > MAX_OUTPUT_CHAR_LENGTH) {\n      return orig.substring(0, MAX_OUTPUT_CHAR_LENGTH) + \"\\r\\n\" + TRUNCATED_OUTPUT;\n    } else {\n      return orig;"}
{"magic_number_smell": "              printDockerEvents();\n              throw new RuntimeException(\"Failed to get docker logs\");\n            }\n        } while (startTime + 5 * 60 * 1000 >= System.currentTimeMillis() && !isContainerReady(pr));\n        if (startTime + 5 * 60 * 1000 < System.currentTimeMillis()) {\n          printDockerEvents();\n          throw new RuntimeException(", "refactored_code": "    private static final int MAX_STARTUP_WAIT = 5 * 60 * 1000;\n              printDockerEvents();\n              throw new RuntimeException(\"Failed to get docker logs\");\n            }\n        } while (startTime + MAX_STARTUP_WAIT >= System.currentTimeMillis() && !isContainerReady(pr));\n        if (startTime + MAX_STARTUP_WAIT < System.currentTimeMillis()) {\n          printDockerEvents();\n          throw new RuntimeException("}
{"magic_number_smell": "    private boolean isMetastoreSecure;\n    private String metastoreServerPrincipal;\n    private String metastoreServerKeyTab;\n    private int dataNodes = 4; // default number of datanodes for miniHS2\n\n    public Builder() {\n    }", "refactored_code": "  private static final int DEFAULT_DATANODE_COUNT = 4;\n    private boolean isMetastoreSecure;\n    private String metastoreServerPrincipal;\n    private String metastoreServerKeyTab;\n    private int dataNodes = DEFAULT_DATANODE_COUNT; // default number of datanodes for miniHS2\n\n    public Builder() {\n    }"}
{"magic_number_smell": "  }\n\n  /**\n   *  Returns the value of 128.\n   *\n   */\n  public int getMaxColumnNameLength() throws SQLException {", "refactored_code": "  private static final int maxColumnNameLength = 128;\n  }\n\n  /**\n   *  Returns the value of maxColumnNameLength.\n   *\n   */\n  public int getMaxColumnNameLength() throws SQLException {"}
{"magic_number_smell": "    timeoutInMs = Integer.parseInt(\n        connectionParams.getSessionVars()\n            .getOrDefault(JdbcConnectionParams.AUTH_BROWSER_RESPONSE_TIMEOUT_SECS,\n                String.valueOf(120))) * 1000L;\n  }\n\n  @Override", "refactored_code": "  private static final int DEFAULT_SOCKET_TIMEOUT_SECS = 120;\n    timeoutInMs = Integer.parseInt(\n        connectionParams.getSessionVars()\n            .getOrDefault(JdbcConnectionParams.AUTH_BROWSER_RESPONSE_TIMEOUT_SECS,\n                String.valueOf(DEFAULT_SOCKET_TIMEOUT_SECS))) * 1000L;\n  }\n\n  @Override"}
{"magic_number_smell": "\n\n  protected int getFetchSize(Configuration conf) {\n    return conf.getInt(JdbcStorageConfig.JDBC_FETCH_SIZE.getPropertyName(), 1000);\n  }\n\n  @Override", "refactored_code": "  protected static final int DEFAULT_FETCH_SIZE = 1000;\n\n\n  protected int getFetchSize(Configuration conf) {\n    return conf.getInt(JdbcStorageConfig.JDBC_FETCH_SIZE.getPropertyName(), DEFAULT_FETCH_SIZE);\n  }\n\n  @Override"}
{"magic_number_smell": "\n  private static long nextRetrySleepMillis(final int nTry) {\n    final double fuzzyMultiplier = Math.min(Math.max(1 + 0.2 * ThreadLocalRandom.current().nextGaussian(), 0), 2);\n    return (long) (Math.min(60000, BASE_SLEEP_MILLIS * Math.pow(2, nTry - 1)) * fuzzyMultiplier);\n  }\n}\n", "refactored_code": "  private static final long MAX_SLEEP_MILLIS = 60000;\n\n  private static long nextRetrySleepMillis(final int nTry) {\n    final double fuzzyMultiplier = Math.min(Math.max(1 + 0.2 * ThreadLocalRandom.current().nextGaussian(), 0), 2);\n    return (long) (Math.min(MAX_SLEEP_MILLIS, BASE_SLEEP_MILLIS * Math.pow(2, nTry - 1)) * fuzzyMultiplier);\n  }\n}\n"}
{"magic_number_smell": "  private static final String TOPIC = \"test-tx-producer\";\n  private static final List<ProducerRecord<byte[], byte[]>>\n      RECORDS =\n      IntStream.range(0, 17384).mapToObj(number -> {\n        final byte[] value = (\"VALUE-\" + number).getBytes(StandardCharsets.UTF_8);\n        return new ProducerRecord<>(TOPIC, value, KEY_BYTES);\n      }).collect(Collectors.toList());", "refactored_code": "  private static final int RECORD_NUMBER = 17384;\n  private static final String TOPIC = \"test-tx-producer\";\n  private static final List<ProducerRecord<byte[], byte[]>>\n      RECORDS =\n      IntStream.range(0, RECORD_NUMBER).mapToObj(number -> {\n        final byte[] value = (\"VALUE-\" + number).getBytes(StandardCharsets.UTF_8);\n        return new ProducerRecord<>(TOPIC, value, KEY_BYTES);\n      }).collect(Collectors.toList());"}
{"magic_number_smell": "  }\n\n  private static List<ConsumerRecord<byte[], byte[]>> getRecords(String topic) {\n    return IntStream.range(0, 19384).mapToObj(number -> {\n      final byte[] value = (\"VALUE-\" + Integer.toString(number)).getBytes(Charset.forName(\"UTF-8\"));\n      return new ConsumerRecord<>(topic, 0, (long) number, 0L, null, 0L, 0, 0, KEY_BYTES, value);\n    }).collect(Collectors.toList());", "refactored_code": "  private static final int RECORD_NUMBER = 19384;\n  }\n\n  private static List<ConsumerRecord<byte[], byte[]>> getRecords(String topic) {\n    return IntStream.range(0, RECORD_NUMBER).mapToObj(number -> {\n      final byte[] value = (\"VALUE-\" + Integer.toString(number)).getBytes(Charset.forName(\"UTF-8\"));\n      return new ConsumerRecord<>(topic, 0, (long) number, 0L, null, 0L, 0, 0, KEY_BYTES, value);\n    }).collect(Collectors.toList());"}
{"magic_number_smell": "    private static final KafkaBrokerResource KAFKA_BROKER_RESOURCE = new KafkaBrokerResource();\n\n    private static List<ConsumerRecord<byte[], byte[]>> getRecords(String topic) {\n        return IntStream.range(0, 17384).mapToObj(number -> {\n            final byte[] value = (\"VALUE-\" + Integer.toString(number)).getBytes(Charset.forName(\"UTF-8\"));\n            return new ConsumerRecord<>(topic, 0, (long) number, 0L, null, 0L, 0, 0, KEY_BYTES, value);\n        }).collect(Collectors.toList());", "refactored_code": "    private static final int RECORD_NUMBER = 17384;\n    private static final KafkaBrokerResource KAFKA_BROKER_RESOURCE = new KafkaBrokerResource();\n\n    private static List<ConsumerRecord<byte[], byte[]>> getRecords(String topic) {\n        return IntStream.range(0, RECORD_NUMBER).mapToObj(number -> {\n            final byte[] value = (\"VALUE-\" + Integer.toString(number)).getBytes(Charset.forName(\"UTF-8\"));\n            return new ConsumerRecord<>(topic, 0, (long) number, 0L, null, 0L, 0, 0, KEY_BYTES, value);\n        }).collect(Collectors.toList());"}
{"magic_number_smell": "  private static final byte[] KEY_BYTES = \"KEY\".getBytes(Charset.forName(\"UTF-8\"));\n  private static final KafkaBrokerResource KAFKA_BROKER_RESOURCE = new KafkaBrokerResource();\n  private static final List<KafkaWritable> RECORDS_WRITABLES = IntStream\n      .range(0, 17384)\n      .mapToObj(number -> {\n        final byte[] value = (\"VALUE-\" + Integer.toString(number)).getBytes(Charset.forName(\"UTF-8\"));\n        return new KafkaWritable(0, (long) number, value, KEY_BYTES);", "refactored_code": "  private static final int RECORD_NUMBER = 17384;\n  private static final byte[] KEY_BYTES = \"KEY\".getBytes(Charset.forName(\"UTF-8\"));\n  private static final KafkaBrokerResource KAFKA_BROKER_RESOURCE = new KafkaBrokerResource();\n  private static final List<KafkaWritable> RECORDS_WRITABLES = IntStream\n      .range(0, RECORD_NUMBER)\n      .mapToObj(number -> {\n        final byte[] value = (\"VALUE-\" + Integer.toString(number)).getBytes(Charset.forName(\"UTF-8\"));\n        return new KafkaWritable(0, (long) number, value, KEY_BYTES);"}
{"magic_number_smell": "  private static final int 1000 = 1000;\n  private static final byte[] KEY_BYTES = \"key\".getBytes();\n  private static final List<KafkaWritable> RECORDS_WRITABLES = IntStream\n      .range(0, 1000)\n      .mapToObj(number -> {\n        final byte[] value = (\"VALUE-\" + Integer.toString(number)).getBytes(Charset.forName(\"UTF-8\"));\n        return new KafkaWritable(0, (long) number, value, KEY_BYTES);", "refactored_code": "  private static final int RECORD_NUMBER = 1000;\n  private static final int RECORD_NUMBER = 1000;\n  private static final byte[] KEY_BYTES = \"key\".getBytes();\n  private static final List<KafkaWritable> RECORDS_WRITABLES = IntStream\n      .range(0, RECORD_NUMBER)\n      .mapToObj(number -> {\n        final byte[] value = (\"VALUE-\" + Integer.toString(number)).getBytes(Charset.forName(\"UTF-8\"));\n        return new KafkaWritable(0, (long) number, value, KEY_BYTES);"}
{"magic_number_smell": "    ROW.addDouble(\"double\", 1.1d);\n    ROW.addString(\"string\", \"one\");\n    ROW.addBinary(\"binary\", \"one\".getBytes(UTF_8));\n    ROW.addTimestamp(\"timestamp\", new Timestamp(System.currentTimeMillis()));\n    ROW.addDecimal(\"decimal\", new BigDecimal(\"1.111\"));\n    ROW.setNull(\"null\");\n    // Not setting the \"default\" column.", "refactored_code": "  private static final long NOW_MS = System.currentTimeMillis();\n    ROW.addDouble(\"double\", 1.1d);\n    ROW.addString(\"string\", \"one\");\n    ROW.addBinary(\"binary\", \"one\".getBytes(UTF_8));\n    ROW.addTimestamp(\"timestamp\", new Timestamp(NOW_MS));\n    ROW.addDecimal(\"decimal\", new BigDecimal(\"1.111\"));\n    ROW.setNull(\"null\");\n    // Not setting the \"default\" column."}
{"magic_number_smell": "      row.addDouble(\"double\", 1.1d);\n      row.addString(\"string\", \"one\");\n      row.addBinary(\"binary\", \"one\".getBytes(UTF_8));\n      row.addTimestamp(\"timestamp\", new Timestamp(System.currentTimeMillis()));\n      row.addDecimal(\"decimal\", new BigDecimal(\"1.111\"));\n      row.setNull(\"null\");\n      // Not setting the \"default\" column.", "refactored_code": "  private static final long NOW_MS = System.currentTimeMillis();\n      row.addDouble(\"double\", 1.1d);\n      row.addString(\"string\", \"one\");\n      row.addBinary(\"binary\", \"one\".getBytes(UTF_8));\n      row.addTimestamp(\"timestamp\", new Timestamp(NOW_MS));\n      row.addDecimal(\"decimal\", new BigDecimal(\"1.111\"));\n      row.setNull(\"null\");\n      // Not setting the \"default\" column."}
{"magic_number_smell": "    ROW.addDouble(\"double\", 1.1d);\n    ROW.addString(\"string\", \"one\");\n    ROW.addBinary(\"binary\", \"one\".getBytes(UTF_8));\n    ROW.addTimestamp(\"timestamp\", new Timestamp(System.currentTimeMillis()));\n    ROW.addDecimal(\"decimal\", new BigDecimal(\"1.111\"));\n    ROW.setNull(\"null\");\n    // Not setting the \"default\" column.", "refactored_code": "  private static final long NOW_MS = System.currentTimeMillis();\n    ROW.addDouble(\"double\", 1.1d);\n    ROW.addString(\"string\", \"one\");\n    ROW.addBinary(\"binary\", \"one\".getBytes(UTF_8));\n    ROW.addTimestamp(\"timestamp\", new Timestamp(NOW_MS));\n    ROW.addDecimal(\"decimal\", new BigDecimal(\"1.111\"));\n    ROW.setNull(\"null\");\n    // Not setting the \"default\" column."}
{"magic_number_smell": "    before.addDouble(\"double\", 1.1d);\n    before.addString(\"string\", \"one\");\n    before.addBinary(\"binary\", \"one\".getBytes(UTF_8));\n    before.addTimestamp(\"timestamp\", new Timestamp(System.currentTimeMillis()));\n    before.addDecimal(\"decimal\", new BigDecimal(\"1.111\"));\n    before.setNull(\"null\");\n    before.addInt(\"default\", 1);", "refactored_code": "  private static final long NOW_MS = System.currentTimeMillis();\n    before.addDouble(\"double\", 1.1d);\n    before.addString(\"string\", \"one\");\n    before.addBinary(\"binary\", \"one\".getBytes(UTF_8));\n    before.addTimestamp(\"timestamp\", new Timestamp(NOW_MS));\n    before.addDecimal(\"decimal\", new BigDecimal(\"1.111\"));\n    before.setNull(\"null\");\n    before.addInt(\"default\", 1);"}
{"magic_number_smell": "      return;\n    }\n    LOG.info(\"Initializing periodic token refresh in AM, will run in every {}s\",\n        300);\n    tokenClient = new LlapTokenClient(conf);\n\n    newTokenChecker.scheduleAtFixedRate(this::fetchToken, 0, 300,", "refactored_code": "  private static final long LLAP_TOKEN_REFRESH_INTERVAL_IN_AM_SECONDS = 300;\n      return;\n    }\n    LOG.info(\"Initializing periodic token refresh in AM, will run in every {}s\",\n        LLAP_TOKEN_REFRESH_INTERVAL_IN_AM_SECONDS);\n    tokenClient = new LlapTokenClient(conf);\n\n    newTokenChecker.scheduleAtFixedRate(this::fetchToken, 0, LLAP_TOKEN_REFRESH_INTERVAL_IN_AM_SECONDS,"}
{"magic_number_smell": "      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:UpdateQueryResponseProto)\n      UpdateQueryResponseProtoOrBuilder {\n  private static final long 0L = 0L;\n    // Use UpdateQueryResponseProto.newBuilder() to construct.\n    private UpdateQueryResponseProto(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);", "refactored_code": "  private static final long serialVersionUID = 0L;\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:UpdateQueryResponseProto)\n      UpdateQueryResponseProtoOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use UpdateQueryResponseProto.newBuilder() to construct.\n    private UpdateQueryResponseProto(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);"}
{"magic_number_smell": "    @Override\n    public RESPONSE call() throws Exception {\n      boolean asyncMode = Client.isAsynchronousMode();\n      long deadline = System.currentTimeMillis() + 60000;\n      int numRetries = 0;\n      long nextBackoffMs = BACKOFF_START;\n      try {", "refactored_code": "    private final long TIMEOUT = 60000;\n    @Override\n    public RESPONSE call() throws Exception {\n      boolean asyncMode = Client.isAsynchronousMode();\n      long deadline = System.currentTimeMillis() + TIMEOUT;\n      int numRetries = 0;\n      long nextBackoffMs = BACKOFF_START;\n      try {"}
{"magic_number_smell": "          lockWaitSum += diff;\n          lockWaitMax = max(diff, lockWaitMax);\n\n          while (nanoTime() <= (start + toNano(5))) {\n            // spin for 5 ms (under lock)\n          }\n        } finally {", "refactored_code": "    public static final long LOCK_HOLD_TIME = 5;   ///< lock hold time in ms\n          lockWaitSum += diff;\n          lockWaitMax = max(diff, lockWaitMax);\n\n          while (nanoTime() <= (start + toNano(LOCK_HOLD_TIME))) {\n            // spin for LOCK_HOLD_TIME ms (under lock)\n          }\n        } finally {"}
{"magic_number_smell": "      long time = System.nanoTime();\n      long lastTime = lastLog.get();\n      // Magic value usage is invalid with nanoTime, so once in a 1000 years we may log extra.\n      boolean shouldLog = (lastTime == -1 || (time - lastTime) > 300 * 1000000000L);\n      if (shouldLog && !lastLog.compareAndSet(lastTime, time)) {\n        continue;\n      }", "refactored_code": "  private static final long MAX_DUMP_INTERVAL_NS = 300 * 1000000000L; // 5 minutes.\n      long time = System.nanoTime();\n      long lastTime = lastLog.get();\n      // Magic value usage is invalid with nanoTime, so once in a 1000 years we may log extra.\n      boolean shouldLog = (lastTime == -1 || (time - lastTime) > MAX_DUMP_INTERVAL_NS);\n      if (shouldLog && !lastLog.compareAndSet(lastTime, time)) {\n        continue;\n      }"}
{"magic_number_smell": "  private final class CleanupRunnable implements Runnable {\n    @Override\n    public void run() {\n      final long cleanupTimeNs = 3600 * 1000L, MIN_TIME_MS = 300 * 1000L * 1000000L;\n      long sleepTimeMs = 3600 * 1000L, MIN_TIME_MS = 300 * 1000L;\n      try {\n        while (true) {", "refactored_code": "  private static final long CLEANUP_TIME_MS = 3600 * 1000L, MIN_TIME_MS = 300 * 1000L;\n  private final class CleanupRunnable implements Runnable {\n    @Override\n    public void run() {\n      final long cleanupTimeNs = CLEANUP_TIME_MS * 1000000L;\n      long sleepTimeMs = CLEANUP_TIME_MS;\n      try {\n        while (true) {"}
{"magic_number_smell": "  boolean incRef() {\n    while (true) {\n      int value = refCount.get();\n      if (value == -1, EVICTING_REFCOUNT = -2) return false;\n      if (value == EVICTING_REFCOUNT) continue; // spin until it resolves; extremely rare\n      assert value >= 0;\n      if (refCount.compareAndSet(value, value + 1)) return true;", "refactored_code": "  private static final int EVICTED_REFCOUNT = -1, EVICTING_REFCOUNT = -2;\n  boolean incRef() {\n    while (true) {\n      int value = refCount.get();\n      if (value == EVICTED_REFCOUNT) return false;\n      if (value == EVICTING_REFCOUNT) continue; // spin until it resolves; extremely rare\n      assert value >= 0;\n      if (refCount.compareAndSet(value, value + 1)) return true;"}
{"magic_number_smell": "\n  /** ORC cache uses this to store compressed length; buffer is cached uncompressed, but\n   * the lookup is on compressed ranges, so we need to know this. */\n  public int declaredCachedLength = -1;\n\n\n  public void setStart(long start){", "refactored_code": "  public static final int UNKNOWN_CACHED_LENGTH = -1;\n\n  /** ORC cache uses this to store compressed length; buffer is cached uncompressed, but\n   * the lookup is on compressed ranges, so we need to know this. */\n  public int declaredCachedLength = UNKNOWN_CACHED_LENGTH;\n\n\n  public void setStart(long start){"}
{"magic_number_smell": "\n  public LowLevelCacheImpl(LlapDaemonCacheMetrics metrics, LowLevelCachePolicy cachePolicy,\n      Allocator allocator, boolean doAssumeGranularBlocks) {\n    this(metrics, cachePolicy, allocator, doAssumeGranularBlocks, 600);\n  }\n\n  @VisibleForTesting", "refactored_code": "  private static final int DEFAULT_CLEANUP_INTERVAL = 600;\n\n  public LowLevelCacheImpl(LlapDaemonCacheMetrics metrics, LowLevelCachePolicy cachePolicy,\n      Allocator allocator, boolean doAssumeGranularBlocks) {\n    this(metrics, cachePolicy, allocator, doAssumeGranularBlocks, DEFAULT_CLEANUP_INTERVAL);\n  }\n\n  @VisibleForTesting"}
{"magic_number_smell": "  }\n  private static final double 1 = 1; // f(0) is always 1\n  private double touchPriority(long time, long lastAccess, double previous) {\n    return 1 + f(time - lastAccess) * previous;\n  }\n  private double expirePriority(long time, long lastAccess, double previous) {\n    return f(time - lastAccess) * previous;", "refactored_code": "  private static final double F0 = 1; // f(0) is always 1\n  }\n  private static final double F0 = 1; // f(0) is always 1\n  private double touchPriority(long time, long lastAccess, double previous) {\n    return F0 + f(time - lastAccess) * previous;\n  }\n  private double expirePriority(long time, long lastAccess, double previous) {\n    return f(time - lastAccess) * previous;"}
{"magic_number_smell": "      LlapDaemonCacheMetrics metrics, LowLevelCachePolicy cachePolicy, Allocator allocator) {\n    this.cachePolicy = cachePolicy;\n    this.allocator = allocator;\n    this.cleanupInterval = 600;\n    this.metrics = metrics;\n    LlapIoImpl.LOG.info(\"SerDe low-level level cache; cleanup interval {} sec\", cleanupInterval);\n  }", "refactored_code": "  private static final int DEFAULT_CLEANUP_INTERVAL = 600;\n      LlapDaemonCacheMetrics metrics, LowLevelCachePolicy cachePolicy, Allocator allocator) {\n    this.cachePolicy = cachePolicy;\n    this.allocator = allocator;\n    this.cleanupInterval = DEFAULT_CLEANUP_INTERVAL;\n    this.metrics = metrics;\n    LlapIoImpl.LOG.info(\"SerDe low-level level cache; cleanup interval {} sec\", cleanupInterval);\n  }"}
{"magic_number_smell": "            CONFIG_TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETRY_POLICY_SPEC_DEFAULT));\n\n    conf.setLong(YarnConfiguration.RESOURCEMANAGER_CONNECT_MAX_WAIT_MS,\n        conf.getLong(CONFIG_YARN_RM_TIMEOUT_MAX_WAIT_MS, 10000L));\n    conf.setLong(YarnConfiguration.RESOURCEMANAGER_CONNECT_RETRY_INTERVAL_MS,\n        conf.getLong(CONFIG_YARN_RM_RETRY_INTERVAL_MS, CONFIG_YARN_RM_RETRY_INTERVAL_MS_DEFAULT));\n", "refactored_code": "  private static final long CONFIG_YARN_RM_TIMEOUT_MAX_WAIT_MS_DEFAULT = 10000L;\n            CONFIG_TIMELINE_SERVICE_ENTITYGROUP_FS_STORE_RETRY_POLICY_SPEC_DEFAULT));\n\n    conf.setLong(YarnConfiguration.RESOURCEMANAGER_CONNECT_MAX_WAIT_MS,\n        conf.getLong(CONFIG_YARN_RM_TIMEOUT_MAX_WAIT_MS, CONFIG_YARN_RM_TIMEOUT_MAX_WAIT_MS_DEFAULT));\n    conf.setLong(YarnConfiguration.RESOURCEMANAGER_CONNECT_RETRY_INTERVAL_MS,\n        conf.getLong(CONFIG_YARN_RM_RETRY_INTERVAL_MS, CONFIG_YARN_RM_RETRY_INTERVAL_MS_DEFAULT));\n"}
{"magic_number_smell": "          task.getVertexName(), \"\", task.getTaskAttemptID());\n\n      nextHeartbeatNumToLog = (Math.max(1,\n          (int) (5000 / (amPollInterval == 0 ? 0.000001f\n              : (float) amPollInterval))));\n    }\n", "refactored_code": "    private static final int LOG_COUNTER_START_INTERVAL = 5000; // 5 seconds\n          task.getVertexName(), \"\", task.getTaskAttemptID());\n\n      nextHeartbeatNumToLog = (Math.max(1,\n          (int) (LOG_COUNTER_START_INTERVAL / (amPollInterval == 0 ? 0.000001f\n              : (float) amPollInterval))));\n    }\n"}
{"magic_number_smell": "          // Handle the rejection outside of the lock\n          if (rejectedException != null) {\n            if (lastKillTimeMs != null\n                && (clock.getTime() - lastKillTimeMs) < 500) {\n              // We killed something, but still got rejected. Wait a bit to give a chance to our\n              // previous victim to actually die.\n              synchronized (lock) {", "refactored_code": "  private static final long PREEMPTION_KILL_GRACE_MS = 500; // 500ms\n          // Handle the rejection outside of the lock\n          if (rejectedException != null) {\n            if (lastKillTimeMs != null\n                && (clock.getTime() - lastKillTimeMs) < PREEMPTION_KILL_GRACE_MS) {\n              // We killed something, but still got rejected. Wait a bit to give a chance to our\n              // previous victim to actually die.\n              synchronized (lock) {"}
{"magic_number_smell": "  }\n\n  public static class LlapPeerRegistryServlet extends HttpServlet {\n    private static final long 1L = 1L;\n    protected transient JsonFactory jsonFactory;\n\n    @Override", "refactored_code": "    private static final long serialVersionUID = 1L;\n  }\n\n  public static class LlapPeerRegistryServlet extends HttpServlet {\n    private static final long serialVersionUID = 1L;\n    protected transient JsonFactory jsonFactory;\n\n    @Override"}
{"magic_number_smell": "    this.downstreamConsumer = consumer;\n    this.ioMetrics = ioMetrics;\n    this.mxBean = LlapUtil.initThreadMxBean();\n    cvbPool = new FixedSizedObjectPool<>(128, new Pool.PoolObjectHelper<ColumnVectorBatch>() {\n      @Override public ColumnVectorBatch create() {\n        return new ColumnVectorBatch(colCount);\n      }", "refactored_code": "  private static final int CVB_POOL_SIZE = 128;\n    this.downstreamConsumer = consumer;\n    this.ioMetrics = ioMetrics;\n    this.mxBean = LlapUtil.initThreadMxBean();\n    cvbPool = new FixedSizedObjectPool<>(CVB_POOL_SIZE, new Pool.PoolObjectHelper<ColumnVectorBatch>() {\n      @Override public ColumnVectorBatch create() {\n        return new ColumnVectorBatch(colCount);\n      }"}
{"magic_number_smell": "        DEFAULT_SHUFFLE_OS_CACHE_ALWAYS_EVICT);\n\n    readaheadLength = conf.getInt(SHUFFLE_READAHEAD_BYTES,\n        4 * 1024 * 1024);\n\n    maxShuffleConnections = conf.getInt(MAX_SHUFFLE_CONNECTIONS,\n        DEFAULT_MAX_SHUFFLE_CONNECTIONS);", "refactored_code": "  public static final int DEFAULT_SHUFFLE_READAHEAD_BYTES = 4 * 1024 * 1024;\n        DEFAULT_SHUFFLE_OS_CACHE_ALWAYS_EVICT);\n\n    readaheadLength = conf.getInt(SHUFFLE_READAHEAD_BYTES,\n        DEFAULT_SHUFFLE_READAHEAD_BYTES);\n\n    maxShuffleConnections = conf.getInt(MAX_SHUFFLE_CONNECTIONS,\n        DEFAULT_MAX_SHUFFLE_CONNECTIONS);"}
{"magic_number_smell": "    conf.setDouble(HiveConf.ConfVars.LLAP_LRFU_LAMBDA.varname, 1.0f);\n    conf.setInt(HiveConf.ConfVars.LLAP_LRFU_BP_WRAPPER_SIZE.varname, 1);\n    int minBufferSize = 1;\n    cachePolicy = new LowLevelLrfuCachePolicy(minBufferSize, 1024, conf);\n    memoryManager = new LowLevelCacheMemoryManager(1024, cachePolicy, CACHE_METRICS);\n    int maxAllocationSize = 1024;\n    int minAllocationSize = 8;", "refactored_code": "  private final long maxSize = 1024;\n    conf.setDouble(HiveConf.ConfVars.LLAP_LRFU_LAMBDA.varname, 1.0f);\n    conf.setInt(HiveConf.ConfVars.LLAP_LRFU_BP_WRAPPER_SIZE.varname, 1);\n    int minBufferSize = 1;\n    cachePolicy = new LowLevelLrfuCachePolicy(minBufferSize, maxSize, conf);\n    memoryManager = new LowLevelCacheMemoryManager(maxSize, cachePolicy, CACHE_METRICS);\n    int maxAllocationSize = 1024;\n    int minAllocationSize = 8;"}
{"magic_number_smell": "  public void verifyResult(DiskRangeList result, long... vals) {\n    for (int i = 0; i < vals.length; i += 3) {\n      switch ((int)vals[i]) {\n      case 0, DRL = 1: assertTrue(result instanceof IncompleteCb); break;\n      case DRL: assertFalse(result instanceof IncompleteCb); break;\n      default: fail();\n      }", "refactored_code": "  private static final int INCOMPLETE = 0, DRL = 1;\n  public void verifyResult(DiskRangeList result, long... vals) {\n    for (int i = 0; i < vals.length; i += 3) {\n      switch ((int)vals[i]) {\n      case INCOMPLETE: assertTrue(result instanceof IncompleteCb); break;\n      case DRL: assertFalse(result instanceof IncompleteCb); break;\n      default: fail();\n      }"}
{"magic_number_smell": "    srvAddress.set(serverSocket);\n\n    this.metrics = LlapDaemonExecutorMetrics\n        .create(\"ContinerRunerTests\", MetricsUtils.getUUID(), 1, waitQueueSize,\n            Ints.toArray(intervalList), 0, 0L, 0);\n\n    for (int i = 0; i < numLocalDirs; i++) {", "refactored_code": "  private final int numExecutors = 1;\n    srvAddress.set(serverSocket);\n\n    this.metrics = LlapDaemonExecutorMetrics\n        .create(\"ContinerRunerTests\", MetricsUtils.getUUID(), numExecutors, waitQueueSize,\n            Ints.toArray(intervalList), 0, 0L, 0);\n\n    for (int i = 0; i < numLocalDirs; i++) {"}
{"magic_number_smell": "  }\n\n  private static TypeInfo[] ArrayOf(Supplier<TypeInfo> supplier) {\n    return IntStream.range(0, 300).mapToObj(i -> supplier.get()).toArray(TypeInfo[]::new);\n  }\n}\n", "refactored_code": "  private static final int END_EXCLUSIVE = 300;\n  }\n\n  private static TypeInfo[] ArrayOf(Supplier<TypeInfo> supplier) {\n    return IntStream.range(0, END_EXCLUSIVE).mapToObj(i -> supplier.get()).toArray(TypeInfo[]::new);\n  }\n}\n"}
{"magic_number_smell": "        null, tracePool)) {\n      loader.init();\n\n      DiskRangeList range = new DiskRangeList(3, 296);\n      loader.loadRanges(range);\n\n      DataCache.BooleanRef gotAllData = new DataCache.BooleanRef();", "refactored_code": "  private static final int ORC_PADDING = 3;\n        null, tracePool)) {\n      loader.init();\n\n      DiskRangeList range = new DiskRangeList(ORC_PADDING, 296);\n      loader.loadRanges(range);\n\n      DataCache.BooleanRef gotAllData = new DataCache.BooleanRef();"}
{"magic_number_smell": "    FixedSizedObjectPool<ColumnVectorBatch> cvbPool = (FixedSizedObjectPool<ColumnVectorBatch>)\n        cvbPoolField.get(consumer);\n\n    ColumnVectorBatch cvb = new ColumnVectorBatch(2);\n    VectorizedRowBatch vrb = new VectorizedRowBatch(2);\n    createTestVectors(cvb, vrb);\n", "refactored_code": "  private static final int TEST_NUM_COLS = 2;\n    FixedSizedObjectPool<ColumnVectorBatch> cvbPool = (FixedSizedObjectPool<ColumnVectorBatch>)\n        cvbPoolField.get(consumer);\n\n    ColumnVectorBatch cvb = new ColumnVectorBatch(TEST_NUM_COLS);\n    VectorizedRowBatch vrb = new VectorizedRowBatch(TEST_NUM_COLS);\n    createTestVectors(cvb, vrb);\n"}
{"magic_number_smell": "\n  private static final int 1 = 1;\n\n  private static final long GUARANTEED_BIT_MASK = (1L << 1) - 1;\n\n  /**\n   * This is a hack to pass initial guaranteed information from {@link LlapTaskSchedulerService}", "refactored_code": "  private static final int GUARANTEED_WIDTH = 1;\n\n  private static final int GUARANTEED_WIDTH = 1;\n\n  private static final long GUARANTEED_BIT_MASK = (1L << GUARANTEED_WIDTH) - 1;\n\n  /**\n   * This is a hack to pass initial guaranteed information from {@link LlapTaskSchedulerService}"}
{"magic_number_smell": "      while (!isShutdown.get() && !Thread.currentThread().isInterrupted()) {\n        try {\n          NodeInfo nodeInfo =\n              disabledNodesQueue.poll(10000L, TimeUnit.MILLISECONDS);\n          if (nodeInfo != null) {\n            // A node became available. Enable the node and try scheduling.\n            reenableDisabledNode(nodeInfo);", "refactored_code": "    private static final long POLL_TIMEOUT = 10000L;\n      while (!isShutdown.get() && !Thread.currentThread().isInterrupted()) {\n        try {\n          NodeInfo nodeInfo =\n              disabledNodesQueue.poll(POLL_TIMEOUT, TimeUnit.MILLISECONDS);\n          if (nodeInfo != null) {\n            // A node became available. Enable the node and try scheduling.\n            reenableDisabledNode(nodeInfo);"}
{"magic_number_smell": "    if (metricsCollectionMs > 0) {\n      scheduledMetricsExecutor.scheduleAtFixedRate(() -> {\n        collectMetrics();\n      }, 10000L, metricsCollectionMs, TimeUnit.MILLISECONDS);\n    }\n  }\n", "refactored_code": "  private static final long INITIAL_DELAY_MSEC = 10000L;\n    if (metricsCollectionMs > 0) {\n      scheduledMetricsExecutor.scheduleAtFixedRate(() -> {\n        collectMetrics();\n      }, INITIAL_DELAY_MSEC, metricsCollectionMs, TimeUnit.MILLISECONDS);\n    }\n  }\n"}
{"magic_number_smell": "    collector = new LlapMetricsCollector(mockConf, mockExecutor, mockClientFactory);\n  }\n\n  @Test(timeout = 1000)\n  public void testAddService() {\n    // Given\n    LlapServiceInstance mockService = mock(LlapServiceInstance.class);", "refactored_code": "  private static final long DEFAULT_TIMEOUT = 1000;\n    collector = new LlapMetricsCollector(mockConf, mockExecutor, mockClientFactory);\n  }\n\n  @Test(timeout = DEFAULT_TIMEOUT)\n  public void testAddService() {\n    // Given\n    LlapServiceInstance mockService = mock(LlapServiceInstance.class);"}
{"magic_number_smell": "      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:HiveHookEventProto)\n      HiveHookEventProtoOrBuilder {\n  private static final long 0L = 0L;\n    // Use HiveHookEventProto.newBuilder() to construct.\n    private HiveHookEventProto(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);", "refactored_code": "  private static final long serialVersionUID = 0L;\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:HiveHookEventProto)\n      HiveHookEventProtoOrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use HiveHookEventProto.newBuilder() to construct.\n    private HiveHookEventProto(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);"}
{"magic_number_smell": "      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:Mesg1)\n      Mesg1OrBuilder {\n  private static final long 0L = 0L;\n    // Use Mesg1.newBuilder() to construct.\n    private Mesg1(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);", "refactored_code": "  private static final long serialVersionUID = 0L;\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:Mesg1)\n      Mesg1OrBuilder {\n  private static final long serialVersionUID = 0L;\n    // Use Mesg1.newBuilder() to construct.\n    private Mesg1(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);"}
{"magic_number_smell": "  }\n\n  public void unsetDone() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field done is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __DONE_ISSET_ID = 0;\n  }\n\n  public void unsetDone() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __DONE_ISSET_ID);\n  }\n\n  /** Returns true if field done is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetDone() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field done is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __DONE_ISSET_ID = 0;\n  }\n\n  public void unsetDone() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __DONE_ISSET_ID);\n  }\n\n  /** Returns true if field done is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetDone() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field done is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __DONE_ISSET_ID = 0;\n  }\n\n  public void unsetDone() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __DONE_ISSET_ID);\n  }\n\n  /** Returns true if field done is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetDone() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field done is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __DONE_ISSET_ID = 0;\n  }\n\n  public void unsetDone() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __DONE_ISSET_ID);\n  }\n\n  /** Returns true if field done is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetDone() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field done is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __DONE_ISSET_ID = 0;\n  }\n\n  public void unsetDone() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __DONE_ISSET_ID);\n  }\n\n  /** Returns true if field done is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "      LOG.warn(\"LlapOutputFormatService does not appear to have a listening port to close.\");\n    }\n\n    eventLoopGroup.shutdownGracefully(1, 5, TimeUnit.SECONDS).sync();\n  }\n\n  @SuppressWarnings(\"unchecked\")", "refactored_code": "  private static final int WAIT_TIME = 5;\n      LOG.warn(\"LlapOutputFormatService does not appear to have a listening port to close.\");\n    }\n\n    eventLoopGroup.shutdownGracefully(1, WAIT_TIME, TimeUnit.SECONDS).sync();\n  }\n\n  @SuppressWarnings(\"unchecked\")"}
{"magic_number_smell": "  }\n\n  public static Object buildCacheKey(Object fileId, int schemaHash) {\n    if (schemaHash == -1) {\n      return fileId;\n    } else {\n      return new SchemaAwareCacheKey(fileId, schemaHash);", "refactored_code": "  public static final int NO_SCHEMA_HASH = -1;\n  }\n\n  public static Object buildCacheKey(Object fileId, int schemaHash) {\n    if (schemaHash == NO_SCHEMA_HASH) {\n      return fileId;\n    } else {\n      return new SchemaAwareCacheKey(fileId, schemaHash);"}
{"magic_number_smell": "          }\n        }\n      };\n      ShutdownHookManager.addShutdownHook(txnRollbackRunner, 0);\n    } catch (LockException e) {\n      ErrorMsg error = ErrorMsg.getErrorMsg(e.getMessage());\n      String errorMessage = \"FAILED: \" + e.getClass().getSimpleName() + \" [Error \"  + error.getErrorCode()  + \"]:\";", "refactored_code": "  private static final int SHUTDOWN_HOOK_PRIORITY = 0;\n          }\n        }\n      };\n      ShutdownHookManager.addShutdownHook(txnRollbackRunner, SHUTDOWN_HOOK_PRIORITY);\n    } catch (LockException e) {\n      ErrorMsg error = ErrorMsg.getErrorMsg(e.getMessage());\n      String errorMessage = \"FAILED: \" + e.getClass().getSimpleName() + \" [Error \"  + error.getErrorCode()  + \"]:\";"}
{"magic_number_smell": "          return runner;\n        }\n      }\n      wait(2000);\n    }\n    return null;\n  }", "refactored_code": "  private static final int SLEEP_TIME = 2000;\n          return runner;\n        }\n      }\n      wait(SLEEP_TIME);\n    }\n    return null;\n  }"}
{"magic_number_smell": "    }\n\n    // metastore schema only allows maximum 255 for constraint name column\n    if (constraintName != null && constraintName.length() > 255) {\n      throw new SemanticException(ErrorMsg.INVALID_CSTR_SYNTAX.getMsg(\"Constraint name: \" + constraintName +\n          \" exceeded maximum allowed length: \" + 255));\n    }", "refactored_code": "  private static final int CONSTRAINT_MAX_LENGTH = 255;\n    }\n\n    // metastore schema only allows maximum 255 for constraint name column\n    if (constraintName != null && constraintName.length() > CONSTRAINT_MAX_LENGTH) {\n      throw new SemanticException(ErrorMsg.INVALID_CSTR_SYNTAX.getMsg(\"Constraint name: \" + constraintName +\n          \" exceeded maximum allowed length: \" + CONSTRAINT_MAX_LENGTH));\n    }"}
{"magic_number_smell": "   * Partition description.\n   */\n  public static class PartitionDesc implements Serializable {\n    private static final long 1L = 1L;\n\n    private final ExprNodeGenericFuncDesc partSpec;\n    // TODO: see if we can get rid of this... used in one place to distinguish archived parts", "refactored_code": "  private static final long serialVersionUID = 1L;\n   * Partition description.\n   */\n  public static class PartitionDesc implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n    private final ExprNodeGenericFuncDesc partSpec;\n    // TODO: see if we can get rid of this... used in one place to distinguish archived parts"}
{"magic_number_smell": "        } else if (key2 == null) {\n            return nullOrdering == null ? 1 : -nullOrdering.getNullValueOption().getCmpReturnValue();\n        } else {\n            return 2;\n        }\n    }\n", "refactored_code": "    protected final int not_null = 2;\n        } else if (key2 == null) {\n            return nullOrdering == null ? 1 : -nullOrdering.getNullValueOption().getCmpReturnValue();\n        } else {\n            return not_null;\n        }\n    }\n"}
{"magic_number_smell": "  /**\n   * Try store the non-vectorized key.\n   * @param key Serialized key.\n   * @return TopNHash.-1 if the row should be forwarded;\n   *         TopNHash.EXCLUDED if the row should be discarded;\n   *         any other number if the row is to be stored; the index should be passed to storeValue.\n   */", "refactored_code": "  public static final int FORWARD = -1; // Forward the row to reducer as is.\n  /**\n   * Try store the non-vectorized key.\n   * @param key Serialized key.\n   * @return TopNHash.FORWARD if the row should be forwarded;\n   *         TopNHash.EXCLUDED if the row should be discarded;\n   *         any other number if the row is to be stored; the index should be passed to storeValue.\n   */"}
{"magic_number_smell": "\n    try {\n      byte[] buffer = new byte[1024];\n      int threshold = conf.getInt(\"mapred.throttle.threshold.percent\", 100);\n      int retry = conf.getInt(\"mapred.throttle.retry.period\", DEFAULT_RETRY_PERIOD);\n\n      // If the threshold is 100 percent, then there is no throttling", "refactored_code": "  private static final int DEFAULT_MEMORY_GC_PERCENT = 100;\n\n    try {\n      byte[] buffer = new byte[1024];\n      int threshold = conf.getInt(\"mapred.throttle.threshold.percent\", DEFAULT_MEMORY_GC_PERCENT);\n      int retry = conf.getInt(\"mapred.throttle.retry.period\", DEFAULT_RETRY_PERIOD);\n\n      // If the threshold is 100 percent, then there is no throttling"}
{"magic_number_smell": "   */\n  private Object[] array;\n  /**\n   * This is kind of tricky. Integer.MAX_VALUE number means unknown. Other positive numbers represent\n   * row length (see array javadoc). Non-positive numbers mean row length is zero (thus,\n   * array is empty); they represent (negated) number of rows (for joins w/o projections).\n   */", "refactored_code": "  private static final int UNKNOWN = Integer.MAX_VALUE;\n   */\n  private Object[] array;\n  /**\n   * This is kind of tricky. UNKNOWN number means unknown. Other positive numbers represent\n   * row length (see array javadoc). Non-positive numbers mean row length is zero (thus,\n   * array is empty); they represent (negated) number of rows (for joins w/o projections).\n   */"}
{"magic_number_smell": "    memoryUsed = 0;\n\n    if (useBloomFilter) {\n      if (newKeyCount <= 300000000) {\n        this.bloom1 = new BloomFilter(newKeyCount);\n      } else {\n        // To avoid having a huge BloomFilter we need to scale up False Positive Probability", "refactored_code": "  private final int BLOOM_FILTER_MAX_SIZE = 300000000;\n    memoryUsed = 0;\n\n    if (useBloomFilter) {\n      if (newKeyCount <= BLOOM_FILTER_MAX_SIZE) {\n        this.bloom1 = new BloomFilter(newKeyCount);\n      } else {\n        // To avoid having a huge BloomFilter we need to scale up False Positive Probability"}
{"magic_number_smell": "      long size = 0;\n      size += keySerDe == null ? 0 : jdm.object();\n      size += valSerDe == null ? 0 : jdm.object();\n      size += keySoi == null ? 0 : 16 * 1024L;\n      size += valSoi == null ? 0 : 16 * 1024L;\n      size += keyOis == null ? 0 : jdm.arrayList() + keyOis.size() * 16 * 1024L;\n      size += valOis == null ? 0 : jdm.arrayList() + valOis.size() * 16 * 1024L;", "refactored_code": "  public static final long DEFAULT_OBJECT_INSPECTOR_MEMORY_SIZE = 16 * 1024L;\n      long size = 0;\n      size += keySerDe == null ? 0 : jdm.object();\n      size += valSerDe == null ? 0 : jdm.object();\n      size += keySoi == null ? 0 : DEFAULT_OBJECT_INSPECTOR_MEMORY_SIZE;\n      size += valSoi == null ? 0 : DEFAULT_OBJECT_INSPECTOR_MEMORY_SIZE;\n      size += keyOis == null ? 0 : jdm.arrayList() + keyOis.size() * DEFAULT_OBJECT_INSPECTOR_MEMORY_SIZE;\n      size += valOis == null ? 0 : jdm.arrayList() + valOis.size() * DEFAULT_OBJECT_INSPECTOR_MEMORY_SIZE;"}
{"magic_number_smell": "  private LocalFileSystem localFs;\n\n  public RowContainer(Configuration jc, Reporter reporter) throws HiveException {\n    this(25000, jc, reporter);\n  }\n\n  public RowContainer(int bs, Configuration jc, Reporter reporter", "refactored_code": "  private static final int BLOCKSIZE = 25000;\n  private LocalFileSystem localFs;\n\n  public RowContainer(Configuration jc, Reporter reporter) throws HiveException {\n    this(BLOCKSIZE, jc, reporter);\n  }\n\n  public RowContainer(int bs, Configuration jc, Reporter reporter"}
{"magic_number_smell": "  }\n\n  public static long getSerialVersionUID() {\n    return 1L;\n  }\n\n  public String getSrcDB() {", "refactored_code": "  private static final long serialVersionUID = 1L;\n  }\n\n  public static long getSerialVersionUID() {\n    return serialVersionUID;\n  }\n\n  public String getSrcDB() {"}
{"magic_number_smell": "\n  private long getNextDelay(long currentDelay) {\n    if (currentDelay <= 0) { // in case initial delay was set to 0.\n      currentDelay = 60;\n    }\n\n    currentDelay *= this.backOff;", "refactored_code": "  private static final long MINIMUM_DELAY_IN_SEC = 60;\n\n  private long getNextDelay(long currentDelay) {\n    if (currentDelay <= 0) { // in case initial delay was set to 0.\n      currentDelay = MINIMUM_DELAY_IN_SEC;\n    }\n\n    currentDelay *= this.backOff;"}
{"magic_number_smell": "        private final int fileStatuses.size() = fileStatuses.size();\n        private final List<LocatedFileStatus> fileStatusesLocal = fileStatuses;\n        public boolean hasNext() throws IOException {\n          return idx < fileStatuses.size();\n        }\n        public LocatedFileStatus next() throws IOException {\n          LOG.info(\" file in next is \" + fileStatusesLocal.get(idx));", "refactored_code": "        private final int numEntry = fileStatuses.size();\n        private final int numEntry = fileStatuses.size();\n        private final List<LocatedFileStatus> fileStatusesLocal = fileStatuses;\n        public boolean hasNext() throws IOException {\n          return idx < numEntry;\n        }\n        public LocatedFileStatus next() throws IOException {\n          LOG.info(\" file in next is \" + fileStatusesLocal.get(idx));"}
{"magic_number_smell": "  public static final int POLICY_TYPE_ROWFILTER = 2;\n\n  public static final int[] POLICY_TYPES = new int[]{\n      0,\n      POLICY_TYPE_DATAMASK,\n      POLICY_TYPE_ROWFILTER,\n  };", "refactored_code": "  public static final int POLICY_TYPE_ACCESS = 0;\n  public static final int POLICY_TYPE_ROWFILTER = 2;\n\n  public static final int[] POLICY_TYPES = new int[]{\n      POLICY_TYPE_ACCESS,\n      POLICY_TYPE_DATAMASK,\n      POLICY_TYPE_ROWFILTER,\n  };"}
{"magic_number_smell": "    try {\n      for (Object value : values) {\n        if (rowIdx >= maxSize ||\n            (rowIdx > 0 && batchBytes >= VectorizedRowBatch.DEFAULT_BYTES)) {\n\n          // Batch is full AND we have at least 1 more row...\n          batch.size = rowIdx;", "refactored_code": "  private final int BATCH_BYTES = VectorizedRowBatch.DEFAULT_BYTES;\n    try {\n      for (Object value : values) {\n        if (rowIdx >= maxSize ||\n            (rowIdx > 0 && batchBytes >= BATCH_BYTES)) {\n\n          // Batch is full AND we have at least 1 more row...\n          batch.size = rowIdx;"}
{"magic_number_smell": "    }\n  }\n\n  private final AtomicInteger sessionState = new AtomicInteger(0, STATE_IN_USE = 1, STATE_EXPIRED = 2);\n  private Long expirationNs;\n  private final Manager parent;\n  private final SessionExpirationTracker expirationTracker;", "refactored_code": "  private static final int STATE_NONE = 0, STATE_IN_USE = 1, STATE_EXPIRED = 2;\n    }\n  }\n\n  private final AtomicInteger sessionState = new AtomicInteger(STATE_NONE);\n  private Long expirationNs;\n  private final Manager parent;\n  private final SessionExpirationTracker expirationTracker;"}
{"magic_number_smell": "  static final String CLASS_NAME = TezJobMonitor.class.getName();\n  private static final int 1000 = 1000;\n  private static final int MAX_RETRY_INTERVAL = 2500;\n  private static final int MAX_RETRY_FAILURES = (MAX_RETRY_INTERVAL / 1000) + 1;\n\n  private final PerfLogger perfLogger;\n  private static final List<DAGClient> shutdownList;", "refactored_code": "  private static final int MAX_CHECK_INTERVAL = 1000;\n  static final String CLASS_NAME = TezJobMonitor.class.getName();\n  private static final int MAX_CHECK_INTERVAL = 1000;\n  private static final int MAX_RETRY_INTERVAL = 2500;\n  private static final int MAX_RETRY_FAILURES = (MAX_RETRY_INTERVAL / MAX_CHECK_INTERVAL) + 1;\n\n  private final PerfLogger perfLogger;\n  private static final List<DAGClient> shutdownList;"}
{"magic_number_smell": "    if (s != null) {\n      float percent = total == 0 ? 0.0f : (float) complete / (float) total;\n      // lets use the remaining space in column 1 as progress bar\n      int spaceRemaining = 16 - s.length() - 1;\n      String trimmedVName = s;\n\n      // if the vertex name is longer than column 1 width, trim it down", "refactored_code": "  private static final int COLUMN_1_WIDTH = 16;\n    if (s != null) {\n      float percent = total == 0 ? 0.0f : (float) complete / (float) total;\n      // lets use the remaining space in column 1 as progress bar\n      int spaceRemaining = COLUMN_1_WIDTH - s.length() - 1;\n      String trimmedVName = s;\n\n      // if the vertex name is longer than column 1 width, trim it down"}
{"magic_number_smell": "      return this.initialDelayInSeconds;\n    }\n    if (currentDelay <= 0) { // in case initial delay was set to 0.\n      currentDelay = 60;\n    }\n    currentDelay *= this.backOff;\n    if (this.maxJitterInSeconds > 0) {", "refactored_code": "  private static final long MINIMUM_DELAY_IN_SEC = 60;\n      return this.initialDelayInSeconds;\n    }\n    if (currentDelay <= 0) { // in case initial delay was set to 0.\n      currentDelay = MINIMUM_DELAY_IN_SEC;\n    }\n    currentDelay *= this.backOff;\n    if (this.maxJitterInSeconds > 0) {"}
{"magic_number_smell": "    StackTraceElement[] stackTrace = e.getStackTrace();\n    int length = stackTrace.length;\n    boolean isTruncated = false;\n    if (length > 15) {\n      length = 15;\n      isTruncated = true;\n    }", "refactored_code": "  private static final int STACK_LENGTH_LIMIT = 15;\n    StackTraceElement[] stackTrace = e.getStackTrace();\n    int length = stackTrace.length;\n    boolean isTruncated = false;\n    if (length > STACK_LENGTH_LIMIT) {\n      length = STACK_LENGTH_LIMIT;\n      isTruncated = true;\n    }"}
{"magic_number_smell": "    // Choose array size. We have two hash tables to hold entries, so the sum\n    // of the two should have a bit more than twice as much space as the\n    // minimum required.\n    n = (int) (expectedSize * 1.0/0.40 / 2.0);\n\n    // some prime numbers spaced about at powers of 2 in magnitude\n", "refactored_code": "  private static final double PADDING_FACTOR = 1.0/0.40; // have minimum 40% fill factor\n    // Choose array size. We have two hash tables to hold entries, so the sum\n    // of the two should have a bit more than twice as much space as the\n    // minimum required.\n    n = (int) (expectedSize * PADDING_FACTOR / 2.0);\n\n    // some prime numbers spaced about at powers of 2 in magnitude\n"}
{"magic_number_smell": "    // Choose array size. We have two hash tables to hold entries, so the sum\n    // of the two should have a bit more than twice as much space as the\n    // minimum required.\n    n = (int) (expectedSize * 1.0/0.40 / 2.0);\n\n    // try to get prime number table size to have less dependence on good hash function\n    for (int i = 0; i != primes.length; i++) {", "refactored_code": "  private static final double PADDING_FACTOR = 1.0/0.40; // have minimum 40% fill factor\n    // Choose array size. We have two hash tables to hold entries, so the sum\n    // of the two should have a bit more than twice as much space as the\n    // minimum required.\n    n = (int) (expectedSize * PADDING_FACTOR / 2.0);\n\n    // try to get prime number table size to have less dependence on good hash function\n    for (int i = 0; i != primes.length; i++) {"}
{"magic_number_smell": "   * class for storing the current aggregate value.\n   */\n  private static final class Aggregation implements AggregationBuffer {\n    private static final long 1L = 1L;\n\n    BloomKFilter bf;\n", "refactored_code": "  private static final long serialVersionUID = 1L;\n   * class for storing the current aggregate value.\n   */\n  private static final class Aggregation implements AggregationBuffer {\n    private static final long serialVersionUID = 1L;\n\n    BloomKFilter bf;\n"}
{"magic_number_smell": "   * class for storing the current aggregate value.\n   */\n  static final class Aggregation implements AggregationBuffer {\n    private static final long 1L = 1L;\n\n    byte[] bfBytes;\n    private ExecutorService executor;", "refactored_code": "  private static final long serialVersionUID = 1L;\n   * class for storing the current aggregate value.\n   */\n  static final class Aggregation implements AggregationBuffer {\n    private static final long serialVersionUID = 1L;\n\n    byte[] bfBytes;\n    private ExecutorService executor;"}
{"magic_number_smell": "     */\n    static class Aggregation implements AggregationBuffer {\n\n      private static final long 1L = 1L;\n\n      transient private long count;\n", "refactored_code": "  private static final long serialVersionUID = 1L;\n     */\n    static class Aggregation implements AggregationBuffer {\n\n      private static final long serialVersionUID = 1L;\n\n      transient private long count;\n"}
{"magic_number_smell": "   */\n  static class Aggregation implements AggregationBuffer {\n\n    private static final long 1L = 1L;\n\n    private transient long value;\n", "refactored_code": "  private static final long serialVersionUID = 1L;\n   */\n  static class Aggregation implements AggregationBuffer {\n\n    private static final long serialVersionUID = 1L;\n\n    private transient long value;\n"}
{"magic_number_smell": "     */\n    static class Aggregation implements AggregationBuffer {\n\n      private static final long 1L = 1L;\n\n      transient private long count;\n", "refactored_code": "  private static final long serialVersionUID = 1L;\n     */\n    static class Aggregation implements AggregationBuffer {\n\n      private static final long serialVersionUID = 1L;\n\n      transient private long count;\n"}
{"magic_number_smell": "   */\n  private static final class Aggregation implements AggregationBuffer {\n\n    private static final long 1L = 1L;\n\n    transient private final HiveDecimalWritable sum = new HiveDecimalWritable();\n    transient private boolean isNull;", "refactored_code": "  private static final long serialVersionUID = 1L;\n   */\n  private static final class Aggregation implements AggregationBuffer {\n\n    private static final long serialVersionUID = 1L;\n\n    transient private final HiveDecimalWritable sum = new HiveDecimalWritable();\n    transient private boolean isNull;"}
{"magic_number_smell": "   */\n  private static final class Aggregation implements AggregationBuffer {\n\n    private static final long 1L = 1L;\n\n    transient private long sum;\n", "refactored_code": "  private static final long serialVersionUID = 1L;\n   */\n  private static final class Aggregation implements AggregationBuffer {\n\n    private static final long serialVersionUID = 1L;\n\n    transient private long sum;\n"}
{"magic_number_smell": "   */\n  private static final class Aggregation implements AggregationBuffer {\n\n    private static final long 1L = 1L;\n\n    // The max for 18 - 1 digits.\n    private static final long nearDecimal64Max =", "refactored_code": "  private static final long serialVersionUID = 1L;\n   */\n  private static final class Aggregation implements AggregationBuffer {\n\n    private static final long serialVersionUID = 1L;\n\n    // The max for 18 - 1 digits.\n    private static final long nearDecimal64Max ="}
{"magic_number_smell": "     */\n    private static final class Aggregation implements AggregationBuffer {\n\n      private static final long 1L = 1L;\n\n      transient private double sum;\n", "refactored_code": "    private static final long serialVersionUID = 1L;\n     */\n    private static final class Aggregation implements AggregationBuffer {\n\n      private static final long serialVersionUID = 1L;\n\n      transient private double sum;\n"}
{"magic_number_smell": "    // Lowest field.\n    public static final class PartialHashCode {\n      public static final int 15 = 15;\n      public static final long allBitsOn = (1L << 15) - 1;\n      public static final long bitMask = allBitsOn;\n\n      // Choose the high bits of the hash code KNOWING it was calculated as an int.", "refactored_code": "      public static final int bitLength = 15;\n    // Lowest field.\n    public static final class PartialHashCode {\n      public static final int bitLength = 15;\n      public static final long allBitsOn = (1L << bitLength) - 1;\n      public static final long bitMask = allBitsOn;\n\n      // Choose the high bits of the hash code KNOWING it was calculated as an int."}
{"magic_number_smell": "     * Extract information from the reference word.\n     */\n    final long referenceAbsoluteOffset =\n        KeyRef.getAbsoluteOffset(refWord) - KeyRef.AbsoluteOffset.KeyRef.AbsoluteOffset.byteLength;\n\n    // Where the new value record will be written.\n    long nextAbsoluteValueOffset = writeBuffers.getWritePoint();", "refactored_code": "    private static final int byteLength = KeyRef.AbsoluteOffset.byteLength;\n     * Extract information from the reference word.\n     */\n    final long referenceAbsoluteOffset =\n        KeyRef.getAbsoluteOffset(refWord) - KeyRef.AbsoluteOffset.byteLength;\n\n    // Where the new value record will be written.\n    long nextAbsoluteValueOffset = writeBuffers.getWritePoint();"}
{"magic_number_smell": "     * Extract information from the reference word.\n     */\n    final long countAbsoluteOffset =\n        KeyRef.getAbsoluteOffset(refWord) - MultiSetCount.Integer.SIZE / Byte.SIZE;\n\n    final int currentCount =\n        writeBuffers.readInt(", "refactored_code": "    private static final int byteLength = Integer.SIZE / Byte.SIZE;\n     * Extract information from the reference word.\n     */\n    final long countAbsoluteOffset =\n        KeyRef.getAbsoluteOffset(refWord) - MultiSetCount.byteLength;\n\n    final int currentCount =\n        writeBuffers.readInt("}
{"magic_number_smell": "  protected final boolean checkResize() {\n    // resize small hashtables up to a higher width (4096 items), but when there are collisions\n    return (resizeThreshold <= keysAssigned)\n        || (logicalHashBucketCount <= 1048576 && largestNumberOfSteps > 1);\n  }\n\n  @Override", "refactored_code": "  public static final int FIRST_SIZE_UP = 1048576;\n  protected final boolean checkResize() {\n    // resize small hashtables up to a higher width (4096 items), but when there are collisions\n    return (resizeThreshold <= keysAssigned)\n        || (logicalHashBucketCount <= FIRST_SIZE_UP && largestNumberOfSteps > 1);\n  }\n\n  @Override"}
{"magic_number_smell": "    private int currentIndex;\n\n    public HashTableElementBatch() {\n      this.batch = new HashTableElement[1024];\n      this.currentIndex = 0;\n    }\n", "refactored_code": "    private static final int BATCH_SIZE = 1024;\n    private int currentIndex;\n\n    public HashTableElementBatch() {\n      this.batch = new HashTableElement[BATCH_SIZE];\n      this.currentIndex = 0;\n    }\n"}
{"magic_number_smell": "   */\n  private final class AbsoluteKeyOffset {\n    private static final int 40 = 40;\n    private static final long allBitsOn = (((long) 1) << 40) - 1;\n    private static final long bitMask = allBitsOn;\n\n    // Make it a power of 2 by backing down (i.e. the -2).", "refactored_code": "    private static final int bitLength = 40;\n   */\n  private final class AbsoluteKeyOffset {\n    private static final int bitLength = 40;\n    private static final long allBitsOn = (((long) 1) << bitLength) - 1;\n    private static final long bitMask = allBitsOn;\n\n    // Make it a power of 2 by backing down (i.e. the -2)."}
{"magic_number_smell": "  // Lowest field.\n  private final class AbsoluteValueOffset {\n    private static final int 40 = 40;\n    private static final long allBitsOn = (1L << 40) - 1;\n    private static final long bitMask = allBitsOn;\n\n    // Make it a power of 2.", "refactored_code": "    private static final int bitLength = 40;\n  // Lowest field.\n  private final class AbsoluteValueOffset {\n    private static final int bitLength = 40;\n    private static final long allBitsOn = (1L << bitLength) - 1;\n    private static final long bitMask = allBitsOn;\n\n    // Make it a power of 2."}
{"magic_number_smell": "  private Output output;\n  private int rowBeginPos;\n  private static final int 4096 = 4096;\n  private static final int THRESHOLD = 8 * (4096 / 10);\n  private static final int INPUT_SIZE = 4096;\n\n  private FileOutputStream fileOutputStream;", "refactored_code": "  private static final int OUTPUT_SIZE = 4096;\n  private Output output;\n  private int rowBeginPos;\n  private static final int OUTPUT_SIZE = 4096;\n  private static final int THRESHOLD = 8 * (OUTPUT_SIZE / 10);\n  private static final int INPUT_SIZE = 4096;\n\n  private FileOutputStream fileOutputStream;"}
{"magic_number_smell": "    // start with the keywrapper itself\n    compiledKeyWrapperBatch.keysFixedSize += JavaDataModel.alignUp(\n        model.object() +\n        model.ref() * 7 +\n        model.primitive1(),\n        model.memoryAlign());\n", "refactored_code": "  private static final int MODEL_REFERENCES_COUNT = 7;\n    // start with the keywrapper itself\n    compiledKeyWrapperBatch.keysFixedSize += JavaDataModel.alignUp(\n        model.object() +\n        model.ref() * MODEL_REFERENCES_COUNT +\n        model.primitive1(),\n        model.memoryAlign());\n"}
{"magic_number_smell": "  }\n\n  public enum OtherInfoType {\n    QUERY, STATUS, TEZ, MAPRED, INVOKER_INFO, SESSION_ID, THREAD_NAME, 1, CLIENT_IP_ADDRESS,\n    HIVE_ADDRESS, HIVE_INSTANCE_TYPE, CONF, PERF, LLAP_APP_ID, ERROR_MESSAGE, QUERY_TYPE\n  }\n", "refactored_code": "  private static final int VERSION = 1;\n  }\n\n  public enum OtherInfoType {\n    QUERY, STATUS, TEZ, MAPRED, INVOKER_INFO, SESSION_ID, THREAD_NAME, VERSION, CLIENT_IP_ADDRESS,\n    HIVE_ADDRESS, HIVE_INSTANCE_TYPE, CONF, PERF, LLAP_APP_ID, ERROR_MESSAGE, QUERY_TYPE\n  }\n"}
{"magic_number_smell": "    /**\n     * Serial version id.\n     */\n    private static final long 1L = 1L;\n\n    /**\n     * The table in case this container is a table.", "refactored_code": "  private static final long serialVersionUID = 1L;\n    /**\n     * Serial version id.\n     */\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * The table in case this container is a table."}
{"magic_number_smell": "\n    @Override\n    public void write(DataOutput out) throws IOException {\n      int flags = (fileId != null ? 1 : 0) |\n          (attemptId != null ? HAS_ATTEMPTID_FLAG : 0) |\n          (stmtId != null ? HAS_STMTID_FLAG : 0);\n      out.writeByte(flags);", "refactored_code": "    private static final int HAS_LONG_FILEID_FLAG = 1;\n\n    @Override\n    public void write(DataOutput out) throws IOException {\n      int flags = (fileId != null ? HAS_LONG_FILEID_FLAG : 0) |\n          (attemptId != null ? HAS_ATTEMPTID_FLAG : 0) |\n          (stmtId != null ? HAS_STMTID_FLAG : 0);\n      out.writeByte(flags);"}
{"magic_number_smell": "  public static BucketCodec determineVersion(int bucket) {\n    try {\n      // look at top 3 bits and return appropriate enum\n      return getCodec((BucketCodec.0b1110_0000_0000_0000_0000_0000_0000_0000 & bucket) >>> 29);\n    } catch (IllegalArgumentException iae) {\n      throw new IllegalArgumentException(\"Cannot decode version from bucket number: \" + Integer.toHexString(bucket),\n          iae);", "refactored_code": "  private static final int TOP3BITS_MASK = 0b1110_0000_0000_0000_0000_0000_0000_0000;\n  public static BucketCodec determineVersion(int bucket) {\n    try {\n      // look at top 3 bits and return appropriate enum\n      return getCodec((BucketCodec.TOP3BITS_MASK & bucket) >>> 29);\n    } catch (IllegalArgumentException iae) {\n      throw new IllegalArgumentException(\"Cannot decode version from bucket number: \" + Integer.toHexString(bucket),\n          iae);"}
{"magic_number_smell": "    List<Path> nonCombinablePaths = new ArrayList<Path>(paths.length / 2);\n    List<Path> combinablePaths = new ArrayList<Path>(paths.length / 2);\n\n    int numThreads = Math.min(50,\n        (int) Math.ceil((double) paths.length / DEFAULT_NUM_PATH_PER_THREAD));\n\n    try {", "refactored_code": "  private static final int MAX_CHECK_NONCOMBINABLE_THREAD_NUM = 50;\n    List<Path> nonCombinablePaths = new ArrayList<Path>(paths.length / 2);\n    List<Path> combinablePaths = new ArrayList<Path>(paths.length / 2);\n\n    int numThreads = Math.min(MAX_CHECK_NONCOMBINABLE_THREAD_NUM,\n        (int) Math.ceil((double) paths.length / DEFAULT_NUM_PATH_PER_THREAD));\n\n    try {"}
{"magic_number_smell": "          .build();\n\n      // updatable map that holds instances of the class\n      inputFormatCheckerInstanceCache = CacheBuilder.newBuilder().maximumSize(16)\n          .build();\n    }\n", "refactored_code": "    private static final int MAX_CACHE_SIZE = 16;\n          .build();\n\n      // updatable map that holds instances of the class\n      inputFormatCheckerInstanceCache = CacheBuilder.newBuilder().maximumSize(MAX_CACHE_SIZE)\n          .build();\n    }\n"}
{"magic_number_smell": "     */\n    @Override\n    public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2) {\n      return compareBytes(b1, s1 + 4, l1 - 4, b2, s2\n          + 4, l2 - 4);\n    }\n  }", "refactored_code": "  private static final int LENGTH_BYTES = 4;\n     */\n    @Override\n    public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2) {\n      return compareBytes(b1, s1 + LENGTH_BYTES, l1 - LENGTH_BYTES, b2, s2\n          + LENGTH_BYTES, l2 - LENGTH_BYTES);\n    }\n  }"}
{"magic_number_smell": "  private static final byte[] ORIGINAL_MAGIC = new byte[] {\n      (byte) 'S', (byte) 'E', (byte) 'Q'};\n  // the version that was included with the original magic, which is mapped\n  // into 0\n  private static final byte ORIGINAL_MAGIC_VERSION_WITH_METADATA = 6;\n\n  private static final byte[] ORIGINAL_MAGIC_VERSION = new byte[] {", "refactored_code": "  private static final int ORIGINAL_VERSION = 0;  // version with SEQ\n  private static final byte[] ORIGINAL_MAGIC = new byte[] {\n      (byte) 'S', (byte) 'E', (byte) 'Q'};\n  // the version that was included with the original magic, which is mapped\n  // into ORIGINAL_VERSION\n  private static final byte ORIGINAL_MAGIC_VERSION_WITH_METADATA = 6;\n\n  private static final byte[] ORIGINAL_MAGIC_VERSION = new byte[] {"}
{"magic_number_smell": "\n  @Override\n  public void write(DataOutput out) throws IOException {\n    out.writeShort(24);\n    out.writeLong(pathHash);\n    out.writeLong(modTime);\n    out.writeLong(length);", "refactored_code": "  private static final short THREE_LONGS = 24;\n\n  @Override\n  public void write(DataOutput out) throws IOException {\n    out.writeShort(THREE_LONGS);\n    out.writeLong(pathHash);\n    out.writeLong(modTime);\n    out.writeLong(length);"}
{"magic_number_smell": "\n  LocalCache(int numThreads, long cacheMemSize, boolean useSoftRef) {\n    CacheBuilder<Path, TailAndFileData> builder = CacheBuilder.newBuilder()\n        .initialCapacity(1024)\n        .concurrencyLevel(numThreads)\n        .maximumWeight(cacheMemSize)\n        .weigher(new Weigher<Path, TailAndFileData>() {", "refactored_code": "  private static final int DEFAULT_CACHE_INITIAL_CAPACITY = 1024;\n\n  LocalCache(int numThreads, long cacheMemSize, boolean useSoftRef) {\n    CacheBuilder<Path, TailAndFileData> builder = CacheBuilder.newBuilder()\n        .initialCapacity(DEFAULT_CACHE_INITIAL_CAPACITY)\n        .concurrencyLevel(numThreads)\n        .maximumWeight(cacheMemSize)\n        .weigher(new Weigher<Path, TailAndFileData>() {"}
{"magic_number_smell": "      this.isVectorMode = Utilities.getIsVectorized(conf);\n      this.forceThreadpool = HiveConf.getBoolVar(conf, ConfVars.HIVE_IN_TEST);\n      this.sarg = ConvertAstToSearchArg.createFromConf(conf);\n      minSize = HiveConf.getLongVar(conf, ConfVars.MAPRED_MIN_SPLIT_SIZE, 16 * 1024 * 1024);\n      maxSize = HiveConf.getLongVar(conf, ConfVars.MAPRED_MAX_SPLIT_SIZE, DEFAULT_MAX_SPLIT_SIZE);\n      String ss = conf.get(ConfVars.HIVE_ORC_SPLIT_STRATEGY.varname);\n      if (ss == null || ss.equals(SplitStrategyKind.HYBRID.name())) {", "refactored_code": "  private static final long DEFAULT_MIN_SPLIT_SIZE = 16 * 1024 * 1024;\n      this.isVectorMode = Utilities.getIsVectorized(conf);\n      this.forceThreadpool = HiveConf.getBoolVar(conf, ConfVars.HIVE_IN_TEST);\n      this.sarg = ConvertAstToSearchArg.createFromConf(conf);\n      minSize = HiveConf.getLongVar(conf, ConfVars.MAPRED_MIN_SPLIT_SIZE, DEFAULT_MIN_SPLIT_SIZE);\n      maxSize = HiveConf.getLongVar(conf, ConfVars.MAPRED_MAX_SPLIT_SIZE, DEFAULT_MAX_SPLIT_SIZE);\n      String ss = conf.get(ConfVars.HIVE_ORC_SPLIT_STRATEGY.varname);\n      if (ss == null || ss.equals(SplitStrategyKind.HYBRID.name())) {"}
{"magic_number_smell": "    if (struct == null) {\n      return null;\n    } else {\n      return (OrcStruct) struct.getFieldValue(5);\n    }\n  }\n", "refactored_code": "  public static final int ROW = 5;\n    if (struct == null) {\n      return null;\n    } else {\n      return (OrcStruct) struct.getFieldValue(ROW);\n    }\n  }\n"}
{"magic_number_smell": "    }\n\n    public ReadContext(int colIx, int colRgIx) {\n      this(colIx, colRgIx, countMaxStreams(Area.DATA));\n    }\n\n    public static final int countMaxStreams(Area.DATA) = countMaxStreams(Area.INDEX);", "refactored_code": "    public static final int MAX_STREAMS = countMaxStreams(Area.DATA);\n    }\n\n    public ReadContext(int colIx, int colRgIx) {\n      this(colIx, colRgIx, MAX_STREAMS);\n    }\n\n    public static final int MAX_STREAMS = countMaxStreams(Area.INDEX);"}
{"magic_number_smell": "\n    switch (timeUnit) {\n    case MILLIS:\n      seconds = value / 1000;\n      nanoseconds = (value % 1000) * MICRO;\n      break;\n", "refactored_code": "  private static final long MILLI = 1000;\n\n    switch (timeUnit) {\n    case MILLIS:\n      seconds = value / MILLI;\n      nanoseconds = (value % MILLI) * MICRO;\n      break;\n"}
{"magic_number_smell": "    positions[cacheData.length - 1] = footerLength;\n    cacheData[cacheData.length - 1] = new FooterEndBuffer(footerLength);\n    this.footerLength = footerLength;\n    this.length = footerLength + FAKE_PREFIX_LENGTH + ParquetFileWriter.MAGIC.length + FOOTER_LENGTH_SIZE;\n  }\n\n  @Override", "refactored_code": "  private static final int TAIL_LENGTH = ParquetFileWriter.MAGIC.length + FOOTER_LENGTH_SIZE;\n    positions[cacheData.length - 1] = footerLength;\n    cacheData[cacheData.length - 1] = new FooterEndBuffer(footerLength);\n    this.footerLength = footerLength;\n    this.length = footerLength + FAKE_PREFIX_LENGTH + TAIL_LENGTH;\n  }\n\n  @Override"}
{"magic_number_smell": "      int nestGroup = 0;\n      GroupType groupType = type.asGroupType();\n      // if FieldCount == 2, get types for key & value,\n      // otherwise, continue to get the group type until 3.\n      while (groupType.getFieldCount() < 2) {\n        if (nestGroup > 3) {\n          throw new RuntimeException(", "refactored_code": "  private static final int MAP_DEFINITION_LEVEL_MAX = 3;\n      int nestGroup = 0;\n      GroupType groupType = type.asGroupType();\n      // if FieldCount == 2, get types for key & value,\n      // otherwise, continue to get the group type until MAP_DEFINITION_LEVEL_MAX.\n      while (groupType.getFieldCount() < 2) {\n        if (nestGroup > MAP_DEFINITION_LEVEL_MAX) {\n          throw new RuntimeException("}
{"magic_number_smell": "  }\n\n  public static String sargToKryo(SearchArgument sarg) {\n    try (Output out = new Output(4 * 1024, KRYO_OUTPUT_BUFFER_MAX_SIZE)) {\n      Kryo kryo = SerializationUtilities.borrowKryo();\n      kryo.writeObject(out, sarg);\n      SerializationUtilities.releaseKryo(kryo);", "refactored_code": "  private static final int KRYO_OUTPUT_BUFFER_SIZE = 4 * 1024;\n  }\n\n  public static String sargToKryo(SearchArgument sarg) {\n    try (Output out = new Output(KRYO_OUTPUT_BUFFER_SIZE, KRYO_OUTPUT_BUFFER_MAX_SIZE)) {\n      Kryo kryo = SerializationUtilities.borrowKryo();\n      kryo.writeObject(out, sarg);\n      SerializationUtilities.releaseKryo(kryo);"}
{"magic_number_smell": "                }\n              });\n      ((ScheduledThreadPoolExecutor) heartbeatExecutorService).setRemoveOnCancelPolicy(true);\n      ShutdownHookManager.addShutdownHook(DbTxnManager::shutdownHeartbeatExecutorService, 0);\n  }\n\n  private synchronized static void shutdownHeartbeatExecutorService() {", "refactored_code": "  private static final int SHUTDOWN_HOOK_PRIORITY = 0;\n                }\n              });\n      ((ScheduledThreadPoolExecutor) heartbeatExecutorService).setRemoveOnCancelPolicy(true);\n      ShutdownHookManager.addShutdownHook(DbTxnManager::shutdownHeartbeatExecutorService, SHUTDOWN_HOOK_PRIORITY);\n  }\n\n  private synchronized static void shutdownHeartbeatExecutorService() {"}
{"magic_number_smell": "\n  @InterfaceAudience.Private\n  public static long getFatal() {\n    return counts.get(0);\n  }\n\n  @InterfaceAudience.Private", "refactored_code": "  private static final int FATAL = 0;\n\n  @InterfaceAudience.Private\n  public static long getFatal() {\n    return counts.get(FATAL);\n  }\n\n  @InterfaceAudience.Private"}
{"magic_number_smell": "  // 2019-10-13 10:15:35.100 -> 2019-10-13 10:15:00.000\n  private Timestamp roundupToMinuteFloor(final Timestamp ts) {\n    long millis = ts.getTime();\n    long newMillis = 60 * 1000L * (millis / 60 * 1000L);\n    return new Timestamp(newMillis);\n  }\n", "refactored_code": "  private static final long MILLISECONDS_PER_MINUTE = 60 * 1000L;\n  // 2019-10-13 10:15:35.100 -> 2019-10-13 10:15:00.000\n  private Timestamp roundupToMinuteFloor(final Timestamp ts) {\n    long millis = ts.getTime();\n    long newMillis = MILLISECONDS_PER_MINUTE * (millis / MILLISECONDS_PER_MINUTE);\n    return new Timestamp(newMillis);\n  }\n"}
{"magic_number_smell": "      if (sqlState != null) {\n        out.write(sqlState.getBytes(\"UTF-8\")); //this breaks all the tests in .q files\n      }\n      out.write(Utilities.newLineCode);\n    } catch (Exception e) {\n      throw new HiveException(e);\n    }", "refactored_code": "  private static final int TERMINATOR = Utilities.newLineCode;\n      if (sqlState != null) {\n        out.write(sqlState.getBytes(\"UTF-8\")); //this breaks all the tests in .q files\n      }\n      out.write(TERMINATOR);\n    } catch (Exception e) {\n      throw new HiveException(e);\n    }"}
{"magic_number_smell": "    int maxExecutorsPerQuery = conf.getIntVar(ConfVars.LLAP_MEMORY_OVERSUBSCRIPTION_MAX_EXECUTORS_PER_QUERY);\n    if (maxExecutorsPerQuery == -1) {\n      if (llapInfo == null) {\n        maxExecutorsPerQuery = 3;\n      } else {\n        maxExecutorsPerQuery = Math.min(Math.max(1, llapInfo.getNumExecutorsPerNode() / 3), 8);\n      }", "refactored_code": "  private static final int DEFAULT_MAX_EXECUTORS_PER_QUERY_CONTAINER_MODE = 3;\n    int maxExecutorsPerQuery = conf.getIntVar(ConfVars.LLAP_MEMORY_OVERSUBSCRIPTION_MAX_EXECUTORS_PER_QUERY);\n    if (maxExecutorsPerQuery == -1) {\n      if (llapInfo == null) {\n        maxExecutorsPerQuery = DEFAULT_MAX_EXECUTORS_PER_QUERY_CONTAINER_MODE;\n      } else {\n        maxExecutorsPerQuery = Math.min(Math.max(1, llapInfo.getNumExecutorsPerNode() / 3), 8);\n      }"}
{"magic_number_smell": "\n  @Override\n  public int getMaxNumericPrecision() {\n    return 38;\n  }\n\n  @Override", "refactored_code": "  private static final int MAX_DECIMAL_PRECISION     = 38;\n\n  @Override\n  public int getMaxNumericPrecision() {\n    return MAX_DECIMAL_PRECISION;\n  }\n\n  @Override"}
{"magic_number_smell": "      int rightPrec) {\n    final SqlWriter.Frame frame =\n        writer.startList(SqlWriter.FrameTypeEnum.create(\"BETWEEN\"), \"\", \"\");\n    call.operand(1).unparse(writer, getLeftPrec(), 0);\n    writer.sep(super.getName());\n\n    // If the expression for the lower bound contains a call to an AND", "refactored_code": "  public static final int VALUE_OPERAND = 1;\n      int rightPrec) {\n    final SqlWriter.Frame frame =\n        writer.startList(SqlWriter.FrameTypeEnum.create(\"BETWEEN\"), \"\", \"\");\n    call.operand(VALUE_OPERAND).unparse(writer, getLeftPrec(), 0);\n    writer.sep(super.getName());\n\n    // If the expression for the lower bound contains a call to an AND"}
{"magic_number_smell": "      super();\n    }\n\n    private static final long 1L = 1L;\n    // Equivalent aliases for the column\n    private List<String> names = new ArrayList<String>();\n    // Indexes of those equivalent columns", "refactored_code": "    private static final long serialVersionUID = 1L;\n      super();\n    }\n\n    private static final long serialVersionUID = 1L;\n    // Equivalent aliases for the column\n    private List<String> names = new ArrayList<String>();\n    // Indexes of those equivalent columns"}
{"magic_number_smell": "      @Override\n      public LlapClusterStateForCompile call() throws Exception {\n        LOG.info(\"Creating cluster info for \" + userName + \":\" + nodes);\n        return new LlapClusterStateForCompile(conf, 120 * 1000L);\n      }\n    };\n    try {", "refactored_code": "  private static final long CLUSTER_UPDATE_INTERVAL_MS = 120 * 1000L; // 2 minutes.\n      @Override\n      public LlapClusterStateForCompile call() throws Exception {\n        LOG.info(\"Creating cluster info for \" + userName + \":\" + nodes);\n        return new LlapClusterStateForCompile(conf, CLUSTER_UPDATE_INTERVAL_MS);\n      }\n    };\n    try {"}
{"magic_number_smell": "  }\n\n  public int getNumJoins() {\n    return 0;\n  }\n\n  public Set<String> getSubqAliases() {", "refactored_code": "  private final int numJoins = 0;\n  }\n\n  public int getNumJoins() {\n    return numJoins;\n  }\n\n  public Set<String> getSubqAliases() {"}
{"magic_number_smell": "      String expr_formatted = expr_no_tok.replaceAll(\"\\\\W\", \" \").trim().replaceAll(\"\\\\s+\", \"_\");\n\n      // limit length to 20 chars\n      if (expr_formatted.length() > 20) {\n        expr_formatted = expr_formatted.substring(0, 20);\n      }\n", "refactored_code": "  private static final int AUTOGEN_COLALIAS_PRFX_MAXLENGTH = 20;\n      String expr_formatted = expr_no_tok.replaceAll(\"\\\\W\", \" \").trim().replaceAll(\"\\\\s+\", \"_\");\n\n      // limit length to 20 chars\n      if (expr_formatted.length() > AUTOGEN_COLALIAS_PRFX_MAXLENGTH) {\n        expr_formatted = expr_formatted.substring(0, AUTOGEN_COLALIAS_PRFX_MAXLENGTH);\n      }\n"}
{"magic_number_smell": "    }\n\n    public boolean isBounded() {\n      return this.amt != Integer.MAX_VALUE;\n    }\n\n    /**", "refactored_code": "    public static final int UNBOUNDED_AMOUNT = Integer.MAX_VALUE;\n    }\n\n    public boolean isBounded() {\n      return this.amt != UNBOUNDED_AMOUNT;\n    }\n\n    /**"}
{"magic_number_smell": "    int repeat = 0;\n    boolean isCopyError = false;\n    List<Path> pathList = Lists.transform(srcFileList, ReplChangeManager.FileInfo::getEffectivePath);\n    while (!pathList.isEmpty() && (repeat < 5)) {\n      try {\n        // if its retrying, first regenerate the path list.\n        if (repeat > 0) {", "refactored_code": "  private static final int MAX_IO_RETRY = 5;\n    int repeat = 0;\n    boolean isCopyError = false;\n    List<Path> pathList = Lists.transform(srcFileList, ReplChangeManager.FileInfo::getEffectivePath);\n    while (!pathList.isEmpty() && (repeat < MAX_IO_RETRY)) {\n      try {\n        // if its retrying, first regenerate the path list.\n        if (repeat > 0) {"}
{"magic_number_smell": "      isServiceRunning.set(false);\n      return;\n    }\n    if (nDumpThreads > 100) {\n      LOG.warn(\"Thread pool size for ExportService (REPL_TABLE_DUMP_PARALLELISM) is specified higher than limit. \" +\n              \"Choosing thread pool size as 100\");\n      nDumpThreads = 100;", "refactored_code": "  private final int threadPoolSizeLimit = 100;\n      isServiceRunning.set(false);\n      return;\n    }\n    if (nDumpThreads > threadPoolSizeLimit) {\n      LOG.warn(\"Thread pool size for ExportService (REPL_TABLE_DUMP_PARALLELISM) is specified higher than limit. \" +\n              \"Choosing thread pool size as 100\");\n      nDumpThreads = threadPoolSizeLimit;"}
{"magic_number_smell": "        try {\n          long bytesWritten;\n          fos = fs.create(exportFilePath);\n          byte[] buffer = new byte[8 * 1024];\n          int bytesRead;\n          while ((bytesRead = is.read(buffer)) != -1) {\n            fos.write(buffer, 0, bytesRead);", "refactored_code": "  private static final int DEF_BUF_SIZE = 8 * 1024;\n        try {\n          long bytesWritten;\n          fos = fs.create(exportFilePath);\n          byte[] buffer = new byte[DEF_BUF_SIZE];\n          int bytesRead;\n          while ((bytesRead = is.read(buffer)) != -1) {\n            fos.write(buffer, 0, bytesRead);"}
{"magic_number_smell": "  private Tuple extract(Context context) throws SemanticException {\n    try {\n      String tableType = null;\n      long writeId = 0L;\n      switch (context.dmd.getDumpType()) {\n      case EVENT_CREATE_TABLE:\n      case EVENT_ADD_PARTITION:", "refactored_code": "  private static final long DEFAULT_WRITE_ID = 0L;\n  private Tuple extract(Context context) throws SemanticException {\n    try {\n      String tableType = null;\n      long writeId = DEFAULT_WRITE_ID;\n      switch (context.dmd.getDumpType()) {\n      case EVENT_CREATE_TABLE:\n      case EVENT_ADD_PARTITION:"}
{"magic_number_smell": "   *\n   */\n  public static class ConditionalResolverCommonJoinCtx implements Serializable {\n    private static final long 1L = 1L;\n\n    private HashMap<Task<?>, Set<String>> taskToAliases;\n    Map<Path, List<String>> pathToAliases;", "refactored_code": "  private static final long serialVersionUID = 1L;\n   *\n   */\n  public static class ConditionalResolverCommonJoinCtx implements Serializable {\n    private static final long serialVersionUID = 1L;\n\n    private HashMap<Task<?>, Set<String>> taskToAliases;\n    Map<Path, List<String>> pathToAliases;"}
{"magic_number_smell": "   *\n   */\n  public static class ConditionalResolverMergeFilesCtx implements Serializable {\n    private static final long 1L = 1L;\n    List<Task<?>> listTasks;\n    private String dir;\n    private DynamicPartitionCtx dpCtx; // merge task could be after dynamic partition insert", "refactored_code": "  private static final long serialVersionUID = 1L;\n   *\n   */\n  public static class ConditionalResolverMergeFilesCtx implements Serializable {\n    private static final long serialVersionUID = 1L;\n    List<Task<?>> listTasks;\n    private String dir;\n    private DynamicPartitionCtx dpCtx; // merge task could be after dynamic partition insert"}
{"magic_number_smell": "   *\n   */\n  public static class ConditionalResolverSkewJoinCtx implements Serializable {\n    private static final long 1L = 1L;\n    // we store big keys in one table into one dir, and same keys in other\n    // tables into corresponding different dirs (one dir per table).\n    // this map stores mapping from \"big key dir\" to its corresponding mapjoin", "refactored_code": "  private static final long serialVersionUID = 1L;\n   *\n   */\n  public static class ConditionalResolverSkewJoinCtx implements Serializable {\n    private static final long serialVersionUID = 1L;\n    // we store big keys in one table into one dir, and same keys in other\n    // tables into corresponding different dirs (one dir per table).\n    // this map stores mapping from \"big key dir\" to its corresponding mapjoin"}
{"magic_number_smell": "\n  @Explain(displayName = \"Sampling\", explainLevels = { Level.EXTENDED })\n  public String getSamplingTypeString() {\n    return samplingType == 1 ? \"1\" :\n        samplingType == 2 ? \"SAMPLING_ON_START\" : null;\n  }\n", "refactored_code": "  public static final int SAMPLING_ON_PREV_MR = 1;  // todo HIVE-3841\n\n  @Explain(displayName = \"Sampling\", explainLevels = { Level.EXTENDED })\n  public String getSamplingTypeString() {\n    return samplingType == 1 ? \"SAMPLING_ON_PREV_MR\" :\n        samplingType == 2 ? \"SAMPLING_ON_START\" : null;\n  }\n"}
{"magic_number_smell": "    } else if (colTypeLowerCase.equals(serdeConstants.DATE_TYPE_NAME)) {\n      cs.setAvgColLen(JavaDataModel.get().lengthOfDate());\n      // epoch, days since epoch\n      cs.setRange(10593, DATE_RANGE_UPPER_LIMIT);\n    } else {\n      cs.setAvgColLen(getSizeOfComplexTypes(conf, cinfo.getObjectInspector()));\n    }", "refactored_code": "  private static final int DATE_RANGE_LOWER_LIMIT = 10593;\n    } else if (colTypeLowerCase.equals(serdeConstants.DATE_TYPE_NAME)) {\n      cs.setAvgColLen(JavaDataModel.get().lengthOfDate());\n      // epoch, days since epoch\n      cs.setRange(DATE_RANGE_LOWER_LIMIT, DATE_RANGE_UPPER_LIMIT);\n    } else {\n      cs.setAvgColLen(getSizeOfComplexTypes(conf, cinfo.getObjectInspector()));\n    }"}
{"magic_number_smell": "\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {\n      return size() > 16;\n    }\n\n  }", "refactored_code": "    private static final int CACHE_SIZE = 16;\n\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {\n      return size() > CACHE_SIZE;\n    }\n\n  }"}
{"magic_number_smell": "    if (a.get() <= 0.0) {\n      return null;\n    } else {\n      result.set(StrictMath.log(a.get()) / StrictMath.log(2.0));\n      return result;\n    }\n  }", "refactored_code": "  private static final double LOG_2 = StrictMath.log(2.0);\n    if (a.get() <= 0.0) {\n      return null;\n    } else {\n      result.set(StrictMath.log(a.get()) / LOG_2);\n      return result;\n    }\n  }"}
{"magic_number_smell": "   * @return OGCType set in the 5th byte of the hive geometry bytes\n   */\n  public static OGCType getType(BytesWritable geomref) {\n    // 4 is the offset to the byte that stores the type information\n    return OGCTypeLookup[geomref.getBytes()[4]];\n  }\n", "refactored_code": "  private static final int SIZE_WKID = 4;\n   * @return OGCType set in the 5th byte of the hive geometry bytes\n   */\n  public static OGCType getType(BytesWritable geomref) {\n    // SIZE_WKID is the offset to the byte that stores the type information\n    return OGCTypeLookup[geomref.getBytes()[SIZE_WKID]];\n  }\n"}
{"magic_number_smell": "   */\n  public static void Log_SRIDMismatch(Logger logger, BytesWritable geomref1, BytesWritable geomref2) {\n    logger.error(\n        String.format(messages[0], GeometryUtils.getWKID(geomref1), GeometryUtils.getWKID(geomref2)));\n  }\n\n  public static void Log_SRIDMismatch(Logger logger, BytesWritable geomref1, int wkid2) {", "refactored_code": "  private static final int MSG_SRID_MISMATCH = 0;\n   */\n  public static void Log_SRIDMismatch(Logger logger, BytesWritable geomref1, BytesWritable geomref2) {\n    logger.error(\n        String.format(messages[MSG_SRID_MISMATCH], GeometryUtils.getWKID(geomref1), GeometryUtils.getWKID(geomref2)));\n  }\n\n  public static void Log_SRIDMismatch(Logger logger, BytesWritable geomref1, int wkid2) {"}
{"magic_number_smell": "  public static class AggrConvexHullBinaryEvaluator implements UDAFEvaluator {\n\n    private final int 1000 = 1000;\n    private final ArrayList<Geometry> geometries = new ArrayList<Geometry>(1000);\n    SpatialReference spatialRef = null;\n    int firstWKID = -2;\n", "refactored_code": "    private final int MAX_BUFFER_SIZE = 1000;\n  public static class AggrConvexHullBinaryEvaluator implements UDAFEvaluator {\n\n    private final int MAX_BUFFER_SIZE = 1000;\n    private final ArrayList<Geometry> geometries = new ArrayList<Geometry>(MAX_BUFFER_SIZE);\n    SpatialReference spatialRef = null;\n    int firstWKID = -2;\n"}
{"magic_number_smell": "\n    opSimpleRelation = getRelationOperator();\n\n    if (OIs.length != 2) {\n      throw new UDFArgumentException(\"The \" + opSimpleRelation.getType().toString().toLowerCase()\n          + \" relationship operator takes exactly two arguments\");\n    }", "refactored_code": "  private static final int NUM_ARGS = 2;\n\n    opSimpleRelation = getRelationOperator();\n\n    if (OIs.length != NUM_ARGS) {\n      throw new UDFArgumentException(\"The \" + opSimpleRelation.getType().toString().toLowerCase()\n          + \" relationship operator takes exactly two arguments\");\n    }"}
{"magic_number_smell": "      // 10b rows. The scale is the same as the input.\n      DecimalTypeInfo outputTypeInfo = null;\n      if (mode == Mode.PARTIAL1 || mode == Mode.COMPLETE) {\n        int precision = Math.min(HiveDecimal.MAX_PRECISION, inputPrecision + 10);\n        outputTypeInfo = TypeInfoFactory.getDecimalTypeInfo(precision, inputScale);\n      } else {\n        outputTypeInfo = TypeInfoFactory.getDecimalTypeInfo(inputPrecision, inputScale);", "refactored_code": "  public static final int SUM_RESULT_PRECISION_INCREASE = 10;\n      // 10b rows. The scale is the same as the input.\n      DecimalTypeInfo outputTypeInfo = null;\n      if (mode == Mode.PARTIAL1 || mode == Mode.COMPLETE) {\n        int precision = Math.min(HiveDecimal.MAX_PRECISION, inputPrecision + SUM_RESULT_PRECISION_INCREASE);\n        outputTypeInfo = TypeInfoFactory.getDecimalTypeInfo(precision, inputScale);\n      } else {\n        outputTypeInfo = TypeInfoFactory.getDecimalTypeInfo(inputPrecision, inputScale);"}
{"magic_number_smell": "  @Override\n  public ObjectInspector initialize(ObjectInspector[] arguments) throws UDFArgumentException {\n    ObjectInspector defaultOI = super.initialize(arguments);\n    checkValueAndListElementTypes(arrayElementOI, FUNC_NAME, arguments[1], 1);\n    return defaultOI;\n  }\n", "refactored_code": "  private static final int ELEMENT_IDX = 1;\n  @Override\n  public ObjectInspector initialize(ObjectInspector[] arguments) throws UDFArgumentException {\n    ObjectInspector defaultOI = super.initialize(arguments);\n    checkValueAndListElementTypes(arrayElementOI, FUNC_NAME, arguments[ELEMENT_IDX], ELEMENT_IDX);\n    return defaultOI;\n  }\n"}
{"magic_number_smell": "              + ARG_COUNT + \" arguments.\");\n    }\n\n    // Check if 0 argument is of category LIST\n    if (!arguments[0].getCategory().equals(Category.LIST)) {\n      throw new UDFArgumentTypeException(0,\n          \"\\\"\" + org.apache.hadoop.hive.serde.serdeConstants.LIST_TYPE_NAME + \"\\\" \"", "refactored_code": "  private static final int ARRAY_IDX = 0;\n              + ARG_COUNT + \" arguments.\");\n    }\n\n    // Check if ARRAY_IDX argument is of category LIST\n    if (!arguments[ARRAY_IDX].getCategory().equals(Category.LIST)) {\n      throw new UDFArgumentTypeException(ARRAY_IDX,\n          \"\\\"\" + org.apache.hadoop.hive.serde.serdeConstants.LIST_TYPE_NAME + \"\\\" \""}
{"magic_number_smell": "    }\n\n    List<?> retArray = ((ListObjectInspector) argumentOIs[ARRAY_IDX]).getList(array);\n    String separator = arguments[1].get().toString();\n    if (arguments.length > REPLACE_NULL_IDX && arguments[REPLACE_NULL_IDX].get() != null) {\n      result.set(Joiner.on(separator).useForNull(arguments[REPLACE_NULL_IDX].get().toString()).join(retArray));\n    } else {", "refactored_code": "  private static final int SEPARATOR_IDX = 1;\n    }\n\n    List<?> retArray = ((ListObjectInspector) argumentOIs[ARRAY_IDX]).getList(array);\n    String separator = arguments[SEPARATOR_IDX].get().toString();\n    if (arguments.length > REPLACE_NULL_IDX && arguments[REPLACE_NULL_IDX].get() != null) {\n      result.set(Joiner.on(separator).useForNull(arguments[REPLACE_NULL_IDX].get().toString()).join(retArray));\n    } else {"}
{"magic_number_smell": "  @Override\n  public ObjectInspector initialize(ObjectInspector[] arguments) throws UDFArgumentException {\n    super.initialize(arguments);\n    valueOI = arguments[1];\n    checkValueAndListElementTypes(arrayElementOI, FUNC_NAME, valueOI,1);\n    return PrimitiveObjectInspectorFactory.writableIntObjectInspector;\n  }", "refactored_code": "  private static final int ELEMENT_IDX = 1;\n  @Override\n  public ObjectInspector initialize(ObjectInspector[] arguments) throws UDFArgumentException {\n    super.initialize(arguments);\n    valueOI = arguments[ELEMENT_IDX];\n    checkValueAndListElementTypes(arrayElementOI, FUNC_NAME, valueOI,ELEMENT_IDX);\n    return PrimitiveObjectInspectorFactory.writableIntObjectInspector;\n  }"}
{"magic_number_smell": "    ObjectInspector defaultOI = super.initialize(arguments);\n    ObjectInspector arrayElementOI = arrayOI.getListElementObjectInspector();\n\n    ObjectInspector valueOI = arguments[1];\n\n    // Check if list element and value are of same type\n    if (!ObjectInspectorUtils.compareTypes(arrayElementOI, valueOI)) {", "refactored_code": "  private static final int VALUE_IDX = 1;\n    ObjectInspector defaultOI = super.initialize(arguments);\n    ObjectInspector arrayElementOI = arrayOI.getListElementObjectInspector();\n\n    ObjectInspector valueOI = arguments[VALUE_IDX];\n\n    // Check if list element and value are of same type\n    if (!ObjectInspectorUtils.compareTypes(arrayElementOI, valueOI)) {"}
{"magic_number_smell": "  @Override public ObjectInspector initialize(ObjectInspector[] arguments) throws UDFArgumentException {\n    ObjectInspector defaultOI = super.initialize(arguments);\n    // Check whether start and length inputs are of integer type\n    checkArgIntPrimitiveCategory((PrimitiveObjectInspector) arguments[1], FUNC_NAME, 1);\n    checkArgIntPrimitiveCategory((PrimitiveObjectInspector) arguments[LENGTH_IDX], FUNC_NAME, LENGTH_IDX);\n    return defaultOI;\n  }", "refactored_code": "  private static final int START_IDX = 1;\n  @Override public ObjectInspector initialize(ObjectInspector[] arguments) throws UDFArgumentException {\n    ObjectInspector defaultOI = super.initialize(arguments);\n    // Check whether start and length inputs are of integer type\n    checkArgIntPrimitiveCategory((PrimitiveObjectInspector) arguments[START_IDX], FUNC_NAME, START_IDX);\n    checkArgIntPrimitiveCategory((PrimitiveObjectInspector) arguments[LENGTH_IDX], FUNC_NAME, LENGTH_IDX);\n    return defaultOI;\n  }"}
{"magic_number_smell": "    // See https://blogs.msdn.microsoft.com/sqlprogrammability/2006/03/29/multiplication-and-division-with-numerics/\n    int intDigits = precision - scale;\n    // If original scale less than 6, use original scale value; otherwise preserve at least 6 fractional digits\n    int minScaleValue = Math.min(scale, 6);\n    int adjustedScale = HiveDecimal.MAX_PRECISION - intDigits;\n    adjustedScale = Math.max(adjustedScale, minScaleValue);\n", "refactored_code": "  public static final int MINIMUM_ADJUSTED_SCALE = 6;\n    // See https://blogs.msdn.microsoft.com/sqlprogrammability/2006/03/29/multiplication-and-division-with-numerics/\n    int intDigits = precision - scale;\n    // If original scale less than 6, use original scale value; otherwise preserve at least 6 fractional digits\n    int minScaleValue = Math.min(scale, MINIMUM_ADJUSTED_SCALE);\n    int adjustedScale = HiveDecimal.MAX_PRECISION - intDigits;\n    adjustedScale = Math.max(adjustedScale, minScaleValue);\n"}
{"magic_number_smell": "    @Override\n    public ObjectInspector initialize(ObjectInspector[] arguments)\n            throws UDFArgumentException {\n        if (arguments.length != 2) {\n            throw new UDFArgumentException(\"The function \" + FUNC_NAME + \" accepts \" + 2 + \" arguments.\");\n        }\n        for (ObjectInspector arg: arguments) {", "refactored_code": "    private static final int ARG_COUNT = 2; // Number of arguments to this UDF\n    @Override\n    public ObjectInspector initialize(ObjectInspector[] arguments)\n            throws UDFArgumentException {\n        if (arguments.length != ARG_COUNT) {\n            throw new UDFArgumentException(\"The function \" + FUNC_NAME + \" accepts \" + ARG_COUNT + \" arguments.\");\n        }\n        for (ObjectInspector arg: arguments) {"}
{"magic_number_smell": "  private final ObjectInspectorConverter objectInspectorConverter;\n  private final ValueConverter valueConverter;\n\n  private int tag = -1;\n  private UnionObjectInspector unionOI;\n  private ObjectInspector sourceOI;\n", "refactored_code": "  private static final int ALL_TAGS = -1;\n  private final ObjectInspectorConverter objectInspectorConverter;\n  private final ValueConverter valueConverter;\n\n  private int tag = ALL_TAGS;\n  private UnionObjectInspector unionOI;\n  private ObjectInspector sourceOI;\n"}
{"magic_number_smell": "  @Override\n  public ObjectInspector initialize(ObjectInspector[] arguments) throws UDFArgumentException {\n    if (arguments.length == 0) {\n      writeIdBits = 24;\n      taskIdBits = DEFAULT_TASK_ID_BITS;\n      rowIdBits = DEFAULT_ROW_ID_BITS;\n    } else if (arguments.length == 2) {", "refactored_code": "  private static final int DEFAULT_WRITE_ID_BITS = 24;\n  @Override\n  public ObjectInspector initialize(ObjectInspector[] arguments) throws UDFArgumentException {\n    if (arguments.length == 0) {\n      writeIdBits = DEFAULT_WRITE_ID_BITS;\n      taskIdBits = DEFAULT_TASK_ID_BITS;\n      rowIdBits = DEFAULT_ROW_ID_BITS;\n    } else if (arguments.length == 2) {"}
{"magic_number_smell": "\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {\n      return size() > 16;\n    }\n\n  }", "refactored_code": "    private static final int CACHE_SIZE = 16;\n\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {\n      return size() > CACHE_SIZE;\n    }\n\n  }"}
{"magic_number_smell": "  public static final int DESCENDING_CODE = 0;\n\n  private static final ImmutableMap<String, Object> ASCENDING_DATA = ImmutableMap.of(\n      \"code\", 1,\n      \"sign\", '+',\n      \"text\", \"ASC\",\n      \"direction\", Direction.ASCENDING,", "refactored_code": "  public static final int ASCENDING_CODE = 1;\n  public static final int DESCENDING_CODE = 0;\n\n  private static final ImmutableMap<String, Object> ASCENDING_DATA = ImmutableMap.of(\n      \"code\", ASCENDING_CODE,\n      \"sign\", '+',\n      \"text\", \"ASC\",\n      \"direction\", Direction.ASCENDING,"}
{"magic_number_smell": "      //now that we know it can be made acid, rename files as needed\n      //process in batches in case there is a huge # of partitions\n      List<String> partNames = hms.listPartitionNames(t.getDbName(), t.getTableName(), (short)-1);\n      int batchSize = 10000;\n      int numWholeBatches = partNames.size()/batchSize;\n      for(int i = 0; i < numWholeBatches; i++) {\n        List<Partition> partitionList = hms.getPartitionsByNames(t.getDbName(), t.getTableName(),", "refactored_code": "  private static final int PARTITION_BATCH_SIZE = 10000;\n      //now that we know it can be made acid, rename files as needed\n      //process in batches in case there is a huge # of partitions\n      List<String> partNames = hms.listPartitionNames(t.getDbName(), t.getTableName(), (short)-1);\n      int batchSize = PARTITION_BATCH_SIZE;\n      int numWholeBatches = partNames.size()/batchSize;\n      for(int i = 0; i < numWholeBatches; i++) {\n        List<Partition> partitionList = hms.getPartitionsByNames(t.getDbName(), t.getTableName(),"}
{"magic_number_smell": "    for (int i = 0; i < size; i++) {\n      if (nulls && (repeating || i % nullFrequency == 0)) {\n        lcv.isNull[i] = true;\n        lcv.vector[i] = 1;\n\n      } else {\n        lcv.isNull[i] = false;", "refactored_code": "  private static final long LONG_VECTOR_NULL_VALUE = 1;\n    for (int i = 0; i < size; i++) {\n      if (nulls && (repeating || i % nullFrequency == 0)) {\n        lcv.isNull[i] = true;\n        lcv.vector[i] = LONG_VECTOR_NULL_VALUE;\n\n      } else {\n        lcv.isNull[i] = false;"}
{"magic_number_smell": "\n        } catch (ExecutionException ex) {\n          responseList.add(ex.getCause() instanceof CommandProcessorException ?\n                ErrorMsg.COMPILE_LOCK_TIMED_OUT.getErrorCode() : 15151);\n        }\n      }\n    } finally {", "refactored_code": "  private static final int CONCURRENT_COMPILATION = 15151;\n\n        } catch (ExecutionException ex) {\n          responseList.add(ex.getCause() instanceof CommandProcessorException ?\n                ErrorMsg.COMPILE_LOCK_TIMED_OUT.getErrorCode() : CONCURRENT_COMPILATION);\n        }\n      }\n    } finally {"}
{"magic_number_smell": "  }\n\n  public static class DummyOperator extends TableScanOperator {\n    private static final long 1L = 1L;\n\n    public DummyOperator(TableScanDesc conf) {\n      super();", "refactored_code": "    private static final long serialVersionUID = 1L;\n  }\n\n  public static class DummyOperator extends TableScanOperator {\n    private static final long serialVersionUID = 1L;\n\n    public DummyOperator(TableScanDesc conf) {\n      super();"}
{"magic_number_smell": "  }\n\n  private void runDropPartitions(int partCount, int batchSize) throws Exception {\n    runDropPartitions(partCount, batchSize, 0, 1);\n  }\n\n  /**", "refactored_code": "  private final int noException = 1;\n  }\n\n  private void runDropPartitions(int partCount, int batchSize) throws Exception {\n    runDropPartitions(partCount, batchSize, 0, noException);\n  }\n\n  /**"}
{"magic_number_smell": "  @Test\n  public void testRemoveTempOrDuplicateFilesOnMrNoDp() throws Exception {\n    List<Path> paths = runRemoveTempOrDuplicateFilesTestCase(\"mr\", false);\n    assertEquals(3, paths.size());\n  }\n\n  @Test", "refactored_code": "  private static final int NUM_BUCKETS = 3;\n  @Test\n  public void testRemoveTempOrDuplicateFilesOnMrNoDp() throws Exception {\n    List<Path> paths = runRemoveTempOrDuplicateFilesTestCase(\"mr\", false);\n    assertEquals(NUM_BUCKETS, paths.size());\n  }\n\n  @Test"}
{"magic_number_smell": "\n  @Test\n  public void testCapacityValidation() {\n    BytesBytesMultiHashMap map = new BytesBytesMultiHashMap(CAPACITY, 0.75f, WB_SIZE);\n    assertEquals(CAPACITY, map.getCapacity());\n    map = new BytesBytesMultiHashMap(9, 0.75f, WB_SIZE);\n    assertEquals(16, map.getCapacity());", "refactored_code": "  private static final float LOAD_FACTOR = 0.75f;\n\n  @Test\n  public void testCapacityValidation() {\n    BytesBytesMultiHashMap map = new BytesBytesMultiHashMap(CAPACITY, LOAD_FACTOR, WB_SIZE);\n    assertEquals(CAPACITY, map.getCapacity());\n    map = new BytesBytesMultiHashMap(9, LOAD_FACTOR, WB_SIZE);\n    assertEquals(16, map.getCapacity());"}
{"magic_number_smell": "      assertTrue(e.getMessage().contains(ABORT_TASK_ERROR_MSG));\n    }\n\n    assertEquals(2, commitTaskCounter);\n    assertEquals(2, abortTaskCounter);\n    assertEquals(0, commitJobCounter);\n    assertEquals(1, abortJobCounter);", "refactored_code": "  private static final int MAX_TASK_ATTEMPTS = 2;\n      assertTrue(e.getMessage().contains(ABORT_TASK_ERROR_MSG));\n    }\n\n    assertEquals(MAX_TASK_ATTEMPTS, commitTaskCounter);\n    assertEquals(MAX_TASK_ATTEMPTS, abortTaskCounter);\n    assertEquals(0, commitJobCounter);\n    assertEquals(1, abortJobCounter);"}
{"magic_number_smell": "     */\n    @Override\n    public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2) {\n      int c = -1 * WritableComparator.compareBytes(b1, s1 + 4, l1 - 4, b2,\n          s2 + 4, l2 - 4);\n      return c;\n    }", "refactored_code": "  private static final int LENGTH_BYTES = 4;\n     */\n    @Override\n    public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2) {\n      int c = -1 * WritableComparator.compareBytes(b1, s1 + LENGTH_BYTES, l1 - LENGTH_BYTES, b2,\n          s2 + LENGTH_BYTES, l2 - LENGTH_BYTES);\n      return c;\n    }"}
{"magic_number_smell": "\n    public FakeDataReader(int size, int numCols, FakeDataSampleType fakeDataSampleType) {\n      this.size = size;\n      vrg = new VectorizedRowBatch(numCols, 1024);\n      for (int i = 0; i < numCols; i++) {\n        try {\n          Thread.sleep(2);", "refactored_code": "    private final int len = 1024;\n\n    public FakeDataReader(int size, int numCols, FakeDataSampleType fakeDataSampleType) {\n      this.size = size;\n      vrg = new VectorizedRowBatch(numCols, len);\n      for (int i = 0; i < numCols; i++) {\n        try {\n          Thread.sleep(2);"}
{"magic_number_smell": "        /* allowNull */ false, /* isUnicodeOk */ true,\n        mergeDataTypePhysicalVariationList);\n\n    Object[][] mergeRandomRows = mergeRowSource.randomRows(100000);\n\n    // Reduce the key range to cause there to be work for each PARTIAL2 key.\n    final int mergeMaxKeyCount = dataAggrMaxKeyCount / reductionFactor;", "refactored_code": "  private static final int TEST_ROW_COUNT = 100000;\n        /* allowNull */ false, /* isUnicodeOk */ true,\n        mergeDataTypePhysicalVariationList);\n\n    Object[][] mergeRandomRows = mergeRowSource.randomRows(TEST_ROW_COUNT);\n\n    // Reduce the key range to cause there to be work for each PARTIAL2 key.\n    final int mergeMaxKeyCount = dataAggrMaxKeyCount / reductionFactor;"}
{"magic_number_smell": "\n  private void testWriterDouble(TypeInfo type) throws HiveException {\n    DoubleColumnVector dcv = VectorizedRowGroupGenUtil.generateDoubleColumnVector(true, false,\n        this.5, new Random(10));\n    dcv.isNull[2] = true;\n    VectorExpressionWriter vew = getWriter(type);\n    for (int i = 0; i < 5; i++) {", "refactored_code": "  private final int vectorSize = 5;\n\n  private void testWriterDouble(TypeInfo type) throws HiveException {\n    DoubleColumnVector dcv = VectorizedRowGroupGenUtil.generateDoubleColumnVector(true, false,\n        this.vectorSize, new Random(10));\n    dcv.isNull[2] = true;\n    VectorExpressionWriter vew = getWriter(type);\n    for (int i = 0; i < vectorSize; i++) {"}
{"magic_number_smell": "    v2.isRepeating = true; // this value should get over-written with correct value\n    v2.noNulls = true; // ditto\n\n    batch.size = 9;\n    return batch;\n  }\n", "refactored_code": "  private static final int BOOLEAN_COLUMN_TEST_SIZE = 9;\n    v2.isRepeating = true; // this value should get over-written with correct value\n    v2.noNulls = true; // ditto\n\n    batch.size = BOOLEAN_COLUMN_TEST_SIZE;\n    return batch;\n  }\n"}
{"magic_number_smell": "\n  private static final double 1.0e-7 = 1.0e-7;\n  private static boolean equalsWithinTolerance(double a, double b) {\n    return Math.abs(a - b) < 1.0e-7;\n  }\n\n  @Test", "refactored_code": "  private static final double eps = 1.0e-7;\n\n  private static final double eps = 1.0e-7;\n  private static boolean equalsWithinTolerance(double a, double b) {\n    return Math.abs(a - b) < eps;\n  }\n\n  @Test"}
{"magic_number_smell": "  }\n\n  private boolean equalsWithinTolerance(double a, double b) {\n    return Math.abs(a - b) < 1e-7d;\n  }\n\n  @Test", "refactored_code": "  private final double EPS = 1e-7d;\n  }\n\n  private boolean equalsWithinTolerance(double a, double b) {\n    return Math.abs(a - b) < EPS;\n  }\n\n  @Test"}
{"magic_number_smell": "        // No nanos.\n        break;\n      case 1:\n        optionalNanos = r.nextInt((int) TimeUnit.SECONDS.toNanos(1));\n        break;\n      case 2:\n        // Limit to milliseconds only...", "refactored_code": "  public static final long NANOSECONDS_PER_SECOND = TimeUnit.SECONDS.toNanos(1);\n        // No nanos.\n        break;\n      case 1:\n        optionalNanos = r.nextInt((int) NANOSECONDS_PER_SECOND);\n        break;\n      case 2:\n        // Limit to milliseconds only..."}
{"magic_number_smell": "            writeBufferSize,\n            estimatedKeyCount,\n            tableDesc,\n            2);\n\n    addToHashMap(hashMapContainer, keyA, properties);\n    addToHashMap(hashMapContainer, keyB, properties);", "refactored_code": "  private static final int numHashTable = 2;\n            writeBufferSize,\n            estimatedKeyCount,\n            tableDesc,\n            numHashTable);\n\n    addToHashMap(hashMapContainer, keyA, properties);\n    addToHashMap(hashMapContainer, keyB, properties);"}
{"magic_number_smell": "    for(int i = 0; i < size; i++) {\n      if(nulls && (repeating || i % nullFrequency == 0)) {\n        lcv.isNull[i] = true;\n        lcv.vector[i] = 1;\n\n      }else {\n        lcv.isNull[i] = false;", "refactored_code": "  private static final long LONG_VECTOR_NULL_VALUE = 1;\n    for(int i = 0; i < size; i++) {\n      if(nulls && (repeating || i % nullFrequency == 0)) {\n        lcv.isNull[i] = true;\n        lcv.vector[i] = LONG_VECTOR_NULL_VALUE;\n\n      }else {\n        lcv.isNull[i] = false;"}
{"magic_number_smell": "    return HiveHookEvents.HiveHookEventProto\n            .newBuilder()\n            .setEventType(HiveProtoLoggingHook.EventType.QUERY_SUBMITTED.name())\n            .setTimestamp(System.currentTimeMillis())\n            .setHiveQueryId(QUERY_1)\n            .setUser(HIVE)\n            .setRequestUser(HIVE)", "refactored_code": "  private static final long TIMESTAMP = System.currentTimeMillis();\n    return HiveHookEvents.HiveHookEventProto\n            .newBuilder()\n            .setEventType(HiveProtoLoggingHook.EventType.QUERY_SUBMITTED.name())\n            .setTimestamp(TIMESTAMP)\n            .setHiveQueryId(QUERY_1)\n            .setUser(HIVE)\n            .setRequestUser(HIVE)"}
{"magic_number_smell": "\n    private String path;\n    public static final long 1024 * 1024 = 1024 * 1024;\n    private long defaultSplitSize = 1024 * 1024;\n    private final List<HiveInputSplit> splits = new ArrayList<>();\n    private final List<HiveInputSplit> selectedSplits = new ArrayList<>();\n    private long position = 0;", "refactored_code": "    public static final long DEFAULT_SPLIT_SIZE = 1024 * 1024;\n\n    private String path;\n    public static final long DEFAULT_SPLIT_SIZE = 1024 * 1024;\n    private long defaultSplitSize = DEFAULT_SPLIT_SIZE;\n    private final List<HiveInputSplit> splits = new ArrayList<>();\n    private final List<HiveInputSplit> selectedSplits = new ArrayList<>();\n    private long position = 0;"}
{"magic_number_smell": "      throws IOException {\n    r.setSeed(seed);\n    for (int i = 0; i < iter; ++i) {\n      switch (r.nextInt(14)) {\n        case 0:\n          assertEquals((byte)(r.nextInt() & 0xFF), in.readByte()); break;\n        case 1:", "refactored_code": "  private static final int numCases = 14; \n      throws IOException {\n    r.setSeed(seed);\n    for (int i = 0; i < iter; ++i) {\n      switch (r.nextInt(numCases)) {\n        case 0:\n          assertEquals((byte)(r.nextInt() & 0xFF), in.readByte()); break;\n        case 1:"}
{"magic_number_smell": "    key = new OrcFileKeyWrapper();\n    value = new OrcFileValueWrapper();\n    tmpPath  = prepareTmpPath();\n    createOrcFile(5000, 5000 + 1);\n  }\n\n  @After", "refactored_code": "  private static final int TEST_STRIPE_SIZE = 5000;\n    key = new OrcFileKeyWrapper();\n    value = new OrcFileValueWrapper();\n    tmpPath  = prepareTmpPath();\n    createOrcFile(TEST_STRIPE_SIZE, TEST_STRIPE_SIZE + 1);\n  }\n\n  @After"}
{"magic_number_smell": "    RecordUpdater updater = new OrcRecordUpdater(root, options);\n    // Create a single insert delta with 150,000 rows, with 15000 rowIds per original transaction id.\n    for (long i = 1; i <= NUM_OWID; ++i) {\n      for (long j = 0; j < 15000L; ++j) {\n        long payload = (i-1) * 15000L + j;\n        updater.insert(i, new DummyRow(payload, j, i, bucket));\n      }", "refactored_code": "  private static final long NUM_ROWID_PER_OWID = 15000L;\n    RecordUpdater updater = new OrcRecordUpdater(root, options);\n    // Create a single insert delta with 150,000 rows, with 15000 rowIds per original transaction id.\n    for (long i = 1; i <= NUM_OWID; ++i) {\n      for (long j = 0; j < NUM_ROWID_PER_OWID; ++j) {\n        long payload = (i-1) * NUM_ROWID_PER_OWID + j;\n        updater.insert(i, new DummyRow(payload, j, i, bucket));\n      }"}
{"magic_number_smell": "    long minute = calendar.get(Calendar.MINUTE);\n    long second = calendar.get(Calendar.SECOND);\n    long nanos = ts.getNanos();\n    long nanosOfDay = nanos + NANOS_PER_SECOND * second + NANOS_PER_MINUTE * minute + TimeUnit.HOURS.toNanos(1) * hour;\n\n    return new NanoTime(days, nanosOfDay);\n  }", "refactored_code": "  private static final long NANOS_PER_HOUR = TimeUnit.HOURS.toNanos(1);\n    long minute = calendar.get(Calendar.MINUTE);\n    long second = calendar.get(Calendar.SECOND);\n    long nanos = ts.getNanos();\n    long nanosOfDay = nanos + NANOS_PER_SECOND * second + NANOS_PER_MINUTE * minute + NANOS_PER_HOUR * hour;\n\n    return new NanoTime(days, nanosOfDay);\n  }"}
{"magic_number_smell": "    testLockExpiration(txnMgr, 5, true);\n\n    //create a lot of locks\n    for(int i = 0; i < 1000 + 17; i++) {\n      ((DbTxnManager)txnMgr).acquireLocks(qp, ctx, \"PeterI\" + i, true); // No heartbeat\n    }\n    testLockExpiration(txnMgr, 1000 + 17, true);", "refactored_code": "  private static final int TEST_TIMED_OUT_TXN_ABORT_BATCH_SIZE = 1000;\n    testLockExpiration(txnMgr, 5, true);\n\n    //create a lot of locks\n    for(int i = 0; i < TEST_TIMED_OUT_TXN_ABORT_BATCH_SIZE + 17; i++) {\n      ((DbTxnManager)txnMgr).acquireLocks(qp, ctx, \"PeterI\" + i, true); // No heartbeat\n    }\n    testLockExpiration(txnMgr, TEST_TIMED_OUT_TXN_ABORT_BATCH_SIZE + 17, true);"}
{"magic_number_smell": "\n  @Test\n  public void testLessThanSelectivity() {\n    Assert.assertEquals(0.6153846153846154, lessThanSelectivity(KLL, 3), Float.MIN_VALUE);\n  }\n\n  @Test", "refactored_code": "  private static final float DELTA = Float.MIN_VALUE;\n\n  @Test\n  public void testLessThanSelectivity() {\n    Assert.assertEquals(0.6153846153846154, lessThanSelectivity(KLL, 3), DELTA);\n  }\n\n  @Test"}
{"magic_number_smell": "  }\n\n  static class SampleOperator extends Operator<SampleDesc> {\n    private static final long 1L = 1L;\n\n    @Override\n    public void process(Object row, int tag) throws HiveException {", "refactored_code": "    private static final long serialVersionUID = 1L;\n  }\n\n  static class SampleOperator extends Operator<SampleDesc> {\n    private static final long serialVersionUID = 1L;\n\n    @Override\n    public void process(Object row, int tag) throws HiveException {"}
{"magic_number_smell": "\n  @Test\n  public void testGetTargetSizeTotalLength() {\n    splitSample = new SplitSample(TOTAL_LENGTH, 123);\n    assertEquals(TOTAL_LENGTH, splitSample.getTargetSize(1000));\n    assertEquals(TOTAL_LENGTH, splitSample.getTargetSize(100));\n  }", "refactored_code": "  private static final int SEED_NUM = 123;\n\n  @Test\n  public void testGetTargetSizeTotalLength() {\n    splitSample = new SplitSample(TOTAL_LENGTH, SEED_NUM);\n    assertEquals(TOTAL_LENGTH, splitSample.getTargetSize(1000));\n    assertEquals(TOTAL_LENGTH, splitSample.getTargetSize(100));\n  }"}
{"magic_number_smell": "\npublic class TestReplStateLogTimeFormat {\n  private static final long 1659367078L = 1659367078L;\n  private static final String UTCString = Instant.ofEpochSecond(1659367078L).toString();\n  private static final Set<Class<? extends ReplState>> DUMP_LOG_EXEMPTED_CLASSES;\n  private static final Set<Class<? extends ReplState>> LOAD_LOG_EXEMPTED_CLASSES;\n", "refactored_code": "  private static final long randomDate = 1659367078L;\n\npublic class TestReplStateLogTimeFormat {\n  private static final long randomDate = 1659367078L;\n  private static final String UTCString = Instant.ofEpochSecond(randomDate).toString();\n  private static final Set<Class<? extends ReplState>> DUMP_LOG_EXEMPTED_CLASSES;\n  private static final Set<Class<? extends ReplState>> LOAD_LOG_EXEMPTED_CLASSES;\n"}
{"magic_number_smell": "  }\n\n  private void configureAndSubmitTasks() throws HiveException {\n    when(conf.getIntVar(HiveConf.ConfVars.REPL_TABLE_DUMP_PARALLELISM)).thenReturn(50);\n    exportService = new ExportService(conf);\n    taskNumber = 0;\n    sem = new Semaphore(totalTask);", "refactored_code": "  private final int nThreads = 50;\n  }\n\n  private void configureAndSubmitTasks() throws HiveException {\n    when(conf.getIntVar(HiveConf.ConfVars.REPL_TABLE_DUMP_PARALLELISM)).thenReturn(nThreads);\n    exportService = new ExportService(conf);\n    taskNumber = 0;\n    sem = new Semaphore(totalTask);"}
{"magic_number_smell": "  private static final int NUM_TBL = TEST? 100 : 10000;\n  private static final int NLOOPS = TEST? 1 : 40;\n\n  private final List<TestTable> tables = createTables(TEST? 2 : 20, NUM_TBL);\n  // lookup some\n  private final List<TestTable> filtered = tables.stream()\n      .filter(t -> t.getTableName().endsWith(\"0\"))", "refactored_code": "  private static final int NUM_DB = TEST? 2 : 20;\n  private static final int NUM_TBL = TEST? 100 : 10000;\n  private static final int NLOOPS = TEST? 1 : 40;\n\n  private final List<TestTable> tables = createTables(NUM_DB, NUM_TBL);\n  // lookup some\n  private final List<TestTable> filtered = tables.stream()\n      .filter(t -> t.getTableName().endsWith(\"0\"))"}
{"magic_number_smell": "   * {@link AcidUtils#DELTA_SIDE_FILE_SUFFIX} side file.\n   * @param dataFile - ORC acid data file\n   * @return version property from file if there,\n   *          {@link #0} otherwise\n   */\n  private static int getAcidVersionFromDataFile(Path dataFile, FileSystem fs) throws IOException {\n    FileStatus fileStatus = fs.getFileStatus(dataFile);", "refactored_code": "  private static final int ORC_ACID_VERSION_DEFAULT = 0;\n   * {@link AcidUtils#DELTA_SIDE_FILE_SUFFIX} side file.\n   * @param dataFile - ORC acid data file\n   * @return version property from file if there,\n   *          {@link #ORC_ACID_VERSION_DEFAULT} otherwise\n   */\n  private static int getAcidVersionFromDataFile(Path dataFile, FileSystem fs) throws IOException {\n    FileStatus fileStatus = fs.getFileStatus(dataFile);"}
{"magic_number_smell": "    testCast(STRING, inputOI, date(\"2009-07-30\"), \"yyyy\", \"2009\");\n    testCast(STRING, inputOI, date(\"1969-07-30\"), \"dd\", \"30\");\n\n    testCast(HiveParser.TOK_CHAR, 3, inputOI, date(\"2009-07-30\"), \"yyyy-MM-dd\", \"200\");\n    testCast(HiveParser.TOK_CHAR, 3, inputOI, date(\"2009-07-30\"), \"yyyy\", \"200\");\n    testCast(HiveParser.TOK_CHAR, 3, inputOI, date(\"1969-07-30\"), \"dd\", \"30 \");\n", "refactored_code": "  public static final int CHAR = HiveParser.TOK_CHAR;\n    testCast(STRING, inputOI, date(\"2009-07-30\"), \"yyyy\", \"2009\");\n    testCast(STRING, inputOI, date(\"1969-07-30\"), \"dd\", \"30\");\n\n    testCast(CHAR, 3, inputOI, date(\"2009-07-30\"), \"yyyy-MM-dd\", \"200\");\n    testCast(CHAR, 3, inputOI, date(\"2009-07-30\"), \"yyyy\", \"200\");\n    testCast(CHAR, 3, inputOI, date(\"1969-07-30\"), \"dd\", \"30 \");\n"}
{"magic_number_smell": "    PrimitiveObjectInspector oi = (PrimitiveObjectInspector) udf.initialize(inputOIs);\n    Assert.assertEquals(oi.getTypeInfo(), TypeInfoFactory.doubleTypeInfo);\n    DoubleWritable res = (DoubleWritable) udf.evaluate(args);\n    Assert.assertEquals(123.0 / 456.0, res.get(), 1E-6);\n  }\n\n  @Test", "refactored_code": "  private static final double EPSILON = 1E-6;\n    PrimitiveObjectInspector oi = (PrimitiveObjectInspector) udf.initialize(inputOIs);\n    Assert.assertEquals(oi.getTypeInfo(), TypeInfoFactory.doubleTypeInfo);\n    DoubleWritable res = (DoubleWritable) udf.evaluate(args);\n    Assert.assertEquals(123.0 / 456.0, res.get(), EPSILON);\n  }\n\n  @Test"}
{"magic_number_smell": "    PrimitiveObjectInspector oi = (PrimitiveObjectInspector) udf.initialize(inputOIs);\n    Assert.assertEquals(oi.getTypeInfo(), TypeInfoFactory.doubleTypeInfo);\n    DoubleWritable res = (DoubleWritable) udf.evaluate(args);\n    Assert.assertEquals(-333.0, res.get(), 1E-6);\n  }\n\n  @Test", "refactored_code": "  private static final double EPSILON = 1E-6;\n    PrimitiveObjectInspector oi = (PrimitiveObjectInspector) udf.initialize(inputOIs);\n    Assert.assertEquals(oi.getTypeInfo(), TypeInfoFactory.doubleTypeInfo);\n    DoubleWritable res = (DoubleWritable) udf.evaluate(args);\n    Assert.assertEquals(-333.0, res.get(), EPSILON);\n  }\n\n  @Test"}
{"magic_number_smell": "    PrimitiveObjectInspector oi = (PrimitiveObjectInspector) udf.initialize(inputOIs);\n    Assert.assertEquals(oi.getTypeInfo(), TypeInfoFactory.doubleTypeInfo);\n    DoubleWritable res = (DoubleWritable) udf.evaluate(args);\n    Assert.assertEquals(123 * 456, res.get(), 1E-6);\n  }\n\n  @Test", "refactored_code": "  private static final double EPSILON = 1E-6;\n    PrimitiveObjectInspector oi = (PrimitiveObjectInspector) udf.initialize(inputOIs);\n    Assert.assertEquals(oi.getTypeInfo(), TypeInfoFactory.doubleTypeInfo);\n    DoubleWritable res = (DoubleWritable) udf.evaluate(args);\n    Assert.assertEquals(123 * 456, res.get(), EPSILON);\n  }\n\n  @Test"}
{"magic_number_smell": "    PrimitiveObjectInspector oi = (PrimitiveObjectInspector) udf.initialize(inputOIs);\n    Assert.assertEquals(TypeInfoFactory.floatTypeInfo, oi.getTypeInfo());\n    FloatWritable res = (FloatWritable) udf.evaluate(args);\n    Assert.assertEquals(-323.4747f, res.get(), 1E-6);\n  }\n\n  @Test", "refactored_code": "  private static final double EPSILON = 1E-6;\n    PrimitiveObjectInspector oi = (PrimitiveObjectInspector) udf.initialize(inputOIs);\n    Assert.assertEquals(TypeInfoFactory.floatTypeInfo, oi.getTypeInfo());\n    FloatWritable res = (FloatWritable) udf.evaluate(args);\n    Assert.assertEquals(-323.4747f, res.get(), EPSILON);\n  }\n\n  @Test"}
{"magic_number_smell": "    PrimitiveObjectInspector oi = (PrimitiveObjectInspector) udf.initialize(inputOIs);\n    Assert.assertEquals(oi.getTypeInfo(), TypeInfoFactory.doubleTypeInfo);\n    DoubleWritable res = (DoubleWritable) udf.evaluate(args);\n    Assert.assertEquals(579.0, res.get(), 1E-6);\n  }\n\n  @Test", "refactored_code": "  private static final double EPSILON = 1E-6;\n    PrimitiveObjectInspector oi = (PrimitiveObjectInspector) udf.initialize(inputOIs);\n    Assert.assertEquals(oi.getTypeInfo(), TypeInfoFactory.doubleTypeInfo);\n    DoubleWritable res = (DoubleWritable) udf.evaluate(args);\n    Assert.assertEquals(579.0, res.get(), EPSILON);\n  }\n\n  @Test"}
{"magic_number_smell": "    PrimitiveObjectInspector oi = (PrimitiveObjectInspector) udf.initialize(inputOIs);\n    Assert.assertEquals(TypeInfoFactory.floatTypeInfo, oi.getTypeInfo());\n    FloatWritable res = (FloatWritable) udf.evaluate(args);\n    Assert.assertEquals(323.4747, res.get(), 1E-6);\n  }\n\n  @Test", "refactored_code": "  private static final double EPSILON = 1E-6;\n    PrimitiveObjectInspector oi = (PrimitiveObjectInspector) udf.initialize(inputOIs);\n    Assert.assertEquals(TypeInfoFactory.floatTypeInfo, oi.getTypeInfo());\n    FloatWritable res = (FloatWritable) udf.evaluate(args);\n    Assert.assertEquals(323.4747, res.get(), EPSILON);\n  }\n\n  @Test"}
{"magic_number_smell": "    PrimitiveObjectInspector oi = (PrimitiveObjectInspector) udf.initialize(inputOIs);\n    Assert.assertEquals(TypeInfoFactory.doubleTypeInfo, oi.getTypeInfo());\n    DoubleWritable res = (DoubleWritable) udf.evaluate(args);\n    Assert.assertEquals(16, res.get(), 1E-10);\n  }\n\n  @Test", "refactored_code": "  private static final double EPSILON = 1E-10;\n    PrimitiveObjectInspector oi = (PrimitiveObjectInspector) udf.initialize(inputOIs);\n    Assert.assertEquals(TypeInfoFactory.doubleTypeInfo, oi.getTypeInfo());\n    DoubleWritable res = (DoubleWritable) udf.evaluate(args);\n    Assert.assertEquals(16, res.get(), EPSILON);\n  }\n\n  @Test"}
{"magic_number_smell": "          LOG.info(\"Cache: \" + cacheSize + \" order: \" + order);\n          BoundaryCache cache = cacheSize == null ? null : new BoundaryCache(cacheSize);\n          Pair<PTFPartition, ValueBoundaryScanner> mocks = setupMocks(partition,\n                  2, startBoundary, endBoundary, order, cache, readCounter);\n          PTFPartition ptfPartition = mocks.getLeft();\n          ValueBoundaryScanner scanner = mocks.getRight();\n          for (int i = 0; i < partition.size(); ++i) {", "refactored_code": "  private static final int ORDER_BY_COL = 2;\n          LOG.info(\"Cache: \" + cacheSize + \" order: \" + order);\n          BoundaryCache cache = cacheSize == null ? null : new BoundaryCache(cacheSize);\n          Pair<PTFPartition, ValueBoundaryScanner> mocks = setupMocks(partition,\n                  ORDER_BY_COL, startBoundary, endBoundary, order, cache, readCounter);\n          PTFPartition ptfPartition = mocks.getLeft();\n          ValueBoundaryScanner scanner = mocks.getRight();\n          for (int i = 0; i < partition.size(); ++i) {"}
{"magic_number_smell": "      if (this.tickTime > 0) {\n        tickTimeToUse = this.tickTime;\n      } else {\n        tickTimeToUse = 2000;\n      }\n\n      // Set up client port - if we have already had a list of valid ports, use it.", "refactored_code": "  private static final int TICK_TIME = 2000;\n      if (this.tickTime > 0) {\n        tickTimeToUse = this.tickTime;\n      } else {\n        tickTimeToUse = TICK_TIME;\n      }\n\n      // Set up client port - if we have already had a list of valid ports, use it."}
{"magic_number_smell": "  }\n\n  public void unsetField0() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field field0 is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __FIELD0_ISSET_ID = 0;\n  }\n\n  public void unsetField0() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __FIELD0_ISSET_ID);\n  }\n\n  /** Returns true if field field0 is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetField1() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field field1 is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __FIELD1_ISSET_ID = 0;\n  }\n\n  public void unsetField1() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __FIELD1_ISSET_ID);\n  }\n\n  /** Returns true if field field1 is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetAint() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field aint is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __AINT_ISSET_ID = 0;\n  }\n\n  public void unsetAint() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __AINT_ISSET_ID);\n  }\n\n  /** Returns true if field aint is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetMyint() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field myint is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __MYINT_ISSET_ID = 0;\n  }\n\n  public void unsetMyint() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __MYINT_ISSET_ID);\n  }\n\n  /** Returns true if field myint is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetMy_bool() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field my_bool is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __MY_BOOL_ISSET_ID = 0;\n  }\n\n  public void unsetMy_bool() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __MY_BOOL_ISSET_ID);\n  }\n\n  /** Returns true if field my_bool is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "      break;\n    case 1:\n      optionalNanos = String.format(\".%09d\",\n          Integer.valueOf(r.nextInt((int) TimeUnit.SECONDS.toNanos(1))));\n      break;\n    case 2:\n      // Limit to milliseconds only...", "refactored_code": "  public static final long NANOSECONDS_PER_SECOND = TimeUnit.SECONDS.toNanos(1);\n      break;\n    case 1:\n      optionalNanos = String.format(\".%09d\",\n          Integer.valueOf(r.nextInt((int) NANOSECONDS_PER_SECOND)));\n      break;\n    case 2:\n      // Limit to milliseconds only..."}
{"magic_number_smell": "\n    int firstInt = (int) seconds;\n    if (hasDecimal || hasSecondVInt) {\n      firstInt |= 1 << 31;\n    }\n    intToBytes(firstInt, internalBytes, offset);\n    if (hasSecondVInt) {", "refactored_code": "  private static final int DECIMAL_OR_SECOND_VINT_FLAG = 1 << 31;\n\n    int firstInt = (int) seconds;\n    if (hasDecimal || hasSecondVInt) {\n      firstInt |= DECIMAL_OR_SECOND_VINT_FLAG;\n    }\n    intToBytes(firstInt, internalBytes, offset);\n    if (hasSecondVInt) {"}
{"magic_number_smell": "    int firstInt = (int) seconds;\n    boolean hasSecondVInt = seconds < 0 || seconds > Integer.MAX_VALUE;\n    if (nanos != 0 || hasSecondVInt) {\n      firstInt |= 0x80000000;\n    } else {\n      firstInt &= LOWEST_31_BITS_OF_SEC_MASK;\n    }", "refactored_code": "  private static final int DECIMAL_OR_SECOND_VINT_FLAG = 0x80000000;\n    int firstInt = (int) seconds;\n    boolean hasSecondVInt = seconds < 0 || seconds > Integer.MAX_VALUE;\n    if (nanos != 0 || hasSecondVInt) {\n      firstInt |= DECIMAL_OR_SECOND_VINT_FLAG;\n    } else {\n      firstInt &= LOWEST_31_BITS_OF_SEC_MASK;\n    }"}
{"magic_number_smell": "    int firstInt = (int) seconds;\n    boolean hasSecondVInt = seconds < 0 || seconds > Integer.MAX_VALUE;\n    if (nanos != 0 || hasSecondVInt) {\n      firstInt |= 0x80000000;\n    } else {\n      firstInt &= LOWEST_31_BITS_OF_SEC_MASK;\n    }", "refactored_code": "  private static final int DECIMAL_OR_SECOND_VINT_FLAG = 0x80000000;\n    int firstInt = (int) seconds;\n    boolean hasSecondVInt = seconds < 0 || seconds > Integer.MAX_VALUE;\n    if (nanos != 0 || hasSecondVInt) {\n      firstInt |= DECIMAL_OR_SECOND_VINT_FLAG;\n    } else {\n      firstInt &= LOWEST_31_BITS_OF_SEC_MASK;\n    }"}
{"magic_number_smell": "  private static ThreadLocal<byte[]> vLongBytesThreadLocal = new ThreadLocal<byte[]>() {\n    @Override\n    public byte[] initialValue() {\n      return new byte[9];\n    }\n  };\n", "refactored_code": "  public static final int VLONG_BYTES_LEN = 9;\n  private static ThreadLocal<byte[]> vLongBytesThreadLocal = new ThreadLocal<byte[]>() {\n    @Override\n    public byte[] initialValue() {\n      return new byte[VLONG_BYTES_LEN];\n    }\n  };\n"}
{"magic_number_smell": "      return null;\n    }\n    String dateString = String.valueOf(di + 19000000);\n    if (dateString.length() < 8) {\n      dateString = StringUtils.leftPad(dateString, 8, '0');\n    }\n    Date date = new Date();", "refactored_code": "  private static final int DATE_STRING_LENGTH = 8;\n      return null;\n    }\n    String dateString = String.valueOf(di + 19000000);\n    if (dateString.length() < DATE_STRING_LENGTH) {\n      dateString = StringUtils.leftPad(dateString, DATE_STRING_LENGTH, '0');\n    }\n    Date date = new Date();"}
{"magic_number_smell": "    }\n    write(sTimeStamp.getBytes(\"UTF8\"));\n    String pad;\n    if (sTimeStamp.length() == 19) {\n      pad = \".\" + join(\"\", Collections.nCopies(byteNum - sTimeStamp.length() - 1, \"0\"));\n    } else {\n      pad = join(\"\", Collections.nCopies(byteNum - sTimeStamp.length(), \"0\"));", "refactored_code": "  private static final int TIMESTAMP_NO_NANOS_BYTE_NUM = 19;\n    }\n    write(sTimeStamp.getBytes(\"UTF8\"));\n    String pad;\n    if (sTimeStamp.length() == TIMESTAMP_NO_NANOS_BYTE_NUM) {\n      pad = \".\" + join(\"\", Collections.nCopies(byteNum - sTimeStamp.length() - 1, \"0\"));\n    } else {\n      pad = join(\"\", Collections.nCopies(byteNum - sTimeStamp.length(), \"0\"));"}
{"magic_number_smell": "\n  private int getTimeStampByteNum(int precision) {\n    if (precision == 0) {\n      return 19;\n    } else {\n      return precision + 1 + 19;\n    }", "refactored_code": "  private static final int DEFAULT_TIMESTAMP_BYTE_NUM = 19;\n\n  private int getTimeStampByteNum(int precision) {\n    if (precision == 0) {\n      return DEFAULT_TIMESTAMP_BYTE_NUM;\n    } else {\n      return precision + 1 + DEFAULT_TIMESTAMP_BYTE_NUM;\n    }"}
{"magic_number_smell": "    nulls = new BitSet();\n    switch (type) {\n      case BOOLEAN_TYPE:\n        boolVars = new boolean[100];\n        break;\n      case TINYINT_TYPE:\n        byteVars = new byte[100];", "refactored_code": "  private static final int DEFAULT_SIZE = 100;\n    nulls = new BitSet();\n    switch (type) {\n      case BOOLEAN_TYPE:\n        boolVars = new boolean[DEFAULT_SIZE];\n        break;\n      case TINYINT_TYPE:\n        byteVars = new byte[DEFAULT_SIZE];"}
{"magic_number_smell": "  private static final int 4 = 4;\n  private static final int SCALE = 2;\n  private static final TypeInfo DECIMAL = TypeInfoFactory.getPrimitiveTypeInfo(\n      new DecimalTypeInfo(4, SCALE).getQualifiedName());\n  private static final int CHAR_LEN = 5;\n  private static final TypeInfo CHAR = TypeInfoFactory.getPrimitiveTypeInfo(\n      new CharTypeInfo(CHAR_LEN).getQualifiedName());", "refactored_code": "  private static final int PRECISION = 4;\n  private static final int PRECISION = 4;\n  private static final int SCALE = 2;\n  private static final TypeInfo DECIMAL = TypeInfoFactory.getPrimitiveTypeInfo(\n      new DecimalTypeInfo(PRECISION, SCALE).getQualifiedName());\n  private static final int CHAR_LEN = 5;\n  private static final TypeInfo CHAR = TypeInfoFactory.getPrimitiveTypeInfo(\n      new CharTypeInfo(CHAR_LEN).getQualifiedName());"}
{"magic_number_smell": "\n      int nanos = reverseNanos(ts.getNanos());\n      assertEquals(ts,\n        fromIntAndVInts((int) timeSeconds | (nanos != 0 ? 0x80000000 : 0),\n          nanos).getTimestamp());\n    }\n", "refactored_code": "  private static final int HAS_DECIMAL_MASK = 0x80000000;\n\n      int nanos = reverseNanos(ts.getNanos());\n      assertEquals(ts,\n        fromIntAndVInts((int) timeSeconds | (nanos != 0 ? HAS_DECIMAL_MASK : 0),\n          nanos).getTimestamp());\n    }\n"}
{"magic_number_smell": "    this.type = type;\n    switch (type) {\n      case BOOLEAN_TYPE:\n        vars = new boolean[100];\n        break;\n      case TINYINT_TYPE:\n        vars = new byte[100];", "refactored_code": "  private static final int NUM_VARS = 100;\n    this.type = type;\n    switch (type) {\n      case BOOLEAN_TYPE:\n        vars = new boolean[NUM_VARS];\n        break;\n      case TINYINT_TYPE:\n        vars = new byte[NUM_VARS];"}
{"magic_number_smell": "\n  @Override\n  public long getStartTime() {\n    return System.currentTimeMillis();\n  }\n\n}", "refactored_code": "  private final long startTime = System.currentTimeMillis();\n\n  @Override\n  public long getStartTime() {\n    return startTime;\n  }\n\n}"}
{"magic_number_smell": "    boolean terminated = operation.isDone();\n    try {\n      while ((sessionState.getProgressMonitor() == null) && !terminated) {\n        long remainingMs = (30 * 1000000000l - (System.nanoTime() - startTime)) / 1000000l;\n        if (remainingMs <= 0) {\n          LOG.debug(\"timed out and hence returning progress log as NULL\");\n          return new JobProgressUpdate(ProgressMonitor.NULL);", "refactored_code": "  private static final long PROGRESS_MAX_WAIT_NS = 30 * 1000000000l;\n    boolean terminated = operation.isDone();\n    try {\n      while ((sessionState.getProgressMonitor() == null) && !terminated) {\n        long remainingMs = (PROGRESS_MAX_WAIT_NS - (System.nanoTime() - startTime)) / 1000000l;\n        if (remainingMs <= 0) {\n          LOG.debug(\"timed out and hence returning progress log as NULL\");\n          return new JobProgressUpdate(ProgressMonitor.NULL);"}
{"magic_number_smell": "  private void shutdownExecutor(final ExecutorService leaderActionsExecutorService) {\n    leaderActionsExecutorService.shutdown();\n    try {\n      if (!leaderActionsExecutorService.awaitTermination(60, TimeUnit.SECONDS)) {\n        LOG.warn(\"Executor service did not terminate in the specified time {} sec\", 60);\n        List<Runnable> droppedTasks = leaderActionsExecutorService.shutdownNow();\n        LOG.warn(\"Executor service was abruptly shut down. \" + droppedTasks.size() + \" tasks will not be executed.\");", "refactored_code": "  private static final int SHUTDOWN_TIME = 60;\n  private void shutdownExecutor(final ExecutorService leaderActionsExecutorService) {\n    leaderActionsExecutorService.shutdown();\n    try {\n      if (!leaderActionsExecutorService.awaitTermination(SHUTDOWN_TIME, TimeUnit.SECONDS)) {\n        LOG.warn(\"Executor service did not terminate in the specified time {} sec\", SHUTDOWN_TIME);\n        List<Runnable> droppedTasks = leaderActionsExecutorService.shutdownNow();\n        LOG.warn(\"Executor service was abruptly shut down. \" + droppedTasks.size() + \" tasks will not be executed.\");"}
{"magic_number_smell": "    try {\n      barrier.setBarrier(queryIdOrTag, hiveServer2.getServerInstanceURI(), doAs, doAsAdmin);\n      LOG.info(\"Created kill query barrier in path: {} for queryId: {}\", barrier.getBarrierPath(), queryIdOrTag);\n      result = barrier.waitOnBarrier(serverHosts.size() - 1, 30,\n          MAX_WAIT_ON_KILL_SECONDS, TimeUnit.SECONDS);\n\n    } catch (Exception e) {", "refactored_code": "  public static final int MAX_WAIT_ON_CONFIRMATION_SECONDS = 30;\n    try {\n      barrier.setBarrier(queryIdOrTag, hiveServer2.getServerInstanceURI(), doAs, doAsAdmin);\n      LOG.info(\"Created kill query barrier in path: {} for queryId: {}\", barrier.getBarrierPath(), queryIdOrTag);\n      result = barrier.waitOnBarrier(serverHosts.size() - 1, MAX_WAIT_ON_CONFIRMATION_SECONDS,\n          MAX_WAIT_ON_KILL_SECONDS, TimeUnit.SECONDS);\n\n    } catch (Exception e) {"}
{"magic_number_smell": "\n    boolean allComplete = false;\n    final long step = 200;\n    final long timeout = System.currentTimeMillis() + 600000;\n\n    while (!allComplete) {\n      allComplete = true;", "refactored_code": "  private static final long ASYNC_QUERY_TIMEOUT_MS = 600000;\n\n    boolean allComplete = false;\n    final long step = 200;\n    final long timeout = System.currentTimeMillis() + ASYNC_QUERY_TIMEOUT_MS;\n\n    while (!allComplete) {\n      allComplete = true;"}
{"magic_number_smell": "\n    @Override\n    public long getNoOperationTime() {\n      return 0xbeef0001;\n    }\n  }\n", "refactored_code": "    public static final int MAGIC_RETURN_VALUE = 0xbeef0001;\n\n    @Override\n    public long getNoOperationTime() {\n      return MAGIC_RETURN_VALUE;\n    }\n  }\n"}
{"magic_number_smell": "  private static CodahaleMetrics metrics;\n  private static final int 30 = 30;\n  private static final String FAIL_TO_START_MSG = \"The tasks could not be started within \"\n      + 30 + \" seconds before the %s metrics verification.\";\n  private static final String FAIL_TO_COMPLETE_MSG = \"The tasks could not be completed within \"\n      + 30 + \" seconds after the %s metrics verification.\";\n", "refactored_code": "  private static final int BARRIER_AWAIT_TIMEOUT = 30;\n  private static CodahaleMetrics metrics;\n  private static final int BARRIER_AWAIT_TIMEOUT = 30;\n  private static final String FAIL_TO_START_MSG = \"The tasks could not be started within \"\n      + BARRIER_AWAIT_TIMEOUT + \" seconds before the %s metrics verification.\";\n  private static final String FAIL_TO_COMPLETE_MSG = \"The tasks could not be completed within \"\n      + BARRIER_AWAIT_TIMEOUT + \" seconds after the %s metrics verification.\";\n"}
{"magic_number_smell": "  }\n\n  public void unsetObjectTypePtr() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field objectTypePtr is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __OBJECTTYPEPTR_ISSET_ID = 0;\n  }\n\n  public void unsetObjectTypePtr() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __OBJECTTYPEPTR_ISSET_ID);\n  }\n\n  /** Returns true if field objectTypePtr is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetValue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field value is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __VALUE_ISSET_ID = 0;\n  }\n\n  public void unsetValue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __VALUE_ISSET_ID);\n  }\n\n  /** Returns true if field value is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetValue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field value is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __VALUE_ISSET_ID = 0;\n  }\n\n  public void unsetValue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __VALUE_ISSET_ID);\n  }\n\n  /** Returns true if field value is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetPosition() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field position is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __POSITION_ISSET_ID = 0;\n  }\n\n  public void unsetPosition() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __POSITION_ISSET_ID);\n  }\n\n  /** Returns true if field position is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetValue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field value is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __VALUE_ISSET_ID = 0;\n  }\n\n  public void unsetValue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __VALUE_ISSET_ID);\n  }\n\n  /** Returns true if field value is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetRunAsync() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field runAsync is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __RUNASYNC_ISSET_ID = 0;\n  }\n\n  public void unsetRunAsync() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __RUNASYNC_ISSET_ID);\n  }\n\n  /** Returns true if field runAsync is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetMaxRows() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field maxRows is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __MAXROWS_ISSET_ID = 0;\n  }\n\n  public void unsetMaxRows() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __MAXROWS_ISSET_ID);\n  }\n\n  /** Returns true if field maxRows is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetHasMoreRows() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field hasMoreRows is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __HASMOREROWS_ISSET_ID = 0;\n  }\n\n  public void unsetHasMoreRows() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __HASMOREROWS_ISSET_ID);\n  }\n\n  /** Returns true if field hasMoreRows is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetGetProgressUpdate() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field getProgressUpdate is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __GETPROGRESSUPDATE_ISSET_ID = 0;\n  }\n\n  public void unsetGetProgressUpdate() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __GETPROGRESSUPDATE_ISSET_ID);\n  }\n\n  /** Returns true if field getProgressUpdate is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetErrorCode() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field errorCode is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ERRORCODE_ISSET_ID = 0;\n  }\n\n  public void unsetErrorCode() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ERRORCODE_ISSET_ID);\n  }\n\n  /** Returns true if field errorCode is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetValue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field value is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __VALUE_ISSET_ID = 0;\n  }\n\n  public void unsetValue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __VALUE_ISSET_ID);\n  }\n\n  /** Returns true if field value is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetValue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field value is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __VALUE_ISSET_ID = 0;\n  }\n\n  public void unsetValue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __VALUE_ISSET_ID);\n  }\n\n  /** Returns true if field value is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetValue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field value is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __VALUE_ISSET_ID = 0;\n  }\n\n  public void unsetValue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __VALUE_ISSET_ID);\n  }\n\n  /** Returns true if field value is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetKeyTypePtr() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field keyTypePtr is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __KEYTYPEPTR_ISSET_ID = 0;\n  }\n\n  public void unsetKeyTypePtr() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __KEYTYPEPTR_ISSET_ID);\n  }\n\n  /** Returns true if field keyTypePtr is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetHasResultSet() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field hasResultSet is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __HASRESULTSET_ISSET_ID = 0;\n  }\n\n  public void unsetHasResultSet() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __HASRESULTSET_ISSET_ID);\n  }\n\n  /** Returns true if field hasResultSet is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetProgressedPercentage() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field progressedPercentage is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __PROGRESSEDPERCENTAGE_ISSET_ID = 0;\n  }\n\n  public void unsetProgressedPercentage() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __PROGRESSEDPERCENTAGE_ISSET_ID);\n  }\n\n  /** Returns true if field progressedPercentage is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetStartRowOffset() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field startRowOffset is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __STARTROWOFFSET_ISSET_ID = 0;\n  }\n\n  public void unsetStartRowOffset() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __STARTROWOFFSET_ISSET_ID);\n  }\n\n  /** Returns true if field startRowOffset is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetErrorCode() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field errorCode is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ERRORCODE_ISSET_ID = 0;\n  }\n\n  public void unsetErrorCode() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ERRORCODE_ISSET_ID);\n  }\n\n  /** Returns true if field errorCode is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetCompactionId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field compactionId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __COMPACTIONID_ISSET_ID = 0;\n  }\n\n  public void unsetCompactionId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __COMPACTIONID_ISSET_ID);\n  }\n\n  /** Returns true if field compactionId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTxnid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field txnid is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TXNID_ISSET_ID = 0;\n  }\n\n  public void unsetTxnid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TXNID_ISSET_ID);\n  }\n\n  /** Returns true if field txnid is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetErrorCode() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field errorCode is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ERRORCODE_ISSET_ID = 0;\n  }\n\n  public void unsetErrorCode() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ERRORCODE_ISSET_ID);\n  }\n\n  /** Returns true if field errorCode is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTxnid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field txnid is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TXNID_ISSET_ID = 0;\n  }\n\n  public void unsetTxnid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TXNID_ISSET_ID);\n  }\n\n  /** Returns true if field txnid is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetIfNotExists() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field ifNotExists is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __IFNOTEXISTS_ISSET_ID = 0;\n  }\n\n  public void unsetIfNotExists() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __IFNOTEXISTS_ISSET_ID);\n  }\n\n  /** Returns true if field ifNotExists is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetIsStatsCompliant() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field isStatsCompliant is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ISSTATSCOMPLIANT_ISSET_ID = 0;\n  }\n\n  public void unsetIsStatsCompliant() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ISSTATSCOMPLIANT_ISSET_ID);\n  }\n\n  /** Returns true if field isStatsCompliant is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetPartsFound() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field partsFound is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __PARTSFOUND_ISSET_ID = 0;\n  }\n\n  public void unsetPartsFound() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __PARTSFOUND_ISSET_ID);\n  }\n\n  /** Returns true if field partsFound is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetReallocate() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field reallocate is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __REALLOCATE_ISSET_ID = 0;\n  }\n\n  public void unsetReallocate() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __REALLOCATE_ISSET_ID);\n  }\n\n  /** Returns true if field reallocate is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TABLEID_ISSET_ID = 0;\n  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TABLEID_ISSET_ID);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetWriteId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field writeId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __WRITEID_ISSET_ID = 0;\n  }\n\n  public void unsetWriteId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __WRITEID_ISSET_ID);\n  }\n\n  /** Returns true if field writeId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetWriteId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field writeId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __WRITEID_ISSET_ID = 0;\n  }\n\n  public void unsetWriteId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __WRITEID_ISSET_ID);\n  }\n\n  /** Returns true if field writeId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetIsnull() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field isnull is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ISNULL_ISSET_ID = 0;\n  }\n\n  public void unsetIsnull() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ISNULL_ISSET_ID);\n  }\n\n  /** Returns true if field isnull is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetMaxColLen() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field maxColLen is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __MAXCOLLEN_ISSET_ID = 0;\n  }\n\n  public void unsetMaxColLen() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __MAXCOLLEN_ISSET_ID);\n  }\n\n  /** Returns true if field maxColLen is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetNumTrues() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field numTrues is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __NUMTRUES_ISSET_ID = 0;\n  }\n\n  public void unsetNumTrues() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __NUMTRUES_ISSET_ID);\n  }\n\n  /** Returns true if field numTrues is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetIsAllParts() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field isAllParts is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ISALLPARTS_ISSET_ID = 0;\n  }\n\n  public void unsetIsAllParts() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ISALLPARTS_ISSET_ID);\n  }\n\n  /** Returns true if field isAllParts is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetIsSupported() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field isSupported is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ISSUPPORTED_ISSET_ID = 0;\n  }\n\n  public void unsetIsSupported() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ISSUPPORTED_ISSET_ID);\n  }\n\n  /** Returns true if field isSupported is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __CREATETIME_ISSET_ID = 0;\n  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __CREATETIME_ISSET_ID);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TABLEID_ISSET_ID = 0;\n  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TABLEID_ISSET_ID);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetLockid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field lockid is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __LOCKID_ISSET_ID = 0;\n  }\n\n  public void unsetLockid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __LOCKID_ISSET_ID);\n  }\n\n  /** Returns true if field lockid is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetPurge() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field purge is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __PURGE_ISSET_ID = 0;\n  }\n\n  public void unsetPurge() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __PURGE_ISSET_ID);\n  }\n\n  /** Returns true if field purge is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetIsStatsCompliant() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field isStatsCompliant is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ISSTATSCOMPLIANT_ISSET_ID = 0;\n  }\n\n  public void unsetIsStatsCompliant() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ISSTATSCOMPLIANT_ISSET_ID);\n  }\n\n  /** Returns true if field isStatsCompliant is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetIsTblLevel() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field isTblLevel is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ISTBLLEVEL_ISSET_ID = 0;\n  }\n\n  public void unsetIsTblLevel() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ISTBLLEVEL_ISSET_ID);\n  }\n\n  /** Returns true if field isTblLevel is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TABLEID_ISSET_ID = 0;\n  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TABLEID_ISSET_ID);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTxnid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field txnid is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TXNID_ISSET_ID = 0;\n  }\n\n  public void unsetTxnid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TXNID_ISSET_ID);\n  }\n\n  /** Returns true if field txnid is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field id is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ID_ISSET_ID = 0;\n  }\n\n  public void unsetId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ID_ISSET_ID);\n  }\n\n  /** Returns true if field id is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetMetricvalue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field metricvalue is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __METRICVALUE_ISSET_ID = 0;\n  }\n\n  public void unsetMetricvalue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __METRICVALUE_ISSET_ID);\n  }\n\n  /** Returns true if field metricvalue is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetNumberOfBuckets() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field numberOfBuckets is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __NUMBEROFBUCKETS_ISSET_ID = 0;\n  }\n\n  public void unsetNumberOfBuckets() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __NUMBEROFBUCKETS_ISSET_ID);\n  }\n\n  /** Returns true if field numberOfBuckets is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field id is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ID_ISSET_ID = 0;\n  }\n\n  public void unsetId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ID_ISSET_ID);\n  }\n\n  /** Returns true if field id is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __CREATETIME_ISSET_ID = 0;\n  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __CREATETIME_ISSET_ID);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetMaterializationTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field materializationTime is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __MATERIALIZATIONTIME_ISSET_ID = 0;\n  }\n\n  public void unsetMaterializationTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __MATERIALIZATIONTIME_ISSET_ID);\n  }\n\n  /** Returns true if field materializationTime is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetEventId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field eventId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __EVENTID_ISSET_ID = 0;\n  }\n\n  public void unsetEventId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __EVENTID_ISSET_ID);\n  }\n\n  /** Returns true if field eventId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __CREATETIME_ISSET_ID = 0;\n  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __CREATETIME_ISSET_ID);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __CREATETIME_ISSET_ID = 0;\n  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __CREATETIME_ISSET_ID);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetDaysSinceEpoch() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field daysSinceEpoch is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __DAYSSINCEEPOCH_ISSET_ID = 0;\n  }\n\n  public void unsetDaysSinceEpoch() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __DAYSSINCEEPOCH_ISSET_ID);\n  }\n\n  /** Returns true if field daysSinceEpoch is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetNumNulls() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field numNulls is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __NUMNULLS_ISSET_ID = 0;\n  }\n\n  public void unsetNumNulls() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __NUMNULLS_ISSET_ID);\n  }\n\n  /** Returns true if field numNulls is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetScale() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field scale is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __SCALE_ISSET_ID = 0;\n  }\n\n  public void unsetScale() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __SCALE_ISSET_ID);\n  }\n\n  /** Returns true if field scale is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetNumNulls() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field numNulls is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __NUMNULLS_ISSET_ID = 0;\n  }\n\n  public void unsetNumNulls() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __NUMNULLS_ISSET_ID);\n  }\n\n  /** Returns true if field numNulls is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TABLEID_ISSET_ID = 0;\n  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TABLEID_ISSET_ID);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetLowValue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field lowValue is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __LOWVALUE_ISSET_ID = 0;\n  }\n\n  public void unsetLowValue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __LOWVALUE_ISSET_ID);\n  }\n\n  /** Returns true if field lowValue is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetIgnoreUnknownDb() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field ignoreUnknownDb is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __IGNOREUNKNOWNDB_ISSET_ID = 0;\n  }\n\n  public void unsetIgnoreUnknownDb() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __IGNOREUNKNOWNDB_ISSET_ID);\n  }\n\n  /** Returns true if field ignoreUnknownDb is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetPartArchiveLevel() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field partArchiveLevel is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __PARTARCHIVELEVEL_ISSET_ID = 0;\n  }\n\n  public void unsetPartArchiveLevel() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __PARTARCHIVELEVEL_ISSET_ID);\n  }\n\n  /** Returns true if field partArchiveLevel is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetDeleteData() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field deleteData is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __DELETEDATA_ISSET_ID = 0;\n  }\n\n  public void unsetDeleteData() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __DELETEDATA_ISSET_ID);\n  }\n\n  /** Returns true if field deleteData is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetAccessType() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field accessType is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ACCESSTYPE_ISSET_ID = 0;\n  }\n\n  public void unsetAccessType() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ACCESSTYPE_ISSET_ID);\n  }\n\n  /** Returns true if field accessType is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetType() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field type is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TYPE_ISSET_ID = 0;\n  }\n\n  public void unsetType() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TYPE_ISSET_ID);\n  }\n\n  /** Returns true if field type is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetSuccessful() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field successful is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __SUCCESSFUL_ISSET_ID = 0;\n  }\n\n  public void unsetSuccessful() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __SUCCESSFUL_ISSET_ID);\n  }\n\n  /** Returns true if field successful is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TABLEID_ISSET_ID = 0;\n  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TABLEID_ISSET_ID);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __CREATETIME_ISSET_ID = 0;\n  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __CREATETIME_ISSET_ID);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTxnId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field txnId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TXNID_ISSET_ID = 0;\n  }\n\n  public void unsetTxnId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TXNID_ISSET_ID);\n  }\n\n  /** Returns true if field txnId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field id is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ID_ISSET_ID = 0;\n  }\n\n  public void unsetId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ID_ISSET_ID);\n  }\n\n  /** Returns true if field id is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetDoGetFooters() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field doGetFooters is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __DOGETFOOTERS_ISSET_ID = 0;\n  }\n\n  public void unsetDoGetFooters() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __DOGETFOOTERS_ISSET_ID);\n  }\n\n  /** Returns true if field doGetFooters is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetIsSupported() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field isSupported is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ISSUPPORTED_ISSET_ID = 0;\n  }\n\n  public void unsetIsSupported() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ISSUPPORTED_ISSET_ID);\n  }\n\n  /** Returns true if field isSupported is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetIsSupported() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field isSupported is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ISSUPPORTED_ISSET_ID = 0;\n  }\n\n  public void unsetIsSupported() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ISSUPPORTED_ISSET_ID);\n  }\n\n  /** Returns true if field isSupported is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetLastCompactionId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field lastCompactionId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __LASTCOMPACTIONID_ISSET_ID = 0;\n  }\n\n  public void unsetLastCompactionId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __LASTCOMPACTIONID_ISSET_ID);\n  }\n\n  /** Returns true if field lastCompactionId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTxn_high_water_mark() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field txn_high_water_mark is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TXN_HIGH_WATER_MARK_ISSET_ID = 0;\n  }\n\n  public void unsetTxn_high_water_mark() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TXN_HIGH_WATER_MARK_ISSET_ID);\n  }\n\n  /** Returns true if field txn_high_water_mark is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTxn_high_water_mark() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field txn_high_water_mark is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TXN_HIGH_WATER_MARK_ISSET_ID = 0;\n  }\n\n  public void unsetTxn_high_water_mark() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TXN_HIGH_WATER_MARK_ISSET_ID);\n  }\n\n  /** Returns true if field txn_high_water_mark is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetMaxParts() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field maxParts is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __MAXPARTS_ISSET_ID = 0;\n  }\n\n  public void unsetMaxParts() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __MAXPARTS_ISSET_ID);\n  }\n\n  /** Returns true if field maxParts is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field id is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ID_ISSET_ID = 0;\n  }\n\n  public void unsetId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ID_ISSET_ID);\n  }\n\n  /** Returns true if field id is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetMaxParts() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field maxParts is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __MAXPARTS_ISSET_ID = 0;\n  }\n\n  public void unsetMaxParts() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __MAXPARTS_ISSET_ID);\n  }\n\n  /** Returns true if field maxParts is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetGet_col_stats() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field get_col_stats is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __GET_COL_STATS_ISSET_ID = 0;\n  }\n\n  public void unsetGet_col_stats() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __GET_COL_STATS_ISSET_ID);\n  }\n\n  /** Returns true if field get_col_stats is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetMaxParts() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field maxParts is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __MAXPARTS_ISSET_ID = 0;\n  }\n\n  public void unsetMaxParts() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __MAXPARTS_ISSET_ID);\n  }\n\n  /** Returns true if field maxParts is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetWithAuth() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field withAuth is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __WITHAUTH_ISSET_ID = 0;\n  }\n\n  public void unsetWithAuth() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __WITHAUTH_ISSET_ID);\n  }\n\n  /** Returns true if field withAuth is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetScheduledExecutionId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field scheduledExecutionId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __SCHEDULEDEXECUTIONID_ISSET_ID = 0;\n  }\n\n  public void unsetScheduledExecutionId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __SCHEDULEDEXECUTIONID_ISSET_ID);\n  }\n\n  /** Returns true if field scheduledExecutionId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetMaxWeight() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field maxWeight is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __MAXWEIGHT_ISSET_ID = 0;\n  }\n\n  public void unsetMaxWeight() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __MAXWEIGHT_ISSET_ID);\n  }\n\n  /** Returns true if field maxWeight is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field id is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ID_ISSET_ID = 0;\n  }\n\n  public void unsetId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ID_ISSET_ID);\n  }\n\n  /** Returns true if field id is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetGetColumnStats() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field getColumnStats is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __GETCOLUMNSTATS_ISSET_ID = 0;\n  }\n\n  public void unsetGetColumnStats() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __GETCOLUMNSTATS_ISSET_ID);\n  }\n\n  /** Returns true if field getColumnStats is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetIsStatsCompliant() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field isStatsCompliant is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ISSTATSCOMPLIANT_ISSET_ID = 0;\n  }\n\n  public void unsetIsStatsCompliant() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ISSTATSCOMPLIANT_ISSET_ID);\n  }\n\n  /** Returns true if field isStatsCompliant is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetRequestedFields() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field requestedFields is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __REQUESTEDFIELDS_ISSET_ID = 0;\n  }\n\n  public void unsetRequestedFields() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __REQUESTEDFIELDS_ISSET_ID);\n  }\n\n  /** Returns true if field requestedFields is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetWriteId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field writeId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __WRITEID_ISSET_ID = 0;\n  }\n\n  public void unsetWriteId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __WRITEID_ISSET_ID);\n  }\n\n  /** Returns true if field writeId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetRevokeGrantOption() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field revokeGrantOption is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __REVOKEGRANTOPTION_ISSET_ID = 0;\n  }\n\n  public void unsetRevokeGrantOption() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __REVOKEGRANTOPTION_ISSET_ID);\n  }\n\n  /** Returns true if field revokeGrantOption is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetSuccess() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field success is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __SUCCESS_ISSET_ID = 0;\n  }\n\n  public void unsetSuccess() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __SUCCESS_ISSET_ID);\n  }\n\n  /** Returns true if field success is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetGrantOption() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field grantOption is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __GRANTOPTION_ISSET_ID = 0;\n  }\n\n  public void unsetGrantOption() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __GRANTOPTION_ISSET_ID);\n  }\n\n  /** Returns true if field grantOption is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetSuccess() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field success is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __SUCCESS_ISSET_ID = 0;\n  }\n\n  public void unsetSuccess() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __SUCCESS_ISSET_ID);\n  }\n\n  /** Returns true if field success is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetLockid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field lockid is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __LOCKID_ISSET_ID = 0;\n  }\n\n  public void unsetLockid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __LOCKID_ISSET_ID);\n  }\n\n  /** Returns true if field lockid is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetMin() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field min is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __MIN_ISSET_ID = 0;\n  }\n\n  public void unsetMin() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __MIN_ISSET_ID);\n  }\n\n  /** Returns true if field min is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetReplace() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field replace is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __REPLACE_ISSET_ID = 0;\n  }\n\n  public void unsetReplace() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __REPLACE_ISSET_ID);\n  }\n\n  /** Returns true if field replace is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetCanEvolve() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field canEvolve is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __CANEVOLVE_ISSET_ID = 0;\n  }\n\n  public void unsetCanEvolve() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __CANEVOLVE_ISSET_ID);\n  }\n\n  /** Returns true if field canEvolve is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetIsTransactional() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field isTransactional is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ISTRANSACTIONAL_ISSET_ID = 0;\n  }\n\n  public void unsetIsTransactional() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ISTRANSACTIONAL_ISSET_ID);\n  }\n\n  /** Returns true if field isTransactional is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTxnid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field txnid is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TXNID_ISSET_ID = 0;\n  }\n\n  public void unsetTxnid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TXNID_ISSET_ID);\n  }\n\n  /** Returns true if field txnid is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetLockid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field lockid is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __LOCKID_ISSET_ID = 0;\n  }\n\n  public void unsetLockid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __LOCKID_ISSET_ID);\n  }\n\n  /** Returns true if field lockid is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetLowValue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field lowValue is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __LOWVALUE_ISSET_ID = 0;\n  }\n\n  public void unsetLowValue() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __LOWVALUE_ISSET_ID);\n  }\n\n  /** Returns true if field lowValue is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetSourceTablesUpdateDeleteModified() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field sourceTablesUpdateDeleteModified is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __SOURCETABLESUPDATEDELETEMODIFIED_ISSET_ID = 0;\n  }\n\n  public void unsetSourceTablesUpdateDeleteModified() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __SOURCETABLESUPDATEDELETEMODIFIED_ISSET_ID);\n  }\n\n  /** Returns true if field sourceTablesUpdateDeleteModified is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetMaxWriteId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field maxWriteId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __MAXWRITEID_ISSET_ID = 0;\n  }\n\n  public void unsetMaxWriteId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __MAXWRITEID_ISSET_ID);\n  }\n\n  /** Returns true if field maxWriteId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetEventId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field eventId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __EVENTID_ISSET_ID = 0;\n  }\n\n  public void unsetEventId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __EVENTID_ISSET_ID);\n  }\n\n  /** Returns true if field eventId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetLastEvent() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field lastEvent is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __LASTEVENT_ISSET_ID = 0;\n  }\n\n  public void unsetLastEvent() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __LASTEVENT_ISSET_ID);\n  }\n\n  /** Returns true if field lastEvent is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetFromEventId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field fromEventId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __FROMEVENTID_ISSET_ID = 0;\n  }\n\n  public void unsetFromEventId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __FROMEVENTID_ISSET_ID);\n  }\n\n  /** Returns true if field fromEventId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetEventsCount() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field eventsCount is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __EVENTSCOUNT_ISSET_ID = 0;\n  }\n\n  public void unsetEventsCount() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __EVENTSCOUNT_ISSET_ID);\n  }\n\n  /** Returns true if field eventsCount is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TABLEID_ISSET_ID = 0;\n  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TABLEID_ISSET_ID);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetNum_txns() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field num_txns is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __NUM_TXNS_ISSET_ID = 0;\n  }\n\n  public void unsetNum_txns() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __NUM_TXNS_ISSET_ID);\n  }\n\n  /** Returns true if field num_txns is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetOrder() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field order is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ORDER_ISSET_ID = 0;\n  }\n\n  public void unsetOrder() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ORDER_ISSET_ID);\n  }\n\n  /** Returns true if field order is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __CREATETIME_ISSET_ID = 0;\n  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __CREATETIME_ISSET_ID);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetMaxParts() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field maxParts is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __MAXPARTS_ISSET_ID = 0;\n  }\n\n  public void unsetMaxParts() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __MAXPARTS_ISSET_ID);\n  }\n\n  /** Returns true if field maxParts is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetHasUnknownPartitions() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field hasUnknownPartitions is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __HASUNKNOWNPARTITIONS_ISSET_ID = 0;\n  }\n\n  public void unsetHasUnknownPartitions() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __HASUNKNOWNPARTITIONS_ISSET_ID);\n  }\n\n  /** Returns true if field hasUnknownPartitions is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetWriteId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field writeId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __WRITEID_ISSET_ID = 0;\n  }\n\n  public void unsetWriteId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __WRITEID_ISSET_ID);\n  }\n\n  /** Returns true if field writeId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetMaxParts() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field maxParts is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __MAXPARTS_ISSET_ID = 0;\n  }\n\n  public void unsetMaxParts() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __MAXPARTS_ISSET_ID);\n  }\n\n  /** Returns true if field maxParts is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetHasUnknownPartitions() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field hasUnknownPartitions is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __HASUNKNOWNPARTITIONS_ISSET_ID = 0;\n  }\n\n  public void unsetHasUnknownPartitions() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __HASUNKNOWNPARTITIONS_ISSET_ID);\n  }\n\n  /** Returns true if field hasUnknownPartitions is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetIsStatsCompliant() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field isStatsCompliant is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ISSTATSCOMPLIANT_ISSET_ID = 0;\n  }\n\n  public void unsetIsStatsCompliant() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ISSTATSCOMPLIANT_ISSET_ID);\n  }\n\n  /** Returns true if field isStatsCompliant is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetApplyDistinct() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field applyDistinct is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __APPLYDISTINCT_ISSET_ID = 0;\n  }\n\n  public void unsetApplyDistinct() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __APPLYDISTINCT_ISSET_ID);\n  }\n\n  /** Returns true if field applyDistinct is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __CREATETIME_ISSET_ID = 0;\n  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __CREATETIME_ISSET_ID);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TABLEID_ISSET_ID = 0;\n  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TABLEID_ISSET_ID);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __CREATETIME_ISSET_ID = 0;\n  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __CREATETIME_ISSET_ID);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTxnId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field txnId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TXNID_ISSET_ID = 0;\n  }\n\n  public void unsetTxnId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TXNID_ISSET_ID);\n  }\n\n  /** Returns true if field txnId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetScheduledExecutionId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field scheduledExecutionId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __SCHEDULEDEXECUTIONID_ISSET_ID = 0;\n  }\n\n  public void unsetScheduledExecutionId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __SCHEDULEDEXECUTIONID_ISSET_ID);\n  }\n\n  /** Returns true if field scheduledExecutionId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetLastReplId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field lastReplId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __LASTREPLID_ISSET_ID = 0;\n  }\n\n  public void unsetLastReplId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __LASTREPLID_ISSET_ID);\n  }\n\n  /** Returns true if field lastReplId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __CREATETIME_ISSET_ID = 0;\n  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __CREATETIME_ISSET_ID);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetGrantOption() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field grantOption is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __GRANTOPTION_ISSET_ID = 0;\n  }\n\n  public void unsetGrantOption() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __GRANTOPTION_ISSET_ID);\n  }\n\n  /** Returns true if field grantOption is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __CREATETIME_ISSET_ID = 0;\n  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __CREATETIME_ISSET_ID);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetEnabled() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field enabled is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ENABLED_ISSET_ID = 0;\n  }\n\n  public void unsetEnabled() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ENABLED_ISSET_ID);\n  }\n\n  /** Returns true if field enabled is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetExecutionId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field executionId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __EXECUTIONID_ISSET_ID = 0;\n  }\n\n  public void unsetExecutionId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __EXECUTIONID_ISSET_ID);\n  }\n\n  /** Returns true if field executionId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetScheduledExecutionId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field scheduledExecutionId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __SCHEDULEDEXECUTIONID_ISSET_ID = 0;\n  }\n\n  public void unsetScheduledExecutionId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __SCHEDULEDEXECUTIONID_ISSET_ID);\n  }\n\n  /** Returns true if field scheduledExecutionId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetVersion() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field version is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __VERSION_ISSET_ID = 0;\n  }\n\n  public void unsetVersion() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __VERSION_ISSET_ID);\n  }\n\n  /** Returns true if field version is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetVersion() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field version is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __VERSION_ISSET_ID = 0;\n  }\n\n  public void unsetVersion() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __VERSION_ISSET_ID);\n  }\n\n  /** Returns true if field version is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetSeedWriteId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field seedWriteId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __SEEDWRITEID_ISSET_ID = 0;\n  }\n\n  public void unsetSeedWriteId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __SEEDWRITEID_ISSET_ID);\n  }\n\n  /** Returns true if field seedWriteId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetSeedTxnId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field seedTxnId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __SEEDTXNID_ISSET_ID = 0;\n  }\n\n  public void unsetSeedTxnId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __SEEDTXNID_ISSET_ID);\n  }\n\n  /** Returns true if field seedTxnId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetNeedMerge() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field needMerge is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __NEEDMERGE_ISSET_ID = 0;\n  }\n\n  public void unsetNeedMerge() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __NEEDMERGE_ISSET_ID);\n  }\n\n  /** Returns true if field needMerge is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetResult() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field result is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __RESULT_ISSET_ID = 0;\n  }\n\n  public void unsetResult() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __RESULT_ISSET_ID);\n  }\n\n  /** Returns true if field result is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field id is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ID_ISSET_ID = 0;\n  }\n\n  public void unsetId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ID_ISSET_ID);\n  }\n\n  /** Returns true if field id is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetStart() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field start is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __START_ISSET_ID = 0;\n  }\n\n  public void unsetStart() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __START_ISSET_ID);\n  }\n\n  /** Returns true if field start is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetIsExtended() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field isExtended is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ISEXTENDED_ISSET_ID = 0;\n  }\n\n  public void unsetIsExtended() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ISEXTENDED_ISSET_ID);\n  }\n\n  /** Returns true if field isExtended is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetLockid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field lockid is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __LOCKID_ISSET_ID = 0;\n  }\n\n  public void unsetLockid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __LOCKID_ISSET_ID);\n  }\n\n  /** Returns true if field lockid is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetInsertedCount() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field insertedCount is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __INSERTEDCOUNT_ISSET_ID = 0;\n  }\n\n  public void unsetInsertedCount() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __INSERTEDCOUNT_ISSET_ID);\n  }\n\n  /** Returns true if field insertedCount is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetEnable_cstr() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field enable_cstr is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ENABLE_CSTR_ISSET_ID = 0;\n  }\n\n  public void unsetEnable_cstr() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ENABLE_CSTR_ISSET_ID);\n  }\n\n  /** Returns true if field enable_cstr is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetEnable_cstr() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field enable_cstr is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ENABLE_CSTR_ISSET_ID = 0;\n  }\n\n  public void unsetEnable_cstr() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ENABLE_CSTR_ISSET_ID);\n  }\n\n  /** Returns true if field enable_cstr is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetKey_seq() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field key_seq is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __KEY_SEQ_ISSET_ID = 0;\n  }\n\n  public void unsetKey_seq() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __KEY_SEQ_ISSET_ID);\n  }\n\n  /** Returns true if field key_seq is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetEnable_cstr() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field enable_cstr is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ENABLE_CSTR_ISSET_ID = 0;\n  }\n\n  public void unsetEnable_cstr() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ENABLE_CSTR_ISSET_ID);\n  }\n\n  /** Returns true if field enable_cstr is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetKey_seq() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field key_seq is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __KEY_SEQ_ISSET_ID = 0;\n  }\n\n  public void unsetKey_seq() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __KEY_SEQ_ISSET_ID);\n  }\n\n  /** Returns true if field key_seq is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetKey_seq() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field key_seq is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __KEY_SEQ_ISSET_ID = 0;\n  }\n\n  public void unsetKey_seq() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __KEY_SEQ_ISSET_ID);\n  }\n\n  /** Returns true if field key_seq is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetCompressed() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field compressed is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __COMPRESSED_ISSET_ID = 0;\n  }\n\n  public void unsetCompressed() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __COMPRESSED_ISSET_ID);\n  }\n\n  /** Returns true if field compressed is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetMaxColLen() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field maxColLen is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __MAXCOLLEN_ISSET_ID = 0;\n  }\n\n  public void unsetMaxColLen() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __MAXCOLLEN_ISSET_ID);\n  }\n\n  /** Returns true if field maxColLen is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __CREATETIME_ISSET_ID = 0;\n  }\n\n  public void unsetCreateTime() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __CREATETIME_ISSET_ID);\n  }\n\n  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field id is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ID_ISSET_ID = 0;\n  }\n\n  public void unsetId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ID_ISSET_ID);\n  }\n\n  /** Returns true if field id is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetIsStatsCompliant() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field isStatsCompliant is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ISSTATSCOMPLIANT_ISSET_ID = 0;\n  }\n\n  public void unsetIsStatsCompliant() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ISSTATSCOMPLIANT_ISSET_ID);\n  }\n\n  /** Returns true if field isStatsCompliant is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetWriteIdHighWaterMark() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field writeIdHighWaterMark is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __WRITEIDHIGHWATERMARK_ISSET_ID = 0;\n  }\n\n  public void unsetWriteIdHighWaterMark() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __WRITEIDHIGHWATERMARK_ISSET_ID);\n  }\n\n  /** Returns true if field writeIdHighWaterMark is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "    }\n\n    public void unsetDeleteData() {\n      __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n    }\n\n    /** Returns true if field deleteData is set (has been assigned a value) and false otherwise */", "refactored_code": "    private static final int __DELETEDATA_ISSET_ID = 0;\n    }\n\n    public void unsetDeleteData() {\n      __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __DELETEDATA_ISSET_ID);\n    }\n\n    /** Returns true if field deleteData is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetSecondsSinceEpoch() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field secondsSinceEpoch is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __SECONDSSINCEEPOCH_ISSET_ID = 0;\n  }\n\n  public void unsetSecondsSinceEpoch() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __SECONDSSINCEEPOCH_ISSET_ID);\n  }\n\n  /** Returns true if field secondsSinceEpoch is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetNumNulls() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field numNulls is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __NUMNULLS_ISSET_ID = 0;\n  }\n\n  public void unsetNumNulls() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __NUMNULLS_ISSET_ID);\n  }\n\n  /** Returns true if field numNulls is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetWriteId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field writeId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __WRITEID_ISSET_ID = 0;\n  }\n\n  public void unsetWriteId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __WRITEID_ISSET_ID);\n  }\n\n  /** Returns true if field writeId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field id is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ID_ISSET_ID = 0;\n  }\n\n  public void unsetId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ID_ISSET_ID);\n  }\n\n  /** Returns true if field id is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTxnId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field txnId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TXNID_ISSET_ID = 0;\n  }\n\n  public void unsetTxnId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TXNID_ISSET_ID);\n  }\n\n  /** Returns true if field txnId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TABLEID_ISSET_ID = 0;\n  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TABLEID_ISSET_ID);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetLockid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field lockid is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __LOCKID_ISSET_ID = 0;\n  }\n\n  public void unsetLockid() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __LOCKID_ISSET_ID);\n  }\n\n  /** Returns true if field lockid is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TABLEID_ISSET_ID = 0;\n  }\n\n  public void unsetTableId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TABLEID_ISSET_ID);\n  }\n\n  /** Returns true if field tableId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetIsEnableAndActivate() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field isEnableAndActivate is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ISENABLEANDACTIVATE_ISSET_ID = 0;\n  }\n\n  public void unsetIsEnableAndActivate() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ISENABLEANDACTIVATE_ISSET_ID);\n  }\n\n  /** Returns true if field isEnableAndActivate is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetDrop() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field drop is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __DROP_ISSET_ID = 0;\n  }\n\n  public void unsetDrop() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __DROP_ISSET_ID);\n  }\n\n  /** Returns true if field drop is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetUpdate() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field update is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __UPDATE_ISSET_ID = 0;\n  }\n\n  public void unsetUpdate() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __UPDATE_ISSET_ID);\n  }\n\n  /** Returns true if field update is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetOrdering() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field ordering is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ORDERING_ISSET_ID = 0;\n  }\n\n  public void unsetOrdering() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ORDERING_ISSET_ID);\n  }\n\n  /** Returns true if field ordering is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetAllocFraction() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field allocFraction is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ALLOCFRACTION_ISSET_ID = 0;\n  }\n\n  public void unsetAllocFraction() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ALLOCFRACTION_ISSET_ID);\n  }\n\n  /** Returns true if field allocFraction is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetQueryParallelism() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field queryParallelism is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __QUERYPARALLELISM_ISSET_ID = 0;\n  }\n\n  public void unsetQueryParallelism() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __QUERYPARALLELISM_ISSET_ID);\n  }\n\n  /** Returns true if field queryParallelism is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetAllocFraction() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field allocFraction is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ALLOCFRACTION_ISSET_ID = 0;\n  }\n\n  public void unsetAllocFraction() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ALLOCFRACTION_ISSET_ID);\n  }\n\n  /** Returns true if field allocFraction is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetQueryParallelism() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field queryParallelism is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __QUERYPARALLELISM_ISSET_ID = 0;\n  }\n\n  public void unsetQueryParallelism() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __QUERYPARALLELISM_ISSET_ID);\n  }\n\n  /** Returns true if field queryParallelism is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetIsInUnmanaged() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field isInUnmanaged is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __ISINUNMANAGED_ISSET_ID = 0;\n  }\n\n  public void unsetIsInUnmanaged() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __ISINUNMANAGED_ISSET_ID);\n  }\n\n  /** Returns true if field isInUnmanaged is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetWriteId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field writeId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __WRITEID_ISSET_ID = 0;\n  }\n\n  public void unsetWriteId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __WRITEID_ISSET_ID);\n  }\n\n  /** Returns true if field writeId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  }\n\n  public void unsetTxnId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /** Returns true if field txnId is set (has been assigned a value) and false otherwise */", "refactored_code": "  private static final int __TXNID_ISSET_ID = 0;\n  }\n\n  public void unsetTxnId() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __TXNID_ISSET_ID);\n  }\n\n  /** Returns true if field txnId is set (has been assigned a value) and false otherwise */"}
{"magic_number_smell": "  public PropertyMap(DataInput input, Function<String, PropertySchema> getSchema) throws IOException {\n    // serial\n    long serial = input.readLong();\n    if (serial != 202212291759L) {\n      throw new InvalidObjectException(\"serial mismatch\");\n    }\n    // schema as string", "refactored_code": "  private static final long serialVersionUID = 202212291759L;\n  public PropertyMap(DataInput input, Function<String, PropertySchema> getSchema) throws IOException {\n    // serial\n    long serial = input.readLong();\n    if (serial != serialVersionUID) {\n      throw new InvalidObjectException(\"serial mismatch\");\n    }\n    // schema as string"}
{"magic_number_smell": "  public PropertySchema(DataInput input) throws IOException {\n    // serial\n    long serial = input.readLong();\n    if (serial != 202212301459L) {\n      throw new InvalidObjectException(\"serial mismatch\");\n    }\n    // name", "refactored_code": "  private static final long serialVersionUID = 202212301459L;\n  public PropertySchema(DataInput input) throws IOException {\n    // serial\n    long serial = input.readLong();\n    if (serial != serialVersionUID) {\n      throw new InvalidObjectException(\"serial mismatch\");\n    }\n    // name"}
{"magic_number_smell": "  @Override\n  public void readExternal(ObjectInput in) throws IOException {\n    long serial = in.readLong();\n    if (serial != 202212281757L) {\n      throw new ProxyException(\"invalid serial version, got \" + serial +\", expected \" + 202212281757L);\n    }\n    type = readType(in);", "refactored_code": "  private static final long serialVersionUID = 202212281757L;\n  @Override\n  public void readExternal(ObjectInput in) throws IOException {\n    long serial = in.readLong();\n    if (serial != serialVersionUID) {\n      throw new ProxyException(\"invalid serial version, got \" + serial +\", expected \" + serialVersionUID);\n    }\n    type = readType(in);"}
{"magic_number_smell": "     * Creates a new instance of a soft cache.\n     */\n    public SoftCache() {\n        this(64);\n    }\n\n    /**", "refactored_code": "    private static final int CACHE_CAPACITY = 64;\n     * Creates a new instance of a soft cache.\n     */\n    public SoftCache() {\n        this(CACHE_CAPACITY);\n    }\n\n    /**"}
{"magic_number_smell": "    } catch(Exception e) {\n      if (e.getClass().equals(retryExceptionType)){\n        tries++;\n        if (4 == tries) {\n          throw e;\n        } else {\n          return run();", "refactored_code": "  public static final int MAX_RETRIES = 4;\n    } catch(Exception e) {\n      if (e.getClass().equals(retryExceptionType)){\n        tries++;\n        if (MAX_RETRIES == tries) {\n          throw e;\n        } else {\n          return run();"}
{"magic_number_smell": "    assertNull(time);\n\n    assertSame(fooScope, metrics.getStoredScope(scopeName));\n    Thread.sleep(50L+ 1);\n    // 1st close:\n    // closing of open scope should be ok:\n    metrics.endStoredScope(scopeName);", "refactored_code": "  private static final long periodMs = 50L;\n    assertNull(time);\n\n    assertSame(fooScope, metrics.getStoredScope(scopeName));\n    Thread.sleep(periodMs+ 1);\n    // 1st close:\n    // closing of open scope should be ok:\n    metrics.endStoredScope(scopeName);"}
{"magic_number_smell": "        \"org.apache.hadoop.hive.common.metrics.metrics2.JsonFileMetricsReporter, \"\n            + \"org.apache.hadoop.hive.common.metrics.metrics2.JmxMetricsReporter\");\n    conf.set(MetastoreConf.ConfVars.METRICS_JSON_FILE_LOCATION.getHiveName(), jsonReportFile.getAbsolutePath());\n    conf.setTimeDuration(MetastoreConf.ConfVars.METRICS_JSON_FILE_INTERVAL.getHiveName(), 2000,\n        TimeUnit.MILLISECONDS);\n\n    MetricsFactory.init(conf);", "refactored_code": "  private static final long REPORT_INTERVAL_MS = 2000;\n        \"org.apache.hadoop.hive.common.metrics.metrics2.JsonFileMetricsReporter, \"\n            + \"org.apache.hadoop.hive.common.metrics.metrics2.JmxMetricsReporter\");\n    conf.set(MetastoreConf.ConfVars.METRICS_JSON_FILE_LOCATION.getHiveName(), jsonReportFile.getAbsolutePath());\n    conf.setTimeDuration(MetastoreConf.ConfVars.METRICS_JSON_FILE_INTERVAL.getHiveName(), REPORT_INTERVAL_MS,\n        TimeUnit.MILLISECONDS);\n\n    MetricsFactory.init(conf);"}
{"magic_number_smell": "    protected final int anInt;\n\n    public PocExternal(ObjectInput in) throws IOException {\n        this(202212281714L, in);\n    }\n\n    public void write(ObjectOutput out) throws IOException {", "refactored_code": "    private static final long serialVersionUID = 202212281714L;\n    protected final int anInt;\n\n    public PocExternal(ObjectInput in) throws IOException {\n        this(serialVersionUID, in);\n    }\n\n    public void write(ObjectOutput out) throws IOException {"}
{"magic_number_smell": "        }\n\n        public PocExternalDerive(ObjectInput in) throws IOException {\n            this(202212281720L, in);\n        }\n\n        protected PocExternalDerive(long version, DataInput in) throws IOException {", "refactored_code": "        private static final long serialVersionUID = 202212281720L;\n        }\n\n        public PocExternalDerive(ObjectInput in) throws IOException {\n            this(serialVersionUID, in);\n        }\n\n        protected PocExternalDerive(long version, DataInput in) throws IOException {"}
{"magic_number_smell": "    Assert.assertNull(DOUBLE.cast(null));\n    Assert.assertNull(DOUBLE.format(null));\n    Assert.assertNull(DOUBLE.parse(null));\n    Assert.assertEquals(42.0d, (double) DOUBLE.cast(\"42\"), 1e-9);\n    Assert.assertEquals(42.0d, (double) DOUBLE.cast(42), 1e-9);\n    Assert.assertNull(DOUBLE.cast(\"foobar\"));\n    Assert.assertEquals(\"42.0\", DOUBLE.format(42.0d));", "refactored_code": "  private static final double EPSILON = 1e-9;\n    Assert.assertNull(DOUBLE.cast(null));\n    Assert.assertNull(DOUBLE.format(null));\n    Assert.assertNull(DOUBLE.parse(null));\n    Assert.assertEquals(42.0d, (double) DOUBLE.cast(\"42\"), EPSILON);\n    Assert.assertEquals(42.0d, (double) DOUBLE.cast(42), EPSILON);\n    Assert.assertNull(DOUBLE.cast(\"foobar\"));\n    Assert.assertEquals(\"42.0\", DOUBLE.format(42.0d));"}
{"magic_number_smell": "    this.numBitVectors = numBitVectors;\n    bitVector = new FastBitSet[numBitVectors];\n    for (int i=0; i< numBitVectors; i++) {\n      bitVector[i] = new FastBitSet(31);\n    }\n\n    a = new int[numBitVectors];", "refactored_code": "  public static final int BIT_VECTOR_SIZE = 31;\n    this.numBitVectors = numBitVectors;\n    bitVector = new FastBitSet[numBitVectors];\n    for (int i=0; i< numBitVectors; i++) {\n      bitVector[i] = new FastBitSet(BIT_VECTOR_SIZE);\n    }\n\n    a = new int[numBitVectors];"}
{"magic_number_smell": "        // cardinality estimate from normalized bias corrected harmonic mean on\n        // the registers\n        cachedCount = (long) (alphaMM * (1.0 / sum));\n        long pow = (long) Math.pow(2, DEFAULT_HASH_BITS);\n\n        // when bias correction is enabled\n        if (noBias) {", "refactored_code": "  private final int chosenHashBits = DEFAULT_HASH_BITS;\n        // cardinality estimate from normalized bias corrected harmonic mean on\n        // the registers\n        cachedCount = (long) (alphaMM * (1.0 / sum));\n        long pow = (long) Math.pow(2, chosenHashBits);\n\n        // when bias correction is enabled\n        if (noBias) {"}
{"magic_number_smell": "      return Collections.emptyList();\n    }\n    try {\n      if (batchSize == -1 || batchSize >= input.size()) {\n        return runnable.run(input);\n      }\n      List<R> result = new ArrayList<>(input.size());", "refactored_code": "  public static final int NO_BATCHING = -1;\n      return Collections.emptyList();\n    }\n    try {\n      if (batchSize == NO_BATCHING || batchSize >= input.size()) {\n        return runnable.run(input);\n      }\n      List<R> result = new ArrayList<>(input.size());"}
{"magic_number_smell": "\n  private void check() throws MetaException{\n    try {\n      if (startTime == Long.MIN_VALUE) {\n        throw new DeadlineException(\"Should execute startTimer() method before \" +\n            \"checkTimeout. Error happens in method: \" + method);\n      }", "refactored_code": "  private static final long NO_DEADLINE = Long.MIN_VALUE;\n\n  private void check() throws MetaException{\n    try {\n      if (startTime == NO_DEADLINE) {\n        throw new DeadlineException(\"Should execute startTimer() method before \" +\n            \"checkTimeout. Error happens in method: \" + method);\n      }"}
{"magic_number_smell": "    int batchSize = MetastoreConf.getIntVar(conf, ConfVars.DIRECT_SQL_PARTITION_BATCH_SIZE);\n    this.directSqlInsertPart = new DirectSqlInsertPart(pm, dbType, batchSize);\n    if (batchSize == DETECT_BATCHING) {\n      batchSize = dbType.needsInBatching() ? 1000 : -1, DETECT_BATCHING = 0;\n    }\n    this.batchSize = batchSize;\n    this.isTxnStatsEnabled = MetastoreConf.getBoolVar(conf, ConfVars.HIVE_TXN_STATS_ENABLED);", "refactored_code": "  private static final int NO_BATCHING = -1, DETECT_BATCHING = 0;\n    int batchSize = MetastoreConf.getIntVar(conf, ConfVars.DIRECT_SQL_PARTITION_BATCH_SIZE);\n    this.directSqlInsertPart = new DirectSqlInsertPart(pm, dbType, batchSize);\n    if (batchSize == DETECT_BATCHING) {\n      batchSize = dbType.needsInBatching() ? 1000 : NO_BATCHING;\n    }\n    this.batchSize = batchSize;\n    this.isTxnStatsEnabled = MetastoreConf.getBoolVar(conf, ConfVars.HIVE_TXN_STATS_ENABLED);"}
{"magic_number_smell": "\n      out.write(msg);\n      for (Object entry : result) {\n        out.write(9);\n        out.write(entry.toString());\n      }\n      return true;", "refactored_code": "  public static final int separator = 9; // tabCode\n\n      out.write(msg);\n      for (Object entry : result) {\n        out.write(separator);\n        out.write(entry.toString());\n      }\n      return true;"}
{"magic_number_smell": "              if (!node.isMultiValued) {\n                // in case of serdeid and sdId node we just collect the sdIds for further processing\n                if (node.equals(sdIdNode)) {\n                  ids[0] = extractSqlLong(value);\n                } else if (node.equals(serdeIdNode)) {\n                  ids[SERDE_INDEX] = extractSqlLong(value);\n                } else if (node.equals(cdIdNode)) {", "refactored_code": "  private static final int SD_INDEX = 0;\n              if (!node.isMultiValued) {\n                // in case of serdeid and sdId node we just collect the sdIds for further processing\n                if (node.equals(sdIdNode)) {\n                  ids[SD_INDEX] = extractSqlLong(value);\n                } else if (node.equals(serdeIdNode)) {\n                  ids[SERDE_INDEX] = extractSqlLong(value);\n                } else if (node.equals(cdIdNode)) {"}
{"magic_number_smell": "\n    if (tableCache == null) {\n      CacheBuilder<String, TableWrapper> b = CacheBuilder.newBuilder()\n          .maximumWeight(maxCacheSizeInBytes > 0 ? maxCacheSizeInBytes : 1024 * 1024)\n          .weigher(new Weigher<String, TableWrapper>() {\n            @Override\n            public int weigh(String key, TableWrapper value) {", "refactored_code": "  private static final long MAX_DEFAULT_CACHE_SIZE = 1024 * 1024;\n\n    if (tableCache == null) {\n      CacheBuilder<String, TableWrapper> b = CacheBuilder.newBuilder()\n          .maximumWeight(maxCacheSizeInBytes > 0 ? maxCacheSizeInBytes : MAX_DEFAULT_CACHE_SIZE)\n          .weigher(new Weigher<String, TableWrapper>() {\n            @Override\n            public int weigh(String key, TableWrapper value) {"}
{"magic_number_smell": "    super();\n    this.status = status;\n    this.handler = handler;\n    this.parameters = new HashMap<>(1);\n    updateUnmodifiableParameters();\n  }\n", "refactored_code": "  private static final int PARAMETERS_INITIAL_CAPACITY = 1;\n    super();\n    this.status = status;\n    this.handler = handler;\n    this.parameters = new HashMap<>(PARAMETERS_INITIAL_CAPACITY);\n    updateUnmodifiableParameters();\n  }\n"}
{"magic_number_smell": "      while (shouldRun) {\n        sw.reset().start();\n        try {\n          Thread.sleep(500);\n        } catch (InterruptedException ie) {\n          return;\n        }", "refactored_code": "  private static final long SLEEP_INTERVAL_MS = 500;\n      while (shouldRun) {\n        sw.reset().start();\n        try {\n          Thread.sleep(SLEEP_INTERVAL_MS);\n        } catch (InterruptedException ie) {\n          return;\n        }"}
{"magic_number_smell": "  }\n\n  public void setHeader(String header) throws MetaException {\n    if (header.length() > 1073741823) {\n      throw new MetaException(\"Header is too long: \" + header.length() + \" max size: \" + 1073741823);\n    }\n    this.header = header;", "refactored_code": "  public static final int MAX_HEADER_SIZE = 1073741823;\n  }\n\n  public void setHeader(String header) throws MetaException {\n    if (header.length() > MAX_HEADER_SIZE) {\n      throw new MetaException(\"Header is too long: \" + header.length() + \" max size: \" + MAX_HEADER_SIZE);\n    }\n    this.header = header;"}
{"magic_number_smell": "  }\n\n  public void setSource(String source) throws MetaException {\n    if (source.length() > 1073741823) {\n      throw new MetaException(\"Source code is too long: \" + source.length() + \" max size: \" + 1073741823);\n    }\n    this.source = source;", "refactored_code": "  public static final int MAX_SOURCE_SIZE = 1073741823;\n  }\n\n  public void setSource(String source) throws MetaException {\n    if (source.length() > MAX_SOURCE_SIZE) {\n      throw new MetaException(\"Source code is too long: \" + source.length() + \" max size: \" + MAX_SOURCE_SIZE);\n    }\n    this.source = source;"}
{"magic_number_smell": "  private Predicate<DelegationTokenIdentifier> selectForDeletion = Predicates.alwaysTrue();\n\n  private static final int 100 = 100;\n  private int batchSize = 100; // Number of tokens to drop, between sleep intervals;\n  private static final long SLEEP_TIME_MILLIS_DEFAULT = 10 * 1000;\n  private long sleepTimeMillis = SLEEP_TIME_MILLIS_DEFAULT; // Sleep-time in milliseconds, between batches of delegation tokens dropped.\n", "refactored_code": "  private static final int BATCH_SIZE_DEFAULT = 100;\n  private Predicate<DelegationTokenIdentifier> selectForDeletion = Predicates.alwaysTrue();\n\n  private static final int BATCH_SIZE_DEFAULT = 100;\n  private int batchSize = BATCH_SIZE_DEFAULT; // Number of tokens to drop, between sleep intervals;\n  private static final long SLEEP_TIME_MILLIS_DEFAULT = 10 * 1000;\n  private long sleepTimeMillis = SLEEP_TIME_MILLIS_DEFAULT; // Sleep-time in milliseconds, between batches of delegation tokens dropped.\n"}
{"magic_number_smell": "      try (PreparedStatement pStmt = conn.prepareStatement(tabLocQuery)) {\n        while (minID <= maxID) {\n          pStmt.setLong(1, minID);\n          pStmt.setLong(2, minID + 2000);\n          try (ResultSet res = pStmt.executeQuery()) {\n            while (res.next()) {\n              String locValue = res.getString(3);", "refactored_code": "  private static final int TAB_LOC_CHECK_SIZE = 2000;\n      try (PreparedStatement pStmt = conn.prepareStatement(tabLocQuery)) {\n        while (minID <= maxID) {\n          pStmt.setLong(1, minID);\n          pStmt.setLong(2, minID + TAB_LOC_CHECK_SIZE);\n          try (ResultSet res = pStmt.executeQuery()) {\n            while (res.next()) {\n              String locValue = res.getString(3);"}
{"magic_number_smell": "  }\n\n  boolean canCreateContext() {\n    return (1 & flag) == 1;\n  }\n\n  boolean canJoinContext() {", "refactored_code": "  private static final int CREATE_FLAG = 1;\n  }\n\n  boolean canCreateContext() {\n    return (CREATE_FLAG & flag) == CREATE_FLAG;\n  }\n\n  boolean canJoinContext() {"}
{"magic_number_smell": "    }\n    properties\n        .setRetryCount(retryLimit)\n        .setDeadlockCount(10);\n    \n    try {\n      if (properties.isLockInternally()) {", "refactored_code": "  private static final int ALLOWED_REPEATED_DEADLOCKS = 10;\n    }\n    properties\n        .setRetryCount(retryLimit)\n        .setDeadlockCount(ALLOWED_REPEATED_DEADLOCKS);\n    \n    try {\n      if (properties.isLockInternally()) {"}
{"magic_number_smell": "      isAliveCounter++;\n      txnHandler.countOpenTxns();\n      long now = System.currentTimeMillis();\n      if (now - lastLogTime > 60 * 1000) {\n        LOG.info(\"Open txn counter ran for {} seconds. isAliveCounter: {}\", (now - start) / 1000, isAliveCounter);\n        lastLogTime = now;\n      }", "refactored_code": "  private static final int LOG_INTERVAL_MS = 60 * 1000;\n      isAliveCounter++;\n      txnHandler.countOpenTxns();\n      long now = System.currentTimeMillis();\n      if (now - lastLogTime > LOG_INTERVAL_MS) {\n        LOG.info(\"Open txn counter ran for {} seconds. isAliveCounter: {}\", (now - start) / 1000, isAliveCounter);\n        lastLogTime = now;\n      }"}
{"magic_number_smell": "  @Test\n  public void testHLLSparseSerialization() throws IOException {\n    HyperLogLog hll = HyperLogLog.builder().setEncoding(EncodingType.SPARSE).build();\n    Random rand = new Random(100);\n    for (int i = 0; i < size; i++) {\n      hll.addLong(rand.nextLong());\n    }", "refactored_code": "  private static final int SEED = 100;\n  @Test\n  public void testHLLSparseSerialization() throws IOException {\n    HyperLogLog hll = HyperLogLog.builder().setEncoding(EncodingType.SPARSE).build();\n    Random rand = new Random(SEED);\n    for (int i = 0; i < size; i++) {\n      hll.addLong(rand.nextLong());\n    }"}
{"magic_number_smell": "    Exception metaStoreException = null;\n    String warehouseDir = MetastoreConf.getVar(conf, ConfVars.WAREHOUSE);\n\n    for (int tryCount = 0; tryCount < MetaStoreTestUtils.10; tryCount++) {\n      try {\n        int metaStorePort = findFreePort();\n        if (!keepWarehousePath) {", "refactored_code": "  public static final int RETRY_COUNT = 10;\n    Exception metaStoreException = null;\n    String warehouseDir = MetastoreConf.getVar(conf, ConfVars.WAREHOUSE);\n\n    for (int tryCount = 0; tryCount < MetaStoreTestUtils.RETRY_COUNT; tryCount++) {\n      try {\n        int metaStorePort = findFreePort();\n        if (!keepWarehousePath) {"}
{"magic_number_smell": "    conf.set(\"hive.in.test\", \"true\");\n\n    MetastoreConf.setLongVar(conf, ConfVars.BATCH_RETRIEVE_MAX, 2);\n    MetastoreConf.setLongVar(conf, ConfVars.LIMIT_PARTITION_REQUEST, 100);\n    MetastoreConf.setVar(conf, ConfVars.STORAGE_SCHEMA_READER_IMPL, \"no.such.class\");\n    MetaStoreTestUtils.setConfForStandloneMode(conf);\n", "refactored_code": "  private static final int DEFAULT_LIMIT_PARTITION_REQUEST = 100;\n    conf.set(\"hive.in.test\", \"true\");\n\n    MetastoreConf.setLongVar(conf, ConfVars.BATCH_RETRIEVE_MAX, 2);\n    MetastoreConf.setLongVar(conf, ConfVars.LIMIT_PARTITION_REQUEST, DEFAULT_LIMIT_PARTITION_REQUEST);\n    MetastoreConf.setVar(conf, ConfVars.STORAGE_SCHEMA_READER_IMPL, \"no.such.class\");\n    MetaStoreTestUtils.setConfForStandloneMode(conf);\n"}
{"magic_number_smell": "\n    MetaStoreTestUtils.setConfForStandloneMode(conf);\n    MetastoreConf.setLongVar(conf, ConfVars.BATCH_RETRIEVE_MAX, 2);\n    MetastoreConf.setLongVar(conf, ConfVars.LIMIT_PARTITION_REQUEST, 100);\n    MetastoreConf.setVar(conf, ConfVars.STORAGE_SCHEMA_READER_IMPL, \"no.such.class\");\n    MetastoreConf.setBoolVar(conf, ConfVars.INTEGER_JDO_PUSHDOWN, true);\n  }", "refactored_code": "  private static final int DEFAULT_LIMIT_PARTITION_REQUEST = 100;\n\n    MetaStoreTestUtils.setConfForStandloneMode(conf);\n    MetastoreConf.setLongVar(conf, ConfVars.BATCH_RETRIEVE_MAX, 2);\n    MetastoreConf.setLongVar(conf, ConfVars.LIMIT_PARTITION_REQUEST, DEFAULT_LIMIT_PARTITION_REQUEST);\n    MetastoreConf.setVar(conf, ConfVars.STORAGE_SCHEMA_READER_IMPL, \"no.such.class\");\n    MetastoreConf.setBoolVar(conf, ConfVars.INTEGER_JDO_PUSHDOWN, true);\n  }"}
{"magic_number_smell": "    conf.set(\"hive.in.test\", \"true\");\n\n    MetastoreConf.setLongVar(conf, ConfVars.BATCH_RETRIEVE_MAX, 2);\n    MetastoreConf.setLongVar(conf, ConfVars.LIMIT_PARTITION_REQUEST, 100);\n    MetastoreConf.setVar(conf, ConfVars.STORAGE_SCHEMA_READER_IMPL, \"no.such.class\");\n    MetastoreConf.setBoolVar(conf, ConfVars.METASTORE_CLIENT_FILTER_ENABLED, false);\n    MetastoreConf.setBoolVar(conf, ConfVars.METASTORE_SERVER_FILTER_ENABLED, false);", "refactored_code": "  private static final int DEFAULT_LIMIT_PARTITION_REQUEST = 100;\n    conf.set(\"hive.in.test\", \"true\");\n\n    MetastoreConf.setLongVar(conf, ConfVars.BATCH_RETRIEVE_MAX, 2);\n    MetastoreConf.setLongVar(conf, ConfVars.LIMIT_PARTITION_REQUEST, DEFAULT_LIMIT_PARTITION_REQUEST);\n    MetastoreConf.setVar(conf, ConfVars.STORAGE_SCHEMA_READER_IMPL, \"no.such.class\");\n    MetastoreConf.setBoolVar(conf, ConfVars.METASTORE_CLIENT_FILTER_ENABLED, false);\n    MetastoreConf.setBoolVar(conf, ConfVars.METASTORE_SERVER_FILTER_ENABLED, false);"}
{"magic_number_smell": "\n  private static final int 8089 = 8089;\n  @ClassRule\n  public static final WireMockRule MOCK_JWKS_SERVER = new WireMockRule(8089);\n\n  /**\n   * This is a hack to make environment variables modifiable.", "refactored_code": "  private static final int MOCK_JWKS_SERVER_PORT = 8089;\n\n  private static final int MOCK_JWKS_SERVER_PORT = 8089;\n  @ClassRule\n  public static final WireMockRule MOCK_JWKS_SERVER = new WireMockRule(MOCK_JWKS_SERVER_PORT);\n\n  /**\n   * This is a hack to make environment variables modifiable."}
{"magic_number_smell": "    conf = MetastoreConf.newMetastoreConf();\n    MetastoreConf.setVar(conf, ConfVars.HMS_HANDLER_PROXY_CLASS,\n        MetastoreConf.METASTORE_RETRYING_HANDLER_CLASS);\n    MetastoreConf.setLongVar(conf, ConfVars.HMS_HANDLER_ATTEMPTS, 3);\n    MetastoreConf.setTimeVar(conf, ConfVars.HMS_HANDLER_INTERVAL, 10, TimeUnit.MILLISECONDS);\n    MetastoreConf.setBoolVar(conf, ConfVars.HMS_HANDLER_FORCE_RELOAD_CONF, false);\n  }", "refactored_code": "  private static final int RETRY_ATTEMPTS = 3;\n    conf = MetastoreConf.newMetastoreConf();\n    MetastoreConf.setVar(conf, ConfVars.HMS_HANDLER_PROXY_CLASS,\n        MetastoreConf.METASTORE_RETRYING_HANDLER_CLASS);\n    MetastoreConf.setLongVar(conf, ConfVars.HMS_HANDLER_ATTEMPTS, RETRY_ATTEMPTS);\n    MetastoreConf.setTimeVar(conf, ConfVars.HMS_HANDLER_INTERVAL, 10, TimeUnit.MILLISECONDS);\n    MetastoreConf.setBoolVar(conf, ConfVars.HMS_HANDLER_FORCE_RELOAD_CONF, false);\n  }"}
{"magic_number_smell": "    MetastoreConf.setLongVar(conf, MetastoreConf.ConfVars.BATCH_RETRIEVE_MAX, 2);\n    MetastoreConf.setLongVar(conf, MetastoreConf.ConfVars.BATCH_RETRIEVE_OBJECTS_MAX, 2);\n    MetastoreConf.setLongVar(conf, MetastoreConf.ConfVars.LIMIT_PARTITION_REQUEST,\n        100);\n    MetaStoreTestUtils.setConfForStandloneMode(conf);\n\n    // Do this only on your own peril, and never in the production code", "refactored_code": "  private static final int DEFAULT_LIMIT_PARTITION_REQUEST = 100;\n    MetastoreConf.setLongVar(conf, MetastoreConf.ConfVars.BATCH_RETRIEVE_MAX, 2);\n    MetastoreConf.setLongVar(conf, MetastoreConf.ConfVars.BATCH_RETRIEVE_OBJECTS_MAX, 2);\n    MetastoreConf.setLongVar(conf, MetastoreConf.ConfVars.LIMIT_PARTITION_REQUEST,\n        DEFAULT_LIMIT_PARTITION_REQUEST);\n    MetaStoreTestUtils.setConfForStandloneMode(conf);\n\n    // Do this only on your own peril, and never in the production code"}
{"magic_number_smell": "      System.out.println(e);\n    }\n\n    List<String> partitionNames = client.listPartitionNames(DB_NAME, tableName, -1);\n    Assert.assertNotNull(partitionNames);\n    Assert.assertTrue(partitionNames.isEmpty());\n  }", "refactored_code": "  private static final short MAX = -1;\n      System.out.println(e);\n    }\n\n    List<String> partitionNames = client.listPartitionNames(DB_NAME, tableName, MAX);\n    Assert.assertNotNull(partitionNames);\n    Assert.assertTrue(partitionNames.isEmpty());\n  }"}
{"magic_number_smell": "        .setSerdeName(\"partserde\" + index)\n        .addStorageDescriptorParam(\"partsdkey\" + index, \"partsdvalue\" + index)\n        .setCols(partCols)\n        .setCreateTime(123456)\n        .setLastAccessTime(123456)\n        .addCol(\"test_id\", \"int\", \"test col id\")\n        .addCol(\"test_value\", \"string\", \"test col value\")", "refactored_code": "  protected static final int DEFAULT_CREATE_TIME = 123456;\n        .setSerdeName(\"partserde\" + index)\n        .addStorageDescriptorParam(\"partsdkey\" + index, \"partsdvalue\" + index)\n        .setCols(partCols)\n        .setCreateTime(DEFAULT_CREATE_TIME)\n        .setLastAccessTime(DEFAULT_CREATE_TIME)\n        .addCol(\"test_id\", \"int\", \"test col id\")\n        .addCol(\"test_value\", \"string\", \"test col value\")"}
{"magic_number_smell": "\n  protected static void makeTestChangesOnPartition(Partition partition) {\n    partition.getParameters().put(\"hmsTestParam001\", \"testValue001\");\n    partition.setCreateTime(123456789);\n    partition.setLastAccessTime(123456789);\n    partition.getSd().setLocation(partition.getSd().getLocation()+\"/hh=01\");\n    partition.getSd().getCols().add(new FieldSchema(\"newcol\", \"string\", \"\"));", "refactored_code": "  protected static final int NEW_CREATE_TIME = 123456789;\n\n  protected static void makeTestChangesOnPartition(Partition partition) {\n    partition.getParameters().put(\"hmsTestParam001\", \"testValue001\");\n    partition.setCreateTime(NEW_CREATE_TIME);\n    partition.setLastAccessTime(NEW_CREATE_TIME);\n    partition.getSd().setLocation(partition.getSd().getLocation()+\"/hh=01\");\n    partition.getSd().getCols().add(new FieldSchema(\"newcol\", \"string\", \"\"));"}
{"magic_number_smell": "        getYearAndMonthPartCols(), partParams);\n\n    client.dropPartition(DB_NAME, TABLE_NAME, Lists.newArrayList(\"2016\", \"may\"), true);\n    List<Partition> partitionsAfterDelete = client.listPartitions(DB_NAME, TABLE_NAME, -1);\n    Assert.assertFalse(partitionsAfterDelete.contains(partition));\n    Assert.assertTrue(\"The location '\" + location + \"' should exist.\",\n        metaStore.isPathExists(new Path(location)));", "refactored_code": "  protected static final short MAX = -1;\n        getYearAndMonthPartCols(), partParams);\n\n    client.dropPartition(DB_NAME, TABLE_NAME, Lists.newArrayList(\"2016\", \"may\"), true);\n    List<Partition> partitionsAfterDelete = client.listPartitions(DB_NAME, TABLE_NAME, MAX);\n    Assert.assertFalse(partitionsAfterDelete.contains(partition));\n    Assert.assertTrue(\"The location '\" + location + \"' should exist.\",\n        metaStore.isPathExists(new Path(location)));"}
{"magic_number_smell": "        Lists.newArrayList(partitions[0], partitions[2], partitions[3], partitions[4]));\n    // Check the original partitions of the dest table\n    List<String> partitionNames =\n        client.listPartitionNames(destTable.getDbName(), destTable.getTableName(), -1);\n    Assert.assertEquals(3, partitionNames.size());\n    Assert.assertTrue(partitionNames.containsAll(\n        Lists.newArrayList(\"year=2019/month=march/day=15\", \"year=2019/month=march/day=22\")));", "refactored_code": "  protected static final short MAX = -1;\n        Lists.newArrayList(partitions[0], partitions[2], partitions[3], partitions[4]));\n    // Check the original partitions of the dest table\n    List<String> partitionNames =\n        client.listPartitionNames(destTable.getDbName(), destTable.getTableName(), MAX);\n    Assert.assertEquals(3, partitionNames.size());\n    Assert.assertTrue(partitionNames.containsAll(\n        Lists.newArrayList(\"year=2019/month=march/day=15\", \"year=2019/month=march/day=22\")));"}
{"magic_number_smell": "\n    createDB(DB_NAME);\n    createTable(DB_NAME, TABLE_NAME);\n    notificationLog = insertTxnWriteNotificationLog(1, WRITE_ID, DB_NAME, TABLE_NAME);\n  }\n\n  @After", "refactored_code": "  private static final long TXN_ID = 1;\n\n    createDB(DB_NAME);\n    createTable(DB_NAME, TABLE_NAME);\n    notificationLog = insertTxnWriteNotificationLog(TXN_ID, WRITE_ID, DB_NAME, TABLE_NAME);\n  }\n\n  @After"}
{"magic_number_smell": "        printDockerEvents();\n        throw new RuntimeException(\"Failed to get docker logs\");\n      }\n    } while (startTime + 5 * 60 * 1000 >= System.currentTimeMillis() && !isContainerReady(pr));\n    if (startTime + 5 * 60 * 1000 < System.currentTimeMillis()) {\n      printDockerEvents();\n      throw new RuntimeException(", "refactored_code": "  private static final int MAX_STARTUP_WAIT = 5 * 60 * 1000;\n        printDockerEvents();\n        throw new RuntimeException(\"Failed to get docker logs\");\n      }\n    } while (startTime + MAX_STARTUP_WAIT >= System.currentTimeMillis() && !isContainerReady(pr));\n    if (startTime + MAX_STARTUP_WAIT < System.currentTimeMillis()) {\n      printDockerEvents();\n      throw new RuntimeException("}
{"magic_number_smell": "\n  @Test\n  public void testCollectWorkerVersionsEmptyLists() {\n    assertThat(CompactionMetricData.of(Collections.emptyList()).allWorkerVersionsSince(0L),\n\n        is(Collections.emptyList()));\n  }", "refactored_code": "  private static final long SINCE_EPOCH = 0L;\n\n  @Test\n  public void testCollectWorkerVersionsEmptyLists() {\n    assertThat(CompactionMetricData.of(Collections.emptyList()).allWorkerVersionsSince(SINCE_EPOCH),\n\n        is(Collections.emptyList()));\n  }"}
{"magic_number_smell": "    Configuration conf = MetastoreConf.newMetastoreConf();\n    MetastoreConf.setVar(conf, MetastoreConf.ConfVars.METRICS_REPORTERS, \"slf4j\");\n    MetastoreConf.setTimeVar(conf,\n        MetastoreConf.ConfVars.METRICS_SLF4J_LOG_FREQUENCY_MINS, 1, TimeUnit.SECONDS);\n\n    // 1. Verify the default level (INFO)\n    MetastoreConf.setVar(conf, MetastoreConf.ConfVars.METRICS_SLF4J_LOG_LEVEL, \"INFO\");", "refactored_code": "  private static final long REPORT_INTERVAL = 1;\n    Configuration conf = MetastoreConf.newMetastoreConf();\n    MetastoreConf.setVar(conf, MetastoreConf.ConfVars.METRICS_REPORTERS, \"slf4j\");\n    MetastoreConf.setTimeVar(conf,\n        MetastoreConf.ConfVars.METRICS_SLF4J_LOG_FREQUENCY_MINS, REPORT_INTERVAL, TimeUnit.SECONDS);\n\n    // 1. Verify the default level (INFO)\n    MetastoreConf.setVar(conf, MetastoreConf.ConfVars.METRICS_SLF4J_LOG_LEVEL, \"INFO\");"}
{"magic_number_smell": "\n  protected static final int 8089 = 8089;\n  @ClassRule\n  public static final WireMockRule MOCK_JWKS_SERVER = new WireMockRule(8089);\n  // the url part\n  /**\n   * Abstract the property client access on a given namespace.", "refactored_code": "  protected static final int MOCK_JWKS_SERVER_PORT = 8089;\n\n  protected static final int MOCK_JWKS_SERVER_PORT = 8089;\n  @ClassRule\n  public static final WireMockRule MOCK_JWKS_SERVER = new WireMockRule(MOCK_JWKS_SERVER_PORT);\n  // the url part\n  /**\n   * Abstract the property client access on a given namespace."}
{"magic_number_smell": "   */\n  private static DescriptiveStatistics sanitize(@NotNull DescriptiveStatistics data) {\n    double meanValue = data.getMean();\n    double delta = 2 * meanValue;\n    double minVal = meanValue - delta;\n    double maxVal = meanValue + delta;\n    return new DescriptiveStatistics(Arrays.stream(data.getValues())", "refactored_code": "  private static final double MARGIN = 2;\n   */\n  private static DescriptiveStatistics sanitize(@NotNull DescriptiveStatistics data) {\n    double meanValue = data.getMean();\n    double delta = MARGIN * meanValue;\n    double minVal = meanValue - delta;\n    double maxVal = meanValue + delta;\n    return new DescriptiveStatistics(Arrays.stream(data.getValues())"}
{"magic_number_smell": "   * Create default micro benchmark measurer\n   */\n  public MicroBenchmark() {\n    this(15, ITERATIONS_DEFAULT, SCALE_DEFAULT);\n  }\n\n  /**", "refactored_code": "  private static final int WARMUP_DEFAULT = 15;\n   * Create default micro benchmark measurer\n   */\n  public MicroBenchmark() {\n    this(WARMUP_DEFAULT, ITERATIONS_DEFAULT, SCALE_DEFAULT);\n  }\n\n  /**"}
{"magic_number_smell": "      }\n      if (txnMin == txnMax) {\n        builder.append(txnMin);\n      } else if (txnMin + 5 - 1 > txnMax) {\n        // If the range is small the overhead is not worth it\n        for (long txn = txnMin; txn <= txnMax; txn++) {\n          builder.append(txn);", "refactored_code": "  private static final int MIN_RANGE_LENGTH = 5;\n      }\n      if (txnMin == txnMax) {\n        builder.append(txnMin);\n      } else if (txnMin + MIN_RANGE_LENGTH - 1 > txnMax) {\n        // If the range is small the overhead is not worth it\n        for (long txn = txnMin; txn <= txnMax; txn++) {\n          builder.append(txn);"}
{"magic_number_smell": "  private static final int FOUR_X_LONGWORD_DECIMAL_DIGITS = 4 * LONGWORD_DECIMAL_DIGITS;\n\n  // 38 decimal maximum - 32 digits in 2 lower longs (6 digits here).\n  private static final int HIGHWORD_DECIMAL_DIGITS = 38 - TWO_X_LONGWORD_DECIMAL_DIGITS;\n  private static final long MAX_HIGHWORD_DECIMAL =\n      powerOfTenTable[HIGHWORD_DECIMAL_DIGITS] - 1;\n", "refactored_code": "  public static final int MAX_DECIMAL_DIGITS = 38;\n  private static final int FOUR_X_LONGWORD_DECIMAL_DIGITS = 4 * LONGWORD_DECIMAL_DIGITS;\n\n  // 38 decimal maximum - 32 digits in 2 lower longs (6 digits here).\n  private static final int HIGHWORD_DECIMAL_DIGITS = MAX_DECIMAL_DIGITS - TWO_X_LONGWORD_DECIMAL_DIGITS;\n  private static final long MAX_HIGHWORD_DECIMAL =\n      powerOfTenTable[HIGHWORD_DECIMAL_DIGITS] - 1;\n"}
{"magic_number_smell": "   *\n   * A BigDecimal object has a decimal scale.\n   *\n   * We will have overflow if BigDecimal's integer part exceed 38 digits or\n   * 99,999,999,999,999,999,999,999,999,999,999,999,999 or 10^38 - 1.\n   *\n   * When the BigDecimal value's precision exceeds 38 and there are fractional digits", "refactored_code": "  public static final int MAX_PRECISION = 38;\n   *\n   * A BigDecimal object has a decimal scale.\n   *\n   * We will have overflow if BigDecimal's integer part exceed MAX_PRECISION digits or\n   * 99,999,999,999,999,999,999,999,999,999,999,999,999 or 10^38 - 1.\n   *\n   * When the BigDecimal value's precision exceeds MAX_PRECISION and there are fractional digits"}
{"magic_number_smell": "\n    int intDigits = bd.precision() - bd.scale();\n\n    if (intDigits > 38) {\n      return null;\n    }\n", "refactored_code": "  public static final int MAX_PRECISION = 38;\n\n    int intDigits = bd.precision() - bd.scale();\n\n    if (intDigits > MAX_PRECISION) {\n      return null;\n    }\n"}
{"magic_number_smell": "    switch (r.nextInt(4)) {\n    case 1:\n      optionalNanos = String.format(\".%09d\",\n          Integer.valueOf(r.nextInt((int) TimeUnit.SECONDS.toNanos(1))));\n      break;\n    case 2:\n      // Limit to milliseconds only...", "refactored_code": "  public static final long NANOSECONDS_PER_SECOND = TimeUnit.SECONDS.toNanos(1);\n    switch (r.nextInt(4)) {\n    case 1:\n      optionalNanos = String.format(\".%09d\",\n          Integer.valueOf(r.nextInt((int) NANOSECONDS_PER_SECOND)));\n      break;\n    case 2:\n      // Limit to milliseconds only..."}
{"magic_number_smell": "  public void fillWithNulls() {\n    noNulls = false;\n    isRepeating = true;\n    vector[0] = Double.NaN;\n    isNull[0] = true;\n  }\n", "refactored_code": "  public static final double NULL_VALUE = Double.NaN;\n  public void fillWithNulls() {\n    noNulls = false;\n    isRepeating = true;\n    vector[0] = NULL_VALUE;\n    isNull[0] = true;\n  }\n"}
{"magic_number_smell": "  public LongColumnVector fillWithNulls() {\n    noNulls = false;\n    isRepeating = true;\n    vector[0] = 1;\n    isNull[0] = true;\n\n    return this;", "refactored_code": "  public static final long NULL_VALUE = 1;\n  public LongColumnVector fillWithNulls() {\n    noNulls = false;\n    isRepeating = true;\n    vector[0] = NULL_VALUE;\n    isNull[0] = true;\n\n    return this;"}
{"magic_number_smell": "   * @param numCols the number of columns to include in the batch\n   */\n  public VectorizedRowBatch(int numCols) {\n    this(numCols, 1024);\n  }\n\n  /**", "refactored_code": "  public static final int DEFAULT_SIZE = 1024;\n   * @param numCols the number of columns to include in the batch\n   */\n  public VectorizedRowBatch(int numCols) {\n    this(numCols, DEFAULT_SIZE);\n  }\n\n  /**"}
{"magic_number_smell": "   */\n  private static class BoyerMooreHorspool implements Finder {\n    private static final int 0xff = 0xff;\n    private final long[] shift = new long[0xff];\n    private final byte[] pattern;\n    private final int plen;\n", "refactored_code": "    private static final int MAX_BYTE = 0xff;\n   */\n  private static class BoyerMooreHorspool implements Finder {\n    private static final int MAX_BYTE = 0xff;\n    private final long[] shift = new long[MAX_BYTE];\n    private final byte[] pattern;\n    private final int plen;\n"}
{"magic_number_smell": "      int numComb = 1;\n      for (ExpressionTree tree : andList) {\n        numComb *= tree.getChildren().size();\n        if (numComb > 256) {\n          return false;\n        }\n      }", "refactored_code": "    private static final int CNF_COMBINATIONS_THRESHOLD = 256;\n      int numComb = 1;\n      for (ExpressionTree tree : andList) {\n        numComb *= tree.getChildren().size();\n        if (numComb > CNF_COMBINATIONS_THRESHOLD) {\n          return false;\n        }\n      }"}
{"magic_number_smell": "  public static final int 12 = 12;\n  public static final int JAVA32_ARRAY_META = 16;\n  public static final int JAVA32_REF = 4;\n  public static final int JAVA32_OBJECT = 16;   // 12 + JAVA32_REF\n  public static final int JAVA32_ARRAY = 20;    // JAVA32_ARRAY_META + JAVA32_REF\n\n  public static final int JAVA64_META = 24;", "refactored_code": "  public static final int JAVA32_META = 12;\n  public static final int JAVA32_META = 12;\n  public static final int JAVA32_ARRAY_META = 16;\n  public static final int JAVA32_REF = 4;\n  public static final int JAVA32_OBJECT = 16;   // JAVA32_META + JAVA32_REF\n  public static final int JAVA32_ARRAY = 20;    // JAVA32_ARRAY_META + JAVA32_REF\n\n  public static final int JAVA64_META = 24;"}
{"magic_number_smell": "    // What we are trying to get is the equivalent of new Date(ymd).getTime() in the local tz,\n    // where ymd is whatever d represents. How it \"works\" is this.\n    // First we get the UTC midnight for that day (which always exists, a small island of sanity).\n    long utcMidnight = d * TimeUnit.DAYS.toMillis(1);\n    // Now we take a local TZ offset at midnight UTC. Say we are in -4; that means (surprise\n    // surprise) that at midnight UTC it was 20:00 in local. So far we are on firm ground.\n    long utcMidnightOffset = LOCAL_TIMEZONE.get().getOffset(utcMidnight);", "refactored_code": "  private static final long MILLIS_PER_DAY = TimeUnit.DAYS.toMillis(1);\n    // What we are trying to get is the equivalent of new Date(ymd).getTime() in the local tz,\n    // where ymd is whatever d represents. How it \"works\" is this.\n    // First we get the UTC midnight for that day (which always exists, a small island of sanity).\n    long utcMidnight = d * MILLIS_PER_DAY;\n    // Now we take a local TZ offset at midnight UTC. Say we are in -4; that means (surprise\n    // surprise) that at midnight UTC it was 20:00 in local. So far we are on firm ground.\n    long utcMidnightOffset = LOCAL_TIMEZONE.get().getOffset(utcMidnight);"}
{"magic_number_smell": "   */\n  @HiveDecimalWritableVersionV2\n  public static boolean isPrecisionDecimal64(int precision) {\n    return (precision <= FastHiveDecimalImpl.DECIMAL64_DECIMAL_DIGITS);\n  }\n\n  /*", "refactored_code": "  public static final int DECIMAL64_DECIMAL_DIGITS = FastHiveDecimalImpl.DECIMAL64_DECIMAL_DIGITS;\n   */\n  @HiveDecimalWritableVersionV2\n  public static boolean isPrecisionDecimal64(int precision) {\n    return (precision <= DECIMAL64_DECIMAL_DIGITS);\n  }\n\n  /*"}
{"magic_number_smell": "  }\n\n  public BloomFilter(long expectedEntries) {\n    this(expectedEntries, 0.05);\n  }\n\n  static void checkArgument(boolean expression, String message) {", "refactored_code": "  public static final double DEFAULT_FPP = 0.05;\n  }\n\n  public BloomFilter(long expectedEntries) {\n    this(expectedEntries, DEFAULT_FPP);\n  }\n\n  static void checkArgument(boolean expression, String message) {"}
{"magic_number_smell": "\n  public BloomKFilter(long maxNumEntries) {\n    checkArgument(maxNumEntries > 0, \"expectedEntries should be > 0\");\n    long numBits = optimalNumOfBits(maxNumEntries, 0.05f);\n    this.k = optimalNumOfHashFunctions(maxNumEntries, numBits);\n    long nLongs = (long) Math.ceil((double) numBits / (double) Long.SIZE);\n    // additional bits to pad long array to block size", "refactored_code": "  public static final float DEFAULT_FPP = 0.05f;\n\n  public BloomKFilter(long maxNumEntries) {\n    checkArgument(maxNumEntries > 0, \"expectedEntries should be > 0\");\n    long numBits = optimalNumOfBits(maxNumEntries, DEFAULT_FPP);\n    this.k = optimalNumOfHashFunctions(maxNumEntries, numBits);\n    long nLongs = (long) Math.ceil((double) numBits / (double) Long.SIZE);\n    // additional bits to pad long array to block size"}
{"magic_number_smell": "\n  public static final int 1000000000 = 1000000000;\n  public static final BigDecimal MAX_INT_BD = new BigDecimal(Integer.MAX_VALUE);\n  public static final BigDecimal NANOS_PER_SEC_BD = new BigDecimal(1000000000);\n\n  public static int parseNumericValueWithRange(String fieldName,\n      String strVal, int minValue, int maxValue) throws IllegalArgumentException {", "refactored_code": "  public static final int NANOS_PER_SEC = 1000000000;\n\n  public static final int NANOS_PER_SEC = 1000000000;\n  public static final BigDecimal MAX_INT_BD = new BigDecimal(Integer.MAX_VALUE);\n  public static final BigDecimal NANOS_PER_SEC_BD = new BigDecimal(NANOS_PER_SEC);\n\n  public static int parseNumericValueWithRange(String fieldName,\n      String strVal, int minValue, int maxValue) throws IllegalArgumentException {"}
{"magic_number_smell": "    assertTrue( bf.test(val2));\n    assertTrue( bf.test(val3));\n\n    byte[] randVal = new byte[100];\n    for (int i = 0; i < 100; i++) {\n      rand.nextBytes(randVal);\n      bf.add(randVal);", "refactored_code": "  private static final int COUNT = 100;\n    assertTrue( bf.test(val2));\n    assertTrue( bf.test(val3));\n\n    byte[] randVal = new byte[COUNT];\n    for (int i = 0; i < COUNT; i++) {\n      rand.nextBytes(randVal);\n      bf.add(randVal);"}
{"magic_number_smell": "    assertTrue(bf.test(val2));\n    assertTrue(bf.test(val3));\n\n    byte[] randVal = new byte[100];\n    for (int i = 0; i < 100; i++) {\n      rand.nextBytes(randVal);\n      bf.add(randVal);", "refactored_code": "  private static final int COUNT = 100;\n    assertTrue(bf.test(val2));\n    assertTrue(bf.test(val3));\n\n    byte[] randVal = new byte[COUNT];\n    for (int i = 0; i < COUNT; i++) {\n      rand.nextBytes(randVal);\n      bf.add(randVal);"}
{"magic_number_smell": "    private List<String> staticPartitionValues;\n    private String agentInfo;\n    private HiveConf hiveConf;\n    private int transactionBatchSize = 1;\n    private boolean streamingOptimizations = DEFAULT_STREAMING_OPTIMIZATIONS_ENABLED;\n    private RecordWriter recordWriter;\n    private long writeId = -1;", "refactored_code": "  private static final int DEFAULT_TRANSACTION_BATCH_SIZE = 1;\n    private List<String> staticPartitionValues;\n    private String agentInfo;\n    private HiveConf hiveConf;\n    private int transactionBatchSize = DEFAULT_TRANSACTION_BATCH_SIZE;\n    private boolean streamingOptimizations = DEFAULT_STREAMING_OPTIMIZATIONS_ENABLED;\n    private RecordWriter recordWriter;\n    private long writeId = -1;"}
{"magic_number_smell": "      // if HIVE_TXN_TIMEOUT is defined, heartbeat interval will be HIVE_TXN_TIMEOUT/2\n      heartBeatInterval = DbTxnManager.getHeartbeatInterval(conn.getConf());\n    } catch (LockException e) {\n      heartBeatInterval = 60 * 1000;\n    }\n    // to introduce some randomness and to avoid hammering the metastore at the same time (same logic as DbTxnManager)\n    initialDelay = (long) (heartBeatInterval * 0.75 * Math.random());", "refactored_code": "  private static final int DEFAULT_HEARTBEAT_INTERVAL = 60 * 1000;\n      // if HIVE_TXN_TIMEOUT is defined, heartbeat interval will be HIVE_TXN_TIMEOUT/2\n      heartBeatInterval = DbTxnManager.getHeartbeatInterval(conn.getConf());\n    } catch (LockException e) {\n      heartBeatInterval = DEFAULT_HEARTBEAT_INTERVAL;\n    }\n    // to introduce some randomness and to avoid hammering the metastore at the same time (same logic as DbTxnManager)\n    initialDelay = (long) (heartBeatInterval * 0.75 * Math.random());"}
{"magic_number_smell": "   */\n  public static void main(String[] args) throws SQLException, ClassNotFoundException {\n    Class.forName(driverName);\n    int numberOfQueryIterations = 80000;\n\n    if (args.length > 0) {\n      numberOfQueryIterations = Integer.parseInt(args[0]);", "refactored_code": "  private static final int NUM_QUERY_ITERATIONS = 80000;\n   */\n  public static void main(String[] args) throws SQLException, ClassNotFoundException {\n    Class.forName(driverName);\n    int numberOfQueryIterations = NUM_QUERY_ITERATIONS;\n\n    if (args.length > 0) {\n      numberOfQueryIterations = Integer.parseInt(args[0]);"}
{"magic_number_smell": "     * The default chunk size tries to leave an error margin so that compressed\n     * data size on hadoop or skewed data sets don't cause chunk overflows\n     */\n    public static final long DEFAULT_CHUNK_SIZE = Integer.MAX_VALUE / 2;\n\n    /**\n     * The max number of keys which can collide to the same hash is based on the", "refactored_code": "    public static final long MAX_CHUNK_SIZE = Integer.MAX_VALUE;\n     * The default chunk size tries to leave an error margin so that compressed\n     * data size on hadoop or skewed data sets don't cause chunk overflows\n     */\n    public static final long DEFAULT_CHUNK_SIZE = MAX_CHUNK_SIZE / 2;\n\n    /**\n     * The max number of keys which can collide to the same hash is based on the"}
{"magic_number_smell": "\n            deleteExtraStatsFiles(statsDirectory, maxVersionsStatsFile);\n\n            String destName = destination.getName() + \".stats-v\" + 4;\n            this.statsFile = new File(statsDirectory, destName);\n            statsFile.createNewFile();\n", "refactored_code": "    private static final int STATS_VERSION = 4;\n\n            deleteExtraStatsFiles(statsDirectory, maxVersionsStatsFile);\n\n            String destName = destination.getName() + \".stats-v\" + STATS_VERSION;\n            this.statsFile = new File(statsDirectory, destName);\n            statsFile.createNewFile();\n"}
{"magic_number_smell": "                fs.delete(outputDir, true);\n            }\n\n            conf.setInt(\"io.file.buffer.size\", 64 * 1024);\n            conf.set(\"cluster.xml\", new ClusterMapper().writeCluster(cluster));\n            conf.set(\"stores.xml\",\n                     new StoreDefinitionsMapper().writeStoreList(Collections.singletonList(storeDef)));", "refactored_code": "    public static final int DEFAULT_BUFFER_SIZE = 64 * 1024;\n                fs.delete(outputDir, true);\n            }\n\n            conf.setInt(\"io.file.buffer.size\", DEFAULT_BUFFER_SIZE);\n            conf.set(\"cluster.xml\", new ClusterMapper().writeCluster(cluster));\n            conf.set(\"stores.xml\",\n                     new StoreDefinitionsMapper().writeStoreList(Collections.singletonList(storeDef)));"}
{"magic_number_smell": "        this.executorService = Executors.newFixedThreadPool(requiredNumberOfThreads);\n\n        this.maxThreadNumForStoreVerification = props.getInt(STORE_VERIFICATION_MAX_THREAD_NUM,\n            20);\n        // Specifying value <= 1 for prop: STORE_VERIFICATION_MAX_THREAD_NUM will enable sequential store verification.\n        if (this.maxThreadNumForStoreVerification > 1) {\n            this.storeVerificationExecutorService = Executors.newFixedThreadPool(this.maxThreadNumForStoreVerification);", "refactored_code": "    private final int DEFAULT_THREAD_NUM_FOR_STORE_VERIFICATION = 20;\n        this.executorService = Executors.newFixedThreadPool(requiredNumberOfThreads);\n\n        this.maxThreadNumForStoreVerification = props.getInt(STORE_VERIFICATION_MAX_THREAD_NUM,\n            DEFAULT_THREAD_NUM_FOR_STORE_VERIFICATION);\n        // Specifying value <= 1 for prop: STORE_VERIFICATION_MAX_THREAD_NUM will enable sequential store verification.\n        if (this.maxThreadNumForStoreVerification > 1) {\n            this.storeVerificationExecutorService = Executors.newFixedThreadPool(this.maxThreadNumForStoreVerification);"}
{"magic_number_smell": "                   String restBootstrapURL,\n                   final TransportClient transportClient,\n                   final RESTClientConfig config) {\n        this(storeName, restBootstrapURL, null, transportClient, null, config, -1);\n    }\n\n    public R2Store(String storeName,", "refactored_code": "    private static final int INVALID_ZONE_ID = -1;\n                   String restBootstrapURL,\n                   final TransportClient transportClient,\n                   final RESTClientConfig config) {\n        this(storeName, restBootstrapURL, null, transportClient, null, config, INVALID_ZONE_ID);\n    }\n\n    public R2Store(String storeName,"}
{"magic_number_smell": "        }\n\n        final FutureCallback<None> factoryShutdownCallback = new FutureCallback<None>();\n        this._clientFactory.shutdown(factoryShutdownCallback, 10, TimeUnit.SECONDS);\n        try {\n            factoryShutdownCallback.get();\n        } catch(InterruptedException e) {", "refactored_code": "    public static final int SHUTDOWN_TIMEOUT = 10;\n        }\n\n        final FutureCallback<None> factoryShutdownCallback = new FutureCallback<None>();\n        this._clientFactory.shutdown(factoryShutdownCallback, SHUTDOWN_TIMEOUT, TimeUnit.SECONDS);\n        try {\n            factoryShutdownCallback.get();\n        } catch(InterruptedException e) {"}
{"magic_number_smell": "            requestBuilder.setHeader(RestMessageHeaders.X_VOLD_ROUTING_TYPE_CODE,\n                                     this.routingTypeCode);\n        }\n        if(this.zoneId != -1) {\n            requestBuilder.setHeader(RestMessageHeaders.X_VOLD_ZONE_ID, String.valueOf(this.zoneId));\n        }\n        return requestBuilder;", "refactored_code": "    private static final int INVALID_ZONE_ID = -1;\n            requestBuilder.setHeader(RestMessageHeaders.X_VOLD_ROUTING_TYPE_CODE,\n                                     this.routingTypeCode);\n        }\n        if(this.zoneId != INVALID_ZONE_ID) {\n            requestBuilder.setHeader(RestMessageHeaders.X_VOLD_ZONE_ID, String.valueOf(this.zoneId));\n        }\n        return requestBuilder;"}
{"magic_number_smell": "                                        long maxWait,\n                                        TimeUnit timeUnit,\n                                        AsyncOperationStatus higherStatus) {\n            long delay = 250;\n            long waitUntil = Long.MAX_VALUE;\n            if(maxWait > 0) {\n                waitUntil = System.currentTimeMillis() + timeUnit.toMillis(maxWait);", "refactored_code": "    private static final long INITIAL_DELAY = 250; // Initial delay\n                                        long maxWait,\n                                        TimeUnit timeUnit,\n                                        AsyncOperationStatus higherStatus) {\n            long delay = INITIAL_DELAY;\n            long waitUntil = Long.MAX_VALUE;\n            if(maxWait > 0) {\n                waitUntil = System.currentTimeMillis() + timeUnit.toMillis(maxWait);"}
{"magic_number_smell": "    private final long createTimestamp;\n\n    public SocketAndStreams(Socket socket, RequestFormatType requestFormatType) throws IOException {\n        this(socket, 1000, requestFormatType);\n    }\n\n    public SocketAndStreams(Socket socket, int bufferSizeBytes, RequestFormatType type)", "refactored_code": "    private static final int DEFAULT_BUFFER_SIZE = 1000;\n    private final long createTimestamp;\n\n    public SocketAndStreams(Socket socket, RequestFormatType requestFormatType) throws IOException {\n        this(socket, DEFAULT_BUFFER_SIZE, requestFormatType);\n    }\n\n    public SocketAndStreams(Socket socket, int bufferSizeBytes, RequestFormatType type)"}
{"magic_number_smell": "    }\n    \n    // required bytes key = 1;\n    public static final int 1 = 1;\n    private boolean hasKey;\n    private com.google.protobuf.ByteString key_ = com.google.protobuf.ByteString.EMPTY;\n    public boolean hasKey() { return hasKey; }", "refactored_code": "    public static final int KEY_FIELD_NUMBER = 1;\n    }\n    \n    // required bytes key = 1;\n    public static final int KEY_FIELD_NUMBER = 1;\n    private boolean hasKey;\n    private com.google.protobuf.ByteString key_ = com.google.protobuf.ByteString.EMPTY;\n    public boolean hasKey() { return hasKey; }"}
{"magic_number_smell": "\n    protected String implementationClassName = DEFAULT_IMPLEMENTATION_CLASS_NAME;\n\n    protected long bannagePeriod = 30000;\n\n    protected int threshold = DEFAULT_THRESHOLD;\n", "refactored_code": "    public static final long DEFAULT_BANNAGE_PERIOD = 30000;\n\n    protected String implementationClassName = DEFAULT_IMPLEMENTATION_CLASS_NAME;\n\n    protected long bannagePeriod = DEFAULT_BANNAGE_PERIOD;\n\n    protected int threshold = DEFAULT_THRESHOLD;\n"}
{"magic_number_smell": "\n                try {\n                    selectTimeMs = System.currentTimeMillis();\n                    int selected = selector.select(500);\n                    selectTimeMs = System.currentTimeMillis() - selectTimeMs;\n                    selectCount = selected;\n", "refactored_code": "    public static final int SELECTOR_POLL_MS = 500;\n\n                try {\n                    selectTimeMs = System.currentTimeMillis();\n                    int selected = selector.select(SELECTOR_POLL_MS);\n                    selectTimeMs = System.currentTimeMillis() - selectTimeMs;\n                    selectCount = selected;\n"}
{"magic_number_smell": "\n    public void recordStats(StoreStats performanceStats, long startTimeInMs, Tracked operation) {\n        long duration = System.currentTimeMillis() - startTimeInMs;\n        performanceStats.recordTime(operation, duration * 1000000);\n    }\n\n    protected void debugLog(String operationType,", "refactored_code": "    protected static final long NS_PER_MS = 1000000;\n\n    public void recordStats(StoreStats performanceStats, long startTimeInMs, Tracked operation) {\n        long duration = System.currentTimeMillis() - startTimeInMs;\n        performanceStats.recordTime(operation, duration * NS_PER_MS);\n    }\n\n    protected void debugLog(String operationType,"}
{"magic_number_smell": "    public ChannelPipeline getPipeline() throws Exception {\n        ChannelPipeline pipeline = pipeline();\n        pipeline.addLast(\"decoder\", new HttpRequestDecoder());\n        pipeline.addLast(\"aggregator\", new HttpChunkAggregator(1048576));\n        pipeline.addLast(\"encoder\", new HttpResponseEncoder());\n        pipeline.addLast(\"deflater\", new HttpContentCompressor());\n        pipeline.addLast(\"handler\", new CoordinatorAdminRequestHandler(storeClientConfigs));", "refactored_code": "    private static final int MAX_AGGREGATE_SIZE = 1048576;\n    public ChannelPipeline getPipeline() throws Exception {\n        ChannelPipeline pipeline = pipeline();\n        pipeline.addLast(\"decoder\", new HttpRequestDecoder());\n        pipeline.addLast(\"aggregator\", new HttpChunkAggregator(MAX_AGGREGATE_SIZE));\n        pipeline.addLast(\"encoder\", new HttpResponseEncoder());\n        pipeline.addLast(\"deflater\", new HttpContentCompressor());\n        pipeline.addLast(\"handler\", new CoordinatorAdminRequestHandler(storeClientConfigs));"}
{"magic_number_smell": "    private void writeLength(DataOutputStream stream, int size) throws IOException {\n        if(size < Short.MAX_VALUE) {\n            stream.writeShort(size);\n        } else if(size <= 0x3FFFFFFF) {\n            stream.writeInt(size | 0xC0000000);\n        } else {\n            throw new SerializationException(\"Invalid length: maximum is \" + 0x3FFFFFFF);", "refactored_code": "    private static final int MAX_SEQ_LENGTH = 0x3FFFFFFF;\n    private void writeLength(DataOutputStream stream, int size) throws IOException {\n        if(size < Short.MAX_VALUE) {\n            stream.writeShort(size);\n        } else if(size <= MAX_SEQ_LENGTH) {\n            stream.writeInt(size | 0xC0000000);\n        } else {\n            throw new SerializationException(\"Invalid length: maximum is \" + MAX_SEQ_LENGTH);"}
{"magic_number_smell": "        try {\n            // Signal the thread to stop accepting new connections...\n            if(logger.isTraceEnabled())\n                logger.trace(\"Interrupted acceptor thread, waiting \" + 15000\n                             + \" ms for termination\");\n\n            acceptorThread.interrupt();", "refactored_code": "    private static final int SHUTDOWN_TIMEOUT_MS = 15000;\n        try {\n            // Signal the thread to stop accepting new connections...\n            if(logger.isTraceEnabled())\n                logger.trace(\"Interrupted acceptor thread, waiting \" + SHUTDOWN_TIMEOUT_MS\n                             + \" ms for termination\");\n\n            acceptorThread.interrupt();"}
{"magic_number_smell": "              networkClassLoader,\n              metadataStore);\n        currBufferedKey = null;\n        currBufferedVals = new ArrayList<Versioned<byte[]>>(5);\n    }\n\n    /**", "refactored_code": "    private static final int VALS_BUFFER_EXPECTED_SIZE = 5;\n              networkClassLoader,\n              metadataStore);\n        currBufferedKey = null;\n        currBufferedVals = new ArrayList<Versioned<byte[]>>(VALS_BUFFER_EXPECTED_SIZE);\n    }\n\n    /**"}
{"magic_number_smell": "    @Override\n    public long getWaitTimeMs() {\n        if(currentState == State.WAITING) {\n            return System.currentTimeMillis() - System.currentTimeMillis();\n        }\n        return 0L;\n    }", "refactored_code": "    private final long startTime = System.currentTimeMillis();\n    @Override\n    public long getWaitTimeMs() {\n        if(currentState == State.WAITING) {\n            return System.currentTimeMillis() - startTime;\n        }\n        return 0L;\n    }"}
{"magic_number_smell": "        }\n        byte[] bytes = new byte[size];\n        int pos = 1;\n        bytes[0] = 0;\n        for(Versioned<byte[]> v: values) {\n            pos += ((VectorClock) v.getVersion()).toBytes(bytes, pos);\n            int len = v.getValue().length;", "refactored_code": "    private static final byte VERSION = 0;\n        }\n        byte[] bytes = new byte[size];\n        int pos = 1;\n        bytes[0] = VERSION;\n        for(Versioned<byte[]> v: values) {\n            pos += ((VectorClock) v.getVersion()).toBytes(bytes, pos);\n            int len = v.getValue().length;"}
{"magic_number_smell": "            destination = new FileOutputStream(destFile);\n            verifyStream = new LogVerificationInputStream(env, source, sourceFile.getName());\n\n            final byte[] buf = new byte[1024];\n\n            while(true) {\n                final int len = verifyStream.read(buf);", "refactored_code": "    private static final int LOGVERIFY_BUFSIZE = 1024;\n            destination = new FileOutputStream(destFile);\n            verifyStream = new LogVerificationInputStream(env, source, sourceFile.getName());\n\n            final byte[] buf = new byte[LOGVERIFY_BUFSIZE];\n\n            while(true) {\n                final int len = verifyStream.read(buf);"}
{"magic_number_smell": "    public static final boolean DEFAULT_MINIMIZE_SCAN_IMPACT = false;\n    public static final boolean DEFAULT_TURNOFF_CHECKPOINTER_BATCH_WRITES = false;\n\n    private long statsCacheTtlMs = 5 * Time.MS_PER_SECOND;\n    private LockMode lockMode = DEFAULT_LOCK_MODE;\n    private boolean exposeSpaceUtil = DEFAULT_EXPOSE_SPACE_UTIL;\n    private boolean minimizeScanImpact = DEFAULT_MINIMIZE_SCAN_IMPACT;", "refactored_code": "    public static final long DEFAULT_STATS_CACHE_TTL_MS = 5 * Time.MS_PER_SECOND;\n    public static final boolean DEFAULT_MINIMIZE_SCAN_IMPACT = false;\n    public static final boolean DEFAULT_TURNOFF_CHECKPOINTER_BATCH_WRITES = false;\n\n    private long statsCacheTtlMs = DEFAULT_STATS_CACHE_TTL_MS;\n    private LockMode lockMode = DEFAULT_LOCK_MODE;\n    private boolean exposeSpaceUtil = DEFAULT_EXPOSE_SPACE_UTIL;\n    private boolean minimizeScanImpact = DEFAULT_MINIMIZE_SCAN_IMPACT;"}
{"magic_number_smell": "    private final QuotaLimitStats parent;\n\n    public QuotaLimitStats(QuotaLimitStats parent) {\n        this(parent, 60000);\n    }\n\n    public QuotaLimitStats(QuotaLimitStats parent, long resetIntervalMs) {", "refactored_code": "    private static final int QUOTA_STATS_RESET_INTERVAL_MS = 60000;\n    private final QuotaLimitStats parent;\n\n    public QuotaLimitStats(QuotaLimitStats parent) {\n        this(parent, QUOTA_STATS_RESET_INTERVAL_MS);\n    }\n\n    public QuotaLimitStats(QuotaLimitStats parent, long resetIntervalMs) {"}
{"magic_number_smell": "        storeVersionManager = new StoreVersionManager(storeDir, config);\n        open(null);\n\n        lastFetchRequestId = -1;\n    }\n\n    @Override", "refactored_code": "    public static final int NO_FETCH_IN_PROGRESS = -1;\n        storeVersionManager = new StoreVersionManager(storeDir, config);\n        open(null);\n\n        lastFetchRequestId = NO_FETCH_IN_PROGRESS;\n    }\n\n    @Override"}
{"magic_number_smell": "     * Permissible values for advice include:\n     * \n     * <p>\n     * 0\n     * \n     * <p>\n     * Indicates that the application has no advice to give about its access", "refactored_code": "    public static final int POSIX_FADV_NORMAL = 0; /* fadvise.h */\n     * Permissible values for advice include:\n     * \n     * <p>\n     * POSIX_FADV_NORMAL\n     * \n     * <p>\n     * Indicates that the application has no advice to give about its access"}
{"magic_number_smell": "            logger.debug(\"File descriptor is: \" + fd);\n\n        // mmap a large file...\n        Pointer addr = mmap(file.length(), 0x1, mman.MAP_SHARED, fd, 0L);\n        if(logger.isDebugEnabled())\n            logger.debug(\"mmap address is: \" + Pointer.nativeValue(addr));\n", "refactored_code": "    public static final int PROT_READ = 0x1; /* Page can be read. */\n            logger.debug(\"File descriptor is: \" + fd);\n\n        // mmap a large file...\n        Pointer addr = mmap(file.length(), PROT_READ, mman.MAP_SHARED, fd, 0L);\n        if(logger.isDebugEnabled())\n            logger.debug(\"mmap address is: \" + Pointer.nativeValue(addr));\n"}
{"magic_number_smell": "                    // the client in one callable does not refresh the AdminClient used by another callable.\n                    AdminClient currentAdminClient = AdminStoreSwapper.this.adminClient;\n                    int attempt = 1;\n                    while (attempt <= 10) {\n                        if (attempt > 1) {\n                            logger.info(\"Fetch attempt \" + attempt + \"/\" + 10 + \" for \" + node.briefToString()\n                                        + \". Will wait \" + WAIT_TIME_BETWEEN_FETCH_ATTEMPTS + \" ms before going ahead.\");", "refactored_code": "    private static final int MAX_FETCH_ATTEMPTS = 10;\n                    // the client in one callable does not refresh the AdminClient used by another callable.\n                    AdminClient currentAdminClient = AdminStoreSwapper.this.adminClient;\n                    int attempt = 1;\n                    while (attempt <= MAX_FETCH_ATTEMPTS) {\n                        if (attempt > 1) {\n                            logger.info(\"Fetch attempt \" + attempt + \"/\" + MAX_FETCH_ATTEMPTS + \" for \" + node.briefToString()\n                                        + \". Will wait \" + WAIT_TIME_BETWEEN_FETCH_ATTEMPTS + \" ms before going ahead.\");"}
{"magic_number_smell": "\n    @Override\n    public boolean delete(final ByteArray key, final Version version) {\n        for(int attempts = 0; attempts < this.3; attempts++) {\n            try {\n                return super.delete(key, version);\n            } catch(InvalidMetadataException e) {", "refactored_code": "    private final int maxMetadataRefreshAttempts = 3;\n\n    @Override\n    public boolean delete(final ByteArray key, final Version version) {\n        for(int attempts = 0; attempts < this.maxMetadataRefreshAttempts; attempts++) {\n            try {\n                return super.delete(key, version);\n            } catch(InvalidMetadataException e) {"}
{"magic_number_smell": "\n            if(logger.isTraceEnabled())\n                logger.trace(\"Shut down SelectorManager thread pool acceptor, waiting \"\n                             + 15000 + \" ms for termination\");\n\n            boolean terminated = selectorManagerThreadPool.awaitTermination(15000,\n                                                                            TimeUnit.MILLISECONDS);", "refactored_code": "    private static final int SHUTDOWN_TIMEOUT_MS = 15000;\n\n            if(logger.isTraceEnabled())\n                logger.trace(\"Shut down SelectorManager thread pool acceptor, waiting \"\n                             + SHUTDOWN_TIMEOUT_MS + \" ms for termination\");\n\n            boolean terminated = selectorManagerThreadPool.awaitTermination(SHUTDOWN_TIMEOUT_MS,\n                                                                            TimeUnit.MILLISECONDS);"}
{"magic_number_smell": "             maxConnectionsPerNode,\n             connectionTimeoutMs,\n             soTimeoutMs,\n             -1,\n             socketBufferSize,\n             socketKeepAlive,\n             DEFAULT_JMX_ENABLED,", "refactored_code": "    public static final long DEFAULT_IDLE_CONNECTION_TIMEOUT_MS  = -1 ; //Disabled by default.\n             maxConnectionsPerNode,\n             connectionTimeoutMs,\n             soTimeoutMs,\n             DEFAULT_IDLE_CONNECTION_TIMEOUT_MS,\n             socketBufferSize,\n             socketKeepAlive,\n             DEFAULT_JMX_ENABLED,"}
{"magic_number_smell": "            RequestCounter requestCounter;\n\n            if (parent == null) {\n                requestCounter = new RequestCounter(requestCounterName, 60000, useHistogram);\n            } else {\n                requestCounterName = parent.storeName + \".\" + requestCounterName;\n                requestCounter =", "refactored_code": "    public static final long timeWindow = 60000;\n            RequestCounter requestCounter;\n\n            if (parent == null) {\n                requestCounter = new RequestCounter(requestCounterName, timeWindow, useHistogram);\n            } else {\n                requestCounterName = parent.storeName + \".\" + requestCounterName;\n                requestCounter ="}
{"magic_number_smell": "\n        // create the counters for each operation\n        networkTimeCounterMap.put(Operation.FETCH_KEYS,\n                                  new SimpleCounter(60000));\n        networkTimeCounterMap.put(Operation.FETCH_ENTRIES,\n                                  new SimpleCounter(60000));\n        networkTimeCounterMap.put(Operation.UPDATE_ENTRIES,", "refactored_code": "    private static final int STREAMING_STATS_RESET_INTERVAL_MS = 60000;\n\n        // create the counters for each operation\n        networkTimeCounterMap.put(Operation.FETCH_KEYS,\n                                  new SimpleCounter(STREAMING_STATS_RESET_INTERVAL_MS));\n        networkTimeCounterMap.put(Operation.FETCH_ENTRIES,\n                                  new SimpleCounter(STREAMING_STATS_RESET_INTERVAL_MS));\n        networkTimeCounterMap.put(Operation.UPDATE_ENTRIES,"}
{"magic_number_smell": "\n        // If orphaned values exist, add them to fake nodes to be processed by\n        // \"getRepairs\"\n        int currentFakeNodeId = Integer.MIN_VALUE;\n        if(this.orphanedValues != null) {\n            for(Versioned<byte[]> value: this.orphanedValues.getValues()) {\n                nodeValues.add(new NodeValue<ByteArray, byte[]>(currentFakeNodeId,", "refactored_code": "    private static final int fakeNodeID = Integer.MIN_VALUE;\n\n        // If orphaned values exist, add them to fake nodes to be processed by\n        // \"getRepairs\"\n        int currentFakeNodeId = fakeNodeID;\n        if(this.orphanedValues != null) {\n            for(Versioned<byte[]> value: this.orphanedValues.getValues()) {\n                nodeValues.add(new NodeValue<ByteArray, byte[]>(currentFakeNodeId,"}
{"magic_number_smell": "              .ofType(Integer.class);\n        parser.accepts(\"max-puts-per-second\",\n                       \"Maximum number of put(...) operations issued against destination cluster per second. [Default: \"\n                               + 500 + \" ]\")\n              .withRequiredArg()\n              .describedAs(\"maxPutsPerSecond\")\n              .ofType(Integer.class);", "refactored_code": "    private static final int DEFAULT_MAX_PUTS_PER_SEC = 500;\n              .ofType(Integer.class);\n        parser.accepts(\"max-puts-per-second\",\n                       \"Maximum number of put(...) operations issued against destination cluster per second. [Default: \"\n                               + DEFAULT_MAX_PUTS_PER_SEC + \" ]\")\n              .withRequiredArg()\n              .describedAs(\"maxPutsPerSecond\")\n              .ofType(Integer.class);"}
{"magic_number_smell": "     * @param maxRatePerSecond Maximum rate that this throttler should allow (0 is unlimited)\n     */\n    public EventThrottler(long maxRatePerSecond) {\n        this(maxRatePerSecond, 1000, null);\n    }\n\n    /**", "refactored_code": "    private static final long DEFAULT_CHECK_INTERVAL_MS = 1000;\n     * @param maxRatePerSecond Maximum rate that this throttler should allow (0 is unlimited)\n     */\n    public EventThrottler(long maxRatePerSecond) {\n        this(maxRatePerSecond, DEFAULT_CHECK_INTERVAL_MS, null);\n    }\n\n    /**"}
{"magic_number_smell": "    public static final long FNV_PRIME_64 = 1099511628211L;\n\n    public int hash(byte[] key) {\n        long hash = 0x811c9dc5;\n        for(int i = 0; i < key.length; i++) {\n            hash ^= 0xFF & key[i];\n            hash *= FNV_PRIME;", "refactored_code": "    private static final long FNV_BASIS = 0x811c9dc5;\n    public static final long FNV_PRIME_64 = 1099511628211L;\n\n    public int hash(byte[] key) {\n        long hash = FNV_BASIS;\n        for(int i = 0; i < key.length; i++) {\n            hash ^= 0xFF & key[i];\n            hash *= FNV_PRIME;"}
{"magic_number_smell": "                return;\n            // Since we demand-zero every page of the heap while bringing up the\n            // jvm, MCL_FUTURE is not needed\n            mlockall(1);\n            logger.info(\"mlockall() on JVM Heap successful\");\n        } catch(Exception e) {\n            if(!(e instanceof LastErrorException))", "refactored_code": "    private static final int MCL_CURRENT = 1;\n                return;\n            // Since we demand-zero every page of the heap while bringing up the\n            // jvm, MCL_FUTURE is not needed\n            mlockall(MCL_CURRENT);\n            logger.info(\"mlockall() on JVM Heap successful\");\n        } catch(Exception e) {\n            if(!(e instanceof LastErrorException))"}
{"magic_number_smell": "    }\n\n    public static long copyLarge(Reader input, Writer output, long limit) throws IOException {\n        char[] buffer = new char[1024 * 4];\n        long count = 0;\n        int n = 0;\n        long remaining = limit;", "refactored_code": "    private static final int DEFAULT_BUFFER_SIZE = 1024 * 4;\n    }\n\n    public static long copyLarge(Reader input, Writer output, long limit) throws IOException {\n        char[] buffer = new char[DEFAULT_BUFFER_SIZE];\n        long count = 0;\n        int n = 0;\n        long remaining = limit;"}
{"magic_number_smell": "     * one ensures that all background work completes before the next period of\n     * put operations (assuming SLOW_PUT_MS >> MAX_PUT_TIME_MS).\n     */\n    private static final long PUT_PERIODICITY_MS = (2 + 1) * SLOW_PUT_MS;\n\n    // Ensure that threads will contend at all servers\n    private static final int CONNECTIONS_PER_NODE = 1;", "refactored_code": "    private static final int NUM_CLIENTS = 2;\n     * one ensures that all background work completes before the next period of\n     * put operations (assuming SLOW_PUT_MS >> MAX_PUT_TIME_MS).\n     */\n    private static final long PUT_PERIODICITY_MS = (NUM_CLIENTS + 1) * SLOW_PUT_MS;\n\n    // Ensure that threads will contend at all servers\n    private static final int CONNECTIONS_PER_NODE = 1;"}
{"magic_number_smell": "\n    private static HttpClient createClient() {\n        ThreadSafeClientConnManager connectionManager = new ThreadSafeClientConnManager(SchemeRegistryFactory.createDefault(),\n                                                                                        100000,\n                                                                                        TimeUnit.MILLISECONDS);\n\n        DefaultHttpClient httpClient = new DefaultHttpClient(connectionManager);", "refactored_code": "    private static final int DEFAULT_CONNECTION_MANAGER_TIMEOUT = 100000;\n\n    private static HttpClient createClient() {\n        ThreadSafeClientConnManager connectionManager = new ThreadSafeClientConnManager(SchemeRegistryFactory.createDefault(),\n                                                                                        DEFAULT_CONNECTION_MANAGER_TIMEOUT,\n                                                                                        TimeUnit.MILLISECONDS);\n\n        DefaultHttpClient httpClient = new DefaultHttpClient(connectionManager);"}
{"magic_number_smell": "        int requests = Integer.parseInt(nonOptions.get(2));\n        int keySize = CmdUtils.valueOf(options, \"k\", 128);\n        int valueSize = CmdUtils.valueOf(options, \"v\", 256);\n        int workers = CmdUtils.valueOf(options, \"threads\", 8);\n        String postfix = (String) (options.has(\"p\") ? options.valueOf(\"p\") : null);\n        RemoteDataGenerator rdg = new RemoteDataGenerator(url, storeName, workers);\n        rdg.generateData(requests, keySize, valueSize, postfix);", "refactored_code": "    private static final int MAX_WORKERS = 8;\n        int requests = Integer.parseInt(nonOptions.get(2));\n        int keySize = CmdUtils.valueOf(options, \"k\", 128);\n        int valueSize = CmdUtils.valueOf(options, \"v\", 256);\n        int workers = CmdUtils.valueOf(options, \"threads\", MAX_WORKERS);\n        String postfix = (String) (options.has(\"p\") ? options.valueOf(\"p\") : null);\n        RemoteDataGenerator rdg = new RemoteDataGenerator(url, storeName, workers);\n        rdg.generateData(requests, keySize, valueSize, postfix);"}
{"magic_number_smell": "    @SuppressWarnings(\"unchecked\")\n    public void initializeStore(Props benchmarkProps) throws Exception {\n\n        this.numThreads = benchmarkProps.getInt(THREADS, 8);\n        this.numConnectionsPerNode = benchmarkProps.getInt(NUM_CONNECTIONS_PER_NODE,\n                                                           MAX_CONNECTIONS_PER_NODE);\n        this.numIterations = benchmarkProps.getInt(ITERATIONS, 1);", "refactored_code": "    private static final int MAX_WORKERS = 8;\n    @SuppressWarnings(\"unchecked\")\n    public void initializeStore(Props benchmarkProps) throws Exception {\n\n        this.numThreads = benchmarkProps.getInt(THREADS, MAX_WORKERS);\n        this.numConnectionsPerNode = benchmarkProps.getInt(NUM_CONNECTIONS_PER_NODE,\n                                                           MAX_CONNECTIONS_PER_NODE);\n        this.numIterations = benchmarkProps.getInt(ITERATIONS, 1);"}
{"magic_number_smell": "        this.min = min;\n        this.max = max;\n        this.itemCount = this.max - this.min + 1;\n        generator = new ZipfianGenerator(0, ITEM_COUNT, zipfianConstant, 52.93805640344461);\n        hash = new FnvHashFunction();\n    }\n", "refactored_code": "    public static final double ZETAN = 52.93805640344461;\n        this.min = min;\n        this.max = max;\n        this.itemCount = this.max - this.min + 1;\n        generator = new ZipfianGenerator(0, ITEM_COUNT, zipfianConstant, ZETAN);\n        hash = new FnvHashFunction();\n    }\n"}
{"magic_number_smell": "    }\n\n    public ZipfianGenerator(long min, long max) {\n        this(min, max, 0.99);\n    }\n\n    public ZipfianGenerator(long items, double zipfianConstant) {", "refactored_code": "    public static final double ZIPFIAN_CONSTANT = 0.99;\n    }\n\n    public ZipfianGenerator(long min, long max) {\n        this(min, max, ZIPFIAN_CONSTANT);\n    }\n\n    public ZipfianGenerator(long items, double zipfianConstant) {"}
{"magic_number_smell": "\n    class MyList extends ArrayList<Versioned<byte[]>> {\n\n        public static final long 1 = 1;\n\n        @Override\n        public Versioned<byte[]> get(int index) {", "refactored_code": "        public static final long serialVersionUID = 1;\n\n    class MyList extends ArrayList<Versioned<byte[]>> {\n\n        public static final long serialVersionUID = 1;\n\n        @Override\n        public Versioned<byte[]> get(int index) {"}
{"magic_number_smell": "\n    @Override\n    protected int getNumKeys() {\n        return 10100;\n    }\n\n}", "refactored_code": "    private final int NUM_KEYS = 10100;\n\n    @Override\n    protected int getNumKeys() {\n        return NUM_KEYS;\n    }\n\n}"}
{"magic_number_smell": "\n    @Override\n    protected int getNumKeys() {\n        return 10100;\n    }\n\n}", "refactored_code": "    private final int NUM_KEYS = 10100;\n\n    @Override\n    protected int getNumKeys() {\n        return NUM_KEYS;\n    }\n\n}"}
{"magic_number_smell": "        }\n\n        public String getKey() {\n            return new Integer(random.nextInt(100)).toString();\n        }\n\n        public String getValue() {", "refactored_code": "    private static final int KEY_RANGE = 100;\n        }\n\n        public String getKey() {\n            return new Integer(random.nextInt(KEY_RANGE)).toString();\n        }\n\n        public String getValue() {"}
{"magic_number_smell": "                                                                        + serverPorts[0])\n                                                      .setClientContextName(CLIENT_CONTEXT_NAME)\n                                                      .enableDefaultClient(false)\n                                                      .setClientRegistryUpdateIntervalInSecs(1)\n                                                      .setEnableLazy(false);\n        SocketStoreClientFactory socketFactory = new SocketStoreClientFactory(clientConfig);\n        StoreClient<String, String> client1 = socketFactory.getStoreClient(TEST_STORE_NAME);", "refactored_code": "    public static final int CLIENT_REGISTRY_REFRESH_INTERVAL = 1;\n                                                                        + serverPorts[0])\n                                                      .setClientContextName(CLIENT_CONTEXT_NAME)\n                                                      .enableDefaultClient(false)\n                                                      .setClientRegistryUpdateIntervalInSecs(CLIENT_REGISTRY_REFRESH_INTERVAL)\n                                                      .setEnableLazy(false);\n        SocketStoreClientFactory socketFactory = new SocketStoreClientFactory(clientConfig);\n        StoreClient<String, String> client1 = socketFactory.getStoreClient(TEST_STORE_NAME);"}
{"magic_number_smell": "            String bootstrapTime = getPropertyFromClientInfo(\"bootstrapTime\");\n            // Update cluster.xml metadata\n            ClientConfig clientConfig = new ClientConfig().setBootstrapUrls(bootStrapUrls)\n                                                          .setClientZoneId(0);\n            AdminClient adminClient = new AdminClient(clientConfig);\n            for(Node node: cluster.getNodes()) {\n                VoldemortAdminTool.executeSetMetadata(node.getId(),", "refactored_code": "    protected final int CLIENT_ZONE_ID = 0;\n            String bootstrapTime = getPropertyFromClientInfo(\"bootstrapTime\");\n            // Update cluster.xml metadata\n            ClientConfig clientConfig = new ClientConfig().setBootstrapUrls(bootStrapUrls)\n                                                          .setClientZoneId(CLIENT_ZONE_ID);\n            AdminClient adminClient = new AdminClient(clientConfig);\n            for(Node node: cluster.getNodes()) {\n                VoldemortAdminTool.executeSetMetadata(node.getId(),"}
{"magic_number_smell": "                                                     originalNode,\n                                                     replacementBootstrapUrl,\n                                                     skipRestore,\n                                                     3);\n\n        finalServers.put(originalNode, replacementServer);\n        verifyReplaceNode(replacer, replacementServer);", "refactored_code": "    private static final int PARALELLISM = 3;\n                                                     originalNode,\n                                                     replacementBootstrapUrl,\n                                                     skipRestore,\n                                                     PARALELLISM);\n\n        finalServers.put(originalNode, replacementServer);\n        verifyReplaceNode(replacer, replacementServer);"}
{"magic_number_smell": "        // Set default quota in between 100 and 1100 at random\n        defaultQuota = 100 + new Random().nextInt(1000);\n\n        FAILED_NODE_ID = new Random().nextInt(4);\n        serverProps = new Properties();\n        serverProps.setProperty(VoldemortConfig.DEFAULT_STORAGE_SPACE_QUOTA_IN_KB, Long.toString(defaultQuota));\n    }", "refactored_code": "    private static final int NUM_SERVERS = 4;\n        // Set default quota in between 100 and 1100 at random\n        defaultQuota = 100 + new Random().nextInt(1000);\n\n        FAILED_NODE_ID = new Random().nextInt(NUM_SERVERS);\n        serverProps = new Properties();\n        serverProps.setProperty(VoldemortConfig.DEFAULT_STORAGE_SPACE_QUOTA_IN_KB, Long.toString(defaultQuota));\n    }"}
{"magic_number_smell": "            startThreeNodeRW();\n\n            // Start another node for only this unit test\n            HashMap<ByteArray, byte[]> entrySet = ServerTestUtils.createRandomKeyValuePairs(1000);\n\n            SocketStoreClientFactory factory = new SocketStoreClientFactory(new ClientConfig().setBootstrapUrls(Lists.newArrayList(\"tcp://\"\n                                                                                                                                   + currentCluster.getNodeById(0)", "refactored_code": "    private final int TEST_SIZE = 1000;\n            startThreeNodeRW();\n\n            // Start another node for only this unit test\n            HashMap<ByteArray, byte[]> entrySet = ServerTestUtils.createRandomKeyValuePairs(TEST_SIZE);\n\n            SocketStoreClientFactory factory = new SocketStoreClientFactory(new ClientConfig().setBootstrapUrls(Lists.newArrayList(\"tcp://\"\n                                                                                                                                   + currentCluster.getNodeById(0)"}
{"magic_number_smell": "\n    @Override\n    protected int getNumKeys() {\n        return 20;\n    }\n}\n", "refactored_code": "    private final int NUM_KEYS = 20;\n\n    @Override\n    protected int getNumKeys() {\n        return NUM_KEYS;\n    }\n}\n"}
{"magic_number_smell": "        bootStrapUrls[0] = socketUrl;\n\n        ClientConfig clientConfig = new ClientConfig();\n        clientConfig.setBootstrapUrls(bootStrapUrls).setClientZoneId(this.0);\n        SystemStoreClientFactory<String, String> systemStoreFactory = new SystemStoreClientFactory<String, String>(clientConfig);\n        sysVersionStore = systemStoreFactory.createSystemStore(SystemStoreConstants.SystemStoreName.voldsys$_metadata_version_persistence.name());\n", "refactored_code": "    protected final int CLIENT_ZONE_ID = 0;\n        bootStrapUrls[0] = socketUrl;\n\n        ClientConfig clientConfig = new ClientConfig();\n        clientConfig.setBootstrapUrls(bootStrapUrls).setClientZoneId(this.CLIENT_ZONE_ID);\n        SystemStoreClientFactory<String, String> systemStoreFactory = new SystemStoreClientFactory<String, String>(clientConfig);\n        sysVersionStore = systemStoreFactory.createSystemStore(SystemStoreConstants.SystemStoreName.voldsys$_metadata_version_persistence.name());\n"}
{"magic_number_smell": "\n    @Override\n    protected int getNumKeys() {\n        return 100;\n    }\n\n    @Before", "refactored_code": "    private final int NUM_KEYS = 100;\n\n    @Override\n    protected int getNumKeys() {\n        return NUM_KEYS;\n    }\n\n    @Before"}
{"magic_number_smell": "\n    @Override\n    protected int getNumKeys() {\n        return 100;\n    }\n}\n", "refactored_code": "    private final int NUM_KEYS = 100;\n\n    @Override\n    protected int getNumKeys() {\n        return NUM_KEYS;\n    }\n}\n"}
{"magic_number_smell": "        ClusterTestUtils.reset();\n\n        sourceCluster = ClusterTestUtils.getZZZCluster();\n        targetCluster = RebalanceUtils.vacateZone(sourceCluster, 0);\n        sourceStoreDefs = ClusterTestUtils.getZZZStoreDefsBDB();\n        targetStoreDefs = RebalanceUtils.dropZone(sourceStoreDefs, 0);\n", "refactored_code": "    private static final int DROP_ZONE_ID = 0;\n        ClusterTestUtils.reset();\n\n        sourceCluster = ClusterTestUtils.getZZZCluster();\n        targetCluster = RebalanceUtils.vacateZone(sourceCluster, DROP_ZONE_ID);\n        sourceStoreDefs = ClusterTestUtils.getZZZStoreDefsBDB();\n        targetStoreDefs = RebalanceUtils.dropZone(sourceStoreDefs, DROP_ZONE_ID);\n"}
{"magic_number_smell": "\n    @Before\n    public void setUp() throws Exception {\n        cluster = ServerTestUtils.getLocalCluster(3);\n        servers = new VoldemortServer[3];\n        props = new Properties();\n        metadataStore = ServerTestUtils.createMetadataStore(cluster,", "refactored_code": "    private static final int NUM_SERVERS = 3;\n\n    @Before\n    public void setUp() throws Exception {\n        cluster = ServerTestUtils.getLocalCluster(NUM_SERVERS);\n        servers = new VoldemortServer[NUM_SERVERS];\n        props = new Properties();\n        metadataStore = ServerTestUtils.createMetadataStore(cluster,"}
{"magic_number_smell": "        List<Node> nodes = Lists.newArrayList();\n        for(int i = 0; i < hostNames.size(); i++) {\n            int nodeId = (nodeIds == null) ? i : nodeIds.get(i);\n            nodes.add(new Node(nodeId, hostNames.get(i), 6666, 6666 + 1, 6666 + 2, Arrays.asList(i)));\n        }\n        return new Cluster(\"HostMatcherTest\", nodes);\n    }", "refactored_code": "    private static final int PORT = 6666; // No socket is created, so hard coded\n        List<Node> nodes = Lists.newArrayList();\n        for(int i = 0; i < hostNames.size(); i++) {\n            int nodeId = (nodeIds == null) ? i : nodeIds.get(i);\n            nodes.add(new Node(nodeId, hostNames.get(i), PORT, PORT + 1, PORT + 2, Arrays.asList(i)));\n        }\n        return new Cluster(\"HostMatcherTest\", nodes);\n    }"}
{"magic_number_smell": "    private SocketStoreFactory socketStoreFactory = new ClientRequestExecutorPool(2,\n                                                                                  10000,\n                                                                                  100000,\n                                                                                  4096);\n    private static String storesXmlfile = \"test/common/voldemort/config/stores.xml\";\n    private final boolean useNio;\n    private CountDownLatch countDownLatch;", "refactored_code": "    private static final int socketBufferSize = 4096;\n    private SocketStoreFactory socketStoreFactory = new ClientRequestExecutorPool(2,\n                                                                                  10000,\n                                                                                  100000,\n                                                                                  socketBufferSize);\n    private static String storesXmlfile = \"test/common/voldemort/config/stores.xml\";\n    private final boolean useNio;\n    private CountDownLatch countDownLatch;"}
{"magic_number_smell": "        this.pool = new ClientRequestExecutorPool(2,\n                                                  maxConnectionsPerNode,\n                                                  CONNECTION_TIMEOUT_MS,\n                                                  1000,\n                                                  IDLE_CONNECTION_TIMEOUT_MS,\n                                                  32 * 1024,\n                                                  false,", "refactored_code": "    private static final int SOCKET_TIMEOUT_MS = 1000;\n        this.pool = new ClientRequestExecutorPool(2,\n                                                  maxConnectionsPerNode,\n                                                  CONNECTION_TIMEOUT_MS,\n                                                  SOCKET_TIMEOUT_MS,\n                                                  IDLE_CONNECTION_TIMEOUT_MS,\n                                                  32 * 1024,\n                                                  false,"}
{"magic_number_smell": "\n        final Store<ByteArray, byte[], byte[]> socketStore = pool.create(STORE_NAME, \"localhost\", port, RequestFormatType.VOLDEMORT_V1, RequestRoutingType.NORMAL);\n        factory = ServerTestUtils.getSocketRequestHandlerFactory(repository);\n        socketService = ServerTestUtils.getSocketService(true, factory, port, numSelectors, 10, 1000, 600);\n        socketService.start();\n    }\n", "refactored_code": "    private final long MAX_HEART_BEAT_MS = 600;\n\n        final Store<ByteArray, byte[], byte[]> socketStore = pool.create(STORE_NAME, \"localhost\", port, RequestFormatType.VOLDEMORT_V1, RequestRoutingType.NORMAL);\n        factory = ServerTestUtils.getSocketRequestHandlerFactory(repository);\n        socketService = ServerTestUtils.getSocketService(true, factory, port, numSelectors, 10, 1000, MAX_HEART_BEAT_MS);\n        socketService.start();\n    }\n"}
{"magic_number_smell": "        long start = System.currentTimeMillis();\n\n        byte[] data = new byte[256];\n        while(((System.currentTimeMillis()) - start) <= 2000) {\n            dataGen.nextBytes(data);\n            ByteArray key = new ByteArray(data);\n            socketStore.put(key, new Versioned<byte[]>(data), null);", "refactored_code": "    private static final int MAX_TRAFFIC_TIME_MS = 2000;\n        long start = System.currentTimeMillis();\n\n        byte[] data = new byte[256];\n        while(((System.currentTimeMillis()) - start) <= MAX_TRAFFIC_TIME_MS) {\n            dataGen.nextBytes(data);\n            ByteArray key = new ByteArray(data);\n            socketStore.put(key, new Versioned<byte[]>(data), null);"}
{"magic_number_smell": "\n    public void testHighMemoryCollection() {\n        long maxMemory = Runtime.getRuntime().maxMemory();\n        int objectSize = Math.max((int) maxMemory / 1000, 1);\n        StorageEngine<ByteArray, byte[], byte[]> engine = getStorageEngine();\n        for(int i = 0; i < 1000; i++)\n            engine.put(TestUtils.toByteArray(Integer.toString(i)),", "refactored_code": "    private static final int NUM_OBJECTS = 1000;\n\n    public void testHighMemoryCollection() {\n        long maxMemory = Runtime.getRuntime().maxMemory();\n        int objectSize = Math.max((int) maxMemory / NUM_OBJECTS, 1);\n        StorageEngine<ByteArray, byte[], byte[]> engine = getStorageEngine();\n        for(int i = 0; i < NUM_OBJECTS; i++)\n            engine.put(TestUtils.toByteArray(Integer.toString(i)),"}
{"magic_number_smell": "\n        ChunkedFileSet fileSet = new ChunkedFileSet(fileDir, \n                                                    getTempStrategy(),\n                                                    0, \n                                                    VoldemortConfig.DEFAULT_RO_MAX_VALUE_BUFFER_ALLOCATION_SIZE);\n\n        for(int i = 0; i < 2; i ++) {", "refactored_code": "    private static final int NODE_ID = 0;\n\n        ChunkedFileSet fileSet = new ChunkedFileSet(fileDir, \n                                                    getTempStrategy(),\n                                                    NODE_ID, \n                                                    VoldemortConfig.DEFAULT_RO_MAX_VALUE_BUFFER_ALLOCATION_SIZE);\n\n        for(int i = 0; i < 2; i ++) {"}
{"magic_number_smell": "        }\n        setFailureDetector(subStores);\n\n        routedStoreThreadPool = Executors.newFixedThreadPool(3);\n        routedStoreFactory = new RoutedStoreFactory(routedStoreThreadPool);\n\n        Map<Integer, NonblockingStore> nonblockingSlopStores = Maps.newHashMap();", "refactored_code": "    private static final int NUM_THREADS = 3;\n        }\n        setFailureDetector(subStores);\n\n        routedStoreThreadPool = Executors.newFixedThreadPool(NUM_THREADS);\n        routedStoreFactory = new RoutedStoreFactory(routedStoreThreadPool);\n\n        Map<Integer, NonblockingStore> nonblockingSlopStores = Maps.newHashMap();"}
{"magic_number_smell": "                                         storeDef,\n                                         subStores,\n                                         failureDetector,\n                                         createConfig(1000));\n    }\n\n    public Store<ByteArray, byte[], byte[]> getZonedStore() throws Exception {", "refactored_code": "    public static final int BANNAGE_PERIOD = 1000;\n                                         storeDef,\n                                         subStores,\n                                         failureDetector,\n                                         createConfig(BANNAGE_PERIOD));\n    }\n\n    public Store<ByteArray, byte[], byte[]> getZonedStore() throws Exception {"}
{"magic_number_smell": "        when(inner.call()).thenReturn(CALL_RESULT);\n        mockTime = new MockTime();\n        cachedCallable = new CachedCallable<Long>(inner,\n                                                  1000,\n                                                  mockTime);\n    }\n", "refactored_code": "    private static final long CACHE_TTL_MS = 1000;\n        when(inner.call()).thenReturn(CALL_RESULT);\n        mockTime = new MockTime();\n        cachedCallable = new CachedCallable<Long>(inner,\n                                                  CACHE_TTL_MS,\n                                                  mockTime);\n    }\n"}
{"magic_number_smell": "    @Before\n    public void setUp() {\n        factory = new TestResourceFactory();\n        config = new ResourcePoolConfig().setMaxPoolSize(100)\n                                         .setTimeout(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n        this.pool = new KeyedResourcePool<String, TestResource>(factory, config);\n    }", "refactored_code": "    protected static final int POOL_SIZE = 100;\n    @Before\n    public void setUp() {\n        factory = new TestResourceFactory();\n        config = new ResourcePoolConfig().setMaxPoolSize(POOL_SIZE)\n                                         .setTimeout(TIMEOUT_MS, TimeUnit.MILLISECONDS);\n        this.pool = new KeyedResourcePool<String, TestResource>(factory, config);\n    }"}
{"magic_number_smell": "            return new CombinationItem(buf.replace(\"-\", \"\"));\n        } else if (isDigit) {\n            buf = stripLeadingZeroes(buf);\n            if (buf.length() <= 9) {\n                // lower than 2^31\n                return new IntItem(buf);\n            } else if (buf.length() <= MAX_LONGITEM_LENGTH) {", "refactored_code": "    private static final int MAX_INTITEM_LENGTH = 9;\n            return new CombinationItem(buf.replace(\"-\", \"\"));\n        } else if (isDigit) {\n            buf = stripLeadingZeroes(buf);\n            if (buf.length() <= MAX_INTITEM_LENGTH) {\n                // lower than 2^31\n                return new IntItem(buf);\n            } else if (buf.length() <= MAX_LONGITEM_LENGTH) {"}
{"magic_number_smell": "     */\n    public void setEventType(final int eventType) {\n        switch (eventType) {\n            case 0:\n                break;\n            case TRANSFER_STARTED:\n                break;", "refactored_code": "    public static final int TRANSFER_INITIATED = 0;\n     */\n    public void setEventType(final int eventType) {\n        switch (eventType) {\n            case TRANSFER_INITIATED:\n                break;\n            case TRANSFER_STARTED:\n                break;"}
{"magic_number_smell": "    }\n\n    private void checkVertices() {\n        checkVertices(32);\n    }\n\n    private void checkVertices(int nVertices) {", "refactored_code": "    public static final int DEFAULT_VERTICES = 32;\n    }\n\n    private void checkVertices() {\n        checkVertices(DEFAULT_VERTICES);\n    }\n\n    private void checkVertices(int nVertices) {"}
{"magic_number_smell": "    private static final Pattern S_FILTER = Pattern.compile(\"\\\\s+\");\n\n    public static String separatorLine() {\n        StringBuilder sb = new StringBuilder(65);\n        repeat(sb, '*', 65);\n        return sb.toString();\n    }", "refactored_code": "    private static final int DEFAULT_MAX_SIZE = 65;\n    private static final Pattern S_FILTER = Pattern.compile(\"\\\\s+\");\n\n    public static String separatorLine() {\n        StringBuilder sb = new StringBuilder(DEFAULT_MAX_SIZE);\n        repeat(sb, '*', DEFAULT_MAX_SIZE);\n        return sb.toString();\n    }"}
{"magic_number_smell": "    static String sha1(Path path) throws NoSuchAlgorithmException, IOException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        try (InputStream fis = Files.newInputStream(path)) {\n            byte[] buffer = new byte[8192];\n            int read;\n            while ((read = fis.read(buffer)) != -1) {\n                md.update(buffer, 0, read);", "refactored_code": "    private static final int SHA1_BUFFER_SIZE = 8192;\n    static String sha1(Path path) throws NoSuchAlgorithmException, IOException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        try (InputStream fis = Files.newInputStream(path)) {\n            byte[] buffer = new byte[SHA1_BUFFER_SIZE];\n            int read;\n            while ((read = fis.read(buffer)) != -1) {\n                md.update(buffer, 0, read);"}
{"magic_number_smell": "        }\n\n        private int getParallelism(ProjectBuildingRequest request) {\n            int parallelism = Runtime.getRuntime().availableProcessors() / 2 + 1;\n            try {\n                String str = request.getUserProperties().getProperty(BUILDER_PARALLELISM);\n                if (str == null) {", "refactored_code": "    public static final int DEFAULT_BUILDER_PARALLELISM = Runtime.getRuntime().availableProcessors() / 2 + 1;\n        }\n\n        private int getParallelism(ProjectBuildingRequest request) {\n            int parallelism = DEFAULT_BUILDER_PARALLELISM;\n            try {\n                String str = request.getUserProperties().getProperty(BUILDER_PARALLELISM);\n                if (str == null) {"}
{"magic_number_smell": "        this.terminalWidth = Math.min(\n                MAX_TERMINAL_WIDTH,\n                Math.max(terminalWidth < 0 ? DEFAULT_TERMINAL_WIDTH : terminalWidth, MIN_TERMINAL_WIDTH));\n        this.lineLength = this.terminalWidth - 8;\n        this.maxProjectNameLength = this.lineLength - PROJECT_STATUS_SUFFIX_SIZE;\n    }\n", "refactored_code": "    private static final int MAX_LOG_PREFIX_SIZE = 8; // \"[ERROR] \"\n        this.terminalWidth = Math.min(\n                MAX_TERMINAL_WIDTH,\n                Math.max(terminalWidth < 0 ? DEFAULT_TERMINAL_WIDTH : terminalWidth, MIN_TERMINAL_WIDTH));\n        this.lineLength = this.terminalWidth - MAX_LOG_PREFIX_SIZE;\n        this.maxProjectNameLength = this.lineLength - PROJECT_STATUS_SUFFIX_SIZE;\n    }\n"}
{"magic_number_smell": "     * Constructor that makes passed in delegate run on single thread, and will block on last event.\n     */\n    public SimplexTransferListener(TransferListener delegate) {\n        this(delegate, 1024, BATCH_MAX_SIZE, true);\n    }\n\n    /**", "refactored_code": "    private static final int QUEUE_SIZE = 1024;\n     * Constructor that makes passed in delegate run on single thread, and will block on last event.\n     */\n    public SimplexTransferListener(TransferListener delegate) {\n        this(delegate, QUEUE_SIZE, BATCH_MAX_SIZE, true);\n    }\n\n    /**"}
{"magic_number_smell": "                Method max = maximal.next();\n\n                switch (moreSpecific(appArgs, max.getParameterTypes())) {\n                    case 0:\n                        // This method is more specific than the previously\n                        // known maximally specific, so remove the old maximum.\n                        maximal.remove();", "refactored_code": "    private static final int MORE_SPECIFIC = 0;\n                Method max = maximal.next();\n\n                switch (moreSpecific(appArgs, max.getParameterTypes())) {\n                    case MORE_SPECIFIC:\n                        // This method is more specific than the previously\n                        // known maximally specific, so remove the old maximum.\n                        maximal.remove();"}
{"magic_number_smell": "    }\n\n    public PluginDescriptor build(ReaderSupplier readerSupplier, String source) throws PlexusConfigurationException {\n        try (BufferedReader br = new BufferedReader(readerSupplier.open(), 8192)) {\n            br.mark(8192);\n            XMLStreamReader xsr = WstxInputFactory.newFactory().createXMLStreamReader(br);\n            xsr.nextTag();", "refactored_code": "    private static final int BUFFER_SIZE = 8192;\n    }\n\n    public PluginDescriptor build(ReaderSupplier readerSupplier, String source) throws PlexusConfigurationException {\n        try (BufferedReader br = new BufferedReader(readerSupplier.open(), BUFFER_SIZE)) {\n            br.mark(BUFFER_SIZE);\n            XMLStreamReader xsr = WstxInputFactory.newFactory().createXMLStreamReader(br);\n            xsr.nextTag();"}
{"magic_number_smell": "    protected void assertSequence(String... versions) {\n        for (int i = 0; i < versions.length - 1; i++) {\n            for (int j = i + 1; j < versions.length; j++) {\n                assertOrder(-1, versions[i], versions[j]);\n            }\n        }\n    }", "refactored_code": "    protected static final int X_LT_Y = -1;\n    protected void assertSequence(String... versions) {\n        for (int i = 0; i < versions.length - 1; i++) {\n            for (int j = i + 1; j < versions.length; j++) {\n                assertOrder(X_LT_Y, versions[i], versions[j]);\n            }\n        }\n    }"}
{"magic_number_smell": "  @Override\n  public void readFields(DataInput in) throws IOException {\n    byte version = in.readByte(); // read version\n    if (version > 7) // check version\n      throw new VersionMismatchException(7, version);\n\n    status = in.readByte();", "refactored_code": "  private static final byte CUR_VERSION = 7;\n  @Override\n  public void readFields(DataInput in) throws IOException {\n    byte version = in.readByte(); // read version\n    if (version > CUR_VERSION) // check version\n      throw new VersionMismatchException(CUR_VERSION, version);\n\n    status = in.readByte();"}
{"magic_number_smell": "   *          {@link #STATUS_NOTMODIFIED} then the content is known to be\n   *          unchanged. This information may be obtained by comparing page\n   *          signatures before and after fetching. If this is set to\n   *          {@link #0}, then it is unknown whether the page was\n   *          changed; implementations are free to follow a sensible default\n   *          behavior.\n   * ", "refactored_code": "  public static final int STATUS_UNKNOWN = 0;\n   *          {@link #STATUS_NOTMODIFIED} then the content is known to be\n   *          unchanged. This information may be obtained by comparing page\n   *          signatures before and after fetching. If this is set to\n   *          {@link #STATUS_UNKNOWN}, then it is unknown whether the page was\n   *          changed; implementations are free to follow a sensible default\n   *          behavior.\n   * "}
{"magic_number_smell": "        writers.delete(document.toString());\n        totalDeleted++;\n        context.getCounter(\"CleaningJobStatus\", \"Deleted documents\").increment(1);\n        // if (numDeletes >= 1000) {\n        // LOG.info(\"CleaningJob: deleting \" + numDeletes\n        // + \" documents\");\n        // // TODO updateRequest.process(solr);", "refactored_code": "    private static final int NUM_MAX_DELETE_REQUEST = 1000;\n        writers.delete(document.toString());\n        totalDeleted++;\n        context.getCounter(\"CleaningJobStatus\", \"Deleted documents\").increment(1);\n        // if (numDeletes >= NUM_MAX_DELETE_REQUEST) {\n        // LOG.info(\"CleaningJob: deleting \" + numDeletes\n        // + \" documents\");\n        // // TODO updateRequest.process(solr);"}
{"magic_number_smell": "  public void readFields(DataInput in) throws IOException {\n    fields.clear();\n    byte version = in.readByte();\n    if (version != 2) {\n      throw new VersionMismatchException(2, version);\n    }\n    int size = WritableUtils.readVInt(in);", "refactored_code": "  public static final byte VERSION = 2;\n  public void readFields(DataInput in) throws IOException {\n    fields.clear();\n    byte version = in.readByte();\n    if (version != VERSION) {\n      throw new VersionMismatchException(VERSION, version);\n    }\n    int size = WritableUtils.readVInt(in);"}
{"magic_number_smell": "  public static final byte UPDATE = 2;\n\n  public NutchDocument doc = null;\n  public byte action = 0;\n\n  protected NutchIndexAction() {\n  }", "refactored_code": "  public static final byte ADD = 0;\n  public static final byte UPDATE = 2;\n\n  public NutchDocument doc = null;\n  public byte action = ADD;\n\n  protected NutchIndexAction() {\n  }"}
{"magic_number_smell": "    String value = NAMES_IDX.get(searched);\n\n    if ((value == null) && (normalized != null)) {\n      int threshold = Math.min(3, searched.length() / 3);\n      for (int i = 0; i < normalized.length && value == null; i++) {\n        if (StringUtils.getLevenshteinDistance(searched, normalized[i]) < threshold) {\n          value = NAMES_IDX.get(normalized[i]);", "refactored_code": "  private static final int TRESHOLD_DIVIDER = 3;\n    String value = NAMES_IDX.get(searched);\n\n    if ((value == null) && (normalized != null)) {\n      int threshold = Math.min(3, searched.length() / TRESHOLD_DIVIDER);\n      for (int i = 0; i < normalized.length && value == null; i++) {\n        if (StringUtils.getLevenshteinDistance(searched, normalized[i]) < threshold) {\n          value = NAMES_IDX.get(normalized[i]);"}
{"magic_number_smell": "  private Metadata contentMeta;\n  private Metadata parseMeta;\n  private ParseStatus status;\n  private byte version = 5;\n\n  public ParseData() {\n    contentMeta = new Metadata();", "refactored_code": "  private static final byte VERSION = 5;\n  private Metadata contentMeta;\n  private Metadata parseMeta;\n  private ParseStatus status;\n  private byte version = VERSION;\n\n  public ParseData() {\n    contentMeta = new Metadata();"}
{"magic_number_smell": "   */\n  public static final short FAILED_MISSING_CONTENT = 205;\n\n  public static final ParseStatus STATUS_NOTPARSED = new ParseStatus(0);\n  public static final ParseStatus STATUS_SUCCESS = new ParseStatus(SUCCESS);\n  public static final ParseStatus STATUS_FAILURE = new ParseStatus(FAILED);\n", "refactored_code": "  public static final byte NOTPARSED = 0;\n   */\n  public static final short FAILED_MISSING_CONTENT = 205;\n\n  public static final ParseStatus STATUS_NOTPARSED = new ParseStatus(NOTPARSED);\n  public static final ParseStatus STATUS_SUCCESS = new ParseStatus(SUCCESS);\n  public static final ParseStatus STATUS_FAILURE = new ParseStatus(FAILED);\n"}
{"magic_number_smell": "    case 1:\n      text = WritableUtils.readCompressedString(in);\n      break;\n    case 2:\n      text = Text.readString(in);\n      break;\n    default:", "refactored_code": "  private static final byte VERSION = 2;\n    case 1:\n      text = WritableUtils.readCompressedString(in);\n      break;\n    case VERSION:\n      text = Text.readString(in);\n      break;\n    default:"}
{"magic_number_smell": "  // Useful static instances for status codes that don't usually require any\n  // additional arguments.\n  public static final ProtocolStatus STATUS_SUCCESS = new ProtocolStatus(\n      1);\n  public static final ProtocolStatus STATUS_FAILED = new ProtocolStatus(FAILED);\n  public static final ProtocolStatus STATUS_GONE = new ProtocolStatus(GONE);\n  public static final ProtocolStatus STATUS_NOTFOUND = new ProtocolStatus(", "refactored_code": "  public static final int SUCCESS = 1;\n  // Useful static instances for status codes that don't usually require any\n  // additional arguments.\n  public static final ProtocolStatus STATUS_SUCCESS = new ProtocolStatus(\n      SUCCESS);\n  public static final ProtocolStatus STATUS_FAILED = new ProtocolStatus(FAILED);\n  public static final ProtocolStatus STATUS_GONE = new ProtocolStatus(GONE);\n  public static final ProtocolStatus STATUS_NOTFOUND = new ProtocolStatus("}
{"magic_number_smell": "    }\n    int mode = -1;\n    if (args[0].equals(\"-dump\"))\n      mode = 0;\n    else if (args[0].equals(\"-list\"))\n      mode = MODE_LIST;\n    else if (args[0].equals(\"-get\"))", "refactored_code": "  private static final int MODE_DUMP = 0;\n    }\n    int mode = -1;\n    if (args[0].equals(\"-dump\"))\n      mode = MODE_DUMP;\n    else if (args[0].equals(\"-list\"))\n      mode = MODE_LIST;\n    else if (args[0].equals(\"-get\"))"}
{"magic_number_smell": "  private NutchServer() {\n    configManager = new ConfManagerImpl();\n    seedManager = new SeedManagerImpl();\n    BlockingQueue<Runnable> runnables = Queues.newArrayBlockingQueue(100);\n    NutchServerPoolExecutor executor = new NutchServerPoolExecutor(10, 100, 1, TimeUnit.HOURS, runnables);\n    jobManager = new JobManagerImpl(new JobFactory(), configManager, executor);\n    fetchNodeDb = FetchNodeDb.getInstance();", "refactored_code": "  private static final int JOB_CAPACITY = 100;\n  private NutchServer() {\n    configManager = new ConfManagerImpl();\n    seedManager = new SeedManagerImpl();\n    BlockingQueue<Runnable> runnables = Queues.newArrayBlockingQueue(JOB_CAPACITY);\n    NutchServerPoolExecutor executor = new NutchServerPoolExecutor(10, JOB_CAPACITY, 1, TimeUnit.HOURS, runnables);\n    jobManager = new JobManagerImpl(new JobFactory(), configManager, executor);\n    fetchNodeDb = FetchNodeDb.getInstance();"}
{"magic_number_smell": "  }\n\n  private void scheduleServerStop() {\n    LOG.info(\"Shutting down server in {} sec\", 1);\n    Thread thread = new Thread() {\n      @Override\n      public void run() {", "refactored_code": "  private final int DELAY_SEC = 1;\n  }\n\n  private void scheduleServerStop() {\n    LOG.info(\"Shutting down server in {} sec\", DELAY_SEC);\n    Thread thread = new Thread() {\n      @Override\n      public void run() {"}
{"magic_number_smell": "              if (inlinks != null) {\n                Iterator<Inlink> iterator = inlinks.iterator();\n                inUrls = new LinkedHashSet<>();\n                while (inUrls.size() <= 5000 && iterator.hasNext()){\n                  inUrls.add(iterator.next().getFromUrl());\n                }\n              }", "refactored_code": "  private static final int MAX_INLINKS = 5000;\n              if (inlinks != null) {\n                Iterator<Inlink> iterator = inlinks.iterator();\n                inUrls = new LinkedHashSet<>();\n                while (inUrls.size() <= MAX_INLINKS && iterator.hasNext()){\n                  inUrls.add(iterator.next().getFromUrl());\n                }\n              }"}
{"magic_number_smell": "    @Override\n    public void run() {\n      try {\n        byte[] buf = new byte[4096];\n        int read = 0;\n        while (!isInterrupted() && (read = _is.read(buf)) != -1) {\n          if (read == 0)", "refactored_code": "  private static final int BUF = 4096;\n    @Override\n    public void run() {\n      try {\n        byte[] buf = new byte[BUF];\n        int read = 0;\n        while (!isInterrupted() && (read = _is.read(buf)) != -1) {\n          if (read == 0)"}
{"magic_number_smell": "    String jobName = \"Nutch CrawlCompletionStats: \";\n    if (cli.getOptionValue(\"mode\").equals(\"host\")) {\n      jobName = jobName + \"Host statistics\";\n      mode = 1;\n    } else if (cli.getOptionValue(\"mode\").equals(\"domain\")) {\n      jobName = jobName + \"Domain statistics\";\n      mode = MODE_DOMAIN;", "refactored_code": "  private static final int MODE_HOST = 1;\n    String jobName = \"Nutch CrawlCompletionStats: \";\n    if (cli.getOptionValue(\"mode\").equals(\"host\")) {\n      jobName = jobName + \"Host statistics\";\n      mode = MODE_HOST;\n    } else if (cli.getOptionValue(\"mode\").equals(\"domain\")) {\n      jobName = jobName + \"Domain statistics\";\n      mode = MODE_DOMAIN;"}
{"magic_number_smell": "  public static final byte[] inflateBestEffort(byte[] in, int sizeLimit) {\n    // decompress using InflaterInputStream\n    ByteArrayOutputStream outStream = new ByteArrayOutputStream(\n        5 * in.length);\n\n    // \"true\" because HTTP does not provide zlib headers\n    Inflater inflater = new Inflater(true);", "refactored_code": "  private static final int EXPECTED_COMPRESSION_RATIO = 5;\n  public static final byte[] inflateBestEffort(byte[] in, int sizeLimit) {\n    // decompress using InflaterInputStream\n    ByteArrayOutputStream outStream = new ByteArrayOutputStream(\n        EXPECTED_COMPRESSION_RATIO * in.length);\n\n    // \"true\" because HTTP does not provide zlib headers\n    Inflater inflater = new Inflater(true);"}
{"magic_number_smell": "  }\n\n  public void addClue(String value, String source) {\n    addClue(value, source, -1);\n  }\n\n  /**", "refactored_code": "  public static final int NO_THRESHOLD = -1;\n  }\n\n  public void addClue(String value, String source) {\n    addClue(value, source, NO_THRESHOLD);\n  }\n\n  /**"}
{"magic_number_smell": "    try {\n      // decompress using GZIPInputStream\n      ByteArrayOutputStream outStream = new ByteArrayOutputStream(\n          5 * in.length);\n\n      GZIPInputStream inStream = new GZIPInputStream(new ByteArrayInputStream(\n          in));", "refactored_code": "  private static final int EXPECTED_COMPRESSION_RATIO = 5;\n    try {\n      // decompress using GZIPInputStream\n      ByteArrayOutputStream outStream = new ByteArrayOutputStream(\n          EXPECTED_COMPRESSION_RATIO * in.length);\n\n      GZIPInputStream inStream = new GZIPInputStream(new ByteArrayInputStream(\n          in));"}
{"magic_number_smell": "    String jobName = \"Nutch DomainStatistics: \";\n    if (args[2].equals(\"host\")) {\n      jobName = jobName + \"Host statistics\";\n      mode = 1;\n    } else if (args[2].equals(\"domain\")) {\n      jobName = jobName + \"Domain statistics\";\n      mode = MODE_DOMAIN;", "refactored_code": "  private static final int MODE_HOST = 1;\n    String jobName = \"Nutch DomainStatistics: \";\n    if (args[2].equals(\"host\")) {\n      jobName = jobName + \"Host statistics\";\n      mode = MODE_HOST;\n    } else if (args[2].equals(\"domain\")) {\n      jobName = jobName + \"Domain statistics\";\n      mode = MODE_DOMAIN;"}
{"magic_number_smell": "  }\n\n  public DomainSuffix(String domain) {\n    this(domain, DEFAULT_STATUS, 1.0f);\n  }\n\n  public String getDomain() {", "refactored_code": "  public static final float DEFAULT_BOOST = 1.0f;\n  }\n\n  public DomainSuffix(String domain) {\n    this(domain, DEFAULT_STATUS, DEFAULT_BOOST);\n  }\n\n  public String getDomain() {"}
{"magic_number_smell": "\n    maxDocsInBatch = parameters.getInt(CloudSearchConstants.MAX_DOCS_BATCH, -1);\n\n    buffer = new StringBuffer(5242880).append('[');\n\n    if (dumpBatchFilesToTemp) {\n      // only dumping to local file", "refactored_code": "  private static final int MAX_SIZE_BATCH_BYTES = 5242880;\n\n    maxDocsInBatch = parameters.getInt(CloudSearchConstants.MAX_DOCS_BATCH, -1);\n\n    buffer = new StringBuffer(MAX_SIZE_BATCH_BYTES).append('[');\n\n    if (dumpBatchFilesToTemp) {\n      // only dumping to local file"}
{"magic_number_smell": "  protected RestHighLevelClient makeClient(IndexWriterParams parameters)\n      throws IOException {\n    hosts = parameters.getStrings(ElasticConstants.HOSTS);\n    port = parameters.getInt(ElasticConstants.PORT, 9300);\n    scheme = parameters.get(ElasticConstants.SCHEME, HttpHost.DEFAULT_SCHEME_NAME);\n    auth = parameters.getBoolean(ElasticConstants.USE_AUTH, false);\n    user = parameters.get(ElasticConstants.USER, DEFAULT_USER);", "refactored_code": "  private static final int DEFAULT_PORT = 9300;\n  protected RestHighLevelClient makeClient(IndexWriterParams parameters)\n      throws IOException {\n    hosts = parameters.getStrings(ElasticConstants.HOSTS);\n    port = parameters.getInt(ElasticConstants.PORT, DEFAULT_PORT);\n    scheme = parameters.get(ElasticConstants.SCHEME, HttpHost.DEFAULT_SCHEME_NAME);\n    auth = parameters.getBoolean(ElasticConstants.USE_AUTH, false);\n    user = parameters.get(ElasticConstants.USER, DEFAULT_USER);"}
{"magic_number_smell": "  protected RestHighLevelClient makeClient(IndexWriterParams parameters)\n      throws IOException {\n    hosts = parameters.getStrings(OpenSearch1xConstants.HOSTS);\n    port = parameters.getInt(OpenSearch1xConstants.PORT, 9300);\n    scheme = parameters.get(OpenSearch1xConstants.SCHEME,\n        HttpHost.DEFAULT_SCHEME_NAME);\n    user = parameters.get(OpenSearch1xConstants.USER, DEFAULT_USER);", "refactored_code": "  private static final int DEFAULT_PORT = 9300;\n  protected RestHighLevelClient makeClient(IndexWriterParams parameters)\n      throws IOException {\n    hosts = parameters.getStrings(OpenSearch1xConstants.HOSTS);\n    port = parameters.getInt(OpenSearch1xConstants.PORT, DEFAULT_PORT);\n    scheme = parameters.get(OpenSearch1xConstants.SCHEME,\n        HttpHost.DEFAULT_SCHEME_NAME);\n    user = parameters.get(OpenSearch1xConstants.USER, DEFAULT_USER);"}
{"magic_number_smell": "  /**\n   * Given a <code>byte[]</code> representing an html file of an\n   * <em>unknown</em> encoding, read out 'charset' parameter in the meta tag\n   * from the first <code>8192</code> bytes. If there's no meta tag for\n   * Content-Type or no charset is specified, the content is checked for a\n   * Unicode Byte Order Mark (BOM). This will also cover non-byte oriented\n   * character encodings (UTF-16 only). If no character set can be determined,", "refactored_code": "  private static final int CHUNK_SIZE = 8192;\n  /**\n   * Given a <code>byte[]</code> representing an html file of an\n   * <em>unknown</em> encoding, read out 'charset' parameter in the meta tag\n   * from the first <code>CHUNK_SIZE</code> bytes. If there's no meta tag for\n   * Content-Type or no charset is specified, the content is checked for a\n   * Unicode Byte Order Mark (BOM). This will also cover non-byte oriented\n   * character encodings (UTF-16 only). If no character set can be determined,"}
{"magic_number_smell": "    String title;\n    int idx = script.indexOf('\\n');\n    if (idx != -1) {\n      if (idx > 80)\n        idx = 80;\n      title = script.substring(0, idx);\n    } else {", "refactored_code": "  private static final int MAX_TITLE_LEN = 80;\n    String title;\n    int idx = script.indexOf('\\n');\n    if (idx != -1) {\n      if (idx > MAX_TITLE_LEN)\n        idx = MAX_TITLE_LEN;\n      title = script.substring(0, idx);\n    } else {"}
{"magic_number_smell": "  }\n\n  public int getBufferSize() {\n    return 16384;\n  }\n\n}", "refactored_code": "  private static final int BUFFER_SIZE = 16384; // 16*1024 = 16384\n  }\n\n  public int getBufferSize() {\n    return BUFFER_SIZE;\n  }\n\n}"}
{"magic_number_smell": "    super.setConf(conf);\n    if (conf == null)\n      return;\n    defaultMaxDepth = conf.getInt(\"scoring.depth.max\", 1000);\n    if (defaultMaxDepth <= 0) {\n      defaultMaxDepth = 1000;\n    }", "refactored_code": "  public static final int DEFAULT_MAX_DEPTH = 1000;\n    super.setConf(conf);\n    if (conf == null)\n      return;\n    defaultMaxDepth = conf.getInt(\"scoring.depth.max\", DEFAULT_MAX_DEPTH);\n    if (defaultMaxDepth <= 0) {\n      defaultMaxDepth = DEFAULT_MAX_DEPTH;\n    }"}
{"magic_number_smell": "      return false;\n    }\n\n    if (!isValidScheme(matchUrlPat.group(2))) {\n      return false;\n    }\n", "refactored_code": "  private static final int PARSE_URL_SCHEME = 2;\n      return false;\n    }\n\n    if (!isValidScheme(matchUrlPat.group(PARSE_URL_SCHEME))) {\n      return false;\n    }\n"}
{"magic_number_smell": "    @SuppressWarnings(\"unused\")\n    SpellCheckedMetadata result;\n    long start = System.currentTimeMillis();\n    for (int i = 0; i < 10000; i++) {\n      SpellCheckedMetadata scmd = constructSpellCheckedMetadata();\n      result = writeRead(scmd);\n    }", "refactored_code": "  private static final int NUM_ITERATIONS = 10000;\n    @SuppressWarnings(\"unused\")\n    SpellCheckedMetadata result;\n    long start = System.currentTimeMillis();\n    for (int i = 0; i < NUM_ITERATIONS; i++) {\n      SpellCheckedMetadata scmd = constructSpellCheckedMetadata();\n      result = writeRead(scmd);\n    }"}
{"magic_number_smell": "     * @return {@code true} if the array contains the object\n     */\n    public static boolean contains(final boolean[] array, final boolean valueToFind) {\n        return indexOf(array, valueToFind) != -1;\n    }\n\n    /**", "refactored_code": "    public static final int INDEX_NOT_FOUND = -1;\n     * @return {@code true} if the array contains the object\n     */\n    public static boolean contains(final boolean[] array, final boolean valueToFind) {\n        return indexOf(array, valueToFind) != INDEX_NOT_FOUND;\n    }\n\n    /**"}
{"magic_number_smell": "                    return i;\n                }\n            }\n            return -1;\n        }\n        //supplementary characters (LANG1300)\n        if (searchChar <= Character.MAX_CODE_POINT) {", "refactored_code": "    private static final int NOT_FOUND = -1;\n                    return i;\n                }\n            }\n            return NOT_FOUND;\n        }\n        //supplementary characters (LANG1300)\n        if (searchChar <= Character.MAX_CODE_POINT) {"}
{"magic_number_smell": "        if (valid.length == 0) {\n            return false;\n        }\n        return indexOfAnyBut(cs, valid) == -1;\n    }\n\n    /**", "refactored_code": "    public static final int INDEX_NOT_FOUND = -1;\n        if (valid.length == 0) {\n            return false;\n        }\n        return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND;\n    }\n\n    /**"}
{"magic_number_smell": "     * @see HashCodeExclude\n     */\n    public static int reflectionHashCode(final Object object, final boolean testTransients) {\n        return reflectionHashCode(17, DEFAULT_MULTIPLIER_VALUE, object,\n                testTransients, null);\n    }\n", "refactored_code": "    private static final int DEFAULT_INITIAL_VALUE = 17;\n     * @see HashCodeExclude\n     */\n    public static int reflectionHashCode(final Object object, final boolean testTransients) {\n        return reflectionHashCode(DEFAULT_INITIAL_VALUE, DEFAULT_MULTIPLIER_VALUE, object,\n                testTransients, null);\n    }\n"}
{"magic_number_smell": "     */\n    private static final class JsonToStringStyle extends ToStringStyle {\n\n        private static final long 1L = 1L;\n\n        private static final String FIELD_NAME_QUOTE = \"\\\"\";\n", "refactored_code": "        private static final long serialVersionUID = 1L;\n     */\n    private static final class JsonToStringStyle extends ToStringStyle {\n\n        private static final long serialVersionUID = 1L;\n\n        private static final String FIELD_NAME_QUOTE = \"\\\"\";\n"}
{"magic_number_smell": "     * @param threshold the threshold.\n     */\n    public ThresholdCircuitBreaker(final long threshold) {\n        this.used = new AtomicLong(0L);\n        this.threshold = threshold;\n    }\n", "refactored_code": "    private static final long INITIAL_COUNT = 0L;\n     * @param threshold the threshold.\n     */\n    public ThresholdCircuitBreaker(final long threshold) {\n        this.used = new AtomicLong(INITIAL_COUNT);\n        this.threshold = threshold;\n    }\n"}
{"magic_number_smell": "     * @return a flag whether a permit could be acquired\n     */\n    private boolean acquirePermit() {\n        if (getLimit() <= 0 || acquireCount < getLimit()) {\n            acquireCount++;\n            return true;\n        }", "refactored_code": "    public static final int NO_LIMIT = 0;\n     * @return a flag whether a permit could be acquired\n     */\n    private boolean acquirePermit() {\n        if (getLimit() <= NO_LIMIT || acquireCount < getLimit()) {\n            acquireCount++;\n            return true;\n        }"}
{"magic_number_smell": "            final String token = frames.nextToken();\n            // Determine if the line starts with <whitespace>at\n            final int at = token.indexOf(\"at\");\n            if (at != -1 && token.substring(0, at).trim().isEmpty()) {\n                traceStarted = true;\n                list.add(token);\n            } else if (traceStarted) {", "refactored_code": "    private static final int NOT_FOUND = -1;\n            final String token = frames.nextToken();\n            // Determine if the line starts with <whitespace>at\n            final int at = token.indexOf(\"at\");\n            if (at != NOT_FOUND && token.substring(0, at).trim().isEmpty()) {\n                traceStarted = true;\n                list.add(token);\n            } else if (traceStarted) {"}
{"magic_number_smell": "     * @return {@code true} unless {@code package}/{@code protected}/{@code private} modifier detected\n     */\n    static boolean isPackageAccess(final int modifiers) {\n        return (modifiers & Modifier.PUBLIC | Modifier.PROTECTED | Modifier.PRIVATE) == 0;\n    }\n\n    /**", "refactored_code": "    private static final int ACCESS_TEST = Modifier.PUBLIC | Modifier.PROTECTED | Modifier.PRIVATE;\n     * @return {@code true} unless {@code package}/{@code protected}/{@code private} modifier detected\n     */\n    static boolean isPackageAccess(final int modifiers) {\n        return (modifiers & ACCESS_TEST) == 0;\n    }\n\n    /**"}
{"magic_number_smell": "     * Number of milliseconds in a standard minute.\n     * @since 2.1\n     */\n    public static final long MILLIS_PER_MINUTE = 60 * 1000;\n\n    /**\n     * Number of milliseconds in a standard hour.", "refactored_code": "    public static final long MILLIS_PER_SECOND = 1000;\n     * Number of milliseconds in a standard minute.\n     * @since 2.1\n     */\n    public static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND;\n\n    /**\n     * Number of milliseconds in a standard hour."}
{"magic_number_smell": "            // TODO Use of getZoneStrings() is discouraged per its Javadoc.\n            final String[][] zones = DateFormatSymbols.getInstance(locale).getZoneStrings();\n            for (final String[] zoneNames : zones) {\n                // offset 0 is the time zone 0 and is not localized\n                final String tzId = zoneNames[0];\n                if (tzId.equalsIgnoreCase(TimeZones.GMT_ID)) {\n                    continue;", "refactored_code": "        private static final int ID = 0;\n            // TODO Use of getZoneStrings() is discouraged per its Javadoc.\n            final String[][] zones = DateFormatSymbols.getInstance(locale).getZoneStrings();\n            for (final String[] zoneNames : zones) {\n                // offset 0 is the time zone ID and is not localized\n                final String tzId = zoneNames[ID];\n                if (tzId.equalsIgnoreCase(TimeZones.GMT_ID)) {\n                    continue;"}
{"magic_number_smell": "        if (minutes >= MINUTES_PER_HOUR) {\n            throw new IllegalArgumentException(minutes + \" minutes out of range\");\n        }\n        final int milliseconds = (minutes + hours * MINUTES_PER_HOUR) * 60 * 1000;\n        offset = negate ? -milliseconds : milliseconds;\n        // @formatter:off\n        zoneId = twoDigits(twoDigits(new StringBuilder(9)", "refactored_code": "    private static final int MILLISECONDS_PER_MINUTE = 60 * 1000;\n        if (minutes >= MINUTES_PER_HOUR) {\n            throw new IllegalArgumentException(minutes + \" minutes out of range\");\n        }\n        final int milliseconds = (minutes + hours * MINUTES_PER_HOUR) * MILLISECONDS_PER_MINUTE;\n        offset = negate ? -milliseconds : milliseconds;\n        // @formatter:off\n        zoneId = twoDigits(twoDigits(new StringBuilder(9)"}
{"magic_number_smell": "     * @return milliseconds conversion result.\n     */\n    private long nanosToMillis(final long nanos) {\n        return nanos / 1000000L;\n    }\n\n    /**", "refactored_code": "    private static final long NANO_2_MILLIS = 1000000L;\n     * @return milliseconds conversion result.\n     */\n    private long nanosToMillis(final long nanos) {\n        return nanos / NANO_2_MILLIS;\n    }\n\n    /**"}
{"magic_number_smell": "        final String[] array1 = {\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\"};\n        final String[] array2 = ArrayUtils.clone(array1);\n\n        ArrayUtils.shuffle(array1, new Random(16111981L));\n        assertFalse(Arrays.equals(array1, array2));\n        for (final String element : array2) {\n            assertTrue(ArrayUtils.contains(array1, element), \"Element \" + element + \" not found\");", "refactored_code": "    private static final long SEED = 16111981L;\n        final String[] array1 = {\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\"};\n        final String[] array2 = ArrayUtils.clone(array1);\n\n        ArrayUtils.shuffle(array1, new Random(SEED));\n        assertFalse(Arrays.equals(array1, array2));\n        for (final String element : array2) {\n            assertTrue(ArrayUtils.contains(array1, element), \"Element \" + element + \" not found\");"}
{"magic_number_smell": "        long startMillis;\n        startMillis = System.currentTimeMillis();\n        this.printlnTotal(\"Do nothing\", startMillis);\n        run_CharUtils_isAsciiNumeric(100);\n        startMillis = System.currentTimeMillis();\n        run_CharUtils_isAsciiNumeric(COUNT);\n        this.printlnTotal(\"run_CharUtils_isAsciiNumeric\", startMillis);", "refactored_code": "    private static final int WARM_UP = 100;\n        long startMillis;\n        startMillis = System.currentTimeMillis();\n        this.printlnTotal(\"Do nothing\", startMillis);\n        run_CharUtils_isAsciiNumeric(WARM_UP);\n        startMillis = System.currentTimeMillis();\n        run_CharUtils_isAsciiNumeric(COUNT);\n        this.printlnTotal(\"run_CharUtils_isAsciiNumeric\", startMillis);"}
{"magic_number_smell": "    public int[] testBitSet() {\n        final BitSet toRemove = new BitSet();\n        int found = 0;\n        for (int i = 0; i < 10; i++) {\n            toRemove.set(found++);\n        }\n        return extractIndices(toRemove);", "refactored_code": "    private static final int numberOfElementsToCompute = 10;\n    public int[] testBitSet() {\n        final BitSet toRemove = new BitSet();\n        int found = 0;\n        for (int i = 0; i < numberOfElementsToCompute; i++) {\n            toRemove.set(found++);\n        }\n        return extractIndices(toRemove);"}
{"magic_number_smell": "     * String that is not cloneable.\n     */\n    static final class UncloneableString extends MutableObject<String> implements Cloneable {\n        private static final long 1L = 1L;\n        UncloneableString(final String s) {\n            super(s);\n        }", "refactored_code": "        private static final long serialVersionUID = 1L;\n     * String that is not cloneable.\n     */\n    static final class UncloneableString extends MutableObject<String> implements Cloneable {\n        private static final long serialVersionUID = 1L;\n        UncloneableString(final String s) {\n            super(s);\n        }"}
{"magic_number_smell": "    public void testRandomAlphabetic() {\n        final char[] testChars = {'a', 'z', 'A', 'Z'};\n        final boolean[] found = {false, false, false, false};\n        for (int i = 0; i < 1_000; i++) {\n            final String randString = RandomStringUtils.randomAlphabetic(10);\n            for (int j = 0; j < testChars.length; j++) {\n                if (randString.indexOf(testChars[j]) > 0) {", "refactored_code": "    private static final int LOOP_COUNT = 1_000;\n    public void testRandomAlphabetic() {\n        final char[] testChars = {'a', 'z', 'A', 'Z'};\n        final boolean[] found = {false, false, false, false};\n        for (int i = 0; i < LOOP_COUNT; i++) {\n            final String randString = RandomStringUtils.randomAlphabetic(10);\n            for (int j = 0; j < testChars.length; j++) {\n                if (randString.indexOf(testChars[j]) > 0) {"}
{"magic_number_smell": "     */\n    @Test\n    public void testNextDoubleMinimalRange() {\n        assertEquals(42.1, RandomUtils.nextDouble(42.1, 42.1), 1e-5);\n    }\n\n    @Test", "refactored_code": "    private static final double DELTA = 1e-5;\n     */\n    @Test\n    public void testNextDoubleMinimalRange() {\n        assertEquals(42.1, RandomUtils.nextDouble(42.1, 42.1), DELTA);\n    }\n\n    @Test"}
{"magic_number_smell": "\n                @Test\n                void shouldNotThrowExceptionWhenValueIsBetweenBounds() {\n                    Validate.exclusiveBetween(0.1, UPPER_BOUND, 2, \"MSG\");\n                }\n\n                @Test", "refactored_code": "            private static final double LOWER_BOUND = 0.1;\n\n                @Test\n                void shouldNotThrowExceptionWhenValueIsBetweenBounds() {\n                    Validate.exclusiveBetween(LOWER_BOUND, UPPER_BOUND, 2, \"MSG\");\n                }\n\n                @Test"}
{"magic_number_smell": "    private void testConcurrency(final CollectionHolder<List<Integer>> holder) throws InterruptedException {\n        final List<Integer> list = holder.collection;\n        // make a big array that takes a long time to toString()\n        for (int i = 0; i < 100000; i++) {\n            list.add(Integer.valueOf(i));\n        }\n        // Create a thread pool with two threads to cause the most contention on the underlying resource.", "refactored_code": "    private static final int DATA_SIZE = 100000;\n    private void testConcurrency(final CollectionHolder<List<Integer>> holder) throws InterruptedException {\n        final List<Integer> list = holder.collection;\n        // make a big array that takes a long time to toString()\n        for (int i = 0; i < DATA_SIZE; i++) {\n            list.add(Integer.valueOf(i));\n        }\n        // Create a thread pool with two threads to cause the most contention on the underlying resource."}
{"magic_number_smell": "\n        TestFixture() {\n            synchronized (this) {\n                for (int i = 0; i < 100; i++) {\n                    listField.add(Integer.valueOf(i));\n                }\n            }", "refactored_code": "        private final int N = 100;\n\n        TestFixture() {\n            synchronized (this) {\n                for (int i = 0; i < N; i++) {\n                    listField.add(Integer.valueOf(i));\n                }\n            }"}
{"magic_number_smell": "    @Test\n    public void testReflectionHierarchyArrayList() {\n        // LANG-1337 without this, the generated string can differ depending on the JVM version/vendor\n        final List<Object> list = new ArrayList<>(10);\n        final String baseString = this.toBaseString(list);\n        final String expectedWithTransients = baseString + \"[elementData={<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>},size=0,modCount=0]\";\n        final String toStringWithTransients = ToStringBuilder.reflectionToString(list, null, true);", "refactored_code": "    private static final int ARRAYLIST_INITIAL_CAPACITY = 10;\n    @Test\n    public void testReflectionHierarchyArrayList() {\n        // LANG-1337 without this, the generated string can differ depending on the JVM version/vendor\n        final List<Object> list = new ArrayList<>(ARRAYLIST_INITIAL_CAPACITY);\n        final String baseString = this.toBaseString(list);\n        final String expectedWithTransients = baseString + \"[elementData={<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>,<null>},size=0,modCount=0]\";\n        final String toStringWithTransients = ToStringBuilder.reflectionToString(list, null, true);"}
{"magic_number_smell": "    private static final int REPEAT = 100;\n\n    static {\n        LIST = new ArrayList<>(100000);\n        for (int i = 0; i < 100000; i++) {\n            LIST.add(Integer.valueOf(i));\n        }", "refactored_code": "    private static final int LIST_SIZE = 100000;\n    private static final int REPEAT = 100;\n\n    static {\n        LIST = new ArrayList<>(LIST_SIZE);\n        for (int i = 0; i < LIST_SIZE; i++) {\n            LIST.add(Integer.valueOf(i));\n        }"}
{"magic_number_smell": "     */\n    @Test\n    public void testAutomaticOpenStartsNewCheckInterval() {\n        final EventCountCircuitBreakerTestImpl breaker = new EventCountCircuitBreakerTestImpl(10, 2,\n                TimeUnit.SECONDS, CLOSING_THRESHOLD, 1, TimeUnit.SECONDS);\n        long time = 10 * NANO_FACTOR;\n        for (int i = 0; i <= 10; i++) {", "refactored_code": "    private static final int OPENING_THRESHOLD = 10;\n     */\n    @Test\n    public void testAutomaticOpenStartsNewCheckInterval() {\n        final EventCountCircuitBreakerTestImpl breaker = new EventCountCircuitBreakerTestImpl(OPENING_THRESHOLD, 2,\n                TimeUnit.SECONDS, CLOSING_THRESHOLD, 1, TimeUnit.SECONDS);\n        long time = 10 * NANO_FACTOR;\n        for (int i = 0; i <= OPENING_THRESHOLD; i++) {"}
{"magic_number_smell": "        while (! childOne.isStarted() || ! childTwo.isStarted()) {\n            if (System.currentTimeMillis() > endTime) {\n                fail(\"children never started\");\n                Thread.sleep(50);\n            }\n        }\n", "refactored_code": "    protected static final long PERIOD_MILLIS = 50;\n        while (! childOne.isStarted() || ! childTwo.isStarted()) {\n            if (System.currentTimeMillis() > endTime) {\n                fail(\"children never started\");\n                Thread.sleep(PERIOD_MILLIS);\n            }\n        }\n"}
{"magic_number_smell": "     */\n    @Test\n    public void testClosingThresholdCircuitBreaker() {\n        final ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker(10L);\n        circuit.incrementAndCheckState(9L);\n        circuit.close();\n        // now the internal counter is back at zero, not 9 anymore. So it is safe to increment 9 again", "refactored_code": "    private static final long threshold = 10L;\n     */\n    @Test\n    public void testClosingThresholdCircuitBreaker() {\n        final ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker(threshold);\n        circuit.incrementAndCheckState(9L);\n        circuit.close();\n        // now the internal counter is back at zero, not 9 anymore. So it is safe to increment 9 again"}
{"magic_number_smell": "    /** Constant for the time period. */\n    private static final long 500 = 500;\n\n    private static final Duration DURATION = Duration.ofMillis(500);\n\n    /** Constant for the time unit. */\n    private static final TimeUnit UNIT = TimeUnit.MILLISECONDS;", "refactored_code": "    private static final long PERIOD_MILLIS = 500;\n    /** Constant for the time period. */\n    private static final long PERIOD_MILLIS = 500;\n\n    private static final Duration DURATION = Duration.ofMillis(PERIOD_MILLIS);\n\n    /** Constant for the time unit. */\n    private static final TimeUnit UNIT = TimeUnit.MILLISECONDS;"}
{"magic_number_smell": "    private static final Duration SHORT_DELAY = Duration.ofMillis(100);\n    private static final Duration DELAY = Duration.ofMillis(1500);\n    private static final int 10 = 10;\n    private static final Duration TOTAL_DELAY = DELAY.multipliedBy(10);\n\n    protected boolean containsTrue(final boolean[] booleanArray) {\n        synchronized (booleanArray) {", "refactored_code": "    private static final int NUMBER_OF_THREADS = 10;\n    private static final Duration SHORT_DELAY = Duration.ofMillis(100);\n    private static final Duration DELAY = Duration.ofMillis(1500);\n    private static final int NUMBER_OF_THREADS = 10;\n    private static final Duration TOTAL_DELAY = DELAY.multipliedBy(NUMBER_OF_THREADS);\n\n    protected boolean containsTrue(final boolean[] booleanArray) {\n        synchronized (booleanArray) {"}
{"magic_number_smell": "     * return value of {@code Throwable}).\n     */\n    private static final class ExceptionWithoutCause extends Exception {\n        private static final long 1L = 1L;\n\n        @SuppressWarnings(\"unused\")\n        public void getTargetException() {", "refactored_code": "        private static final long serialVersionUID = 1L;\n     * return value of {@code Throwable}).\n     */\n    private static final class ExceptionWithoutCause extends Exception {\n        private static final long serialVersionUID = 1L;\n\n        @SuppressWarnings(\"unused\")\n        public void getTargetException() {"}
{"magic_number_smell": "            }\n        }\n        // save time by skipping some tests!  (\n        for (int i = 1001; i <= 10000; i+=500) {  // denominator\n            for (int j = 1; j <= i; j++) {  // numerator\n                f = Fraction.getFraction((double) j / (double) i);\n                f2 = Fraction.getReducedFraction(j, i);", "refactored_code": "    private static final int SKIP = 500;  //53\n            }\n        }\n        // save time by skipping some tests!  (\n        for (int i = 1001; i <= 10000; i+=SKIP) {  // denominator\n            for (int j = 1; j <= i; j++) {  // numerator\n                f = Fraction.getFraction((double) j / (double) i);\n                f2 = Fraction.getReducedFraction(j, i);"}
{"magic_number_smell": "        };\n\n        final Format formatter = new Format() {\n            private static final long 1L = 1L;\n\n            @Override\n            public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {", "refactored_code": "            private static final long serialVersionUID = 1L;\n        };\n\n        final Format formatter = new Format() {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos) {"}
{"magic_number_smell": "     * Alternative ExtendedMessageFormat impl.\n     */\n    private static final class OtherExtendedMessageFormat extends ExtendedMessageFormat {\n        private static final long 1L = 1L;\n\n        OtherExtendedMessageFormat(final String pattern, final Locale locale,\n                final Map<String, ? extends FormatFactory> registry) {", "refactored_code": "        private static final long serialVersionUID = 1L;\n     * Alternative ExtendedMessageFormat impl.\n     */\n    private static final class OtherExtendedMessageFormat extends ExtendedMessageFormat {\n        private static final long serialVersionUID = 1L;\n\n        OtherExtendedMessageFormat(final String pattern, final Locale locale,\n                final Map<String, ? extends FormatFactory> registry) {"}
{"magic_number_smell": "    public void testAppendln_CharArray_int_int() {\n        final int[] count = new int[2];\n        final StrBuilder sb = new StrBuilder() {\n            private static final long 1L = 1L;\n\n            @Override\n            public StrBuilder append(final char[] str, final int startIndex, final int length) {", "refactored_code": "            private static final long serialVersionUID = 1L;\n    public void testAppendln_CharArray_int_int() {\n        final int[] count = new int[2];\n        final StrBuilder sb = new StrBuilder() {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            public StrBuilder append(final char[] str, final int startIndex, final int length) {"}
{"magic_number_smell": "    @BeforeEach\n    public void setUp() {\n        aCalendar = Calendar.getInstance();\n        aCalendar.set(2005, 7, days, hours, minutes, seconds);\n        aCalendar.set(Calendar.MILLISECOND, millis);\n        aDate = aCalendar.getTime();\n    }", "refactored_code": "    private static final int months = 7;   // second final prime before 12\n    @BeforeEach\n    public void setUp() {\n        aCalendar = Calendar.getInstance();\n        aCalendar.set(2005, months, days, hours, minutes, seconds);\n        aCalendar.set(Calendar.MILLISECOND, millis);\n        aDate = aCalendar.getTime();\n    }"}
{"magic_number_smell": "        c.set(year, month, day, 0, 0, 0);\n        final int[] array1 = { year, month, day, 0, 0, 0 };\n        final int[] array2 = { year, month, day, 0, 0, 0 };\n        for (int i=0; i < 365 * 3 + 366; i++) {\n            array2[0] = c.get(Calendar.YEAR);\n            array2[1] = c.get(Calendar.MONTH);\n            array2[2] = c.get(Calendar.DAY_OF_MONTH);", "refactored_code": "    private static final int FOUR_YEARS = 365 * 3 + 366;\n        c.set(year, month, day, 0, 0, 0);\n        final int[] array1 = { year, month, day, 0, 0, 0 };\n        final int[] array2 = { year, month, day, 0, 0, 0 };\n        for (int i=0; i < FOUR_YEARS; i++) {\n            array2[0] = c.get(Calendar.YEAR);\n            array2[1] = c.get(Calendar.MONTH);\n            array2[2] = c.get(Calendar.DAY_OF_MONTH);"}
{"magic_number_smell": "    final Locale HUNGARIAN = Locale.forLanguageTag(\"hu\");\n\n    private AtomicLongArray measureTime(final Format printer, final Format parser) throws InterruptedException {\n        final ExecutorService pool = Executors.newFixedThreadPool(10);\n        final AtomicInteger failures = new AtomicInteger();\n        final AtomicLongArray totalElapsed = new AtomicLongArray(2);\n        try {", "refactored_code": "    private static final int NTHREADS = 10;\n    final Locale HUNGARIAN = Locale.forLanguageTag(\"hu\");\n\n    private AtomicLongArray measureTime(final Format printer, final Format parser) throws InterruptedException {\n        final ExecutorService pool = Executors.newFixedThreadPool(NTHREADS);\n        final AtomicInteger failures = new AtomicInteger();\n        final AtomicLongArray totalElapsed = new AtomicLongArray(2);\n        try {"}
{"magic_number_smell": "\n    @Test\n    public void testGmtPrefix() {\n        assertEquals(23 * 60 * 60 * 1000, FastTimeZone.getGmtTimeZone(\"GMT+23:00\").getRawOffset());\n        assertEquals(-23 * 60 * 60 * 1000, FastTimeZone.getGmtTimeZone(\"GMT-23:00\").getRawOffset());\n    }\n", "refactored_code": "    private static final int HOURS_23 = 23 * 60 * 60 * 1000;\n\n    @Test\n    public void testGmtPrefix() {\n        assertEquals(HOURS_23, FastTimeZone.getGmtTimeZone(\"GMT+23:00\").getRawOffset());\n        assertEquals(-HOURS_23, FastTimeZone.getGmtTimeZone(\"GMT-23:00\").getRawOffset());\n    }\n"}
{"magic_number_smell": "    }\n\n    private FrameParser initializeFrameLengthParser() {\n        frameSizeReader.reset(4);\n        return frameSizeReader;\n    }\n", "refactored_code": "    private static final byte AMQP_FRAME_SIZE_BYTES = 4;\n    }\n\n    private FrameParser initializeFrameLengthParser() {\n        frameSizeReader.reset(AMQP_FRAME_SIZE_BYTES);\n        return frameSizeReader;\n    }\n"}
{"magic_number_smell": "        public void run() {\n            long now = System.currentTimeMillis();\n\n            if ((now - System.currentTimeMillis()) >= connectionTimeout && connectCheckerTask != null && !ASYNC_TASKS.isShutdown()) {\n                LOG.debug(\"No connection attempt made in time for {}! Throwing InactivityIOException.\", AmqpInactivityMonitor.this.toString());\n                try {\n                    ASYNC_TASKS.execute(new Runnable() {", "refactored_code": "        private final long startTime = System.currentTimeMillis();\n        public void run() {\n            long now = System.currentTimeMillis();\n\n            if ((now - startTime) >= connectionTimeout && connectCheckerTask != null && !ASYNC_TASKS.isShutdown()) {\n                LOG.debug(\"No connection attempt made in time for {}! Throwing InactivityIOException.\", AmqpInactivityMonitor.this.toString());\n                try {\n                    ASYNC_TASKS.execute(new Runnable() {"}
{"magic_number_smell": "    private static final int SASL_PROTOCOL = 3;\n\n    private int version = 1;\n    private long maxFrameSize = Long.MAX_VALUE;\n    private int maxAmqpFrameSize = DEFAULT_ANQP_FRAME_SIZE;\n    private int connectAttemptTimeout = DEFAULT_CONNECTION_TIMEOUT;\n    private int idelTimeout = DEFAULT_IDLE_TIMEOUT;", "refactored_code": "    public static final long DEFAULT_MAX_FRAME_SIZE = Long.MAX_VALUE;\n    private static final int SASL_PROTOCOL = 3;\n\n    private int version = 1;\n    private long maxFrameSize = DEFAULT_MAX_FRAME_SIZE;\n    private int maxAmqpFrameSize = DEFAULT_ANQP_FRAME_SIZE;\n    private int connectAttemptTimeout = DEFAULT_CONNECTION_TIMEOUT;\n    private int idelTimeout = DEFAULT_IDLE_TIMEOUT;"}
{"magic_number_smell": "\n        try {\n            if (hasAmqpUuidPrefix(baseId)) {\n                String uuidString = strip(baseId, AMQP_UUID_PREFIX.length());\n                return UUID.fromString(uuidString);\n            } else if (hasAmqpUlongPrefix(baseId)) {\n                String longString = strip(baseId, AMQP_ULONG_PREFIX_LENGTH);", "refactored_code": "    private static final int AMQP_UUID_PREFIX_LENGTH = AMQP_UUID_PREFIX.length();\n\n        try {\n            if (hasAmqpUuidPrefix(baseId)) {\n                String uuidString = strip(baseId, AMQP_UUID_PREFIX_LENGTH);\n                return UUID.fromString(uuidString);\n            } else if (hasAmqpUlongPrefix(baseId)) {\n                String longString = strip(baseId, AMQP_ULONG_PREFIX_LENGTH);"}
{"magic_number_smell": "            if (destination.isTemporary()) {\n                return TEMP_QUEUE_TYPE;\n            } else {\n                return 0x00;\n            }\n        } else if (destination.isTopic()) {\n            if (destination.isTemporary()) {", "refactored_code": "    public static final byte QUEUE_TYPE = 0x00;\n            if (destination.isTemporary()) {\n                return TEMP_QUEUE_TYPE;\n            } else {\n                return QUEUE_TYPE;\n            }\n        } else if (destination.isTopic()) {\n            if (destination.isTemporary()) {"}
{"magic_number_smell": "        }\n\n        this.protonTransport.bind(this.protonConnection);\n        this.protonTransport.setChannelMax(32767);\n        this.protonTransport.setEmitFlowEventOnSend(false);\n\n        this.protonConnection.collect(eventCollector);", "refactored_code": "    private static final int CHANNEL_MAX = 32767;\n        }\n\n        this.protonTransport.bind(this.protonConnection);\n        this.protonTransport.setChannelMax(CHANNEL_MAX);\n        this.protonTransport.setEmitFlowEventOnSend(false);\n\n        this.protonConnection.collect(eventCollector);"}
{"magic_number_smell": "    private final Deque<byte[]> tagPool;\n\n    private long nextTagId;\n    private int maxPoolSize = 1024;\n\n    public AmqpTransferTagGenerator() {\n        this(true);", "refactored_code": "    public static final int DEFAULT_TAG_POOL_SIZE = 1024;\n    private final Deque<byte[]> tagPool;\n\n    private long nextTagId;\n    private int maxPoolSize = DEFAULT_TAG_POOL_SIZE;\n\n    public AmqpTransferTagGenerator() {\n        this(true);"}
{"magic_number_smell": "        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n        Destination queue = session.createQueue(getTestName());\n        MessageProducer messageProducer = session.createProducer(queue);\n        for (int i = 0; i < 1000; i++) {\n            TextMessage message = session.createTextMessage();\n            message.setText(\"test\" + i);\n            messageProducer.send(message, DeliveryMode.PERSISTENT, jakarta.jms.Message.DEFAULT_PRIORITY, jakarta.jms.Message.DEFAULT_TIME_TO_LIVE);", "refactored_code": "    private final int MSG_COUNT = 1000;\n        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n        Destination queue = session.createQueue(getTestName());\n        MessageProducer messageProducer = session.createProducer(queue);\n        for (int i = 0; i < MSG_COUNT; i++) {\n            TextMessage message = session.createTextMessage();\n            message.setText(\"test\" + i);\n            messageProducer.send(message, DeliveryMode.PERSISTENT, jakarta.jms.Message.DEFAULT_PRIORITY, jakarta.jms.Message.DEFAULT_TIME_TO_LIVE);"}
{"magic_number_smell": "        LOG.debug(\"Testing that noLocal=true subscription doesn't get any messages.\");\n\n        // Standard subscriber should receive them\n        for (int i = 0; i < 5; ++i) {\n            Message message = nonDurableSubscriber.receive(2000);\n            assertNotNull(message);\n        }", "refactored_code": "    private final int MSG_COUNT = 5;\n        LOG.debug(\"Testing that noLocal=true subscription doesn't get any messages.\");\n\n        // Standard subscriber should receive them\n        for (int i = 0; i < MSG_COUNT; ++i) {\n            Message message = nonDurableSubscriber.receive(2000);\n            assertNotNull(message);\n        }"}
{"magic_number_smell": "    @Test(timeout = 60000)\n    public void testFailedSSLConnectionAttemptsDoesNotBreakTransport() throws Exception {\n\n        for (int i = 0; i < 10; ++i) {\n            try {\n                createFailingConnection();\n                fail(\"Should not be able to connect.\");", "refactored_code": "    private static final int MAX_CONNECTIONS = 10;\n    @Test(timeout = 60000)\n    public void testFailedSSLConnectionAttemptsDoesNotBreakTransport() throws Exception {\n\n        for (int i = 0; i < MAX_CONNECTIONS; ++i) {\n            try {\n                createFailingConnection();\n                fail(\"Should not be able to connect.\");"}
{"magic_number_smell": "    public void testGroupSeqIsNeverLost() throws Exception {\n        AtomicInteger sequenceCounter = new AtomicInteger();\n\n        for (int i = 0; i < 10; ++i) {\n            connection = createConnection();\n            {\n                sendMessagesToBroker(MESSAGE_COUNT, sequenceCounter);", "refactored_code": "    private static final int ITERATIONS = 10;\n    public void testGroupSeqIsNeverLost() throws Exception {\n        AtomicInteger sequenceCounter = new AtomicInteger();\n\n        for (int i = 0; i < ITERATIONS; ++i) {\n            connection = createConnection();\n            {\n                sendMessagesToBroker(MESSAGE_COUNT, sequenceCounter);"}
{"magic_number_smell": "     * @return the currently set Max Frame Size value.\n     */\n    public int getMaxFrameSize() {\n        return 1024 * 1024 * 1;\n    }\n\n    public int getChannelMax() {", "refactored_code": "    private static final int DEFAULT_MAX_FRAME_SIZE = 1024 * 1024 * 1;\n     * @return the currently set Max Frame Size value.\n     */\n    public int getMaxFrameSize() {\n        return DEFAULT_MAX_FRAME_SIZE;\n    }\n\n    public int getChannelMax() {"}
{"magic_number_smell": "    private final ReceiverSettleMode userSpecifiedReceiverSettlementMode;\n\n    private boolean presettle;\n    private long sendTimeout = 15000;\n\n    private final Set<Delivery> pending = new LinkedHashSet<>();\n    private byte[] encodeBuffer = new byte[1024 * 8];", "refactored_code": "    public static final long DEFAULT_SEND_TIMEOUT = 15000;\n    private final ReceiverSettleMode userSpecifiedReceiverSettlementMode;\n\n    private boolean presettle;\n    private long sendTimeout = DEFAULT_SEND_TIMEOUT;\n\n    private final Set<Delivery> pending = new LinkedHashSet<>();\n    private byte[] encodeBuffer = new byte[1024 * 8];"}
{"magic_number_smell": "\n    private final String txId;\n    private Binary remoteTxId;\n    private int state = 1;\n\n    public AmqpTransactionId(String txId) {\n        this.txId = txId;", "refactored_code": "    public static final int DECLARE_MARKER = 1;\n\n    private final String txId;\n    private Binary remoteTxId;\n    private int state = DECLARE_MARKER;\n\n    public AmqpTransactionId(String txId) {\n        this.txId = txId;"}
{"magic_number_smell": "    private final Deque<byte[]> tagPool;\n\n    private long nextTagId;\n    private int maxPoolSize = 1024;\n\n    public AmqpTransferTagGenerator() {\n        this(true);", "refactored_code": "    public static final int DEFAULT_TAG_POOL_SIZE = 1024;\n    private final Deque<byte[]> tagPool;\n\n    private long nextTagId;\n    private int maxPoolSize = DEFAULT_TAG_POOL_SIZE;\n\n    public AmqpTransferTagGenerator() {\n        this(true);"}
{"magic_number_smell": "                channel = null;\n            }\n            if (group != null) {\n                Future<?> fut = group.shutdownGracefully(0, 100, TimeUnit.MILLISECONDS);\n                if (!fut.awaitUninterruptibly(2 * 100)) {\n                    LOG.trace(\"Channel group shutdown failed to complete in allotted time\");\n                }", "refactored_code": "    private static final int SHUTDOWN_TIMEOUT = 100;\n                channel = null;\n            }\n            if (group != null) {\n                Future<?> fut = group.shutdownGracefully(0, SHUTDOWN_TIMEOUT, TimeUnit.MILLISECONDS);\n                if (!fut.awaitUninterruptibly(2 * SHUTDOWN_TIMEOUT)) {\n                    LOG.trace(\"Channel group shutdown failed to complete in allotted time\");\n                }"}
{"magic_number_smell": "public class NettyTransportOptions implements Cloneable {\n\n    public static final int 64 * 1024 = 64 * 1024;\n    public static final int DEFAULT_RECEIVE_BUFFER_SIZE = 64 * 1024;\n    public static final int DEFAULT_TRAFFIC_CLASS = 0;\n    public static final boolean DEFAULT_TCP_NO_DELAY = true;\n    public static final boolean DEFAULT_TCP_KEEP_ALIVE = false;", "refactored_code": "    public static final int DEFAULT_SEND_BUFFER_SIZE = 64 * 1024;\npublic class NettyTransportOptions implements Cloneable {\n\n    public static final int DEFAULT_SEND_BUFFER_SIZE = 64 * 1024;\n    public static final int DEFAULT_RECEIVE_BUFFER_SIZE = DEFAULT_SEND_BUFFER_SIZE;\n    public static final int DEFAULT_TRAFFIC_CLASS = 0;\n    public static final boolean DEFAULT_TCP_NO_DELAY = true;\n    public static final boolean DEFAULT_TCP_KEEP_ALIVE = false;"}
{"magic_number_smell": "    private boolean trustAll = DEFAULT_TRUST_ALL;\n    private boolean verifyHost = DEFAULT_VERIFY_HOST;\n    private String keyAlias;\n    private int defaultSslPort = 5671;\n\n    static {\n        INSTANCE.setKeyStoreLocation(System.getProperty(\"javax.net.ssl.keyStore\"));", "refactored_code": "    public static final int DEFAULT_SSL_PORT = 5671;\n    private boolean trustAll = DEFAULT_TRUST_ALL;\n    private boolean verifyHost = DEFAULT_VERIFY_HOST;\n    private String keyAlias;\n    private int defaultSslPort = DEFAULT_SSL_PORT;\n\n    static {\n        INSTANCE.setKeyStoreLocation(System.getProperty(\"javax.net.ssl.keyStore\"));"}
{"magic_number_smell": "\n    @Override\n    protected String getAdditionalConfig() {\n        return \"&transport.wireFormat.idleTimeout=\" + 1000;\n    }\n\n    @Test(timeout = 60000)", "refactored_code": "    private final int TEST_IDLE_TIMEOUT = 1000;\n\n    @Override\n    protected String getAdditionalConfig() {\n        return \"&transport.wireFormat.idleTimeout=\" + TEST_IDLE_TIMEOUT;\n    }\n\n    @Test(timeout = 60000)"}
{"magic_number_smell": "        assertNotNull(client);\n\n        AmqpConnection connection = trackConnection(client.createConnection());\n        connection.setIdleTimeout(1000);\n        assertNotNull(connection);\n\n        connection.setListener(new AmqpConnectionListener() {", "refactored_code": "    private final int TEST_IDLE_TIMEOUT = 1000;\n        assertNotNull(client);\n\n        AmqpConnection connection = trackConnection(client.createConnection());\n        connection.setIdleTimeout(TEST_IDLE_TIMEOUT);\n        assertNotNull(connection);\n\n        connection.setListener(new AmqpConnectionListener() {"}
{"magic_number_smell": "\n        List<AmqpConnection> connections = new ArrayList<AmqpConnection>();\n\n        for (int i = 0; i < 10; ++i) {\n            AmqpConnection connection = client.connect();\n            assertNotNull(connection);\n", "refactored_code": "    private static final int MAX_CONNECTIONS = 10;\n\n        List<AmqpConnection> connections = new ArrayList<AmqpConnection>();\n\n        for (int i = 0; i < MAX_CONNECTIONS; ++i) {\n            AmqpConnection connection = client.connect();\n            assertNotNull(connection);\n"}
{"magic_number_smell": "\n    @Override\n    protected String getAdditionalConfig() {\n        return \"&transport.useInactivityMonitor=false&transport.wireFormat.idleTimeout=\" + 3000;\n    }\n\n    @Test(timeout = 60000)", "refactored_code": "    private final int TEST_IDLE_TIMEOUT = 3000;\n\n    @Override\n    protected String getAdditionalConfig() {\n        return \"&transport.useInactivityMonitor=false&transport.wireFormat.idleTimeout=\" + TEST_IDLE_TIMEOUT;\n    }\n\n    @Test(timeout = 60000)"}
{"magic_number_smell": "            }\n        });\n\n        connection.setIdleTimeout(500);\n        connection.connect();\n\n        AmqpSession session = connection.createSession();", "refactored_code": "    private final int TEST_IDLE_TIMEOUT = 500;\n            }\n        });\n\n        connection.setIdleTimeout(TEST_IDLE_TIMEOUT);\n        connection.connect();\n\n        AmqpSession session = connection.createSession();"}
{"magic_number_smell": "         AmqpConnection connection = client.connect();\n         AmqpSession session = connection.createSession();\n         AmqpSender sender = session.createSender(testQueueName);\n         AmqpMessage message = createAmqpMessage((byte) 'A', 110 * 1024);\n\n         message.setApplicationProperty(\"IntProperty\", 42);\n         message.setDurable(true);", "refactored_code": "    private static final int PAYLOAD = 110 * 1024;\n         AmqpConnection connection = client.connect();\n         AmqpSession session = connection.createSession();\n         AmqpSender sender = session.createSender(testQueueName);\n         AmqpMessage message = createAmqpMessage((byte) 'A', PAYLOAD);\n\n         message.setApplicationProperty(\"IntProperty\", 42);\n         message.setDurable(true);"}
{"magic_number_smell": "    protected void performAdditionalConfiguration(BrokerService brokerService) throws Exception {\n        strategy = new AbortSlowAckConsumerStrategy();\n        strategy.setAbortConnection(false);\n        strategy.setCheckPeriod(1000);\n        strategy.setMaxSlowDuration(DEFAULT_MAX_SLOW_DURATION);\n        strategy.setMaxTimeSinceLastAck(DEFAULT_MAX_SLOW_DURATION);\n", "refactored_code": "    private final long DEFAULT_CHECK_PERIOD = 1000;\n    protected void performAdditionalConfiguration(BrokerService brokerService) throws Exception {\n        strategy = new AbortSlowAckConsumerStrategy();\n        strategy.setAbortConnection(false);\n        strategy.setCheckPeriod(DEFAULT_CHECK_PERIOD);\n        strategy.setMaxSlowDuration(DEFAULT_MAX_SLOW_DURATION);\n        strategy.setMaxTimeSinceLastAck(DEFAULT_MAX_SLOW_DURATION);\n"}
{"magic_number_smell": "\n    @Override\n    protected String getAdditionalConfig() {\n        return \"&transport.wireFormat.idleTimeout=\" + 3000;\n    }\n\n    @Test(timeout = 60000)", "refactored_code": "    private final int TEST_IDLE_TIMEOUT = 3000;\n\n    @Override\n    protected String getAdditionalConfig() {\n        return \"&transport.wireFormat.idleTimeout=\" + TEST_IDLE_TIMEOUT;\n    }\n\n    @Test(timeout = 60000)"}
{"magic_number_smell": "        OutboundTransformer outboundTransformer = getOutboundTransformer();\n\n        // Warm up\n        for (int i = 0; i < 10000; ++i) {\n            ActiveMQMessage intermediate = inboundTransformer.transform(encoded);\n            intermediate.onSend();\n            outboundTransformer.transform(intermediate);", "refactored_code": "    private final int WARM_CYCLES = 10000;\n        OutboundTransformer outboundTransformer = getOutboundTransformer();\n\n        // Warm up\n        for (int i = 0; i < WARM_CYCLES; ++i) {\n            ActiveMQMessage intermediate = inboundTransformer.transform(encoded);\n            intermediate.onSend();\n            outboundTransformer.transform(intermediate);"}
{"magic_number_smell": "\n    public static final int 64 * 1024 = 64 * 1024;\n\n    private final byte[] payload = new byte[64 * 1024];\n    private final int parallelProducer = 1;\n    private final int parallelConsumer = 1;\n    private final Vector<Throwable> exceptions = new Vector<Throwable>();", "refactored_code": "    public static final int PAYLOAD_SIZE = 64 * 1024;\n\n    public static final int PAYLOAD_SIZE = 64 * 1024;\n\n    private final byte[] payload = new byte[PAYLOAD_SIZE];\n    private final int parallelProducer = 1;\n    private final int parallelConsumer = 1;\n    private final Vector<Throwable> exceptions = new Vector<Throwable>();"}
{"magic_number_smell": "        Queue queue = session.createQueue(getDestinationName());\n        session.close();\n\n        for (int i = 1; i <= 1000; ++i) {\n            // When recreating session, memory leak does occurs on the client but memory leak still occurs on the server\n            session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n            QueueBrowser browser = session.createBrowser(queue, \"JMSXGroupSeq=0\");", "refactored_code": "    private final int NUM_ITERATIONS = 1000;\n        Queue queue = session.createQueue(getDestinationName());\n        session.close();\n\n        for (int i = 1; i <= NUM_ITERATIONS; ++i) {\n            // When recreating session, memory leak does occurs on the client but memory leak still occurs on the server\n            session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n            QueueBrowser browser = session.createBrowser(queue, \"JMSXGroupSeq=0\");"}
{"magic_number_smell": "    public void testResetReadsNextAMQPHeaderAfterContentParsed() throws Exception {\n        AmqpHeader inputHeader = new AmqpHeader();\n\n        byte[] CONTENTS = new byte[5 * 1024 * 1024];\n        for (int i = 0; i < 5 * 1024 * 1024; i++) {\n            CONTENTS[i] = 'a';\n        }", "refactored_code": "    private final int MESSAGE_SIZE = 5 * 1024 * 1024;\n    public void testResetReadsNextAMQPHeaderAfterContentParsed() throws Exception {\n        AmqpHeader inputHeader = new AmqpHeader();\n\n        byte[] CONTENTS = new byte[MESSAGE_SIZE];\n        for (int i = 0; i < MESSAGE_SIZE; i++) {\n            CONTENTS[i] = 'a';\n        }"}
{"magic_number_smell": "        }\n\n        public AmqpHeader readAmqpHeader() throws Exception {\n            clientSocket.setSoTimeout((int)10000);\n            InputStream is = clientSocket.getInputStream();\n\n            byte[] header = new byte[8];", "refactored_code": "        protected static final long RECEIVE_TIMEOUT = 10000;\n        }\n\n        public AmqpHeader readAmqpHeader() throws Exception {\n            clientSocket.setSoTimeout((int)RECEIVE_TIMEOUT);\n            InputStream is = clientSocket.getInputStream();\n\n            byte[] header = new byte[8];"}
{"magic_number_smell": "\n    protected String name;\n    protected boolean failIfLocked = false;\n    protected long lockAcquireSleepInterval = 10 * 1000;\n    protected LockableServiceSupport lockable;\n\n    @Override", "refactored_code": "    public static final long DEFAULT_LOCK_ACQUIRE_SLEEP_INTERVAL = 10 * 1000;\n\n    protected String name;\n    protected boolean failIfLocked = false;\n    protected long lockAcquireSleepInterval = DEFAULT_LOCK_ACQUIRE_SLEEP_INTERVAL;\n    protected LockableServiceSupport lockable;\n\n    @Override"}
{"magic_number_smell": "                if (store != null && store instanceof JournaledStore) {\n                    maxJournalFileSize = ((JournaledStore) store).getJournalMaxFileLength();\n                } else {\n                    maxJournalFileSize = 1024 * 1024 * 32;\n                }\n                long storeLimit = usage.getTempUsage().getLimit();\n", "refactored_code": "    public static final int DEFAULT_MAX_FILE_LENGTH = 1024 * 1024 * 32;\n                if (store != null && store instanceof JournaledStore) {\n                    maxJournalFileSize = ((JournaledStore) store).getJournalMaxFileLength();\n                } else {\n                    maxJournalFileSize = DEFAULT_MAX_FILE_LENGTH;\n                }\n                long storeLimit = usage.getTempUsage().getLimit();\n"}
{"magic_number_smell": "    private static final int STARTING      = 1;\n    private static final int STARTED       = 2;\n    private static final int PENDING_STOP  = 3;\n    private final AtomicInteger status = new AtomicInteger(0);\n\n    private long timeStamp;\n    private final AtomicBoolean stopping = new AtomicBoolean(false);", "refactored_code": "    private static final int NEW           = 0;\n    private static final int STARTING      = 1;\n    private static final int STARTED       = 2;\n    private static final int PENDING_STOP  = 3;\n    private final AtomicInteger status = new AtomicInteger(NEW);\n\n    private long timeStamp;\n    private final AtomicBoolean stopping = new AtomicBoolean(false);"}
{"magic_number_smell": "    private static final byte EXIT = 0b10;\n    private static final byte ALL = 0b11;\n\n    private static byte audit = 0b00;\n    private static AuditLogService auditLog;\n\n    static {", "refactored_code": "    private static final byte OFF = 0b00;\n    private static final byte EXIT = 0b10;\n    private static final byte ALL = 0b11;\n\n    private static byte audit = OFF;\n    private static AuditLogService auditLog;\n\n    static {"}
{"magic_number_smell": "     * persistent storage\n     */\n    public static final int 200 = 200;\n    public static final int MAX_BROWSE_PAGE_SIZE = 200 * 2;\n    public static final long EXPIRE_MESSAGE_PERIOD = 30 * 1000;\n    public static final long DEFAULT_INACTIVE_TIMEOUT_BEFORE_GC = 60 * 1000;\n    public static final int MAX_PRODUCERS_TO_AUDIT = 64;", "refactored_code": "    public static final int MAX_PAGE_SIZE = 200;\n     * persistent storage\n     */\n    public static final int MAX_PAGE_SIZE = 200;\n    public static final int MAX_BROWSE_PAGE_SIZE = MAX_PAGE_SIZE * 2;\n    public static final long EXPIRE_MESSAGE_PERIOD = 30 * 1000;\n    public static final long DEFAULT_INACTIVE_TIMEOUT_BEFORE_GC = 60 * 1000;\n    public static final int MAX_PRODUCERS_TO_AUDIT = 64;"}
{"magic_number_smell": "    }\n\n    public void start() throws Exception {\n        scheduler.executePeriodically(gcTask, 1000);\n    }\n\n    public void stop() throws Exception {", "refactored_code": "    private static final int GC_INTERVAL = 1000;\n    }\n\n    public void start() throws Exception {\n        scheduler.executePeriodically(gcTask, GC_INTERVAL);\n    }\n\n    public void stop() throws Exception {"}
{"magic_number_smell": "\n    private final JobSchedulerStore store;\n    private JobScheduler scheduler;\n    private int maxRepeatAllowed = 1000;\n\n    public SchedulerBroker(BrokerService brokerService, Broker next, JobSchedulerStore store) throws Exception {\n        super(next);", "refactored_code": "    private static final int MAX_REPEAT_ALLOWED = 1000;\n\n    private final JobSchedulerStore store;\n    private JobScheduler scheduler;\n    private int maxRepeatAllowed = MAX_REPEAT_ALLOWED;\n\n    public SchedulerBroker(BrokerService brokerService, Broker next, JobSchedulerStore store) throws Exception {\n        super(next);"}
{"magic_number_smell": "    private int maxSendRetries = 10;\n    private long sendRetryDelay = 1000L;\n\n    private int maxReconnectAttempts = -1;\n    private int maxInitialConnectAttempts = -1;\n    private long maximumReconnectDelay = 30000;\n    private long initialReconnectDelay = 1000L;", "refactored_code": "    public static final int INFINITE = -1;\n    private int maxSendRetries = 10;\n    private long sendRetryDelay = 1000L;\n\n    private int maxReconnectAttempts = INFINITE;\n    private int maxInitialConnectAttempts = INFINITE;\n    private long maximumReconnectDelay = 30000;\n    private long initialReconnectDelay = 1000L;"}
{"magic_number_smell": "    }\n\n    /**\n     * Persist the selector cache every {@code 600000}ms.\n     *\n     * @see java.lang.Runnable#run()\n     */", "refactored_code": "    public static final long MAX_PERSIST_INTERVAL = 600000;\n    }\n\n    /**\n     * Persist the selector cache every {@code MAX_PERSIST_INTERVAL}ms.\n     *\n     * @see java.lang.Runnable#run()\n     */"}
{"magic_number_smell": "    Throwable rollackOnlyCause = null;\n\n    private final ArrayList<Synchronization> synchronizations = new ArrayList<Synchronization>();\n    private byte state = 0;\n    protected FutureTask<?> preCommitTask = new FutureTask<Object>(new Callable<Object>() {\n        public Object call() throws Exception {\n            doPreCommit();", "refactored_code": "    public static final byte START_STATE = 0; // can go to: 1,2,3\n    Throwable rollackOnlyCause = null;\n\n    private final ArrayList<Synchronization> synchronizations = new ArrayList<Synchronization>();\n    private byte state = START_STATE;\n    protected FutureTask<?> preCommitTask = new FutureTask<Object>(new Callable<Object>() {\n        public Object call() throws Exception {\n            doPreCommit();"}
{"magic_number_smell": "\n    public static void copyInputStream(InputStream in, OutputStream out) throws IOException {\n        try {\n            byte[] buffer = new byte[4096];\n            int len = in.read(buffer);\n            while (len >= 0) {\n                out.write(buffer, 0, len);", "refactored_code": "    private static final int DEFAULT_BUFFER_SIZE = 4096;\n\n    public static void copyInputStream(InputStream in, OutputStream out) throws IOException {\n        try {\n            byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];\n            int len = in.read(buffer);\n            while (len >= 0) {\n                out.write(buffer, 0, len);"}
{"magic_number_smell": "    protected BrokerService broker;\n\n    // for message listener test\n    private final List<Message> unackMessages = new ArrayList<Message>(5);\n    private final List<Message> ackMessages = new ArrayList<Message>(5);\n    private boolean resendPhase;\n", "refactored_code": "    private static final int MESSAGE_COUNT = 5;\n    protected BrokerService broker;\n\n    // for message listener test\n    private final List<Message> unackMessages = new ArrayList<Message>(MESSAGE_COUNT);\n    private final List<Message> ackMessages = new ArrayList<Message>(MESSAGE_COUNT);\n    private boolean resendPhase;\n"}
{"magic_number_smell": "            target = uri;\n            pause.set(new CountDownLatch(0));\n            try {\n                socket.setSoTimeout(100);\n            } catch (SocketException e) {\n                e.printStackTrace();\n            }", "refactored_code": "    public static final int ACCEPT_TIMEOUT_MILLIS = 100;\n            target = uri;\n            pause.set(new CountDownLatch(0));\n            try {\n                socket.setSoTimeout(ACCEPT_TIMEOUT_MILLIS);\n            } catch (SocketException e) {\n                e.printStackTrace();\n            }"}
{"magic_number_smell": "    }\n\n    public static boolean waitFor(Condition condition) throws Exception {\n        return waitFor(condition, 30*1000);\n    }\n\n    public static boolean waitFor(final Condition condition, final long duration) throws Exception {", "refactored_code": "    public static final long MAX_WAIT_MILLIS = 30*1000;\n    }\n\n    public static boolean waitFor(Condition condition) throws Exception {\n        return waitFor(condition, MAX_WAIT_MILLIS);\n    }\n\n    public static boolean waitFor(final Condition condition, final long duration) throws Exception {"}
{"magic_number_smell": "    private boolean nestedMapAndListEnabled = true;\n    private boolean alwaysSyncSend;\n    private boolean watchTopicAdvisories = true;\n    private int producerWindowSize = 0;\n    private long warnAboutUnstartedConnectionTimeout = 500L;\n    private int sendTimeout = 0;\n    private int connectResponseTimeout = 0;", "refactored_code": "    public static final int DEFAULT_PRODUCER_WINDOW_SIZE = 0;\n    private boolean nestedMapAndListEnabled = true;\n    private boolean alwaysSyncSend;\n    private boolean watchTopicAdvisories = true;\n    private int producerWindowSize = DEFAULT_PRODUCER_WINDOW_SIZE;\n    private long warnAboutUnstartedConnectionTimeout = 500L;\n    private int sendTimeout = 0;\n    private int connectResponseTimeout = 0;"}
{"magic_number_smell": "    public static final int DEFAULT_QUEUE_BROWSER_PREFETCH = 500;\n    public static final int DEFAULT_DURABLE_TOPIC_PREFETCH = 100;\n    public static final int DEFAULT_OPTIMIZE_DURABLE_TOPIC_PREFETCH = 1000;\n    public static final int DEFAULT_TOPIC_PREFETCH = Short.MAX_VALUE;\n\n    private static final Logger LOG = LoggerFactory.getLogger(ActiveMQPrefetchPolicy.class);\n", "refactored_code": "    public static final int MAX_PREFETCH_SIZE = Short.MAX_VALUE;\n    public static final int DEFAULT_QUEUE_BROWSER_PREFETCH = 500;\n    public static final int DEFAULT_DURABLE_TOPIC_PREFETCH = 100;\n    public static final int DEFAULT_OPTIMIZE_DURABLE_TOPIC_PREFETCH = 1000;\n    public static final int DEFAULT_TOPIC_PREFETCH = MAX_PREFETCH_SIZE;\n\n    private static final Logger LOG = LoggerFactory.getLogger(ActiveMQPrefetchPolicy.class);\n"}
{"magic_number_smell": "     * is called\n     */\n    public static final int 4 = 4;\n    public static final int MAX_ACK_CONSTANT = 4;\n\n    public static interface DeliveryListener {\n        void beforeDelivery(ActiveMQSession session, Message msg);", "refactored_code": "    public static final int INDIVIDUAL_ACKNOWLEDGE = 4;\n     * is called\n     */\n    public static final int INDIVIDUAL_ACKNOWLEDGE = 4;\n    public static final int MAX_ACK_CONSTANT = INDIVIDUAL_ACKNOWLEDGE;\n\n    public static interface DeliveryListener {\n        void beforeDelivery(ActiveMQSession session, Message msg);"}
{"magic_number_smell": "        while (tokenize.hasMoreTokens()) {\n            result.add(tokenize.nextToken());\n        }\n        if (result.size() != 5) {\n            throw new IllegalArgumentException(\"Not a valid cron entry - wrong number of tokens(\" + result.size()\n                    + \"): \" + cron);\n        }", "refactored_code": "    private static final int NUMBER_TOKENS = 5;\n        while (tokenize.hasMoreTokens()) {\n            result.add(tokenize.nextToken());\n        }\n        if (result.size() != NUMBER_TOKENS) {\n            throw new IllegalArgumentException(\"Not a valid cron entry - wrong number of tokens(\" + result.size()\n                    + \"): \" + cron);\n        }"}
{"magic_number_smell": "    }\n\n    public byte getDataStructureType() {\n        return CommandTypes.ACTIVEMQ_BLOB_MESSAGE;\n    }\n\n    /**", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.ACTIVEMQ_BLOB_MESSAGE;\n    }\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    /**"}
{"magic_number_smell": "\n    @Override\n    public byte getDataStructureType() {\n        return CommandTypes.ACTIVEMQ_BYTES_MESSAGE;\n    }\n\n    @Override", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.ACTIVEMQ_BYTES_MESSAGE;\n\n    @Override\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    @Override"}
{"magic_number_smell": "    public static final byte TOPIC_TYPE = 0x02;\n    public static final byte TEMP_MASK = 0x04;\n    public static final byte TEMP_TOPIC_TYPE = TOPIC_TYPE | TEMP_MASK;\n    public static final byte TEMP_QUEUE_TYPE = 0x01 | TEMP_MASK;\n\n    public static final String QUEUE_QUALIFIED_PREFIX = \"queue://\";\n    public static final String TOPIC_QUALIFIED_PREFIX = \"topic://\";", "refactored_code": "    public static final byte QUEUE_TYPE = 0x01;\n    public static final byte TOPIC_TYPE = 0x02;\n    public static final byte TEMP_MASK = 0x04;\n    public static final byte TEMP_TOPIC_TYPE = TOPIC_TYPE | TEMP_MASK;\n    public static final byte TEMP_QUEUE_TYPE = QUEUE_TYPE | TEMP_MASK;\n\n    public static final String QUEUE_QUALIFIED_PREFIX = \"queue://\";\n    public static final String TOPIC_QUALIFIED_PREFIX = \"topic://\";"}
{"magic_number_smell": "\n    @Override\n    public byte getDataStructureType() {\n        return CommandTypes.ACTIVEMQ_MAP_MESSAGE;\n    }\n\n    @Override", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.ACTIVEMQ_MAP_MESSAGE;\n\n    @Override\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public byte getDataStructureType() {\n        return CommandTypes.ACTIVEMQ_MESSAGE;\n    }\n\n    @Override", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.ACTIVEMQ_MESSAGE;\n\n    @Override\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public byte getDataStructureType() {\n        return CommandTypes.ACTIVEMQ_OBJECT_MESSAGE;\n    }\n\n    @Override", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.ACTIVEMQ_OBJECT_MESSAGE;\n\n    @Override\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public byte getDataStructureType() {\n        return CommandTypes.ACTIVEMQ_QUEUE;\n    }\n\n    public boolean isQueue() {", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.ACTIVEMQ_QUEUE;\n    }\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    public boolean isQueue() {"}
{"magic_number_smell": "\n    @Override\n    public byte getDataStructureType() {\n        return CommandTypes.ACTIVEMQ_STREAM_MESSAGE;\n    }\n\n    @Override", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.ACTIVEMQ_STREAM_MESSAGE;\n\n    @Override\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public byte getDataStructureType() {\n        return CommandTypes.ACTIVEMQ_TEMP_QUEUE;\n    }\n\n    public boolean isQueue() {", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.ACTIVEMQ_TEMP_QUEUE;\n    }\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    public boolean isQueue() {"}
{"magic_number_smell": "    }\n\n    public byte getDataStructureType() {\n        return CommandTypes.ACTIVEMQ_TEMP_TOPIC;\n    }\n\n    public boolean isTopic() {", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.ACTIVEMQ_TEMP_TOPIC;\n    }\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    public boolean isTopic() {"}
{"magic_number_smell": "\n    @Override\n    public byte getDataStructureType() {\n        return CommandTypes.ACTIVEMQ_TEXT_MESSAGE;\n    }\n\n    @Override", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.ACTIVEMQ_TEXT_MESSAGE;\n\n    @Override\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public byte getDataStructureType() {\n        return CommandTypes.ACTIVEMQ_TOPIC;\n    }\n\n    public boolean isTopic() {", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.ACTIVEMQ_TOPIC;\n    }\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    public boolean isTopic() {"}
{"magic_number_smell": "    }\n\n    public byte getDataStructureType() {\n        return CommandTypes.BROKER_ID;\n    }\n\n    public String toString() {", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.BROKER_ID;\n    }\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    public String toString() {"}
{"magic_number_smell": "\n    @Override\n    public byte getDataStructureType() {\n        return CommandTypes.BROKER_INFO;\n    }\n\n    /**", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.BROKER_INFO;\n\n    @Override\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    /**"}
{"magic_number_smell": "\n    @Override\n    public byte getDataStructureType() {\n        return CommandTypes.BROKER_SUBSCRIPTION_INFO;\n    }\n\n    /**", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.BROKER_SUBSCRIPTION_INFO;\n\n    @Override\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    /**"}
{"magic_number_smell": "    protected boolean rebalanceConnection;\n\n    public byte getDataStructureType() {\n        return CommandTypes.CONNECTION_CONTROL;\n    }\n\n    public Response visit(CommandVisitor visitor) throws Exception {", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.CONNECTION_CONTROL;\n    protected boolean rebalanceConnection;\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    public Response visit(CommandVisitor visitor) throws Exception {"}
{"magic_number_smell": "    private Throwable exception;\n\n    public byte getDataStructureType() {\n        return CommandTypes.CONNECTION_ERROR;\n    }\n\n    public Response visit(CommandVisitor visitor) throws Exception {", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.CONNECTION_ERROR;\n    private Throwable exception;\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    public Response visit(CommandVisitor visitor) throws Exception {"}
{"magic_number_smell": "    }\n\n    public byte getDataStructureType() {\n        return CommandTypes.CONNECTION_ID;\n    }\n\n    public String toString() {", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.CONNECTION_ID;\n    }\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    public String toString() {"}
{"magic_number_smell": "    }\n\n    public byte getDataStructureType() {\n        return CommandTypes.CONNECTION_INFO;\n    }\n\n    public ConnectionInfo copy() {", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.CONNECTION_INFO;\n    }\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    public ConnectionInfo copy() {"}
{"magic_number_smell": "\n    @Override\n    public byte getDataStructureType() {\n        return CommandTypes.CONSUMER_CONTROL;\n    }\n\n    @Override", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.CONSUMER_CONTROL;\n\n    @Override\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public byte getDataStructureType() {\n        return CommandTypes.CONSUMER_ID;\n    }\n\n    public String toString() {", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.CONSUMER_ID;\n    }\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    public String toString() {"}
{"magic_number_smell": "\n    @Override\n    public byte getDataStructureType() {\n        return CommandTypes.CONSUMER_INFO;\n    }\n\n    /**", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.CONSUMER_INFO;\n\n    @Override\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    /**"}
{"magic_number_smell": "    private String command;\n\n    public byte getDataStructureType() {\n        return CommandTypes.CONTROL_COMMAND;\n    }\n\n    /**", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.CONTROL_COMMAND;\n    private String command;\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    /**"}
{"magic_number_smell": "    }\n\n    public byte getDataStructureType() {\n        return CommandTypes.DATA_ARRAY_RESPONSE;\n    }\n\n    /**", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.DATA_ARRAY_RESPONSE;\n    }\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    /**"}
{"magic_number_smell": "    }\n\n    public byte getDataStructureType() {\n        return CommandTypes.DATA_RESPONSE;\n    }\n\n    /**", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.DATA_RESPONSE;\n    }\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    /**"}
{"magic_number_smell": "    }\n\n    public byte getDataStructureType() {\n        return CommandTypes.DESTINATION_INFO;\n    }\n\n    public boolean isAddOperation() {", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.DESTINATION_INFO;\n    }\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    public boolean isAddOperation() {"}
{"magic_number_smell": "    }\n    \n    public byte getDataStructureType() {\n        return CommandTypes.DISCOVERY_EVENT;\n    }\n\n    /**", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.DISCOVERY_EVENT;\n    }\n    \n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    /**"}
{"magic_number_smell": "    }\n\n    public byte getDataStructureType() {\n        return CommandTypes.EXCEPTION_RESPONSE;\n    }\n\n    /**", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.EXCEPTION_RESPONSE;\n    }\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    /**"}
{"magic_number_smell": "    public static final Command COMMAND = new FlushCommand();\n\n    public byte getDataStructureType() {\n        return CommandTypes.FLUSH_COMMAND;\n    }\n\n    public Response visit(CommandVisitor visitor) throws Exception {", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.FLUSH_COMMAND;\n    public static final Command COMMAND = new FlushCommand();\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    public Response visit(CommandVisitor visitor) throws Exception {"}
{"magic_number_smell": "    }\n\n    public byte getDataStructureType() {\n        return CommandTypes.INTEGER_RESPONSE;\n    }\n\n    /**", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.INTEGER_RESPONSE;\n    }\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    /**"}
{"magic_number_smell": "    MessageAck messageAck;\n\n    public byte getDataStructureType() {\n        return CommandTypes.JOURNAL_REMOVE;\n    }\n\n    /**", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.JOURNAL_REMOVE;\n    MessageAck messageAck;\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    /**"}
{"magic_number_smell": "    TransactionId transactionId;\n\n    public byte getDataStructureType() {\n        return CommandTypes.JOURNAL_ACK;\n    }\n\n    /**", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.JOURNAL_ACK;\n    TransactionId transactionId;\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    /**"}
{"magic_number_smell": "    }\n\n    public byte getDataStructureType() {\n        return CommandTypes.JOURNAL_TRACE;\n    }\n\n    /**", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.JOURNAL_TRACE;\n    }\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    /**"}
{"magic_number_smell": "    }\n\n    public byte getDataStructureType() {\n        return CommandTypes.JOURNAL_TRANSACTION;\n    }\n\n    /**", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.JOURNAL_TRANSACTION;\n    }\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    /**"}
{"magic_number_smell": "    private transient Endpoint to;\n\n    public byte getDataStructureType() {\n        return CommandTypes.KEEP_ALIVE_INFO;\n    }\n\n    public boolean isResponse() {", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.KEEP_ALIVE_INFO;\n    private transient Endpoint to;\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    public boolean isResponse() {"}
{"magic_number_smell": "    }\n\n    public byte getDataStructureType() {\n        return CommandTypes.PARTIAL_LAST_COMMAND;\n    }\n\n    public Response visit(CommandVisitor visitor) throws Exception {", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.PARTIAL_LAST_COMMAND;\n    }\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    public Response visit(CommandVisitor visitor) throws Exception {"}
{"magic_number_smell": "    }\n\n    public byte getDataStructureType() {\n        return CommandTypes.ACTIVEMQ_LOCAL_TRANSACTION_ID;\n    }\n\n    public boolean isXATransaction() {", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.ACTIVEMQ_LOCAL_TRANSACTION_ID;\n    }\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    public boolean isXATransaction() {"}
{"magic_number_smell": "    }\n\n    protected int getMinimumMessageSize() {\n        int result = 1024;\n        //let destination override\n        MessageDestination dest = regionDestination;\n        if (dest != null) {", "refactored_code": "    public static final int DEFAULT_MINIMUM_MESSAGE_SIZE = 1024;\n    }\n\n    protected int getMinimumMessageSize() {\n        int result = DEFAULT_MINIMUM_MESSAGE_SIZE;\n        //let destination override\n        MessageDestination dest = regionDestination;\n        if (dest != null) {"}
{"magic_number_smell": "    }\n\n    public byte getDataStructureType() {\n        return CommandTypes.MESSAGE_ACK;\n    }\n\n    public boolean isMessageAck() {", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.MESSAGE_ACK;\n    }\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    public boolean isMessageAck() {"}
{"magic_number_smell": "\n    @Override\n    public byte getDataStructureType() {\n        return CommandTypes.MESSAGE_DISPATCH;\n    }\n\n    @Override", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.MESSAGE_DISPATCH;\n\n    @Override\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    @Override"}
{"magic_number_smell": "    protected long deliverySequenceId;\n\n    public byte getDataStructureType() {\n        return CommandTypes.MESSAGE_DISPATCH_NOTIFICATION;\n    }\n\n    public boolean isMessageDispatchNotification() {", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.MESSAGE_DISPATCH_NOTIFICATION;\n    protected long deliverySequenceId;\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    public boolean isMessageDispatchNotification() {"}
{"magic_number_smell": "\n    @Override\n    public byte getDataStructureType() {\n        return CommandTypes.MESSAGE_ID;\n    }\n\n    @Override", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.MESSAGE_ID;\n\n    @Override\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public byte getDataStructureType() {\n        return CommandTypes.MESSAGE_PULL;\n    }\n\n    @Override", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.MESSAGE_PULL;\n\n    @Override\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public byte getDataStructureType() {\n        return CommandTypes.NETWORK_BRIDGE_FILTER;\n    }\n\n    @Override", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.NETWORK_BRIDGE_FILTER;\n\n    @Override\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public byte getDataStructureType() {\n        return CommandTypes.PARTIAL_COMMAND;\n    }\n\n    /**", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.PARTIAL_COMMAND;\n\n    @Override\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    /**"}
{"magic_number_smell": "    }\n\n    public byte getDataStructureType() {\n        return CommandTypes.PRODUCER_ACK;\n    }\n\n    public Response visit(CommandVisitor visitor) throws Exception {", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.PRODUCER_ACK;\n    }\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    public Response visit(CommandVisitor visitor) throws Exception {"}
{"magic_number_smell": "    }\n\n    public byte getDataStructureType() {\n        return CommandTypes.PRODUCER_ID;\n    }\n\n    /**", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.PRODUCER_ID;\n    }\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    /**"}
{"magic_number_smell": "    }\n\n    public byte getDataStructureType() {\n        return CommandTypes.PRODUCER_INFO;\n    }\n\n    /**", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.PRODUCER_INFO;\n    }\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    /**"}
{"magic_number_smell": "    }\n\n    public byte getDataStructureType() {\n        return CommandTypes.REMOVE_INFO;\n    }\n\n    /**", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.REMOVE_INFO;\n    }\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    /**"}
{"magic_number_smell": "    protected String subscriptionName;\n\n    public byte getDataStructureType() {\n        return CommandTypes.REMOVE_SUBSCRIPTION_INFO;\n    }\n\n    /**", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.REMOVE_SUBSCRIPTION_INFO;\n    protected String subscriptionName;\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    /**"}
{"magic_number_smell": "    }\n\n    public byte getDataStructureType() {\n        return CommandTypes.REPLAY;\n    }\n\n    public String getProducerId() {", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.REPLAY;\n    }\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    public String getProducerId() {"}
{"magic_number_smell": "    int correlationId;\n\n    public byte getDataStructureType() {\n        return CommandTypes.RESPONSE;\n    }\n\n    /**", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.RESPONSE;\n    int correlationId;\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    /**"}
{"magic_number_smell": "    }\n\n    public byte getDataStructureType() {\n        return CommandTypes.SESSION_ID;\n    }\n\n    /**", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.SESSION_ID;\n    }\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    /**"}
{"magic_number_smell": "    }\n\n    public byte getDataStructureType() {\n        return CommandTypes.SESSION_INFO;\n    }\n\n    /**", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.SESSION_INFO;\n    }\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    /**"}
{"magic_number_smell": "    public static final byte CommandTypes.SHUTDOWN_INFO = CommandTypes.SHUTDOWN_INFO;\n\n    public byte getDataStructureType() {\n        return CommandTypes.SHUTDOWN_INFO;\n    }\n\n    public Response visit(CommandVisitor visitor) throws Exception {", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.SHUTDOWN_INFO;\n    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.SHUTDOWN_INFO;\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    public Response visit(CommandVisitor visitor) throws Exception {"}
{"magic_number_smell": "\n    @Override\n    public byte getDataStructureType() {\n        return CommandTypes.DURABLE_SUBSCRIPTION_INFO;\n    }\n\n    /**", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.DURABLE_SUBSCRIPTION_INFO;\n\n    @Override\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    /**"}
{"magic_number_smell": "    }\n\n    public byte getDataStructureType() {\n        return CommandTypes.TRANSACTION_INFO;\n    }\n\n    /**", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.TRANSACTION_INFO;\n    }\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    /**"}
{"magic_number_smell": "\n    @Override\n    public byte getDataStructureType() {\n        return CommandTypes.WIREFORMAT_INFO;\n    }\n\n    @Override", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.WIREFORMAT_INFO;\n\n    @Override\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public byte getDataStructureType() {\n        return CommandTypes.ACTIVEMQ_XA_TRANSACTION_ID;\n    }\n\n    final int XID_PREFIX_SIZE = 16;", "refactored_code": "    public static final byte DATA_STRUCTURE_TYPE = CommandTypes.ACTIVEMQ_XA_TRANSACTION_ID;\n    }\n\n    public byte getDataStructureType() {\n        return DATA_STRUCTURE_TYPE;\n    }\n\n    final int XID_PREFIX_SIZE = 16;"}
{"magic_number_smell": "\n    protected Number plus(Number left, Number right) {\n        switch (numberType(left, right)) {\n        case 1:\n            return left.intValue() + right.intValue();\n        case LONG:\n            return left.longValue() + right.longValue();", "refactored_code": "    protected static final int INTEGER = 1;\n\n    protected Number plus(Number left, Number right) {\n        switch (numberType(left, right)) {\n        case INTEGER:\n            return left.intValue() + right.intValue();\n        case LONG:\n            return left.longValue() + right.longValue();"}
{"magic_number_smell": "            }\n        });\n        data.put(\"dynamicTopics\", new LazyCreateContext() {\n            private static final long 6503881346214855588L = 2019166796234979615L;\n\n            @Override\n            protected Object createEntry(String name) {", "refactored_code": "            private static final long serialVersionUID = 6503881346214855588L;\n            }\n        });\n        data.put(\"dynamicTopics\", new LazyCreateContext() {\n            private static final long serialVersionUID = 2019166796234979615L;\n\n            @Override\n            protected Object createEntry(String name) {"}
{"magic_number_smell": "    private WireFormatInfo preferedWireFormatInfo;\n\n    public OpenWireFormat() {\n        this(CommandTypes.PROTOCOL_STORE_VERSION);\n    }\n\n    public OpenWireFormat(int i) {", "refactored_code": "    public static final int DEFAULT_STORE_VERSION = CommandTypes.PROTOCOL_STORE_VERSION;\n    private WireFormatInfo preferedWireFormatInfo;\n\n    public OpenWireFormat() {\n        this(DEFAULT_STORE_VERSION);\n    }\n\n    public OpenWireFormat(int i) {"}
{"magic_number_smell": "    }\n\n    protected String cutMessageIfNeeded(final String message) {\n        return (message.length() > 1024)?\n            message.substring(0, 1024 - 3) + \"...\" : message;\n\n    }", "refactored_code": "    private static final int MAX_EXCEPTION_MESSAGE_SIZE = 1024;\n    }\n\n    protected String cutMessageIfNeeded(final String message) {\n        return (message.length() > MAX_EXCEPTION_MESSAGE_SIZE)?\n            message.substring(0, MAX_EXCEPTION_MESSAGE_SIZE - 3) + \"...\" : message;\n\n    }"}
{"magic_number_smell": "    }\n    \n    protected String cutMessageIfNeeded(final String message) {\n        return (message.length() > 1024)?\n            message.substring(0, 1024 - 3) + \"...\" : message;\n            \n    }", "refactored_code": "    private static final int MAX_EXCEPTION_MESSAGE_SIZE = 1024;\n    }\n    \n    protected String cutMessageIfNeeded(final String message) {\n        return (message.length() > MAX_EXCEPTION_MESSAGE_SIZE)?\n            message.substring(0, MAX_EXCEPTION_MESSAGE_SIZE - 3) + \"...\" : message;\n            \n    }"}
{"magic_number_smell": "                if (eldest.getValue() instanceof Message) {\n                    currentCacheSize -= ((Message)eldest.getValue()).getSize();\n                } else if (eldest.getValue() instanceof MessagePull) {\n                    currentCacheSize -= 400;\n                }\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"removing tracked message: \" + eldest.getKey());", "refactored_code": "    private static final int MESSAGE_PULL_SIZE = 400;\n                if (eldest.getValue() instanceof Message) {\n                    currentCacheSize -= ((Message)eldest.getValue()).getSize();\n                } else if (eldest.getValue() instanceof MessagePull) {\n                    currentCacheSize -= MESSAGE_PULL_SIZE;\n                }\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"removing tracked message: \" + eldest.getKey());"}
{"magic_number_smell": "    }\n\n    public long getCreatedAt() {\n        return System.currentTimeMillis();\n    }\n}\n", "refactored_code": "    private final long createdAt = System.currentTimeMillis();\n    }\n\n    public long getCreatedAt() {\n        return createdAt;\n    }\n}\n"}
{"magic_number_smell": "    private SchedulerTimerTask writeCheckerTask;\n    private SchedulerTimerTask readCheckerTask;\n\n    private long connectAttemptTimeout = 30000;\n    private long readCheckTime = 30000;\n    private long writeCheckTime = 30000;\n    private long initialDelayTime = 30000;", "refactored_code": "    private static final long DEFAULT_CHECK_TIME_MILLS = 30000;\n    private SchedulerTimerTask writeCheckerTask;\n    private SchedulerTimerTask readCheckerTask;\n\n    private long connectAttemptTimeout = DEFAULT_CHECK_TIME_MILLS;\n    private long readCheckTime = DEFAULT_CHECK_TIME_MILLS;\n    private long writeCheckTime = DEFAULT_CHECK_TIME_MILLS;\n    private long initialDelayTime = DEFAULT_CHECK_TIME_MILLS;"}
{"magic_number_smell": "            }\n\n            if (myPort < 0) {\n                myPort = 6155;\n            }\n\n            if (LOG.isTraceEnabled()) {", "refactored_code": "    public static final int    DEFAULT_PORT  = 6155; \n            }\n\n            if (myPort < 0) {\n                myPort = DEFAULT_PORT;\n            }\n\n            if (LOG.isTraceEnabled()) {"}
{"magic_number_smell": "    private final TaskRunnerFactory reconnectTaskFactory;\n    private final TaskRunner reconnectTask;\n    private volatile boolean started;\n    private long initialReconnectDelay = 10;\n    private long maxReconnectDelay = 1000 * 30;\n    private double backOffMultiplier = 2d;\n    private long timeout = INFINITE;", "refactored_code": "    private static final int DEFAULT_INITIAL_RECONNECT_DELAY = 10;\n    private final TaskRunnerFactory reconnectTaskFactory;\n    private final TaskRunner reconnectTask;\n    private volatile boolean started;\n    private long initialReconnectDelay = DEFAULT_INITIAL_RECONNECT_DELAY;\n    private long maxReconnectDelay = 1000 * 30;\n    private double backOffMultiplier = 2d;\n    private long timeout = INFINITE;"}
{"magic_number_smell": "    private int mcastPort;\n    private int timeToLive = 1;\n    private boolean loopBackMode;\n    private long keepAliveInterval = 5000;\n\n    public MulticastTransport(OpenWireFormat wireFormat, URI remoteLocation) throws UnknownHostException, IOException {\n        super(wireFormat, remoteLocation);", "refactored_code": "    private static final int DEFAULT_IDLE_TIME = 5000;\n    private int mcastPort;\n    private int timeToLive = 1;\n    private boolean loopBackMode;\n    private long keepAliveInterval = DEFAULT_IDLE_TIME;\n\n    public MulticastTransport(OpenWireFormat wireFormat, URI remoteLocation) throws UnknownHostException, IOException {\n        super(wireFormat, remoteLocation);"}
{"magic_number_smell": "     *        the channel to write data to.\n     */\n    public NIOOutputStream(WritableByteChannel out) {\n        this(out, 8196);\n    }\n\n    /**", "refactored_code": "    private static final int BUFFER_SIZE = 8196;\n     *        the channel to write data to.\n     */\n    public NIOOutputStream(WritableByteChannel out) {\n        this(out, BUFFER_SIZE);\n    }\n\n    /**"}
{"magic_number_smell": "        } else {\n            try {\n                intValue = Integer.parseInt(value);\n                if (intValue > 63 || intValue < MIN_DIFF_SERV) {\n                    throw new IllegalArgumentException(\"Differentiated Services\"\n                        + \" value: \" + intValue + \" not in legal range [\"\n                        + MIN_DIFF_SERV + \", \" + 63 + \"].\");", "refactored_code": "    private static final int MAX_DIFF_SERV = 63;\n        } else {\n            try {\n                intValue = Integer.parseInt(value);\n                if (intValue > MAX_DIFF_SERV || intValue < MIN_DIFF_SERV) {\n                    throw new IllegalArgumentException(\"Differentiated Services\"\n                        + \" value: \" + intValue + \" not in legal range [\"\n                        + MIN_DIFF_SERV + \", \" + MAX_DIFF_SERV + \"].\");"}
{"magic_number_smell": "    protected int position;\n\n    public TcpBufferedInputStream(InputStream in) {\n        this(in, 8192);\n    }\n\n    public TcpBufferedInputStream(InputStream in, int size) {", "refactored_code": "    private static final int DEFAULT_BUFFER_SIZE = 8192;\n    protected int position;\n\n    public TcpBufferedInputStream(InputStream in) {\n        this(in, DEFAULT_BUFFER_SIZE);\n    }\n\n    public TcpBufferedInputStream(InputStream in, int size) {"}
{"magic_number_smell": "     * @param out\n     */\n    public TcpBufferedOutputStream(OutputStream out) {\n        this(out, 8192);\n    }\n\n    /**", "refactored_code": "    private static final int BUFFER_SIZE = 8192;\n     * @param out\n     */\n    public TcpBufferedOutputStream(OutputStream out) {\n        this(out, BUFFER_SIZE);\n    }\n\n    /**"}
{"magic_number_smell": "        // a previously bound socket, it can take a little while before we can\n        // bind it again.\n        //\n        for (int i = 0; i < 50; i++) {\n            try {\n                socket.bind(localAddress);\n                return;", "refactored_code": "    private static final int MAX_BIND_ATTEMPTS = 50;\n        // a previously bound socket, it can take a little while before we can\n        // bind it again.\n        //\n        for (int i = 0; i < MAX_BIND_ATTEMPTS; i++) {\n            try {\n                socket.bind(localAddress);\n                return;"}
{"magic_number_smell": "     * Creates a new byte array output stream.\n     */\n    public DataByteArrayOutputStream() {\n        this(2048);\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_SIZE = 2048;\n     * Creates a new byte array output stream.\n     */\n    public DataByteArrayOutputStream() {\n        this(DEFAULT_SIZE);\n    }\n\n    /**"}
{"magic_number_smell": "    }\n\n    private static long rot(long val, int pos) {\n        return ((Integer.rotateLeft((int) (val & 0x00000000ffffffffL), pos)) & 0x00000000ffffffffL);\n    }\n\n    /**", "refactored_code": "    private static final long INT_MASK = 0x00000000ffffffffL;\n    }\n\n    private static long rot(long val, int pos) {\n        return ((Integer.rotateLeft((int) (val & INT_MASK), pos)) & INT_MASK);\n    }\n\n    /**"}
{"magic_number_smell": "        case LIST_TYPE:\n            value = unmarshalPrimitiveList(in, true);\n            break;\n        case 0:\n            value = null;\n            break;\n        default:", "refactored_code": "    public static final byte NULL = 0;\n        case LIST_TYPE:\n            value = unmarshalPrimitiveList(in, true);\n            break;\n        case NULL:\n            value = null;\n            break;\n        default:"}
{"magic_number_smell": "     * if the await termination timeout was hit.\n     * <p/>\n     * This implementation invokes the {@link #shutdownGraceful(java.util.concurrent.ExecutorService, long)}\n     * with a timeout value of {@link #10 * 1000L} millis.\n     */\n    public static void shutdownGraceful(ExecutorService executorService) {\n        doShutdown(executorService, 10 * 1000L);", "refactored_code": "    public static final long DEFAULT_SHUTDOWN_AWAIT_TERMINATION = 10 * 1000L;\n     * if the await termination timeout was hit.\n     * <p/>\n     * This implementation invokes the {@link #shutdownGraceful(java.util.concurrent.ExecutorService, long)}\n     * with a timeout value of {@link #DEFAULT_SHUTDOWN_AWAIT_TERMINATION} millis.\n     */\n    public static void shutdownGraceful(ExecutorService executorService) {\n        doShutdown(executorService, DEFAULT_SHUTDOWN_AWAIT_TERMINATION);"}
{"magic_number_smell": "        char[] message = new char[2056];\n        Arrays.fill(message, '1');\n        String cutMessage = (new WireFormatInfoMarshaller()).cutMessageIfNeeded(String.valueOf(message));\n        assertEquals(\"Expected length \" + 1024, 1024, cutMessage.length());\n        assertTrue(\"Expected message tail ...\", cutMessage.endsWith(\"...\"));\n    }\n}", "refactored_code": "    private static final int MAX_MESSAGE_LENGTH = 1024;\n        char[] message = new char[2056];\n        Arrays.fill(message, '1');\n        String cutMessage = (new WireFormatInfoMarshaller()).cutMessageIfNeeded(String.valueOf(message));\n        assertEquals(\"Expected length \" + MAX_MESSAGE_LENGTH, MAX_MESSAGE_LENGTH, cutMessage.length());\n        assertTrue(\"Expected message tail ...\", cutMessage.endsWith(\"...\"));\n    }\n}"}
{"magic_number_smell": "        char[] message = new char[2056];\n        Arrays.fill(message, '1');\n        String cutMessage = (new WireFormatInfoMarshaller()).cutMessageIfNeeded(String.valueOf(message));\n        assertEquals(\"Expected length \" + 1024, 1024, cutMessage.length());\n        assertTrue(\"Expected message tail ...\", cutMessage.endsWith(\"...\"));\n    }\n}", "refactored_code": "    private static final int MAX_MESSAGE_LENGTH = 1024;\n        char[] message = new char[2056];\n        Arrays.fill(message, '1');\n        String cutMessage = (new WireFormatInfoMarshaller()).cutMessageIfNeeded(String.valueOf(message));\n        assertEquals(\"Expected length \" + MAX_MESSAGE_LENGTH, MAX_MESSAGE_LENGTH, cutMessage.length());\n        assertTrue(\"Expected message tail ...\", cutMessage.endsWith(\"...\"));\n    }\n}"}
{"magic_number_smell": "        // have to be since the object references us and is used\n        // during the serialization.\n        payload = new SimplePojo(simplePojoPayload) {\n            private static final long 1L = 1L;\n        };\n    }\n", "refactored_code": "    private static final long serialVersionUID = 1L;\n        // have to be since the object references us and is used\n        // during the serialization.\n        payload = new SimplePojo(simplePojoPayload) {\n            private static final long serialVersionUID = 1L;\n        };\n    }\n"}
{"magic_number_smell": "        // during the serialization.\n\n        class LocalSimplPojo extends SimplePojo {\n            private static final long 1L = 1L;\n\n            LocalSimplPojo(Object simplePojoPayload) {\n                super(simplePojoPayload);", "refactored_code": "    private static final long serialVersionUID = 1L;\n        // during the serialization.\n\n        class LocalSimplPojo extends SimplePojo {\n            private static final long serialVersionUID = 1L;\n\n            LocalSimplPojo(Object simplePojoPayload) {\n                super(simplePojoPayload);"}
{"magic_number_smell": "\n        String user = System.getProperty(\"user.name\", \"\");\n\n        if (user.length() > 31) {\n            user = user.substring(0, 31);\n        }\n", "refactored_code": "    public static final int MAX_NAMELEN = 31;\n\n        String user = System.getProperty(\"user.name\", \"\");\n\n        if (user.length() > MAX_NAMELEN) {\n            user = user.substring(0, MAX_NAMELEN);\n        }\n"}
{"magic_number_smell": "        if (currEntry != null && currEntry.isGNULongNameEntry()) {\n            // read in the name\n            StringBuffer longName = new StringBuffer();\n            byte[] buf = new byte[256];\n            int length = 0;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));", "refactored_code": "    private static final int SMALL_BUFFER_SIZE = 256;\n        if (currEntry != null && currEntry.isGNULongNameEntry()) {\n            // read in the name\n            StringBuffer longName = new StringBuffer();\n            byte[] buf = new byte[SMALL_BUFFER_SIZE];\n            int length = 0;\n            while ((length = read(buf)) >= 0) {\n                longName.append(new String(buf, 0, length));"}
{"magic_number_smell": "    protected int       assemLen;\n    protected byte[]    assemBuf;\n    protected TarBuffer buffer;\n    protected int       longFileMode = 0;\n    // CheckStyle:VisibilityModifier ON\n\n    private boolean closed = false;", "refactored_code": "    public static final int LONGFILE_ERROR = 0;\n    protected int       assemLen;\n    protected byte[]    assemBuf;\n    protected TarBuffer buffer;\n    protected int       longFileMode = LONGFILE_ERROR;\n    // CheckStyle:VisibilityModifier ON\n\n    private boolean closed = false;"}
{"magic_number_smell": "        long sum = 0;\n\n        for (int i = 0; i < buf.length; ++i) {\n            sum += 255 & buf[i];\n        }\n\n        return sum;", "refactored_code": "    private static final int BYTE_MASK = 255;\n        long sum = 0;\n\n        for (int i = 0; i < buf.length; ++i) {\n            sum += BYTE_MASK & buf[i];\n        }\n\n        return sum;"}
{"magic_number_smell": "    @Override\n    public void oneway(Object command) throws IOException {\n        try {\n            boolean success = queue.offer(command, 30000L, TimeUnit.MILLISECONDS);\n            if (!success) {\n                throw new IOException(\"Fail to add to BlockingQueue. Add timed out after \" + 30000L + \"ms: size=\" + queue.size());\n            }", "refactored_code": "    public static final long MAX_TIMEOUT = 30000L;\n    @Override\n    public void oneway(Object command) throws IOException {\n        try {\n            boolean success = queue.offer(command, MAX_TIMEOUT, TimeUnit.MILLISECONDS);\n            if (!success) {\n                throw new IOException(\"Fail to add to BlockingQueue. Add timed out after \" + MAX_TIMEOUT + \"ms: size=\" + queue.size());\n            }"}
{"magic_number_smell": "    private HttpGet httpMethod;\n    private volatile int receiveCounter;\n\n    private int soTimeout = 90000;\n\n    private boolean useCompression = false;\n    protected boolean canSendCompressed = false;", "refactored_code": "    public static final int MAX_CLIENT_TIMEOUT = 90000;\n    private HttpGet httpMethod;\n    private volatile int receiveCounter;\n\n    private int soTimeout = MAX_CLIENT_TIMEOUT;\n\n    private boolean useCompression = false;\n    protected boolean canSendCompressed = false;"}
{"magic_number_smell": "    public int getProxyPort() {\n        return proxyPort != null ? proxyPort\n                : (getSystemProperty(PROPERTY_PROXY_PORT) != null\n                        ? Integer.parseInt(getSystemProperty(PROPERTY_PROXY_PORT)) : 8080);\n    }\n\n    public void setProxyPort(int proxyPort) {", "refactored_code": "    private static final int DEFAULT_PROXY_PORT = 8080;\n    public int getProxyPort() {\n        return proxyPort != null ? proxyPort\n                : (getSystemProperty(PROPERTY_PROXY_PORT) != null\n                        ? Integer.parseInt(getSystemProperty(PROPERTY_PROXY_PORT)) : DEFAULT_PROXY_PORT);\n    }\n\n    public void setProxyPort(int proxyPort) {"}
{"magic_number_smell": "    @Override\n    public void onWebSocketClose(int statusCode, String reason) {\n        try {\n            if (protocolLock.tryLock() || protocolLock.tryLock(10, TimeUnit.SECONDS)) {\n                LOG.debug(\"WebSocket closed: code[{}] message[{}]\", statusCode, reason);\n                wsTransport.onWebSocketClosed();\n            }", "refactored_code": "    private final int ORDERLY_CLOSE_TIMEOUT = 10;\n    @Override\n    public void onWebSocketClose(int statusCode, String reason) {\n        try {\n            if (protocolLock.tryLock() || protocolLock.tryLock(ORDERLY_CLOSE_TIMEOUT, TimeUnit.SECONDS)) {\n                LOG.debug(\"WebSocket closed: code[{}] message[{}]\", statusCode, reason);\n                wsTransport.onWebSocketClosed();\n            }"}
{"magic_number_smell": "    @Override\n    public void onWebSocketClose(int arg0, String arg1) {\n        try {\n            if (protocolLock.tryLock() || protocolLock.tryLock(10, TimeUnit.SECONDS)) {\n                LOG.debug(\"MQTT WebSocket closed: code[{}] message[{}]\", arg0, arg1);\n                //Check if we received a disconnect packet before closing\n                if (!receivedDisconnect.get()) {", "refactored_code": "    private final int ORDERLY_CLOSE_TIMEOUT = 10;\n    @Override\n    public void onWebSocketClose(int arg0, String arg1) {\n        try {\n            if (protocolLock.tryLock() || protocolLock.tryLock(ORDERLY_CLOSE_TIMEOUT, TimeUnit.SECONDS)) {\n                LOG.debug(\"MQTT WebSocket closed: code[{}] message[{}]\", arg0, arg1);\n                //Check if we received a disconnect packet before closing\n                if (!receivedDisconnect.get()) {"}
{"magic_number_smell": "    @Override\n    public void onWebSocketClose(int arg0, String arg1) {\n        try {\n            if (protocolLock.tryLock() || protocolLock.tryLock(10, TimeUnit.SECONDS)) {\n                LOG.debug(\"Stomp WebSocket closed: code[{}] message[{}]\", arg0, arg1);\n                protocolConverter.onStompCommand(new StompFrame(Stomp.Commands.DISCONNECT));\n            }", "refactored_code": "    private final int ORDERLY_CLOSE_TIMEOUT = 10;\n    @Override\n    public void onWebSocketClose(int arg0, String arg1) {\n        try {\n            if (protocolLock.tryLock() || protocolLock.tryLock(ORDERLY_CLOSE_TIMEOUT, TimeUnit.SECONDS)) {\n                LOG.debug(\"Stomp WebSocket closed: code[{}] message[{}]\", arg0, arg1);\n                protocolConverter.onStompCommand(new StompFrame(Stomp.Commands.DISCONNECT));\n            }"}
{"magic_number_smell": "\n    @Override\n    protected String getWSConnectorURI() {\n        return \"ws://127.0.0.1:\" + 61623 + \"?websocket.maxTextMessageSize=99999&transport.maxIdleTime=1001\";\n    }\n\n    protected Server createWebServer() throws Exception {", "refactored_code": "    protected final int port = 61623;\n\n    @Override\n    protected String getWSConnectorURI() {\n        return \"ws://127.0.0.1:\" + port + \"?websocket.maxTextMessageSize=99999&transport.maxIdleTime=1001\";\n    }\n\n    protected Server createWebServer() throws Exception {"}
{"magic_number_smell": "    protected final HashMap<ActiveMQDestination, MessageStore> storeCache = new HashMap<>();\n\n    {\n        setLockKeepAlivePeriod(30 * 1000);\n    }\n\n    public JDBCPersistenceAdapter() {", "refactored_code": "    public static final long DEFAULT_LOCK_KEEP_ALIVE_PERIOD = 30 * 1000;\n    protected final HashMap<ActiveMQDestination, MessageStore> storeCache = new HashMap<>();\n\n    {\n        setLockKeepAlivePeriod(DEFAULT_LOCK_KEEP_ALIVE_PERIOD);\n    }\n\n    public JDBCPersistenceAdapter() {"}
{"magic_number_smell": "    //This is deprecated and should be removed in a future release\n    protected boolean batchStatments = true;\n    protected boolean prioritizedMessages;\n    protected int maxRows = org.apache.activemq.ActiveMQPrefetchPolicy.MAX_PREFETCH_SIZE;\n\n    protected void setBinaryData(PreparedStatement s, int index, byte data[]) throws SQLException {\n        s.setBytes(index, data);", "refactored_code": "    public static final int MAX_ROWS = org.apache.activemq.ActiveMQPrefetchPolicy.MAX_PREFETCH_SIZE;\n    //This is deprecated and should be removed in a future release\n    protected boolean batchStatments = true;\n    protected boolean prioritizedMessages;\n    protected int maxRows = MAX_ROWS;\n\n    protected void setBinaryData(PreparedStatement s, int index, byte data[]) throws SQLException {\n        s.setBytes(index, data);"}
{"magic_number_smell": "        when(connection.getAutoCommit()).thenReturn(true);\n\n        when(resultSet.next()).thenReturn(false);\n        when(statement2.execute(CREATE_STATEMENT2)).thenThrow(new SQLException(MY_REASON, SQL_STATE, 1));\n\n        defaultJDBCAdapter.doCreateTables(transactionContext);\n", "refactored_code": "    private static final int VENDOR_CODE = 1;\n        when(connection.getAutoCommit()).thenReturn(true);\n\n        when(resultSet.next()).thenReturn(false);\n        when(statement2.execute(CREATE_STATEMENT2)).thenThrow(new SQLException(MY_REASON, SQL_STATE, VENDOR_CODE));\n\n        defaultJDBCAdapter.doCreateTables(transactionContext);\n"}
{"magic_number_smell": "        when(connection.getAutoCommit()).thenReturn(true);\n\n        when(resultSet.next()).thenReturn(true);\n        when(statement1.execute(CREATE_STATEMENT1)).thenThrow(new SQLException(MY_REASON, SQL_STATE, 1));\n\n        defaultJDBCAdapter.doCreateTables(transactionContext);\n", "refactored_code": "    private static final int VENDOR_CODE = 1;\n        when(connection.getAutoCommit()).thenReturn(true);\n\n        when(resultSet.next()).thenReturn(true);\n        when(statement1.execute(CREATE_STATEMENT1)).thenThrow(new SQLException(MY_REASON, SQL_STATE, VENDOR_CODE));\n\n        defaultJDBCAdapter.doCreateTables(transactionContext);\n"}
{"magic_number_smell": "            }\n        }\n\n        if (expiryTimeout > 0 && (lastUsed + expiryTimeout) - System.currentTimeMillis() < 0) {\n            hasExpired = true;\n            if (referenceCount == 0) {\n                close();", "refactored_code": "    private final long firstUsed = lastUsed;\n            }\n        }\n\n        if (expiryTimeout > 0 && (firstUsed + expiryTimeout) - System.currentTimeMillis() < 0) {\n            hasExpired = true;\n            if (referenceCount == 0) {\n                close();"}
{"magic_number_smell": "\n        Session session = directConn1.createSession(false, Session.AUTO_ACKNOWLEDGE);\n        MessageProducer producer = session.createProducer(queue);\n        for (int i = 0; i < 50; ++i) {\n            producer.send(session.createTextMessage(\"Test Message: \" + i));\n        }\n        producer.close();", "refactored_code": "    private final int MESSAGE_COUNT = 50;\n\n        Session session = directConn1.createSession(false, Session.AUTO_ACKNOWLEDGE);\n        MessageProducer producer = session.createProducer(queue);\n        for (int i = 0; i < MESSAGE_COUNT; ++i) {\n            producer.send(session.createTextMessage(\"Test Message: \" + i));\n        }\n        producer.close();"}
{"magic_number_smell": "    }\n\n    public void sendMessages(ConnectionFactory connectionFactory) throws Exception {\n        for (int i = 0; i < 500; i++) {\n            Connection connection = connectionFactory.createConnection();\n            connection.start();\n", "refactored_code": "    private static final int NUM_MESSAGES = 500;\n    }\n\n    public void sendMessages(ConnectionFactory connectionFactory) throws Exception {\n        for (int i = 0; i < NUM_MESSAGES; i++) {\n            Connection connection = connectionFactory.createConnection();\n            connection.start();\n"}
{"magic_number_smell": "    }\n\n    public void sendMessages(ConnectionFactory connectionFactory) throws Exception {\n        for (int i = 0; i < 500; i++) {\n            Connection connection = connectionFactory.createConnection();\n            connection.start();\n", "refactored_code": "    private static final int NUM_MESSAGES = 500;\n    }\n\n    public void sendMessages(ConnectionFactory connectionFactory) throws Exception {\n        for (int i = 0; i < NUM_MESSAGES; i++) {\n            Connection connection = connectionFactory.createConnection();\n            connection.start();\n"}
{"magic_number_smell": "                process(command, location);\n\n                long end = System.currentTimeMillis();\n                if (Integer.getInteger(PROPERTY_LOG_SLOW_ACCESS_TIME, 0) > 0 && end - start > Integer.getInteger(PROPERTY_LOG_SLOW_ACCESS_TIME, 0)) {\n                    LOG.info(\"Slow KahaDB access: Journal append took: {} ms, Index update took {} ms\",\n                             (start2-start), (end-start2));\n                }", "refactored_code": "    public static final int LOG_SLOW_ACCESS_TIME = Integer.getInteger(PROPERTY_LOG_SLOW_ACCESS_TIME, 0);\n                process(command, location);\n\n                long end = System.currentTimeMillis();\n                if (LOG_SLOW_ACCESS_TIME > 0 && end - start > LOG_SLOW_ACCESS_TIME) {\n                    LOG.info(\"Slow KahaDB access: Journal append took: {} ms, Index update took {} ms\",\n                             (start2-start), (end-start2));\n                }"}
{"magic_number_smell": "    // when true, message order may be compromised when cache is exhausted if store is out\n    // or order w.r.t cache\n    private boolean concurrentStoreAndDispatchTopics = false;\n    private int maxAsyncJobs = BaseDestination.MAX_AUDIT_DEPTH;\n    private final KahaDBTransactionStore transactionStore;\n    private TransactionIdTransformer transactionIdTransformer;\n", "refactored_code": "    private static final int MAX_ASYNC_JOBS = BaseDestination.MAX_AUDIT_DEPTH;\n    // when true, message order may be compromised when cache is exhausted if store is out\n    // or order w.r.t cache\n    private boolean concurrentStoreAndDispatchTopics = false;\n    private int maxAsyncJobs = MAX_ASYNC_JOBS;\n    private final KahaDBTransactionStore transactionStore;\n    private TransactionIdTransformer transactionIdTransformer;\n"}
{"magic_number_smell": "        }\n        checkpointUpdate(cleanup);\n        long totalTimeMillis = System.currentTimeMillis() - start;\n        if (Integer.getInteger(PROPERTY_LOG_SLOW_ACCESS_TIME, 0) > 0 && totalTimeMillis > Integer.getInteger(PROPERTY_LOG_SLOW_ACCESS_TIME, 0)) {\n            if (LOG.isInfoEnabled()) {\n                LOG.info(\"Slow KahaDB access: cleanup took \" + totalTimeMillis);\n            }", "refactored_code": "    public static final int LOG_SLOW_ACCESS_TIME = Integer.getInteger(PROPERTY_LOG_SLOW_ACCESS_TIME, 0);\n        }\n        checkpointUpdate(cleanup);\n        long totalTimeMillis = System.currentTimeMillis() - start;\n        if (LOG_SLOW_ACCESS_TIME > 0 && totalTimeMillis > LOG_SLOW_ACCESS_TIME) {\n            if (LOG.isInfoEnabled()) {\n                LOG.info(\"Slow KahaDB access: cleanup took \" + totalTimeMillis);\n            }"}
{"magic_number_smell": "\n    public synchronized void unload(Transaction tx) throws IOException {\n        if (loaded.compareAndSet(true, false)) {\n            metadata.state = 1;\n            tx.store(metadata.page, metadataMarshaller, true);\n        }\n    }", "refactored_code": "    public static final int CLOSED_STATE = 1;\n\n    public synchronized void unload(Transaction tx) throws IOException {\n        if (loaded.compareAndSet(true, false)) {\n            metadata.state = CLOSED_STATE;\n            tx.store(metadata.page, metadataMarshaller, true);\n        }\n    }"}
{"magic_number_smell": "                }\n                break;\n                case CHUNKED_ZEROS: {\n                    preAllocateDirectBuffer = allocateDirectBuffer(1024*1024);\n                }\n                break;\n                case ZEROS: {", "refactored_code": "    private static final int PREALLOC_CHUNK_SIZE = 1024*1024;\n                }\n                break;\n                case CHUNKED_ZEROS: {\n                    preAllocateDirectBuffer = allocateDirectBuffer(PREALLOC_CHUNK_SIZE);\n                }\n                break;\n                case ZEROS: {"}
{"magic_number_smell": "    private RecoverableRandomAccessFile recoveryFile;\n\n    // The size of pages\n    private int pageSize = Integer.getInteger(\"defaultPageSize\", 1024*4);\n\n    // The minimum number of space allocated to the recovery file in number of pages.\n    private int recoveryFileMinPageCount = 1000;", "refactored_code": "    public static final int DEFAULT_PAGE_SIZE = Integer.getInteger(\"defaultPageSize\", 1024*4);\n    private RecoverableRandomAccessFile recoveryFile;\n\n    // The size of pages\n    private int pageSize = DEFAULT_PAGE_SIZE;\n\n    // The minimum number of space allocated to the recovery file in number of pages.\n    private int recoveryFileMinPageCount = 1000;"}
{"magic_number_smell": "     * with an invalid page id.\n     */\n    public class InvalidPageIOException extends IOException {\n        private static final long 1L = 1L;\n\n        private final long page;\n", "refactored_code": "        private static final long serialVersionUID = 1L;\n     * with an invalid page id.\n     */\n    public class InvalidPageIOException extends IOException {\n        private static final long serialVersionUID = 1L;\n\n        private final long page;\n"}
{"magic_number_smell": "     * Creates a new byte array output stream.\n     */\n    public DataByteArrayOutputStream() {\n        this(PageFile.DEFAULT_PAGE_SIZE);\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_SIZE = PageFile.DEFAULT_PAGE_SIZE;\n     * Creates a new byte array output stream.\n     */\n    public DataByteArrayOutputStream() {\n        this(DEFAULT_SIZE);\n    }\n\n    /**"}
{"magic_number_smell": "                        break;\n                    } catch (IOException e) {\n                        LOG.info(\"Database \" + lockFileName + \" is locked... waiting \"\n                                + (10 * 1000 / 1000)\n                                + \" seconds for the database to be unlocked. Reason: \" + e);\n                        try {\n                            Thread.sleep(10 * 1000);", "refactored_code": "    private static final int DATABASE_LOCKED_WAIT_DELAY = 10 * 1000;\n                        break;\n                    } catch (IOException e) {\n                        LOG.info(\"Database \" + lockFileName + \" is locked... waiting \"\n                                + (DATABASE_LOCKED_WAIT_DELAY / 1000)\n                                + \" seconds for the database to be unlocked. Reason: \" + e);\n                        try {\n                            Thread.sleep(DATABASE_LOCKED_WAIT_DELAY);"}
{"magic_number_smell": "        private final int 500 = 500;\n        private final int DEFAULT_NEW_JOB_WAIT = 100;\n        private boolean newJob;\n        private long waitTime = 500;\n        private final Object mutex = new Object();\n\n        /**", "refactored_code": "        private final int DEFAULT_WAIT = 500;\n        private final int DEFAULT_WAIT = 500;\n        private final int DEFAULT_NEW_JOB_WAIT = 100;\n        private boolean newJob;\n        private long waitTime = DEFAULT_WAIT;\n        private final Object mutex = new Object();\n\n        /**"}
{"magic_number_smell": "                        lockFile.lock();\n                        break;\n                    } catch (IOException e) {\n                        LOG.info(\"Database \" + lockFileName + \" is locked... waiting \" + (10 * 1000 / 1000)\n                            + \" seconds for the database to be unlocked. Reason: \" + e);\n                        try {\n                            Thread.sleep(10 * 1000);", "refactored_code": "    private static final int DATABASE_LOCKED_WAIT_DELAY = 10 * 1000;\n                        lockFile.lock();\n                        break;\n                    } catch (IOException e) {\n                        LOG.info(\"Database \" + lockFileName + \" is locked... waiting \" + (DATABASE_LOCKED_WAIT_DELAY / 1000)\n                            + \" seconds for the database to be unlocked. Reason: \" + e);\n                        try {\n                            Thread.sleep(DATABASE_LOCKED_WAIT_DELAY);"}
{"magic_number_smell": "\n        MessageProducer producer = session.createProducer(topic);\n        producer.setPriority(9);\n        for (int i = 0; i < 10; i++) {\n            Message msg = session.createTextMessage(\"test message:\" + i);\n            producer.send(msg);\n        }", "refactored_code": "    private final int NUM_MESSAGES = 10;\n\n        MessageProducer producer = session.createProducer(topic);\n        producer.setPriority(9);\n        for (int i = 0; i < NUM_MESSAGES; i++) {\n            Message msg = session.createTextMessage(\"test message:\" + i);\n            producer.send(msg);\n        }"}
{"magic_number_smell": "    // Slower machines might need to make this bigger.\n    private static final long Integer.parseInt(System.getProperty(\"SAMPLES_DURATION\", \"\" + 1000 * 5)) = Integer.parseInt(System.getProperty(\"SAMPLES_DURATION\", \"\" + 1000 * 5));\n    // How many times do we sample?\n    private static final long SAMPLES = Integer.parseInt(System.getProperty(\"SAMPLES\", \"\" + 60 * 1000 / Integer.parseInt(System.getProperty(\"SAMPLES_DURATION\", \"\" + 1000 * 5))));\n    // How many indexes will we be benchmarking concurrently?\n    private static final int INDEX_COUNT = Integer.parseInt(System.getProperty(\"INDEX_COUNT\", \"\" + 1));\n    // Indexes tend to perform worse when they get big.. so how many items", "refactored_code": "    private static final long SAMPLE_DURATION = Integer.parseInt(System.getProperty(\"SAMPLES_DURATION\", \"\" + 1000 * 5));\n    // Slower machines might need to make this bigger.\n    private static final long SAMPLE_DURATION = Integer.parseInt(System.getProperty(\"SAMPLES_DURATION\", \"\" + 1000 * 5));\n    // How many times do we sample?\n    private static final long SAMPLES = Integer.parseInt(System.getProperty(\"SAMPLES\", \"\" + 60 * 1000 / SAMPLE_DURATION));\n    // How many indexes will we be benchmarking concurrently?\n    private static final int INDEX_COUNT = Integer.parseInt(System.getProperty(\"INDEX_COUNT\", \"\" + 1));\n    // Indexes tend to perform worse when they get big.. so how many items"}
{"magic_number_smell": "        createPageFileAndIndex(500);\n        this.index.load(tx);\n        tx.commit();\n        doInsert(10000);\n        this.index.unload(tx);\n        tx.commit();\n        this.index.load(tx);", "refactored_code": "    private static final int COUNT = 10000;\n        createPageFileAndIndex(500);\n        this.index.load(tx);\n        tx.commit();\n        doInsert(COUNT);\n        this.index.unload(tx);\n        tx.commit();\n        this.index.load(tx);"}
{"magic_number_smell": "                latch.countDown();\n            }\n        };\n        int messageSize = 1024 * 1024 * 4 / iterations;\n        byte[] message = new byte[messageSize];\n        ByteSequence data = new ByteSequence(message);\n", "refactored_code": "    protected static final int DEFAULT_MAX_BATCH_SIZE = 1024 * 1024 * 4;\n                latch.countDown();\n            }\n        };\n        int messageSize = DEFAULT_MAX_BATCH_SIZE / iterations;\n        byte[] message = new byte[messageSize];\n        ByteSequence data = new ByteSequence(message);\n"}
{"magic_number_smell": "    }\n\n    public static boolean withinReason(Callable<Boolean> callable) throws Exception {\n        long max = System.currentTimeMillis() + 30000L;\n        while (true) {\n            try {\n                return callable.call();", "refactored_code": "    public static final long ASSERTION_TIMEOUT = 30000L;\n    }\n\n    public static boolean withinReason(Callable<Boolean> callable) throws Exception {\n        long max = System.currentTimeMillis() + ASSERTION_TIMEOUT;\n        while (true) {\n            try {\n                return callable.call();"}
{"magic_number_smell": "    }\n\n    public static String executeCommand(SessionFactory sessionFactory, final String command) {\n        return executeCommand(sessionFactory, command, 30000L, false);\n    }\n}\n", "refactored_code": "    public static final long COMMAND_TIMEOUT = 30000L;\n    }\n\n    public static String executeCommand(SessionFactory sessionFactory, final String command) {\n        return executeCommand(sessionFactory, command, COMMAND_TIMEOUT, false);\n    }\n}\n"}
{"magic_number_smell": "    private final ReentrantLock sendLock = new ReentrantLock();\n    private SchedulerTimerTask readCheckerTask;\n\n    private long readGraceTime = 30000;\n    private long readKeepAliveTime = 30000;\n    private MQTTProtocolConverter protocolConverter;\n", "refactored_code": "    private static final long DEFAULT_CHECK_TIME_MILLS = 30000;\n    private final ReentrantLock sendLock = new ReentrantLock();\n    private SchedulerTimerTask readCheckerTask;\n\n    private long readGraceTime = DEFAULT_CHECK_TIME_MILLS;\n    private long readKeepAliveTime = DEFAULT_CHECK_TIME_MILLS;\n    private MQTTProtocolConverter protocolConverter;\n"}
{"magic_number_smell": "        String passswd = null;\n        if (connect.password() != null) {\n\n            if (userName == null && connect.version() != 3) {\n                // [MQTT-3.1.2-22]: If the user name is not present then the\n                // password must also be absent.\n                // [MQTT-3.1.4-1]: would seem to imply we don't send a CONNACK here.", "refactored_code": "    public static final int V3_1 = 3;\n        String passswd = null;\n        if (connect.password() != null) {\n\n            if (userName == null && connect.version() != V3_1) {\n                // [MQTT-3.1.2-22]: If the user name is not present then the\n                // password must also be absent.\n                // [MQTT-3.1.4-1]: would seem to imply we don't send a CONNACK here."}
{"magic_number_smell": "\n        // Spec: Unless stated otherwise all UTF-8 encoded strings can have any length in\n        //       the range 0 to 65535 bytes.\n        if (topicLen < 1 || topicLen > TOPIC_NAME_MAX_LENGTH) {\n            throw new MQTTProtocolException(\"Topic name given had invliad length.\");\n        }\n", "refactored_code": "    private static final int TOPIC_NAME_MIN_LENGTH = 1;\n\n        // Spec: Unless stated otherwise all UTF-8 encoded strings can have any length in\n        //       the range 0 to 65535 bytes.\n        if (topicLen < TOPIC_NAME_MIN_LENGTH || topicLen > TOPIC_NAME_MAX_LENGTH) {\n            throw new MQTTProtocolException(\"Topic name given had invliad length.\");\n        }\n"}
{"magic_number_smell": "    @Test\n    public void testMessageDecoding() throws Exception {\n\n        byte[] CONTENTS = new byte[5 * 1024 * 1024];\n        for (int i = 0; i < 5 * 1024 * 1024; i++) {\n            CONTENTS[i] = 'a';\n        }", "refactored_code": "    private final int MESSAGE_SIZE = 5 * 1024 * 1024;\n    @Test\n    public void testMessageDecoding() throws Exception {\n\n        byte[] CONTENTS = new byte[MESSAGE_SIZE];\n        for (int i = 0; i < MESSAGE_SIZE; i++) {\n            CONTENTS[i] = 'a';\n        }"}
{"magic_number_smell": "        assertFalse(message.getBooleanProperty(RetainedMessageSubscriptionRecoveryPolicy.RETAIN_PROPERTY));\n        assertTrue(message.getBooleanProperty(RetainedMessageSubscriptionRecoveryPolicy.RETAINED_PROPERTY));\n\n        for (int i = 0; i < 25; i++) {\n            String payload = \"Test Message: \" + i;\n            provider.publish(MQTT_TOPIC, payload.getBytes(), AT_LEAST_ONCE);\n", "refactored_code": "    private static final int NUM_MESSAGES = 25;\n        assertFalse(message.getBooleanProperty(RetainedMessageSubscriptionRecoveryPolicy.RETAIN_PROPERTY));\n        assertTrue(message.getBooleanProperty(RetainedMessageSubscriptionRecoveryPolicy.RETAINED_PROPERTY));\n\n        for (int i = 0; i < NUM_MESSAGES; i++) {\n            String payload = \"Test Message: \" + i;\n            provider.publish(MQTT_TOPIC, payload.getBytes(), AT_LEAST_ONCE);\n"}
{"magic_number_smell": "\n        subscriptionProvider.subscribe(\"foo/bah\", AT_MOST_ONCE);\n\n        final CountDownLatch latch = new CountDownLatch(200);\n\n        Thread thread = new Thread(new Runnable() {\n            @Override", "refactored_code": "    private static final int NUM_MESSAGES = 200;\n\n        subscriptionProvider.subscribe(\"foo/bah\", AT_MOST_ONCE);\n\n        final CountDownLatch latch = new CountDownLatch(NUM_MESSAGES);\n\n        Thread thread = new Thread(new Runnable() {\n            @Override"}
{"magic_number_smell": "        } else if (DUPS_OK_ACKNOWLEDGE_MODE.equals(acknowledgeMode)) {\n            return Session.DUPS_OK_ACKNOWLEDGE;\n        } else {\n            return -1;\n        }\n    }\n", "refactored_code": "    public static final int INVALID_ACKNOWLEDGE_MODE = -1;\n        } else if (DUPS_OK_ACKNOWLEDGE_MODE.equals(acknowledgeMode)) {\n            return Session.DUPS_OK_ACKNOWLEDGE;\n        } else {\n            return INVALID_ACKNOWLEDGE_MODE;\n        }\n    }\n"}
{"magic_number_smell": "        }\n\n        connectWork = new Work() {\n            long currentReconnectDelay = 1000;\n\n            public void release() {\n                //", "refactored_code": "    private static final long INITIAL_RECONNECT_DELAY = 1000; // 1 second.\n        }\n\n        connectWork = new Work() {\n            long currentReconnectDelay = INITIAL_RECONNECT_DELAY;\n\n            public void release() {\n                //"}
{"magic_number_smell": "        brokerService.waitUntilStarted();\n\n        // File system lastMod time granularity can be up to 2 seconds\n        TimeUnit.SECONDS.sleep(4);\n    }\n\n    public BrokerService createBroker(String configFileName) throws Exception {", "refactored_code": "    public static final int SLEEP = 4; // seconds\n        brokerService.waitUntilStarted();\n\n        // File system lastMod time granularity can be up to 2 seconds\n        TimeUnit.SECONDS.sleep(SLEEP);\n    }\n\n    public BrokerService createBroker(String configFileName) throws Exception {"}
{"magic_number_smell": "        authenticationPlugin.setAnonymousAccessAllowed(true);\n        javaConfigBroker.updateSimpleAuthenticationPlugin(authenticationPlugin);\n\n        TimeUnit.SECONDS.sleep(2);\n\n        assertAllowed(\"test_user_password\", \"USERS.A\");\n        assertAllowed(\"another_test_user_password\", \"USERS.A\");", "refactored_code": "    public static final int SLEEP = 2; // seconds\n        authenticationPlugin.setAnonymousAccessAllowed(true);\n        javaConfigBroker.updateSimpleAuthenticationPlugin(authenticationPlugin);\n\n        TimeUnit.SECONDS.sleep(SLEEP);\n\n        assertAllowed(\"test_user_password\", \"USERS.A\");\n        assertAllowed(\"another_test_user_password\", \"USERS.A\");"}
{"magic_number_smell": "\n        assertDeniedTemp(\"guest\");\n\n       // applyNewConfig(brokerConfig, configurationSeed + \"-users-guests\", 2);\n\n        authorizationMap = buildUsersGuestsMap();\n        javaConfigBroker.updateAuthorizationMap(authorizationMap);", "refactored_code": "    public static final int SLEEP = 2; // seconds\n\n        assertDeniedTemp(\"guest\");\n\n       // applyNewConfig(brokerConfig, configurationSeed + \"-users-guests\", SLEEP);\n\n        authorizationMap = buildUsersGuestsMap();\n        javaConfigBroker.updateAuthorizationMap(authorizationMap);"}
{"magic_number_smell": "\n        NetworkConnector networkConnector = brokerService.getNetworkConnectors().get(0);\n        javaConfigBroker.addNetworkConnector(nc);\n        TimeUnit.SECONDS.sleep(2);\n        assertEquals(\"no new network connectors\", 1, brokerService.getNetworkConnectors().size());\n        assertSame(\"same instance\", networkConnector, brokerService.getNetworkConnectors().get(0));\n", "refactored_code": "    public static final int SLEEP = 2; // seconds\n\n        NetworkConnector networkConnector = brokerService.getNetworkConnectors().get(0);\n        javaConfigBroker.addNetworkConnector(nc);\n        TimeUnit.SECONDS.sleep(SLEEP);\n        assertEquals(\"no new network connectors\", 1, brokerService.getNetworkConnectors().size());\n        assertSame(\"same instance\", networkConnector, brokerService.getNetworkConnectors().get(0));\n"}
{"magic_number_smell": "        //Reapply new limit\n        entry.setMemoryLimit(4194304);\n        javaConfigBroker.modifyPolicyEntry(entry);\n        TimeUnit.SECONDS.sleep(2);\n\n        verifyQueueLimit(\"After\", 4194304);\n", "refactored_code": "    public static final int SLEEP = 2; // seconds\n        //Reapply new limit\n        entry.setMemoryLimit(4194304);\n        javaConfigBroker.modifyPolicyEntry(entry);\n        TimeUnit.SECONDS.sleep(SLEEP);\n\n        verifyQueueLimit(\"After\", 4194304);\n"}
{"magic_number_smell": "        exerciseVirtualTopic(\"VirtualTopic.Default\");\n\n        javaConfigBroker.setVirtualDestinations(new VirtualDestination[]{buildVirtualTopic(\"A.>\", false)});\n        TimeUnit.SECONDS.sleep(2);\n\n        assertEquals(\"one interceptor\", 1, interceptors.length);\n        assertTrue(\"it is virtual topic interceptor\", interceptors[0] instanceof VirtualDestinationInterceptor);", "refactored_code": "    public static final int SLEEP = 2; // seconds\n        exerciseVirtualTopic(\"VirtualTopic.Default\");\n\n        javaConfigBroker.setVirtualDestinations(new VirtualDestination[]{buildVirtualTopic(\"A.>\", false)});\n        TimeUnit.SECONDS.sleep(SLEEP);\n\n        assertEquals(\"one interceptor\", 1, interceptors.length);\n        assertTrue(\"it is virtual topic interceptor\", interceptors[0] instanceof VirtualDestinationInterceptor);"}
{"magic_number_smell": "\n            @Override\n            public Long getConnectedTimestamp() {\n                return System.currentTimeMillis();\n            }\n\n        };", "refactored_code": "            private final long connectedTimestamp = System.currentTimeMillis();\n\n            @Override\n            public Long getConnectedTimestamp() {\n                return connectedTimestamp;\n            }\n\n        };"}
{"magic_number_smell": "        container.setMessageListener(listener);\n        container.setSessionTransacted(false);\n        container.setSessionAcknowledgeMode(Session.AUTO_ACKNOWLEDGE);\n        container.setConcurrentConsumers(1);\n        return container;\n    }\n", "refactored_code": "    private static final int MAX_CONSUMERS = 1;\n        container.setMessageListener(listener);\n        container.setSessionTransacted(false);\n        container.setSessionAcknowledgeMode(Session.AUTO_ACKNOWLEDGE);\n        container.setConcurrentConsumers(MAX_CONSUMERS);\n        return container;\n    }\n"}
{"magic_number_smell": "    private static final String QUEUE1_NAME = \"test.queue.1\";\n    private static final int 5 = 5;\n    private static final int NUM_MESSAGE_TO_SEND = 10000;\n    private static final CountDownLatch LATCH = new CountDownLatch(5 * NUM_MESSAGE_TO_SEND);\n\n    @Override\n    public void setUp() throws Exception {", "refactored_code": "    private static final int MAX_CONSUMERS = 5;\n    private static final String QUEUE1_NAME = \"test.queue.1\";\n    private static final int MAX_CONSUMERS = 5;\n    private static final int NUM_MESSAGE_TO_SEND = 10000;\n    private static final CountDownLatch LATCH = new CountDownLatch(MAX_CONSUMERS * NUM_MESSAGE_TO_SEND);\n\n    @Override\n    public void setUp() throws Exception {"}
{"magic_number_smell": "        container.setMessageListener(listener);\n        container.setSessionTransacted(false);\n        container.setSessionAcknowledgeMode(Session.AUTO_ACKNOWLEDGE);\n        container.setConcurrentConsumers(10);\n        return container;\n    }\n", "refactored_code": "    private static final int MAX_CONSUMERS = 10;\n        container.setMessageListener(listener);\n        container.setSessionTransacted(false);\n        container.setSessionAcknowledgeMode(Session.AUTO_ACKNOWLEDGE);\n        container.setConcurrentConsumers(MAX_CONSUMERS);\n        return container;\n    }\n"}
{"magic_number_smell": "\n        MessageProducer producer = session.createProducer(queue);\n\n        for (int i = 0; i < 250; i++) {\n            log.info(\"Sending message \" + i);\n            TextMessage message = session.createTextMessage(\"Message \" + i);\n            producer.send(message);", "refactored_code": "    private static final int MESSAGE_COUNT = 250;\n\n        MessageProducer producer = session.createProducer(queue);\n\n        for (int i = 0; i < MESSAGE_COUNT; i++) {\n            log.info(\"Sending message \" + i);\n            TextMessage message = session.createTextMessage(\"Message \" + i);\n            producer.send(message);"}
{"magic_number_smell": "    }\n\n    public StompFrame receive() throws Exception {\n        return receive(10000);\n    }\n\n    public StompFrame receive(long timeOut) throws Exception {", "refactored_code": "    public static final long RECEIVE_TIMEOUT = 10000;\n    }\n\n    public StompFrame receive() throws Exception {\n        return receive(RECEIVE_TIMEOUT);\n    }\n\n    public StompFrame receive(long timeOut) throws Exception {"}
{"magic_number_smell": "\n        // skip white space to next real action line\n        while (true) {\n            action = readLine(in, 1024, \"The maximum command length was exceeded\");\n            if (action == null) {\n                throw new IOException(\"connection was closed\");\n            } else {", "refactored_code": "    private static final int MAX_COMMAND_LENGTH = 1024;\n\n        // skip white space to next real action line\n        while (true) {\n            action = readLine(in, MAX_COMMAND_LENGTH, \"The maximum command length was exceeded\");\n            if (action == null) {\n                throw new IOException(\"connection was closed\");\n            } else {"}
{"magic_number_smell": "        stompConnect();\n        stompConnection.connect(\"system\", \"manager\");\n\n        executor = Executors.newFixedThreadPool(100, new ThreadFactory() {\n\n            private long i = 0;\n", "refactored_code": "    private static final int TASK_COUNT = 100;\n        stompConnect();\n        stompConnection.connect(\"system\", \"manager\");\n\n        executor = Executors.newFixedThreadPool(TASK_COUNT, new ThreadFactory() {\n\n            private long i = 0;\n"}
{"magic_number_smell": "\n    @Override\n    protected String getAdditionalConfig() {\n        return \"?transport.maxDataLength=\" + 64 * 1024;\n    }\n\n    @Test(timeout = 60000)", "refactored_code": "    private static final int TEST_MAX_DATA_SIZE = 64 * 1024;\n\n    @Override\n    protected String getAdditionalConfig() {\n        return \"?transport.maxDataLength=\" + TEST_MAX_DATA_SIZE;\n    }\n\n    @Test(timeout = 60000)"}
{"magic_number_smell": "\n    @Override\n    protected String getAdditionalConfig() {\n        return \"?wireFormat.maxDataLength=\" + 100 * 1024 + \"&wireFormat.maxFrameSize=\" + maxFrameSize;\n    }\n\n    /**", "refactored_code": "    private static final int MAX_DATA_SIZE = 100 * 1024;\n\n    @Override\n    protected String getAdditionalConfig() {\n        return \"?wireFormat.maxDataLength=\" + MAX_DATA_SIZE + \"&wireFormat.maxFrameSize=\" + maxFrameSize;\n    }\n\n    /**"}
{"magic_number_smell": "        StompFrame frame = stompConnection.receive();\n        assertTrue(frame.toString().startsWith(\"CONNECTED\"));\n\n        for (int i = 0; i < 30000 - 1; i++) {\n            stompConnection.send(\"/topic/VirtualTopic.FOO\", \"Hello World {\" + (i + 1) + \"} \" + payload.toString());\n        }\n", "refactored_code": "    private static final int NUM_MSGS = 30000;\n        StompFrame frame = stompConnection.receive();\n        assertTrue(frame.toString().startsWith(\"CONNECTED\"));\n\n        for (int i = 0; i < NUM_MSGS - 1; i++) {\n            stompConnection.send(\"/topic/VirtualTopic.FOO\", \"Hello World {\" + (i + 1) + \"} \" + payload.toString());\n        }\n"}
{"magic_number_smell": "        Thread monitorThread = memoryMonitoringTool.startMonitor();\n\n        if (messageCount == 0) {\n            messageCount = 5000;\n        }\n\n", "refactored_code": "    private static final int DEFAULT_MESSAGECOUNT = 5000;\n        Thread monitorThread = memoryMonitoringTool.startMonitor();\n\n        if (messageCount == 0) {\n            messageCount = DEFAULT_MESSAGECOUNT;\n        }\n\n"}
{"magic_number_smell": "\n        LOG.info(getName() + \": Waiting for Producers and Consumers to startup.\");\n        connectionsEstablished.acquire();\n        LOG.info(\"Producers and Consumers are now running.  Waiting for system to reach steady state: \" + (Integer.parseInt(System.getProperty(\"SAMPLE_DELAY\", \"\" + 1000 * 5)) / 1000.0f) + \" seconds\");\n        Thread.sleep(1000 * 10);\n\n        LOG.info(\"Starting sample: \" + SAMPLES + \" each lasting \" + (SAMPLE_DURATION / 1000.0f) + \" seconds\");", "refactored_code": "    private static final long SAMPLE_DELAY = Integer.parseInt(System.getProperty(\"SAMPLE_DELAY\", \"\" + 1000 * 5));\n\n        LOG.info(getName() + \": Waiting for Producers and Consumers to startup.\");\n        connectionsEstablished.acquire();\n        LOG.info(\"Producers and Consumers are now running.  Waiting for system to reach steady state: \" + (SAMPLE_DELAY / 1000.0f) + \" seconds\");\n        Thread.sleep(1000 * 10);\n\n        LOG.info(\"Starting sample: \" + SAMPLES + \" each lasting \" + (SAMPLE_DURATION / 1000.0f) + \" seconds\");"}
{"magic_number_smell": "\n        // The number of messages browsed should be equal to the number of\n        // messages sent.\n        assertEquals(50, browsed);\n\n        long begin = System.nanoTime();\n        while (browsed != 0) {", "refactored_code": "    private static final int MESSAGES_TO_SEND = 50;\n\n        // The number of messages browsed should be equal to the number of\n        // messages sent.\n        assertEquals(MESSAGES_TO_SEND, browsed);\n\n        long begin = System.nanoTime();\n        while (browsed != 0) {"}
{"magic_number_smell": "        messageCount.set(0);\n\n        destination = createDestination();\n        largeMessageData = new byte[128 * 1024];\n        for (int i = 0; i < 128 * 1024; i++) {\n            if (i % 2 == 0) {\n                largeMessageData[i] = 'a';", "refactored_code": "    protected static final int LARGE_MESSAGE_SIZE = 128 * 1024;\n        messageCount.set(0);\n\n        destination = createDestination();\n        largeMessageData = new byte[LARGE_MESSAGE_SIZE];\n        for (int i = 0; i < LARGE_MESSAGE_SIZE; i++) {\n            if (i % 2 == 0) {\n                largeMessageData[i] = 'a';"}
{"magic_number_smell": "        MessageConsumer advisoryConsumer = s.createConsumer(advisoryTopic);\n        // start throwing messages at the consumer\n        MessageProducer producer = s.createProducer(queue);\n        for (int i = 0; i < 2000; i++) {\n            BytesMessage m = s.createBytesMessage();\n            m.writeBytes(new byte[1024]);\n            producer.send(m);", "refactored_code": "    protected static final int MESSAGE_COUNT = 2000;\n        MessageConsumer advisoryConsumer = s.createConsumer(advisoryTopic);\n        // start throwing messages at the consumer\n        MessageProducer producer = s.createProducer(queue);\n        for (int i = 0; i < MESSAGE_COUNT; i++) {\n            BytesMessage m = s.createBytesMessage();\n            m.writeBytes(new byte[1024]);\n            producer.send(m);"}
{"magic_number_smell": "        MessageConsumer advisoryConsumer = s.createConsumer(advisoryTopic);\n        // start throwing messages at the consumer\n        MessageProducer producer = s.createProducer(queue);\n        for (int i = 0; i < 100; i++) {\n            BytesMessage m = s.createBytesMessage();\n            m.writeBytes(new byte[1024]);\n            producer.send(m);", "refactored_code": "    protected static final int MESSAGE_COUNT = 100;\n        MessageConsumer advisoryConsumer = s.createConsumer(advisoryTopic);\n        // start throwing messages at the consumer\n        MessageProducer producer = s.createProducer(queue);\n        for (int i = 0; i < MESSAGE_COUNT; i++) {\n            BytesMessage m = s.createBytesMessage();\n            m.writeBytes(new byte[1024]);\n            producer.send(m);"}
{"magic_number_smell": "\n    public void testLoadTempAdvisoryQueues() throws Exception {\n\n        for (int i = 0; i < 2000; i++) {\n            TemporaryQueue tempQueue = session.createTemporaryQueue();\n            MessageConsumer consumer = session.createConsumer(tempQueue);\n            MessageProducer producer = session.createProducer(tempQueue);", "refactored_code": "    private static final int MESSAGE_COUNT = 2000;\n\n    public void testLoadTempAdvisoryQueues() throws Exception {\n\n        for (int i = 0; i < MESSAGE_COUNT; i++) {\n            TemporaryQueue tempQueue = session.createTemporaryQueue();\n            MessageConsumer consumer = session.createConsumer(tempQueue);\n            MessageProducer producer = session.createProducer(tempQueue);"}
{"magic_number_smell": "\n        // The point of this test is that message should not be delivered until\n        // send is committed.\n        assertNull(receiveMessage(connection1,500));\n\n        // Commit the transaction.\n        connection1.send(createCommitTransaction1Phase(connectionInfo1, txid));", "refactored_code": "    protected static final int MAX_NULL_WAIT=500;\n\n        // The point of this test is that message should not be delivered until\n        // send is committed.\n        assertNull(receiveMessage(connection1,MAX_NULL_WAIT));\n\n        // Commit the transaction.\n        connection1.send(createCommitTransaction1Phase(connectionInfo1, txid));"}
{"magic_number_smell": "            @Override\n            public boolean isSatisified() throws Exception {\n                LOG.info(\"Dlq size: \" + dlq.getQueueSize() + \", qSize: \" + queue.getQueueSize());\n                return 2*BaseDestination.MAX_PAGE_SIZE == dlq.getQueueSize();\n            }\n        }));\n", "refactored_code": "    protected static final int MESSAGE_COUNT = 2*BaseDestination.MAX_PAGE_SIZE;\n            @Override\n            public boolean isSatisified() throws Exception {\n                LOG.info(\"Dlq size: \" + dlq.getQueueSize() + \", qSize: \" + queue.getQueueSize());\n                return MESSAGE_COUNT == dlq.getQueueSize();\n            }\n        }));\n"}
{"magic_number_smell": "        producerExchange.setConnectionContext(contextNotInTx);\n\n        // populate the queue store, exceed memory limit so that cache is disabled\n        for (int i = 0; i < 50; i++) {\n            Message message = getMessage(i);\n            queue.send(producerExchange, message);\n        }", "refactored_code": "    private static final int count = 50;\n        producerExchange.setConnectionContext(contextNotInTx);\n\n        // populate the queue store, exceed memory limit so that cache is disabled\n        for (int i = 0; i < count; i++) {\n            Message message = getMessage(i);\n            queue.send(producerExchange, message);\n        }"}
{"magic_number_smell": "\n    private void testPurgeLargeQueue(boolean prioritizedMessages) throws Exception {\n        applyBrokerSpoolingPolicy(prioritizedMessages);\n        createProducerAndSendMessages(20000);\n        QueueViewMBean proxy = getProxyToQueueViewMBean();\n        LOG.info(\"purging..\");\n", "refactored_code": "    private static final int NUM_TO_SEND = 20000;\n\n    private void testPurgeLargeQueue(boolean prioritizedMessages) throws Exception {\n        applyBrokerSpoolingPolicy(prioritizedMessages);\n        createProducerAndSendMessages(NUM_TO_SEND);\n        QueueViewMBean proxy = getProxyToQueueViewMBean();\n        LOG.info(\"purging..\");\n"}
{"magic_number_smell": "        this.factory = new ActiveMQConnectionFactory(broker.getVmConnectorURI());\n        this.queue = new ActiveMQQueue(\"TESTQUEUE\");\n\n        connections = new Connection[8];\n        int iter = 0;\n        while ( iter < 8 ) {\n            this.connections[iter] = factory.createConnection();", "refactored_code": "    public static final int             NUM_CONNECTION_TO_TEST = 8;\n        this.factory = new ActiveMQConnectionFactory(broker.getVmConnectorURI());\n        this.queue = new ActiveMQQueue(\"TESTQUEUE\");\n\n        connections = new Connection[NUM_CONNECTION_TO_TEST];\n        int iter = 0;\n        while ( iter < NUM_CONNECTION_TO_TEST ) {\n            this.connections[iter] = factory.createConnection();"}
{"magic_number_smell": "\n    protected void configureBroker(BrokerService answer) throws Exception {\n        PolicyEntry policy = new PolicyEntry();\n        policy.setMemoryLimit(2097152);\n        policy.setPendingQueuePolicy(new StorePendingQueueMessageStoragePolicy());\n\n        // disable the cache to be sure setBatch is the problem", "refactored_code": "    private static final long QUEUE_MEMORY_LIMIT = 2097152;\n\n    protected void configureBroker(BrokerService answer) throws Exception {\n        PolicyEntry policy = new PolicyEntry();\n        policy.setMemoryLimit(QUEUE_MEMORY_LIMIT);\n        policy.setPendingQueuePolicy(new StorePendingQueueMessageStoragePolicy());\n\n        // disable the cache to be sure setBatch is the problem"}
{"magic_number_smell": "        ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory(\"vm://localhost\");\n        Connection connection = cf.createConnection();\n        connection.start();\n        for (int i = 0; i < 50; ++i) {\n            scheduleRepeating(connection);\n        }\n        connection.close();", "refactored_code": "    private final int NUM_JOBS = 50;\n        ActiveMQConnectionFactory cf = new ActiveMQConnectionFactory(\"vm://localhost\");\n        Connection connection = cf.createConnection();\n        connection.start();\n        for (int i = 0; i < NUM_JOBS; ++i) {\n            scheduleRepeating(connection);\n        }\n        connection.close();"}
{"magic_number_smell": "        connection.start();\n        while (true) {\n            scheduleRepeating(session, producer);\n            if (schedulerStore.getJournal().getFileMap().size() == 6) {\n                break;\n            }\n        }", "refactored_code": "    private final int NUM_LOGS = 6;\n        connection.start();\n        while (true) {\n            scheduleRepeating(session, producer);\n            if (schedulerStore.getJournal().getFileMap().size() == NUM_LOGS) {\n                break;\n            }\n        }"}
{"magic_number_smell": "    private static final Logger logger = LoggerFactory.getLogger(MirroredQueueCorrectMemoryUsageTest.class);\n\n    private static final long 0x0100000 = 0x0100000;\n    private static final long TEN_MB = 0x0100000 * 10;\n    private static final long TWENTY_MB = TEN_MB * 2;\n\n    private static final String CREATED_STATIC_FOR_PERSISTENT = \"created.static.for.persistent\";", "refactored_code": "    private static final long ONE_MB = 0x0100000;\n    private static final Logger logger = LoggerFactory.getLogger(MirroredQueueCorrectMemoryUsageTest.class);\n\n    private static final long ONE_MB = 0x0100000;\n    private static final long TEN_MB = ONE_MB * 10;\n    private static final long TWENTY_MB = TEN_MB * 2;\n\n    private static final String CREATED_STATIC_FOR_PERSISTENT = \"created.static.for.persistent\";"}
{"magic_number_smell": "\n            // The first 2 consumers will rollback, ultimately causing messages\n            // to land on the DLQ\n            consumer1 = new TestConsumer(consumer1Prefix + virtualTopicName, false, 6, true);\n            thread(consumer1, false);\n\n            consumer2 = new TestConsumer(consumer2Prefix + virtualTopicName, false, 6, true);", "refactored_code": "    private static final int numberMessages = 6;\n\n            // The first 2 consumers will rollback, ultimately causing messages\n            // to land on the DLQ\n            consumer1 = new TestConsumer(consumer1Prefix + virtualTopicName, false, numberMessages, true);\n            thread(consumer1, false);\n\n            consumer2 = new TestConsumer(consumer2Prefix + virtualTopicName, false, numberMessages, true);"}
{"magic_number_smell": "public class ActiveMQSlowConsumerManualTest {\n    private static final int 12345 = 12345;\n    private static final ActiveMQTopic TOPIC = new ActiveMQTopic(\"TOPIC\");\n    private static final String URL = \"nio://localhost:\" + 12345 + \"?socket.tcpNoDelay=true\";\n\n    @Test(timeout = 60000)\n    public void testDefaultSettings() throws Exception {", "refactored_code": "    private static final int PORT = 12345;\npublic class ActiveMQSlowConsumerManualTest {\n    private static final int PORT = 12345;\n    private static final ActiveMQTopic TOPIC = new ActiveMQTopic(\"TOPIC\");\n    private static final String URL = \"nio://localhost:\" + PORT + \"?socket.tcpNoDelay=true\";\n\n    @Test(timeout = 60000)\n    public void testDefaultSettings() throws Exception {"}
{"magic_number_smell": "    // Number of messages\n\n    private final int 5 = 5;\n    private final int totalNumberMessages = 5 * 2;\n    private final int maxRedeliveries = 2;\n    private final int redeliveryDelay = 1000;\n", "refactored_code": "    private final int producerMessages = 5;\n    // Number of messages\n\n    private final int producerMessages = 5;\n    private final int totalNumberMessages = producerMessages * 2;\n    private final int maxRedeliveries = 2;\n    private final int redeliveryDelay = 1000;\n"}
{"magic_number_smell": "        private Destination replyDestination = ActiveMQDestination.createDestination(\n                REPLY_QUEUE, ActiveMQDestination.QUEUE_TYPE);\n\n        private CountDownLatch roundTripLatch = new CountDownLatch(4000);\n        private CountDownLatch errorLatch = new CountDownLatch(1);\n        private ThreadPoolExecutor tpe;\n        private final String BROKER_URL = \"tcp://localhost:0\";", "refactored_code": "        private static final int NUM_MESSAGES = 4000;\n        private Destination replyDestination = ActiveMQDestination.createDestination(\n                REPLY_QUEUE, ActiveMQDestination.QUEUE_TYPE);\n\n        private CountDownLatch roundTripLatch = new CountDownLatch(NUM_MESSAGES);\n        private CountDownLatch errorLatch = new CountDownLatch(1);\n        private ThreadPoolExecutor tpe;\n        private final String BROKER_URL = \"tcp://localhost:0\";"}
{"magic_number_smell": "\n    private final int 1000 = 1000;\n    private final int numConsumers = 2;\n    private final int dlqMessages = 1000 / 2;\n\n    private CountDownLatch receivedLatch;\n    private ActiveMQTopic destination;", "refactored_code": "    private final int numMessages = 1000;\n\n    private final int numMessages = 1000;\n    private final int numConsumers = 2;\n    private final int dlqMessages = numMessages / 2;\n\n    private CountDownLatch receivedLatch;\n    private ActiveMQTopic destination;"}
{"magic_number_smell": "    private static final long 10 * 1000 = 10 * 1000;\n    private static final long DEFAULT_NUM_TO_SEND = 1400;\n    \n    long brokerStopPeriod = 10 * 1000;\n    long numtoSend = DEFAULT_NUM_TO_SEND;\n    long sleepBetweenSend = SLEEP_BETWEEN_SEND_MS;\n    String brokerURL = DEFAULT_BROKER_URL;", "refactored_code": "    private static final long DEFAULT_BROKER_STOP_PERIOD = 10 * 1000;\n    private static final long DEFAULT_BROKER_STOP_PERIOD = 10 * 1000;\n    private static final long DEFAULT_NUM_TO_SEND = 1400;\n    \n    long brokerStopPeriod = DEFAULT_BROKER_STOP_PERIOD;\n    long numtoSend = DEFAULT_NUM_TO_SEND;\n    long sleepBetweenSend = SLEEP_BETWEEN_SEND_MS;\n    String brokerURL = DEFAULT_BROKER_URL;"}
{"magic_number_smell": "        brokerUriNoPrefetch = brokerUri + \"?jms.prefetchPolicy.all=0\";\n\n        destination = new ActiveMQQueue(\"Test\");\n        produce(brokerUri, 100);\n    }\n\n    @Before", "refactored_code": "    private static final int QUEUE_SIZE = 100;\n        brokerUriNoPrefetch = brokerUri + \"?jms.prefetchPolicy.all=0\";\n\n        destination = new ActiveMQQueue(\"Test\");\n        produce(brokerUri, QUEUE_SIZE);\n    }\n\n    @Before"}
{"magic_number_smell": "                    Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n                    MessageProducer producer = session.createProducer(destination);\n                    producer.setDeliveryMode(deliveryMode);\n                    for (int idx = 0; idx < 30000; ++idx) {\n                        Message message = session.createTextMessage(new String(buf) + idx);\n                        producer.send(message);\n                    }", "refactored_code": "    private static final int MESSAGES_COUNT = 30000;\n                    Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n                    MessageProducer producer = session.createProducer(destination);\n                    producer.setDeliveryMode(deliveryMode);\n                    for (int idx = 0; idx < MESSAGES_COUNT; ++idx) {\n                        Message message = session.createTextMessage(new String(buf) + idx);\n                        producer.send(message);\n                    }"}
{"magic_number_smell": "        for (int i = 0; i < NUMBER_OF_PAIRS; i++) {\n            ActiveMQQueue queue = new ActiveMQQueue(getClass().getName() + \":\" + i);\n            ProducerConsumerPair cp = new ProducerConsumerPair();\n            cp.start(this.brokerURL, queue, 1000);\n            cp.testRun();\n            cp.stop();\n        }", "refactored_code": "    protected static final int MESSAGE_COUNT = 1000;\n        for (int i = 0; i < NUMBER_OF_PAIRS; i++) {\n            ActiveMQQueue queue = new ActiveMQQueue(getClass().getName() + \":\" + i);\n            ProducerConsumerPair cp = new ProducerConsumerPair();\n            cp.start(this.brokerURL, queue, MESSAGE_COUNT);\n            cp.testRun();\n            cp.stop();\n        }"}
{"magic_number_smell": "        TestProducer p = null;\n        TestConsumer c = null;\n        try {\n            latch = new CountDownLatch(500);\n\n            for (int i = 0; i < CONSUMER_COUNT; i++) {\n                TestConsumer consumer = new TestConsumer();", "refactored_code": "    private static final int SEND_COUNT = 500;\n        TestProducer p = null;\n        TestConsumer c = null;\n        try {\n            latch = new CountDownLatch(SEND_COUNT);\n\n            for (int i = 0; i < CONSUMER_COUNT; i++) {\n                TestConsumer consumer = new TestConsumer();"}
{"magic_number_smell": "    private void waitForMessageReceipt() throws InterruptedException, TimeoutException {\n        try {\n            while (count.get() < SEND_COUNT) {\n                if (!receivedMessages.tryAcquire(60, TimeUnit.SECONDS)) {\n                    if (count.get() == SEND_COUNT)\n                        break;\n                    verifyTracking();", "refactored_code": "    private static final int HANG_THRESHOLD = 60;\n    private void waitForMessageReceipt() throws InterruptedException, TimeoutException {\n        try {\n            while (count.get() < SEND_COUNT) {\n                if (!receivedMessages.tryAcquire(HANG_THRESHOLD, TimeUnit.SECONDS)) {\n                    if (count.get() == SEND_COUNT)\n                        break;\n                    verifyTracking();"}
{"magic_number_smell": "    private final String QUEUE_NAME = \"dee.q\";\n    private final int 1000 = 1000;\n    private final int WORKER_INTERNAL_ITERATIONS = 100;\n    private final int TOTAL_MESSAGES_CNT = 1000 * WORKER_INTERNAL_ITERATIONS + 1000;\n    private final byte[] payload = new byte[5 * 1024];\n    private final String TEXT = new String(payload);\n", "refactored_code": "    private final int INITIAL_MESSAGES_CNT = 1000;\n    private final String QUEUE_NAME = \"dee.q\";\n    private final int INITIAL_MESSAGES_CNT = 1000;\n    private final int WORKER_INTERNAL_ITERATIONS = 100;\n    private final int TOTAL_MESSAGES_CNT = INITIAL_MESSAGES_CNT * WORKER_INTERNAL_ITERATIONS + INITIAL_MESSAGES_CNT;\n    private final byte[] payload = new byte[5 * 1024];\n    private final String TEXT = new String(payload);\n"}
{"magic_number_smell": "        MessageProducer testProducer = testSession.createProducer(tempQueue);\n        byte[] payload = new byte[1024 * 4];\n\n        for (int i = 0; i < 2000; i++) {\n            BytesMessage msg = testSession.createBytesMessage();\n            msg.writeBytes(payload);\n            testProducer.send(msg);", "refactored_code": "    private static final int NUMBER = 2000;\n        MessageProducer testProducer = testSession.createProducer(tempQueue);\n        byte[] payload = new byte[1024 * 4];\n\n        for (int i = 0; i < NUMBER; i++) {\n            BytesMessage msg = testSession.createBytesMessage();\n            msg.writeBytes(payload);\n            testProducer.send(msg);"}
{"magic_number_smell": "        producer.setDeliveryMode(DeliveryMode.PERSISTENT);\n        long tStamp = System.currentTimeMillis();\n        BytesMessage message = session2.createBytesMessage();\n        for (int i = 1; i <= 2500; i++)\n        {\n            message.setStringProperty(\"JMS_ID\", \"TEST\");\n            message.setIntProperty(\"Type\", i);", "refactored_code": "    private static final int MSG_COUNT = 2500;\n        producer.setDeliveryMode(DeliveryMode.PERSISTENT);\n        long tStamp = System.currentTimeMillis();\n        BytesMessage message = session2.createBytesMessage();\n        for (int i = 1; i <= MSG_COUNT; i++)\n        {\n            message.setStringProperty(\"JMS_ID\", \"TEST\");\n            message.setIntProperty(\"Type\", i);"}
{"magic_number_smell": "\n    private BrokerService broker;\n\n    private final CountDownLatch messageCountDown = new CountDownLatch(500);\n\n    private CleanableKahaDBStore kahaDB;\n", "refactored_code": "    private static final int MAX_MESSAGES = 500;\n\n    private BrokerService broker;\n\n    private final CountDownLatch messageCountDown = new CountDownLatch(MAX_MESSAGES);\n\n    private CleanableKahaDBStore kahaDB;\n"}
{"magic_number_smell": "    public void testNoStickyKahaDbLogFilesOnConcurrentTransactionalConsumer() throws Exception {\n\n        List<Thread> consumerThreads = new ArrayList<Thread>();\n        for (int i = 0; i < 10; i++) {\n            ConsumerThread thread = new ConsumerThread();\n            thread.start();\n            consumerThreads.add(thread);", "refactored_code": "    private static final int MAX_CONSUMER = 10;\n    public void testNoStickyKahaDbLogFilesOnConcurrentTransactionalConsumer() throws Exception {\n\n        List<Thread> consumerThreads = new ArrayList<Thread>();\n        for (int i = 0; i < MAX_CONSUMER; i++) {\n            ConsumerThread thread = new ConsumerThread();\n            thread.start();\n            consumerThreads.add(thread);"}
{"magic_number_smell": "                Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n                MessageProducer producer = session.createProducer(session.createQueue(QUEUE_NAME));\n                Message message = session.createTextMessage(\"test\");\n                for (int i = 0; i < 100; i++) {\n                    message.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY, DELAY);\n                    producer.send(message);\n                }", "refactored_code": "    private static final int MESSAGES_PER_THREAD = 100;\n                Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n                MessageProducer producer = session.createProducer(session.createQueue(QUEUE_NAME));\n                Message message = session.createTextMessage(\"test\");\n                for (int i = 0; i < MESSAGES_PER_THREAD; i++) {\n                    message.setLongProperty(ScheduledMessage.AMQ_SCHEDULED_DELAY, DELAY);\n                    producer.send(message);\n                }"}
{"magic_number_smell": "\n    private BrokerService broker;\n\n    private final CountDownLatch messageCountDown = new CountDownLatch(100);\n\n    private ConnectionFactory factory;\n", "refactored_code": "    private static final int MAX_MESSAGES = 100;\n\n    private BrokerService broker;\n\n    private final CountDownLatch messageCountDown = new CountDownLatch(MAX_MESSAGES);\n\n    private ConnectionFactory factory;\n"}
{"magic_number_smell": "\n        pol_ent = new PolicyEntry();\n        pol_ent.setQueue(\">\");\n        pol_ent.setMemoryLimit(16 * 1024);\n        pol_ent.setProducerFlowControl(false);\n        ent_list.add(pol_ent);\n", "refactored_code": "    protected static final int MEMORY_LIMIT = 16 * 1024;\n\n        pol_ent = new PolicyEntry();\n        pol_ent.setQueue(\">\");\n        pol_ent.setMemoryLimit(MEMORY_LIMIT);\n        pol_ent.setProducerFlowControl(false);\n        ent_list.add(pol_ent);\n"}
{"magic_number_smell": "        MessageProducer producer = session.createProducer(queue);\n\n        // send lots of messages to the tempQueue\n        for (int i = 0; i < 100; i++) {\n            BytesMessage m = session.createBytesMessage();\n            m.writeBytes(new byte[1024]);\n            producer.send(m);", "refactored_code": "    private static final int MESSAGE_COUNT = 100;\n        MessageProducer producer = session.createProducer(queue);\n\n        // send lots of messages to the tempQueue\n        for (int i = 0; i < MESSAGE_COUNT; i++) {\n            BytesMessage m = session.createBytesMessage();\n            m.writeBytes(new byte[1024]);\n            producer.send(m);"}
{"magic_number_smell": "        broker.addConnector(\"tcp://localhost:0\");\n\n        // populate a bunch of destinations, validate the impact on a call to send\n        ActiveMQDestination[] destinations = new ActiveMQDestination[10000];\n        for (int idx = 0; idx < 10000; ++idx) {\n            destinations[idx] = new ActiveMQQueue(getDestinationName() + \"-\" + idx);\n        }", "refactored_code": "    private static final int MESSAGES_COUNT = 10000;\n        broker.addConnector(\"tcp://localhost:0\");\n\n        // populate a bunch of destinations, validate the impact on a call to send\n        ActiveMQDestination[] destinations = new ActiveMQDestination[MESSAGES_COUNT];\n        for (int idx = 0; idx < MESSAGES_COUNT; ++idx) {\n            destinations[idx] = new ActiveMQQueue(getDestinationName() + \"-\" + idx);\n        }"}
{"magic_number_smell": "\n        final Session producerSession = producerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n        final MessageProducer producer = producerSession.createProducer(destination);\n        producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);\n\n        Thread t = new Thread(new Runnable() {\n", "refactored_code": "    private final int deliveryMode = DeliveryMode.NON_PERSISTENT;\n\n        final Session producerSession = producerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n        final MessageProducer producer = producerSession.createProducer(destination);\n        producer.setDeliveryMode(deliveryMode);\n\n        Thread t = new Thread(new Runnable() {\n"}
{"magic_number_smell": "            @Override\n            public void run() {\n                try {\n                    while (totalConsumed.get() < 25000) {\n                        Message message = consumer1.receiveNoWait();\n                        if (message != null) {\n                            workQueue.add(message);", "refactored_code": "    private final long NUM_MESSAGES = 25000;\n            @Override\n            public void run() {\n                try {\n                    while (totalConsumed.get() < NUM_MESSAGES) {\n                        Message message = consumer1.receiveNoWait();\n                        if (message != null) {\n                            workQueue.add(message);"}
{"magic_number_smell": "\n        try {\n            // send lots of messages to the tempQueue\n            for (int i = 0; i < 100; i++) {\n                BytesMessage m = session.createBytesMessage();\n                m.writeBytes(new byte[1024]);\n                if (genericProducer) {", "refactored_code": "    private static final int MESSAGE_COUNT = 100;\n\n        try {\n            // send lots of messages to the tempQueue\n            for (int i = 0; i < MESSAGE_COUNT; i++) {\n                BytesMessage m = session.createBytesMessage();\n                m.writeBytes(new byte[1024]);\n                if (genericProducer) {"}
{"magic_number_smell": "        publisherConnection.start();\n        final TopicSession publisherSession = publisherConnection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);\n        final TopicPublisher publisher = publisherSession.createPublisher(topic);\n        for (int i = 1; i <= 16; i++) {\n            final Message msg = publisherSession.createTextMessage(\"Message #\" + i);\n            publisher.publish(msg);\n        }", "refactored_code": "    public static final int MESSAGE_COUNT = 16;\n        publisherConnection.start();\n        final TopicSession publisherSession = publisherConnection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);\n        final TopicPublisher publisher = publisherSession.createPublisher(topic);\n        for (int i = 1; i <= MESSAGE_COUNT; i++) {\n            final Message msg = publisherSession.createTextMessage(\"Message #\" + i);\n            publisher.publish(msg);\n        }"}
{"magic_number_smell": "\n        policy = new PolicyEntry();\n        policy.setTopic(\">\");\n        policy.setDurableTopicPrefetch(5);\n        PolicyMap pMap = new PolicyMap();\n        pMap.setDefaultEntry(policy);\n", "refactored_code": "    private static final int PREFETCH_SIZE_5=5;\n\n        policy = new PolicyEntry();\n        policy.setTopic(\">\");\n        policy.setDurableTopicPrefetch(PREFETCH_SIZE_5);\n        PolicyMap pMap = new PolicyMap();\n        pMap.setDefaultEntry(policy);\n"}
{"magic_number_smell": "        brokerService.start();\n        brokerService.waitUntilStarted();\n\n        data = new String[100];\n\n        for (int i = 0; i < 100; i++) {\n            data[i] = \"Text for message: \" + i + \" at \" + new Date();", "refactored_code": "    private final int messageCount = 100;\n        brokerService.start();\n        brokerService.waitUntilStarted();\n\n        data = new String[messageCount];\n\n        for (int i = 0; i < messageCount; i++) {\n            data[i] = \"Text for message: \" + i + \" at \" + new Date();"}
{"magic_number_smell": "            });\n        }\n\n        for (int i=0; i< 20; i++) {\n            executorService.execute(new Runnable() {\n                @Override\n                public void run() {", "refactored_code": "    private final int parallelProducer = 20;\n            });\n        }\n\n        for (int i=0; i< parallelProducer; i++) {\n            executorService.execute(new Runnable() {\n                @Override\n                public void run() {"}
{"magic_number_smell": "            }\n        }, TimeUnit.MINUTES.toMillis(2)));\n\n        LOG.info(\"Sending {} Messages to the Topic.\", 256);\n        // Send some messages to the inactive destination\n        sendMessages(topic);\n", "refactored_code": "    private final int MSG_COUNT = 256;\n            }\n        }, TimeUnit.MINUTES.toMillis(2)));\n\n        LOG.info(\"Sending {} Messages to the Topic.\", MSG_COUNT);\n        // Send some messages to the inactive destination\n        sendMessages(topic);\n"}
{"magic_number_smell": "        service = new BrokerService();\n        service.setPersistent(false);\n        service.setUseJmx(false);\n        connector = service.addConnector(\"tcp://0.0.0.0:0?maximumConnections=\"+100);\n        connectionUri = connector.getPublishableConnectString();\n        service.start();\n        service.waitUntilStarted();", "refactored_code": "    private static final int maxConnections = 100;\n        service = new BrokerService();\n        service.setPersistent(false);\n        service.setUseJmx(false);\n        connector = service.addConnector(\"tcp://0.0.0.0:0?maximumConnections=\"+maxConnections);\n        connectionUri = connector.getPublishableConnectString();\n        service.start();\n        service.waitUntilStarted();"}
{"magic_number_smell": "        List<Future<ProducerTask>> tasks = new ArrayList<Future<ProducerTask>>();\n\n        for (int index = 0; index < 1; index++) {\n            ProducerTask p = new ProducerTask(connectionUri, original, 1000);\n            Future<ProducerTask> future = executor.submit(p, p);\n            tasks.add(future);\n        }", "refactored_code": "    private final int NUM_MSGS = 1000;\n        List<Future<ProducerTask>> tasks = new ArrayList<Future<ProducerTask>>();\n\n        for (int index = 0; index < 1; index++) {\n            ProducerTask p = new ProducerTask(connectionUri, original, NUM_MSGS);\n            Future<ProducerTask> future = executor.submit(p, p);\n            tasks.add(future);\n        }"}
{"magic_number_smell": "        Destination dest = createDestination(\"TEST.FOO\", false);\n        sendMessages(\"Broker0\", dest, 1);\n\n        for (int i=0; i< 3; i++) {\n            MessageConsumer messageConsumer = createConsumer(\"Broker\" + i, dest, \"DoNotConsume = 'true'\");\n\n            for (int J = 0; J < 3; J++) {", "refactored_code": "    public static final int BROKER_COUNT = 3;\n        Destination dest = createDestination(\"TEST.FOO\", false);\n        sendMessages(\"Broker0\", dest, 1);\n\n        for (int i=0; i< BROKER_COUNT; i++) {\n            MessageConsumer messageConsumer = createConsumer(\"Broker\" + i, dest, \"DoNotConsume = 'true'\");\n\n            for (int J = 0; J < BROKER_COUNT; J++) {"}
{"magic_number_smell": "            final MessageProducer remoteProducer = producerSession.createProducer(QUEUE_NAME);\n\n            int i = 0;\n            while (1 > i) {\n                String payload = \"test msg \" + i;\n                TextMessage msg = producerSession.createTextMessage(payload);\n                remoteProducer.send(msg);", "refactored_code": "    protected static final int MESSAGE_COUNT = 1;\n            final MessageProducer remoteProducer = producerSession.createProducer(QUEUE_NAME);\n\n            int i = 0;\n            while (MESSAGE_COUNT > i) {\n                String payload = \"test msg \" + i;\n                TextMessage msg = producerSession.createTextMessage(payload);\n                remoteProducer.send(msg);"}
{"magic_number_smell": "\n    protected static byte[] randomByteArray() {\n        final Random random = new Random();\n        final byte[] byteArray = new byte[random.nextInt(128 * 1024)];\n        random.nextBytes(byteArray);\n\n        return byteArray;", "refactored_code": "    protected static final int MAX_RANDOM_BYTE_ARRAY_SIZE_KB = 128;\n\n    protected static byte[] randomByteArray() {\n        final Random random = new Random();\n        final byte[] byteArray = new byte[random.nextInt(MAX_RANDOM_BYTE_ARRAY_SIZE_KB * 1024)];\n        random.nextBytes(byteArray);\n\n        return byteArray;"}
{"magic_number_smell": "    private static final Logger LOG = LoggerFactory.getLogger(AMQ5421Test.class);\n\n    private static final int 1000 = 1000;\n    private final Destination[] destination = new Destination[1000];\n    private final MessageProducer[] producer = new MessageProducer[1000];\n    private BrokerService brokerService;\n    private String connectionUri;", "refactored_code": "    private static final int DEST_COUNT = 1000;\n    private static final Logger LOG = LoggerFactory.getLogger(AMQ5421Test.class);\n\n    private static final int DEST_COUNT = 1000;\n    private final Destination[] destination = new Destination[DEST_COUNT];\n    private final MessageProducer[] producer = new MessageProducer[DEST_COUNT];\n    private BrokerService brokerService;\n    private String connectionUri;"}
{"magic_number_smell": "        final ConnectionFactory cf = createConnectionFactory();\n        final CountDownLatch startupLatch = new CountDownLatch(1);\n        final List<Exception> exceptions = Collections.synchronizedList(new LinkedList<Exception>());\n        for(int i = 0; i < 100; i++) {\n            executor.submit(new Runnable() {\n                @Override\n                public void run() {", "refactored_code": "    private static final int maxConnections = 100;\n        final ConnectionFactory cf = createConnectionFactory();\n        final CountDownLatch startupLatch = new CountDownLatch(1);\n        final List<Exception> exceptions = Collections.synchronizedList(new LinkedList<Exception>());\n        for(int i = 0; i < maxConnections; i++) {\n            executor.submit(new Runnable() {\n                @Override\n                public void run() {"}
{"magic_number_smell": "\n    @Test(timeout = 60000)\n    public void tesIndividualAcksWithClosedConsumerAndAuditAsync() throws Exception {\n        produceSomeMessages(20);\n\n        QueueViewMBean queueView = getProxyToQueue(getDestinationName());\n        assertEquals(20, queueView.getQueueSize());", "refactored_code": "    private final int MSG_COUNT = 20;\n\n    @Test(timeout = 60000)\n    public void tesIndividualAcksWithClosedConsumerAndAuditAsync() throws Exception {\n        produceSomeMessages(MSG_COUNT);\n\n        QueueViewMBean queueView = getProxyToQueue(getDestinationName());\n        assertEquals(MSG_COUNT, queueView.getQueueSize());"}
{"magic_number_smell": "        // Send one to the destination where we want a matching advisory\n        producer.send(session.createTopic(topicA), session.createMessage());\n\n        for (int i = 0; i < 2000; i++) {\n            BytesMessage m = session.createBytesMessage();\n            m.writeBytes(new byte[1024]);\n            Topic newTopic = session.createTopic(topicPrefix + UUID.randomUUID().toString());", "refactored_code": "    protected final int MESSAGE_COUNT = 2000;\n        // Send one to the destination where we want a matching advisory\n        producer.send(session.createTopic(topicA), session.createMessage());\n\n        for (int i = 0; i < MESSAGE_COUNT; i++) {\n            BytesMessage m = session.createBytesMessage();\n            m.writeBytes(new byte[1024]);\n            Topic newTopic = session.createTopic(topicPrefix + UUID.randomUUID().toString());"}
{"magic_number_smell": "    @Test(timeout=90000)\n    public void testDestinationStatisticsOnPurge() throws Exception {\n        //send messages to the store\n        sendTestMessages(10000);\n\n        //Start up 5 consumers\n        final Queue regionQueue = (Queue) brokerService.getRegionBroker().getDestinationMap().get(queue);", "refactored_code": "    private final int numMessages = 10000;\n    @Test(timeout=90000)\n    public void testDestinationStatisticsOnPurge() throws Exception {\n        //send messages to the store\n        sendTestMessages(numMessages);\n\n        //Start up 5 consumers\n        final Queue regionQueue = (Queue) brokerService.getRegionBroker().getDestinationMap().get(queue);"}
{"magic_number_smell": "\n        connection.start();\n\n        for (int i = 0; i < 150; ++i) {\n            assertNotNull(consumer.receive(5000));\n        }\n", "refactored_code": "    private final int MSG_COUNT = 150;\n\n        connection.start();\n\n        for (int i = 0; i < MSG_COUNT; ++i) {\n            assertNotNull(consumer.receive(5000));\n        }\n"}
{"magic_number_smell": "\n\n        //send X messages with with a sequence number number in the message property.\n        sendMessages(4000);\n\n\n        final BrokerViewMBean brokerView = getBrokerView(broker);", "refactored_code": "    private static final int MESSAGES_TO_SEND = 4000;\n\n\n        //send X messages with with a sequence number number in the message property.\n        sendMessages(MESSAGES_TO_SEND);\n\n\n        final BrokerViewMBean brokerView = getBrokerView(broker);"}
{"magic_number_smell": "\t\t\t\t+ bindAddress);\n\t\tfinal ActiveMQConnectionFactory normalFactory = new ActiveMQConnectionFactory();\n\t\tnormalFactory.setBrokerURL(bindAddress);\n\t\tfor (int i = 0; i < 2000; i++) {\n\n\t\t\tif (i % 100 == 0) {\n\t\t\t\tLOG.info(Integer.toString(i));", "refactored_code": "\tprivate static final int COUNT = 2000;\n\t\t\t\t+ bindAddress);\n\t\tfinal ActiveMQConnectionFactory normalFactory = new ActiveMQConnectionFactory();\n\t\tnormalFactory.setBrokerURL(bindAddress);\n\t\tfor (int i = 0; i < COUNT; i++) {\n\n\t\t\tif (i % 100 == 0) {\n\t\t\t\tLOG.info(Integer.toString(i));"}
{"magic_number_smell": "\t\t\tMessageProducer producer = session.createProducer(destination);\n\t\t\tMessage testMessage = session.createTextMessage(\"test message\");\n\t\t\tproducer.send(testMessage, Message.DEFAULT_DELIVERY_MODE,\n\t\t\t\t\tMessage.DEFAULT_PRIORITY, 1000);\n\t\t\tAssert.assertEquals(1, getSize(destination));\n\n\t\t\t// Wait for the message to expire.", "refactored_code": "\tprivate static final long MESSAGE_TTL_MILLIS = 1000;\n\t\t\tMessageProducer producer = session.createProducer(destination);\n\t\t\tMessage testMessage = session.createTextMessage(\"test message\");\n\t\t\tproducer.send(testMessage, Message.DEFAULT_DELIVERY_MODE,\n\t\t\t\t\tMessage.DEFAULT_PRIORITY, MESSAGE_TTL_MILLIS);\n\t\t\tAssert.assertEquals(1, getSize(destination));\n\n\t\t\t// Wait for the message to expire."}
{"magic_number_smell": "    protected String createMessageText() {\n        StringBuffer buffer = new StringBuffer();\n        buffer.append(\"<filler>\");\n        for (int i = buffer.length(); i < 1024*64; i++) {\n            buffer.append('X');\n        }\n        buffer.append(\"</filler>\");", "refactored_code": "    protected final int messageSize=1024*64;\n    protected String createMessageText() {\n        StringBuffer buffer = new StringBuffer();\n        buffer.append(\"<filler>\");\n        for (int i = buffer.length(); i < messageSize; i++) {\n            buffer.append('X');\n        }\n        buffer.append(\"</filler>\");"}
{"magic_number_smell": "\n    private static final String BROKER_URL = \"tcp://localhost:0\";\n    private static final int 10 = 10;\n    private static final String CONNECTION_URL_OPTIONS = \"?jms.prefetchPolicy.all=\" + 10;\n\n    private static final String DESTINATION = \"QUEUE?consumer.exclusive=true\";\n", "refactored_code": "    private static final int PREFETCH = 10;\n\n    private static final String BROKER_URL = \"tcp://localhost:0\";\n    private static final int PREFETCH = 10;\n    private static final String CONNECTION_URL_OPTIONS = \"?jms.prefetchPolicy.all=\" + PREFETCH;\n\n    private static final String DESTINATION = \"QUEUE?consumer.exclusive=true\";\n"}
{"magic_number_smell": "\n                long c = counter.incrementAndGet();\n\n                // Don't create a new work item for every 10 message. */\n                if (c % 10 != 0) {\n                    // Send new work item to work-item queue.\n                    workItemProducer.send(session", "refactored_code": "    private static final int BATCH_SIZE = 10;\n\n                long c = counter.incrementAndGet();\n\n                // Don't create a new work item for every BATCH_SIZE message. */\n                if (c % BATCH_SIZE != 0) {\n                    // Send new work item to work-item queue.\n                    workItemProducer.send(session"}
{"magic_number_smell": "                try {\n                    Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n                    MessageProducer producer = session.createProducer(new ActiveMQQueue(getDestinationName()));\n                    for (int idx = 0; idx < 10000; ++idx) {\n                        Message message = session.createTextMessage(\"\" + idx);\n                        producer.send(message);\n                        LOG.debug(\"Sending: \" + idx);", "refactored_code": "    private static final int MESSAGES_COUNT = 10000;\n                try {\n                    Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n                    MessageProducer producer = session.createProducer(new ActiveMQQueue(getDestinationName()));\n                    for (int idx = 0; idx < MESSAGES_COUNT; ++idx) {\n                        Message message = session.createTextMessage(\"\" + idx);\n                        producer.send(message);\n                        LOG.debug(\"Sending: \" + idx);"}
{"magic_number_smell": "                    Session session = producerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n                    MessageProducer producer = session.createProducer(destination);\n                    producer.setDeliveryMode(deliveryMode);\n                    for (int idx = 0; idx < 1000; ++idx) {\n                        Message message = session.createTextMessage(new String(buf) + idx);\n\n                        producer.send(message);", "refactored_code": "    private static final int MESSAGES_COUNT = 1000;\n                    Session session = producerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n                    MessageProducer producer = session.createProducer(destination);\n                    producer.setDeliveryMode(deliveryMode);\n                    for (int idx = 0; idx < MESSAGES_COUNT; ++idx) {\n                        Message message = session.createTextMessage(new String(buf) + idx);\n\n                        producer.send(message);"}
{"magic_number_smell": "\n    private BrokerService broker;\n\n    private final CountDownLatch messagesReceivedCountDown = new CountDownLatch(10000);\n    private final CountDownLatch messagesSentCountDown = new CountDownLatch(10000);\n    private final CountDownLatch consumerStartLatch = new CountDownLatch(1);\n", "refactored_code": "    private static final int MAX_MESSAGES = 10000;\n\n    private BrokerService broker;\n\n    private final CountDownLatch messagesReceivedCountDown = new CountDownLatch(MAX_MESSAGES);\n    private final CountDownLatch messagesSentCountDown = new CountDownLatch(MAX_MESSAGES);\n    private final CountDownLatch consumerStartLatch = new CountDownLatch(1);\n"}
{"magic_number_smell": "        Receiver hHectorReceiver = new Receiver() {\n            public void receive(String s) throws Exception {\n                haloToHectorCtr++;\n                if (haloToHectorCtr >= 500) {\n                    synchronized (lock) {\n                        lock.notifyAll();\n                    }", "refactored_code": "    private static final int counter = 500;\n        Receiver hHectorReceiver = new Receiver() {\n            public void receive(String s) throws Exception {\n                haloToHectorCtr++;\n                if (haloToHectorCtr >= counter) {\n                    synchronized (lock) {\n                        lock.notifyAll();\n                    }"}
{"magic_number_smell": "\n\tpublic void setUp() throws Exception {\n\t\tsetAutoFail(true);\n\t\tsetMaxTestTime(300000);\n\t\tsuper.setUp();\n\t}\n", "refactored_code": "\tprivate static final long MAX_TEST_TIME_MILLIS = 300000; // 5min\n\n\tpublic void setUp() throws Exception {\n\t\tsetAutoFail(true);\n\t\tsetMaxTestTime(MAX_TEST_TIME_MILLIS);\n\t\tsuper.setUp();\n\t}\n"}
{"magic_number_smell": "                final MessageConsumer consumer = i.next();\n                if (consumer != null)\n                    do\n                        msg = (TextMessage) consumer.receive(500);\n                    while (msg != null);\n            }\n        } catch (Exception e) {", "refactored_code": "    protected final long RECEIVE_TIMEOUT = 500;\n                final MessageConsumer consumer = i.next();\n                if (consumer != null)\n                    do\n                        msg = (TextMessage) consumer.receive(RECEIVE_TIMEOUT);\n                    while (msg != null);\n            }\n        } catch (Exception e) {"}
{"magic_number_smell": "    }\n\n    public void cleanup() throws JMSException {\n        for (int i = 0; i < 10 * 2; i++) {\n            requestServerConsumer.receive();\n        }\n    }", "refactored_code": "    protected static final int MESSAGE_COUNT = 10;\n    }\n\n    public void cleanup() throws JMSException {\n        for (int i = 0; i < MESSAGE_COUNT * 2; i++) {\n            requestServerConsumer.receive();\n        }\n    }"}
{"magic_number_smell": "\n        Message test = localSession.createTextMessage(payload.toString());\n        producer.send(test);\n        Message msg = consumer1.receive(10000);\n        assertNotNull(msg);\n        ActiveMQTextMessage message = (ActiveMQTextMessage) msg;\n        assertTrue(message.isCompressed());", "refactored_code": "    protected static final int RECEIVE_TIMEOUT_MILLS = 10000;\n\n        Message test = localSession.createTextMessage(payload.toString());\n        producer.send(test);\n        Message msg = consumer1.receive(RECEIVE_TIMEOUT_MILLS);\n        assertNotNull(msg);\n        ActiveMQTextMessage message = (ActiveMQTextMessage) msg;\n        assertTrue(message.isCompressed());"}
{"magic_number_smell": "            assertEquals(1, countMbeans(broker, \"connector\", 30000));\n            assertEquals(0, countMbeans(broker, \"connectionName\"));\n            BrokerService networkedBroker = null;\n            for (int i=0; i<3; i++) {\n                networkedBroker = createNetworkedBroker();\n                try {\n                    networkedBroker.start();", "refactored_code": "    protected final int numRestarts = 3;\n            assertEquals(1, countMbeans(broker, \"connector\", 30000));\n            assertEquals(0, countMbeans(broker, \"connectionName\"));\n            BrokerService networkedBroker = null;\n            for (int i=0; i<numRestarts; i++) {\n                networkedBroker = createNetworkedBroker();\n                try {\n                    networkedBroker.start();"}
{"magic_number_smell": "    protected BrokerService createRemoteBroker() throws Exception {\n        BrokerService broker = new BrokerService();\n        broker.setBrokerName(\"remoteBroker\");\n        broker.addConnector(\"tcp://localhost:\" + 61617);\n        return broker;\n    }\n", "refactored_code": "    private static final int REMOTE_BROKER_TCP_PORT = 61617;\n    protected BrokerService createRemoteBroker() throws Exception {\n        BrokerService broker = new BrokerService();\n        broker.setBrokerName(\"remoteBroker\");\n        broker.addConnector(\"tcp://localhost:\" + REMOTE_BROKER_TCP_PORT);\n        return broker;\n    }\n"}
{"magic_number_smell": "\n        // allow for consumer infos to perculate arround\n        Thread.sleep(2000);\n        long done = System.currentTimeMillis() + (10 * 6000);\n        int i = 0;\n        while (10 > roundTripComplete.get() + remoteDLQCount.get() + replyToNonExistDest.get()\n                && done > System.currentTimeMillis()) {", "refactored_code": "    protected static final int MESSAGE_COUNT = 10;\n\n        // allow for consumer infos to perculate arround\n        Thread.sleep(2000);\n        long done = System.currentTimeMillis() + (MESSAGE_COUNT * 6000);\n        int i = 0;\n        while (MESSAGE_COUNT > roundTripComplete.get() + remoteDLQCount.get() + replyToNonExistDest.get()\n                && done > System.currentTimeMillis()) {"}
{"magic_number_smell": "\t\t// stream broker queues..\n\t\tThread.sleep(BROKER_COUNT*200);\n\t\t\n        for (int i = 0; i < Integer.parseInt(System.getProperty(\"SAMPLES\", \"\"+60*1/5)); i++) {\n\n            long start = System.currentTimeMillis();\n            producedMessages.set(0);", "refactored_code": "    private static final long SAMPLES = Integer.parseInt(System.getProperty(\"SAMPLES\", \"\"+60*1/5)); \n\t\t// stream broker queues..\n\t\tThread.sleep(BROKER_COUNT*200);\n\t\t\n        for (int i = 0; i < SAMPLES; i++) {\n\n            long start = System.currentTimeMillis();\n            producedMessages.set(0);"}
{"magic_number_smell": "\n        waitForConsumerRegistration(localBroker, 1, included);\n\n        for (int i = 0; i < 10; i++) {\n            Message test = localSession.createTextMessage(\"test-\" + i);\n            producer.send(test);\n            Message msg = consumer1.receive(3000);", "refactored_code": "    protected static final int MESSAGE_COUNT = 10;\n\n        waitForConsumerRegistration(localBroker, 1, included);\n\n        for (int i = 0; i < MESSAGE_COUNT; i++) {\n            Message test = localSession.createTextMessage(\"test-\" + i);\n            producer.send(test);\n            Message msg = consumer1.receive(3000);"}
{"magic_number_smell": "    }\n\n    public void testQueueRequestorOverBridge() throws JMSException {\n        for (int i = 0; i < 10; i++) {\n            TextMessage msg = requestServerSession.createTextMessage(\"test msg: \" + i);\n            TextMessage result = (TextMessage)requestor.request(msg);\n            assertNotNull(result);", "refactored_code": "    protected static final int MESSAGE_COUNT = 10;\n    }\n\n    public void testQueueRequestorOverBridge() throws JMSException {\n        for (int i = 0; i < MESSAGE_COUNT; i++) {\n            TextMessage msg = requestServerSession.createTextMessage(\"test msg: \" + i);\n            TextMessage result = (TextMessage)requestor.request(msg);\n            assertNotNull(result);"}
{"magic_number_smell": "    }\n\n    public void testTopicRequestorOverBridge() throws JMSException {\n        for (int i = 0; i < 10; i++) {\n            TextMessage msg = requestServerSession.createTextMessage(\"test msg: \" + i);\n            LOG.info(\"Making request: \" + msg);\n            TextMessage result = (TextMessage)requestor.request(msg);", "refactored_code": "    protected static final int MESSAGE_COUNT = 10;\n    }\n\n    public void testTopicRequestorOverBridge() throws JMSException {\n        for (int i = 0; i < MESSAGE_COUNT; i++) {\n            TextMessage msg = requestServerSession.createTextMessage(\"test msg: \" + i);\n            LOG.info(\"Making request: \" + msg);\n            TextMessage result = (TextMessage)requestor.request(msg);"}
{"magic_number_smell": "    public void testPerformance() throws Exception {\n        ConnectionFactory factory = createConnectionFactory();\n        List<Connection> list = new ArrayList<Connection>();\n        for (int i = 0; i < 200; i++) {\n            Connection connection = factory.createConnection();\n            connection.start();\n            list.add(connection);", "refactored_code": "    protected static final int CONNECTION_COUNT = 200;\n    public void testPerformance() throws Exception {\n        ConnectionFactory factory = createConnectionFactory();\n        List<Connection> list = new ArrayList<Connection>();\n        for (int i = 0; i < CONNECTION_COUNT; i++) {\n            Connection connection = factory.createConnection();\n            connection.start();\n            list.add(connection);"}
{"magic_number_smell": "            assertNotNull(msg);\n            msg.setString(\"key1\", \"value1\");\n            int loop;\n            for (loop = 0; loop < 2000; loop++) {\n                msg.setInt(\"key2\", loop);\n                publisher.send(msg, DELIVERY_MODE, DELIVERY_PRIORITY, Message.DEFAULT_TIME_TO_LIVE);\n                if (loop % 5000 == 0) {", "refactored_code": "    private static final int MESSAGE_COUNT = 2000;\n            assertNotNull(msg);\n            msg.setString(\"key1\", \"value1\");\n            int loop;\n            for (loop = 0; loop < MESSAGE_COUNT; loop++) {\n                msg.setInt(\"key2\", loop);\n                publisher.send(msg, DELIVERY_MODE, DELIVERY_PRIORITY, Message.DEFAULT_TIME_TO_LIVE);\n                if (loop % 5000 == 0) {"}
{"magic_number_smell": "        assertNotNull(msg);\n        msg.setString(\"key1\", \"value1\");\n        int loop;\n        for (loop = 0; loop < 0; loop++) {\n            msg.setInt(\"key2\", loop);\n            publisher.send(msg, DELIVERY_MODE, DELIVERY_PRIORITY, Message.DEFAULT_TIME_TO_LIVE);\n            if (loop % 500 == 0) {", "refactored_code": "    private static final int MESSAGE_COUNT = 0;\n        assertNotNull(msg);\n        msg.setString(\"key1\", \"value1\");\n        int loop;\n        for (loop = 0; loop < MESSAGE_COUNT; loop++) {\n            msg.setInt(\"key2\", loop);\n            publisher.send(msg, DELIVERY_MODE, DELIVERY_PRIORITY, Message.DEFAULT_TIME_TO_LIVE);\n            if (loop % 500 == 0) {"}
{"magic_number_smell": "    public void testPerformance() throws Exception {\n        ConnectionFactory factory = createConnectionFactory();\n        Connection connection = factory.createConnection();\n        for (int i = 0; i < 2000; i++) {\n\n            Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n            Destination dest = session.createTemporaryTopic();", "refactored_code": "    protected static final int MESSAGE_COUNT = 2000;\n    public void testPerformance() throws Exception {\n        ConnectionFactory factory = createConnectionFactory();\n        Connection connection = factory.createConnection();\n        for (int i = 0; i < MESSAGE_COUNT; i++) {\n\n            Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n            Destination dest = session.createTemporaryTopic();"}
{"magic_number_smell": "            long counter = 0;\n\n            // Create and send message\n            for (int i = 0; i < NetworkedSyncTest.10000; i++) {\n\n                String text = \"Hello world! From: \"\n                        + Thread.currentThread().getName() + \" : \"", "refactored_code": "    public static final int MESSAGE_COUNT = 10000; //100000;\n            long counter = 0;\n\n            // Create and send message\n            for (int i = 0; i < NetworkedSyncTest.MESSAGE_COUNT; i++) {\n\n                String text = \"Hello world! From: \"\n                        + Thread.currentThread().getName() + \" : \""}
{"magic_number_smell": "        for (int j = 0; j < NUMBER_OF_DESTINATIONS; j++) {\n            Destination dest = getDestination(session);\n          \n            for (int i = 0; i < 1; i++) {\n                Message msg = session.createTextMessage(\"test\" + i);\n                mp.send(dest, msg);\n                ", "refactored_code": "    protected static final int MESSAGE_COUNT = 1;\n        for (int j = 0; j < NUMBER_OF_DESTINATIONS; j++) {\n            Destination dest = getDestination(session);\n          \n            for (int i = 0; i < MESSAGE_COUNT; i++) {\n                Message msg = session.createTextMessage(\"test\" + i);\n                mp.send(dest, msg);\n                "}
{"magic_number_smell": "        super.setup();\n        \n        cleanAndLoad(\"dc=apache,dc=org\", \"org/apache/activemq/security/activemq-openldap-legacy.ldif\",\n                LDAP_HOST, 389, LDAP_USER, LDAP_PASS, map.open());\n    }\n    \n    @Test", "refactored_code": "    protected static final int LDAP_PORT = 389;\n        super.setup();\n        \n        cleanAndLoad(\"dc=apache,dc=org\", \"org/apache/activemq/security/activemq-openldap-legacy.ldif\",\n                LDAP_HOST, LDAP_PORT, LDAP_USER, LDAP_PASS, map.open());\n    }\n    \n    @Test"}
{"magic_number_smell": "        super.setup();\n        \n        cleanAndLoad(\"dc=apache,dc=org\", \"org/apache/activemq/security/activemq-openldap.ldif\",\n                LDAP_HOST, 389, LDAP_USER, LDAP_PASS, map.open());\n    }\n    \n    @Test", "refactored_code": "    protected static final int LDAP_PORT = 389;\n        super.setup();\n        \n        cleanAndLoad(\"dc=apache,dc=org\", \"org/apache/activemq/security/activemq-openldap.ldif\",\n                LDAP_HOST, LDAP_PORT, LDAP_USER, LDAP_PASS, map.open());\n    }\n    \n    @Test"}
{"magic_number_smell": "        options.put(\"org.apache.activemq.jaas.textfiledn.group\", groupsFile);\n        options.put(\"reload\", \"true\");\n\n        JaasCertificateCallbackHandler[] callbackHandlers = new JaasCertificateCallbackHandler[10];\n        Subject[] subjects = new Subject[10];\n\n        for (int i = 0; i < callbackHandlers.length; i++) {", "refactored_code": "    private static final int NUMBER_SUBJECTS = 10;\n        options.put(\"org.apache.activemq.jaas.textfiledn.group\", groupsFile);\n        options.put(\"reload\", \"true\");\n\n        JaasCertificateCallbackHandler[] callbackHandlers = new JaasCertificateCallbackHandler[NUMBER_SUBJECTS];\n        Subject[] subjects = new Subject[NUMBER_SUBJECTS];\n\n        for (int i = 0; i < callbackHandlers.length; i++) {"}
{"magic_number_smell": "        final long size = sendMessages(10);\n\n        assertTrue(\"Inflight message size should be greater than the content length sent\",\n                Wait.waitFor(() -> getSubscription().getInFlightMessageSize() > size, 10 * 1000, SLEEP_DURATION));\n        assertTrue(\"Inflight sub dispatched message count should equal number of messages sent\",\n                Wait.waitFor(() -> getSubscription().getDispatchedQueueSize() == 10, 10 * 1000, SLEEP_DURATION));\n        assertTrue(\"Destination inflight message count should equal number of messages sent\",", "refactored_code": "    protected final long WAIT_DURATION = 10 * 1000;\n        final long size = sendMessages(10);\n\n        assertTrue(\"Inflight message size should be greater than the content length sent\",\n                Wait.waitFor(() -> getSubscription().getInFlightMessageSize() > size, WAIT_DURATION, SLEEP_DURATION));\n        assertTrue(\"Inflight sub dispatched message count should equal number of messages sent\",\n                Wait.waitFor(() -> getSubscription().getDispatchedQueueSize() == 10, WAIT_DURATION, SLEEP_DURATION));\n        assertTrue(\"Destination inflight message count should equal number of messages sent\","}
{"magic_number_smell": "    protected void writeMessages() throws Exception {\n        final ConnectionContext context = new ConnectionContext();\n\n        for (int i = 0; i < 20; i++) {\n            ActiveMQMessage message = new ActiveMQMessage();\n            final byte[] data = new byte[testMessageSize];\n            final Random rng = new Random();", "refactored_code": "    protected static final int MESSAGE_COUNT = 20;\n    protected void writeMessages() throws Exception {\n        final ConnectionContext context = new ConnectionContext();\n\n        for (int i = 0; i < MESSAGE_COUNT; i++) {\n            ActiveMQMessage message = new ActiveMQMessage();\n            final byte[] data = new byte[testMessageSize];\n            final Random rng = new Random();"}
{"magic_number_smell": "\n    private final int 30 = 30;\n    private final int NUM_PRODUCERS = 1;\n    private final int NUM_TASKS = 30 + NUM_PRODUCERS;\n\n    private final AtomicInteger count = new AtomicInteger();\n    private String MessageId = null;", "refactored_code": "    private final int NUM_CONSUMERS = 30;\n\n    private final int NUM_CONSUMERS = 30;\n    private final int NUM_PRODUCERS = 1;\n    private final int NUM_TASKS = NUM_CONSUMERS + NUM_PRODUCERS;\n\n    private final AtomicInteger count = new AtomicInteger();\n    private String MessageId = null;"}
{"magic_number_smell": "        broker.start();\n\n        factory = new ActiveMQConnectionFactory(\n            connectionUri + \"?jms.prefetchPolicy.all=0&jms.redeliveryPolicy.maximumRedeliveries=\"+10);\n    }\n\n    @Override", "refactored_code": "    protected static final int messagesExpected = 10;\n        broker.start();\n\n        factory = new ActiveMQConnectionFactory(\n            connectionUri + \"?jms.prefetchPolicy.all=0&jms.redeliveryPolicy.maximumRedeliveries=\"+messagesExpected);\n    }\n\n    @Override"}
{"magic_number_smell": "    public void testStatsAndBrowseAfterAckPreparedCommitted() throws Exception {\n\n        factory = new ActiveMQXAConnectionFactory(\n                connectionUri + \"?jms.prefetchPolicy.all=0&jms.redeliveryPolicy.maximumRedeliveries=\" + 1);\n\n        factory.setWatchTopicAdvisories(false);\n        sendMessages(1);", "refactored_code": "    protected static final int messagesExpected = 1;\n    public void testStatsAndBrowseAfterAckPreparedCommitted() throws Exception {\n\n        factory = new ActiveMQXAConnectionFactory(\n                connectionUri + \"?jms.prefetchPolicy.all=0&jms.redeliveryPolicy.maximumRedeliveries=\" + messagesExpected);\n\n        factory.setWatchTopicAdvisories(false);\n        sendMessages(messagesExpected);"}
{"magic_number_smell": "        final AtomicLong sharedCount = new AtomicLong(toSend);\n        long start = System.currentTimeMillis();\n        ExecutorService executorService = Executors.newCachedThreadPool();\n        for (int i=0; i< 20; i++) {\n            executorService.execute(new Runnable() {\n                @Override\n                public void run() {", "refactored_code": "    private final int parallelProducer = 20;\n        final AtomicLong sharedCount = new AtomicLong(toSend);\n        long start = System.currentTimeMillis();\n        ExecutorService executorService = Executors.newCachedThreadPool();\n        for (int i=0; i< parallelProducer; i++) {\n            executorService.execute(new Runnable() {\n                @Override\n                public void run() {"}
{"magic_number_smell": "    public void testConcurrentStoreAndDispatchQueue() throws Exception {\n\n        ExecutorService executor = Executors.newCachedThreadPool();\n        for (int i=0; i<2000; i++) {\n            final int id = ++i;\n            executor.execute(new Runnable() {\n                public void run() {", "refactored_code": "    private static final int MESSAGE_COUNT = 2000;\n    public void testConcurrentStoreAndDispatchQueue() throws Exception {\n\n        ExecutorService executor = Executors.newCachedThreadPool();\n        for (int i=0; i<MESSAGE_COUNT; i++) {\n            final int id = ++i;\n            executor.execute(new Runnable() {\n                public void run() {"}
{"magic_number_smell": "            }\n        }, TimeUnit.MINUTES.toMillis(2)));\n\n        LOG.info(\"Sending {} Messages to the Topic.\", 256);\n        // Send some messages to the inactive destination\n        sendMessages(topic);\n", "refactored_code": "    private final int MSG_COUNT = 256;\n            }\n        }, TimeUnit.MINUTES.toMillis(2)));\n\n        LOG.info(\"Sending {} Messages to the Topic.\", MSG_COUNT);\n        // Send some messages to the inactive destination\n        sendMessages(topic);\n"}
{"magic_number_smell": "\n    \n    public void execute(ActiveMQDestination destination, MessageListener listener) throws Exception {\n        LOG.info(\"Initial query is creating: \" + 10 + \" messages\");\n        for (int i = 0; i < 10; i++) {\n            ActiveMQTextMessage message = new ActiveMQTextMessage();\n            message.setText(\"Initial message: \" + i + \" loaded from query\");", "refactored_code": "    public static final int MESSAGE_COUNT = 10;\n\n    \n    public void execute(ActiveMQDestination destination, MessageListener listener) throws Exception {\n        LOG.info(\"Initial query is creating: \" + MESSAGE_COUNT + \" messages\");\n        for (int i = 0; i < MESSAGE_COUNT; i++) {\n            ActiveMQTextMessage message = new ActiveMQTextMessage();\n            message.setText(\"Initial message: \" + i + \" loaded from query\");"}
{"magic_number_smell": "    }\n\n    protected int expectedReceiveCount() {\n        return 50 * NUMBER_IN_CLUSTER * NUMBER_IN_CLUSTER;\n    }\n\n    protected Connection createConnection(String name) throws Exception {", "refactored_code": "    protected static final int MESSAGE_COUNT = 50;\n    }\n\n    protected int expectedReceiveCount() {\n        return MESSAGE_COUNT * NUMBER_IN_CLUSTER * NUMBER_IN_CLUSTER;\n    }\n\n    protected Connection createConnection(String name) throws Exception {"}
{"magic_number_smell": "\n    @Test\n    public void testMaxConnectionControl() throws Exception {\n        configureConnectorAndStart(transportType + \"://0.0.0.0:0?maxConnectionThreadPoolSize=10&maximumConnections=\"+20);\n\n        final ConnectionFactory cf = createConnectionFactory();\n        final CountDownLatch startupLatch = new CountDownLatch(1);", "refactored_code": "    private static final int maxConnections = 20;\n\n    @Test\n    public void testMaxConnectionControl() throws Exception {\n        configureConnectorAndStart(transportType + \"://0.0.0.0:0?maxConnectionThreadPoolSize=10&maximumConnections=\"+maxConnections);\n\n        final ConnectionFactory cf = createConnectionFactory();\n        final CountDownLatch startupLatch = new CountDownLatch(1);"}
{"magic_number_smell": "\t\tsynchronized (starter) {\n\t\t\tstarter.notifyAll();\n\t\t}\n\t\tfor (int i = 0; i < 10000; i++) {\n\t\t\tMessage message = consumer.receive(500);\n\t\t\tassertNotNull(\"No Message \" + i + \" found\", message);\n", "refactored_code": "\tprivate static final int MESSAGE_COUNT = 10000;\n\t\tsynchronized (starter) {\n\t\t\tstarter.notifyAll();\n\t\t}\n\t\tfor (int i = 0; i < MESSAGE_COUNT; i++) {\n\t\t\tMessage message = consumer.receive(500);\n\t\t\tassertNotNull(\"No Message \" + i + \" found\", message);\n"}
{"magic_number_smell": "    @SuppressWarnings(\"unused\")\n    protected void createClients() throws Exception {\n        ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(clientUrl);\n        for (int i = 0; i < 10; i++) {\n            ActiveMQConnection c = (ActiveMQConnection) factory.createConnection();\n            c.start();\n            Session s = c.createSession(false, Session.AUTO_ACKNOWLEDGE);", "refactored_code": "    private static final int NUMBER = 10;\n    @SuppressWarnings(\"unused\")\n    protected void createClients() throws Exception {\n        ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory(clientUrl);\n        for (int i = 0; i < NUMBER; i++) {\n            ActiveMQConnection c = (ActiveMQConnection) factory.createConnection();\n            c.start();\n            Session s = c.createSession(false, Session.AUTO_ACKNOWLEDGE);"}
{"magic_number_smell": "    }\n\n    protected void createClients() throws Exception {\n        createClients(30);\n    }\n\n    @SuppressWarnings(\"unused\")", "refactored_code": "    protected static final int NUMBER_OF_CLIENTS = 30;\n    }\n\n    protected void createClients() throws Exception {\n        createClients(NUMBER_OF_CLIENTS);\n    }\n\n    @SuppressWarnings(\"unused\")"}
{"magic_number_smell": "                MessageProducer producer = session.createProducer(queue);\n                producer.setDeliveryMode(DeliveryMode.PERSISTENT);\n                while (!stop.get()) {\n                    for (int i = 0; i < 10; i++) {\n                        producer.send(session.createTextMessage(\"TEST:\" + i));\n                    }\n                    for (int i = 0; i < 10; i++) {", "refactored_code": "    public static final int MESSAGES_PER_ITTERATION = 10;\n                MessageProducer producer = session.createProducer(queue);\n                producer.setDeliveryMode(DeliveryMode.PERSISTENT);\n                while (!stop.get()) {\n                    for (int i = 0; i < MESSAGES_PER_ITTERATION; i++) {\n                        producer.send(session.createTextMessage(\"TEST:\" + i));\n                    }\n                    for (int i = 0; i < MESSAGES_PER_ITTERATION; i++) {"}
{"magic_number_smell": "        public void run() {\n            try {\n                //send X messages\n                sendMessages(100, DESTINATION_ONE, sync);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }", "refactored_code": "    private static final int MESSAGES_TO_SEND = 100;\n        public void run() {\n            try {\n                //send X messages\n                sendMessages(MESSAGES_TO_SEND, DESTINATION_ONE, sync);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }"}
{"magic_number_smell": "    public static final int MESSAGE_SIZE = 4096;\n\n    final ConsumerThread[] consumers = new ConsumerThread[CONSUMER_COUNT];\n    final Session[] producerSessions = new Session[10];\n    final Session[] consumerSessions = new Session[CONSUMER_COUNT];\n\n    byte[] messageData;", "refactored_code": "    public static final int PRODUCER_COUNT = 10;\n    public static final int MESSAGE_SIZE = 4096;\n\n    final ConsumerThread[] consumers = new ConsumerThread[CONSUMER_COUNT];\n    final Session[] producerSessions = new Session[PRODUCER_COUNT];\n    final Session[] consumerSessions = new Session[CONSUMER_COUNT];\n\n    byte[] messageData;"}
{"magic_number_smell": "    @Test\n    public void testLoad() throws Exception {\n        Queue dest = session.createQueue(\"TEST\");\n        for (int i = 0; i < 10; i++) {\n            ProducerThread producer = new ProducerThread(session, dest);\n            producer.setMessageCount(MESSAGE_COUNT);\n            producer.start();", "refactored_code": "    public static final int PRODUCER_COUNT = 10;\n    @Test\n    public void testLoad() throws Exception {\n        Queue dest = session.createQueue(\"TEST\");\n        for (int i = 0; i < PRODUCER_COUNT; i++) {\n            ProducerThread producer = new ProducerThread(session, dest);\n            producer.setMessageCount(MESSAGE_COUNT);\n            producer.start();"}
{"magic_number_smell": "     * @throws Exception\n     */\n    public void testSendReceive() throws Exception {\n        for (int i = 0; i < 50; i++) {\n            for (int x = 0; x < producers.length; x++) {\n                TextMessage textMessage = new ActiveMQTextMessage();\n                textMessage.setText(\"MSG-NO: \" + i + \" in cluster: \" + x);", "refactored_code": "    protected static final int MESSAGE_COUNT = 50;\n     * @throws Exception\n     */\n    public void testSendReceive() throws Exception {\n        for (int i = 0; i < MESSAGE_COUNT; i++) {\n            for (int x = 0; x < producers.length; x++) {\n                TextMessage textMessage = new ActiveMQTextMessage();\n                textMessage.setText(\"MSG-NO: \" + i + \" in cluster: \" + x);"}
{"magic_number_smell": "    public static final int FALSE = 0;\n    public static final int TRUE = 1;\n    \n    private int wantClientAuthStatus = -1;\n    private int needClientAuthStatus = -1;\n    \n    public StubSSLServerSocket() throws IOException {", "refactored_code": "    public static final int UNTOUCHED = -1;\n    public static final int FALSE = 0;\n    public static final int TRUE = 1;\n    \n    private int wantClientAuthStatus = UNTOUCHED;\n    private int needClientAuthStatus = UNTOUCHED;\n    \n    public StubSSLServerSocket() throws IOException {"}
{"magic_number_smell": "    public static final int FALSE = 0;\n    public static final int TRUE = 1;\n\n    private int wantClientAuthStatus = -1;\n    private int needClientAuthStatus = -1;\n    private int useClientModeStatus = -1;\n    private final StubSSLSession session;", "refactored_code": "    public static final int UNTOUCHED = -1;\n    public static final int FALSE = 0;\n    public static final int TRUE = 1;\n\n    private int wantClientAuthStatus = UNTOUCHED;\n    private int needClientAuthStatus = UNTOUCHED;\n    private int useClientModeStatus = UNTOUCHED;\n    private final StubSSLSession session;"}
{"magic_number_smell": "    public static final int FALSE = 0;\n    public static final int TRUE = 1;\n\n    private int wantClientAuthStatus = -1;\n    private int needClientAuthStatus = -1;\n\n    public StubSslTransport(WireFormat wireFormat, SSLSocket socket) throws Exception {", "refactored_code": "    public static final int UNTOUCHED = -1;\n    public static final int FALSE = 0;\n    public static final int TRUE = 1;\n\n    private int wantClientAuthStatus = UNTOUCHED;\n    private int needClientAuthStatus = UNTOUCHED;\n\n    public StubSslTransport(WireFormat wireFormat, SSLSocket socket) throws Exception {"}
{"magic_number_smell": "        \"vm://localhost?broker.persistent=false&create=false\";\n\n    private static final String VM_BROKER_URI_WAIT_FOR_START =\n        VM_BROKER_URI_NO_WAIT + \"&waitForStart=\" + 20000;\n\n    private static final String VM_BROKER_URI_SHORT_WAIT_FOR_START =\n        VM_BROKER_URI_NO_WAIT + \"&waitForStart=\" + SHORT_WAIT_TIME;", "refactored_code": "    private static final int WAIT_TIME = 20000;\n        \"vm://localhost?broker.persistent=false&create=false\";\n\n    private static final String VM_BROKER_URI_WAIT_FOR_START =\n        VM_BROKER_URI_NO_WAIT + \"&waitForStart=\" + WAIT_TIME;\n\n    private static final String VM_BROKER_URI_SHORT_WAIT_FOR_START =\n        VM_BROKER_URI_NO_WAIT + \"&waitForStart=\" + SHORT_WAIT_TIME;"}
{"magic_number_smell": "        MessageConsumer consumer = subType.equals(SubType.DURABLE) ?\n                session.createDurableSubscriber(topic, \"sub1\") : session.createConsumer(destination);\n        MessageProducer producer = session.createProducer(destination);\n        for (int i = 0; i < 10; i++) {\n            TextMessage m = session.createTextMessage(\"test\");\n            m.setStringProperty(\"test\", \"test\");\n            producer.send(m);", "refactored_code": "    private final int numMessages = 10;\n        MessageConsumer consumer = subType.equals(SubType.DURABLE) ?\n                session.createDurableSubscriber(topic, \"sub1\") : session.createConsumer(destination);\n        MessageProducer producer = session.createProducer(destination);\n        for (int i = 0; i < numMessages; i++) {\n            TextMessage m = session.createTextMessage(\"test\");\n            m.setStringProperty(\"test\", \"test\");\n            producer.send(m);"}
{"magic_number_smell": "            }\n            networkDownTimeStart = System.currentTimeMillis();\n        } else if (networkDownTimeStart > 0) {\n             // restart after 5000 seconds\n             if (networkDownTimeStart + 5000 < System.currentTimeMillis()) {\n                 if (simulateStalledNetwork) {\n                     socketProxy.goOn();", "refactored_code": "    private static final int NETWORK_DOWN_TIME = 5000;\n            }\n            networkDownTimeStart = System.currentTimeMillis();\n        } else if (networkDownTimeStart > 0) {\n             // restart after NETWORK_DOWN_TIME seconds\n             if (networkDownTimeStart + NETWORK_DOWN_TIME < System.currentTimeMillis()) {\n                 if (simulateStalledNetwork) {\n                     socketProxy.goOn();"}
{"magic_number_smell": "        Connection connection = factory.createConnection();\n        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n        MessageProducer producer = session.createProducer(testQueue);\n        for (int i = 0; i < 100; i++) {\n            producer.send(testQueue,session.createTextMessage(\"Hello world #\"  + i), DeliveryMode.PERSISTENT,\n                    4, 500);\n        }", "refactored_code": "    private static final int NUM_MESSAGES = 100;\n        Connection connection = factory.createConnection();\n        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n        MessageProducer producer = session.createProducer(testQueue);\n        for (int i = 0; i < NUM_MESSAGES; i++) {\n            producer.send(testQueue,session.createTextMessage(\"Hello world #\"  + i), DeliveryMode.PERSISTENT,\n                    4, 500);\n        }"}
{"magic_number_smell": "\n        Destination dest = createDestination(\"TEST.FOO\", false);\n\n        sendMessages(\"BrokerA\", dest, 10);\n\n        Thread.sleep(1000);\n", "refactored_code": "    protected static final int MESSAGE_COUNT = 10;\n\n        Destination dest = createDestination(\"TEST.FOO\", false);\n\n        sendMessages(\"BrokerA\", dest, MESSAGE_COUNT);\n\n        Thread.sleep(1000);\n"}
{"magic_number_smell": "        MessageProducer producer = publisherSession.createProducer(destination);\n        HashMap<String, Integer> map = new HashMap<String, Integer>();\n        ObjectMessage message = publisherSession.createObjectMessage();\n        for (int i = 0; i < 200; i++) {\n            map.put(VALUE_NAME, i);\n            message.setObject(map);\n            producer.send(message);", "refactored_code": "    private static final int COUNT = 200;\n        MessageProducer producer = publisherSession.createProducer(destination);\n        HashMap<String, Integer> map = new HashMap<String, Integer>();\n        ObjectMessage message = publisherSession.createObjectMessage();\n        for (int i = 0; i < COUNT; i++) {\n            map.put(VALUE_NAME, i);\n            message.setObject(map);\n            producer.send(message);"}
{"magic_number_smell": "        assertTrue(\"max X times as slow with consumer: \" + withConsumerStats[1] + \", with no Consumer: \" + noConsumerStats[1] + \", multiplier: \"\n            + (withConsumerStats[1] / noConsumerStats[1]), withConsumerStats[1] < noConsumerStats[1] * reasonableMultiplier);\n\n        final int toReceive = toSend * numIterations * 5 * 2;\n        Wait.waitFor(new Wait.Condition() {\n            @Override\n            public boolean isSatisified() throws Exception {", "refactored_code": "    private final int consumerCount = 5;\n        assertTrue(\"max X times as slow with consumer: \" + withConsumerStats[1] + \", with no Consumer: \" + noConsumerStats[1] + \", multiplier: \"\n            + (withConsumerStats[1] / noConsumerStats[1]), withConsumerStats[1] < noConsumerStats[1] * reasonableMultiplier);\n\n        final int toReceive = toSend * numIterations * consumerCount * 2;\n        Wait.waitFor(new Wait.Condition() {\n            @Override\n            public boolean isSatisified() throws Exception {"}
{"magic_number_smell": "                + noConsumerStats[1] + \", multiplier: \" + (withConsumerStats[1]/noConsumerStats[1]),\n                withConsumerStats[1] < noConsumerStats[1] * reasonableMultiplier);\n\n        final int toReceive = toSend * numIterations * 5 * 2;\n        Wait.waitFor(new Wait.Condition() {\n            public boolean isSatisified() throws Exception {\n                LOG.info(\"count: \" + allMessagesList.getMessageCount());", "refactored_code": "    private final int consumerCount = 5;\n                + noConsumerStats[1] + \", multiplier: \" + (withConsumerStats[1]/noConsumerStats[1]),\n                withConsumerStats[1] < noConsumerStats[1] * reasonableMultiplier);\n\n        final int toReceive = toSend * numIterations * consumerCount * 2;\n        Wait.waitFor(new Wait.Condition() {\n            public boolean isSatisified() throws Exception {\n                LOG.info(\"count: \" + allMessagesList.getMessageCount());"}
{"magic_number_smell": "        // workaround is to ensure sufficient dispatch buffer for the destination\n        PolicyMap policyMap = new PolicyMap();\n        PolicyEntry defaultPolicy = new PolicyEntry();\n        defaultPolicy.setMaxPageSize(5000);\n        policyMap.setDefaultEntry(defaultPolicy);\n        broker.setDestinationPolicy(policyMap);\n        broker.start();", "refactored_code": "    private final int testSize = 5000; // setting this to a small number will pass all tests\n        // workaround is to ensure sufficient dispatch buffer for the destination\n        PolicyMap policyMap = new PolicyMap();\n        PolicyEntry defaultPolicy = new PolicyEntry();\n        defaultPolicy.setMaxPageSize(testSize);\n        policyMap.setDefaultEntry(defaultPolicy);\n        broker.setDestinationPolicy(policyMap);\n        broker.start();"}
{"magic_number_smell": "        int counter = 1;\n        for (int i = 0; i < 15; i++) {\n            makeConsumer(Session.AUTO_ACKNOWLEDGE);\n            Message message = consumer.receive(5000L);\n            assertTrue(\"Should have received a message!\", message != null);\n            LOG.info(\"Received message \" + counter++);\n            message = consumer.receive(5000L);", "refactored_code": "    protected static final long RECEIVE_TIMEOUT = 5000L;\n        int counter = 1;\n        for (int i = 0; i < 15; i++) {\n            makeConsumer(Session.AUTO_ACKNOWLEDGE);\n            Message message = consumer.receive(RECEIVE_TIMEOUT);\n            assertTrue(\"Should have received a message!\", message != null);\n            LOG.info(\"Received message \" + counter++);\n            message = consumer.receive(RECEIVE_TIMEOUT);"}
{"magic_number_smell": "        houseKeeper.start();\n\n        // Sleep to\n        Thread.sleep(2 * 60 * 1000);\n\n        // inform message producer to stop\n        server.stopped = true;", "refactored_code": "    private static final long RUNTIME = 2 * 60 * 1000;\n        houseKeeper.start();\n\n        // Sleep to\n        Thread.sleep(RUNTIME);\n\n        // inform message producer to stop\n        server.stopped = true;"}
{"magic_number_smell": "                houseKeeper.start();\n\n            if (BROKER_RESTART <= 0)\n                Thread.sleep(5 * 60 * 1000);\n            else {\n                long end = System.currentTimeMillis() + 5 * 60 * 1000;\n", "refactored_code": "    public static final long RUNTIME = 5 * 60 * 1000;\n                houseKeeper.start();\n\n            if (BROKER_RESTART <= 0)\n                Thread.sleep(RUNTIME);\n            else {\n                long end = System.currentTimeMillis() + RUNTIME;\n"}
{"magic_number_smell": "            durableSubscriber.start();\n            msgProducer.start();\n\n            long endTime = System.currentTimeMillis() + 1 * 60 * 1000;\n\n            while (endTime > System.currentTimeMillis()) {\n                Thread.sleep(10000);", "refactored_code": "    public static final long RUNTIME = 1 * 60 * 1000;\n            durableSubscriber.start();\n            msgProducer.start();\n\n            long endTime = System.currentTimeMillis() + RUNTIME;\n\n            while (endTime > System.currentTimeMillis()) {\n                Thread.sleep(10000);"}
{"magic_number_smell": "            if (ALLOW_SUBSCRIPTION_ABANDONMENT)\n                houseKeeper.start();\n\n            Thread.sleep(4 * 60 * 1000);\n            assertTrue(\"no exceptions: \" + exceptions, exceptions.isEmpty());\n        }\n        catch (Throwable e) {", "refactored_code": "    public static final long RUNTIME = 4 * 60 * 1000;\n            if (ALLOW_SUBSCRIPTION_ABANDONMENT)\n                houseKeeper.start();\n\n            Thread.sleep(RUNTIME);\n            assertTrue(\"no exceptions: \" + exceptions, exceptions.isEmpty());\n        }\n        catch (Throwable e) {"}
{"magic_number_smell": "            if (ALLOW_SUBSCRIPTION_ABANDONMENT)\n                houseKeeper.start();\n\n            long end = System.currentTimeMillis() + 5 * 60 * 1000;\n\n            while (true) {\n                long now = System.currentTimeMillis();", "refactored_code": "    public static final long RUNTIME = 5 * 60 * 1000;\n            if (ALLOW_SUBSCRIPTION_ABANDONMENT)\n                houseKeeper.start();\n\n            long end = System.currentTimeMillis() + RUNTIME;\n\n            while (true) {\n                long now = System.currentTimeMillis();"}
{"magic_number_smell": "        protected transient MessageProducer producer;\n        protected static final int 1024 = 1024;\n\n        public Producer(String brokerURL, String interest, int 1024, long ttl) throws JMSException {\n\n            factory = new ActiveMQConnectionFactory(brokerURL);\n            connection = factory.createConnection();", "refactored_code": "        protected static final int messageSize = 1024;\n        protected transient MessageProducer producer;\n        protected static final int messageSize = 1024;\n\n        public Producer(String brokerURL, String interest, int messageSize, long ttl) throws JMSException {\n\n            factory = new ActiveMQConnectionFactory(brokerURL);\n            connection = factory.createConnection();"}
{"magic_number_smell": "                }\n                networkDownTimeStart = System.currentTimeMillis();\n            } else if (networkDownTimeStart > 0) {\n                // restart after 10000 seconds\n                sleep(10000);\n                networkDownTimeStart = 0;\n                if (simulateStalledNetwork) {", "refactored_code": "    private static final int NETWORK_DOWN_TIME = 10000;\n                }\n                networkDownTimeStart = System.currentTimeMillis();\n            } else if (networkDownTimeStart > 0) {\n                // restart after NETWORK_DOWN_TIME seconds\n                sleep(NETWORK_DOWN_TIME);\n                networkDownTimeStart = 0;\n                if (simulateStalledNetwork) {"}
{"magic_number_smell": "\n        final String payloadString = new String(new byte[10*1024]);\n        // Send messages\n        for (int i = 0; i < 10; i++) {\n            Message test = sesSpoke.createTextMessage(\"test-\" + i);\n            test.setStringProperty(\"payload\", payloadString);\n            localProducer.send(test);", "refactored_code": "    protected static final int MESSAGE_COUNT = 10;\n\n        final String payloadString = new String(new byte[10*1024]);\n        // Send messages\n        for (int i = 0; i < MESSAGE_COUNT; i++) {\n            Message test = sesSpoke.createTextMessage(\"test-\" + i);\n            test.setStringProperty(\"payload\", payloadString);\n            localProducer.send(test);"}
{"magic_number_smell": "        publishToTopic(session, topic, 8);\n\n        // Standard subscriber should receive them\n        for (int i = 0; i < 5; ++i) {\n            Message message = durableSubscriber.receive(2000);\n            assertNotNull(message);\n            assertEquals(9, message.getJMSPriority());", "refactored_code": "    private final int MSG_COUNT = 5;\n        publishToTopic(session, topic, 8);\n\n        // Standard subscriber should receive them\n        for (int i = 0; i < MSG_COUNT; ++i) {\n            Message message = durableSubscriber.receive(2000);\n            assertNotNull(message);\n            assertEquals(9, message.getJMSPriority());"}
{"magic_number_smell": "        TopicSubscriber subscriber = session.createSubscriber(topic);\n        TopicSubscriber durableSub = session.createDurableSubscriber(topic, getSubscriptionName(), null, true);\n\n        LOG.debug(\"Sending \" + 10 + \" messages to topic\");\n        for (int i = 0; i < 10; i++) {\n            publisher.publish(session.createMessage());\n        }", "refactored_code": "    private final int MSG_COUNT = 10;\n        TopicSubscriber subscriber = session.createSubscriber(topic);\n        TopicSubscriber durableSub = session.createDurableSubscriber(topic, getSubscriptionName(), null, true);\n\n        LOG.debug(\"Sending \" + MSG_COUNT + \" messages to topic\");\n        for (int i = 0; i < MSG_COUNT; i++) {\n            publisher.publish(session.createMessage());\n        }"}
{"magic_number_smell": "\n        @Override\n        public void run() {\n            long endTime = 3 * 60 * 1000 + System.currentTimeMillis();\n\n            try {\n                while (endTime > System.currentTimeMillis()) {", "refactored_code": "    public static final long RUNTIME = 3 * 60 * 1000;\n\n        @Override\n        public void run() {\n            long endTime = RUNTIME + System.currentTimeMillis();\n\n            try {\n                while (endTime > System.currentTimeMillis()) {"}
{"magic_number_smell": "\n        @Override\n        public void run() {\n            long endTime = 1 * 60 * 1000 + System.currentTimeMillis();\n\n            try {\n                while (endTime > System.currentTimeMillis()) {", "refactored_code": "    public static final long RUNTIME = 1 * 60 * 1000;\n\n        @Override\n        public void run() {\n            long endTime = RUNTIME + System.currentTimeMillis();\n\n            try {\n                while (endTime > System.currentTimeMillis()) {"}
{"magic_number_smell": "\n        // wait checkpoint\n        // When we create a new consumer a KahaProducerAuditCommand written to the journal files changing the lastUpdate pointer\n        Thread.sleep(500 * 2);\n\n        for (int i = 0; i < 5; i++) {\n            sendMessage(session, producer);", "refactored_code": "    private static final int CHECKPOINT_INTERVAL = 500;\n\n        // wait checkpoint\n        // When we create a new consumer a KahaProducerAuditCommand written to the journal files changing the lastUpdate pointer\n        Thread.sleep(CHECKPOINT_INTERVAL * 2);\n\n        for (int i = 0; i < 5; i++) {\n            sendMessage(session, producer);"}
{"magic_number_smell": "        Thread.sleep(2000); //wait for subs to propagate\n\n        // send/receive messages\n        sendMessages(\"broker-A\", dest, 50);\n        received.waitForMessagesToArrive(50);\n        LOG.info(\"received \" +  received.getMessageCount() + \" messages\");\n        assertEquals(50, received.getMessageCount());", "refactored_code": "    public static final int MESSAGE_COUNT = 50;\n        Thread.sleep(2000); //wait for subs to propagate\n\n        // send/receive messages\n        sendMessages(\"broker-A\", dest, MESSAGE_COUNT);\n        received.waitForMessagesToArrive(MESSAGE_COUNT);\n        LOG.info(\"received \" +  received.getMessageCount() + \" messages\");\n        assertEquals(MESSAGE_COUNT, received.getMessageCount());"}
{"magic_number_smell": "        // Setup topic destination\n        Destination dest = createDestination(\"TEST.FOO\", true);\n\n        CountDownLatch latch = new CountDownLatch(6 * PRODUCER_COUNT * 6 * CONSUMER_COUNT * MESSAGE_COUNT);\n\n        // Setup consumers\n        for (int i = 1; i <= 6; i++) {", "refactored_code": "    public static final int BROKER_COUNT = 6; // number of brokers to network\n        // Setup topic destination\n        Destination dest = createDestination(\"TEST.FOO\", true);\n\n        CountDownLatch latch = new CountDownLatch(BROKER_COUNT * PRODUCER_COUNT * BROKER_COUNT * CONSUMER_COUNT * MESSAGE_COUNT);\n\n        // Setup consumers\n        for (int i = 1; i <= BROKER_COUNT; i++) {"}
{"magic_number_smell": "        sleep(600);\n        \n        // Send messages\n        sendMessages(SPOKE, dest, 200);\n\n        MessageIdList msgs = getConsumerMessages(HUB, client);\n\tmsgs.setMaximumDuration(200000L);", "refactored_code": "    protected static final int MESSAGE_COUNT = 200;\n        sleep(600);\n        \n        // Send messages\n        sendMessages(SPOKE, dest, MESSAGE_COUNT);\n\n        MessageIdList msgs = getConsumerMessages(HUB, client);\n\tmsgs.setMaximumDuration(200000L);"}
{"magic_number_smell": "    @Override\n    protected void setUp() throws Exception {\n        setAutoFail(true);\n        setMaxTestTime(120000);\n        super.setUp();\n    }\n", "refactored_code": "    private static final long MAX_TEST_TIME = 120000;\n    @Override\n    protected void setUp() throws Exception {\n        setAutoFail(true);\n        setMaxTestTime(MAX_TEST_TIME);\n        super.setUp();\n    }\n"}
{"magic_number_smell": "        session.commit();\n        connection.start();\n\n        assertTrue(\"Pre-Rollback expects to receive: \" + 100 + \" messages.\",\n            Wait.waitFor(new Wait.Condition(){\n                @Override\n                public boolean isSatisified() throws Exception {", "refactored_code": "    private final int MSG_COUNT = 100;\n        session.commit();\n        connection.start();\n\n        assertTrue(\"Pre-Rollback expects to receive: \" + MSG_COUNT + \" messages.\",\n            Wait.waitFor(new Wait.Condition(){\n                @Override\n                public boolean isSatisified() throws Exception {"}
{"magic_number_smell": "    public void testMessageDeliveryOrderAfterPrefetch() throws Exception {\n\n        //send X messages with with a sequence number number in the message property.\n        sendMessages(1000);\n\n        for (int i = 0; i < (1000 / MESSAGES_PER_CONSUMER); i++) {\n            totalConsumed += consumeMessages(MESSAGES_PER_CONSUMER);", "refactored_code": "    private static final int MESSAGES_TO_SEND = 1000;\n    public void testMessageDeliveryOrderAfterPrefetch() throws Exception {\n\n        //send X messages with with a sequence number number in the message property.\n        sendMessages(MESSAGES_TO_SEND);\n\n        for (int i = 0; i < (MESSAGES_TO_SEND / MESSAGES_PER_CONSUMER); i++) {\n            totalConsumed += consumeMessages(MESSAGES_PER_CONSUMER);"}
{"magic_number_smell": "        broker.waitUntilStarted();\n\n        PolicyEntry policy = new PolicyEntry();\n        policy.setMaxBrowsePageSize(300);\n        broker.setDestinationPolicy(new PolicyMap());\n        broker.getDestinationPolicy().setDefaultEntry(policy);\n", "refactored_code": "    private final int browserLimit = 300;\n        broker.waitUntilStarted();\n\n        PolicyEntry policy = new PolicyEntry();\n        policy.setMaxBrowsePageSize(browserLimit);\n        broker.setDestinationPolicy(new PolicyMap());\n        broker.getDestinationPolicy().setDefaultEntry(policy);\n"}
{"magic_number_smell": "        broker.waitUntilStarted();\n\n        PolicyEntry policy = new PolicyEntry();\n        policy.setMaxPageSize(100);\n        broker.setDestinationPolicy(new PolicyMap());\n        broker.getDestinationPolicy().setDefaultEntry(policy);\n", "refactored_code": "    private final int maxPageSize = 100;\n        broker.waitUntilStarted();\n\n        PolicyEntry policy = new PolicyEntry();\n        policy.setMaxPageSize(maxPageSize);\n        broker.setDestinationPolicy(new PolicyMap());\n        broker.getDestinationPolicy().setDefaultEntry(policy);\n"}
{"magic_number_smell": "        messageSize = 1024;\n        \n        // Setup n brokers\n        for (int i = 1; i <= 2; i++) {\n            createBroker(new URI(\"broker:()/Broker\" + i + \"?persistent=false&useJmx=false\"));\n        }\n        BrokerService broker2 = brokers.get(\"Broker2\").broker;", "refactored_code": "    public static final int BROKER_COUNT = 2;\n        messageSize = 1024;\n        \n        // Setup n brokers\n        for (int i = 1; i <= BROKER_COUNT; i++) {\n            createBroker(new URI(\"broker:()/Broker\" + i + \"?persistent=false&useJmx=false\"));\n        }\n        BrokerService broker2 = brokers.get(\"Broker2\").broker;"}
{"magic_number_smell": "    @Test(timeout=120000)\n    public void testPriorityMessages() throws Exception {\n\n        for (int i = 0; i < 2; i++) {\n\n            // send 4 message priority MEDIUM\n            produceMessages(4, 4, \"TestQ\");", "refactored_code": "    private final int ITERATIONS = 2;\n    @Test(timeout=120000)\n    public void testPriorityMessages() throws Exception {\n\n        for (int i = 0; i < ITERATIONS; i++) {\n\n            // send 4 message priority MEDIUM\n            produceMessages(4, 4, \"TestQ\");"}
{"magic_number_smell": "    protected AtomicBoolean closeBroker = new AtomicBoolean(false);\n    protected AtomicInteger messagesReceived = new AtomicInteger(0);\n    protected BrokerService broker;\n    protected int firstBatch = 100 / 10;\n    private IdGenerator idGen = new IdGenerator();\n\n    public ReliableReconnectTest() {", "refactored_code": "    protected static final int MESSAGE_COUNT = 100;\n    protected AtomicBoolean closeBroker = new AtomicBoolean(false);\n    protected AtomicInteger messagesReceived = new AtomicInteger(0);\n    protected BrokerService broker;\n    protected int firstBatch = MESSAGE_COUNT / 10;\n    private IdGenerator idGen = new IdGenerator();\n\n    public ReliableReconnectTest() {"}
{"magic_number_smell": "\n        ActiveMQSession consumerSession = (ActiveMQSession)consumerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n        MessageConsumer consumer = consumerSession.createConsumer(sendQ);\n        TextMessage received = (TextMessage) consumer.receive(30000);\n        assertNotNull(\"got request from sender ok\", received);\n\n        LOG.info(\"got request, sending reply\");", "refactored_code": "    private final long receiveTimeout = 30000;\n\n        ActiveMQSession consumerSession = (ActiveMQSession)consumerConnection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n        MessageConsumer consumer = consumerSession.createConsumer(sendQ);\n        TextMessage received = (TextMessage) consumer.receive(receiveTimeout);\n        assertNotNull(\"got request from sender ok\", received);\n\n        LOG.info(\"got request, sending reply\");"}
{"magic_number_smell": "        ActiveMQConnectionFactory brokerAFactory = new ActiveMQConnectionFactory(brokerA.broker.getTransportConnectorByScheme(\"tcp\").getName()\n                + \"?jms.watchTopicAdvisories=false\");\n        brokerAFactory.setAlwaysSyncSend(true);\n        for (int i = 0; i < 1; i++) {\n            respondentThreadPool.execute(new EchoRespondent(brokerAFactory));\n        }\n", "refactored_code": "    private static final int NUM_RESPONDENTS = 1;\n        ActiveMQConnectionFactory brokerAFactory = new ActiveMQConnectionFactory(brokerA.broker.getTransportConnectorByScheme(\"tcp\").getName()\n                + \"?jms.watchTopicAdvisories=false\");\n        brokerAFactory.setAlwaysSyncSend(true);\n        for (int i = 0; i < NUM_RESPONDENTS; i++) {\n            respondentThreadPool.execute(new EchoRespondent(brokerAFactory));\n        }\n"}
{"magic_number_smell": "        // Execute up to 20 clients at a time to simulate that load.\n        //\n\n        clientExecPool = new ThreadPoolExecutor(5, 5, 0, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(10000));\n        clientCompletionLatch = new CountDownLatch(TOTAL_CLIENT_ITER);\n\n        // Use threads to avoid startup deadlock since the first broker started waits until", "refactored_code": "    protected static final int CONCURRENT_CLIENT_COUNT = 5;\n        // Execute up to 20 clients at a time to simulate that load.\n        //\n\n        clientExecPool = new ThreadPoolExecutor(CONCURRENT_CLIENT_COUNT, CONCURRENT_CLIENT_COUNT, 0, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(10000));\n        clientCompletionLatch = new CountDownLatch(TOTAL_CLIENT_ITER);\n\n        // Use threads to avoid startup deadlock since the first broker started waits until"}
{"magic_number_smell": "        MessageConsumer clientC = createConsumer(\"BrokerC\", dest);\n\n        // Send messages\n        sendMessages(\"BrokerA\", dest, 100);\n\n        // Let's try to wait for any messages. Should be none.\n        Thread.sleep(1000);", "refactored_code": "    protected static final int MESSAGE_COUNT = 100;\n        MessageConsumer clientC = createConsumer(\"BrokerC\", dest);\n\n        // Send messages\n        sendMessages(\"BrokerA\", dest, MESSAGE_COUNT);\n\n        // Let's try to wait for any messages. Should be none.\n        Thread.sleep(1000);"}
{"magic_number_smell": "\n            @Override\n            public void run() {\n                for (int i = 0; i < 100; i++) {\n\n                    Connection conn = null;\n                    try {", "refactored_code": "    private static final int NUM_ITER = 100;\n\n            @Override\n            public void run() {\n                for (int i = 0; i < NUM_ITER; i++) {\n\n                    Connection conn = null;\n                    try {"}
{"magic_number_smell": "        //let consumers propagate around the network\n        Thread.sleep(2000);\n        // Send messages\n        sendMessages(\"BrokerA\", dest, 100);\n        sendMessages(\"BrokerB\", dest, 100);\n        sendMessages(\"BrokerC\", dest, 100);\n", "refactored_code": "    protected static final int MESSAGE_COUNT = 100;\n        //let consumers propagate around the network\n        Thread.sleep(2000);\n        // Send messages\n        sendMessages(\"BrokerA\", dest, MESSAGE_COUNT);\n        sendMessages(\"BrokerB\", dest, MESSAGE_COUNT);\n        sendMessages(\"BrokerC\", dest, MESSAGE_COUNT);\n"}
{"magic_number_smell": "\n\n    private String createMessageText(int index) {\n        StringBuffer buffer = new StringBuffer(4000);\n        buffer.append(\"Message: \" + index + \" sent at: \" + new Date());\n        if (buffer.length() > 4000) {\n            return buffer.substring(0, 4000);", "refactored_code": "    private final int messageSize = 4000;\n\n\n    private String createMessageText(int index) {\n        StringBuffer buffer = new StringBuffer(messageSize);\n        buffer.append(\"Message: \" + index + \" sent at: \" + new Date());\n        if (buffer.length() > messageSize) {\n            return buffer.substring(0, messageSize);"}
{"magic_number_smell": "        broker.addConnector(brokerUrl);\n        broker.setAdvisorySupport(false);\n\n        broker.getSystemUsage().getMemoryUsage().setLimit(2097152 * 10);\n\n        broker.setDeleteAllMessagesOnStartup(deleteAll);\n", "refactored_code": "    protected static final int destinationMemLimit = 2097152; // 2MB\n        broker.addConnector(brokerUrl);\n        broker.setAdvisorySupport(false);\n\n        broker.getSystemUsage().getMemoryUsage().setLimit(destinationMemLimit * 10);\n\n        broker.setDeleteAllMessagesOnStartup(deleteAll);\n"}
{"magic_number_smell": "        // Setup the topic destination policy\n        PolicyEntry tpe = new PolicyEntry();\n        tpe.setTopic(\">\");\n        tpe.setMemoryLimit(2097152);\n        tpe.setProducerFlowControl(true);\n        tpe.setAdvisoryWhenFull(true);\n        tpe.setBlockedProducerWarningInterval(2000);", "refactored_code": "    protected static final int destinationMemLimit = 2097152; // 2MB\n        // Setup the topic destination policy\n        PolicyEntry tpe = new PolicyEntry();\n        tpe.setTopic(\">\");\n        tpe.setMemoryLimit(destinationMemLimit);\n        tpe.setProducerFlowControl(true);\n        tpe.setAdvisoryWhenFull(true);\n        tpe.setBlockedProducerWarningInterval(2000);"}
{"magic_number_smell": "        // Setup the topic destination policy\n        PolicyEntry tpe = new PolicyEntry();\n        tpe.setTopic(\">\");\n        tpe.setMemoryLimit(2097152);\n        tpe.setCursorMemoryHighWaterMark(2); // 2% of global usage will match destMemLimit\n        tpe.setProducerFlowControl(true);\n        tpe.setAdvisoryWhenFull(true);", "refactored_code": "    protected static final int destinationMemLimit = 2097152; // 2MB\n        // Setup the topic destination policy\n        PolicyEntry tpe = new PolicyEntry();\n        tpe.setTopic(\">\");\n        tpe.setMemoryLimit(destinationMemLimit);\n        tpe.setCursorMemoryHighWaterMark(2); // 2% of global usage will match destMemLimit\n        tpe.setProducerFlowControl(true);\n        tpe.setAdvisoryWhenFull(true);"}
{"magic_number_smell": "        sent1.setText(\"msg3\");\n        producer.send(sent3);\n\n        consumer.receive(10000);\n        Message rec2 = consumer.receive(10000);\n        consumer.receive(10000);\n", "refactored_code": "    private static final int RECEIVE_TIMEOUT = 10000;\n        sent1.setText(\"msg3\");\n        producer.send(sent3);\n\n        consumer.receive(RECEIVE_TIMEOUT);\n        Message rec2 = consumer.receive(RECEIVE_TIMEOUT);\n        consumer.receive(RECEIVE_TIMEOUT);\n"}
{"magic_number_smell": "\n\n        // send messages to broker1\n        sendMessages(\"replication-broker1\", dest, 10);\n\n\n        msgsA.waitForMessagesToArrive(10);", "refactored_code": "    public static final int MSG_COUNT = 10;\n\n\n        // send messages to broker1\n        sendMessages(\"replication-broker1\", dest, MSG_COUNT);\n\n\n        msgsA.waitForMessagesToArrive(MSG_COUNT);"}
{"magic_number_smell": "\n        Thread.sleep(2000);\n        // Send messages\n        sendMessages(\"BrokerA\", dest, 100);\n\n        // Get message count\n        MessageIdList msgsA = getConsumerMessages(\"BrokerA\", clientA);", "refactored_code": "    protected static final int MESSAGE_COUNT = 100;\n\n        Thread.sleep(2000);\n        // Send messages\n        sendMessages(\"BrokerA\", dest, MESSAGE_COUNT);\n\n        // Get message count\n        MessageIdList msgsA = getConsumerMessages(\"BrokerA\", clientA);"}
{"magic_number_smell": "        ConnectionFactory sendFactory = createConnectionFactory(sendUri);\n\n        Connection conn = createConnection(sendFactory);\n        sendMessages(conn, dest, 100);\n\n        Thread.sleep(500);\n", "refactored_code": "    public static final int MESSAGE_COUNT = 100;\n        ConnectionFactory sendFactory = createConnectionFactory(sendUri);\n\n        Connection conn = createConnection(sendFactory);\n        sendMessages(conn, dest, MESSAGE_COUNT);\n\n        Thread.sleep(500);\n"}
{"magic_number_smell": "        Thread.sleep(500);\n\n        // Always send messages to broker A\n        sendMessages(\"BrokerA\", dest, 100);\n\n        // Close the second client, messages should be sent to the first client\n        client2.close();", "refactored_code": "    protected static final int MESSAGE_COUNT = 100; // Best if a factor of 100\n        Thread.sleep(500);\n\n        // Always send messages to broker A\n        sendMessages(\"BrokerA\", dest, MESSAGE_COUNT);\n\n        // Close the second client, messages should be sent to the first client\n        client2.close();"}
{"magic_number_smell": "        Thread.sleep(2*1000);\n\n        // Send messages\n        sendMessages(\"BrokerA\", dest, 10);\n\n        // Get message count\n        MessageIdList msgsA = getConsumerMessages(\"BrokerA\", clientA);", "refactored_code": "    protected static final int MESSAGE_COUNT = 10;\n        Thread.sleep(2*1000);\n\n        // Send messages\n        sendMessages(\"BrokerA\", dest, MESSAGE_COUNT);\n\n        // Get message count\n        MessageIdList msgsA = getConsumerMessages(\"BrokerA\", clientA);"}
{"magic_number_smell": "        }\n\n        // fill cache and consume all memory\n        for (int idx = 0; idx < 100; ++idx) {\n            for (ActiveMQQueue q : fillers) {\n                producer.send(q, message);\n            }", "refactored_code": "    private static final int MESSAGES_COUNT = 100;\n        }\n\n        // fill cache and consume all memory\n        for (int idx = 0; idx < MESSAGES_COUNT; ++idx) {\n            for (ActiveMQQueue q : fillers) {\n                producer.send(q, message);\n            }"}
{"magic_number_smell": "        Destination dest = createDestination(\"TEST.FOO\", false);\n\n        // Setup consumers\n        for (int i = 0; i < 3; i++) {\n            consumerMap.put(\"Consumer:\" + i + \":0\", createConsumer(\"Broker\" + i, dest));\n        }\n", "refactored_code": "    public static final int BROKER_COUNT = 3;\n        Destination dest = createDestination(\"TEST.FOO\", false);\n\n        // Setup consumers\n        for (int i = 0; i < BROKER_COUNT; i++) {\n            consumerMap.put(\"Consumer:\" + i + \":0\", createConsumer(\"Broker\" + i, dest));\n        }\n"}
{"magic_number_smell": "\n    private void sleep() {\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException igonred) {\n        }\n    }", "refactored_code": "    private static final long DEFAULT_SLEEP_MS = 1000;\n\n    private void sleep() {\n        try {\n            Thread.sleep(DEFAULT_SLEEP_MS);\n        } catch (InterruptedException igonred) {\n        }\n    }"}
{"magic_number_smell": "\n        // Pre-fill with a sane default set.\n        for (int i = 0; i < count; ++i) {\n            safeSet.add(61616 + i);\n        }\n\n        try {", "refactored_code": "    public static final int DEFAULT_PORT = 61616;\n\n        // Pre-fill with a sane default set.\n        for (int i = 0; i < count; ++i) {\n            safeSet.add(DEFAULT_PORT + i);\n        }\n\n        try {"}
{"magic_number_smell": "    }\n\n    protected double mutatePrice(double price) {\n        double percentChange = (2 * Math.random() * 1) - 1;\n\n        return price * (100 + percentChange) / 100;\n    }", "refactored_code": "    private static final int MAX_DELTA_PERCENT = 1;\n    }\n\n    protected double mutatePrice(double price) {\n        double percentChange = (2 * Math.random() * MAX_DELTA_PERCENT) - MAX_DELTA_PERCENT;\n\n        return price * (100 + percentChange) / 100;\n    }"}
{"magic_number_smell": "    public static final String DEFAULT_HOST = \"0.0.0.0\";\n    public static final int 8161 = 8161;\n\n    private int port = 8161;\n\tprivate String host = DEFAULT_HOST;\n\n    public int getPort() {", "refactored_code": "    public static final int DEFAULT_PORT = 8161;\n    public static final String DEFAULT_HOST = \"0.0.0.0\";\n    public static final int DEFAULT_PORT = 8161;\n\n    private int port = DEFAULT_PORT;\n\tprivate String host = DEFAULT_HOST;\n\n    public int getPort() {"}
{"magic_number_smell": "\n    public static void main(String[] args) throws Exception {\n        // now lets start the web server\n        int port = 8080;\n        if (args.length > 0) {\n            String text = args[0];\n            port = Integer.parseInt(text);", "refactored_code": "    public static final int PORT = 8080;\n\n    public static void main(String[] args) throws Exception {\n        // now lets start the web server\n        int port = PORT;\n        if (args.length > 0) {\n            String text = args[0];\n            port = Integer.parseInt(text);"}
{"magic_number_smell": "        });\n\n        // now lets start the web server\n        int port = 8080;\n        if (args.length > 0) {\n            String text = args[0];\n            port = Integer.parseInt(text);", "refactored_code": "    public static final int PORT = 8080;\n        });\n\n        // now lets start the web server\n        int port = PORT;\n        if (args.length > 0) {\n            String text = args[0];\n            port = Integer.parseInt(text);"}
{"magic_number_smell": "        if (args.length > 0) {\n            url = args[0].trim();\n        }\n        System.out.println(\"\\nWaiting to receive messages... will timeout after \" + 20000 / 1000 +\"s\");\n        ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"admin\", \"password\", url);\n        Connection connection = null;\n", "refactored_code": "    private static final long TIMEOUT = 20000;\n        if (args.length > 0) {\n            url = args[0].trim();\n        }\n        System.out.println(\"\\nWaiting to receive messages... will timeout after \" + TIMEOUT / 1000 +\"s\");\n        ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"admin\", \"password\", url);\n        Connection connection = null;\n"}
{"magic_number_smell": "            Destination destination = session.createQueue(\"test-queue,test-queue-foo,test-queue-bar,topic://test-topic-foo\");\n            MessageProducer producer = session.createProducer(destination);\n\n            for (int i = 0; i < 100; i++) {\n                TextMessage message = session.createTextMessage(\"Message #\" + i);\n                System.out.println(\"Sending message #\" + i);\n                producer.send(message);", "refactored_code": "    private static final int NUM_MESSAGES_TO_SEND = 100;\n            Destination destination = session.createQueue(\"test-queue,test-queue-foo,test-queue-bar,topic://test-topic-foo\");\n            MessageProducer producer = session.createProducer(destination);\n\n            for (int i = 0; i < NUM_MESSAGES_TO_SEND; i++) {\n                TextMessage message = session.createTextMessage(\"Message #\" + i);\n                System.out.println(\"Sending message #\" + i);\n                producer.send(message);"}
{"magic_number_smell": "            Destination destination = session.createTopic(\"test-topic\");\n            MessageProducer producer = session.createProducer(destination);\n\n            for (int i = 0; i < 100; i++) {\n                TextMessage message = session.createTextMessage(\"Message #\" + i);\n                System.out.println(\"Sending message #\" + i);\n                producer.send(message);", "refactored_code": "    private static final int NUM_MESSAGES_TO_SEND = 100;\n            Destination destination = session.createTopic(\"test-topic\");\n            MessageProducer producer = session.createProducer(destination);\n\n            for (int i = 0; i < NUM_MESSAGES_TO_SEND; i++) {\n                TextMessage message = session.createTextMessage(\"Message #\" + i);\n                System.out.println(\"Sending message #\" + i);\n                producer.send(message);"}
{"magic_number_smell": "        if (args.length > 0) {\n            url = args[0].trim();\n        }\n        System.out.println(\"\\nWaiting to receive messages... will timeout after \" + 20000 / 1000 +\"s\");\n        ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"admin\", \"password\", url);\n        Connection connection = null;\n", "refactored_code": "    private static final long TIMEOUT = 20000;\n        if (args.length > 0) {\n            url = args[0].trim();\n        }\n        System.out.println(\"\\nWaiting to receive messages... will timeout after \" + TIMEOUT / 1000 +\"s\");\n        ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"admin\", \"password\", url);\n        Connection connection = null;\n"}
{"magic_number_smell": "            Destination destination = session.createQueue(\"test-queue\");\n            MessageProducer producer = session.createProducer(destination);\n\n            for (int i = 0; i < 100; i++) {\n                TextMessage message = session.createTextMessage(\"Message #\" + i);\n                System.out.println(\"Sending message #\" + i);\n                producer.send(message);", "refactored_code": "    private static final int NUM_MESSAGES_TO_SEND = 100;\n            Destination destination = session.createQueue(\"test-queue\");\n            MessageProducer producer = session.createProducer(destination);\n\n            for (int i = 0; i < NUM_MESSAGES_TO_SEND; i++) {\n                TextMessage message = session.createTextMessage(\"Message #\" + i);\n                System.out.println(\"Sending message #\" + i);\n                producer.send(message);"}
{"magic_number_smell": "            while (enumeration.hasMoreElements()) {\n                TextMessage message = (TextMessage) enumeration.nextElement();\n                System.out.println(\"Browsing: \" + message);\n                TimeUnit.MILLISECONDS.sleep(100);\n            }\n\n            session.close();", "refactored_code": "    private static final long DELAY = 100;\n            while (enumeration.hasMoreElements()) {\n                TextMessage message = (TextMessage) enumeration.nextElement();\n                System.out.println(\"Browsing: \" + message);\n                TimeUnit.MILLISECONDS.sleep(DELAY);\n            }\n\n            session.close();"}
{"magic_number_smell": "            Destination destination = session.createQueue(\"test-queue\");\n            MessageProducer producer = session.createProducer(destination);\n\n            for (int i = 0; i < 100; i++) {\n                TextMessage message = session.createTextMessage(\"Message #\" + i);\n                System.out.println(\"Sending message #\" + i);\n                producer.send(message);", "refactored_code": "    private static final int NUM_MESSAGES_TO_SEND = 100;\n            Destination destination = session.createQueue(\"test-queue\");\n            MessageProducer producer = session.createProducer(destination);\n\n            for (int i = 0; i < NUM_MESSAGES_TO_SEND; i++) {\n                TextMessage message = session.createTextMessage(\"Message #\" + i);\n                System.out.println(\"Sending message #\" + i);\n                producer.send(message);"}
{"magic_number_smell": "        if (args.length > 0) {\n            url = args[0].trim();\n        }\n        System.out.println(\"\\nWaiting to receive messages... will timeout after \" + 20000 / 1000 +\"s\");\n        ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"admin\", \"password\", url);\n        Connection connection = null;\n", "refactored_code": "    private static final long TIMEOUT = 20000;\n        if (args.length > 0) {\n            url = args[0].trim();\n        }\n        System.out.println(\"\\nWaiting to receive messages... will timeout after \" + TIMEOUT / 1000 +\"s\");\n        ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"admin\", \"password\", url);\n        Connection connection = null;\n"}
{"magic_number_smell": "            Destination destination = session.createQueue(\"test-queue\");\n            MessageProducer producer = session.createProducer(destination);\n\n            for (int i = 0; i < 100; i++) {\n                TextMessage message = session.createTextMessage(\"Message #\" + i);\n                System.out.println(\"Sending message #\" + i);\n                producer.send(message);", "refactored_code": "    private static final int NUM_MESSAGES_TO_SEND = 100;\n            Destination destination = session.createQueue(\"test-queue\");\n            MessageProducer producer = session.createProducer(destination);\n\n            for (int i = 0; i < NUM_MESSAGES_TO_SEND; i++) {\n                TextMessage message = session.createTextMessage(\"Message #\" + i);\n                System.out.println(\"Sending message #\" + i);\n                producer.send(message);"}
{"magic_number_smell": "        if (args.length > 0) {\n            url = args[0].trim();\n        }\n        System.out.println(\"\\nWaiting to receive messages... will timeout after \" + 20000 / 1000 +\"s\");\n        ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"admin\", \"password\", url);\n        Connection connection = null;\n", "refactored_code": "    private static final long TIMEOUT = 20000;\n        if (args.length > 0) {\n            url = args[0].trim();\n        }\n        System.out.println(\"\\nWaiting to receive messages... will timeout after \" + TIMEOUT / 1000 +\"s\");\n        ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"admin\", \"password\", url);\n        Connection connection = null;\n"}
{"magic_number_smell": "            Destination destination = session.createQueue(\"test-queue\");\n            MessageProducer producer = session.createProducer(destination);\n\n            for (int i = 0; i < 100; i++) {\n                TextMessage message = session.createTextMessage(\"Message #\" + i);\n                System.out.println(\"Sending message #\" + i);\n                if (i % 2 == 0) {", "refactored_code": "    private static final int NUM_MESSAGES_TO_SEND = 100;\n            Destination destination = session.createQueue(\"test-queue\");\n            MessageProducer producer = session.createProducer(destination);\n\n            for (int i = 0; i < NUM_MESSAGES_TO_SEND; i++) {\n                TextMessage message = session.createTextMessage(\"Message #\" + i);\n                System.out.println(\"Sending message #\" + i);\n                if (i % 2 == 0) {"}
{"magic_number_smell": "        if (args.length > 0) {\n            url = args[0].trim();\n        }\n        System.out.println(\"\\nWaiting to receive messages... will timeout after \" + 20000 / 1000 +\"s\");\n        ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"admin\", \"password\", url);\n        Connection connection = null;\n", "refactored_code": "    private static final long TIMEOUT = 20000;\n        if (args.length > 0) {\n            url = args[0].trim();\n        }\n        System.out.println(\"\\nWaiting to receive messages... will timeout after \" + TIMEOUT / 1000 +\"s\");\n        ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"admin\", \"password\", url);\n        Connection connection = null;\n"}
{"magic_number_smell": "            Destination destination = session.createTopic(\"test-topic\");\n            MessageProducer producer = session.createProducer(destination);\n\n            for (int i = 0; i < 100; i++) {\n                TextMessage message = session.createTextMessage(\"Message #\" + i);\n                System.out.println(\"Sending message #\" + i);\n                producer.send(message);", "refactored_code": "    private static final int NUM_MESSAGES_TO_SEND = 100;\n            Destination destination = session.createTopic(\"test-topic\");\n            MessageProducer producer = session.createProducer(destination);\n\n            for (int i = 0; i < NUM_MESSAGES_TO_SEND; i++) {\n                TextMessage message = session.createTextMessage(\"Message #\" + i);\n                System.out.println(\"Sending message #\" + i);\n                producer.send(message);"}
{"magic_number_smell": "    // Create random users\n    User user;\n    Random random = new Random();\n    for (int i = 0; i < 20; i++) {\n      user = new User(\"user\", null, COLORS[random.nextInt(COLORS.length)]);\n      dataFileWriter.append(user);\n      System.out.println(user);", "refactored_code": "  public static final int USERS = 20;\n    // Create random users\n    User user;\n    Random random = new Random();\n    for (int i = 0; i < USERS; i++) {\n      user = new User(\"user\", null, COLORS[random.nextInt(COLORS.length)]);\n      dataFileWriter.append(user);\n      System.out.println(user);"}
{"magic_number_smell": "      if (schema.getType() != Schema.Type.STRING && schema.getType() != Schema.Type.FIXED) {\n        throw new IllegalArgumentException(\"Uuid can only be used with an underlying string or fixed type\");\n      }\n      if (schema.getType() == Schema.Type.FIXED && schema.getFixedSize() != 2 * Long.BYTES) {\n        throw new IllegalArgumentException(\"Uuid with fixed type must have a size of \" + 2 * Long.BYTES + \" bytes\");\n      }\n    }", "refactored_code": "    private static final int UUID_BYTES = 2 * Long.BYTES;\n      if (schema.getType() != Schema.Type.STRING && schema.getType() != Schema.Type.FIXED) {\n        throw new IllegalArgumentException(\"Uuid can only be used with an underlying string or fixed type\");\n      }\n      if (schema.getType() == Schema.Type.FIXED && schema.getFixedSize() != UUID_BYTES) {\n        throw new IllegalArgumentException(\"Uuid with fixed type must have a size of \" + UUID_BYTES + \" bytes\");\n      }\n    }"}
{"magic_number_smell": "\n  private static final class SerializableSchema implements Serializable {\n\n    private static final long 1L = 1L;\n\n    private String schemaString;\n", "refactored_code": "  private static final long serialVersionUID = 1L;\n\n  private static final class SerializableSchema implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private String schemaString;\n"}
{"magic_number_smell": "public class BZip2Codec extends Codec {\n\n  public static final int 64 * 1024 = 64 * 1024;\n  private final byte[] buffer = new byte[64 * 1024];\n\n  static class Option extends CodecFactory {\n    @Override", "refactored_code": "  public static final int DEFAULT_BUFFER_SIZE = 64 * 1024;\npublic class BZip2Codec extends Codec {\n\n  public static final int DEFAULT_BUFFER_SIZE = 64 * 1024;\n  private final byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];\n\n  static class Option extends CodecFactory {\n    @Override"}
{"magic_number_smell": "\n  static {\n    addCodec(DataFileConstants.NULL_CODEC, nullCodec());\n    addCodec(DataFileConstants.DEFLATE_CODEC, deflateCodec(Deflater.DEFAULT_COMPRESSION));\n    addCodec(DataFileConstants.BZIP2_CODEC, bzip2Codec());\n    addCodec(DataFileConstants.XZ_CODEC, xzCodec(DEFAULT_XZ_LEVEL));\n    addCodec(DataFileConstants.ZSTANDARD_CODEC, zstandardCodec(DEFAULT_ZSTANDARD_LEVEL, DEFAULT_ZSTANDARD_BUFFERPOOL));", "refactored_code": "  public static final int DEFAULT_DEFLATE_LEVEL = Deflater.DEFAULT_COMPRESSION;\n\n  static {\n    addCodec(DataFileConstants.NULL_CODEC, nullCodec());\n    addCodec(DataFileConstants.DEFLATE_CODEC, deflateCodec(DEFAULT_DEFLATE_LEVEL));\n    addCodec(DataFileConstants.BZIP2_CODEC, bzip2Codec());\n    addCodec(DataFileConstants.XZ_CODEC, xzCodec(DEFAULT_XZ_LEVEL));\n    addCodec(DataFileConstants.ZSTANDARD_CODEC, zstandardCodec(DEFAULT_ZSTANDARD_LEVEL, DEFAULT_ZSTANDARD_BUFFERPOOL));"}
{"magic_number_smell": "  } // no public ctor\n\n  public static final byte 1 = 1;\n  public static final byte[] MAGIC = new byte[] { (byte) 'O', (byte) 'b', (byte) 'j', 1 };\n  public static final long FOOTER_BLOCK = -1;\n  public static final int SYNC_SIZE = 16;\n  public static final int DEFAULT_SYNC_INTERVAL = 4000 * SYNC_SIZE;", "refactored_code": "  public static final byte VERSION = 1;\n  } // no public ctor\n\n  public static final byte VERSION = 1;\n  public static final byte[] MAGIC = new byte[] { (byte) 'O', (byte) 'b', (byte) 'j', VERSION };\n  public static final long FOOTER_BLOCK = -1;\n  public static final int SYNC_SIZE = 16;\n  public static final int DEFAULT_SYNC_INTERVAL = 4000 * SYNC_SIZE;"}
{"magic_number_smell": "/** Read files written by Avro version 1.2. */\npublic class DataFileReader12<D> implements FileReader<D>, Closeable {\n  private static final byte 0 = 0;\n  static final byte[] MAGIC = new byte[] { (byte) 'O', (byte) 'b', (byte) 'j', 0 };\n  private static final long FOOTER_BLOCK = -1;\n  private static final int SYNC_SIZE = 16;\n  private static final String SCHEMA = \"schema\";", "refactored_code": "  private static final byte VERSION = 0;\n/** Read files written by Avro version 1.2. */\npublic class DataFileReader12<D> implements FileReader<D>, Closeable {\n  private static final byte VERSION = 0;\n  static final byte[] MAGIC = new byte[] { (byte) 'O', (byte) 'b', (byte) 'j', VERSION };\n  private static final long FOOTER_BLOCK = -1;\n  private static final int SYNC_SIZE = 16;\n  private static final String SCHEMA = \"schema\";"}
{"magic_number_smell": "\n  @Override\n  public ByteBuffer compress(ByteBuffer data) throws IOException {\n    NonCopyingByteArrayOutputStream baos = new NonCopyingByteArrayOutputStream(8192);\n    try (OutputStream outputStream = new DeflaterOutputStream(baos, getDeflater())) {\n      outputStream.write(data.array(), computeOffset(data), data.remaining());\n    }", "refactored_code": "  private static final int DEFAULT_BUFFER_SIZE = 8192;\n\n  @Override\n  public ByteBuffer compress(ByteBuffer data) throws IOException {\n    NonCopyingByteArrayOutputStream baos = new NonCopyingByteArrayOutputStream(DEFAULT_BUFFER_SIZE);\n    try (OutputStream outputStream = new DeflaterOutputStream(baos, getDeflater())) {\n      outputStream.write(data.array(), computeOffset(data), data.remaining());\n    }"}
{"magic_number_smell": "\n  @Override\n  public ByteBuffer compress(ByteBuffer data) throws IOException {\n    NonCopyingByteArrayOutputStream baos = new NonCopyingByteArrayOutputStream(8192);\n    try (OutputStream outputStream = new XZCompressorOutputStream(baos, compressionLevel)) {\n      outputStream.write(data.array(), computeOffset(data), data.remaining());\n    }", "refactored_code": "  private static final int DEFAULT_BUFFER_SIZE = 8192;\n\n  @Override\n  public ByteBuffer compress(ByteBuffer data) throws IOException {\n    NonCopyingByteArrayOutputStream baos = new NonCopyingByteArrayOutputStream(DEFAULT_BUFFER_SIZE);\n    try (OutputStream outputStream = new XZCompressorOutputStream(baos, compressionLevel)) {\n      outputStream.write(data.array(), computeOffset(data), data.remaining());\n    }"}
{"magic_number_smell": "\n  @Override\n  public ByteBuffer compress(ByteBuffer data) throws IOException {\n    NonCopyingByteArrayOutputStream baos = new NonCopyingByteArrayOutputStream(8192);\n    try (OutputStream outputStream = ZstandardLoader.output(baos, compressionLevel, useChecksum, useBufferPool)) {\n      outputStream.write(data.array(), computeOffset(data), data.remaining());\n    }", "refactored_code": "  private static final int DEFAULT_BUFFER_SIZE = 8192;\n\n  @Override\n  public ByteBuffer compress(ByteBuffer data) throws IOException {\n    NonCopyingByteArrayOutputStream baos = new NonCopyingByteArrayOutputStream(DEFAULT_BUFFER_SIZE);\n    try (OutputStream outputStream = ZstandardLoader.output(baos, compressionLevel, useChecksum, useBufferPool)) {\n      outputStream.write(data.array(), computeOffset(data), data.remaining());\n    }"}
{"magic_number_smell": "      super();\n      // make sure data is not too small, otherwise getLong may try and\n      // read 10 bytes and get index out of bounds.\n      if (len < 16) {\n        this.data = Arrays.copyOfRange(data, start, start + 16);\n        this.position = 0;\n        this.max = len;", "refactored_code": "    private static final int MIN_SIZE = 16;\n      super();\n      // make sure data is not too small, otherwise getLong may try and\n      // read 10 bytes and get index out of bounds.\n      if (len < MIN_SIZE) {\n        this.data = Arrays.copyOfRange(data, start, start + MIN_SIZE);\n        this.position = 0;\n        this.max = len;"}
{"magic_number_smell": "\n  private void expandStack() {\n    int oldLength = blockStack.length;\n    blockStack = Arrays.copyOf(blockStack, blockStack.length + 10);\n    for (int i = oldLength; i < blockStack.length; i++) {\n      blockStack[i] = new BlockedValue();\n    }", "refactored_code": "  private static final int STACK_STEP = 10;\n\n  private void expandStack() {\n    int oldLength = blockStack.length;\n    blockStack = Arrays.copyOf(blockStack, blockStack.length + STACK_STEP);\n    for (int i = oldLength; i < blockStack.length; i++) {\n      blockStack[i] = new BlockedValue();\n    }"}
{"magic_number_smell": "\n  private static final EncoderFactory DEFAULT_FACTORY = new DefaultEncoderFactory();\n\n  protected int binaryBufferSize = 2048;\n  protected int binaryBlockSize = DEFAULT_BLOCK_BUFFER_SIZE;\n\n  /**", "refactored_code": "  private static final int DEFAULT_BUFFER_SIZE = 2048;\n\n  private static final EncoderFactory DEFAULT_FACTORY = new DefaultEncoderFactory();\n\n  protected int binaryBufferSize = DEFAULT_BUFFER_SIZE;\n  protected int binaryBlockSize = DEFAULT_BLOCK_BUFFER_SIZE;\n\n  /**"}
{"magic_number_smell": "\n  public void reset() {\n    buffers = new ArrayList<>();\n    buffers.add(ByteBuffer.allocate(8192));\n  }\n\n  public void write(ByteBuffer buffer) {", "refactored_code": "  public static final int BUFFER_SIZE = 8192;\n\n  public void reset() {\n    buffers = new ArrayList<>();\n    buffers.add(ByteBuffer.allocate(BUFFER_SIZE));\n  }\n\n  public void write(ByteBuffer buffer) {"}
{"magic_number_smell": "  }\n\n  private static long unsignedInt(long number) {\n    if (number != (number & 0xffffffffL)) {\n      throw new ArithmeticException(\"Overflow/underflow of unsigned int\");\n    }\n    return number;", "refactored_code": "  private static final long MAX_UNSIGNED_INT = 0xffffffffL;\n  }\n\n  private static long unsignedInt(long number) {\n    if (number != (number & MAX_UNSIGNED_INT)) {\n      throw new ArithmeticException(\"Overflow/underflow of unsigned int\");\n    }\n    return number;"}
{"magic_number_smell": "\n  public static String readAllChars(Reader input) throws IOException {\n    StringBuilder buffer = new StringBuilder();\n    char[] charBuffer = new char[4096];\n    int charsRead;\n    while ((charsRead = input.read(charBuffer, 0, 4096)) >= 0) {\n      buffer.append(charBuffer, 0, charsRead);", "refactored_code": "  private static final int TRANSFER_BUFFER_SIZE = 4096;\n\n  public static String readAllChars(Reader input) throws IOException {\n    StringBuilder buffer = new StringBuilder();\n    char[] charBuffer = new char[TRANSFER_BUFFER_SIZE];\n    int charsRead;\n    while ((charsRead = input.read(charBuffer, 0, TRANSFER_BUFFER_SIZE)) >= 0) {\n      buffer.append(charBuffer, 0, charsRead);"}
{"magic_number_smell": "   * Create a new {@code ConcurrentReferenceHashMap} instance.\n   */\n  public ConcurrentReferenceHashMap() {\n    this(16, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE);\n  }\n\n  /**", "refactored_code": "  private static final int DEFAULT_INITIAL_CAPACITY = 16;\n   * Create a new {@code ConcurrentReferenceHashMap} instance.\n   */\n  public ConcurrentReferenceHashMap() {\n    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE);\n  }\n\n  /**"}
{"magic_number_smell": "    if (array == null) {\n      return 0;\n    }\n    int hash = 7;\n    for (Object element : array) {\n      hash = MULTIPLIER * hash + nullSafeHashCode(element);\n    }", "refactored_code": "  private static final int INITIAL_HASH = 7;\n    if (array == null) {\n      return 0;\n    }\n    int hash = INITIAL_HASH;\n    for (Object element : array) {\n      hash = MULTIPLIER * hash + nullSafeHashCode(element);\n    }"}
{"magic_number_smell": " */\npublic class GenerateBlockingData {\n  private static final int 1000 = 1000;\n  private static ByteArrayOutputStream buffer = new ByteArrayOutputStream(2 * 1000);\n\n  private static EncoderFactory factory = EncoderFactory.get();\n  private static Encoder bufOut = EncoderFactory.get().blockingBinaryEncoder(buffer, null);", "refactored_code": "  private static final int SYNC_INTERVAL = 1000;\n */\npublic class GenerateBlockingData {\n  private static final int SYNC_INTERVAL = 1000;\n  private static ByteArrayOutputStream buffer = new ByteArrayOutputStream(2 * SYNC_INTERVAL);\n\n  private static EncoderFactory factory = EncoderFactory.get();\n  private static Encoder bufOut = EncoderFactory.get().blockingBinaryEncoder(buffer, null);"}
{"magic_number_smell": "    writer.create(SCHEMA, makeFile(codec));\n    try {\n      int count = 0;\n      for (Object datum : new RandomData(SCHEMA, Integer.parseInt(System.getProperty(\"test.count\", \"200\")), SEED)) {\n        writer.append(datum);\n        if (++count % (Integer.parseInt(System.getProperty(\"test.count\", \"200\")) / 3) == 0)\n          writer.sync(); // force some syncs mid-file", "refactored_code": "  private static final int COUNT = Integer.parseInt(System.getProperty(\"test.count\", \"200\"));\n    writer.create(SCHEMA, makeFile(codec));\n    try {\n      int count = 0;\n      for (Object datum : new RandomData(SCHEMA, COUNT, SEED)) {\n        writer.append(datum);\n        if (++count % (COUNT / 3) == 0)\n          writer.sync(); // force some syncs mid-file"}
{"magic_number_smell": "  @MethodSource(\"codecs\")\n  void concatenateFiles(CodecFactory codec, CodecFactory codec2, boolean recompress) throws IOException {\n    System.out.println(\"SEED = \" + SEED);\n    System.out.println(\"Integer.parseInt(System.getProperty(\"test.count\", \"200\")) = \" + Integer.parseInt(System.getProperty(\"test.count\", \"200\")));\n    for (int k = 0; k < 5; k++) {\n      int syncInterval = 460 + k;\n      RandomData data1 = new RandomData(SCHEMA, Integer.parseInt(System.getProperty(\"test.count\", \"200\")), SEED);", "refactored_code": "  private static final int COUNT = Integer.parseInt(System.getProperty(\"test.count\", \"200\"));\n  @MethodSource(\"codecs\")\n  void concatenateFiles(CodecFactory codec, CodecFactory codec2, boolean recompress) throws IOException {\n    System.out.println(\"SEED = \" + SEED);\n    System.out.println(\"COUNT = \" + COUNT);\n    for (int k = 0; k < 5; k++) {\n      int syncInterval = 460 + k;\n      RandomData data1 = new RandomData(SCHEMA, COUNT, SEED);"}
{"magic_number_smell": "  public static final int SystemLimitException.MAX_ARRAY_VM_LIMIT = SystemLimitException.SystemLimitException.MAX_ARRAY_VM_LIMIT;\n\n  public static final String ERROR_NEGATIVE = \"Malformed data. Length is negative: -1\";\n  public static final String ERROR_VM_LIMIT_BYTES = \"Cannot read arrays longer than \" + SystemLimitException.MAX_ARRAY_VM_LIMIT\n      + \" bytes in Java library\";\n  public static final String ERROR_VM_LIMIT_COLLECTION = \"Cannot read collections larger than \" + SystemLimitException.MAX_ARRAY_VM_LIMIT\n      + \" items in Java library\";", "refactored_code": "  public static final int MAX_ARRAY_VM_LIMIT = SystemLimitException.MAX_ARRAY_VM_LIMIT;\n  public static final int MAX_ARRAY_VM_LIMIT = SystemLimitException.MAX_ARRAY_VM_LIMIT;\n\n  public static final String ERROR_NEGATIVE = \"Malformed data. Length is negative: -1\";\n  public static final String ERROR_VM_LIMIT_BYTES = \"Cannot read arrays longer than \" + MAX_ARRAY_VM_LIMIT\n      + \" bytes in Java library\";\n  public static final String ERROR_VM_LIMIT_COLLECTION = \"Cannot read collections larger than \" + MAX_ARRAY_VM_LIMIT\n      + \" items in Java library\";"}
{"magic_number_smell": "  private static byte[] data = null;\n  private static Schema schema = null;\n  private static final int 200 = 200;\n  private static final ArrayList<Object> records = new ArrayList<>(200);\n\n  @BeforeAll\n  public static void generateData() throws IOException {", "refactored_code": "  private static final int count = 200;\n  private static byte[] data = null;\n  private static Schema schema = null;\n  private static final int count = 200;\n  private static final ArrayList<Object> records = new ArrayList<>(count);\n\n  @BeforeAll\n  public static void generateData() throws IOException {"}
{"magic_number_smell": "\n    ByteArrayOutputStream output = new ByteArrayOutputStream(EXAMPLE_DATA_SIZE * 2);\n    EncoderFactory encoderFactory = new EncoderFactory();\n    encoderFactory.configureBufferSize(32);\n\n    Encoder encoder = encoderFactory.binaryEncoder(output, null);\n    new GenericDatumWriter<ByteBuffer>(Schema.create(Schema.Type.BYTES)).write(buffer, encoder);", "refactored_code": "  private static final int ENCODER_BUFFER_SIZE = 32;\n\n    ByteArrayOutputStream output = new ByteArrayOutputStream(EXAMPLE_DATA_SIZE * 2);\n    EncoderFactory encoderFactory = new EncoderFactory();\n    encoderFactory.configureBufferSize(ENCODER_BUFFER_SIZE);\n\n    Encoder encoder = encoderFactory.binaryEncoder(output, null);\n    new GenericDatumWriter<ByteBuffer>(Schema.create(Schema.Type.BYTES)).write(buffer, encoder);"}
{"magic_number_smell": "\n  private void performTest(Encoding encoding, int skipLevel, String jsonWriterSchema, String writerCalls,\n      String jsonReaderSchema, String readerCalls) throws IOException {\n    for (int i = 0; i < 10; i++) {\n      testOnce(jsonWriterSchema, writerCalls, jsonReaderSchema, readerCalls, encoding, skipLevel);\n    }\n  }", "refactored_code": "  private static final int COUNT = 10;\n\n  private void performTest(Encoding encoding, int skipLevel, String jsonWriterSchema, String writerCalls,\n      String jsonReaderSchema, String readerCalls) throws IOException {\n    for (int i = 0; i < COUNT; i++) {\n      testOnce(jsonWriterSchema, writerCalls, jsonReaderSchema, readerCalls, encoding, skipLevel);\n    }\n  }"}
{"magic_number_smell": "  @ParameterizedTest\n  @MethodSource(\"data\")\n  public void testMain(Encoding enc, int skip, String js, String cls) throws IOException {\n    for (int i = 0; i < 1; i++) {\n      testOnce(new Schema.Parser().parse(js), cls, skip, enc);\n    }\n  }", "refactored_code": "  private static final int COUNT = 1;\n  @ParameterizedTest\n  @MethodSource(\"data\")\n  public void testMain(Encoding enc, int skip, String js, String cls) throws IOException {\n    for (int i = 0; i < COUNT; i++) {\n      testOnce(new Schema.Parser().parse(js), cls, skip, enc);\n    }\n  }"}
{"magic_number_smell": "    assertThrows(UnsupportedTemporalTypeException.class, () -> TimePeriod.from(TimeAmount.of(ChronoUnit.ERAS, 1)));\n    assertThrows(UnsupportedTemporalTypeException.class, () -> TimePeriod.from(TimeAmount.of(DummyUnit.INSTANCE, 3)));\n    // Arguments are long, but must fit an unsigned long\n    assertThrows(ArithmeticException.class, () -> TimePeriod.of(Integer.MAX_VALUE * 3L, 0, 0));\n    assertThrows(ArithmeticException.class, () -> TimePeriod.of(0, Integer.MAX_VALUE * 3L, 0));\n    assertThrows(ArithmeticException.class, () -> TimePeriod.of(0, 0, Integer.MAX_VALUE * 3L));\n", "refactored_code": "  private static final long TOO_LARGE = Integer.MAX_VALUE * 3L;\n    assertThrows(UnsupportedTemporalTypeException.class, () -> TimePeriod.from(TimeAmount.of(ChronoUnit.ERAS, 1)));\n    assertThrows(UnsupportedTemporalTypeException.class, () -> TimePeriod.from(TimeAmount.of(DummyUnit.INSTANCE, 3)));\n    // Arguments are long, but must fit an unsigned long\n    assertThrows(ArithmeticException.class, () -> TimePeriod.of(TOO_LARGE, 0, 0));\n    assertThrows(ArithmeticException.class, () -> TimePeriod.of(0, TOO_LARGE, 0));\n    assertThrows(ArithmeticException.class, () -> TimePeriod.of(0, 0, TOO_LARGE));\n"}
{"magic_number_smell": "\n  private static final int 4001 = 4001;\n\n  List<String> data = new ArrayList<>(4001);\n\n  final WeakIdentityHashMap<String, String> map = new WeakIdentityHashMap<>();\n", "refactored_code": "  private static final int TEST_SIZE = 4001;\n\n  private static final int TEST_SIZE = 4001;\n\n  List<String> data = new ArrayList<>(TEST_SIZE);\n\n  final WeakIdentityHashMap<String, String> map = new WeakIdentityHashMap<>();\n"}
{"magic_number_smell": "  /*\n   * Note: This is protected instead of private only so it's visible for testing.\n   */\n  protected static final int MAX_FIELD_PARAMETER_UNIT_COUNT = 255 - 1;\n\n  public enum FieldVisibility {\n    PUBLIC, PRIVATE", "refactored_code": "  private static final int JVM_METHOD_ARG_LIMIT = 255;\n  /*\n   * Note: This is protected instead of private only so it's visible for testing.\n   */\n  protected static final int MAX_FIELD_PARAMETER_UNIT_COUNT = JVM_METHOD_ARG_LIMIT - 1;\n\n  public enum FieldVisibility {\n    PUBLIC, PRIVATE"}
{"magic_number_smell": "\n  private DatagramChannel channel;\n  private SocketAddress remote;\n  private ByteBuffer buffer = ByteBuffer.allocate(16 * 1024);\n\n  @Override\n  public String getRemoteName() {", "refactored_code": "  private static final int MAX_SIZE = 16 * 1024;\n\n  private DatagramChannel channel;\n  private SocketAddress remote;\n  private ByteBuffer buffer = ByteBuffer.allocate(MAX_SIZE);\n\n  @Override\n  public String getRemoteName() {"}
{"magic_number_smell": "    int i = segmenter.segment(value);\n    counts[i]++;\n    totalCount++;\n    if (this.recentAdditions.size() > Histogram.20) {\n      this.recentAdditions.pollLast();\n    }\n    this.recentAdditions.push(value);", "refactored_code": "  public static final int MAX_HISTORY_SIZE = 20;\n    int i = segmenter.segment(value);\n    counts[i]++;\n    totalCount++;\n    if (this.recentAdditions.size() > Histogram.MAX_HISTORY_SIZE) {\n      this.recentAdditions.pollLast();\n    }\n    this.recentAdditions.push(value);"}
{"magic_number_smell": "\n    public void assertHandshake() {\n      int expected = getExpectedHandshakeCount();\n      if (expected != -1) {\n        assertEquals(expected, handshakes, \"Expected number of handshakes did not take place.\");\n      }\n    }", "refactored_code": "  protected static final int REPEATING = -1;\n\n    public void assertHandshake() {\n      int expected = getExpectedHandshakeCount();\n      if (expected != REPEATING) {\n        assertEquals(expected, handshakes, \"Expected number of handshakes did not take place.\");\n      }\n    }"}
{"magic_number_smell": "    Schema schema = new Schema.Parser().parse(jsonSchema);\n    checkProp(schema);\n    Object reuse = null;\n    for (Object datum : new RandomData(schema, Integer.parseInt(System.getProperty(\"test.count\", \"30\")), true)) {\n\n      if (induce) {\n        Schema induced = GenericData.get().induce(datum);", "refactored_code": "  private static final int COUNT = Integer.parseInt(System.getProperty(\"test.count\", \"30\"));\n    Schema schema = new Schema.Parser().parse(jsonSchema);\n    checkProp(schema);\n    Object reuse = null;\n    for (Object datum : new RandomData(schema, COUNT, true)) {\n\n      if (induce) {\n        Schema induced = GenericData.get().induce(datum);"}
{"magic_number_smell": "      }\n    }\n    System.out.println(\"Executing tests: \\n\" + tests + \"\\n readTests:\" + readTests + \"\\n writeTests:\" + writeTests\n        + \"\\n cycles=\" + Integer.parseInt(System.getProperty(\"org.apache.avro.io.perf.cycles\", \"800\")) + \"\\n count=\" + (COUNT / 1000) + \"K\");\n    if (out != System.out)\n      System.out.println(\" Writing to: \" + outputfilename);\n    if (csvFormat != null)", "refactored_code": "  private static final int CYCLES = Integer.parseInt(System.getProperty(\"org.apache.avro.io.perf.cycles\", \"800\"));\n      }\n    }\n    System.out.println(\"Executing tests: \\n\" + tests + \"\\n readTests:\" + readTests + \"\\n writeTests:\" + writeTests\n        + \"\\n cycles=\" + CYCLES + \"\\n count=\" + (COUNT / 1000) + \"K\");\n    if (out != System.out)\n      System.out.println(\" Writing to: \" + outputfilename);\n    if (csvFormat != null)"}
{"magic_number_smell": "    double without = sendRpcs(false) / 1000000000.0;\n\n    System.out.println(String.format(\"Overhead: %f%%.  RPC/s: %f (with) vs %f (without).  \" + \"RPC time (ms): %f vs %f\",\n        100 * (with - without) / (without), 100000 / with, 100000 / without, 1000 * with / 100000,\n        1000 * without / 100000));\n  }\n", "refactored_code": "  private static final int COUNT = 100000;\n    double without = sendRpcs(false) / 1000000000.0;\n\n    System.out.println(String.format(\"Overhead: %f%%.  RPC/s: %f (with) vs %f (without).  \" + \"RPC time (ms): %f vs %f\",\n        100 * (with - without) / (without), COUNT / with, COUNT / without, 1000 * with / COUNT,\n        1000 * without / COUNT));\n  }\n"}
{"magic_number_smell": "\n  @Test\n  void read() throws IOException {\n    for (long i = 0; i < Integer.parseInt(System.getProperty(\"test.count\", \"10\")); i++)\n      assertEquals(SIZE, proxy.read().remaining());\n  }\n", "refactored_code": "  private static final long COUNT = Integer.parseInt(System.getProperty(\"test.count\", \"10\"));\n\n  @Test\n  void read() throws IOException {\n    for (long i = 0; i < COUNT; i++)\n      assertEquals(SIZE, proxy.read().remaining());\n  }\n"}
{"magic_number_smell": "    RPCContext context1 = makeContext();\n    RPCContext context2 = makeContext();\n    statsPlugin.serverReceiveRequest(context1);\n    t.passTime(100 * 1000 * 1000L); // first takes 100ms\n    statsPlugin.serverReceiveRequest(context2);\n    String r = generateServletResponse(statsPlugin);\n    // Check in progress RPCs", "refactored_code": "  private static final long MS = 1000 * 1000L;\n    RPCContext context1 = makeContext();\n    RPCContext context2 = makeContext();\n    statsPlugin.serverReceiveRequest(context1);\n    t.passTime(100 * MS); // first takes 100ms\n    statsPlugin.serverReceiveRequest(context2);\n    String r = generateServletResponse(statsPlugin);\n    // Check in progress RPCs"}
{"magic_number_smell": "\n  /**\n   * Creates a NettyTransceiver, and attempts to connect to the given address.\n   * {@link #60 * 1000} is used for the connection\n   * timeout.\n   * \n   * @param addr the address to connect to.", "refactored_code": "  public static final int DEFAULT_CONNECTION_TIMEOUT_MILLIS = 60 * 1000;\n\n  /**\n   * Creates a NettyTransceiver, and attempts to connect to the given address.\n   * {@link #DEFAULT_CONNECTION_TIMEOUT_MILLIS} is used for the connection\n   * timeout.\n   * \n   * @param addr the address to connect to."}
{"magic_number_smell": "\n      // Sanity check to reduce likelihood of invalid requests being honored.\n      // Only allow 10% of available memory to go towards this list (too much!)\n      if (listSize * 8L > 0.1 * maxMem) {\n        throw new AvroRuntimeException(\n            \"Excessively large list allocation \" + \"request detected: \" + listSize + \" items! Connection closed.\");\n      }", "refactored_code": "    private static final long SIZEOF_REF = 8L; // mem usage of 64-bit pointer\n\n      // Sanity check to reduce likelihood of invalid requests being honored.\n      // Only allow 10% of available memory to go towards this list (too much!)\n      if (listSize * SIZEOF_REF > 0.1 * maxMem) {\n        throw new AvroRuntimeException(\n            \"Excessively large list allocation \" + \"request detected: \" + listSize + \" items! Connection closed.\");\n      }"}
{"magic_number_smell": "       * Creates a new <code>Options</code> instance with default values.\n       */\n      public Options() {\n        mBufferSizeBytes = -1;\n        mReplicationFactor = -1;\n        mBlockSizeBytes = -1;\n        mCompressionType = CompressionType.NONE;", "refactored_code": "      private static final short DEFAULT = -1;\n       * Creates a new <code>Options</code> instance with default values.\n       */\n      public Options() {\n        mBufferSizeBytes = DEFAULT;\n        mReplicationFactor = DEFAULT;\n        mBlockSizeBytes = DEFAULT;\n        mCompressionType = CompressionType.NONE;"}
{"magic_number_smell": "  public synchronized int inputPort() throws Exception {\n    if (inputPort == 0) {\n      LOG.info(\"waiting for input port from child\");\n      wait(10 * 1000);\n    }\n\n    if (inputPort == 0) {", "refactored_code": "  public static final long TIMEOUT = 10 * 1000;\n  public synchronized int inputPort() throws Exception {\n    if (inputPort == 0) {\n      LOG.info(\"waiting for input port from child\");\n      wait(TIMEOUT);\n    }\n\n    if (inputPort == 0) {"}
{"magic_number_smell": "        LongWritable.class, Text.class)) {\n      final LongWritable key = new LongWritable();\n      final Text val = new Text();\n      for (int i = 0; i < Integer.parseInt(System.getProperty(\"test.count\", \"10\")); ++i) {\n        key.set(i);\n        val.set(Integer.toString(i));\n        writer.append(key, val);", "refactored_code": "  private static final int COUNT = Integer.parseInt(System.getProperty(\"test.count\", \"10\"));\n        LongWritable.class, Text.class)) {\n      final LongWritable key = new LongWritable();\n      final Text val = new Text();\n      for (int i = 0; i < COUNT; ++i) {\n        key.set(i);\n        val.set(Integer.toString(i));\n        writer.append(key, val);"}
{"magic_number_smell": "\n  public static void setMeta(JobConf job) {\n    AvroJob.setOutputMeta(job, STRING_KEY, STRING_META_VALUE);\n    AvroJob.setOutputMeta(job, LONG_KEY, 666);\n    AvroJob.setOutputMeta(job, BYTES_KEY, BYTES_META_VALUE);\n  }\n", "refactored_code": "  private static final long LONG_META_VALUE = 666;\n\n  public static void setMeta(JobConf job) {\n    AvroJob.setOutputMeta(job, STRING_KEY, STRING_META_VALUE);\n    AvroJob.setOutputMeta(job, LONG_KEY, LONG_META_VALUE);\n    AvroJob.setOutputMeta(job, BYTES_KEY, BYTES_META_VALUE);\n  }\n"}
{"magic_number_smell": "  @Test\n  void withNullCodec() throws IOException {\n    Configuration conf = new Configuration();\n    conf.setInt(SYNC_INTERVAL_KEY, 12345);\n    testGetRecordWriter(conf, CodecFactory.nullCodec(), 12345);\n  }\n", "refactored_code": "  private static final int TEST_SYNC_INTERVAL = 12345;\n  @Test\n  void withNullCodec() throws IOException {\n    Configuration conf = new Configuration();\n    conf.setInt(SYNC_INTERVAL_KEY, TEST_SYNC_INTERVAL);\n    testGetRecordWriter(conf, CodecFactory.nullCodec(), TEST_SYNC_INTERVAL);\n  }\n"}
{"magic_number_smell": "  private static final OutputStream NULL_OUTPUTSTREAM = new NullOutputStream();\n\n  private final Random random = new Random(13L);\n  private final int batchSize = 10000;\n\n  private BinaryDecoder reuseDecoder;\n  private BinaryEncoder reuseEncoder;", "refactored_code": "  public static final int BATCH_SIZE = 10000;\n  private static final OutputStream NULL_OUTPUTSTREAM = new NullOutputStream();\n\n  private final Random random = new Random(13L);\n  private final int batchSize = BATCH_SIZE;\n\n  private BinaryDecoder reuseDecoder;\n  private BinaryEncoder reuseEncoder;"}
{"magic_number_smell": "    private ReflectDatumWriter<double[]> datumWriter;\n\n    public TestStateEncode() {\n      super(10);\n      final String jsonText = ReflectData.get().getSchema(double[].class).toString();\n      this.schema = new Schema.Parser().parse(jsonText);\n    }", "refactored_code": "  private static final int ARRAY_SIZE = 10;\n    private ReflectDatumWriter<double[]> datumWriter;\n\n    public TestStateEncode() {\n      super(ARRAY_SIZE);\n      final String jsonText = ReflectData.get().getSchema(double[].class).toString();\n      this.schema = new Schema.Parser().parse(jsonText);\n    }"}
{"magic_number_smell": "    private ReflectDatumWriter<float[]> datumWriter;\n\n    public TestStateEncode() {\n      super(10);\n      final String jsonText = ReflectData.get().getSchema(float[].class).toString();\n      this.schema = new Schema.Parser().parse(jsonText);\n    }", "refactored_code": "  private static final int ARRAY_SIZE = 10;\n    private ReflectDatumWriter<float[]> datumWriter;\n\n    public TestStateEncode() {\n      super(ARRAY_SIZE);\n      final String jsonText = ReflectData.get().getSchema(float[].class).toString();\n      this.schema = new Schema.Parser().parse(jsonText);\n    }"}
{"magic_number_smell": "    private ReflectDatumWriter<int[]> datumWriter;\n\n    public TestStateEncode() {\n      super(10);\n      final String jsonText = ReflectData.get().getSchema(int[].class).toString();\n      this.schema = new Schema.Parser().parse(jsonText);\n    }", "refactored_code": "  private static final int ARRAY_SIZE = 10;\n    private ReflectDatumWriter<int[]> datumWriter;\n\n    public TestStateEncode() {\n      super(ARRAY_SIZE);\n      final String jsonText = ReflectData.get().getSchema(int[].class).toString();\n      this.schema = new Schema.Parser().parse(jsonText);\n    }"}
{"magic_number_smell": "    private ReflectDatumWriter<float[]> datumWriter;\n\n    public TestStateEncode() {\n      super(100);\n      final String jsonText = ReflectData.get().getSchema(float[].class).toString();\n      this.schema = new Schema.Parser().parse(jsonText);\n    }", "refactored_code": "  private static final int ARRAY_SIZE = 100;\n    private ReflectDatumWriter<float[]> datumWriter;\n\n    public TestStateEncode() {\n      super(ARRAY_SIZE);\n      final String jsonText = ReflectData.get().getSchema(float[].class).toString();\n      this.schema = new Schema.Parser().parse(jsonText);\n    }"}
{"magic_number_smell": "    private ReflectDatumWriter<float[]> datumWriter;\n\n    public TestStateEncode() {\n      super(100);\n      final String jsonText = ReflectData.get().getSchema(float[].class).toString();\n      this.schema = new Schema.Parser().parse(jsonText);\n    }", "refactored_code": "  private static final int ARRAY_SIZE = 100;\n    private ReflectDatumWriter<float[]> datumWriter;\n\n    public TestStateEncode() {\n      super(ARRAY_SIZE);\n      final String jsonText = ReflectData.get().getSchema(float[].class).toString();\n      this.schema = new Schema.Parser().parse(jsonText);\n    }"}
{"magic_number_smell": "    private ReflectDatumWriter<long[]> datumWriter;\n\n    public TestStateEncode() {\n      super(10);\n      final String jsonText = ReflectData.get().getSchema(long[].class).toString();\n      this.schema = new Schema.Parser().parse(jsonText);\n    }", "refactored_code": "  private static final int ARRAY_SIZE = 10;\n    private ReflectDatumWriter<long[]> datumWriter;\n\n    public TestStateEncode() {\n      super(ARRAY_SIZE);\n      final String jsonText = ReflectData.get().getSchema(long[].class).toString();\n      this.schema = new Schema.Parser().parse(jsonText);\n    }"}
{"magic_number_smell": "    private ReflectDatumWriter<NativeArrayWrapper> datumWriter;\n\n    public TestStateEncode() {\n      super(10);\n      final String jsonText = ReflectData.get().getSchema(NativeArrayWrapper.class).toString();\n      this.schema = new Schema.Parser().parse(jsonText);\n    }", "refactored_code": "  private static final int ARRAY_SIZE = 10;\n    private ReflectDatumWriter<NativeArrayWrapper> datumWriter;\n\n    public TestStateEncode() {\n      super(ARRAY_SIZE);\n      final String jsonText = ReflectData.get().getSchema(NativeArrayWrapper.class).toString();\n      this.schema = new Schema.Parser().parse(jsonText);\n    }"}
{"magic_number_smell": "    private ReflectDatumWriter<ObjectArrayWrapper> datumWriter;\n\n    public TestStateEncode() {\n      super(10);\n      final String jsonText = ReflectData.get().getSchema(ObjectArrayWrapper.class).toString();\n      this.schema = new Schema.Parser().parse(jsonText);\n    }", "refactored_code": "  private static final int ARRAY_SIZE = 10;\n    private ReflectDatumWriter<ObjectArrayWrapper> datumWriter;\n\n    public TestStateEncode() {\n      super(ARRAY_SIZE);\n      final String jsonText = ReflectData.get().getSchema(ObjectArrayWrapper.class).toString();\n      this.schema = new Schema.Parser().parse(jsonText);\n    }"}
{"magic_number_smell": "\n    switch (precise) {\n    case Millis:\n      rv = value.getSeconds() * 1_000 + value.getNanos() / MILLION;\n      break;\n    case Micros:\n      rv = value.getSeconds() * MILLION + value.getNanos() / 1_000;", "refactored_code": "  private static final int THOUSAND = 1_000;\n\n    switch (precise) {\n    case Millis:\n      rv = value.getSeconds() * THOUSAND + value.getNanos() / MILLION;\n      break;\n    case Micros:\n      rv = value.getSeconds() * MILLION + value.getNanos() / THOUSAND;"}
{"magic_number_smell": "    }\n\n    public void unsetNum1() {\n      __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n    }\n\n    /**", "refactored_code": "    private static final int __NUM1_ISSET_ID = 0;\n    }\n\n    public void unsetNum1() {\n      __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __NUM1_ISSET_ID);\n    }\n\n    /**"}
{"magic_number_smell": "  }\n\n  public void unsetX() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /**", "refactored_code": "  private static final int __X_ISSET_ID = 0;\n  }\n\n  public void unsetX() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __X_ISSET_ID);\n  }\n\n  /**"}
{"magic_number_smell": "  }\n\n  public void unsetBoolField() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, 0);\n  }\n\n  /**", "refactored_code": "  private static final int __BOOLFIELD_ISSET_ID = 0;\n  }\n\n  public void unsetBoolField() {\n    __isset_bitfield = org.apache.thrift.EncodingUtils.clearBit(__isset_bitfield, __BOOLFIELD_ISSET_ID);\n  }\n\n  /**"}
{"magic_number_smell": "  public int run(InputStream stdin, PrintStream out, PrintStream err, List<String> args) throws Exception {\n    OptionParser optionParser = new OptionParser();\n    OptionSpec<Void> prettyOption = optionParser.accepts(\"pretty\", \"Turns on pretty printing.\");\n    String headDesc = String.format(\"Converts the first X records (default is %d).\", 10);\n    OptionSpec<String> headOption = optionParser.accepts(\"head\", headDesc).withOptionalArg();\n    OptionSpec<String> readerSchemaFileOption = optionParser.accepts(\"reader-schema-file\", \"Reader schema file\")\n        .withOptionalArg().ofType(String.class);", "refactored_code": "  private static final long DEFAULT_HEAD_COUNT = 10;\n  public int run(InputStream stdin, PrintStream out, PrintStream err, List<String> args) throws Exception {\n    OptionParser optionParser = new OptionParser();\n    OptionSpec<Void> prettyOption = optionParser.accepts(\"pretty\", \"Turns on pretty printing.\");\n    String headDesc = String.format(\"Converts the first X records (default is %d).\", DEFAULT_HEAD_COUNT);\n    OptionSpec<String> headOption = optionParser.accepts(\"head\", headDesc).withOptionalArg();\n    OptionSpec<String> readerSchemaFileOption = optionParser.accepts(\"reader-schema-file\", \"Reader schema file\")\n        .withOptionalArg().ofType(String.class);"}
{"magic_number_smell": "    writer.setCodec(codec);\n    writer.create(schema, inputFile);\n\n    for (int i = 0; i < 100000; i++) {\n      writer.append(aDatum(type, i));\n    }\n    writer.close();", "refactored_code": "  private static final int ROWS_IN_INPUT_FILES = 100000;\n    writer.setCodec(codec);\n    writer.create(schema, inputFile);\n\n    for (int i = 0; i < ROWS_IN_INPUT_FILES; i++) {\n      writer.append(aDatum(type, i));\n    }\n    writer.close();"}
{"magic_number_smell": "      writer.setCodec(codec);\n      writer.create(schema, inputFile);\n\n      for (int i = 0; i < 100000; i++) {\n        writer.append(aDatum(type, i));\n      }\n    }", "refactored_code": "  private static final int ROWS_IN_INPUT_FILES = 100000;\n      writer.setCodec(codec);\n      writer.create(schema, inputFile);\n\n      for (int i = 0; i < ROWS_IN_INPUT_FILES; i++) {\n        writer.append(aDatum(type, i));\n      }\n    }"}
{"magic_number_smell": "    ArrayList<String> args = new ArrayList<>();\n    File outFile = dataDir.resolve(\"random.avro\").toFile();\n    args.addAll(Arrays.asList(outFile.toString(), \"--count\", COUNT, \"--schema-file\", SCHEMA_FILE.toString(), \"--seed\",\n        Long.toString(System.currentTimeMillis())));\n    args.addAll(Arrays.asList(extraArgs));\n    run(args);\n", "refactored_code": "  private static final long SEED = System.currentTimeMillis();\n    ArrayList<String> args = new ArrayList<>();\n    File outFile = dataDir.resolve(\"random.avro\").toFile();\n    args.addAll(Arrays.asList(outFile.toString(), \"--count\", COUNT, \"--schema-file\", SCHEMA_FILE.toString(), \"--seed\",\n        Long.toString(SEED)));\n    args.addAll(Arrays.asList(extraArgs));\n    run(args);\n"}
{"magic_number_smell": "  @BeforeAll\n  public static void writeRandomFile() throws IOException {\n    schema = Schema.create(Type.BYTES);\n    lines = new ByteBuffer[Integer.parseInt(System.getProperty(\"test.count\", \"10\"))];\n    linesFile = new File(DIR, \"random.lines\");\n\n    OutputStream out = new BufferedOutputStream(new FileOutputStream(linesFile));", "refactored_code": "  private static final int COUNT = Integer.parseInt(System.getProperty(\"test.count\", \"10\"));\n  @BeforeAll\n  public static void writeRandomFile() throws IOException {\n    schema = Schema.create(Type.BYTES);\n    lines = new ByteBuffer[COUNT];\n    linesFile = new File(DIR, \"random.lines\");\n\n    OutputStream out = new BufferedOutputStream(new FileOutputStream(linesFile));"}
{"magic_number_smell": "    DataFileWriter<Object> writer = new DataFileWriter<>(new GenericDatumWriter<>());\n    File avroFile = dataDir.resolve(\"random.avro\").toFile();\n    writer.create(schema, avroFile);\n    for (Object datum : new RandomData(schema, COUNT, System.currentTimeMillis()))\n      writer.append(datum);\n    writer.close();\n", "refactored_code": "  private static final long SEED = System.currentTimeMillis();\n    DataFileWriter<Object> writer = new DataFileWriter<>(new GenericDatumWriter<>());\n    File avroFile = dataDir.resolve(\"random.avro\").toFile();\n    writer.create(schema, avroFile);\n    for (Object datum : new RandomData(schema, COUNT, SEED))\n      writer.append(datum);\n    writer.close();\n"}
{"magic_number_smell": "  private void checkWrite(Schema schema) throws IOException {\n    AvroColumnWriter<Object> writer = new AvroColumnWriter<>(schema, new ColumnFileMetaData());\n    int count = 0;\n    for (Object datum : new RandomData(schema, COUNT, System.currentTimeMillis())) {\n      // System.out.println(\"datum=\"+datum);\n      writer.write(datum);\n    }", "refactored_code": "  private static final long SEED = System.currentTimeMillis();\n  private void checkWrite(Schema schema) throws IOException {\n    AvroColumnWriter<Object> writer = new AvroColumnWriter<>(schema, new ColumnFileMetaData());\n    int count = 0;\n    for (Object datum : new RandomData(schema, COUNT, SEED)) {\n      // System.out.println(\"datum=\"+datum);\n      writer.write(datum);\n    }"}
{"magic_number_smell": "  private static final int -1 = -1;\n\n  private int runLength; // length of current run\n  private int runValue = -1; // what kind of run\n\n  public ArrayColumnOutputBuffer(ColumnFileWriter writer, ColumnMetaData meta) throws IOException {\n    super(writer, meta);", "refactored_code": "  private static final int NONE = -1;\n  private static final int NONE = -1;\n\n  private int runLength; // length of current run\n  private int runValue = NONE; // what kind of run\n\n  public ArrayColumnOutputBuffer(ColumnFileWriter writer, ColumnMetaData meta) throws IOException {\n    super(writer, meta);"}
{"magic_number_smell": "    try (BZip2CompressorInputStream inputStream = new BZip2CompressorInputStream(bais)) {\n      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\n      byte[] buffer = new byte[64 * 1024];\n\n      int readCount = -1;\n", "refactored_code": "  public static final int DEFAULT_BUFFER_SIZE = 64 * 1024;\n    try (BZip2CompressorInputStream inputStream = new BZip2CompressorInputStream(bais)) {\n      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\n      byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];\n\n      int readCount = -1;\n"}
{"magic_number_smell": "\n    ColumnFileWriter out = new ColumnFileWriter(fileMeta, new ColumnMetaData(\"test\", ValueType.INT));\n    Random random = TestUtil.createRandom();\n    for (int i = 0; i < 1024 * 64; i++)\n      out.writeRow(TestUtil.randomLength(random));\n    out.writeTo(FILE);\n", "refactored_code": "  private static final int COUNT = 1024 * 64;\n\n    ColumnFileWriter out = new ColumnFileWriter(fileMeta, new ColumnMetaData(\"test\", ValueType.INT));\n    Random random = TestUtil.createRandom();\n    for (int i = 0; i < COUNT; i++)\n      out.writeRow(TestUtil.randomLength(random));\n    out.writeTo(FILE);\n"}
{"magic_number_smell": "  @Test\n  void randomReads() throws Exception {\n    Random random = new Random(19820210);\n    int length = random.nextInt(1000) + 1;\n    byte[] data = new byte[length];\n    random.nextBytes(data);\n", "refactored_code": "  private static final int SIZE = 1000;\n  @Test\n  void randomReads() throws Exception {\n    Random random = new Random(19820210);\n    int length = random.nextInt(SIZE) + 1;\n    byte[] data = new byte[length];\n    random.nextBytes(data);\n"}
{"magic_number_smell": "  void testBoolean() throws Exception {\n    Random random = TestUtil.createRandom();\n    OutputBuffer out = new OutputBuffer();\n    for (int i = 0; i < 1001; i++)\n      out.writeValue(random.nextBoolean(), ValueType.BOOLEAN);\n\n    InputBuffer in = new InputBuffer(new InputBytes(out.toByteArray()));", "refactored_code": "  private static final int COUNT = 1001;\n  void testBoolean() throws Exception {\n    Random random = TestUtil.createRandom();\n    OutputBuffer out = new OutputBuffer();\n    for (int i = 0; i < COUNT; i++)\n      out.writeValue(random.nextBoolean(), ValueType.BOOLEAN);\n\n    InputBuffer in = new InputBuffer(new InputBytes(out.toByteArray()));"}
{"magic_number_smell": "    @Benchmark\n    public void oneJdbc() throws SQLException {\n        Connection c = db.getHandle().getConnection();\n        for (int i = 0; i < 10_000; i++) {\n            PreparedStatement ps = c.prepareStatement(\"insert into sample_table values (?, ?, ?, ?, ?, ?, ?)\");\n            SampleBean sampleBean = sampleList.get(0);\n            ps.setString(1, sampleBean.getField1());", "refactored_code": "    private static final int INNER_LOOPS = 10_000;\n    @Benchmark\n    public void oneJdbc() throws SQLException {\n        Connection c = db.getHandle().getConnection();\n        for (int i = 0; i < INNER_LOOPS; i++) {\n            PreparedStatement ps = c.prepareStatement(\"insert into sample_table values (?, ?, ?, ?, ?, ?, ?)\");\n            SampleBean sampleBean = sampleList.get(0);\n            ps.setString(1, sampleBean.getField1());"}
{"magic_number_smell": "    private final JdbiCache<String, ParsedSql> parsedSqlCache;\n\n    CachingSqlParser() {\n        this(DefaultJdbiCacheBuilder.builder().maxSize(1_000));\n    }\n\n    CachingSqlParser(JdbiCacheBuilder cacheBuilder) {", "refactored_code": "    public static final int PARSED_SQL_CACHE_SIZE = 1_000;\n    private final JdbiCache<String, ParsedSql> parsedSqlCache;\n\n    CachingSqlParser() {\n        this(DefaultJdbiCacheBuilder.builder().maxSize(PARSED_SQL_CACHE_SIZE));\n    }\n\n    CachingSqlParser(JdbiCacheBuilder cacheBuilder) {"}
{"magic_number_smell": "        queryTimeout = null;\n        customizers = new CopyOnWriteArrayList<>();\n        contextListeners = new CopyOnWriteArraySet<>();\n        templateCache = DefaultJdbiCacheBuilder.builder().maxSize(1_000).build();\n    }\n\n    private SqlStatements(SqlStatements that) {", "refactored_code": "    public static final int SQL_TEMPLATE_CACHE_SIZE = 1_000;\n        queryTimeout = null;\n        customizers = new CopyOnWriteArrayList<>();\n        contextListeners = new CopyOnWriteArraySet<>();\n        templateCache = DefaultJdbiCacheBuilder.builder().maxSize(SQL_TEMPLATE_CACHE_SIZE).build();\n    }\n\n    private SqlStatements(SqlStatements that) {"}
{"magic_number_smell": "        @SuppressWarnings(\"UnnecessaryLambda\") // constant for readablity\n        private static final Consumer<List<Exception>> NOP = list -> {};\n\n        private int maxRetries = 5;\n        private String serializationFailureSqlState = SQLSTATE_TXN_SERIALIZATION_FAILED;\n        private Consumer<List<Exception>> onFailure = NOP;\n        private Consumer<List<Exception>> onSuccess = NOP;", "refactored_code": "        private static final int DEFAULT_MAX_RETRIES = 5;\n        @SuppressWarnings(\"UnnecessaryLambda\") // constant for readablity\n        private static final Consumer<List<Exception>> NOP = list -> {};\n\n        private int maxRetries = DEFAULT_MAX_RETRIES;\n        private String serializationFailureSqlState = SQLSTATE_TXN_SERIALIZATION_FAILED;\n        private Consumer<List<Exception>> onFailure = NOP;\n        private Consumer<List<Exception>> onSuccess = NOP;"}
{"magic_number_smell": "    public void setUp() {\n        h2Extension.getJdbi().setTransactionHandler(new SerializableTransactionRunner());\n        h2Extension.getJdbi().getConfig(SerializableTransactionRunner.Configuration.class)\n            .setMaxRetries(5)\n            .setOnFailure(onFailure)\n            .setOnSuccess(onSuccess);\n    }", "refactored_code": "    private static final int MAX_RETRIES = 5;\n    public void setUp() {\n        h2Extension.getJdbi().setTransactionHandler(new SerializableTransactionRunner());\n        h2Extension.getJdbi().getConfig(SerializableTransactionRunner.Configuration.class)\n            .setMaxRetries(MAX_RETRIES)\n            .setOnFailure(onFailure)\n            .setOnSuccess(onSuccess);\n    }"}
{"magic_number_smell": "    @SuppressWarnings(\"PMD.AssignmentInOperand\")\n    public void writeLob(long oid, InputStream data) {\n        try (LargeObject lob = mgr.open(oid)) {\n            byte[] buf = new byte[1024 * 4];\n            int read;\n            while ((read = data.read(buf, 0, buf.length)) > -1) {\n                if (read > 0) {", "refactored_code": "    private static final int BUF_SIZE = 1024 * 4;\n    @SuppressWarnings(\"PMD.AssignmentInOperand\")\n    public void writeLob(long oid, InputStream data) {\n        try (LargeObject lob = mgr.open(oid)) {\n            byte[] buf = new byte[BUF_SIZE];\n            int read;\n            while ((read = data.read(buf, 0, buf.length)) > -1) {\n                if (read > 0) {"}
{"magic_number_smell": "\n        @Override\n        public int read() throws IOException {\n            if (count++ >= 1024 * 1024 * 64) {\n                return -1;\n            }\n            if (++current > hi) {", "refactored_code": "    private static final int BIG_DATA = 1024 * 1024 * 64;\n\n        @Override\n        public int read() throws IOException {\n            if (count++ >= BIG_DATA) {\n                return -1;\n            }\n            if (++current > hi) {"}
{"magic_number_smell": "    public SqlStatementCustomizer createForMethod(Annotation annotation, Class<?> sqlObjectType, Method method) {\n        final int maxRows = ((MaxRows) annotation).value();\n\n        if (maxRows == -1) {\n            throw new IllegalArgumentException(String.format(\n                \"no value given for @%s on %s:%s\",\n                MaxRows.class.getSimpleName(),", "refactored_code": "    public static final int DEFAULT_MAX_ROWS = -1;\n    public SqlStatementCustomizer createForMethod(Annotation annotation, Class<?> sqlObjectType, Method method) {\n        final int maxRows = ((MaxRows) annotation).value();\n\n        if (maxRows == DEFAULT_MAX_ROWS) {\n            throw new IllegalArgumentException(String.format(\n                \"no value given for @%s on %s:%s\",\n                MaxRows.class.getSimpleName(),"}
{"magic_number_smell": "            script.execute();\n        }\n\n        assertThat(sqlObject.bar()).hasSize(1);\n    }\n\n    @Test", "refactored_code": "    private static final int ROWS = 1;\n            script.execute();\n        }\n\n        assertThat(sqlObject.bar()).hasSize(ROWS);\n    }\n\n    @Test"}
{"magic_number_smell": "\n    @Override\n    public String getKeyColumn() {\n        String column = getColumn(1);\n        if (column == null) {\n            // fallback to global map key config\n            return this.registry.get(MapEntryMappers.class).getKeyColumn();", "refactored_code": "    private static final int KEY_COLUMN_TUPLE_INDEX = 1;\n\n    @Override\n    public String getKeyColumn() {\n        String column = getColumn(KEY_COLUMN_TUPLE_INDEX);\n        if (column == null) {\n            // fallback to global map key config\n            return this.registry.get(MapEntryMappers.class).getKeyColumn();"}
{"magic_number_smell": "        if ( ! androidDebugBridge.hasInitialDeviceList() )\n        {\n            getLog().info( \"Waiting for initial device list from the Android Debug Bridge\" );\n            long limitTime = System.currentTimeMillis() + 60L * 1000;\n            while ( ! androidDebugBridge.hasInitialDeviceList() && ( System.currentTimeMillis() < limitTime ) )\n            {\n                try", "refactored_code": "    private static final long ADB_TIMEOUT_MS = 60L * 1000;\n        if ( ! androidDebugBridge.hasInitialDeviceList() )\n        {\n            getLog().info( \"Waiting for initial device list from the Android Debug Bridge\" );\n            long limitTime = System.currentTimeMillis() + ADB_TIMEOUT_MS;\n            while ( ! androidDebugBridge.hasInitialDeviceList() && ( System.currentTimeMillis() < limitTime ) )\n            {\n                try"}
{"magic_number_smell": "            }\n            try\n            {\n                Thread.sleep( 200 );\n            }\n            catch ( InterruptedException e )\n            {", "refactored_code": "    private static final int MILLIS_TO_SLEEP_BETWEEN_DEVICE_ONLINE_CHECKS = 200;\n            }\n            try\n            {\n                Thread.sleep( MILLIS_TO_SLEEP_BETWEEN_DEVICE_ONLINE_CHECKS );\n            }\n            catch ( InterruptedException e )\n            {"}
{"magic_number_smell": "\n        OnDemandScreenshotService screenshotService = new OnDemandScreenshotService( device,\n                new ImageSaver( deviceScreenshotDir ),\n                new ImageScaler( new AnimatedGifCreator( deviceGifFile ), square( 320 ) ) );\n\n        screenshotService.start();\n", "refactored_code": "    private static final int MAX_BOUNDS = 320;\n\n        OnDemandScreenshotService screenshotService = new OnDemandScreenshotService( device,\n                new ImageSaver( deviceScreenshotDir ),\n                new ImageScaler( new AnimatedGifCreator( deviceGifFile ), square( MAX_BOUNDS ) ) );\n\n        screenshotService.start();\n"}
{"magic_number_smell": "    public int hashCode()\n    {\n        int result = minSdkVersion != null ? minSdkVersion.hashCode() : 0;\n        result = 31 * result + ( maxSdkVersion != null ? maxSdkVersion.hashCode() : 0 );\n        result = 31 * result + ( targetSdkVersion != null ? targetSdkVersion.hashCode() : 0 );\n        return result;\n    }", "refactored_code": "    private static final int PRIME_NUMBER = 31;\n    public int hashCode()\n    {\n        int result = minSdkVersion != null ? minSdkVersion.hashCode() : 0;\n        result = PRIME_NUMBER * result + ( maxSdkVersion != null ? maxSdkVersion.hashCode() : 0 );\n        result = PRIME_NUMBER * result + ( targetSdkVersion != null ? targetSdkVersion.hashCode() : 0 );\n        return result;\n    }"}
{"magic_number_smell": "        for ( File localeDir : localeDirs )\n        {\n            String recentChanges = readFileWithChecks( localeDir, fileNameWhatsnew,\n                    500, \"What's new texts are missing.\" );\n            if ( recentChanges == null )\n            {\n                continue;", "refactored_code": "    private static final int MAX_CHARS_WHATSNEW = 500;\n        for ( File localeDir : localeDirs )\n        {\n            String recentChanges = readFileWithChecks( localeDir, fileNameWhatsnew,\n                    MAX_CHARS_WHATSNEW, \"What's new texts are missing.\" );\n            if ( recentChanges == null )\n            {\n                continue;"}
{"magic_number_smell": "                            MAX_CHARS_SHORT_DESCRIPTION, \"Short description file is missing.\" );\n\n                    String title = readFileWithChecks( listingDir, fileNameTitle,\n                            50, \"Title file is missing.\" );\n\n                    if ( title == null || shortDescription == null || fullDescription == null )\n                    {", "refactored_code": "    private static final int MAX_CHARS_TITLE = 50;\n                            MAX_CHARS_SHORT_DESCRIPTION, \"Short description file is missing.\" );\n\n                    String title = readFileWithChecks( listingDir, fileNameTitle,\n                            MAX_CHARS_TITLE, \"Title file is missing.\" );\n\n                    if ( title == null || shortDescription == null || fullDescription == null )\n                    {"}
{"magic_number_smell": "    {\n        boolean onlineAtSecondTry = false;\n        int extraBootStatusPollCycles = -1;//ignored\n        abstractEmulatorMojo.setWait( 500 );\n\n        IDevice emulatorDevice = withEmulatorDevice( onlineAtSecondTry, extraBootStatusPollCycles );\n", "refactored_code": "    private static final long DEFAULT_TIMEOUT = 500;\n    {\n        boolean onlineAtSecondTry = false;\n        int extraBootStatusPollCycles = -1;//ignored\n        abstractEmulatorMojo.setWait( DEFAULT_TIMEOUT );\n\n        IDevice emulatorDevice = withEmulatorDevice( onlineAtSecondTry, extraBootStatusPollCycles );\n"}
{"magic_number_smell": "        replay( device );\n\n        final ITestRunListener listener = new AndroidTestRunListener( device, new SystemStreamLog(), true, false, null, suffix, target.getRoot() );\n        listener.testRunStarted( runName, RandomUtils.nextInt( 1, 10 ) );\n\n        final int tests = RandomUtils.nextInt( 5, 10 );\n        for (int i = 0; i < tests; i++)", "refactored_code": "    private final int count = RandomUtils.nextInt( 1, 10 );\n        replay( device );\n\n        final ITestRunListener listener = new AndroidTestRunListener( device, new SystemStreamLog(), true, false, null, suffix, target.getRoot() );\n        listener.testRunStarted( runName, count );\n\n        final int tests = RandomUtils.nextInt( 5, 10 );\n        for (int i = 0; i < tests; i++)"}
{"magic_number_smell": "        // We want to provide specific type of feedback.\n        info.feedbackType = feedbackType;\n        // We want to receive events in a certain interval.\n        info.notificationTimeout = 80;\n        // We want to receive accessibility events only from certain packages.\n        info.packageNames = PACKAGE_NAMES;\n        setServiceInfo(info);", "refactored_code": "    private static final int EVENT_NOTIFICATION_TIMEOUT_MILLIS = 80;\n        // We want to provide specific type of feedback.\n        info.feedbackType = feedbackType;\n        // We want to receive events in a certain interval.\n        info.notificationTimeout = EVENT_NOTIFICATION_TIMEOUT_MILLIS;\n        // We want to receive accessibility events only from certain packages.\n        info.packageNames = PACKAGE_NAMES;\n        setServiceInfo(info);"}
{"magic_number_smell": "        });\n\n        mSeekBar = (SeekBar) findViewById(R.id.seekBar);\n        mSeekBar.setMax(1500);\n        mSeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {\n            public void onStopTrackingTouch(SeekBar seekBar) {\n            }", "refactored_code": "    private static final int DURATION = 1500;\n        });\n\n        mSeekBar = (SeekBar) findViewById(R.id.seekBar);\n        mSeekBar.setMax(DURATION);\n        mSeekBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {\n            public void onStopTrackingTouch(SeekBar seekBar) {\n            }"}
{"magic_number_smell": "            // Note that setting the background color will automatically invalidate the\n            // view, so that the animated color, and the bouncing balls, get redisplayed on\n            // every frame of the animation.\n            ValueAnimator colorAnim = ObjectAnimator.ofInt(this, \"backgroundColor\", 0xffFF8080, BLUE);\n            colorAnim.setDuration(3000);\n            colorAnim.setEvaluator(new ArgbEvaluator());\n            colorAnim.setRepeatCount(ValueAnimator.INFINITE);", "refactored_code": "        private static final int RED = 0xffFF8080;\n            // Note that setting the background color will automatically invalidate the\n            // view, so that the animated color, and the bouncing balls, get redisplayed on\n            // every frame of the animation.\n            ValueAnimator colorAnim = ObjectAnimator.ofInt(this, \"backgroundColor\", RED, BLUE);\n            colorAnim.setDuration(3000);\n            colorAnim.setEvaluator(new ArgbEvaluator());\n            colorAnim.setRepeatCount(ValueAnimator.INFINITE);"}
{"magic_number_smell": "                ShapeHolder ball;\n                ball = balls.get(0);\n                ObjectAnimator yBouncer = ObjectAnimator.ofFloat(ball, \"y\",\n                        ball.getY(), getHeight() - BALL_SIZE).setDuration(1500);\n                yBouncer.setInterpolator(new BounceInterpolator());\n                yBouncer.addUpdateListener(this);\n", "refactored_code": "    private static final int DURATION = 1500;\n                ShapeHolder ball;\n                ball = balls.get(0);\n                ObjectAnimator yBouncer = ObjectAnimator.ofFloat(ball, \"y\",\n                        ball.getY(), getHeight() - BALL_SIZE).setDuration(DURATION);\n                yBouncer.setInterpolator(new BounceInterpolator());\n                yBouncer.addUpdateListener(this);\n"}
{"magic_number_smell": "    @Override\n    protected Dialog onCreateDialog(int id) {\n        switch (id) {\n        case 1:\n            return new AlertDialog.Builder(AlertDialogSamples.this)\n                .setIconAttribute(android.R.attr.alertDialogIcon)\n                .setTitle(R.string.alert_dialog_two_buttons_title)", "refactored_code": "    private static final int DIALOG_YES_NO_MESSAGE = 1;\n    @Override\n    protected Dialog onCreateDialog(int id) {\n        switch (id) {\n        case DIALOG_YES_NO_MESSAGE:\n            return new AlertDialog.Builder(AlertDialogSamples.this)\n                .setIconAttribute(android.R.attr.alertDialogIcon)\n                .setTitle(R.string.alert_dialog_two_buttons_title)"}
{"magic_number_smell": "                        intent.putExtra(DevicePolicyManager.EXTRA_DEVICE_ADMIN, mDeviceAdminSample);\n                        intent.putExtra(DevicePolicyManager.EXTRA_ADD_EXPLANATION,\n                                mActivity.getString(R.string.add_admin_extra_app_text));\n                        startActivityForResult(intent, 1);\n                        // return false - don't update checkbox until we're really active\n                        return false;\n                    } else {", "refactored_code": "    private static final int REQUEST_CODE_ENABLE_ADMIN = 1;\n                        intent.putExtra(DevicePolicyManager.EXTRA_DEVICE_ADMIN, mDeviceAdminSample);\n                        intent.putExtra(DevicePolicyManager.EXTRA_ADD_EXPLANATION,\n                                mActivity.getString(R.string.add_admin_extra_app_text));\n                        startActivityForResult(intent, REQUEST_CODE_ENABLE_ADMIN);\n                        // return false - don't update checkbox until we're really active\n                        return false;\n                    } else {"}
{"magic_number_smell": "       DatabaseHelper(Context context) {\n\n           // calls the super constructor, requesting the default cursor factory.\n           super(context, DATABASE_NAME, null, 2);\n       }\n\n       /**", "refactored_code": "       private static final int DATABASE_VERSION = 2;\n       DatabaseHelper(Context context) {\n\n           // calls the super constructor, requesting the default cursor factory.\n           super(context, DATABASE_NAME, null, DATABASE_VERSION);\n       }\n\n       /**"}
{"magic_number_smell": "            switch (msg.what) {\n                \n                // It is time to bump the value!\n                case 1: {\n                    // Up it goes.\n                    int value = ++mValue;\n                    ", "refactored_code": "    private static final int REPORT_MSG = 1;\n            switch (msg.what) {\n                \n                // It is time to bump the value!\n                case REPORT_MSG: {\n                    // Up it goes.\n                    int value = ++mValue;\n                    "}
{"magic_number_smell": "                    mSupportedLanguageView.getSelectedItem().toString());\n        }\n\n        startActivityForResult(intent, 1234);\n    }\n\n    /**", "refactored_code": "    private static final int VOICE_RECOGNITION_REQUEST_CODE = 1234;\n                    mSupportedLanguageView.getSelectedItem().toString());\n        }\n\n        startActivityForResult(intent, VOICE_RECOGNITION_REQUEST_CODE);\n    }\n\n    /**"}
{"magic_number_smell": "                drawArcs(canvas, mOvals[i], mUseCenters[i], mPaints[i]);\n            }\n\n            mSweep += 2;\n            if (mSweep > 360) {\n                mSweep -= 360;\n                mStart += START_INC;", "refactored_code": "        private static final float SWEEP_INC = 2;\n                drawArcs(canvas, mOvals[i], mUseCenters[i], mPaints[i]);\n            }\n\n            mSweep += SWEEP_INC;\n            if (mSweep > 360) {\n                mSweep -= 360;\n                mStart += START_INC;"}
{"magic_number_smell": "    private static class SampleView extends View {\n        private static final int 20 = 20;\n        private static final int HEIGHT = 20;\n        private static final int COUNT = (20 + 1) * (HEIGHT + 1);\n\n        private final Bitmap mBitmap;\n        private final float[] mVerts = new float[COUNT*2];", "refactored_code": "        private static final int WIDTH = 20;\n    private static class SampleView extends View {\n        private static final int WIDTH = 20;\n        private static final int HEIGHT = 20;\n        private static final int COUNT = (WIDTH + 1) * (HEIGHT + 1);\n\n        private final Bitmap mBitmap;\n        private final float[] mVerts = new float[COUNT*2];"}
{"magic_number_smell": "\n        @Override\n        public boolean onTouchEvent(MotionEvent event) {\n            float x = event.getX() - 100;\n            float y = event.getY() - CENTER_Y;\n            boolean inCenter = java.lang.Math.sqrt(x*x + y*y) <= CENTER_RADIUS;\n", "refactored_code": "        private static final int CENTER_X = 100;\n\n        @Override\n        public boolean onTouchEvent(MotionEvent event) {\n            float x = event.getX() - CENTER_X;\n            float y = event.getY() - CENTER_Y;\n            boolean inCenter = java.lang.Math.sqrt(x*x + y*y) <= CENTER_RADIUS;\n"}
{"magic_number_smell": "\n    private static final int 50 = 50;\n    private static final int HEIGHT = 50;\n    private static final int STRIDE = 64;   // must be >= 50\n\n    private static int[] createColors() {\n        int[] colors = new int[STRIDE * HEIGHT];", "refactored_code": "    private static final int WIDTH = 50;\n\n    private static final int WIDTH = 50;\n    private static final int HEIGHT = 50;\n    private static final int STRIDE = 64;   // must be >= WIDTH\n\n    private static int[] createColors() {\n        int[] colors = new int[STRIDE * HEIGHT];"}
{"magic_number_smell": "            mPts = new float[ptCount * 2];\n\n            float value = 0;\n            final float delta = 300 / SEGS;\n            for (int i = 0; i <= SEGS; i++) {\n                mPts[i*4 + X] = 300 - value;\n                mPts[i*4 + Y] = 0;", "refactored_code": "        private static final float SIZE = 300;\n            mPts = new float[ptCount * 2];\n\n            float value = 0;\n            final float delta = SIZE / SEGS;\n            for (int i = 0; i <= SEGS; i++) {\n                mPts[i*4 + X] = SIZE - value;\n                mPts[i*4 + Y] = 0;"}
{"magic_number_smell": "    }\n\n    private static final int 4 = 4;\n    private static final int TRIANGLE_VERTICES_DATA_STRIDE_BYTES = 5 * 4;\n    private static final int TRIANGLE_VERTICES_DATA_POS_OFFSET = 0;\n    private static final int TRIANGLE_VERTICES_DATA_UV_OFFSET = 3;\n    private final float[] mTriangleVerticesData = {", "refactored_code": "    private static final int FLOAT_SIZE_BYTES = 4;\n    }\n\n    private static final int FLOAT_SIZE_BYTES = 4;\n    private static final int TRIANGLE_VERTICES_DATA_STRIDE_BYTES = 5 * FLOAT_SIZE_BYTES;\n    private static final int TRIANGLE_VERTICES_DATA_POS_OFFSET = 0;\n    private static final int TRIANGLE_VERTICES_DATA_UV_OFFSET = 3;\n    private final float[] mTriangleVerticesData = {"}
{"magic_number_smell": "\n    private static final int 50 = 50;\n    private static final int HEIGHT = 50;\n    private static final int STRIDE = 64;   // must be >= 50\n\n    private static int[] createColors() {\n        int[] colors = new int[STRIDE * HEIGHT];", "refactored_code": "    private static final int WIDTH = 50;\n\n    private static final int WIDTH = 50;\n    private static final int HEIGHT = 50;\n    private static final int STRIDE = 64;   // must be >= WIDTH\n\n    private static int[] createColors() {\n        int[] colors = new int[STRIDE * HEIGHT];"}
{"magic_number_smell": "\n    private Bitmap mBitmap;\n    private final int 200 = 200;\n    private final Bitmap[] mBitmapArray = new Bitmap [200];\n    private final Options mOptions = new Options();\n    private static final int WIDTH = 150;\n    private static final int HEIGHT = 450;", "refactored_code": "    private final int mArraySize = 200;\n\n    private Bitmap mBitmap;\n    private final int mArraySize = 200;\n    private final Bitmap[] mBitmapArray = new Bitmap [mArraySize];\n    private final Options mOptions = new Options();\n    private static final int WIDTH = 150;\n    private static final int HEIGHT = 450;"}
{"magic_number_smell": "            canvas.translate(10, 10);\n\n            canvas.save();\n            for (int i = 0; i < 4; i++) {\n                setSrcR(i);\n                drawSrcR(canvas, i);\n                canvas.translate(mSrcR.width() + 15, 0);", "refactored_code": "        private static final int N = 4;\n            canvas.translate(10, 10);\n\n            canvas.save();\n            for (int i = 0; i < N; i++) {\n                setSrcR(i);\n                drawSrcR(canvas, i);\n                canvas.translate(mSrcR.width() + 15, 0);"}
{"magic_number_smell": "            // draw the normal strings\n\n            p.setColor(0x80FF0000);\n            canvas.drawLine(x, y, x, y+30*3, p);\n            p.setColor(Color.BLACK);\n\n            canvas.translate(0, 30);", "refactored_code": "        private static final int DY = 30;\n            // draw the normal strings\n\n            p.setColor(0x80FF0000);\n            canvas.drawLine(x, y, x, y+DY*3, p);\n            p.setColor(Color.BLACK);\n\n            canvas.translate(0, DY);"}
{"magic_number_smell": "     * ensure that we don't have multiple pulses running at a time.\n     */\n    void startFading() {\n        mHandler.removeMessages(1);\n        scheduleFade();\n    }\n", "refactored_code": "    private static final int MSG_FADE = 1;\n     * ensure that we don't have multiple pulses running at a time.\n     */\n    void startFading() {\n        mHandler.removeMessages(MSG_FADE);\n        scheduleFade();\n    }\n"}
{"magic_number_smell": "            float[] pos = mPos;\n            int index = 0;\n            for (int col = 0; col < 16; col++) {\n                final float x = col * 20 + 10;\n                for (int row = 0; row < 16; row++) {\n                    pos[index++] = x;\n                    pos[index++] = row * YMUL + YBASE;", "refactored_code": "        private static final int XMUL = 20;\n            float[] pos = mPos;\n            int index = 0;\n            for (int col = 0; col < 16; col++) {\n                final float x = col * XMUL + 10;\n                for (int row = 0; row < 16; row++) {\n                    pos[index++] = x;\n                    pos[index++] = row * YMUL + YBASE;"}
{"magic_number_smell": "        public SampleView(Context context) {\n            super(context);\n\n            mSrcB = makeSrc(64, H);\n            mDstB = makeDst(64, H);\n\n            // make a ckeckerboard pattern", "refactored_code": "        private static final int W = 64;\n        public SampleView(Context context) {\n            super(context);\n\n            mSrcB = makeSrc(W, H);\n            mDstB = makeDst(W, H);\n\n            // make a ckeckerboard pattern"}
{"magic_number_smell": "        mVisualizerView = new VisualizerView(this);\n        mVisualizerView.setLayoutParams(new ViewGroup.LayoutParams(\n                ViewGroup.LayoutParams.FILL_PARENT,\n                (int)(50f * getResources().getDisplayMetrics().density)));\n        mLinearLayout.addView(mVisualizerView);\n\n        // Create the Visualizer object and attach it to our media player.", "refactored_code": "    private static final float VISUALIZER_HEIGHT_DIP = 50f;\n        mVisualizerView = new VisualizerView(this);\n        mVisualizerView.setLayoutParams(new ViewGroup.LayoutParams(\n                ViewGroup.LayoutParams.FILL_PARENT,\n                (int)(VISUALIZER_HEIGHT_DIP * getResources().getDisplayMetrics().density)));\n        mLinearLayout.addView(mVisualizerView);\n\n        // Create the Visualizer object and attach it to our media player."}
{"magic_number_smell": "            Intent intent =\n                    new Intent(MediaPlayerDemo.this.getApplication(),\n                            MediaPlayerDemo_Audio.class);\n            intent.putExtra(MEDIA, 1);\n            startActivity(intent);\n\n        }", "refactored_code": "    private static final int LOCAL_AUDIO = 1;\n            Intent intent =\n                    new Intent(MediaPlayerDemo.this.getApplication(),\n                            MediaPlayerDemo_Audio.class);\n            intent.putExtra(MEDIA, LOCAL_AUDIO);\n            startActivity(intent);\n\n        }"}
{"magic_number_smell": "    private void playAudio(Integer media) {\n        try {\n            switch (media) {\n                case 1:\n                    /**\n                     * TODO: Set the path variable to a local audio file path.\n                     */", "refactored_code": "    private static final int LOCAL_AUDIO = 1;\n    private void playAudio(Integer media) {\n        try {\n            switch (media) {\n                case LOCAL_AUDIO:\n                    /**\n                     * TODO: Set the path variable to a local audio file path.\n                     */"}
{"magic_number_smell": "/** Class that implements the text to morse code coversion */\nclass MorseCodeConverter {\n    private static final long 100 = 100;\n    static final long DOT = 100;\n    static final long DASH = 100 * 3;\n    static final long GAP = 100;\n    static final long LETTER_GAP = 100 * 3;", "refactored_code": "    private static final long SPEED_BASE = 100;\n/** Class that implements the text to morse code coversion */\nclass MorseCodeConverter {\n    private static final long SPEED_BASE = 100;\n    static final long DOT = SPEED_BASE;\n    static final long DASH = SPEED_BASE * 3;\n    static final long GAP = SPEED_BASE;\n    static final long LETTER_GAP = SPEED_BASE * 3;"}
{"magic_number_smell": "                mFromDisplayName,\n                mMessage);\n\n        showDialog(1);\n        mTts = new TextToSpeech(this, this);\n    }\n", "refactored_code": "    private static final int DIALOG_SHOW_MESSAGE = 1;\n                mFromDisplayName,\n                mMessage);\n\n        showDialog(DIALOG_SHOW_MESSAGE);\n        mTts = new TextToSpeech(this, this);\n    }\n"}
{"magic_number_smell": "        Intent launchPreferencesIntent = new Intent().setClass(this, AdvancedPreferences.class);\n\n        // Make it a subactivity so we know when it returns\n        startActivityForResult(launchPreferencesIntent, 1);\n    }\n\n    @Override", "refactored_code": "    private static final int REQUEST_CODE_PREFERENCES = 1;\n        Intent launchPreferencesIntent = new Intent().setClass(this, AdvancedPreferences.class);\n\n        // Make it a subactivity so we know when it returns\n        startActivityForResult(launchPreferencesIntent, REQUEST_CODE_PREFERENCES);\n    }\n\n    @Override"}
{"magic_number_smell": "    private TextPaint mLegendPaint;\n    private Paint mGlow;\n    private static final int 10 = 10;\n    private static final int GREEN_STEP = 0x0000FF00 / 10;\n    private static final int WHITE_STEP = 0x00FFFFFF / 10;\n    private static final int ALPHA_STEP = 0xFF000000 / 10;\n", "refactored_code": "    private static final int NUM_GLOW_STEPS = 10;\n    private TextPaint mLegendPaint;\n    private Paint mGlow;\n    private static final int NUM_GLOW_STEPS = 10;\n    private static final int GREEN_STEP = 0x0000FF00 / NUM_GLOW_STEPS;\n    private static final int WHITE_STEP = 0x00FFFFFF / NUM_GLOW_STEPS;\n    private static final int ALPHA_STEP = 0xFF000000 / NUM_GLOW_STEPS;\n"}
{"magic_number_smell": "\n            // Return a cursor that points to this contact's phone numbers\n            Uri.Builder builder = Contacts.CONTENT_URI.buildUpon();\n            ContentUris.appendId(builder, groupCursor.getLong(0));\n            builder.appendEncodedPath(Contacts.Data.CONTENT_DIRECTORY);\n            Uri phoneNumbersUri = builder.build();\n", "refactored_code": "    private static final int GROUP_ID_COLUMN_INDEX = 0;\n\n            // Return a cursor that points to this contact's phone numbers\n            Uri.Builder builder = Contacts.CONTENT_URI.buildUpon();\n            ContentUris.appendId(builder, groupCursor.getLong(GROUP_ID_COLUMN_INDEX));\n            builder.appendEncodedPath(Contacts.Data.CONTENT_DIRECTORY);\n            Uri phoneNumbersUri = builder.build();\n"}
{"magic_number_smell": "                imageView = (ImageView) convertView;\n                imageView.setScaleType(ImageView.ScaleType.FIT_XY);\n                imageView.setLayoutParams(new Gallery.LayoutParams(\n                        (int) (136 * mDensity + 0.5f),\n                        (int) (ITEM_HEIGHT * mDensity + 0.5f)));\n            \n                // The preferred Gallery item background", "refactored_code": "        private static final int ITEM_WIDTH = 136;\n                imageView = (ImageView) convertView;\n                imageView.setScaleType(ImageView.ScaleType.FIT_XY);\n                imageView.setLayoutParams(new Gallery.LayoutParams(\n                        (int) (ITEM_WIDTH * mDensity + 0.5f),\n                        (int) (ITEM_HEIGHT * mDensity + 0.5f)));\n            \n                // The preferred Gallery item background"}
{"magic_number_smell": "            mContext = context;\n            mResources = resources;\n\n            mDeviceHeading = new Heading(1 << 10 | 0,\n                    mResources.getString(R.string.game_controller_input_heading_device));\n            mDeviceNameTextColumn = new TextColumn(BASE_ID_DEVICE_ITEM | 0,\n                    mResources.getString(R.string.game_controller_input_label_device_name));", "refactored_code": "        private static final int BASE_ID_HEADING = 1 << 10;\n            mContext = context;\n            mResources = resources;\n\n            mDeviceHeading = new Heading(BASE_ID_HEADING | 0,\n                    mResources.getString(R.string.game_controller_input_heading_device));\n            mDeviceNameTextColumn = new TextColumn(BASE_ID_DEVICE_ITEM | 0,\n                    mResources.getString(R.string.game_controller_input_label_device_name));"}
{"magic_number_smell": "        // Alternately, we could update the game state using the Activity onResume()\n        // and onPause() lifecycle events.\n        if (hasWindowFocus) {\n            getHandler().postDelayed(mAnimationRunnable, 1000 / 60);\n            mLastStepTime = SystemClock.uptimeMillis();\n        } else {\n            getHandler().removeCallbacks(mAnimationRunnable);", "refactored_code": "    private final long ANIMATION_TIME_STEP = 1000 / 60;\n        // Alternately, we could update the game state using the Activity onResume()\n        // and onPause() lifecycle events.\n        if (hasWindowFocus) {\n            getHandler().postDelayed(mAnimationRunnable, ANIMATION_TIME_STEP);\n            mLastStepTime = SystemClock.uptimeMillis();\n        } else {\n            getHandler().removeCallbacks(mAnimationRunnable);"}
{"magic_number_smell": "\n        int desiredHeight = mDesiredHeight != null ?\n                mDesiredHeight :\n                mNumRows * 10 + getPaddingTop() + getPaddingBottom();\n        if (specMode == MeasureSpec.EXACTLY) {\n            // We were told how big to be\n            return specSize;", "refactored_code": "    private final int mEstimatedPixelHeight = 10;\n\n        int desiredHeight = mDesiredHeight != null ?\n                mDesiredHeight :\n                mNumRows * mEstimatedPixelHeight + getPaddingTop() + getPaddingBottom();\n        if (specMode == MeasureSpec.EXACTLY) {\n            // We were told how big to be\n            return specSize;"}
{"magic_number_smell": "    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        menu.add(0, Menu.FIRST, 0, R.string.linear_layout_8_vertical);\n        menu.add(0, HORIZONTAL_ID, 0, R.string.linear_layout_8_horizontal);\n        menu.add(0, TOP_ID, 0, R.string.linear_layout_8_top);\n        menu.add(0, MIDDLE_ID, 0, R.string.linear_layout_8_middle);", "refactored_code": "    public static final int VERTICAL_ID = Menu.FIRST;\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n        menu.add(0, VERTICAL_ID, 0, R.string.linear_layout_8_vertical);\n        menu.add(0, HORIZONTAL_ID, 0, R.string.linear_layout_8_horizontal);\n        menu.add(0, TOP_ID, 0, R.string.linear_layout_8_top);\n        menu.add(0, MIDDLE_ID, 0, R.string.linear_layout_8_middle);"}
{"magic_number_smell": "        if (position >= 0) {\n            //Get current cursor\n            Cursor c = (Cursor) parent.getItemAtPosition(position);\n            int type = c.getInt(1);\n            String phone = c.getString(COLUMN_PHONE_NUMBER);\n            String label = null;\n            //Custom type? Then get the custom label", "refactored_code": "    private static final int COLUMN_PHONE_TYPE = 1;\n        if (position >= 0) {\n            //Get current cursor\n            Cursor c = (Cursor) parent.getItemAtPosition(position);\n            int type = c.getInt(COLUMN_PHONE_TYPE);\n            String phone = c.getString(COLUMN_PHONE_NUMBER);\n            String label = null;\n            //Custom type? Then get the custom label"}
{"magic_number_smell": "        Button button = (Button) findViewById(R.id.showIndeterminate);\n        button.setOnClickListener(new View.OnClickListener() {\n            public void onClick(View v) {\n                showDialog(0);\n            }\n        });\n", "refactored_code": "    private static final int DIALOG1_KEY = 0;\n        Button button = (Button) findViewById(R.id.showIndeterminate);\n        button.setOnClickListener(new View.OnClickListener() {\n            public void onClick(View v) {\n                showDialog(DIALOG1_KEY);\n            }\n        });\n"}
{"magic_number_smell": " */\npublic class MorseCodeConverter {\n    private static final long 100 = 100;\n    static final long DOT = 100;\n    static final long DASH = 100 * 3;\n    static final long GAP = 100;\n    static final long LETTER_GAP = 100 * 3;", "refactored_code": "    private static final long SPEED_BASE = 100;\n */\npublic class MorseCodeConverter {\n    private static final long SPEED_BASE = 100;\n    static final long DOT = SPEED_BASE;\n    static final long DASH = SPEED_BASE * 3;\n    static final long GAP = SPEED_BASE;\n    static final long LETTER_GAP = SPEED_BASE * 3;"}
{"magic_number_smell": "       DatabaseHelper(Context context) {\n\n           // calls the super constructor, requesting the default cursor factory.\n           super(context, DATABASE_NAME, null, 2);\n       }\n\n       /**", "refactored_code": "       private static final int DATABASE_VERSION = 2;\n       DatabaseHelper(Context context) {\n\n           // calls the super constructor, requesting the default cursor factory.\n           super(context, DATABASE_NAME, null, DATABASE_VERSION);\n       }\n\n       /**"}
{"magic_number_smell": "            }\n        }\n        if (player == State.PLAYER2) {\n            mHandler.sendEmptyMessageDelayed(1, COMPUTER_DELAY_MS);\n        }\n        if (player == State.WIN) {\n            setWinState(mGameView.getWinner());", "refactored_code": "    private static final int MSG_COMPUTER_TURN = 1;\n            }\n        }\n        if (player == State.PLAYER2) {\n            mHandler.sendEmptyMessageDelayed(MSG_COMPUTER_TURN, COMPUTER_DELAY_MS);\n        }\n        if (player == State.WIN) {\n            setWinState(mGameView.getWinner());"}
{"magic_number_smell": "\n                if (state != State.EMPTY) {\n                    // Start the blinker\n                    mHandler.sendEmptyMessageDelayed(MSG_BLINK, 1000/2);\n                }\n\n                if (mCellListener != null) {", "refactored_code": "    public static final long FPS_MS = 1000/2;\n\n                if (state != State.EMPTY) {\n                    // Start the blinker\n                    mHandler.sendEmptyMessageDelayed(MSG_BLINK, FPS_MS);\n                }\n\n                if (mCellListener != null) {"}
{"magic_number_smell": "    private final int _sessionTimeOut;\n\n    public ZkConnection(String zkServers) {\n        this(zkServers, 30000);\n    }\n\n    public ZkConnection(String zkServers, int sessionTimeOut) {", "refactored_code": "    private static final int DEFAULT_SESSION_TIMEOUT = 30000;\n    private final int _sessionTimeOut;\n\n    public ZkConnection(String zkServers) {\n        this(zkServers, DEFAULT_SESSION_TIMEOUT);\n    }\n\n    public ZkConnection(String zkServers, int sessionTimeOut) {"}
{"magic_number_smell": "    private int _minSessionTimeout;\n\n    public ZkServer(String dataDir, String logDir, IDefaultNameSpace defaultNameSpace) {\n        this(dataDir, logDir, defaultNameSpace, 2181);\n    }\n\n    public ZkServer(String dataDir, String logDir, IDefaultNameSpace defaultNameSpace, int port) {", "refactored_code": "    public static final int DEFAULT_PORT = 2181;\n    private int _minSessionTimeout;\n\n    public ZkServer(String dataDir, String logDir, IDefaultNameSpace defaultNameSpace) {\n        this(dataDir, logDir, defaultNameSpace, DEFAULT_PORT);\n    }\n\n    public ZkServer(String dataDir, String logDir, IDefaultNameSpace defaultNameSpace, int port) {"}
{"magic_number_smell": "    public void setUp() throws Exception {\n        super.setUp();\n        _zkServer = TestUtil.startZkServer(_temporaryFolder, 4711);\n        _client = new ZkClient(\"localhost:4711\", 30000);\n    }\n\n    @Override", "refactored_code": "    private static final int CONNECTION_TIMEOUT = 30000;\n    public void setUp() throws Exception {\n        super.setUp();\n        _zkServer = TestUtil.startZkServer(_temporaryFolder, 4711);\n        _client = new ZkClient(\"localhost:4711\", CONNECTION_TIMEOUT);\n    }\n\n    @Override"}
{"magic_number_smell": "        InputStream stdout,stderr;\n        @Nonnull\n        OutputStream stdin;\n        private static final long 1L = 1L;\n    }\n    /**\n     * Remoting interface of a remote process", "refactored_code": "            private static final long serialVersionUID = 1L;\n        InputStream stdout,stderr;\n        @Nonnull\n        OutputStream stdin;\n        private static final long serialVersionUID = 1L;\n    }\n    /**\n     * Remoting interface of a remote process"}
{"magic_number_smell": "            }\n        }\n        \n        if(SystemProperties.getInteger(\"hudson.ProxyConfiguration.DEFAULT_CONNECT_TIMEOUT_MILLIS\", 20 * 1000) > 0) {\n            con.setConnectTimeout(SystemProperties.getInteger(\"hudson.ProxyConfiguration.DEFAULT_CONNECT_TIMEOUT_MILLIS\", 20 * 1000));\n        }\n        ", "refactored_code": "    private static final int DEFAULT_CONNECT_TIMEOUT_MILLIS = SystemProperties.getInteger(\"hudson.ProxyConfiguration.DEFAULT_CONNECT_TIMEOUT_MILLIS\", 20 * 1000);\n            }\n        }\n        \n        if(DEFAULT_CONNECT_TIMEOUT_MILLIS > 0) {\n            con.setConnectTimeout(DEFAULT_CONNECT_TIMEOUT_MILLIS);\n        }\n        "}
{"magic_number_smell": "\n    // Constant number of milliseconds in various time units.\n    private static final long 1000 = 1000;\n    private static final long ONE_MINUTE_MS = 60 * 1000;\n    private static final long ONE_HOUR_MS = 60 * ONE_MINUTE_MS;\n    private static final long ONE_DAY_MS = 24 * ONE_HOUR_MS;\n    private static final long ONE_MONTH_MS = 30 * ONE_DAY_MS;", "refactored_code": "    private static final long ONE_SECOND_MS = 1000;\n\n    // Constant number of milliseconds in various time units.\n    private static final long ONE_SECOND_MS = 1000;\n    private static final long ONE_MINUTE_MS = 60 * ONE_SECOND_MS;\n    private static final long ONE_HOUR_MS = 60 * ONE_MINUTE_MS;\n    private static final long ONE_DAY_MS = 24 * ONE_HOUR_MS;\n    private static final long ONE_MONTH_MS = 30 * ONE_DAY_MS;"}
{"magic_number_smell": "    // use RingBufferLogHandler class name to configure for backward compatibility\n    private static final int SystemProperties.getInteger(RingBufferLogHandler.class.getName() + \".defaultSize\", 256) = SystemProperties.getInteger(RingBufferLogHandler.class.getName() + \".defaultSize\", 256);\n\n    private final RingBufferLogHandler handler = new RingBufferLogHandler(SystemProperties.getInteger(RingBufferLogHandler.class.getName() + \".defaultSize\", 256)) {\n        @Override public synchronized void publish(LogRecord record) {\n            if (record.getLevel().intValue() >= Level.INFO.intValue()) {\n                super.publish(record);", "refactored_code": "    private static final int DEFAULT_RING_BUFFER_SIZE = SystemProperties.getInteger(RingBufferLogHandler.class.getName() + \".defaultSize\", 256);\n    // use RingBufferLogHandler class name to configure for backward compatibility\n    private static final int DEFAULT_RING_BUFFER_SIZE = SystemProperties.getInteger(RingBufferLogHandler.class.getName() + \".defaultSize\", 256);\n\n    private final RingBufferLogHandler handler = new RingBufferLogHandler(DEFAULT_RING_BUFFER_SIZE) {\n        @Override public synchronized void publish(LogRecord record) {\n            if (record.getLevel().intValue() >= Level.INFO.intValue()) {\n                super.publish(record);"}
{"magic_number_smell": "            return Charset.defaultCharset().name();\n        }\n\n        private static final long 1L = 1L;\n    }\n\n    /**", "refactored_code": "        private static final long serialVersionUID = 1L;\n            return Charset.defaultCharset().name();\n        }\n\n        private static final long serialVersionUID = 1L;\n    }\n\n    /**"}
{"magic_number_smell": "        // channel is closed\n        final Closure originalErrorHook = shell.getErrorHook();\n        shell.setErrorHook(new Closure(shell, shell) {\n            private static final long 1L = 1L;\n\n            @SuppressWarnings(\"unused\")\n            @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value=\"UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS\",justification=\"Closure invokes this via reflection\")", "refactored_code": "            private static final long serialVersionUID = 1L;\n        // channel is closed\n        final Closure originalErrorHook = shell.getErrorHook();\n        shell.setErrorHook(new Closure(shell, shell) {\n            private static final long serialVersionUID = 1L;\n\n            @SuppressWarnings(\"unused\")\n            @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(value=\"UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS\",justification=\"Closure invokes this via reflection\")"}
{"magic_number_smell": "            upstreamCauses = new ArrayList<Cause>();\n            Set<String> traversed = new HashSet<String>();\n            for (Cause c : up.getCauses()) {\n                upstreamCauses.add(trim(c, 10, traversed));\n            }\n        }\n", "refactored_code": "        private static final int MAX_DEPTH = 10;\n            upstreamCauses = new ArrayList<Cause>();\n            Set<String> traversed = new HashSet<String>();\n            for (Cause c : up.getCauses()) {\n                upstreamCauses.add(trim(c, MAX_DEPTH, traversed));\n            }\n        }\n"}
{"magic_number_smell": "        public String call() throws IOException {\n            return SystemProperties.getString(\"host.name\");\n        }\n        private static final long 1L = 1L;\n    }\n\n    public static final ExecutorService threadPoolForRemoting = new ContextResettingExecutorService(", "refactored_code": "        private static final long serialVersionUID = 1L;\n        public String call() throws IOException {\n            return SystemProperties.getString(\"host.name\");\n        }\n        private static final long serialVersionUID = 1L;\n    }\n\n    public static final ExecutorService threadPoolForRemoting = new ContextResettingExecutorService("}
{"magic_number_smell": "    /**\n     * Calculation of estimated duration needs some time, so, it's better to cache it once executable is known\n     */\n    private long executableEstimatedDuration = -1;\n\n    /**\n     * Used to mark that the execution is continuing asynchronously even though {@link Executor} as {@link Thread}", "refactored_code": "    private static final int DEFAULT_ESTIMATED_DURATION = -1;\n    /**\n     * Calculation of estimated duration needs some time, so, it's better to cache it once executable is known\n     */\n    private long executableEstimatedDuration = DEFAULT_ESTIMATED_DURATION;\n\n    /**\n     * Used to mark that the execution is continuing asynchronously even though {@link Executor} as {@link Thread}"}
{"magic_number_smell": "\n    // time constants\n    protected static final long 1000*60 = 1000*60;\n    protected static final long HOUR =60*1000*60;\n    protected static final long DAY = 24*HOUR;\n\n    private static final Random RANDOM = new Random();", "refactored_code": "    protected static final long MIN = 1000*60;\n\n    // time constants\n    protected static final long MIN = 1000*60;\n    protected static final long HOUR =60*MIN;\n    protected static final long DAY = 24*HOUR;\n\n    private static final Random RANDOM = new Random();"}
{"magic_number_smell": "    /**\n     * The original Queue task ID from where this Run instance originated.\n     */\n    private long queueId = Run.-1;\n\n    /**\n     * Previous build. Can be null.", "refactored_code": "    public static final long QUEUE_ID_UNKNOWN = -1;\n    /**\n     * The original Queue task ID from where this Run instance originated.\n     */\n    private long queueId = Run.QUEUE_ID_UNKNOWN;\n\n    /**\n     * Previous build. Can be null."}
{"magic_number_smell": "            return new GetClockDifference3(startTime);\n        }\n\n        private static final long 1L = 1L;\n    }\n\n    private static final class GetClockDifference3 implements Serializable {", "refactored_code": "        private static final long serialVersionUID = 1L;\n            return new GetClockDifference3(startTime);\n        }\n\n        private static final long serialVersionUID = 1L;\n    }\n\n    private static final class GetClockDifference3 implements Serializable {"}
{"magic_number_smell": "                //JENKINS-34174 - set timeout for downloads, may hang indefinitely\n                // particularly noticeable during 2.0 install when downloading\n                // many plugins\n                con.setReadTimeout(SystemProperties.getInteger(UpdateCenter.class.getName()+\".pluginDownloadReadTimeoutSeconds\", 60) * 1000);\n                \n                int total = con.getContentLength();\n                byte[] buf = new byte[8192];", "refactored_code": "    private static final int PLUGIN_DOWNLOAD_READ_TIMEOUT = SystemProperties.getInteger(UpdateCenter.class.getName()+\".pluginDownloadReadTimeoutSeconds\", 60) * 1000;\n                //JENKINS-34174 - set timeout for downloads, may hang indefinitely\n                // particularly noticeable during 2.0 install when downloading\n                // many plugins\n                con.setReadTimeout(PLUGIN_DOWNLOAD_READ_TIMEOUT);\n                \n                int total = con.getContentLength();\n                byte[] buf = new byte[8192];"}
{"magic_number_smell": "                if(s<=0)    return null;\n                return new DiskSpace(f.getCanonicalPath(), s);\n        }\n        private static final long 2L = 1L;\n    }\n}\n", "refactored_code": "        private static final long serialVersionUID = 2L;\n                if(s<=0)    return null;\n                return new DiskSpace(f.getCanonicalPath(), s);\n        }\n        private static final long serialVersionUID = 1L;\n    }\n}\n"}
{"magic_number_smell": "            return new Step3(cur,start);\n        }\n\n        private static final long 1L = 1L;\n    }\n\n    private static final class Step3 implements Serializable {", "refactored_code": "        private static final long serialVersionUID = 1L;\n            return new Step3(cur,start);\n        }\n\n        private static final long serialVersionUID = 1L;\n    }\n\n    private static final class Step3 implements Serializable {"}
{"magic_number_smell": "     */\n    @ExportedBean\n    public static class MemoryUsage2 extends MemoryUsage {\n        private static final long 1L = 2216994637932270352L;\n\n        public MemoryUsage2(MemoryUsage mem) {\n            super(mem.totalPhysicalMemory, mem.availablePhysicalMemory, mem.totalSwapSpace, mem.availableSwapSpace);", "refactored_code": "        private static final long serialVersionUID = 1L;\n     */\n    @ExportedBean\n    public static class MemoryUsage2 extends MemoryUsage {\n        private static final long serialVersionUID = 2216994637932270352L;\n\n        public MemoryUsage2(MemoryUsage mem) {\n            super(mem.totalPhysicalMemory, mem.availablePhysicalMemory, mem.totalSwapSpace, mem.availableSwapSpace);"}
{"magic_number_smell": "    protected int       assemLen;\n    protected byte[]    assemBuf;\n    protected TarBuffer buffer;\n    protected int       longFileMode = 0;\n    // CheckStyle:VisibilityModifier ON\n\n    private boolean closed = false;", "refactored_code": "    public static final int LONGFILE_ERROR = 0;\n    protected int       assemLen;\n    protected byte[]    assemBuf;\n    protected TarBuffer buffer;\n    protected int       longFileMode = LONGFILE_ERROR;\n    // CheckStyle:VisibilityModifier ON\n\n    private boolean closed = false;"}
{"magic_number_smell": "            this.gid = gid;\n            this.userName = userName;\n        }\n            private static final long 1018007614648118323L = 7731167233498214301L;\n            @Override\n            public String call() throws IOException {\n                PrintStream out = listener.getLogger();", "refactored_code": "    private static final long serialVersionUID = 1018007614648118323L;\n            this.gid = gid;\n            this.userName = userName;\n        }\n            private static final long serialVersionUID = 7731167233498214301L;\n            @Override\n            public String call() throws IOException {\n                PrintStream out = listener.getLogger();"}
{"magic_number_smell": "            this.name = name;\n            this.listener = listener;\n        }\n            private static final long -2142349338699797436L = 2129531727963121198L;\n            @Override\n            public Void invoke(File f, VirtualChannel channel) throws IOException {\n                ZFSFileSystem fs = libzfs.getFileSystemByMountPoint(f);", "refactored_code": "            private static final long serialVersionUID = -2142349338699797436L;\n            this.name = name;\n            this.listener = listener;\n        }\n            private static final long serialVersionUID = 2129531727963121198L;\n            @Override\n            public Void invoke(File f, VirtualChannel channel) throws IOException {\n                ZFSFileSystem fs = libzfs.getFileSystemByMountPoint(f);"}
{"magic_number_smell": "\n    private static final Logger LOGGER = Logger.getLogger(NodeProvisioner.class.getName());\n    private static final float SystemProperties.getInteger(NodeProvisioner.class.getName()+\".MARGIN\",10)/100f = SystemProperties.getInteger(NodeProvisioner.class.getName()+\".SystemProperties.getInteger(NodeProvisioner.class.getName()+\".MARGIN\",10)/100f\",10)/100f;\n    private static final float MARGIN0 = Math.max(SystemProperties.getInteger(NodeProvisioner.class.getName()+\".MARGIN\",10)/100f, getFloatSystemProperty(NodeProvisioner.class.getName()+\".MARGIN0\",0.5f));\n    private static final float MARGIN_DECAY = getFloatSystemProperty(NodeProvisioner.class.getName()+\".MARGIN_DECAY\",0.5f);\n\n    // TODO: picker should be selectable", "refactored_code": "    private static final float MARGIN = SystemProperties.getInteger(NodeProvisioner.class.getName()+\".MARGIN\",10)/100f;\n\n    private static final Logger LOGGER = Logger.getLogger(NodeProvisioner.class.getName());\n    private static final float MARGIN = SystemProperties.getInteger(NodeProvisioner.class.getName()+\".MARGIN\",10)/100f;\n    private static final float MARGIN0 = Math.max(MARGIN, getFloatSystemProperty(NodeProvisioner.class.getName()+\".MARGIN0\",0.5f));\n    private static final float MARGIN_DECAY = getFloatSystemProperty(NodeProvisioner.class.getName()+\".MARGIN_DECAY\",0.5f);\n\n    // TODO: picker should be selectable"}
{"magic_number_smell": "     */\n    @Exported\n    public long getTimestamp() {\n        return System.currentTimeMillis();\n    }\n\n    /**", "refactored_code": "    protected final long timestamp = System.currentTimeMillis();\n     */\n    @Exported\n    public long getTimestamp() {\n        return timestamp;\n    }\n\n    /**"}
{"magic_number_smell": "\n            return null;\n        }\n        private static final long 1L = 1L;\n        private static final Logger LOGGER = Logger.getLogger(\"\");\n    }\n", "refactored_code": "        private static final long serialVersionUID = 1L;\n\n            return null;\n        }\n        private static final long serialVersionUID = 1L;\n        private static final Logger LOGGER = Logger.getLogger(\"\");\n    }\n"}
{"magic_number_smell": "\n        @Override\n        public String toString() {\n            String s = path+\" owned by \"+holder.getName()+\" from \"+new Date(System.currentTimeMillis());\n            if(quick) s+=\" (quick)\";\n            s+=\"\\n\"+Functions.printThrowable(source);\n            return s;", "refactored_code": "        public final long time = System.currentTimeMillis();\n\n        @Override\n        public String toString() {\n            String s = path+\" owned by \"+holder.getName()+\" from \"+new Date(time);\n            if(quick) s+=\" (quick)\";\n            s+=\"\\n\"+Functions.printThrowable(source);\n            return s;"}
{"magic_number_smell": "\n    private static final Logger logger = Logger.getLogger(Fingerprinter.class.getName());\n\n    private static final long 1L = 1L;\n}\n", "refactored_code": "        private static final long serialVersionUID = 1L;\n\n    private static final Logger logger = Logger.getLogger(Fingerprinter.class.getName());\n\n    private static final long serialVersionUID = 1L;\n}\n"}
{"magic_number_smell": "            \n        }\n        private class GetMavenVersion extends MasterToSlaveCallable<String, IOException> {\n            private static final long -2327576423452215146L = -4143159957567745621L;\n            @Override\n            public String call() throws IOException {\n                File[] jars = new File(getHomeDir(), \"lib\").listFiles();", "refactored_code": "        private static final long serialVersionUID = -2327576423452215146L;\n            \n        }\n        private class GetMavenVersion extends MasterToSlaveCallable<String, IOException> {\n            private static final long serialVersionUID = -4143159957567745621L;\n            @Override\n            public String call() throws IOException {\n                File[] jars = new File(getHomeDir(), \"lib\").listFiles();"}
{"magic_number_smell": "         */\n        public void setPollingThreadCount(int n) {\n            // fool proof\n            if (n < 5) {\n                n = 5;\n            }\n            if (n > THREADS_UPPER_BOUND) {", "refactored_code": "        private static final int THREADS_LOWER_BOUND = 5;\n         */\n        public void setPollingThreadCount(int n) {\n            // fool proof\n            if (n < THREADS_LOWER_BOUND) {\n                n = THREADS_LOWER_BOUND;\n            }\n            if (n > THREADS_UPPER_BOUND) {"}
{"magic_number_smell": "            super.scan(dir,visitor.with(filter));\n        }\n\n        private static final long 1L = 1L;\n    }\n\n    /**", "refactored_code": "        private static final long serialVersionUID = 1L;\n            super.scan(dir,visitor.with(filter));\n        }\n\n        private static final long serialVersionUID = 1L;\n    }\n\n    /**"}
{"magic_number_smell": "            }\n\n            // after that wait for it to cease to exist\n            long deadline = System.nanoTime() + Integer.getInteger(\"SoftKillWaitSeconds\", 2 * 60) * 1000000000;\n            int sleepTime = 10; // initially we sleep briefly, then sleep up to 1sec\n            do {\n                if (!p.isRunning()) {", "refactored_code": "    private final long softKillWaitSeconds = Integer.getInteger(\"SoftKillWaitSeconds\", 2 * 60); // by default processes get at most 2 minutes to respond to SIGTERM (JENKINS-17116)\n            }\n\n            // after that wait for it to cease to exist\n            long deadline = System.nanoTime() + softKillWaitSeconds * 1000000000;\n            int sleepTime = 10; // initially we sleep briefly, then sleep up to 1sec\n            do {\n                if (!p.isRunning()) {"}
{"magic_number_smell": "                    r.put(ti.getThreadName(),Functions.dumpThreadInfo(ti,map));\n            return r;\n        }\n        private static final long 1L = 1L;\n    }\n\n    /**", "refactored_code": "        private static final long serialVersionUID = 1L;\n                    r.put(ti.getThreadName(),Functions.dumpThreadInfo(ti,map));\n            return r;\n        }\n        private static final long serialVersionUID = 1L;\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Deprecated\n    public RingBufferLogHandler() {\n        this(Integer.getInteger(RingBufferLogHandler.class.getName() + \".defaultSize\", 256));\n    }\n\n    public RingBufferLogHandler(int ringSize) {", "refactored_code": "    private static final int DEFAULT_RING_BUFFER_SIZE = Integer.getInteger(RingBufferLogHandler.class.getName() + \".defaultSize\", 256);\n     */\n    @Deprecated\n    public RingBufferLogHandler() {\n        this(DEFAULT_RING_BUFFER_SIZE);\n    }\n\n    public RingBufferLogHandler(int ringSize) {"}
{"magic_number_smell": "            byte[] encrypted = cipher.doFinal(this.value.getBytes(UTF_8));\n            byte[] payload = new byte[1 + 8 + iv.length + encrypted.length];\n            int pos = 0;\n            // For 1 we use this byte shifting model, V2 probably will need DataOutput\n            payload[pos++] = 1;\n            payload[pos++] = (byte)(iv.length >> 24);\n            payload[pos++] = (byte)(iv.length >> 16);", "refactored_code": "    private static final byte PAYLOAD_V1 = 1;\n            byte[] encrypted = cipher.doFinal(this.value.getBytes(UTF_8));\n            byte[] payload = new byte[1 + 8 + iv.length + encrypted.length];\n            int pos = 0;\n            // For PAYLOAD_V1 we use this byte shifting model, V2 probably will need DataOutput\n            payload[pos++] = PAYLOAD_V1;\n            payload[pos++] = (byte)(iv.length >> 24);\n            payload[pos++] = (byte)(iv.length >> 16);"}
{"magic_number_smell": "            return new ZipArchiver(out);\n        }\n\n        private static final long 1L = 1L;\n    }\n\n    private static final long 1L = 1L;", "refactored_code": "        private static final long serialVersionUID = 1L;\n            return new ZipArchiver(out);\n        }\n\n        private static final long serialVersionUID = 1L;\n    }\n\n    private static final long serialVersionUID = 1L;"}
{"magic_number_smell": "            pc.configure(reader,context);\n    }\n    private static class GetParserConfigurators extends SlaveToMasterCallable<Collection<ParserConfigurator>, IOException> {\n        private static final long -2523542286453177108L = -2178106894481500733L;\n        @Override\n        public Collection<ParserConfigurator> call() throws IOException {\n            return new ArrayList<>(all());", "refactored_code": "    private static final long serialVersionUID = -2523542286453177108L;\n            pc.configure(reader,context);\n    }\n    private static class GetParserConfigurators extends SlaveToMasterCallable<Collection<ParserConfigurator>, IOException> {\n        private static final long serialVersionUID = -2178106894481500733L;\n        @Override\n        public Collection<ParserConfigurator> call() throws IOException {\n            return new ArrayList<>(all());"}
{"magic_number_smell": "\n    @Override\n    public String getMessage() {\n        return super.getMessage()+\" error=\"+Native.getLastError()+\":\"+ Util.getWin32ErrorMessage(Native.getLastError());\n    }\n\n    public int getErrorCode() {", "refactored_code": "    private final int errorCode = Native.getLastError();\n\n    @Override\n    public String getMessage() {\n        return super.getMessage()+\" error=\"+errorCode+\":\"+ Util.getWin32ErrorMessage(errorCode);\n    }\n\n    public int getErrorCode() {"}
{"magic_number_smell": "        private static final long 1L = 1L;\n    }\n\n    private static final long 1L = 1L;\n}\n", "refactored_code": "        private static final long serialVersionUID = 1L;\n        private static final long serialVersionUID = 1L;\n    }\n\n    private static final long serialVersionUID = 1L;\n}\n"}
{"magic_number_smell": "     * The idea here is to overlap the CPU and I/O, so we want more threads than CPU numbers.\n     */\n    /*package*/ transient final ExecutorService threadPoolForLoad = new ThreadPoolExecutor(\n        Math.max(4, Runtime.getRuntime().availableProcessors() * 2), Math.max(4, Runtime.getRuntime().availableProcessors() * 2),\n        5L, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new NamingThreadFactory(new DaemonThreadFactory(), \"Jenkins load\"));\n\n", "refactored_code": "    private static final int TWICE_CPU_NUM = Math.max(4, Runtime.getRuntime().availableProcessors() * 2);\n     * The idea here is to overlap the CPU and I/O, so we want more threads than CPU numbers.\n     */\n    /*package*/ transient final ExecutorService threadPoolForLoad = new ThreadPoolExecutor(\n        TWICE_CPU_NUM, TWICE_CPU_NUM,\n        5L, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new NamingThreadFactory(new DaemonThreadFactory(), \"Jenkins load\"));\n\n"}
{"magic_number_smell": "     * Naming strategy which allows the admin to define a pattern a job's name has to follow.\n     */\n    public static final class PatternProjectNamingStrategy extends ProjectNamingStrategy implements Serializable {\n        private static final long 1L = 1L;\n\n        /**\n         * regex pattern a job's name has to follow", "refactored_code": "        private static final long serialVersionUID = 1L;\n     * Naming strategy which allows the admin to define a pattern a job's name has to follow.\n     */\n    public static final class PatternProjectNamingStrategy extends ProjectNamingStrategy implements Serializable {\n        private static final long serialVersionUID = 1L;\n\n        /**\n         * regex pattern a job's name has to follow"}
{"magic_number_smell": "                return false;\n            }\n\n            if (iIpSegment > 255) {\n                return false;\n            }\n", "refactored_code": "    private static final int IPV4_MAX_OCTET_VALUE = 255;\n                return false;\n            }\n\n            if (iIpSegment > IPV4_MAX_OCTET_VALUE) {\n                return false;\n            }\n"}
{"magic_number_smell": "     */\n    @Restricted(NoExternalUse.class) // TODO pending API\n    public byte[] newIv() {\n        return newIv(16);\n    }\n\n    /**", "refactored_code": "    public static final int DEFAULT_IV_LENGTH = 16;\n     */\n    @Restricted(NoExternalUse.class) // TODO pending API\n    public byte[] newIv() {\n        return newIv(DEFAULT_IV_LENGTH);\n    }\n\n    /**"}
{"magic_number_smell": "     * Determine if the given token was generated by the legacy system or the new one\n     */\n    private boolean isLegacyToken(@Nonnull String token) {\n        return token.length() != 34;\n    }\n    \n    /**", "refactored_code": "    private static final int TOKEN_LENGTH_V2 = 34;\n     * Determine if the given token was generated by the legacy system or the new one\n     */\n    private boolean isLegacyToken(@Nonnull String token) {\n        return token.length() != TOKEN_LENGTH_V2;\n    }\n    \n    /**"}
{"magic_number_smell": "            throws IOException, SecurityException {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        int bytesRead = -1;\n        byte[] buffer = new byte[8192];\n\n        while ((bytesRead = stream.read(buffer, 0, 8192)) != -1) {\n            baos.write(buffer, 0, bytesRead);", "refactored_code": "    private static final int BUFFER_SIZE = 8192;\n            throws IOException, SecurityException {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        int bytesRead = -1;\n        byte[] buffer = new byte[BUFFER_SIZE];\n\n        while ((bytesRead = stream.read(buffer, 0, BUFFER_SIZE)) != -1) {\n            baos.write(buffer, 0, bytesRead);"}
{"magic_number_smell": "                try {\n                    SecurityContextHolder.setContext(securityContext);\n                    compute();\n                    if (status != -1 && status != ERROR) {\n                        status = 1;\n                    }\n                } catch (Exception x) {", "refactored_code": "    private static final int CANCELED = -1;\n                try {\n                    SecurityContextHolder.setContext(securityContext);\n                    compute();\n                    if (status != CANCELED && status != ERROR) {\n                        status = 1;\n                    }\n                } catch (Exception x) {"}
{"magic_number_smell": "            synchronized (this) {\n                results.add(element);\n            }\n            decay *= (1 - 1 / 20);\n            progress(1 - decay);\n        }\n    }", "refactored_code": "    private static final double MAX_LIKELY_RUNS = 20;\n            synchronized (this) {\n                results.add(element);\n            }\n            decay *= (1 - 1 / MAX_LIKELY_RUNS);\n            progress(1 - decay);\n        }\n    }"}
{"magic_number_smell": "            return t;\n        }\n\n        private static final long 1L = 1L;\n    }\n\n    private static class ProcessCallableImpl implements ProcessCallable<Void> {", "refactored_code": "        private static final long serialVersionUID = 1L;\n            return t;\n        }\n\n        private static final long serialVersionUID = 1L;\n    }\n\n    private static class ProcessCallableImpl implements ProcessCallable<Void> {"}
{"magic_number_smell": "    @BeforeClass public static void setUpClass() throws Exception {\n        command = new CLICommandInvoker(j,  new DummyRangeCommand());\n        project = j.createFreeStyleProject(PROJECT_NAME);\n        for (int i=0; i<10; i++) {\n            assertThat(project.scheduleBuild2(0).get(), not(equalTo(null)));\n        }\n        assertThat(((FreeStyleProject) j.jenkins.getItem(\"aProject\")).getBuilds().size(),", "refactored_code": "    private static final int BUILDS = 10;\n    @BeforeClass public static void setUpClass() throws Exception {\n        command = new CLICommandInvoker(j,  new DummyRangeCommand());\n        project = j.createFreeStyleProject(PROJECT_NAME);\n        for (int i=0; i<BUILDS; i++) {\n            assertThat(project.scheduleBuild2(0).get(), not(equalTo(null)));\n        }\n        assertThat(((FreeStyleProject) j.jenkins.getItem(\"aProject\")).getBuilds().size(),"}
{"magic_number_smell": "\n        @Override\n        public long getRecurrencePeriod() {\n            return 50L;\n        }\n    }\n}", "refactored_code": "        public static final long RECURRENCE_PERIOD = 50L;\n\n        @Override\n        public long getRecurrencePeriod() {\n            return RECURRENCE_PERIOD;\n        }\n    }\n}"}
{"magic_number_smell": "                    throw ex;\n                }\n            }\n            return 0;\n        }\n\n        @Override", "refactored_code": "        public static final int EXIT_CODE_OK = 0;\n                    throw ex;\n                }\n            }\n            return EXIT_CODE_OK;\n        }\n\n        @Override"}
{"magic_number_smell": "\t\t} catch (Throwable e) {\n\t\t\tSystem.err.println(\"Error while generating or serializing payload\");\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(70);\n\t\t}\n\t\tSystem.exit(0);\n\t}", "refactored_code": "\tprivate static final int INTERNAL_ERROR_CODE = 70;\n\t\t} catch (Throwable e) {\n\t\t\tSystem.err.println(\"Error while generating or serializing payload\");\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(INTERNAL_ERROR_CODE);\n\t\t}\n\t\tSystem.exit(0);\n\t}"}
{"magic_number_smell": "    // required to make TemplatesImpl happy\n    public static class Foo implements Serializable {\n\n        private static final long -5971610431559700674L = 8207363842866235160L;\n    }\n\n", "refactored_code": "        private static final long serialVersionUID = -5971610431559700674L;\n    // required to make TemplatesImpl happy\n    public static class Foo implements Serializable {\n\n        private static final long serialVersionUID = 8207363842866235160L;\n    }\n\n"}
{"magic_number_smell": "\n\t// required to make TemplatesImpl happy\n\tpublic static class Foo implements Serializable {\n\t\tprivate static final long -5971610431559700674L = 8207363842866235160L; \t\t\n\t}\n\n\tpublic static <T> T createMemoitizedProxy(final Map<String,Object> map, final Class<T> iface, ", "refactored_code": "\t\tprivate static final long serialVersionUID = -5971610431559700674L;\n\n\t// required to make TemplatesImpl happy\n\tpublic static class Foo implements Serializable {\n\t\tprivate static final long serialVersionUID = 8207363842866235160L; \t\t\n\t}\n\n\tpublic static <T> T createMemoitizedProxy(final Map<String,Object> map, final Class<T> iface, "}
{"magic_number_smell": "            return new UpcaseFilter();\n        }\n        private static class UpcaseFilter extends ConsoleLogFilter implements Serializable {\n            private static final long 1 = 1;\n            @SuppressWarnings(\"rawtypes\") // inherited\n            @Override public OutputStream decorateLogger(AbstractBuild _ignore, final OutputStream logger) throws IOException, InterruptedException {\n                return new LineTransformationOutputStream() {", "refactored_code": "            private static final long serialVersionUID = 1;\n            return new UpcaseFilter();\n        }\n        private static class UpcaseFilter extends ConsoleLogFilter implements Serializable {\n            private static final long serialVersionUID = 1;\n            @SuppressWarnings(\"rawtypes\") // inherited\n            @Override public OutputStream decorateLogger(AbstractBuild _ignore, final OutputStream logger) throws IOException, InterruptedException {\n                return new LineTransformationOutputStream() {"}
{"magic_number_smell": "        String escapeForValue_uglyButSafe = escapeForValue_uglyButSafe(advancedText);\n\n        { // lenient mode\n            checkJelly(0, advancedText, advancedText, false);\n            checkGroovy(MODE_GROOVY_TEXT, advancedText, advancedText, false);\n            checkGroovy(MODE_XML_ESCAPE, advancedText, advancedText, false);\n", "refactored_code": "    private static final int MODE_JELLY_REGULAR = 0;\n        String escapeForValue_uglyButSafe = escapeForValue_uglyButSafe(advancedText);\n\n        { // lenient mode\n            checkJelly(MODE_JELLY_REGULAR, advancedText, advancedText, false);\n            checkGroovy(MODE_GROOVY_TEXT, advancedText, advancedText, false);\n            checkGroovy(MODE_XML_ESCAPE, advancedText, advancedText, false);\n"}
{"magic_number_smell": "        } else if (arg.startsWith(\"--config=\")) {\n            configFilePath = arg.substring(\"--config=\".length());\n        } else if (arg.startsWith(\"--digest=\")) {\n            digester = new CommonsDigester(20 * 1024 * 1024, arg.substring(\"--digest=\".length()));\n        } else if (arg.startsWith(\"-e\")) {\n            encoding = arg.substring(\"-e\".length());\n        } else if (arg.startsWith(\"--encoding=\")) {", "refactored_code": "    private final int MAX_MARK = 20 * 1024 * 1024;//20MB\n        } else if (arg.startsWith(\"--config=\")) {\n            configFilePath = arg.substring(\"--config=\".length());\n        } else if (arg.startsWith(\"--digest=\")) {\n            digester = new CommonsDigester(MAX_MARK, arg.substring(\"--digest=\".length()));\n        } else if (arg.startsWith(\"-e\")) {\n            encoding = arg.substring(\"-e\".length());\n        } else if (arg.startsWith(\"--encoding=\")) {"}
{"magic_number_smell": "        final TikaConfig finalConfig = config;\n        SwingUtilities.invokeLater(() -> new TikaGUI(\n                new DigestingParser(new AutoDetectParser(finalConfig),\n                        new CommonsDigester(20 * 1024 * 1024, CommonsDigester.DigestAlgorithm.MD5,\n                                CommonsDigester.DigestAlgorithm.SHA256), false)).setVisible(true));\n    }\n", "refactored_code": "    private static final int MAX_MARK = 20 * 1024 * 1024;//20MB\n        final TikaConfig finalConfig = config;\n        SwingUtilities.invokeLater(() -> new TikaGUI(\n                new DigestingParser(new AutoDetectParser(finalConfig),\n                        new CommonsDigester(MAX_MARK, CommonsDigester.DigestAlgorithm.MD5,\n                                CommonsDigester.DigestAlgorithm.SHA256), false)).setVisible(true));\n    }\n"}
{"magic_number_smell": "                LOG.trace(\"About to try to restart because: exit={} receivedRestartMsg={}\", exit,\n                        receivedRestartMsg);\n\n                if (exit == BatchProcessDriverCLI.253) {\n                    LOG.info(\"Restarting on expected restart code\");\n                } else {\n                    LOG.warn(\"Restarting on unexpected restart code: {}\", exit);", "refactored_code": "    public static final int PROCESS_RESTART_EXIT_CODE = 253;\n                LOG.trace(\"About to try to restart because: exit={} receivedRestartMsg={}\", exit,\n                        receivedRestartMsg);\n\n                if (exit == BatchProcessDriverCLI.PROCESS_RESTART_EXIT_CODE) {\n                    LOG.info(\"Restarting on expected restart code\");\n                } else {\n                    LOG.warn(\"Restarting on unexpected restart code: {}\", exit);"}
{"magic_number_smell": "                    fileQueue.size());\n\n            long elapsed = System.currentTimeMillis() - start;\n            if (10 * 60 * 1000 > 0 && elapsed > 10 * 60 * 1000) {\n                setEndedState(STATE.EXCEEDED_MAX_CONSEC_WAIT_MILLIS);\n                break;\n            }", "refactored_code": "    private final long MAX_CONSEC_WAIT_IN_MILLIS = 10 * 60 * 1000;// 10 minutes\n                    fileQueue.size());\n\n            long elapsed = System.currentTimeMillis() - start;\n            if (MAX_CONSEC_WAIT_IN_MILLIS > 0 && elapsed > MAX_CONSEC_WAIT_IN_MILLIS) {\n                setEndedState(STATE.EXCEEDED_MAX_CONSEC_WAIT_MILLIS);\n                break;\n            }"}
{"magic_number_smell": "        boolean isAdded = false;\n        if (select(fileResource.getMetadata())) {\n            long start = System.currentTimeMillis();\n            while (queue.offer(fileResource, 1000, TimeUnit.MILLISECONDS) ==\n                    false) {\n                long elapsed = System.currentTimeMillis() - start;\n                LOG.info(\"FileResourceCrawler is pausing. Queue is full: {} after {} ms\",", "refactored_code": "    private static final long PAUSE_INCREMENT_MILLIS = 1000;\n        boolean isAdded = false;\n        if (select(fileResource.getMetadata())) {\n            long start = System.currentTimeMillis();\n            while (queue.offer(fileResource, PAUSE_INCREMENT_MILLIS, TimeUnit.MILLISECONDS) ==\n                    false) {\n                long elapsed = System.currentTimeMillis() - start;\n                LOG.info(\"FileResourceCrawler is pausing. Queue is full: {} after {} ms\","}
{"magic_number_smell": "            }\n            long start = System.currentTimeMillis();\n            long elapsed = System.currentTimeMillis() - start;\n            while (elapsed < (pauseOnEarlyTermination + 1000)) {\n                try {\n                    Thread.sleep(500);\n                } catch (InterruptedException e) {", "refactored_code": "    private static final long EXTRA_GRACE_PERIOD_MILLIS = 1000;\n            }\n            long start = System.currentTimeMillis();\n            long elapsed = System.currentTimeMillis() - start;\n            while (elapsed < (pauseOnEarlyTermination + EXTRA_GRACE_PERIOD_MILLIS)) {\n                try {\n                    Thread.sleep(500);\n                } catch (InterruptedException e) {"}
{"magic_number_smell": "        if (hangOnInit) {\n            //interruptible light hang\n            try {\n                Thread.sleep(30000);\n            } catch (InterruptedException e) {\n                return;\n            }", "refactored_code": "    private final long HANG_MS = 30000;\n        if (hangOnInit) {\n            //interruptible light hang\n            try {\n                Thread.sleep(HANG_MS);\n            } catch (InterruptedException e) {\n                return;\n            }"}
{"magic_number_smell": "    private Boolean hasFileCommand = null;\n    private String fileCommandPath = DEFAULT_FILE_COMMAND_PATH;\n    private int maxBytes = 1_000_000;\n    private long timeoutMs = 6000;\n\n    private boolean useMime = false;\n", "refactored_code": "    private static final long DEFAULT_TIMEOUT_MS = 6000;\n    private Boolean hasFileCommand = null;\n    private String fileCommandPath = DEFAULT_FILE_COMMAND_PATH;\n    private int maxBytes = 1_000_000;\n    private long timeoutMs = DEFAULT_TIMEOUT_MS;\n\n    private boolean useMime = false;\n"}
{"magic_number_smell": "    }\n\n    public void startDocument() throws SAXException {\n        sendRequest(1);\n        doneSending();\n    }\n", "refactored_code": "    public static final int START_DOCUMENT = 1;\n    }\n\n    public void startDocument() throws SAXException {\n        sendRequest(START_DOCUMENT);\n        doneSending();\n    }\n"}
{"magic_number_smell": "    }\n\n    public int getId() {\n        return CLIENT_COUNTER.incrementAndGet();\n    }\n}\n", "refactored_code": "    private final int id = CLIENT_COUNTER.incrementAndGet();\n    }\n\n    public int getId() {\n        return id;\n    }\n}\n"}
{"magic_number_smell": "                method.invoke(object, args);\n                output.write(DONE);\n            } catch (InvocationTargetException e) {\n                output.write(-1);\n                // Try to send the underlying Exception itself\n                Throwable toSend = e.getCause();\n                try {", "refactored_code": "    public static final byte ERROR = -1;\n                method.invoke(object, args);\n                output.write(DONE);\n            } catch (InvocationTargetException e) {\n                output.write(ERROR);\n                // Try to send the underlying Exception itself\n                Throwable toSend = e.getCause();\n                try {"}
{"magic_number_smell": "    @Override\n    public void endEmbeddedDocument(ContentHandler contentHandler, Metadata metadata)\n            throws SAXException {\n        proxyBackToClient(1, contentHandler, metadata);\n    }\n\n    @Override", "refactored_code": "    public static final byte EMBEDDED_DOCUMENT = 1;\n    @Override\n    public void endEmbeddedDocument(ContentHandler contentHandler, Metadata metadata)\n            throws SAXException {\n        proxyBackToClient(EMBEDDED_DOCUMENT, contentHandler, metadata);\n    }\n\n    @Override"}
{"magic_number_smell": "    public static long getLongLE(byte[] data, int offset) {\n        long result = 0;\n\n        for (int j = offset + 8 - 1; j >= offset; j--) {\n            result <<= 8;\n            result |= 0xff & data[j];\n        }", "refactored_code": "    private static final int LONG_SIZE = 8;\n    public static long getLongLE(byte[] data, int offset) {\n        long result = 0;\n\n        for (int j = offset + LONG_SIZE - 1; j >= offset; j--) {\n            result <<= 8;\n            result |= 0xff & data[j];\n        }"}
{"magic_number_smell": "     */\n    @Override\n    public long skip(long n) throws IOException {\n        int bufSize = (int) Math.min(n, 4096);\n        byte[] buf = new byte[bufSize];\n        long bytesSkipped = 0;\n        int bytesRead = 0;", "refactored_code": "    private static final int SKIP_SIZE = 4096;\n     */\n    @Override\n    public long skip(long n) throws IOException {\n        int bufSize = (int) Math.min(n, SKIP_SIZE);\n        byte[] buf = new byte[bufSize];\n        long bytesSkipped = 0;\n        int bytesRead = 0;"}
{"magic_number_smell": "            position += n;\n        } else {\n            consecutiveEOFs++;\n            if (consecutiveEOFs > 1000) {\n                throw new IOException(\"Read too many -1 (EOFs); there could be an infinite loop.\" +\n                        \"If you think your file is not corrupt, please open an issue on Tika's \" +\n                        \"JIRA\");", "refactored_code": "    private static final int MAX_CONSECUTIVE_EOFS = 1000;\n            position += n;\n        } else {\n            consecutiveEOFs++;\n            if (consecutiveEOFs > MAX_CONSECUTIVE_EOFS) {\n                throw new IOException(\"Read too many -1 (EOFs); there could be an infinite loop.\" +\n                        \"If you think your file is not corrupt, please open an issue on Tika's \" +\n                        \"JIRA\");"}
{"magic_number_smell": "     */\n    public void addText(CharSequence text) {\n        int len = text.length();\n        if (len < 4096) {\n            char[] chars = text.toString().toCharArray();\n            addText(chars, 0, chars.length);\n            return;", "refactored_code": "    private static final int BUFFER_LENGTH = 4096;\n     */\n    public void addText(CharSequence text) {\n        int len = text.length();\n        if (len < BUFFER_LENGTH) {\n            char[] chars = text.toString().toCharArray();\n            addText(chars, 0, chars.length);\n            return;"}
{"magic_number_smell": "            return;\n        }\n        int sizeToAdd = estimateSize(value);\n        //if the maxFieldSize is < 300, use the minmax\n        //we do not want to truncate a mime!\n        int alwaysMaxFieldLength = Math.max(300, maxFieldSize);\n        String toSet = value;", "refactored_code": "    private final int minimumMaxFieldSizeInAlwaysFields = 300;\n            return;\n        }\n        int sizeToAdd = estimateSize(value);\n        //if the maxFieldSize is < minimumMaxFieldSizeInAlwaysFields, use the minmax\n        //we do not want to truncate a mime!\n        int alwaysMaxFieldLength = Math.max(minimumMaxFieldSizeInAlwaysFields, maxFieldSize);\n        String toSet = value;"}
{"magic_number_smell": "        /**\n         * Serial version UID.\n         */\n        private static final long 4357830439860729201L = 5140496601491000730L;\n\n        private MimeType type = null;\n", "refactored_code": "    private static final long serialVersionUID = 4357830439860729201L;\n        /**\n         * Serial version UID.\n         */\n        private static final long serialVersionUID = 5140496601491000730L;\n\n        private MimeType type = null;\n"}
{"magic_number_smell": "        /**\n         * Serial version UID.\n         */\n        private static final long -5778015347278111140L = 8468289702915532359L;\n\n        public int compare(String a, String b) {\n            int diff = b.length() - a.length();", "refactored_code": "    private static final long serialVersionUID = -5778015347278111140L;\n        /**\n         * Serial version UID.\n         */\n        private static final long serialVersionUID = 8468289702915532359L;\n\n        public int compare(String a, String b) {\n            int diff = b.length() - a.length();"}
{"magic_number_smell": "     */\n    public static final Parser withTypes(Parser parser, final Set<MediaType> types) {\n        return new ParserDecorator(parser) {\n            private static final long -3861669115439125268L = -7345051519565330731L;\n\n            @Override\n            public Set<MediaType> getSupportedTypes(ParseContext context) {", "refactored_code": "    private static final long serialVersionUID = -3861669115439125268L;\n     */\n    public static final Parser withTypes(Parser parser, final Set<MediaType> types) {\n        return new ParserDecorator(parser) {\n            private static final long serialVersionUID = -7345051519565330731L;\n\n            @Override\n            public Set<MediaType> getSupportedTypes(ParseContext context) {"}
{"magic_number_smell": "    }\n\n    public void addException(Exception e) {\n        if (exceptions.size() < 100) {\n            exceptions.add(e);\n        }\n    }", "refactored_code": "    private static final int MAX_EXCEPTIONS = 100;\n    }\n\n    public void addException(Exception e) {\n        if (exceptions.size() < MAX_EXCEPTIONS) {\n            exceptions.add(e);\n        }\n    }"}
{"magic_number_smell": "\n    private class EmbeddedParserDecorator extends StatefulParser {\n\n        private static final long 9086536568120690938L = 207648200464263337L;\n        private final ParserState parserState;\n        private String location = null;\n", "refactored_code": "    private static final long serialVersionUID = 9086536568120690938L;\n\n    private class EmbeddedParserDecorator extends StatefulParser {\n\n        private static final long serialVersionUID = 207648200464263337L;\n        private final ParserState parserState;\n        private String location = null;\n"}
{"magic_number_smell": "\n    private boolean returnStderr = true;\n\n    private long timeoutMs = 60000;\n\n    private int maxStdErr = 10000;\n", "refactored_code": "    public static final long DEFAULT_TIMEOUT_MS = 60000;\n\n    private boolean returnStderr = true;\n\n    private long timeoutMs = DEFAULT_TIMEOUT_MS;\n\n    private int maxStdErr = 10000;\n"}
{"magic_number_smell": "        FutureTask<Integer> futureTask = new FutureTask<>(() -> {\n            int b = input.read();\n            int read = 1;\n            while (read < 20000 && b != READY.getByte()) {\n\n                if (b == -1) {\n                    throw new RuntimeException(getMsg(\"pipesClientId=\" + pipesClientId + \": \" +", "refactored_code": "    private static final int MAX_BYTES_BEFORE_READY = 20000;\n        FutureTask<Integer> futureTask = new FutureTask<>(() -> {\n            int b = input.read();\n            int read = 1;\n            while (read < MAX_BYTES_BEFORE_READY && b != READY.getByte()) {\n\n                if (b == -1) {\n                    throw new RuntimeException(getMsg(\"pipesClientId=\" + pipesClientId + \": \" +"}
{"magic_number_smell": "\n    //if an extract is larger than this, the forked PipesServer should\n    //emit the extract directly and not send the contents back to the PipesClient\n    private long maxForEmitBatchBytes = 100000;\n    private long timeoutMillis = DEFAULT_TIMEOUT_MILLIS;\n    private long startupTimeoutMillis = DEFAULT_STARTUP_TIMEOUT_MILLIS;\n    private long sleepOnStartupTimeoutMillis = DEFAULT_STARTUP_TIMEOUT_MILLIS;", "refactored_code": "    public static final long DEFAULT_MAX_FOR_EMIT_BATCH = 100000;\n\n    //if an extract is larger than this, the forked PipesServer should\n    //emit the extract directly and not send the contents back to the PipesClient\n    private long maxForEmitBatchBytes = DEFAULT_MAX_FOR_EMIT_BATCH;\n    private long timeoutMillis = DEFAULT_TIMEOUT_MILLIS;\n    private long startupTimeoutMillis = DEFAULT_STARTUP_TIMEOUT_MILLIS;\n    private long sleepOnStartupTimeoutMillis = DEFAULT_STARTUP_TIMEOUT_MILLIS;"}
{"magic_number_smell": "                    long elapsed = System.currentTimeMillis() - since;\n                    if (parsing && elapsed > serverParseTimeoutMillis) {\n                        LOG.warn(\"timeout server; elapsed {}  with {}\", elapsed, serverParseTimeoutMillis);\n                        exit(17);\n                    } else if (!parsing && serverWaitTimeoutMillis > 0 &&\n                            elapsed > serverWaitTimeoutMillis) {\n                        LOG.info(\"closing down from inactivity\");", "refactored_code": "    public static final int TIMEOUT_EXIT_CODE = 17;\n                    long elapsed = System.currentTimeMillis() - since;\n                    if (parsing && elapsed > serverParseTimeoutMillis) {\n                        LOG.warn(\"timeout server; elapsed {}  with {}\", elapsed, serverParseTimeoutMillis);\n                        exit(TIMEOUT_EXIT_CODE);\n                    } else if (!parsing && serverWaitTimeoutMillis > 0 &&\n                            elapsed > serverWaitTimeoutMillis) {\n                        LOG.info(\"closing down from inactivity\");"}
{"magic_number_smell": "\n    private static final Logger LOGGER = LoggerFactory.getLogger(PipesIterator.class);\n\n    private long maxWaitMs = 300_000;\n    private ArrayBlockingQueue<FetchEmitTuple> queue = null;\n    private int queueSize = DEFAULT_QUEUE_SIZE;\n    private String fetcherName;", "refactored_code": "    public static final long DEFAULT_MAX_WAIT_MS = 300_000;\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(PipesIterator.class);\n\n    private long maxWaitMs = DEFAULT_MAX_WAIT_MS;\n    private ArrayBlockingQueue<FetchEmitTuple> queue = null;\n    private int queueSize = DEFAULT_QUEUE_SIZE;\n    private String fetcherName;"}
{"magic_number_smell": "            throws SAXException {\n        embeddedResources++;\n        embeddedDepth++;\n        if (embeddedDepth >= 100) {\n            throw new SAXException(\"Max embedded depth reached: \" + embeddedDepth);\n        }\n        metadata.set(TikaCoreProperties.EMBEDDED_DEPTH, embeddedDepth);", "refactored_code": "    private static final int MAX_DEPTH = 100;\n            throws SAXException {\n        embeddedResources++;\n        embeddedDepth++;\n        if (embeddedDepth >= MAX_DEPTH) {\n            throw new SAXException(\"Max embedded depth reached: \" + embeddedDepth);\n        }\n        metadata.set(TikaCoreProperties.EMBEDDED_DEPTH, embeddedDepth);"}
{"magic_number_smell": "     * @param inputStream stream containing the source of data\n     */\n    public RereadableInputStream(InputStream inputStream) {\n        this(inputStream, 512 * 1024 * 1024, true);\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_MAX_BYTES_IN_MEMORY = 512 * 1024 * 1024;\n     * @param inputStream stream containing the source of data\n     */\n    public RereadableInputStream(InputStream inputStream) {\n        this(inputStream, DEFAULT_MAX_BYTES_IN_MEMORY, true);\n    }\n\n    /**"}
{"magic_number_smell": "    /**\n     * Parser pool size\n     */\n    private static int POOL_SIZE = 10;\n    private static long LAST_LOG = -1;\n    private static volatile int MAX_ENTITY_EXPANSIONS = determineMaxEntityExpansions();\n    private static ArrayBlockingQueue<PoolSAXParser> SAX_PARSERS =", "refactored_code": "    public static final int DEFAULT_POOL_SIZE = 10;\n    /**\n     * Parser pool size\n     */\n    private static int POOL_SIZE = DEFAULT_POOL_SIZE;\n    private static long LAST_LOG = -1;\n    private static volatile int MAX_ENTITY_EXPANSIONS = determineMaxEntityExpansions();\n    private static ArrayBlockingQueue<PoolSAXParser> SAX_PARSERS ="}
{"magic_number_smell": "\n    @Test\n    public void testRewind() throws IOException {\n        InputStream is = createTestInputStream(3);\n        try (RereadableInputStream ris = new RereadableInputStream(is, MEMORY_THRESHOLD, true)) {\n            ris.rewind();  // rewind before we've done anything\n            for (int byteNum = 0; byteNum < 1; byteNum++) {", "refactored_code": "    private final int DEFAULT_TEST_SIZE = 3;\n\n    @Test\n    public void testRewind() throws IOException {\n        InputStream is = createTestInputStream(DEFAULT_TEST_SIZE);\n        try (RereadableInputStream ris = new RereadableInputStream(is, MEMORY_THRESHOLD, true)) {\n            ris.rewind();  // rewind before we've done anything\n            for (int byteNum = 0; byteNum < 1; byteNum++) {"}
{"magic_number_smell": "                        \"</properties>\";\n        Files.write(tikaConfigPath, xml.getBytes(StandardCharsets.UTF_8));\n        Random r = new Random();\n        for (int i = 0; i < 100; i++) {\n            float f = r.nextFloat();\n            if (f < 0.05) {\n                Files.write(inputDir.resolve(i + \".xml\"), OOM.getBytes(StandardCharsets.UTF_8));", "refactored_code": "    private final int totalFiles = 100;\n                        \"</properties>\";\n        Files.write(tikaConfigPath, xml.getBytes(StandardCharsets.UTF_8));\n        Random r = new Random();\n        for (int i = 0; i < totalFiles; i++) {\n            float f = r.nextFloat();\n            if (f < 0.05) {\n                Files.write(inputDir.resolve(i + \".xml\"), OOM.getBytes(StandardCharsets.UTF_8));"}
{"magic_number_smell": "\n    @Test\n    public void testIgnore() throws Exception {\n        Parser p = new MockParser(120000);\n        ContentHandler handler =\n                new BasicContentHandlerFactory(BasicContentHandlerFactory.HANDLER_TYPE.IGNORE, -1)\n                        .getNewContentHandler();", "refactored_code": "    private static final int OVER_DEFAULT = 120000;\n\n    @Test\n    public void testIgnore() throws Exception {\n        Parser p = new MockParser(OVER_DEFAULT);\n        ContentHandler handler =\n                new BasicContentHandlerFactory(BasicContentHandlerFactory.HANDLER_TYPE.IGNORE, -1)\n                        .getNewContentHandler();"}
{"magic_number_smell": "\n    @BeforeEach\n    public void setUp() {\n        stream = TikaInputStream.get(new NullInputStream(2000000));\n        handler = new SecureContentHandler(new DefaultHandler(), stream);\n    }\n", "refactored_code": "    private static final int MANY_BYTES = 2000000;\n\n    @BeforeEach\n    public void setUp() {\n        stream = TikaInputStream.get(new NullInputStream(MANY_BYTES));\n        handler = new SecureContentHandler(new DefaultHandler(), stream);\n    }\n"}
{"magic_number_smell": "    private Boolean hasSiegfriedCommand = null;\n    private String siegfriedPath = DEFAULT_SIEGFRIED_PATH;\n    private int maxBytes = 1_000_000;\n    private long timeoutMs = 60000;\n\n    private boolean useMime = false;\n", "refactored_code": "    private static final long DEFAULT_TIMEOUT_MS = 60000;\n    private Boolean hasSiegfriedCommand = null;\n    private String siegfriedPath = DEFAULT_SIEGFRIED_PATH;\n    private int maxBytes = 1_000_000;\n    private long timeoutMs = DEFAULT_TIMEOUT_MS;\n\n    private boolean useMime = false;\n"}
{"magic_number_smell": "            if (\n                //elapsed > commitEveryXMS ||\n                    lastInsert.rowCount % commitEveryXRows == 0) {\n                LOG.info(\"writer ({}) on table ({}) is committing after {} rows and {} ms\", WRITER_ID.getAndIncrement(),\n                        table.getName(), lastInsert.rowCount, elapsed);\n                p.executeBatch();\n                conn.commit();", "refactored_code": "    private final int myId = WRITER_ID.getAndIncrement();\n            if (\n                //elapsed > commitEveryXMS ||\n                    lastInsert.rowCount % commitEveryXRows == 0) {\n                LOG.info(\"writer ({}) on table ({}) is committing after {} rows and {} ms\", myId,\n                        table.getName(), lastInsert.rowCount, elapsed);\n                p.executeBatch();\n                conn.commit();"}
{"magic_number_smell": "     * Reads full extract, no modification of metadata list, no min or max extract length checking\n     */\n    public ExtractReader() {\n        this(ALTER_METADATA_LIST.AS_IS, -1L, -1L);\n    }\n\n    public ExtractReader(ALTER_METADATA_LIST alterMetadataList) {", "refactored_code": "    public static final long IGNORE_LENGTH = -1L;\n     * Reads full extract, no modification of metadata list, no min or max extract length checking\n     */\n    public ExtractReader() {\n        this(ALTER_METADATA_LIST.AS_IS, IGNORE_LENGTH, IGNORE_LENGTH);\n    }\n\n    public ExtractReader(ALTER_METADATA_LIST alterMetadataList) {"}
{"magic_number_smell": "    @Override\n    public void applyStyleAndValue(int dbColNum, ResultSet resultSet, Cell cell)\n            throws SQLException {\n        if (links < 65000) {\n            Hyperlink hyperlink = workbook.getCreationHelper().createHyperlink(linkType);\n            String path = resultSet.getString(dbColNum);\n            String address = urlBase + path;", "refactored_code": "    private static final int MAX_HYPERLINKS = 65000;\n    @Override\n    public void applyStyleAndValue(int dbColNum, ResultSet resultSet, Cell cell)\n            throws SQLException {\n        if (links < MAX_HYPERLINKS) {\n            Hyperlink hyperlink = workbook.getCreationHelper().createHyperlink(linkType);\n            String path = resultSet.getString(dbColNum);\n            String address = urlBase + path;"}
{"magic_number_smell": "    private final List<BytesRefCalculator> bytesRefCalculators = new ArrayList<>();\n\n    public CompositeTextStatsCalculator(List<TextStatsCalculator> calculators) {\n        this(calculators, AnalyzerManager.newInstance(10_000_000).getGeneralAnalyzer(),\n                new LanguageIDWrapper());\n    }\n", "refactored_code": "    private static final int DEFAULT_MAX_TOKENS = 10_000_000;\n    private final List<BytesRefCalculator> bytesRefCalculators = new ArrayList<>();\n\n    public CompositeTextStatsCalculator(List<TextStatsCalculator> calculators) {\n        this(calculators, AnalyzerManager.newInstance(DEFAULT_MAX_TOKENS).getGeneralAnalyzer(),\n                new LanguageIDWrapper());\n    }\n"}
{"magic_number_smell": "                String lastChunk = chunks.get(chunks.size() - 1);\n                String thisStr = new String(ch, start, length);\n\n                if (lastChunk.length() + length > 40) {\n                    chunks.add(thisStr);\n                } else {\n                    chunks.set(chunks.size() - 1, lastChunk + thisStr);", "refactored_code": "    protected final int MAXIMUM_TEXT_CHUNK_SIZE = 40;\n                String lastChunk = chunks.get(chunks.size() - 1);\n                String thisStr = new String(ch, start, length);\n\n                if (lastChunk.length() + length > MAXIMUM_TEXT_CHUNK_SIZE) {\n                    chunks.add(thisStr);\n                } else {\n                    chunks.set(chunks.size() - 1, lastChunk + thisStr);"}
{"magic_number_smell": "            while (true) {\n                FetchEmitTuple fetchEmitTuple = q.take();\n                if (fetchEmitTuple.equals(PipesIterator.COMPLETED_SEMAPHORE)) {\n                    LOG.debug(\"Thread \" + COUNTER.getAndIncrement() + \" stopping\");\n                    q.put(PipesIterator.COMPLETED_SEMAPHORE);\n                    return 1;\n                }", "refactored_code": "        private final int threadId = COUNTER.getAndIncrement();\n            while (true) {\n                FetchEmitTuple fetchEmitTuple = q.take();\n                if (fetchEmitTuple.equals(PipesIterator.COMPLETED_SEMAPHORE)) {\n                    LOG.debug(\"Thread \" + threadId + \" stopping\");\n                    q.put(PipesIterator.COMPLETED_SEMAPHORE);\n                    return 1;\n                }"}
{"magic_number_smell": "\n    }\n    //number of variants tried per file\n    int perFileIterations = 100;\n    //maxTransformers per file\n    int maxTransformers = DEFAULT_MAX_TRANSFORMERS;\n    //max time allowed to process each file in milliseconds", "refactored_code": "    private static final int DEFAULT_NUM_ITERATIONS = 100;\n\n    }\n    //number of variants tried per file\n    int perFileIterations = DEFAULT_NUM_ITERATIONS;\n    //maxTransformers per file\n    int maxTransformers = DEFAULT_MAX_TRANSFORMERS;\n    //max time allowed to process each file in milliseconds"}
{"magic_number_smell": "    @Override\n    public void transform(InputStream is, OutputStream os) throws IOException {\n        byte[] input = IOUtils.toByteArray(is);\n        int numSwaps = (int) Math.floor(0.01f * input.length);\n        //at least one swap\n        numSwaps = numSwaps == 0 ? 1 : numSwaps;\n        byte[] ret = new byte[input.length];", "refactored_code": "    private final float swapProbability = 0.01f;\n    @Override\n    public void transform(InputStream is, OutputStream os) throws IOException {\n        byte[] input = IOUtils.toByteArray(is);\n        int numSwaps = (int) Math.floor(swapProbability * input.length);\n        //at least one swap\n        numSwaps = numSwaps == 0 ? 1 : numSwaps;\n        byte[] ret = new byte[input.length];"}
{"magic_number_smell": "\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        while (!waitingFor.isEmpty()) {\n            assertFalse(stopwatch.elapsed(TimeUnit.MINUTES) > 2,\n                    \"Timed out after \" + 2 +\n                            \" minutes waiting for the emitted docs\");\n            try {", "refactored_code": "    public static final int WAIT_FOR_EMITTED_DOCS_TIMEOUT_MINUTES = 2;\n\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        while (!waitingFor.isEmpty()) {\n            assertFalse(stopwatch.elapsed(TimeUnit.MINUTES) > WAIT_FOR_EMITTED_DOCS_TIMEOUT_MINUTES,\n                    \"Timed out after \" + WAIT_FOR_EMITTED_DOCS_TIMEOUT_MINUTES +\n                            \" minutes waiting for the emitted docs\");\n            try {"}
{"magic_number_smell": "    public static final int 120 = 120;\n    private static final DockerComposeContainer<?> minioContainer = new DockerComposeContainer<>(\n            new File(\"src/test/resources/docker-compose.yml\")).withStartupTimeout(\n                    Duration.of(120, ChronoUnit.SECONDS))\n            .withExposedService(\"minio-service\", 9000);\n    private static final String MINIO_ENDPOINT = \"http://localhost:9000\";\n    private static final String ACCESS_KEY = \"minio\";", "refactored_code": "    public static final int MAX_STARTUP_TIMEOUT = 120;\n    public static final int MAX_STARTUP_TIMEOUT = 120;\n    private static final DockerComposeContainer<?> minioContainer = new DockerComposeContainer<>(\n            new File(\"src/test/resources/docker-compose.yml\")).withStartupTimeout(\n                    Duration.of(MAX_STARTUP_TIMEOUT, ChronoUnit.SECONDS))\n            .withExposedService(\"minio-service\", 9000);\n    private static final String MINIO_ENDPOINT = \"http://localhost:9000\";\n    private static final String ACCESS_KEY = \"minio\";"}
{"magic_number_smell": "\n    private void createTestFiles(String bodyContent) throws Exception {\n        testFileFolder.mkdirs();\n        for (int i = 0; i < 42; ++i) {\n            FileUtils.writeStringToFile(new File(testFileFolder, \"test-\" + i + \".html\"),\n                    \"<html><body>\" + bodyContent + \"</body></html>\", StandardCharsets.UTF_8);\n        }", "refactored_code": "    private final int numDocs = 42;\n\n    private void createTestFiles(String bodyContent) throws Exception {\n        testFileFolder.mkdirs();\n        for (int i = 0; i < numDocs; ++i) {\n            FileUtils.writeStringToFile(new File(testFileFolder, \"test-\" + i + \".html\"),\n                    \"<html><body>\" + bodyContent + \"</body></html>\", StandardCharsets.UTF_8);\n        }"}
{"magic_number_smell": "    private static final String SPACE = \" \";\n\n    //size at which to break strings for detection (in codepoints)\n    private int chunkSize = 300;\n\n    //require that the \"best\" language be the same\n    //and that the confidence in that language increase over", "refactored_code": "    public static final int DEFAULT_CHUNK_SIZE = 300;\n    private static final String SPACE = \" \";\n\n    //size at which to break strings for detection (in codepoints)\n    private int chunkSize = DEFAULT_CHUNK_SIZE;\n\n    //require that the \"best\" language be the same\n    //and that the confidence in that language increase over"}
{"magic_number_smell": "    private CharArrayWriter writer;\n    private Set<String> languages;\n    private Map<String, Float> languageProbabilities;\n    private int maxCharsForDetection = 20000;\n\n    public OptimaizeLangDetector() {\n        this(20000);", "refactored_code": "    public static final int DEFAULT_MAX_CHARS_FOR_DETECTION = 20000;\n    private CharArrayWriter writer;\n    private Set<String> languages;\n    private Map<String, Float> languageProbabilities;\n    private int maxCharsForDetection = DEFAULT_MAX_CHARS_FOR_DETECTION;\n\n    public OptimaizeLangDetector() {\n        this(DEFAULT_MAX_CHARS_FOR_DETECTION);"}
{"magic_number_smell": "     * WARNING: Will never return true for small amount of input texts.\n     *\n     * @return <code>true</code> if the distance is smaller then\n     * {@value LanguageIdentifier#0.022}, <code>false</code> otherwise\n     */\n    public boolean isReasonablyCertain() {\n        return distance < 0.022;", "refactored_code": "    private static final double CERTAINTY_LIMIT = 0.022;\n     * WARNING: Will never return true for small amount of input texts.\n     *\n     * @return <code>true</code> if the distance is smaller then\n     * {@value LanguageIdentifier#CERTAINTY_LIMIT}, <code>false</code> otherwise\n     */\n    public boolean isReasonablyCertain() {\n        return distance < CERTAINTY_LIMIT;"}
{"magic_number_smell": "    }\n\n    public LanguageProfile() {\n        this(3);\n    }\n\n    public LanguageProfile(String content, int length) {", "refactored_code": "    public static final int DEFAULT_NGRAM_LENGTH = 3;\n    }\n\n    public LanguageProfile() {\n        this(DEFAULT_NGRAM_LENGTH);\n    }\n\n    public LanguageProfile(String content, int length) {"}
{"magic_number_smell": "                    LanguageProfilerBuilder.create(profileName, is, UTF_8.name());\n            try (OutputStream os = Files.newOutputStream(tmpProfileModel)) {\n                ngramProfileBuilder.save(os);;\n                assertEquals(1000, ngramProfileBuilder.getSorted().size());\n            }\n        }\n    }", "refactored_code": "    private final int maxlen = 1000;\n                    LanguageProfilerBuilder.create(profileName, is, UTF_8.name());\n            try (OutputStream os = Files.newOutputStream(tmpProfileModel)) {\n                ngramProfileBuilder.save(os);;\n                assertEquals(maxlen, ngramProfileBuilder.getSorted().size());\n            }\n        }\n    }"}
{"magic_number_smell": "        AgeRecogniser.setAgePredictorClient(mockAgeClassifier);\n\n        try {\n            when(mockAgeClassifier.predictAge(TEST_TEXT)).thenReturn(26.4);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }", "refactored_code": "    private static final double TEST_AGE = 26.4;\n        AgeRecogniser.setAgePredictorClient(mockAgeClassifier);\n\n        try {\n            when(mockAgeClassifier.predictAge(TEST_TEXT)).thenReturn(TEST_AGE);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }"}
{"magic_number_smell": "    }\n\n    private static class CompositeVideoParser extends CompositeParser {\n        private static final long -2855917932512164988L = -2398203965206381382L;\n        private static List<Parser> videoParsers = Arrays.asList(new Parser[]{new MP4Parser()});\n\n        CompositeVideoParser() {", "refactored_code": "    private static final long serialVersionUID = -2855917932512164988L;\n    }\n\n    private static class CompositeVideoParser extends CompositeParser {\n        private static final long serialVersionUID = -2398203965206381382L;\n        private static List<Parser> videoParsers = Arrays.asList(new Parser[]{new MP4Parser()});\n\n        CompositeVideoParser() {"}
{"magic_number_smell": "            IOUtils.skipFully(stream, diff);\n            bytesRead += diff;\n            if (f.entryId == REAL_NAME) {\n                if (f.length > 1_073_741_824) {\n                    throw new TikaMemoryLimitException(f.length, 1_073_741_824);\n                }\n                buffer = new byte[(int) f.length];", "refactored_code": "    private static final int MAX_FIELD_LENGTH = 1_073_741_824;\n            IOUtils.skipFully(stream, diff);\n            bytesRead += diff;\n            if (f.entryId == REAL_NAME) {\n                if (f.length > MAX_FIELD_LENGTH) {\n                    throw new TikaMemoryLimitException(f.length, MAX_FIELD_LENGTH);\n                }\n                buffer = new byte[(int) f.length];"}
{"magic_number_smell": "\n    public static String asAlphaNumeric(int i) {\n        StringBuffer sbuff = new StringBuffer();\n        int index = i % 26;\n        int ratio = i / 26;\n\n        if (index == 0) {", "refactored_code": "    private static final int MAX = 26;\n\n    public static String asAlphaNumeric(int i) {\n        StringBuffer sbuff = new StringBuffer();\n        int index = i % MAX;\n        int ratio = i / MAX;\n\n        if (index == 0) {"}
{"magic_number_smell": "            }\n            if (versionCode == MPEG_V2) {\n                rate *= 2;\n            } else if (versionCode == 3) {\n                rate *= 4;\n            }\n            sampleRate = rate;", "refactored_code": "    public static final int MPEG_V1 = 3;\n            }\n            if (versionCode == MPEG_V2) {\n                rate *= 2;\n            } else if (versionCode == MPEG_V1) {\n                rate *= 4;\n            }\n            sampleRate = rate;"}
{"magic_number_smell": "     * @return the duration of this frame in milliseconds\n     */\n    private static float calculateDuration(int layer, int sampleRate) {\n        int sampleCount = (layer == AudioFrame.LAYER_1) ? 384 : SAMPLE_COUNT_L2;\n        return (1000.0f / sampleRate) * sampleCount;\n    }\n", "refactored_code": "    private static final int SAMPLE_COUNT_L1 = 384;\n     * @return the duration of this frame in milliseconds\n     */\n    private static float calculateDuration(int layer, int sampleRate) {\n        int sampleCount = (layer == AudioFrame.LAYER_1) ? SAMPLE_COUNT_L1 : SAMPLE_COUNT_L2;\n        return (1000.0f / sampleRate) * sampleCount;\n    }\n"}
{"magic_number_smell": "\n    private Instant toInstant(double day) {\n        long l = (long) day;\n        return epoch.plus(l, ChronoUnit.DAYS).plusNanos(Math.round((day - l) * 24.0 * 60.0 * 60.0 * 1000000000.0));\n    }\n\n    public static Instant toInstant(long julianDay, long millisecondsIntoDay) {", "refactored_code": "    private static final double NANOS_PER_DAY = 24.0 * 60.0 * 60.0 * 1000000000.0;\n\n    private Instant toInstant(double day) {\n        long l = (long) day;\n        return epoch.plus(l, ChronoUnit.DAYS).plusNanos(Math.round((day - l) * NANOS_PER_DAY));\n    }\n\n    public static Instant toInstant(long julianDay, long millisecondsIntoDay) {"}
{"magic_number_smell": "\n    private static final Map<MediaType, String> TYPES_TO_RENDERER =\n            new HashMap<MediaType, String>() {\n                private static final long -4543476498190054160L = -741976157563751152L;\n\n                {\n                    put(MediaType.text(\"x-c++src\"), CPP);", "refactored_code": "    private static final long serialVersionUID = -4543476498190054160L;\n\n    private static final Map<MediaType, String> TYPES_TO_RENDERER =\n            new HashMap<MediaType, String>() {\n                private static final long serialVersionUID = -741976157563751152L;\n\n                {\n                    put(MediaType.text(\"x-c++src\"), CPP);"}
{"magic_number_smell": "    }\n\n    @Field\n    private int markLimit = 8192;\n\n    public Charset detect(InputStream input, Metadata metadata) throws IOException {\n        if (input == null) {", "refactored_code": "    private static final int DEFAULT_MARK_LIMIT = 8192;\n    }\n\n    @Field\n    private int markLimit = DEFAULT_MARK_LIMIT;\n\n    public Charset detect(InputStream input, Metadata metadata) throws IOException {\n        if (input == null) {"}
{"magic_number_smell": "    private static final int 8192 = 8192;\n\n    @Field\n    private int markLimit = 8192;\n\n    /**\n     * Extracts a charset from a Content-Type HTTP header.", "refactored_code": "    private static final int META_TAG_BUFFER_SIZE = 8192;\n    private static final int META_TAG_BUFFER_SIZE = 8192;\n\n    @Field\n    private int markLimit = META_TAG_BUFFER_SIZE;\n\n    /**\n     * Extracts a charset from a Content-Type HTTP header."}
{"magic_number_smell": "                            \"consider bumping the maxRecordLength via tika-config.xml\");\n                }\n                switch (extensionType) {\n                    case 1:\n                        metadataExtractor.parseRawExif(stream, extensionLength, true);\n                        break;\n                    case EXTENSION_TAG_XMP:", "refactored_code": "    protected static final int EXTENSION_TAG_EXIF = 1;\n                            \"consider bumping the maxRecordLength via tika-config.xml\");\n                }\n                switch (extensionType) {\n                    case EXTENSION_TAG_EXIF:\n                        metadataExtractor.parseRawExif(stream, extensionLength, true);\n                        break;\n                    case EXTENSION_TAG_XMP:"}
{"magic_number_smell": "            .appendLiteral(' ')\n            .appendText(MONTH_OF_YEAR, monthOfYear())\n            .appendLiteral(' ')\n            .appendValueReduced(YEAR, 2, 4, 1970)\n            .appendLiteral(' ')\n            .appendValue(HOUR_OF_DAY, 2)\n            .appendLiteral(':')", "refactored_code": "    private static final int INITIAL_YEAR = 1970;\n            .appendLiteral(' ')\n            .appendText(MONTH_OF_YEAR, monthOfYear())\n            .appendLiteral(' ')\n            .appendValueReduced(YEAR, 2, 4, INITIAL_YEAR)\n            .appendLiteral(' ')\n            .appendValue(HOUR_OF_DAY, 2)\n            .appendLiteral(':')"}
{"magic_number_smell": "                        message.write(0x0A);\n                        curLine = reader.readLine();\n                    } while (curLine != null && !curLine.startsWith(MBOX_RECORD_DIVIDER) &&\n                            message.size() < 50000000);\n\n                    for (String item : multiline) {\n                        saveHeaderInMetadata(mailMetadata, item);", "refactored_code": "    public static final int MAIL_MAX_SIZE = 50000000;\n                        message.write(0x0A);\n                        curLine = reader.readLine();\n                    } while (curLine != null && !curLine.startsWith(MBOX_RECORD_DIVIDER) &&\n                            message.size() < MAIL_MAX_SIZE);\n\n                    for (String item : multiline) {\n                        saveHeaderInMetadata(mailMetadata, item);"}
{"magic_number_smell": "\n        XHTMLContentHandler xhtml = new XHTMLContentHandler(handler, metadata);\n        xhtml.startDocument();\n        byte[] asciiNameBytes = new byte[54];\n        IOUtils.readFully(stream, asciiNameBytes);\n        int asciiNameLength =\n                (int) asciiNameBytes[0];//don't need to convert to unsigned int because it can't", "refactored_code": "    private static final int ASCII_CHUNK_LENGTH = 54;\n\n        XHTMLContentHandler xhtml = new XHTMLContentHandler(handler, metadata);\n        xhtml.startDocument();\n        byte[] asciiNameBytes = new byte[ASCII_CHUNK_LENGTH];\n        IOUtils.readFully(stream, asciiNameBytes);\n        int asciiNameLength =\n                (int) asciiNameBytes[0];//don't need to convert to unsigned int because it can't"}
{"magic_number_smell": "     */\n    public FileNodeListHeader(long position, long uintMagic, long fileNodeListId,\n                              long nFragmentSequence) throws TikaException {\n        if (uintMagic != 0xA4567AB1F5F7F4C4L) {\n            throw new TikaException(\n                    \"unitMagic must always be: 0x\" + Long.toHexString(0xA4567AB1F5F7F4C4L));\n        }", "refactored_code": "    public static final long UNIT_MAGIC_CONSTANT = 0xA4567AB1F5F7F4C4L;\n     */\n    public FileNodeListHeader(long position, long uintMagic, long fileNodeListId,\n                              long nFragmentSequence) throws TikaException {\n        if (uintMagic != UNIT_MAGIC_CONSTANT) {\n            throw new TikaException(\n                    \"unitMagic must always be: 0x\" + Long.toHexString(UNIT_MAGIC_CONSTANT));\n        }"}
{"magic_number_smell": "        int len = byteBuffer.remaining();\n        int totalRead = 0;\n        int bytesRead = 0;\n        byte[] buf = new byte[8192];\n        while (totalRead < len) {\n            int bytesToRead = Math.min((len - totalRead), 8192);\n            bytesRead = raf.read(buf, 0, bytesToRead);", "refactored_code": "    private static final int TRANSFER_SIZE = 8192;\n        int len = byteBuffer.remaining();\n        int totalRead = 0;\n        int bytesRead = 0;\n        byte[] buf = new byte[TRANSFER_SIZE];\n        while (totalRead < len) {\n            int bytesToRead = Math.min((len - totalRead), TRANSFER_SIZE);\n            bytesRead = raf.read(buf, 0, bytesToRead);"}
{"magic_number_smell": "            // TODO check that next is OK\n        }\n        long footer = deserializeLittleEndianLong();\n        if (footer != 0x8BC215C38233BA4BL) {\n            throw new TikaException(\n                    \"Invalid footer constant. Expected \" + 0x8BC215C38233BA4BL + \" but was \" + footer);\n        }", "refactored_code": "    public static final long FOOTER_CONST = 0x8BC215C38233BA4BL;\n            // TODO check that next is OK\n        }\n        long footer = deserializeLittleEndianLong();\n        if (footer != FOOTER_CONST) {\n            throw new TikaException(\n                    \"Invalid footer constant. Expected \" + FOOTER_CONST + \" but was \" + footer);\n        }"}
{"magic_number_smell": "    public static int tryParse(byte[] byteArray, int startIndex,\n                               AtomicReference<StreamObjectHeaderStart> streamObjectHeader) {\n        int headerType = byteArray[startIndex] & 0x03;\n        if (headerType == StreamObjectHeaderStart.0x0) {\n            streamObjectHeader.set(new StreamObjectHeaderStart16bit());\n        } else {\n            if (headerType == StreamObjectHeaderStart.STREAM_OBJECT_HEADER_START_32_BIT) {", "refactored_code": "    public static final int STREAM_OBJECT_HEADER_START_16_BIT = 0x0;\n    public static int tryParse(byte[] byteArray, int startIndex,\n                               AtomicReference<StreamObjectHeaderStart> streamObjectHeader) {\n        int headerType = byteArray[startIndex] & 0x03;\n        if (headerType == StreamObjectHeaderStart.STREAM_OBJECT_HEADER_START_16_BIT) {\n            streamObjectHeader.set(new StreamObjectHeaderStart16bit());\n        } else {\n            if (headerType == StreamObjectHeaderStart.STREAM_OBJECT_HEADER_START_32_BIT) {"}
{"magic_number_smell": "\n            case 8:\n                this.decodedValue = 0;\n                this.type = 0;\n                return 1;\n\n            default:", "refactored_code": "    public static final int CompactUintNullType = 0;\n\n            case 8:\n                this.decodedValue = 0;\n                this.type = CompactUintNullType;\n                return 1;\n\n            default:"}
{"magic_number_smell": "\n            case 8:\n                this.guid = GuidUtil.emptyGuid();\n                this.type = 0;\n                return 1;\n\n            default:", "refactored_code": "    public static final int ExtendedGUIDNullType = 0;\n\n            case 8:\n                this.guid = GuidUtil.emptyGuid();\n                this.type = ExtendedGUIDNullType;\n                return 1;\n\n            default:"}
{"magic_number_smell": "        UInteger[] hashValues = this.getHashValues();\n\n        while (chunkStart + 1 < inputLength) {\n            long chunkEndMax = Math.min(chunkStart + this.65535, inputLength);\n            long chunkEnd = (int) chunkEndMax;\n\n            for (long n = chunkStart; n < chunkEndMax; n++) {", "refactored_code": "    private final int maxChunkSize = 65535;\n        UInteger[] hashValues = this.getHashValues();\n\n        while (chunkStart + 1 < inputLength) {\n            long chunkEndMax = Math.min(chunkStart + this.maxChunkSize, inputLength);\n            long chunkEnd = (int) chunkEndMax;\n\n            for (long n = chunkStart; n < chunkEndMax; n++) {"}
{"magic_number_smell": "    private static final UByte[] mkValues() {\n        UByte[] ret = new UByte[256];\n\n        for (int i = Byte.0x00; i <= Byte.MAX_VALUE; i++) {\n            ret[i & MAX_VALUE] = new UByte((byte) i);\n        }\n", "refactored_code": "    public static final short MIN_VALUE = 0x00;\n    private static final UByte[] mkValues() {\n        UByte[] ret = new UByte[256];\n\n        for (int i = Byte.MIN_VALUE; i <= Byte.MAX_VALUE; i++) {\n            ret[i & MAX_VALUE] = new UByte((byte) i);\n        }\n"}
{"magic_number_smell": "     * A constant holding the minimum value an <code>unsigned int</code> can\n     * have as UInteger, 0.\n     */\n    public static final UInteger MIN = valueOf(0x00000000);\n    /**\n     * A constant holding the maximum value an <code>unsigned int</code> can\n     * have as UInteger, 2<sup>32</sup>-1.", "refactored_code": "    public static final long MIN_VALUE = 0x00000000;\n     * A constant holding the minimum value an <code>unsigned int</code> can\n     * have as UInteger, 0.\n     */\n    public static final UInteger MIN = valueOf(MIN_VALUE);\n    /**\n     * A constant holding the maximum value an <code>unsigned int</code> can\n     * have as UInteger, 2<sup>32</sup>-1."}
{"magic_number_smell": "     * A constant holding the minimum value an <code>unsigned short</code> can\n     * have as UShort, 0.\n     */\n    public static final UShort MIN = valueOf(0x0000);\n    /**\n     * A constant holding the maximum value an <code>unsigned short</code> can\n     * have as UShort, 2<sup>16</sup>-1.", "refactored_code": "    public static final int MIN_VALUE = 0x0000;\n     * A constant holding the minimum value an <code>unsigned short</code> can\n     * have as UShort, 0.\n     */\n    public static final UShort MIN = valueOf(MIN_VALUE);\n    /**\n     * A constant holding the maximum value an <code>unsigned short</code> can\n     * have as UShort, 2<sup>16</sup>-1."}
{"magic_number_smell": "        long currentToken = token.incrementAndGet();\n\n        // The token value cannot be exceed the value 4294967295.\n        if (currentToken > 4294967295.0) {\n            throw new TikaException(\"The token exceeds the max value 4294967295\");\n        }\n", "refactored_code": "    public static final double MAXTOKENVALUE = 4294967295.0;\n        long currentToken = token.incrementAndGet();\n\n        // The token value cannot be exceed the value 4294967295.\n        if (currentToken > MAXTOKENVALUE) {\n            throw new TikaException(\"The token exceeds the max value 4294967295\");\n        }\n"}
{"magic_number_smell": "                //without apparent problems\n                mustRevertPackage = true;\n                try (RereadableInputStream rereadableInputStream = new RereadableInputStream(stream,\n                        1000000, false)) {\n                    try {\n                        pkg = OPCPackage.open(CloseShieldInputStream.wrap(rereadableInputStream));\n                    } catch (UnsupportedZipFeatureException e) {", "refactored_code": "    private static final int MAX_BUFFER_LENGTH = 1000000;\n                //without apparent problems\n                mustRevertPackage = true;\n                try (RereadableInputStream rereadableInputStream = new RereadableInputStream(stream,\n                        MAX_BUFFER_LENGTH, false)) {\n                    try {\n                        pkg = OPCPackage.open(CloseShieldInputStream.wrap(rereadableInputStream));\n                    } catch (UnsupportedZipFeatureException e) {"}
{"magic_number_smell": "        List<DBFRow> firstRows = new LinkedList<>();\n        DBFRow row = reader.next();\n        int i = 0;\n        while (row != null && i++ < 10) {\n            firstRows.add(row.deepCopy());\n            row = reader.next();\n        }", "refactored_code": "    private static final int ROWS_TO_BUFFER_FOR_CHARSET_DETECTION = 10;\n        List<DBFRow> firstRows = new LinkedList<>();\n        DBFRow row = reader.next();\n        int i = 0;\n        while (row != null && i++ < ROWS_TO_BUFFER_FOR_CHARSET_DETECTION) {\n            firstRows.add(row.deepCopy());\n            row = reader.next();\n        }"}
{"magic_number_smell": "        //what the third byte signifies.\n        if (c == 241) {\n            byte b = in.readWPByte();\n            if (b == 0) {\n                inUndo = true;\n            } else if (b == END_UNDO) {\n                inUndo = false;", "refactored_code": "    private static final byte START_UNDO = 0;\n        //what the third byte signifies.\n        if (c == 241) {\n            byte b = in.readWPByte();\n            if (b == START_UNDO) {\n                inUndo = true;\n            } else if (b == END_UNDO) {\n                inUndo = false;"}
{"magic_number_smell": "        ImageDeskew id = new ImageDeskew(bi);\n        double angle = id.getSkewAngle();\n\n        if (angle < 1.0D && angle > -1.0D) {\n            LOG.debug(\"Changing angle \" + angle + \" to 0.0\");\n            angle = 0d;\n        } else {", "refactored_code": "    private static final double MINIMUM_DESKEW_THRESHOLD = 1.0D;\n        ImageDeskew id = new ImageDeskew(bi);\n        double angle = id.getSkewAngle();\n\n        if (angle < MINIMUM_DESKEW_THRESHOLD && angle > -MINIMUM_DESKEW_THRESHOLD) {\n            LOG.debug(\"Changing angle \" + angle + \" to 0.0\");\n            angle = 0d;\n        } else {"}
{"magic_number_smell": "        }\n\n        for (int var6 = 0; var6 < var1; ++var6) {\n            var5 = var2[var6].index / this.200;\n            var4 = var2[var6].index - var5 * this.200;\n            var2[var6].alpha = this.getAlpha(var4);\n            var2[var6].d = (double) var5 + this.cDMin;", "refactored_code": "    private final int cSteps = 200;\n        }\n\n        for (int var6 = 0; var6 < var1; ++var6) {\n            var5 = var2[var6].index / this.cSteps;\n            var4 = var2[var6].index - var5 * this.cSteps;\n            var2[var6].alpha = this.getAlpha(var4);\n            var2[var6].d = (double) var5 + this.cDMin;"}
{"magic_number_smell": "                         Map<MCID, String> paragraphs, Map<String, HtmlTag> roleMap)\n            throws IOException, SAXException {\n\n        if (depth > 1000) {\n            throw new IOException(\n                    new TikaException(\"Exceeded max recursion depth \" + 1000));\n        }", "refactored_code": "    private static final int MAX_RECURSION_DEPTH = 1000;\n                         Map<MCID, String> paragraphs, Map<String, HtmlTag> roleMap)\n            throws IOException, SAXException {\n\n        if (depth > MAX_RECURSION_DEPTH) {\n            throw new IOException(\n                    new TikaException(\"Exceeded max recursion depth \" + MAX_RECURSION_DEPTH));\n        }"}
{"magic_number_smell": "\n    protected static void copyUpToMaxLength(InputStream is, OutputStream os)\n            throws IOException, TikaException {\n        BoundedInputStream bis = new BoundedInputStream(100 * 1024 * 1024, is);\n        IOUtils.copy(bis, os);\n        if (bis.hasHitBound()) {\n            throw new TikaMemoryLimitException(", "refactored_code": "    protected static final long MAX_IMAGE_LENGTH_BYTES = 100 * 1024 * 1024;\n\n    protected static void copyUpToMaxLength(InputStream is, OutputStream os)\n            throws IOException, TikaException {\n        BoundedInputStream bis = new BoundedInputStream(MAX_IMAGE_LENGTH_BYTES, is);\n        IOUtils.copy(bis, os);\n        if (bis.hasHitBound()) {\n            throw new TikaMemoryLimitException("}
{"magic_number_smell": "    }\n\n    protected boolean isWhitespace(int c) {\n        return c == 0 || c == 9 || c == 12 || c == 10 || c == ASCII_CR || c == ASCII_SPACE;\n    }\n\n    protected long readLong() throws IOException {", "refactored_code": "    private static final byte ASCII_LF = 10;\n    }\n\n    protected boolean isWhitespace(int c) {\n        return c == 0 || c == 9 || c == 12 || c == ASCII_LF || c == ASCII_CR || c == ASCII_SPACE;\n    }\n\n    protected long readLong() throws IOException {"}
{"magic_number_smell": "    private final double minConfidence;\n\n    CSVSniffer(char[] delimiters) {\n        this(10000, delimiters, DEFAULT_MIN_CONFIDENCE);\n    }\n\n    CSVSniffer(int markLimit, char[] delimiters, double minConfidence) {", "refactored_code": "    private static final int DEFAULT_MARK_LIMIT = 10000;\n    private final double minConfidence;\n\n    CSVSniffer(char[] delimiters) {\n        this(DEFAULT_MARK_LIMIT, delimiters, DEFAULT_MIN_CONFIDENCE);\n    }\n\n    CSVSniffer(int markLimit, char[] delimiters, double minConfidence) {"}
{"magic_number_smell": "     * csv, tsv or txt.\n     */\n    @Field\n    private int markLimit = 20000;\n\n\n    /**", "refactored_code": "    private static final int DEFAULT_MARK_LIMIT = 20000;\n     * csv, tsv or txt.\n     */\n    @Field\n    private int markLimit = DEFAULT_MARK_LIMIT;\n\n\n    /**"}
{"magic_number_smell": "        byte[] bytes = new byte[MAX_BYTES];\n        try {\n            int numRead = IOUtils.read(input, bytes);\n            if (numRead < 2) {\n                return null;\n            } else if (numRead < MAX_BYTES) {\n                //s", "refactored_code": "    private static final int MIN_BYTES = 2;\n        byte[] bytes = new byte[MAX_BYTES];\n        try {\n            int numRead = IOUtils.read(input, bytes);\n            if (numRead < MIN_BYTES) {\n                return null;\n            } else if (numRead < MAX_BYTES) {\n                //s"}
{"magic_number_smell": "                confidence = charsetMatch.getConfidence() & 0x000000ff;\n                if (confidence > 0) {\n                    // Just to be safe, constrain\n                    confidence = Math.min(confidence, 100);\n\n                    // Apply charset hint.\n                    if ((fDeclaredEncoding != null) &&", "refactored_code": "    private static final int MAX_CONFIDENCE = 100;\n                confidence = charsetMatch.getConfidence() & 0x000000ff;\n                if (confidence > 0) {\n                    // Just to be safe, constrain\n                    confidence = Math.min(confidence, MAX_CONFIDENCE);\n\n                    // Apply charset hint.\n                    if ((fDeclaredEncoding != null) &&"}
{"magic_number_smell": "\n    private static final int 1024 = 1024;\n\n    private static final int DEFAULT_MARK_LIMIT = 16 * 1024;\n\n    private int markLimit = DEFAULT_MARK_LIMIT;\n", "refactored_code": "    private static final int BUFSIZE = 1024;\n\n    private static final int BUFSIZE = 1024;\n\n    private static final int DEFAULT_MARK_LIMIT = 16 * BUFSIZE;\n\n    private int markLimit = DEFAULT_MARK_LIMIT;\n"}
{"magic_number_smell": "\n    private class AllowEmptiesAndDuplicatesCustomXMLTestParser extends DefaultCustomXMLTestParser {\n\n        private static final long 2458579047014545931L = 3735646809954466229L;\n\n        protected ElementMetadataHandler getCustomElementHandler(Metadata metadata,\n                                                                 Property tikaProperty,", "refactored_code": "        private static final long serialVersionUID = 2458579047014545931L;\n\n    private class AllowEmptiesAndDuplicatesCustomXMLTestParser extends DefaultCustomXMLTestParser {\n\n        private static final long serialVersionUID = 3735646809954466229L;\n\n        protected ElementMetadataHandler getCustomElementHandler(Metadata metadata,\n                                                                 Property tikaProperty,"}
{"magic_number_smell": "                    //can't rely on zae.getSize to determine if there is any\n                    //content here. :(\n                    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n                    BoundedInputStream bis = new BoundedInputStream(1024,\n                    zipArchiveInputStream);\n                    IOUtils.copy(bis, bos);\n                    //do anything with an inputstream > 1024?", "refactored_code": "    private static final int MAX_MIME_TYPE = 1024;\n                    //can't rely on zae.getSize to determine if there is any\n                    //content here. :(\n                    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n                    BoundedInputStream bis = new BoundedInputStream(MAX_MIME_TYPE,\n                    zipArchiveInputStream);\n                    IOUtils.copy(bis, bos);\n                    //do anything with an inputstream > MAX_MIME_TYPE?"}
{"magic_number_smell": "            //can't rely on zae.getSize to determine if there is any\n            //content here. :(\n            UnsynchronizedByteArrayOutputStream bos = new UnsynchronizedByteArrayOutputStream();\n            BoundedInputStream bis = new BoundedInputStream(1024, zis);\n            IOUtils.copy(bis, bos);\n            //do anything with an inputstream > 1024?\n            if (bos.size() > 0) {", "refactored_code": "    private static final int MAX_MIME_TYPE = 1024;\n            //can't rely on zae.getSize to determine if there is any\n            //content here. :(\n            UnsynchronizedByteArrayOutputStream bos = new UnsynchronizedByteArrayOutputStream();\n            BoundedInputStream bis = new BoundedInputStream(MAX_MIME_TYPE, zis);\n            IOUtils.copy(bis, bos);\n            //do anything with an inputstream > MAX_MIME_TYPE?\n            if (bos.size() > 0) {"}
{"magic_number_smell": "        //without exception or warning.  So, copy the full stream, then\n        //process.  TIKA-3061\n        UnsynchronizedByteArrayOutputStream bos = new UnsynchronizedByteArrayOutputStream();\n        BoundedInputStream bis = new BoundedInputStream(20 * 1024 * 1024, zis);\n        IOUtils.copy(bis, bos);\n\n        return detectStarOfficeX(bos.toInputStream());", "refactored_code": "    private static final int MAX_MANIFEST = 20 * 1024 * 1024;\n        //without exception or warning.  So, copy the full stream, then\n        //process.  TIKA-3061\n        UnsynchronizedByteArrayOutputStream bos = new UnsynchronizedByteArrayOutputStream();\n        BoundedInputStream bis = new BoundedInputStream(MAX_MANIFEST, zis);\n        IOUtils.copy(bis, bos);\n\n        return detectStarOfficeX(bos.toInputStream());"}
{"magic_number_smell": "     * to the Fork Client once it has occured\n     */\n    static class WontBeSerializedError extends RuntimeException {\n        private static final long -6197267350768803348L = 1L;\n\n        WontBeSerializedError(String message) {\n            super(message);", "refactored_code": "        private static final long serialVersionUID = -6197267350768803348L;\n     * to the Fork Client once it has occured\n     */\n    static class WontBeSerializedError extends RuntimeException {\n        private static final long serialVersionUID = 1L;\n\n        WontBeSerializedError(String message) {\n            super(message);"}
{"magic_number_smell": "        try (AsyncProcessor processor = new AsyncProcessor(tikaConfigPath, pipesIterator)) {\n\n            for (FetchEmitTuple t : pipesIterator) {\n                boolean offered = processor.offer(t, 600_000);\n                if (! offered) {\n                    throw new TimeoutException(\"timed out waiting to add a fetch emit tuple\");\n                }", "refactored_code": "    private static final long TIMEOUT_MS = 600_000;\n        try (AsyncProcessor processor = new AsyncProcessor(tikaConfigPath, pipesIterator)) {\n\n            for (FetchEmitTuple t : pipesIterator) {\n                boolean offered = processor.offer(t, TIMEOUT_MS);\n                if (! offered) {\n                    throw new TimeoutException(\"timed out waiting to add a fetch emit tuple\");\n                }"}
{"magic_number_smell": "                \"fetchKey varchar(128))\";\n        CONNECTION.createStatement().execute(sql);\n\n        for (int i = 0; i < 1000; i++) {\n            sql = \"insert into \" + TABLE + \" (id, project, fetchKey) values ('id\" + i +\n                    \"','project\" + (i % 2 == 0 ? \"a\" : \"b\") + \"','fk\" + i + \"')\";\n            CONNECTION.createStatement().execute(sql);", "refactored_code": "    private static final int NUM_ROWS = 1000;\n                \"fetchKey varchar(128))\";\n        CONNECTION.createStatement().execute(sql);\n\n        for (int i = 0; i < NUM_ROWS; i++) {\n            sql = \"insert into \" + TABLE + \" (id, project, fetchKey) values ('id\" + i +\n                    \"','project\" + (i % 2 == 0 ? \"a\" : \"b\") + \"','fk\" + i + \"')\";\n            CONNECTION.createStatement().execute(sql);"}
{"magic_number_smell": "\n    private long reportWithinMs = DEFAULT_REPORT_WITHIN_MS;\n\n    private int cacheSize = 100;\n\n    private String connectionString;\n", "refactored_code": "    private static final int DEFAULT_CACHE_SIZE = 100;\n\n    private long reportWithinMs = DEFAULT_REPORT_WITHIN_MS;\n\n    private int cacheSize = DEFAULT_CACHE_SIZE;\n\n    private String connectionString;\n"}
{"magic_number_smell": "\n        final PipesIterator pipesIterator = PipesIterator.build(tikaConfigPath);\n\n        final ArrayBlockingQueue<FetchEmitTuple> queue = new ArrayBlockingQueue<>(10000);\n\n        completionService.submit(new CallablePipesIterator(pipesIterator, queue));\n", "refactored_code": "    private static final int QUEUE_SIZE = 10000;\n\n        final PipesIterator pipesIterator = PipesIterator.build(tikaConfigPath);\n\n        final ArrayBlockingQueue<FetchEmitTuple> queue = new ArrayBlockingQueue<>(QUEUE_SIZE);\n\n        completionService.submit(new CallablePipesIterator(pipesIterator, queue));\n"}
{"magic_number_smell": "        int tries = 0;\n        long start = System.currentTimeMillis();\n        try {\n            while (tries++ < 3) {\n                HttpResponse response = null;\n                try {\n                    response = httpClient.execute(post);", "refactored_code": "    private final int maxRetries = 3;\n        int tries = 0;\n        long start = System.currentTimeMillis();\n        try {\n            while (tries++ < maxRetries) {\n                HttpResponse response = null;\n                try {\n                    response = httpClient.execute(post);"}
{"magic_number_smell": "    private Set<String> supportedEmitters = new HashSet<>();\n    private List<String> forkedJvmArgs = new ArrayList<>();\n    private String idBase = UUID.randomUUID().toString();\n    private String port = Integer.toString(9998);\n    private String host = DEFAULT_HOST;\n    private int digestMarkLimit = DEFAULT_DIGEST_MARK_LIMIT;\n    private String digest = \"\";", "refactored_code": "    public static final int DEFAULT_PORT = 9998;\n    private Set<String> supportedEmitters = new HashSet<>();\n    private List<String> forkedJvmArgs = new ArrayList<>();\n    private String idBase = UUID.randomUUID().toString();\n    private String port = Integer.toString(DEFAULT_PORT);\n    private String host = DEFAULT_HOST;\n    private int digestMarkLimit = DEFAULT_DIGEST_MARK_LIMIT;\n    private String digest = \"\";"}
{"magic_number_smell": "        } catch (ServiceConstructionException e) {\n            LOG.warn(\"exception starting server\", e);\n            if (isBindException(e)) {\n                System.exit(42);\n            }\n            System.exit(DO_NOT_RESTART_EXIT_VALUE);\n        }", "refactored_code": "    public static final int BIND_EXCEPTION = 42;\n        } catch (ServiceConstructionException e) {\n            LOG.warn(\"exception starting server\", e);\n            if (isBindException(e)) {\n                System.exit(BIND_EXCEPTION);\n            }\n            System.exit(DO_NOT_RESTART_EXIT_VALUE);\n        }"}
{"magic_number_smell": "                                        @Context UriInfo info, boolean saveAll) throws Exception {\n        Metadata metadata = new Metadata();\n        ParseContext pc = new ParseContext();\n        long unpackMaxBytes = 100 * 1024 * 1024;\n        String unpackMaxBytesString =\n                httpHeaders.getRequestHeaders().getFirst(UNPACK_MAX_BYTES_KEY);\n        if (!StringUtils.isBlank(unpackMaxBytesString)) {", "refactored_code": "    private static final long DEFAULT_MAX_ATTACHMENT_BYTES = 100 * 1024 * 1024;\n                                        @Context UriInfo info, boolean saveAll) throws Exception {\n        Metadata metadata = new Metadata();\n        ParseContext pc = new ParseContext();\n        long unpackMaxBytes = DEFAULT_MAX_ATTACHMENT_BYTES;\n        String unpackMaxBytesString =\n                httpHeaders.getRequestHeaders().getFirst(UNPACK_MAX_BYTES_KEY);\n        if (!StringUtils.isBlank(unpackMaxBytesString)) {"}
{"magic_number_smell": "                            \"attachment; filename=\" + TEST_PASSWORD_PROTECTED)\n                    .put(ClassLoader.getSystemResourceAsStream(TEST_PASSWORD_PROTECTED));\n            assertNotNull(response, \"null response: \" + path);\n            assertEquals(422, response.getStatus(), \"unprocessable: \" + path);\n            String msg = getStringFromInputStream((InputStream) response.getEntity());\n            assertEquals(\"\", msg, \"should be empty: \" + path);\n        }", "refactored_code": "    private static final int UNPROCESSEABLE = 422;\n                            \"attachment; filename=\" + TEST_PASSWORD_PROTECTED)\n                    .put(ClassLoader.getSystemResourceAsStream(TEST_PASSWORD_PROTECTED));\n            assertNotNull(response, \"null response: \" + path);\n            assertEquals(UNPROCESSEABLE, response.getStatus(), \"unprocessable: \" + path);\n            String msg = getStringFromInputStream((InputStream) response.getEntity());\n            assertEquals(\"\", msg, \"should be empty: \" + path);\n        }"}
{"magic_number_smell": "                            \"attachment; filename=\" + TEST_PASSWORD_PROTECTED)\n                    .put(ClassLoader.getSystemResourceAsStream(TEST_PASSWORD_PROTECTED));\n            assertNotNull(response, \"null response: \" + path);\n            assertEquals(422, response.getStatus(), \"unprocessable: \" + path);\n            String msg = getStringFromInputStream((InputStream) response.getEntity());\n            assertContains(\"org.apache.tika.exception.EncryptedDocumentException\", msg);\n        }", "refactored_code": "    private static final int UNPROCESSEABLE = 422;\n                            \"attachment; filename=\" + TEST_PASSWORD_PROTECTED)\n                    .put(ClassLoader.getSystemResourceAsStream(TEST_PASSWORD_PROTECTED));\n            assertNotNull(response, \"null response: \" + path);\n            assertEquals(UNPROCESSEABLE, response.getStatus(), \"unprocessable: \" + path);\n            String msg = getStringFromInputStream((InputStream) response.getEntity());\n            assertContains(\"org.apache.tika.exception.EncryptedDocumentException\", msg);\n        }"}
{"magic_number_smell": "        Response response = WebClient.create(endPoint + TIKA_PATH).accept(\n                \"application/json\")\n                .put(ClassLoader.getSystemResourceAsStream(TEST_NULL_POINTER));\n        assertEquals(422, response.getStatus());\n        String content = getStringFromInputStream((InputStream) response.getEntity());\n        assertEquals(0, content.length());\n    }", "refactored_code": "    private static final int UNPROCESSEABLE = 422;\n        Response response = WebClient.create(endPoint + TIKA_PATH).accept(\n                \"application/json\")\n                .put(ClassLoader.getSystemResourceAsStream(TEST_NULL_POINTER));\n        assertEquals(UNPROCESSEABLE, response.getStatus());\n        String content = getStringFromInputStream((InputStream) response.getEntity());\n        assertEquals(0, content.length());\n    }"}
{"magic_number_smell": "        Files.createDirectories(inputDir);\n        Files.createDirectories(TMP_OUTPUT_DIR);\n        Random rand = new Random();\n        for (int i = 0; i < 100; i++) {\n            for (String mockFile : FILES) {\n                if (mockFile.equals(\"system_exit.xml\")) {\n                    if (rand.nextFloat() > 0.1) {", "refactored_code": "    private static final int NUM_FILES = 100;\n        Files.createDirectories(inputDir);\n        Files.createDirectories(TMP_OUTPUT_DIR);\n        Random rand = new Random();\n        for (int i = 0; i < NUM_FILES; i++) {\n            for (String mockFile : FILES) {\n                if (mockFile.equals(\"system_exit.xml\")) {\n                    if (rand.nextFloat() > 0.1) {"}
{"magic_number_smell": "        String textA = node.get(TEXT_A).asText();\n        String textB = node.get(TEXT_B).asText();\n        long timeoutMillis = node.has(\"timeoutMillis\") ? node.get(\"timeoutMillis\").asLong() :\n                60000;\n        return compareText(id, textA, textB, timeoutMillis);\n    }\n", "refactored_code": "    public static final long DEFAULT_TIMEOUT_MILLIS = 60000;\n        String textA = node.get(TEXT_A).asText();\n        String textB = node.get(TEXT_B).asText();\n        long timeoutMillis = node.has(\"timeoutMillis\") ? node.get(\"timeoutMillis\").asLong() :\n                DEFAULT_TIMEOUT_MILLIS;\n        return compareText(id, textA, textB, timeoutMillis);\n    }\n"}
{"magic_number_smell": "                .accept(\"text/plain\")\n                .put(ClassLoader.getSystemResourceAsStream(\"test-documents/password.xls\"));\n\n        assertEquals(422, response.getStatus());\n    }\n\n    @Test", "refactored_code": "    private static final int UNPROCESSEABLE = 422;\n                .accept(\"text/plain\")\n                .put(ClassLoader.getSystemResourceAsStream(\"test-documents/password.xls\"));\n\n        assertEquals(UNPROCESSEABLE, response.getStatus());\n    }\n\n    @Test"}
{"magic_number_smell": "        LRUMap<String, String> translationCache =\n                cache.get(buildCacheKeyString(sourceLanguage, targetLanguage));\n        if (translationCache == null) {\n            translationCache = new LRUMap<>(100, MAX_ENTRIES);\n            cache.put(buildCacheKeyString(sourceLanguage, targetLanguage), translationCache);\n        }\n        return translationCache;", "refactored_code": "    private static final int INITIAL_ENTRIES = 100;\n        LRUMap<String, String> translationCache =\n                cache.get(buildCacheKeyString(sourceLanguage, targetLanguage));\n        if (translationCache == null) {\n            translationCache = new LRUMap<>(INITIAL_ENTRIES, MAX_ENTRIES);\n            cache.put(buildCacheKeyString(sourceLanguage, targetLanguage), translationCache);\n        }\n        return translationCache;"}
{"magic_number_smell": "    }\n\n    public boolean isBold() {\n        return getWeight() > 400;\n    }\n\n    public byte getCharsetByte() {", "refactored_code": "    public static final int REGULAR_WEIGHT = 400;\n    }\n\n    public boolean isBold() {\n        return getWeight() > REGULAR_WEIGHT;\n    }\n\n    public byte getCharsetByte() {"}
{"magic_number_smell": "\n    // arbitrarily selected; may need to increase\n    private static final int 100_000 = 100_000;\n    private static int MAX_RECORD_LENGTH = 100_000;\n\n    /**\n     * The size of the header that goes at the start of the array, before the data", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000;\n\n    // arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    /**\n     * The size of the header that goes at the start of the array, before the data"}
{"magic_number_smell": "\n    //arbitrarily selected; may need to increase\n    private static final int 104_857_600 = 104_857_600;\n    private static int MAX_RECORD_LENGTH = 104_857_600;\n\n    public static final short  RECORD_ID_START    = EscherRecordTypes.BLIP_START.typeID;\n    public static final short  RECORD_ID_END      = EscherRecordTypes.BLIP_END.typeID;", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 104_857_600;\n\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 104_857_600;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    public static final short  RECORD_ID_START    = EscherRecordTypes.BLIP_START.typeID;\n    public static final short  RECORD_ID_END      = EscherRecordTypes.BLIP_END.typeID;"}
{"magic_number_smell": "\n    //arbitrarily selected; may need to increase\n    private static final int 100_000 = 100_000;\n    private static int MAX_RECORD_LENGTH = 100_000;\n\n    public static final short RECORD_ID = EscherRecordTypes.BSE.typeID;\n", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000;\n\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    public static final short RECORD_ID = EscherRecordTypes.BSE.typeID;\n"}
{"magic_number_smell": "\n    @Override\n    public short getRecordId() {\n        return EscherRecordTypes.CHILD_ANCHOR.typeID;\n    }\n\n    @Override", "refactored_code": "    public static final short RECORD_ID = EscherRecordTypes.CHILD_ANCHOR.typeID;\n\n    @Override\n    public short getRecordId() {\n        return RECORD_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "public class EscherClientAnchorRecord extends EscherRecord {\n    //arbitrarily selected; may need to increase\n    private static final int 100_000 = 100_000;\n    private static int MAX_RECORD_LENGTH = 100_000;\n\n    public static final short RECORD_ID = EscherRecordTypes.CLIENT_ANCHOR.typeID;\n", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000;\npublic class EscherClientAnchorRecord extends EscherRecord {\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    public static final short RECORD_ID = EscherRecordTypes.CLIENT_ANCHOR.typeID;\n"}
{"magic_number_smell": "\n    @Override\n    public short getRecordId() {\n        return EscherRecordTypes.CLIENT_DATA.typeID;\n    }\n\n    @Override", "refactored_code": "    public static final short RECORD_ID = EscherRecordTypes.CLIENT_DATA.typeID;\n\n    @Override\n    public short getRecordId() {\n        return RECORD_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "public class EscherComplexProperty extends EscherProperty {\n    //arbitrarily selected; may need to increase\n    private static final int 100_000_000 = 100_000_000;\n    private static int MAX_RECORD_LENGTH = 100_000_000;\n\n    private byte[] complexData;\n", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000_000;\npublic class EscherComplexProperty extends EscherProperty {\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    private byte[] complexData;\n"}
{"magic_number_smell": "\n    @Override\n    public short getRecordId() {\n        return EscherRecordTypes.DGG.typeID;\n    }\n\n    @Override", "refactored_code": "    public static final short RECORD_ID = EscherRecordTypes.DGG.typeID;\n\n    @Override\n    public short getRecordId() {\n        return RECORD_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public short getRecordId() {\n        return EscherRecordTypes.DG.typeID;\n    }\n\n    @Override", "refactored_code": "    public static final short RECORD_ID = EscherRecordTypes.DG.typeID;\n\n    @Override\n    public short getRecordId() {\n        return RECORD_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "    private static final Logger LOGGER = LogManager.getLogger(EscherMetafileBlip.class);\n    //arbitrarily selected; may need to increase\n    private static final int 100_000_000 = 100_000_000;\n    private static int MAX_RECORD_LENGTH = 100_000_000;\n\n    /** @deprecated use EscherRecordTypes.BLIP_EMF.typeID */\n    @Deprecated", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000_000;\n    private static final Logger LOGGER = LogManager.getLogger(EscherMetafileBlip.class);\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    /** @deprecated use EscherRecordTypes.BLIP_EMF.typeID */\n    @Deprecated"}
{"magic_number_smell": "\n    @Override\n    public short getRecordId() {\n        return EscherRecordTypes.SPGR.typeID;\n    }\n\n    @Override", "refactored_code": "    public static final short RECORD_ID = EscherRecordTypes.SPGR.typeID;\n\n    @Override\n    public short getRecordId() {\n        return RECORD_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public short getRecordId() {\n        return EscherRecordTypes.SPLIT_MENU_COLORS.typeID;\n    }\n\n    @Override", "refactored_code": "    public static final short RECORD_ID = EscherRecordTypes.SPLIT_MENU_COLORS.typeID;\n\n    @Override\n    public short getRecordId() {\n        return RECORD_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public short getRecordId() {\n        return EscherRecordTypes.SP.typeID;\n    }\n\n    @Override", "refactored_code": "    public static final short RECORD_ID = EscherRecordTypes.SP.typeID;\n\n    @Override\n    public short getRecordId() {\n        return RECORD_ID;\n    }\n\n    @Override"}
{"magic_number_smell": "public final class UnknownEscherRecord extends EscherRecord {\n    //arbitrarily selected; may need to increase\n    private static final int 100_000_000 = 100_000_000;\n    private static int MAX_RECORD_LENGTH = 100_000_000;\n\n    private static final byte[] NO_BYTES = new byte[0];\n", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000_000;\npublic final class UnknownEscherRecord extends EscherRecord {\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    private static final byte[] NO_BYTES = new byte[0];\n"}
{"magic_number_smell": "@Internal\npublic class Array {\n    private static final int 100_000 = 100_000;\n    private static int MAX_NUMBER_OF_ARRAY_SCALARS = 100_000;\n\n    public static int getMaxNumberOfArrayScalars() {\n        return MAX_NUMBER_OF_ARRAY_SCALARS;", "refactored_code": "    private static final int DEFAULT_MAX_NUMBER_OF_ARRAY_SCALARS = 100_000;\n@Internal\npublic class Array {\n    private static final int DEFAULT_MAX_NUMBER_OF_ARRAY_SCALARS = 100_000;\n    private static int MAX_NUMBER_OF_ARRAY_SCALARS = DEFAULT_MAX_NUMBER_OF_ARRAY_SCALARS;\n\n    public static int getMaxNumberOfArrayScalars() {\n        return MAX_NUMBER_OF_ARRAY_SCALARS;"}
{"magic_number_smell": "\n    //arbitrarily selected; may need to increase\n    private static final int 10_000_000 = 10_000_000;\n    private static int MAX_RECORD_LENGTH = 10_000_000;\n\n    private byte[] _value;\n", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 10_000_000;\n\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 10_000_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    private byte[] _value;\n"}
{"magic_number_smell": "    /**\n     * The bytes making out the class ID in correct order, i.e. big-endian.\n     */\n    private final byte[] bytes = new byte[16];\n\n    /**\n     * Creates a ClassID and reads its value from a byte array.", "refactored_code": "    public static final int LENGTH = 16;\n    /**\n     * The bytes making out the class ID in correct order, i.e. big-endian.\n     */\n    private final byte[] bytes = new byte[LENGTH];\n\n    /**\n     * Creates a ClassID and reads its value from a byte array."}
{"magic_number_smell": "public class ClipboardData {\n    //arbitrarily selected; may need to increase\n    private static final int 100_000_000 = 100_000_000;\n    private static int MAX_RECORD_LENGTH = 100_000_000;\n\n    private static final Logger LOG = LogManager.getLogger(ClipboardData.class);\n", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000_000;\npublic class ClipboardData {\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    private static final Logger LOG = LogManager.getLogger(ClipboardData.class);\n"}
{"magic_number_smell": "public class CodePageString {\n    //arbitrarily selected; may need to increase\n    private static final int 100_000 = 100_000;\n    private static int MAX_RECORD_LENGTH = 100_000;\n\n    private static final Logger LOG = LogManager.getLogger(CodePageString.class);\n", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000;\npublic class CodePageString {\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    private static final Logger LOG = LogManager.getLogger(CodePageString.class);\n"}
{"magic_number_smell": "public class Currency {\n    private static final int 8 = 8;\n\n    private final byte[] _value = new byte[8];\n\n    public void read( LittleEndianByteArrayInputStream lei ) {\n        lei.readFully(_value);", "refactored_code": "    private static final int SIZE = 8;\npublic class Currency {\n    private static final int SIZE = 8;\n\n    private final byte[] _value = new byte[SIZE];\n\n    public void read( LittleEndianByteArrayInputStream lei ) {\n        lei.readFully(_value);"}
{"magic_number_smell": "public class Date {\n    private static final int 8 = 8;\n\n    private final byte[] _value = new byte[8];\n\n    public void read( LittleEndianByteArrayInputStream lei ) {\n        lei.readFully(_value);", "refactored_code": "    private static final int SIZE = 8;\npublic class Date {\n    private static final int SIZE = 8;\n\n    private final byte[] _value = new byte[SIZE];\n\n    public void read( LittleEndianByteArrayInputStream lei ) {\n        lei.readFully(_value);"}
{"magic_number_smell": "\n    @Override\n    public String toString() {\n        return toString(Property.CodePageUtil.CP_WINDOWS_1252, null);\n    }\n\n    public String toString(int codepage, PropertyIDMap idMap) {", "refactored_code": "    public static final int DEFAULT_CODEPAGE = CodePageUtil.CP_WINDOWS_1252;\n\n    @Override\n    public String toString() {\n        return toString(Property.DEFAULT_CODEPAGE, null);\n    }\n\n    public String toString(int codepage, PropertyIDMap idMap) {"}
{"magic_number_smell": "    public long getClipboardFormatTag()\n    {\n        return (long) LittleEndian.getInt(getThumbnail(),\n                                                       4);\n    }\n\n", "refactored_code": "    public static final int OFFSET_CFTAG = 4;\n    public long getClipboardFormatTag()\n    {\n        return (long) LittleEndian.getInt(getThumbnail(),\n                                                       OFFSET_CFTAG);\n    }\n\n"}
{"magic_number_smell": "    public static final Integer LENGTH_8 = 8;\n\n    private static final Object[][] NUMBER_TO_NAME_LIST = {\n            {0L, \"0\", LENGTH_0},\n            {1L, \"VT_NULL\", LENGTH_UNKNOWN},\n            {2L, \"VT_I2\", LENGTH_2},\n            {3L, \"VT_I4\", LENGTH_4},", "refactored_code": "    public static final int VT_EMPTY = 0;\n    public static final Integer LENGTH_8 = 8;\n\n    private static final Object[][] NUMBER_TO_NAME_LIST = {\n            {0L, \"VT_EMPTY\", LENGTH_0},\n            {1L, \"VT_NULL\", LENGTH_UNKNOWN},\n            {2L, \"VT_I2\", LENGTH_2},\n            {3L, \"VT_I4\", LENGTH_4},"}
{"magic_number_smell": "     */\n    private static PropertyIDMap summaryInformationProperties;\n    private static final Object[][] summaryInformationIdValues = {\n        { (long)2, \"2\" },\n        { (long)PID_SUBJECT, \"PID_SUBJECT\" },\n        { (long)PID_AUTHOR, \"PID_AUTHOR\" },\n        { (long)PID_KEYWORDS, \"PID_KEYWORDS\" },", "refactored_code": "    public static final int PID_TITLE = 2;\n     */\n    private static PropertyIDMap summaryInformationProperties;\n    private static final Object[][] summaryInformationIdValues = {\n        { (long)PID_TITLE, \"PID_TITLE\" },\n        { (long)PID_SUBJECT, \"PID_SUBJECT\" },\n        { (long)PID_AUTHOR, \"PID_AUTHOR\" },\n        { (long)PID_KEYWORDS, \"PID_KEYWORDS\" },"}
{"magic_number_smell": "            ris.nextRecord();\n\n            switch (sid) {\n                case  0x2f:\n                    throw new EncryptedDocumentException(\"Encryption not supported for Old Excel files\");\n\n                case OldSheetRecord.sid:", "refactored_code": "    private static final int FILE_PASS_RECORD_SID = 0x2f;\n            ris.nextRecord();\n\n            switch (sid) {\n                case  FILE_PASS_RECORD_SID:\n                    throw new EncryptedDocumentException(\"Encryption not supported for Old Excel files\");\n\n                case OldSheetRecord.sid:"}
{"magic_number_smell": "     */\n    public boolean doesContainsSheetName(String name, int excludeSheetIdx) {\n        String aName = name;\n        if (aName.length() > 31) {\n            aName = aName.substring(0, 31);\n        }\n        int i=0;", "refactored_code": "    private static final int MAX_SENSITIVE_SHEET_NAME_LEN = 31;\n     */\n    public boolean doesContainsSheetName(String name, int excludeSheetIdx) {\n        String aName = name;\n        if (aName.length() > MAX_SENSITIVE_SHEET_NAME_LEN) {\n            aName = aName.substring(0, MAX_SENSITIVE_SHEET_NAME_LEN);\n        }\n        int i=0;"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x0221;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x0221;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x9D;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x9D;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x40;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x40;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "     */\n    public short getSid()\n    {\n        return 0x0201;\n    }\n\n    public void serialize(LittleEndianOutput out) {", "refactored_code": "    public static final short sid = 0x0201;\n     */\n    public short getSid()\n    {\n        return sid;\n    }\n\n    public void serialize(LittleEndianOutput out) {"}
{"magic_number_smell": "    }\n\n    public short getSid(){\n        return 0x809;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x809;\n    }\n\n    public short getSid(){\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0xDA;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0xDA;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x0205;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x0205;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x29;\n    }\n\n    /**", "refactored_code": "    public static final short sid = 0x29;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    /**"}
{"magic_number_smell": "    }\n\n    /**\n     * UTF8: 0x0085 + len + bof + flags + len(str) + unicode + str 2 + 2 + 4 + 2 +\n     * 1 + 1 + len(str)\n     *\n     * UNICODE: 0x0085 + len + bof + flags + len(str) + unicode + str 2 + 2 + 4 + 2 +", "refactored_code": "    public static final short sid = 0x0085;\n    }\n\n    /**\n     * UTF8: sid + len + bof + flags + len(str) + unicode + str 2 + 2 + 4 + 2 +\n     * 1 + 1 + len(str)\n     *\n     * UNICODE: sid + len + bof + flags + len(str) + unicode + str 2 + 2 + 4 + 2 +"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0xC;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0xC;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0xD;\n    }\n\n    @Override", "refactored_code": "    public static final short sid                     = 0xD;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    public CFHeader12Record() {\n        createEmpty();\n        futureHeader = new FtrHeader();\n        futureHeader.setRecordType(0x0879);\n    }\n\n    public CFHeader12Record(CFHeader12Record other) {", "refactored_code": "    public static final short sid = 0x0879;\n    public CFHeader12Record() {\n        createEmpty();\n        futureHeader = new FtrHeader();\n        futureHeader.setRecordType(sid);\n    }\n\n    public CFHeader12Record(CFHeader12Record other) {"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x01B0;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x01B0;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    private void setDefaults() {\n        futureHeader = new FtrHeader();\n        futureHeader.setRecordType(0x087A);\n\n        ext_formatting_length = 0;\n        ext_formatting_data = new byte[4];", "refactored_code": "    public static final short sid = 0x087A;\n\n    private void setDefaults() {\n        futureHeader = new FtrHeader();\n        futureHeader.setRecordType(sid);\n\n        ext_formatting_length = 0;\n        ext_formatting_data = new byte[4];"}
{"magic_number_smell": "    }\n    protected void setConditionType(byte condition_type) {\n        if ((this instanceof CFRuleRecord)) {\n            if (!(condition_type == 1 ||\n                condition_type == CONDITION_TYPE_FORMULA)) {\n                throw new IllegalArgumentException(\"CFRuleRecord only accepts Value-Is and Formula types\");\n            }", "refactored_code": "    public static final byte CONDITION_TYPE_CELL_VALUE_IS = 1;\n    }\n    protected void setConditionType(byte condition_type) {\n        if ((this instanceof CFRuleRecord)) {\n            if (!(condition_type == CONDITION_TYPE_CELL_VALUE_IS ||\n                condition_type == CONDITION_TYPE_FORMULA)) {\n                throw new IllegalArgumentException(\"CFRuleRecord only accepts Value-Is and Formula types\");\n            }"}
{"magic_number_smell": "\n    @Override\n    public short getSid() {\n        return 0x01B1;\n    }\n\n    /**", "refactored_code": "    public static final short sid = 0x01B1;\n\n    @Override\n    public short getSid() {\n        return sid;\n    }\n\n    /**"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x42;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x42;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x007D;\n    }\n\n    public void serialize(LittleEndianOutput out) {", "refactored_code": "    public static final short sid = 0x007D;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    public void serialize(LittleEndianOutput out) {"}
{"magic_number_smell": "    @Override\n    public void serialize(LittleEndianOutput out) {\n\n        out.writeShort(0x0015);\n        out.writeShort(getDataSize());\n\n        out.writeShort(field_1_objectType);", "refactored_code": "    public static final short sid = 0x0015;\n    @Override\n    public void serialize(LittleEndianOutput out) {\n\n        out.writeShort(sid);\n        out.writeShort(getDataSize());\n\n        out.writeShort(field_1_objectType);"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x003C;\n    }\n\n    public ContinueRecord(RecordInputStream in) {", "refactored_code": "    public static final short sid = 0x003C;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    public ContinueRecord(RecordInputStream in) {"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x8c;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x8c;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "     * return the non static version of the id for this record.\n     */\n    public short getSid() {\n        return 0x59;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x59;\n     * return the non static version of the id for this record.\n     */\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "     * return the non static version of the id for this record.\n     */\n    public short getSid() {\n        return 0x005A;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x005A;\n     * return the non static version of the id for this record.\n     */\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x22;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x22;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x00D7;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x00D7;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "     * @param inStream RecordInputStream containing a DConRefRecord structure.\n     */\n    public DConRefRecord(RecordInputStream inStream) {\n        if (inStream.getSid() != 0x0051) {\n            throw new RecordFormatException(\"Wrong 0x0051: \" + inStream.getSid());\n        }\n", "refactored_code": "    public static final short sid = 0x0051;\n     * @param inStream RecordInputStream containing a DConRefRecord structure.\n     */\n    public DConRefRecord(RecordInputStream inStream) {\n        if (inStream.getSid() != sid) {\n            throw new RecordFormatException(\"Wrong sid: \" + inStream.getSid());\n        }\n"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x0055;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x0055;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x225;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x225;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x0010;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x0010;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x200;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x200;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0xEB;\n    }\n\n    public int serialize(int offset, byte[] data)", "refactored_code": "    public static final short sid = 0xEB;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    public int serialize(int offset, byte[] data)"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x00EC;\n    }\n\n    public byte[] getRecordData(){", "refactored_code": "    public static final short sid = 0x00EC;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    public byte[] getRecordData(){"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0xEC;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0xEC;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x00ED;\n    }\n\n    protected int getDataSize() {", "refactored_code": "    public static final short sid = 0x00ED;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    protected int getDataSize() {"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x0161;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x0161;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x01B2;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x01B2;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x01BE;\n    }\n\n    /** Clones the object. */", "refactored_code": "    public static final short sid = 0x01BE;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    /** Clones the object. */"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x0009;\n    }\n\n    private static Ptg readRefPtg(byte[] formulaRawBytes) {", "refactored_code": "    public static final short sid = 0x0009;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    private static Ptg readRefPtg(byte[] formulaRawBytes) {"}
{"magic_number_smell": "    }\n\n    public void serialize(LittleEndianOutput out) {\n        out.writeShort(0x0000);\n        out.writeShort(ENCODED_SIZE);\n    }\n", "refactored_code": "    public static final short sid = 0x0000;\n    }\n\n    public void serialize(LittleEndianOutput out) {\n        out.writeShort(sid);\n        out.writeShort(ENCODED_SIZE);\n    }\n"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x0A;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x0A;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    /**\n     * @return Returns the current 9876.\n     */\n    @Override\n    public short getSid() {", "refactored_code": "    public static final short sid = 9876;\n    }\n\n    /**\n     * @return Returns the current sid.\n     */\n    @Override\n    public short getSid() {"}
{"magic_number_smell": "    @Override\n    public short getSid()\n    {\n        return 0xE0;\n    }\n\n    /**", "refactored_code": "    public static final short sid                 = 0xE0;\n    @Override\n    public short getSid()\n    {\n        return sid;\n    }\n\n    /**"}
{"magic_number_smell": "\n    @Override\n    public short getSid() {\n        return 0x0023;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x0023; // as per BIFF8. (some old versions used 0x223)\n\n    @Override\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "     */\n    @Override\n    public short getSid() {\n        return 0x0017;\n    }\n\n    /**", "refactored_code": "    public static final short sid = 0x0017;\n     */\n    @Override\n    public short getSid() {\n        return sid;\n    }\n\n    /**"}
{"magic_number_smell": "            InfoSubRecord info = new InfoSubRecord(in);\n            lst.add(info);\n\n            if(in.available() == 0 && in.hasNextRecord() && in.getNextSid() == ContinueRecord.0x00FF) {\n                in.nextRecord();\n            }\n        }", "refactored_code": "    public static final short sid = 0x00FF;\n            InfoSubRecord info = new InfoSubRecord(in);\n            lst.add(info);\n\n            if(in.available() == 0 && in.hasNextRecord() && in.getNextSid() == ContinueRecord.sid) {\n                in.nextRecord();\n            }\n        }"}
{"magic_number_smell": "\n    public FeatRecord() {\n        futureHeader = new FtrHeader();\n        futureHeader.setRecordType(0x0868);\n    }\n\n    public FeatRecord(FeatRecord other) {", "refactored_code": "    public static final short sid = 0x0868;\n\n    public FeatRecord() {\n        futureHeader = new FtrHeader();\n        futureHeader.setRecordType(sid);\n    }\n\n    public FeatRecord(FeatRecord other) {"}
{"magic_number_smell": "\n    @Override\n    public short getSid() {\n        return 0x002F;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x002F;\n\n    @Override\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x005B;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x005B;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x9c;\n    }\n\n    @Override", "refactored_code": "    public static final short sid   = 0x9c;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x0031;\n    }\n\n    /**", "refactored_code": "    public static final short sid                = 0x0031;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    /**"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x0015;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x0015;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x041E;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x041E;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public short getSid() {\n        return 0x0006;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x0006;\n\n    @Override\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "     * is a normal (non NaN) double value.\n     */\n    public static FormulaSpecialCachedValue create(long valueLongBits) {\n        if ((0xFFFF000000000000L & valueLongBits) != 0xFFFF000000000000L) {\n            return null;\n        }\n", "refactored_code": "    private static final long BIT_MARKER = 0xFFFF000000000000L;\n     * is a normal (non NaN) double value.\n     */\n    public static FormulaSpecialCachedValue create(long valueLongBits) {\n        if ((BIT_MARKER & valueLongBits) != BIT_MARKER) {\n            return null;\n        }\n"}
{"magic_number_smell": "     * @param out the stream to serialize into\n     */\n    public void serialize(LittleEndianOutput out) {\n        out.writeShort(0x0C);\n        out.writeShort(reserved.length);\n        out.write(reserved);\n    }", "refactored_code": "    public static final short sid = 0x0C;\n     * @param out the stream to serialize into\n     */\n    public void serialize(LittleEndianOutput out) {\n        out.writeShort(sid);\n        out.writeShort(reserved.length);\n        out.write(reserved);\n    }"}
{"magic_number_smell": "     * @param out the stream to serialize into\n     */\n    public void serialize(LittleEndianOutput out) {\n        out.writeShort(0x07);\n        out.writeShort(length);\n        out.writeShort(flags);\n    }", "refactored_code": "    public static final short sid = 0x07;\n     * @param out the stream to serialize into\n     */\n    public void serialize(LittleEndianOutput out) {\n        out.writeShort(sid);\n        out.writeShort(length);\n        out.writeShort(flags);\n    }"}
{"magic_number_smell": "     * @param out the stream to serialize into\n     */\n    public void serialize(LittleEndianOutput out) {\n        out.writeShort(0x08);\n        out.writeShort(length);\n        out.writeShort(flags);\n    }", "refactored_code": "    public static final short sid = 0x08;\n     * @param out the stream to serialize into\n     */\n    public void serialize(LittleEndianOutput out) {\n        out.writeShort(sid);\n        out.writeShort(length);\n        out.writeShort(flags);\n    }"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x82;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x82;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public void serialize(LittleEndianOutput out) {\n        out.writeShort(0x0006);\n        out.writeShort(reserved.length);\n        out.write(reserved);\n    }", "refactored_code": "    public static final short sid = 0x0006;\n    }\n\n    public void serialize(LittleEndianOutput out) {\n        out.writeShort(sid);\n        out.writeShort(reserved.length);\n        out.write(reserved);\n    }"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x80;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x80;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x0083;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x0083;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x089C;\n    }\n\n    /**", "refactored_code": "    public static final short sid = 0x089C;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    /**"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x0014;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x0014;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x8d;\n    }\n\n    @Override", "refactored_code": "    public static final short sid               = 0x8d;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x001B;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x001B;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public short getSid() {\n        return HyperlinkRecord.0x01B8;\n    }\n\n", "refactored_code": "    public static final short sid = 0x01B8;\n\n    @Override\n    public short getSid() {\n        return HyperlinkRecord.sid;\n    }\n\n"}
{"magic_number_smell": "\n    @Override\n    public short getSid() {\n        return 0x020B;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x020B;\n\n    @Override\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x00E2;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x00E2;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x00E1;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x00E1;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x0011;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x0011;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    @Override\n    public short getSid()\n    {\n        return 0x0204;\n    }\n\n    /**", "refactored_code": "    public static final short sid = 0x0204;\n    @Override\n    public short getSid()\n    {\n        return sid;\n    }\n\n    /**"}
{"magic_number_smell": "\n    @Override\n    public short getSid() {\n        return 0xfd;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0xfd;\n\n    @Override\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "     *\n     * An unsigned integer that indirectly specifies whether\n     * some of the data in this structure appear in a subsequent Continue record.\n     * If _cbFContinued is 0x00, all of the fields in this structure except 0x0013 and _cbFContinued\n     *  MUST NOT exist. If this entire structure is contained within the same record,\n     * then _cbFContinued MUST be greater than or equal to the size, in bytes,\n     * of this structure, not including the four bytes for the ft and _cbFContinued fields", "refactored_code": "    public static final int sid = 0x0013;\n     *\n     * An unsigned integer that indirectly specifies whether\n     * some of the data in this structure appear in a subsequent Continue record.\n     * If _cbFContinued is 0x00, all of the fields in this structure except sid and _cbFContinued\n     *  MUST NOT exist. If this entire structure is contained within the same record,\n     * then _cbFContinued MUST be greater than or equal to the size, in bytes,\n     * of this structure, not including the four bytes for the ft and _cbFContinued fields"}
{"magic_number_smell": "    }\n\n    public short getSid()    {\n        return 0x0026;\n    }\n\n    /**", "refactored_code": "    public static final short sid = 0x0026;\n    }\n\n    public short getSid()    {\n        return sid;\n    }\n\n    /**"}
{"magic_number_smell": "\n    @Override\n    public short getSid() {\n        return 0x00E5;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x00E5;\n\n    @Override\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0xC1;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0xC1;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x00BE;\n    }\n\n    public void serialize(LittleEndianOutput out) {", "refactored_code": "    public static final short sid = 0x00BE;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    public void serialize(LittleEndianOutput out) {"}
{"magic_number_smell": "    @Override\n    public short getSid()\n    {\n        return 0x00BD;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x00BD;\n    @Override\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "     */\n    @Override\n    public short getSid() {\n        return 0x0894;\n    }\n\n    /**", "refactored_code": "    public static final short sid = 0x0894;\n     */\n    @Override\n    public short getSid() {\n        return sid;\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Override\n    public short getSid() {\n        return 0x0018;\n    }\n    /*\n      20 00", "refactored_code": "    public static final short sid = 0x0018;\n     */\n    @Override\n    public short getSid() {\n        return sid;\n    }\n    /*\n      20 00"}
{"magic_number_smell": "     * @return id of this record.\n     */\n    public short getSid() {\n        return 0x001C;\n    }\n\n    /**", "refactored_code": "    public static final short sid = 0x001C;\n     * @return id of this record.\n     */\n    public short getSid() {\n        return sid;\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    @Override\n    public void serialize(LittleEndianOutput out) {\n        out.writeShort(0x0D);\n        out.writeShort(reserved.length);\n        out.write(reserved);\n    }", "refactored_code": "    public static final short sid = 0x0D;\n     */\n    @Override\n    public void serialize(LittleEndianOutput out) {\n        out.writeShort(sid);\n        out.writeShort(reserved.length);\n        out.write(reserved);\n    }"}
{"magic_number_smell": "\n    @Override\n    public short getSid() {\n        return 0x0203;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x0203;\n\n    @Override\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x63;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x63;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "        // Check if this can be continued, if so then the\n        // following wont work properly\n        byte[] subRecordData = in.readRemainder();\n        if (LittleEndian.getUShort(subRecordData, 0) != CommonObjectDataSubRecord.0x005D) {\n            // seems to occur in just one junit on \"OddStyleRecord.xls\" (file created by CrystalReports)\n            // Excel tolerates the funny ObjRecord, and replaces it with a corrected version\n            // The exact logic/reasoning is not yet understood", "refactored_code": "    public static final short sid = 0x005D;\n        // Check if this can be continued, if so then the\n        // following wont work properly\n        byte[] subRecordData = in.readRemainder();\n        if (LittleEndian.getUShort(subRecordData, 0) != CommonObjectDataSubRecord.sid) {\n            // seems to occur in just one junit on \"OddStyleRecord.xls\" (file created by CrystalReports)\n            // Excel tolerates the funny ObjRecord, and replaces it with a corrected version\n            // The exact logic/reasoning is not yet understood"}
{"magic_number_smell": "    private Formula field_6_parsed_expr;\n\n    public OldFormulaRecord(RecordInputStream ris) {\n        super(ris, ris.getSid() == 0x0006);\n\n        if (isBiff2()) {\n            field_4_value = ris.readDouble();", "refactored_code": "    public static final short biff2_sid = 0x0006;\n    private Formula field_6_parsed_expr;\n\n    public OldFormulaRecord(RecordInputStream ris) {\n        super(ris, ris.getSid() == biff2_sid);\n\n        if (isBiff2()) {\n            field_4_value = ris.readDouble();"}
{"magic_number_smell": "     */\n    public OldLabelRecord(RecordInputStream in)\n    {\n        super(in, in.getSid() == 0x0004);\n\n        if (isBiff2()) {\n            field_4_string_len  = (short)in.readUByte();", "refactored_code": "    public static final short biff2_sid = 0x0004;\n     */\n    public OldLabelRecord(RecordInputStream in)\n    {\n        super(in, in.getSid() == biff2_sid);\n\n        if (isBiff2()) {\n            field_4_string_len  = (short)in.readUByte();"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x0085;\n    }\n\n    /**", "refactored_code": "    public static final short sid = 0x0085;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    /**"}
{"magic_number_smell": "    public OldStringRecord(RecordInputStream in) {\n        sid = in.getSid();\n\n        if (in.getSid() == 0x0007) {\n            field_1_string_len  = (short)in.readUByte();\n        } else {\n            field_1_string_len   = in.readShort();", "refactored_code": "    public static final short biff2_sid = 0x0007;\n    public OldStringRecord(RecordInputStream in) {\n        sid = in.getSid();\n\n        if (in.getSid() == biff2_sid) {\n            field_1_string_len  = (short)in.readUByte();\n        } else {\n            field_1_string_len   = in.readShort();"}
{"magic_number_smell": "        return _breaks.isEmpty();\n    }\n    protected int getDataSize() {\n        return 2 + _breaks.size() * Break.6;\n    }\n\n    public final void serialize(LittleEndianOutput out) {", "refactored_code": "        public static final int ENCODED_SIZE = 6;\n        return _breaks.isEmpty();\n    }\n    protected int getDataSize() {\n        return 2 + _breaks.size() * Break.ENCODED_SIZE;\n    }\n\n    public final void serialize(LittleEndianOutput out) {"}
{"magic_number_smell": "\n    @Override\n    public short getSid() {\n        return 0x0092;\n    }\n\n    /**", "refactored_code": "    public static final short sid = 0x0092;\n\n    @Override\n    public short getSid() {\n        return sid;\n    }\n\n    /**"}
{"magic_number_smell": "    @Override\n    public short getSid()\n    {\n        return 0x41;\n    }\n\n    @Override", "refactored_code": "    public static final short sid                     = 0x41;\n    @Override\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x0013;\n    }\n\n    /**", "refactored_code": "    public static final short sid = 0x0013;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    /**"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x01BC;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x01BC;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0xE;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0xE;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x2b;\n    }\n\n    public PrintGridlinesRecord copy() {", "refactored_code": "    public static final short sid = 0x2b;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    public PrintGridlinesRecord copy() {"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x2a;\n    }\n\n    public PrintHeadersRecord copy() {", "refactored_code": "    public static final short sid = 0x2a;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    public PrintHeadersRecord copy() {"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x00A1;\n    }\n\n    @Override", "refactored_code": "    public static final short     sid = 0x00A1;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public short getSid() {\n        return 0x01AF;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x01AF;\n\n    @Override\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x0012;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x0012;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public void serialize(LittleEndianOutput out) {\n        out.writeShort(0x01C1); // always write 'rt' field as 0x01C1\n        out.writeShort(_reserved0);\n        out.writeInt(_engineId);\n    }", "refactored_code": "    public static final short sid = 0x01C1;\n    }\n\n    public void serialize(LittleEndianOutput out) {\n        out.writeShort(sid); // always write 'rt' field as 0x01C1\n        out.writeShort(_reserved0);\n        out.writeInt(_engineId);\n    }"}
{"magic_number_smell": "     */\n    public static List<org.apache.poi.hssf.record.Record> createRecords(InputStream in) throws RecordFormatException {\n\n        List<org.apache.poi.hssf.record.Record> records = new ArrayList<>(512);\n\n        RecordFactoryInputStream recStream = new RecordFactoryInputStream(in, true);\n", "refactored_code": "    private static final int NUM_RECORDS = 512;\n     */\n    public static List<org.apache.poi.hssf.record.Record> createRecords(InputStream in) throws RecordFormatException {\n\n        List<org.apache.poi.hssf.record.Record> records = new ArrayList<>(NUM_RECORDS);\n\n        RecordFactoryInputStream recStream = new RecordFactoryInputStream(in, true);\n"}
{"magic_number_smell": "        _currentSid = _nextSid;\n        _currentDataOffset = 0;\n        _currentDataLength = _bhi.readDataSize();\n        if (_currentDataLength > 8224) {\n            throw new RecordFormatException(\"The content of an excel record cannot exceed \"\n                    + 8224 + \" bytes\");\n        }", "refactored_code": "    public static final short MAX_RECORD_DATA_SIZE = 8224;\n        _currentSid = _nextSid;\n        _currentDataOffset = 0;\n        _currentDataLength = _bhi.readDataSize();\n        if (_currentDataLength > MAX_RECORD_DATA_SIZE) {\n            throw new RecordFormatException(\"The content of an excel record cannot exceed \"\n                    + MAX_RECORD_DATA_SIZE + \" bytes\");\n        }"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0xf;\n    }\n\n    @Override", "refactored_code": "    public static final short sid           = 0xf;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x01B7;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x01B7;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "        return 8;\n    }\n\n    public short getSid()    {        return 0x27;    }\n\n    /**\n     * Get the margin field for the RightMargin record.", "refactored_code": "    public static final short sid = 0x27;\n        return 8;\n    }\n\n    public short getSid()    {        return sid;    }\n\n    /**\n     * Get the margin field for the RightMargin record."}
{"magic_number_smell": "\n    @Override\n    public short getSid() {\n        return 0x027E;\n    }\n\n    @Override", "refactored_code": "    public static final short sid                      = 0x027E;\n\n    @Override\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x0208;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x0208;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x5f;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x5f;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0xdd;\n    }\n\n    public ScenarioProtectRecord copy() {", "refactored_code": "    public static final short sid = 0xdd;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    public ScenarioProtectRecord copy() {"}
{"magic_number_smell": "    @Override\n    public short getSid()\n    {\n        return 0x00A0;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x00A0;\n    @Override\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public short getSid() {\n        return 0x001D;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x001D;\n\n    @Override\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x04BC;\n    }\n\n    /**", "refactored_code": "    public static final short sid = 0x04BC;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    /**"}
{"magic_number_smell": "\n    @Override\n    public short getSid() {\n        return 0x00FC;\n    }\n\n    /**", "refactored_code": "    public static final short sid = 0x00FC;\n\n    @Override\n    public short getSid() {\n        return sid;\n    }\n\n    /**"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x0207;\n    }\n\n    /**", "refactored_code": "    public static final short sid = 0x0207;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    /**"}
{"magic_number_smell": "\n    @Override\n    public short getSid() {\n        return 0x0293;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x0293;\n\n    @Override\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    //arbitrarily selected; may need to increase\n    private static final int 1_000_000 = 1_000_000;\n    private static int MAX_RECORD_LENGTH = 1_000_000;\n\n    /**\n     * @param length the max record length allowed for SubRecord", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 1_000_000;\n\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 1_000_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    /**\n     * @param length the max record length allowed for SubRecord"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x01AE;\n    }\n    public String getURL() {\n        String encodedUrl = field_2_encoded_url;", "refactored_code": "    public static final short sid = 0x01AE;\n\n    public short getSid()\n    {\n        return sid;\n    }\n    public String getURL() {\n        String encodedUrl = field_2_encoded_url;"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x013D;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x013D;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n\n    public short getSid() {\n        return 0x0236;\n    }\n    protected int getExtraDataSize() {\n        return", "refactored_code": "    public static final short sid = 0x0236;\n\n\n    public short getSid() {\n        return sid;\n    }\n    protected int getExtraDataSize() {\n        return"}
{"magic_number_smell": "\n    @Override\n    public short getSid() {\n        return 0x088E;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x088E;\n\n    @Override\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x01B6;\n    }\n\n    private void serializeTXORecord(ContinuableRecordOutput out) {", "refactored_code": "    public static final short sid = 0x01B6;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    private void serializeTXORecord(ContinuableRecordOutput out) {"}
{"magic_number_smell": "        return 8;\n    }\n\n    public short getSid()    {        return 0x28;    }\n\n    /**\n     * Get the margin field for the TopMargin record.", "refactored_code": "    public static final short sid = 0x28;\n        return 8;\n    }\n\n    public short getSid()    {        return sid;    }\n\n    /**\n     * Get the margin field for the TopMargin record."}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x005E;\n    }\n\n    public UncalcedRecord(RecordInputStream in) {", "refactored_code": "    public static final short sid = 0x005E;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    public UncalcedRecord(RecordInputStream in) {"}
{"magic_number_smell": "        // Make sure you delete the corresponding entry from\n        // this method any time a new Record subclass is created.\n        switch (sid) {\n            case 0x0033: return \"PRINTSIZE\";\n            case PLS_004D: return \"PLS\";\n            case 0x0050: return \"DCON\"; // Data Consolidation Information\n            case 0x007F: return \"IMDATA\";", "refactored_code": "    public static final int PRINTSIZE_0033       = 0x0033;\n        // Make sure you delete the corresponding entry from\n        // this method any time a new Record subclass is created.\n        switch (sid) {\n            case PRINTSIZE_0033: return \"PRINTSIZE\";\n            case PLS_004D: return \"PLS\";\n            case 0x0050: return \"DCON\"; // Data Consolidation Information\n            case 0x007F: return \"IMDATA\";"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x01AA;\n    }\n\n    /**", "refactored_code": "    public static final short sid = 0x01AA;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    /**"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x01AB;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x01AB;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x0160;\n    }\n\n    @Override", "refactored_code": "    public static final short sid   = 0x0160;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x84;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x84;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x001A;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x001A;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x3d;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x3d;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x0019;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x0019;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x023E;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x023E;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public short getSid() {\n        return 0x005C;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x005C;\n\n    @Override\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x86;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x86;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x0081;\n    }\n\n    @Override", "refactored_code": "    public static final short     sid = 0x0081;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "        if(pRules == null) {\n            throw new IllegalArgumentException(\"rules must not be null\");\n        }\n        if(pRules.length > 3) {\n            LOG.atWarn().log(\"Excel versions before 2007 require that No more than \" +\n                    3 + \" rules may be specified, {} were found, this file will \" +\n                    \"cause problems with old Excel versions\", box(pRules.length));", "refactored_code": "    private static final int MAX_97_2003_CONDTIONAL_FORMAT_RULES = 3;\n        if(pRules == null) {\n            throw new IllegalArgumentException(\"rules must not be null\");\n        }\n        if(pRules.length > MAX_97_2003_CONDTIONAL_FORMAT_RULES) {\n            LOG.atWarn().log(\"Excel versions before 2007 require that No more than \" +\n                    MAX_97_2003_CONDTIONAL_FORMAT_RULES + \" rules may be specified, {} were found, this file will \" +\n                    \"cause problems with old Excel versions\", box(pRules.length));"}
{"magic_number_smell": "            // no need to write a single empty MergeCellsRecord\n            return 0;\n        }\n        int nMergedCellsRecords = nRegions / 1027;\n        int nLeftoverMergedRegions = nRegions % 1027;\n\n        return nMergedCellsRecords", "refactored_code": "    private static final int MAX_MERGED_REGIONS = 1027;\n            // no need to write a single empty MergeCellsRecord\n            return 0;\n        }\n        int nMergedCellsRecords = nRegions / MAX_MERGED_REGIONS;\n        int nLeftoverMergedRegions = nRegions % MAX_MERGED_REGIONS;\n\n        return nMergedCellsRecords"}
{"magic_number_smell": "    }\n\n    public void removeAllCellsValuesForRow(int rowIndex) {\n        if (rowIndex < 0 || rowIndex > 0XFFFF) {\n            throw new IllegalArgumentException(\"Specified rowIndex \" + rowIndex\n                    + \" is outside the allowable range (0..\" +0XFFFF + \")\");\n        }", "refactored_code": "    private static final int MAX_ROW_INDEX = 0XFFFF;\n    }\n\n    public void removeAllCellsValuesForRow(int rowIndex) {\n        if (rowIndex < 0 || rowIndex > MAX_ROW_INDEX) {\n            throw new IllegalArgumentException(\"Specified rowIndex \" + rowIndex\n                    + \" is outside the allowable range (0..\" +MAX_ROW_INDEX + \")\");\n        }"}
{"magic_number_smell": "    /**\n     * set the type of border to use for the left border of the cell\n     * @param border type\n     * @see #0x0\n     * @see #BORDER_THIN\n     * @see #BORDER_MEDIUM\n     * @see #BORDER_DASHED", "refactored_code": "    public static final short    BORDER_NONE                = 0x0;\n    /**\n     * set the type of border to use for the left border of the cell\n     * @param border type\n     * @see #BORDER_NONE\n     * @see #BORDER_THIN\n     * @see #BORDER_MEDIUM\n     * @see #BORDER_DASHED"}
{"magic_number_smell": "        setEscapementTypeModified(false);\n        setUnderlineTypeModified(false);\n\n        setShort(0, 0);\n        setInt(OFFSET_NOT_USED1, 0x00000001);\n        setInt(OFFSET_NOT_USED2, 0x00000000);\n        setInt(OFFSET_NOT_USED3, 0x7FFFFFFF);// for some reason Excel always writes  0x7FFFFFFF at this offset", "refactored_code": "    private static final int OFFSET_FONT_NAME = 0;\n        setEscapementTypeModified(false);\n        setUnderlineTypeModified(false);\n\n        setShort(OFFSET_FONT_NAME, 0);\n        setInt(OFFSET_NOT_USED1, 0x00000001);\n        setInt(OFFSET_NOT_USED2, 0x00000000);\n        setInt(OFFSET_NOT_USED3, 0x7FFFFFFF);// for some reason Excel always writes  0x7FFFFFFF at this offset"}
{"magic_number_smell": "\n\n    // PATTERN FORMATING BLOCK\n    // For Pattern Styles see constants at HSSFCellStyle (from 0 to LEAST_DOTS)\n    private static final BitField  fillPatternStyle = BitFieldFactory.getInstance(0xFC00);\n\n    private static final BitField  patternColorIndex = BitFieldFactory.getInstance(0x007F);", "refactored_code": "    public static final short     NO_FILL             = 0  ;\n\n\n    // PATTERN FORMATING BLOCK\n    // For Pattern Styles see constants at HSSFCellStyle (from NO_FILL to LEAST_DOTS)\n    private static final BitField  fillPatternStyle = BitFieldFactory.getInstance(0xFC00);\n\n    private static final BitField  patternColorIndex = BitFieldFactory.getInstance(0x007F);"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x100A;\n    }\n\n    /**", "refactored_code": "    public static final short sid = 0x100A;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    /**"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x101A;\n    }\n\n    /**", "refactored_code": "    public static final short sid = 0x101A;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    /**"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x1021;\n    }\n\n    /**", "refactored_code": "    public static final short sid                       = 0x1021;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    /**"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x1062;\n    }\n\n    /**", "refactored_code": "    public static final short sid = 0x1062;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    /**"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x1041;\n    }\n\n    /**", "refactored_code": "    public static final short sid                 = 0x1041;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    /**"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x101d;\n    }\n\n    /**", "refactored_code": "    public static final short sid                          = 0x101d;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    /**"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x1046;\n    }\n\n    /**", "refactored_code": "    public static final short sid = 0x1046;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    /**"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x1017;\n    }\n\n    /**", "refactored_code": "    public static final short sid = 0x1017;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    /**"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x1033;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x1033;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x1020;\n    }\n\n    /**", "refactored_code": "    public static final short sid = 0x1020;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    /**"}
{"magic_number_smell": "\n    @Override\n    public short getSid() {\n        return 0x0856;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x0856;\n\n    @Override\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public short getSid() {\n        return 0x0853;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x0853;\n\n    @Override\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public short getSid() {\n        return 0x0855;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x0855;\n\n    @Override\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x1014;\n    }\n\n    public int getXPosition() {", "refactored_code": "    public static final short sid = 0x1014;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    public int getXPosition() {"}
{"magic_number_smell": "\n    @Override\n    public short getSid() {\n        return 0x850;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x850;\n\n    @Override\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x1002;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x1002;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public short getSid() {\n        return 0x0852;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x0852;\n\n    @Override\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public short getSid() {\n        return 0x0854;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x0854;\n\n    @Override\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x1050;\n    }\n\n    public int getFormatCount() {", "refactored_code": "    public static final short sid = 0x1050;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    public int getFormatCount() {"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x1006;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x1006;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public short getSid() {\n        return 0x086A;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x086A;\n\n    @Override\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x1063;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x1063;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x1024;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x1024;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x1034;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x1034;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x1060;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x1060;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x1026;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x1026;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x1032;\n    }\n\n    @Override", "refactored_code": "    public static final short sid  = 0x1032;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x1015;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x1015;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x1007;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x1007;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x1051;\n    }\n\n    @Override", "refactored_code": "    public static final short sid  = 0x1051;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x104E;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x104E;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x1027;\n    }\n\n    @Override", "refactored_code": "    public static final short sid                            = 0x1027;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x1035;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x1035;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x1064;\n    }\n\n    public PlotGrowthRecord copy() {", "refactored_code": "    public static final short sid = 0x1064;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    public PlotGrowthRecord copy() {"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x1045;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x1045;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x1065;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x1065;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x100c;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x100c;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x1016;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x1016;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x1003;\n    }\n\n    @Override", "refactored_code": "    public static final short sid                         = 0x1003;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x100D;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x100D;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public short getSid() {\n        return 0x1044;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x1044;\n    }\n\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x1025;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x1025;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    @Override\n    public short getSid()\n    {\n        return 0x101E;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x101E;\n    @Override\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x1001;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x1001;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    public short getSid()\n    {\n        return 0x101f;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x101f;\n\n    public short getSid()\n    {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "        if (_out == null) {\n            throw new IllegalStateException(\"Record already terminated\");\n        }\n        return RecordInputStream.MAX_RECORD_DATA_SIZE - _size;\n    }\n    /**\n     * Finishes writing the current record and updates 'ushort size' field.<br>", "refactored_code": "    private static final int MAX_DATA_SIZE = RecordInputStream.MAX_RECORD_DATA_SIZE;\n        if (_out == null) {\n            throw new IllegalStateException(\"Record already terminated\");\n        }\n        return MAX_DATA_SIZE - _size;\n    }\n    /**\n     * Finishes writing the current record and updates 'ushort size' field.<br>"}
{"magic_number_smell": "            }\n\n            Decryptor dec = info.getDecryptor();\n            dec.setChunkSize(1024);\n            ccis = (ChunkedCipherInputStream)dec.getDataStream(stream, Integer.MAX_VALUE, 0);\n\n            if (initialOffset > 0) {", "refactored_code": "    public static final int RC4_REKEYING_INTERVAL = 1024;\n            }\n\n            Decryptor dec = info.getDecryptor();\n            dec.setChunkSize(RC4_REKEYING_INTERVAL);\n            ccis = (ChunkedCipherInputStream)dec.getDataStream(stream, Integer.MAX_VALUE, 0);\n\n            if (initialOffset > 0) {"}
{"magic_number_smell": "\n    @Override\n    public short getSid() {\n        return 0x00C5;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x00C5;\n\n    @Override\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public short getSid() {\n        return 0x0100;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x0100;\n\n    @Override\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public short getSid() {\n        return 0x00B6;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x00B6;\n\n    @Override\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public short getSid() {\n        return 0x00D5;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x00D5;\n\n    @Override\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public short getSid() {\n        return 0x00B0;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x00B0;\n\n    @Override\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public short getSid() {\n        return 0x00B1;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x00B1;\n\n    @Override\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public short getSid() {\n        return 0x00E3;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x00E3;\n\n    @Override\n    public short getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "     * @throws IllegalStateException if the bounds are exceeded.\n     */\n    private static void checkBounds(int cellIndex) {\n        if (cellIndex < 0 || cellIndex > SpreadsheetVersion.EXCEL97.getLastColumnIndex()) {\n            throw new IllegalArgumentException(\"Invalid column index (\" + cellIndex\n                    + \").  Allowable column range for \" + FILE_FORMAT_NAME + \" is (0..\"\n                    + SpreadsheetVersion.EXCEL97.getLastColumnIndex() + \") or ('A'..'\" + LAST_COLUMN_NAME + \"')\");", "refactored_code": "    public static final int LAST_COLUMN_NUMBER  = SpreadsheetVersion.EXCEL97.getLastColumnIndex(); // 2^8 - 1\n     * @throws IllegalStateException if the bounds are exceeded.\n     */\n    private static void checkBounds(int cellIndex) {\n        if (cellIndex < 0 || cellIndex > LAST_COLUMN_NUMBER) {\n            throw new IllegalArgumentException(\"Invalid column index (\" + cellIndex\n                    + \").  Allowable column range for \" + FILE_FORMAT_NAME + \" is (0..\"\n                    + LAST_COLUMN_NUMBER + \") or ('A'..'\" + LAST_COLUMN_NAME + \"')\");"}
{"magic_number_smell": "        checkRange(dx2, 0, 1023, \"dx2\");\n        checkRange(dy1, 0, 255, \"dy1\");\n        checkRange(dy2, 0, 255, \"dy2\");\n        checkRange(col1, 0, SpreadsheetVersion.EXCEL97.getLastColumnIndex(), \"col1\");\n        checkRange(col2, 0, SpreadsheetVersion.EXCEL97.getLastColumnIndex(), \"col2\");\n        checkRange(row1, 0, MAX_ROW, \"row1\");\n        checkRange(row2, 0, MAX_ROW, \"row2\");", "refactored_code": "    public static final int MAX_COL = SpreadsheetVersion.EXCEL97.getLastColumnIndex();\n        checkRange(dx2, 0, 1023, \"dx2\");\n        checkRange(dy1, 0, 255, \"dy1\");\n        checkRange(dy2, 0, 255, \"dy2\");\n        checkRange(col1, 0, MAX_COL, \"col1\");\n        checkRange(col2, 0, MAX_COL, \"col2\");\n        checkRange(row1, 0, MAX_ROW, \"row1\");\n        checkRange(row2, 0, MAX_ROW, \"row2\");"}
{"magic_number_smell": "            bse.setRef(bse.getRef() - 1);\n            getOptRecord().removeEscherProperty(EscherPropertyTypes.FILL__PATTERNTEXTURE);\n        }\n        setPropertyValue(new EscherSimpleProperty( EscherPropertyTypes.FILL__FILLTYPE, false, false, 0));\n    }\n\n    public int getBackgroundImageId(){", "refactored_code": "    private static final int FILL_TYPE_SOLID = 0;\n            bse.setRef(bse.getRef() - 1);\n            getOptRecord().removeEscherProperty(EscherPropertyTypes.FILL__PATTERNTEXTURE);\n        }\n        setPropertyValue(new EscherSimpleProperty( EscherPropertyTypes.FILL__FILLTYPE, false, false, FILL_TYPE_SOLID));\n    }\n\n    public int getBackgroundImageId(){"}
{"magic_number_smell": "    @Override\n    public String getFormula2() {\n        byte conditionType = cfRuleRecord.getConditionType();\n        if (conditionType == CFRuleBase.CONDITION_TYPE_CELL_VALUE_IS) {\n            byte comparisonOperation = cfRuleRecord.getComparisonOperation();\n            switch(comparisonOperation) {\n                case ComparisonOperator.BETWEEN:", "refactored_code": "    private static final byte CELL_COMPARISON = CFRuleBase.CONDITION_TYPE_CELL_VALUE_IS;\n    @Override\n    public String getFormula2() {\n        byte conditionType = cfRuleRecord.getConditionType();\n        if (conditionType == CELL_COMPARISON) {\n            byte comparisonOperation = cfRuleRecord.getComparisonOperation();\n            switch(comparisonOperation) {\n                case ComparisonOperator.BETWEEN:"}
{"magic_number_smell": "    protected ObjRecord createObjRecord() {\n        ObjRecord obj = new ObjRecord();\n        CommonObjectDataSubRecord c = new CommonObjectDataSubRecord();\n        c.setObjectType(0x1E);\n        c.setLocked(true);\n        c.setPrintable(true);\n        c.setAutofill(true);", "refactored_code": "    public static final short OBJECT_TYPE_MICROSOFT_OFFICE_DRAWING = 0x1E;\n    protected ObjRecord createObjRecord() {\n        ObjRecord obj = new ObjRecord();\n        CommonObjectDataSubRecord c = new CommonObjectDataSubRecord();\n        c.setObjectType(OBJECT_TYPE_MICROSOFT_OFFICE_DRAWING);\n        c.setLocked(true);\n        c.setPrintable(true);\n        c.setAutofill(true);"}
{"magic_number_smell": "\n        //Need to check what the font is currently, so we can reapply it after\n        //the range is completed\n        short currentFont = 0;\n        if (endIndex != length()) {\n          currentFont = this.getFontAtIndex(endIndex);\n        }", "refactored_code": "    public static final short NO_FONT = 0;\n\n        //Need to check what the font is currently, so we can reapply it after\n        //the range is completed\n        short currentFont = NO_FONT;\n        if (endIndex != length()) {\n          currentFont = this.getFontAtIndex(endIndex);\n        }"}
{"magic_number_smell": "        row = record;\n        setRowNum(record.getRowNumber());\n\n        if (record.getLastCol() < 0 || Configurator.getIntValue(\"HSSFRow.ColInitialCapacity\", 5) < 0) {\n            throw new IllegalArgumentException(\"Had invalid column counts: \" + record.getLastCol() + \" and \" + Configurator.getIntValue(\"HSSFRow.ColInitialCapacity\", 5));\n        }\n", "refactored_code": "    public static final int INITIAL_CAPACITY = Configurator.getIntValue(\"HSSFRow.ColInitialCapacity\", 5);\n        row = record;\n        setRowNum(record.getRowNumber());\n\n        if (record.getLastCol() < 0 || INITIAL_CAPACITY < 0) {\n            throw new IllegalArgumentException(\"Had invalid column counts: \" + record.getLastCol() + \" and \" + INITIAL_CAPACITY);\n        }\n"}
{"magic_number_smell": "     * Sets the width of the line.  12700 = 1 pt.\n     *\n     * @param lineWidth width in EMU's.  12700EMU's = 1 pt\n     * @see HSSFShape#12700\n     */\n    public void setLineWidth(int lineWidth) {\n        setPropertyValue(new EscherSimpleProperty(EscherPropertyTypes.LINESTYLE__LINEWIDTH, lineWidth));", "refactored_code": "    public static final int LINEWIDTH_ONE_PT = 12700;\n     * Sets the width of the line.  12700 = 1 pt.\n     *\n     * @param lineWidth width in EMU's.  12700EMU's = 1 pt\n     * @see HSSFShape#LINEWIDTH_ONE_PT\n     */\n    public void setLineWidth(int lineWidth) {\n        setPropertyValue(new EscherSimpleProperty(EscherPropertyTypes.LINESTYLE__LINEWIDTH, lineWidth));"}
{"magic_number_smell": "    public float getColumnWidthInPixels(int column){\n        int cw = getColumnWidth(column);\n        int def = getDefaultColumnWidth()*256;\n        float px = (cw == def ? 32.00f : PX_MODIFIED);\n\n        return cw/px;\n    }", "refactored_code": "    private static final float PX_DEFAULT = 32.00f;\n    public float getColumnWidthInPixels(int column){\n        int cw = getColumnWidth(column);\n        int def = getDefaultColumnWidth()*256;\n        float px = (cw == def ? PX_DEFAULT : PX_MODIFIED);\n\n        return cw/px;\n    }"}
{"magic_number_smell": "     */\n    public void setString(RichTextString string) {\n        //TODO add other shape types which can not contain text\n        if (getShapeType() == 0 || getShapeType() == HSSFShapeTypes.Line){\n            throw new IllegalStateException(\"Cannot set text for shape type: \"+getShapeType());\n        }\n        HSSFRichTextString rtr = (HSSFRichTextString) string;", "refactored_code": "    public static final short       OBJECT_TYPE_LINE               = HSSFShapeTypes.Line;\n     */\n    public void setString(RichTextString string) {\n        //TODO add other shape types which can not contain text\n        if (getShapeType() == 0 || getShapeType() == OBJECT_TYPE_LINE){\n            throw new IllegalStateException(\"Cannot set text for shape type: \"+getShapeType());\n        }\n        HSSFRichTextString rtr = (HSSFRichTextString) string;"}
{"magic_number_smell": "    protected ObjRecord createObjRecord() {\n        ObjRecord obj = new ObjRecord();\n        CommonObjectDataSubRecord c = new CommonObjectDataSubRecord();\n        c.setObjectType(HSSFTextbox.6);\n        c.setLocked(true);\n        c.setPrintable(true);\n        c.setAutofill(true);", "refactored_code": "    public static final short OBJECT_TYPE_TEXT = 6;\n    protected ObjRecord createObjRecord() {\n        ObjRecord obj = new ObjRecord();\n        CommonObjectDataSubRecord c = new CommonObjectDataSubRecord();\n        c.setObjectType(HSSFTextbox.OBJECT_TYPE_TEXT);\n        c.setLocked(true);\n        c.setPrintable(true);\n        c.setAutofill(true);"}
{"magic_number_smell": "\n    //arbitrarily selected; may need to increase\n    private static final int 100_000 = 100_000;\n    private static int MAX_RECORD_LENGTH = 100_000;\n    private static final int DEFAULT_MAX_IMAGE_LENGTH = 50_000_000;\n    private static int MAX_IMAGE_LENGTH = DEFAULT_MAX_IMAGE_LENGTH;\n", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000;\n\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n    private static final int DEFAULT_MAX_IMAGE_LENGTH = 50_000_000;\n    private static int MAX_IMAGE_LENGTH = DEFAULT_MAX_IMAGE_LENGTH;\n"}
{"magic_number_smell": "    }\n\n    private static int readUShortAndCheck(LittleEndianInput in) {\n        if (in.available() < 6) {\n            // Ran out of data\n            throw new IllegalArgumentException(\"Ran out of data reading CellRangeAddress, available: \" + in.available());\n        }", "refactored_code": "    public static final int ENCODED_SIZE = 6;\n    }\n\n    private static int readUShortAndCheck(LittleEndianInput in) {\n        if (in.available() < ENCODED_SIZE) {\n            // Ran out of data\n            throw new IllegalArgumentException(\"Ran out of data reading CellRangeAddress, available: \" + in.available());\n        }"}
{"magic_number_smell": "    public ChunkedCipherOutputStream(DirectoryNode dir, int chunkSize) throws IOException, GeneralSecurityException {\n        super(null);\n        this.chunkSize = chunkSize;\n        int cs = chunkSize == -1 ? 4096 : chunkSize;\n        this.chunk = IOUtils.safelyAllocate(cs, CryptoFunctions.MAX_RECORD_LENGTH);\n        this.plainByteFlags = new SparseBitSet(cs);\n        this.chunkBits = Integer.bitCount(cs-1);", "refactored_code": "    private static final int STREAMING = -1;\n    public ChunkedCipherOutputStream(DirectoryNode dir, int chunkSize) throws IOException, GeneralSecurityException {\n        super(null);\n        this.chunkSize = chunkSize;\n        int cs = chunkSize == STREAMING ? 4096 : chunkSize;\n        this.chunk = IOUtils.safelyAllocate(cs, CryptoFunctions.MAX_RECORD_LENGTH);\n        this.plainByteFlags = new SparseBitSet(cs);\n        this.chunkBits = Integer.bitCount(cs-1);"}
{"magic_number_smell": "\n    //arbitrarily selected; may need to increase\n    private static final int 100_000 = 100_000;\n    static int MAX_RECORD_LENGTH = 100_000;\n\n    /**\n     * @param length the max record length allowed for CryptoFunctions", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000;\n\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000;\n    static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    /**\n     * @param length the max record length allowed for CryptoFunctions"}
{"magic_number_smell": "        is.readFully(encryptedVerifierHash);\n        setEncryptedVerifierHash(encryptedVerifierHash);\n\n        setSpinCount(50000);\n        setCipherAlgorithm(header.getCipherAlgorithm());\n        setChainingMode(header.getChainingMode());\n        setEncryptedKey(null);", "refactored_code": "    private static final int SPIN_COUNT = 50000;\n        is.readFully(encryptedVerifierHash);\n        setEncryptedVerifierHash(encryptedVerifierHash);\n\n        setSpinCount(SPIN_COUNT);\n        setCipherAlgorithm(header.getCipherAlgorithm());\n        setChainingMode(header.getChainingMode());\n        setEncryptedKey(null);"}
{"magic_number_smell": "    public int read() throws IOException {\n        dieIfClosed();\n        if (atEOD()) {\n            return -1;\n        }\n        byte[] b = new byte[1];\n        int result = read(b, 0, 1);", "refactored_code": "    private static final int EOF = -1;\n    public int read() throws IOException {\n        dieIfClosed();\n        if (atEOD()) {\n            return EOF;\n        }\n        byte[] b = new byte[1];\n        int result = read(b, 0, 1);"}
{"magic_number_smell": "    private static final Charset UTF8 = StandardCharsets.UTF_8;\n    // arbitrarily selected; may need to increase\n    private static final int 100_000_000 = 100_000_000;\n    private static int MAX_RECORD_LENGTH = 100_000_000;\n    // arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_STRING_LENGTH = 1024;\n    private static int MAX_STRING_LENGTH = DEFAULT_MAX_STRING_LENGTH;", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000_000;\n    private static final Charset UTF8 = StandardCharsets.UTF_8;\n    // arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n    // arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_STRING_LENGTH = 1024;\n    private static int MAX_STRING_LENGTH = DEFAULT_MAX_STRING_LENGTH;"}
{"magic_number_smell": "        implements POIFSViewable, Closeable {\n    //arbitrarily selected; may need to increase\n    private static final int 100_000 = 100_000;\n    private static int MAX_RECORD_LENGTH = 100_000;\n\n    private static final int MAX_ALLOCATION_SIZE = 250_000_000;\n", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000;\n        implements POIFSViewable, Closeable {\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    private static final int MAX_ALLOCATION_SIZE = 250_000_000;\n"}
{"magic_number_smell": "            int b1 = IOUtils.readByte(is);\n\n            int read = 2;\n            while ((b0 + b1) != 0 && read < 20000) {\n                bos.write(b0);\n                bos.write(b1);\n                b0 = IOUtils.readByte(is);", "refactored_code": "    private static final int MAX_STRING_LENGTH = 20000;\n            int b1 = IOUtils.readByte(is);\n\n            int read = 2;\n            while ((b0 + b1) != 0 && read < MAX_STRING_LENGTH) {\n                bos.write(b0);\n                bos.write(b1);\n                b0 = IOUtils.readByte(is);"}
{"magic_number_smell": "      }\n\n      long totalLen = difference+buffer.length;\n      byte[] nb = IOUtils.safelyAllocate(totalLen, Integer.MAX_VALUE);\n      System.arraycopy(buffer, 0, nb, 0, (int)size);\n      buffer = nb;\n   }", "refactored_code": "   private static final int MAX_RECORD_LENGTH = Integer.MAX_VALUE;\n      }\n\n      long totalLen = difference+buffer.length;\n      byte[] nb = IOUtils.safelyAllocate(totalLen, MAX_RECORD_LENGTH);\n      System.arraycopy(buffer, 0, nb, 0, (int)size);\n      buffer = nb;\n   }"}
{"magic_number_smell": "        java.awt.Shape tailShape = null;\n        Path p = null;\n        Rectangle2D bounds;\n        final double scaleY = Math.pow(1.5d, tailWidth.ordinal()+1.);\n        final double scaleX = Math.pow(1.5d, tailLength.ordinal()+1.);\n\n        DecorationShape tailShapeEnum = deco.getTailShape();", "refactored_code": "    private static final double DECO_SIZE_POW = 1.5d;\n        java.awt.Shape tailShape = null;\n        Path p = null;\n        Rectangle2D bounds;\n        final double scaleY = Math.pow(DECO_SIZE_POW, tailWidth.ordinal()+1.);\n        final double scaleX = Math.pow(DECO_SIZE_POW, tailLength.ordinal()+1.);\n\n        DecorationShape tailShapeEnum = deco.getTailShape();"}
{"magic_number_smell": "                    switch (edge) {\n                        default:\n                        case bottom:\n                            line = new Line2D.Double(x-2, y+h, x+w+2, y+h);\n                            break;\n                        case left:\n                            line = new Line2D.Double(x, y, x, y+h+2);", "refactored_code": "    public static final int borderSize = 2;\n                    switch (edge) {\n                        default:\n                        case bottom:\n                            line = new Line2D.Double(x-borderSize, y+h, x+w+borderSize, y+h);\n                            break;\n                        case left:\n                            line = new Line2D.Double(x, y, x, y+h+borderSize);"}
{"magic_number_smell": "    public byte[] extractPNG() {\n        //\n        //Just cut it off!.\n        if (data.length >= 16) {\n            byte[] newData = Arrays.copyOfRange(data, 16, data.length);\n            if (FileMagic.valueOf(newData) == FileMagic.PNG) {\n                return newData;", "refactored_code": "    private static final int MAGIC_OFFSET = 16;\n    public byte[] extractPNG() {\n        //\n        //Just cut it off!.\n        if (data.length >= MAGIC_OFFSET) {\n            byte[] newData = Arrays.copyOfRange(data, MAGIC_OFFSET, data.length);\n            if (FileMagic.valueOf(newData) == FileMagic.PNG) {\n                return newData;"}
{"magic_number_smell": "    public ImageHeaderWMF(byte[] data, final int off) {\n        int offset = off;\n        int key = LittleEndian.getInt(data, offset); offset += LittleEndianConsts.INT_SIZE; //header key\n        if (key != 0x9AC6CDD7) {\n            LOG.atWarn().log(\"WMF file doesn't contain a placeable header - ignore parsing\");\n            handle = 0;\n            left = 0;", "refactored_code": "    public static final int APMHEADER_KEY = 0x9AC6CDD7;\n    public ImageHeaderWMF(byte[] data, final int off) {\n        int offset = off;\n        int key = LittleEndian.getInt(data, offset); offset += LittleEndianConsts.INT_SIZE; //header key\n        if (key != APMHEADER_KEY) {\n            LOG.atWarn().log(\"WMF file doesn't contain a placeable header - ignore parsing\");\n            handle = 0;\n            left = 0;"}
{"magic_number_smell": "    private static final Logger LOG = LogManager.getLogger(EmbeddedExtractor.class);\n    //arbitrarily selected; may need to increase\n    private static final int 1_000_000 = 1_000_000;\n    private static int MAX_RECORD_LENGTH = 1_000_000;\n\n    // contentType\n    private static final String CONTENT_TYPE_BYTES = \"binary/octet-stream\";", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 1_000_000;\n    private static final Logger LOG = LogManager.getLogger(EmbeddedExtractor.class);\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 1_000_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    // contentType\n    private static final String CONTENT_TYPE_BYTES = \"binary/octet-stream\";"}
{"magic_number_smell": "        if (value instanceof Number) {\n            Number num = (Number) value;\n            // Convert from fractional days to milliseconds. Excel always rounds up.\n            double v = Math.round(num.doubleValue() * 1000 * 60 * 60 * 24);\n            if (v == 0L) {\n                value = EXCEL_EPOCH_CAL.getTime();\n            } else {", "refactored_code": "    private static final int NUM_MILLISECONDS_IN_DAY = 1000 * 60 * 60 * 24;\n        if (value instanceof Number) {\n            Number num = (Number) value;\n            // Convert from fractional days to milliseconds. Excel always rounds up.\n            double v = Math.round(num.doubleValue() * NUM_MILLISECONDS_IN_DAY);\n            if (v == 0L) {\n                value = EXCEL_EPOCH_CAL.getTime();\n            } else {"}
{"magic_number_smell": "    private static final Pattern PERCENTS = Pattern.compile(\"%\");\n\n    private static final double 1.0 / 24.0 = 1.0 / 24.0;\n    private static final double MIN__FACTOR = 1.0 / 24.0 / 60.0;\n    private static final double SEC__FACTOR = MIN__FACTOR / 60.0;\n\n    private static class TimeSpec {", "refactored_code": "    private static final double HOUR__FACTOR = 1.0 / 24.0;\n    private static final Pattern PERCENTS = Pattern.compile(\"%\");\n\n    private static final double HOUR__FACTOR = 1.0 / 24.0;\n    private static final double MIN__FACTOR = HOUR__FACTOR / 60.0;\n    private static final double SEC__FACTOR = MIN__FACTOR / 60.0;\n\n    private static class TimeSpec {"}
{"magic_number_smell": "\n    static {\n        TESTS = new HashMap<>();\n        TESTS.put(\"<\", 0);\n        TESTS.put(\"<=\", LE);\n        TESTS.put(\">\", GT);\n        TESTS.put(\">=\", GE);", "refactored_code": "    private static final int LT = 0;\n\n    static {\n        TESTS = new HashMap<>();\n        TESTS.put(\"<\", LT);\n        TESTS.put(\"<=\", LE);\n        TESTS.put(\">\", GT);\n        TESTS.put(\">=\", GE);"}
{"magic_number_smell": "     * @return A new formula object as read from the stream.  Possibly empty, never {@code null}.\n     */\n    public static Formula read(int encodedTokenLen, LittleEndianInput in, int totalEncodedLen) {\n        byte[] byteEncoding = IOUtils.safelyAllocate(totalEncodedLen, 100000);\n        in.readFully(byteEncoding);\n        return new Formula(byteEncoding, encodedTokenLen);\n    }", "refactored_code": "    private static final int MAX_ENCODED_LEN = 100000;\n     * @return A new formula object as read from the stream.  Possibly empty, never {@code null}.\n     */\n    public static Formula read(int encodedTokenLen, LittleEndianInput in, int totalEncodedLen) {\n        byte[] byteEncoding = IOUtils.safelyAllocate(totalEncodedLen, MAX_ENCODED_LEN);\n        in.readFully(byteEncoding);\n        return new Formula(byteEncoding, encodedTokenLen);\n    }"}
{"magic_number_smell": "@Internal\nfinal class YearFracCalculator {\n    private static final int 60 * 60 * 1000 = 60 * 60 * 1000;\n    private static final int MS_PER_DAY = 24 * 60 * 60 * 1000;\n    private static final int DAYS_PER_NORMAL_YEAR = 365;\n    private static final int DAYS_PER_LEAP_YEAR = DAYS_PER_NORMAL_YEAR + 1;\n", "refactored_code": "    private static final int MS_PER_HOUR = 60 * 60 * 1000;\n@Internal\nfinal class YearFracCalculator {\n    private static final int MS_PER_HOUR = 60 * 60 * 1000;\n    private static final int MS_PER_DAY = 24 * MS_PER_HOUR;\n    private static final int DAYS_PER_NORMAL_YEAR = 365;\n    private static final int DAYS_PER_LEAP_YEAR = DAYS_PER_NORMAL_YEAR + 1;\n"}
{"magic_number_smell": "    private static Object readAConstantValue(LittleEndianInput in) {\n        byte grbit = in.readByte();\n        switch(grbit) {\n            case 0:\n                in.readLong(); // 8 byte 'not used' field\n                return EMPTY_REPRESENTATION;\n            case TYPE_NUMBER:", "refactored_code": "    private static final int TYPE_EMPTY = 0;\n    private static Object readAConstantValue(LittleEndianInput in) {\n        byte grbit = in.readByte();\n        switch(grbit) {\n            case TYPE_EMPTY:\n                in.readLong(); // 8 byte 'not used' field\n                return EMPTY_REPRESENTATION;\n            case TYPE_NUMBER:"}
{"magic_number_smell": "        Function[] retval = new Function[368];\n\n        retval[0] = new Count();\n        retval[FunctionID.FunctionMetadataRegistry.FUNCTION_INDEX_IF] = new IfFunc(); //nominally 1\n        retval[2] = LogicalFunction.ISNA;\n        retval[3] = LogicalFunction.ISERROR;\n        retval[FunctionID.SUM] = AggregateFunction.SUM; //nominally 4", "refactored_code": "        public static final int IF = FunctionMetadataRegistry.FUNCTION_INDEX_IF;\n        Function[] retval = new Function[368];\n\n        retval[0] = new Count();\n        retval[FunctionID.IF] = new IfFunc(); //nominally 1\n        retval[2] = LogicalFunction.ISNA;\n        retval[3] = LogicalFunction.ISERROR;\n        retval[FunctionID.SUM] = AggregateFunction.SUM; //nominally 4"}
{"magic_number_smell": "     * the {@link org.apache.poi.ss.SpreadsheetVersion}\n     */\n    public boolean hasUnlimitedVarags() {\n        return 30 == _maxParams;\n    }\n\n    public String toString() {", "refactored_code": "    private static final short FUNCTION_MAX_PARAMS = 30;\n     * the {@link org.apache.poi.ss.SpreadsheetVersion}\n     */\n    public boolean hasUnlimitedVarags() {\n        return FUNCTION_MAX_PARAMS == _maxParams;\n    }\n\n    public String toString() {"}
{"magic_number_smell": "\n    //arbitrarily selected; may need to increase\n    private static final int 100_000 = 100_000;\n    private static int MAX_RECORD_LENGTH = 100_000;\n\n    private static final String METADATA_FILE_NAME = \"functionMetadata.txt\";\n    private static final String METADATA_FILE_NAME_CETAB = \"functionMetadataCetab.txt\";", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000;\n\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    private static final String METADATA_FILE_NAME = \"functionMetadata.txt\";\n    private static final String METADATA_FILE_NAME_CETAB = \"functionMetadataCetab.txt\";"}
{"magic_number_smell": "            if (args.length > 2  &&  args[2] != MissingArgEval.instance) {\n                refType = (int)NumericFunction.singleOperandEvaluate(args[2], srcRowIndex, srcColumnIndex);\n            } else {\n                refType = 1;     // this is also the default if parameter is not given\n            }\n            switch (refType){\n                case 1:", "refactored_code": "    public static final int REF_ABSOLUTE = 1;\n            if (args.length > 2  &&  args[2] != MissingArgEval.instance) {\n                refType = (int)NumericFunction.singleOperandEvaluate(args[2], srcRowIndex, srcColumnIndex);\n            } else {\n                refType = REF_ABSOLUTE;     // this is also the default if parameter is not given\n            }\n            switch (refType){\n                case REF_ABSOLUTE:"}
{"magic_number_smell": "        public static final int GT = 5;\n        public static final int GE = 6;\n\n        public static final CmpOp OP_NONE = op(\"\", 0);\n        public static final CmpOp OP_EQ = op(\"=\", EQ);\n        public static final CmpOp OP_NE = op(\"<>\", NE);\n        public static final CmpOp OP_LE = op(\"<=\", LE);", "refactored_code": "        public static final int NONE = 0;\n        public static final int GT = 5;\n        public static final int GE = 6;\n\n        public static final CmpOp OP_NONE = op(\"\", NONE);\n        public static final CmpOp OP_EQ = op(\"=\", EQ);\n        public static final CmpOp OP_NE = op(\"<>\", NE);\n        public static final CmpOp OP_LE = op(\"<=\", LE);"}
{"magic_number_smell": "        }\n\n        //If number < -512 or if number > 512, this function returns the #NUM! error value.\n        if (number.longValue() < -512 || number.longValue() > MAX_VALUE) {\n            return ErrorEval.NUM_ERROR;\n        }\n", "refactored_code": "    private static final long MIN_VALUE = -512;\n        }\n\n        //If number < -512 or if number > 512, this function returns the #NUM! error value.\n        if (number.longValue() < MIN_VALUE || number.longValue() > MAX_VALUE) {\n            return ErrorEval.NUM_ERROR;\n        }\n"}
{"magic_number_smell": "        }\n\n        //If number < -549,755,813,888 or if number > 549,755,813,887, this function returns the #NUM! error value.\n        if (number1.longValue() < Long.parseLong(\"-549755813888\") || number1.longValue() > MAX_VALUE)  {\n            return ErrorEval.NUM_ERROR;\n        }\n", "refactored_code": "    private static final long MIN_VALUE = Long.parseLong(\"-549755813888\");\n        }\n\n        //If number < -549,755,813,888 or if number > 549,755,813,887, this function returns the #NUM! error value.\n        if (number1.longValue() < MIN_VALUE || number1.longValue() > MAX_VALUE)  {\n            return ErrorEval.NUM_ERROR;\n        }\n"}
{"magic_number_smell": "\n        double x0 = guess;\n\n        for (int i = 0; i < 1000; i++) {\n\n            // the value of the function (NPV) and its derivation can be calculated in the same loop\n            final double factor = 1.0 + x0;", "refactored_code": "    private static final int MAX_ITERATION_COUNT = 1000;\n\n        double x0 = guess;\n\n        for (int i = 0; i < MAX_ITERATION_COUNT; i++) {\n\n            // the value of the function (NPV) and its derivation can be calculated in the same loop\n            final double factor = 1.0 + x0;"}
{"magic_number_smell": "\npublic class Log {\n    private static final double 10.0 = 10.0;\n    private static final double LOG_10_TO_BASE_e = Math.log(10.0);\n\n    public static ValueEval evaluate(ValueEval[] args, int srcRowIndex, int srcColumnIndex) {\n        if (args.length != 1 && args.length != 2) {", "refactored_code": "    private static final double TEN = 10.0;\n\npublic class Log {\n    private static final double TEN = 10.0;\n    private static final double LOG_10_TO_BASE_e = Math.log(TEN);\n\n    public static ValueEval evaluate(ValueEval[] args, int srcRowIndex, int srcColumnIndex) {\n        if (args.length != 1 && args.length != 2) {"}
{"magic_number_smell": "     * Subclasses may override to change default value.\n     */\n    protected int getMaxNumOperands() {\n        return SpreadsheetVersion.EXCEL2007.getMaxFunctionArgs();\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_MAX_NUM_OPERANDS = SpreadsheetVersion.EXCEL2007.getMaxFunctionArgs();\n     * Subclasses may override to change default value.\n     */\n    protected int getMaxNumOperands() {\n        return DEFAULT_MAX_NUM_OPERANDS;\n    }\n\n    /**"}
{"magic_number_smell": "    /* -------------------------------------------------------------------------- */\n\n    public static final Function ATAN2 = twoDouble((d0, d1) ->\n        (d0 == 0.0 && d1 == 0.0) ? ErrorEval.DIV_ZERO : Math.atan2(d1, d0)\n    );\n\n    public static final Function CEILING = twoDouble(MathX::ceiling);", "refactored_code": "    private static final double ZERO = 0.0;\n    /* -------------------------------------------------------------------------- */\n\n    public static final Function ATAN2 = twoDouble((d0, d1) ->\n        (d0 == ZERO && d1 == ZERO) ? ErrorEval.DIV_ZERO : Math.atan2(d1, d0)\n    );\n\n    public static final Function CEILING = twoDouble(MathX::ceiling);"}
{"magic_number_smell": "            // check for default result : excel implementation for 0,0\n            // is different to Math Common.\n            if (isDefaultResult(x,mean)) {\n                return new NumberEval(1);\n            }\n            // check the arguments : as per excel function def\n            checkArgument(x);", "refactored_code": "    private static final double DEFAULT_RETURN_RESULT = 1;\n            // check for default result : excel implementation for 0,0\n            // is different to Math Common.\n            if (isDefaultResult(x,mean)) {\n                return new NumberEval(DEFAULT_RETURN_RESULT);\n            }\n            // check the arguments : as per excel function def\n            checkArgument(x);"}
{"magic_number_smell": "        if (hours > 32767 || minutes > 32767 || seconds > 32767) {\n            throw new EvaluationException(ErrorEval.VALUE_INVALID);\n        }\n        int totalSeconds = hours * SECONDS_PER_HOUR + minutes * 60 + seconds;\n\n        if (totalSeconds < 0) {\n            throw new EvaluationException(ErrorEval.VALUE_INVALID);", "refactored_code": "    private static final int SECONDS_PER_MINUTE = 60;\n        if (hours > 32767 || minutes > 32767 || seconds > 32767) {\n            throw new EvaluationException(ErrorEval.VALUE_INVALID);\n        }\n        int totalSeconds = hours * SECONDS_PER_HOUR + minutes * SECONDS_PER_MINUTE + seconds;\n\n        if (totalSeconds < 0) {\n            throw new EvaluationException(ErrorEval.VALUE_INVALID);"}
{"magic_number_smell": "                    if (foundDecimalPoint) {\n                        return null;\n                    }\n                    if (i - lastThousandsSeparatorIndex < 4) {\n                        return null;\n                    }\n                    foundDecimalPoint = true;", "refactored_code": "    private static final int MIN_DISTANCE_BETWEEN_THOUSANDS_SEPARATOR = 4;\n                    if (foundDecimalPoint) {\n                        return null;\n                    }\n                    if (i - lastThousandsSeparatorIndex < MIN_DISTANCE_BETWEEN_THOUSANDS_SEPARATOR) {\n                        return null;\n                    }\n                    foundDecimalPoint = true;"}
{"magic_number_smell": "     * @return {@code true} if this is an external function\n     */\n    public final boolean isExternalFunction() {\n        return _functionIndex == 255;\n    }\n\n    @Override", "refactored_code": "    private static final short FUNCTION_INDEX_EXTERNAL = 255;\n     * @return {@code true} if this is an external function\n     */\n    public final boolean isExternalFunction() {\n        return _functionIndex == FUNCTION_INDEX_EXTERNAL;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public byte getSid() {\n        return 0x03;\n    }\n\n    public int getNumberOfOperands() {", "refactored_code": "    public static final byte sid  = 0x03;\n\n    @Override\n    public byte getSid() {\n        return sid;\n    }\n\n    public int getNumberOfOperands() {"}
{"magic_number_smell": "    }\n\n    public final int getSize() {\n        return 9;\n    }\n\n    public final String toFormulaString() {", "refactored_code": "    private static final int SIZE = 9;\n    }\n\n    public final int getSize() {\n        return SIZE;\n    }\n\n    public final String toFormulaString() {"}
{"magic_number_smell": "\n    @Override\n    public void write(LittleEndianOutput out) {\n        out.writeByte(0x3b + getPtgClass());\n        out.writeShort(field_1_index_extern_sheet);\n        writeCoordinates(out);\n    }", "refactored_code": "    public static final byte sid = 0x3b;\n\n    @Override\n    public void write(LittleEndianOutput out) {\n        out.writeByte(sid + getPtgClass());\n        out.writeShort(field_1_index_extern_sheet);\n        writeCoordinates(out);\n    }"}
{"magic_number_smell": "    }\n\n    public void write(LittleEndianOutput out) {\n        out.writeByte(0x2B + getPtgClass());\n        out.writeInt(unused1);\n        out.writeInt(unused2);\n    }", "refactored_code": "    public static final byte sid = 0x2B;\n    }\n\n    public void write(LittleEndianOutput out) {\n        out.writeByte(sid + getPtgClass());\n        out.writeInt(unused1);\n        out.writeInt(unused2);\n    }"}
{"magic_number_smell": "\n    @Override\n    public byte getSid() {\n        return 0x2D;\n    }\n\n    @Override", "refactored_code": "    public static final short sid = 0x2D;\n\n    @Override\n    public byte getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public byte getSid() {\n        return 0x25;\n    }\n\n    @Override", "refactored_code": "    public static final short sid  = 0x25;\n\n    @Override\n    public byte getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public void write(LittleEndianOutput out) {\n        out.writeByte(0x20 + getPtgClass());\n        out.writeInt(_reserved0Int);\n        out.writeShort(_reserved1Short);\n        out.writeByte(_reserved2Byte);", "refactored_code": "    public static final byte sid = 0x20;\n    }\n\n    public void write(LittleEndianOutput out) {\n        out.writeByte(sid + getPtgClass());\n        out.writeInt(_reserved0Int);\n        out.writeShort(_reserved1Short);\n        out.writeByte(_reserved2Byte);"}
{"magic_number_smell": "\n    @Override\n    public void write(LittleEndianOutput out) {\n        out.writeByte(0x19 + getPtgClass());\n        out.writeByte(_options);\n        out.writeShort(_data);\n        int[] jt = _jumpTable;", "refactored_code": "    public static final byte sid  = 0x19;\n\n    @Override\n    public void write(LittleEndianOutput out) {\n        out.writeByte(sid + getPtgClass());\n        out.writeByte(_options);\n        out.writeShort(_data);\n        int[] jt = _jumpTable;"}
{"magic_number_smell": "    }\n\n    public int getSize() {\n        return 2;\n    }\n\n    public String toFormulaString() {", "refactored_code": "    public static final int SIZE = 2;\n    }\n\n    public int getSize() {\n        return SIZE;\n    }\n\n    public String toFormulaString() {"}
{"magic_number_smell": "\n    @Override\n    public byte getSid() {\n        return 0x08;\n    }\n\n    public int getNumberOfOperands() {", "refactored_code": "    public static final byte sid  = 0x08;\n\n    @Override\n    public byte getSid() {\n        return sid;\n    }\n\n    public int getNumberOfOperands() {"}
{"magic_number_smell": "\n    @Override\n    public byte getSid() {\n        return 0x3d;\n    }\n\n    public int getSize() {", "refactored_code": "    public static final byte sid = 0x3d;\n\n    @Override\n    public byte getSid() {\n        return sid;\n    }\n\n    public int getSize() {"}
{"magic_number_smell": "\n    @Override\n    public byte getSid() {\n        return 0x3c;\n    }\n\n    public int getSize() {", "refactored_code": "    public static final byte sid  = 0x3c;\n\n    @Override\n    public byte getSid() {\n        return sid;\n    }\n\n    public int getSize() {"}
{"magic_number_smell": "\n    @Override\n    public byte getSid() {\n        return 0x06;\n    }\n\n    public int getNumberOfOperands() {", "refactored_code": "    public static final byte sid  = 0x06;\n\n    @Override\n    public byte getSid() {\n        return sid;\n    }\n\n    public int getNumberOfOperands() {"}
{"magic_number_smell": "\n    @Override\n    public byte getSid() {\n        return 0x0b;\n    }\n\n    public int getNumberOfOperands() {", "refactored_code": "    public static final byte sid  = 0x0b;\n\n    @Override\n    public byte getSid() {\n        return sid;\n    }\n\n    public int getNumberOfOperands() {"}
{"magic_number_smell": "    }\n\n    public void write(LittleEndianOutput out) {\n        out.writeByte(0x1c + getPtgClass());\n        out.writeByte(field_1_error_code);\n    }\n", "refactored_code": "    public static final short sid  = 0x1c;\n    }\n\n    public void write(LittleEndianOutput out) {\n        out.writeByte(sid + getPtgClass());\n        out.writeByte(field_1_error_code);\n    }\n"}
{"magic_number_smell": "\n    @Override\n    public int getSize() {\n        return 5;\n    }\n\n    public int getRow() {", "refactored_code": "    private static final int  SIZE = 5;\n\n    @Override\n    public int getSize() {\n        return SIZE;\n    }\n\n    public int getRow() {"}
{"magic_number_smell": "\n\n    public void write(LittleEndianOutput out) {\n        out.writeByte(0x21 + getPtgClass());\n        out.writeShort(getFunctionIndex());\n    }\n", "refactored_code": "    public static final byte sid  = 0x21;\n\n\n    public void write(LittleEndianOutput out) {\n        out.writeByte(sid + getPtgClass());\n        out.writeShort(getFunctionIndex());\n    }\n"}
{"magic_number_smell": "    }\n\n    public void write(LittleEndianOutput out) {\n        out.writeByte(0x22 + getPtgClass());\n        out.writeByte(getNumberOfOperands());\n        out.writeShort(getFunctionIndex());\n    }", "refactored_code": "    public static final byte sid  = 0x22;\n    }\n\n    public void write(LittleEndianOutput out) {\n        out.writeByte(sid + getPtgClass());\n        out.writeByte(getNumberOfOperands());\n        out.writeShort(getFunctionIndex());\n    }"}
{"magic_number_smell": "\n    @Override\n    public byte getSid() {\n        return 0x0D;\n    }\n\n    /**", "refactored_code": "    public static final byte sid  = 0x0D;\n\n    @Override\n    public byte getSid() {\n        return sid;\n    }\n\n    /**"}
{"magic_number_smell": "\n    @Override\n    public byte getSid() {\n        return 0x0f;\n    }\n\n    public int getSize() {", "refactored_code": "    public static final byte sid = 0x0f;\n\n    @Override\n    public byte getSid() {\n        return sid;\n    }\n\n    public int getSize() {"}
{"magic_number_smell": "     * {@code IntPtg} can represent.\n     */\n    public static boolean isInRange(int i) {\n        return i >= 0x0000 && i <= MAX_VALUE;\n    }\n\n    public static final int SIZE = 3;", "refactored_code": "    private static final int MIN_VALUE = 0x0000;\n     * {@code IntPtg} can represent.\n     */\n    public static boolean isInRange(int i) {\n        return i >= MIN_VALUE && i <= MAX_VALUE;\n    }\n\n    public static final int SIZE = 3;"}
{"magic_number_smell": "\n    @Override\n    public byte getSid() {\n        return 0x0a;\n    }\n\n    public int getNumberOfOperands() {", "refactored_code": "    public static final byte sid = 0x0a;\n\n    @Override\n    public byte getSid() {\n        return sid;\n    }\n\n    public int getNumberOfOperands() {"}
{"magic_number_smell": "\n    @Override\n    public byte getSid() {\n        return 0x09;\n    }\n\n    /**", "refactored_code": "    public static final byte sid  = 0x09;\n\n    @Override\n    public byte getSid() {\n        return sid;\n    }\n\n    /**"}
{"magic_number_smell": "    }\n\n    public void write(LittleEndianOutput out) {\n        out.writeByte(0x26 + getPtgClass());\n        out.writeInt(field_1_reserved);\n        out.writeShort(field_2_subex_len);\n    }", "refactored_code": "    public static final short sid = 0x26;\n    }\n\n    public void write(LittleEndianOutput out) {\n        out.writeByte(sid + getPtgClass());\n        out.writeInt(field_1_reserved);\n        out.writeShort(field_2_subex_len);\n    }"}
{"magic_number_smell": "    }\n\n    public void write(LittleEndianOutput out) {\n        out.writeByte(0x27 + getPtgClass());\n        out.writeInt(field_1_reserved);\n        out.writeShort(field_2_subex_len);\n    }", "refactored_code": "    public static final short sid = 0x27;\n    }\n\n    public void write(LittleEndianOutput out) {\n        out.writeByte(sid + getPtgClass());\n        out.writeInt(field_1_reserved);\n        out.writeShort(field_2_subex_len);\n    }"}
{"magic_number_smell": "\n    @Override\n    public byte getSid() {\n        return 0x29;\n    }\n\n    public int getSize() {", "refactored_code": "    public static final byte sid = 0x29;\n\n    @Override\n    public byte getSid() {\n        return sid;\n    }\n\n    public int getSize() {"}
{"magic_number_smell": "    }\n\n    public int getSize() {\n        return 1;\n    }\n\n    public String toFormulaString() {", "refactored_code": "    private static final int SIZE = 1;\n    }\n\n    public int getSize() {\n        return SIZE;\n    }\n\n    public String toFormulaString() {"}
{"magic_number_smell": "\n    @Override\n    public byte getSid() {\n        return 0x05;\n    }\n\n    public int getNumberOfOperands() {", "refactored_code": "    public static final byte sid  = 0x05;\n\n    @Override\n    public byte getSid() {\n        return sid;\n    }\n\n    public int getNumberOfOperands() {"}
{"magic_number_smell": "\n    @Override\n    public void write(LittleEndianOutput out) {\n        out.writeByte(0x23 + getPtgClass());\n        out.writeShort(field_1_label_index);\n        out.writeShort(field_2_zero);\n    }", "refactored_code": "    public static final short sid = 0x23;\n\n    @Override\n    public void write(LittleEndianOutput out) {\n        out.writeByte(sid + getPtgClass());\n        out.writeShort(field_1_label_index);\n        out.writeShort(field_2_zero);\n    }"}
{"magic_number_smell": "    }\n\n    public void write(LittleEndianOutput out) {\n        out.writeByte(0x39 + getPtgClass());\n        out.writeShort(_sheetRefIndex);\n        out.writeShort(_nameNumber);\n        out.writeShort(_reserved);", "refactored_code": "    public static final short sid = 0x39;\n    }\n\n    public void write(LittleEndianOutput out) {\n        out.writeByte(sid + getPtgClass());\n        out.writeShort(_sheetRefIndex);\n        out.writeShort(_nameNumber);\n        out.writeShort(_reserved);"}
{"magic_number_smell": "\n    @Override\n    public byte getSid() {\n        return 0x0e;\n    }\n\n    public int getNumberOfOperands() {", "refactored_code": "    public static final byte sid = 0x0e;\n\n    @Override\n    public byte getSid() {\n        return sid;\n    }\n\n    public int getNumberOfOperands() {"}
{"magic_number_smell": "\n    @Override\n    public int getSize() {\n        return 9;\n    }\n\n    @Override", "refactored_code": "    public static final int SIZE = 9;\n\n    @Override\n    public int getSize() {\n        return SIZE;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public int getSize() {\n        return 1;\n    }\n\n    public String toFormulaString() {", "refactored_code": "    private static final int SIZE = 1;\n    }\n\n    public int getSize() {\n        return SIZE;\n    }\n\n    public String toFormulaString() {"}
{"magic_number_smell": "\n    @Override\n    public byte getSid() {\n        return 0x07;\n    }\n\n    public int getNumberOfOperands() {", "refactored_code": "    public static final byte sid  = 0x07;\n\n    @Override\n    public byte getSid() {\n        return sid;\n    }\n\n    public int getNumberOfOperands() {"}
{"magic_number_smell": "    public static final byte CLASS_VALUE = 0x20;\n    public static final byte CLASS_ARRAY = 0x40;\n\n    private byte ptgClass = 0x00; //base ptg\n\n    protected Ptg() {}\n", "refactored_code": "    public static final byte CLASS_REF = 0x00;\n    public static final byte CLASS_VALUE = 0x20;\n    public static final byte CLASS_ARRAY = 0x40;\n\n    private byte ptgClass = CLASS_REF; //base ptg\n\n    protected Ptg() {}\n"}
{"magic_number_smell": "\n    @Override\n    public int getSize() {\n        return 1;\n    }\n\n    @Override", "refactored_code": "    public static final int  SIZE = 1;\n\n    @Override\n    public int getSize() {\n        return SIZE;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public final int getSize() {\n        return 5;\n    }\n}\n", "refactored_code": "    private static final int SIZE = 5;\n\n    @Override\n    public final int getSize() {\n        return SIZE;\n    }\n}\n"}
{"magic_number_smell": "    }\n\n    public void write(LittleEndianOutput out) {\n        out.writeByte(0x3a + getPtgClass());\n        out.writeShort(getExternSheetIndex());\n        writeCoordinates(out);\n    }", "refactored_code": "    public static final byte sid  = 0x3a;\n    }\n\n    public void write(LittleEndianOutput out) {\n        out.writeByte(sid + getPtgClass());\n        out.writeShort(getExternSheetIndex());\n        writeCoordinates(out);\n    }"}
{"magic_number_smell": "\n    @Override\n    public int getSize() {\n        return 5;\n    }\n\n    @Override", "refactored_code": "    private static final int SIZE = 5;\n\n    @Override\n    public int getSize() {\n        return SIZE;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public byte getSid() {\n        return 0x2C;\n    }\n\n    protected final String formatReferenceAsString() {", "refactored_code": "    public static final byte sid = 0x2C;\n\n    @Override\n    public byte getSid() {\n        return sid;\n    }\n\n    protected final String formatReferenceAsString() {"}
{"magic_number_smell": "\n    @Override\n    public byte getSid() {\n        return 0x24;\n    }\n\n    @Override", "refactored_code": "    public static final byte sid = 0x24;\n\n    @Override\n    public byte getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "    }\n\n    public void write(LittleEndianOutput out) {\n        out.writeByte(0x17 + getPtgClass());\n        out.writeByte(field_3_string.length()); // Note - nChars is 8-bit\n        out.writeByte(_is16bitUnicode ? 0x01 : 0x00);\n        if (_is16bitUnicode) {", "refactored_code": "     public static final byte sid = 0x17;\n    }\n\n    public void write(LittleEndianOutput out) {\n        out.writeByte(sid + getPtgClass());\n        out.writeByte(field_3_string.length()); // Note - nChars is 8-bit\n        out.writeByte(_is16bitUnicode ? 0x01 : 0x00);\n        if (_is16bitUnicode) {"}
{"magic_number_smell": "\n    @Override\n    public byte getSid() {\n        return 0x04;\n    }\n\n    public int getNumberOfOperands() {", "refactored_code": "    public static final byte sid  = 0x04;\n\n    @Override\n    public byte getSid() {\n        return sid;\n    }\n\n    public int getNumberOfOperands() {"}
{"magic_number_smell": "    }\n\n    public int getSize() {\n        return 5;\n    }\n\n    public int getRow() {", "refactored_code": "    private static final int  SIZE = 5;\n    }\n\n    public int getSize() {\n        return SIZE;\n    }\n\n    public int getRow() {"}
{"magic_number_smell": "\n    @Override\n    public byte getSid() {\n        return 0x13;\n    }\n\n    public int getNumberOfOperands() {", "refactored_code": "    public static final byte sid  = 0x13;\n\n    @Override\n    public byte getSid() {\n        return sid;\n    }\n\n    public int getNumberOfOperands() {"}
{"magic_number_smell": "\n    @Override\n    public byte getSid() {\n        return 0x12;\n    }\n\n    public int getNumberOfOperands() {", "refactored_code": "    public static final byte sid  = 0x12;\n\n    @Override\n    public byte getSid() {\n        return sid;\n    }\n\n    public int getNumberOfOperands() {"}
{"magic_number_smell": "\n    @Override\n    public byte getSid() {\n        return 0x10;\n    }\n\n    @Override", "refactored_code": "    public static final byte sid  = 0x10;\n\n    @Override\n    public byte getSid() {\n        return sid;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public int getSize() {\n        return 1;\n    }\n\n    @Override", "refactored_code": "    private final short size = 1;\n\n    @Override\n    public int getSize() {\n        return size;\n    }\n\n    @Override"}
{"magic_number_smell": "    public static final int 60 = 60;\n    public static final int MINUTES_PER_HOUR = 60;\n    public static final int HOURS_PER_DAY = 24;\n    public static final int SECONDS_PER_DAY = (HOURS_PER_DAY * MINUTES_PER_HOUR * 60);\n\n    // used to specify that date is invalid\n    private static final int BAD_DATE         = -1;", "refactored_code": "    public static final int SECONDS_PER_MINUTE = 60;\n    public static final int SECONDS_PER_MINUTE = 60;\n    public static final int MINUTES_PER_HOUR = 60;\n    public static final int HOURS_PER_DAY = 24;\n    public static final int SECONDS_PER_DAY = (HOURS_PER_DAY * MINUTES_PER_HOUR * SECONDS_PER_MINUTE);\n\n    // used to specify that date is invalid\n    private static final int BAD_DATE         = -1;"}
{"magic_number_smell": "\n     private static final int values().length = values().values().length;\n     public static FillPatternType forInt(int code) {\n         if (code < 0 || code > values().length) {\n             throw new IllegalArgumentException(\"Invalid FillPatternType code: \" + code);\n         }\n         return values()[code];", "refactored_code": "     private static final int length = values().length;\n\n     private static final int length = values().length;\n     public static FillPatternType forInt(int code) {\n         if (code < 0 || code > length) {\n             throw new IllegalArgumentException(\"Invalid FillPatternType code: \" + code);\n         }\n         return values()[code];"}
{"magic_number_smell": "                }\n            } else if (m.group(1) != null) {\n                int len = m.group(1).length();\n                len = Math.min(len, 4);\n                tmpMax = (int)Math.pow(10, len);\n            } else {\n                tmpExact = 100;", "refactored_code": "    private static final int MAX_DENOM_POW = 4;\n                }\n            } else if (m.group(1) != null) {\n                int len = m.group(1).length();\n                len = Math.min(len, MAX_DENOM_POW);\n                tmpMax = (int)Math.pow(10, len);\n            } else {\n                tmpExact = 100;"}
{"magic_number_smell": "    }\n\n    private static int readUShortAndCheck(RecordInputStream in) {\n        if (in.remaining() < 8) {\n            // Ran out of data\n            throw new IllegalArgumentException(\"Ran out of data reading CellRangeAddress\");\n        }", "refactored_code": "    public static final int ENCODED_SIZE = 8;\n    }\n\n    private static int readUShortAndCheck(RecordInputStream in) {\n        if (in.remaining() < ENCODED_SIZE) {\n            // Ran out of data\n            throw new IllegalArgumentException(\"Ran out of data reading CellRangeAddress\");\n        }"}
{"magic_number_smell": "     * @return code which reflects how the specified range is related to this range.<br>\n     * Possible return codes are:\n     * <ul>\n     *     <li>{@link #1} - the specified range is outside of this range;</li>\n     *     <li>{@link #OVERLAP} - both ranges partially overlap</li>\n     *     <li>{@link #INSIDE} - the specified range is inside of this one</li>\n     *     <li>{@link #ENCLOSES} - the specified range encloses (possibly exactly the same as) this range</li>", "refactored_code": "    public static final int NO_INTERSECTION = 1;\n     * @return code which reflects how the specified range is related to this range.<br>\n     * Possible return codes are:\n     * <ul>\n     *     <li>{@link #NO_INTERSECTION} - the specified range is outside of this range;</li>\n     *     <li>{@link #OVERLAP} - both ranges partially overlap</li>\n     *     <li>{@link #INSIDE} - the specified range is inside of this one</li>\n     *     <li>{@link #ENCLOSES} - the specified range encloses (possibly exactly the same as) this range</li>"}
{"magic_number_smell": "     * @return the top 12 bits (sign and biased exponent value)\n     */\n    public static int getBiasedExponent(long rawBits) {\n        return Math.toIntExact((rawBits & 0x7FF0000000000000L) >> EXPONENT_SHIFT);\n    }\n}\n", "refactored_code": "    private static final long EXPONENT_MASK = 0x7FF0000000000000L;\n     * @return the top 12 bits (sign and biased exponent value)\n     */\n    public static int getBiasedExponent(long rawBits) {\n        return Math.toIntExact((rawBits & EXPONENT_MASK) >> EXPONENT_SHIFT);\n    }\n}\n"}
{"magic_number_smell": "            ? imgSize.getHeight() : anchorSize.getHeight()/EMU_PER_PIXEL * scaleY;\n\n        scaleCell(scaledWidth, anchor.getCol1(), anchor.getDx1(), anchor::setCol2, anchor::setDx2,\n             isHSSF ? 1024 : 0, sheet::getColumnWidthInPixels);\n\n        scaleCell(scaledHeight, anchor.getRow1(), anchor.getDy1(), anchor::setRow2, anchor::setDy2,\n                  isHSSF ? HEIGHT_UNITS : 0, (row) -> getRowHeightInPixels(sheet, row));", "refactored_code": "    private static final int WIDTH_UNITS = 1024;\n            ? imgSize.getHeight() : anchorSize.getHeight()/EMU_PER_PIXEL * scaleY;\n\n        scaleCell(scaledWidth, anchor.getCol1(), anchor.getDx1(), anchor::setCol2, anchor::setDx2,\n             isHSSF ? WIDTH_UNITS : 0, sheet::getColumnWidthInPixels);\n\n        scaleCell(scaledHeight, anchor.getRow1(), anchor.getDy1(), anchor::setRow2, anchor::setDy2,\n                  isHSSF ? HEIGHT_UNITS : 0, (row) -> getRowHeightInPixels(sheet, row));"}
{"magic_number_smell": "    }\n    public void normalise64bit() {\n        int oldBitLen = _significand.bitLength();\n        int sc = oldBitLen - 64;\n        if (sc == 0) {\n            return;\n        }", "refactored_code": "    private static final int C_64 = 64;\n    }\n    public void normalise64bit() {\n        int oldBitLen = _significand.bitLength();\n        int sc = oldBitLen - C_64;\n        if (sc == 0) {\n            return;\n        }"}
{"magic_number_smell": "     * @return the number of powers of 10 which have been extracted from the significand and binary exponent.\n     */\n    public int getDecimalExponent() {\n        return _relativeDecimalExponent+14;\n    }\n\n    /**", "refactored_code": "    private static final int EXPONENT_OFFSET = 14;\n     * @return the number of powers of 10 which have been extracted from the significand and binary exponent.\n     */\n    public int getDecimalExponent() {\n        return _relativeDecimalExponent+EXPONENT_OFFSET;\n    }\n\n    /**"}
{"magic_number_smell": "            // Special number NaN /Infinity\n            // Normally one would not create HybridDecimal objects from these values\n            // except in these cases Excel really tries to render them as if they were normal numbers\n            if(rawBits == 0xFFFF0420003C0000L) {\n                return \"3.484840871308E+308\";\n            }\n            // This is where excel really gets it wrong", "refactored_code": "    private static final long EXCEL_NAN_BITS = 0xFFFF0420003C0000L;\n            // Special number NaN /Infinity\n            // Normally one would not create HybridDecimal objects from these values\n            // except in these cases Excel really tries to render them as if they were normal numbers\n            if(rawBits == EXCEL_NAN_BITS) {\n                return \"3.484840871308E+308\";\n            }\n            // This is where excel really gets it wrong"}
{"magic_number_smell": "            AffineTransform trans = new AffineTransform();\n            trans.concatenate(AffineTransform.getRotateInstance(style.getRotation()*2.0*Math.PI/360.0));\n            trans.concatenate(\n                    AffineTransform.getScaleInstance(1, 2.0)\n            );\n            bounds = layout.getOutline(trans).getBounds();\n        } else {", "refactored_code": "    private static final double fontHeightMultiple = 2.0;\n            AffineTransform trans = new AffineTransform();\n            trans.concatenate(AffineTransform.getRotateInstance(style.getRotation()*2.0*Math.PI/360.0));\n            trans.concatenate(\n                    AffineTransform.getScaleInstance(1, fontHeightMultiple)\n            );\n            bounds = layout.getOutline(trans).getBounds();\n        } else {"}
{"magic_number_smell": "    public ByteField(final int offset)\n        throws ArrayIndexOutOfBoundsException\n    {\n        this(offset, 0);\n    }\n\n    /**", "refactored_code": "    private static final byte _default_value = 0;\n    public ByteField(final int offset)\n        throws ArrayIndexOutOfBoundsException\n    {\n        this(offset, _default_value);\n    }\n\n    /**"}
{"magic_number_smell": "                return \"UTF-16BE\";\n            case CP_UTF8:\n                return \"UTF-8\";\n            case 37:\n                return \"cp037\";\n            case CP_GBK:\n                return \"GBK\";", "refactored_code": "    public static final int CP_037 = 37;\n                return \"UTF-16BE\";\n            case CP_UTF8:\n                return \"UTF-8\";\n            case CP_037:\n                return \"cp037\";\n            case CP_GBK:\n                return \"GBK\";"}
{"magic_number_smell": "\n    public IntList()\n    {\n        this(128);\n    }\n\n    public IntList(final int initialCapacity)", "refactored_code": "    private static final int _default_size = 128;\n\n    public IntList()\n    {\n        this(_default_size);\n    }\n\n    public IntList(final int initialCapacity)"}
{"magic_number_smell": "     * create an IntMapper of default size\n     */\n    public IntMapper() {\n        this(10);\n    }\n\n    public IntMapper(final int initialCapacity) {", "refactored_code": "    private static final int _default_size = 10;\n     * create an IntMapper of default size\n     */\n    public IntMapper() {\n        this(_default_size);\n    }\n\n    public IntMapper(final int initialCapacity) {"}
{"magic_number_smell": "            return 0L;\n        }\n        // use dedicated buffer to avoid having other threads possibly access the bytes in a shared byte array\n        final byte[] skipBuffer = new byte[2048];\n        long remain = toSkip;\n        while (remain > 0) {\n            // See https://issues.apache.org/jira/browse/IO-203 for why we use read() rather than delegating to skip()", "refactored_code": "    private static final int SKIP_BUFFER_SIZE = 2048;\n            return 0L;\n        }\n        // use dedicated buffer to avoid having other threads possibly access the bytes in a shared byte array\n        final byte[] skipBuffer = new byte[SKIP_BUFFER_SIZE];\n        long remain = toSkip;\n        while (remain > 0) {\n            // See https://issues.apache.org/jira/browse/IO-203 for why we use read() rather than delegating to skip()"}
{"magic_number_smell": "    private int markIndex = -1;\n\n    public LittleEndianInputStream(InputStream is) {\n        super(is.markSupported() ? is : new BufferedInputStream(is, 8096));\n    }\n\n    @Override", "refactored_code": "    private static final int BUFFERED_SIZE = 8096;\n    private int markIndex = -1;\n\n    public LittleEndianInputStream(InputStream is) {\n        super(is.markSupported() ? is : new BufferedInputStream(is, BUFFERED_SIZE));\n    }\n\n    @Override"}
{"magic_number_smell": "        // * 256-4095 are the substring codes\n        // Java handily initialises our buffer / dictionary\n        //  to all zeros\n        final byte[] buffer = new byte[0x1000];\n        pos = populateDictionary(buffer);\n\n        // These are bytes as looked up in the dictionary", "refactored_code": "    public static final int DICT_SIZE = 0x1000;\n        // * 256-4095 are the substring codes\n        // Java handily initialises our buffer / dictionary\n        //  to all zeros\n        final byte[] buffer = new byte[DICT_SIZE];\n        pos = populateDictionary(buffer);\n\n        // These are bytes as looked up in the dictionary"}
{"magic_number_smell": "public final class StringUtil {\n    //arbitrarily selected; may need to increase\n    private static final int 10000000 = 10000000;\n    private static int MAX_RECORD_LENGTH = 10000000;\n\n    public static final Charset UTF16LE = StandardCharsets.UTF_16LE;\n    public static final Charset UTF8 = StandardCharsets.UTF_8;", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 10000000;\npublic final class StringUtil {\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 10000000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    public static final Charset UTF16LE = StandardCharsets.UTF_16LE;\n    public static final Charset UTF8 = StandardCharsets.UTF_8;"}
{"magic_number_smell": "     * One character is defined as the widest value for the integers 0-9 in the\n     * default font.\n     */\n    public static final int EMU_PER_CHARACTER = (int) (9525 * DEFAULT_CHARACTER_WIDTH);\n\n    /**\n     * Converts points to EMUs", "refactored_code": "    public static final int EMU_PER_PIXEL = 9525;\n     * One character is defined as the widest value for the integers 0-9 in the\n     * default font.\n     */\n    public static final int EMU_PER_CHARACTER = (int) (EMU_PER_PIXEL * DEFAULT_CHARACTER_WIDTH);\n\n    /**\n     * Converts points to EMUs"}
{"magic_number_smell": "        for (int i = 0; i < 2; i++) {\n            byte[] b = poiFiles.get(i).getBytes();\n            PropertySet ps = PropertySetFactory.create(new ByteArrayInputStream(b));\n            assertEquals(0xfffe, ps.getByteOrder());\n            assertEquals(FORMAT, ps.getFormat());\n            assertEquals(OS_VERSION, ps.getOSVersion());\n            assertEquals(CLASS_ID, ps.getClassID());", "refactored_code": "    private static final int BYTE_ORDER   = 0xfffe;\n        for (int i = 0; i < 2; i++) {\n            byte[] b = poiFiles.get(i).getBytes();\n            PropertySet ps = PropertySetFactory.create(new ByteArrayInputStream(b));\n            assertEquals(BYTE_ORDER, ps.getByteOrder());\n            assertEquals(FORMAT, ps.getFormat());\n            assertEquals(OS_VERSION, ps.getOSVersion());\n            assertEquals(CLASS_ID, ps.getClassID());"}
{"magic_number_smell": "     */\n    @Test\n    void variantTypes() throws Exception {\n        final int codepage = -1;\n        Assumptions.assumeTrue(hasProperDefaultCharset(), IMPROPER_DEFAULT_CHARSET_MESSAGE);\n\n        check(Variant.VT_EMPTY, null, codepage);", "refactored_code": "    private static final int CODEPAGE_DEFAULT = -1;\n     */\n    @Test\n    void variantTypes() throws Exception {\n        final int codepage = CODEPAGE_DEFAULT;\n        Assumptions.assumeTrue(hasProperDefaultCharset(), IMPROPER_DEFAULT_CHARSET_MESSAGE);\n\n        check(Variant.VT_EMPTY, null, codepage);"}
{"magic_number_smell": "\n        si.setApplicationName(P_APPLICATION_NAME);\n        si.setAuthor(P_AUTHOR);\n        si.setCharCount(4712);\n        si.setComments(P_COMMENTS);\n        si.setCreateDateTime(P_CREATE_DATE_TIME);\n        si.setEditTime(P_EDIT_TIME);", "refactored_code": "    private static final int    P_CHAR_COUNT = 4712;\n\n        si.setApplicationName(P_APPLICATION_NAME);\n        si.setAuthor(P_AUTHOR);\n        si.setCharCount(P_CHAR_COUNT);\n        si.setComments(P_COMMENTS);\n        si.setCreateDateTime(P_CREATE_DATE_TIME);\n        si.setEditTime(P_EDIT_TIME);"}
{"magic_number_smell": "        // perhaps this code should be moved to HexDump\n        int globalStart = globalOffset + baseDataOffset;\n        int globalEnd = globalOffset + baseDataOffset + dumpLen;\n        int startDelta = globalStart % 16;\n        int endDelta = globalEnd % 16;\n        if (zeroAlignRecord) {\n            endDelta -= startDelta;", "refactored_code": "    private static final int DUMP_LINE_LEN = 16;\n        // perhaps this code should be moved to HexDump\n        int globalStart = globalOffset + baseDataOffset;\n        int globalEnd = globalOffset + baseDataOffset + dumpLen;\n        int startDelta = globalStart % DUMP_LINE_LEN;\n        int endDelta = globalEnd % DUMP_LINE_LEN;\n        if (zeroAlignRecord) {\n            endDelta -= startDelta;"}
{"magic_number_smell": "\nfinal class TestDrawingGroupRecord {\n    private static final int DrawingGroupRecord.getMaxRecordSize() = DrawingGroupRecord.getMaxRecordSize();\n    private static final int MAX_DATA_SIZE = DrawingGroupRecord.getMaxRecordSize() - 4;\n\n    @Test\n    void testGetRecordSize() {", "refactored_code": "    private static final int MAX_RECORD_SIZE = DrawingGroupRecord.getMaxRecordSize();\n\nfinal class TestDrawingGroupRecord {\n    private static final int MAX_RECORD_SIZE = DrawingGroupRecord.getMaxRecordSize();\n    private static final int MAX_DATA_SIZE = MAX_RECORD_SIZE - 4;\n\n    @Test\n    void testGetRecordSize() {"}
{"magic_number_smell": "\n        byte[] src = hr(data1);\n\n        RecordInputStream in = TestcaseRecordInputStream.create(EmbeddedObjectRefSubRecord.sid, src);\n\n        EmbeddedObjectRefSubRecord record1 = new EmbeddedObjectRefSubRecord(in, src.length);\n", "refactored_code": "    private static final short EORSR_SID = EmbeddedObjectRefSubRecord.sid;\n\n        byte[] src = hr(data1);\n\n        RecordInputStream in = TestcaseRecordInputStream.create(EORSR_SID, src);\n\n        EmbeddedObjectRefSubRecord record1 = new EmbeddedObjectRefSubRecord(in, src.length);\n"}
{"magic_number_smell": "                + \"00\" // unicode options byte\n                );\n\n        RecordInputStream in = TestcaseRecordInputStream.create(0x31, emptyNameData);\n        FontRecord fr = new FontRecord(in);\n        assertNotEquals(1, in.available());\n        assertEquals(0, in.available());", "refactored_code": "    private static final int SID = 0x31;\n                + \"00\" // unicode options byte\n                );\n\n        RecordInputStream in = TestcaseRecordInputStream.create(SID, emptyNameData);\n        FontRecord fr = new FontRecord(in);\n        assertNotEquals(1, in.available());\n        assertEquals(0, in.available());"}
{"magic_number_smell": "\n    @Test\n    void testSpanRichTextToPlainText() throws IOException {\n        byte[] header = readSampleHexData(\"richtextdata.txt\", \"header\", -5555);\n        byte[] continueBytes = readSampleHexData(\"richtextdata.txt\", \"continue1\", ContinueRecord.sid);\n        RecordInputStream in = TestcaseRecordInputStream.create(concat(header, continueBytes));\n", "refactored_code": "    private static final int FAKE_SID = -5555;\n\n    @Test\n    void testSpanRichTextToPlainText() throws IOException {\n        byte[] header = readSampleHexData(\"richtextdata.txt\", \"header\", FAKE_SID);\n        byte[] continueBytes = readSampleHexData(\"richtextdata.txt\", \"continue1\", ContinueRecord.sid);\n        RecordInputStream in = TestcaseRecordInputStream.create(concat(header, continueBytes));\n"}
{"magic_number_smell": "    void testBasic() {\n        strings.add(makeUnicodeString(SMALL_STRING));\n        confirmSize(SST_RECORD_OVERHEAD\n                + 3\n                + SMALL_STRING.length());\n    }\n", "refactored_code": "    private static final int COMPRESSED_PLAIN_STRING_OVERHEAD = 3;\n    void testBasic() {\n        strings.add(makeUnicodeString(SMALL_STRING));\n        confirmSize(SST_RECORD_OVERHEAD\n                + COMPRESSED_PLAIN_STRING_OVERHEAD\n                + SMALL_STRING.length());\n    }\n"}
{"magic_number_smell": "    void testPartiallyOverlappingRanges() {\n\n\n        for (int attempt=1; attempt < 5; attempt++) {\n            HSSFWorkbook wb = HSSFTestDataSamples.openSampleWorkbook(SAMPLE_FILE_NAME);\n\n            HSSFSheet sheet = wb.getSheetAt(0);", "refactored_code": "    private static final int MAX_ATTEMPTS=5;\n    void testPartiallyOverlappingRanges() {\n\n\n        for (int attempt=1; attempt < MAX_ATTEMPTS; attempt++) {\n            HSSFWorkbook wb = HSSFTestDataSamples.openSampleWorkbook(SAMPLE_FILE_NAME);\n\n            HSSFSheet sheet = wb.getSheetAt(0);"}
{"magic_number_smell": "     * Note - a value of zero for {@code amountUsedInCurrentRecord} would only ever occur just\n     * after a {@link ContinueRecord} had been started.  In the initial {@link SSTRecord} this\n     * value starts at 8 (for the first {@link UnicodeString} written).  In general, it can be\n     * any value between 0 and {@link #RecordInputStream.MAX_RECORD_DATA_SIZE}\n     */\n    private static void confirmSize(int expectedSize, UnicodeString s, int amountUsedInCurrentRecord) {\n        ContinuableRecordOutput out = ContinuableRecordOutput.createForCountingOnly();", "refactored_code": "    private static final int MAX_DATA_SIZE = RecordInputStream.MAX_RECORD_DATA_SIZE;\n     * Note - a value of zero for {@code amountUsedInCurrentRecord} would only ever occur just\n     * after a {@link ContinueRecord} had been started.  In the initial {@link SSTRecord} this\n     * value starts at 8 (for the first {@link UnicodeString} written).  In general, it can be\n     * any value between 0 and {@link #MAX_DATA_SIZE}\n     */\n    private static void confirmSize(int expectedSize, UnicodeString s, int amountUsedInCurrentRecord) {\n        ContinuableRecordOutput out = ContinuableRecordOutput.createForCountingOnly();"}
{"magic_number_smell": "    private byte[] _workbook_data;\n    private static final int 5000 = 5000;\n\n    // non-even division of 5000, also non-even division of\n    // any block size\n    private static final int _buffer_size = 6;\n", "refactored_code": "    private static final int _workbook_size = 5000;\n    private byte[] _workbook_data;\n    private static final int _workbook_size = 5000;\n\n    // non-even division of _workbook_size, also non-even division of\n    // any block size\n    private static final int _buffer_size = 6;\n"}
{"magic_number_smell": "        row5.createCell(2).setCellFormula(\"rowFormula\");\n\n        FormulaEvaluator fe = wb.getCreationHelper().createFormulaEvaluator();\n        assertEquals(3.14, fe.evaluate(row0.getCell(2)).getNumberValue(), 0.0000001);\n        assertEquals(10.0, fe.evaluate(row1.getCell(2)).getNumberValue(), 0.0000001);\n        assertEquals(15.0, fe.evaluate(row2.getCell(2)).getNumberValue(), 0.0000001);\n        assertEquals(28.14, fe.evaluate(row3.getCell(2)).getNumberValue(), 0.0000001);", "refactored_code": "    private static final double EPSILON = 0.0000001;\n        row5.createCell(2).setCellFormula(\"rowFormula\");\n\n        FormulaEvaluator fe = wb.getCreationHelper().createFormulaEvaluator();\n        assertEquals(3.14, fe.evaluate(row0.getCell(2)).getNumberValue(), EPSILON);\n        assertEquals(10.0, fe.evaluate(row1.getCell(2)).getNumberValue(), EPSILON);\n        assertEquals(15.0, fe.evaluate(row2.getCell(2)).getNumberValue(), EPSILON);\n        assertEquals(28.14, fe.evaluate(row3.getCell(2)).getNumberValue(), EPSILON);"}
{"magic_number_smell": "        double startDate = makeDate(row, SS.START_YEAR_COLUMN);\n        double endDate = makeDate(row, SS.END_YEAR_COLUMN);\n\n        int basis = getIntCell(row, SS.1);\n\n        double expectedValue = getDoubleCell(row, SS.EXPECTED_RESULT_COLUMN);\n", "refactored_code": "        public static final int BASIS_COLUMN = 1; // \"B\"\n        double startDate = makeDate(row, SS.START_YEAR_COLUMN);\n        double endDate = makeDate(row, SS.END_YEAR_COLUMN);\n\n        int basis = getIntCell(row, SS.BASIS_COLUMN);\n\n        double expectedValue = getDoubleCell(row, SS.EXPECTED_RESULT_COLUMN);\n"}
{"magic_number_smell": "    void testSimpleOperators() {\n\n        // unary plus is a no-op\n        checkEval(-0.0, UnaryPlusEval.instance, -0.0);\n\n        // most simple operators convert -0.0 to +0.0\n        checkEval(0.0, EvalInstances.UnaryMinus, 0.0);", "refactored_code": "    private static final double MINUS_ZERO = -0.0;\n    void testSimpleOperators() {\n\n        // unary plus is a no-op\n        checkEval(MINUS_ZERO, UnaryPlusEval.instance, MINUS_ZERO);\n\n        // most simple operators convert -0.0 to +0.0\n        checkEval(0.0, EvalInstances.UnaryMinus, 0.0);"}
{"magic_number_smell": "        funcs = FunctionEval.getSupportedFunctionNames();\n\n        List<Arguments> data = new ArrayList<>();\n        for (int rowIndex = SS.10;true;rowIndex++) {\n            Row r = sheet.getRow(rowIndex);\n\n            // only evaluate non empty row", "refactored_code": "        public static final int START_FUNCTIONS_ROW_INDEX = 10; // Row '11'\n        funcs = FunctionEval.getSupportedFunctionNames();\n\n        List<Arguments> data = new ArrayList<>();\n        for (int rowIndex = SS.START_FUNCTIONS_ROW_INDEX;true;rowIndex++) {\n            Row r = sheet.getRow(rowIndex);\n\n            // only evaluate non empty row"}
{"magic_number_smell": "                    case CHAR_NDASH_8211:\n                        sb.append('-');\n                        continue;\n                    case 8230:\n                        sb.append(\"...\");\n                        continue;\n                }", "refactored_code": "        private static final int CHAR_ELLIPSIS_8230 = 8230;\n                    case CHAR_NDASH_8211:\n                        sb.append('-');\n                        continue;\n                    case CHAR_ELLIPSIS_8230:\n                        sb.append(\"...\");\n                        continue;\n                }"}
{"magic_number_smell": "                    case CHAR_NDASH_8211:\n                        sb.append('-');\n                        continue;\n                    case 8230:\n                        sb.append(\"...\");\n                        continue;\n                }", "refactored_code": "        private static final int CHAR_ELLIPSIS_8230 = 8230;\n                    case CHAR_NDASH_8211:\n                        sb.append('-');\n                        continue;\n                    case CHAR_ELLIPSIS_8230:\n                        sb.append(\"...\");\n                        continue;\n                }"}
{"magic_number_smell": "    }\n\n    public static void assertDouble(String msg, double baseval, double checkval) {\n        assertDouble(msg, baseval, checkval, 1E-4, DIFF_TOLERANCE_FACTOR);\n    }\n\n", "refactored_code": "    public static final double POS_ZERO = 1E-4;\n    }\n\n    public static void assertDouble(String msg, double baseval, double checkval) {\n        assertDouble(msg, baseval, checkval, POS_ZERO, DIFF_TOLERANCE_FACTOR);\n    }\n\n"}
{"magic_number_smell": "\n    @Test\n    void testEOMonthBadDateValues() {\n        checkValue(0.0, -2, -1.0);\n        checkValue(0.0, -3, -1.0);\n        checkValue(DATE_1900_01_31, -1, -1.0);\n    }", "refactored_code": "    private static final double BAD_DATE = -1.0;\n\n    @Test\n    void testEOMonthBadDateValues() {\n        checkValue(0.0, -2, BAD_DATE);\n        checkValue(0.0, -3, BAD_DATE);\n        checkValue(DATE_1900_01_31, -1, BAD_DATE);\n    }"}
{"magic_number_smell": "\n        NumberEval myResult = (NumberEval)invokePoisson(x,mean,true);\n\n        assertEquals(myResult.getNumberValue(), result, 1E-15);\n    }\n\n    @Test", "refactored_code": "    private static final double DELTA = 1E-15;\n\n        NumberEval myResult = (NumberEval)invokePoisson(x,mean,true);\n\n        assertEquals(myResult.getNumberValue(), result, DELTA);\n    }\n\n    @Test"}
{"magic_number_smell": "    @Test\n    void testBasics() {\n        confirmSubtotal(FUNCTION_SUM, 55.0);\n        confirmSubtotal(1, 5.5);\n        confirmSubtotal(FUNCTION_COUNT, 10.0);\n        confirmSubtotal(FUNCTION_MAX, 10.0);\n        confirmSubtotal(FUNCTION_MIN, 1.0);", "refactored_code": "    private static final int FUNCTION_AVERAGE = 1;\n    @Test\n    void testBasics() {\n        confirmSubtotal(FUNCTION_SUM, 55.0);\n        confirmSubtotal(FUNCTION_AVERAGE, 5.5);\n        confirmSubtotal(FUNCTION_COUNT, 10.0);\n        confirmSubtotal(FUNCTION_MAX, 10.0);\n        confirmSubtotal(FUNCTION_MIN, 1.0);"}
{"magic_number_smell": "final class TestTime {\n\n    private static final int 60 = 60;\n    private static final int SECONDS_PER_HOUR = 60 * 60;\n    private static final double SECONDS_PER_DAY = 24 * SECONDS_PER_HOUR;\n    private HSSFCell cell11;\n    private HSSFFormulaEvaluator evaluator;", "refactored_code": "    private static final int SECONDS_PER_MINUTE = 60;\nfinal class TestTime {\n\n    private static final int SECONDS_PER_MINUTE = 60;\n    private static final int SECONDS_PER_HOUR = 60 * SECONDS_PER_MINUTE;\n    private static final double SECONDS_PER_DAY = 24 * SECONDS_PER_HOUR;\n    private HSSFCell cell11;\n    private HSSFFormulaEvaluator evaluator;"}
{"magic_number_smell": "        String formula = \"WEEKDAY(\" + serial_number + \")\";\n        ValueEval[] args = new ValueEval[] { new NumberEval(serial_number) };\n        NumberEval result = (NumberEval) WeekdayFunc.instance.evaluate(args, 0, 0);\n        assertEquals(expected, result.getNumberValue(), 0.001, formula);\n    }\n    private void assertEvaluateEquals(double expected, double serial_number, double return_type) {\n        String formula = \"WEEKDAY(\" + serial_number + \", \" + return_type + \")\";", "refactored_code": "    private static final double TOLERANCE = 0.001;\n        String formula = \"WEEKDAY(\" + serial_number + \")\";\n        ValueEval[] args = new ValueEval[] { new NumberEval(serial_number) };\n        NumberEval result = (NumberEval) WeekdayFunc.instance.evaluate(args, 0, 0);\n        assertEquals(expected, result.getNumberValue(), TOLERANCE, formula);\n    }\n    private void assertEvaluateEquals(double expected, double serial_number, double return_type) {\n        String formula = \"WEEKDAY(\" + serial_number + \", \" + return_type + \")\";"}
{"magic_number_smell": "        ValueEval[] args = new ValueEval[] { new NumberEval(dateValue) };\n        ValueEval result = WeekNum.instance.evaluate(args, DEFAULT_CONTEXT);\n        assertTrue(result instanceof NumberEval);\n        assertEquals(expected, ((NumberEval)result).getNumberValue(), 0.001, formula);\n    }\n\n    private void assertEvaluateEquals(double expected, double dateValue, double return_type) {", "refactored_code": "    private static final double TOLERANCE = 0.001;\n        ValueEval[] args = new ValueEval[] { new NumberEval(dateValue) };\n        ValueEval result = WeekNum.instance.evaluate(args, DEFAULT_CONTEXT);\n        assertTrue(result instanceof NumberEval);\n        assertEquals(expected, ((NumberEval)result).getNumberValue(), TOLERANCE, formula);\n    }\n\n    private void assertEvaluateEquals(double expected, double dateValue, double return_type) {"}
{"magic_number_smell": "\n            sheet.showInPane(0, 0);\n\n            for (int i = 40000 / 2; i < 40000; i++) {\n                sheet.createRow(i);\n                sheet.showInPane(i, 0);\n                // this one fails: sheet.showInPane((short)i, 0);", "refactored_code": "    private static final int ROW_COUNT = 40000;\n\n            sheet.showInPane(0, 0);\n\n            for (int i = ROW_COUNT / 2; i < ROW_COUNT; i++) {\n                sheet.createRow(i);\n                sheet.showInPane(i, 0);\n                // this one fails: sheet.showInPane((short)i, 0);"}
{"magic_number_smell": "        DataFormatter formatter = new DataFormatter();\n        String format = \"[h]\\\"\\\"h\\\"\\\" m\\\"\\\"m\\\"\\\"\";\n        assertTrue(DateUtil.isADateFormat(-1,format));\n        assertTrue(DateUtil.isValidExcelDate(0.041666667));\n\n        assertEquals(\"1h 0m\", formatter.formatRawCellContents(0.041666667, -1, format, false));\n        assertEquals(\"0.041666667\", formatter.formatRawCellContents(0.041666667, -1, \"[h]'h'\", false));", "refactored_code": "    private static final double _15_MINUTES = 0.041666667;\n        DataFormatter formatter = new DataFormatter();\n        String format = \"[h]\\\"\\\"h\\\"\\\" m\\\"\\\"m\\\"\\\"\";\n        assertTrue(DateUtil.isADateFormat(-1,format));\n        assertTrue(DateUtil.isValidExcelDate(_15_MINUTES));\n\n        assertEquals(\"1h 0m\", formatter.formatRawCellContents(_15_MINUTES, -1, format, false));\n        assertEquals(\"0.041666667\", formatter.formatRawCellContents(_15_MINUTES, -1, \"[h]'h'\", false));"}
{"magic_number_smell": "     * is expected and selected via an index\n     */\n    private static int localeIndex(Locale locale) {\n        return POITestCase.getJDKVersion() < 9 ||\n            !locale.equals (Locale.CHINESE) ||\n            (provider != null && (provider.startsWith(\"JRE\") || provider.startsWith(\"COMPAT\")))\n            ? 0 : 1;", "refactored_code": "    private static final int jreVersion = POITestCase.getJDKVersion();\n     * is expected and selected via an index\n     */\n    private static int localeIndex(Locale locale) {\n        return jreVersion < 9 ||\n            !locale.equals (Locale.CHINESE) ||\n            (provider != null && (provider.startsWith(\"JRE\") || provider.startsWith(\"COMPAT\")))\n            ? 0 : 1;"}
{"magic_number_smell": "        assertEquals(DEFAULT_COLOR, getCellStyle(0, 0).getTopBorderColor());\n        assertEquals(DEFAULT_COLOR, getCellStyle(0, 1).getTopBorderColor());\n        assertEquals(DEFAULT_COLOR, getCellStyle(0, 2).getTopBorderColor());\n        RegionUtil.setTopBorderColor(IndexedColors.RED.getIndex(), A1C3, sheet);\n        assertEquals(IndexedColors.RED.getIndex(), getCellStyle(0, 0).getTopBorderColor());\n        assertEquals(IndexedColors.RED.getIndex(), getCellStyle(0, 1).getTopBorderColor());\n        assertEquals(IndexedColors.RED.getIndex(), getCellStyle(0, 2).getTopBorderColor());", "refactored_code": "    private static final int RED = IndexedColors.RED.getIndex();\n        assertEquals(DEFAULT_COLOR, getCellStyle(0, 0).getTopBorderColor());\n        assertEquals(DEFAULT_COLOR, getCellStyle(0, 1).getTopBorderColor());\n        assertEquals(DEFAULT_COLOR, getCellStyle(0, 2).getTopBorderColor());\n        RegionUtil.setTopBorderColor(RED, A1C3, sheet);\n        assertEquals(RED, getCellStyle(0, 0).getTopBorderColor());\n        assertEquals(RED, getCellStyle(0, 1).getTopBorderColor());\n        assertEquals(RED, getCellStyle(0, 2).getTopBorderColor());"}
{"magic_number_smell": "     * Based upon the method described in: http://www.javaworld.com/javaworld/javatips/jw-javatip130.html\n     */\n    public void assertGarbageCollected() {\n        assertGarbageCollected(50);\n    }\n\n    /**", "refactored_code": "    private static final int MAX_GC_ITERATIONS = 50;\n     * Based upon the method described in: http://www.javaworld.com/javaworld/javatips/jw-javatip130.html\n     */\n    public void assertGarbageCollected() {\n        assertGarbageCollected(MAX_GC_ITERATIONS);\n    }\n\n    /**"}
{"magic_number_smell": "    public static void setUp() throws IOException {\n        TMP = File.createTempFile(\"poi-ioutils-\", \"\");\n        try (OutputStream os = new FileOutputStream(TMP)) {\n            for (int i = 0; i < 300 + RandomSingleton.getInstance().nextInt(9000); i++) {\n                os.write(0x01);\n            }\n        }", "refactored_code": "    private static final long LENGTH = 300 + RandomSingleton.getInstance().nextInt(9000);\n    public static void setUp() throws IOException {\n        TMP = File.createTempFile(\"poi-ioutils-\", \"\");\n        try (OutputStream os = new FileOutputStream(TMP)) {\n            for (int i = 0; i < LENGTH; i++) {\n                os.write(0x01);\n            }\n        }"}
{"magic_number_smell": "    }\n\n    private static BufferedImage getPattern() {\n        return HwmfGraphics.getPatternFromLong(0xAADDAA55AADDAA55L, Color.BLACK, Color.WHITE, false);\n    }\n\n    private static BufferedImage getSource() {", "refactored_code": "    private static final long PATTERN = 0xAADDAA55AADDAA55L;\n    }\n\n    private static BufferedImage getPattern() {\n        return HwmfGraphics.getPatternFromLong(PATTERN, Color.BLACK, Color.WHITE, false);\n    }\n\n    private static BufferedImage getSource() {"}
{"magic_number_smell": "     *                         the cell referenced by the cellNumber parameter.\n     *                         Four constants are provided to determine what\n     *                         should happen;\n     *                         AddDimensionedImage.1\n     *                         AddDimensionedImage.EXPAND_COLUMN\n     *                         AddDimensionedImage.EXPAND_ROW_AND_COLUMN\n     *                         AddDimensionedImage.OVERLAY_ROW_AND_COLUMN", "refactored_code": "    public static final int EXPAND_ROW = 1;\n     *                         the cell referenced by the cellNumber parameter.\n     *                         Four constants are provided to determine what\n     *                         should happen;\n     *                         AddDimensionedImage.EXPAND_ROW\n     *                         AddDimensionedImage.EXPAND_COLUMN\n     *                         AddDimensionedImage.EXPAND_ROW_AND_COLUMN\n     *                         AddDimensionedImage.OVERLAY_ROW_AND_COLUMN"}
{"magic_number_smell": "        // that certain embedded characters are escaped in accordance with\n        // Excel's formatting conventions\n        this.convertExcelToCSV(strSource, strDestination,\n                ToCSV.DEFAULT_SEPARATOR, ToCSV.0);\n    }\n\n    /**", "refactored_code": "    public static final int EXCEL_STYLE_ESCAPING = 0;\n        // that certain embedded characters are escaped in accordance with\n        // Excel's formatting conventions\n        this.convertExcelToCSV(strSource, strDestination,\n                ToCSV.DEFAULT_SEPARATOR, ToCSV.EXCEL_STYLE_ESCAPING);\n    }\n\n    /**"}
{"magic_number_smell": "    public void printSheet(Sheet sheet) {\n        ensureOut();\n        Map<Integer, Integer> widths = computeWidths(sheet);\n        int tableWidth = widths.get(-2);\n        out.format(\"<table class=%s style=\\\"width:%dpx;\\\">%n\", DEFAULTS_CLASS, tableWidth);\n        printCols(widths);\n        printSheetContent(sheet);", "refactored_code": "    private static final int IDX_TABLE_WIDTH = -2;\n    public void printSheet(Sheet sheet) {\n        ensureOut();\n        Map<Integer, Integer> widths = computeWidths(sheet);\n        int tableWidth = widths.get(IDX_TABLE_WIDTH);\n        out.format(\"<table class=%s style=\\\"width:%dpx;\\\">%n\", DEFAULTS_CLASS, tableWidth);\n        printCols(widths);\n        printSheetContent(sheet);"}
{"magic_number_smell": "            row.createCell(2).setCellValue(\"Lines\");\n\n            XSSFCell cell;\n            for (int r = 1; r < 7; r++) {\n                row = sheet.createRow(r);\n                cell = row.createCell(0);\n                cell.setCellValue(\"C\" + r);", "refactored_code": "    private static final int NUM_OF_ROWS = 7;\n            row.createCell(2).setCellValue(\"Lines\");\n\n            XSSFCell cell;\n            for (int r = 1; r < NUM_OF_ROWS; r++) {\n                row = sheet.createRow(r);\n                cell = row.createCell(0);\n                cell.setCellValue(\"C\" + r);"}
{"magic_number_smell": "        for (int c : chartedCols) {\n            // the data sources\n            XDDFCategoryDataSource xs = XDDFDataSourcesFactory.fromStringCellRange(sheet,\n                    new CellRangeAddress(1, 6, 0, 0));\n            XDDFNumericalDataSource<Double> ys = XDDFDataSourcesFactory.fromNumericCellRange(sheet,\n                    new CellRangeAddress(1, 6, c, c));\n            XDDFBarChartData.Series series = (XDDFBarChartData.Series) bar.addSeries(xs, ys);", "refactored_code": "    private static final int NUM_OF_ROWS = 6;\n        for (int c : chartedCols) {\n            // the data sources\n            XDDFCategoryDataSource xs = XDDFDataSourcesFactory.fromStringCellRange(sheet,\n                    new CellRangeAddress(1, NUM_OF_ROWS, 0, 0));\n            XDDFNumericalDataSource<Double> ys = XDDFDataSourcesFactory.fromNumericCellRange(sheet,\n                    new CellRangeAddress(1, NUM_OF_ROWS, c, c));\n            XDDFBarChartData.Series series = (XDDFBarChartData.Series) bar.addSeries(xs, ys);"}
{"magic_number_smell": "                try (InputStream is = pPart.getInputStream();\n                     Workbook workbook = WorkbookFactory.create(is);\n                     OutputStream os = pPart.getOutputStream()) {\n                    Sheet sheet = workbook.getSheetAt(0);\n                    Row row = sheet.getRow(ROW_NUM);\n                    Cell cell = row.getCell(CELL_NUM);\n                    cell.setCellValue(NEW_VALUE);", "refactored_code": "    private static final int SHEET_NUM = 0;\n                try (InputStream is = pPart.getInputStream();\n                     Workbook workbook = WorkbookFactory.create(is);\n                     OutputStream os = pPart.getOutputStream()) {\n                    Sheet sheet = workbook.getSheetAt(SHEET_NUM);\n                    Row row = sheet.getRow(ROW_NUM);\n                    Cell cell = row.getCell(CELL_NUM);\n                    cell.setCellValue(NEW_VALUE);"}
{"magic_number_smell": "\n    /**\n     * @param lowerbound the lower limit of the id-range to manage. Must be greater than or equal to {@link #MIN_ID}.\n     * @param upperbound the upper limit of the id-range to manage. Must be less than or equal {@link #Long.MAX_VALUE - 1}.\n     */\n    public IdentifierManager(long lowerbound, long upperbound) {\n        if (lowerbound > upperbound) {", "refactored_code": "    public static final long MAX_ID = Long.MAX_VALUE - 1;\n\n    /**\n     * @param lowerbound the lower limit of the id-range to manage. Must be greater than or equal to {@link #MIN_ID}.\n     * @param upperbound the upper limit of the id-range to manage. Must be less than or equal {@link #MAX_ID}.\n     */\n    public IdentifierManager(long lowerbound, long upperbound) {\n        if (lowerbound > upperbound) {"}
{"magic_number_smell": "    // how large a single entry in a zip-file should become at max\n    // can be overwritten via IOUtils.setByteArrayMaxOverride()\n    private static final int 100_000_000 = 100_000_000;\n    private static int MAX_ENTRY_SIZE = 100_000_000;\n\n    public static void setMaxEntrySize(int maxEntrySize) {\n        MAX_ENTRY_SIZE = maxEntrySize;", "refactored_code": "    private static final int DEFAULT_MAX_ENTRY_SIZE = 100_000_000;\n    // how large a single entry in a zip-file should become at max\n    // can be overwritten via IOUtils.setByteArrayMaxOverride()\n    private static final int DEFAULT_MAX_ENTRY_SIZE = 100_000_000;\n    private static int MAX_ENTRY_SIZE = DEFAULT_MAX_ENTRY_SIZE;\n\n    public static void setMaxEntrySize(int maxEntrySize) {\n        MAX_ENTRY_SIZE = maxEntrySize;"}
{"magic_number_smell": "    // how large a timestamp response is expected to be\n    // can be overwritten via IOUtils.setByteArrayMaxOverride()\n    private static final int 10_000_000 = 10_000_000;\n    private static int MAX_TIMESTAMP_RESPONSE_SIZE = 10_000_000;\n\n    /**\n     * @param maxTimestampResponseSize the max timestamp response size allowed", "refactored_code": "    private static final int DEFAULT_TIMESTAMP_RESPONSE_SIZE = 10_000_000;\n    // how large a timestamp response is expected to be\n    // can be overwritten via IOUtils.setByteArrayMaxOverride()\n    private static final int DEFAULT_TIMESTAMP_RESPONSE_SIZE = 10_000_000;\n    private static int MAX_TIMESTAMP_RESPONSE_SIZE = DEFAULT_TIMESTAMP_RESPONSE_SIZE;\n\n    /**\n     * @param maxTimestampResponseSize the max timestamp response size allowed"}
{"magic_number_smell": "    public static final int 60_000 = 60_000;\n\n    public static final int degreesToAttribute(double angle) {\n        return Math.toIntExact(Math.round(60_000 * angle));\n    }\n\n    public static final double attributeToDegrees(int angle) {", "refactored_code": "    public static final int OOXML_DEGREE = 60_000;\n    public static final int OOXML_DEGREE = 60_000;\n\n    public static final int degreesToAttribute(double angle) {\n        return Math.toIntExact(Math.round(OOXML_DEGREE * angle));\n    }\n\n    public static final double attributeToDegrees(int angle) {"}
{"magic_number_smell": "     *             if log base not within allowed range\n     */\n    public void setLogBase(double logBase) {\n        if (logBase < 2.0 || MAX_LOG_BASE < logBase) {\n            throw new IllegalArgumentException(\"Axis log base must be between 2 and 1000 (inclusive), got: \" + logBase);\n        }\n        CTScaling scaling = getCTScaling();", "refactored_code": "    private static final double MIN_LOG_BASE = 2.0;\n     *             if log base not within allowed range\n     */\n    public void setLogBase(double logBase) {\n        if (logBase < MIN_LOG_BASE || MAX_LOG_BASE < logBase) {\n            throw new IllegalArgumentException(\"Axis log base must be between 2 and 1000 (inclusive), got: \" + logBase);\n        }\n        CTScaling scaling = getCTScaling();"}
{"magic_number_smell": "    }\n\n    private static boolean isColinear(double x1, double y1, double x2, double y2, double x3, double y3) {\n        return Math.abs((y1 - y2) * (x1 - x3) - (y1 - y3) * (x1 - x2)) < 1e-10;\n    }\n\n    protected static double computeSweep(double startAngle, double endAngle,", "refactored_code": "    private static final double EPS = 1e-10;\n    }\n\n    private static boolean isColinear(double x1, double y1, double x2, double y2, double x3, double y3) {\n        return Math.abs((y1 - y2) * (x1 - x3) - (y1 - y3) * (x1 - x2)) < EPS;\n    }\n\n    protected static double computeSweep(double startAngle, double endAngle,"}
{"magic_number_smell": "        // length of a base64 string\n        int sbLen = ((4 * imgData.length / 3) + 3) & ~3;\n        // add line breaks every 65 chars and a few more padding chars\n        sbLen += sbLen / 65 + 30;\n        StringBuilder sb = new StringBuilder(sbLen);\n        sb.append(\"data:\");\n        sb.append(contentType);", "refactored_code": "    private static final int LINE_LENGTH = 65;\n        // length of a base64 string\n        int sbLen = ((4 * imgData.length / 3) + 3) & ~3;\n        // add line breaks every 65 chars and a few more padding chars\n        sbLen += sbLen / LINE_LENGTH + 30;\n        StringBuilder sb = new StringBuilder(sbLen);\n        sb.append(\"data:\");\n        sb.append(contentType);"}
{"magic_number_smell": "    private static final Logger LOG = LogManager.getLogger(XMLSlideShow.class);\n    //arbitrarily selected; may need to increase\n    private static final int 1_000_000 = 1_000_000;\n    private static int MAX_RECORD_LENGTH = 1_000_000;\n    private static final Pattern GET_ALL_EMBEDDED_PARTS_PATTERN = Pattern.compile(\"/ppt/embeddings/.*?\");\n    private static final Pattern GET_PICTURE_DATA_PATTERN = Pattern.compile(\"/ppt/media/.*?\");\n", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 1_000_000;\n    private static final Logger LOG = LogManager.getLogger(XMLSlideShow.class);\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 1_000_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n    private static final Pattern GET_ALL_EMBEDDED_PARTS_PATTERN = Pattern.compile(\"/ppt/embeddings/.*?\");\n    private static final Pattern GET_PICTURE_DATA_PATTERN = Pattern.compile(\"/ppt/media/.*?\");\n"}
{"magic_number_smell": "public final class XSLFPictureData extends POIXMLDocumentPart implements PictureData {\n\n    private static final int 100_000_000 = 100_000_000;\n    private static int MAX_IMAGE_SIZE = 100_000_000;\n\n    /**\n     * @param length the max image size allowed for XSLF pictures", "refactored_code": "    private static final int DEFAULT_MAX_IMAGE_SIZE = 100_000_000;\npublic final class XSLFPictureData extends POIXMLDocumentPart implements PictureData {\n\n    private static final int DEFAULT_MAX_IMAGE_SIZE = 100_000_000;\n    private static int MAX_IMAGE_SIZE = DEFAULT_MAX_IMAGE_SIZE;\n\n    /**\n     * @param length the max image size allowed for XSLF pictures"}
{"magic_number_smell": "\n    //arbitrarily selected; may need to increase\n    private static final int 1_000_000 = 1_000_000;\n    private static int MAX_RECORD_LENGTH = 1_000_000;\n\n    private final LittleEndianInputStream is;\n    private final SparseBitSet records;", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 1_000_000;\n\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 1_000_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    private final LittleEndianInputStream is;\n    private final SparseBitSet records;"}
{"magic_number_smell": "                break;\n                //TODO: All the PCDI and PCDIA\n            case BrtEndSheetData:\n                checkMissedComments(-1);\n                endRow(lastStartedRow);\n                break;\n            case BrtBeginHeaderFooter:", "refactored_code": "    private static final int CHECK_ALL_ROWS = -1;\n                break;\n                //TODO: All the PCDI and PCDIA\n            case BrtEndSheetData:\n                checkMissedComments(CHECK_ALL_ROWS);\n                endRow(lastStartedRow);\n                break;\n            case BrtBeginHeaderFooter:"}
{"magic_number_smell": "    public CTComment newComment(CellAddress ref) {\n        CTComment ct = comments.getCommentList().addNewComment();\n        ct.setRef(ref.formatAsString());\n        ct.setAuthorId(0);\n        \n        if(commentRefs != null) {\n           commentRefs.put(ref, ct);", "refactored_code": "    public static final int DEFAULT_AUTHOR_ID = 0;\n    public CTComment newComment(CellAddress ref) {\n        CTComment ct = comments.getCommentList().addNewComment();\n        ct.setRef(ref.formatAsString());\n        ct.setAuthorId(DEFAULT_AUTHOR_ID);\n        \n        if(commentRefs != null) {\n           commentRefs.put(ref, ct);"}
{"magic_number_smell": "        XSSFSheet sheet = getSheet();\n\n        CTCol col = sheet.getColumnHelper().getColumn(columnIndex, false);\n        double numChars = col == null || !col.isSetWidth() ? 9.140625f : col.getWidth();\n\n        return (float)numChars*Units.DEFAULT_CHARACTER_WIDTH;\n    }", "refactored_code": "    private static final float DEFAULT_COLUMN_WIDTH = 9.140625f;\n        XSSFSheet sheet = getSheet();\n\n        CTCol col = sheet.getColumnHelper().getColumn(columnIndex, false);\n        double numChars = col == null || !col.isSetWidth() ? DEFAULT_COLUMN_WIDTH : col.getWidth();\n\n        return (float)numChars*Units.DEFAULT_CHARACTER_WIDTH;\n    }"}
{"magic_number_smell": "    private final Map<SXSSFSheet,XSSFSheet> _sxFromXHash = new HashMap<>();\n    private final Map<XSSFSheet,SXSSFSheet> _xFromSxHash = new HashMap<>();\n\n    private int _randomAccessWindowSize = 100;\n\n    protected interface ISheetInjector {\n        void writeSheetData(OutputStream out) throws IOException;", "refactored_code": "    public static final int DEFAULT_WINDOW_SIZE = 100;\n    private final Map<SXSSFSheet,XSSFSheet> _sxFromXHash = new HashMap<>();\n    private final Map<XSSFSheet,SXSSFSheet> _xFromSxHash = new HashMap<>();\n\n    private int _randomAccessWindowSize = DEFAULT_WINDOW_SIZE;\n\n    protected interface ISheetInjector {\n        void writeSheetData(OutputStream out) throws IOException;"}
{"magic_number_smell": "    int writeCEN(Entry entry) throws IOException {\n        written = 0;\n        boolean useZip64 = entry.size > MAX32;\n        writeInt(0x02014b50L);                              // \"PK\\001\\002\"\n        writeShort(VERSION_45);                        // version made by: 4.5\n        writeShort(useZip64 ? VERSION_45 : VERSION_20);// version required: 4.5\n        writeShort(DATA_DESCRIPTOR_USED);              // flags: 8 = data descriptor used", "refactored_code": "    private static final long PK0102 = 0x02014b50L;\n    int writeCEN(Entry entry) throws IOException {\n        written = 0;\n        boolean useZip64 = entry.size > MAX32;\n        writeInt(PK0102);                              // \"PK\\001\\002\"\n        writeShort(VERSION_45);                        // version made by: 4.5\n        writeShort(useZip64 ? VERSION_45 : VERSION_20);// version required: 4.5\n        writeShort(DATA_DESCRIPTOR_USED);              // flags: 8 = data descriptor used"}
{"magic_number_smell": "     */\n    public void createErrorBox(String title, String text) {\n        // the spec does not specify a length-limit, however Excel reports files as \"corrupt\" if they exceed 255 bytes for these texts...\n        if(title != null && title.length() > 255) {\n            throw new IllegalStateException(\"Error-title cannot be longer than 32 characters, but had: \" + title);\n        }\n        if(text != null && text.length() > 255) {", "refactored_code": "    private static final int MAX_TEXT_LENGTH = 255;\n     */\n    public void createErrorBox(String title, String text) {\n        // the spec does not specify a length-limit, however Excel reports files as \"corrupt\" if they exceed 255 bytes for these texts...\n        if(title != null && title.length() > MAX_TEXT_LENGTH) {\n            throw new IllegalStateException(\"Error-title cannot be longer than 32 characters, but had: \" + title);\n        }\n        if(text != null && text.length() > MAX_TEXT_LENGTH) {"}
{"magic_number_smell": "            if (isFormulaEmpty(formula1)) {\n                throw new IllegalArgumentException(\"A valid formula or a list of values must be specified for list validation.\");\n            }\n            if(formula1.length() > 257) {\n                throw new IllegalArgumentException(\"A valid formula or a list of values must be less than or equal to 255 characters (including separators).\");\n            }\n        } else  {", "refactored_code": "    private static final int MAX_EXPLICIT_LIST_LENGTH = 257;\n            if (isFormulaEmpty(formula1)) {\n                throw new IllegalArgumentException(\"A valid formula or a list of values must be specified for list validation.\");\n            }\n            if(formula1.length() > MAX_EXPLICIT_LIST_LENGTH) {\n                throw new IllegalArgumentException(\"A valid formula or a list of values must be less than or equal to 255 characters (including separators).\");\n            }\n        } else  {"}
{"magic_number_smell": "    public XSSFFont() {\n        this._ctFont = CTFont.Factory.newInstance();\n        setFontName(DEFAULT_FONT_NAME);\n        setFontHeight((double)11);\n    }\n\n    /**", "refactored_code": "    public static final short DEFAULT_FONT_SIZE = 11;\n    public XSSFFont() {\n        this._ctFont = CTFont.Factory.newInstance();\n        setFontName(DEFAULT_FONT_NAME);\n        setFontHeight((double)DEFAULT_FONT_SIZE);\n    }\n\n    /**"}
{"magic_number_smell": "public class XSSFPictureData extends POIXMLDocumentPart implements PictureData {\n\n    private static final int 100_000_000 = 100_000_000;\n    private static int MAX_IMAGE_SIZE = 100_000_000;\n\n    /**\n     * @param length the max image size allowed for XSSF pictures", "refactored_code": "    private static final int DEFAULT_MAX_IMAGE_SIZE = 100_000_000;\npublic class XSSFPictureData extends POIXMLDocumentPart implements PictureData {\n\n    private static final int DEFAULT_MAX_IMAGE_SIZE = 100_000_000;\n    private static int MAX_IMAGE_SIZE = DEFAULT_MAX_IMAGE_SIZE;\n\n    /**\n     * @param length the max image size allowed for XSSF pictures"}
{"magic_number_smell": "        //Indentation increment for compact rows\n        pivotTableDefinition.setIndent(0);\n        //The pivot version which created the pivot cache set to default value\n        pivotTableDefinition.setCreatedVersion(3);\n        //Minimum version required to update the pivot cache\n        pivotTableDefinition.setMinRefreshableVersion(MIN_REFRESHABLE_VERSION);\n        //Version of the application which \"updated the spreadsheet last\"", "refactored_code": "    protected static final short CREATED_VERSION = 3;\n        //Indentation increment for compact rows\n        pivotTableDefinition.setIndent(0);\n        //The pivot version which created the pivot cache set to default value\n        pivotTableDefinition.setCreatedVersion(CREATED_VERSION);\n        //Minimum version required to update the pivot cache\n        pivotTableDefinition.setMinRefreshableVersion(MIN_REFRESHABLE_VERSION);\n        //Version of the application which \"updated the spreadsheet last\""}
{"magic_number_smell": "    private static CTWorksheet newSheet(){\n        CTWorksheet worksheet = CTWorksheet.Factory.newInstance();\n        CTSheetFormatPr ctFormat = worksheet.addNewSheetFormatPr();\n        ctFormat.setDefaultRowHeight(15.0);\n\n        CTSheetView ctView = worksheet.addNewSheetViews().addNewSheetView();\n        ctView.setWorkbookViewId(0);", "refactored_code": "    private static final double DEFAULT_ROW_HEIGHT = 15.0;\n    private static CTWorksheet newSheet(){\n        CTWorksheet worksheet = CTWorksheet.Factory.newInstance();\n        CTSheetFormatPr ctFormat = worksheet.addNewSheetFormatPr();\n        ctFormat.setDefaultRowHeight(DEFAULT_ROW_HEIGHT);\n\n        CTSheetView ctView = worksheet.addNewSheetViews().addNewSheetView();\n        ctView.setWorkbookViewId(0);"}
{"magic_number_smell": "            case OVERLAPS_1_WRAPS:\n                return range2;\n            default:\n            case -1:\n                return new long[]{-1, -1};\n        }\n    }", "refactored_code": "    public static final int NO_OVERLAPS = -1;\n            case OVERLAPS_1_WRAPS:\n                return range2;\n            default:\n            case NO_OVERLAPS:\n                return new long[]{-1, -1};\n        }\n    }"}
{"magic_number_smell": "        throws InvalidFormatException, IOException {\n        ctInline = run.addChart(chartRelId);\n        ctInline.addNewExtent();\n        setChartBoundingBox(XDDFChart.DEFAULT_WIDTH, DEFAULT_HEIGHT);\n    }\n\n    /**", "refactored_code": "    public static final int DEFAULT_WIDTH = XDDFChart.DEFAULT_WIDTH;\n        throws InvalidFormatException, IOException {\n        ctInline = run.addChart(chartRelId);\n        ctInline.addNewExtent();\n        setChartBoundingBox(DEFAULT_WIDTH, DEFAULT_HEIGHT);\n    }\n\n    /**"}
{"magic_number_smell": "public class XWPFPictureData extends POIXMLDocumentPart {\n\n    private static final int 100_000_000 = 100_000_000;\n    private static int MAX_IMAGE_SIZE = 100_000_000;\n\n    /**\n     * @param length the max image size allowed for XWPF pictures", "refactored_code": "    private static final int DEFAULT_MAX_IMAGE_SIZE = 100_000_000;\npublic class XWPFPictureData extends POIXMLDocumentPart {\n\n    private static final int DEFAULT_MAX_IMAGE_SIZE = 100_000_000;\n    private static int MAX_IMAGE_SIZE = DEFAULT_MAX_IMAGE_SIZE;\n\n    /**\n     * @param length the max image size allowed for XWPF pictures"}
{"magic_number_smell": "    @BeforeEach\n    void setUp() {\n        // Initialize array to allow to summarize afterwards\n        executions = new int[10];\n    }\n\n    @Test", "refactored_code": "    private static final int NUMBER_OF_THREADS = 10;\n    @BeforeEach\n    void setUp() {\n        // Initialize array to allow to summarize afterwards\n        executions = new int[NUMBER_OF_THREADS];\n    }\n\n    @Test"}
{"magic_number_smell": "            double e = expected[i];\n            double a = actual[i];\n\n            if (Math.abs(e - a) > 1e-6) {\n                Assertions.fail(String.format(\n                        LocaleUtil.getUserLocale(),\n                        \"expected <%f> but found <%f>\", e, a));", "refactored_code": "    private static final double EPS = 1e-6;\n            double e = expected[i];\n            double a = actual[i];\n\n            if (Math.abs(e - a) > EPS) {\n                Assertions.fail(String.format(\n                        LocaleUtil.getUserLocale(),\n                        \"expected <%f> but found <%f>\", e, a));"}
{"magic_number_smell": "        ArcTo arcTo = createArcTo(A);\n\n        Path2D.Double actualPath = new Path2D.Double();\n        actualPath.moveTo(0.0, Y0);\n\n        // Shape isn't used while creating a circular arc\n        arcTo.addToPath(actualPath, null);", "refactored_code": "    private static final double X0 = 0.0;\n        ArcTo arcTo = createArcTo(A);\n\n        Path2D.Double actualPath = new Path2D.Double();\n        actualPath.moveTo(X0, Y0);\n\n        // Shape isn't used while creating a circular arc\n        arcTo.addToPath(actualPath, null);"}
{"magic_number_smell": "        EllipticalArcTo ellipticalArcTo = createEllipticalArcTo(a, b);\n\n        Path2D.Double actualPath = new Path2D.Double();\n        actualPath.moveTo(0.0, Y0);\n\n        // Shape isn't used while creating an elliptical arc\n        ellipticalArcTo.addToPath(actualPath, null);", "refactored_code": "    private static final double X0 = 0.0;\n        EllipticalArcTo ellipticalArcTo = createEllipticalArcTo(a, b);\n\n        Path2D.Double actualPath = new Path2D.Double();\n        actualPath.moveTo(X0, Y0);\n\n        // Shape isn't used while creating an elliptical arc\n        ellipticalArcTo.addToPath(actualPath, null);"}
{"magic_number_smell": "    public void shouldAddMultipleLinesToPath(String formula) {\n        PolyLineTo polyLine = createPolyLine(formula);\n\n        XDGFShape parent = GeometryTestUtils.mockShape(X - 0.0, Y - Y0);\n\n        Path2D.Double actualPath = new Path2D.Double();\n        actualPath.moveTo(0.0, Y0);", "refactored_code": "    private static final double X0 = 0.0;\n    public void shouldAddMultipleLinesToPath(String formula) {\n        PolyLineTo polyLine = createPolyLine(formula);\n\n        XDGFShape parent = GeometryTestUtils.mockShape(X - X0, Y - Y0);\n\n        Path2D.Double actualPath = new Path2D.Double();\n        actualPath.moveTo(X0, Y0);"}
{"magic_number_smell": "\n        sheet.autoSizeColumn(0, useMergedCells);\n\n        assertColumnWidthStrictlyWithinRange(sheet.getColumnWidth(0), 4000, MAX_COLUMN_WIDTH);\n    }\n\n    @ParameterizedTest", "refactored_code": "    private static final int COLUMN_WIDTH_THRESHOLD_BETWEEN_SHORT_AND_LONG = 4000;\n\n        sheet.autoSizeColumn(0, useMergedCells);\n\n        assertColumnWidthStrictlyWithinRange(sheet.getColumnWidth(0), COLUMN_WIDTH_THRESHOLD_BETWEEN_SHORT_AND_LONG, MAX_COLUMN_WIDTH);\n    }\n\n    @ParameterizedTest"}
{"magic_number_smell": "        Sheet sheet = p_wb.createSheet(\"sheet123\");\n        sheet.setRowSumsBelow(false);\n\n        for (int i = 0; i < 200; i++) {\n            Row row = sheet.createRow(i);\n            Cell cell = row.createCell(0);\n            cell.setCellValue(i+1);", "refactored_code": "    private static final int ROWS_NUMBER = 200;\n        Sheet sheet = p_wb.createSheet(\"sheet123\");\n        sheet.setRowSumsBelow(false);\n\n        for (int i = 0; i < ROWS_NUMBER; i++) {\n            Row row = sheet.createRow(i);\n            Cell cell = row.createCell(0);\n            cell.setCellValue(i+1);"}
{"magic_number_smell": "    private static final int INSERT_ROW = 1;\n    private static final int INSERT_COLUMN = 1;\n    private static final int FIRST_MERGE_ROW = INSERT_ROW+1;\n    private static final int LAST_MERGE_ROW = 4-1;\n    private static final int FIRST_MERGE_COL = INSERT_COLUMN+1;\n    private static final int LAST_MERGE_COL = numCols-1;\n", "refactored_code": "    private static final int numRows = 4;\n    private static final int INSERT_ROW = 1;\n    private static final int INSERT_COLUMN = 1;\n    private static final int FIRST_MERGE_ROW = INSERT_ROW+1;\n    private static final int LAST_MERGE_ROW = numRows-1;\n    private static final int FIRST_MERGE_COL = INSERT_COLUMN+1;\n    private static final int LAST_MERGE_COL = numCols-1;\n"}
{"magic_number_smell": "    @Test\n    void testLogBaseLegalArgument() {\n        axis.setLogBase(Math.E);\n        assertTrue(Math.abs(axis.getLogBase() - Math.E) < 1E-7);\n    }\n\n    @Test", "refactored_code": "    private static final double EPSILON = 1E-7;\n    @Test\n    void testLogBaseLegalArgument() {\n        axis.setLogBase(Math.E);\n        assertTrue(Math.abs(axis.getLogBase() - Math.E) < EPSILON);\n    }\n\n    @Test"}
{"magic_number_smell": "            Sheet sh = wb.createSheet();\n            for(i=0; ; i++) {\n                Row row = sh.createRow(i);\n                for(int j=0; j < 255; j++) {\n                    Cell cell = row.createCell(j);\n                    assertNotNull(cell);\n                    if(j % 2 == 0) {", "refactored_code": "    private static final int NUM_COLUMNS = 255;\n            Sheet sh = wb.createSheet();\n            for(i=0; ; i++) {\n                Row row = sh.createRow(i);\n                for(int j=0; j < NUM_COLUMNS; j++) {\n                    Cell cell = row.createCell(j);\n                    assertNotNull(cell);\n                    if(j % 2 == 0) {"}
{"magic_number_smell": "\n    //arbitrarily selected; may need to increase\n    private static final int 1_000_000 = 1_000_000;\n    private static int MAX_RECORD_LENGTH = 1_000_000;\n\n    /** The version of the currently open document */\n    private int version;", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 1_000_000;\n\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 1_000_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    /** The version of the currently open document */\n    private int version;"}
{"magic_number_smell": "            throw new IllegalArgumentException(\"Cannot create container pointers with negative count: \" + numPointers);\n        }\n\n        IOUtils.safelyAllocateCheck(numPointers, 100_000);\n\n        // Create\n        int pos = numPointersOffset + skip;", "refactored_code": "    private static final int MAX_NUMBER_OF_POINTERS = 100_000;\n            throw new IllegalArgumentException(\"Cannot create container pointers with negative count: \" + numPointers);\n        }\n\n        IOUtils.safelyAllocateCheck(numPointers, MAX_NUMBER_OF_POINTERS);\n\n        // Create\n        int pos = numPointersOffset + skip;"}
{"magic_number_smell": "\n    //arbitrarily selected; may need to increase\n    private static final int 64_000_000 = 64_000_000;\n    private static int MAX_RECORD_LENGTH = 64_000_000;\n\n    /** The raw, compressed contents */\n    private byte[] compressedContents;", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 64_000_000;\n\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 64_000_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    /** The raw, compressed contents */\n    private byte[] compressedContents;"}
{"magic_number_smell": "    }\n\n    private void findChildren(byte[] documentData, int nesting) {\n        if (nesting > 500) {\n            LOG.warn(\"Encountered too deep nesting, cannot fully process stream \" +\n                    \" with more than \" + 500 + \" nested children.\" +\n                    \" Some data could not be parsed.\");", "refactored_code": "    private static final int MAX_CHILDREN_NESTING = 500;\n    }\n\n    private void findChildren(byte[] documentData, int nesting) {\n        if (nesting > MAX_CHILDREN_NESTING) {\n            LOG.warn(\"Encountered too deep nesting, cannot fully process stream \" +\n                    \" with more than \" + MAX_CHILDREN_NESTING + \" nested children.\" +\n                    \" Some data could not be parsed.\");"}
{"magic_number_smell": "public class StreamStore { // TODO - instantiable superclass\n    //arbitrarily selected; may need to increase\n    private static final int 10_000_000 = 10_000_000;\n    private static int MAX_RECORD_LENGTH = 10_000_000;\n\n    private byte[] contents;\n", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 10_000_000;\npublic class StreamStore { // TODO - instantiable superclass\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 10_000_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    private byte[] contents;\n"}
{"magic_number_smell": "        facename = sb.toString();\n        size += readBytes;\n\n        if (recordSize <= 92) {\n            return size;\n        }\n", "refactored_code": "    private static final int LOGFONT_SIZE = 92;\n        facename = sb.toString();\n        size += readBytes;\n\n        if (recordSize <= LOGFONT_SIZE) {\n            return size;\n        }\n"}
{"magic_number_smell": "public class HemfText {\n\n    private static final int 1_000_000 = 1_000_000;\n    private static int MAX_RECORD_LENGTH = 1_000_000;\n\n    /**\n     * @param length the max record length allowed for HemfText", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 1_000_000;\npublic class HemfText {\n\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 1_000_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    /**\n     * @param length the max record length allowed for HemfText"}
{"magic_number_smell": "                size += LittleEndianConsts.INT_SIZE;\n            }\n\n            brushBytes = IOUtils.toByteArray(leis, Math.toIntExact(dataSize-size), 1_000_000);\n\n            return dataSize;\n        }", "refactored_code": "        private static final int MAX_OBJECT_SIZE = 1_000_000;\n                size += LittleEndianConsts.INT_SIZE;\n            }\n\n            brushBytes = IOUtils.toByteArray(leis, Math.toIntExact(dataSize-size), MAX_OBJECT_SIZE);\n\n            return dataSize;\n        }"}
{"magic_number_smell": "            // If the CMAP_LOOKUP flag in the optionsFlags field is set, each value in this array specifies a\n            // Unicode character. Otherwise, each value specifies an index to a character glyph in the EmfPlusFont\n            // object specified by the ObjectId value in Flags field.\n            byte[] glyphBuf = IOUtils.toByteArray(leis, glyphCount*2, 1_000_000);\n            glyphs = StringUtil.getFromUnicodeLE(glyphBuf);\n\n            size += glyphBuf.length;", "refactored_code": "    private static final int MAX_OBJECT_SIZE = 1_000_000;\n            // If the CMAP_LOOKUP flag in the optionsFlags field is set, each value in this array specifies a\n            // Unicode character. Otherwise, each value specifies an index to a character glyph in the EmfPlusFont\n            // object specified by the ObjectId value in Flags field.\n            byte[] glyphBuf = IOUtils.toByteArray(leis, glyphCount*2, MAX_OBJECT_SIZE);\n            glyphs = StringUtil.getFromUnicodeLE(glyphBuf);\n\n            size += glyphBuf.length;"}
{"magic_number_smell": "\n            assert (fileSize <= dataSize - size);\n\n            imageData = IOUtils.toByteArray(leis, fileSize, 50_000_000);\n\n            // TODO: remove padding bytes between placeable WMF header and body?\n", "refactored_code": "        private static final int MAX_OBJECT_SIZE = 50_000_000;\n\n            assert (fileSize <= dataSize - size);\n\n            imageData = IOUtils.toByteArray(leis, fileSize, MAX_OBJECT_SIZE);\n\n            // TODO: remove padding bytes between placeable WMF header and body?\n"}
{"magic_number_smell": "\n            long size = graphicsVersion.init(leis);\n\n            objectDataBytes = IOUtils.toByteArray(leis, (int)(dataSize - size), 50_000_000);\n\n            return dataSize;\n        }", "refactored_code": "    private static final int MAX_OBJECT_SIZE = 50_000_000;\n\n            long size = graphicsVersion.init(leis);\n\n            objectDataBytes = IOUtils.toByteArray(leis, (int)(dataSize - size), MAX_OBJECT_SIZE);\n\n            return dataSize;\n        }"}
{"magic_number_smell": "public class HemfEmbeddedIterator implements Iterator<HwmfEmbedded> {\n    //arbitrarily selected; may need to increase\n    private static final int 100_000_000 = 100_000_000;\n    private static int MAX_RECORD_LENGTH = 100_000_000;\n\n    private final Deque<Iterator<?>> iterStack = new ArrayDeque<>();\n    private Object current;", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000_000;\npublic class HemfEmbeddedIterator implements Iterator<HwmfEmbedded> {\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    private final Deque<Iterator<?>> iterStack = new ArrayDeque<>();\n    private Object current;"}
{"magic_number_smell": "        try {\n            // Check the signature matches\n            int sig = LittleEndian.readInt(inp);\n            if (sig != 0x223e9f78) {\n                throw new IllegalArgumentException(\n                        \"TNEF signature not detected in file, \" +\n                        \"expected \" + 0x223e9f78 + \" but got \" + sig", "refactored_code": "    public static final int HEADER_SIGNATURE = 0x223e9f78;\n        try {\n            // Check the signature matches\n            int sig = LittleEndian.readInt(inp);\n            if (sig != HEADER_SIGNATURE) {\n                throw new IllegalArgumentException(\n                        \"TNEF signature not detected in file, \" +\n                        \"expected \" + HEADER_SIGNATURE + \" but got \" + sig"}
{"magic_number_smell": "      }\n\n      if(tmp.length > rtf.getDeCompressedSize()) {\n         this.decompressed = IOUtils.safelyClone(tmp, 0, rtf.getDeCompressedSize(), 50_000_000);\n      } else {\n         this.decompressed = tmp;\n      }", "refactored_code": "   private static final int MAX_RECORD_LENGTH = 50_000_000;\n      }\n\n      if(tmp.length > rtf.getDeCompressedSize()) {\n         this.decompressed = IOUtils.safelyClone(tmp, 0, rtf.getDeCompressedSize(), MAX_RECORD_LENGTH);\n      } else {\n         this.decompressed = tmp;\n      }"}
{"magic_number_smell": "\n   //arbitrarily selected; may need to increase\n   private static final int 20_000_000 = 20_000_000;\n   private static int MAX_RECORD_LENGTH = 20_000_000;\n\n   private final TNEFProperty property;\n   private final int type;", "refactored_code": "   private static final int DEFAULT_MAX_RECORD_LENGTH = 20_000_000;\n\n   //arbitrarily selected; may need to increase\n   private static final int DEFAULT_MAX_RECORD_LENGTH = 20_000_000;\n   private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n   private final TNEFProperty property;\n   private final int type;"}
{"magic_number_smell": "\n   //arbitrarily selected; may need to increase\n   private static final int 1_000_000 = 1_000_000;\n   private static int MAX_RECORD_LENGTH = 1_000_000;\n\n   /**\n    * @param length the max record length allowed for HMEFDumper", "refactored_code": "   private static final int DEFAULT_MAX_RECORD_LENGTH = 1_000_000;\n\n   //arbitrarily selected; may need to increase\n   private static final int DEFAULT_MAX_RECORD_LENGTH = 1_000_000;\n   private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n   /**\n    * @param length the max record length allowed for HMEFDumper"}
{"magic_number_smell": "\n    //arbitrarily selected; may need to increase\n    private static final int 1_000_000 = 1_000_000;\n    private static int MAX_RECORD_LENGTH = 1_000_000;\n\n    /**\n     * @param length the max record length allowed for EscherPart", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 1_000_000;\n\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 1_000_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    /**\n     * @param length the max record length allowed for EscherPart"}
{"magic_number_smell": "        typeOfPLCS = (int)LittleEndian.getUInt(data, 4);\n\n        // Init the arrays that we can\n        IOUtils.safelyAllocateCheck(numberOfPLCs, 1000);\n        plcValA = new long[numberOfPLCs];\n        plcValB = new long[numberOfPLCs];\n    }", "refactored_code": "    private static final int MAX_NUMBER_OF_PLCS = 1000;\n        typeOfPLCS = (int)LittleEndian.getUInt(data, 4);\n\n        // Init the arrays that we can\n        IOUtils.safelyAllocateCheck(numberOfPLCs, MAX_NUMBER_OF_PLCS);\n        plcValA = new long[numberOfPLCs];\n        plcValB = new long[numberOfPLCs];\n    }"}
{"magic_number_smell": "\n    //arbitrarily selected; may need to increase\n    private static final int 1_000_000 = 1_000_000;\n    private static int MAX_RECORD_LENGTH = 1_000_000;\n\n    /**\n     * @param length the max record length allowed for QCTextBit", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 1_000_000;\n\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 1_000_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    /**\n     * @param length the max record length allowed for QCTextBit"}
{"magic_number_smell": "        // bitmap file-header, corresponds to a\n        // Windows  BITMAPFILEHEADER structure\n        // (For more information, consult the Windows API Programmer's reference )\n        byte[] header = new byte[14];\n        //Specifies the file type. It must be set to the signature word BM (0x4D42) to indicate bitmap.\n        LittleEndian.putInt(header, 0, 0x4D42);\n", "refactored_code": "    private static final int HEADER_SIZE = 14;\n        // bitmap file-header, corresponds to a\n        // Windows  BITMAPFILEHEADER structure\n        // (For more information, consult the Windows API Programmer's reference )\n        byte[] header = new byte[HEADER_SIZE];\n        //Specifies the file type. It must be set to the signature word BM (0x4D42) to indicate bitmap.\n        LittleEndian.putInt(header, 0, 0x4D42);\n"}
{"magic_number_smell": "        public void read(byte[] data, int offset) {\n            try (\n                    LittleEndianInputStream leis = new LittleEndianInputStream(\n                            UnsynchronizedByteArrayInputStream.builder().setByteArray(data).setOffset(offset).setLength(34).get())\n            ) {\n                wmfsize = leis.readInt();\n", "refactored_code": "        private static final int RECORD_LENGTH = 34;\n        public void read(byte[] data, int offset) {\n            try (\n                    LittleEndianInputStream leis = new LittleEndianInputStream(\n                            UnsynchronizedByteArrayInputStream.builder().setByteArray(data).setOffset(offset).setLength(RECORD_LENGTH).get())\n            ) {\n                wmfsize = leis.readInt();\n"}
{"magic_number_smell": "     */\n    public void dump(byte[] data, int offset, int length, int padding) throws IOException {\n        int pos = offset;\n        while (pos <= (offset + length - 8)){\n            if (pos < 0) {\n                break;\n            }", "refactored_code": "    private static final int HEADER_SIZE = 8; //size of the record header\n     */\n    public void dump(byte[] data, int offset, int length, int padding) throws IOException {\n        int pos = offset;\n        while (pos <= (offset + length - HEADER_SIZE)){\n            if (pos < 0) {\n                break;\n            }"}
{"magic_number_smell": "\n    //arbitrarily selected; may need to increase\n    private static final int 100_000 = 100_000;\n    private static int MAX_RECORD_LENGTH = 100_000;\n\n    private byte[] docstream;\n", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000;\n\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    private byte[] docstream;\n"}
{"magic_number_smell": "        switch (getValue()) {\n            default:\n                return FontAlign.AUTO;\n            case 0:\n                return FontAlign.0;\n            case TOP:\n                return FontAlign.TOP;", "refactored_code": "    public static final int BASELINE = 0;\n        switch (getValue()) {\n            default:\n                return FontAlign.AUTO;\n            case BASELINE:\n                return FontAlign.BASELINE;\n            case TOP:\n                return FontAlign.TOP;"}
{"magic_number_smell": "    public TextAlign getTextAlign() {\n        switch (getValue()) {\n            default:\n            case 0:\n                return TextAlign.0;\n            case CENTER:\n                return TextAlign.CENTER;", "refactored_code": "    public static final int LEFT = 0;\n    public TextAlign getTextAlign() {\n        switch (getValue()) {\n            default:\n            case LEFT:\n                return TextAlign.LEFT;\n            case CENTER:\n                return TextAlign.CENTER;"}
{"magic_number_smell": "    public static final int AnimateBg = 0x4000;\n\n    private static final int[] FLAGS_MASKS = {\n        0x0001,\n        Automatic,\n        Sound,\n        StopSound,", "refactored_code": "    public static final int Reverse = 0x0001;\n    public static final int AnimateBg = 0x4000;\n\n    private static final int[] FLAGS_MASKS = {\n        Reverse,\n        Automatic,\n        Sound,\n        StopSound,"}
{"magic_number_smell": "    public ColorSchemeAtom(){\n        _header = new byte[8];\n        LittleEndian.putUShort(_header, 0, 16);\n        LittleEndian.putUShort(_header, 2, (int)2032L);\n        LittleEndian.putInt(_header, 4, 32);\n\n        // Setup the default rgb values", "refactored_code": "    private static final long _type = 2032L;\n    public ColorSchemeAtom(){\n        _header = new byte[8];\n        LittleEndian.putUShort(_header, 0, 16);\n        LittleEndian.putUShort(_header, 2, (int)_type);\n        LittleEndian.putInt(_header, 4, 32);\n\n        // Setup the default rgb values"}
{"magic_number_smell": "\n        // Setup our header block\n        _header[0] = 0x0f; // We are a container record\n        LittleEndian.putShort(_header, 2, (short)RecordTypes.Comment2000.typeID);\n\n        // Setup our child records\n        CString csa = new CString();", "refactored_code": "    private static final long _type = RecordTypes.Comment2000.typeID;\n\n        // Setup our header block\n        _header[0] = 0x0f; // We are a container record\n        LittleEndian.putShort(_header, 2, (short)_type);\n\n        // Setup our child records\n        CString csa = new CString();"}
{"magic_number_smell": "\n        // Setup our header block\n        _header[0] = 0x0f; // We are a container record\n        LittleEndian.putShort(_header, 2, (short)RecordTypes.List.typeID);\n\n        // Setup our child records\n        findInterestingChildren();", "refactored_code": "    private static final long _type = RecordTypes.List.typeID;\n\n        // Setup our header block\n        _header[0] = 0x0f; // We are a container record\n        LittleEndian.putShort(_header, 2, (short)_type);\n\n        // Setup our child records\n        findInterestingChildren();"}
{"magic_number_smell": "     * We are of type 1001\n     */\n    @Override\n    public long getRecordType() { return RecordTypes.DocumentAtom.typeID; }\n\n    /**\n     * Write the contents of the record back, so it can be written", "refactored_code": "    private static final long _type = RecordTypes.DocumentAtom.typeID;\n     * We are of type 1001\n     */\n    @Override\n    public long getRecordType() { return _type; }\n\n    /**\n     * Write the contents of the record back, so it can be written"}
{"magic_number_smell": "    public DocumentEncryptionAtom() {\n        _header = new byte[8];\n        LittleEndian.putShort(_header, 0, (short)0x000F);\n        LittleEndian.putShort(_header, 2, (short)RecordTypes.DocumentEncryptionAtom.typeID);\n        // record length not yet known ...\n\n        ei = new EncryptionInfo(EncryptionMode.cryptoAPI);", "refactored_code": "    private static final long _type = RecordTypes.DocumentEncryptionAtom.typeID;\n    public DocumentEncryptionAtom() {\n        _header = new byte[8];\n        LittleEndian.putShort(_header, 0, (short)0x000F);\n        LittleEndian.putShort(_header, 2, (short)_type);\n        // record length not yet known ...\n\n        ei = new EncryptionInfo(EncryptionMode.cryptoAPI);"}
{"magic_number_smell": "    /**\n     * Gets whether the object follows the color scheme.\n     *\n     * @return one of {@link #0},\n     *                {@link #FOLLOWS_ENTIRE_COLOR_SCHEME}, or\n     *                {@link #FOLLOWS_TEXT_AND_BACKGROUND_SCHEME}.\n     */", "refactored_code": "    public static final int DOES_NOT_FOLLOW_COLOR_SCHEME = 0;\n    /**\n     * Gets whether the object follows the color scheme.\n     *\n     * @return one of {@link #DOES_NOT_FOLLOW_COLOR_SCHEME},\n     *                {@link #FOLLOWS_ENTIRE_COLOR_SCHEME}, or\n     *                {@link #FOLLOWS_TEXT_AND_BACKGROUND_SCHEME}.\n     */"}
{"magic_number_smell": "\n        // Setup our header block\n        _header[0] = 0x0f; // We are a container record\n        LittleEndian.putShort(_header, 2, (short)RecordTypes.ExHyperlink.typeID);\n\n        // Setup our child records\n        CString csa = new CString();", "refactored_code": "    private static final long _type = RecordTypes.ExHyperlink.typeID;\n\n        // Setup our header block\n        _header[0] = 0x0f; // We are a container record\n        LittleEndian.putShort(_header, 2, (short)_type);\n\n        // Setup our child records\n        CString csa = new CString();"}
{"magic_number_smell": "    public static final int fNarration = 4;\n\n\n    private static final int[] FLAG_MASKS = { 1, fRewind, fNarration };\n\n    private static final String[] FLAG_NAMES = { \"LOOP\", \"REWIND\", \"NARRATION\" };\n", "refactored_code": "    public static final int fLoop = 1;\n    public static final int fNarration = 4;\n\n\n    private static final int[] FLAG_MASKS = { fLoop, fRewind, fNarration };\n\n    private static final String[] FLAG_NAMES = { \"LOOP\", \"REWIND\", \"NARRATION\" };\n"}
{"magic_number_smell": "\n        // Setup our header block\n        _header[0] = 0x0f; // We are a container record\n        LittleEndian.putShort(_header, 2, (short)RecordTypes.ExObjList.typeID);\n\n        // Setup our child records\n        _children[0] = new ExObjListAtom();", "refactored_code": "    private static final long _type = RecordTypes.ExObjList.typeID;\n\n        // Setup our header block\n        _header[0] = 0x0f; // We are a container record\n        LittleEndian.putShort(_header, 2, (short)_type);\n\n        // Setup our child records\n        _children[0] = new ExObjListAtom();"}
{"magic_number_smell": "        _header = Arrays.copyOfRange(source, start, start+8);\n\n        // Get the record data.\n        _data = IOUtils.safelyClone(source, start+8, len-8, 10_485_760);\n\n        // Must be at least 24 bytes long\n        if(_data.length < 24) {", "refactored_code": "    private static final int MAX_RECORD_LENGTH = 10_485_760;\n        _header = Arrays.copyOfRange(source, start, start+8);\n\n        // Get the record data.\n        _data = IOUtils.safelyClone(source, start+8, len-8, MAX_RECORD_LENGTH);\n\n        // Must be at least 24 bytes long\n        if(_data.length < 24) {"}
{"magic_number_smell": "        _header = Arrays.copyOfRange(source, start, start+8);\n\n        // Get the record data.\n        _data = IOUtils.safelyClone(source, start+8, len-8, 100_000_000);\n    }\n\n    public boolean isCompressed() {", "refactored_code": "    private static final int MAX_RECORD_LENGTH = 100_000_000;\n        _header = Arrays.copyOfRange(source, start, start+8);\n\n        // Get the record data.\n        _data = IOUtils.safelyClone(source, start+8, len-8, MAX_RECORD_LENGTH);\n    }\n\n    public boolean isCompressed() {"}
{"magic_number_smell": "public class FontEmbeddedData extends RecordAtom implements FontFacet {\n    //arbitrarily selected; may need to increase (increased due to https://bz.apache.org/bugzilla/show_bug.cgi?id=65639)\n    private static final int 5_000_000 = 5_000_000;\n    private static int MAX_RECORD_LENGTH = 5_000_000;\n\n    /**\n     * Record header.", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 5_000_000;\npublic class FontEmbeddedData extends RecordAtom implements FontFacet {\n    //arbitrarily selected; may need to increase (increased due to https://bz.apache.org/bugzilla/show_bug.cgi?id=65639)\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 5_000_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    /**\n     * Record header."}
{"magic_number_smell": "    public static final int fHasFooter = 32;\n\n    private static final int[] PLACEHOLDER_MASKS = {\n        1,\n        fHasTodayDate,\n        fHasUserDate,\n        fHasSlideNumber,", "refactored_code": "    public static final int fHasDate = 1;\n    public static final int fHasFooter = 32;\n\n    private static final int[] PLACEHOLDER_MASKS = {\n        fHasDate,\n        fHasTodayDate,\n        fHasUserDate,\n        fHasSlideNumber,"}
{"magic_number_smell": "    }\n\n    /**\n     * Must be either {@link #0x3F} or {@link #NotesHeadersFootersContainer}\n     *\n     * @return \"instance\" field in the record header\n     */", "refactored_code": "    public static final short SlideHeadersFootersContainer = 0x3F;\n    }\n\n    /**\n     * Must be either {@link #SlideHeadersFootersContainer} or {@link #NotesHeadersFootersContainer}\n     *\n     * @return \"instance\" field in the record header\n     */"}
{"magic_number_smell": "\n        // Setup our header block\n        _header[0] = 0x0f; // We are a container record\n        LittleEndian.putShort(_header, 2, (short)RecordTypes.InteractiveInfo.typeID);\n\n        // Setup our child records\n        infoAtom = new InteractiveInfoAtom();", "refactored_code": "    private static final long _type = RecordTypes.InteractiveInfo.typeID;\n\n        // Setup our header block\n        _header[0] = 0x0f; // We are a container record\n        LittleEndian.putShort(_header, 2, (short)_type);\n\n        // Setup our child records\n        infoAtom = new InteractiveInfoAtom();"}
{"magic_number_smell": "\n    //arbitrarily selected; may need to increase\n    private static final int 100_000 = 100_000;\n    private static int MAX_RECORD_LENGTH = 100_000;\n\n    /**\n     * Record header.", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000;\n\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    /**\n     * Record header."}
{"magic_number_smell": "        _header = Arrays.copyOfRange(source, start, start+8);\n\n        // Get the contents for now\n        byte[] contents = IOUtils.safelyClone(source, start, len, 10_485_760);\n\n        DefaultEscherRecordFactory erf = new HSLFEscherRecordFactory();\n        EscherRecord child = erf.createRecord(contents, 0);", "refactored_code": "    private static final int MAX_RECORD_LENGTH = 10_485_760;\n        _header = Arrays.copyOfRange(source, start, start+8);\n\n        // Get the contents for now\n        byte[] contents = IOUtils.safelyClone(source, start, len, MAX_RECORD_LENGTH);\n\n        DefaultEscherRecordFactory erf = new HSLFEscherRecordFactory();\n        EscherRecord child = erf.createRecord(contents, 0);"}
{"magic_number_smell": "\n    //arbitrarily selected; may need to increase\n    private static final int 1_000_000 = 1_000_000;\n    private static int MAX_RECORD_LENGTH = 1_000_000;\n\n    /**\n     * @param length the max record length allowed for RecordAtom", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 1_000_000;\n\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 1_000_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    /**\n     * @param length the max record length allowed for RecordAtom"}
{"magic_number_smell": "        followMasterObjects = true;\n        followMasterScheme = true;\n        followMasterBackground = true;\n        masterID = 0x80000000; // -2147483648;\n        notesID = 0;\n        reserved = new byte[2];\n    }", "refactored_code": "    public static final int USES_MASTER_SLIDE_ID  =  0x80000000;\n        followMasterObjects = true;\n        followMasterScheme = true;\n        followMasterBackground = true;\n        masterID = USES_MASTER_SLIDE_ID; // -2147483648;\n        notesID = 0;\n        reserved = new byte[2];\n    }"}
{"magic_number_smell": "    public SlideListWithText(){\n        _header = new byte[8];\n        LittleEndian.putUShort(_header, 0, 15);\n        LittleEndian.putUShort(_header, 2, (int)RecordTypes.SlideListWithText.typeID);\n        LittleEndian.putInt(_header, 4, 0);\n\n        // We have no children to start with", "refactored_code": "    private static final long _type = RecordTypes.SlideListWithText.typeID;\n    public SlideListWithText(){\n        _header = new byte[8];\n        LittleEndian.putUShort(_header, 0, 15);\n        LittleEndian.putUShort(_header, 2, (int)_type);\n        LittleEndian.putInt(_header, 4, 0);\n\n        // We have no children to start with"}
{"magic_number_smell": "\n        // Finally you have typically 4 or 8 bytes of reserved fields,\n        //  all zero running from 24 bytes in to the end\n        reservedFields = IOUtils.safelyClone(source,start+24, len-24, 32);\n    }\n\n    /**", "refactored_code": "    private static final int MAX_RECORD_LENGTH = 32;\n\n        // Finally you have typically 4 or 8 bytes of reserved fields,\n        //  all zero running from 24 bytes in to the end\n        reservedFields = IOUtils.safelyClone(source,start+24, len-24, MAX_RECORD_LENGTH);\n    }\n\n    /**"}
{"magic_number_smell": "\n    //arbitrarily selected; may need to increase\n    private static final int 100_000_000 = 100_000_000;\n    private static int MAX_RECORD_LENGTH = 100_000_000;\n\n    /**\n     * @param length the max record length allowed for SoundData", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000_000;\n\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    /**\n     * @param length the max record length allowed for SoundData"}
{"magic_number_smell": "    // public static int RESERVED7_BIT       = 1 << 13 | 1 << 14 | 1 << 15;\n\n    private static final int[] EFFECT_MASKS = {\n        1 << 0,\n        HIDDEN_BIT,\n        SOUND_BIT,\n        LOOP_SOUND_BIT,", "refactored_code": "    public static final int MANUAL_ADVANCE_BIT     = 1 << 0;\n    // public static int RESERVED7_BIT       = 1 << 13 | 1 << 14 | 1 << 15;\n\n    private static final int[] EFFECT_MASKS = {\n        MANUAL_ADVANCE_BIT,\n        HIDDEN_BIT,\n        SOUND_BIT,\n        LOOP_SOUND_BIT,"}
{"magic_number_smell": "\n    //arbitrarily selected; may need to increase\n    private static final int 100_000 = 100_000;\n    private static int MAX_RECORD_LENGTH = 100_000;\n\n    private final TextPFException9[] autoNumberSchemes;\n    /** Record header. */", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000;\n\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    private final TextPFException9[] autoNumberSchemes;\n    /** Record header. */"}
{"magic_number_smell": "        reserved = new byte[0];\n\n        // Set our type\n        LittleEndian.putInt(_header,2,(short)RecordTypes.StyleTextPropAtom.typeID);\n        // Our initial size is 10\n        LittleEndian.putInt(_header,4,10);\n", "refactored_code": "    public static final long _type = RecordTypes.StyleTextPropAtom.typeID;\n        reserved = new byte[0];\n\n        // Set our type\n        LittleEndian.putInt(_header,2,(short)_type);\n        // Our initial size is 10\n        LittleEndian.putInt(_header,4,10);\n"}
{"magic_number_smell": "    public TextBytesAtom() {\n        _header = new byte[8];\n        LittleEndian.putUShort(_header, 0, 0);\n        LittleEndian.putUShort(_header, 2, (int)RecordTypes.TextBytesAtom.typeID);\n        LittleEndian.putInt(_header, 4, 0);\n\n        _text = new byte[]{};", "refactored_code": "    public static final long _type = RecordTypes.TextBytesAtom.typeID;\n    public TextBytesAtom() {\n        _header = new byte[8];\n        LittleEndian.putUShort(_header, 0, 0);\n        LittleEndian.putUShort(_header, 2, (int)_type);\n        LittleEndian.putInt(_header, 4, 0);\n\n        _text = new byte[]{};"}
{"magic_number_smell": "     * We are of type 4000\n     */\n    @Override\n    public long getRecordType() { return RecordTypes.TextCharsAtom.typeID; }\n\n    /**\n     * Write the contents of the record back, so it can be written", "refactored_code": "    public static final long _type = RecordTypes.TextCharsAtom.typeID;\n     * We are of type 4000\n     */\n    @Override\n    public long getRecordType() { return _type; }\n\n    /**\n     * Write the contents of the record back, so it can be written"}
{"magic_number_smell": "    public TextHeaderAtom() {\n        _header = new byte[8];\n        LittleEndian.putUShort(_header, 0, 0);\n        LittleEndian.putUShort(_header, 2, (int)RecordTypes.TextHeaderAtom.typeID);\n        LittleEndian.putInt(_header, 4, 4);\n\n        textType = TextPlaceholder.OTHER.nativeId;", "refactored_code": "    public static final long _type = RecordTypes.TextHeaderAtom.typeID;\n    public TextHeaderAtom() {\n        _header = new byte[8];\n        LittleEndian.putUShort(_header, 0, 0);\n        LittleEndian.putUShort(_header, 2, (int)_type);\n        LittleEndian.putInt(_header, 4, 4);\n\n        textType = TextPlaceholder.OTHER.nativeId;"}
{"magic_number_smell": "     */\n    public TextSpecInfoAtom() {\n        _header = new byte[8];\n        LittleEndian.putUInt(_header, 4, RecordTypes.TextSpecInfoAtom.typeID);\n        reset(1);\n    }\n", "refactored_code": "    private static final long _type = RecordTypes.TextSpecInfoAtom.typeID;\n     */\n    public TextSpecInfoAtom() {\n        _header = new byte[8];\n        LittleEndian.putUInt(_header, 4, _type);\n        reset(1);\n    }\n"}
{"magic_number_smell": "        if(len < 0) { len = 0; }\n\n        // Treat as an atom, grab and hold everything\n        _contents = IOUtils.safelyClone(source, start, len, 20_000_000);\n        _type = LittleEndian.getUShort(_contents,2);\n    }\n", "refactored_code": "    private static final int MAX_RECORD_LENGTH = 20_000_000;\n        if(len < 0) { len = 0; }\n\n        // Treat as an atom, grab and hold everything\n        _contents = IOUtils.safelyClone(source, start, len, MAX_RECORD_LENGTH);\n        _type = LittleEndian.getUShort(_contents,2);\n    }\n"}
{"magic_number_smell": "    private VBAInfoAtom() {\n        _header = new byte[8];\n        // TODO: fix me\n        LittleEndian.putUInt(_header, 0, RecordTypes.VBAInfoAtom.typeID);\n        persistIdRef = 0;\n        hasMacros = true;\n        version = 2;", "refactored_code": "    private static final long _type = RecordTypes.VBAInfoAtom.typeID;\n    private VBAInfoAtom() {\n        _header = new byte[8];\n        // TODO: fix me\n        LittleEndian.putUInt(_header, 0, _type);\n        persistIdRef = 0;\n        hasMacros = true;\n        version = 2;"}
{"magic_number_smell": "\n        // Setup our header block\n        _header[0] = 0x0f; // We are a container record\n        LittleEndian.putShort(_header, 2, (short) RecordTypes.VBAInfo.typeID);\n\n        // Setup our child records\n        findInterestingChildren();", "refactored_code": "    private static final long _type = RecordTypes.VBAInfo.typeID;\n\n        // Setup our header block\n        _header[0] = 0x0f; // We are a container record\n        LittleEndian.putShort(_header, 2, (short) _type);\n\n        // Setup our child records\n        findInterestingChildren();"}
{"magic_number_smell": "     * Returns 16-byte checksum of this picture\n     */\n    public byte[] getUID(){\n        return Arrays.copyOf(formattedData, 16);\n    }\n\n    @Override", "refactored_code": "    protected static final int CHECKSUM_SIZE = 16;\n     * Returns 16-byte checksum of this picture\n     */\n    public byte[] getUID(){\n        return Arrays.copyOf(formattedData, CHECKSUM_SIZE);\n    }\n\n    @Override"}
{"magic_number_smell": "    public double getLineWidth(){\n        AbstractEscherOptRecord opt = getEscherOptRecord();\n        EscherSimpleProperty prop = getEscherProperty(opt, EscherPropertyTypes.LINESTYLE__LINEWIDTH);\n        return (prop == null) ? 0.75 : Units.toPoints(prop.getPropertyValue());\n    }\n\n    /**", "refactored_code": "    public static final double DEFAULT_LINE_WIDTH = 0.75;\n    public double getLineWidth(){\n        AbstractEscherOptRecord opt = getEscherOptRecord();\n        EscherSimpleProperty prop = getEscherProperty(opt, EscherPropertyTypes.LINESTYLE__LINEWIDTH);\n        return (prop == null) ? DEFAULT_LINE_WIDTH : Units.toPoints(prop.getPropertyValue());\n    }\n\n    /**"}
{"magic_number_smell": "\n    //arbitrarily selected; may need to increase\n    private static final int 10_000_000 = 10_000_000;\n    private static int MAX_RECORD_LENGTH = 10_000_000;\n\n    enum LoadSavePhase {\n        INIT, LOADED", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 10_000_000;\n\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 10_000_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    enum LoadSavePhase {\n        INIT, LOADED"}
{"magic_number_smell": "    //arbitrarily selected; may need to increase\n    private static final int 200_000_000 = 200_000_000;\n    private static final int MAX_DOCUMENT_SIZE = 100_000_000;\n    private static int MAX_RECORD_LENGTH = 200_000_000;\n    private static final int MAX_IMAGE_LENGTH = 150_000_000;\n\n    // Holds metadata on where things are in our document", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 200_000_000;\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 200_000_000;\n    private static final int MAX_DOCUMENT_SIZE = 100_000_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n    private static final int MAX_IMAGE_LENGTH = 150_000_000;\n\n    // Holds metadata on where things are in our document"}
{"magic_number_smell": "        for (int csIdx = 0; csIdx < charStyles.size(); csIdx++) {\n            TextPropCollection p = charStyles.get(csIdx);\n            int ccStyle = p.getCharactersCovered();\n            if (ccStyle > 20_000) {\n                throw new IllegalStateException(\"Cannot process more than \" + 20_000 + \" styles, but had paragraph with \" + ccStyle);\n            }\n            for (int ccRun = 0; ccRun < ccStyle;) {", "refactored_code": "    private static final int MAX_NUMBER_OF_STYLES = 20_000;\n        for (int csIdx = 0; csIdx < charStyles.size(); csIdx++) {\n            TextPropCollection p = charStyles.get(csIdx);\n            int ccStyle = p.getCharactersCovered();\n            if (ccStyle > MAX_NUMBER_OF_STYLES) {\n                throw new IllegalStateException(\"Cannot process more than \" + MAX_NUMBER_OF_STYLES + \" styles, but had paragraph with \" + ccStyle);\n            }\n            for (int ccRun = 0; ccRun < ccStyle;) {"}
{"magic_number_smell": "     */\n    public static final int 0 = 0;\n    /**\n     * Specifies a wrapping rule that is equivalent to that of 0\n     * Excel 97, Excel 2000, Excel 2002, and Office Excel 2003 use this value.\n     * All other product versions listed at the beginning of this appendix ignore this value.\n     */", "refactored_code": "    public static final int WrapSquare = 0;\n     */\n    public static final int WrapSquare = 0;\n    /**\n     * Specifies a wrapping rule that is equivalent to that of WrapSquare\n     * Excel 97, Excel 2000, Excel 2002, and Office Excel 2003 use this value.\n     * All other product versions listed at the beginning of this appendix ignore this value.\n     */"}
{"magic_number_smell": "\n        // If it isn't unknown or custom, store it for lookup\n        if (id == -1\n            || (id >= 0x8000 && id <= ID_LAST_CUSTOM)\n            || (this instanceof CustomMAPIProperty)) {\n            // Custom/Unknown, skip\n        } else {", "refactored_code": "    private static final int ID_FIRST_CUSTOM = 0x8000;\n\n        // If it isn't unknown or custom, store it for lookup\n        if (id == -1\n            || (id >= ID_FIRST_CUSTOM && id <= ID_LAST_CUSTOM)\n            || (this instanceof CustomMAPIProperty)) {\n            // Custom/Unknown, skip\n        } else {"}
{"magic_number_smell": "\n    // arbitrarily selected; may need to increase\n    private static final int 1_000_000 = 1_000_000;\n    private static int MAX_RECORD_LENGTH = 1_000_000;\n\n    // standard prefix, defined in the spec\n    public static final String VARIABLE_LENGTH_PROPERTY_PREFIX = \"__substg1.0_\";", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 1_000_000;\n\n    // arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 1_000_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    // standard prefix, defined in the spec\n    public static final String VARIABLE_LENGTH_PROPERTY_PREFIX = \"__substg1.0_\";"}
{"magic_number_smell": "     * >here</a> for Xio explanation and details\n     */\n    public static int getColumnWidthInPx(int widthUnits) {\n        int pixels = (widthUnits / 256)\n            * UNIT_OFFSET_LENGTH;\n\n        int offsetWidthUnits = widthUnits % 256;", "refactored_code": "    private static final short EXCEL_COLUMN_WIDTH_FACTOR = 256;\n     * >here</a> for Xio explanation and details\n     */\n    public static int getColumnWidthInPx(int widthUnits) {\n        int pixels = (widthUnits / EXCEL_COLUMN_WIDTH_FACTOR)\n            * UNIT_OFFSET_LENGTH;\n\n        int offsetWidthUnits = widthUnits % EXCEL_COLUMN_WIDTH_FACTOR;"}
{"magic_number_smell": "\n    private static final Logger LOG = LogManager.getLogger(ExcelToFoConverter.class);\n\n    private static final float PAPER_A4_HEIGHT_INCHES = 29.4f / 2.54f;\n\n    private static final float PAPER_A4_WIDTH_INCHES = 21.0f / 2.54f;\n", "refactored_code": "    private static final float CM_PER_INCH = 2.54f;\n\n    private static final Logger LOG = LogManager.getLogger(ExcelToFoConverter.class);\n\n    private static final float PAPER_A4_HEIGHT_INCHES = 29.4f / CM_PER_INCH;\n\n    private static final float PAPER_A4_WIDTH_INCHES = 21.0f / CM_PER_INCH;\n"}
{"magic_number_smell": "        int imageSize = (int)Math.max(imageData.length, introSize+headerImageSize);\n\n        // create the image data and leave the parsing to the ImageIO api\n        byte[] buf = IOUtils.safelyAllocate(14 + (long)imageSize, HwmfPicture.getMaxRecordLength());\n\n        // https://en.wikipedia.org/wiki/BMP_file_format #  Bitmap file header\n        buf[0] = (byte)'B';", "refactored_code": "    private static final int BMP_HEADER_SIZE = 14;\n        int imageSize = (int)Math.max(imageData.length, introSize+headerImageSize);\n\n        // create the image data and leave the parsing to the ImageIO api\n        byte[] buf = IOUtils.safelyAllocate(BMP_HEADER_SIZE + (long)imageSize, HwmfPicture.getMaxRecordLength());\n\n        // https://en.wikipedia.org/wiki/BMP_file_format #  Bitmap file header\n        buf[0] = (byte)'B';"}
{"magic_number_smell": "        @Override\n        public int init(LittleEndianInputStream leis, long recordSize, EscapeFunction escapeFunction) throws IOException {\n            this.escapeFunction = escapeFunction;\n            escapeDataBytes = IOUtils.toByteArray(leis,(int)recordSize,0xFFFF);\n            return (int)recordSize;\n        }\n", "refactored_code": "    private static final int MAX_OBJECT_SIZE = 0xFFFF;\n        @Override\n        public int init(LittleEndianInputStream leis, long recordSize, EscapeFunction escapeFunction) throws IOException {\n            this.escapeFunction = escapeFunction;\n            escapeDataBytes = IOUtils.toByteArray(leis,(int)recordSize,MAX_OBJECT_SIZE);\n            return (int)recordSize;\n        }\n"}
{"magic_number_smell": "    public static HwmfPlaceableHeader readHeader(LittleEndianInputStream leis) throws IOException {\n        leis.mark(LittleEndianConsts.INT_SIZE);\n        int magic = leis.readInt();\n        if (magic == 0x9AC6CDD7) {\n            return new HwmfPlaceableHeader(leis);\n        } else {\n            leis.reset();", "refactored_code": "    public static final int WMF_HEADER_MAGIC = 0x9AC6CDD7;\n    public static HwmfPlaceableHeader readHeader(LittleEndianInputStream leis) throws IOException {\n        leis.mark(LittleEndianConsts.INT_SIZE);\n        int magic = leis.readInt();\n        if (magic == WMF_HEADER_MAGIC) {\n            return new HwmfPlaceableHeader(leis);\n        } else {\n            leis.reset();"}
{"magic_number_smell": "public class HwmfText {\n    private static final Logger LOG = LogManager.getLogger(HwmfText.class);\n    private static final int 1_000_000 = 1_000_000;\n    private static int MAX_RECORD_LENGTH = 1_000_000;\n\n    /**\n     * @param length the max record length allowed for HwmfText", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 1_000_000;\npublic class HwmfText {\n    private static final Logger LOG = LogManager.getLogger(HwmfText.class);\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 1_000_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    /**\n     * @param length the max record length allowed for HwmfText"}
{"magic_number_smell": "public class HwmfPicture implements Iterable<HwmfRecord>, GenericRecord {\n    /** Max. record length - processing longer records will throw an exception */\n    public static final int 100_000_000 = 100_000_000;\n    public static int MAX_RECORD_LENGTH = 100_000_000;\n\n    private static final Logger LOG = LogManager.getLogger(HwmfPicture.class);\n", "refactored_code": "    public static final int DEFAULT_MAX_RECORD_LENGTH = 100_000_000;\npublic class HwmfPicture implements Iterable<HwmfRecord>, GenericRecord {\n    /** Max. record length - processing longer records will throw an exception */\n    public static final int DEFAULT_MAX_RECORD_LENGTH = 100_000_000;\n    public static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    private static final Logger LOG = LogManager.getLogger(HwmfPicture.class);\n"}
{"magic_number_smell": "    private static final String PROPERTY_PRESERVE_TEXT_TABLE = \"org.apache.poi.hwpf.preserveTextTable\";\n    //arbitrarily selected; may need to increase\n    private static final int 100_000 = 100_000;\n    private static int MAX_RECORD_LENGTH = 100_000;\n\n    private static final String STREAM_DATA = \"Data\";\n", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000;\n    private static final String PROPERTY_PRESERVE_TEXT_TABLE = \"org.apache.poi.hwpf.preserveTextTable\";\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    private static final String STREAM_DATA = \"Data\";\n"}
{"magic_number_smell": "\n    //arbitrarily selected; may need to increase\n    private static final int 500_000_000 = 500_000_000;\n    private static int MAX_RECORD_LENGTH = 500_000_000;\n\n    /**\n     * @param length the max record length allowed for HWPFDocumentCore", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 500_000_000;\n\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 500_000_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    /**\n     * @param length the max record length allowed for HWPFDocumentCore"}
{"magic_number_smell": "\n    //arbitrarily selected; may need to increase\n    private static final int 10_000_000 = 10_000_000;\n    private static int MAX_RECORD_LENGTH = 10_000_000;\n\n    /**\n     * @param length the max record length allowed for HWPFOldDocument", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 10_000_000;\n\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 10_000_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    /**\n     * @param length the max record length allowed for HWPFOldDocument"}
{"magic_number_smell": "            }\n\n            if (text.endsWith(\"\\r\")\n                || (text.charAt(text.length() - 1) == 7 && currentTableLevel != Integer.MIN_VALUE)) {\n                text = text.substring(0, text.length() - 1);\n            }\n", "refactored_code": "    private static final byte BEL_MARK = 7;\n            }\n\n            if (text.endsWith(\"\\r\")\n                || (text.charAt(text.length() - 1) == BEL_MARK && currentTableLevel != Integer.MIN_VALUE)) {\n                text = text.substring(0, text.length() - 1);\n            }\n"}
{"magic_number_smell": "            return toLetters( num ).toUpperCase(Locale.ROOT);\n        case T_LOWER_LETTER:\n            return toLetters( num );\n        case 0:\n        case T_ORDINAL:\n        default:\n            return String.valueOf( num );", "refactored_code": "    private static final int T_ARABIC = 0;\n            return toLetters( num ).toUpperCase(Locale.ROOT);\n        case T_LOWER_LETTER:\n            return toLetters( num );\n        case T_ARABIC:\n        case T_ORDINAL:\n        default:\n            return String.valueOf( num );"}
{"magic_number_smell": "\n        // avoid StackOverflowException with very deeply nested files (mostly synthetic test files via fuzzing)\n        // if this limit is reached in real-word documents, we can make this configurable\n        if (note.getParentNode() != null && note.getParentNode().getChildNodes().getLength() > 300) {\n            throw new IllegalStateException(\"Had more than the limit of \" + 300 + \" nested child notes\");\n        }\n", "refactored_code": "    private static final int MAX_NESTED_CHILD_NODES = 300;\n\n        // avoid StackOverflowException with very deeply nested files (mostly synthetic test files via fuzzing)\n        // if this limit is reached in real-word documents, we can make this configurable\n        if (note.getParentNode() != null && note.getParentNode().getChildNodes().getLength() > MAX_NESTED_CHILD_NODES) {\n            throw new IllegalStateException(\"Had more than the limit of \" + MAX_NESTED_CHILD_NODES + \" nested child notes\");\n        }\n"}
{"magic_number_smell": "        int fcOffset = 0;\n\n        // total size is currently the size of one FC\n        int totalSize = 4 + 2;\n\n        int index = 0;\n        for ( ; index < size; index++ )", "refactored_code": "    private static final int FC_SIZE = 4;\n        int fcOffset = 0;\n\n        // total size is currently the size of one FC\n        int totalSize = FC_SIZE + 2;\n\n        int index = 0;\n        for ( ; index < size; index++ )"}
{"magic_number_smell": "        //skips through the prms before we reach the piece table. These contain data\n        //for actual fast saved files\n        List<SprmBuffer> sprmBuffers = new LinkedList<>();\n        while (tableStream[offset] == 1) {\n            offset++;\n            int size = LittleEndian.getShort(tableStream, offset);\n            offset += LittleEndianConsts.SHORT_SIZE;", "refactored_code": "    private static final byte GRPPRL_TYPE = 1;\n        //skips through the prms before we reach the piece table. These contain data\n        //for actual fast saved files\n        List<SprmBuffer> sprmBuffers = new LinkedList<>();\n        while (tableStream[offset] == GRPPRL_TYPE) {\n            offset++;\n            int size = LittleEndian.getShort(tableStream, offset);\n            offset += LittleEndianConsts.SHORT_SIZE;"}
{"magic_number_smell": "\n    public int getFieldType()\n    {\n        if ( getCh() != 0x13 )\n            throw new UnsupportedOperationException(\n                    \"This field is only defined for begin marks.\" );\n        return getFlt();", "refactored_code": "    public static final int FIELD_BEGIN_MARK = 0x13;\n\n    public int getFieldType()\n    {\n        if ( getCh() != FIELD_BEGIN_MARK )\n            throw new UnsupportedOperationException(\n                    \"This field is only defined for begin marks.\" );\n        return getFlt();"}
{"magic_number_smell": "        if ( start <= 0 || length <= 0 )\n            return null;\n\n        return new PlexOfCps( tableStream, start, length, 2 );\n    }\n\n    private int savePlex( FileInformationBlock fib, FieldsDocumentPart part,", "refactored_code": "    private static final int FLD_SIZE = 2;\n        if ( start <= 0 || length <= 0 )\n            return null;\n\n        return new PlexOfCps( tableStream, start, length, FLD_SIZE );\n    }\n\n    private int savePlex( FileInformationBlock fib, FieldsDocumentPart part,"}
{"magic_number_smell": "\n    public byte[] toByteArray()\n    {\n        byte[] buf = IOUtils.safelyAllocate(getSizeInBytes(), 10_485_760);\n        int offset = 0;\n\n        _lvlf.setCbGrpprlChpx( (short) _grpprlChpx.length );", "refactored_code": "    private static final int MAX_RECORD_LENGTH = 10_485_760;\n\n    public byte[] toByteArray()\n    {\n        byte[] buf = IOUtils.safelyAllocate(getSizeInBytes(), MAX_RECORD_LENGTH);\n        int offset = 0;\n\n        _lvlf.setCbGrpprlChpx( (short) _grpprlChpx.length );"}
{"magic_number_smell": "        }\n\n        // make sure these do not cause OOM if passed as invalid or extremely large values\n        IOUtils.safelyAllocateCheck(lcb, 100_000);\n        IOUtils.safelyAllocateCheck(cbHeader, 100_000);\n\n        // skip the 62 ignored bytes", "refactored_code": "    private static final int MAX_SIZE = 100_000;\n        }\n\n        // make sure these do not cause OOM if passed as invalid or extremely large values\n        IOUtils.safelyAllocateCheck(lcb, MAX_SIZE);\n        IOUtils.safelyAllocateCheck(cbHeader, MAX_SIZE);\n\n        // skip the 62 ignored bytes"}
{"magic_number_smell": "     */\n    protected byte[] getGrpprl(int index)\n    {\n        int papxOffset = 2 * LittleEndian.getUByte(_fkp, _offset + (((_crun + 1) * FC_SIZE) + (index * 13)));\n        int size = 2 * LittleEndian.getUByte(_fkp, _offset + papxOffset);\n        if(size == 0) {\n            size = 2 * LittleEndian.getUByte(_fkp, _offset + ++papxOffset);", "refactored_code": "    private static final int BX_SIZE = 13;\n     */\n    protected byte[] getGrpprl(int index)\n    {\n        int papxOffset = 2 * LittleEndian.getUByte(_fkp, _offset + (((_crun + 1) * FC_SIZE) + (index * BX_SIZE)));\n        int size = 2 * LittleEndian.getUByte(_fkp, _offset + papxOffset);\n        if(size == 0) {\n            size = 2 * LittleEndian.getUByte(_fkp, _offset + ++papxOffset);"}
{"magic_number_smell": "        int structBufSize = +(_cbStruct * size);\n        int bufSize = cpBufSize + structBufSize;\n\n        byte[] buf = IOUtils.safelyAllocate(bufSize, 10_485_760);\n\n        int nodeEnd = 0;\n        for (int x = 0; x < size; x++) {", "refactored_code": "    private static final int MAX_RECORD_LENGTH = 10_485_760;\n        int structBufSize = +(_cbStruct * size);\n        int bufSize = cpBufSize + structBufSize;\n\n        byte[] buf = IOUtils.safelyAllocate(bufSize, MAX_RECORD_LENGTH);\n\n        int nodeEnd = 0;\n        for (int x = 0; x < size; x++) {"}
{"magic_number_smell": "                            + Integer.MAX_VALUE + \" elements\" );\n        }\n\n        IOUtils.safelyAllocateCheck(lfoMacLong, 100_000);\n\n        this._lfoMac = (int) lfoMacLong;\n        _rgLfo = new LFO[_lfoMac];", "refactored_code": "    private static final int MAX_NUMBER_OF_LFO = 100_000;\n                            + Integer.MAX_VALUE + \" elements\" );\n        }\n\n        IOUtils.safelyAllocateCheck(lfoMacLong, MAX_NUMBER_OF_LFO);\n\n        this._lfoMac = (int) lfoMacLong;\n        _rgLfo = new LFO[_lfoMac];"}
{"magic_number_smell": "            byte[] documentStream, byte[] tableStream,\n            int offset, int size, int fcMin, TextPieceTable tpt, int mainLength)\n    {\n        PlexOfCps sedPlex = new PlexOfCps(tableStream, offset, size, 12);\n        //this.tpt = tpt;\n        this._text = tpt.getTextPieces();\n", "refactored_code": "    private static final int SED_SIZE = 12;\n            byte[] documentStream, byte[] tableStream,\n            int offset, int size, int fcMin, TextPieceTable tpt, int mainLength)\n    {\n        PlexOfCps sedPlex = new PlexOfCps(tableStream, offset, size, SED_SIZE);\n        //this.tpt = tpt;\n        this._text = tpt.getTextPieces();\n"}
{"magic_number_smell": "\n    static String[] readSttbSavedBy( byte[] buffer, int startOffset )\n    {\n        return new Sttb( 2, buffer, startOffset )\n                .getData();\n    }\n", "refactored_code": "    private static final int CDATA_SIZE_STTB_SAVED_BY = 2; // bytes\n\n    static String[] readSttbSavedBy( byte[] buffer, int startOffset )\n    {\n        return new Sttb( CDATA_SIZE_STTB_SAVED_BY, buffer, startOffset )\n                .getData();\n    }\n"}
{"magic_number_smell": "\n    public byte[] getCHPX() {\n        switch (_stdfBase.getStk()) {\n            case 1:\n                if (_upxs.length > 1) {\n                    return _upxs[1].getUPX();\n                }", "refactored_code": "    private static final int PARAGRAPH_STYLE = 1;\n\n    public byte[] getCHPX() {\n        switch (_stdfBase.getStk()) {\n            case PARAGRAPH_STYLE:\n                if (_upxs.length > 1) {\n                    return _upxs[1].getUPX();\n                }"}
{"magic_number_smell": "        int baseIndex = sd.getBaseStyle();\n        if (pap == null && papx != null) {\n            ParagraphProperties parentPAP = new ParagraphProperties();\n            if (baseIndex != 4095) {\n\n                StyleDescription styleDescription = _styleDescriptions[baseIndex];\n                if (styleDescription == null) {", "refactored_code": "    public static final int NIL_STYLE = 4095;\n        int baseIndex = sd.getBaseStyle();\n        if (pap == null && papx != null) {\n            ParagraphProperties parentPAP = new ParagraphProperties();\n            if (baseIndex != NIL_STYLE) {\n\n                StyleDescription styleDescription = _styleDescriptions[baseIndex];\n                if (styleDescription == null) {"}
{"magic_number_smell": "    private static final Logger LOG = LogManager.getLogger(TextPieceTable.class);\n    //arbitrarily selected; may need to increase\n    private static final int 100_000_000 = 100_000_000;\n    private static int MAX_RECORD_LENGTH = 100_000_000;\n\n    /**\n     * @param length the max record length allowed for TextPieceTable", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000_000;\n    private static final Logger LOG = LogManager.getLogger(TextPieceTable.class);\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000_000;\n    private static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    /**\n     * @param length the max record length allowed for TextPieceTable"}
{"magic_number_smell": "        _xst.serialize( data, offset );\n        offset += _xst.getSize();\n\n        LittleEndian.putUShort( data, offset, 0 );\n        offset += LittleEndianConsts.SHORT_SIZE;\n\n        return offset - startOffset;", "refactored_code": "    private final short _chTerm = 0;\n        _xst.serialize( data, offset );\n        offset += _xst.getSize();\n\n        LittleEndian.putUShort( data, offset, _chTerm );\n        offset += LittleEndianConsts.SHORT_SIZE;\n\n        return offset - startOffset;"}
{"magic_number_smell": "    /**\n     * Text animation.\n     *\n     * @return One of {@link #0},{@link #SFXTTEXT_LAS_VEGAS_LIGHTS},{@link #SFXTTEXT_BACKGROUND_BLINK},\n     *      {@link #SFXTTEXT_SPARKLE_TEXT},{@link #SFXTTEXT_MARCHING_ANTS},{@link #SFXTTEXT_MARCHING_RED_ANTS},\n     *      {@link #SFXTTEXT_SHIMMER}\n     */", "refactored_code": "    protected static final byte SFXTTEXT_NO = 0;\n    /**\n     * Text animation.\n     *\n     * @return One of {@link #SFXTTEXT_NO},{@link #SFXTTEXT_LAS_VEGAS_LIGHTS},{@link #SFXTTEXT_BACKGROUND_BLINK},\n     *      {@link #SFXTTEXT_SPARKLE_TEXT},{@link #SFXTTEXT_MARCHING_ANTS},{@link #SFXTTEXT_MARCHING_RED_ANTS},\n     *      {@link #SFXTTEXT_SHIMMER}\n     */"}
{"magic_number_smell": "     *\n     * @return One of\n     * <ul>\n     * <li>{@link #0}\n     * <li>{@link #HRES_NORMAL}\n     * <li>{@link #HRES_ADD_LETTER_BEFORE}\n     * <li>{@link #HRES_CHANGE_LETTER_BEFORE}", "refactored_code": "    public static final byte HRES_NO = 0;\n     *\n     * @return One of\n     * <ul>\n     * <li>{@link #HRES_NO}\n     * <li>{@link #HRES_NORMAL}\n     * <li>{@link #HRES_ADD_LETTER_BEFORE}\n     * <li>{@link #HRES_CHANGE_LETTER_BEFORE}"}
{"magic_number_smell": "     * Border line style.\n     *\n     * @return One of <ul>\n     * <li>{@link #0}\n     * <li>{@link #BRCL_THICK}\n     * <li>{@link #BRCL_DOUBLE}\n     * <li>{@link #BRCL_SHADOW}", "refactored_code": "    protected static final byte BRCL_SINGLE = 0;\n     * Border line style.\n     *\n     * @return One of <ul>\n     * <li>{@link #BRCL_SINGLE}\n     * <li>{@link #BRCL_THICK}\n     * <li>{@link #BRCL_DOUBLE}\n     * <li>{@link #BRCL_SHADOW}"}
{"magic_number_smell": "     * Break code.\n     *\n     * @return One of <ul>\n     * <li>{@link #0}\n     * <li>{@link #BKC_NEW_COLUMN}\n     * <li>{@link #BKC_NEW_PAGE}\n     * <li>{@link #BKC_EVEN_PAGE}", "refactored_code": "    public static final byte BKC_NO_BREAK = 0;\n     * Break code.\n     *\n     * @return One of <ul>\n     * <li>{@link #BKC_NO_BREAK}\n     * <li>{@link #BKC_NEW_COLUMN}\n     * <li>{@link #BKC_NEW_PAGE}\n     * <li>{@link #BKC_EVEN_PAGE}"}
{"magic_number_smell": "\n    //arbitrarily selected; may need to increase\n    private static final int 100_000 = 100_000;\n    static int MAX_RECORD_LENGTH = 100_000;\n\n    /**\n     * @param length the max record length allowed for SPRM data", "refactored_code": "    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000;\n\n    //arbitrarily selected; may need to increase\n    private static final int DEFAULT_MAX_RECORD_LENGTH = 100_000;\n    static int MAX_RECORD_LENGTH = DEFAULT_MAX_RECORD_LENGTH;\n\n    /**\n     * @param length the max record length allowed for SPRM data"}
{"magic_number_smell": "  public void setJustification(byte jc)\n  {\n    _props.setJc(jc);\n    _papx.updateSprm(0x2403, jc);\n  }\n\n  public boolean keepOnPage()", "refactored_code": "    public static final short SPRM_JC = 0x2403;\n  public void setJustification(byte jc)\n  {\n    _props.setJc(jc);\n    _papx.updateSprm(SPRM_JC, jc);\n  }\n\n  public boolean keepOnPage()"}
{"magic_number_smell": "        try (VisioTextExtractor extractor1 = openExtractor(defFilename)) {\n            assertNotNull(extractor1);\n            assertNotNull(extractor1.getAllText());\n            assertEquals(5, extractor1.getAllText().length);\n        }\n\n        try (InputStream is2 = _dgTests.openResourceAsStream(defFilename);", "refactored_code": "    private final int defTextChunks = 5;\n        try (VisioTextExtractor extractor1 = openExtractor(defFilename)) {\n            assertNotNull(extractor1);\n            assertNotNull(extractor1.getAllText());\n            assertEquals(defTextChunks, extractor1.getAllText().length);\n        }\n\n        try (InputStream is2 = _dgTests.openResourceAsStream(defFilename);"}
{"magic_number_smell": "    @Test\n    void testTrailer() {\n        // Find the trailer\n        Pointer trailerPtr = ptrFactory.createPointer(contents, 0x24);\n\n        assertEquals(20, trailerPtr.getType());\n        assertEquals(trailerDataAt, trailerPtr.getOffset());", "refactored_code": "    private final int trailerPointerAt = 0x24;\n    @Test\n    void testTrailer() {\n        // Find the trailer\n        Pointer trailerPtr = ptrFactory.createPointer(contents, trailerPointerAt);\n\n        assertEquals(20, trailerPtr.getType());\n        assertEquals(trailerDataAt, trailerPtr.getOffset());"}
{"magic_number_smell": "        StyleTextPropAtom stpb = new StyleTextPropAtom(data_b,0,data_b.length);\n\n        // Set for the appropriate text sizes\n        stpa.setParentTextSize(0x36-1);\n        stpb.setParentTextSize(data_b_text_len);\n\n        // In case A, there is a single styling of the characters", "refactored_code": "    private static final int data_a_text_len = 0x36-1;\n        StyleTextPropAtom stpb = new StyleTextPropAtom(data_b,0,data_b.length);\n\n        // Set for the appropriate text sizes\n        stpa.setParentTextSize(data_a_text_len);\n        stpb.setParentTextSize(data_b_text_len);\n\n        // In case A, there is a single styling of the characters"}
{"magic_number_smell": "\n            assertEquals(originalText, text);\n\n            assertEquals(122, para.getStartOffset());\n        }\n    }\n", "refactored_code": "    private static final int insertionPoint = 122;\n\n            assertEquals(originalText, text);\n\n            assertEquals(insertionPoint, para.getStartOffset());\n        }\n    }\n"}
{"magic_number_smell": "     * \n     * @param originatingContext an ObjectContext that initiated the sync. Can be null.\n     * @param changes diff from the context that initiated the sync.\n     * @param syncType One of {@link #1}, {@link #FLUSH_CASCADE_SYNC},\n     *            {@link #ROLLBACK_CASCADE_SYNC}.\n     */\n    GraphDiff onSync(ObjectContext originatingContext, GraphDiff changes, int syncType);", "refactored_code": "    public static final int FLUSH_NOCASCADE_SYNC = 1;\n     * \n     * @param originatingContext an ObjectContext that initiated the sync. Can be null.\n     * @param changes diff from the context that initiated the sync.\n     * @param syncType One of {@link #FLUSH_NOCASCADE_SYNC}, {@link #FLUSH_CASCADE_SYNC},\n     *            {@link #ROLLBACK_CASCADE_SYNC}.\n     */\n    GraphDiff onSync(ObjectContext originatingContext, GraphDiff changes, int syncType);"}
{"magic_number_smell": "            idSnapshot.forEach((key, value) -> {\n                Object initial = value;\n                int safeguard = 0;\n                while (value instanceof Supplier && safeguard < 1000) {\n                    value = ((Supplier<?>) value).get();\n                    safeguard++;\n                }", "refactored_code": "    private static final int MAX_NESTED_SUPPLIER_LEVEL = 1000;\n            idSnapshot.forEach((key, value) -> {\n                Object initial = value;\n                int safeguard = 0;\n                while (value instanceof Supplier && safeguard < MAX_NESTED_SUPPLIER_LEVEL) {\n                    value = ((Supplier<?>) value).get();\n                    safeguard++;\n                }"}
{"magic_number_smell": "\n    public DeleteBuilder(String table) {\n        super(new DeleteNode(), WHERE_NODE + 1);\n        node(0, () -> new TableNode(table, null));\n    }\n\n    public DeleteBuilder(DbEntity table) {", "refactored_code": "    private static final int TABLE_NODE = 0;\n\n    public DeleteBuilder(String table) {\n        super(new DeleteNode(), WHERE_NODE + 1);\n        node(TABLE_NODE, () -> new TableNode(table, null));\n    }\n\n    public DeleteBuilder(DbEntity table) {"}
{"magic_number_smell": "\n    public InsertBuilder(String table) {\n        super(new InsertNode(), VALUES_NODE + 1);\n        node(0, () -> new TableNode(table, null));\n    }\n\n    public InsertBuilder(DbEntity table) {", "refactored_code": "    private static final int TABLE_NODE   = 0;\n\n    public InsertBuilder(String table) {\n        super(new InsertNode(), VALUES_NODE + 1);\n        node(TABLE_NODE, () -> new TableNode(table, null));\n    }\n\n    public InsertBuilder(DbEntity table) {"}
{"magic_number_smell": "    SelectBuilder(NodeBuilder... selectExpressions) {\n        super(new SelectNode(), LIMIT_NODE + 1);\n        for(NodeBuilder exp : selectExpressions) {\n            node(0, SelectResultNode::new).addChild(exp.build());\n        }\n    }\n", "refactored_code": "    private static final int SELECT_NODE    = 0;\n    SelectBuilder(NodeBuilder... selectExpressions) {\n        super(new SelectNode(), LIMIT_NODE + 1);\n        for(NodeBuilder exp : selectExpressions) {\n            node(SELECT_NODE, SelectResultNode::new).addChild(exp.build());\n        }\n    }\n"}
{"magic_number_smell": "\n    public UpdateBuilder(String table) {\n        super(new UpdateNode(), WHERE_NODE + 1);\n        node(0, () -> new TableNode(table, null));\n    }\n\n    public UpdateBuilder(DbEntity table) {", "refactored_code": "    private static final int TABLE_NODE = 0;\n\n    public UpdateBuilder(String table) {\n        super(new UpdateNode(), WHERE_NODE + 1);\n        node(TABLE_NODE, () -> new TableNode(table, null));\n    }\n\n    public UpdateBuilder(DbEntity table) {"}
{"magic_number_smell": "\t}\n\n\tpublic ParameterBinding() {\n\t\tthis.statementPosition = -1;\n\t}\n\n\tpublic Object getValue() {", "refactored_code": "\tprivate static final int EXCLUDED_POSITION = -1;\n\t}\n\n\tpublic ParameterBinding() {\n\t\tthis.statementPosition = EXCLUDED_POSITION;\n\t}\n\n\tpublic Object getValue() {"}
{"magic_number_smell": "\n\tprotected byte[] readBinaryStream(ResultSet rs, int index) throws IOException, SQLException {\n\t\ttry (InputStream in = rs.getBinaryStream(index);) {\n\t\t\treturn (in != null) ? readValueStream(in, -1, 8 * 1024) : null;\n\t\t}\n\t}\n", "refactored_code": "\tprivate static final int BUF_SIZE = 8 * 1024;\n\n\tprotected byte[] readBinaryStream(ResultSet rs, int index) throws IOException, SQLException {\n\t\ttry (InputStream in = rs.getBinaryStream(index);) {\n\t\t\treturn (in != null) ? readValueStream(in, -1, BUF_SIZE) : null;\n\t\t}\n\t}\n"}
{"magic_number_smell": "\n\tprotected String readCharStream(ResultSet rs, int index) throws IOException, SQLException {\n\t\ttry (Reader in = rs.getCharacterStream(index);) {\n\t\t\treturn in != null ? readValueStream(in, -1, 8 * 1024) : null;\n\t\t}\n\t}\n", "refactored_code": "\tprivate static final int BUF_SIZE = 8 * 1024;\n\n\tprotected String readCharStream(ResultSet rs, int index) throws IOException, SQLException {\n\t\ttry (Reader in = rs.getCharacterStream(index);) {\n\t\t\treturn in != null ? readValueStream(in, -1, BUF_SIZE) : null;\n\t\t}\n\t}\n"}
{"magic_number_smell": "\tpublic static final int SHRINK_STAMP = 2;\n\tpublic static final int LEAF_STAMP = 3;\n\n\tprivate int stamp = -1;\n\n\tpublic DepthFirstStampSearch(DigraphIteration<E, ?> factory, E firstVertex) {\n\t\tsuper(factory, firstVertex);", "refactored_code": "\tpublic static final int UNDEFINED_STAMP = -1;\n\tpublic static final int SHRINK_STAMP = 2;\n\tpublic static final int LEAF_STAMP = 3;\n\n\tprivate int stamp = UNDEFINED_STAMP;\n\n\tpublic DepthFirstStampSearch(DigraphIteration<E, ?> factory, E firstVertex) {\n\t\tsuper(factory, firstVertex);"}
{"magic_number_smell": "    private int maxSize;\n\n    public MapQueryCache() {\n        this(1000);\n    }\n\n    public MapQueryCache(int maxSize) {", "refactored_code": "    public static final int DEFAULT_CACHE_SIZE = 1000;\n    private int maxSize;\n\n    public MapQueryCache() {\n        this(DEFAULT_CACHE_SIZE);\n    }\n\n    public MapQueryCache(int maxSize) {"}
{"magic_number_smell": "        extend(binder).initAllExtensions()\n\n                // global stack properties\n                .setProperty(Constants.MAX_ID_QUALIFIER_SIZE_PROPERTY, 10000)\n                .setProperty(Constants.CONTEXTS_SYNC_PROPERTY, \"false\")\n\n                // known DbAdapter detectors in reverse order of popularity.", "refactored_code": "    private static final int DEFAULT_MAX_ID_QUALIFIER_SIZE = 10000;\n        extend(binder).initAllExtensions()\n\n                // global stack properties\n                .setProperty(Constants.MAX_ID_QUALIFIER_SIZE_PROPERTY, DEFAULT_MAX_ID_QUALIFIER_SIZE)\n                .setProperty(Constants.CONTEXTS_SYNC_PROPERTY, \"false\")\n\n                // known DbAdapter detectors in reverse order of popularity."}
{"magic_number_smell": "\n    protected JdbcAdapter adapter;\n    protected ConcurrentMap<String, Queue<Long>> pkCache = new ConcurrentHashMap<>();\n    protected int pkCacheSize = 20;\n    protected long pkStartValue = DEFAULT_PK_START_VALUE;\n\n    /**", "refactored_code": "    public static final int DEFAULT_PK_CACHE_SIZE = 20;\n\n    protected JdbcAdapter adapter;\n    protected ConcurrentMap<String, Queue<Long>> pkCache = new ConcurrentHashMap<>();\n    protected int pkCacheSize = DEFAULT_PK_CACHE_SIZE;\n    protected long pkStartValue = DEFAULT_PK_START_VALUE;\n\n    /**"}
{"magic_number_smell": "\t */\n\tpublic static int getSqlTypeByName(String typeName) {\n\t\tInteger tmp = SQL_STRING_TYPE.get(typeName);\n\t\treturn tmp == null ? Integer.MAX_VALUE : tmp;\n\t}\n\n\t/**", "refactored_code": "\tpublic static final int NOT_DEFINED = Integer.MAX_VALUE;\n\t */\n\tpublic static int getSqlTypeByName(String typeName) {\n\t\tInteger tmp = SQL_STRING_TYPE.get(typeName);\n\t\treturn tmp == null ? NOT_DEFINED : tmp;\n\t}\n\n\t/**"}
{"magic_number_smell": "\n        // need to slice for batches of 1500 values\n        if(value instanceof Object[]) {\n            for(Object[] slice : ArrayUtil.sliceArray((Object[])value, 1500)) {\n                newChildren.add(newSliceNode(child, arg, valueNode, slice));\n            }\n        } else if(value instanceof int[]) {", "refactored_code": "    private static final int FIREBIRD_IN_BATCH_SIZE = 1500;\n\n        // need to slice for batches of 1500 values\n        if(value instanceof Object[]) {\n            for(Object[] slice : ArrayUtil.sliceArray((Object[])value, FIREBIRD_IN_BATCH_SIZE)) {\n                newChildren.add(newSliceNode(child, arg, valueNode, slice));\n            }\n        } else if(value instanceof int[]) {"}
{"magic_number_smell": "\n        // need to slice for batches of 1000 values\n        if(value instanceof Object[]) {\n            for(Object[] slice : ArrayUtil.sliceArray((Object[])value, 1000)) {\n                newChildren.add(newSliceNode(child, arg, valueNode, slice));\n            }\n        } else if(value instanceof int[]) {", "refactored_code": "    private static final int ORACLE_IN_BATCH_SIZE = 1000;\n\n        // need to slice for batches of 1000 values\n        if(value instanceof Object[]) {\n            for(Object[] slice : ArrayUtil.sliceArray((Object[])value, ORACLE_IN_BATCH_SIZE)) {\n                newChildren.add(newSliceNode(child, arg, valueNode, slice));\n            }\n        } else if(value instanceof int[]) {"}
{"magic_number_smell": "        DbEntity entity = pk.getEntity();\n\n        //check key on UNIQUEIDENTIFIER; UNIQUEIDENTIFIER is a character with a length of 36\n        if (TypesMapping.isCharacter(pk.getType()) && pk.getMaxLength() == 36) {\n            return guidPkFromDatabase(node, entity);\n        } else {\n            return super.generatePk(node, pk);", "refactored_code": "    private static final int MAX_LENGTH_GUID = 36;\n        DbEntity entity = pk.getEntity();\n\n        //check key on UNIQUEIDENTIFIER; UNIQUEIDENTIFIER is a character with a length of 36\n        if (TypesMapping.isCharacter(pk.getType()) && pk.getMaxLength() == MAX_LENGTH_GUID) {\n            return guidPkFromDatabase(node, entity);\n        } else {\n            return super.generatePk(node, pk);"}
{"magic_number_smell": "     * Creates a multithreaded EventManager using default thread count.\n     */\n    public DefaultEventManager() {\n        this(5);\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_DISPATCH_THREAD_COUNT = 5;\n     * Creates a multithreaded EventManager using default thread count.\n     */\n    public DefaultEventManager() {\n        this(DEFAULT_DISPATCH_THREAD_COUNT);\n    }\n\n    /**"}
{"magic_number_smell": "     * EventManager.\n     */\n    public boolean receivesLocalEvents() {\n        return mode == RECEIVE_LOCAL_EXTERNAL || mode == 1;\n    }\n\n    /**", "refactored_code": "    public static final int RECEIVE_LOCAL = 1;\n     * EventManager.\n     */\n    public boolean receivesLocalEvents() {\n        return mode == RECEIVE_LOCAL_EXTERNAL || mode == RECEIVE_LOCAL;\n    }\n\n    /**"}
{"magic_number_smell": "\t\t// optimizing parser buffers per CAY-1667...\n\t\t// adding 1 extra char to the buffer size above the String length, as\n\t\t// otherwise resizing still occurs at the end of the stream\n\t\tint bufferSize = expressionString.length() > 4096 ?\n\t\t\t\t4096 : expressionString.length() + 1;\n\t\tReader reader = new StringReader(expressionString);\n\t\tJavaCharStream stream = new JavaCharStream(reader, 1, 1, bufferSize);", "refactored_code": "\tprivate static final int PARSE_BUFFER_MAX_SIZE = 4096;\n\t\t// optimizing parser buffers per CAY-1667...\n\t\t// adding 1 extra char to the buffer size above the String length, as\n\t\t// otherwise resizing still occurs at the end of the stream\n\t\tint bufferSize = expressionString.length() > PARSE_BUFFER_MAX_SIZE ?\n\t\t\t\tPARSE_BUFFER_MAX_SIZE : expressionString.length() + 1;\n\t\tReader reader = new StringReader(expressionString);\n\t\tJavaCharStream stream = new JavaCharStream(reader, 1, 1, bufferSize);"}
{"magic_number_smell": "\n\t\tESCAPE_ALPHABET = new boolean[Byte.MAX_VALUE];\n\t\t// exclude certain chars, such as unprintable ones, and ?\n\t\tfor (int i = '!'; i < Byte.MAX_VALUE; i++) {\n\n\t\t\tif (i != '?' && i != '\\\"' && i != '\\'' && i != WILDCARD_SEQUENCE && i != WILDCARD_ONE) {\n\t\t\t\tESCAPE_ALPHABET[i] = true;", "refactored_code": "\tprivate static final int ESCAPE_ALPHABET_START = '!';\n\n\t\tESCAPE_ALPHABET = new boolean[Byte.MAX_VALUE];\n\t\t// exclude certain chars, such as unprintable ones, and ?\n\t\tfor (int i = ESCAPE_ALPHABET_START; i < Byte.MAX_VALUE; i++) {\n\n\t\t\tif (i != '?' && i != '\\\"' && i != '\\'' && i != WILDCARD_SEQUENCE && i != WILDCARD_ONE) {\n\t\t\t\tESCAPE_ALPHABET[i] = true;"}
{"magic_number_smell": "            \t\treturn lhs.longValue() == rhs.longValue();\n            \t\t\n            \t} else if (Double.class.equals(widestClass)) {\n            \t\treturn Math.abs(lhs.doubleValue() - rhs.doubleValue()) < 0.0000001;\n            \t\t\n            \t} else if (Short.class.equals(widestClass)) {\n                \treturn lhs.shortValue() == rhs.shortValue();", "refactored_code": "    private static final double EPSILON = 0.0000001;\n            \t\treturn lhs.longValue() == rhs.longValue();\n            \t\t\n            \t} else if (Double.class.equals(widestClass)) {\n            \t\treturn Math.abs(lhs.doubleValue() - rhs.doubleValue()) < EPSILON;\n            \t\t\n            \t} else if (Short.class.equals(widestClass)) {\n                \treturn lhs.shortValue() == rhs.shortValue();"}
{"magic_number_smell": "                throw new IllegalArgumentException(\"Illegal path expression\");\n            }\n            if(result == null) {\n                result = new CayennePathSegment[4];\n            }\n            result[i++] = parseSegment(path, off, next);\n            if(i == result.length) {", "refactored_code": "    private static final int INITIAL_SEGMENTS_COUNT = 4;\n                throw new IllegalArgumentException(\"Illegal path expression\");\n            }\n            if(result == null) {\n                result = new CayennePathSegment[INITIAL_SEGMENTS_COUNT];\n            }\n            result[i++] = parseSegment(path, off, next);\n            if(i == result.length) {"}
{"magic_number_smell": "        } else if (NULLIFY_NAME.equals(name)) {\n            return NULLIFY;\n        }\n        return 0;\n    }\n\n}", "refactored_code": "    public static final int NO_ACTION = 0;\n        } else if (NULLIFY_NAME.equals(name)) {\n            return NULLIFY;\n        }\n        return NO_ACTION;\n    }\n\n}"}
{"magic_number_smell": "\n    public ObjEntity(String name) {\n        setName(name);\n        this.lockType = 0;\n        this.callbacks = new CallbackMap();\n        this.attributeOverrides = new TreeMap<>();\n    }", "refactored_code": "    public static final int LOCK_TYPE_NONE = 0;\n\n    public ObjEntity(String name) {\n        setName(name);\n        this.lockType = LOCK_TYPE_NONE;\n        this.callbacks = new CallbackMap();\n        this.attributeOverrides = new TreeMap<>();\n    }"}
{"magic_number_smell": "        int direction = getDirection();\n        if (direction == ProcedureParameter.IN_PARAMETER) {\n            encoder.attribute(\"direction\", \"in\");\n        } else if (direction == ProcedureParameter.3) {\n            encoder.attribute(\"direction\", \"in_out\");\n        } else if (direction == ProcedureParameter.OUT_PARAMETER) {\n            encoder.attribute(\"direction\", \"out\");", "refactored_code": "    public static final int IN_OUT_PARAMETER = 3;\n        int direction = getDirection();\n        if (direction == ProcedureParameter.IN_PARAMETER) {\n            encoder.attribute(\"direction\", \"in\");\n        } else if (direction == ProcedureParameter.IN_OUT_PARAMETER) {\n            encoder.attribute(\"direction\", \"in_out\");\n        } else if (direction == ProcedureParameter.OUT_PARAMETER) {\n            encoder.attribute(\"direction\", \"out\");"}
{"magic_number_smell": "     */\n    public static final int REMOVE = 3;\n\n    protected int id = 1;\n    protected String oldName;\n    protected boolean oldNameSet;\n    ", "refactored_code": "    public static final int CHANGE = 1;\n     */\n    public static final int REMOVE = 3;\n\n    protected int id = CHANGE;\n    protected String oldName;\n    protected boolean oldNameSet;\n    "}
{"magic_number_smell": "        int safeguard = 0;\n\n        // Supplier can be nested, resolve all the way down\n        while(value instanceof Supplier && safeguard < 1000) {\n            value = ((Supplier) value).get();\n            isSupplier = true;\n            safeguard++;", "refactored_code": "    private static final int MAX_NESTED_SUPPLIER_LEVEL = 1000;\n        int safeguard = 0;\n\n        // Supplier can be nested, resolve all the way down\n        while(value instanceof Supplier && safeguard < MAX_NESTED_SUPPLIER_LEVEL) {\n            value = ((Supplier) value).get();\n            isSupplier = true;\n            safeguard++;"}
{"magic_number_smell": "\n    static String decodeStatus(int status) {\n        switch (status) {\n            case 1:\n                return \"1\";\n            case STATUS_COMMITTING:\n                return \"STATUS_COMMITTING\";", "refactored_code": "    protected static final int STATUS_ACTIVE = 1;\n\n    static String decodeStatus(int status) {\n        switch (status) {\n            case STATUS_ACTIVE:\n                return \"STATUS_ACTIVE\";\n            case STATUS_COMMITTING:\n                return \"STATUS_COMMITTING\";"}
{"magic_number_smell": "\n    private static final TransactionDescriptor DEFAULT_DESCRIPTOR = builder()\n            .propagation(TransactionPropagation.NESTED)\n            .isolation(TransactionDescriptor.-1)\n            .build();\n\n    private int isolation;", "refactored_code": "    public static final int ISOLATION_DEFAULT = -1;\n\n    private static final TransactionDescriptor DEFAULT_DESCRIPTOR = builder()\n            .propagation(TransactionPropagation.NESTED)\n            .isolation(TransactionDescriptor.ISOLATION_DEFAULT)\n            .build();\n\n    private int isolation;"}
{"magic_number_smell": "\n        bytes[3] = (byte) ((t & BITMASK_2) >>> 16);\n        bytes[4] = (byte) ((t & BITMASK_1) >>> 8);\n        bytes[5] = (byte) (t & 0xff);\n\n        // append 2 last bytes of IP address\n        System.arraycopy(ipAddress, 2, bytes, 6, 2);", "refactored_code": "    private static final int BITMASK_0 = 0xff;\n\n        bytes[3] = (byte) ((t & BITMASK_2) >>> 16);\n        bytes[4] = (byte) ((t & BITMASK_1) >>> 8);\n        bytes[5] = (byte) (t & BITMASK_0);\n\n        // append 2 last bytes of IP address\n        System.arraycopy(ipAddress, 2, bytes, 6, 2);"}
{"magic_number_smell": "     */\n    class ReferenceEntry extends SimpleEntry<K, V> {\n\n        private static final long -3365744592038165092L = -1795136249842496011L;\n\n        Entry<K, R> refEntry;\n", "refactored_code": "    private static final long serialVersionUID = -3365744592038165092L;\n     */\n    class ReferenceEntry extends SimpleEntry<K, V> {\n\n        private static final long serialVersionUID = -1795136249842496011L;\n\n        Entry<K, R> refEntry;\n"}
{"magic_number_smell": "\t\tPoolingDataSourceParameters poolParameters = new PoolingDataSourceParameters();\n\t\tpoolParameters.setMinConnections(2);\n\t\tpoolParameters.setMaxConnections(3);\n\t\tpoolParameters.setMaxQueueWaitTime(1000L);\n\t\treturn poolParameters;\n\t}\n", "refactored_code": "\tprotected static final long QUEUE_WAIT_TIME = 1000L;\n\t\tPoolingDataSourceParameters poolParameters = new PoolingDataSourceParameters();\n\t\tpoolParameters.setMinConnections(2);\n\t\tpoolParameters.setMaxConnections(3);\n\t\tpoolParameters.setMaxQueueWaitTime(QUEUE_WAIT_TIME);\n\t\treturn poolParameters;\n\t}\n"}
{"magic_number_smell": "        int n = MAGIC_NUMBER.length + 1 + 1 + keyNameBytes.length;\n\n        byte[] data = new byte[n];\n        System.arraycopy(MAGIC_NUMBER, 0, data, 0, MAGIC_NUMBER.length);\n\n        // total header size\n        data[SIZE_POSITION] = (byte) n;", "refactored_code": "    private static final int MAGIC_NUMBER_POSITION = 0;\n        int n = MAGIC_NUMBER.length + 1 + 1 + keyNameBytes.length;\n\n        byte[] data = new byte[n];\n        System.arraycopy(MAGIC_NUMBER, 0, data, MAGIC_NUMBER_POSITION, MAGIC_NUMBER.length);\n\n        // total header size\n        data[SIZE_POSITION] = (byte) n;"}
{"magic_number_smell": "    public static final BytesConverter<BigDecimal> INSTANCE = new BigDecimalConverter();\n\n    private static final int Integer.SIZE / Byte.SIZE = Integer.SIZE / Byte.SIZE;\n    private static final int MIN_BYTES = Integer.SIZE / Byte.SIZE + 1;\n\n    static BigDecimal getBigDecimal(byte[] bytes) {\n", "refactored_code": "    private static final int INTEGER_BYTES = Integer.SIZE / Byte.SIZE;\n    public static final BytesConverter<BigDecimal> INSTANCE = new BigDecimalConverter();\n\n    private static final int INTEGER_BYTES = Integer.SIZE / Byte.SIZE;\n    private static final int MIN_BYTES = INTEGER_BYTES + 1;\n\n    static BigDecimal getBigDecimal(byte[] bytes) {\n"}
{"magic_number_smell": "    private static final int 1 = 1;\n\n    static byte getByte(byte[] bytes) {\n        if (bytes.length != 1) {\n            throw new IllegalArgumentException(\"Unexpected number of bytes: \" + bytes.length);\n        }\n", "refactored_code": "    private static final int BYTES = 1;\n    private static final int BYTES = 1;\n\n    static byte getByte(byte[] bytes) {\n        if (bytes.length != BYTES) {\n            throw new IllegalArgumentException(\"Unexpected number of bytes: \" + bytes.length);\n        }\n"}
{"magic_number_smell": "\n    static double getDouble(byte[] bytes) {\n\n        if (bytes.length > 8) {\n            throw new IllegalArgumentException(\"byte[] is too large for a single double value: \" + bytes.length);\n        }\n", "refactored_code": "    private static final int BYTES = 8;\n\n    static double getDouble(byte[] bytes) {\n\n        if (bytes.length > BYTES) {\n            throw new IllegalArgumentException(\"byte[] is too large for a single double value: \" + bytes.length);\n        }\n"}
{"magic_number_smell": "\n    static float getFloat(byte[] bytes) {\n\n        if (bytes.length > 4) {\n            throw new IllegalArgumentException(\"byte[] is too large for a single float value: \" + bytes.length);\n        }\n", "refactored_code": "    private static final int BYTES = 4;\n\n    static float getFloat(byte[] bytes) {\n\n        if (bytes.length > BYTES) {\n            throw new IllegalArgumentException(\"byte[] is too large for a single float value: \" + bytes.length);\n        }\n"}
{"magic_number_smell": "    private static final int 4 = 4;\n\n    static int getInt(byte[] bytes) {\n        if (bytes.length < 4) {\n            return ShortConverter.getShort(bytes);\n        }\n", "refactored_code": "    private static final int BYTES = 4;\n    private static final int BYTES = 4;\n\n    static int getInt(byte[] bytes) {\n        if (bytes.length < BYTES) {\n            return ShortConverter.getShort(bytes);\n        }\n"}
{"magic_number_smell": "    private static final int 8 = 8;\n\n    static long getLong(byte[] bytes) {\n        if (bytes.length < 8) {\n            return IntegerConverter.getInt(bytes);\n        }\n", "refactored_code": "    private static final int BYTES = 8;\n    private static final int BYTES = 8;\n\n    static long getLong(byte[] bytes) {\n        if (bytes.length < BYTES) {\n            return IntegerConverter.getInt(bytes);\n        }\n"}
{"magic_number_smell": "\n    static short getShort(byte[] bytes) {\n\n        if (bytes.length < 2) {\n            return ByteConverter.getByte(bytes);\n        }\n", "refactored_code": "    private static final int BYTES = 2;\n\n    static short getShort(byte[] bytes) {\n\n        if (bytes.length < BYTES) {\n            return ByteConverter.getByte(bytes);\n        }\n"}
{"magic_number_smell": "        ObjectContext context = runtime.newContext();\n\n        // make sure compression is on...\n        byte[] cryptoBytes = CryptoUnitUtils.bytesOfSize(150 + 100);\n\n        Table2 t1 = context.newObject(Table2.class);\n        t1.setPlainBytes(\"plain_1\".getBytes());", "refactored_code": "    private static final int GZIP_THRESHOLD = 150;\n        ObjectContext context = runtime.newContext();\n\n        // make sure compression is on...\n        byte[] cryptoBytes = CryptoUnitUtils.bytesOfSize(GZIP_THRESHOLD + 100);\n\n        Table2 t1 = context.newObject(Table2.class);\n        t1.setPlainBytes(\"plain_1\".getBytes());"}
{"magic_number_smell": "            if(attributes.isEmpty()) {\n                attributes = \"{}\";\n            } else {\n                attributes = \"{\" + attributes.substring(0, attributes.length() - COMMA_SEPARATOR.length()) + \"}\";\n            }\n        }\n", "refactored_code": "    public static final int COMMA_SEPARATOR_LENGTH = COMMA_SEPARATOR.length();\n            if(attributes.isEmpty()) {\n                attributes = \"{}\";\n            } else {\n                attributes = \"{\" + attributes.substring(0, attributes.length() - COMMA_SEPARATOR_LENGTH) + \"}\";\n            }\n        }\n"}
{"magic_number_smell": "        String name = id.substring(0, separator);\n\n        if (name.startsWith(TEMP_ID_PREFIX)) {\n            name = name.substring(TEMP_ID_PREFIX.length());\n        }\n\n        return name;", "refactored_code": "    private static final int TEMP_PREFIX_LENGTH = TEMP_ID_PREFIX.length();\n        String name = id.substring(0, separator);\n\n        if (name.startsWith(TEMP_ID_PREFIX)) {\n            name = name.substring(TEMP_PREFIX_LENGTH);\n        }\n\n        return name;"}
{"magic_number_smell": "    public void run() {\n        while (true) {\n            try {\n                Thread.sleep(4000);\n                check();\n            } catch (InterruptedException e) {\n                // someone asked to stop", "refactored_code": "    private static final long DEFAULT_DELAY = 4000;\n    public void run() {\n        while (true) {\n            try {\n                Thread.sleep(DEFAULT_DELAY);\n                check();\n            } catch (InterruptedException e) {\n                // someone asked to stop"}
{"magic_number_smell": "        Document doc = view.getLogView().getDocument(); \n            \n        //truncate if needed\n        if (doc.getLength() > 500000) {\n            clear();\n        }\n        ", "refactored_code": "    private static final int TEXT_MAX_LENGTH = 500000;\n        Document doc = view.getLogView().getDocument(); \n            \n        //truncate if needed\n        if (doc.getLength() > TEXT_MAX_LENGTH) {\n            clear();\n        }\n        "}
{"magic_number_smell": "        setNamingStrategy(strategy);\n        createNames();\n        entitySelector.initBindings();\n        view.setChoice(1);\n\n    }\n", "refactored_code": "    public static final int SELECT = 1;\n        setNamingStrategy(strategy);\n        createNames();\n        entitySelector.initBindings();\n        view.setChoice(SELECT);\n\n    }\n"}
{"magic_number_smell": "\n        this.configButton = new JButton(\"...\");\n        this.configButton.setToolTipText(\"configure local DataSource\");\n        this.okButton = new JButton(labels[0]);\n        this.cancelButton = new JButton(labels[CANCEL_BUTTON_INDEX]);\n        this.connectionInfo = new DBConnectionInfoEditor(controller);\n", "refactored_code": "    private static final byte OK_BUTTON_INDEX = 0;\n\n        this.configButton = new JButton(\"...\");\n        this.configButton.setToolTipText(\"configure local DataSource\");\n        this.okButton = new JButton(labels[OK_BUTTON_INDEX]);\n        this.cancelButton = new JButton(labels[CANCEL_BUTTON_INDEX]);\n        this.connectionInfo = new DBConnectionInfoEditor(controller);\n"}
{"magic_number_smell": "    }\n\n    protected void initFromModel(Collection<String> catalogs, Collection<String> schemas, String currentCatalog, String currentSchema) {\n        this.choice = 0;\n\n        boolean showSchemaSelector = schemas != null && !schemas.isEmpty();\n        schemaSelector.setVisible(showSchemaSelector);", "refactored_code": "    public static final int CANCEL = 0;\n    }\n\n    protected void initFromModel(Collection<String> catalogs, Collection<String> schemas, String currentCatalog, String currentSchema) {\n        this.choice = CANCEL;\n\n        boolean showSchemaSelector = schemas != null && !schemas.isEmpty();\n        schemaSelector.setVisible(showSchemaSelector);"}
{"magic_number_smell": "        tablePane.add(dataMapLabel, BorderLayout.NORTH);\n        JTable tokensTable = new JTable(tokensTableModel);\n        tokensTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n        tokensTable.setRowHeight(24);\n        tokensTable.setRowMargin(TABLE_ROW_MARGIN);\n        tokensTableModel.addColumn(\"\");\n        tablePane.add(tokensTable, BorderLayout.CENTER);", "refactored_code": "    private static final int TABLE_ROW_HIGH = 24;\n        tablePane.add(dataMapLabel, BorderLayout.NORTH);\n        JTable tokensTable = new JTable(tokensTableModel);\n        tokensTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n        tokensTable.setRowHeight(TABLE_ROW_HIGH);\n        tokensTable.setRowMargin(TABLE_ROW_MARGIN);\n        tokensTableModel.addColumn(\"\");\n        tablePane.add(tokensTable, BorderLayout.CENTER);"}
{"magic_number_smell": "    public RootPopUpMenu() {\n        initPopUpMenuElements();\n        initListeners();\n        this.add(addItem, 0);\n        delete.setVisible(false);\n        rename.setVisible(false);\n    }", "refactored_code": "    private static final int FIRST_POSITION = 0;\n    public RootPopUpMenu() {\n        initPopUpMenuElements();\n        initListeners();\n        this.add(addItem, FIRST_POSITION);\n        delete.setVisible(false);\n        rename.setVisible(false);\n    }"}
{"magic_number_smell": "\n    public Class getColumnClass(int columnIndex) {\n        switch (columnIndex) {\n            case 0:\n                return Boolean.class;\n            case COL_DIRECTION:\n                // TODO: correct?", "refactored_code": "    public static final int COL_SELECT = 0;\n\n    public Class getColumnClass(int columnIndex) {\n        switch (columnIndex) {\n            case COL_SELECT:\n                return Boolean.class;\n            case COL_DIRECTION:\n                // TODO: correct?"}
{"magic_number_smell": "    private void transferTo(InputStream in, OutputStream out) throws IOException {\n        Objects.requireNonNull(in);\n        Objects.requireNonNull(out);\n        byte[] buffer = new byte[8192];\n        int read;\n        while ((read = in.read(buffer, 0, 8192)) >= 0) {\n            out.write(buffer, 0, read);", "refactored_code": "    private static final int DEFAULT_BUFFER_SIZE = 8192;\n    private void transferTo(InputStream in, OutputStream out) throws IOException {\n        Objects.requireNonNull(in);\n        Objects.requireNonNull(out);\n        byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];\n        int read;\n        while ((read = in.read(buffer, 0, DEFAULT_BUFFER_SIZE)) >= 0) {\n            out.write(buffer, 0, read);"}
{"magic_number_smell": "     * @see #getRowCount\n     */\n    public int getColumnCount() {\n        return 1;\n    }\n\n    /**", "refactored_code": "    private static final int COLUMN_COUNT = 1;\n     * @see #getRowCount\n     */\n    public int getColumnCount() {\n        return COLUMN_COUNT;\n    }\n\n    /**"}
{"magic_number_smell": "\n    public String getColumnName(int column) {\n        switch (column) {\n            case 0:\n                return \"Name\";\n            case OBJ_ATTRIBUTE_TYPE:\n                return \"Java Type\";", "refactored_code": "    public static final int OBJ_ATTRIBUTE = 0;\n\n    public String getColumnName(int column) {\n        switch (column) {\n            case OBJ_ATTRIBUTE:\n                return \"Name\";\n            case OBJ_ATTRIBUTE_TYPE:\n                return \"Java Type\";"}
{"magic_number_smell": "    @Override\n    public String getColumnName(int column) {\n        switch (column) {\n            case 0:\n                return \"Name\";\n            case REL_TARGET:\n                return \"Target\";", "refactored_code": "    public static final int REL_NAME = 0;\n    @Override\n    public String getColumnName(int column) {\n        switch (column) {\n            case REL_NAME:\n                return \"Name\";\n            case REL_TARGET:\n                return \"Target\";"}
{"magic_number_smell": "    public static final String[] PARAMETER_DIRECTION_NAMES = { \"\", IN_PARAMETER, OUT_PARAMETER, IN_OUT_PARAMETER };\n\n    private static final int[] PARAMETER_INDEXES = {\n            0,\n            PARAMETER_NAME,\n            PARAMETER_DIRECTION,\n            PARAMETER_TYPE,", "refactored_code": "    public static final int PARAMETER_NUMBER    = 0;\n    public static final String[] PARAMETER_DIRECTION_NAMES = { \"\", IN_PARAMETER, OUT_PARAMETER, IN_OUT_PARAMETER };\n\n    private static final int[] PARAMETER_INDEXES = {\n            PARAMETER_NUMBER,\n            PARAMETER_NAME,\n            PARAMETER_DIRECTION,\n            PARAMETER_TYPE,"}
{"magic_number_smell": "          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = -1;\n            break zzForAction;\n          }\n          else {", "refactored_code": "  public static final int YYEOF = -1;\n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {"}
{"magic_number_smell": "    }\n\n    public int nameColumnInd() {\n        return 0;\n    }\n\n    public int typeColumnInd() {", "refactored_code": "    private static final int DB_ATTRIBUTE_NAME = 0;\n    }\n\n    public int nameColumnInd() {\n        return DB_ATTRIBUTE_NAME;\n    }\n\n    public int typeColumnInd() {"}
{"magic_number_smell": "\n        FormLayout layout = new FormLayout(MAIN_LAYOUT);\n        DefaultFormBuilder builder = new DefaultFormBuilder(layout);\n        builder.append(treeToolbar, 5);\n        FormLayout headerLayout = new FormLayout(HEADER_LAYOUT);\n\n        DefaultFormBuilder reverseEngineeringHeaderBuilder = new DefaultFormBuilder(headerLayout);", "refactored_code": "    private static final int ALL_LINE_SPAN = 5;\n\n        FormLayout layout = new FormLayout(MAIN_LAYOUT);\n        DefaultFormBuilder builder = new DefaultFormBuilder(layout);\n        builder.append(treeToolbar, ALL_LINE_SPAN);\n        FormLayout headerLayout = new FormLayout(HEADER_LAYOUT);\n\n        DefaultFormBuilder reverseEngineeringHeaderBuilder = new DefaultFormBuilder(headerLayout);"}
{"magic_number_smell": "    }\n\n    private void initLevels() {\n        levels.put(ReverseEngineering.class, 14);\n        levels.put(Catalog.class, FIRST_LEVEL);\n        levels.put(Schema.class, SECOND_LEVEL);\n        levels.put(IncludeTable.class, THIRD_LEVEL);", "refactored_code": "    private static final int ROOT_LEVEL = 14;\n    }\n\n    private void initLevels() {\n        levels.put(ReverseEngineering.class, ROOT_LEVEL);\n        levels.put(Catalog.class, FIRST_LEVEL);\n        levels.put(Schema.class, SECOND_LEVEL);\n        levels.put(IncludeTable.class, THIRD_LEVEL);"}
{"magic_number_smell": "    }\n\n    public BlankIcon() {\n        this(null, 18);\n    }\n\n    public void paintIcon(Component c, Graphics g, int x, int y) {", "refactored_code": "    private static final int DEFAULT_BUTTON_SIZE = 18;\n    }\n\n    public BlankIcon() {\n        this(null, DEFAULT_BUTTON_SIZE);\n    }\n\n    public void paintIcon(Component c, Graphics g, int x, int y) {"}
{"magic_number_smell": "\n    @Override\n    public Object getCellEditorValue() {\n        return model.getValueAt(row, ObjAttributeTableModel.DB_ATTRIBUTE);\n    }\n\n    @Override", "refactored_code": "    private static final int DB_ATTRIBUTE_PATH_COLUMN = ObjAttributeTableModel.DB_ATTRIBUTE;\n\n    @Override\n    public Object getCellEditorValue() {\n        return model.getValueAt(row, DB_ATTRIBUTE_PATH_COLUMN);\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public Object getCellEditorValue() {\n        return model.getValueAt(row, 2);\n    }\n\n    @Override", "refactored_code": "    private static final int REL_TARGET_PATH_COLUMN = 2;\n\n    @Override\n    public Object getCellEditorValue() {\n        return model.getValueAt(row, REL_TARGET_PATH_COLUMN);\n    }\n\n    @Override"}
{"magic_number_smell": "        Thread task = new Thread(this::internalExecute);\n\n        Timer progressDisplayTimer = new Timer(\n                500,\n                e -> showProgress());\n\n        progressDisplayTimer.setRepeats(false);", "refactored_code": "    protected static final int DEFAULT_MS_TO_DECIDE_TO_POPUP = 500;\n        Thread task = new Thread(this::internalExecute);\n\n        Timer progressDisplayTimer = new Timer(\n                DEFAULT_MS_TO_DECIDE_TO_POPUP,\n                e -> showProgress());\n\n        progressDisplayTimer.setRepeats(false);"}
{"magic_number_smell": "\n    private void consoleLog(byte level, String message, Throwable throwable) {\n        if(this.isLevelEnabled(level)) {\n            StringBuilder buffer = new StringBuilder(32);\n            buffer.append(this.getFormattedDate());\n            buffer.append(' ');\n", "refactored_code": "    private static final int BUFFER_SIZE = 32;\n\n    private void consoleLog(byte level, String message, Throwable throwable) {\n        if(this.isLevelEnabled(level)) {\n            StringBuilder buffer = new StringBuilder(BUFFER_SIZE);\n            buffer.append(this.getFormattedDate());\n            buffer.append(' ');\n"}
{"magic_number_smell": "    private boolean fireDisabled;\n\n    public MultiColumnBrowser() {\n        this(3);\n    }\n\n    public MultiColumnBrowser(int minColumns) {", "refactored_code": "    public static final int DEFAULT_MIN_COLUMNS_COUNT = 3;\n    private boolean fireDisabled;\n\n    public MultiColumnBrowser() {\n        this(DEFAULT_MIN_COLUMNS_COUNT);\n    }\n\n    public MultiColumnBrowser(int minColumns) {"}
{"magic_number_smell": "        if (col == currentColumn){\n            return currentState;\n        }\n        return 0;\n    }\n\n    public boolean isSortingEnabled() {", "refactored_code": "    public static final int NONE = 0;\n        if (col == currentColumn){\n            return currentState;\n        }\n        return NONE;\n    }\n\n    public boolean isSortingEnabled() {"}
{"magic_number_smell": "    }\n\n    private int getLeftColumn(Point pt) {\n        pt.x -= 5;\n        return table.getTableHeader().columnAtPoint(pt);\n    }\n", "refactored_code": "    private static final int EPSILON = 5;\n    }\n\n    private int getLeftColumn(Point pt) {\n        pt.x -= EPSILON;\n        return table.getTableHeader().columnAtPoint(pt);\n    }\n"}
{"magic_number_smell": "    @Override\n    public String trim(String path) {\n        String[] components = splitPath(path);\n        if(components.length <= 8 + 1) {\n            return path;\n        }\n        String[] strippedComponents = new String[8 + 1];", "refactored_code": "    private static final int PATH_LENGTH_THRESHOLD = 8;\n    @Override\n    public String trim(String path) {\n        String[] components = splitPath(path);\n        if(components.length <= PATH_LENGTH_THRESHOLD + 1) {\n            return path;\n        }\n        String[] strippedComponents = new String[PATH_LENGTH_THRESHOLD + 1];"}
{"magic_number_smell": "\n    private static class LimitedDocument extends PlainDocument {\n\n        private static final long 5615520143950793884L = 2371422073526259311L;\n        private int limit;\n\n        LimitedDocument(int limit) {", "refactored_code": "    private static final long serialVersionUID = 5615520143950793884L;\n\n    private static class LimitedDocument extends PlainDocument {\n\n        private static final long serialVersionUID = 2371422073526259311L;\n        private int limit;\n\n        LimitedDocument(int limit) {"}
{"magic_number_smell": "            int r = (rgb >> 16) & 0xff;\n            int g = (rgb >>  8) & 0xff;\n            int b = (rgb      ) & 0xff;\n            int luminance = (int)((1 - 0.4) * Math.min(255.0, (r + g + b) / 3.0));\n\n            return  (int)(a * ALPHA_FACTOR) << 24 |\n                    (int)(r * 0.4 + luminance) << 16 |", "refactored_code": "        private static final double COLOR_FACTOR = 0.4;\n            int r = (rgb >> 16) & 0xff;\n            int g = (rgb >>  8) & 0xff;\n            int b = (rgb      ) & 0xff;\n            int luminance = (int)((1 - COLOR_FACTOR) * Math.min(255.0, (r + g + b) / 3.0));\n\n            return  (int)(a * ALPHA_FACTOR) << 24 |\n                    (int)(r * COLOR_FACTOR + luminance) << 16 |"}
{"magic_number_smell": "        int i;\n        // First check to see if need to allocate a new StringBuilder\n        for (i = 0; i < chars.length; i++) {\n            if (chars[i] < Chars.SP) {\n                break;\n            }\n        }", "refactored_code": "    private static final int FIRST_VALID_CHAR = Chars.SP;\n        int i;\n        // First check to see if need to allocate a new StringBuilder\n        for (i = 0; i < chars.length; i++) {\n            if (chars[i] < FIRST_VALID_CHAR) {\n                break;\n            }\n        }"}
{"magic_number_smell": "            this.maxLineLength = INIT_MAX_LINE_LENGTH;\n            this.maxHeaderCount = INIT_MAX_HEADER_COUNT;\n            this.maxEmptyLineCount = INIT_MAX_EMPTY_LINE_COUNT;\n            this.initialWindowSize = 65535;\n        }\n\n        /**", "refactored_code": "    private static final int INIT_WINDOW_SIZE = 65535;\n            this.maxLineLength = INIT_MAX_LINE_LENGTH;\n            this.maxHeaderCount = INIT_MAX_HEADER_COUNT;\n            this.maxEmptyLineCount = INIT_MAX_EMPTY_LINE_COUNT;\n            this.initialWindowSize = INIT_WINDOW_SIZE;\n        }\n\n        /**"}
{"magic_number_smell": "        this.lineParser = lineParser != null ? lineParser : LazyLineParser.INSTANCE;\n        this.headerLines = new ArrayList<>();\n        this.headLine = new CharArrayBuffer(128);\n        this.state = 0;\n    }\n\n    /**", "refactored_code": "    private static final int HEAD_LINE    = 0;\n        this.lineParser = lineParser != null ? lineParser : LazyLineParser.INSTANCE;\n        this.headerLines = new ArrayList<>();\n        this.headLine = new CharArrayBuffer(128);\n        this.state = HEAD_LINE;\n    }\n\n    /**"}
{"magic_number_smell": "                        return;\n                    }\n                    // read and discard the remainder of the message\n                    final byte[] buff = new byte[2048];\n                    while (read(buff) >= 0) {\n                    }\n                }", "refactored_code": "    private static final int BUFFER_SIZE = 2048;\n                        return;\n                    }\n                    // read and discard the remainder of the message\n                    final byte[] buff = new byte[BUFFER_SIZE];\n                    while (read(buff) >= 0) {\n                    }\n                }"}
{"magic_number_smell": "        if (!closed) {\n            try {\n                if (pos < contentLength) {\n                    final byte[] buffer = new byte[2048];\n                    while (read(buffer) >= 0) {\n                        // keep reading\n                    }", "refactored_code": "    private static final int BUFFER_SIZE = 2048;\n        if (!closed) {\n            try {\n                if (pos < contentLength) {\n                    final byte[] buffer = new byte[BUFFER_SIZE];\n                    while (read(buffer) >= 0) {\n                        // keep reading\n                    }"}
{"magic_number_smell": "     * Instantiates a default {@link MonitoringResponseOutOfOrderStrategy}. {@link #INSTANCE} may be used instead.\n     */\n    public MonitoringResponseOutOfOrderStrategy() {\n        this(8 * 1024);\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_CHUNK_SIZE = 8 * 1024;\n     * Instantiates a default {@link MonitoringResponseOutOfOrderStrategy}. {@link #INSTANCE} may be used instead.\n     */\n    public MonitoringResponseOutOfOrderStrategy() {\n        this(DEFAULT_CHUNK_SIZE);\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    public static String toString(\n            final HttpEntity entity, final Charset defaultCharset) throws IOException, ParseException {\n        return toString(entity, defaultCharset, Integer.MAX_VALUE);\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_ENTITY_RETURN_MAX_LENGTH = Integer.MAX_VALUE;\n     */\n    public static String toString(\n            final HttpEntity entity, final Charset defaultCharset) throws IOException, ParseException {\n        return toString(entity, defaultCharset, DEFAULT_ENTITY_RETURN_MAX_LENGTH);\n    }\n\n    /**"}
{"magic_number_smell": "    }\n\n    public AbstractCharDataConsumer() {\n        this(8192, CharCodingConfig.DEFAULT);\n    }\n    /**\n     * Triggered to obtain the capacity increment.", "refactored_code": "    protected static final int DEF_BUF_SIZE = 8192;\n    }\n\n    public AbstractCharDataConsumer() {\n        this(DEF_BUF_SIZE, CharCodingConfig.DEFAULT);\n    }\n    /**\n     * Triggered to obtain the capacity increment."}
{"magic_number_smell": "\n    public PathEntityProducer(final Path file, final ContentType contentType, final boolean chunked,\n            final OpenOption... openOptions) throws IOException {\n        this(file, 8192, contentType, chunked, openOptions);\n    }\n\n    public PathEntityProducer(final Path file, final ContentType contentType, final OpenOption... openOptions)", "refactored_code": "    private static final int BUFFER_SIZE = 8192;\n\n    public PathEntityProducer(final Path file, final ContentType contentType, final boolean chunked,\n            final OpenOption... openOptions) throws IOException {\n        this(file, BUFFER_SIZE, contentType, chunked, openOptions);\n    }\n\n    public PathEntityProducer(final Path file, final ContentType contentType, final OpenOption... openOptions)"}
{"magic_number_smell": "        lock.lock();\n        try {\n            final long now = System.currentTimeMillis();\n            if (now - this.dateAsMillis > 1000) {\n                // Generate new date string\n                dateAsText = dateTimeFormatter.format(Instant.now().atZone(zoneId));\n                dateAsMillis = now;", "refactored_code": "    private static final int GRANULARITY_MILLIS = 1000;\n        lock.lock();\n        try {\n            final long now = System.currentTimeMillis();\n            if (now - this.dateAsMillis > GRANULARITY_MILLIS) {\n                // Generate new date string\n                dateAsText = dateTimeFormatter.format(Instant.now().atZone(zoneId));\n                dateAsMillis = now;"}
{"magic_number_smell": "                buf.append(\"+\");\n            } else {\n                buf.append(\"%\");\n                final char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n                final char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n                buf.append(hex1);\n                buf.append(hex2);", "refactored_code": "    private static final int RADIX = 16;\n                buf.append(\"+\");\n            } else {\n                buf.append(\"%\");\n                final char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));\n                final char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));\n                buf.append(hex1);\n                buf.append(hex2);"}
{"magic_number_smell": "    /**\n     * Interest in data input/output.\n     */\n    public static final int READ_WRITE = SelectionKey.OP_READ | WRITE;\n\n}\n", "refactored_code": "    public static final int READ = SelectionKey.OP_READ;\n    /**\n     * Interest in data input/output.\n     */\n    public static final int READ_WRITE = READ | WRITE;\n\n}\n"}
{"magic_number_smell": "\n    private void processPendingChannels() throws IOException {\n        ChannelEntry entry;\n        for (int i = 0; i < 10000 && (entry = this.channelQueue.poll()) != null; i++) {\n            final SocketChannel socketChannel = entry.channel;\n            final Object attachment = entry.attachment;\n            try {", "refactored_code": "    private static final int MAX_CHANNEL_REQUESTS = 10000;\n\n    private void processPendingChannels() throws IOException {\n        ChannelEntry entry;\n        for (int i = 0; i < MAX_CHANNEL_REQUESTS && (entry = this.channelQueue.poll()) != null; i++) {\n            final SocketChannel socketChannel = entry.channel;\n            final Object attachment = entry.attachment;\n            try {"}
{"magic_number_smell": "\n    private static final int 255 = 255;\n\n    private static final int MAX_COMMAND_CONNECT_LENGTH = 6 + 255 + 1;\n\n    private static final byte CLIENT_VERSION = 5;\n", "refactored_code": "    private static final int MAX_DNS_NAME_LENGTH = 255;\n\n    private static final int MAX_DNS_NAME_LENGTH = 255;\n\n    private static final int MAX_COMMAND_CONNECT_LENGTH = 6 + MAX_DNS_NAME_LENGTH + 1;\n\n    private static final byte CLIENT_VERSION = 5;\n"}
{"magic_number_smell": "    /**\n     * The maximum (longest-lived) deadline.\n     */\n    public static Deadline MAX_VALUE = new Deadline(Long.MAX_VALUE);\n\n    /**\n     * The minimum (shortest-lived) deadline.", "refactored_code": "    private static final long INTERNAL_MAX_VALUE = Long.MAX_VALUE;\n    /**\n     * The maximum (longest-lived) deadline.\n     */\n    public static Deadline MAX_VALUE = new Deadline(INTERNAL_MAX_VALUE);\n\n    /**\n     * The minimum (shortest-lived) deadline."}
{"magic_number_smell": "    public static final int HT = 9;  // <US-ASCII HT, horizontal-tab (9)>\n\n    public static boolean isWhitespace(final char ch) {\n        return ch == SP || ch == HT || ch == 13 || ch == LF;\n    }\n\n    /**", "refactored_code": "    public static final int CR = 13; // <US-ASCII CR, carriage return (13)>\n    public static final int HT = 9;  // <US-ASCII HT, horizontal-tab (9)>\n\n    public static boolean isWhitespace(final char ch) {\n        return ch == SP || ch == HT || ch == CR || ch == LF;\n    }\n\n    /**"}
{"magic_number_smell": "            lock.lock();\n            try {\n                exchangeState.requestCapacityChannel = capacityChannel;\n                final int capacity = exchangeState.inBuf != null ? exchangeState.inBuf.capacity() : 4096;\n                if (capacity > 0) {\n                    println(\"[client<-proxy] \" + exchangeState.id + \" input capacity: \" + capacity);\n                    capacityChannel.update(capacity);", "refactored_code": "    private static final int INIT_BUFFER_SIZE = 4096;\n            lock.lock();\n            try {\n                exchangeState.requestCapacityChannel = capacityChannel;\n                final int capacity = exchangeState.inBuf != null ? exchangeState.inBuf.capacity() : INIT_BUFFER_SIZE;\n                if (capacity > 0) {\n                    println(\"[client<-proxy] \" + exchangeState.id + \" input capacity: \" + capacity);\n                    capacityChannel.update(capacity);"}
{"magic_number_smell": "\n    public static H2Config.Builder initial() {\n        return new Builder()\n                .setHeaderTableSize(4096)\n                .setPushEnabled(INIT_ENABLE_PUSH)\n                .setMaxConcurrentStreams(Integer.MAX_VALUE) // no limit\n                .setMaxFrameSize(INIT_MAX_FRAME_SIZE)", "refactored_code": "    private static final int      INIT_HEADER_TABLE_SIZE   = 4096;\n\n    public static H2Config.Builder initial() {\n        return new Builder()\n                .setHeaderTableSize(INIT_HEADER_TABLE_SIZE)\n                .setPushEnabled(INIT_ENABLE_PUSH)\n                .setMaxConcurrentStreams(Integer.MAX_VALUE) // no limit\n                .setMaxFrameSize(INIT_MAX_FRAME_SIZE)"}
{"magic_number_smell": "    }\n\n    public int getTotalSize() {\n        return nameLen + valueLen + 32;\n    }\n\n    @Override", "refactored_code": "    static private final int ENTRY_SIZE_OVERHEAD = 32;\n    }\n\n    public int getTotalSize() {\n        return nameLen + valueLen + ENTRY_SIZE_OVERHEAD;\n    }\n\n    @Override"}
{"magic_number_smell": "                    return false;\n                }\n                localEndStream = true;\n                deadline = System.currentTimeMillis() + 1000;\n                if (!idle) {\n                    final RawFrame resetStream = frameFactory.createResetStream(id, code);\n                    commitFrameInternal(resetStream);", "refactored_code": "    private static final long LINGER_TIME = 1000; // 1 second\n                    return false;\n                }\n                localEndStream = true;\n                deadline = System.currentTimeMillis() + LINGER_TIME;\n                if (!idle) {\n                    final RawFrame resetStream = frameFactory.createResetStream(id, code);\n                    commitFrameInternal(resetStream);"}
{"magic_number_smell": "            throw new IllegalStateException(\"Already subscribed\");\n        }\n\n        subscription.request(5);\n    }\n\n    @Override", "refactored_code": "    private static final int BUFFER_WINDOW_SIZE = 5;\n            throw new IllegalStateException(\"Already subscribed\");\n        }\n\n        subscription.request(BUFFER_WINDOW_SIZE);\n    }\n\n    @Override"}
{"magic_number_smell": "        final Flowable<ByteBuffer> publisher = Flowable.just(\n                ByteBuffer.wrap(new byte[]{'1', '2', '3'}),\n                ByteBuffer.wrap(new byte[]{'4', '5', '6'}));\n        final ReactiveEntityProducer entityProducer = new ReactiveEntityProducer(publisher, 1, CONTENT_TYPE, GZIP_CONTENT_ENCODING);\n\n        final WritableByteChannelMock byteChannel = new WritableByteChannelMock(1024);\n        final DataStreamChannel streamChannel = new BasicDataStreamChannel(byteChannel);", "refactored_code": "    private static final long CONTENT_LENGTH = 1;\n        final Flowable<ByteBuffer> publisher = Flowable.just(\n                ByteBuffer.wrap(new byte[]{'1', '2', '3'}),\n                ByteBuffer.wrap(new byte[]{'4', '5', '6'}));\n        final ReactiveEntityProducer entityProducer = new ReactiveEntityProducer(publisher, CONTENT_LENGTH, CONTENT_TYPE, GZIP_CONTENT_ENCODING);\n\n        final WritableByteChannelMock byteChannel = new WritableByteChannelMock(1024);\n        final DataStreamChannel streamChannel = new BasicDataStreamChannel(byteChannel);"}
{"magic_number_smell": "\n                private Socket establishConnection(final DataInputStream input, final DataOutputStream output) throws IOException {\n                    final int clientVersion = input.readUnsignedByte();\n                    if (clientVersion != 5) {\n                        throw new IOException(\"SOCKS implementation only supports version 5\");\n                    }\n                    final int nMethods = input.readUnsignedByte();", "refactored_code": "        public static final int VERSION_5 = 5;\n\n                private Socket establishConnection(final DataInputStream input, final DataOutputStream output) throws IOException {\n                    final int clientVersion = input.readUnsignedByte();\n                    if (clientVersion != VERSION_5) {\n                        throw new IOException(\"SOCKS implementation only supports version 5\");\n                    }\n                    final int nMethods = input.readUnsignedByte();"}
{"magic_number_smell": "        this.serverResource = new HttpServerResource(scheme, bootstrap -> bootstrap\n                .setSocketConfig(SocketConfig.custom()\n                        .setSoTimeout(TIMEOUT)\n                        .setSndBufSize(16 * 1024)\n                        .setRcvBufSize(16 * 1024)\n                        .setSoKeepAlive(false)\n                        .build())", "refactored_code": "    private static final int BUFFER_SIZE = 16 * 1024;\n        this.serverResource = new HttpServerResource(scheme, bootstrap -> bootstrap\n                .setSocketConfig(SocketConfig.custom()\n                        .setSoTimeout(TIMEOUT)\n                        .setSndBufSize(BUFFER_SIZE)\n                        .setRcvBufSize(BUFFER_SIZE)\n                        .setSoKeepAlive(false)\n                        .build())"}
{"magic_number_smell": "                \"localhost\", serverEndpoint.getPort(), TIMEOUT);\n        final ClientSessionEndpoint streamEndpoint = connectFuture.get();\n\n        for (int i = 0; i < 25; i++) {\n            final Future<Message<HttpResponse, String>> future = streamEndpoint.execute(\n                    new BasicRequestProducer(Method.GET, createRequestURI(serverEndpoint, \"/hello\")),\n                    new BasicResponseConsumer<>(new StringAsyncEntityConsumer()), null);", "refactored_code": "    private static final int REQ_NUM = 25;\n                \"localhost\", serverEndpoint.getPort(), TIMEOUT);\n        final ClientSessionEndpoint streamEndpoint = connectFuture.get();\n\n        for (int i = 0; i < REQ_NUM; i++) {\n            final Future<Message<HttpResponse, String>> future = streamEndpoint.execute(\n                    new BasicRequestProducer(Method.GET, createRequestURI(serverEndpoint, \"/hello\")),\n                    new BasicResponseConsumer<>(new StringAsyncEntityConsumer()), null);"}
{"magic_number_smell": "\n\tprotected static final int 60 * 1000 = 60 * 1000;\n\n\tprotected static final int FIVE_MINUTES = 5 * 60 * 1000;\n\n\tprotected static final int ACCURACY_THRESHOLD = 30; // in meters\n", "refactored_code": "\tprotected static final int ONE_MINUTE = 60 * 1000;\n\n\tprotected static final int ONE_MINUTE = 60 * 1000;\n\n\tprotected static final int FIVE_MINUTES = 5 * ONE_MINUTE;\n\n\tprotected static final int ACCURACY_THRESHOLD = 30; // in meters\n"}
{"magic_number_smell": "    protected static final int -1 = -1;\n    protected Context context;\n    public BaseArrayAdapter(Context context) {\n        this(context, -1);\n        this.context = context;\n    }\n", "refactored_code": "    protected static final int NOT_SPECIFIED = -1;\n    protected static final int NOT_SPECIFIED = -1;\n    protected Context context;\n    public BaseArrayAdapter(Context context) {\n        this(context, NOT_SPECIFIED);\n        this.context = context;\n    }\n"}
{"magic_number_smell": "\n\tprivate static class DatabaseHelper extends SQLiteOpenHelper {\n\t\tDatabaseHelper(Context context) {\n\t\t\tsuper(context, DATABASE_NAME, null, 19);\n\t\t}\n\n\t\t@Override", "refactored_code": "\tprivate static final int DATABASE_VERSION = 19;\n\n\tprivate static class DatabaseHelper extends SQLiteOpenHelper {\n\t\tDatabaseHelper(Context context) {\n\t\t\tsuper(context, DATABASE_NAME, null, DATABASE_VERSION);\n\t\t}\n\n\t\t@Override"}
{"magic_number_smell": "\tpublic static final String DEFAULT_MAP_CREATE = String\n\t\t\t.format(\"INSERT INTO %s (%s, %s, %s, %s, %s, %s, %s, %s, %s) VALUES (%d,%d,%d,'%s','%s','%s','%s','%s','%s')\",\n\t\t\t\t\tTABLE, MAP_ID, CAT_ID, ACTIVE, NAME, DATE, DESC, URL,\n\t\t\t\t\tLATITUDE, LONGITUDE, 0, DEMO_CAT_ID, DEMO_ACTIVE,\n\t\t\t\t\tDEMO_NAME, DEMO_DATE, DEMO_DESC, DEMO_URL, DEMO_LATITUDE,\n\t\t\t\t\tDEMO_LONGITUDE);\n", "refactored_code": "\tpublic static final int DEMO_ID = 0;\n\tpublic static final String DEFAULT_MAP_CREATE = String\n\t\t\t.format(\"INSERT INTO %s (%s, %s, %s, %s, %s, %s, %s, %s, %s) VALUES (%d,%d,%d,'%s','%s','%s','%s','%s','%s')\",\n\t\t\t\t\tTABLE, MAP_ID, CAT_ID, ACTIVE, NAME, DATE, DESC, URL,\n\t\t\t\t\tLATITUDE, LONGITUDE, DEMO_ID, DEMO_CAT_ID, DEMO_ACTIVE,\n\t\t\t\t\tDEMO_NAME, DEMO_DATE, DEMO_DESC, DEMO_URL, DEMO_LATITUDE,\n\t\t\t\t\tDEMO_LONGITUDE);\n"}
{"magic_number_smell": "        mRefreshView.setOnClickListener(new OnClickRefreshListener());\n        mRefreshOriginalTopPadding = mRefreshView.getPaddingTop();\n\n        mRefreshState = 1;\n\n        addHeaderView(mRefreshView);\n", "refactored_code": "    private static final int TAP_TO_REFRESH = 1;\n        mRefreshView.setOnClickListener(new OnClickRefreshListener());\n        mRefreshOriginalTopPadding = mRefreshView.getPaddingTop();\n\n        mRefreshState = TAP_TO_REFRESH;\n\n        addHeaderView(mRefreshView);\n"}
{"magic_number_smell": "\t\t}\n\n\t\tif (required) {\n\t\t\tcreateDialog(0);\n\t\t} else if (mError) {\n\t\t\tcreateDialog(DIALOG_SHOW_MESSAGE);\n\t\t} else {", "refactored_code": "\tprivate static final int DIALOG_SHOW_REQUIRED = 0;\n\t\t}\n\n\t\tif (required) {\n\t\t\tcreateDialog(DIALOG_SHOW_REQUIRED);\n\t\t} else if (mError) {\n\t\t\tcreateDialog(DIALOG_SHOW_MESSAGE);\n\t\t} else {"}
{"magic_number_smell": "\t */\n\tprivate void createDialog(int id) {\n\t\tswitch (id) {\n\t\tcase 0: {\n\t\t\tDialog dialog = new AlertDialog.Builder(this)\n\t\t\t\t\t.setTitle(R.string.network_error)\n\t\t\t\t\t.setMessage(R.string.network_error_msg)", "refactored_code": "\tprivate static final int DIALOG_ERROR_NETWORK = 0;\n\t */\n\tprivate void createDialog(int id) {\n\t\tswitch (id) {\n\t\tcase DIALOG_ERROR_NETWORK: {\n\t\t\tDialog dialog = new AlertDialog.Builder(this)\n\t\t\t\t\t.setTitle(R.string.network_error)\n\t\t\t\t\t.setMessage(R.string.network_error_msg)"}
{"magic_number_smell": "            maps.createDialog(DIALOG_ADD_DEPLOYMENT);\n            return true;\n        } else if (itemPosition == 2) { // find map around me\n            maps.createDialog(0);\n            return true;\n        } else if (itemPosition == 3) { // clear all map\n            maps.createDialog(DIALOG_CLEAR_DEPLOYMENT);", "refactored_code": "    private static final int DIALOG_DISTANCE = 0;\n            maps.createDialog(DIALOG_ADD_DEPLOYMENT);\n            return true;\n        } else if (itemPosition == 2) { // find map around me\n            maps.createDialog(DIALOG_DISTANCE);\n            return true;\n        } else if (itemPosition == 3) { // clear all map\n            maps.createDialog(DIALOG_CLEAR_DEPLOYMENT);"}
{"magic_number_smell": "            return true;\n        } else if (item.getItemId() == R.id.menu_find) {\n\n            createDialog(0);\n            return true;\n        } else if (item.getItemId() == R.id.menu_add) {\n            edit = false;", "refactored_code": "    public static final int DIALOG_DISTANCE = 0;\n            return true;\n        } else if (item.getItemId() == R.id.menu_find) {\n\n            createDialog(DIALOG_DISTANCE);\n            return true;\n        } else if (item.getItemId() == R.id.menu_add) {\n            edit = false;"}
{"magic_number_smell": "\n\t\ttry {\n\t\t\tin = new BufferedInputStream(new URL(address).openStream(),\n\t\t\t\t\t512);\n\n\t\t\tfinal ByteArrayOutputStream dataStream = new ByteArrayOutputStream();\n\t\t\tout = new BufferedOutputStream(dataStream, 4 * 1024);", "refactored_code": "\tprivate static final int IO_BUFFER_SIZE = 512;\n\n\t\ttry {\n\t\t\tin = new BufferedInputStream(new URL(address).openStream(),\n\t\t\t\t\tIO_BUFFER_SIZE);\n\n\t\t\tfinal ByteArrayOutputStream dataStream = new ByteArrayOutputStream();\n\t\t\tout = new BufferedOutputStream(dataStream, 4 * 1024);"}
{"magic_number_smell": "\t\t\t\t\t.getResources(), loadingBitmap));\n\n\t\t\timageSwitcher.setImageDrawable(td);\n\t\t\ttd.startTransition(200);\n\t\t} else {\n\t\t\timageSwitcher.setImageDrawable(new BitmapDrawable(context\n\t\t\t\t\t.getResources(), bitmap));", "refactored_code": "\tprivate static final int FADE_IN_TIME = 200;\n\t\t\t\t\t.getResources(), loadingBitmap));\n\n\t\t\timageSwitcher.setImageDrawable(td);\n\t\t\ttd.startTransition(FADE_IN_TIME);\n\t\t} else {\n\t\t\timageSwitcher.setImageDrawable(new BitmapDrawable(context\n\t\t\t\t\t.getResources(), bitmap));"}
{"magic_number_smell": "\t\t\t\t\t.getResources(), loadingBitmap));\n\n\t\t\timageView.setImageDrawable(td);\n\t\t\ttd.startTransition(200);\n\t\t} else {\n\t\t\timageView.setImageBitmap(bitmap);\n\t\t}", "refactored_code": "\tprivate static final int FADE_IN_TIME = 200;\n\t\t\t\t\t.getResources(), loadingBitmap));\n\n\t\t\timageView.setImageDrawable(td);\n\t\t\ttd.startTransition(FADE_IN_TIME);\n\t\t} else {\n\t\t\timageView.setImageBitmap(bitmap);\n\t\t}"}
{"magic_number_smell": "        if (DEBUG) Log.d(TAG, \"[<ctor>] activity: \" + activity + \", flags: \" + flags);\n\n        mActivity = activity;\n        mIsDelegate = (flags & 1) != 0;\n    }\n\n", "refactored_code": "    public static final int FLAG_DELEGATE = 1;\n        if (DEBUG) Log.d(TAG, \"[<ctor>] activity: \" + activity + \", flags: \" + flags);\n\n        mActivity = activity;\n        mIsDelegate = (flags & FLAG_DELEGATE) != 0;\n    }\n\n"}
{"magic_number_smell": "    /**\n     * Returns the current ActionBar title in standard mode.\n     * Returns null if {@link #getNavigationMode()} would not return\n     * {@link #android.app.ActionBar.NAVIGATION_MODE_STANDARD}.\n     *\n     * @return The current ActionBar title or null.\n     */", "refactored_code": "    public static final int NAVIGATION_MODE_STANDARD = android.app.ActionBar.NAVIGATION_MODE_STANDARD;\n    /**\n     * Returns the current ActionBar title in standard mode.\n     * Returns null if {@link #getNavigationMode()} would not return\n     * {@link #NAVIGATION_MODE_STANDARD}.\n     *\n     * @return The current ActionBar title or null.\n     */"}
{"magic_number_smell": "    /** Main action bar view which displays the core content. */\n    private ActionBarView wActionBar;\n    /** Relevant window and action bar features flags. */\n    private int mFeatures = 0;\n    /** Relevant user interface option flags. */\n    private int mUiOptions = 0;\n", "refactored_code": "    protected static final int DEFAULT_FEATURES = 0;\n    /** Main action bar view which displays the core content. */\n    private ActionBarView wActionBar;\n    /** Relevant window and action bar features flags. */\n    private int mFeatures = DEFAULT_FEATURES;\n    /** Relevant user interface option flags. */\n    private int mUiOptions = 0;\n"}
{"magic_number_smell": "\n        mActionView.setContextView(mContextView);\n        mContextDisplayMode = mActionView.isSplitActionBar() ?\n                CONTEXT_DISPLAY_SPLIT : 0;\n\n        // Older apps get the home button interaction enabled by default.\n        // Newer apps need to enable it explicitly.", "refactored_code": "    private static final int CONTEXT_DISPLAY_NORMAL = 0;\n\n        mActionView.setContextView(mContextView);\n        mContextDisplayMode = mActionView.isSplitActionBar() ?\n                CONTEXT_DISPLAY_SPLIT : CONTEXT_DISPLAY_NORMAL;\n\n        // Older apps get the home button interaction enabled by default.\n        // Newer apps need to enable it explicitly."}
{"magic_number_smell": "    private long mStartDelay = 0;\n\n    // The number of milliseconds between animation frames\n    private static long sFrameDelay = 10;\n\n    // The number of times the animation will repeat. The default is 0, which means the animation\n    // will play only once", "refactored_code": "    private static final long DEFAULT_FRAME_DELAY = 10;\n    private long mStartDelay = 0;\n\n    // The number of milliseconds between animation frames\n    private static long sFrameDelay = DEFAULT_FRAME_DELAY;\n\n    // The number of times the animation will repeat. The default is 0, which means the animation\n    // will play only once"}
{"magic_number_smell": "\n    public MenuItem setIcon(Drawable icon) {\n        mIconDrawable = icon;\n        //UNUSED mIconResId = 0;\n        return this;\n    }\n", "refactored_code": "    //UNUSED private static final int NO_ICON = 0;\n\n    public MenuItem setIcon(Drawable icon) {\n        mIconDrawable = icon;\n        //UNUSED mIconResId = NO_ICON;\n        return this;\n    }\n"}
{"magic_number_smell": "                }\n            }\n            ObjectAnimator anim = ObjectAnimator.ofFloat(this, \"alpha\", 1);\n            anim.setDuration(200);\n            anim.setInterpolator(sAlphaInterpolator);\n            if (mSplitView != null && mMenuView != null) {\n                AnimatorSet set = new AnimatorSet();", "refactored_code": "    private static final int FADE_DURATION = 200;\n                }\n            }\n            ObjectAnimator anim = ObjectAnimator.ofFloat(this, \"alpha\", 1);\n            anim.setDuration(FADE_DURATION);\n            anim.setInterpolator(sAlphaInterpolator);\n            if (mSplitView != null && mMenuView != null) {\n                AnimatorSet set = new AnimatorSet();"}
{"magic_number_smell": "        if (mAnimationMode == ANIMATE_OUT) {\n            killMode();\n        }\n        mAnimationMode = 0;\n    }\n\n    @Override", "refactored_code": "    private static final int ANIMATE_IDLE = 0;\n        if (mAnimationMode == ANIMATE_OUT) {\n            killMode();\n        }\n        mAnimationMode = ANIMATE_IDLE;\n    }\n\n    @Override"}
{"magic_number_smell": "        mProgressBarPadding = a.getDimensionPixelOffset(R.styleable.SherlockActionBar_progressBarPadding, 0);\n        mItemPadding = a.getDimensionPixelOffset(R.styleable.SherlockActionBar_itemPadding, 0);\n\n        setDisplayOptions(a.getInt(R.styleable.SherlockActionBar_displayOptions, 0));\n\n        final int customNavId = a.getResourceId(R.styleable.SherlockActionBar_customNavigationLayout, 0);\n        if (customNavId != 0) {", "refactored_code": "    public static final int DISPLAY_DEFAULT = 0;\n        mProgressBarPadding = a.getDimensionPixelOffset(R.styleable.SherlockActionBar_progressBarPadding, 0);\n        mItemPadding = a.getDimensionPixelOffset(R.styleable.SherlockActionBar_itemPadding, 0);\n\n        setDisplayOptions(a.getInt(R.styleable.SherlockActionBar_displayOptions, DISPLAY_DEFAULT));\n\n        final int customNavId = a.getResourceId(R.styleable.SherlockActionBar_customNavigationLayout, 0);\n        if (customNavId != 0) {"}
{"magic_number_smell": "        super(context, attrs);\n\n        TypedArray a = context.obtainStyledAttributes(attrs, R_styleable_Button);\n        int ap = a.getResourceId(0, -1);\n        a.recycle();\n        if (ap != -1) {\n            TypedArray appearance = context.obtainStyledAttributes(ap, R_styleable_TextAppearance);", "refactored_code": "    private static final int R_styleable_Button_textAppearance = 0;\n        super(context, attrs);\n\n        TypedArray a = context.obtainStyledAttributes(attrs, R_styleable_Button);\n        int ap = a.getResourceId(R_styleable_Button_textAppearance, -1);\n        a.recycle();\n        if (ap != -1) {\n            TypedArray appearance = context.obtainStyledAttributes(ap, R_styleable_TextAppearance);"}
{"magic_number_smell": "        super(context, attrs, defStyle);\n\n        TypedArray a = context.obtainStyledAttributes(attrs, R_styleable_TextView, defStyle, 0);\n        mAllCaps = a.getBoolean(0, true);\n        a.recycle();\n    }\n", "refactored_code": "    private static final int R_styleable_TextView_textAllCaps = 0;\n        super(context, attrs, defStyle);\n\n        TypedArray a = context.obtainStyledAttributes(attrs, R_styleable_TextView, defStyle, 0);\n        mAllCaps = a.getBoolean(R_styleable_TextView_textAllCaps, true);\n        a.recycle();\n    }\n"}
{"magic_number_smell": "\n        TypedArray a = context.obtainStyledAttributes(attrs, /*com.android.internal.R.styleable.*/R_styleable_LinearLayout);\n\n        setDividerDrawable(a.getDrawable(/*com.android.internal.R.styleable.*/0));\n        mShowDividers = a.getInt(/*com.android.internal.R.styleable.*/LinearLayout_showDividers, SHOW_DIVIDER_NONE);\n        mDividerPadding = a.getDimensionPixelSize(/*com.android.internal.R.styleable.*/LinearLayout_dividerPadding, 0);\n", "refactored_code": "    private static final int LinearLayout_divider = 0;\n\n        TypedArray a = context.obtainStyledAttributes(attrs, /*com.android.internal.R.styleable.*/R_styleable_LinearLayout);\n\n        setDividerDrawable(a.getDrawable(/*com.android.internal.R.styleable.*/LinearLayout_divider));\n        mShowDividers = a.getInt(/*com.android.internal.R.styleable.*/LinearLayout_showDividers, SHOW_DIVIDER_NONE);\n        mDividerPadding = a.getDimensionPixelSize(/*com.android.internal.R.styleable.*/LinearLayout_dividerPadding, 0);\n"}
{"magic_number_smell": "            if (action == MotionEvent.ACTION_DOWN &&\n                    mPopup != null && mPopup.isShowing() &&\n                    (x >= 0 && x < mPopup.getWidth() && y >= 0 && y < mPopup.getHeight())) {\n                mHandler.postDelayed(mResizePopupRunnable, 250);\n            } else if (action == MotionEvent.ACTION_UP) {\n                mHandler.removeCallbacks(mResizePopupRunnable);\n            }", "refactored_code": "    private static final int EXPAND_LIST_TIMEOUT = 250;\n            if (action == MotionEvent.ACTION_DOWN &&\n                    mPopup != null && mPopup.isShowing() &&\n                    (x >= 0 && x < mPopup.getWidth() && y >= 0 && y < mPopup.getHeight())) {\n                mHandler.postDelayed(mResizePopupRunnable, EXPAND_LIST_TIMEOUT);\n            } else if (action == MotionEvent.ACTION_UP) {\n                mHandler.removeCallbacks(mResizePopupRunnable);\n            }"}
{"magic_number_smell": "        // Make sure the number of items we'll measure is capped. If it's a huge data set\n        // with wildly varying sizes, oh well.\n        int start = Math.max(0, getSelectedItemPosition());\n        final int end = Math.min(adapter.getCount(), start + 15);\n        final int count = end - start;\n        start = Math.max(0, start - (15 - count));\n        for (int i = start; i < end; i++) {", "refactored_code": "    private static final int MAX_ITEMS_MEASURED = 15;\n        // Make sure the number of items we'll measure is capped. If it's a huge data set\n        // with wildly varying sizes, oh well.\n        int start = Math.max(0, getSelectedItemPosition());\n        final int end = Math.min(adapter.getCount(), start + MAX_ITEMS_MEASURED);\n        final int count = end - start;\n        start = Math.max(0, start - (MAX_ITEMS_MEASURED - count));\n        for (int i = start; i < end; i++) {"}
{"magic_number_smell": "                setAlpha(0);\n            }\n            ObjectAnimator anim = ObjectAnimator.ofFloat(this, \"alpha\", 1);\n            anim.setDuration(200);\n            anim.setInterpolator(sAlphaInterpolator);\n\n            anim.addListener(mVisAnimListener.withFinalVisibility(visibility));", "refactored_code": "    private static final int FADE_DURATION = 200;\n                setAlpha(0);\n            }\n            ObjectAnimator anim = ObjectAnimator.ofFloat(this, \"alpha\", 1);\n            anim.setDuration(FADE_DURATION);\n            anim.setInterpolator(sAlphaInterpolator);\n\n            anim.addListener(mVisAnimListener.withFinalVisibility(visibility));"}
{"magic_number_smell": "        super(context, attrs);\n\n        TypedArray a = context.obtainStyledAttributes(attrs, /*com.android.internal.R.styleable.*/R_styleable_LinearLayout);\n        mUseLargestChild = a.getBoolean(/*com.android.internal.R.styleable.*/0, false);\n\n        a.recycle();\n    }", "refactored_code": "    private static final int LinearLayout_measureWithLargestChild = 0;\n        super(context, attrs);\n\n        TypedArray a = context.obtainStyledAttributes(attrs, /*com.android.internal.R.styleable.*/R_styleable_LinearLayout);\n        mUseLargestChild = a.getBoolean(/*com.android.internal.R.styleable.*/LinearLayout_measureWithLargestChild, false);\n\n        a.recycle();\n    }"}
{"magic_number_smell": "\n        private ActionProvider itemActionProvider;\n\n        private static final int defaultGroupId = 0;\n        private static final int defaultItemId = 0;\n        private static final int defaultItemCategory = 0;\n        private static final int defaultItemOrder = 0;", "refactored_code": "    private static final int NO_ID = 0;\n\n        private ActionProvider itemActionProvider;\n\n        private static final int defaultGroupId = NO_ID;\n        private static final int defaultItemId = NO_ID;\n        private static final int defaultItemCategory = 0;\n        private static final int defaultItemOrder = 0;"}
{"magic_number_smell": "    /**\n     * Sets how this item should display in the presence of an Action Bar.\n     * The parameter actionEnum is a flag set. One of {@link #SHOW_AS_ACTION_ALWAYS},\n     * {@link #SHOW_AS_ACTION_IF_ROOM}, or {@link #android.view.MenuItem.SHOW_AS_ACTION_NEVER} should\n     * be used, and you may optionally OR the value with {@link #SHOW_AS_ACTION_WITH_TEXT}.\n     * SHOW_AS_ACTION_WITH_TEXT requests that when the item is shown as an action,\n     * it should be shown with a text label.", "refactored_code": "    public static final int SHOW_AS_ACTION_NEVER = android.view.MenuItem.SHOW_AS_ACTION_NEVER;\n    /**\n     * Sets how this item should display in the presence of an Action Bar.\n     * The parameter actionEnum is a flag set. One of {@link #SHOW_AS_ACTION_ALWAYS},\n     * {@link #SHOW_AS_ACTION_IF_ROOM}, or {@link #SHOW_AS_ACTION_NEVER} should\n     * be used, and you may optionally OR the value with {@link #SHOW_AS_ACTION_WITH_TEXT}.\n     * SHOW_AS_ACTION_WITH_TEXT requests that when the item is shown as an action,\n     * it should be shown with a text label."}
{"magic_number_smell": "    /**\n     * The maximal length of the choice history.\n     */\n    private int mHistoryMaxSize = 50;\n\n    /**\n     * Flag whether choice history can be read. In general many clients can", "refactored_code": "    public static final int DEFAULT_HISTORY_MAX_LENGTH = 50;\n    /**\n     * The maximal length of the choice history.\n     */\n    private int mHistoryMaxSize = DEFAULT_HISTORY_MAX_LENGTH;\n\n    /**\n     * Flag whether choice history can be read. In general many clients can"}
{"magic_number_smell": "            // The user may have specified some of the target not to be shown but we\n            // want to measure all of them since after expansion they should fit.\n            final int oldMaxActivityCount = mMaxActivityCount;\n            mMaxActivityCount = Integer.MAX_VALUE;\n\n            int contentWidth = 0;\n            View itemView = null;", "refactored_code": "        public static final int MAX_ACTIVITY_COUNT_UNLIMITED = Integer.MAX_VALUE;\n            // The user may have specified some of the target not to be shown but we\n            // want to measure all of them since after expansion they should fit.\n            final int oldMaxActivityCount = mMaxActivityCount;\n            mMaxActivityCount = MAX_ACTIVITY_COUNT_UNLIMITED;\n\n            int contentWidth = 0;\n            View itemView = null;"}
{"magic_number_smell": "    /**\n     * The the maximum number activities shown in the sub-menu.\n     */\n    private int mMaxShownActivityCount = 4;\n\n    /**\n     * Listener for handling menu item clicks.", "refactored_code": "    private static final int DEFAULT_INITIAL_ACTIVITY_COUNT = 4;\n    /**\n     * The the maximum number activities shown in the sub-menu.\n     */\n    private int mMaxShownActivityCount = DEFAULT_INITIAL_ACTIVITY_COUNT;\n\n    /**\n     * Listener for handling menu item clicks."}
{"magic_number_smell": "        }\n        //mSearchView.getWindow().getDecorView().post(mStartSpinnerRunnable); // TODO:\n        try {\n            cursor = getSuggestions(query, 50);\n            // trigger fill window so the spinner stays up until the results are copied over and\n            // closer to being ready\n            if (cursor != null) {", "refactored_code": "    private static final int QUERY_LIMIT = 50;\n        }\n        //mSearchView.getWindow().getDecorView().post(mStartSpinnerRunnable); // TODO:\n        try {\n            cursor = getSuggestions(query, QUERY_LIMIT);\n            // trigger fill window so the spinner stays up until the results are copied over and\n            // closer to being ready\n            if (cursor != null) {"}
{"magic_number_smell": "    private boolean optionalArg;\n\n    /** The number of argument values this option can have. */\n    private int argCount = -1;\n\n    /** The type of this Option. */\n    private Class<?> type = String.class;", "refactored_code": "    public static final int UNINITIALIZED = -1;\n    private boolean optionalArg;\n\n    /** The number of argument values this option can have. */\n    private int argCount = UNINITIALIZED;\n\n    /** The type of this Option. */\n    private Class<?> type = String.class;"}
{"magic_number_smell": "        converterMap.put(Integer.class, Integer::parseInt);\n        converterMap.put(Short.class, Short::parseShort);\n        converterMap.put(Byte.class, Byte::parseByte);\n        converterMap.put(Character.class, s -> s.startsWith(\"\\\\u\") ? Character.toChars(Integer.parseInt(s.substring(2), 16))[0] : s.charAt(0));\n        converterMap.put(Double.class, Double::parseDouble);\n        converterMap.put(Float.class, Float::parseFloat);\n        converterMap.put(BigInteger.class, BigInteger::new);", "refactored_code": "    private static final int HEX_RADIX = 16;\n        converterMap.put(Integer.class, Integer::parseInt);\n        converterMap.put(Short.class, Short::parseShort);\n        converterMap.put(Byte.class, Byte::parseByte);\n        converterMap.put(Character.class, s -> s.startsWith(\"\\\\u\") ? Character.toChars(Integer.parseInt(s.substring(2), HEX_RADIX))[0] : s.charAt(0));\n        converterMap.put(Double.class, Double::parseDouble);\n        converterMap.put(Float.class, Float::parseFloat);\n        converterMap.put(BigInteger.class, BigInteger::new);"}
{"magic_number_smell": "    }\n\n    private static final class TestOption extends Option {\n        private static final long 1L = 1L;\n\n        TestOption(final String opt, final boolean hasArg, final String description) throws IllegalArgumentException {\n            super(opt, hasArg, description);", "refactored_code": "        private static final long serialVersionUID = 1L;\n    }\n\n    private static final class TestOption extends Option {\n        private static final long serialVersionUID = 1L;\n\n        TestOption(final String opt, final boolean hasArg, final String description) throws IllegalArgumentException {\n            super(opt, hasArg, description);"}
{"magic_number_smell": "\n        priorities = new Priorities();\n\n        eventStack = new EventStack(50);\n    }\n\n    public void startBackgroundTasks() {", "refactored_code": "    private static final int EVENT_STACK_CAPACITY = 50;\n\n        priorities = new Priorities();\n\n        eventStack = new EventStack(EVENT_STACK_CAPACITY);\n    }\n\n    public void startBackgroundTasks() {"}
{"magic_number_smell": "    private int totalVisits;\n\n    public History() {\n        this.visited = new AtomId[1000];\n        totalVisits = 0;\n    }\n", "refactored_code": "    private static final int CAPACITY = 1000;\n    private int totalVisits;\n\n    public History() {\n        this.visited = new AtomId[CAPACITY];\n        totalVisits = 0;\n    }\n"}
{"magic_number_smell": "\n    @Before\n    public void setUp() throws Exception {\n        eventStack = new EventStack(50);\n    }\n\n    @After", "refactored_code": "    private final int testCapacity = 50;\n\n    @Before\n    public void setUp() throws Exception {\n        eventStack = new EventStack(testCapacity);\n    }\n\n    @After"}
{"magic_number_smell": "        }\n\n        // First add the static data...\n        RDFHandler a = streamProcessor.createRDFHandler(0, QUERY_TTL = 0);\n        RDFParser p = Rio.createParser(RDFFormat.TURTLE);\n        p.setRDFHandler(a);\n        p.parse(MonitronOntology.class.getResourceAsStream(\"universe.ttl\"), baseUri);", "refactored_code": "    private static final int TUPLE_TTL = 0, QUERY_TTL = 0;\n        }\n\n        // First add the static data...\n        RDFHandler a = streamProcessor.createRDFHandler(TUPLE_TTL);\n        RDFParser p = Rio.createParser(RDFFormat.TURTLE);\n        p.setRDFHandler(a);\n        p.parse(MonitronOntology.class.getResourceAsStream(\"universe.ttl\"), baseUri);"}
{"magic_number_smell": "            return;\n        }\n\n        if (level >= 16) {\n            logger.warning(\"LaTeX tree exceeds maximum depth of \" + 16);\n            return;\n        }", "refactored_code": "    private static final int MAX_LATEX_RECURSE_LEVELS = 16;\n            return;\n        }\n\n        if (level >= MAX_LATEX_RECURSE_LEVELS) {\n            logger.warning(\"LaTeX tree exceeds maximum depth of \" + MAX_LATEX_RECURSE_LEVELS);\n            return;\n        }"}
{"magic_number_smell": "    private final OscSender notificationSender;\n\n    public GesturalServer(final Consumer<Dataset> datasetHandler) {\n        this(42003, datasetHandler);\n    }\n\n    public GesturalServer(final int port,", "refactored_code": "    private static final int DEFAULT_PORT = 42003;\n    private final OscSender notificationSender;\n\n    public GesturalServer(final Consumer<Dataset> datasetHandler) {\n        this(DEFAULT_PORT, datasetHandler);\n    }\n\n    public GesturalServer(final int port,"}
{"magic_number_smell": "\n    private boolean isOld(final Handoff h,\n                          final long now) {\n        return now - h.timeOfSpike > 60;\n    }\n\n    private void cleanup(final long timestamp) {", "refactored_code": "    private static final long SPIKE_MAX_GAP = 60;\n\n    private boolean isOld(final Handoff h,\n                          final long now) {\n        return now - h.timeOfSpike > SPIKE_MAX_GAP;\n    }\n\n    private void cleanup(final long timestamp) {"}
{"magic_number_smell": "\n    private boolean isOld(final HandshakeSequence h,\n                          final long now) {\n        return now - h.latestPeak > 353;\n    }\n\n    private void cleanup(final long timestamp) {", "refactored_code": "    private static final long PEAK_MAX_GAP = 353;\n\n    private boolean isOld(final HandshakeSequence h,\n                          final long now) {\n        return now - h.latestPeak > PEAK_MAX_GAP;\n    }\n\n    private void cleanup(final long timestamp) {"}
{"magic_number_smell": "    }\n\n    private void cleanup(final long timestamp) {\n        if (null != lastClap && timestamp - lastClap.timeOfPeak > 200) {\n            lastClap = null;\n        }\n    }", "refactored_code": "    private static final long PEAK_MAX_GAP = 200;\n    }\n\n    private void cleanup(final long timestamp) {\n        if (null != lastClap && timestamp - lastClap.timeOfPeak > PEAK_MAX_GAP) {\n            lastClap = null;\n        }\n    }"}
{"magic_number_smell": "                        }\n\n                        total++;\n                        if (total > 1000) {\n                            SemanticSynchrony.getLogger().log(Level.INFO, \"showing only the first \"\n                                    + 1000 + \" duplicates\");\n                            break;", "refactored_code": "    private static final int MAX_DUPLICATES = 1000;\n                        }\n\n                        total++;\n                        if (total > MAX_DUPLICATES) {\n                            SemanticSynchrony.getLogger().log(Level.INFO, \"showing only the first \"\n                                    + MAX_DUPLICATES + \" duplicates\");\n                            break;"}
{"magic_number_smell": "                logger.warning(\"error while sending broadcast message(s): \" + e.getMessage());\n                //e.printStackTrace(System.err);\n                backoff *= 2;\n                if (backoff > 60000) {\n                    backoff = 60000;\n                }\n", "refactored_code": "    private static final long MAX_BACKOFF = 60000;\n                logger.warning(\"error while sending broadcast message(s): \" + e.getMessage());\n                //e.printStackTrace(System.err);\n                backoff *= 2;\n                if (backoff > MAX_BACKOFF) {\n                    backoff = MAX_BACKOFF;\n                }\n"}
{"magic_number_smell": "\n        int port = config.getPort();\n\n        byte[] buffer = new byte[1000];\n        try {\n            DatagramPacket dataIn = new DatagramPacket(buffer, buffer.length);\n            try (DatagramSocket socket = new DatagramSocket(port)) {", "refactored_code": "    private static final int BROADCAST_MAX_LENGTH = 1000;\n\n        int port = config.getPort();\n\n        byte[] buffer = new byte[BROADCAST_MAX_LENGTH];\n        try {\n            DatagramPacket dataIn = new DatagramPacket(buffer, buffer.length);\n            try (DatagramSocket socket = new DatagramSocket(port)) {"}
{"magic_number_smell": "    }\n\n    public SlipInputStream(final InputStream inputStream) {\n        this(inputStream, 1500);\n    }\n\n    public void receive(final PacketHandler handler) throws IOException, PacketHandlerException {", "refactored_code": "    private static final int DEFAULT_BUFFER_LENGTH = 1500;\n    }\n\n    public SlipInputStream(final InputStream inputStream) {\n        this(inputStream, DEFAULT_BUFFER_LENGTH);\n    }\n\n    public void receive(final PacketHandler handler) throws IOException, PacketHandlerException {"}
{"magic_number_smell": "                byte[] bytes = bundle.getByteArray();\n\n                // TODO: this warning is only relevant in a Bluetooth context\n                if (bytes.length >= 128) {\n                    // SLIP will expand a message by at least one byte (for END),\n                    // sometimes many bytes (depending on the number of escape sequences required)\n                    logger.log(Level.WARNING, \"message length (\" + bytes.length", "refactored_code": "    private static final int SPP_PAYLOAD_CAPACITY = 128;\n                byte[] bytes = bundle.getByteArray();\n\n                // TODO: this warning is only relevant in a Bluetooth context\n                if (bytes.length >= SPP_PAYLOAD_CAPACITY) {\n                    // SLIP will expand a message by at least one byte (for END),\n                    // sometimes many bytes (depending on the number of escape sequences required)\n                    logger.log(Level.WARNING, \"message length (\" + bytes.length"}
{"magic_number_smell": "            requestJson.put(Params.QUERY, query);\n            requestJson.put(Params.HEIGHT, height);\n            requestJson.put(Params.STYLE, style.getName());\n            requestJson.put(Params.TITLE_CUTOFF, 100);\n        } catch (JSONException e) {\n            throw new BrainClientException(e);\n        }", "refactored_code": "    private static final int DEFAULT_VALUE_CUTOFF = 100;\n            requestJson.put(Params.QUERY, query);\n            requestJson.put(Params.HEIGHT, height);\n            requestJson.put(Params.STYLE, style.getName());\n            requestJson.put(Params.TITLE_CUTOFF, DEFAULT_VALUE_CUTOFF);\n        } catch (JSONException e) {\n            throw new BrainClientException(e);\n        }"}
{"magic_number_smell": "    private final UndoRedoStack<Collector<RippleList>> undoRedoStack;\n\n    public RippleSession() throws RippleException {\n        this.undoRedoStack = new UndoRedoStack<>(20);\n        undoRedoStack.done(new Collector<>());\n\n        sail = new MemoryStore();", "refactored_code": "    private static final int UNDO_REDO_DEPTH = 20;\n    private final UndoRedoStack<Collector<RippleList>> undoRedoStack;\n\n    public RippleSession() throws RippleException {\n        this.undoRedoStack = new UndoRedoStack<>(UNDO_REDO_DEPTH);\n        undoRedoStack.done(new Collector<>());\n\n        sail = new MemoryStore();"}
{"magic_number_smell": "\tpublic static Date getNowPlusOneMinute() {\n\t\tCalendar date = Calendar.getInstance();\n\t\tlong t = date.getTimeInMillis();\n\t\tDate nowDatePlusMinute = new Date(t + 60000);\n\t\treturn nowDatePlusMinute;\n\t}\n", "refactored_code": "\tprivate static final long ONE_MINUTE_IN_MILLIS = 60000;// millisecs\n\tpublic static Date getNowPlusOneMinute() {\n\t\tCalendar date = Calendar.getInstance();\n\t\tlong t = date.getTimeInMillis();\n\t\tDate nowDatePlusMinute = new Date(t + ONE_MINUTE_IN_MILLIS);\n\t\treturn nowDatePlusMinute;\n\t}\n"}
{"magic_number_smell": "    public JSONWriter(Writer w) {\n        this.comma = false;\n        this.mode = 'i';\n        this.stack = new JSONObject[20];\n        this.top = 0;\n        this.writer = w;\n    }", "refactored_code": "    private static final int maxdepth = 20;\n    public JSONWriter(Writer w) {\n        this.comma = false;\n        this.mode = 'i';\n        this.stack = new JSONObject[maxdepth];\n        this.top = 0;\n        this.writer = w;\n    }"}
{"magic_number_smell": "            }\n            else\n            {\n                _agent = new Agent(this, 10);\n                // Vendor and Product are deliberately set to be the same as for the C++ broker.\n                _agent.setVendor(\"apache.org\");\n                _agent.setProduct(\"qpidd\");", "refactored_code": "    private static final int HEARTBEAT_INTERVAL = 10;\n            }\n            else\n            {\n                _agent = new Agent(this, HEARTBEAT_INTERVAL);\n                // Vendor and Product are deliberately set to be the same as for the C++ broker.\n                _agent.setVendor(\"apache.org\");\n                _agent.setProduct(\"qpidd\");"}
{"magic_number_smell": "\n    /**\n     * Set the Subscription lifetime in seconds. If the value passed to this method is zero the duration gets\n     * set to the Agent's 300 is the duration has not already been set, if the duration has already\n     * been set passing in a zero value has no effect on the duration.\n     * If the value passed is non-zero the duration passed gets restricted between the Agent's MIN_DURATION\n     * and MAX_DURATION.", "refactored_code": "    private static final int DEFAULT_DURATION = 300;\n\n    /**\n     * Set the Subscription lifetime in seconds. If the value passed to this method is zero the duration gets\n     * set to the Agent's DEFAULT_DURATION is the duration has not already been set, if the duration has already\n     * been set passing in a zero value has no effect on the duration.\n     * If the value passed is non-zero the duration passed gets restricted between the Agent's MIN_DURATION\n     * and MAX_DURATION."}
{"magic_number_smell": "        {\n            //System.out.println(\"ConnectionProxy name: \" + _name + \", thread: \" + Thread.currentThread().getId() + \", WorkItem count = \" + _console.getWorkitemCount());\n\n            while (_console.getWorkitemCount() > 20)\n            {\n                _console.getNextWorkitem();\n            }", "refactored_code": "    private static final int MAX_WORKITEM_QUEUE_SIZE = 20; // Maximum number of items allowed on WorkItem queue.\n        {\n            //System.out.println(\"ConnectionProxy name: \" + _name + \", thread: \" + Thread.currentThread().getId() + \", WorkItem count = \" + _console.getWorkitemCount());\n\n            while (_console.getWorkitemCount() > MAX_WORKITEM_QUEUE_SIZE)\n            {\n                _console.getNextWorkitem();\n            }"}
{"magic_number_smell": "        {\n            connection = new ConnectionProxy(this, name, url, opts, disableEvents);\n            _connections.put(name, connection);\n            _timer.schedule(connection, 0, 5000);\n        }\n        return connection;\n    }", "refactored_code": "    public static final int PING_PERIOD = 5000;\n        {\n            connection = new ConnectionProxy(this, name, url, opts, disableEvents);\n            _connections.put(name, connection);\n            _timer.schedule(connection, 0, PING_PERIOD);\n        }\n        return connection;\n    }"}
{"magic_number_smell": "        if (_file.exists())\n        {\n            CacheUpdater updater = new CacheUpdater();\n            _timer.schedule(updater, 0, 10000);\n        }\n        else\n        {", "refactored_code": "    private static final int CHECK_PERIOD = 10000; // Check every 10 seconds if the account properties have been changed.\n        if (_file.exists())\n        {\n            CacheUpdater updater = new CacheUpdater();\n            _timer.schedule(updater, 0, CHECK_PERIOD);\n        }\n        else\n        {"}
{"magic_number_smell": "    public JSONWriter(Writer w) {\n        this.comma = false;\n        this.mode = 'i';\n        this.stack = new JSONObject[20];\n        this.top = 0;\n        this.writer = w;\n    }", "refactored_code": "    private static final int maxdepth = 20;\n    public JSONWriter(Writer w) {\n        this.comma = false;\n        this.mode = 'i';\n        this.stack = new JSONObject[maxdepth];\n        this.top = 0;\n        this.writer = w;\n    }"}
{"magic_number_smell": "\t}\n\t\n\tpublic int getClassification() {\n\t\tif(!isFlat()) return Classification.1;\n\t\t\n\t\tif(name.equals(\"Int\")   || name.equals(\"UInt\")  || name.equals(\"Short\")\n\t\t|| name.equals(\"UShort\")|| name.equals(\"Long\")  || name.equals(\"ULong\")", "refactored_code": "\t\tpublic static final int POINTER = 1;\n\t}\n\t\n\tpublic int getClassification() {\n\t\tif(!isFlat()) return Classification.POINTER;\n\t\t\n\t\tif(name.equals(\"Int\")   || name.equals(\"UInt\")  || name.equals(\"Short\")\n\t\t|| name.equals(\"UShort\")|| name.equals(\"Long\")  || name.equals(\"ULong\")"}
{"magic_number_smell": "\t}\n\n\tpublic boolean isNameToken() {\n\t\treturn type == TokenType.NAME || type == TokenType.1 || type == TokenType.IN_KW || type == TokenType.STRUCT;\n\t}\n\t\n}", "refactored_code": "\t\tpublic static final byte CLASS_KW = 1; // class keyword\n\t}\n\n\tpublic boolean isNameToken() {\n\t\treturn type == TokenType.NAME || type == TokenType.CLASS_KW || type == TokenType.IN_KW || type == TokenType.STRUCT;\n\t}\n\t\n}"}
{"magic_number_smell": "\t\t\n\t\tint count = 0, safeCount = 0;\n\t\trunning = true;\n\t\tif(count > 4, SAFE_MAX = 1024 || safeCount > SAFE_MAX) {\n\t\t\tfatal = true;\n\t\t\tnosy.start().visit(module);\n\t\t\tthrow new OocCompilationError(module, module, \"Resolver is running in circles. Abandoning. (count = \"", "refactored_code": "\tprotected static final int MAX = 4, SAFE_MAX = 1024;\n\t\t\n\t\tint count = 0, safeCount = 0;\n\t\trunning = true;\n\t\tif(count > MAX || safeCount > SAFE_MAX) {\n\t\t\tfatal = true;\n\t\t\tnosy.start().visit(module);\n\t\t\tthrow new OocCompilationError(module, module, \"Resolver is running in circles. Abandoning. (count = \""}
{"magic_number_smell": "\t\tint count = 0;\n\t\trunning = true;\n\t\twhile (running) {\n\t\t\tif (count > 1024) {\n\t\t\t\tthrow new Error(\"Unwrapper going round in circles! More than \"\n\t\t\t\t\t\t+ 1024 + \" runs, abandoning...\");\n\t\t\t}", "refactored_code": "\tprotected static final int MAX = 1024;\n\t\tint count = 0;\n\t\trunning = true;\n\t\twhile (running) {\n\t\t\tif (count > MAX) {\n\t\t\t\tthrow new Error(\"Unwrapper going round in circles! More than \"\n\t\t\t\t\t\t+ MAX + \" runs, abandoning...\");\n\t\t\t}"}
{"magic_number_smell": "    private Date endDate;\n    private String owner;\n    private String label;\n    private int type = 1;\n    private String dependant = \"\";\n\n    public void setType(int t) {", "refactored_code": "    public static final int TASK = 1;\n    private Date endDate;\n    private String owner;\n    private String label;\n    private int type = TASK;\n    private String dependant = \"\";\n\n    public void setType(int t) {"}
{"magic_number_smell": "        ow.write(\"<classes>\\n\");\n        for (String line = inbr.readLine(); line != null; line = inbr.readLine()) {\n            String[] fields = line.split(\";\", NUM_FIELDS);\n            int code = Integer.parseInt(fields[0], 16);\n            if (code > maxChar) {\n                break;\n            }", "refactored_code": "    public static final int UNICODE = 0;\n        ow.write(\"<classes>\\n\");\n        for (String line = inbr.readLine(); line != null; line = inbr.readLine()) {\n            String[] fields = line.split(\";\", NUM_FIELDS);\n            int code = Integer.parseInt(fields[UNICODE], 16);\n            if (code > maxChar) {\n                break;\n            }"}
{"magic_number_smell": "        for (int i = 0; i < lineBreakPropertyShortNames.size(); i++) {\n            name = (String)lineBreakPropertyShortNames.get(i);\n            if (printComma) {\n                if (lineLength <= 110 - 2) {\n                    out.print(\", \");\n                } else {\n                    out.print(\",\");", "refactored_code": "    private static final int MAX_LINE_LENGTH = 110;\n        for (int i = 0; i < lineBreakPropertyShortNames.size(); i++) {\n            name = (String)lineBreakPropertyShortNames.get(i);\n            if (printComma) {\n                if (lineLength <= MAX_LINE_LENGTH - 2) {\n                    out.print(\", \");\n                } else {\n                    out.print(\",\");"}
{"magic_number_smell": "            double[] dstPts = new double[6];\n            iter.currentSegment(dstPts);\n            int[] coords = new int[4];\n            coords[X1] = (int) Math.round(dstPts[0]);\n            coords[Y1] = (int) Math.round(dstPts[Y]);\n            iter.next();\n            iter.currentSegment(dstPts);", "refactored_code": "    private static final int X = 0;\n            double[] dstPts = new double[6];\n            iter.currentSegment(dstPts);\n            int[] coords = new int[4];\n            coords[X1] = (int) Math.round(dstPts[X]);\n            coords[Y1] = (int) Math.round(dstPts[Y]);\n            iter.next();\n            iter.currentSegment(dstPts);"}
{"magic_number_smell": "     */\n    // @SuppressFBWarnings(\"SE_INNER_CLASS\")\n    private class AFPData extends org.apache.fop.util.AbstractPaintingState.AbstractData {\n        private static final long 8206711712452344473L = -1789481244175275686L;\n\n        /** The current fill status */\n        private boolean filled;", "refactored_code": "    private static final long serialVersionUID = 8206711712452344473L;\n     */\n    // @SuppressFBWarnings(\"SE_INNER_CLASS\")\n    private class AFPData extends org.apache.fop.util.AbstractPaintingState.AbstractData {\n        private static final long serialVersionUID = -1789481244175275686L;\n\n        /** The current fill status */\n        private boolean filled;"}
{"magic_number_smell": "     */\n    public Color convert(Color color) {\n\n        float kValue = (77 * color.getRed() + GREEN_WEIGTH * color.getGreen() + BLUE_WEIGHT\n                * color.getBlue()) / 255.0f / 255.0f;\n\n        return ColorUtil.toCMYKGrayColor(kValue);", "refactored_code": "    private static final int RED_WEIGHT = 77;\n     */\n    public Color convert(Color color) {\n\n        float kValue = (RED_WEIGHT * color.getRed() + GREEN_WEIGTH * color.getGreen() + BLUE_WEIGHT\n                * color.getBlue()) / 255.0f / 255.0f;\n\n        return ColorUtil.toCMYKGrayColor(kValue);"}
{"magic_number_smell": "    public int getStrikeoutPosition(int size) {\n        //TODO This conflicts with the FOCA recommendation of 0 in the absence of the Throughscore Position\n        // parameter\n        return (int) (0.45 * getCapHeight(size));\n    }\n\n    /** {@inheritDoc} */", "refactored_code": "    private static final double STRIKEOUT_POSITION_FACTOR = 0.45;\n    public int getStrikeoutPosition(int size) {\n        //TODO This conflicts with the FOCA recommendation of 0 in the absence of the Throughscore Position\n        // parameter\n        return (int) (STRIKEOUT_POSITION_FACTOR * getCapHeight(size));\n    }\n\n    /** {@inheritDoc} */"}
{"magic_number_smell": "     */\n    CharacterSet(String codePage, String encoding, CharacterSetType charsetType, String name,\n            AFPResourceAccessor accessor, AFPEventProducer eventProducer) {\n        if (name.length() > 8) {\n            String msg = \"Character set name '\" + name + \"' must be a maximum of \"\n                + 8 + \" characters\";\n            eventProducer.characterSetNameInvalid(this, msg);", "refactored_code": "    private static final int MAX_NAME_LEN = 8;\n     */\n    CharacterSet(String codePage, String encoding, CharacterSetType charsetType, String name,\n            AFPResourceAccessor accessor, AFPEventProducer eventProducer) {\n        if (name.length() > MAX_NAME_LEN) {\n            String msg = \"Character set name '\" + name + \"' must be a maximum of \"\n                + MAX_NAME_LEN + \" characters\";\n            eventProducer.characterSetNameInvalid(this, msg);"}
{"magic_number_smell": "\n    private static final int 8 = 8;\n\n    private static final int RANGE_SIZE = 1 << 8;\n\n    private final Map<Integer, ArrayList<T>> arrays = new HashMap<Integer, ArrayList<T>>();\n", "refactored_code": "    private static final int RANGE_BIT_SIZE = 8;\n\n    private static final int RANGE_BIT_SIZE = 8;\n\n    private static final int RANGE_SIZE = 1 << RANGE_BIT_SIZE;\n\n    private final Map<Integer, ArrayList<T>> arrays = new HashMap<Integer, ArrayList<T>>();\n"}
{"magic_number_smell": "    public void writeToStream(OutputStream os) throws IOException {\n        byte[] data = new byte[] {\n            getOrderCode(), // GBAR order code\n            (byte)(128 + (drawBoundary ? BOUNDARY : NO_BOUNDARY))\n        };\n        os.write(data);\n    }", "refactored_code": "    private static final int RES1 = 128;\n    public void writeToStream(OutputStream os) throws IOException {\n        byte[] data = new byte[] {\n            getOrderCode(), // GBAR order code\n            (byte)(RES1 + (drawBoundary ? BOUNDARY : NO_BOUNDARY))\n        };\n        os.write(data);\n    }"}
{"magic_number_smell": "     */\n    public GraphicsCharacterString(String str, int x, int y, CharacterSet charSet) {\n        super(x, y);\n        this.str = truncate(str, 255);\n        this.charSet = charSet;\n    }\n", "refactored_code": "    protected static final int MAX_STR_LEN = 255;\n     */\n    public GraphicsCharacterString(String str, int x, int y, CharacterSet charSet) {\n        super(x, y);\n        this.str = truncate(str, MAX_STR_LEN);\n        this.charSet = charSet;\n    }\n"}
{"magic_number_smell": "    public void addObject(StructuredData object) {\n        if (currentSegment == null\n                || (currentSegment.getDataLength() + object.getDataLength())\n                >= GraphicsChainedSegment.GraphicsChainedSegment.MAX_DATA_LEN + 16) {\n            newSegment(true, false);\n        }\n        currentSegment.addObject(object);", "refactored_code": "    public static final int MAX_DATA_LEN = GraphicsChainedSegment.MAX_DATA_LEN + 16;\n    public void addObject(StructuredData object) {\n        if (currentSegment == null\n                || (currentSegment.getDataLength() + object.getDataLength())\n                >= GraphicsChainedSegment.MAX_DATA_LEN) {\n            newSegment(true, false);\n        }\n        currentSegment.addObject(object);"}
{"magic_number_smell": "            (byte) 0x92 // GIMD\n        };\n        final int lengthOffset = 1;\n        writeChunksToStream(imageData, dataHeader, lengthOffset, 255, os);\n\n        byte[] endData = new byte[] {\n            (byte) 0x93, // GEIMG order code", "refactored_code": "    public static final short MAX_DATA_LEN = 255;\n            (byte) 0x92 // GIMD\n        };\n        final int lengthOffset = 1;\n        writeChunksToStream(imageData, dataHeader, lengthOffset, MAX_DATA_LEN, os);\n\n        byte[] endData = new byte[] {\n            (byte) 0x93, // GEIMG order code"}
{"magic_number_smell": "    public static final byte INVISIBLE = 0x08;\n\n    /** line type */\n    private byte type = 0x00;\n\n    /**\n     * Main constructor", "refactored_code": "    public static final byte DEFAULT = 0x00; // normally SOLID\n    public static final byte INVISIBLE = 0x08;\n\n    /** line type */\n    private byte type = DEFAULT;\n\n    /**\n     * Main constructor"}
{"magic_number_smell": "                baout.write(Math.round(colorComponent * 255));\n            }\n        } else if (colSpaceType == ColorSpace.TYPE_RGB) {\n            colspace = 0x01;\n            colsizes = new byte[] {0x08, 0x08, 0x08, 0x00};\n            for (float colorComponent : colorComponents) {\n                baout.write(Math.round(colorComponent * 255));", "refactored_code": "    private static final byte RGB = 0x01;\n                baout.write(Math.round(colorComponent * 255));\n            }\n        } else if (colSpaceType == ColorSpace.TYPE_RGB) {\n            colspace = RGB;\n            colsizes = new byte[] {0x08, 0x08, 0x08, 0x00};\n            for (float colorComponent : colorComponents) {\n                baout.write(Math.round(colorComponent * 255));"}
{"magic_number_smell": "\n    /** {@inheritDoc} */\n    protected int getNameLength() {\n        return 4;\n    }\n\n    /** {@inheritDoc} */", "refactored_code": "    private static final int NAME_LENGTH = 4;\n\n    /** {@inheritDoc} */\n    protected int getNameLength() {\n        return NAME_LENGTH;\n    }\n\n    /** {@inheritDoc} */"}
{"magic_number_smell": "                blue[j] = data[3 * j + 2];\n            }\n            dataHeader[4] = (byte) 0x01;\n            writeChunksToStream(red, dataHeader, lengthOffset, 8191, os);\n            dataHeader[4] = (byte) 0x02;\n            writeChunksToStream(green, dataHeader, lengthOffset, 8191, os);\n            dataHeader[4] = (byte) 0x03;", "refactored_code": "    private static final int MAX_DATA_LEN = 8191;\n                blue[j] = data[3 * j + 2];\n            }\n            dataHeader[4] = (byte) 0x01;\n            writeChunksToStream(red, dataHeader, lengthOffset, MAX_DATA_LEN, os);\n            dataHeader[4] = (byte) 0x02;\n            writeChunksToStream(green, dataHeader, lengthOffset, MAX_DATA_LEN, os);\n            dataHeader[4] = (byte) 0x03;"}
{"magic_number_smell": "                0x00 // length\n        };\n        final int lengthOffset = 2;\n        writeChunksToStream(maskData, dataHeader, lengthOffset, 8188, os);\n\n        os.write(0x8F);\n        os.write(0);", "refactored_code": "    private static final int MAX_DATA_LEN = 8188;\n                0x00 // length\n        };\n        final int lengthOffset = 2;\n        writeChunksToStream(maskData, dataHeader, lengthOffset, MAX_DATA_LEN, os);\n\n        os.write(0x8F);\n        os.write(0);"}
{"magic_number_smell": "     * @return the name length\n     */\n    protected int getNameLength() {\n        return 8;\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_NAME_LENGTH = 8;\n     * @return the name length\n     */\n    protected int getNameLength() {\n        return DEFAULT_NAME_LENGTH;\n    }\n\n    /**"}
{"magic_number_smell": "        final byte[] data = new byte[] {\n            (byte) 0xF6,\n            18, // LENGTH\n            (64 + IMGRES), // FLAGS (64)\n            0x00, // reserved (must be zero)\n            0x00, // CFORMAT (coordinate format - 16bit high byte first signed)\n            0x00, // UBASE (unit base - ten inches)", "refactored_code": "    private static final int ABS = 64;\n        final byte[] data = new byte[] {\n            (byte) 0xF6,\n            18, // LENGTH\n            (ABS + IMGRES), // FLAGS (ABS)\n            0x00, // reserved (must be zero)\n            0x00, // CFORMAT (coordinate format - 16bit high byte first signed)\n            0x00, // UBASE (unit base - ten inches)"}
{"magic_number_smell": "            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            imageSegment.writeToStream(baos);\n            byte[] data = baos.toByteArray();\n            writeChunksToStream(data, dataHeader, lengthOffset, 8192, os);\n        }\n    }\n", "refactored_code": "    private static final int MAX_DATA_LEN = 8192;\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            imageSegment.writeToStream(baos);\n            byte[] data = baos.toByteArray();\n            writeChunksToStream(data, dataHeader, lengthOffset, MAX_DATA_LEN, os);\n        }\n    }\n"}
{"magic_number_smell": "     */\n    public static InterchangeSet valueOf(String str) {\n        if (MODCA_PRESENTATION_INTERCHANGE_SET_1.equals(str)) {\n            return new InterchangeSet(0);\n        } else if (MODCA_PRESENTATION_INTERCHANGE_SET_2.equals(str)) {\n            return new InterchangeSet(SET_2);\n        } else if (MODCA_RESOURCE_INTERCHANGE_SET.equals(str)) {", "refactored_code": "    private static final int SET_1 = 0;\n     */\n    public static InterchangeSet valueOf(String str) {\n        if (MODCA_PRESENTATION_INTERCHANGE_SET_1.equals(str)) {\n            return new InterchangeSet(SET_1);\n        } else if (MODCA_PRESENTATION_INTERCHANGE_SET_2.equals(str)) {\n            return new InterchangeSet(SET_2);\n        } else if (MODCA_RESOURCE_INTERCHANGE_SET.equals(str)) {"}
{"magic_number_smell": "     * @throws MaximumSizeExceededException if the maximum size is reached\n     */\n    public void addOverlay(String name) throws MaximumSizeExceededException {\n        if (getOverlays().size() > 253) {\n            throw new MaximumSizeExceededException();\n        }\n        if (name.length() != 8) {", "refactored_code": "    private static final int MAX_SIZE = 253;\n     * @throws MaximumSizeExceededException if the maximum size is reached\n     */\n    public void addOverlay(String name) throws MaximumSizeExceededException {\n        if (getOverlays().size() > MAX_SIZE) {\n            throw new MaximumSizeExceededException();\n        }\n        if (name.length() != 8) {"}
{"magic_number_smell": "     * @throws MaximumSizeExceededException if the maximum size is reached\n     */\n    public void addPageSegment(String name) throws MaximumSizeExceededException {\n        if (getPageSegments().size() > 127) {\n            throw new MaximumSizeExceededException();\n        }\n        if (name.length() > 8) {", "refactored_code": "    private static final int MAX_SIZE = 127;\n     * @throws MaximumSizeExceededException if the maximum size is reached\n     */\n    public void addPageSegment(String name) throws MaximumSizeExceededException {\n        if (getPageSegments().size() > MAX_SIZE) {\n            throw new MaximumSizeExceededException();\n        }\n        if (name.length() > 8) {"}
{"magic_number_smell": "        int contentLen = contentData.length;\n\n        // packet maximum of 32759 bytes\n        if (contentLen > 32759) {\n            contentLen = 32759;\n        }\n", "refactored_code": "    private static final int MAX_DATA_LEN = 32759;\n        int contentLen = contentData.length;\n\n        // packet maximum of 32759 bytes\n        if (contentLen > MAX_DATA_LEN) {\n            contentLen = MAX_DATA_LEN;\n        }\n"}
{"magic_number_smell": "        byte[] data = new byte[9];\n        copySF(data, Type.DESCRIPTOR, Category.OBJECT_AREA);\n\n        addTriplet(new DescriptorPositionTriplet(0x01));\n        addTriplet(new MeasurementUnitsTriplet(widthRes, heightRes));\n        addTriplet(new ObjectAreaSizeTriplet(width, height));\n        /* not allowed in Presentation Interchange Set 1", "refactored_code": "    private static final byte OBJECT_AREA_POSITION_ID = 0x01;\n        byte[] data = new byte[9];\n        copySF(data, Type.DESCRIPTOR, Category.OBJECT_AREA);\n\n        addTriplet(new DescriptorPositionTriplet(OBJECT_AREA_POSITION_ID));\n        addTriplet(new MeasurementUnitsTriplet(widthRes, heightRes));\n        addTriplet(new ObjectAreaSizeTriplet(width, height));\n        /* not allowed in Presentation Interchange Set 1"}
{"magic_number_smell": "        final int lengthOffset = 1;\n\n        if (data != null) {\n            writeChunksToStream(data, dataHeader, lengthOffset, 8192, os);\n        }\n    }\n", "refactored_code": "    private static final int MAX_DATA_LEN = 8192;\n        final int lengthOffset = 1;\n\n        if (data != null) {\n            writeChunksToStream(data, dataHeader, lengthOffset, MAX_DATA_LEN, os);\n        }\n    }\n"}
{"magic_number_smell": "     * @return the number of data bytes available\n     */\n    public int getBytesAvailable() {\n        return 8192 - baos.size() + HEADER_LENGTH;\n    }\n\n    /**", "refactored_code": "    private static final int MAX_SIZE = 8192;\n     * @return the number of data bytes available\n     */\n    public int getBytesAvailable() {\n        return MAX_SIZE - baos.size() + HEADER_LENGTH;\n    }\n\n    /**"}
{"magic_number_smell": "        mimeObjectTypeMap.put(\n                MimeConstants.MIME_AFP_IOCA_FS10,\n                new ObjectType(\n                        5,\n                        new byte[] {0x06, 0x07, 0x2B, 0x12, 0x00, 0x04, 0x01, 0x01, 0x05},\n                        \"IOCA FS10\",\n                        true,", "refactored_code": "    private static final byte COMPID_IOCA_FS10 = 5;\n        mimeObjectTypeMap.put(\n                MimeConstants.MIME_AFP_IOCA_FS10,\n                new ObjectType(\n                        COMPID_IOCA_FS10,\n                        new byte[] {0x06, 0x07, 0x2B, 0x12, 0x00, 0x04, 0x01, 0x01, 0x05},\n                        \"IOCA FS10\",\n                        true,"}
{"magic_number_smell": "        private String value;\n\n        /** The CCSID character et encoding attribute */\n        private int encoding =  -1;\n\n\n        /**", "refactored_code": "        public static final int ENCODING_NONE = -1;\n        private String value;\n\n        /** The CCSID character et encoding attribute */\n        private int encoding =  ENCODING_NONE;\n\n\n        /**"}
{"magic_number_smell": "    public void writeToStream(OutputStream os) throws IOException {\n        byte[] data = getData();\n\n        data[2] = 0x00; // XoaBase\n        data[3] = 0x00; // YoaBase\n\n        byte[] xUnits = BinaryUtils.convert(xRes * 10, 2);", "refactored_code": "    private static final byte TEN_INCHES = 0x00;\n    public void writeToStream(OutputStream os) throws IOException {\n        byte[] data = getData();\n\n        data[2] = TEN_INCHES; // XoaBase\n        data[3] = TEN_INCHES; // YoaBase\n\n        byte[] xUnits = BinaryUtils.convert(xRes * 10, 2);"}
{"magic_number_smell": "     * @param objectType the resource object type\n     */\n    public ResourceObjectTypeTriplet(byte objectType) {\n        super(0x21);\n        this.objectType = objectType;\n    }\n", "refactored_code": "    private static final byte RESOURCE_OBJECT = 0x21;\n     * @param objectType the resource object type\n     */\n    public ResourceObjectTypeTriplet(byte objectType) {\n        super(RESOURCE_OBJECT);\n        this.objectType = objectType;\n    }\n"}
{"magic_number_smell": "        } while (din.readByte() != CARRIAGE_CONTROL_CHAR);\n\n        //Read introducer as byte array to preserve any data not parsed below\n        byte[] introducerData = new byte[8]; //Length of introducer\n        din.readFully(introducerData);\n\n        Introducer introducer = new Introducer(introducerData);", "refactored_code": "    private static final int INTRODUCER_LENGTH = 8;\n        } while (din.readByte() != CARRIAGE_CONTROL_CHAR);\n\n        //Read introducer as byte array to preserve any data not parsed below\n        byte[] introducerData = new byte[INTRODUCER_LENGTH]; //Length of introducer\n        din.readFully(introducerData);\n\n        Introducer introducer = new Introducer(introducerData);"}
{"magic_number_smell": "    private static final int TRANSPARENT_DATA_MAX_SIZE = TRANSPARENT_DATA_MAX_SIZE;\n    // The maximum size of a TRN must be an EVEN number so that we're splitting TRNs on character\n    // boundaries rather than in the middle of a double-byte character\n    private static final int MAX_DBCS_TRN_SIZE = TRANSPARENT_DATA_MAX_SIZE - 1;\n\n    static final class TransparentData {\n        private final int offset;", "refactored_code": "    private static final int MAX_SBCS_TRN_SIZE = TRANSPARENT_DATA_MAX_SIZE;\n    private static final int MAX_SBCS_TRN_SIZE = TRANSPARENT_DATA_MAX_SIZE;\n    // The maximum size of a TRN must be an EVEN number so that we're splitting TRNs on character\n    // boundaries rather than in the middle of a double-byte character\n    private static final int MAX_DBCS_TRN_SIZE = MAX_SBCS_TRN_SIZE - 1;\n\n    static final class TransparentData {\n        private final int offset;"}
{"magic_number_smell": "\n\n    /** Indicates in what phase the item should be processed. */\n    protected int whenToProcess = 0;\n\n    /**\n     * Get an indicator of when this item should be processed", "refactored_code": "    public static final int IMMEDIATELY = 0;\n\n\n    /** Indicates in what phase the item should be processed. */\n    protected int whenToProcess = IMMEDIATELY;\n\n    /**\n     * Get an indicator of when this item should be processed"}
{"magic_number_smell": "    // @SuppressFBWarnings(\"SE_INNER_CLASS\")\n    private final class LineAdjustingInfo implements Serializable {\n\n        private static final long 7670235908329290684L = -6103629976229458273L;\n\n        private int lineAlignment;\n        private int difference;", "refactored_code": "    private static final long serialVersionUID = 7670235908329290684L;\n    // @SuppressFBWarnings(\"SE_INNER_CLASS\")\n    private final class LineAdjustingInfo implements Serializable {\n\n        private static final long serialVersionUID = -6103629976229458273L;\n\n        private int lineAlignment;\n        private int difference;"}
{"magic_number_smell": "     */\n    public static class InternalLink implements Serializable {\n\n        private static final long 3234280285391611437L = -8993505060996723039L;\n\n        /** The unique key of the PageViewport. */\n        private String pvKey;", "refactored_code": "    private static final long serialVersionUID = 3234280285391611437L;\n     */\n    public static class InternalLink implements Serializable {\n\n        private static final long serialVersionUID = -8993505060996723039L;\n\n        /** The unique key of the PageViewport. */\n        private String pvKey;"}
{"magic_number_smell": "    // @SuppressFBWarnings(\"SE_INNER_CLASS\")\n    protected class TextAdjustingInfo extends InlineAdjustingInfo {\n\n        private static final long -1246306443569094371L = -2412095162983479947L;\n\n        /** difference between the optimal width of a space\n         * and the default width of a space according to the font", "refactored_code": "    private static final long serialVersionUID = -1246306443569094371L;\n    // @SuppressFBWarnings(\"SE_INNER_CLASS\")\n    protected class TextAdjustingInfo extends InlineAdjustingInfo {\n\n        private static final long serialVersionUID = -2412095162983479947L;\n\n        /** difference between the optimal width of a space\n         * and the default width of a space according to the font"}
{"magic_number_smell": "    // @SuppressFBWarnings(\"SE_INNER_CLASS\")\n    protected class InlineAdjustingInfo implements Serializable {\n\n        private static final long -8940066479810170980L = -5601387735459712149L;\n\n        /** stretch of the inline area */\n        protected int availableStretch;", "refactored_code": "    private static final long serialVersionUID = -8940066479810170980L;\n    // @SuppressFBWarnings(\"SE_INNER_CLASS\")\n    protected class InlineAdjustingInfo implements Serializable {\n\n        private static final long serialVersionUID = -5601387735459712149L;\n\n        /** stretch of the inline area */\n        protected int availableStretch;"}
{"magic_number_smell": "        int t;\n        String s = name.toLowerCase();\n        if (\"glyphclass\".equals(s)) {\n            t = 1;\n        } else if (\"attachmentpoint\".equals(s)) {\n            t = GDEF_LOOKUP_TYPE_ATTACHMENT_POINT;\n        } else if (\"ligaturecaret\".equals(s)) {", "refactored_code": "    public static final int GDEF_LOOKUP_TYPE_GLYPH_CLASS = 1;\n        int t;\n        String s = name.toLowerCase();\n        if (\"glyphclass\".equals(s)) {\n            t = GDEF_LOOKUP_TYPE_GLYPH_CLASS;\n        } else if (\"attachmentpoint\".equals(s)) {\n            t = GDEF_LOOKUP_TYPE_ATTACHMENT_POINT;\n        } else if (\"ligaturecaret\".equals(s)) {"}
{"magic_number_smell": "        }\n        /** {@inheritDoc} */\n        public int getType() {\n            return 0;\n        }\n        /** {@inheritDoc} */\n        public List getEntries() {", "refactored_code": "    public static final int GLYPH_MAPPING_TYPE_EMPTY = 0;\n        }\n        /** {@inheritDoc} */\n        public int getType() {\n            return GLYPH_MAPPING_TYPE_EMPTY;\n        }\n        /** {@inheritDoc} */\n        public List getEntries() {"}
{"magic_number_smell": "        int t;\n        String s = name.toLowerCase();\n        if (\"single\".equals(s)) {\n            t = 1;\n        } else if (\"pair\".equals(s)) {\n            t = GPOS_LOOKUP_TYPE_PAIR;\n        } else if (\"cursive\".equals(s)) {", "refactored_code": "    public static final int GPOS_LOOKUP_TYPE_SINGLE = 1;\n        int t;\n        String s = name.toLowerCase();\n        if (\"single\".equals(s)) {\n            t = GPOS_LOOKUP_TYPE_SINGLE;\n        } else if (\"pair\".equals(s)) {\n            t = GPOS_LOOKUP_TYPE_PAIR;\n        } else if (\"cursive\".equals(s)) {"}
{"magic_number_smell": "        int t;\n        String s = name.toLowerCase();\n        if (\"single\".equals(s)) {\n            t = 1;\n        } else if (\"multiple\".equals(s)) {\n            t = GSUB_LOOKUP_TYPE_MULTIPLE;\n        } else if (\"alternate\".equals(s)) {", "refactored_code": "    public static final int GSUB_LOOKUP_TYPE_SINGLE = 1;\n        int t;\n        String s = name.toLowerCase();\n        if (\"single\".equals(s)) {\n            t = GSUB_LOOKUP_TYPE_SINGLE;\n        } else if (\"multiple\".equals(s)) {\n            t = GSUB_LOOKUP_TYPE_MULTIPLE;\n        } else if (\"alternate\".equals(s)) {"}
{"magic_number_smell": "        int t;\n        String s = name.toLowerCase();\n        if (\"gsub\".equals(s)) {\n            t = 1;\n        } else if (\"gpos\".equals(s)) {\n            t = GLYPH_TABLE_TYPE_POSITIONING;\n        } else if (\"jstf\".equals(s)) {", "refactored_code": "    public static final int GLYPH_TABLE_TYPE_SUBSTITUTION = 1;\n        int t;\n        String s = name.toLowerCase();\n        if (\"gsub\".equals(s)) {\n            t = GLYPH_TABLE_TYPE_SUBSTITUTION;\n        } else if (\"gpos\".equals(s)) {\n            t = GLYPH_TABLE_TYPE_POSITIONING;\n        } else if (\"jstf\".equals(s)) {"}
{"magic_number_smell": "            C1, C1, C1, C1, C3, C2, C1, C1, C1, C3, C3, C1, C3, C1, C1, C1, C1, C1, C1, C1, C1,\n            C1, C1, C1, C1, C1, C1, C1, C1, C1, C1, DR, DR, DR, DA, DA, DA, DA, DB, DB, DB, VA,\n            VR, VR, DL, DL, DL, VR, VR, SA, SP, SP, CS, CS, SA, RB, SA, SA, SA, SA, SA, CO, SA,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, SA, 0, 0\n    };\n    private short[][] khmerStateTable = new short[][] {\n            {", "refactored_code": "    private static final int XX = 0;\n            C1, C1, C1, C1, C3, C2, C1, C1, C1, C3, C3, C1, C3, C1, C1, C1, C1, C1, C1, C1, C1,\n            C1, C1, C1, C1, C1, C1, C1, C1, C1, C1, DR, DR, DR, DA, DA, DA, DA, DB, DB, DB, VA,\n            VR, VR, DL, DL, DL, VR, VR, SA, SP, SP, CS, CS, SA, RB, SA, SA, SA, SA, SA, CO, SA,\n            XX, XX, XX, XX, XX, XX, XX, XX, XX, SA, XX, XX\n    };\n    private short[][] khmerStateTable = new short[][] {\n            {"}
{"magic_number_smell": "    }\n\n    public static int maximumDecompositionLength() {\n        return 3;\n    }\n\n    public static int[] decompose(int c, int[] da) {", "refactored_code": "    private static final int MAX_DECOMPOSITION_LENGTH = 3;\n    }\n\n    public static int maximumDecompositionLength() {\n        return MAX_DECOMPOSITION_LENGTH;\n    }\n\n    public static int[] decompose(int c, int[] da) {"}
{"magic_number_smell": "        } else if (isArabic(c)) {\n            return SCRIPT_ARABIC;\n        } else if (isHebrew(c)) {\n            return 125;\n        } else if (isMongolian(c)) {\n            return SCRIPT_MONGOLIAN;\n        } else if (isGeorgian(c)) {", "refactored_code": "    public static final int SCRIPT_HEBREW                               = 125;  // 'hebr'\n        } else if (isArabic(c)) {\n            return SCRIPT_ARABIC;\n        } else if (isHebrew(c)) {\n            return SCRIPT_HEBREW;\n        } else if (isMongolian(c)) {\n            return SCRIPT_MONGOLIAN;\n        } else if (isGeorgian(c)) {"}
{"magic_number_smell": "     */\n    public GlyphSequence(IntBuffer characters, IntBuffer glyphs, List associations, boolean predications) {\n        if (characters == null) {\n            characters = IntBuffer.allocate(8);\n        }\n        if (glyphs == null) {\n            glyphs = IntBuffer.allocate(characters.capacity());", "refactored_code": "    private static final int DEFAULT_CHARS_CAPACITY = 8;\n     */\n    public GlyphSequence(IntBuffer characters, IntBuffer glyphs, List associations, boolean predications) {\n        if (characters == null) {\n            characters = IntBuffer.allocate(DEFAULT_CHARS_CAPACITY);\n        }\n        if (glyphs == null) {\n            glyphs = IntBuffer.allocate(characters.capacity());"}
{"magic_number_smell": "    private class GematriaNumeralsFormatter implements SpecialNumberFormatter {\n        public Integer[] format(long number, int one, int letterValue, String features, String language, String country) {\n            if (one == 0x05D0) {\n                if (letterValue == 1) {\n                    return formatNumberAsSequence(number, one, hebrewGematriaAlphabeticMap.length, hebrewGematriaAlphabeticMap);\n                } else if (letterValue == LETTER_VALUE_TRADITIONAL) {\n                    if ((number == 0) || (number > 1999)) {", "refactored_code": "    public static final int LETTER_VALUE_ALPHABETIC = 1;\n    private class GematriaNumeralsFormatter implements SpecialNumberFormatter {\n        public Integer[] format(long number, int one, int letterValue, String features, String language, String country) {\n            if (one == 0x05D0) {\n                if (letterValue == LETTER_VALUE_ALPHABETIC) {\n                    return formatNumberAsSequence(number, one, hebrewGematriaAlphabeticMap.length, hebrewGematriaAlphabeticMap);\n                } else if (letterValue == LETTER_VALUE_TRADITIONAL) {\n                    if ((number == 0) || (number > 1999)) {"}
{"magic_number_smell": "        private FONode currentNode;\n        private final FObj parentNode;\n        private int currentIndex;\n        private int flags = 0;\n\n        FObjIterator(FObj parent) {\n            this.parentNode = parent;", "refactored_code": "        private static final int F_NONE_ALLOWED = 0;\n        private FONode currentNode;\n        private final FObj parentNode;\n        private int currentIndex;\n        private int flags = F_NONE_ALLOWED;\n\n        FObjIterator(FObj parent) {\n            this.parentNode = parent;"}
{"magic_number_smell": "        switch (isWordChar(prevChar)) {\n            case IS_WORD_CHAR_TRUE:\n                return false;\n            case 0:\n                return true;\n            /* \"MAYBE\" implies that additional context is needed. An example is a\n             * single-quote, either straight or closing, which might be interpreted", "refactored_code": "    private static final int IS_WORD_CHAR_FALSE = 0;\n        switch (isWordChar(prevChar)) {\n            case IS_WORD_CHAR_TRUE:\n                return false;\n            case IS_WORD_CHAR_FALSE:\n                return true;\n            /* \"MAYBE\" implies that additional context is needed. An example is a\n             * single-quote, either straight or closing, which might be interpreted"}
{"magic_number_smell": "\n    /**\n     * Constructor for a two argument operation.\n     * @param operation the operation opcode: 1, SUBTRACTION, ...\n     * @param op1 the first operand.\n     * @param op2 the second operand\n     */", "refactored_code": "    public static final int ADDITION = 1;\n\n    /**\n     * Constructor for a two argument operation.\n     * @param operation the operation opcode: ADDITION, SUBTRACTION, ...\n     * @param op1 the first operand.\n     * @param op2 the second operand\n     */"}
{"magic_number_smell": "    /**\n     * Returns a flag for this effective row. Only a subset of the flags on GridUnit is supported.\n     * The flag is determined by inspecting flags on the EffRow's GridUnits.\n     * @param which the requested flag (one of {@link EffRow#GridUnit.FIRST_IN_PART} or {@link\n     * EffRow#LAST_IN_PART})\n     * @return true if the flag is set\n     */", "refactored_code": "    public static final int FIRST_IN_PART = GridUnit.FIRST_IN_PART;\n    /**\n     * Returns a flag for this effective row. Only a subset of the flags on GridUnit is supported.\n     * The flag is determined by inspecting flags on the EffRow's GridUnits.\n     * @param which the requested flag (one of {@link EffRow#FIRST_IN_PART} or {@link\n     * EffRow#LAST_IN_PART})\n     * @return true if the flag is set\n     */"}
{"magic_number_smell": "     */\n    public int getMaximumRepeats() {\n        if (maximumRepeats.getEnum() == EN_NO_LIMIT) {\n            return -1;\n        } else {\n            int mr = maximumRepeats.getNumeric().getValue();\n            if (mr < 0) {", "refactored_code": "    private static final int INFINITE = -1;\n     */\n    public int getMaximumRepeats() {\n        if (maximumRepeats.getEnum() == EN_NO_LIMIT) {\n            return INFINITE;\n        } else {\n            int mr = maximumRepeats.getNumeric().getValue();\n            if (mr < 0) {"}
{"magic_number_smell": "                                        boolean isFirstPage,\n                                        boolean isLastPage,\n                                        boolean isEmptyPage, boolean skipPagePositionOnly) {\n        if (getMaximumRepeats() != -1 && numberConsumed >= getMaximumRepeats()) {\n           return null;\n        }\n        numberConsumed++;", "refactored_code": "    private static final int INFINITE = -1;\n                                        boolean isFirstPage,\n                                        boolean isLastPage,\n                                        boolean isEmptyPage, boolean skipPagePositionOnly) {\n        if (getMaximumRepeats() != INFINITE && numberConsumed >= getMaximumRepeats()) {\n           return null;\n        }\n        numberConsumed++;"}
{"magic_number_smell": "     */\n    public SinglePageMasterReference(FONode parent) {\n        super(parent);\n        this.state = 0;\n    }\n\n    /** {@inheritDoc} */", "refactored_code": "    private static final int FIRST = 0;\n     */\n    public SinglePageMasterReference(FONode parent) {\n        super(parent);\n        this.state = FIRST;\n    }\n\n    /** {@inheritDoc} */"}
{"magic_number_smell": "        backgroungImageTargetWidth = pList.get(Constants.PR_X_BACKGROUND_IMAGE_WIDTH).getLength();\n        backgroungImageTargetHeight = pList.get(Constants.PR_X_BACKGROUND_IMAGE_HEIGHT).getLength();\n\n        initBorderInfo(pList, 0,\n                Constants.PR_BORDER_BEFORE_COLOR,\n                Constants.PR_BORDER_BEFORE_STYLE,\n                Constants.PR_BORDER_BEFORE_WIDTH,", "refactored_code": "    public static final int BEFORE = 0;\n        backgroungImageTargetWidth = pList.get(Constants.PR_X_BACKGROUND_IMAGE_WIDTH).getLength();\n        backgroungImageTargetHeight = pList.get(Constants.PR_X_BACKGROUND_IMAGE_HEIGHT).getLength();\n\n        initBorderInfo(pList, BEFORE,\n                Constants.PR_BORDER_BEFORE_COLOR,\n                Constants.PR_BORDER_BEFORE_STYLE,\n                Constants.PR_BORDER_BEFORE_WIDTH,"}
{"magic_number_smell": "                    if (deco == null) {\n                        deco = new CommonTextDecoration();\n                    }\n                    deco.decoration |= 1;\n                    deco.underColor = pList.get(Constants.PR_COLOR).getColor(ua);\n                } else if (propEnum == Constants.EN_NO_UNDERLINE) {\n                    if (deco != null) {", "refactored_code": "    private static final int UNDERLINE    = 1;\n                    if (deco == null) {\n                        deco = new CommonTextDecoration();\n                    }\n                    deco.decoration |= UNDERLINE;\n                    deco.underColor = pList.get(Constants.PR_COLOR).getColor(ua);\n                } else if (propEnum == Constants.EN_NO_UNDERLINE) {\n                    if (deco != null) {"}
{"magic_number_smell": "     */\n    private int computeClosestAbsoluteFontSize(int baseFontSize) {\n        double scale = FONT_SIZE_GROWTH_FACTOR;\n        int lastStepFontSize = 12000;\n        if (baseFontSize < 12000) {\n            // Need to shrink the font sizes = scale downwards\n            scale = 1 / FONT_SIZE_GROWTH_FACTOR;", "refactored_code": "    private static final int FONT_SIZE_NORMAL = 12000;\n     */\n    private int computeClosestAbsoluteFontSize(int baseFontSize) {\n        double scale = FONT_SIZE_GROWTH_FACTOR;\n        int lastStepFontSize = FONT_SIZE_NORMAL;\n        if (baseFontSize < FONT_SIZE_NORMAL) {\n            // Need to shrink the font sizes = scale downwards\n            scale = 1 / FONT_SIZE_GROWTH_FACTOR;"}
{"magic_number_smell": "    protected void setMinimum(Property minimum, boolean bIsDefault) {\n        this.minimum = minimum;\n        if (!bIsDefault) {\n            bfSet |= 1;\n        }\n        consistent = false;\n    }", "refactored_code": "    private static final int MINSET = 1;\n    protected void setMinimum(Property minimum, boolean bIsDefault) {\n        this.minimum = minimum;\n        if (!bIsDefault) {\n            bfSet |= MINSET;\n        }\n        consistent = false;\n    }"}
{"magic_number_smell": "    }\n\n    public int getStrikeoutThickness(int size) {\n        return size * 50;\n    }\n\n}", "refactored_code": "    private static final int LINE_THICKNESS = 50;\n    }\n\n    public int getStrikeoutThickness(int size) {\n        return size * LINE_THICKNESS;\n    }\n\n}"}
{"magic_number_smell": "    }\n\n    public int getUnderlineThickness(int size) {\n        return size * ((underlineThickness == 0) ? 50 : underlineThickness);\n    }\n\n    public void setUnderlineThickness(int underlineThickness) {", "refactored_code": "    private static final int DEFAULT_LINE_THICKNESS = 50;\n    }\n\n    public int getUnderlineThickness(int size) {\n        return size * ((underlineThickness == 0) ? DEFAULT_LINE_THICKNESS : underlineThickness);\n    }\n\n    public void setUnderlineThickness(int underlineThickness) {"}
{"magic_number_smell": "    }\n\n    private static class CachedFontFile implements Serializable {\n        private static final long 9129238336422194339L = 4524237324330578883L;\n\n        /** file modify date (if available) */\n        private long lastModified = -1;", "refactored_code": "    private static final long serialVersionUID = 9129238336422194339L;\n    }\n\n    private static class CachedFontFile implements Serializable {\n        private static final long serialVersionUID = 4524237324330578883L;\n\n        /** file modify date (if available) */\n        private long lastModified = -1;"}
{"magic_number_smell": "\n    // since for most users the most likely glyphs are in the first cmap segments we store their mapping.\n    private static final int 256 = 256;\n    private int[] mostLikelyGlyphs = new int[256];\n\n    //A map to store each used glyph from the CID set against the glyph name.\n    private LinkedHashMap<Integer, String> usedGlyphNames = new LinkedHashMap<Integer, String>();", "refactored_code": "    private static final int NUM_MOST_LIKELY_GLYPHS = 256;\n\n    // since for most users the most likely glyphs are in the first cmap segments we store their mapping.\n    private static final int NUM_MOST_LIKELY_GLYPHS = 256;\n    private int[] mostLikelyGlyphs = new int[NUM_MOST_LIKELY_GLYPHS];\n\n    //A map to store each used glyph from the CID set against the glyph name.\n    private LinkedHashMap<Integer, String> usedGlyphNames = new LinkedHashMap<Integer, String>();"}
{"magic_number_smell": "        }\n        Element root = doc.createElement(\"font-metrics\");\n        doc.appendChild(root);\n        root.setAttribute(METRICS_VERSION_ATTR, String.valueOf(2));\n        if (isCid) {\n            root.setAttribute(\"type\", \"TYPE0\");\n        } else {", "refactored_code": "    public static final int METRICS_VERSION = 2;\n        }\n        Element root = doc.createElement(\"font-metrics\");\n        doc.appendChild(root);\n        root.setAttribute(METRICS_VERSION_ATTR, String.valueOf(METRICS_VERSION));\n        if (isCid) {\n            root.setAttribute(\"type\", \"TYPE0\");\n        } else {"}
{"magic_number_smell": "     * @param listener for throwing font related events\n     */\n    public FontFileFinder(FontEventListener listener) {\n        this(-1, listener);\n    }\n\n    /**", "refactored_code": "    public static final int DEFAULT_DEPTH_LIMIT = -1;\n     * @param listener for throwing font related events\n     */\n    public FontFileFinder(FontEventListener listener) {\n        this(DEFAULT_DEPTH_LIMIT, listener);\n    }\n\n    /**"}
{"magic_number_smell": "        for (int i = 0; i < dictData.length; i++) {\n            int readByte = dictData[i] & 0xFF;\n            if (readByte < 28) {\n                int[] operator = new int[(readByte == 12) ? 2 : 1];\n                if (readByte == 12) {\n                    operator[0] = dictData[i];\n                    operator[1] = dictData[i + 1];", "refactored_code": "    private static final int DOUBLE_BYTE_OPERATOR = 12;\n        for (int i = 0; i < dictData.length; i++) {\n            int readByte = dictData[i] & 0xFF;\n            if (readByte < 28) {\n                int[] operator = new int[(readByte == DOUBLE_BYTE_OPERATOR) ? 2 : 1];\n                if (readByte == DOUBLE_BYTE_OPERATOR) {\n                    operator[0] = dictData[i];\n                    operator[1] = dictData[i + 1];"}
{"magic_number_smell": "     * @return short Index of the first character\n     */\n    public short getFirstChar() {\n        return 0;\n    }\n\n    /**", "refactored_code": "    private static final short FIRST_CHAR = 0;\n     * @return short Index of the first character\n     */\n    public short getFirstChar() {\n        return FIRST_CHAR;\n    }\n\n    /**"}
{"magic_number_smell": "            FontDict fdFont = fdFonts.get(uniqueNewRef);\n            byte[] fdFontByteData = fdFont.getByteData();\n            Map<String, DICTEntry> fdFontDict = cffReader.parseDictData(fdFontByteData);\n            fontNameSIDs.add(stringIndexData.size() + 391);\n            stringIndexData.add(cffReader.getStringIndex().getValue(fdFontDict.get(\"FontName\")\n                    .getOperands().get(0).intValue() - 391));\n        }", "refactored_code": "    public static final int NUM_STANDARD_STRINGS = 391;\n            FontDict fdFont = fdFonts.get(uniqueNewRef);\n            byte[] fdFontByteData = fdFont.getByteData();\n            Map<String, DICTEntry> fdFontDict = cffReader.parseDictData(fdFontByteData);\n            fontNameSIDs.add(stringIndexData.size() + NUM_STANDARD_STRINGS);\n            stringIndexData.add(cffReader.getStringIndex().getValue(fdFontDict.get(\"FontName\")\n                    .getOperands().get(0).intValue() - NUM_STANDARD_STRINGS));\n        }"}
{"magic_number_smell": "\n        PARSE_MODE_CHANGES = new HashMap<String, Integer>();\n        PARSE_MODE_CHANGES.put(START_CHAR_METRICS, PARSE_CHAR_METRICS);\n        PARSE_MODE_CHANGES.put(END_CHAR_METRICS, 0);\n    }\n\n    /**", "refactored_code": "    private static final int PARSE_NORMAL = 0;\n\n        PARSE_MODE_CHANGES = new HashMap<String, Integer>();\n        PARSE_MODE_CHANGES.put(START_CHAR_METRICS, PARSE_CHAR_METRICS);\n        PARSE_MODE_CHANGES.put(END_CHAR_METRICS, PARSE_NORMAL);\n    }\n\n    /**"}
{"magic_number_smell": "     */\n    public void setPFBFormat(int format) {\n        switch (format) {\n            case 0:\n            case PFB_PC:\n                this.pfbFormat = format;\n                break;", "refactored_code": "    public static final int PFB_RAW = 0;\n     */\n    public void setPFBFormat(int format) {\n        switch (format) {\n            case PFB_RAW:\n            case PFB_PC:\n                this.pfbFormat = format;\n                break;"}
{"magic_number_smell": "                    }\n                } else if (cur == 12) {\n                    int next = data[++i] & 0xFF;\n                    if (next == 6) {\n                        /* This charString references two other glyphs which must also be included\n                         * for this character to be displayed properly. */\n                        int first = operands.get(operands.size() - 2).getNumber();", "refactored_code": "    private static final int OP_SEAC = 6;\n                    }\n                } else if (cur == 12) {\n                    int next = data[++i] & 0xFF;\n                    if (next == OP_SEAC) {\n                        /* This charString references two other glyphs which must also be included\n                         * for this character to be displayed properly. */\n                        int first = operands.get(operands.size() - 2).getNumber();"}
{"magic_number_smell": "            if (maxAdjustment > 0) {\n                return (double) difference / maxAdjustment;\n            } else {\n                return 1000;\n            }\n        } else if (difference < 0) {\n            int maxAdjustment = totalShrink - activeNode.totalShrink;", "refactored_code": "    protected static final int INFINITE_RATIO = 1000;\n            if (maxAdjustment > 0) {\n                return (double) difference / maxAdjustment;\n            } else {\n                return INFINITE_RATIO;\n            }\n        } else if (difference < 0) {\n            int maxAdjustment = totalShrink - activeNode.totalShrink;"}
{"magic_number_smell": "    private static final int STRENGTH_ALWAYS = Integer.MAX_VALUE;\n\n    /** keep auto */\n    public static final Keep KEEP_AUTO = new Keep(Integer.MIN_VALUE, Constants.EN_AUTO);\n\n    /** keep always */\n    public static final Keep KEEP_ALWAYS = new Keep(STRENGTH_ALWAYS, Constants.EN_LINE);", "refactored_code": "    private static final int STRENGTH_AUTO = Integer.MIN_VALUE;\n    private static final int STRENGTH_ALWAYS = Integer.MAX_VALUE;\n\n    /** keep auto */\n    public static final Keep KEEP_AUTO = new Keep(STRENGTH_AUTO, Constants.EN_AUTO);\n\n    /** keep always */\n    public static final Keep KEEP_ALWAYS = new Keep(STRENGTH_ALWAYS, Constants.EN_LINE);"}
{"magic_number_smell": "\n    /** @return true if new area is set */\n    public boolean isStart() {\n        return ((this.flags & 0x01) != 0);\n    }\n\n    /** @return true if new area is set and leading space is non-null */", "refactored_code": "    public static final int NEW_AREA = 0x01;\n\n    /** @return true if new area is set */\n    public boolean isStart() {\n        return ((this.flags & NEW_AREA) != 0);\n    }\n\n    /** @return true if new area is set and leading space is non-null */"}
{"magic_number_smell": "                if (footnoteElementIndex\n                        < getFootnoteList(footnoteListIndex).size() - 1) {\n                    // add demerits for the footnote split between pages\n                    demerits += 5000;\n                }\n            } else {\n                //TODO Why can this happen in the first place? Does anybody know? See #44160", "refactored_code": "    private final int splitFootnoteDemerits = 5000;\n                if (footnoteElementIndex\n                        < getFootnoteList(footnoteListIndex).size() - 1) {\n                    // add demerits for the footnote split between pages\n                    demerits += splitFootnoteDemerits;\n                }\n            } else {\n                //TODO Why can this happen in the first place? Does anybody know? See #44160"}
{"magic_number_smell": "     * @return the requested Page\n     */\n    public Page getPage(boolean isBlank, int index, int relativeTo) {\n        if (relativeTo == 0) {\n            return getPage(isBlank, index);\n        } else if (relativeTo == RELTO_CURRENT_ELEMENT_LIST) {\n            int effIndex = startPageOfCurrentElementList + index;", "refactored_code": "    public static final int RELTO_PAGE_SEQUENCE = 0;\n     * @return the requested Page\n     */\n    public Page getPage(boolean isBlank, int index, int relativeTo) {\n        if (relativeTo == RELTO_PAGE_SEQUENCE) {\n            return getPage(isBlank, index);\n        } else if (relativeTo == RELTO_CURRENT_ELEMENT_LIST) {\n            int effIndex = startPageOfCurrentElementList + index;"}
{"magic_number_smell": "\n            // add auxiliary elements at the beginning of the paragraph\n            if (textAlignment == EN_CENTER && textAlignmentLast != EN_JUSTIFY) {\n                this.add(new KnuthGlue(0, 3 * 3336, 0,\n                                       null, false));\n                ignoreAtStart++;\n            }", "refactored_code": "    public static final int DEFAULT_SPACE_WIDTH = 3336;\n\n            // add auxiliary elements at the beginning of the paragraph\n            if (textAlignment == EN_CENTER && textAlignmentLast != EN_JUSTIFY) {\n                this.add(new KnuthGlue(0, 3 * DEFAULT_SPACE_WIDTH, 0,\n                                       null, false));\n                ignoreAtStart++;\n            }"}
{"magic_number_smell": "                offset = altitude;\n                break;\n            case Constants.EN_HANGING:\n                offset = Math.round(altitude * 0.8f);\n                break;\n            case Constants.EN_CENTRAL:\n                offset = (altitude - depth) / 2 + depth;", "refactored_code": "    private static final float HANGING_BASELINE_FACTOR = 0.8f;\n                offset = altitude;\n                break;\n            case Constants.EN_HANGING:\n                offset = Math.round(altitude * HANGING_BASELINE_FACTOR);\n                break;\n            case Constants.EN_CENTRAL:\n                offset = (altitude - depth) / 2 + depth;"}
{"magic_number_smell": "            baseList.add(new KnuthGlue(lineEndBAP, 3 * LineLayoutManager.DEFAULT_SPACE_WIDTH, 0,\n                    auxiliaryPosition, true));\n            baseList.add(new KnuthPenalty(hyphIPD, unflagged\n                    ? TextLayoutManager.1\n                            : KnuthPenalty.FLAGGED_PENALTY, !unflagged, auxiliaryPosition, false));\n            baseList.add(new KnuthGlue(-(lineEndBAP + lineStartBAP),\n                    -6 * LineLayoutManager.DEFAULT_SPACE_WIDTH, 0,", "refactored_code": "    private static final int SOFT_HYPHEN_PENALTY = 1;\n            baseList.add(new KnuthGlue(lineEndBAP, 3 * LineLayoutManager.DEFAULT_SPACE_WIDTH, 0,\n                    auxiliaryPosition, true));\n            baseList.add(new KnuthPenalty(hyphIPD, unflagged\n                    ? TextLayoutManager.SOFT_HYPHEN_PENALTY\n                            : KnuthPenalty.FLAGGED_PENALTY, !unflagged, auxiliaryPosition, false));\n            baseList.add(new KnuthGlue(-(lineEndBAP + lineStartBAP),\n                    -6 * LineLayoutManager.DEFAULT_SPACE_WIDTH, 0,"}
{"magic_number_smell": "     */\n    public/*TODO*/ static int getOtherSide(int side) {\n        switch (side) {\n            case CommonBorderPaddingBackground.CommonBorderPaddingBackground.BEFORE:\n                return CommonBorderPaddingBackground.AFTER;\n            case CommonBorderPaddingBackground.AFTER:\n                return CommonBorderPaddingBackground.CommonBorderPaddingBackground.BEFORE;", "refactored_code": "    protected static final int BEFORE = CommonBorderPaddingBackground.BEFORE;\n     */\n    public/*TODO*/ static int getOtherSide(int side) {\n        switch (side) {\n            case CommonBorderPaddingBackground.BEFORE:\n                return CommonBorderPaddingBackground.AFTER;\n            case CommonBorderPaddingBackground.AFTER:\n                return CommonBorderPaddingBackground.BEFORE;"}
{"magic_number_smell": "    }\n\n    static class SortBlocksByYOffset implements Comparator<Object>, Serializable {\n        private static final long 5368454957520223766L = -1166133555737149237L;\n        public int compare(Object o1, Object o2) {\n            Block b1 = (Block) o1;\n            Block b2 = (Block) o2;", "refactored_code": "         private static final long serialVersionUID = 5368454957520223766L;\n    }\n\n    static class SortBlocksByYOffset implements Comparator<Object>, Serializable {\n        private static final long serialVersionUID = -1166133555737149237L;\n        public int compare(Object o1, Object o2) {\n            Block b1 = (Block) o1;\n            Block b2 = (Block) o2;"}
{"magic_number_smell": "        sb.append(getIndex());\n        sb.append(\"[\");\n        sb.append(row.getIndex()).append(\"/\");\n        sb.append(getFlag(1) ? \"F\" : \"-\");\n        sb.append(getFlag(LAST_IN_ROWGROUP) ? \"L\" : \"-\").append(\"]\");\n        sb.append(\"(\");\n        sb.append(cellParts);", "refactored_code": "    public static final int FIRST_IN_ROWGROUP = 1;\n        sb.append(getIndex());\n        sb.append(\"[\");\n        sb.append(row.getIndex()).append(\"/\");\n        sb.append(getFlag(FIRST_IN_ROWGROUP) ? \"F\" : \"-\");\n        sb.append(getFlag(LAST_IN_ROWGROUP) ? \"L\" : \"-\").append(\"]\");\n        sb.append(\"(\");\n        sb.append(cellParts);"}
{"magic_number_smell": "    /** Selects the table-footer elements for iteration. */\n    public static final int FOOTER = 2;\n\n    /** Part of the table over which to iterate. One of 0, HEADER or FOOTER. */\n    private int tablePart;\n\n    private Iterator rowGroupsIter;", "refactored_code": "    public static final int BODY = 0;\n    /** Selects the table-footer elements for iteration. */\n    public static final int FOOTER = 2;\n\n    /** Part of the table over which to iterate. One of BODY, HEADER or FOOTER. */\n    private int tablePart;\n\n    private Iterator rowGroupsIter;"}
{"magic_number_smell": "    public static final int PREDICTION_PNG_OPT = 15;\n\n\n    private int predictor = 1;\n    private int colors;\n    private int bitsPerComponent;\n    private int columns;", "refactored_code": "    public static final int PREDICTION_NONE = 1;\n    public static final int PREDICTION_PNG_OPT = 15;\n\n\n    private int predictor = PREDICTION_NONE;\n    private int colors;\n    private int bitsPerComponent;\n    private int columns;"}
{"magic_number_smell": "    }\n\n    void add(CompressedObject compressedObject) {\n        if (numObjectsInStream++ == 100) {\n            createObjectStream();\n            numObjectsInStream = 1;\n        }", "refactored_code": "    private static final int OBJECT_STREAM_CAPACITY = 100;\n    }\n\n    void add(CompressedObject compressedObject) {\n        if (numObjectsInStream++ == OBJECT_STREAM_CAPACITY) {\n            createObjectStream();\n            numObjectsInStream = 1;\n        }"}
{"magic_number_smell": "    /**\n     * font's writing direction\n     */\n    protected byte wMode = 0; // @SuppressFBWarnings(\"URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD\")\n\n    /**\n     * base CMap (String or PDFStream)", "refactored_code": "    public static final byte WMODE_HORIZONTAL = 0;\n    /**\n     * font's writing direction\n     */\n    protected byte wMode = WMODE_HORIZONTAL; // @SuppressFBWarnings(\"URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD\")\n\n    /**\n     * base CMap (String or PDFStream)"}
{"magic_number_smell": "    /**\n     * Current color space value.\n     */\n    protected int currentColorSpace = -1;\n\n    /**\n     * Create a PDF colorspace object.", "refactored_code": "    public static final int DEVICE_UNKNOWN = -1;\n    /**\n     * Current color space value.\n     */\n    protected int currentColorSpace = DEVICE_UNKNOWN;\n\n    /**\n     * Create a PDF colorspace object."}
{"magic_number_smell": "        String currentZeroPaddingPrefix = \"\";\n        if (MATCH_DECIMAL.matcher(pageLabel).matches()) {\n            // since an integer is the most common case we start with that\n            currentPageLabelType = 1;\n            currentPageNumber = Integer.parseInt(pageLabel);\n            int zeroPadding = 0;\n            if (pageLabel.charAt(zeroPadding) == '0') {", "refactored_code": "    private static final int DECIMAL = 1; // '0*1'\n        String currentZeroPaddingPrefix = \"\";\n        if (MATCH_DECIMAL.matcher(pageLabel).matches()) {\n            // since an integer is the most common case we start with that\n            currentPageLabelType = DECIMAL;\n            currentPageNumber = Integer.parseInt(pageLabel);\n            int zeroPadding = 0;\n            if (pageLabel.charAt(zeroPadding) == '0') {"}
{"magic_number_smell": "    // @SuppressFBWarnings(\"SE_INNER_CLASS\")\n    private class PDFData extends org.apache.fop.util.AbstractPaintingState.AbstractData {\n\n        private static final long 5384726143906371279L = 3527950647293177764L;\n\n        private Paint paint;\n        private Paint backPaint;", "refactored_code": "    private static final long serialVersionUID = 5384726143906371279L;\n    // @SuppressFBWarnings(\"SE_INNER_CLASS\")\n    private class PDFData extends org.apache.fop.util.AbstractPaintingState.AbstractData {\n\n        private static final long serialVersionUID = 3527950647293177764L;\n\n        private Paint paint;\n        private Paint backPaint;"}
{"magic_number_smell": "\n    @Override\n    public void addToNums(int num, Object object) {\n        int arrayIndex = num / 50;\n        setNumOfKidsArrays(arrayIndex + 1);\n        insertItemToNumsArray(arrayIndex, num, object);\n    }", "refactored_code": "    private static final int MAX_NUMS_ARRAY_SIZE = 50;\n\n    @Override\n    public void addToNums(int num, Object object) {\n        int arrayIndex = num / MAX_NUMS_ARRAY_SIZE;\n        setNumOfKidsArrays(arrayIndex + 1);\n        insertItemToNumsArray(arrayIndex, num, object);\n    }"}
{"magic_number_smell": "            }\n            throw new IllegalStateException(\"Unknown /PageMode encountered: \" + mode);\n        } else {\n            return 0;\n        }\n    }\n", "refactored_code": "    public static final int PAGEMODE_USENONE = 0;\n            }\n            throw new IllegalStateException(\"Unknown /PageMode encountered: \" + mode);\n        } else {\n            return PAGEMODE_USENONE;\n        }\n    }\n"}
{"magic_number_smell": "\n    class Contents extends PDFObject {\n        protected String toPDFString() {\n            return PDFText.toHex(new byte[18944 / 2]);\n        }\n\n        public int output(OutputStream stream) throws IOException {", "refactored_code": "    private static final int SIZE_OF_CONTENTS = 18944;\n\n    class Contents extends PDFObject {\n        protected String toPDFString() {\n            return PDFText.toHex(new byte[SIZE_OF_CONTENTS / 2]);\n        }\n\n        public int output(OutputStream stream) throws IOException {"}
{"magic_number_smell": "     */\n    public static class Placeholder extends PDFStructElem {\n\n        private static final long -3055241807589202532L = -2397980642558372068L;\n\n        @Override\n        public void outputInline(OutputStream out, StringBuilder textBuffer) throws IOException {", "refactored_code": "    private static final long serialVersionUID = -3055241807589202532L;\n     */\n    public static class Placeholder extends PDFStructElem {\n\n        private static final long serialVersionUID = -2397980642558372068L;\n\n        @Override\n        public void outputInline(OutputStream out, StringBuilder textBuffer) throws IOException {"}
{"magic_number_smell": "    private void writeAffineTransform(AffineTransform at, StringBuffer sb) {\n        double[] lt = new double[6];\n        at.getMatrix(lt);\n        PDFNumber.doubleOut(lt[0], 8, sb);\n        sb.append(' ');\n        PDFNumber.doubleOut(lt[1], 8, sb);\n        sb.append(' ');", "refactored_code": "    private static final int DEC = 8;\n    private void writeAffineTransform(AffineTransform at, StringBuffer sb) {\n        double[] lt = new double[6];\n        at.getMatrix(lt);\n        PDFNumber.doubleOut(lt[0], DEC, sb);\n        sb.append(' ');\n        PDFNumber.doubleOut(lt[1], DEC, sb);\n        sb.append(' ');"}
{"magic_number_smell": "        float width = borderRect.width;\n        float height = borderRect.height;\n        float[] borderWidth = new float[] {\n            (border[0] ? bpsTop.width / 1000f : 0.0f),\n            (border[RIGHT] ? bpsRight.width / 1000f : 0.0f),\n            (border[BOTTOM] ? bpsBottom.width / 1000f : 0.0f),\n            (border[LEFT] ? bpsLeft.width / 1000f : 0.0f)};", "refactored_code": "    private static final int TOP = 0;\n        float width = borderRect.width;\n        float height = borderRect.height;\n        float[] borderWidth = new float[] {\n            (border[TOP] ? bpsTop.width / 1000f : 0.0f),\n            (border[RIGHT] ? bpsRight.width / 1000f : 0.0f),\n            (border[BOTTOM] ? bpsBottom.width / 1000f : 0.0f),\n            (border[LEFT] ? bpsLeft.width / 1000f : 0.0f)};"}
{"magic_number_smell": "        int height = (int) Math.ceil(unitConv.mpt2units(targetRect.height));\n\n        int resolution = paintingState.getResolution();\n        AFPObjectAreaInfo objectAreaInfo = new AFPObjectAreaInfo(coords[0], coords[Y], width,\n                height, resolution, paintingState.getRotation());\n        return objectAreaInfo;\n    }", "refactored_code": "    private static final int X = 0;\n        int height = (int) Math.ceil(unitConv.mpt2units(targetRect.height));\n\n        int resolution = paintingState.getResolution();\n        AFPObjectAreaInfo objectAreaInfo = new AFPObjectAreaInfo(coords[X], coords[Y], width,\n                height, resolution, paintingState.getRotation());\n        return objectAreaInfo;\n    }"}
{"magic_number_smell": "            int height = Math.round(unitConv.mpt2units(rect.height));\n\n            getDataStream().createIncludePageSegment(pageSegment.getName(),\n                    coords[0], coords[Y], width, height);\n\n            //Do we need to embed an external page segment?\n            if (pageSegment.getURI() != null) {", "refactored_code": "    private static final int X = 0;\n            int height = Math.round(unitConv.mpt2units(rect.height));\n\n            getDataStream().createIncludePageSegment(pageSegment.getName(),\n                    coords[X], coords[Y], width, height);\n\n            //Do we need to embed an external page segment?\n            if (pageSegment.getURI() != null) {"}
{"magic_number_smell": "    /** The number of pages concurrently displayed on screen. */\n    private int pageRange = 1;\n\n    /** The display mode. One of 1, CONTINUOUS or CONT_FACING. */\n    private int displayMode = 1;\n\n    /** The component(s) that hold the rendered page(s) */", "refactored_code": "    public static final int SINGLE = 1;\n    /** The number of pages concurrently displayed on screen. */\n    private int pageRange = 1;\n\n    /** The display mode. One of SINGLE, CONTINUOUS or CONT_FACING. */\n    private int displayMode = SINGLE;\n\n    /** The component(s) that hold the rendered page(s) */"}
{"magic_number_smell": "        boolean[] b = new boolean[] {\n                (bpsTop != null), (bpsRight != null),\n                (bpsBottom != null), (bpsLeft != null)};\n        if (!b[0] && !b[RIGHT] && !b[BOTTOM] && !b[LEFT]) {\n            return;\n        }\n        int[] bw = new int[] {", "refactored_code": "    protected static final int TOP = 0;\n        boolean[] b = new boolean[] {\n                (bpsTop != null), (bpsRight != null),\n                (bpsBottom != null), (bpsLeft != null)};\n        if (!b[TOP] && !b[RIGHT] && !b[BOTTOM] && !b[LEFT]) {\n            return;\n        }\n        int[] bw = new int[] {"}
{"magic_number_smell": "\n    private class TextUtil {\n        private static final int 16 = 16;\n        private int[][] dp = new int[16][];\n        private final StringBuffer text = new StringBuffer();\n        private int startx;\n        private int starty;", "refactored_code": "        private static final int INITIAL_BUFFER_SIZE = 16;\n\n    private class TextUtil {\n        private static final int INITIAL_BUFFER_SIZE = 16;\n        private int[][] dp = new int[INITIAL_BUFFER_SIZE][];\n        private final StringBuffer text = new StringBuffer();\n        private int startx;\n        private int starty;"}
{"magic_number_smell": "                throws FontFormatException, IOException {\n        int type = Font.TRUETYPE_FONT;\n        if (FontType.TYPE1.equals(typeface.getFontType())) {\n            type = 1; //Font.1; only available in Java 1.5\n        }\n        this.font = Font.createFont(type, inStream);\n        inStream.close();", "refactored_code": "    private static final int TYPE1_FONT = 1; //Defined in Java 1.5\n                throws FontFormatException, IOException {\n        int type = Font.TRUETYPE_FONT;\n        if (FontType.TYPE1.equals(typeface.getFontType())) {\n            type = TYPE1_FONT; //Font.TYPE1_FONT; only available in Java 1.5\n        }\n        this.font = Font.createFont(type, inStream);\n        inStream.close();"}
{"magic_number_smell": "     * This factor multiplies the calculated values to scale\n     * to FOP internal measurements\n     */\n    public static final int FONT_FACTOR = (1000 * 1000) / 1;\n\n    /**\n     * The width of all 256 character, if requested", "refactored_code": "    public static final int FONT_SIZE = 1;\n     * This factor multiplies the calculated values to scale\n     * to FOP internal measurements\n     */\n    public static final int FONT_FACTOR = (1000 * 1000) / FONT_SIZE;\n\n    /**\n     * The width of all 256 character, if requested"}
{"magic_number_smell": "            int[][] dp, String text, Font font, FontMetricsMapper metrics) {\n        int maxAscent = metrics.getMaxAscent(font.getFontSize()) / 1000;\n        int descent = metrics.getDescender(font.getFontSize()) / 1000; // is negative\n        int safetyMargin = (int) (0.05 * font.getFontSize());\n        Rectangle boundingRect = new Rectangle(x, y - maxAscent - safetyMargin, 0, maxAscent\n                - descent + 2 * safetyMargin);\n", "refactored_code": "    private static final double SAFETY_MARGIN_FACTOR = 0.05;\n            int[][] dp, String text, Font font, FontMetricsMapper metrics) {\n        int maxAscent = metrics.getMaxAscent(font.getFontSize()) / 1000;\n        int descent = metrics.getDescender(font.getFontSize()) / 1000; // is negative\n        int safetyMargin = (int) (SAFETY_MARGIN_FACTOR * font.getFontSize());\n        Rectangle boundingRect = new Rectangle(x, y - maxAscent - safetyMargin, 0, maxAscent\n                - descent + 2 * safetyMargin);\n"}
{"magic_number_smell": "        }\n        for (PCLSoftFont sftFont : fonts) {\n            if (sftFont.getTypeface().equals(font) && sftFont != last\n                    && (sftFont.getCharCount() + countNonMatches(sftFont, text)) < 255) {\n                return sftFont;\n            }\n        }", "refactored_code": "    private static final int SOFT_FONT_SIZE = 255;\n        }\n        for (PCLSoftFont sftFont : fonts) {\n            if (sftFont.getTypeface().equals(font) && sftFont != last\n                    && (sftFont.getCharCount() + countNonMatches(sftFont, text)) < SOFT_FONT_SIZE) {\n                return sftFont;\n            }\n        }"}
{"magic_number_smell": "        }\n        int c = icm.getMapSize();\n        int hival = c - 1;\n        if (hival > 255) {\n            throw new UnsupportedOperationException(\"hival must not go beyond \" + 255);\n        }\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();", "refactored_code": "    private static final int MAX_HIVAL = 255;\n        }\n        int c = icm.getMapSize();\n        int hival = c - 1;\n        if (hival > MAX_HIVAL) {\n            throw new UnsupportedOperationException(\"hival must not go beyond \" + MAX_HIVAL);\n        }\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();"}
{"magic_number_smell": "        gen.writeDSCComment(DSCConstants.HIRES_BBOX, DSCConstants.ATEND);\n        gen.writeDSCComment(DSCConstants.DOCUMENT_SUPPLIED_RESOURCES,\n                new Object[] {DSCConstants.ATEND});\n        writeExtensions(0);\n        gen.writeDSCComment(DSCConstants.END_COMMENTS);\n\n        //Defaults", "refactored_code": "    private static final int COMMENT_DOCUMENT_HEADER = 0;\n        gen.writeDSCComment(DSCConstants.HIRES_BBOX, DSCConstants.ATEND);\n        gen.writeDSCComment(DSCConstants.DOCUMENT_SUPPLIED_RESOURCES,\n                new Object[] {DSCConstants.ATEND});\n        writeExtensions(COMMENT_DOCUMENT_HEADER);\n        gen.writeDSCComment(DSCConstants.END_COMMENTS);\n\n        //Defaults"}
{"magic_number_smell": "     * @param byteArray byte[] a byte array\n     * @param offset the position in the byte array where the streaming must start\n     * @param length the number of bytes to stream. This MUST be less than\n     * 32764 - 1 since strings are suffixed by '00' (see Section 4.2 of\n     * Adobe Technical Note #5012, <em>The Type 42 Font Format Specification</em>.).\n     */\n    public void streamBytes(byte[] byteArray, int offset, int length) throws IOException {", "refactored_code": "    public static final int MAX_BUFFER_SIZE = 32764;\n     * @param byteArray byte[] a byte array\n     * @param offset the position in the byte array where the streaming must start\n     * @param length the number of bytes to stream. This MUST be less than\n     * MAX_BUFFER_SIZE - 1 since strings are suffixed by '00' (see Section 4.2 of\n     * Adobe Technical Note #5012, <em>The Type 42 Font Format Specification</em>.).\n     */\n    public void streamBytes(byte[] byteArray, int offset, int length) throws IOException {"}
{"magic_number_smell": "    public static final float 20f = 20f;\n\n    /** millimeters and centimeters to twips: , one point is 1/72 of an inch, one inch is 25.4 mm */\n    public static final float IN_TO_TWIPS = UnitConv.IN2PT * 20f;\n    public static final float MM_TO_TWIPS = IN_TO_TWIPS / UnitConv.IN2MM;\n    public static final float CM_TO_TWIPS = 10 * MM_TO_TWIPS;\n", "refactored_code": "    public static final float POINT_TO_TWIPS = 20f;\n    public static final float POINT_TO_TWIPS = 20f;\n\n    /** millimeters and centimeters to twips: , one point is 1/72 of an inch, one inch is 25.4 mm */\n    public static final float IN_TO_TWIPS = UnitConv.IN2PT * POINT_TO_TWIPS;\n    public static final float MM_TO_TWIPS = IN_TO_TWIPS / UnitConv.IN2MM;\n    public static final float CM_TO_TWIPS = 10 * MM_TO_TWIPS;\n"}
{"magic_number_smell": "        int now = bookmark.length();\n\n        this.bookmark = bookmark.substring(0,\n                now < 40 ? now : 40);\n        this.bookmark = this.bookmark.replace('.', REPLACE_CHARACTER);\n        this.bookmark = this.bookmark.replace(' ', REPLACE_CHARACTER);\n    }", "refactored_code": "    public static final int MAX_BOOKMARK_LENGTH = 40;\n        int now = bookmark.length();\n\n        this.bookmark = bookmark.substring(0,\n                now < MAX_BOOKMARK_LENGTH ? now : MAX_BOOKMARK_LENGTH);\n        this.bookmark = this.bookmark.replace('.', REPLACE_CHARACTER);\n        this.bookmark = this.bookmark.replace(' ', REPLACE_CHARACTER);\n    }"}
{"magic_number_smell": "            int identifier = (Integer) aColorTable;\n\n            header.newLine();\n            header.write(\"\\\\red\" + determineColorLevel(identifier, 16));\n            header.write(\"\\\\green\" + determineColorLevel(identifier, GREEN));\n            header.write(\"\\\\blue\" + determineColorLevel(identifier, BLUE) + \";\");\n        }", "refactored_code": "    private static final int RED = 16;\n            int identifier = (Integer) aColorTable;\n\n            header.newLine();\n            header.write(\"\\\\red\" + determineColorLevel(identifier, RED));\n            header.write(\"\\\\green\" + determineColorLevel(identifier, GREEN));\n            header.write(\"\\\\blue\" + determineColorLevel(identifier, BLUE) + \";\");\n        }"}
{"magic_number_smell": "    /** {@inheritDoc} */\n    protected void writeRtfContent() throws IOException {\n\n        int thickness = 30;\n        String tablead = null;\n        String tabwidth = null;\n        for (Iterator it = attrs.nameIterator(); it.hasNext();) {", "refactored_code": "    public static final int LEADER_STANDARD_WIDTH = 30;\n    /** {@inheritDoc} */\n    protected void writeRtfContent() throws IOException {\n\n        int thickness = LEADER_STANDARD_WIDTH;\n        String tablead = null;\n        String tabwidth = null;\n        for (Iterator it = attrs.nameIterator(); it.hasNext();) {"}
{"magic_number_smell": "    /** constant for close paragraph */\n    public static final int STATUS_CLOSE_PARAGRAPH = 2;\n\n    private int status = 0;\n\n\n    /**    RtfParagraphKeepTogether*/", "refactored_code": "    public static final int STATUS_NULL = 0;\n    /** constant for close paragraph */\n    public static final int STATUS_CLOSE_PARAGRAPH = 2;\n\n    private int status = STATUS_NULL;\n\n\n    /**    RtfParagraphKeepTogether*/"}
{"magic_number_smell": "     */\n    public int addStyleToAttributes(String name, RtfAttributes attr) {\n        // Sets status to ok\n        int status = 0;\n\n        // Gets the style number from table\n        Integer style  = (Integer) styles.get(name);", "refactored_code": "    public static final int STATUS_OK = 0;\n     */\n    public int addStyleToAttributes(String name, RtfAttributes attr) {\n        // Sets status to ok\n        int status = STATUS_OK;\n\n        // Gets the style number from table\n        Integer style  = (Integer) styles.get(name);"}
{"magic_number_smell": "     */\n    public boolean isNbsp() {\n        if (!isEmpty()) {\n            if (text.trim().length() == 1 && text.charAt(0) == 160) {\n                return true;\n            }\n        }", "refactored_code": "    private static final int CHAR_NBSP = 160;\n     */\n    public boolean isNbsp() {\n        if (!isEmpty()) {\n            if (text.trim().length() == 1 && text.charAt(0) == CHAR_NBSP) {\n                return true;\n            }\n        }"}
{"magic_number_smell": "\n    /**  Class which represents the closing of a RTF group mark.*/\n    private class RtfCloseGroupMark extends RtfElement {\n        private int breakType = 0;\n\n        RtfCloseGroupMark(RtfContainer parent, Writer w, int breakType)\n                  throws IOException {", "refactored_code": "    public static final int BREAK_NONE = 0;\n\n    /**  Class which represents the closing of a RTF group mark.*/\n    private class RtfCloseGroupMark extends RtfElement {\n        private int breakType = BREAK_NONE;\n\n        RtfCloseGroupMark(RtfContainer parent, Writer w, int breakType)\n                  throws IOException {"}
{"magic_number_smell": "     */\n    protected void renderText(TextArea area) {\n        int col = Helper.ceilPosition(this.currentIPPosition, CHAR_WIDTH);\n        int row = Helper.ceilPosition(this.currentBPPosition - 1070, CHAR_HEIGHT + 2 * 1070);\n\n        String s = area.getText();\n", "refactored_code": "    public static final int LINE_LEADING = 1070;\n     */\n    protected void renderText(TextArea area) {\n        int col = Helper.ceilPosition(this.currentIPPosition, CHAR_WIDTH);\n        int row = Helper.ceilPosition(this.currentBPPosition - LINE_LEADING, CHAR_HEIGHT + 2 * LINE_LEADING);\n\n        String s = area.getText();\n"}
{"magic_number_smell": "\n    /**\n     * I-th element of this array specify, if there line from center of symbol\n     * to corresponding side (0, RIGHT, DOWN, LEFT).\n     */\n    protected int[] data = {0, 0, 0, 0};\n", "refactored_code": "    public static final int UP = 0;\n\n    /**\n     * I-th element of this array specify, if there line from center of symbol\n     * to corresponding side (UP, RIGHT, DOWN, LEFT).\n     */\n    protected int[] data = {0, 0, 0, 0};\n"}
{"magic_number_smell": "    static {\n        Arrays.fill(map, UNDEFINED);\n        map[0] = ' ';\n        map[1] = DASH_VERTICAL;\n        map[DOWN2] = DASH_VERTICAL;\n        map[1 + DOWN2] = DASH_VERTICAL;\n", "refactored_code": "    private static final int UP2 = 1;\n    static {\n        Arrays.fill(map, UNDEFINED);\n        map[0] = ' ';\n        map[UP2] = DASH_VERTICAL;\n        map[DOWN2] = DASH_VERTICAL;\n        map[UP2 + DOWN2] = DASH_VERTICAL;\n"}
{"magic_number_smell": "    static {\n        Arrays.fill(MAP, UNDEFINED);\n        MAP[0] = ' ';\n        MAP[1] = LIGHT_VERTICAL;\n        MAP[DOWN3] = LIGHT_VERTICAL;\n        MAP[RIGHT3] = LIGHT_HORIZONTAL;\n        MAP[LEFT3] = LIGHT_HORIZONTAL;", "refactored_code": "    private static final int UP3 = 1;\n    static {\n        Arrays.fill(MAP, UNDEFINED);\n        MAP[0] = ' ';\n        MAP[UP3] = LIGHT_VERTICAL;\n        MAP[DOWN3] = LIGHT_VERTICAL;\n        MAP[RIGHT3] = LIGHT_HORIZONTAL;\n        MAP[LEFT3] = LIGHT_HORIZONTAL;"}
{"magic_number_smell": "            currentStream.write(\"\" + PDFNumber.doubleOut(scaleX) + \" 0 0 \"\n                                + PDFNumber.doubleOut(scaleY) + \" 0 0 cm\\n\");\n        }\n        if (deviceDPI != 72) {\n            double s = 72 / deviceDPI;\n            at.scale(s, s);\n            currentStream.write(\"\" + PDFNumber.doubleOut(s) + \" 0 0 \"", "refactored_code": "    public static final int NORMAL_PDF_RESOLUTION = 72;\n            currentStream.write(\"\" + PDFNumber.doubleOut(scaleX) + \" 0 0 \"\n                                + PDFNumber.doubleOut(scaleY) + \" 0 0 cm\\n\");\n        }\n        if (deviceDPI != NORMAL_PDF_RESOLUTION) {\n            double s = NORMAL_PDF_RESOLUTION / deviceDPI;\n            at.scale(s, s);\n            currentStream.write(\"\" + PDFNumber.doubleOut(s) + \" 0 0 \""}
{"magic_number_smell": "    }*/\n\n    private void concatMatrix(double[] matrix) {\n        currentStream.write(PDFNumber.doubleOut(matrix[0], 8) + \" \"\n                + PDFNumber.doubleOut(matrix[1], 8) + \" \"\n                + PDFNumber.doubleOut(matrix[2], 8) + \" \"\n                + PDFNumber.doubleOut(matrix[3], 8) + \" \"", "refactored_code": "    private static final int DEC = 8;\n    }*/\n\n    private void concatMatrix(double[] matrix) {\n        currentStream.write(PDFNumber.doubleOut(matrix[0], DEC) + \" \"\n                + PDFNumber.doubleOut(matrix[1], DEC) + \" \"\n                + PDFNumber.doubleOut(matrix[2], DEC) + \" \"\n                + PDFNumber.doubleOut(matrix[3], DEC) + \" \""}
{"magic_number_smell": "     *\n     * @param c the character to check\n     * @return the break action to be taken\n     *          one of: {@link #LineBreakUtils.DIRECT_BREAK},\n     *                  {@link #INDIRECT_BREAK},\n     *                  {@link #COMBINING_INDIRECT_BREAK},\n     *                  {@link #COMBINING_PROHIBITED_BREAK},", "refactored_code": "    public static final byte DIRECT_BREAK = LineBreakUtils.DIRECT_BREAK;\n     *\n     * @param c the character to check\n     * @return the break action to be taken\n     *          one of: {@link #DIRECT_BREAK},\n     *                  {@link #INDIRECT_BREAK},\n     *                  {@link #COMBINING_INDIRECT_BREAK},\n     *                  {@link #COMBINING_PROHIBITED_BREAK},"}
{"magic_number_smell": "    private File outputFile;\n    private String configMime = MimeConstants.MIME_PDF;\n    private String outputMime;\n    private int mode = 0;\n    private String singleFamilyFilter;\n\n    private FontListMain() throws SAXException, IOException {", "refactored_code": "    private static final int GENERATE_CONSOLE = 0;\n    private File outputFile;\n    private String configMime = MimeConstants.MIME_PDF;\n    private String outputMime;\n    private int mode = GENERATE_CONSOLE;\n    private String singleFamilyFilter;\n\n    private FontListMain() throws SAXException, IOException {"}
{"magic_number_smell": "    // @SuppressFBWarnings(\"SE_INNER_CLASS\")\n    public class StateStack<E> extends java.util.Stack<E> {\n\n        private static final long 5998356138437094188L = 4897178211223823041L;\n\n        /**\n         * Default constructor", "refactored_code": "    private static final long serialVersionUID = 5998356138437094188L;\n    // @SuppressFBWarnings(\"SE_INNER_CLASS\")\n    public class StateStack<E> extends java.util.Stack<E> {\n\n        private static final long serialVersionUID = 4897178211223823041L;\n\n        /**\n         * Default constructor"}
{"magic_number_smell": "            case TAB:\n                return XMLWHITESPACE;\n            default:\n                return isAnySpace(c) ? 0 : NONWHITESPACE;\n        }\n    }\n", "refactored_code": "    public static final int UCWHITESPACE = 0;\n            case TAB:\n                return XMLWHITESPACE;\n            default:\n                return isAnySpace(c) ? UCWHITESPACE : NONWHITESPACE;\n        }\n    }\n"}
{"magic_number_smell": "\n    /**\n     * Returns the Bayer dither base pattern for a particular matrix size.\n     * @param matrix the matrix size ({@link #2}, {@link #DITHER_MATRIX_4X4}\n     *                                   or {@link #DITHER_MATRIX_8X8})\n     * @return the base pattern for the given size\n     */", "refactored_code": "    public static final int DITHER_MATRIX_2X2 = 2;\n\n    /**\n     * Returns the Bayer dither base pattern for a particular matrix size.\n     * @param matrix the matrix size ({@link #DITHER_MATRIX_2X2}, {@link #DITHER_MATRIX_4X4}\n     *                                   or {@link #DITHER_MATRIX_8X8})\n     * @return the base pattern for the given size\n     */"}
{"magic_number_smell": "    @Test\n    public void testApplyStroke() {\n        // note: this only tests the setLineWidth in the GraphicsObject\n        float correctedLineWidth = 1.0f * correction;\n        when(stroke.getLineWidth()).thenReturn(1.0f);\n        when(paintingState.getLineWidthCorrection()).thenReturn(correction);\n        graphics2D.setGraphicsObject(gObject);", "refactored_code": "    private final float lineWidth = 1.0f;\n    @Test\n    public void testApplyStroke() {\n        // note: this only tests the setLineWidth in the GraphicsObject\n        float correctedLineWidth = lineWidth * correction;\n        when(stroke.getLineWidth()).thenReturn(lineWidth);\n        when(paintingState.getLineWidthCorrection()).thenReturn(correction);\n        graphics2D.setGraphicsObject(gObject);"}
{"magic_number_smell": "public class GraphicsSetFractionalLineWidthTestCase {\n\n    private final float 5.25f = 5.25f;\n    private final GraphicsSetFractionalLineWidth gsflw = new GraphicsSetFractionalLineWidth(5.25f);\n\n    @Test\n    public void testGetDataLength() {", "refactored_code": "    private final float multiplier = 5.25f;\npublic class GraphicsSetFractionalLineWidthTestCase {\n\n    private final float multiplier = 5.25f;\n    private final GraphicsSetFractionalLineWidth gsflw = new GraphicsSetFractionalLineWidth(multiplier);\n\n    @Test\n    public void testGetDataLength() {"}
{"magic_number_smell": "public class GraphicsSetLineWidthTestCase {\n\n    private final int 5 = 5;\n    private final GraphicsSetLineWidth gslw = new GraphicsSetLineWidth(5);\n\n    @Test\n    public void testGetDataLength() {", "refactored_code": "    private final int multiplier = 5;\npublic class GraphicsSetLineWidthTestCase {\n\n    private final int multiplier = 5;\n    private final GraphicsSetLineWidth gslw = new GraphicsSetLineWidth(multiplier);\n\n    @Test\n    public void testGetDataLength() {"}
{"magic_number_smell": "    @Test\n    public void testAddChildAreaMixedFromFootnote() {\n        InlineParent parent = new InlineParent();\n        InlineParent firstChild = createChildInlineParent(-12, BPD, false);\n        InlineParent secondChild = createChildInlineParent(3 * -12, 3 * BPD, false);\n        InlineParent thirdChild = createChildInlineParent(2 * -12, 2 * BPD, true);\n        InlineParent forthChild = createChildInlineParent(0, 0, true);", "refactored_code": "    private static final int BLOCK_PROG_OFFSET = -12;\n    @Test\n    public void testAddChildAreaMixedFromFootnote() {\n        InlineParent parent = new InlineParent();\n        InlineParent firstChild = createChildInlineParent(BLOCK_PROG_OFFSET, BPD, false);\n        InlineParent secondChild = createChildInlineParent(3 * BLOCK_PROG_OFFSET, 3 * BPD, false);\n        InlineParent thirdChild = createChildInlineParent(2 * BLOCK_PROG_OFFSET, 2 * BPD, true);\n        InlineParent forthChild = createChildInlineParent(0, 0, true);"}
{"magic_number_smell": "\n    public void checkStats() {\n        long now = System.currentTimeMillis();\n        if (now > lastProgressDump + 2000) {\n            dumpStats();\n            reset();\n        }", "refactored_code": "    private static final int INTERVAL = 2000;\n\n    public void checkStats() {\n        long now = System.currentTimeMillis();\n        if (now > lastProgressDump + INTERVAL) {\n            dumpStats();\n            reset();\n        }"}
{"magic_number_smell": "    private static final int 44 = 44;\n    private static final String TEST_TEXT = \"Test text\";\n    private PDFNumsArray numsArray;\n    private String expectedStringNumsArray = \"[0 1 0 R 1 \" + 44 + \"]\";\n    private String expectedStringText = \"((\" + TEST_TEXT + \"))\";\n\n    @Before", "refactored_code": "    private static final int TEST_NUMBER = 44;\n    private static final int TEST_NUMBER = 44;\n    private static final String TEST_TEXT = \"Test text\";\n    private PDFNumsArray numsArray;\n    private String expectedStringNumsArray = \"[0 1 0 R 1 \" + TEST_NUMBER + \"]\";\n    private String expectedStringText = \"((\" + TEST_TEXT + \"))\";\n\n    @Before"}
{"magic_number_smell": "    private PDFNumsArray numsArray;\n    private String expectedString = \"[0 1 0 R 1 2 0 R]\";\n    private String expectedStringName = \"/Test#20name\";\n    private String expectedStringNumber = Integer.valueOf(10).toString();\n\n    @Before\n    public void setUp() {", "refactored_code": "    private static final int TEST_NUMBER = 10;\n    private PDFNumsArray numsArray;\n    private String expectedString = \"[0 1 0 R 1 2 0 R]\";\n    private String expectedStringName = \"/Test#20name\";\n    private String expectedStringNumber = Integer.valueOf(TEST_NUMBER).toString();\n\n    @Before\n    public void setUp() {"}
{"magic_number_smell": "\n    private static final int 200 = 200;\n\n    private static final char[] S_UNICODE_CHAR_MAP = new char[200];\n\n    private EventBroadcaster eventBroadcaster;\n", "refactored_code": "    private static final int UNICODE_CHAR_MAP_SIZE = 200;\n\n    private static final int UNICODE_CHAR_MAP_SIZE = 200;\n\n    private static final char[] S_UNICODE_CHAR_MAP = new char[UNICODE_CHAR_MAP_SIZE];\n\n    private EventBroadcaster eventBroadcaster;\n"}
{"magic_number_smell": "    public static byte[] buildGRGBAData(int gray, int red, int green, int blue, int alpha) throws IOException {\n        // build an image, 32x32, Gray or RGB, with or without alpha, and with filter\n        int filter = 0;\n        int numRows = 32;\n        int numColumns = NUM_COLUMNS;\n        int numComponents = (gray > -1 ? 1 : 3) + (alpha > -1 ? 1 : 0);\n        int numBytesPerRow = numColumns * numComponents + 1; // 1 for filter", "refactored_code": "    private static final int NUM_ROWS = 32;\n    public static byte[] buildGRGBAData(int gray, int red, int green, int blue, int alpha) throws IOException {\n        // build an image, 32x32, Gray or RGB, with or without alpha, and with filter\n        int filter = 0;\n        int numRows = NUM_ROWS;\n        int numColumns = NUM_COLUMNS;\n        int numComponents = (gray > -1 ? 1 : 3) + (alpha > -1 ? 1 : 0);\n        int numBytesPerRow = numColumns * numComponents + 1; // 1 for filter"}
{"magic_number_smell": "        }\n\n        public BorderProps build() {\n            return new BorderProps(0, width, radiusStart, radiusEnd, color, mode);\n        }\n    }\n", "refactored_code": "        private final int style = 0;\n        }\n\n        public BorderProps build() {\n            return new BorderProps(style, width, radiusStart, radiusEnd, color, mode);\n        }\n    }\n"}
{"magic_number_smell": "\n    private FontMetrics mockFontMetrics() {\n        FontMetrics metrics = mock(FontMetrics.class);\n        when(metrics.getAscender(eq(10000))).thenReturn(8000000);\n        when(metrics.getDescender(eq(10000))).thenReturn(-4000000);\n        when(metrics.getWidth(eq(1), eq(10000))).thenReturn(10000000);\n        when(metrics.getBoundingBox(eq(1), eq(10000))).thenReturn(", "refactored_code": "    private final int fontSize = 10000;\n\n    private FontMetrics mockFontMetrics() {\n        FontMetrics metrics = mock(FontMetrics.class);\n        when(metrics.getAscender(eq(fontSize))).thenReturn(8000000);\n        when(metrics.getDescender(eq(fontSize))).thenReturn(-4000000);\n        when(metrics.getWidth(eq(1), eq(fontSize))).thenReturn(10000000);\n        when(metrics.getBoundingBox(eq(1), eq(fontSize))).thenReturn("}
{"magic_number_smell": "\n    private FontMetrics mockFontMetrics() {\n        FontMetrics metrics = mock(FontMetrics.class);\n        when(metrics.getWidth(eq(1), eq(37500))).thenReturn(25012000);\n        when(metrics.getWidth(eq(2), eq(37500))).thenReturn(22912000);\n        when(metrics.getWidth(eq(3), eq(37500))).thenReturn(20850000);\n        return metrics;", "refactored_code": "    private final int fontSize = 37500;\n\n    private FontMetrics mockFontMetrics() {\n        FontMetrics metrics = mock(FontMetrics.class);\n        when(metrics.getWidth(eq(1), eq(fontSize))).thenReturn(25012000);\n        when(metrics.getWidth(eq(2), eq(fontSize))).thenReturn(22912000);\n        when(metrics.getWidth(eq(3), eq(fontSize))).thenReturn(20850000);\n        return metrics;"}
{"magic_number_smell": "     */\n    public static class Parameter implements Serializable, XMLizable {\n\n        private static final long -7548882973341444354L = 6062500277953887099L;\n\n        private Class type;\n        private String name;", "refactored_code": "    private static final long serialVersionUID = -7548882973341444354L;\n     */\n    public static class Parameter implements Serializable, XMLizable {\n\n        private static final long serialVersionUID = 6062500277953887099L;\n\n        private Class type;\n        private String name;"}
{"magic_number_smell": "    private static final int 0 = 0;\n    private static final int MODE_TEXT = 1;\n\n    private int mode = 0;\n\n    public AbstractSVGDocumentHandler(IFContext context) {\n        super(context);", "refactored_code": "    private static final int MODE_NORMAL = 0;\n    private static final int MODE_NORMAL = 0;\n    private static final int MODE_TEXT = 1;\n\n    private int mode = MODE_NORMAL;\n\n    public AbstractSVGDocumentHandler(IFContext context) {\n        super(context);"}
{"magic_number_smell": "    private static final int 0 = 0;\n    private static final int MODE_TEXT = 1;\n\n    private int mode = 0;\n\n    /**\n     * Main constructor.", "refactored_code": "    private static final int MODE_NORMAL = 0;\n    private static final int MODE_NORMAL = 0;\n    private static final int MODE_TEXT = 1;\n\n    private int mode = MODE_NORMAL;\n\n    /**\n     * Main constructor."}
{"magic_number_smell": "     * @param type the type of animation (must be one of the\n     *             <code>ANIM_TYPE_*</code> constants defined in this class\n     * @param ns the namespace URI of the attribute being animated, if\n     *           <code>type == </code>{@link #0}\n     * @param an the attribute name if <code>type == </code>{@link\n     *           #0}, the property name if <code>type == </code>\n     *           {@link #ANIM_TYPE_CSS}, and the animation type otherwise", "refactored_code": "    public static final short ANIM_TYPE_XML   = 0;\n     * @param type the type of animation (must be one of the\n     *             <code>ANIM_TYPE_*</code> constants defined in this class\n     * @param ns the namespace URI of the attribute being animated, if\n     *           <code>type == </code>{@link #ANIM_TYPE_XML}\n     * @param an the attribute name if <code>type == </code>{@link\n     *           #ANIM_TYPE_XML}, the property name if <code>type == </code>\n     *           {@link #ANIM_TYPE_CSS}, and the animation type otherwise"}
{"magic_number_smell": "     */\n    protected void parseFill(String fill) {\n        if (fill.length() == 0 || fill.equals(SMIL_REMOVE_VALUE)) {\n            fillMode = 0;\n        } else if (fill.equals(SMIL_FREEZE_VALUE)) {\n            fillMode = FILL_FREEZE;\n        } else {", "refactored_code": "    public static final int FILL_REMOVE = 0;\n     */\n    protected void parseFill(String fill) {\n        if (fill.length() == 0 || fill.equals(SMIL_REMOVE_VALUE)) {\n            fillMode = FILL_REMOVE;\n        } else if (fill.equals(SMIL_FREEZE_VALUE)) {\n            fillMode = FILL_FREEZE;\n        } else {"}
{"magic_number_smell": "    public static AnimatablePaintValue createNonePaintValue\n            (AnimationTarget target) {\n        AnimatablePaintValue v = new AnimatablePaintValue(target);\n        v.paintType = 0;\n        return v;\n    }\n", "refactored_code": "    public static final int PAINT_NONE              = 0;\n    public static AnimatablePaintValue createNonePaintValue\n            (AnimationTarget target) {\n        AnimatablePaintValue v = new AnimatablePaintValue(target);\n        v.paintType = PAINT_NONE;\n        return v;\n    }\n"}
{"magic_number_smell": "        Object colorRend = hints.get(RenderingHints.KEY_COLOR_RENDERING);\n        Object rend      = hints.get(RenderingHints.KEY_RENDERING);\n\n        fillMethod = 1;\n\n        if ((cycleMethod == MultipleGradientPaint.REPEAT) ||\n            hasDiscontinuity) {", "refactored_code": "    private static final int DEFAULT_IMPL = 1;\n        Object colorRend = hints.get(RenderingHints.KEY_COLOR_RENDERING);\n        Object rend      = hints.get(RenderingHints.KEY_RENDERING);\n\n        fillMethod = DEFAULT_IMPL;\n\n        if ((cycleMethod == MultipleGradientPaint.REPEAT) ||\n            hasDiscontinuity) {"}
{"magic_number_smell": "     * Used for creating and indexing gradients arrays.\n     */\n    protected static final int 256 = 256;\n    protected static final int GRADIENT_SIZE_INDEX = 256 -1;\n\n    /** Maximum length of the fast single-array.  If the estimated array size\n     * is greater than this, switch over to the slow lookup method.", "refactored_code": "    protected static final int GRADIENT_SIZE = 256;\n     * Used for creating and indexing gradients arrays.\n     */\n    protected static final int GRADIENT_SIZE = 256;\n    protected static final int GRADIENT_SIZE_INDEX = GRADIENT_SIZE -1;\n\n    /** Maximum length of the fast single-array.  If the estimated array size\n     * is greater than this, switch over to the slow lookup method."}
{"magic_number_smell": "        if ((fillMethod == DEFAULT_IMPL) &&\n            (isSimpleFocus && isNonCyclic && isSimpleLookup)) {\n            this.calculateFixedPointSqrtLookupTable();\n            fillMethod = 1;\n        }\n    }\n", "refactored_code": "    private static final int FIXED_POINT_IMPL = 1;\n        if ((fillMethod == DEFAULT_IMPL) &&\n            (isSimpleFocus && isNonCyclic && isSimpleLookup)) {\n            this.calculateFixedPointSqrtLookupTable();\n            fillMethod = FIXED_POINT_IMPL;\n        }\n    }\n"}
{"magic_number_smell": "        case RELATIVE_COLORIMETRIC:\n        case ABSOLUTE_COLORIMETRIC:\n        case SATURATION:\n        case 0:\n            break;\n        default:\n            throw new IllegalArgumentException();", "refactored_code": "    public static final int PERCEPTUAL = 0;\n        case RELATIVE_COLORIMETRIC:\n        case ABSOLUTE_COLORIMETRIC:\n        case SATURATION:\n        case PERCEPTUAL:\n            break;\n        default:\n            throw new IllegalArgumentException();"}
{"magic_number_smell": "     * @param glyphs The GlyphVector to layout.\n     * @param path The path (or shape) to wrap around\n     * @param align The text alignment to use. Should be one\n     *              of 0, ALIGN_MIDDLE or ALIGN_END.\n     * @param startOffset The offset from the start of the path for the initial\n     *              text position.\n     * @param textLength The length that the text should fill.", "refactored_code": "    public static final int ALIGN_START = 0;\n     * @param glyphs The GlyphVector to layout.\n     * @param path The path (or shape) to wrap around\n     * @param align The text alignment to use. Should be one\n     *              of ALIGN_START, ALIGN_MIDDLE or ALIGN_END.\n     * @param startOffset The offset from the start of the path for the initial\n     *              text position.\n     * @param textLength The length that the text should fill."}
{"magic_number_smell": "    /**\n     * TransformType values\n     */\n    public static final TransformType TRANSLATE = new TransformType(0, TRANSLATE_STRING);\n    public static final TransformType ROTATE = new TransformType(TRANSFORM_ROTATE, ROTATE_STRING);\n    public static final TransformType SCALE = new TransformType(TRANSFORM_SCALE, SCALE_STRING);\n    public static final TransformType SHEAR = new TransformType(TRANSFORM_SHEAR, SHEAR_STRING);", "refactored_code": "    public static final int TRANSFORM_TRANSLATE = 0;\n    /**\n     * TransformType values\n     */\n    public static final TransformType TRANSLATE = new TransformType(TRANSFORM_TRANSLATE, TRANSLATE_STRING);\n    public static final TransformType ROTATE = new TransformType(TRANSFORM_ROTATE, ROTATE_STRING);\n    public static final TransformType SCALE = new TransformType(TRANSFORM_SCALE, SCALE_STRING);\n    public static final TransformType SHEAR = new TransformType(TRANSFORM_SHEAR, SHEAR_STRING);"}
{"magic_number_smell": "        Point2D.Double p1 =\n            new Point2D.Double(xpoints[npoints-1], ypoints[npoints-1]);\n\n        if (p0.distance(p1) > 0.001f)\n            pol.addPoint(xpoints[npoints-1], ypoints[npoints-1]);\n\n        return pol;", "refactored_code": "    private static final float ASSUME_ZERO = 0.001f;\n        Point2D.Double p1 =\n            new Point2D.Double(xpoints[npoints-1], ypoints[npoints-1]);\n\n        if (p0.distance(p1) > ASSUME_ZERO)\n            pol.addPoint(xpoints[npoints-1], ypoints[npoints-1]);\n\n        return pol;"}
{"magic_number_smell": "    public static final ARGBChannel B \n        = new ARGBChannel(CHANNEL_B, BLUE);\n    public static final ARGBChannel A \n        = new ARGBChannel(3, ALPHA);\n\n    private String desc;\n    private int val;", "refactored_code": "    public static final int CHANNEL_A = 3;\n    public static final ARGBChannel B \n        = new ARGBChannel(CHANNEL_B, BLUE);\n    public static final ARGBChannel A \n        = new ARGBChannel(CHANNEL_A, ALPHA);\n\n    private String desc;\n    private int val;"}
{"magic_number_smell": "       *        Ad = As + Ad*(1-As)\n       * </pre>\n       */\n    public static final CompositeRule OVER = new CompositeRule(1);\n\n      /**\n       * Porter-Duff Source In Destination rule. The part of the", "refactored_code": "    public static final int RULE_OVER = 1;\n       *        Ad = As + Ad*(1-As)\n       * </pre>\n       */\n    public static final CompositeRule OVER = new CompositeRule(RULE_OVER);\n\n      /**\n       * Porter-Duff Source In Destination rule. The part of the"}
{"magic_number_smell": "    public static final int MODE_WRAP = 3;\n\n      /** Pad edges with zeros */\n    public static final PadMode ZERO_PAD = new PadMode(1);\n\n      /** Pad edges by replicating edge pixels */\n    public static final PadMode REPLICATE = new PadMode(MODE_REPLICATE);", "refactored_code": "    public static final int MODE_ZERO_PAD = 1;\n    public static final int MODE_WRAP = 3;\n\n      /** Pad edges with zeros */\n    public static final PadMode ZERO_PAD = new PadMode(MODE_ZERO_PAD);\n\n      /** Pad edges by replicating edge pixels */\n    public static final PadMode REPLICATE = new PadMode(MODE_REPLICATE);"}
{"magic_number_smell": "     * Returns the transfer function for the alpha channel\n     */\n    public ComponentTransferFunction getAlphaFunction(){\n        return functions[0];\n    }\n\n    /**", "refactored_code": "    public static final int ALPHA = 0;\n     * Returns the transfer function for the alpha channel\n     */\n    public ComponentTransferFunction getAlphaFunction(){\n        return functions[ALPHA];\n    }\n\n    /**"}
{"magic_number_smell": "    public static final double 0.0001 = 0.0001;\n\n    public static boolean eps_eq(double f1, double f2) {\n        return ((f1 >= f2-0.0001) && (f1 <= f2+0.0001));\n    }\n    public static boolean eps_abs_eq(double f1, double f2) {\n        if (f1 <0) f1 = -f1;", "refactored_code": "    public static final double eps = 0.0001;\n    public static final double eps = 0.0001;\n\n    public static boolean eps_eq(double f1, double f2) {\n        return ((f1 >= f2-eps) && (f1 <= f2+eps));\n    }\n    public static boolean eps_abs_eq(double f1, double f2) {\n        if (f1 <0) f1 = -f1;"}
{"magic_number_smell": "    public static final double sRGBToLsRGB(double value) {\n        if(value <= 0.003928)\n            return value*LFACT;\n        return Math.pow((value+0.055)/1.055, 2.4);\n    }\n\n    /**", "refactored_code": "    private static final double GAMMA = 2.4;\n    public static final double sRGBToLsRGB(double value) {\n        if(value <= 0.003928)\n            return value*LFACT;\n        return Math.pow((value+0.055)/1.055, GAMMA);\n    }\n\n    /**"}
{"magic_number_smell": "\n    static {\n        final double scale = 1.0/255;\n        final double exp   = 1.0/2.4;\n        // System.out.print(\"L2S: \");\n        for(int i=0; i<256; i++){\n            double value = i*scale;", "refactored_code": "    private static final double GAMMA = 2.4;\n\n    static {\n        final double scale = 1.0/255;\n        final double exp   = 1.0/GAMMA;\n        // System.out.print(\"L2S: \");\n        for(int i=0; i<256; i++){\n            double value = i*scale;"}
{"magic_number_smell": "    }\n\n    public final int setupSeed(int seed) {\n        if (seed <= 0) seed = -(seed % (2147483647 - 1)) + 1;\n        if (seed > 2147483647 - 1) seed = 2147483647 - 1;\n        return seed;\n    }", "refactored_code": "    private static final int RAND_m = 2147483647; /* 2**31 - 1 */\n    }\n\n    public final int setupSeed(int seed) {\n        if (seed <= 0) seed = -(seed % (RAND_m - 1)) + 1;\n        if (seed > RAND_m - 1) seed = RAND_m - 1;\n        return seed;\n    }"}
{"magic_number_smell": "                                    String ext,\n                                    String mimeType,\n                                    int offset, byte[] magicNumber) {\n        this(name, 1000, ext, mimeType, offset, magicNumber);\n    }\n\n    /**", "refactored_code": "    public static final float PRIORITY = 1000;\n                                    String ext,\n                                    String mimeType,\n                                    int offset, byte[] magicNumber) {\n        this(name, PRIORITY, ext, mimeType, offset, magicNumber);\n    }\n\n    /**"}
{"magic_number_smell": "        }\n\n        // Rotate\n        rotateModel.setValue(180./Math.PI*theta);\n        rxModel.setValue(0);\n        ryModel.setValue(0);\n    }", "refactored_code": "    protected static final double RAD_TO_DEG = 180./Math.PI;\n        }\n\n        // Rotate\n        rotateModel.setValue(RAD_TO_DEG*theta);\n        rxModel.setValue(0);\n        ryModel.setValue(0);\n    }"}
{"magic_number_smell": "    /**\n     * Whether the bridge should support dynamic, or interactive features.\n     */\n    protected int dynamicStatus = 0;\n\n    /**\n     * The update manager.", "refactored_code": "    public static final int STATIC      = 0;\n    /**\n     * Whether the bridge should support dynamic, or interactive features.\n     */\n    protected int dynamicStatus = STATIC;\n\n    /**\n     * The update manager."}
{"magic_number_smell": "            // cursor is displayed. That viewport is platform\n            // dependant and is not defined by the SVG content.\n            //\n            float width  = 32;\n            float height = DEFAULT_PREFERRED_HEIGHT;\n            UnitProcessor.Context uctx\n                = UnitProcessor.createContext(ctx, rootElement);", "refactored_code": "    public static final int DEFAULT_PREFERRED_WIDTH = 32;\n            // cursor is displayed. That viewport is platform\n            // dependant and is not defined by the SVG content.\n            //\n            float width  = DEFAULT_PREFERRED_WIDTH;\n            float height = DEFAULT_PREFERRED_HEIGHT;\n            UnitProcessor.Context uctx\n                = UnitProcessor.createContext(ctx, rootElement);"}
{"magic_number_smell": "    public static final double 0.00001 = 0.00001;\n\n    public static boolean epsEQ(double a, double b) {\n        return ((a+0.00001 > b) && (a-0.00001 < b));\n    }\n\n    public static int makeConvexHull(Point2D.Float [] pts, int numPts) {", "refactored_code": "    public static final double eps = 0.00001;\n    public static final double eps = 0.00001;\n\n    public static boolean epsEQ(double a, double b) {\n        return ((a+eps > b) && (a-eps < b));\n    }\n\n    public static int makeConvexHull(Point2D.Float [] pts, int numPts) {"}
{"magic_number_smell": "                    };\n                    script = (Script)AccessController.doPrivileged(compile);\n\n                    if (compiledScripts.size() + 1 > 32) {\n                        // too many cached items - we should delete the\n                        // oldest entry.  all of this is very fast on\n                        // linkedlist", "refactored_code": "    private static final int MAX_CACHED_SCRIPTS = 32;\n                    };\n                    script = (Script)AccessController.doPrivileged(compile);\n\n                    if (compiledScripts.size() + 1 > MAX_CACHED_SCRIPTS) {\n                        // too many cached items - we should delete the\n                        // oldest entry.  all of this is very fast on\n                        // linkedlist"}
{"magic_number_smell": "        /**\n         * The past tick times.\n         */\n        protected long[] times = new long[8];\n\n        /**\n         * The sum of the times in {@link #times}.", "refactored_code": "        private static final int NUM_TIMES = 8;\n        /**\n         * The past tick times.\n         */\n        protected long[] times = new long[NUM_TIMES];\n\n        /**\n         * The sum of the times in {@link #times}."}
{"magic_number_smell": "     * @param attr the attribute which contains the coordinate system\n     * @param coordinateSystem the coordinate system to parse\n     * @param ctx the BridgeContext to use for error information\n     * @return OBJECT_BOUNDING_BOX | 1\n     */\n    public static short parseCoordinateSystem(Element e,\n                                              String attr,", "refactored_code": "    public static final short USER_SPACE_ON_USE = 1;\n     * @param attr the attribute which contains the coordinate system\n     * @param coordinateSystem the coordinate system to parse\n     * @param ctx the BridgeContext to use for error information\n     * @return OBJECT_BOUNDING_BOX | USER_SPACE_ON_USE\n     */\n    public static short parseCoordinateSystem(Element e,\n                                              String attr,"}
{"magic_number_smell": "         * that the start of the text string is at the initial current text\n         * location.\n         */\n        public static final Anchor START = new Anchor(0);\n\n        /**\n         * The anchor which enables the rendered characters to be aligned such", "refactored_code": "        public static final int ANCHOR_START  = 0;\n         * that the start of the text string is at the initial current text\n         * location.\n         */\n        public static final Anchor START = new Anchor(ANCHOR_START);\n\n        /**\n         * The anchor which enables the rendered characters to be aligned such"}
{"magic_number_smell": "     * Parses the selector string.\n     */\n    protected void parseSelector(String selector) {\n        selectorType = -1;\n        Scanner scanner = new Scanner(selector);\n        int token = scanner.next();\n        if (token == Scanner.NAME) {", "refactored_code": "    protected static final int SELECTOR_INVALID = -1;\n     * Parses the selector string.\n     */\n    protected void parseSelector(String selector) {\n        selectorType = SELECTOR_INVALID;\n        Scanner scanner = new Scanner(selector);\n        int token = scanner.next();\n        if (token == Scanner.NAME) {"}
{"magic_number_smell": "        maxOpacity = (1 << bitDepth) - 1;\n\n        colorType = chunk.getInt1(9);\n        if ((colorType != 0) &&\n            (colorType != PNG_COLOR_RGB) &&\n            (colorType != PNG_COLOR_PALETTE) &&\n            (colorType != PNG_COLOR_GRAY_ALPHA) &&", "refactored_code": "    public static final int PNG_COLOR_GRAY = 0;\n        maxOpacity = (1 << bitDepth) - 1;\n\n        colorType = chunk.getInt1(9);\n        if ((colorType != PNG_COLOR_GRAY) &&\n            (colorType != PNG_COLOR_RGB) &&\n            (colorType != PNG_COLOR_PALETTE) &&\n            (colorType != PNG_COLOR_GRAY_ALPHA) &&"}
{"magic_number_smell": "            ChunkStream cs = new ChunkStream(\"bKGD\");\n\n            switch (colorType) {\n            case 0:\n            case PNG_COLOR_GRAY_ALPHA:\n                int gray = ((PNGEncodeParam.Gray)param).getBackgroundGray();\n                cs.writeShort(gray);", "refactored_code": "    private static final int PNG_COLOR_GRAY = 0;\n            ChunkStream cs = new ChunkStream(\"bKGD\");\n\n            switch (colorType) {\n            case PNG_COLOR_GRAY:\n            case PNG_COLOR_GRAY_ALPHA:\n                int gray = ((PNGEncodeParam.Gray)param).getBackgroundGray();\n                cs.writeShort(gray);"}
{"magic_number_smell": "        maxOpacity = (1 << bitDepth) - 1;\n\n        colorType = chunk.getInt1(9);\n        if ((colorType != 0) &&\n            (colorType != PNG_COLOR_RGB) &&\n            (colorType != PNG_COLOR_PALETTE) &&\n            (colorType != PNG_COLOR_GRAY_ALPHA) &&", "refactored_code": "    public static final int PNG_COLOR_GRAY = 0;\n        maxOpacity = (1 << bitDepth) - 1;\n\n        colorType = chunk.getInt1(9);\n        if ((colorType != PNG_COLOR_GRAY) &&\n            (colorType != PNG_COLOR_RGB) &&\n            (colorType != PNG_COLOR_PALETTE) &&\n            (colorType != PNG_COLOR_GRAY_ALPHA) &&"}
{"magic_number_smell": "    private static final int 9 = 9;\n\n    /** The sector size. */\n    private static final int SECTOR_SIZE = 1 << 9;\n\n    /** A mask to determine the offset within a sector. */\n    private static final int SECTOR_MASK = SECTOR_SIZE - 1;", "refactored_code": "    private static final int SECTOR_SHIFT = 9;\n    private static final int SECTOR_SHIFT = 9;\n\n    /** The sector size. */\n    private static final int SECTOR_SIZE = 1 << SECTOR_SHIFT;\n\n    /** A mask to determine the offset within a sector. */\n    private static final int SECTOR_MASK = SECTOR_SIZE - 1;"}
{"magic_number_smell": "    /**\n     * Returns a constant identifying the rule type.\n     */\n    public short getType() { return 3; }\n\n    /**\n     * Returns the URI of the @font-face rule.", "refactored_code": "    public static final short TYPE = 3;\n    /**\n     * Returns a constant identifying the rule type.\n     */\n    public short getType() { return TYPE; }\n\n    /**\n     * Returns the URI of the @font-face rule."}
{"magic_number_smell": "     * Returns a constant identifying the rule type.\n     */\n    public short getType() {\n        return 2;\n    }\n\n    /**", "refactored_code": "    public static final short TYPE = 2;\n     * Returns a constant identifying the rule type.\n     */\n    public short getType() {\n        return TYPE;\n    }\n\n    /**"}
{"magic_number_smell": "     * Returns a constant identifying the rule type.\n     */\n    public short getType() {\n        return 1;\n    }\n\n    /**", "refactored_code": "    public static final short TYPE = 1;\n     * Returns a constant identifying the rule type.\n     */\n    public short getType() {\n        return TYPE;\n    }\n\n    /**"}
{"magic_number_smell": "    /**\n     * The values.\n     */\n    protected Value[] values = new Value[8];\n\n    /**\n     * The value indexes.", "refactored_code": "    protected static final int INITIAL_LENGTH = 8;\n    /**\n     * The values.\n     */\n    protected Value[] values = new Value[INITIAL_LENGTH];\n\n    /**\n     * The value indexes."}
{"magic_number_smell": "     * Tells whether the given property value is important.\n     */\n    public boolean isImportant(int i) {\n        return (masks[i] & 0x0001) != 0;\n    }\n\n    /**", "refactored_code": "    public static final short IMPORTANT_MASK             = 0x0001;\n     * Tells whether the given property value is important.\n     */\n    public boolean isImportant(int i) {\n        return (masks[i] & IMPORTANT_MASK) != 0;\n    }\n\n    /**"}
{"magic_number_smell": "     * Returns a constant identifying the rule type.\n     */\n    public short getType() {\n        return 0;\n    }\n\n    /**", "refactored_code": "    public static final short TYPE = 0;\n     * Returns a constant identifying the rule type.\n     */\n    public short getType() {\n        return TYPE;\n    }\n\n    /**"}
{"magic_number_smell": "    // The property indexes.\n    //\n    public static final int SVGCSSEngine.FINAL_INDEX+1   = SVGCSSEngine.FINAL_INDEX+1;\n    public static final int INDENT_INDEX        = SVGCSSEngine.FINAL_INDEX+1+1;\n    public static final int MARGIN_BOTTOM_INDEX = INDENT_INDEX+1;\n    public static final int MARGIN_LEFT_INDEX   = MARGIN_BOTTOM_INDEX+1;\n    public static final int MARGIN_RIGHT_INDEX  = MARGIN_LEFT_INDEX+1;", "refactored_code": "    public static final int LINE_HEIGHT_INDEX   = SVGCSSEngine.FINAL_INDEX+1;\n    // The property indexes.\n    //\n    public static final int LINE_HEIGHT_INDEX   = SVGCSSEngine.FINAL_INDEX+1;\n    public static final int INDENT_INDEX        = LINE_HEIGHT_INDEX+1;\n    public static final int MARGIN_BOTTOM_INDEX = INDENT_INDEX+1;\n    public static final int MARGIN_LEFT_INDEX   = MARGIN_BOTTOM_INDEX+1;\n    public static final int MARGIN_RIGHT_INDEX  = MARGIN_LEFT_INDEX+1;"}
{"magic_number_smell": "    //\n    public static final int 0 = 0;\n    public static final int BASELINE_SHIFT_INDEX =\n        0 + 1;\n    public static final int CLIP_INDEX = BASELINE_SHIFT_INDEX + 1;\n    public static final int CLIP_PATH_INDEX = CLIP_INDEX +1;\n    public static final int CLIP_RULE_INDEX = CLIP_PATH_INDEX + 1;", "refactored_code": "    public static final int ALIGNMENT_BASELINE_INDEX = 0;\n    //\n    public static final int ALIGNMENT_BASELINE_INDEX = 0;\n    public static final int BASELINE_SHIFT_INDEX =\n        ALIGNMENT_BASELINE_INDEX + 1;\n    public static final int CLIP_INDEX = BASELINE_SHIFT_INDEX + 1;\n    public static final int CLIP_PATH_INDEX = CLIP_INDEX +1;\n    public static final int CLIP_RULE_INDEX = CLIP_PATH_INDEX + 1;"}
{"magic_number_smell": "     * Creates a new table.\n     */\n    public StringMap() {\n        table = new Entry[11];\n    }\n\n    /**", "refactored_code": "    protected static final int INITIAL_CAPACITY = 11;\n     * Creates a new table.\n     */\n    public StringMap() {\n        table = new Entry[INITIAL_CAPACITY];\n    }\n\n    /**"}
{"magic_number_smell": "         * Creates a new NamedNodeHashMap object.\n         */\n        public NamedNodeHashMap() {\n                  table = new Entry[3];\n        }\n\n        /**", "refactored_code": "        protected static final int INITIAL_CAPACITY = 3;\n         * Creates a new NamedNodeHashMap object.\n         */\n        public NamedNodeHashMap() {\n                  table = new Entry[INITIAL_CAPACITY];\n        }\n\n        /**"}
{"magic_number_smell": "        int i2 = c2 - 1;\n        if (a1.get(i1) != a2.get(i2)) {\n            if (hashCode() < other.hashCode()) {\n                return 0x01\n                    | DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC\n                    | DOCUMENT_POSITION_PRECEDING;\n            } else {", "refactored_code": "    public static final short DOCUMENT_POSITION_DISCONNECTED = 0x01;\n        int i2 = c2 - 1;\n        if (a1.get(i1) != a2.get(i2)) {\n            if (hashCode() < other.hashCode()) {\n                return DOCUMENT_POSITION_DISCONNECTED\n                    | DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC\n                    | DOCUMENT_POSITION_PRECEDING;\n            } else {"}
{"magic_number_smell": "                (DOMException.INVALID_STATE_ERR,\n                 \"detached.iterator\",  null);\n        case BACKWARD:\n        case 0:\n            state = FORWARD;\n            return referenceNode;\n        case FORWARD:", "refactored_code": "    protected static final short INITIAL = 0;\n                (DOMException.INVALID_STATE_ERR,\n                 \"detached.iterator\",  null);\n        case BACKWARD:\n        case INITIAL:\n            state = FORWARD;\n            return referenceNode;\n        case FORWARD:"}
{"magic_number_smell": "     * Creates a new table.\n     */\n    public DocumentDescriptor() {\n        table = new Entry[101];\n    }\n\n    /**", "refactored_code": "    protected static final int INITIAL_CAPACITY = 101;\n     * Creates a new table.\n     */\n    public DocumentDescriptor() {\n        table = new Entry[INITIAL_CAPACITY];\n    }\n\n    /**"}
{"magic_number_smell": "     * Creates a new table.\n     */\n    public IntTable() {\n        table = new Entry[11];\n    }\n\n    /**", "refactored_code": "    protected static final int INITIAL_CAPACITY = 11;\n     * Creates a new table.\n     */\n    public IntTable() {\n        table = new Entry[INITIAL_CAPACITY];\n    }\n\n    /**"}
{"magic_number_smell": "     * Creates a new TriplyIndexedTable.\n     */\n    public TriplyIndexedTable() {\n        table = new Entry[11];\n    }\n\n    /**", "refactored_code": "    protected static final int INITIAL_CAPACITY = 11;\n     * Creates a new TriplyIndexedTable.\n     */\n    public TriplyIndexedTable() {\n        table = new Entry[INITIAL_CAPACITY];\n    }\n\n    /**"}
{"magic_number_smell": "         */\n        protected class OKButtonAction extends AbstractAction {\n            public void actionPerformed(ActionEvent e) {\n                returnCode = 0;\n                dispose();\n            }\n        }", "refactored_code": "        public static final int OK_OPTION = 0;\n         */\n        protected class OKButtonAction extends AbstractAction {\n            public void actionPerformed(ActionEvent e) {\n                returnCode = OK_OPTION;\n                dispose();\n            }\n        }"}
{"magic_number_smell": "     */\n    protected class OKButtonAction extends AbstractAction {\n        public void actionPerformed(ActionEvent e) {\n            returnCode = 0;\n            dispose();\n        }\n    }", "refactored_code": "    public static final int OK_OPTION = 0;\n     */\n    protected class OKButtonAction extends AbstractAction {\n        public void actionPerformed(ActionEvent e) {\n            returnCode = OK_OPTION;\n            dispose();\n        }\n    }"}
{"magic_number_smell": "         * The blocks width.\n         */\n        protected static final double BLOCK_WIDTH =\n            90-BLOCK_MARGIN*2;\n\n        /**\n         * The blocks height.", "refactored_code": "        public static final int PREFERRED_WIDTH = 90;\n         * The blocks width.\n         */\n        protected static final double BLOCK_WIDTH =\n            PREFERRED_WIDTH-BLOCK_MARGIN*2;\n\n        /**\n         * The blocks height."}
{"magic_number_smell": "\n    /**\n     * Shows the dialog.\n     * @return 0 or CANCEL_OPTION.\n     */\n    public int showDialog() {\n        pack();", "refactored_code": "    public static final int OK_OPTION = 0;\n\n    /**\n     * Shows the dialog.\n     * @return OK_OPTION or CANCEL_OPTION.\n     */\n    public int showDialog() {\n        pack();"}
{"magic_number_smell": "\n    /**\n     * Shows the dialog.\n     * @return 0 or CANCEL_OPTION.\n     */\n    public int showDialog() {\n        pack();", "refactored_code": "    public static final int OK_OPTION = 0;\n\n    /**\n     * Shows the dialog.\n     * @return OK_OPTION or CANCEL_OPTION.\n     */\n    public int showDialog() {\n        pack();"}
{"magic_number_smell": "                if (nextChar() == '>') {\n                    return CHARACTER_DATA_CONTEXT;\n                } else {\n                    return -2;\n                }\n            }\n            nextChar();", "refactored_code": "    public static final int TEMP_ERROR_CONTEXT = -2;\n                if (nextChar() == '>') {\n                    return CHARACTER_DATA_CONTEXT;\n                } else {\n                    return TEMP_ERROR_CONTEXT;\n                }\n            }\n            nextChar();"}
{"magic_number_smell": "     * Returns whether or not the Shift modifier is down on this event.\n     */\n    public boolean isShiftDown() {\n        return (modifiers & InputEvent.SHIFT_DOWN_MASK) != 0;\n    }\n\n    /**", "refactored_code": "    public static final int SHIFT_MASK = InputEvent.SHIFT_DOWN_MASK;\n     * Returns whether or not the Shift modifier is down on this event.\n     */\n    public boolean isShiftDown() {\n        return (modifiers & SHIFT_MASK) != 0;\n    }\n\n    /**"}
{"magic_number_smell": "\n    /**\n     * Returns the event's selection event type.\n     * @see org.apache.batik.gvt.event.SelectionEvent#1\n     * @see org.apache.batik.gvt.event.SelectionEvent#SELECTION_CLEARED\n     * @see org.apache.batik.gvt.event.SelectionEvent#SELECTION_DONE\n     */", "refactored_code": "    public static final int SELECTION_CHANGED = 1;\n\n    /**\n     * Returns the event's selection event type.\n     * @see org.apache.batik.gvt.event.SelectionEvent#SELECTION_CHANGED\n     * @see org.apache.batik.gvt.event.SelectionEvent#SELECTION_CLEARED\n     * @see org.apache.batik.gvt.event.SelectionEvent#SELECTION_DONE\n     */"}
{"magic_number_smell": "        assignGlyphGroupRanges(size, ggis);\n\n        GVTGlyphVector gv     = ggis[0].getGlyphVector();\n        int            justType = 0;\n        double         ggAdv  = 0;\n        double         gAdv   = 0;\n", "refactored_code": "    protected static final int FULL_WORD   = 0;\n        assignGlyphGroupRanges(size, ggis);\n\n        GVTGlyphVector gv     = ggis[0].getGlyphVector();\n        int            justType = FULL_WORD;\n        double         ggAdv  = 0;\n        double         gAdv   = 0;\n"}
{"magic_number_smell": "\n    protected static void buildQuickLut() {\n        int entry = 0;\n        quickLut = new byte[256];\n        int i=0;\n        while (i<256) {\n            int max = raw_data[2*entry+1];", "refactored_code": "    protected static final int QUICK_LUT_SIZE = 256;\n\n    protected static void buildQuickLut() {\n        int entry = 0;\n        quickLut = new byte[QUICK_LUT_SIZE];\n        int i=0;\n        while (i<QUICK_LUT_SIZE) {\n            int max = raw_data[2*entry+1];"}
{"magic_number_smell": "     * Creates a new AWTGlyphGeometryCache.\n     */\n    public AWTGlyphGeometryCache() {\n        table = new Entry[71];\n    }\n\n    /**", "refactored_code": "    protected static final int INITIAL_CAPACITY = 71;\n     * Creates a new AWTGlyphGeometryCache.\n     */\n    public AWTGlyphGeometryCache() {\n        table = new Entry[INITIAL_CAPACITY];\n    }\n\n    /**"}
{"magic_number_smell": "        for (int c = aci.first();\n             c != AttributedCharacterIterator.DONE;\n             c = aci.next(), idx++) {\n            if ((c >= 0x0600) && (c <= arabicEnd)) {\n                if (runStart == -1)\n                    runStart = idx;\n            } else if (runStart != -1) {", "refactored_code": "    private static final int arabicStart = 0x0600;\n        for (int c = aci.first();\n             c != AttributedCharacterIterator.DONE;\n             c = aci.next(), idx++) {\n            if ((c >= arabicStart) && (c <= arabicEnd)) {\n                if (runStart == -1)\n                    runStart = idx;\n            } else if (runStart != -1) {"}
{"magic_number_smell": "     * Parses a timing specifier.  Returns an array of Objects of the\n     * form:\n     * <ul>\n     *   <li>{ 0,          offset }</li>\n     *   <li>{ TIME_SYNCBASE,        offset, id, time-symbol }</li>\n     *   <li>{ TIME_EVENTBASE,       offset, id, event-ref }</li>\n     *   <li>{ TIME_REPEAT,          offset, id, repeat-count }</li>", "refactored_code": "    protected static final int TIME_OFFSET          = 0;\n     * Parses a timing specifier.  Returns an array of Objects of the\n     * form:\n     * <ul>\n     *   <li>{ TIME_OFFSET,          offset }</li>\n     *   <li>{ TIME_SYNCBASE,        offset, id, time-symbol }</li>\n     *   <li>{ TIME_EVENTBASE,       offset, id, event-ref }</li>\n     *   <li>{ TIME_REPEAT,          offset, id, repeat-count }</li>"}
{"magic_number_smell": "     *\n     * @param v the value to convert\n     * @param type the type of the value\n     * @param d 2, VERTICAL_LENGTH, or OTHER_LENGTH\n     * @param ctx the context used to resolve relative value\n     */\n    public static float svgToUserSpace(float v,", "refactored_code": "    public static final short HORIZONTAL_LENGTH = 2;\n     *\n     * @param v the value to convert\n     * @param type the type of the value\n     * @param d HORIZONTAL_LENGTH, VERTICAL_LENGTH, or OTHER_LENGTH\n     * @param ctx the context used to resolve relative value\n     */\n    public static float svgToUserSpace(float v,"}
{"magic_number_smell": "            Rectangle bounds = tree.getPathBounds(currentPath);\n            // Upper area of the tree node\n            if (p.y <= bounds.y + visualTipOffset) {\n                positionIndicator = 1;\n            }\n            // Lower area of the tree node\n            else if (p.y >= bounds.y + bounds.height - visualTipOffset) {", "refactored_code": "        private static final int BEFORE = 1;\n            Rectangle bounds = tree.getPathBounds(currentPath);\n            // Upper area of the tree node\n            if (p.y <= bounds.y + visualTipOffset) {\n                positionIndicator = BEFORE;\n            }\n            // Lower area of the tree node\n            else if (p.y >= bounds.y + bounds.height - visualTipOffset) {"}
{"magic_number_smell": "        if (commandController != null) {\n            commandController.execute(command);\n        } else {\n            state = 1;\n            command.execute();\n            state = IDLE;\n        }", "refactored_code": "    public static final int EXECUTING = 1;\n        if (commandController != null) {\n            commandController.execute(command);\n        } else {\n            state = EXECUTING;\n            command.execute();\n            state = IDLE;\n        }"}
{"magic_number_smell": "         */\n        public void clearAllBreakpoints() {\n            try {\n                debuggerMethods[0].invoke\n                    (debuggerInstance, (Object[]) null);\n            } catch (InvocationTargetException ite) {\n                throw new RuntimeException(ite.getMessage());", "refactored_code": "        protected static final int CLEAR_ALL_BREAKPOINTS_METHOD = 0;\n         */\n        public void clearAllBreakpoints() {\n            try {\n                debuggerMethods[CLEAR_ALL_BREAKPOINTS_METHOD].invoke\n                    (debuggerInstance, (Object[]) null);\n            } catch (InvocationTargetException ite) {\n                throw new RuntimeException(ite.getMessage());"}
{"magic_number_smell": "        if (currentURI < -1) {\n            throw new IllegalStateException(\"Unexpected currentURI:\" + currentURI );\n        }\n        state = 0;\n        if (++currentURI < visitedURIs.size()) {\n            if (!visitedURIs.get(currentURI).equals(uri)) {\n                int len = menu.getItemCount();", "refactored_code": "    protected static final int STABLE_STATE = 0;\n        if (currentURI < -1) {\n            throw new IllegalStateException(\"Unexpected currentURI:\" + currentURI );\n        }\n        state = STABLE_STATE;\n        if (++currentURI < visitedURIs.size()) {\n            if (!visitedURIs.get(currentURI).equals(uri)) {\n                int len = menu.getItemCount();"}
{"magic_number_smell": "    /**\n     * The actual allowed maximum number of last visited URIs\n     */\n    protected int maxVisitedURIs = 10;\n\n    /**\n     * The arguments.", "refactored_code": "    public static final int MAX_VISITED_URIS = 10;\n    /**\n     * The actual allowed maximum number of last visited URIs\n     */\n    protected int maxVisitedURIs = MAX_VISITED_URIS;\n\n    /**\n     * The arguments."}
{"magic_number_smell": "     * Enters the view mode.\n     */\n    public void enterViewMode() {\n        if (mode != 1) {\n            mode = 1;\n            // Disable appropriate buttons\n            getApplyButton().setEnabled(false);", "refactored_code": "    private static final int VIEW_MODE = 1;\n     * Enters the view mode.\n     */\n    public void enterViewMode() {\n        if (mode != VIEW_MODE) {\n            mode = VIEW_MODE;\n            // Disable appropriate buttons\n            getApplyButton().setEnabled(false);"}
{"magic_number_smell": "        okButton.addActionListener(new ActionListener() {\n                public void actionPerformed(ActionEvent e) {\n                    setVisible(false);\n                    returnCode = 0;\n                    savePreferences();\n                    dispose();\n                }", "refactored_code": "    public static final int OK_OPTION = 0;\n        okButton.addActionListener(new ActionListener() {\n                public void actionPerformed(ActionEvent e) {\n                    setVisible(false);\n                    returnCode = OK_OPTION;\n                    savePreferences();\n                    dispose();\n                }"}
{"magic_number_smell": "     * @param element child Element to add to the group\n     */\n    public void addElement(Element element) {\n        addElement(element, (short)(0x01|FILL));\n    }\n\n    /**", "refactored_code": "    public static final short DRAW = 0x01;\n     * @param element child Element to add to the group\n     */\n    public void addElement(Element element) {\n        addElement(element, (short)(DRAW|FILL));\n    }\n\n    /**"}
{"magic_number_smell": "    private SVGRenderingHints hintsConverter;\n    private SVGFont fontConverter;\n    private SVGConverter[] converters =\n        new SVGConverter[6];\n\n    public SVGTransform getTransformConverter() { return transformConverter; }\n    public SVGPaint getPaintConverter(){ return paintConverter; }", "refactored_code": "    private static final int GRAPHIC_CONTEXT_CONVERTER_COUNT = 6;\n    private SVGRenderingHints hintsConverter;\n    private SVGFont fontConverter;\n    private SVGConverter[] converters =\n        new SVGConverter[GRAPHIC_CONTEXT_CONVERTER_COUNT];\n\n    public SVGTransform getTransformConverter() { return transformConverter; }\n    public SVGPaint getPaintConverter(){ return paintConverter; }"}
{"magic_number_smell": "        this.shapeConverter = new SVGShape(generatorCtx);\n        this.domTreeManager = new DOMTreeManager(gc,\n                                                 generatorCtx,\n                                                 3);\n        this.domGroupManager = new DOMGroupManager(gc, domTreeManager);\n        this.domTreeManager.addGroupManager(domGroupManager);\n        generatorCtx.genericImageHandler.setDOMTreeManager(domTreeManager);", "refactored_code": "    public static final int DEFAULT_MAX_GC_OVERRIDES = 3;\n        this.shapeConverter = new SVGShape(generatorCtx);\n        this.domTreeManager = new DOMTreeManager(gc,\n                                                 generatorCtx,\n                                                 DEFAULT_MAX_GC_OVERRIDES);\n        this.domGroupManager = new DOMGroupManager(gc, domTreeManager);\n        this.domTreeManager.addGroupManager(domGroupManager);\n        generatorCtx.genericImageHandler.setDOMTreeManager(domTreeManager);"}
{"magic_number_smell": "            if (value <= 0.0031308) {\n                value *= 12.92f;\n            } else {\n                value = 1.055f * ((float) Math.pow(value, 1.0/2.4)) - 0.055f;\n            }\n            linearToSRGBLut[i] = Math.round(value*255);\n", "refactored_code": "    private static final double GAMMA = 1.0/2.4;\n            if (value <= 0.0031308) {\n                value *= 12.92f;\n            } else {\n                value = 1.055f * ((float) Math.pow(value, GAMMA)) - 0.055f;\n            }\n            linearToSRGBLut[i] = Math.round(value*255);\n"}
{"magic_number_smell": "            proxied.write(EOL);\n            int temp = indentLevel;\n            while(temp > 0){\n                if (temp > SPACES.length) {\n                    proxied.write(SPACES, 0, SPACES.length);\n                    temp -= SPACES.length;\n                } else {", "refactored_code": "    private static final int    SPACES_LEN = SPACES.length;\n            proxied.write(EOL);\n            int temp = indentLevel;\n            while(temp > 0){\n                if (temp > SPACES_LEN) {\n                    proxied.write(SPACES, 0, SPACES_LEN);\n                    temp -= SPACES_LEN;\n                } else {"}
{"magic_number_smell": "        glyphIndex =        ((bais.read()<<8) | bais.read());\n\n        // Get the arguments as just their raw values\n        if ((flags & 0x0001) != 0) {\n            argument1 = (short)(bais.read()<<8 | bais.read());\n            argument2 = (short)(bais.read()<<8 | bais.read());\n        } else {", "refactored_code": "    public static final short ARG_1_AND_2_ARE_WORDS = 0x0001;\n        glyphIndex =        ((bais.read()<<8) | bais.read());\n\n        // Get the arguments as just their raw values\n        if ((flags & ARG_1_AND_2_ARE_WORDS) != 0) {\n            argument1 = (short)(bais.read()<<8 | bais.read());\n            argument2 = (short)(bais.read()<<8 | bais.read());\n        } else {"}
{"magic_number_smell": "    public static final String PDF_EXTENSION  = \".pdf\";\n\n    public static final DestinationType PNG\n        = new DestinationType(PNG_STR, 0, PNG_EXTENSION);\n    public static final DestinationType JPEG\n        = new DestinationType(JPEG_STR, JPEG_CODE, JPEG_EXTENSION);\n    public static final DestinationType TIFF", "refactored_code": "    public static final int PNG_CODE  = 0;\n    public static final String PDF_EXTENSION  = \".pdf\";\n\n    public static final DestinationType PNG\n        = new DestinationType(PNG_STR, PNG_CODE, PNG_EXTENSION);\n    public static final DestinationType JPEG\n        = new DestinationType(JPEG_STR, JPEG_CODE, JPEG_EXTENSION);\n    public static final DestinationType TIFF"}
{"magic_number_smell": "\n    /**\n     * Sets the document state. The given value must be one of\n     * 0, ALWAYS_DYNAMIC or ALWAYS_STATIC.  This only\n     * effects the loading of subsequent documents, it has no\n     * effect on the currently loaded document.\n     */", "refactored_code": "    public static final int AUTODETECT = 0;\n\n    /**\n     * Sets the document state. The given value must be one of\n     * AUTODETECT, ALWAYS_DYNAMIC or ALWAYS_STATIC.  This only\n     * effects the loading of subsequent documents, it has no\n     * effect on the currently loaded document.\n     */"}
{"magic_number_smell": "    }\n\n    public static final int 0xff00 = 0xff00;\n    public static final int ERROR_NULL_INPUT = 0xff00 + 0;\n    public static final int ERROR_INCOMPATIBLE_INPUT_TYPE = 0xff00 + 1;\n    public static final int ERROR_INCOMPATIBLE_OUTPUT_TYPE = 0xff00 + 2;\n", "refactored_code": "    public static final int TRANSCODER_ERROR_BASE = 0xff00;\n    }\n\n    public static final int TRANSCODER_ERROR_BASE = 0xff00;\n    public static final int ERROR_NULL_INPUT = TRANSCODER_ERROR_BASE + 0;\n    public static final int ERROR_INCOMPATIBLE_INPUT_TYPE = TRANSCODER_ERROR_BASE + 1;\n    public static final int ERROR_INCOMPATIBLE_OUTPUT_TYPE = TRANSCODER_ERROR_BASE + 2;\n"}
{"magic_number_smell": "                    }\n                }\n\n                if (doctypeOption == 0) {\n                    if (publicId != null) {\n                        externalId = \"PUBLIC\";\n                        string1 = publicId.toCharArray();", "refactored_code": "    public static final int DOCTYPE_CHANGE = 0;\n                    }\n                }\n\n                if (doctypeOption == DOCTYPE_CHANGE) {\n                    if (publicId != null) {\n                        externalId = \"PUBLIC\";\n                        string1 = publicId.toCharArray();"}
{"magic_number_smell": "    /** Return the number of pixels per unit.\n     */\n    public float getPixelsPerUnit() {\n        return Platform.getScreenResolution() / inch;\n    }\n\n    /**", "refactored_code": "    public static final float PIXEL_PER_INCH = Platform.getScreenResolution();\n    /** Return the number of pixels per unit.\n     */\n    public float getPixelsPerUnit() {\n        return PIXEL_PER_INCH / inch;\n    }\n\n    /**"}
{"magic_number_smell": "     *  be created.\n     */\n    private Paint createTexture(int textureId, Color foreground, Color background) {\n        BufferedImage img = new BufferedImage(10, 10, BufferedImage.TYPE_INT_ARGB);\n        Graphics2D g2d = img.createGraphics();\n        Rectangle2D rec = new Rectangle2D.Float(0, 0, 10, 10);\n        Paint paint = null;", "refactored_code": "    private static final int SIZE = 10;\n     *  be created.\n     */\n    private Paint createTexture(int textureId, Color foreground, Color background) {\n        BufferedImage img = new BufferedImage(SIZE, SIZE, BufferedImage.TYPE_INT_ARGB);\n        Graphics2D g2d = img.createGraphics();\n        Rectangle2D rec = new Rectangle2D.Float(0, 0, SIZE, SIZE);\n        Paint paint = null;"}
{"magic_number_smell": "                    if ( penStyle == WMFConstants.META_PS_NULL ) {\n                        objIndex = addObjectAt( NULL_PEN, color, objIndex );\n                    } else {\n                        objIndex = addObjectAt( 1, color, objIndex );\n                    }\n                }\n                break;", "refactored_code": "    public static final int PEN = 1;\n                    if ( penStyle == WMFConstants.META_PS_NULL ) {\n                        objIndex = addObjectAt( NULL_PEN, color, objIndex );\n                    } else {\n                        objIndex = addObjectAt( PEN, color, objIndex );\n                    }\n                }\n                break;"}
{"magic_number_smell": "                desc.add(dis.readShort() & 0xffff);\n                break;\n\n            case 1:\n                strs[i] = dis.readUTF();\n                break;\n", "refactored_code": "    public static final byte CONSTANT_UTF8_INFO                = 1;\n                desc.add(dis.readShort() & 0xffff);\n                break;\n\n            case CONSTANT_UTF8_INFO:\n                strs[i] = dis.readUTF();\n                break;\n"}
{"magic_number_smell": "     * Creates a new SoftDoublyIndexedTable.\n     */\n    public SoftDoublyIndexedTable() {\n        table = new Entry[11];\n    }\n\n    /**", "refactored_code": "    protected static final int INITIAL_CAPACITY = 11;\n     * Creates a new SoftDoublyIndexedTable.\n     */\n    public SoftDoublyIndexedTable() {\n        table = new Entry[INITIAL_CAPACITY];\n    }\n\n    /**"}
{"magic_number_smell": "    /**\n     * The input buffer.\n     */\n    protected byte[] buffer = new byte[8192];\n\n    /**\n     * The current position in the buffer.", "refactored_code": "    protected static final int BUFFER_SIZE = 8192;\n    /**\n     * The input buffer.\n     */\n    protected byte[] buffer = new byte[BUFFER_SIZE];\n\n    /**\n     * The current position in the buffer."}
{"magic_number_smell": "            try {\n                while (count-- != 0) {\n                    switch (style) {\n                    case 1:\n                        synchronized (rqRable) {\n                            System.out.println(\"     InvL #\" + idx);\n                            rq.invokeLater(rqRable);", "refactored_code": "    public static final int INVOKE_LATER     = 1;\n            try {\n                while (count-- != 0) {\n                    switch (style) {\n                    case INVOKE_LATER:\n                        synchronized (rqRable) {\n                            System.out.println(\"     InvL #\" + idx);\n                            rq.invokeLater(rqRable);"}
{"magic_number_smell": "     * @param r The reader to scan.\n     */\n    public XMLScanner(Reader r) throws XMLException {\n        context = 0;\n        try {\n            reader = new StreamNormalizingReader(r);\n            current = nextChar();", "refactored_code": "    public static final int DOCUMENT_START_CONTEXT = 0;\n     * @param r The reader to scan.\n     */\n    public XMLScanner(Reader r) throws XMLException {\n        context = DOCUMENT_START_CONTEXT;\n        try {\n            reader = new StreamNormalizingReader(r);\n            current = nextChar();"}
{"magic_number_smell": "\n    /**\n     * Test whether the given string is an XML 1.0 Name and/or QName.\n     * @return A bitfield of {@link #1} and\n     *   {@link #IS_XML_10_QNAME}.\n     */\n    public static int testXMLQName(String s) {", "refactored_code": "    public static final int IS_XML_10_NAME  = 1;\n\n    /**\n     * Test whether the given string is an XML 1.0 Name and/or QName.\n     * @return A bitfield of {@link #IS_XML_10_NAME} and\n     *   {@link #IS_XML_10_QNAME}.\n     */\n    public static int testXMLQName(String s) {"}
{"magic_number_smell": "            } else {\n                // Set something to quiet irritating error \n                // from JPEGTranscoder.\n                converter.setQuality(0.99f);\n            }\n        }\n        if(this.area != null) {", "refactored_code": "    private static final float DEFAULT_QUALITY = 0.99f;\n            } else {\n                // Set something to quiet irritating error \n                // from JPEGTranscoder.\n                converter.setQuality(DEFAULT_QUALITY);\n            }\n        }\n        if(this.area != null) {"}
{"magic_number_smell": "        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n            case 1:\n                if (sFilterListener != null) {\n                    sFilterListener.onPerformFiltering();\n                }", "refactored_code": "    protected static final int WHAT_NOTIFY_PERFORM_FILTERING = 1;\n        @Override\n        public void handleMessage(Message msg) {\n            switch (msg.what) {\n            case WHAT_NOTIFY_PERFORM_FILTERING:\n                if (sFilterListener != null) {\n                    sFilterListener.onPerformFiltering();\n                }"}
{"magic_number_smell": "    public void requestLocationPermission() {\n        ActivityCompat.requestPermissions(this,\n                new String[]{Manifest.permission.ACCESS_FINE_LOCATION},\n                100);\n    }\n\n    @Override", "refactored_code": "    public static final int PERMISSIONS_REQUEST_LOCATION = 100;\n    public void requestLocationPermission() {\n        ActivityCompat.requestPermissions(this,\n                new String[]{Manifest.permission.ACCESS_FINE_LOCATION},\n                PERMISSIONS_REQUEST_LOCATION);\n    }\n\n    @Override"}
{"magic_number_smell": "    @Override\n    protected Dialog onCreateDialog(int id) {\n        switch (id) {\n            case 0:\n                ArrayAdapter<Site> siteAdapter =\n                        new ArrayAdapter<Site>(this, R.layout.simple_dropdown_item_1line,\n                                mSiteAlternatives);", "refactored_code": "    private static final int DIALOG_SITE_ALTERNATIVES = 0;\n    @Override\n    protected Dialog onCreateDialog(int id) {\n        switch (id) {\n            case DIALOG_SITE_ALTERNATIVES:\n                ArrayAdapter<Site> siteAdapter =\n                        new ArrayAdapter<Site>(this, R.layout.simple_dropdown_item_1line,\n                                mSiteAlternatives);"}
{"magic_number_smell": "    @Override\n    protected Dialog onCreateDialog(int id) {\n        switch(id) {\n        case 1:\n            return DialogHelper.createNetworkProblemDialog(this, new OnClickListener() {\n                @Override\n                public void onClick(DialogInterface dialog, int which) {", "refactored_code": "    private static final int DIALOG_GET_DEVIATIONS_NETWORK_PROBLEM = 1;\n    @Override\n    protected Dialog onCreateDialog(int id) {\n        switch(id) {\n        case DIALOG_GET_DEVIATIONS_NETWORK_PROBLEM:\n            return DialogHelper.createNetworkProblemDialog(this, new OnClickListener() {\n                @Override\n                public void onClick(DialogInterface dialog, int which) {"}
{"magic_number_smell": "\n    private static JourneyQuery getJourneyQuery(Cursor cursor) {\n        // TODO: Investigate if we can add some kind of caching here.\n        String jsonJourneyQuery = cursor.getString(1);\n        JourneyQuery journeyQuery = null;\n\n        try {", "refactored_code": "    private static final int COLUMN_INDEX_JOURNEY_DATA = 1;\n\n    private static JourneyQuery getJourneyQuery(Cursor cursor) {\n        // TODO: Investigate if we can add some kind of caching here.\n        String jsonJourneyQuery = cursor.getString(COLUMN_INDEX_JOURNEY_DATA);\n        JourneyQuery journeyQuery = null;\n\n        try {"}
{"magic_number_smell": "                            i.putExtra(PointOnMapActivity.EXTRA_STOP, new Site());\n                            i.putExtra(PointOnMapActivity.EXTRA_HELP_TEXT,\n                                    getString(R.string.tap_your_start_point_on_map));\n                            startActivityForResult(i, 0);\n                            break;\n                    }\n                }", "refactored_code": "    protected static final int REQUEST_CODE_POINT_ON_MAP = 0;\n                            i.putExtra(PointOnMapActivity.EXTRA_STOP, new Site());\n                            i.putExtra(PointOnMapActivity.EXTRA_HELP_TEXT,\n                                    getString(R.string.tap_your_start_point_on_map));\n                            startActivityForResult(i, REQUEST_CODE_POINT_ON_MAP);\n                            break;\n                    }\n                }"}
{"magic_number_smell": "    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        switch (requestCode) {\n            case 0:\n                if (resultCode == Activity.RESULT_CANCELED) {\n                    Log.d(TAG, \"action canceled\");\n                } else {", "refactored_code": "    protected static final int REQUEST_CODE_POINT_ON_MAP_START = 0;\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        switch (requestCode) {\n            case REQUEST_CODE_POINT_ON_MAP_START:\n                if (resultCode == Activity.RESULT_CANCELED) {\n                    Log.d(TAG, \"action canceled\");\n                } else {"}
{"magic_number_smell": "\n        if (mJourneyQuery == null || (mJourneyQuery.origin.getName() == null\n                || mJourneyQuery.destination.getName() == null)) {\n            showDialog(0);\n            // If passed with bad parameters, break the execution.\n            return;\n        }", "refactored_code": "    private static final int DIALOG_ILLEGAL_PARAMETERS = 0;\n\n        if (mJourneyQuery == null || (mJourneyQuery.origin.getName() == null\n                || mJourneyQuery.destination.getName() == null)) {\n            showDialog(DIALOG_ILLEGAL_PARAMETERS);\n            // If passed with bad parameters, break the execution.\n            return;\n        }"}
{"magic_number_smell": "            public void onClick(View v) {\n                Intent searchIntent = new Intent(getActivity(), PlaceSearchActivity.class);\n                searchIntent.putExtra(PlaceSearchActivity.ARG_ONLY_STOPS, true);\n                startActivityForResult(searchIntent, 1);\n            }\n        });\n", "refactored_code": "    private static final int REQUEST_CODE_PICK_SITE = 1;\n            public void onClick(View v) {\n                Intent searchIntent = new Intent(getActivity(), PlaceSearchActivity.class);\n                searchIntent.putExtra(PlaceSearchActivity.ARG_ONLY_STOPS, true);\n                startActivityForResult(searchIntent, REQUEST_CODE_PICK_SITE);\n            }\n        });\n"}
{"magic_number_smell": "    @Override\n    public boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen, Preference preference) {\n        if (preference.getKey().equals(\"clear_search_history\")) {\n            onCreateDialog(0).show();\n            return true;\n        } else if (preference.getKey().equals(\"clear_favorites\")) {\n            onCreateDialog(DIALOG_CLEAR_FAVORITES).show();", "refactored_code": "    private static final int DIALOG_CLEAR_SEARCH_HISTORY = 0;\n    @Override\n    public boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen, Preference preference) {\n        if (preference.getKey().equals(\"clear_search_history\")) {\n            onCreateDialog(DIALOG_CLEAR_SEARCH_HISTORY).show();\n            return true;\n        } else if (preference.getKey().equals(\"clear_favorites\")) {\n            onCreateDialog(DIALOG_CLEAR_FAVORITES).show();"}
{"magic_number_smell": "            public void onPageSelected(int position) {\n                int pos = getPagePos(position);\n                switch (pos) {\n                    case 0:\n                        registerScreen(\"Planner\");\n                        break;\n                    case PAGE_FAVORITES_POS:", "refactored_code": "    private static final int PAGE_SEARCH_POS = 0;\n            public void onPageSelected(int position) {\n                int pos = getPagePos(position);\n                switch (pos) {\n                    case PAGE_SEARCH_POS:\n                        registerScreen(\"Planner\");\n                        break;\n                    case PAGE_FAVORITES_POS:"}
{"magic_number_smell": "    private static class DatabaseHelper extends SQLiteOpenHelper {\n\n        DatabaseHelper(Context context) {\n            super(context, DATABASE_NAME, null, 8);\n        }\n\n        @Override", "refactored_code": "    private static final int DATABASE_VERSION = 8;\n    private static class DatabaseHelper extends SQLiteOpenHelper {\n\n        DatabaseHelper(Context context) {\n            super(context, DATABASE_NAME, null, DATABASE_VERSION);\n        }\n\n        @Override"}
{"magic_number_smell": "    private static class DatabaseHelper extends SQLiteOpenHelper {\n\n        DatabaseHelper(Context context) {\n            super(context, DATABASE_NAME, null, 2);\n        }\n\n        @Override", "refactored_code": "    private static final int DATABASE_VERSION = 2;\n    private static class DatabaseHelper extends SQLiteOpenHelper {\n\n        DatabaseHelper(Context context) {\n            super(context, DATABASE_NAME, null, DATABASE_VERSION);\n        }\n\n        @Override"}
{"magic_number_smell": "    private static class DatabaseHelper extends SQLiteOpenHelper {\n\n        DatabaseHelper(Context context) {\n            super(context, DATABASE_NAME, null, 1);\n        }\n\n        @Override", "refactored_code": "    private static final int DATABASE_VERSION = 1;\n    private static class DatabaseHelper extends SQLiteOpenHelper {\n\n        DatabaseHelper(Context context) {\n            super(context, DATABASE_NAME, null, DATABASE_VERSION);\n        }\n\n        @Override"}
{"magic_number_smell": "    private static class DatabaseHelper extends SQLiteOpenHelper {\n\n        DatabaseHelper(Context context) {\n            super(context, DATABASE_NAME, null, 3);\n        }\n\n        @Override", "refactored_code": "    private static final int DATABASE_VERSION = 3;\n    private static class DatabaseHelper extends SQLiteOpenHelper {\n\n        DatabaseHelper(Context context) {\n            super(context, DATABASE_NAME, null, DATABASE_VERSION);\n        }\n\n        @Override"}
{"magic_number_smell": "\npublic class OnBootReceiver extends BroadcastReceiver {\n    //private static final int 300000 = 300000; // 5 minutes\n    private static final int 300000 = 300000; // 5 minutes\n    private static final String TAG = \"OnBootReceiver\";\n\n    @Override", "refactored_code": "    //private static final int PERIOD = 300000; // 5 minutes\n\npublic class OnBootReceiver extends BroadcastReceiver {\n    //private static final int PERIOD = 300000; // 5 minutes\n    private static final int PERIOD = 300000; // 5 minutes\n    private static final String TAG = \"OnBootReceiver\";\n\n    @Override"}
{"magic_number_smell": "        if (mLoadingIndicator != null) {\n            mLoadingIndicator.setVisibility(View.VISIBLE);\n        }\n        mHandler.removeMessages(100);\n        mHandler.sendMessageDelayed(mHandler.obtainMessage(100, text), mAutoCompleteDelay);\n    }\n", "refactored_code": "    private static final int MESSAGE_TEXT_CHANGED = 100;\n        if (mLoadingIndicator != null) {\n            mLoadingIndicator.setVisibility(View.VISIBLE);\n        }\n        mHandler.removeMessages(MESSAGE_TEXT_CHANGED);\n        mHandler.sendMessageDelayed(mHandler.obtainMessage(MESSAGE_TEXT_CHANGED, text), mAutoCompleteDelay);\n    }\n"}
{"magic_number_smell": "\n    private static final int 1000 = 1000;\n    private static final int HEADER_VIEW_TYPE_OFFSET = 0;\n    private static final int FOOTER_VIEW_TYPE_OFFSET = HEADER_VIEW_TYPE_OFFSET + 1000;\n    private static final int CONTENT_VIEW_TYPE_OFFSET = FOOTER_VIEW_TYPE_OFFSET + 1000;\n\n    private int headerItemCount;", "refactored_code": "    private static final int VIEW_TYPE_MAX_COUNT = 1000;\n\n    private static final int VIEW_TYPE_MAX_COUNT = 1000;\n    private static final int HEADER_VIEW_TYPE_OFFSET = 0;\n    private static final int FOOTER_VIEW_TYPE_OFFSET = HEADER_VIEW_TYPE_OFFSET + VIEW_TYPE_MAX_COUNT;\n    private static final int CONTENT_VIEW_TYPE_OFFSET = FOOTER_VIEW_TYPE_OFFSET + VIEW_TYPE_MAX_COUNT;\n\n    private int headerItemCount;"}
{"magic_number_smell": "\n    @Override\n    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int typeView) {\n        if (typeView == 0) {\n            final View view = LayoutInflater.from(context).inflate(sectionResourceId, parent, false);\n            return new SectionViewHolder(view, textResourceId);\n        } else {", "refactored_code": "    private static final int SECTION_TYPE = 0;\n\n    @Override\n    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int typeView) {\n        if (typeView == SECTION_TYPE) {\n            final View view = LayoutInflater.from(context).inflate(sectionResourceId, parent, false);\n            return new SectionViewHolder(view, textResourceId);\n        } else {"}
{"magic_number_smell": "        // Make sure that the Tab Strips fills this View\n        setFillViewport(true);\n\n        mTitleOffset = (int) (24 * getResources().getDisplayMetrics().density);\n\n        mTabStrip = new SlidingTabStrip(context);\n        addView(mTabStrip, LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);", "refactored_code": "    private static final int TITLE_OFFSET_DIPS = 24;\n        // Make sure that the Tab Strips fills this View\n        setFillViewport(true);\n\n        mTitleOffset = (int) (TITLE_OFFSET_DIPS * getResources().getDisplayMetrics().density);\n\n        mTabStrip = new SlidingTabStrip(context);\n        addView(mTabStrip, LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);"}
{"magic_number_smell": "        mDefaultTabColorizer = new SimpleTabColorizer();\n        mDefaultTabColorizer.setIndicatorColors(DEFAULT_SELECTED_INDICATOR_COLOR);\n\n        mBottomBorderThickness = (int) (0 * density);\n        mBottomBorderPaint = new Paint();\n        mBottomBorderPaint.setColor(mDefaultBottomBorderColor);\n", "refactored_code": "    private static final int DEFAULT_BOTTOM_BORDER_THICKNESS_DIPS = 0;\n        mDefaultTabColorizer = new SimpleTabColorizer();\n        mDefaultTabColorizer.setIndicatorColors(DEFAULT_SELECTED_INDICATOR_COLOR);\n\n        mBottomBorderThickness = (int) (DEFAULT_BOTTOM_BORDER_THICKNESS_DIPS * density);\n        mBottomBorderPaint = new Paint();\n        mBottomBorderPaint.setColor(mDefaultBottomBorderColor);\n"}
{"magic_number_smell": "public class DateTimeUtil {\n    private static final String TAG = \"DateTimeUtil\";\n    public static final long 1000 = 1000;\n    public static final long MINUTE_IN_MILLIS = 1000 * 60;\n    public static final long HOUR_IN_MILLIS = MINUTE_IN_MILLIS * 60;\n    public static final long DAY_IN_MILLIS = HOUR_IN_MILLIS * 24;\n    public static final long WEEK_IN_MILLIS = DAY_IN_MILLIS * 7;", "refactored_code": "    public static final long SECOND_IN_MILLIS = 1000;\npublic class DateTimeUtil {\n    private static final String TAG = \"DateTimeUtil\";\n    public static final long SECOND_IN_MILLIS = 1000;\n    public static final long MINUTE_IN_MILLIS = SECOND_IN_MILLIS * 60;\n    public static final long HOUR_IN_MILLIS = MINUTE_IN_MILLIS * 60;\n    public static final long DAY_IN_MILLIS = HOUR_IN_MILLIS * 24;\n    public static final long WEEK_IN_MILLIS = DAY_IN_MILLIS * 7;"}
{"magic_number_smell": "     */\n    private class LocationRequestTimeOut extends CountDownTimer {\n        public LocationRequestTimeOut() {\n            super(8000, 1000);\n        }\n\n        @Override", "refactored_code": "    private static final long FIND_LOCATION_TIME_OUT_MILLIS = 8000;\n     */\n    private class LocationRequestTimeOut extends CountDownTimer {\n        public LocationRequestTimeOut() {\n            super(FIND_LOCATION_TIME_OUT_MILLIS, 1000);\n        }\n\n        @Override"}
{"magic_number_smell": "\n        long begin = System.currentTimeMillis();\n\n        for (int i = 0; i < 1000000; i++) {\n            defaultMirror.on(fixture).invoke().method(method).withoutArgs();\n        }\n", "refactored_code": "    private static final int BATCH_SIZE = 1000000;\n\n        long begin = System.currentTimeMillis();\n\n        for (int i = 0; i < BATCH_SIZE; i++) {\n            defaultMirror.on(fixture).invoke().method(method).withoutArgs();\n        }\n"}
{"magic_number_smell": "public class ContinuousWorkerThread extends WorkerThread {\n    private static Log mLogger = LogFactory.getLog(ContinuousWorkerThread.class);\n    private static final int 10000 = 10000;\n    long sleepTime = 10000;\n\n    public ContinuousWorkerThread(String id) {\n        super(id);", "refactored_code": "    private static final int DEFAULT_SLEEP_IN_MS = 10000;\npublic class ContinuousWorkerThread extends WorkerThread {\n    private static Log mLogger = LogFactory.getLog(ContinuousWorkerThread.class);\n    private static final int DEFAULT_SLEEP_IN_MS = 10000;\n    long sleepTime = DEFAULT_SLEEP_IN_MS;\n\n    public ContinuousWorkerThread(String id) {\n        super(id);"}
{"magic_number_smell": "     * @return the configured (or default) maximum number of ping attempts\n     */\n    public static int getMaxPingAttempts() {\n        return getIntegerProperty(MAX_PING_ATTEMPTS_PROP, 3,\n                MAX_PING_ATTEMPTS_MIN, MAX_PING_ATTEMPTS_MAX);\n    }\n", "refactored_code": "    private static final int MAX_PING_ATTEMPTS_DEFAULT = 3;\n     * @return the configured (or default) maximum number of ping attempts\n     */\n    public static int getMaxPingAttempts() {\n        return getIntegerProperty(MAX_PING_ATTEMPTS_PROP, MAX_PING_ATTEMPTS_DEFAULT,\n                MAX_PING_ATTEMPTS_MIN, MAX_PING_ATTEMPTS_MAX);\n    }\n"}
{"magic_number_smell": "                    feedRequest.getLocale(), feedRequest.getType(),\n                    feedRequest.getFormat(), null, null, null, false, true), \n                    feedRequest.getWeblog(), null, feedRequest.getWeblogCategoryName(), feedRequest.getTags(),\n                    feedRequest.getLocale(), -1, feedRequest.getPage(), WebloggerRuntimeConfig.getIntProperty(\"site.newsfeeds.defaultEntries\"));\n            this.feedRequest = feedRequest;\n        }\n        ", "refactored_code": "    private static final int DEFAULT_ENTRIES = WebloggerRuntimeConfig.getIntProperty(\"site.newsfeeds.defaultEntries\");\n                    feedRequest.getLocale(), feedRequest.getType(),\n                    feedRequest.getFormat(), null, null, null, false, true), \n                    feedRequest.getWeblog(), null, feedRequest.getWeblogCategoryName(), feedRequest.getTags(),\n                    feedRequest.getLocale(), -1, feedRequest.getPage(), DEFAULT_ENTRIES);\n            this.feedRequest = feedRequest;\n        }\n        "}
{"magic_number_smell": "\t\t\t\tsearchRequest.getWeblogCategoryName(),\n\t\t\t\tsearchRequest.getLocale(),\n\t\t\t\tsearchRequest.getPageNum(),\n\t\t\t\t10,\n\t\t\t\turlStrategy\n\t\t\t);\n\t\t\thits = searchResultList.getResults().size();", "refactored_code": "\tpublic static final int RESULTS_PER_PAGE = 10;\n\t\t\t\tsearchRequest.getWeblogCategoryName(),\n\t\t\t\tsearchRequest.getLocale(),\n\t\t\t\tsearchRequest.getPageNum(),\n\t\t\t\tRESULTS_PER_PAGE,\n\t\t\t\turlStrategy\n\t\t\t);\n\t\t\thits = searchResultList.getResults().size();"}
{"magic_number_smell": "            csc.setEndDate(getBean().getEndDate());\n            csc.setStatus(getBean().getStatus());\n            csc.setReverseChrono(true);\n            csc.setOffset(getBean().getPage() * 30);\n            csc.setMaxResults(30+1);\n\n            List<WeblogEntryComment> rawComments = wmgr.getComments(csc);", "refactored_code": "    private static final int COUNT = 30;\n            csc.setEndDate(getBean().getEndDate());\n            csc.setStatus(getBean().getStatus());\n            csc.setReverseChrono(true);\n            csc.setOffset(getBean().getPage() * COUNT);\n            csc.setMaxResults(COUNT+1);\n\n            List<WeblogEntryComment> rawComments = wmgr.getComments(csc);"}
{"magic_number_smell": "    \n    // only write files out that are below this threshold\n    private static final long 4 = 4;\n    private static final long WRITE_THRESHOLD = 4 * 1024000;\n\n    // uploaded opml file\n    private File opmlFile = null;", "refactored_code": "    private static final long WRITE_THRESHOLD_IN_MB = 4;\n    \n    // only write files out that are below this threshold\n    private static final long WRITE_THRESHOLD_IN_MB = 4;\n    private static final long WRITE_THRESHOLD = WRITE_THRESHOLD_IN_MB * 1024000;\n\n    // uploaded opml file\n    private File opmlFile = null;"}
{"magic_number_smell": "            wesc.setStatus(\"ALL\".equals(status) ? null : WeblogEntry.PubStatus.valueOf(status));\n            wesc.setText(getBean().getText());\n            wesc.setSortBy(getBean().getSortBy());\n            wesc.setOffset(getBean().getPage() * 30);\n            wesc.setMaxResults(30 + 1);\n            List<WeblogEntry> rawEntries = wmgr.getWeblogEntries(wesc);\n            entries = new ArrayList<>();", "refactored_code": "    private static final int COUNT = 30;\n            wesc.setStatus(\"ALL\".equals(status) ? null : WeblogEntry.PubStatus.valueOf(status));\n            wesc.setText(getBean().getText());\n            wesc.setSortBy(getBean().getSortBy());\n            wesc.setOffset(getBean().getPage() * COUNT);\n            wesc.setMaxResults(COUNT + 1);\n            List<WeblogEntry> rawEntries = wmgr.getWeblogEntries(wesc);\n            entries = new ArrayList<>();"}
{"magic_number_smell": "            dataHolder.setTags(Arrays.asList(this.tags.split(\" \")));\n        }\n\n        dataHolder.setStartIndex(pageNum * 10);\n\n        // set length to fetch to one more than what is required.\n        // this would help us determine whether there are more pages", "refactored_code": "    public static final int PAGE_SIZE = 10;\n            dataHolder.setTags(Arrays.asList(this.tags.split(\" \")));\n        }\n\n        dataHolder.setStartIndex(pageNum * PAGE_SIZE);\n\n        // set length to fetch to one more than what is required.\n        // this would help us determine whether there are more pages"}
{"magic_number_smell": "            mExcerpt = sb.toString().substring(mStart, mEnd);\n            mExcerpt = Utilities.removeHTML(mExcerpt);\n\n            if (mExcerpt.length() > 500) {\n                mExcerpt = mExcerpt.substring(0, 500) + \"...\";\n            }\n        }", "refactored_code": "    private static final int MAX_EXCERPT_CHARS = 500;\n            mExcerpt = sb.toString().substring(mStart, mEnd);\n            mExcerpt = Utilities.removeHTML(mExcerpt);\n\n            if (mExcerpt.length() > MAX_EXCERPT_CHARS) {\n                mExcerpt = mExcerpt.substring(0, MAX_EXCERPT_CHARS) + \"...\";\n            }\n        }"}
{"magic_number_smell": "            }\n        } catch (MalformedURLException mfue) {\n            LOG.debug(\"Malformed MediaCast url: \" + url);\n            throw new MediacastException(1, \"weblogEdit.mediaCastUrlMalformed\", mfue);\n        } catch (Exception e) {\n            LOG.error(\"ERROR while checking MediaCast URL: \" + url + \": \" + e.getMessage());\n            throw new MediacastException(CHECK_FAILED, \"weblogEdit.mediaCastFailedFetchingInfo\", e);", "refactored_code": "    public static final int BAD_URL = 1;\n            }\n        } catch (MalformedURLException mfue) {\n            LOG.debug(\"Malformed MediaCast url: \" + url);\n            throw new MediacastException(BAD_URL, \"weblogEdit.mediaCastUrlMalformed\", mfue);\n        } catch (Exception e) {\n            LOG.error(\"ERROR while checking MediaCast URL: \" + url + \": \" + e.getMessage());\n            throw new MediacastException(CHECK_FAILED, \"weblogEdit.mediaCastFailedFetchingInfo\", e);"}
{"magic_number_smell": "        String[] pathInfo = StringUtils.split(areq.getPathInfo(),\"/\");\n        try {\n            int start = 0;\n            int max = 20;\n            if (pathInfo.length > 2) {\n                try {\n                    String s = pathInfo[2].trim();", "refactored_code": "    private static final int MAX_ENTRIES = 20;\n        String[] pathInfo = StringUtils.split(areq.getPathInfo(),\"/\");\n        try {\n            int start = 0;\n            int max = MAX_ENTRIES;\n            if (pathInfo.length > 2) {\n                try {\n                    String s = pathInfo[2].trim();"}
{"magic_number_smell": "        String[] rawPathInfo = StringUtils.split(areq.getPathInfo(),\"/\");\n        try {\n            int start = 0;\n            int max = 20;\n            String[] pathInfo = rawPathInfo;\n            if (rawPathInfo.length > 2) {\n                try {", "refactored_code": "    private static final int MAX_ENTRIES = 20;\n        String[] rawPathInfo = StringUtils.split(areq.getPathInfo(),\"/\");\n        try {\n            int start = 0;\n            int max = MAX_ENTRIES;\n            String[] pathInfo = rawPathInfo;\n            if (rawPathInfo.length > 2) {\n                try {"}
{"magic_number_smell": "                return;\n            }\n            // get tags, if site-wide then don't specify weblog\n            tags = emgr.getTags(siteWide ? null : weblog, null, prefix, page * WebloggerConfig.getIntProperty(\"services.tagdata.max\", 30), WebloggerConfig.getIntProperty(\"services.tagdata.max\", 30) + 1);\n\n        } catch (WebloggerException we) {\n            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, \"ERROR fetching tags\");", "refactored_code": "    private static final int MAX = WebloggerConfig.getIntProperty(\"services.tagdata.max\", 30);\n                return;\n            }\n            // get tags, if site-wide then don't specify weblog\n            tags = emgr.getTags(siteWide ? null : weblog, null, prefix, page * MAX, MAX + 1);\n\n        } catch (WebloggerException we) {\n            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, \"ERROR fetching tags\");"}
{"magic_number_smell": "                final ServiceLoader<LogFactory> serviceLoader = ServiceLoader.load(LogFactory.class);\n                final Iterator<LogFactory> iterator = serviceLoader.iterator();\n\n                int i = 3;\n                while (factory == null && i-- > 0) {\n                    try {\n                        if (iterator.hasNext()) {", "refactored_code": "    private static final int MAX_BROKEN_SERVICES = 3;\n                final ServiceLoader<LogFactory> serviceLoader = ServiceLoader.load(LogFactory.class);\n                final Iterator<LogFactory> iterator = serviceLoader.iterator();\n\n                int i = MAX_BROKEN_SERVICES;\n                while (factory == null && i-- > 0) {\n                    try {\n                        if (iterator.hasNext()) {"}
{"magic_number_smell": "        // If the user provides a name that is in the right package, and gets\n        // the first 5 characters of the adapter class right (ignoring case),\n        // then suggest the candidate adapter class name.\n        if (name.regionMatches(true, 0, candidate, 0, PKG_IMPL.length() + 5)) {\n            messageBuffer.append(\" Did you mean '\");\n            messageBuffer.append(candidate);\n            messageBuffer.append(\"'?\");", "refactored_code": "    private static final int PKG_LEN = PKG_IMPL.length();\n        // If the user provides a name that is in the right package, and gets\n        // the first 5 characters of the adapter class right (ignoring case),\n        // then suggest the candidate adapter class name.\n        if (name.regionMatches(true, 0, candidate, 0, PKG_LEN + 5)) {\n            messageBuffer.append(\" Did you mean '\");\n            messageBuffer.append(candidate);\n            messageBuffer.append(\"'?\");"}
{"magic_number_smell": "        try {\n            final long start = System.currentTimeMillis();\n            while (thisClassLoaderRef.get() != null) {\n                if (System.currentTimeMillis() - start > 15_000) {\n                    fail(\"After waiting \" + 15_000 + \"ms, the weak ref still yields a non-null value.\");\n                }\n                Thread.sleep(100);", "refactored_code": "    private static final long MAX_WAIT_FOR_REF_NULLED_BY_GC = 15_000;\n        try {\n            final long start = System.currentTimeMillis();\n            while (thisClassLoaderRef.get() != null) {\n                if (System.currentTimeMillis() - start > MAX_WAIT_FOR_REF_NULLED_BY_GC) {\n                    fail(\"After waiting \" + MAX_WAIT_FOR_REF_NULLED_BY_GC + \"ms, the weak ref still yields a non-null value.\");\n                }\n                Thread.sleep(100);"}
{"magic_number_smell": "                t[i].start();\n            }\n            for (final Thread element : t) {\n                element.join(5000);\n                if (element.isAlive()) {\n                    break; // at least one thread is stuck\n                }", "refactored_code": "    private static final int WAIT_FOR_THREAD_COMPLETION = 5000; // 5 seconds\n                t[i].start();\n            }\n            for (final Thread element : t) {\n                element.join(WAIT_FOR_THREAD_COMPLETION);\n                if (element.isAlive()) {\n                    break; // at least one thread is stuck\n                }"}
{"magic_number_smell": "        camera.save();\n        float time;\n        switch (mAction) {\n            case 0:\n                if (mRealTurn) {\n                    time = interpolatedTime >= 0.5f ? (interpolatedTime - 1.0f) : interpolatedTime;\n                } else {", "refactored_code": "    public static final int ANIMATION_TURN = 0;\n        camera.save();\n        float time;\n        switch (mAction) {\n            case ANIMATION_TURN:\n                if (mRealTurn) {\n                    time = interpolatedTime >= 0.5f ? (interpolatedTime - 1.0f) : interpolatedTime;\n                } else {"}
{"magic_number_smell": "    public static Animation slide(int type, int duration, int offset) {\n        Animation animation;\n        switch (type) {\n            case 0:\n                animation = new TranslateAnimation(Animation.RELATIVE_TO_SELF, +1.0f, Animation.RELATIVE_TO_SELF, 0.0f,\n                        Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, 0.0f);\n                animation.setInterpolator(new DecelerateInterpolator());", "refactored_code": "    public static final int SLIDE_IN_FROM_RIGHT = 0;\n    public static Animation slide(int type, int duration, int offset) {\n        Animation animation;\n        switch (type) {\n            case SLIDE_IN_FROM_RIGHT:\n                animation = new TranslateAnimation(Animation.RELATIVE_TO_SELF, +1.0f, Animation.RELATIVE_TO_SELF, 0.0f,\n                        Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, 0.0f);\n                animation.setInterpolator(new DecelerateInterpolator());"}
{"magic_number_smell": "    public void onCreate() {\n        super.onCreate();\n\n        if (isNookHdPlus() && AnkiDroidApp.android.os.Build.VERSION.SDK_INT == 15) {\n            mCompat = new CompatV15NookHdPlus();\n        } else if (isNook()) {\n            mCompat = new CompatV4();", "refactored_code": "    public static final int SDK_VERSION = android.os.Build.VERSION.SDK_INT;\n    public void onCreate() {\n        super.onCreate();\n\n        if (isNookHdPlus() && AnkiDroidApp.SDK_VERSION == 15) {\n            mCompat = new CompatV15NookHdPlus();\n        } else if (isNook()) {\n            mCompat = new CompatV4();"}
{"magic_number_smell": "            return;\n        }\n\n        if (getFreeDiscSpace(collectionFile) < collectionFile.length() + (10 * 1024 * 1024)) {\n            Log.e(AnkiDroidApp.TAG, \"performBackup: Not enough space on sd card to backup.\");\n            prefs.edit().putBoolean(\"noSpaceLeft\", true).commit();\n            return;", "refactored_code": "    public static final int MIN_FREE_SPACE = 10;\n            return;\n        }\n\n        if (getFreeDiscSpace(collectionFile) < collectionFile.length() + (MIN_FREE_SPACE * 1024 * 1024)) {\n            Log.e(AnkiDroidApp.TAG, \"performBackup: Not enough space on sd card to backup.\");\n            prefs.edit().putBoolean(\"noSpaceLeft\", true).commit();\n            return;"}
{"magic_number_smell": "                URL fileUrl;\n                fileUrl = new URL(FILE_URL);\n                URLConnection conn = fileUrl.openConnection();\n                conn.setConnectTimeout(30000);\n                conn.setReadTimeout(30000);\n                DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n                DocumentBuilder db = dbf.newDocumentBuilder();", "refactored_code": "    private static final int TIMEOUT = 30000;\n                URL fileUrl;\n                fileUrl = new URL(FILE_URL);\n                URLConnection conn = fileUrl.openConnection();\n                conn.setConnectTimeout(TIMEOUT);\n                conn.setReadTimeout(TIMEOUT);\n                DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n                DocumentBuilder db = dbf.newDocumentBuilder();"}
{"magic_number_smell": "        @Override\n        public void onClick(DialogInterface dialog, int which) {\n            switch (which) {\n                case 0:\n                    DeckTask.launchDeckTask(DeckTask.TASK_TYPE_MARK_CARD, mUpdateCardHandler, new DeckTask.TaskData(\n                            mCol.getSched(), mCol.getCard(Long.parseLong(mCards.get(mPositionInCardsList).get(\"id\"))),\n                            0));", "refactored_code": "    private static final int CONTEXT_MENU_MARK = 0;\n        @Override\n        public void onClick(DialogInterface dialog, int which) {\n            switch (which) {\n                case CONTEXT_MENU_MARK:\n                    DeckTask.launchDeckTask(DeckTask.TASK_TYPE_MARK_CARD, mUpdateCardHandler, new DeckTask.TaskData(\n                            mCol.getSched(), mCol.getCard(Long.parseLong(mCards.get(mPositionInCardsList).get(\"id\"))),\n                            0));"}
{"magic_number_smell": "\n        ((LinearLayout) findViewById(R.id.CardEditorDeckButton)).setOnClickListener(new View.OnClickListener() {\n            public void onClick(View v) {\n                showDialog(0);\n            }\n        });\n", "refactored_code": "    private static final int DIALOG_DECK_SELECT = 0;\n\n        ((LinearLayout) findViewById(R.id.CardEditorDeckButton)).setOnClickListener(new View.OnClickListener() {\n            public void onClick(View v) {\n                showDialog(DIALOG_DECK_SELECT);\n            }\n        });\n"}
{"magic_number_smell": "        this.put(title, true);\n        mSize = -1;\n        mDownloaded = 0;\n        mStatus = -1;\n        // The deck file name should match the deck title, but some characters are invalid in it,\n        // so they need to be replaced.\n        mFilename = Utils.removeInvalidDeckNameCharacters(mTitle);", "refactored_code": "    public static final int STATUS_STARTED = -1;\n        this.put(title, true);\n        mSize = -1;\n        mDownloaded = 0;\n        mStatus = STATUS_STARTED;\n        // The deck file name should match the deck title, but some characters are invalid in it,\n        // so they need to be replaced.\n        mFilename = Utils.removeInvalidDeckNameCharacters(mTitle);"}
{"magic_number_smell": "\n        Resources res = getResources();\n\n        mType = getIntent().getIntExtra(TYPE_EXTRA, 0);\n\n        setTitle(getTitleString());\n", "refactored_code": "    public static final int TYPE_ABOUT = 0;\n\n        Resources res = getResources();\n\n        mType = getIntent().getIntExtra(TYPE_EXTRA, TYPE_ABOUT);\n\n        setTitle(getTitleString());\n"}
{"magic_number_smell": "            mDictionary = Integer.parseInt(preferences.getString(\"dictionary\", Integer.toString(DICTIONARY_COLORDICT)));\n        }\n        switch (mDictionary) {\n            case 0:\n                mDictionaryAction = \"sk.baka.aedict.action.ACTION_SEARCH_EDICT\";\n                mIsDictionaryAvailable = Utils.isIntentAvailable(mContext, mDictionaryAction);\n                break;", "refactored_code": "    private static final int DICTIONARY_AEDICT = 0;\n            mDictionary = Integer.parseInt(preferences.getString(\"dictionary\", Integer.toString(DICTIONARY_COLORDICT)));\n        }\n        switch (mDictionary) {\n            case DICTIONARY_AEDICT:\n                mDictionaryAction = \"sk.baka.aedict.action.ACTION_SEARCH_EDICT\";\n                mIsDictionaryAvailable = Utils.isIntentAvailable(mContext, mDictionaryAction);\n                break;"}
{"magic_number_smell": "    private static void openDB(Context context) {\n        try {\n            mMetaDb = context.openOrCreateDatabase(DATABASE_NAME, 0, null);\n            if (mMetaDb.needUpgrade(4)) {\n                mMetaDb = upgradeDB(mMetaDb, 4);\n            }\n            Log.i(AnkiDroidApp.TAG, \"Opening MetaDB\");", "refactored_code": "    private static final int DATABASE_VERSION = 4;\n    private static void openDB(Context context) {\n        try {\n            mMetaDb = context.openOrCreateDatabase(DATABASE_NAME, 0, null);\n            if (mMetaDb.needUpgrade(DATABASE_VERSION)) {\n                mMetaDb = upgradeDB(mMetaDb, DATABASE_VERSION);\n            }\n            Log.i(AnkiDroidApp.TAG, \"Opening MetaDB\");"}
{"magic_number_smell": "                } else if (asyncModePreference.isChecked()) {\n                    lockCheckAction = true;\n                    asyncModePreference.setChecked(false);\n                    showDialog(1);\n                }\n            } else if (key.equals(\"deckPath\")) {\n                File decksDirectory = new File(AnkiDroidApp.getCurrentAnkiDroidDirectory());", "refactored_code": "    private static final int DIALOG_ASYNC = 1;\n                } else if (asyncModePreference.isChecked()) {\n                    lockCheckAction = true;\n                    asyncModePreference.setChecked(false);\n                    showDialog(DIALOG_ASYNC);\n                }\n            } else if (key.equals(\"deckPath\")) {\n                File decksDirectory = new File(AnkiDroidApp.getCurrentAnkiDroidDirectory());"}
{"magic_number_smell": "\t        realContent = realContent.replaceAll(\"\\\\<hr.*?\\\\>\", \" \");\n\t        realContent = realContent.replaceAll(\"\\\\<.*?\\\\>\", \"\");\n\t        realContent = realContent.replaceAll(\"&nbsp;\", \" \");\n\t        return Math.max(DYNAMIC_FONT_MIN_SIZE, 14\n\t                - (int) (realContent.length() / DYNAMIC_FONT_FACTOR));\n\t    }\n", "refactored_code": "    private static final int DYNAMIC_FONT_MAX_SIZE = 14;\n\t        realContent = realContent.replaceAll(\"\\\\<hr.*?\\\\>\", \" \");\n\t        realContent = realContent.replaceAll(\"\\\\<.*?\\\\>\", \"\");\n\t        realContent = realContent.replaceAll(\"&nbsp;\", \" \");\n\t        return Math.max(DYNAMIC_FONT_MIN_SIZE, DYNAMIC_FONT_MAX_SIZE\n\t                - (int) (realContent.length() / DYNAMIC_FONT_FACTOR));\n\t    }\n"}
{"magic_number_smell": "    public boolean onKeyDown(int keyCode, KeyEvent event) {\n        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {\n            Log.i(AnkiDroidApp.TAG, \"Reviewer - onBackPressed()\");\n            closeReviewer(50, false);\n            return true;\n        }\n        /** Enhancement 722: Hardware buttons for scrolling, I.Z. */", "refactored_code": "    public static final int RESULT_DEFAULT = 50;\n    public boolean onKeyDown(int keyCode, KeyEvent event) {\n        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {\n            Log.i(AnkiDroidApp.TAG, \"Reviewer - onBackPressed()\");\n            closeReviewer(RESULT_DEFAULT, false);\n            return true;\n        }\n        /** Enhancement 722: Hardware buttons for scrolling, I.Z. */"}
{"magic_number_smell": "\n    @Override\n    public int getProgress() {\n        if (mStatus == 5 || mStatus == STATUS_PAUSED) {\n            if (mNumTotalCards > 0) {\n                return (int) (((float) mNumUpdatedCards / mNumTotalCards) * 100);\n            } else {", "refactored_code": "    public static final int STATUS_UPDATING = 5;\n\n    @Override\n    public int getProgress() {\n        if (mStatus == STATUS_UPDATING || mStatus == STATUS_PAUSED) {\n            if (mNumTotalCards > 0) {\n                return (int) (((float) mNumUpdatedCards / mNumTotalCards) * 100);\n            } else {"}
{"magic_number_smell": "    \tmInvalidateMenu = false;\n        UIUtils.addMenuItemInActionBar(menu, Menu.NONE, MENU_NIGHT, Menu.NONE, R.string.night_mode,\n                icon);\n        UIUtils.addMenuItem(menu, Menu.NONE, 201, Menu.NONE, R.string.menu_preferences,\n                R.drawable.ic_menu_preferences);\n        UIUtils.addMenuItem(menu, Menu.NONE, MENU_ROTATE, Menu.NONE, R.string.menu_rotate,\n                android.R.drawable.ic_menu_always_landscape_portrait);", "refactored_code": "    private static final int MENU_PREFERENCES = 201;\n    \tmInvalidateMenu = false;\n        UIUtils.addMenuItemInActionBar(menu, Menu.NONE, MENU_NIGHT, Menu.NONE, R.string.night_mode,\n                icon);\n        UIUtils.addMenuItem(menu, Menu.NONE, MENU_PREFERENCES, Menu.NONE, R.string.menu_preferences,\n                R.drawable.ic_menu_preferences);\n        UIUtils.addMenuItem(menu, Menu.NONE, MENU_ROTATE, Menu.NONE, R.string.menu_rotate,\n                android.R.drawable.ic_menu_always_landscape_portrait);"}
{"magic_number_smell": "    private void touchMove(float x, float y) {\n        float dx = Math.abs(x - mX);\n        float dy = Math.abs(y - mY);\n        if (dx >= 4 || dy >= 4) {\n            mPath.quadTo(mX, mY, (x + mX) / 2, (y + mY) / 2);\n            mX = x;\n            mY = y;", "refactored_code": "    private static final float TOUCH_TOLERANCE = 4;\n    private void touchMove(float x, float y) {\n        float dx = Math.abs(x - mX);\n        float dy = Math.abs(y - mY);\n        if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {\n            mPath.quadTo(mX, mY, (x + mX) / 2, (y + mY) / 2);\n            mX = x;\n            mY = y;"}
{"magic_number_smell": "            @Override\n            public void onClick(View v) {\n                Intent i = new Intent(Intent.ACTION_PICK, android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI);\n                mActivity.startActivityForResult(i, 1);\n            }\n        });\n", "refactored_code": "    protected static final int ACTIVITY_SELECT_IMAGE = 1;\n            @Override\n            public void onClick(View v) {\n                Intent i = new Intent(Intent.ACTION_PICK, android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_URI);\n                mActivity.startActivityForResult(i, ACTIVITY_SELECT_IMAGE);\n            }\n        });\n"}
{"magic_number_smell": "     */\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        if (requestCode == 101 && resultCode == Activity.RESULT_OK) {\n            // Translation returned.\n            try {\n                String translation = data.getExtras().get(TranslationActivity.EXTRA_TRANSLATION).toString();", "refactored_code": "    private static final int REQUEST_CODE_TRANSLATE_GLOSBE = 101;\n     */\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, Intent data) {\n        if (requestCode == REQUEST_CODE_TRANSLATE_GLOSBE && resultCode == Activity.RESULT_OK) {\n            // Translation returned.\n            try {\n                String translation = data.getExtras().get(TranslationActivity.EXTRA_TRANSLATION).toString();"}
{"magic_number_smell": "                    // Size buffer according to how much of the file is left to download\n                    Log.v(AnkiDroidApp.TAG, \"Downloading... \" + download.getDownloaded());\n                    byte[] buffer;\n                    // if (size - downloaded > 1024) {\n                    buffer = new byte[1024];\n                    // } else {\n                    // buffer = new byte[size - downloaded];", "refactored_code": "    private static final int MAX_BUFFER_SIZE = 1024;\n                    // Size buffer according to how much of the file is left to download\n                    Log.v(AnkiDroidApp.TAG, \"Downloading... \" + download.getDownloaded());\n                    byte[] buffer;\n                    // if (size - downloaded > MAX_BUFFER_SIZE) {\n                    buffer = new byte[MAX_BUFFER_SIZE];\n                    // } else {\n                    // buffer = new byte[size - downloaded];"}
{"magic_number_smell": "                    PendingIntent.FLAG_UPDATE_CURRENT);\n            notification.setLatestEventInfo(appContext, contentTitle, tickerText, pendingAnkiDroidIntent);\n\n            mNotificationManager.notify(1, notification);\n        } else {\n            // Cancel the existing notification, if any.\n            mNotificationManager.cancel(1);", "refactored_code": "    private static final int WIDGET_NOTIFY_ID = 1;\n                    PendingIntent.FLAG_UPDATE_CURRENT);\n            notification.setLatestEventInfo(appContext, contentTitle, tickerText, pendingAnkiDroidIntent);\n\n            mNotificationManager.notify(WIDGET_NOTIFY_ID, notification);\n        } else {\n            // Cancel the existing notification, if any.\n            mNotificationManager.cancel(WIDGET_NOTIFY_ID);"}
{"magic_number_smell": "    }\n\n    public static Connection login(TaskListener listener, Payload data) {\n        data.taskType = 0;\n        return launchConnectionTask(listener, data);\n    }\n", "refactored_code": "    public static final int TASK_TYPE_LOGIN = 0;\n    }\n\n    public static Connection login(TaskListener listener, Payload data) {\n        data.taskType = TASK_TYPE_LOGIN;\n        return launchConnectionTask(listener, data);\n    }\n"}
{"magic_number_smell": "            Log.i(AnkiDroidApp.TAG, \"Waiting for \" + mPreviousTask.mType + \" to finish before starting \" + mType);\n\n            // Let user know if the last deck close is still performing a backup.\n            if (mType == 0 && mPreviousTask.mType == TASK_TYPE_CLOSE_DECK) {\n                publishProgress(new TaskData(AnkiDroidApp.getInstance().getBaseContext().getResources()\n                        .getString(R.string.finish_operation)));\n            }", "refactored_code": "    public static final int TASK_TYPE_OPEN_COLLECTION = 0;\n            Log.i(AnkiDroidApp.TAG, \"Waiting for \" + mPreviousTask.mType + \" to finish before starting \" + mType);\n\n            // Let user know if the last deck close is still performing a backup.\n            if (mType == TASK_TYPE_OPEN_COLLECTION && mPreviousTask.mType == TASK_TYPE_CLOSE_DECK) {\n                publishProgress(new TaskData(AnkiDroidApp.getInstance().getBaseContext().getResources()\n                        .getString(R.string.finish_operation)));\n            }"}
{"magic_number_smell": "    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        MenuItem item;\n        item = menu.add(Menu.NONE, 0, Menu.NONE, R.string.statistics_fullscreen);\n        item.setIcon(R.drawable.ic_menu_manage);\n        return true;\n    }", "refactored_code": "    private static final int MENU_FULLSCREEN = 0;\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        MenuItem item;\n        item = menu.add(Menu.NONE, MENU_FULLSCREEN, Menu.NONE, R.string.statistics_fullscreen);\n        item.setIcon(R.drawable.ic_menu_manage);\n        return true;\n    }"}
{"magic_number_smell": "    public Pair<File, List<String>> zipAdded() {\n        File f = new File(mCol.getPath().replaceFirst(\"collection\\\\.anki2$\", \"tmpSyncToServer.zip\"));\n\n        String sql = \"select fname from log where type = \" + Integer.toString(0);\n        List<String> filenames = mMediaDb.queryColumn(String.class, sql, 0);\n        List<String> fnames = new ArrayList<String>();\n", "refactored_code": "    public static final int MEDIA_ADD = 0;\n    public Pair<File, List<String>> zipAdded() {\n        File f = new File(mCol.getPath().replaceFirst(\"collection\\\\.anki2$\", \"tmpSyncToServer.zip\"));\n\n        String sql = \"select fname from log where type = \" + Integer.toString(MEDIA_ADD);\n        List<String> filenames = mMediaDb.queryColumn(String.class, sql, 0);\n        List<String> fnames = new ArrayList<String>();\n"}
{"magic_number_smell": "\n    private void _updateNewCardRatio() {\n        try {\n            if (mCol.getConf().getInt(\"newSpread\") == 0) {\n                if (mNewCount != 0) {\n                    mNewCardModulus = (mNewCount + mRevCount) / mNewCount;\n                    // if there are cards to review, ensure modulo >= 2", "refactored_code": "    public static final int NEW_CARDS_DISTRIBUTE = 0;\n\n    private void _updateNewCardRatio() {\n        try {\n            if (mCol.getConf().getInt(\"newSpread\") == NEW_CARDS_DISTRIBUTE) {\n                if (mNewCount != 0) {\n                    mNewCardModulus = (mNewCount + mRevCount) / mNewCount;\n                    // if there are cards to review, ensure modulo >= 2"}
{"magic_number_smell": "        int end = 0;\n        int chunk = 0;\n        switch (type) {\n            case 0:\n                end = 31;\n                chunk = 1;\n                break;", "refactored_code": "    public static final int TYPE_MONTH = 0;\n        int end = 0;\n        int chunk = 0;\n        switch (type) {\n            case TYPE_MONTH:\n                end = 31;\n                chunk = 1;\n                break;"}
{"magic_number_smell": "        OutputStream output = new BufferedOutputStream(new FileOutputStream(destination));\n\n        // Transfer bytes, from source to destination.\n        byte[] buf = new byte[32768];\n        long sizeBytes = 0;\n        int len;\n        if (source == null) {", "refactored_code": "    public static final int CHUNK_SIZE = 32768;\n        OutputStream output = new BufferedOutputStream(new FileOutputStream(destination));\n\n        // Transfer bytes, from source to destination.\n        byte[] buf = new byte[CHUNK_SIZE];\n        long sizeBytes = 0;\n        int len;\n        if (source == null) {"}
{"magic_number_smell": "            \t\tadd.add(note);\n            \t\tdirty.add((Long) note[0]);\n            \t\t// note we have the added guid\n            \t\tmNotes.put((String) note[1], new Object[]{note[0], note[3], note[MID]});\n            \t} else {\n            \t\tdupes += 1;\n//            \t\t// update existing note - not yet tested; for post 2.0", "refactored_code": "    private static final int GUID = 1;\n            \t\tadd.add(note);\n            \t\tdirty.add((Long) note[0]);\n            \t\t// note we have the added guid\n            \t\tmNotes.put((String) note[GUID], new Object[]{note[0], note[3], note[MID]});\n            \t} else {\n            \t\tdupes += 1;\n//            \t\t// update existing note - not yet tested; for post 2.0"}
{"magic_number_smell": "    }\n    mChart.draw(canvas, left, top, width, height, mPaint);\n    if (mRenderer != null && mRenderer.isZoomEnabled() && mRenderer.isZoomButtonsVisible()) {\n      mPaint.setColor(Color.argb(175, 150, 150, 150));\n      zoomSize = Math.max(zoomSize, Math.min(width, height) / 7);\n      mZoomR.set(left + width - zoomSize * 3, top + height - zoomSize * 0.775f, left + width, top\n          + height);", "refactored_code": "  private static final int ZOOM_BUTTONS_COLOR = Color.argb(175, 150, 150, 150);\n    }\n    mChart.draw(canvas, left, top, width, height, mPaint);\n    if (mRenderer != null && mRenderer.isZoomEnabled() && mRenderer.isZoomButtonsVisible()) {\n      mPaint.setColor(ZOOM_BUTTONS_COLOR);\n      zoomSize = Math.max(zoomSize, Math.min(width, height) / 7);\n      mZoomR.set(left + width - zoomSize * 3, top + height - zoomSize * 0.775f, left + width, top\n          + height);"}
{"magic_number_smell": "   * @return the legend shape width\n   */\n  public int getLegendShapeWidth(int seriesIndex) {\n    return 12;\n  }\n\n  /**", "refactored_code": "  private static final int SHAPE_WIDTH = 12;\n   * @return the legend shape width\n   */\n  public int getLegendShapeWidth(int seriesIndex) {\n    return SHAPE_WIDTH;\n  }\n\n  /**"}
{"magic_number_smell": "   * @return the legend shape width\n   */\n  public int getLegendShapeWidth(int seriesIndex) {\n    return 10;\n  }\n\n  /**", "refactored_code": "  private static final int SHAPE_WIDTH = 10;\n   * @return the legend shape width\n   */\n  public int getLegendShapeWidth(int seriesIndex) {\n    return SHAPE_WIDTH;\n  }\n\n  /**"}
{"magic_number_smell": "  private void drawNeedle(Canvas canvas, double angle, int centerX, int centerY, double radius,\n      boolean arrow, Paint paint) {\n    double diff = Math.toRadians(90);\n    int needleSinValue = (int) (10 * Math.sin(angle - diff));\n    int needleCosValue = (int) (10 * Math.cos(angle - diff));\n    int needleX = (int) (radius * Math.sin(angle));\n    int needleY = (int) (radius * Math.cos(angle));", "refactored_code": "  private static final int NEEDLE_RADIUS = 10;\n  private void drawNeedle(Canvas canvas, double angle, int centerX, int centerY, double radius,\n      boolean arrow, Paint paint) {\n    double diff = Math.toRadians(90);\n    int needleSinValue = (int) (NEEDLE_RADIUS * Math.sin(angle - diff));\n    int needleCosValue = (int) (NEEDLE_RADIUS * Math.cos(angle - diff));\n    int needleX = (int) (radius * Math.sin(angle));\n    int needleY = (int) (radius * Math.cos(angle));"}
{"magic_number_smell": "   * @return the legend shape width\n   */\n  public int getLegendShapeWidth(int seriesIndex) {\n    return 30;\n  }\n\n  /**", "refactored_code": "  private static final int SHAPE_WIDTH = 30;\n   * @return the legend shape width\n   */\n  public int getLegendShapeWidth(int seriesIndex) {\n    return SHAPE_WIDTH;\n  }\n\n  /**"}
{"magic_number_smell": "   * @return the legend shape width\n   */\n  public int getLegendShapeWidth(int seriesIndex) {\n    return 10;\n  }\n\n  /**", "refactored_code": "  protected static final int SHAPE_WIDTH = 10;\n   * @return the legend shape width\n   */\n  public int getLegendShapeWidth(int seriesIndex) {\n    return SHAPE_WIDTH;\n  }\n\n  /**"}
{"magic_number_smell": "  /** The legend shape width. */\n  private static final int SHAPE_WIDTH = 10;\n  /** The point shape size. */\n  private float size = 3;\n\n  ScatterChart() {\n  }", "refactored_code": "  private static final float SIZE = 3;\n  /** The legend shape width. */\n  private static final int SHAPE_WIDTH = 10;\n  /** The point shape size. */\n  private float size = SIZE;\n\n  ScatterChart() {\n  }"}
{"magic_number_smell": "    }\n    DateFormat format = SimpleDateFormat.getDateInstance(SimpleDateFormat.MEDIUM);\n    double diff = end - start;\n    if (diff > 24 * 60 * 60 * 1000 && diff < 5 * 24 * 60 * 60 * 1000) {\n      format = SimpleDateFormat.getDateTimeInstance(SimpleDateFormat.SHORT, SimpleDateFormat.SHORT);\n    } else if (diff < 24 * 60 * 60 * 1000) {\n      format = SimpleDateFormat.getTimeInstance(SimpleDateFormat.MEDIUM);", "refactored_code": "  public static final long DAY = 24 * 60 * 60 * 1000;\n    }\n    DateFormat format = SimpleDateFormat.getDateInstance(SimpleDateFormat.MEDIUM);\n    double diff = end - start;\n    if (diff > DAY && diff < 5 * DAY) {\n      format = SimpleDateFormat.getDateTimeInstance(SimpleDateFormat.SHORT, SimpleDateFormat.SHORT);\n    } else if (diff < DAY) {\n      format = SimpleDateFormat.getTimeInstance(SimpleDateFormat.MEDIUM);"}
{"magic_number_smell": "     */\n    public class InstanceCellRenderer extends DefaultTableCellRenderer {\n        \n        private static final long 1L = 1L;\n        private final PersistenceUnitUtil util;\n\n        public InstanceCellRenderer(PersistenceUnitUtil util) {", "refactored_code": "    private static final long serialVersionUID = 1L;\n     */\n    public class InstanceCellRenderer extends DefaultTableCellRenderer {\n        \n        private static final long serialVersionUID = 1L;\n        private final PersistenceUnitUtil util;\n\n        public InstanceCellRenderer(PersistenceUnitUtil util) {"}
{"magic_number_smell": "    public static int getAttributeType(Attribute<?, ?> a) {\n        if (a instanceof SingularAttribute) {\n            SingularAttribute<?, ?> sa = (SingularAttribute<?, ?>)a;\n            if (sa.isId()) return 0;\n            if (sa.isVersion()) return ATTR_VERSION;\n            if (sa.isAssociation()) return ATTR_SINGULAR_RELATION;\n            if (sa.isCollection()) return ATTR_PLURAL_RELATION;", "refactored_code": "    public static final int ATTR_ID      = 0;\n    public static int getAttributeType(Attribute<?, ?> a) {\n        if (a instanceof SingularAttribute) {\n            SingularAttribute<?, ?> sa = (SingularAttribute<?, ?>)a;\n            if (sa.isId()) return ATTR_ID;\n            if (sa.isVersion()) return ATTR_VERSION;\n            if (sa.isAssociation()) return ATTR_SINGULAR_RELATION;\n            if (sa.isCollection()) return ATTR_PLURAL_RELATION;"}
{"magic_number_smell": "     */\n    class SearchPanel extends JPanel implements ActionListener {\n        \n        private static final long 1L = 1L;\n        private final JTextField _title       = new JTextField(\"\", 20);\n        private final JTextField _author      = new JTextField(\"\", 20);\n        private final JTextField _maxPrice    = new JTextField(\"\", 6);", "refactored_code": "    private static final long serialVersionUID = 1L;\n     */\n    class SearchPanel extends JPanel implements ActionListener {\n        \n        private static final long serialVersionUID = 1L;\n        private final JTextField _title       = new JTextField(\"\", 20);\n        private final JTextField _author      = new JTextField(\"\", 20);\n        private final JTextField _maxPrice    = new JTextField(\"\", 6);"}
{"magic_number_smell": "     */\n    public abstract class OpenBookAction extends AbstractAction {\n        \n        private static final long 1L = 1L;\n\n        public OpenBookAction(String name, Icon icon, String tooltip) {\n            putValue(Action.NAME, name);", "refactored_code": "    private static final long serialVersionUID = 1L;\n     */\n    public abstract class OpenBookAction extends AbstractAction {\n        \n        private static final long serialVersionUID = 1L;\n\n        public OpenBookAction(String name, Icon icon, String tooltip) {\n            putValue(Action.NAME, name);"}
{"magic_number_smell": "     */\n    public static class LineItemId implements Serializable {\n        \n        private static final long 1L = 1L;\n        long order;\n        int index;\n", "refactored_code": "    private static final long serialVersionUID = 1L;\n     */\n    public static class LineItemId implements Serializable {\n        \n        private static final long serialVersionUID = 1L;\n        long order;\n        int index;\n"}
{"magic_number_smell": "    }\n    // $ANTLR end \"T__28\"\n\n    // $ANTLR start \"29\"\n    public final void mT__29() throws RecognitionException {\n        try {\n            int _type = 29;", "refactored_code": "    public static final int T__29=29;\n    }\n    // $ANTLR end \"T__28\"\n\n    // $ANTLR start \"T__29\"\n    public final void mT__29() throws RecognitionException {\n        try {\n            int _type = T__29;"}
{"magic_number_smell": "        bar.setCellPadding(0);\n        bar.setWidget(0, 0, header);\n        header.addStyleName(\"progressMonitor-caption\");\n        for (int i = 0; i < 10; i++) {\n            Label box = new Label();\n            box.setSize(\"30px\", \"20px\");\n            DOM.setStyleAttribute(box.getElement(), \"backgroundColor\", \"black\");", "refactored_code": "    private final int N = 10;\n        bar.setCellPadding(0);\n        bar.setWidget(0, 0, header);\n        header.addStyleName(\"progressMonitor-caption\");\n        for (int i = 0; i < N; i++) {\n            Label box = new Label();\n            box.setSize(\"30px\", \"20px\");\n            DOM.setStyleAttribute(box.getElement(), \"backgroundColor\", \"black\");"}
{"magic_number_smell": "            if (rng.nextDouble() < 0.25) {\n                Stock stock = stocks.get(i);\n                double oldPrice = stock.getMarketPrice();\n                double delta = (rng.nextDouble() - 0.5) * 10;\n                double newPrice = Math.max(oldPrice + delta, 0.01);\n                stock.setMarketPrice(newPrice);\n            }", "refactored_code": "    private static final int MAX_CHANGE = 10;\n            if (rng.nextDouble() < 0.25) {\n                Stock stock = stocks.get(i);\n                double oldPrice = stock.getMarketPrice();\n                double delta = (rng.nextDouble() - 0.5) * MAX_CHANGE;\n                double newPrice = Math.max(oldPrice + delta, 0.01);\n                stock.setMarketPrice(newPrice);\n            }"}
{"magic_number_smell": "        tradeDB.setup(TradeConfig.getMAX_QUOTES(), TradeConfig.getMAX_USERS());\n        // perform some operations per user\n        TradeScenario scenario = new TradeScenario(trade);\n        log.info(\"TestDaytrader.testTrade() calling TradeScenario.performUserTasks(\" + 500 + \")\");\n        for (int i = 0; i < 500; i++) {\n            String userID = \"uid:\" + i;\n            if (!scenario.performUserTasks(userID)) {", "refactored_code": "    private static final int TEST_USERS = 500;\n        tradeDB.setup(TradeConfig.getMAX_QUOTES(), TradeConfig.getMAX_USERS());\n        // perform some operations per user\n        TradeScenario scenario = new TradeScenario(trade);\n        log.info(\"TestDaytrader.testTrade() calling TradeScenario.performUserTasks(\" + TEST_USERS + \")\");\n        for (int i = 0; i < TEST_USERS; i++) {\n            String userID = \"uid:\" + i;\n            if (!scenario.performUserTasks(userID)) {"}
{"magic_number_smell": "\n        public void execute(JDBCStore store) throws SQLException {\n            switch (_action) {\n            case 0:\n                _strat.customInsert(_sm, store);\n                break;\n            case UPDATE:", "refactored_code": "        public static final int INSERT = 0;\n\n        public void execute(JDBCStore store) throws SQLException {\n            switch (_action) {\n            case INSERT:\n                _strat.customInsert(_sm, store);\n                break;\n            case UPDATE:"}
{"magic_number_smell": "     */\n    protected static class JDBCConfigurationState implements Serializable {\n        \n        private static final long 1L = 1L;\n        public int eagerMode = 0;\n        public int subclassMode = 0;\n        public int type = 0;", "refactored_code": "    private static final long serialVersionUID = 1L;\n     */\n    protected static class JDBCConfigurationState implements Serializable {\n        \n        private static final long serialVersionUID = 1L;\n        public int eagerMode = 0;\n        public int subclassMode = 0;\n        public int type = 0;"}
{"magic_number_smell": "        // locking, but we don't necessarily have a read or write lock\n        // according to our superclass\n        if (getLockLevel(sm) == LOCK_NONE)\n            setLockLevel(sm, 1);\n    }\n\n    @Override", "refactored_code": "    public static final int LOCK_DATASTORE_ONLY = 1;\n        // locking, but we don't necessarily have a read or write lock\n        // according to our superclass\n        if (getLockLevel(sm) == LOCK_NONE)\n            setLockLevel(sm, LOCK_DATASTORE_ONLY);\n    }\n\n    @Override"}
{"magic_number_smell": "        implements Serializable {\n\n        \n        private static final long 1L = 1L;\n        public static final int GET = 0;\n        public static final int GET_OUTER = 1;\n        public static final int GET_KEY = 2;", "refactored_code": "    private static final long serialVersionUID = 1L;\n        implements Serializable {\n\n        \n        private static final long serialVersionUID = 1L;\n        public static final int GET = 0;\n        public static final int GET_OUTER = 1;\n        public static final int GET_KEY = 2;"}
{"magic_number_smell": "        else if (getUniqueForeignKey(table) != null)\n            type = TABLE_SECONDARY;\n        else if (fks.length == 1)\n            type = 0;\n        else\n            type = -1;\n", "refactored_code": "    public static final int TABLE_NONE = 0;\n        else if (getUniqueForeignKey(table) != null)\n            type = TABLE_SECONDARY;\n        else if (fks.length == 1)\n            type = TABLE_NONE;\n        else\n            type = -1;\n"}
{"magic_number_smell": "    private static final long 1L = 1L;\n\n    public static final ColumnIO UNRESTRICTED = new ColumnIO() {\n        private static final long 1L = 1L;\n\n        @Override\n        public void setInsertable(int col, boolean insertable) {", "refactored_code": "    private static final long serialVersionUID = 1L;\n    private static final long serialVersionUID = 1L;\n\n    public static final ColumnIO UNRESTRICTED = new ColumnIO() {\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public void setInsertable(int col, boolean insertable) {"}
{"magic_number_smell": "        extends Table {\n\n        \n        private static final long 1L = 1L;\n\n        public DynamicTable(String name, Schema schema) {\n            super(name, schema);", "refactored_code": "    private static final long serialVersionUID = 1L;\n        extends Table {\n\n        \n        private static final long serialVersionUID = 1L;\n\n        public DynamicTable(String name, Schema schema) {\n            super(name, schema);"}
{"magic_number_smell": "\n        if (versionLaterThan(0)) {\n            if (isDB2ISeriesV5R3OrEarlier())\n                db2ServerType = 1;\n            else if (isDB2ISeriesV5R4OrLater())\n                db2ServerType = db2ISeriesV5R4OrLater;\n        }", "refactored_code": "    public static final int db2ISeriesV5R3OrEarlier = 1;\n\n        if (versionLaterThan(0)) {\n            if (isDB2ISeriesV5R3OrEarlier())\n                db2ServerType = db2ISeriesV5R3OrEarlier;\n            else if (isDB2ISeriesV5R4OrLater())\n                db2ServerType = db2ISeriesV5R4OrLater;\n        }"}
{"magic_number_smell": "    public boolean supportsHaving = true;\n    public boolean supportsSelectStartIndex = false;\n    public boolean supportsSelectEndIndex = false;\n    public int rangePosition = 0;\n    public boolean requiresAliasForSubselect = false;\n    public boolean requiresTargetForDelete = false;\n    public boolean allowsAliasInBulkClause = true;", "refactored_code": "    protected static final int RANGE_POST_SELECT   = 0;\n    public boolean supportsHaving = true;\n    public boolean supportsSelectStartIndex = false;\n    public boolean supportsSelectEndIndex = false;\n    public int rangePosition = RANGE_POST_SELECT;\n    public boolean requiresAliasForSubselect = false;\n    public boolean requiresTargetForDelete = false;\n    public boolean allowsAliasInBulkClause = true;"}
{"magic_number_smell": "            crossJoinClause = \"JOIN\";\n            requiresConditionForCrossJoin = true;\n        }\n        if (firebirdVersion == 15) {\n            stringLengthFunction = \"STRLEN({0})\";\n            trimLeadingFunction = \"LTRIM({0})\";\n            trimTrailingFunction = \"RTRIM({0})\";", "refactored_code": "    public static final int FB_VERSION_15 = 15;\n            crossJoinClause = \"JOIN\";\n            requiresConditionForCrossJoin = true;\n        }\n        if (firebirdVersion == FB_VERSION_15) {\n            stringLengthFunction = \"STRLEN({0})\";\n            trimLeadingFunction = \"LTRIM({0})\";\n            trimTrailingFunction = \"RTRIM({0})\";"}
{"magic_number_smell": "    public static final int TYPE_OUTER = 1;\n    public static final int TYPE_CROSS = 2;\n\n    private int _type = 0;\n\n    private int _alias1;\n    private int _alias2;", "refactored_code": "    public static final int TYPE_INNER = 0;\n    public static final int TYPE_OUTER = 1;\n    public static final int TYPE_CROSS = 2;\n\n    private int _type = TYPE_INNER;\n\n    private int _alias1;\n    private int _alias2;"}
{"magic_number_smell": "        boolean hasValue = false;\n        for (int i = 0; i < _status.length; i++) {\n            switch (_status[i]) {\n                case 0:\n                    if (_res[i].next()) {\n                        hasValue = true;\n                        _status[i] = CURRENT;", "refactored_code": "    private static final byte NEXT = 0;\n        boolean hasValue = false;\n        for (int i = 0; i < _status.length; i++) {\n            switch (_status[i]) {\n                case NEXT:\n                    if (_res[i].next()) {\n                        hasValue = true;\n                        _status[i] = CURRENT;"}
{"magic_number_smell": "            || driverVendor.equals(VENDOR_DATADIRECT + \"31\"))\n            _driverBehavior = BEHAVE_DATADIRECT31;\n        else\n            _driverBehavior = 0;\n    }\n\n    /**", "refactored_code": "    private static final int BEHAVE_OTHER = 0;\n            || driverVendor.equals(VENDOR_DATADIRECT + \"31\"))\n            _driverBehavior = BEHAVE_DATADIRECT31;\n        else\n            _driverBehavior = BEHAVE_OTHER;\n    }\n\n    /**"}
{"magic_number_smell": "    @Override\n    public void setPrimaryKey(ColumnIO io, OpenJPAStateManager sm) {\n        _pk = sm;\n        flags |= 2 << 1;\n        _pkIO = io;\n\n        // force valid", "refactored_code": "    private static final byte PK_SET = 2 << 1;\n    @Override\n    public void setPrimaryKey(ColumnIO io, OpenJPAStateManager sm) {\n        _pk = sm;\n        flags |= PK_SET;\n        _pkIO = io;\n\n        // force valid"}
{"magic_number_smell": "\n    @Override\n    public boolean isValid() {\n        return (flags & 2 << 0) != 0;\n    }\n\n    @Override", "refactored_code": "    protected static final int VALID = 2 << 0;\n\n    @Override\n    public boolean isValid() {\n        return (flags & VALID) != 0;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    @Override\n    public boolean getAutoDistinct() {\n        return (_flags & 2 << 0) == 0;\n    }\n\n    @Override", "refactored_code": "    private static final int NONAUTO_DISTINCT = 2 << 0;\n\n    @Override\n    public boolean getAutoDistinct() {\n        return (_flags & NONAUTO_DISTINCT) == 0;\n    }\n\n    @Override"}
{"magic_number_smell": "\n    /**\n     * Whether or not JPQL extensions are allowed. Defaults to\n     * {@link #0}.\n     *\n     * @since 1.1.0\n     * @see #JPQL_WARN", "refactored_code": "    public static final int JPQL_STRICT = 0;\n\n    /**\n     * Whether or not JPQL extensions are allowed. Defaults to\n     * {@link #JPQL_STRICT}.\n     *\n     * @since 1.1.0\n     * @see #JPQL_WARN"}
{"magic_number_smell": "     */\n    public static class Default<T> implements QueryStatistics<T> {\n\n        private static final long 1L = -7889619105916307055L;\n\n        private static final int FIXED_SIZE = 1000;\n        private static final float LOAD_FACTOR = 0.75f;", "refactored_code": "    private static final long serialVersionUID = 1L;\n     */\n    public static class Default<T> implements QueryStatistics<T> {\n\n        private static final long serialVersionUID = -7889619105916307055L;\n\n        private static final int FIXED_SIZE = 1000;\n        private static final float LOAD_FACTOR = 0.75f;"}
{"magic_number_smell": "    public void doNonTransactionalWork(Runnable runnable) throws RuntimeException {\n        try {\n            UOWManager uowManager = UOWManagerFactory.getUOWManager();\n            uowManager.runUnderUOW(0, false, new DelegatingUOWAction(runnable));\n        }\n        catch(Exception e ) {\n            RuntimeException re = new RuntimeException(e.getMessage(), e);", "refactored_code": "    private static final int WEBSPHERE_UOW_TYPE_LOCAL_TRANSACTION = 0;\n    public void doNonTransactionalWork(Runnable runnable) throws RuntimeException {\n        try {\n            UOWManager uowManager = UOWManagerFactory.getUOWManager();\n            uowManager.runUnderUOW(WEBSPHERE_UOW_TYPE_LOCAL_TRANSACTION, false, new DelegatingUOWAction(runnable));\n        }\n        catch(Exception e ) {\n            RuntimeException re = new RuntimeException(e.getMessage(), e);"}
{"magic_number_smell": "     * Return the policy constant for how to create type methods.\n     */\n    protected int getCreateFieldMethods(int type) {\n        return 0;\n    }\n\n    /**", "refactored_code": "    protected static final int POLICY_EXCEPTION = 0;\n     * Return the policy constant for how to create type methods.\n     */\n    protected int getCreateFieldMethods(int type) {\n        return POLICY_EXCEPTION;\n    }\n\n    /**"}
{"magic_number_smell": "        try {\n            // if enum, skip, no need of any meta\n            if ((managedType.getClassNode().access & Opcodes.ACC_ENUM) > 0) {\n                return 0;\n            }\n\n            // if managed interface, skip", "refactored_code": "    public static final int ENHANCE_NONE = 0;\n        try {\n            // if enum, skip, no need of any meta\n            if ((managedType.getClassNode().access & Opcodes.ACC_ENUM) > 0) {\n                return ENHANCE_NONE;\n            }\n\n            // if managed interface, skip"}
{"magic_number_smell": "    public static class ListenerList extends ArrayList<Object> {\n\n        \n        private static final long 1L = 1L;\n        private int _types = 0;\n\n        public ListenerList(int size) {", "refactored_code": "    private static final long serialVersionUID = 1L;\n    public static class ListenerList extends ArrayList<Object> {\n\n        \n        private static final long serialVersionUID = 1L;\n        private int _types = 0;\n\n        public ListenerList(int size) {"}
{"magic_number_smell": "    private static final Localizer s_loc = Localizer.forPackage\n        (RemoteCommitEvent.class);\n\n    private int _payload = 0;\n    private Collection _addIds = null;\n    private Collection _addClasses = null;\n    private Collection _updates = null;", "refactored_code": "    public static final int PAYLOAD_OIDS = 0;\n    private static final Localizer s_loc = Localizer.forPackage\n        (RemoteCommitEvent.class);\n\n    private int _payload = PAYLOAD_OIDS;\n    private Collection _addIds = null;\n    private Collection _addClasses = null;\n    private Collection _updates = null;"}
{"magic_number_smell": "\n    private final long _id;\n    private final byte[] _localhost;\n    protected int _port = 5636;\n    private int _maxTotal = 2;\n    private int _maxIdle = 2;\n    private int _recoveryTimeMillis = 15000;", "refactored_code": "    private static final int DEFAULT_PORT = 5636;\n\n    private final long _id;\n    private final byte[] _localhost;\n    protected int _port = DEFAULT_PORT;\n    private int _maxTotal = 2;\n    private int _maxIdle = 2;\n    private int _recoveryTimeMillis = 15000;"}
{"magic_number_smell": "        CacheStatistics stats = getStatistics();\n        if (stats != null)\n            return stats.getHitCount();\n        return -1;\n    }\n\n    @Override", "refactored_code": "    public static final long NO_STATS = -1;\n        CacheStatistics stats = getStatistics();\n        if (stats != null)\n            return stats.getHitCount();\n        return NO_STATS;\n    }\n\n    @Override"}
{"magic_number_smell": "        QueryStatistics<String> stats = getStatistics();\n        if (stats != null)\n            return stats.getExecutionCount();\n        return -1;\n    }\n\n    @Override", "refactored_code": "    public static final long NO_STATS = -1;\n        QueryStatistics<String> stats = getStatistics();\n        if (stats != null)\n            return stats.getExecutionCount();\n        return NO_STATS;\n    }\n\n    @Override"}
{"magic_number_smell": "        QueryStatistics<QueryKey> stats = getStatistics();\n        if (stats != null)\n            return stats.getExecutionCount();\n        return -1;\n    }\n\n    @Override", "refactored_code": "    public static final long NO_STATS = -1;\n        QueryStatistics<QueryKey> stats = getStatistics();\n        if (stats != null)\n            return stats.getExecutionCount();\n        return NO_STATS;\n    }\n\n    @Override"}
{"magic_number_smell": "        extends ArrayList {\n\n        \n        private static final long 1L = 1L;\n\n        public static final ProxyDataList EMPTY_LIST = new ProxyDataList(0);\n", "refactored_code": "    private static final long serialVersionUID = 1L;\n        extends ArrayList {\n\n        \n        private static final long serialVersionUID = 1L;\n\n        public static final ProxyDataList EMPTY_LIST = new ProxyDataList(0);\n"}
{"magic_number_smell": "        implements Set, Serializable {\n\n        \n        private static final long 1L = 1L;\n        private final boolean _orderDirty;\n        private Set<StateManagerImpl> _dirty = null;\n        private Set<StateManagerImpl> _clean = null;", "refactored_code": "    private static final long serialVersionUID = 1L;\n        implements Set, Serializable {\n\n        \n        private static final long serialVersionUID = 1L;\n        private final boolean _orderDirty;\n        private Set<StateManagerImpl> _dirty = null;\n        private Set<StateManagerImpl> _clean = null;"}
{"magic_number_smell": "        implements Executor, Serializable {\n\n        \n        private static final long 1L = 1L;\n        private final ClassMetaData _meta;\n        private final boolean _subs;\n        private final InMemoryExpressionFactory _factory;", "refactored_code": "    private static final long serialVersionUID = 1L;\n        implements Executor, Serializable {\n\n        \n        private static final long serialVersionUID = 1L;\n        private final ClassMetaData _meta;\n        private final boolean _subs;\n        private final InMemoryExpressionFactory _factory;"}
{"magic_number_smell": "        implements Serializable\n    {\n        \n        private static final long 1L = 1L;\n        public transient StoreContext ctx = null;\n        public int fetchBatchSize = 0;\n        public int maxFetchDepth = 1;", "refactored_code": "    private static final long serialVersionUID = 1L;\n        implements Serializable\n    {\n        \n        private static final long serialVersionUID = 1L;\n        public transient StoreContext ctx = null;\n        public int fetchBatchSize = 0;\n        public int maxFetchDepth = 1;"}
{"magic_number_smell": "     * Add the given values.\n     */\n    public static Object add(Object o1, Class<?> c1, Object o2, Class<?> c2) {\n        return op(o1, c1, o2, c2, 0);\n    }\n\n    /**", "refactored_code": "    private static final int OP_ADD = 0;\n     * Add the given values.\n     */\n    public static Object add(Object o1, Class<?> c1, Object o2, Class<?> c2) {\n        return op(o1, c1, o2, c2, OP_ADD);\n    }\n\n    /**"}
{"magic_number_smell": "    public static final int ACTION_EXCEPTION = 2;\n\n    private boolean _manageLRS = false;\n    private int _action = 0;\n    private Log _log;\n\n    /**", "refactored_code": "    public static final int ACTION_MANAGE = 0;\n    public static final int ACTION_EXCEPTION = 2;\n\n    private boolean _manageLRS = false;\n    private int _action = ACTION_MANAGE;\n    private Log _log;\n\n    /**"}
{"magic_number_smell": "        implements Serializable {\n\n        \n        private static final long 1L = 1L;\n        public StoreQuery.Executor memory = null;\n        public StoreQuery.Executor datastore = null;\n        public Object storeData = null;", "refactored_code": "    private static final long serialVersionUID = 1L;\n        implements Serializable {\n\n        \n        private static final long serialVersionUID = 1L;\n        public StoreQuery.Executor memory = null;\n        public StoreQuery.Executor datastore = null;\n        public Object storeData = null;"}
{"magic_number_smell": "\t */\n\tpublic static class None<T> implements QueryStatistics<T> {\n        \n        private static final long 1L = 1L;\n        private Date start = new Date();\n        private Date since = start;\n", "refactored_code": "        private static final long serialVersionUID = 1L;\n\t */\n\tpublic static class None<T> implements QueryStatistics<T> {\n        \n        private static final long serialVersionUID = 1L;\n        private Date start = new Date();\n        private Date since = start;\n"}
{"magic_number_smell": "            var = entry.getValue();\n            if (var.getMetaData() == null && !isBound(var)\n                && !isDeclaredVariable(entry.getKey())) {\n                throw parseException(0, \"not-unbound-var\",\n                    new Object[]{ entry.getKey() }, null);\n            }\n        }", "refactored_code": "    protected static final int EX_USER = 0;\n            var = entry.getValue();\n            if (var.getMetaData() == null && !isBound(var)\n                && !isDeclaredVariable(entry.getKey())) {\n                throw parseException(EX_USER, \"not-unbound-var\",\n                    new Object[]{ entry.getKey() }, null);\n            }\n        }"}
{"magic_number_smell": "        // do a regular contains with that\n        boolean bound = isBound(var);\n        if (bound) {\n            var = getValue(aliasNode, 1);\n        } else {\n            bind(var);\n            join = and(join, factory.bindVariable(var, path));", "refactored_code": "    private static final int VAR_PATH = 1;\n        // do a regular contains with that\n        boolean bound = isBound(var);\n        if (bound) {\n            var = getValue(aliasNode, VAR_PATH);\n        } else {\n            bind(var);\n            join = and(join, factory.bindVariable(var, path));"}
{"magic_number_smell": "        implements Serializable {\n\n        \n        private static final long 1L = 1L;\n        public final String vendor;\n        public final String key;\n", "refactored_code": "    private static final long serialVersionUID = 1L;\n        implements Serializable {\n\n        \n        private static final long serialVersionUID = 1L;\n        public final String vendor;\n        public final String key;\n"}
{"magic_number_smell": "        if (type.isPrimitive()) {\n            switch (type.getName().charAt(0)) {\n                case 'b':\n                    return (type == boolean.class) ? 0 : BYTE;\n                case 'c':\n                    return CHAR;\n                case 'd':", "refactored_code": "    public static final int BOOLEAN = 0;\n        if (type.isPrimitive()) {\n            switch (type.getName().charAt(0)) {\n                case 'b':\n                    return (type == boolean.class) ? BOOLEAN : BYTE;\n                case 'c':\n                    return CHAR;\n                case 'd':"}
{"magic_number_smell": "    private static class QueryKey implements Serializable {\n\n        \n        private static final long 1L = 1L;\n        public String clsName;\n        public String name;\n", "refactored_code": "    private static final long serialVersionUID = 1L;\n    private static class QueryKey implements Serializable {\n\n        \n        private static final long serialVersionUID = 1L;\n        public String clsName;\n        public String name;\n"}
{"magic_number_smell": "     */\n    public static String getName(int strategy) {\n        switch (strategy) {\n            case 0:\n                return \"none\";\n            case IGNORE:\n                return \"ignore\";", "refactored_code": "    public static final int NONE = 0;\n     */\n    public static String getName(int strategy) {\n        switch (strategy) {\n            case NONE:\n                return \"none\";\n            case IGNORE:\n                return \"ignore\";"}
{"magic_number_smell": "    private static final TreeBidiMap _map = new TreeBidiMap();\n\n    static {\n        _map.put(\"none\", 0);\n        _map.put(\"native\", NATIVE);\n        _map.put(\"sequence\", SEQUENCE);\n        _map.put(\"autoassign\", AUTOASSIGN);", "refactored_code": "    public static final int NONE = 0;\n    private static final TreeBidiMap _map = new TreeBidiMap();\n\n    static {\n        _map.put(\"none\", NONE);\n        _map.put(\"native\", NATIVE);\n        _map.put(\"sequence\", SEQUENCE);\n        _map.put(\"autoassign\", AUTOASSIGN);"}
{"magic_number_smell": "\n        private final IteratorChain _itr;\n        private Object _last = null;\n        private int _state = 0;\n\n        public Itr(IteratorChain itr) {\n            _itr = itr;", "refactored_code": "        private static final int OPEN = 0;\n\n        private final IteratorChain _itr;\n        private Object _last = null;\n        private int _state = OPEN;\n\n        public Itr(IteratorChain itr) {\n            _itr = itr;"}
{"magic_number_smell": "\n            @Override\n            public Iterator<K> iterator() {\n                return AbstractLRSProxyMap.this.iterator(0);\n            }\n        };\n    }", "refactored_code": "    private static final int MODE_KEY = 0;\n\n            @Override\n            public Iterator<K> iterator() {\n                return AbstractLRSProxyMap.this.iterator(MODE_KEY);\n            }\n        };\n    }"}
{"magic_number_smell": "        } else {\n            cacheMap = new LRUMap(size, load) {\n                \n                private static final long 1L = 1L;\n\n                @Override\n                public void overflowRemoved(Object key, Object value) {", "refactored_code": "                private static final long serialVersionUID = 1L;\n        } else {\n            cacheMap = new LRUMap(size, load) {\n                \n                private static final long serialVersionUID = 1L;\n\n                @Override\n                public void overflowRemoved(Object key, Object value) {"}
{"magic_number_smell": "    // Valid class codes are 0 2 4 10 12 26 28\n    @Test\n    public void testValidClassCodes() {\n        isValidClassCode(true,   0, AccessCode.UNKNOWN);\n\n        isValidClassCode(true,   2, FIELD);\n        isValidClassCode(true,   4, PROPERTY);", "refactored_code": "    public static final int UNKNOWN = AccessCode.UNKNOWN;\n    // Valid class codes are 0 2 4 10 12 26 28\n    @Test\n    public void testValidClassCodes() {\n        isValidClassCode(true,   0, UNKNOWN);\n\n        isValidClassCode(true,   2, FIELD);\n        isValidClassCode(true,   4, PROPERTY);"}
{"magic_number_smell": "    public static class CustomComparatorSortedSet extends TreeSet {\n\n        \n        private static final long 1L = 1L;\n\n        public CustomComparatorSortedSet() {\n        }", "refactored_code": "        private static final long serialVersionUID = 1L;\n    public static class CustomComparatorSortedSet extends TreeSet {\n\n        \n        private static final long serialVersionUID = 1L;\n\n        public CustomComparatorSortedSet() {\n        }"}
{"magic_number_smell": "    public static final int COLOR_BLACK = 2;\n\n    public int finished = 0;\n    public int color = 0;\n}\n", "refactored_code": "    public static final int COLOR_WHITE = 0;\n    public static final int COLOR_BLACK = 2;\n\n    public int finished = 0;\n    public int color = COLOR_WHITE;\n}\n"}
{"magic_number_smell": "    private static final String[] WARNING_ACTIONS = new String[7];\n\n    static {\n        WARNING_ACTIONS[0] = \"ignore\";\n        WARNING_ACTIONS[WARN_LOG_TRACE] = \"trace\";\n        WARNING_ACTIONS[WARN_LOG_INFO] = \"info\";\n        WARNING_ACTIONS[WARN_LOG_WARN] = \"warn\";", "refactored_code": "    private static final int WARN_IGNORE = 0;\n    private static final String[] WARNING_ACTIONS = new String[7];\n\n    static {\n        WARNING_ACTIONS[WARN_IGNORE] = \"ignore\";\n        WARNING_ACTIONS[WARN_LOG_TRACE] = \"trace\";\n        WARNING_ACTIONS[WARN_LOG_INFO] = \"info\";\n        WARNING_ACTIONS[WARN_LOG_WARN] = \"warn\";"}
{"magic_number_smell": "            // read element name; look for packages and classes\n            token = readElementToken(ch, in);\n            switch (token) {\n                case -1:\n                    break read;\n                case TOKEN_PACKAGE:\n                    pkg = readAttribute(in, _packageAttr);", "refactored_code": "    private static final int TOKEN_EOF = -1;\n            // read element name; look for packages and classes\n            token = readElementToken(ch, in);\n            switch (token) {\n                case TOKEN_EOF:\n                    break read;\n                case TOKEN_PACKAGE:\n                    pkg = readAttribute(in, _packageAttr);"}
{"magic_number_smell": "     */\n    private int scan(File file, MetaDataFilter filter, FileResource rsrc,\n        Collection<File> metas, int scanned) throws IOException {\n        if (scanned > 100000)\n            throw new IllegalStateException(_loc.get(\"too-many-files\",\n                String.valueOf(100000)).getMessage());\n        scanned++;", "refactored_code": "    private static final long SCAN_LIMIT = 100000;\n     */\n    private int scan(File file, MetaDataFilter filter, FileResource rsrc,\n        Collection<File> metas, int scanned) throws IOException {\n        if (scanned > SCAN_LIMIT)\n            throw new IllegalStateException(_loc.get(\"too-many-files\",\n                String.valueOf(SCAN_LIMIT)).getMessage());\n        scanned++;"}
{"magic_number_smell": "\n    private ResultObjectProvider _rop = null;\n    private final List _list = new ArrayList();\n    private int _state = 0;\n    private int _size = -1;\n\n    public LazyForwardResultList(ResultObjectProvider rop) {", "refactored_code": "    private static final int OPEN = 0;\n\n    private ResultObjectProvider _rop = null;\n    private final List _list = new ArrayList();\n    private int _state = OPEN;\n    private int _size = -1;\n\n    public LazyForwardResultList(ResultObjectProvider rop) {"}
{"magic_number_smell": "\n        // have to open all to get sizes\n        for (int i = 0; i < _status.length; i++) {\n            if (_status[i] == 0) {\n                _rops[i].open();\n                _status[i] = OPENED;\n            }", "refactored_code": "    private static final byte UNOPENED = 0;\n\n        // have to open all to get sizes\n        for (int i = 0; i < _status.length; i++) {\n            if (_status[i] == UNOPENED) {\n                _rops[i].open();\n                _status[i] = OPENED;\n            }"}
{"magic_number_smell": "\n    // bookkeeping\n    private long _requests = 0;\n    private int _state = 0;\n    private int _size = -1;\n\n    public RandomAccessResultList(ResultObjectProvider rop) {", "refactored_code": "    private static final int OPEN = 0;\n\n    // bookkeeping\n    private long _requests = 0;\n    private int _state = OPEN;\n    private int _size = -1;\n\n    public RandomAccessResultList(ResultObjectProvider rop) {"}
{"magic_number_smell": "    private int _pos = -1;\n    private ResultObjectProvider _rop = null;\n    private boolean _random = false;\n    private int _state = 0;\n    private int _size = -1;\n\n    public WindowResultList(ResultObjectProvider rop) {", "refactored_code": "    private static final int OPEN = 0;\n    private int _pos = -1;\n    private ResultObjectProvider _rop = null;\n    private boolean _random = false;\n    private int _state = OPEN;\n    private int _size = -1;\n\n    public WindowResultList(ResultObjectProvider rop) {"}
{"magic_number_smell": "    public static class DuplicateKeyException extends RuntimeException {\n\n        \n        private static final long 1L = 1L;\n\n        public DuplicateKeyException(String key, Object firstVal,\n            String secondVal) {", "refactored_code": "    private static final long serialVersionUID = 1L;\n    public static class DuplicateKeyException extends RuntimeException {\n\n        \n        private static final long serialVersionUID = 1L;\n\n        public DuplicateKeyException(String key, Object firstVal,\n            String secondVal) {"}
{"magic_number_smell": "    private static class EmptyOptions extends Options {\n\n\n        private static final long 1L = 1L;\n\n        @Override\n        public Object setProperty(String key, String value) {", "refactored_code": "    private static final long serialVersionUID = 1L;\n    private static class EmptyOptions extends Options {\n\n\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public Object setProperty(String key, String value) {"}
{"magic_number_smell": "\n    private static final Object DUMMY_VAL = new Serializable() {\n        \n        private static final long 1L = 1L;\n\n        @Override\n        public String toString() {", "refactored_code": "    private static final long serialVersionUID = 1L;\n\n    private static final Object DUMMY_VAL = new Serializable() {\n        \n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public String toString() {"}
{"magic_number_smell": "\n    // number of millisecond, mircoseconds and nanoseconds in one second.\n    protected static final long 1000L = 1000L;\n    protected static final long MicroMuliplier = 1000L * 1000L;\n    protected static final long NanoMuliplier = MicroMuliplier * 1000L;\n\n    // number of seconds passed 1970/1/1 00:00:00 GMT.", "refactored_code": "    protected static final long MilliMuliplier = 1000L;\n\n    // number of millisecond, mircoseconds and nanoseconds in one second.\n    protected static final long MilliMuliplier = 1000L;\n    protected static final long MicroMuliplier = MilliMuliplier * 1000L;\n    protected static final long NanoMuliplier = MicroMuliplier * 1000L;\n\n    // number of seconds passed 1970/1/1 00:00:00 GMT."}
{"magic_number_smell": "    protected static class KeySet<K> extends View<K, Object, K> implements Set<K> {\n\n        /** Serialization version */\n        private static final long 4621510560119690639L = -7107935777385040694L;\n\n        /**\n         * Constructs a new view of the BidiMap.", "refactored_code": "        private static final long serialVersionUID = 4621510560119690639L;\n    protected static class KeySet<K> extends View<K, Object, K> implements Set<K> {\n\n        /** Serialization version */\n        private static final long serialVersionUID = -7107935777385040694L;\n\n        /**\n         * Constructs a new view of the BidiMap."}
{"magic_number_smell": "     * @throws NullPointerException if the map is null\n     */\n    protected AbstractHashedMap(final Map<? extends K, ? extends V> map) {\n        this(Math.max(2 * map.size(), 16), DEFAULT_LOAD_FACTOR);\n        _putAll(map);\n    }\n", "refactored_code": "    protected static final int DEFAULT_CAPACITY = 16;\n     * @throws NullPointerException if the map is null\n     */\n    protected AbstractHashedMap(final Map<? extends K, ? extends V> map) {\n        this(Math.max(2 * map.size(), DEFAULT_CAPACITY), DEFAULT_LOAD_FACTOR);\n        _putAll(map);\n    }\n"}
{"magic_number_smell": "     * capacity(16) and the default load factor(0.75).\n     */\n    public ConcurrentHashMap() {\n        this(16, DEFAULT_LOAD_FACTOR);\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_INITIAL_CAPACITY = 16;\n     * capacity(16) and the default load factor(0.75).\n     */\n    public ConcurrentHashMap() {\n        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);\n    }\n\n    /**"}
{"magic_number_smell": "                throw new NoSuchElementException();\n            Entry e = lastReturned = entry;\n            entry = e.getNext();\n            return type == 0 ? e.getKey()\n                : (type == VALUES ? e.getValue() : e);\n        }\n", "refactored_code": "    private static final int KEYS = 0;\n                throw new NoSuchElementException();\n            Entry e = lastReturned = entry;\n            entry = e.getNext();\n            return type == KEYS ? e.getKey()\n                : (type == VALUES ? e.getValue() : e);\n        }\n"}
{"magic_number_smell": "                case TYPE_META:\n                    serializeClass((ClassMetaData) obj);\n                    break;\n                case 10:\n                    if (isMappingMode())\n                        serializeSequence((SequenceMetaData) obj);\n                    break;", "refactored_code": "    protected static final int TYPE_SEQ = 10;\n                case TYPE_META:\n                    serializeClass((ClassMetaData) obj);\n                    break;\n                case TYPE_SEQ:\n                    if (isMappingMode())\n                        serializeSequence((SequenceMetaData) obj);\n                    break;"}
{"magic_number_smell": "        final OpenJPAEntityManager em) {\n        return new RuntimeExceptionTranslator() {\n            \n            private static final long 1L = 1L;\n            private boolean throwing = false;\n\n            @Override", "refactored_code": "            private static final long serialVersionUID = 1L;\n        final OpenJPAEntityManager em) {\n        return new RuntimeExceptionTranslator() {\n            \n            private static final long serialVersionUID = 1L;\n            private boolean throwing = false;\n\n            @Override"}
{"magic_number_smell": "                    serializeClass((ClassMetaData) obj, fieldAccess\n                        && propertyAccess);\n                    break;\n                case 10:\n                    if (isMappingMode())\n                        serializeSequence((SequenceMetaData) obj);\n                    break;", "refactored_code": "    protected static final int TYPE_SEQ = 10;\n                    serializeClass((ClassMetaData) obj, fieldAccess\n                        && propertyAccess);\n                    break;\n                case TYPE_SEQ:\n                    if (isMappingMode())\n                        serializeSequence((SequenceMetaData) obj);\n                    break;"}
{"magic_number_smell": "                jcols = new ArrayList<>(scols.length);\n                unique = 0;\n                for (JoinColumn scol : scols) {\n                    unique |= (scol.unique()) ? 1 : FALSE;\n                    jcols.add(newColumn(scol));\n                }\n                setColumns(sup, sup.getValueInfo(), jcols, unique);", "refactored_code": "    protected static final int TRUE = 1;\n                jcols = new ArrayList<>(scols.length);\n                unique = 0;\n                for (JoinColumn scol : scols) {\n                    unique |= (scol.unique()) ? TRUE : FALSE;\n                    jcols.add(newColumn(scol));\n                }\n                setColumns(sup, sup.getValueInfo(), jcols, unique);"}
{"magic_number_smell": "    protected int type(Object o) {\n        int type = super.type(o);\n        if (type == -1 && o instanceof QueryResultMapping)\n            return TYPE_QUERY + 1;\n        return type;\n    }\n", "refactored_code": "    private static final int TYPE_RESULTMAP = TYPE_QUERY + 1;\n    protected int type(Object o) {\n        int type = super.type(o);\n        if (type == -1 && o instanceof QueryResultMapping)\n            return TYPE_RESULTMAP;\n        return type;\n    }\n"}
{"magic_number_smell": "    protected int type(Object o) {\n        int type = super.type(o);\n        if (type == -1 && o instanceof QueryResultMapping)\n            return TYPE_QUERY + 1;\n        return type;\n    }\n", "refactored_code": "    private static final int TYPE_RESULTMAP = TYPE_QUERY + 1;\n    protected int type(Object o) {\n        int type = super.type(o);\n        if (type == -1 && o instanceof QueryResultMapping)\n            return TYPE_RESULTMAP;\n        return type;\n    }\n"}
{"magic_number_smell": "    private static final int MIN = 1;\n    private static final int SUM = 2;\n\n    private static final String[] numericAggregateFunctions = { \"0\", \"AVG\",\n            \"MIN\", \"SUM\" };\n\n    private static final String[] stringAggregateFunctions = { \"0\", \"MIN\" };", "refactored_code": "    private static final int MAX = 0;\n    private static final int MIN = 1;\n    private static final int SUM = 2;\n\n    private static final String[] numericAggregateFunctions = { \"MAX\", \"AVG\",\n            \"MIN\", \"SUM\" };\n\n    private static final String[] stringAggregateFunctions = { \"MAX\", \"MIN\" };"}
{"magic_number_smell": "        implements Serializable {\n\n        \n        private static final long 1L = 1L;\n        private int refreshCount = 0;\n\n        @Override", "refactored_code": "        private static final long serialVersionUID = 1L;\n        implements Serializable {\n\n        \n        private static final long serialVersionUID = 1L;\n        private int refreshCount = 0;\n\n        @Override"}
{"magic_number_smell": "    }\n\n    public void testEntityListeners() {\n        helper(1);\n    }\n\n    public void testGlobalListeners() {", "refactored_code": "    private static final int ENTITY_LISTENER_ENTITY = 1;\n    }\n\n    public void testEntityListeners() {\n        helper(ENTITY_LISTENER_ENTITY);\n    }\n\n    public void testGlobalListeners() {"}
{"magic_number_smell": "    }\n\n    public void testMSCEntityListeners() {\n        helper(4);\n    }\n\n    public void helper(int entityListeners) {", "refactored_code": "    private static final int MSC_LISTENER_ENTITY = 4;\n    }\n\n    public void testMSCEntityListeners() {\n        helper(MSC_LISTENER_ENTITY);\n    }\n\n    public void helper(int entityListeners) {"}
{"magic_number_smell": "    public static class OperationTimedOutException extends RuntimeException {\n\n        \n        private static final long 1L = 1L;\n        private final Throwable _err;\n\n        public OperationTimedOutException(String msg, Throwable throwable) {", "refactored_code": "        private static final long serialVersionUID = 1L;\n    public static class OperationTimedOutException extends RuntimeException {\n\n        \n        private static final long serialVersionUID = 1L;\n        private final Throwable _err;\n\n        public OperationTimedOutException(String msg, Throwable throwable) {"}
{"magic_number_smell": "                fail(\"Test should have failed on OpenJPA 1.3 or above.\");\n            } else {\n                // OpenJPA 1.2.x and earlier ignored unused parameters\n                assertEquals(3, dept.getFullTimeEmployees().size());\n                assertEquals(PARTTIME_EMPLOYEE_COUNT, dept.getPartTimeEmployees().size());\n                assertSQL(\".* AND t0.TYPE = .*\");\n            }", "refactored_code": "    private static final int FULLTIME_EMPLOYEE_COUNT = 3;\n                fail(\"Test should have failed on OpenJPA 1.3 or above.\");\n            } else {\n                // OpenJPA 1.2.x and earlier ignored unused parameters\n                assertEquals(FULLTIME_EMPLOYEE_COUNT, dept.getFullTimeEmployees().size());\n                assertEquals(PARTTIME_EMPLOYEE_COUNT, dept.getPartTimeEmployees().size());\n                assertSQL(\".* AND t0.TYPE = .*\");\n            }"}
{"magic_number_smell": "        s.setName(\"eBay.com\");\n        s.setOrders(new HashSet<>());\n\n        for (int i = 1; i <= 15; i++) {\n            order = new Order();\n            order.setId(i);\n            order.setDate(df.parse(ORDER_DATES[i % ORDER_DATES.length]));", "refactored_code": "    private static final int N_ORDERS = 15;\n        s.setName(\"eBay.com\");\n        s.setOrders(new HashSet<>());\n\n        for (int i = 1; i <= N_ORDERS; i++) {\n            order = new Order();\n            order.setId(i);\n            order.setDate(df.parse(ORDER_DATES[i % ORDER_DATES.length]));"}
{"magic_number_smell": "    public static class CachedQueryResult extends ListResultList {\n\n        \n        private static final long 1L = 1L;\n\n        public CachedQueryResult(List list) {\n            super(list);", "refactored_code": "    private static final long serialVersionUID = 1L;\n    public static class CachedQueryResult extends ListResultList {\n\n        \n        private static final long serialVersionUID = 1L;\n\n        public CachedQueryResult(List list) {\n            super(list);"}
{"magic_number_smell": "        // Noraml transaction\n        OpenJPAEntityManager pmSender = (OpenJPAEntityManager) pmfSender\n            .createEntityManager();\n        seedDataStore(pmSender, 4);\n        endEm(pmSender);\n\n        // wait a bit so they get stored", "refactored_code": "    private static final int NUM_OBJECTS = 4;\n        // Noraml transaction\n        OpenJPAEntityManager pmSender = (OpenJPAEntityManager) pmfSender\n            .createEntityManager();\n        seedDataStore(pmSender, NUM_OBJECTS);\n        endEm(pmSender);\n\n        // wait a bit so they get stored"}
{"magic_number_smell": "\n\tpublic void createData() {\n\t\tEmbeddingOwnerEntity owner = new EmbeddingOwnerEntity();\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tEmbeddedEntity member = new EmbeddedEntity();\n\t\t\tmember.setMarker(\"Member-\" + i);\n\t\t\towner.addMember(member);", "refactored_code": "\tprivate static final int SIZE = 4;\n\n\tpublic void createData() {\n\t\tEmbeddingOwnerEntity owner = new EmbeddingOwnerEntity();\n\t\tfor (int i = 0; i < SIZE; i++) {\n\t\t\tEmbeddedEntity member = new EmbeddedEntity();\n\t\t\tmember.setMarker(\"Member-\" + i);\n\t\t\towner.addMember(member);"}
{"magic_number_smell": "        super.setUp(CLEAR_TABLES,\n            CachedPerson.class,\n            \"openjpa.RemoteCommitProvider\", \"sjvm\",\n            \"openjpa.DataCache\",\"true(SoftReferenceSize=0,Lru=true,CacheSize=\"+5+\")\",\n            \"openjpa.QueryCache\",\"true(SoftReferenceSize=0,Lru=true,CacheSize=\"+5+\")\"\n        );\n    }", "refactored_code": "    private final int cacheSize = 5;\n        super.setUp(CLEAR_TABLES,\n            CachedPerson.class,\n            \"openjpa.RemoteCommitProvider\", \"sjvm\",\n            \"openjpa.DataCache\",\"true(SoftReferenceSize=0,Lru=true,CacheSize=\"+cacheSize+\")\",\n            \"openjpa.QueryCache\",\"true(SoftReferenceSize=0,Lru=true,CacheSize=\"+cacheSize+\")\"\n        );\n    }"}
{"magic_number_smell": "    public void setUp() {\n        setUp(DROP_TABLES, Entity20.class);\n        _log = emf.getConfiguration().getLog(\"test\");\n        createEntities(3);\n    }\n\n    private void createEntities(int count) {", "refactored_code": "    private static final int numEntities = 3;\n    public void setUp() {\n        setUp(DROP_TABLES, Entity20.class);\n        _log = emf.getConfiguration().getLog(\"test\");\n        createEntities(numEntities);\n    }\n\n    private void createEntities(int count) {"}
{"magic_number_smell": "\n        tran.begin();\n        ae = new AnEntity();\n        ae.setId(2);\n        ae.setName(\"\");\n        em.persist(ae);\n        tran.commit();", "refactored_code": "    public final int PKID = 2;\n\n        tran.begin();\n        ae = new AnEntity();\n        ae.setId(PKID);\n        ae.setName(\"\");\n        em.persist(ae);\n        tran.commit();"}
{"magic_number_smell": "\n        // Perform transaction that adds objects.\n        // Noraml transaction\n        performAdds(pmSender, 4);\n\n        // Wait for a bit so the receiver can get the event.\n        pause(1);", "refactored_code": "    private static final int NUM_OBJECTS = 4;\n\n        // Perform transaction that adds objects.\n        // Noraml transaction\n        performAdds(pmSender, NUM_OBJECTS);\n\n        // Wait for a bit so the receiver can get the event.\n        pause(1);"}
{"magic_number_smell": "        System.out.println(\"3 PMFs created, 1 as standalone, and 2 acting \" +\n            \"as a cluster using ports 5636 and 6636\");\n        // This call is a \"throw away\" run to seed caches, etc.\n        doTransactions(pmSingle, 200);\n\n        double benchmarkSingle = 0.0;\n        for (int i = 0; i < NUM_TO_AVERAGE; i++) {", "refactored_code": "    private static final int NUM_OBJECTS = 200;\n        System.out.println(\"3 PMFs created, 1 as standalone, and 2 acting \" +\n            \"as a cluster using ports 5636 and 6636\");\n        // This call is a \"throw away\" run to seed caches, etc.\n        doTransactions(pmSingle, NUM_OBJECTS);\n\n        double benchmarkSingle = 0.0;\n        for (int i = 0; i < NUM_TO_AVERAGE; i++) {"}
{"magic_number_smell": "        System.out.println(\"to send.\");\n\n        // Perform a set of transactions. Events will be communicated\n        performAddsModifiesDeletes(pmSender, 1);\n\n        // Wait for a bit so the receiver can get the event.\n        pause(1);", "refactored_code": "    private static final int NUM_OBJECTS = 1;\n        System.out.println(\"to send.\");\n\n        // Perform a set of transactions. Events will be communicated\n        performAddsModifiesDeletes(pmSender, NUM_OBJECTS);\n\n        // Wait for a bit so the receiver can get the event.\n        pause(1);"}
{"magic_number_smell": "        System.out.println(\"to send.\");\n\n        // Perform a set of transactions. Events will be communicated\n        performAddsModifiesDeletes(pmSender, 1);\n\n        // Wait for a bit so the receiver can get the event.\n        pause(3);", "refactored_code": "    private static final int NUM_OBJECTS = 1;\n        System.out.println(\"to send.\");\n\n        // Perform a set of transactions. Events will be communicated\n        performAddsModifiesDeletes(pmSender, NUM_OBJECTS);\n\n        // Wait for a bit so the receiver can get the event.\n        pause(3);"}
{"magic_number_smell": "public class TestFetchGroups extends SingleEMTestCase {\n    private static final int 5 = 5;\n    private static final int mgrCount = 3;\n    private static final int empCount = mgrCount * 5;\n\n    private HashSet<FGEmployee> employeeSet = new HashSet<>();\n    private HashSet<FGManager> managerSet = new HashSet<>();", "refactored_code": "    private static final int empPerMgr = 5;\npublic class TestFetchGroups extends SingleEMTestCase {\n    private static final int empPerMgr = 5;\n    private static final int mgrCount = 3;\n    private static final int empCount = mgrCount * empPerMgr;\n\n    private HashSet<FGEmployee> employeeSet = new HashSet<>();\n    private HashSet<FGManager> managerSet = new HashSet<>();"}
{"magic_number_smell": "\n            _seq = (TableJDBCSeq) meta.getInstance(contextLoader);\n            // Change defaults so this test doesn't take so long to run.\n            _seq.setAllocate(100000);\n            _seq.setInitialValue(1);\n\n            Object obj = _seq.next(_ctx, _cmd);", "refactored_code": "    public final int ALLOC_SIZE = 100000;\n\n            _seq = (TableJDBCSeq) meta.getInstance(contextLoader);\n            // Change defaults so this test doesn't take so long to run.\n            _seq.setAllocate(ALLOC_SIZE);\n            _seq.setInitialValue(1);\n\n            Object obj = _seq.next(_ctx, _cmd);"}
{"magic_number_smell": "\n    public static class TestExternal\n    {\n        private static final long 1L = 1L;\n        public boolean throwEx=false;\n\n        private String value = \"test - TE\";", "refactored_code": "    private static final long serialVersionUID = 1L;\n\n    public static class TestExternal\n    {\n        private static final long serialVersionUID = 1L;\n        public boolean throwEx=false;\n\n        private String value = \"test - TE\";"}
{"magic_number_smell": "\n        em = emf.createEntityManager();\n        em.getTransaction().begin();\n        em.persist(new Entity1(1, CONST_NAME, 42));\n        em.persist(new Entity1(2, CONST_NAME+\" Changed\", 42+1));\n        em.persist(new Entity1(3, CONST_NAME+\" Changed 2\", 42+2));\n        em.getTransaction().commit();", "refactored_code": "    private static final int CONST_INT = 42;\n\n        em = emf.createEntityManager();\n        em.getTransaction().begin();\n        em.persist(new Entity1(1, CONST_NAME, CONST_INT));\n        em.persist(new Entity1(2, CONST_NAME+\" Changed\", CONST_INT+1));\n        em.persist(new Entity1(3, CONST_NAME+\" Changed 2\", CONST_INT+2));\n        em.getTransaction().commit();"}
{"magic_number_smell": "\t\tquery.setParameter(1, DEPT_NAME);\n\t\tDepartment dept = (Department) query.getSingleResult();\n\n        assertEquals(3, dept.getFullTimeEmployees()\n                .size());\n        assertEquals(PARTTIME_EMPLOYEE_COUNT, dept.getPartTimeEmployees()\n\t\t\t\t.size());", "refactored_code": "\tprivate static final int FULLTIME_EMPLOYEE_COUNT = 3;\n\t\tquery.setParameter(1, DEPT_NAME);\n\t\tDepartment dept = (Department) query.getSingleResult();\n\n        assertEquals(FULLTIME_EMPLOYEE_COUNT, dept.getFullTimeEmployees()\n                .size());\n        assertEquals(PARTTIME_EMPLOYEE_COUNT, dept.getPartTimeEmployees()\n\t\t\t\t.size());"}
{"magic_number_smell": "\n        // run N times without cache\n        auditor.clear();\n        long without = run(query, isNamed, params, expectedCount, !USE_CACHE, 100);\n        List<String> originalSQLs = auditor.getSQLs();\n\n        // run N times with cache", "refactored_code": "    protected static final int SAMPLE_SIZE = 100;  // no. of observations for performance statistics\n\n        // run N times without cache\n        auditor.clear();\n        long without = run(query, isNamed, params, expectedCount, !USE_CACHE, SAMPLE_SIZE);\n        List<String> originalSQLs = auditor.getSQLs();\n\n        // run N times with cache"}
{"magic_number_smell": "    }\n\n    public void testDependentFieldsLoaded() {\n        delete(true, 0);\n        checkFields();\n    }\n", "refactored_code": "    private static final int COMMIT = 0;\n    }\n\n    public void testDependentFieldsLoaded() {\n        delete(true, COMMIT);\n        checkFields();\n    }\n"}
{"magic_number_smell": "    }\n\n    public void testPreStore() {\n        preStoreTest(0);\n    }\n\n    public void testPreStoreWithFlush() {", "refactored_code": "    private static final int COMMIT = 0;\n    }\n\n    public void testPreStore() {\n        preStoreTest(COMMIT);\n    }\n\n    public void testPreStoreWithFlush() {"}
{"magic_number_smell": "    public void testMemoryUse() throws Exception {\n\n        System.out.println(\"Baseline, starting memory for N objects of \" +\n            2000);\n        OpenJPAEntityManagerFactory kpmf =\n            (OpenJPAEntityManagerFactory) getEmf();\n        OpenJPAEntityManager kpm = (OpenJPAEntityManager)", "refactored_code": "    private static final int NUM_OBJECTS = 2000;\n    public void testMemoryUse() throws Exception {\n\n        System.out.println(\"Baseline, starting memory for N objects of \" +\n            NUM_OBJECTS);\n        OpenJPAEntityManagerFactory kpmf =\n            (OpenJPAEntityManagerFactory) getEmf();\n        OpenJPAEntityManager kpm = (OpenJPAEntityManager)"}
{"magic_number_smell": "            Collection results = runQuery(RuntimeTest1.class, true, query, pm);\n            assertEquals(\"query (\" + query + \") failed to yield \"\n                + currentcount + \" instances\",\n                currentcount * 3, results.size());\n        }\n\n        endEm(pm);", "refactored_code": "    private static final int CHILD_COUNT = 3;\n            Collection results = runQuery(RuntimeTest1.class, true, query, pm);\n            assertEquals(\"query (\" + query + \") failed to yield \"\n                + currentcount + \" instances\",\n                currentcount * CHILD_COUNT, results.size());\n        }\n\n        endEm(pm);"}
{"magic_number_smell": "            endTx(pm);\n        else\n            rollbackTx(pm);\n        assertFlags(\"test\", RELEASED, 1 | ROLLBACK);\n        assertFlags(\"test2\", RELEASED, 1 | ROLLBACK);\n        endEm(pm);\n    }", "refactored_code": "    private static final int USER = 1;\n            endTx(pm);\n        else\n            rollbackTx(pm);\n        assertFlags(\"test\", RELEASED, USER | ROLLBACK);\n        assertFlags(\"test2\", RELEASED, USER | ROLLBACK);\n        endEm(pm);\n    }"}
{"magic_number_smell": "\n    /**\n     * This method tests a timing window where more than one thread requests MetaData using an alias\n     * at the same time. All 100 should get data back and no 100 should receive an\n     * exception.\n     */\n    public void testMultiThreadGetMetaDataAlias() throws Exception {", "refactored_code": "    private final int threads = 100;\n\n    /**\n     * This method tests a timing window where more than one thread requests MetaData using an alias\n     * at the same time. All threads should get data back and no threads should receive an\n     * exception.\n     */\n    public void testMultiThreadGetMetaDataAlias() throws Exception {"}
{"magic_number_smell": "        if (borrower != null) {\n            this.borrower = borrower;\n            // set the due date, one week from today\n            long one_week_out = System.currentTimeMillis() + 1000 * 60 * 60 * 24 * 7;\n            dueDate = new Date(one_week_out);\n        }\n    }", "refactored_code": "    private static final int WEEKS_TIME_MS = 1000 * 60 * 60 * 24 * 7;\n        if (borrower != null) {\n            this.borrower = borrower;\n            // set the due date, one week from today\n            long one_week_out = System.currentTimeMillis() + WEEKS_TIME_MS;\n            dueDate = new Date(one_week_out);\n        }\n    }"}
{"magic_number_smell": "\t\tem.persist(projekt1);\n\t\tem.persist(projekt2);\n\n\t\tfor (int i=0; i<6; i++)\n\t\t\tlink(osoby[i], projekt1);\n\t\tfor (int i=0; i<MEMBER_COUNT_PROJEKT2; i++)\n\t\t\tlink(osoby[osoby.length-i-1], projekt2);", "refactored_code": "\tpublic static final int MEMBER_COUNT_PROJEKT1 = 6;\n\t\tem.persist(projekt1);\n\t\tem.persist(projekt2);\n\n\t\tfor (int i=0; i<MEMBER_COUNT_PROJEKT1; i++)\n\t\t\tlink(osoby[i], projekt1);\n\t\tfor (int i=0; i<MEMBER_COUNT_PROJEKT2; i++)\n\t\t\tlink(osoby[osoby.length-i-1], projekt2);"}
{"magic_number_smell": "        s.setName(\"eBay.com\");\n        s.setOrders(new HashSet<>());\n\n        for (int i = 1; i <= 15; i++) {\n            order = new Order();\n            order.setId(i);\n            order.setDate(df.parse(ORDER_DATES[i % ORDER_DATES.length]));", "refactored_code": "    private static final int N_ORDERS = 15;\n        s.setName(\"eBay.com\");\n        s.setOrders(new HashSet<>());\n\n        for (int i = 1; i <= N_ORDERS; i++) {\n            order = new Order();\n            order.setId(i);\n            order.setDate(df.parse(ORDER_DATES[i % ORDER_DATES.length]));"}
{"magic_number_smell": "\t\t * ChainEntityC) increases the probability to get the unique key\n\t\t * constraint violation error.\n\t\t */\n\t\tfor (int i = 1; i <= 50; i++) {\n\t\t\tc = new ChainEntityC ();\n\t\t\tc.setName (\"Test_C_\" + i);\n\t\t\tb.addChainEntityC (c);", "refactored_code": "\tprivate static final int MAGICAL_NUMBER = 50;\n\t\t * ChainEntityC) increases the probability to get the unique key\n\t\t * constraint violation error.\n\t\t */\n\t\tfor (int i = 1; i <= MAGICAL_NUMBER; i++) {\n\t\t\tc = new ChainEntityC ();\n\t\t\tc.setName (\"Test_C_\" + i);\n\t\t\tb.addChainEntityC (c);"}
{"magic_number_smell": "\n    @Embeddable\n    public static class IncompleteRelationshipChildEntityPk implements Serializable {\n        private static final long 1L = 1L;\n\n        @Column(name = \"DISCOUNT\", nullable = false, length = 120)\n        protected String discount;", "refactored_code": "    private static final long serialVersionUID = 1L;\n\n    @Embeddable\n    public static class IncompleteRelationshipChildEntityPk implements Serializable {\n        private static final long serialVersionUID = 1L;\n\n        @Column(name = \"DISCOUNT\", nullable = false, length = 120)\n        protected String discount;"}
{"magic_number_smell": "\n    @Embeddable\n    public static class IncompleteRelationshipParentEntityPk implements Serializable {\n        private static final long 1L = 1L;\n\n        @Column(name = \"ID\", nullable = false, precision = 9)\n        protected int id;", "refactored_code": "    private static final long serialVersionUID = 1L;\n\n    @Embeddable\n    public static class IncompleteRelationshipParentEntityPk implements Serializable {\n        private static final long serialVersionUID = 1L;\n\n        @Column(name = \"ID\", nullable = false, precision = 9)\n        protected int id;"}
{"magic_number_smell": "        EntityEmployee employee = new EntityEmployee();\n        employee.setFirstName(\"Employee_First_Name\");\n        employee.setLastName(\"Employee_Last_Name\");\n        employee.setSalary(5000);\n\n        em.getTransaction().begin();\n        em.persist(person);", "refactored_code": "    private static final int NUMBER_ENTITIES = 5000;\n        EntityEmployee employee = new EntityEmployee();\n        employee.setFirstName(\"Employee_First_Name\");\n        employee.setLastName(\"Employee_Last_Name\");\n        employee.setSalary(NUMBER_ENTITIES);\n\n        em.getTransaction().begin();\n        em.persist(person);"}
{"magic_number_smell": "\n    public static class TestPrincipal implements Principal, Serializable {\n        \n        private static final long 8371304701543038775L = 1L;\n        private final String name;\n\n        public TestPrincipal(String name) {", "refactored_code": "    private static final long serialVersionUID = 8371304701543038775L;\n\n    public static class TestPrincipal implements Principal, Serializable {\n        \n        private static final long serialVersionUID = 1L;\n        private final String name;\n\n        public TestPrincipal(String name) {"}
{"magic_number_smell": "        Object[] ordersFromDb = orders.get(0);\n        Order order1 = (Order) ordersFromDb[0];\n        Order order2 = (Order) ordersFromDb[1];\n        assertEquals(10, order1.getOid());\n        assertOrdersEqual(order1, order2);\n\n        ordersFromDb = orders.get(1);", "refactored_code": "    private static final int ORDER_1_OID = 10;\n        Object[] ordersFromDb = orders.get(0);\n        Order order1 = (Order) ordersFromDb[0];\n        Order order2 = (Order) ordersFromDb[1];\n        assertEquals(ORDER_1_OID, order1.getOid());\n        assertOrdersEqual(order1, order2);\n\n        ordersFromDb = orders.get(1);"}
{"magic_number_smell": "        if (waitInMsec == -1) {\n            speedCnt = platformSpeedTest();\n            try {\n                waitInMsec = 10000 + 250000 / (speedCnt / 1000000);\n            } catch (Throwable t) {\n            }\n        }", "refactored_code": "    protected static final int MinThreadWaitInMs = 10000;\n        if (waitInMsec == -1) {\n            speedCnt = platformSpeedTest();\n            try {\n                waitInMsec = MinThreadWaitInMs + 250000 / (speedCnt / 1000000);\n            } catch (Throwable t) {\n            }\n        }"}
{"magic_number_smell": "\t */\n\tpublic static class ParallelExecutor extends\n\t\t\tExpressionStoreQuery.DataStoreExecutor {\n        private static final long 1L = 1L;\n        private List<Executor> executors = new ArrayList<>();\n\t\tprivate DistributedStoreQuery owner = null;\n", "refactored_code": "    private static final long serialVersionUID = 1L;\n\t */\n\tpublic static class ParallelExecutor extends\n\t\t\tExpressionStoreQuery.DataStoreExecutor {\n        private static final long serialVersionUID = 1L;\n        private List<Executor> executors = new ArrayList<>();\n\t\tprivate DistributedStoreQuery owner = null;\n"}
{"magic_number_smell": "    {\n        changeLog = new DefaultChangeLog();\n        journal = new DefaultJournal();\n        syncPeriodMillis = 15000;\n        csnFactory = new CsnFactory( replicaId );\n        evaluator = new SubtreeEvaluator( schemaManager );\n        setDefaultInterceptorConfigurations();", "refactored_code": "    private static final long DEFAULT_SYNC_PERIOD = 15000;\n    {\n        changeLog = new DefaultChangeLog();\n        journal = new DefaultJournal();\n        syncPeriodMillis = DEFAULT_SYNC_PERIOD;\n        csnFactory = new CsnFactory( replicaId );\n        evaluator = new SubtreeEvaluator( schemaManager );\n        setDefaultInterceptorConfigurations();"}
{"magic_number_smell": "            LOG.warn( \"failed to create certificate subject name from host name\", e );\n            subjectDn = CERTIFICATE_PRINCIPAL_DN;\n        }\n        addKeyPair( entry, CERTIFICATE_PRINCIPAL_DN, subjectDn, ALGORITHM, 2048 );\n    }\n\n", "refactored_code": "    private static final int KEY_SIZE = 2048;\n            LOG.warn( \"failed to create certificate subject name from host name\", e );\n            subjectDn = CERTIFICATE_PRINCIPAL_DN;\n        }\n        addKeyPair( entry, CERTIFICATE_PRINCIPAL_DN, subjectDn, ALGORITHM, KEY_SIZE );\n    }\n\n"}
{"magic_number_smell": "\n        switch ( matchType )\n        {\n            case ( 0 ):\n                mrule = attributeType.getEquality();\n                break;\n", "refactored_code": "    private static final int EQUALITY_MATCH = 0;\n\n        switch ( matchType )\n        {\n            case ( EQUALITY_MATCH ):\n                mrule = attributeType.getEquality();\n                break;\n"}
{"magic_number_smell": "        this.schemaSynchronizer = new SchemaSynchronizer( schemaManager );\n        this.objectClassAT = schemaManager.lookupAttributeTypeRegistry( SchemaConstants.OBJECT_CLASS_AT );\n\n        this.registrySynchronizers[0] = new ComparatorSynchronizer( schemaManager );\n        this.registrySynchronizers[NORMALIZER_INDEX] = new NormalizerSynchronizer( schemaManager );\n        this.registrySynchronizers[SYNTAX_CHECKER_INDEX] = new SyntaxCheckerSynchronizer( schemaManager );\n        this.registrySynchronizers[SYNTAX_INDEX] = new SyntaxSynchronizer( schemaManager );", "refactored_code": "    private static final int COMPARATOR_INDEX = 0;\n        this.schemaSynchronizer = new SchemaSynchronizer( schemaManager );\n        this.objectClassAT = schemaManager.lookupAttributeTypeRegistry( SchemaConstants.OBJECT_CLASS_AT );\n\n        this.registrySynchronizers[COMPARATOR_INDEX] = new ComparatorSynchronizer( schemaManager );\n        this.registrySynchronizers[NORMALIZER_INDEX] = new NormalizerSynchronizer( schemaManager );\n        this.registrySynchronizers[SYNTAX_CHECKER_INDEX] = new SyntaxCheckerSynchronizer( schemaManager );\n        this.registrySynchronizers[SYNTAX_INDEX] = new SyntaxSynchronizer( schemaManager );"}
{"magic_number_smell": "    private static final int 1000 = 1000;\n\n    /** The cache size limit */\n    private int cacheMaxSize = 1000;\n\n    /** The current cache size */\n    private AtomicInteger cacheSize;", "refactored_code": "    private static final int DEFAULT_CACHE_MAX_SIZE = 1000;\n    private static final int DEFAULT_CACHE_MAX_SIZE = 1000;\n\n    /** The cache size limit */\n    private int cacheMaxSize = DEFAULT_CACHE_MAX_SIZE;\n\n    /** The current cache size */\n    private AtomicInteger cacheSize;"}
{"magic_number_smell": "    public ArrayTree( Comparator<K> comparator )\n    {\n        this.comparator = comparator;\n        array = ( K[] ) new Object[16];\n        size = 0;\n    }\n", "refactored_code": "    private static final int INCREMENT = 16;\n    public ArrayTree( Comparator<K> comparator )\n    {\n        this.comparator = comparator;\n        array = ( K[] ) new Object[INCREMENT];\n        size = 0;\n    }\n"}
{"magic_number_smell": "\n    static class Foo implements Serializable\n    {\n        private static final long -6304421912253987925L = 2036800942831561377L;\n\n        float floatValue = 3;\n        String stringValue = \"foo\";", "refactored_code": "        private static final long serialVersionUID = -6304421912253987925L;\n\n    static class Foo implements Serializable\n    {\n        private static final long serialVersionUID = 2036800942831561377L;\n\n        float floatValue = 3;\n        String stringValue = \"foo\";"}
{"magic_number_smell": "\n    static class Foo implements Serializable\n    {\n        private static final long 2982919006977619754L = -1366956596647335984L;\n\n        float floatValue = 3;\n        String stringValue = \"foo\";", "refactored_code": "        private static final long serialVersionUID = 2982919006977619754L;\n\n    static class Foo implements Serializable\n    {\n        private static final long serialVersionUID = -1366956596647335984L;\n\n        float floatValue = 3;\n        String stringValue = \"foo\";"}
{"magic_number_smell": "    public SimpleAuthenticator()\n    {\n        super( AuthenticationLevel.SIMPLE );\n        credentialCache = new LRUMap( 100 );\n    }\n\n", "refactored_code": "    private static final int DEFAULT_CACHE_SIZE = 100;\n    public SimpleAuthenticator()\n    {\n        super( AuthenticationLevel.SIMPLE );\n        credentialCache = new LRUMap( DEFAULT_CACHE_SIZE );\n    }\n\n"}
{"magic_number_smell": "        this.parsers = new DescriptionParsers( schemaManager );\n\n        String comparatorsOid = schemaManager.getAttributeTypeRegistry().getOidByName( SchemaConstants.COMPARATORS_AT );\n        opAttr2handlerIndex.put( comparatorsOid, 0 );\n\n        String normalizersOid = schemaManager.getAttributeTypeRegistry().getOidByName( SchemaConstants.NORMALIZERS_AT );\n        opAttr2handlerIndex.put( normalizersOid, NORMALIZER_INDEX );", "refactored_code": "    private static final int COMPARATOR_INDEX = 0;\n        this.parsers = new DescriptionParsers( schemaManager );\n\n        String comparatorsOid = schemaManager.getAttributeTypeRegistry().getOidByName( SchemaConstants.COMPARATORS_AT );\n        opAttr2handlerIndex.put( comparatorsOid, COMPARATOR_INDEX );\n\n        String normalizersOid = schemaManager.getAttributeTypeRegistry().getOidByName( SchemaConstants.NORMALIZERS_AT );\n        opAttr2handlerIndex.put( normalizersOid, NORMALIZER_INDEX );"}
{"magic_number_smell": "    /**\n     * duplicate limit before duplicate keys switch to using a btree for values\n     */\n    protected int numDupLimit = 512;\n\n    /** a custom working directory path when specified in configuration */\n    protected File wkDirPath;", "refactored_code": "    public static final int DEFAULT_DUPLICATE_LIMIT = 512;\n    /**\n     * duplicate limit before duplicate keys switch to using a btree for values\n     */\n    protected int numDupLimit = DEFAULT_DUPLICATE_LIMIT;\n\n    /** a custom working directory path when specified in configuration */\n    protected File wkDirPath;"}
{"magic_number_smell": "        SerializableComparator<String> comparator = new SerializableComparator<String>(\n            SchemaConstants.INTEGER_ORDERING_MATCH_MR_OID );\n        comparator.setSchemaManager( schemaManager );\n        table = new JdbmTable<String, String>( schemaManager, \"test\", 15, recman,\n            comparator, comparator, null, new DefaultSerializer() );\n        partitionTxn = new MockPartitionReadTxn();\n        LOG.debug( \"Created new table and populated it with data\" );", "refactored_code": "    private static final int SIZE = 15;\n        SerializableComparator<String> comparator = new SerializableComparator<String>(\n            SchemaConstants.INTEGER_ORDERING_MATCH_MR_OID );\n        comparator.setSchemaManager( schemaManager );\n        table = new JdbmTable<String, String>( schemaManager, \"test\", SIZE, recman,\n            comparator, comparator, null, new DefaultSerializer() );\n        partitionTxn = new MockPartitionReadTxn();\n        LOG.debug( \"Created new table and populated it with data\" );"}
{"magic_number_smell": "            SchemaConstants.INTEGER_ORDERING_MATCH_MR_OID );\n        comparator.setSchemaManager( schemaManager );\n\n        table = new JdbmTable<String, String>( schemaManager, \"test\", 15, recman,\n            comparator, comparator, null, new DefaultSerializer() );\n        \n        partitionTxn = new MockPartitionReadTxn();", "refactored_code": "    private static final int SIZE = 15;\n            SchemaConstants.INTEGER_ORDERING_MATCH_MR_OID );\n        comparator.setSchemaManager( schemaManager );\n\n        table = new JdbmTable<String, String>( schemaManager, \"test\", SIZE, recman,\n            comparator, comparator, null, new DefaultSerializer() );\n        \n        partitionTxn = new MockPartitionReadTxn();"}
{"magic_number_smell": "            SchemaConstants.INTEGER_ORDERING_MATCH_MR_OID );\n        comparator.setSchemaManager( schemaManager );\n\n        table = new JdbmTable<String, String>( schemaManager, \"test\", 15, recman,\n            comparator, comparator, new DefaultSerializer(), new DefaultSerializer() );\n        LOG.debug( \"Created new table and populated it with data\" );\n        ", "refactored_code": "    private static final int SIZE = 15;\n            SchemaConstants.INTEGER_ORDERING_MATCH_MR_OID );\n        comparator.setSchemaManager( schemaManager );\n\n        table = new JdbmTable<String, String>( schemaManager, \"test\", SIZE, recman,\n            comparator, comparator, new DefaultSerializer(), new DefaultSerializer() );\n        LOG.debug( \"Created new table and populated it with data\" );\n        "}
{"magic_number_smell": "\n        // injecting some values to keep the\n        // followed search operation to run for a while\n        for ( int i = 0; i < 100; i++ )\n        {\n            String s = String.valueOf( i );\n            Dn dn = new Dn( \"cn=\" + s + \",ou=system\" );", "refactored_code": "    private static final int numEntries = 100;\n\n        // injecting some values to keep the\n        // followed search operation to run for a while\n        for ( int i = 0; i < numEntries; i++ )\n        {\n            String s = String.valueOf( i );\n            Dn dn = new Dn( \"cn=\" + s + \",ou=system\" );"}
{"magic_number_smell": "            @Override\n            public Void call()\n            {\n                for ( int i = 0; i < 50; i++ )\n                {\n                    System.out.println( \"search thread: round \" + i );\n                    try", "refactored_code": "    private static final int NUM_ROUNDS = 50;\n            @Override\n            public Void call()\n            {\n                for ( int i = 0; i < NUM_ROUNDS; i++ )\n                {\n                    System.out.println( \"search thread: round \" + i );\n                    try"}
{"magic_number_smell": "        List<Dn> injected = new ArrayList<Dn>();\n        int batch = 20;\n        \n        if( batch > 200 )\n        {\n            batch = 200;\n        }", "refactored_code": "    private static final int TOTAL_ENTRY_COUNT = 200;\n        List<Dn> injected = new ArrayList<Dn>();\n        int batch = 20;\n        \n        if( batch > TOTAL_ENTRY_COUNT )\n        {\n            batch = TOTAL_ENTRY_COUNT;\n        }"}
{"magic_number_smell": "            {\n                // have a current address? unicast to it.\n                return new InetSocketAddress( request.getCurrentClientAddress(),\n                    68 );\n            }\n            else\n            {", "refactored_code": "    public static final int CLIENT_PORT = 68;\n            {\n                // have a current address? unicast to it.\n                return new InetSocketAddress( request.getCurrentClientAddress(),\n                    CLIENT_PORT );\n            }\n            else\n            {"}
{"magic_number_smell": "    /**\n     * The lease's state.\n     * \n     * @see #1\n     * @see #STATE_OFFERED\n     * @see #STATE_ACTIVE\n     * @see #STATE_RELEASED", "refactored_code": "    public static final int STATE_NEW = 1;\n    /**\n     * The lease's state.\n     * \n     * @see #STATE_NEW\n     * @see #STATE_OFFERED\n     * @see #STATE_ACTIVE\n     * @see #STATE_RELEASED"}
{"magic_number_smell": "    {\n        InputStream is = getClass().getResourceAsStream( file );\n\n        byte[] bytes = new byte[576];\n\n        int offset = 0;\n        int numRead = 0;", "refactored_code": "    protected static final int MINIMUM_DHCP_DATAGRAM_SIZE = 576;\n    {\n        InputStream is = getClass().getResourceAsStream( file );\n\n        byte[] bytes = new byte[MINIMUM_DHCP_DATAGRAM_SIZE];\n\n        int offset = 0;\n        int numRead = 0;"}
{"magic_number_smell": "    {\n        try ( InputStream is = getClass().getResourceAsStream( file ) )\n        {\n            byte[] bytes = new byte[576];\n\n            int offset = 0;\n            int numRead = 0;", "refactored_code": "    protected static final int MINIMUM_DNS_DATAGRAM_SIZE = 576;\n    {\n        try ( InputStream is = getClass().getResourceAsStream( file ) )\n        {\n            byte[] bytes = new byte[MINIMUM_DNS_DATAGRAM_SIZE];\n\n            int offset = 0;\n            int numRead = 0;"}
{"magic_number_smell": "\n        int pos = cookieString.indexOf( COOKIE_DELIM );\n\n        // position should start from REPLICA_ID_PREFIX.length() or higher cause a cookie can be\n        // like \"rid=0,csn={csn}\" or \"rid=11,csn={csn}\"\n        if ( pos <= REPLICA_ID_PREFIX.length() )\n        {", "refactored_code": "    public static final int REPLICA_ID_PREFIX_LEN = REPLICA_ID_PREFIX.length();\n\n        int pos = cookieString.indexOf( COOKIE_DELIM );\n\n        // position should start from REPLICA_ID_PREFIX_LEN or higher cause a cookie can be\n        // like \"rid=0,csn={csn}\" or \"rid=11,csn={csn}\"\n        if ( pos <= REPLICA_ID_PREFIX_LEN )\n        {"}
{"magic_number_smell": "     */\n    public void checkNotClosed() throws CursorClosedException\n    {\n        if ( ( System.currentTimeMillis() > System.currentTimeMillis() + millisToLive ) && !closed )\n        {\n            // state check needed to \"try\" not to overwrite exception (lack of \n            // synchronization may still allow overwriting but who cares that ", "refactored_code": "    private final long startTime = System.currentTimeMillis();\n     */\n    public void checkNotClosed() throws CursorClosedException\n    {\n        if ( ( System.currentTimeMillis() > startTime + millisToLive ) && !closed )\n        {\n            // state check needed to \"try\" not to overwrite exception (lack of \n            // synchronization may still allow overwriting but who cares that "}
{"magic_number_smell": "    {\n        if ( purgeThresholdCount <= 0 )\n        {\n            purgeThresholdCount = 10000;\n        }\n\n        this.purgeThresholdCount = purgeThresholdCount;", "refactored_code": "    public static final int DEFAULT_PURGE_THRESHOLD_COUNT = 10000;\n    {\n        if ( purgeThresholdCount <= 0 )\n        {\n            purgeThresholdCount = DEFAULT_PURGE_THRESHOLD_COUNT;\n        }\n\n        this.purgeThresholdCount = purgeThresholdCount;"}
{"magic_number_smell": "        {\n            // Default to UDP with port 123\n            // We have to create a DatagramAcceptor\n            UdpTransport transport = new UdpTransport( 123 );\n            setTransports( transport );\n\n            DatagramAcceptor acceptor = transport.getAcceptor();", "refactored_code": "    private static final int IP_PORT_DEFAULT = 123;\n        {\n            // Default to UDP with port 123\n            // We have to create a DatagramAcceptor\n            UdpTransport transport = new UdpTransport( IP_PORT_DEFAULT );\n            setTransports( transport );\n\n            DatagramAcceptor acceptor = transport.getAcceptor();"}
{"magic_number_smell": "     */\n    public NtpTimeStamp( Date date )\n    {\n        long msSinceStartOfNtpEpoch = date.getTime() - -2208988800000L;\n\n        seconds = msSinceStartOfNtpEpoch / 1000;\n        fraction = ( ( msSinceStartOfNtpEpoch % 1000 ) * 0x100000000L ) / 1000;", "refactored_code": "    private static final long NTP_EPOCH_DIFFERENCE = -2208988800000L;\n     */\n    public NtpTimeStamp( Date date )\n    {\n        long msSinceStartOfNtpEpoch = date.getTime() - NTP_EPOCH_DIFFERENCE;\n\n        seconds = msSinceStartOfNtpEpoch / 1000;\n        fraction = ( ( msSinceStartOfNtpEpoch % 1000 ) * 0x100000000L ) / 1000;"}
{"magic_number_smell": "        address = null;\n        nbThreads = DEFAULT_NB_THREADS;\n        port = -1;\n        backlog = 50;\n    }\n\n", "refactored_code": "    protected static final int DEFAULT_BACKLOG_NB = 50;\n        address = null;\n        nbThreads = DEFAULT_NB_THREADS;\n        port = -1;\n        backlog = DEFAULT_BACKLOG_NB;\n    }\n\n"}
{"magic_number_smell": "\n    /** the size (number of index entries) for the cache */\n    @ConfigurationElement(attributeType = \"ads-indexCacheSize\", isOptional = true, defaultValue = \"100\")\n    private int indexCacheSize = 100;\n\n    /** duplicate limit before duplicate keys switch to using a btree for values */\n    @ConfigurationElement(attributeType = \"ads-indexNumDupLimit\", isOptional = true, defaultValue = \"512\")", "refactored_code": "    private static final int DEFAULT_INDEX_CACHE_SIZE = 100;\n\n    /** the size (number of index entries) for the cache */\n    @ConfigurationElement(attributeType = \"ads-indexCacheSize\", isOptional = true, defaultValue = \"100\")\n    private int indexCacheSize = DEFAULT_INDEX_CACHE_SIZE;\n\n    /** duplicate limit before duplicate keys switch to using a btree for values */\n    @ConfigurationElement(attributeType = \"ads-indexNumDupLimit\", isOptional = true, defaultValue = \"512\")"}
{"magic_number_smell": "\n    /** The backlog for the transport services */\n    @ConfigurationElement(attributeType = \"ads-transportBackLog\", isOptional = true, defaultValue = \"50\")\n    private int transportBackLog = 50;\n\n    /** The transport list of enabled ciphers */\n    @ConfigurationElement(attributeType = \"ads-enabledCiphers\", isOptional = true)", "refactored_code": "    private static final int DEFAULT_BACKLOG_NB = 50;\n\n    /** The backlog for the transport services */\n    @ConfigurationElement(attributeType = \"ads-transportBackLog\", isOptional = true, defaultValue = \"50\")\n    private int transportBackLog = DEFAULT_BACKLOG_NB;\n\n    /** The transport list of enabled ciphers */\n    @ConfigurationElement(attributeType = \"ads-enabledCiphers\", isOptional = true)"}
{"magic_number_smell": "        String host = System.getProperty( testServer + \".host\", Network.LOOPBACK_HOSTNAME );\n        LOG.debug( \"{}.host = {}\", testServer, host );\n\n        int port = Integer.parseInt( System.getProperty( testServer + \".port\", Integer.toString( 10389 ) ) );\n        LOG.debug( \"{}.port = {}\", testServer, port );\n\n        LdapConnection conn = new LdapNetworkConnection( host, port );", "refactored_code": "    private static final int DEFAULT_PORT = 10389;\n        String host = System.getProperty( testServer + \".host\", Network.LOOPBACK_HOSTNAME );\n        LOG.debug( \"{}.host = {}\", testServer, host );\n\n        int port = Integer.parseInt( System.getProperty( testServer + \".port\", Integer.toString( DEFAULT_PORT ) ) );\n        LOG.debug( \"{}.port = {}\", testServer, port );\n\n        LdapConnection conn = new LdapNetworkConnection( host, port );"}
{"magic_number_smell": "\n    private static final int 10 = 10;\n\n    private static final int TOTAL_COUNT = 10 + 1;\n\n    private static File cookiesDir;\n", "refactored_code": "    private static final int INSERT_COUNT = 10;\n\n    private static final int INSERT_COUNT = 10;\n\n    private static final int TOTAL_COUNT = INSERT_COUNT + 1;\n\n    private static File cookiesDir;\n"}
{"magic_number_smell": "\n    private static final int 10 = 10;\n\n    private static final int TOTAL_COUNT = 10 + 1;\n\n    private static File cookiesDir;\n", "refactored_code": "    private static final int INSERT_COUNT = 10;\n\n    private static final int INSERT_COUNT = 10;\n\n    private static final int TOTAL_COUNT = INSERT_COUNT + 1;\n\n    private static File cookiesDir;\n"}
{"magic_number_smell": "     * store with the installed self signed certificate.  It then searches \n     * the server and verifies the presence of the expected entries and closes\n     * the connection.  This process repeats for a number of iterations.  \n     * Modify the 10 constant to change the number of \n     * iterations.  Modify the VERBOSE constant to print out information while\n     * performing searches.\n     */", "refactored_code": "    private static final int CONNECT_ITERATIONS = 10;\n     * store with the installed self signed certificate.  It then searches \n     * the server and verifies the presence of the expected entries and closes\n     * the connection.  This process repeats for a number of iterations.  \n     * Modify the CONNECT_ITERATIONS constant to change the number of \n     * iterations.  Modify the VERBOSE constant to print out information while\n     * performing searches.\n     */"}
{"magic_number_smell": "    private static final long 20000 = 20000;\n\n    /** Wainting period between two flushes to the backend */\n    private long synchPeriodMillis = 20000;\n\n    /** Directory where are stored the LDIF files to be loaded at startup */\n    private File ldifDirectory;", "refactored_code": "    private static final long DEFAULT_SYNC_PERIOD_MILLIS = 20000;\n    private static final long DEFAULT_SYNC_PERIOD_MILLIS = 20000;\n\n    /** Wainting period between two flushes to the backend */\n    private long synchPeriodMillis = DEFAULT_SYNC_PERIOD_MILLIS;\n\n    /** Directory where are stored the LDIF files to be loaded at startup */\n    private File ldifDirectory;"}
{"magic_number_smell": "    public static final int 10000 = 10000;\n\n    /** The Entry cache size for this partition */\n    protected int cacheSize = 10000;\n\n    /** The alias cache */\n    protected Cache<String, Dn> aliasCache;", "refactored_code": "    public static final int DEFAULT_CACHE_SIZE = 10000;\n    public static final int DEFAULT_CACHE_SIZE = 10000;\n\n    /** The Entry cache size for this partition */\n    protected int cacheSize = DEFAULT_CACHE_SIZE;\n\n    /** The alias cache */\n    protected Cache<String, Dn> aliasCache;"}
{"magic_number_smell": "    private static final int 10 = 10;\n\n    /**\n     * A list of the 10 last errors or warnings.\n     */\n    private final List<String> stderr = new ArrayList<>();\n", "refactored_code": "    private static final int MAX_STDERR_SIZE = 10;\n    private static final int MAX_STDERR_SIZE = 10;\n\n    /**\n     * A list of the MAX_STDERR_SIZE last errors or warnings.\n     */\n    private final List<String> stderr = new ArrayList<>();\n"}
{"magic_number_smell": "    public void consumeLine(String line) {\n        if (line.startsWith(INDEX_TOKEN)) {\n            // start a new file\n            currentFile = line.substring(INDEX_TOKEN.length() + 12 + 1);\n\n            changedFiles.add(new ScmFile(currentFile, ScmFileStatus.MODIFIED));\n", "refactored_code": "    private static final int HASH_ID_LEN = 12;\n    public void consumeLine(String line) {\n        if (line.startsWith(INDEX_TOKEN)) {\n            // start a new file\n            currentFile = line.substring(INDEX_TOKEN.length() + HASH_ID_LEN + 1);\n\n            changedFiles.add(new ScmFile(currentFile, ScmFileStatus.MODIFIED));\n"}
{"magic_number_smell": "    /**\n     * Current status of the parser\n     */\n    private int status = 1;\n\n    /**\n     * List of change log entries", "refactored_code": "    private static final int STATUS_GET_HEADER = 1;\n    /**\n     * Current status of the parser\n     */\n    private int status = STATUS_GET_HEADER;\n\n    /**\n     * List of change log entries"}
{"magic_number_smell": "        Commandline cli = GitCommandLineUtils.getBaseGitCommandLine(fileSet.getBasedir(), \"rev-parse\");\n        cli.createArg().setValue(\"--verify\");\n        final int revLength = getRevisionLength(parameters);\n        if (revLength > -1) // set the --short key only if revision length parameter is passed and\n        // different from -1\n        {\n            cli.createArg().setValue(\"--short=\" + revLength);", "refactored_code": "    public static final int NO_REVISION_LENGTH = -1;\n        Commandline cli = GitCommandLineUtils.getBaseGitCommandLine(fileSet.getBasedir(), \"rev-parse\");\n        cli.createArg().setValue(\"--verify\");\n        final int revLength = getRevisionLength(parameters);\n        if (revLength > NO_REVISION_LENGTH) // set the --short key only if revision length parameter is passed and\n        // different from -1\n        {\n            cli.createArg().setValue(\"--short=\" + revLength);"}
{"magic_number_smell": "\n    @Test\n    public void testChangeLogCommandFromHeadAncestorAndHead() throws Exception {\n        Thread.sleep(250L);\n        ScmRepository scmRepository = getScmRepository();\n        ScmProvider provider = getScmManager().getProviderByRepository(scmRepository);\n        ScmFileSet fileSet = new ScmFileSet(getWorkingCopy());", "refactored_code": "    public static final long SLEEP_TIME_IN_MILLIS = 250L;\n\n    @Test\n    public void testChangeLogCommandFromHeadAncestorAndHead() throws Exception {\n        Thread.sleep(SLEEP_TIME_IN_MILLIS);\n        ScmRepository scmRepository = getScmRepository();\n        ScmProvider provider = getScmManager().getProviderByRepository(scmRepository);\n        ScmFileSet fileSet = new ScmFileSet(getWorkingCopy());"}
{"magic_number_smell": "    /**\n     * Current status of the parser\n     */\n    private int status = 1;\n\n    /**\n     * List of change log entries", "refactored_code": "    private static final int GET_HEADER = 1;\n    /**\n     * Current status of the parser\n     */\n    private int status = GET_HEADER;\n\n    /**\n     * List of change log entries"}
{"magic_number_smell": "  public AbstractSecurityToken enforceNotExpired() throws BlobExpiredException {\n    Long expiresAt = getExpiresAt();\n    if (expiresAt != null) {\n      long maxTime = expiresAt + 180;\n      long now = getTimeSource().currentTimeMillis() / 1000;\n\n      if (!(now < maxTime)) {", "refactored_code": "  private static final long CLOCK_SKEW_ALLOWANCE = 180;\n  public AbstractSecurityToken enforceNotExpired() throws BlobExpiredException {\n    Long expiresAt = getExpiresAt();\n    if (expiresAt != null) {\n      long maxTime = expiresAt + CLOCK_SKEW_ALLOWANCE;\n      long now = getTimeSource().currentTimeMillis() / 1000;\n\n      if (!(now < maxTime)) {"}
{"magic_number_smell": "      }\n\n      BasicSecurityToken basicToken = new BasicSecurityToken(\n          Utf8UrlCoder.decode(tokens[0]),\n          Utf8UrlCoder.decode(tokens[VIEWER_INDEX]),\n          Utf8UrlCoder.decode(tokens[APP_ID_INDEX]),\n          Utf8UrlCoder.decode(tokens[DOMAIN_INDEX]),", "refactored_code": "  private static final int OWNER_INDEX = 0;\n      }\n\n      BasicSecurityToken basicToken = new BasicSecurityToken(\n          Utf8UrlCoder.decode(tokens[OWNER_INDEX]),\n          Utf8UrlCoder.decode(tokens[VIEWER_INDEX]),\n          Utf8UrlCoder.decode(tokens[APP_ID_INDEX]),\n          Utf8UrlCoder.decode(tokens[DOMAIN_INDEX]),"}
{"magic_number_smell": "   * Serialize a JSONObject. Does not guard against cyclical references.\n   */\n  public static String serialize(JSONObject object) {\n    StringBuilder buf = new StringBuilder(object.length() * 256);\n    try {\n      appendJsonObject(buf, object);\n    } catch (IOException e) {", "refactored_code": "  private static final int BASE_MULTIPLIER = 256;\n   * Serialize a JSONObject. Does not guard against cyclical references.\n   */\n  public static String serialize(JSONObject object) {\n    StringBuilder buf = new StringBuilder(object.length() * BASE_MULTIPLIER);\n    try {\n      appendJsonObject(buf, object);\n    } catch (IOException e) {"}
{"magic_number_smell": "    Preconditions.checkArgument(masterKey.length >= MASTER_KEY_MIN_LEN,\n        \"Master key needs at least %s bytes\", MASTER_KEY_MIN_LEN);\n\n    cipherKey = deriveKey(0, masterKey, Crypto.CIPHER_KEY_LEN);\n    hmacKey = deriveKey(HMAC_KEY_LABEL, masterKey, 0);\n  }\n", "refactored_code": "  private static final byte CIPHER_KEY_LABEL = 0;\n    Preconditions.checkArgument(masterKey.length >= MASTER_KEY_MIN_LEN,\n        \"Master key needs at least %s bytes\", MASTER_KEY_MIN_LEN);\n\n    cipherKey = deriveKey(CIPHER_KEY_LABEL, masterKey, Crypto.CIPHER_KEY_LEN);\n    hmacKey = deriveKey(HMAC_KEY_LABEL, masterKey, 0);\n  }\n"}
{"magic_number_smell": "   */\n  public static byte[] aes128cbcDecrypt(byte[] key, byte[] cipherText)\n  throws GeneralSecurityException {\n    byte iv[] = new byte[16];\n    System.arraycopy(cipherText, 0, iv, 0, iv.length);\n    return aes128cbcDecryptWithIv(key, iv, cipherText, iv.length);\n  }", "refactored_code": "  private static final int CIPHER_BLOCK_SIZE = 16;\n   */\n  public static byte[] aes128cbcDecrypt(byte[] key, byte[] cipherText)\n  throws GeneralSecurityException {\n    byte iv[] = new byte[CIPHER_BLOCK_SIZE];\n    System.arraycopy(cipherText, 0, iv, 0, iv.length);\n    return aes128cbcDecryptWithIv(key, iv, cipherText, iv.length);\n  }"}
{"magic_number_smell": "\n  private static byte[] digest(MessageDigest digest, InputStream data)\n      throws IOException {\n    byte[] buffer = new byte[1024];\n    int read = data.read(buffer, 0, 1024);\n\n    while (read > -1) {", "refactored_code": "  private static final int STREAM_BUFFER_LENGTH = 1024;\n\n  private static byte[] digest(MessageDigest digest, InputStream data)\n      throws IOException {\n    byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {"}
{"magic_number_smell": "  private static final int 2 = 2;\n\n  private final LruCache<String, String> cache\n      = new LruCache<String, String>(2);\n\n  @Test\n  public void normalCapacityOk() {", "refactored_code": "  private static final int TEST_CAPACITY = 2;\n  private static final int TEST_CAPACITY = 2;\n\n  private final LruCache<String, String> cache\n      = new LruCache<String, String>(TEST_CAPACITY);\n\n  @Test\n  public void normalCapacityOk() {"}
{"magic_number_smell": "  @Test\n  public void testSetCachingHeaders() {\n    HttpUtil.setCachingHeaders(recorder);\n    checkCacheControlHeaders(timeSource.currentTimeMillis(), recorder, HttpUtil.getDefaultTtl(), false);\n  }\n\n  @Test", "refactored_code": "  public static final long testStartTime = timeSource.currentTimeMillis();\n  @Test\n  public void testSetCachingHeaders() {\n    HttpUtil.setCachingHeaders(recorder);\n    checkCacheControlHeaders(testStartTime, recorder, HttpUtil.getDefaultTtl(), false);\n  }\n\n  @Test"}
{"magic_number_smell": "  }\n\n  public FakeHttpServletRequest() {\n    this(DEFAULT_HOST, 80, \"\", null, null);\n  }\n\n  public FakeHttpServletRequest(String urlStr) throws MalformedURLException {", "refactored_code": "  protected static final int DEFAULT_PORT = 80;\n  }\n\n  public FakeHttpServletRequest() {\n    this(DEFAULT_HOST, DEFAULT_PORT, \"\", null, null);\n  }\n\n  public FakeHttpServletRequest(String urlStr) throws MalformedURLException {"}
{"magic_number_smell": "      if (origUrl.getPort() <= 0 && origHost != null && origHost.length() != 0\n              && !STAR.equals(origHost)) {\n        if (origUrl.getProtocol().equalsIgnoreCase(HTTP)) {\n          urlWithPort = new URL(origUrl.getProtocol(), origUrl.getHost(), 80, origUrl.getFile());\n        }\n        else if (origUrl.getProtocol().equalsIgnoreCase(HTTPS)) {\n          urlWithPort = new URL(origUrl.getProtocol(), origUrl.getHost(), HTTPS_PORT, origUrl.getFile());", "refactored_code": "  private static final int HTTP_PORT = 80;\n      if (origUrl.getPort() <= 0 && origHost != null && origHost.length() != 0\n              && !STAR.equals(origHost)) {\n        if (origUrl.getProtocol().equalsIgnoreCase(HTTP)) {\n          urlWithPort = new URL(origUrl.getProtocol(), origUrl.getHost(), HTTP_PORT, origUrl.getFile());\n        }\n        else if (origUrl.getProtocol().equalsIgnoreCase(HTTPS)) {\n          urlWithPort = new URL(origUrl.getProtocol(), origUrl.getHost(), HTTPS_PORT, origUrl.getFile());"}
{"magic_number_smell": "  @Inject\n  public BasicHttpFetcher(@Nullable @Named(\"org.apache.shindig.gadgets.http.basicHttpFetcherProxy\")\n                          String basicHttpFetcherProxy) {\n    this(DEFAULT_MAX_OBJECT_SIZE, 5000, DEFAULT_READ_TIMEOUT_MS,\n         basicHttpFetcherProxy);\n  }\n", "refactored_code": "  private static final int DEFAULT_CONNECT_TIMEOUT_MS = 5000;\n  @Inject\n  public BasicHttpFetcher(@Nullable @Named(\"org.apache.shindig.gadgets.http.basicHttpFetcherProxy\")\n                          String basicHttpFetcherProxy) {\n    this(DEFAULT_MAX_OBJECT_SIZE, DEFAULT_CONNECT_TIMEOUT_MS, DEFAULT_READ_TIMEOUT_MS,\n         basicHttpFetcherProxy);\n  }\n"}
{"magic_number_smell": "\n  public CacheKeyBuilder() {\n    this.paramMap = Maps.newTreeMap();\n    this.legacyParams = new Object[9];\n  }\n\n  private String getValueOrDefault(Object value) {", "refactored_code": "  private static final int NUM_LEGACY_PARAMS = 9;\n\n  public CacheKeyBuilder() {\n    this.paramMap = Maps.newTreeMap();\n    this.legacyParams = new Object[NUM_LEGACY_PARAMS];\n  }\n\n  private String getValueOrDefault(Object value) {"}
{"magic_number_smell": "  private final FeatureRegistryProvider registryProvider;\n  private final JsCompiler compiler;\n\n  private int versionedMaxAge = -1;\n  private int unversionedMaxAge = DEFAULT_UNVERSIONED_MAXAGE;\n  private int invalidMaxAge = DEFAULT_INVALID_MAXAGE;\n", "refactored_code": "  public static final int DEFAULT_VERSIONED_MAXAGE = -1;\n  private final FeatureRegistryProvider registryProvider;\n  private final JsCompiler compiler;\n\n  private int versionedMaxAge = DEFAULT_VERSIONED_MAXAGE;\n  private int unversionedMaxAge = DEFAULT_UNVERSIONED_MAXAGE;\n  private int invalidMaxAge = DEFAULT_INVALID_MAXAGE;\n"}
{"magic_number_smell": "\n  public static final int -1 = -1;\n\n  private int versionedMaxAge = -1;\n\n  @Inject(optional=true)\n  public void setVersionedMaxAge(@Named(\"shindig.jscontent.versioned.maxage\") Integer maxAge) {", "refactored_code": "  public static final int DEFAULT_VERSIONED_MAXAGE = -1;\n\n  public static final int DEFAULT_VERSIONED_MAXAGE = -1;\n\n  private int versionedMaxAge = DEFAULT_VERSIONED_MAXAGE;\n\n  @Inject(optional=true)\n  public void setVersionedMaxAge(@Named(\"shindig.jscontent.versioned.maxage\") Integer maxAge) {"}
{"magic_number_smell": "      accessorInfo.setSessionHandle(null);\n      accessorInfo.setTokenExpireMillis(ACCESS_TOKEN_EXPIRE_UNKNOWN);\n    }\n    return (attempts < 2 && pe.canRetry());\n  }\n\n  /**", "refactored_code": "  private static final int MAX_ATTEMPTS = 2;\n      accessorInfo.setSessionHandle(null);\n      accessorInfo.setTokenExpireMillis(ACCESS_TOKEN_EXPIRE_UNKNOWN);\n    }\n    return (attempts < MAX_ATTEMPTS && pe.canRetry());\n  }\n\n  /**"}
{"magic_number_smell": "              BasicOAuth2Request.haveRefreshToken(accessor) != null);\n    }\n\n    if (this.attemptCounter > BasicOAuth2Request.3) {\n      if (isLogging) {\n        BasicOAuth2Request.LOG.log(\"3 exceeded {0}\", this.attemptCounter);\n        // This can be useful to diagnose the recursion", "refactored_code": "  private static final short MAX_ATTEMPTS = 3;\n              BasicOAuth2Request.haveRefreshToken(accessor) != null);\n    }\n\n    if (this.attemptCounter > BasicOAuth2Request.MAX_ATTEMPTS) {\n      if (isLogging) {\n        BasicOAuth2Request.LOG.log(\"MAX_ATTEMPTS exceeded {0}\", this.attemptCounter);\n        // This can be useful to diagnose the recursion"}
{"magic_number_smell": "      }\n\n      batchCount++;\n      if (batchCount == 3) {\n        break;\n      }\n    }", "refactored_code": "  private static final int MAX_BATCH_COUNT = 3;\n      }\n\n      batchCount++;\n      if (batchCount == MAX_BATCH_COUNT) {\n        break;\n      }\n    }"}
{"magic_number_smell": "      ImageInfo imageInfo) {\n    long imagePixels = abs(requestedHeight) * abs(requestedWidth);\n    long imageSizeBits = imagePixels * imageInfo.getBitsPerPixel();\n    return imageSizeBits > config.getMaxInMemoryBytes() * 8;\n  }\n\n  protected boolean isSupportedImageResult(HttpResponseBuilder response, Uri uri) {", "refactored_code": "  private static final int BITS_PER_BYTE = 8;\n      ImageInfo imageInfo) {\n    long imagePixels = abs(requestedHeight) * abs(requestedWidth);\n    long imageSizeBits = imagePixels * imageInfo.getBitsPerPixel();\n    return imageSizeBits > config.getMaxInMemoryBytes() * BITS_PER_BYTE;\n  }\n\n  protected boolean isSupportedImageResult(HttpResponseBuilder response, Uri uri) {"}
{"magic_number_smell": "      public boolean visitSegment(int marker, byte markerBytes[], int markerLength,\n          byte markerLengthBytes[], byte segmentData[]) throws ImageReadException, IOException {\n\n        if (marker == 0xffd9)\n          return false;\n\n        if ((marker == JpegConstants.SOF0Marker) || (marker == JpegConstants.SOF2Marker)) {", "refactored_code": "  private static final int END_OF_IMAGE_MARKER = 0xffd9;\n      public boolean visitSegment(int marker, byte markerBytes[], int markerLength,\n          byte markerLengthBytes[], byte segmentData[]) throws ImageReadException, IOException {\n\n        if (marker == END_OF_IMAGE_MARKER)\n          return false;\n\n        if ((marker == JpegConstants.SOF0Marker) || (marker == JpegConstants.SOF2Marker)) {"}
{"magic_number_smell": "  private final Map<String, Future<CompileResult>> compiling;\n\n  private int threadPoolSize = 5;\n  private long compilerStackSize = 1048576L;\n  private ExecutorService compilerPool;\n\n  @Inject", "refactored_code": "  private static final long DEFAULT_COMPILER_STACK_SIZE = 1048576L;\n  private final Map<String, Future<CompileResult>> compiling;\n\n  private int threadPoolSize = 5;\n  private long compilerStackSize = DEFAULT_COMPILER_STACK_SIZE;\n  private ExecutorService compilerPool;\n\n  @Inject"}
{"magic_number_smell": "    private static final int 16384 = 16384;\n\n    private MessageDigest digest = null;\n    private ByteArrayBuffer buffer = new ByteArrayBuffer(16384);\n\n    @Override\n    public void write(int b) throws IOException {", "refactored_code": "    private static final int BUFFER_INITIAL_CAPACITY = 16384;\n    private static final int BUFFER_INITIAL_CAPACITY = 16384;\n\n    private MessageDigest digest = null;\n    private ByteArrayBuffer buffer = new ByteArrayBuffer(BUFFER_INITIAL_CAPACITY);\n\n    @Override\n    public void write(int b) throws IOException {"}
{"magic_number_smell": "    for (String container : changed) {\n      Integer maxPostSize = config.getInt(container, MAX_POST_SIZE_KEY);\n      if (maxPostSize == 0) {\n        maxPostSize = 5 * 1024 * 1024;\n      }\n      maxPostSizes.put(container, maxPostSize);\n      Map<String, Map<String, String>> features = config.getMap(container, GADGETS_FEATURES);", "refactored_code": "  public static final int MAX_POST_SIZE_DEFAULT = 5 * 1024 * 1024; // 5 MiB\n    for (String container : changed) {\n      Integer maxPostSize = config.getInt(container, MAX_POST_SIZE_KEY);\n      if (maxPostSize == 0) {\n        maxPostSize = MAX_POST_SIZE_DEFAULT;\n      }\n      maxPostSizes.put(container, maxPostSize);\n      Map<String, Map<String, String>> features = config.getMap(container, GADGETS_FEATURES);"}
{"magic_number_smell": "    // Similar versioning method to other APIs, implemented more compactly.\n    String v = req.getParameter(UriCommon.Param.VERSION.getKey());\n    if (v != null && v.equals(hash)) {\n      HttpUtil.setCachingHeaders(resp, 365 * 24 * 60 * 60, true);\n    } else {\n      HttpUtil.setCachingHeaders(resp, defaultSwfTtl, true);\n    }", "refactored_code": "  private static final int ONE_YEAR_IN_SEC = 365 * 24 * 60 * 60;\n    // Similar versioning method to other APIs, implemented more compactly.\n    String v = req.getParameter(UriCommon.Param.VERSION.getKey());\n    if (v != null && v.equals(hash)) {\n      HttpUtil.setCachingHeaders(resp, ONE_YEAR_IN_SEC, true);\n    } else {\n      HttpUtil.setCachingHeaders(resp, defaultSwfTtl, true);\n    }"}
{"magic_number_smell": "    // Allowed Max Url length is .80 times of actual max length. So, Split will\n    // happen whenever Concat url length crosses this value. Here, buffer also assumes\n    // version length.\n    int injectedMaxUrlLength = (int) (this.getUrlMaxLength() * .8f);\n\n    // batchUris holds uris for the current batch of uris being concatenated.\n    List<Uri> batchUris = Lists.newArrayList();", "refactored_code": "  private static final float URL_LENGTH_BUFFER_MARGIN = .8f;\n    // Allowed Max Url length is .80 times of actual max length. So, Split will\n    // happen whenever Concat url length crosses this value. Here, buffer also assumes\n    // version length.\n    int injectedMaxUrlLength = (int) (this.getUrlMaxLength() * URL_LENGTH_BUFFER_MARGIN);\n\n    // batchUris holds uris for the current batch of uris being concatenated.\n    List<Uri> batchUris = Lists.newArrayList();"}
{"magic_number_smell": "  private final CacheProvider cacheProvider = new LruCacheProvider(5);\n\n  private final DefaultGadgetSpecFactory specFactory\n      = new DefaultGadgetSpecFactory(executor, pipeline, cacheProvider, 10000);\n\n  private static HttpRequest createIgnoreCacheRequest() {\n    return new HttpRequest(SPEC_URL)", "refactored_code": "  private static final int MAX_AGE = 10000;\n  private final CacheProvider cacheProvider = new LruCacheProvider(5);\n\n  private final DefaultGadgetSpecFactory specFactory\n      = new DefaultGadgetSpecFactory(executor, pipeline, cacheProvider, MAX_AGE);\n\n  private static HttpRequest createIgnoreCacheRequest() {\n    return new HttpRequest(SPEC_URL)"}
{"magic_number_smell": "  private final Cache<String, MessageBundle> cache\n      = cacheProvider.createCache(DefaultMessageBundleFactory.CACHE_NAME);\n  private final DefaultMessageBundleFactory bundleFactory\n      = new DefaultMessageBundleFactory(new ImmediateExecutorService(), pipeline, cacheProvider, 10000);\n  private final GadgetSpec gadgetSpec;\n  private final GadgetSpec externalSpec;\n", "refactored_code": "  private static final int MAX_AGE = 10000;\n  private final Cache<String, MessageBundle> cache\n      = cacheProvider.createCache(DefaultMessageBundleFactory.CACHE_NAME);\n  private final DefaultMessageBundleFactory bundleFactory\n      = new DefaultMessageBundleFactory(new ImmediateExecutorService(), pipeline, cacheProvider, MAX_AGE);\n  private final GadgetSpec gadgetSpec;\n  private final GadgetSpec externalSpec;\n"}
{"magic_number_smell": "  @BeforeClass\n  public static void setUpOnce() throws Exception {\n    server = new EchoServer();\n    server.start(9003);\n  }\n\n  @AfterClass", "refactored_code": "  private static final int ECHO_PORT = 9003;\n  @BeforeClass\n  public static void setUpOnce() throws Exception {\n    server = new EchoServer();\n    server.start(ECHO_PORT);\n  }\n\n  @AfterClass"}
{"magic_number_smell": "  @BeforeClass\n  public static void setUpOnce() throws Exception {\n    server = new EchoServer();\n    server.start(9003);\n  }\n\n  @AfterClass", "refactored_code": "  private static final int ECHO_PORT = 9003;\n  @BeforeClass\n  public static void setUpOnce() throws Exception {\n    server = new EchoServer();\n    server.start(ECHO_PORT);\n  }\n\n  @AfterClass"}
{"magic_number_smell": "    EasyMock.expect(response.getCharacterEncoding()).andReturn(ENCODING).anyTimes();\n    EasyMock.expect(request.getHeader(ETaggingHttpResponse.REQUEST_HEADER)).andReturn(null);\n    response.setHeader(ETaggingHttpResponse.RESPONSE_HEADER, '\"' + GOOD_ETAG + '\"');\n    response.setContentLength(RESPONSE_BODY_BYTES.length);\n  }\n\n  @Test", "refactored_code": "  private static final int RESPONSE_BODY_LENGTH = RESPONSE_BODY_BYTES.length;\n    EasyMock.expect(response.getCharacterEncoding()).andReturn(ENCODING).anyTimes();\n    EasyMock.expect(request.getHeader(ETaggingHttpResponse.REQUEST_HEADER)).andReturn(null);\n    response.setHeader(ETaggingHttpResponse.RESPONSE_HEADER, '\"' + GOOD_ETAG + '\"');\n    response.setContentLength(RESPONSE_BODY_LENGTH);\n  }\n\n  @Test"}
{"magic_number_smell": "\n  private void expectFullResponse() {\n    origResponse.setHeader(ETaggingHttpResponse.RESPONSE_HEADER, '\"' + GOOD_ETAG + '\"');\n    origResponse.setContentLength(RESPONSE_BODY_BYTES.length);\n  }\n\n  private void expectNotModifiedResponse(String eTag) {", "refactored_code": "  private static final int RESPONSE_BODY_LENGTH = RESPONSE_BODY_BYTES.length;\n\n  private void expectFullResponse() {\n    origResponse.setHeader(ETaggingHttpResponse.RESPONSE_HEADER, '\"' + GOOD_ETAG + '\"');\n    origResponse.setContentLength(RESPONSE_BODY_LENGTH);\n  }\n\n  private void expectNotModifiedResponse(String eTag) {"}
{"magic_number_smell": "      \"  <EnumValue value=\\\"foo\\\" display_value=\\\"disp4\\\"/>\" +\n      \"</UserPref>\" +\n      \"<Content type=\\\"html\\\"\" +\n      \" preferred_height = \\\"\" + 100 + '\\\"' +\n      \" preferred_width = \\\"\" + PREFERRED_WIDTH + '\\\"' +\n      \">Hello, world</Content>\" +\n      \"</Module>\";", "refactored_code": "  public static final int PREFERRED_HEIGHT = 100;\n      \"  <EnumValue value=\\\"foo\\\" display_value=\\\"disp4\\\"/>\" +\n      \"</UserPref>\" +\n      \"<Content type=\\\"html\\\"\" +\n      \" preferred_height = \\\"\" + PREFERRED_HEIGHT + '\\\"' +\n      \" preferred_width = \\\"\" + PREFERRED_WIDTH + '\\\"' +\n      \">Hello, world</Content>\" +\n      \"</Module>\";"}
{"magic_number_smell": "  public void testWithIfModifiedSinceHeaderPresentAndVersionReturnsNotModified() throws Exception {\n    setUp(0);\n    JsUri jsUri = mockJsUri(CONTAINER_PARAM, RenderingContext.CONTAINER, false, false, false,\n        null, 200, UriStatus.VALID_VERSIONED);\n    expect(jsUriManagerMock.processExternJsUri(isA(Uri.class))).andReturn(jsUri);\n    expect(request.getHeader(\"If-Modified-Since\")).andReturn(\"12345\");\n    replay();", "refactored_code": "  private static final int REFRESH_INTERVAL_SEC = 200;\n  public void testWithIfModifiedSinceHeaderPresentAndVersionReturnsNotModified() throws Exception {\n    setUp(0);\n    JsUri jsUri = mockJsUri(CONTAINER_PARAM, RenderingContext.CONTAINER, false, false, false,\n        null, REFRESH_INTERVAL_SEC, UriStatus.VALID_VERSIONED);\n    expect(jsUriManagerMock.processExternJsUri(isA(Uri.class))).andReturn(jsUri);\n    expect(request.getHeader(\"If-Modified-Since\")).andReturn(\"12345\");\n    replay();"}
{"magic_number_smell": "    assertEquals(prefVal, urlGadgetUri.getQueryParameter(\"up_\" + prefKey));\n\n    // Only the params that are needed.\n    assertEquals(8 + 1, urlGadgetUri.getQueryParameters().size());\n    assertEquals(0, urlGadgetUri.getFragmentParameters().size());\n\n    assertFalse(manager.tokenForRenderingCalled());", "refactored_code": "  private static final int TYPE_URL_NUM_BASE_PARAMS = 8;\n    assertEquals(prefVal, urlGadgetUri.getQueryParameter(\"up_\" + prefKey));\n\n    // Only the params that are needed.\n    assertEquals(TYPE_URL_NUM_BASE_PARAMS + 1, urlGadgetUri.getQueryParameters().size());\n    assertEquals(0, urlGadgetUri.getFragmentParameters().size());\n\n    assertFalse(manager.tokenForRenderingCalled());"}
{"magic_number_smell": "  private static final String CONCAT_BASE = \"/gadgets/concat\";\n  private static final String JS_BASE = \"/gadgets/js/*\";\n  private static final String MAKE_REQUEST_BASE = \"/gadgets/makeRequest\";\n  public static final String SERVER_URL = \"http://localhost:\" + 9003;\n  public static final String GADGET_BASEURL = SERVER_URL + GADGET_BASE;\n\n  private final Server server;", "refactored_code": "  private static final int JETTY_PORT = 9003;\n  private static final String CONCAT_BASE = \"/gadgets/concat\";\n  private static final String JS_BASE = \"/gadgets/js/*\";\n  private static final String MAKE_REQUEST_BASE = \"/gadgets/makeRequest\";\n  public static final String SERVER_URL = \"http://localhost:\" + JETTY_PORT;\n  public static final String GADGET_BASEURL = SERVER_URL + GADGET_BASE;\n\n  private final Server server;"}
{"magic_number_smell": "      expirationTime += FIVE_MINUTES;\n      break;\n    case ACCESS:\n      expirationTime += 365 * 24 * 60 * 60 * 1000L;\n      break;\n    }\n", "refactored_code": "  public static final long ONE_YEAR = 365 * 24 * 60 * 60 * 1000L;\n      expirationTime += FIVE_MINUTES;\n      break;\n    case ACCESS:\n      expirationTime += ONE_YEAR;\n      break;\n    }\n"}
{"magic_number_smell": "    entry.setAuthorized(true);\n    entry.setUserId(Preconditions.checkNotNull(userId));\n    if (entry.isCallbackUrlSigned()) {\n      entry.setCallbackToken(Crypto.getRandomDigits(6));\n    }\n  }\n", "refactored_code": "  private static final int CALLBACK_TOKEN_LENGTH = 6;\n    entry.setAuthorized(true);\n    entry.setUserId(Preconditions.checkNotNull(userId));\n    if (entry.isCallbackUrlSigned()) {\n      entry.setCallbackToken(Crypto.getRandomDigits(CALLBACK_TOKEN_LENGTH));\n    }\n  }\n"}
{"magic_number_smell": "    protected void configure() {\n      // Bind string values, to match what happens when reading the shindig.properties file.\n      bindConstant().annotatedWith(Names.named(\"shindig.oauth2.authCodeExpiration\"))\n          .to(Long.toString(300000));\n      bindConstant().annotatedWith(Names.named(\"shindig.oauth2.accessTokenExpiration\"))\n          .to(Long.toString(EXPECTED_ACCESSTOKEN_EXPIRATION));\n", "refactored_code": "  private static final long EXPECTED_AUTHCODE_EXPIRATION = 300000;\n    protected void configure() {\n      // Bind string values, to match what happens when reading the shindig.properties file.\n      bindConstant().annotatedWith(Names.named(\"shindig.oauth2.authCodeExpiration\"))\n          .to(Long.toString(EXPECTED_AUTHCODE_EXPIRATION));\n      bindConstant().annotatedWith(Names.named(\"shindig.oauth2.accessTokenExpiration\"))\n          .to(Long.toString(EXPECTED_ACCESSTOKEN_EXPIRATION));\n"}
{"magic_number_smell": "    private Hashtable<String, String> createLdapEnvironment() {\n        Hashtable<String, String> ldapEnvironment = new Hashtable<String, String>();\n        ldapEnvironment.put(LdapContext.CONTROL_FACTORIES, DefaultResponseControlFactory.class.getName());\n        ldapEnvironment.put(Context.PROVIDER_URL, String.format(\"ldap://localhost:%1$s\", 27389));\n        ldapEnvironment.put(Context.INITIAL_CONTEXT_FACTORY, LdapCtxFactory.class.getName());\n        ldapEnvironment.put(Context.SECURITY_PRINCIPAL, \"uid=admin,ou=system\");\n        ldapEnvironment.put(Context.SECURITY_CREDENTIALS, \"secret\");", "refactored_code": "    public static final int LDAP_PORT = 27389;\n    private Hashtable<String, String> createLdapEnvironment() {\n        Hashtable<String, String> ldapEnvironment = new Hashtable<String, String>();\n        ldapEnvironment.put(LdapContext.CONTROL_FACTORIES, DefaultResponseControlFactory.class.getName());\n        ldapEnvironment.put(Context.PROVIDER_URL, String.format(\"ldap://localhost:%1$s\", LDAP_PORT));\n        ldapEnvironment.put(Context.INITIAL_CONTEXT_FACTORY, LdapCtxFactory.class.getName());\n        ldapEnvironment.put(Context.SECURITY_PRINCIPAL, \"uid=admin,ou=system\");\n        ldapEnvironment.put(Context.SECURITY_CREDENTIALS, \"secret\");"}
{"magic_number_smell": "\n    private StringBuilder stdOut = new StringBuilder();\n\n    private int resultCode = -1;\n\n    private long startTime;\n", "refactored_code": "    public static final int UNDEFINED = -1;\n\n    private StringBuilder stdOut = new StringBuilder();\n\n    private int resultCode = UNDEFINED;\n\n    private long startTime;\n"}
{"magic_number_smell": "\n        Matcher m = STANDARD_PATTERN.matcher(strVersion);\n        if (m.matches()) {\n            digits = parseDigits(m.group(1));\n            if (!SNAPSHOT_IDENTIFIER.equals(m.group(ANNOTATION_INDEX))) {\n                annotationSeparator = m.group(ANNOTATION_SEPARATOR_INDEX);\n                annotation = nullIfEmpty(m.group(ANNOTATION_INDEX));", "refactored_code": "    private static final int DIGITS_INDEX = 1;\n\n        Matcher m = STANDARD_PATTERN.matcher(strVersion);\n        if (m.matches()) {\n            digits = parseDigits(m.group(DIGITS_INDEX));\n            if (!SNAPSHOT_IDENTIFIER.equals(m.group(ANNOTATION_INDEX))) {\n                annotationSeparator = m.group(ANNOTATION_SEPARATOR_INDEX);\n                annotation = nullIfEmpty(m.group(ANNOTATION_INDEX));"}
{"magic_number_smell": "\n        Matcher m = STANDARD_PATTERN.matcher(strVersion);\n        if (m.matches()) {\n            digits = parseDigits(m.group(1));\n            if (!SNAPSHOT_IDENTIFIER.equals(m.group(ANNOTATION_INDEX))) {\n                annotationSeparator = m.group(ANNOTATION_SEPARATOR_INDEX);\n                annotation = nullIfEmpty(m.group(ANNOTATION_INDEX));", "refactored_code": "    private static final int DIGITS_INDEX = 1;\n\n        Matcher m = STANDARD_PATTERN.matcher(strVersion);\n        if (m.matches()) {\n            digits = parseDigits(m.group(DIGITS_INDEX));\n            if (!SNAPSHOT_IDENTIFIER.equals(m.group(ANNOTATION_INDEX))) {\n                annotationSeparator = m.group(ANNOTATION_SEPARATOR_INDEX);\n                annotation = nullIfEmpty(m.group(ANNOTATION_INDEX));"}
{"magic_number_smell": "     */\n    protected void createButtonsForButtonBar( Composite parent )\n    {\n        createButton( parent, 987654321, Messages.getString( \"ACIItemDialog.button.format\" ), false ); //$NON-NLS-1$\n        createButton( parent, CHECK_SYNTAX_BUTTON, Messages.getString( \"ACIItemDialog.button.checkSyntax\" ), false ); //$NON-NLS-1$\n        createButton( parent, IDialogConstants.OK_ID, IDialogConstants.OK_LABEL, false );\n        createButton( parent, IDialogConstants.CANCEL_ID, IDialogConstants.CANCEL_LABEL, false );", "refactored_code": "    private static final int FORMAT_BUTTON = 987654321;\n     */\n    protected void createButtonsForButtonBar( Composite parent )\n    {\n        createButton( parent, FORMAT_BUTTON, Messages.getString( \"ACIItemDialog.button.format\" ), false ); //$NON-NLS-1$\n        createButton( parent, CHECK_SYNTAX_BUTTON, Messages.getString( \"ACIItemDialog.button.checkSyntax\" ), false ); //$NON-NLS-1$\n        createButton( parent, IDialogConstants.OK_ID, IDialogConstants.OK_LABEL, false );\n        createButton( parent, IDialogConstants.CANCEL_ID, IDialogConstants.CANCEL_LABEL, false );"}
{"magic_number_smell": "        {\n            for ( GrantAndDenialWrapper grantAndDenialWrapper : grantAndDenialCategory.grantAndDenialWrappers )\n            {\n                if ( grantAndDenialWrapper.undoStack.size() == 25 )\n                {\n                    grantAndDenialWrapper.undoStack.remove( grantAndDenialWrapper.undoStack.size() - 1 );\n                }", "refactored_code": "    private static final int MAX_STACK_SIZE = 25;\n        {\n            for ( GrantAndDenialWrapper grantAndDenialWrapper : grantAndDenialCategory.grantAndDenialWrappers )\n            {\n                if ( grantAndDenialWrapper.undoStack.size() == MAX_STACK_SIZE )\n                {\n                    grantAndDenialWrapper.undoStack.remove( grantAndDenialWrapper.undoStack.size() - 1 );\n                }"}
{"magic_number_smell": "        visualComposite.setLayoutData( new GridData( SWT.FILL, SWT.FILL, true, true ) );\n\n        // create tab\n        TabItem visualTab = new TabItem( tabFolder, SWT.NONE, 0 );\n        visualTab.setText( Messages.getString( \"ACIItemTabFolderComposite.visual.tab\" ) ); //$NON-NLS-1$\n        visualTab.setControl( visualContainer );\n    }", "refactored_code": "    public static final int VISUAL_TAB_INDEX = 0;\n        visualComposite.setLayoutData( new GridData( SWT.FILL, SWT.FILL, true, true ) );\n\n        // create tab\n        TabItem visualTab = new TabItem( tabFolder, SWT.NONE, VISUAL_TAB_INDEX );\n        visualTab.setText( Messages.getString( \"ACIItemTabFolderComposite.visual.tab\" ) ); //$NON-NLS-1$\n        visualTab.setControl( visualContainer );\n    }"}
{"magic_number_smell": "        boolean configEntryFound = false;\n        boolean directoryServiceEntryFound = false;\n\n        while ( reader.hasNext() && ( checkedEntries < 10 ) )\n        {\n            if ( configEntryFound && directoryServiceEntryFound )\n            {", "refactored_code": "    private static final int MAX_NUMBER_ENTRIES_SEARCH = 10;\n        boolean configEntryFound = false;\n        boolean directoryServiceEntryFound = false;\n\n        while ( reader.hasNext() && ( checkedEntries < MAX_NUMBER_ENTRIES_SEARCH ) )\n        {\n            if ( configEntryFound && directoryServiceEntryFound )\n            {"}
{"magic_number_smell": "        toolkit.createLabel( composite, TABULATION );\n        toolkit.createLabel( composite, Messages.getString( \"LdapLdapsServersPage.NbThreads\" ) ); //$NON-NLS-1$\n        ldapNbThreadsText = createNbThreadsText( toolkit, composite );\n        createDefaultValueLabel( toolkit, composite,  Integer.toString( 4 ) );\n\n        // LDAP Server backlog Text\n        toolkit.createLabel( composite, TABULATION );", "refactored_code": "    private static final int DEFAULT_NB_THREADS = 4;\n        toolkit.createLabel( composite, TABULATION );\n        toolkit.createLabel( composite, Messages.getString( \"LdapLdapsServersPage.NbThreads\" ) ); //$NON-NLS-1$\n        ldapNbThreadsText = createNbThreadsText( toolkit, composite );\n        createDefaultValueLabel( toolkit, composite,  Integer.toString( DEFAULT_NB_THREADS ) );\n\n        // LDAP Server backlog Text\n        toolkit.createLabel( composite, TABULATION );"}
{"magic_number_smell": "    protected int[] getTypeIds()\n    {\n        return new int[]\n            { registerType( TYPENAME ) };\n    }\n}", "refactored_code": "    private static final int TYPEID = registerType( TYPENAME );\n    protected int[] getTypeIds()\n    {\n        return new int[]\n            { TYPEID };\n    }\n}"}
{"magic_number_smell": "        fingerprintMD5 = BaseWidgetUtils.createLabeledText( fingerprintsComposite, StringUtils.EMPTY, 1 );\n\n        // create tab\n        TabItem generalTab = new TabItem( tabFolder, SWT.NONE, 0 );\n        generalTab.setText( Messages.getString( \"CertificateInfoComposite.General\" ) ); //$NON-NLS-1$\n        generalTab.setControl( generalContainer );\n    }", "refactored_code": "    public static final int GENERAL_TAB_INDEX = 0;\n        fingerprintMD5 = BaseWidgetUtils.createLabeledText( fingerprintsComposite, StringUtils.EMPTY, 1 );\n\n        // create tab\n        TabItem generalTab = new TabItem( tabFolder, SWT.NONE, GENERAL_TAB_INDEX );\n        generalTab.setText( Messages.getString( \"CertificateInfoComposite.General\" ) ); //$NON-NLS-1$\n        generalTab.setControl( generalContainer );\n    }"}
{"magic_number_smell": "            parser.parse( sourceViewer.getDocument().get() );\n            filter = parser.getModel().toString();\n        }\n        else if ( buttonId == 987654321 )\n        {\n            IRegion region = new Region( 0, sourceViewer.getDocument().getLength() );\n            configuration.getContentFormatter( sourceViewer ).format( sourceViewer.getDocument(), region );", "refactored_code": "    private static final int FORMAT_BUTTON_ID = 987654321;\n            parser.parse( sourceViewer.getDocument().get() );\n            filter = parser.getModel().toString();\n        }\n        else if ( buttonId == FORMAT_BUTTON_ID )\n        {\n            IRegion region = new Region( 0, sourceViewer.getDocument().getLength() );\n            configuration.getContentFormatter( sourceViewer ).format( sourceViewer.getDocument(), region );"}
{"magic_number_smell": "        {\n            returnData = currentData;\n        }\n        else if ( buttonId == 9997 )\n        {\n            TextDialog dialog = new TextDialog( getShell(), new String( currentData, StandardCharsets.UTF_8 ) );\n            if ( dialog.open() == TextDialog.OK )", "refactored_code": "    private static final int EDIT_AS_TEXT_BUTTON_ID = 9997;\n        {\n            returnData = currentData;\n        }\n        else if ( buttonId == EDIT_AS_TEXT_BUTTON_ID )\n        {\n            TextDialog dialog = new TextDialog( getShell(), new String( currentData, StandardCharsets.UTF_8 ) );\n            if ( dialog.open() == TextDialog.OK )"}
{"magic_number_smell": "    @Override\n    protected void createButtonsForButtonBar( Composite parent )\n    {\n        createButton( parent, 9999, Messages.getString( \"TextDialog.WrapLines\" ), false, SWT.TOGGLE ); //$NON-NLS-1$\n        createButton( parent, IDialogConstants.OK_ID, IDialogConstants.OK_LABEL, false );\n        createButton( parent, IDialogConstants.CANCEL_ID, IDialogConstants.CANCEL_LABEL, false );\n    }", "refactored_code": "    private static final int TOGGLE_BUTTON_ID = 9999;\n    @Override\n    protected void createButtonsForButtonBar( Composite parent )\n    {\n        createButton( parent, TOGGLE_BUTTON_ID, Messages.getString( \"TextDialog.WrapLines\" ), false, SWT.TOGGLE ); //$NON-NLS-1$\n        createButton( parent, IDialogConstants.OK_ID, IDialogConstants.OK_LABEL, false );\n        createButton( parent, IDialogConstants.CANCEL_ID, IDialogConstants.CANCEL_LABEL, false );\n    }"}
{"magic_number_smell": "    protected int[] getTypeIds()\n    {\n        return new int[]\n            { registerType( TYPENAME ) };\n    }\n\n}", "refactored_code": "    private static final int TYPEID = registerType( TYPENAME );\n    protected int[] getTypeIds()\n    {\n        return new int[]\n            { TYPEID };\n    }\n\n}"}
{"magic_number_smell": "    protected int[] getTypeIds()\n    {\n        return new int[]\n            { registerType( TYPENAME ) };\n    }\n\n}", "refactored_code": "    private static final int TYPEID = registerType( TYPENAME );\n    protected int[] getTypeIds()\n    {\n        return new int[]\n            { TYPEID };\n    }\n\n}"}
{"magic_number_smell": "    protected int[] getTypeIds()\n    {\n        return new int[]\n            { registerType( TYPENAME ) };\n    }\n\n}", "refactored_code": "    private static final int TYPEID = registerType( TYPENAME );\n    protected int[] getTypeIds()\n    {\n        return new int[]\n            { TYPEID };\n    }\n\n}"}
{"magic_number_smell": "     *\n     * @param title The title\n     * @param extensions The valid file extensions\n     * @param type The type, one of {@link #SWT.OPEN} or {@link #TYPE_SAVE}\n     */\n    public FileBrowserWidget( String title, String[] extensions, int type )\n    {", "refactored_code": "    public static final int TYPE_OPEN = SWT.OPEN;\n     *\n     * @param title The title\n     * @param extensions The valid file extensions\n     * @param type The type, one of {@link #TYPE_OPEN} or {@link #TYPE_SAVE}\n     */\n    public FileBrowserWidget( String title, String[] extensions, int type )\n    {"}
{"magic_number_smell": "    /**\n     * Creates a new instance of BrowserCategory.\n     *\n     * @param type the category's type, one of 0, TYPE_SEARCHES or TYPE_BOOKMARKS\n     * @param parent the category's connection\n     */\n    public BrowserCategory( int type, IBrowserConnection parent )", "refactored_code": "    public static final int TYPE_DIT = 0;\n    /**\n     * Creates a new instance of BrowserCategory.\n     *\n     * @param type the category's type, one of TYPE_DIT, TYPE_SEARCHES or TYPE_BOOKMARKS\n     * @param parent the category's connection\n     */\n    public BrowserCategory( int type, IBrowserConnection parent )"}
{"magic_number_smell": "            }\n\n            // max export\n            if ( searchParameter.getCountLimit() < 1 || searchParameter.getCountLimit() > 65000 )\n            {\n                searchParameter.setCountLimit( 65000 );\n            }", "refactored_code": "    public static final int MAX_COUNT_LIMIT = 65000;\n            }\n\n            // max export\n            if ( searchParameter.getCountLimit() < 1 || searchParameter.getCountLimit() > MAX_COUNT_LIMIT )\n            {\n                searchParameter.setCountLimit( MAX_COUNT_LIMIT );\n            }"}
{"magic_number_smell": "        }\n\n        // max export\n        if ( searchParameter.getCountLimit() < 1 || searchParameter.getCountLimit() > 65000 )\n        {\n            searchParameter.setCountLimit( 65000 );\n        }", "refactored_code": "    public static final int MAX_COUNT_LIMIT = 65000;\n        }\n\n        // max export\n        if ( searchParameter.getCountLimit() < 1 || searchParameter.getCountLimit() > MAX_COUNT_LIMIT )\n        {\n            searchParameter.setCountLimit( MAX_COUNT_LIMIT );\n        }"}
{"magic_number_smell": "        super();\n        this.type = type;\n        this.mode = mode;\n        if ( this.mode == 1 )\n        {\n            this.appendix = Messages.getString( \"CopyEntryAsAction.DNOnly\" ); //$NON-NLS-1$\n        }", "refactored_code": "    public static final int MODE_DN_ONLY = 1;\n        super();\n        this.type = type;\n        this.mode = mode;\n        if ( this.mode == MODE_DN_ONLY )\n        {\n            this.appendix = Messages.getString( \"CopyEntryAsAction.DNOnly\" ); //$NON-NLS-1$\n        }"}
{"magic_number_smell": "        {\n            return BrowserUIPlugin.getDefault().getImageDescriptor( BrowserUIConstants.IMG_COPY_CSV_USER );\n        }\n        else if ( this.mode == 5 )\n        {\n            return BrowserUIPlugin.getDefault().getImageDescriptor( BrowserUIConstants.IMG_COPY_TABLE );\n        }", "refactored_code": "    public static final int MODE_TABLE = 5;\n        {\n            return BrowserUIPlugin.getDefault().getImageDescriptor( BrowserUIConstants.IMG_COPY_CSV_USER );\n        }\n        else if ( this.mode == MODE_TABLE )\n        {\n            return BrowserUIPlugin.getDefault().getImageDescriptor( BrowserUIConstants.IMG_COPY_TABLE );\n        }"}
{"magic_number_smell": "     */\n    public String getText()\n    {\n        if ( mode == 0 )\n        {\n            return Messages.getString( \"CopySearchFilterAction.CopySearchFilter\" ); //$NON-NLS-1$\n        }", "refactored_code": "    public static final int MODE_EQUALS = 0;\n     */\n    public String getText()\n    {\n        if ( mode == MODE_EQUALS )\n        {\n            return Messages.getString( \"CopySearchFilterAction.CopySearchFilter\" ); //$NON-NLS-1$\n        }"}
{"magic_number_smell": "     */\n    public String getText()\n    {\n        if ( this.type == 0 )\n        {\n            return Messages.getString( \"ImportExportAction.LDIFImport\" ); //$NON-NLS-1$\n        }", "refactored_code": "    public static final int TYPE_IMPORT_LDIF = 0;\n     */\n    public String getText()\n    {\n        if ( this.type == TYPE_IMPORT_LDIF )\n        {\n            return Messages.getString( \"ImportExportAction.LDIFImport\" ); //$NON-NLS-1$\n        }"}
{"magic_number_smell": "    public OpenSchemaBrowserAction()\n    {\n        super();\n        this.mode = 0;\n    }\n\n", "refactored_code": "    public static final int MODE_NONE = 0;\n    public OpenSchemaBrowserAction()\n    {\n        super();\n        this.mode = MODE_NONE;\n    }\n\n"}
{"magic_number_smell": "        public static final int 1 = 1;\n\n        /** The comparison order */\n        int order = 1;\n\n        /** The column used to compare objects */\n        int column = 0;", "refactored_code": "        public static final int ASCENDING = 1;\n        public static final int ASCENDING = 1;\n\n        /** The comparison order */\n        int order = ASCENDING;\n\n        /** The column used to compare objects */\n        int column = 0;"}
{"magic_number_smell": "                        }\n\n                        // set range on viewer, add global offset\n                        int start = range != null ? range[0] : part.getOffset();\n                        start += offset;\n                        int length = range != null ? range[LENGTH] : part.getLength();\n                        viewer.setSelectedRange( start, length );", "refactored_code": "    private static final int OFFSET = 0;\n                        }\n\n                        // set range on viewer, add global offset\n                        int start = range != null ? range[OFFSET] : part.getOffset();\n                        start += offset;\n                        int length = range != null ? range[LENGTH] : part.getLength();\n                        viewer.setSelectedRange( start, length );"}
{"magic_number_smell": "     */\n    protected void createButtonsForButtonBar( Composite parent )\n    {\n        createButton( parent, 999999, \"Format\", false );\n        createButton( parent, CHECK_SYNTAX_BUTTON, \"Check Syntax\", false );\n        createButton( parent, IDialogConstants.OK_ID, IDialogConstants.OK_LABEL, false );\n        createButton( parent, IDialogConstants.CANCEL_ID, IDialogConstants.CANCEL_LABEL, false );", "refactored_code": "    private static final int FORMAT_BUTTON = 999999;\n     */\n    protected void createButtonsForButtonBar( Composite parent )\n    {\n        createButton( parent, FORMAT_BUTTON, \"Format\", false );\n        createButton( parent, CHECK_SYNTAX_BUTTON, \"Check Syntax\", false );\n        createButton( parent, IDialogConstants.OK_ID, IDialogConstants.OK_LABEL, false );\n        createButton( parent, IDialogConstants.CANCEL_ID, IDialogConstants.CANCEL_LABEL, false );"}
{"magic_number_smell": "        visualComposite.setLayoutData( new GridData( SWT.FILL, SWT.FILL, true, true ) );\n\n        // create tab\n        visualTab = new TabItem( tabFolder, SWT.NONE, 0 );\n        visualTab.setText( \"Visual Editor\" );\n        visualTab.setControl( visualContainer );\n    }", "refactored_code": "    public static final int VISUAL_TAB_INDEX = 0;\n        visualComposite.setLayoutData( new GridData( SWT.FILL, SWT.FILL, true, true ) );\n\n        // create tab\n        visualTab = new TabItem( tabFolder, SWT.NONE, VISUAL_TAB_INDEX );\n        visualTab.setText( \"Visual Editor\" );\n        visualTab.setControl( visualContainer );\n    }"}
{"magic_number_smell": "        public void widgetSelected( SelectionEvent e )\n        {\n            // Simple Authentication\n            if ( authenticationTabFolder.getSelectionIndex() == 0 )\n            {\n                syncRepl.setBindMethod( BindMethod.SIMPLE );\n", "refactored_code": "    private static final int SIMPLE_AUTHENTICATION_TAB_ITEM_INDEX = 0;\n        public void widgetSelected( SelectionEvent e )\n        {\n            // Simple Authentication\n            if ( authenticationTabFolder.getSelectionIndex() == SIMPLE_AUTHENTICATION_TAB_ITEM_INDEX )\n            {\n                syncRepl.setBindMethod( BindMethod.SIMPLE );\n"}
{"magic_number_smell": "                    // parse the type\n                    pos = parseDnSpec( lowerCaseLimits, pos );\n                    \n                    if ( pos == -1 )\n                    {\n                        isValid = false;\n                    }", "refactored_code": "    private static final int ERROR = -1;\n                    // parse the type\n                    pos = parseDnSpec( lowerCaseLimits, pos );\n                    \n                    if ( pos == ERROR )\n                    {\n                        isValid = false;\n                    }"}
{"magic_number_smell": "            {\n                size = Long.valueOf( sizeStr );\n                \n                if ( ( size < 0L ) || ( size > 0xFFFFFFFFL ) )\n                {\n                    // This is wrong\n                }", "refactored_code": "    public static final long MAX_TCP_BUFFER_SIZE = 0xFFFFFFFFL;\n            {\n                size = Long.valueOf( sizeStr );\n                \n                if ( ( size < 0L ) || ( size > MAX_TCP_BUFFER_SIZE ) )\n                {\n                    // This is wrong\n                }"}
{"magic_number_smell": "    private String host;\n\n    /** The port */\n    private int port = -1;\n\n\n    /**", "refactored_code": "    public static final int NO_PORT = -1;\n    private String host;\n\n    /** The port */\n    private int port = NO_PORT;\n\n\n    /**"}
{"magic_number_smell": "\n            if ( \"+\".equalsIgnoreCase( retries ) )\n            {\n                retryPair.setRetries( -1 );\n            }\n            else\n            {", "refactored_code": "    public static final int PLUS = -1;\n\n            if ( \"+\".equalsIgnoreCase( retries ) )\n            {\n                retryPair.setRetries( PLUS );\n            }\n            else\n            {"}
{"magic_number_smell": "    /**\n     * Gets the type of export.\n     * <p>\n     * Values can either 0 or EXPORT_SINGLE_FILE.\n     * \n     * @return\n     *      the type of export", "refactored_code": "    public static final int EXPORT_MULTIPLE_FILES = 0;\n    /**\n     * Gets the type of export.\n     * <p>\n     * Values can either EXPORT_MULTIPLE_FILES or EXPORT_SINGLE_FILE.\n     * \n     * @return\n     *      the type of export"}
{"magic_number_smell": "    /**\n     * Gets the type of export.\n     * <p>\n     * Values can either 0 or EXPORT_SINGLE_FILE.\n     * \n     * @return\n     *      the type of export", "refactored_code": "    public static final int EXPORT_MULTIPLE_FILES = 0;\n    /**\n     * Gets the type of export.\n     * <p>\n     * Values can either EXPORT_MULTIPLE_FILES or EXPORT_SINGLE_FILE.\n     * \n     * @return\n     *      the type of export"}
{"magic_number_smell": "    protected ITableLabelProvider labelProvider;\n\n    /** The comparison order */\n    int order = 1;\n\n    /** The column used to compare objects */\n    int column = 0;", "refactored_code": "    public static final int ASCENDING = 1;\n    protected ITableLabelProvider labelProvider;\n\n    /** The comparison order */\n    int order = ASCENDING;\n\n    /** The column used to compare objects */\n    int column = 0;"}
{"magic_number_smell": "                }\n            }\n        }\n        else if ( buttonId == 9998 )\n        {\n            FileDialog fileDialog = new FileDialog( getShell(), SWT.OPEN );\n            fileDialog.setText( Messages.getString( \"CertificateDialog.LoadCertificate\" ) ); //$NON-NLS-1$", "refactored_code": "    private static final int LOAD_BUTTON_ID = 9998;\n                }\n            }\n        }\n        else if ( buttonId == LOAD_BUTTON_ID )\n        {\n            FileDialog fileDialog = new FileDialog( getShell(), SWT.OPEN );\n            fileDialog.setText( Messages.getString( \"CertificateDialog.LoadCertificate\" ) ); //$NON-NLS-1$"}
{"magic_number_smell": "        // Computing the width scale factor\n        double widthScaleFactor = 1.0;\n        \n        if ( imageData.width > 400 )\n        {\n            widthScaleFactor = ( double ) 400 / imageData.width;\n        }", "refactored_code": "    private static final int MAX_WIDTH = 400;\n        // Computing the width scale factor\n        double widthScaleFactor = 1.0;\n        \n        if ( imageData.width > MAX_WIDTH )\n        {\n            widthScaleFactor = ( double ) MAX_WIDTH / imageData.width;\n        }"}
{"magic_number_smell": "    {\n        if ( testPasswordText != null && newPasswordText != null )\n        {\n            if ( tabFolder.getSelectionIndex() == 0 )\n            {\n                updateCurrentPasswordGroup();\n                testPasswordText.setFocus();", "refactored_code": "    private static final int CURRENT_TAB = 0;\n    {\n        if ( testPasswordText != null && newPasswordText != null )\n        {\n            if ( tabFolder.getSelectionIndex() == CURRENT_TAB )\n            {\n                updateCurrentPasswordGroup();\n                testPasswordText.setFocus();"}
{"magic_number_smell": "\n    private Fedora389dsLdapServer()\n    {\n        super( LdapServerType.Fedora389ds, FEDORA_389DS_HOST, Integer.parseInt( getEnvOrDefault( \"FEDORA_389DS_PORT\", \"21389\" ) ), FEDORA_389DS_PORT_SSL,\n            FEDORA_389DS_ADMIN_DN, FEDORA_389DS_ADMIN_PASSWORD );\n    }\n", "refactored_code": "    private static final int FEDORA_389DS_PORT = Integer.parseInt( getEnvOrDefault( \"FEDORA_389DS_PORT\", \"21389\" ) );\n\n    private Fedora389dsLdapServer()\n    {\n        super( LdapServerType.Fedora389ds, FEDORA_389DS_HOST, FEDORA_389DS_PORT, FEDORA_389DS_PORT_SSL,\n            FEDORA_389DS_ADMIN_DN, FEDORA_389DS_ADMIN_PASSWORD );\n    }\n"}
{"magic_number_smell": "\n    private OpenLdapServer()\n    {\n        super( LdapServerType.OpenLdap, OPENLDAP_HOST, Integer.parseInt( getEnvOrDefault( \"OPENLDAP_PORT\", \"20389\" ) ), OPENLDAP_PORT_SSL, OPENLDAP_ADMIN_DN,\n            OPENLDAP_ADMIN_PASSWORD );\n    }\n", "refactored_code": "    private static final int OPENLDAP_PORT = Integer.parseInt( getEnvOrDefault( \"OPENLDAP_PORT\", \"20389\" ) );\n\n    private OpenLdapServer()\n    {\n        super( LdapServerType.OpenLdap, OPENLDAP_HOST, OPENLDAP_PORT, OPENLDAP_PORT_SSL, OPENLDAP_ADMIN_DN,\n            OPENLDAP_ADMIN_PASSWORD );\n    }\n"}
{"magic_number_smell": "    public static void skipIfKdcServerIsNotAvailable()\n    {\n        boolean available = false;\n        try(Socket s = new Socket(KDC_HOST, 60088))\n        {\n            available = true;\n        }", "refactored_code": "    public static final int KDC_PORT = 60088;\n    public static void skipIfKdcServerIsNotAvailable()\n    {\n        boolean available = false;\n        try(Socket s = new Socket(KDC_HOST, KDC_PORT))\n        {\n            available = true;\n        }"}
{"magic_number_smell": "        int n;\n        for (n = off; n < off + len; n++) {\n            int readResult = read();\n            if (readResult == -1) {\n                return n == 0 ? -1 : n;\n            } else {\n                cbuf[n] = (char) readResult;", "refactored_code": "    private static final int EOL = -1;\n        int n;\n        for (n = off; n < off + len; n++) {\n            int readResult = read();\n            if (readResult == EOL) {\n                return n == 0 ? EOL : n;\n            } else {\n                cbuf[n] = (char) readResult;"}
{"magic_number_smell": "    private static final long 10000 = 10000;\n\n    /** the max size allowed. */\n    private long maxsize = 10000;\n\n    /** the min size allowed. */\n    private long minsize = 0;", "refactored_code": "    private static final long MAXSIZE = 10000;\n    private static final long MAXSIZE = 10000;\n\n    /** the max size allowed. */\n    private long maxsize = MAXSIZE;\n\n    /** the min size allowed. */\n    private long minsize = 0;"}
{"magic_number_smell": "    private static final String SYNAPSE_THREADING_VIEW = \"Threading\";\n    private static final int 2 = 2;\n    private static final int LONG_SAMPLING_PERIOD = 5 * 60;\n    private static final int SAMPLES_PER_MINUTE = 60/ 2;\n    private static final int SAMPLES_PER_HOUR = 3600/LONG_SAMPLING_PERIOD;\n\n    private String threadNamePrefix = null;", "refactored_code": "    private static final int SHORT_SAMPLING_PERIOD = 2;\n    private static final String SYNAPSE_THREADING_VIEW = \"Threading\";\n    private static final int SHORT_SAMPLING_PERIOD = 2;\n    private static final int LONG_SAMPLING_PERIOD = 5 * 60;\n    private static final int SAMPLES_PER_MINUTE = 60/ SHORT_SAMPLING_PERIOD;\n    private static final int SAMPLES_PER_HOUR = 3600/LONG_SAMPLING_PERIOD;\n\n    private String threadNamePrefix = null;"}
{"magic_number_smell": "public class MultiPriorityBlockingQueueStressTest extends MultiPriorityBlockingQueueAbstractTest {\n    private static final int 10000 = 10000;\n\n    private final int[] sizes = {10000, 10000, 10000};\n    private final int[] priorities = {1, 10, 100};\n    private final int QUEUES = 3;\n", "refactored_code": "    private static final int CONCURRENT_ITEMS = 10000;\npublic class MultiPriorityBlockingQueueStressTest extends MultiPriorityBlockingQueueAbstractTest {\n    private static final int CONCURRENT_ITEMS = 10000;\n\n    private final int[] sizes = {CONCURRENT_ITEMS, CONCURRENT_ITEMS, CONCURRENT_ITEMS};\n    private final int[] priorities = {1, 10, 100};\n    private final int QUEUES = 3;\n"}
{"magic_number_smell": "    private MultiPriorityBlockingQueue unboundedQueue;\n\n    private final int[] priorities = {10, 1};\n    private final int[] sizes = {100, 100};\n\n    @Override\n    protected void setUp() throws Exception {", "refactored_code": "    private static final int ITEMS = 100;\n    private MultiPriorityBlockingQueue unboundedQueue;\n\n    private final int[] priorities = {10, 1};\n    private final int[] sizes = {ITEMS, ITEMS};\n\n    @Override\n    protected void setUp() throws Exception {"}
{"magic_number_smell": "    protected void setUp() throws Exception {\n        super.setUp();\n\n        queue = new FixedSizeQueue<DummyTask>(PRIORITY, 10);\n    }\n\n    public void testOffer() {", "refactored_code": "    private final int SIZE = 10;\n    protected void setUp() throws Exception {\n        super.setUp();\n\n        queue = new FixedSizeQueue<DummyTask>(PRIORITY, SIZE);\n    }\n\n    public void testOffer() {"}
{"magic_number_smell": "            \n            // automatic detection starting at base port\n            if (jndiPort == 0) {\n                jndiPort = 1099;\n                for (int retries = 0; !registryCreated && (retries < 100); retries++) {\n                    try {\n                        RMIRegistryController.getInstance().createLocalRegistry(jndiPort);", "refactored_code": "    private static final int JNDI_AUTO_PORT_OFFSET = 1099;\n            \n            // automatic detection starting at base port\n            if (jndiPort == 0) {\n                jndiPort = JNDI_AUTO_PORT_OFFSET;\n                for (int retries = 0; !registryCreated && (retries < 100); retries++) {\n                    try {\n                        RMIRegistryController.getInstance().createLocalRegistry(jndiPort);"}
{"magic_number_smell": "            if (timeoutAttr != null && timeoutAttr.getAttributeValue() != null) {\n                cache.setTimeout(Long.parseLong(timeoutAttr.getAttributeValue()));\n            } else {\n                cache.setTimeout(5000L);\n            }\n\n            OMAttribute maxMessageSizeAttr = elem.getAttribute(ATT_MAX_MSG_SIZE);", "refactored_code": "    private static final long DEFAULT_TIMEOUT = 5000L;\n            if (timeoutAttr != null && timeoutAttr.getAttributeValue() != null) {\n                cache.setTimeout(Long.parseLong(timeoutAttr.getAttributeValue()));\n            } else {\n                cache.setTimeout(DEFAULT_TIMEOUT);\n            }\n\n            OMAttribute maxMessageSizeAttr = elem.getAttribute(ATT_MAX_MSG_SIZE);"}
{"magic_number_smell": "    public static final int ST_OFF = 4;\n\n    /** The state of the endpoint at present */\n    private int  localState = 1;\n    /** The time in ms, until the next retry - depending on a timeout or suspension */\n    private long localNextRetryTime = -1;\n    /** The number of attempts left for timeout failures, until they make the endpoint suspended */", "refactored_code": "    public static final int ST_ACTIVE      = 1;\n    public static final int ST_OFF = 4;\n\n    /** The state of the endpoint at present */\n    private int  localState = ST_ACTIVE;\n    /** The time in ms, until the next retry - depending on a timeout or suspension */\n    private long localNextRetryTime = -1;\n    /** The number of attempts left for timeout failures, until they make the endpoint suspended */"}
{"magic_number_smell": "\n            // Prevent infinite retrying to failed members\n            callCount.set(callCount.get() + 1);\n            if (callCount.get() >= 5) {\n                return;\n            }\n", "refactored_code": "        private static final int MAX_RETRY_COUNT = 5;\n\n            // Prevent infinite retrying to failed members\n            callCount.set(callCount.get() + 1);\n            if (callCount.get() >= MAX_RETRY_COUNT) {\n                return;\n            }\n"}
{"magic_number_smell": "        for (int i = 0; i < endpoints.size(); i++) {\n            Endpoint endpoint = endpoints.get(i);\n            if (!(endpoint instanceof PropertyInclude)) {\n                EndpointState state = new EndpointState(i, 1);\n                endpointStates[i] = state;\n            } else {\n                MediatorProperty property =", "refactored_code": "    private static final int DEFAULT_WEIGHT = 1;\n        for (int i = 0; i < endpoints.size(); i++) {\n            Endpoint endpoint = endpoints.get(i);\n            if (!(endpoint instanceof PropertyInclude)) {\n                EndpointState state = new EndpointState(i, DEFAULT_WEIGHT);\n                endpointStates[i] = state;\n            } else {\n                MediatorProperty property ="}
{"magic_number_smell": "            this.currentWeight = fixedWeight;\n            this.currentCalcWeight = fixedWeight;\n            this.keyToConnectionCount = keyToConnectionCount;\n            this.maxWeight = fixedWeight + 2;\n            this.minWeight = fixedWeight - 2 > 0 ?\n                    fixedWeight - 2 : 0;\n        }", "refactored_code": "    public static final int LB_WEIGHTED_RRLC_WEIGHT_SKEW = 2;    \n            this.currentWeight = fixedWeight;\n            this.currentCalcWeight = fixedWeight;\n            this.keyToConnectionCount = keyToConnectionCount;\n            this.maxWeight = fixedWeight + LB_WEIGHTED_RRLC_WEIGHT_SKEW;\n            this.minWeight = fixedWeight - LB_WEIGHTED_RRLC_WEIGHT_SKEW > 0 ?\n                    fixedWeight - LB_WEIGHTED_RRLC_WEIGHT_SKEW : 0;\n        }"}
{"magic_number_smell": "\n    private String getLogMessage(MessageContext synCtx) {\n        switch (logLevel) {\n            case 0:\n                return getCustomLogMessage(synCtx);\n            case SIMPLE:\n                return getSimpleLogMessage(synCtx);", "refactored_code": "    public static final int CUSTOM  = 0;\n\n    private String getLogMessage(MessageContext synCtx) {\n        switch (logLevel) {\n            case CUSTOM:\n                return getCustomLogMessage(synCtx);\n            case SIMPLE:\n                return getSimpleLogMessage(synCtx);"}
{"magic_number_smell": "    /** The Action - set or remove */\n    public static final int 0 = 0;\n    public static final int ACTION_REMOVE = 1;\n    /** Set the property (0) or remove it (ACTION_REMOVE). Defaults to 0 */\n    private int action = 0;\n\n    /** Regular expression pattern to be evaluated over the property value.", "refactored_code": "    public static final int ACTION_SET = 0;\n    /** The Action - set or remove */\n    public static final int ACTION_SET = 0;\n    public static final int ACTION_REMOVE = 1;\n    /** Set the property (ACTION_SET) or remove it (ACTION_REMOVE). Defaults to ACTION_SET */\n    private int action = ACTION_SET;\n\n    /** Regular expression pattern to be evaluated over the property value."}
{"magic_number_smell": "        }\n\n        switch (soapVersion) {\n            case 1:\n                makeSOAPFault(synCtx, 1, synLog);\n                break;\n            case SOAP12:", "refactored_code": "    public static final int SOAP11 = 1;\n        }\n\n        switch (soapVersion) {\n            case SOAP11:\n                makeSOAPFault(synCtx, SOAP11, synLog);\n                break;\n            case SOAP12:"}
{"magic_number_smell": "    private QName qName = null;\n    /** The literal value to be set as the header (if one was specified) */\n    private String value = null;\n    /** Set the header (0) or remove it (ACTION_REMOVE). Defaults to 0 */\n    private int action = 0;\n    /** Optional embedded XML content of the header element */\n    private List<OMElement> embeddedXmlContent = new ArrayList<OMElement>();", "refactored_code": "    public static final int ACTION_SET = 0;\n    private QName qName = null;\n    /** The literal value to be set as the header (if one was specified) */\n    private String value = null;\n    /** Set the header (ACTION_SET) or remove it (ACTION_REMOVE). Defaults to ACTION_SET */\n    private int action = ACTION_SET;\n    /** Optional embedded XML content of the header element */\n    private List<OMElement> embeddedXmlContent = new ArrayList<OMElement>();"}
{"magic_number_smell": "    private SynapseXPath xpath;\n    private String regex;\n    private int fragmentIndex = URIFragments.FULL_URI;\n    private int actionType = 0;\n\n    public void execute(URIFragments fragments,\n                        MessageContext messageContext) throws URISyntaxException {", "refactored_code": "    public static final int ACTION_SET      = 0;\n    private SynapseXPath xpath;\n    private String regex;\n    private int fragmentIndex = URIFragments.FULL_URI;\n    private int actionType = ACTION_SET;\n\n    public void execute(URIFragments fragments,\n                        MessageContext messageContext) throws URISyntaxException {"}
{"magic_number_smell": "                if (child == null) {\n                    continue;\n                }\n                if (list.size() > 200) {\n                    break;\n                }\n                fillDescendants(child, list);", "refactored_code": "    private static final int MAX_KEYS = 200;\n                if (child == null) {\n                    continue;\n                }\n                if (list.size() > MAX_KEYS) {\n                    break;\n                }\n                fillDescendants(child, list);"}
{"magic_number_smell": "    }\n\n    public String getMessageLable() {\n        if (type == 1) {\n            return WSDLConstants.MESSAGE_LABEL_IN_VALUE;\n        } else if (type == MESSAGE_TYPE_OUT) {\n            return WSDLConstants.MESSAGE_LABEL_OUT_VALUE;", "refactored_code": "    public static final int MESSAGE_TYPE_IN = 1;\n    }\n\n    public String getMessageLable() {\n        if (type == MESSAGE_TYPE_IN) {\n            return WSDLConstants.MESSAGE_LABEL_IN_VALUE;\n        } else if (type == MESSAGE_TYPE_OUT) {\n            return WSDLConstants.MESSAGE_LABEL_OUT_VALUE;"}
{"magic_number_smell": "     * Default Constructor for the thread pool and will use all the values as default\n     */\n    public SynapseThreadPool() {\n        this(20, SYNAPSE_MAX_THREADS, SYNAPSE_KEEP_ALIVE,\n            TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());\n    }\n", "refactored_code": "    public static final int SYNAPSE_CORE_THREADS  = 20;\n     * Default Constructor for the thread pool and will use all the values as default\n     */\n    public SynapseThreadPool() {\n        this(SYNAPSE_CORE_THREADS, SYNAPSE_MAX_THREADS, SYNAPSE_KEEP_ALIVE,\n            TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());\n    }\n"}
{"magic_number_smell": "        Endpoint epr = new AddressEndpoint();\n        epr.setName(\"endpoint1\");\n        synapseConfig.addEndpoint(epr.getName(), epr);\n        assertItemAdded(epr.getName(), 0);\n        synapseConfig.removeEndpoint(epr.getName());\n        assertItemRemoved(epr.getName(), 0);\n", "refactored_code": "    private static final int ENDPOINT   = 0;\n        Endpoint epr = new AddressEndpoint();\n        epr.setName(\"endpoint1\");\n        synapseConfig.addEndpoint(epr.getName(), epr);\n        assertItemAdded(epr.getName(), ENDPOINT);\n        synapseConfig.removeEndpoint(epr.getName());\n        assertItemRemoved(epr.getName(), ENDPOINT);\n"}
{"magic_number_smell": "        AddressEndpoint endpoint = new AddressEndpoint();\n        EndpointDefinition def = new EndpointDefinition();\n        def.addTimeoutErrorCode(SynapseConstants.NHTTP_CONNECTION_TIMEOUT);\n        def.addTimeoutErrorCode(911911);\n        endpoint.setDefinition(def);\n\n        MessageContext messageContext = TestUtils.createLightweightSynapseMessageContext(\"<test/>\");", "refactored_code": "    private static final int CUSTOM_ERROR = 911911;\n        AddressEndpoint endpoint = new AddressEndpoint();\n        EndpointDefinition def = new EndpointDefinition();\n        def.addTimeoutErrorCode(SynapseConstants.NHTTP_CONNECTION_TIMEOUT);\n        def.addTimeoutErrorCode(CUSTOM_ERROR);\n        endpoint.setDefinition(def);\n\n        MessageContext messageContext = TestUtils.createLightweightSynapseMessageContext(\"<test/>\");"}
{"magic_number_smell": "    private String httpsPort;\n    private boolean counterEnabled;\n\n    private int serverState = 1;\n\n    private final Axis2Server axis2Server;\n    private Exception processException;", "refactored_code": "    private static final int UNDEFINED      = 1;\n    private String httpsPort;\n    private boolean counterEnabled;\n\n    private int serverState = UNDEFINED;\n\n    private final Axis2Server axis2Server;\n    private Exception processException;"}
{"magic_number_smell": "    private ServerConfigurationInformation information;\n    private boolean clusteringEnabled;\n\n    private int serverState = 1;\n\n    private final SynapseServer synapseServer;\n    private Exception processException;", "refactored_code": "    private static final int UNDEFINED      = 1;\n    private ServerConfigurationInformation information;\n    private boolean clusteringEnabled;\n\n    private int serverState = UNDEFINED;\n\n    private final SynapseServer synapseServer;\n    private Exception processException;"}
{"magic_number_smell": "\n    public FtpFileNameParser()\n    {\n        super(21);\n    }\n\n    public static FileNameParser getInstance()", "refactored_code": "    private static final int PORT = 21;\n\n    public FtpFileNameParser()\n    {\n        super(PORT);\n    }\n\n    public static FileNameParser getInstance()"}
{"magic_number_smell": "\n        File tempFile = File.createTempFile(\"mtom-\", \".gif\");\n        FileOutputStream fos = new FileOutputStream(tempFile);\n        BufferedOutputStream dest = new BufferedOutputStream(fos, 2048);\n\n        byte data[] = new byte[2048];\n        int count;", "refactored_code": "    private static final int BUFFER = 2048;\n\n        File tempFile = File.createTempFile(\"mtom-\", \".gif\");\n        FileOutputStream fos = new FileOutputStream(tempFile);\n        BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n\n        byte data[] = new byte[BUFFER];\n        int count;"}
{"magic_number_smell": "    }\n\n    public GetFullQuoteResponse(String symbol) {\n        tradeHistory = new TradingDay[365];\n        for (int i=0; i<365; i++) {\n            tradeHistory[i] = new TradingDay(i, new GetQuoteResponse(symbol));\n        }", "refactored_code": "    private static final int COUNT = 365;\n    }\n\n    public GetFullQuoteResponse(String symbol) {\n        tradeHistory = new TradingDay[COUNT];\n        for (int i=0; i<COUNT; i++) {\n            tradeHistory[i] = new TradingDay(i, new GetQuoteResponse(symbol));\n        }"}
{"magic_number_smell": "    }\n\n    public GetFullQuoteResponse(String symbol) {\n        tradeHistory = new TradingDay[365];\n        for (int i=0; i<365; i++) {\n            tradeHistory[i] = new TradingDay(i, new GetQuoteResponse(symbol));\n        }", "refactored_code": "    private static final int COUNT = 365;\n    }\n\n    public GetFullQuoteResponse(String symbol) {\n        tradeHistory = new TradingDay[COUNT];\n        for (int i=0; i<COUNT; i++) {\n            tradeHistory[i] = new TradingDay(i, new GetQuoteResponse(symbol));\n        }"}
{"magic_number_smell": "\n        File tempFile = File.createTempFile(\"mtom-\", \".gif\");\n        FileOutputStream fos = new FileOutputStream(tempFile);\n        BufferedOutputStream dest = new BufferedOutputStream(fos, 2048);\n\n        byte data[] = new byte[2048];\n        int count;", "refactored_code": "    private static final int BUFFER = 2048;\n\n        File tempFile = File.createTempFile(\"mtom-\", \".gif\");\n        FileOutputStream fos = new FileOutputStream(tempFile);\n        BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n\n        byte data[] = new byte[BUFFER];\n        int count;"}
{"magic_number_smell": "    public static final int SIMPLE_CLIENT_SESSION = 2;\n    public static final int TRANSPORT_SESSION = 3;\n\n    private int session = 0;\n\n    /**\n     * @param args  1: epr", "refactored_code": "    public static final int STATELESS = 0;\n    public static final int SIMPLE_CLIENT_SESSION = 2;\n    public static final int TRANSPORT_SESSION = 3;\n\n    private int session = STATELESS;\n\n    /**\n     * @param args  1: epr"}
{"magic_number_smell": "        Timer requestTimer = new Timer();\n        Timer responseTimer = new Timer();\n        // Retry in 30 seconds\n        long retryIn = 1000 * 30;\n        requestTimer.schedule(logRequests, 0, retryIn);\n        responseTimer.schedule(logResponses, 0, retryIn);\n    }", "refactored_code": "    private static final int LOG_FREQUENCY_IN_SECONDS = 30;\n        Timer requestTimer = new Timer();\n        Timer responseTimer = new Timer();\n        // Retry in 30 seconds\n        long retryIn = 1000 * LOG_FREQUENCY_IN_SECONDS;\n        requestTimer.schedule(logRequests, 0, retryIn);\n        responseTimer.schedule(logResponses, 0, retryIn);\n    }"}
{"magic_number_smell": "    }\n\n    public int getServerCoreThreads() {\n        return getIntProperty(S_T_CORE, 20);\n    }\n\n    public int getServerMaxThreads() {", "refactored_code": "    private static final int WORKERS_CORE_THREADS  = 20;\n    }\n\n    public int getServerCoreThreads() {\n        return getIntProperty(S_T_CORE, WORKERS_CORE_THREADS);\n    }\n\n    public int getServerMaxThreads() {"}
{"magic_number_smell": "        AtomicInteger[] counters = isRequest ? requestSizeCounters : responseSizeCounters;\n\n        if (size < 1024) {\n            counters[0].incrementAndGet();\n        } else if (size < 10240) {\n            counters[LESS_THAN_10K].incrementAndGet();\n        } else if (size < 102400) {", "refactored_code": "    private static final int LESS_THAN_1K       = 0;\n        AtomicInteger[] counters = isRequest ? requestSizeCounters : responseSizeCounters;\n\n        if (size < 1024) {\n            counters[LESS_THAN_1K].incrementAndGet();\n        } else if (size < 10240) {\n            counters[LESS_THAN_10K].incrementAndGet();\n        } else if (size < 102400) {"}
{"magic_number_smell": "\n    private static final int 5 = 5;\n    private static final int LARGE_DATA_COLLECTION_PERIOD = 5 * 60;\n    private static final int SAMPLES_PER_MINUTE = 60/ 5;\n    private static final int SAMPLES_PER_HOUR = (60 * 60)/LARGE_DATA_COLLECTION_PERIOD;\n\n    /** Keeps track of th last reported latency value */", "refactored_code": "    private static final int SMALL_DATA_COLLECTION_PERIOD = 5;\n\n    private static final int SMALL_DATA_COLLECTION_PERIOD = 5;\n    private static final int LARGE_DATA_COLLECTION_PERIOD = 5 * 60;\n    private static final int SAMPLES_PER_MINUTE = 60/ SMALL_DATA_COLLECTION_PERIOD;\n    private static final int SAMPLES_PER_HOUR = (60 * 60)/LARGE_DATA_COLLECTION_PERIOD;\n\n    /** Keeps track of th last reported latency value */"}
{"magic_number_smell": "\n    public int getWorkerPoolCoreSize() {\n        return getIntProperty(PassThroughConfigPNames.WORKER_POOL_SIZE_CORE,\n                40);\n    }\n\n    public int getWorkerPoolMaxSize() {", "refactored_code": "    private static final int DEFAULT_WORKER_POOL_SIZE_CORE       = 40;\n\n    public int getWorkerPoolCoreSize() {\n        return getIntProperty(PassThroughConfigPNames.WORKER_POOL_SIZE_CORE,\n                DEFAULT_WORKER_POOL_SIZE_CORE);\n    }\n\n    public int getWorkerPoolMaxSize() {"}
{"magic_number_smell": "        AtomicInteger[] counters = isRequest ? requestSizeCounters : responseSizeCounters;\n\n        if (size < 1024) {\n            counters[0].incrementAndGet();\n        } else if (size < 10240) {\n            counters[LESS_THAN_10K].incrementAndGet();\n        } else if (size < 102400) {", "refactored_code": "    private static final int LESS_THAN_1K       = 0;\n        AtomicInteger[] counters = isRequest ? requestSizeCounters : responseSizeCounters;\n\n        if (size < 1024) {\n            counters[LESS_THAN_1K].incrementAndGet();\n        } else if (size < 10240) {\n            counters[LESS_THAN_10K].incrementAndGet();\n        } else if (size < 102400) {"}
{"magic_number_smell": "\n    private static final int 5 = 5;\n    private static final int LARGE_DATA_COLLECTION_PERIOD = 5 * 60;\n    private static final int SAMPLES_PER_MINUTE = 60/ 5;\n    private static final int SAMPLES_PER_HOUR = (60 * 60)/LARGE_DATA_COLLECTION_PERIOD;\n\n    /** Keeps track of th last reported latency value */", "refactored_code": "    private static final int SMALL_DATA_COLLECTION_PERIOD = 5;\n\n    private static final int SMALL_DATA_COLLECTION_PERIOD = 5;\n    private static final int LARGE_DATA_COLLECTION_PERIOD = 5 * 60;\n    private static final int SAMPLES_PER_MINUTE = 60/ SMALL_DATA_COLLECTION_PERIOD;\n    private static final int SAMPLES_PER_HOUR = (60 * 60)/LARGE_DATA_COLLECTION_PERIOD;\n\n    /** Keeps track of th last reported latency value */"}
{"magic_number_smell": "    private String contentType;\n\n    /** action to take after a successful poll */\n    private int actionAfterProcess = 0;\n    /** action to take after a poll with errors */\n    private int actionAfterErrors = 0;\n    /** action to take after a failed poll */", "refactored_code": "    public static final int DELETE = 0;\n    private String contentType;\n\n    /** action to take after a successful poll */\n    private int actionAfterProcess = DELETE;\n    /** action to take after a poll with errors */\n    private int actionAfterErrors = DELETE;\n    /** action to take after a failed poll */"}
{"magic_number_smell": "\n    private static final int STATE_RUNNING = 1;\n\n    private volatile int removeTaskState = 0;\n\n    @Override\n    protected void doInit() throws AxisFault {", "refactored_code": "    private static final int STATE_STOPPED = 0;\n\n    private static final int STATE_RUNNING = 1;\n\n    private volatile int removeTaskState = STATE_STOPPED;\n\n    @Override\n    protected void doInit() throws AxisFault {"}
{"magic_number_smell": "        message.getHeader().setField(new BeginString(BEGIN_STRING));\n        message.getHeader().setField(new SenderCompID(SENDER_ID));\n        message.getHeader().setField(new TargetCompID(TARGET_ID));\n        message.getHeader().setField(new MsgSeqNum(5));\n\n        message.setField(new Symbol(SYMBOL));\n        message.setField(new ClOrdID(CLORD_ID));", "refactored_code": "    private static final int SEQ_NUM            = 5;\n        message.getHeader().setField(new BeginString(BEGIN_STRING));\n        message.getHeader().setField(new SenderCompID(SENDER_ID));\n        message.getHeader().setField(new TargetCompID(TARGET_ID));\n        message.getHeader().setField(new MsgSeqNum(SEQ_NUM));\n\n        message.setField(new Symbol(SYMBOL));\n        message.setField(new ClOrdID(CLORD_ID));"}
{"magic_number_smell": "        Matcher matcher = INLINE_TAG_PATTERN.matcher(text);\n        StringBuffer sb = new StringBuffer();\n        while (matcher.find()) {\n            String tagName = matcher.group(1);\n            JavadocTagToHtmlConverter converter = converters.get(tagName);\n            String patternReplacement;\n            if (converter == null) {", "refactored_code": "    private static final int GROUP_TAG_NAME = 1;\n        Matcher matcher = INLINE_TAG_PATTERN.matcher(text);\n        StringBuffer sb = new StringBuffer();\n        while (matcher.find()) {\n            String tagName = matcher.group(GROUP_TAG_NAME);\n            JavadocTagToHtmlConverter converter = converters.get(tagName);\n            String patternReplacement;\n            if (converter == null) {"}
{"magic_number_smell": "        if (!matcher.matches()) {\n            throw new IllegalArgumentException(\"Invalid format of javadoc reference: \" + reference);\n        }\n        final Optional<String> moduleName = getOptionalGroup(matcher, 1);\n        final Optional<String> packageNameClassName = getOptionalGroup(matcher, GROUP_INDEX_PACKAGECLASS);\n        final Optional<String> member = getOptionalGroup(matcher, GROUP_INDEX_MEMBER);\n        final Optional<String> label = getOptionalGroup(matcher, GROUP_INDEX_LABEL);", "refactored_code": "    private static final int GROUP_INDEX_MODULE = 1;\n        if (!matcher.matches()) {\n            throw new IllegalArgumentException(\"Invalid format of javadoc reference: \" + reference);\n        }\n        final Optional<String> moduleName = getOptionalGroup(matcher, GROUP_INDEX_MODULE);\n        final Optional<String> packageNameClassName = getOptionalGroup(matcher, GROUP_INDEX_PACKAGECLASS);\n        final Optional<String> member = getOptionalGroup(matcher, GROUP_INDEX_MEMBER);\n        final Optional<String> label = getOptionalGroup(matcher, GROUP_INDEX_LABEL);"}
{"magic_number_smell": "     * @param settings The settings to use for setting up the client or {@code null}.\n     * @param url The {@code URL} to use for setting up the client or {@code null}.\n     * @return A new {@code HttpClient} instance.\n     * @see #2000\n     * @since 2.8\n     */\n    private static CloseableHttpClient createHttpClient(Settings settings, URL url) {", "refactored_code": "    public static final int DEFAULT_TIMEOUT = 2000;\n     * @param settings The settings to use for setting up the client or {@code null}.\n     * @param url The {@code URL} to use for setting up the client or {@code null}.\n     * @return A new {@code HttpClient} instance.\n     * @see #DEFAULT_TIMEOUT\n     * @since 2.8\n     */\n    private static CloseableHttpClient createHttpClient(Settings settings, URL url) {"}
{"magic_number_smell": "    \n    private void registerAcclSensor() {\n        if (sensorManager.getSensorList(Sensor.TYPE_ACCELEROMETER).size() > 0) {\n            acclSensor = sensorManager.getSensorList(Sensor.TYPE_ACCELEROMETER).get(0);\n            sensorManager.registerListener(this, acclSensor, SensorManager.SENSOR_DELAY_NORMAL);\n        }\n    };", "refactored_code": "    private static final int FIRST_SENSOR_ITEM = 0;\n    \n    private void registerAcclSensor() {\n        if (sensorManager.getSensorList(Sensor.TYPE_ACCELEROMETER).size() > 0) {\n            acclSensor = sensorManager.getSensorList(Sensor.TYPE_ACCELEROMETER).get(FIRST_SENSOR_ITEM);\n            sensorManager.registerListener(this, acclSensor, SensorManager.SENSOR_DELAY_NORMAL);\n        }\n    };"}
{"magic_number_smell": "        if (input.length != prev.length)\n            throw new IllegalArgumentException(\"input and prev must be the same length\");\n        for (int i = 0; i < input.length; i++) {\n            prev[i] = prev[i] + 0.2f * (input[i] - prev[i]);\n        }\n        return prev;\n    }", "refactored_code": "    private static final float ALPHA = 0.2f;\n        if (input.length != prev.length)\n            throw new IllegalArgumentException(\"input and prev must be the same length\");\n        for (int i = 0; i < input.length; i++) {\n            prev[i] = prev[i] + ALPHA * (input[i] - prev[i]);\n        }\n        return prev;\n    }"}
{"magic_number_smell": "\n    private float mLastTouchX;\n    private float mLastTouchY;\n    private int mActivePointerId = -1;\n\n    private ScaleGestureDetector mScaleDetector;\n    private float mScaleFactor = 1.f;", "refactored_code": "    private static final int INVALID_POINTER_ID = -1;\n\n    private float mLastTouchX;\n    private float mLastTouchY;\n    private int mActivePointerId = INVALID_POINTER_ID;\n\n    private ScaleGestureDetector mScaleDetector;\n    private float mScaleFactor = 1.f;"}
{"magic_number_smell": "            @Override\n            public void onClick(View arg0) {\n                Intent intent = new Intent(Intent.ACTION_PICK, People.CONTENT_URI);\n                startActivityForResult(intent, 1);\n            }\n        });\n    }", "refactored_code": "    private static final int PICK_CONTACT = 1;\n            @Override\n            public void onClick(View arg0) {\n                Intent intent = new Intent(Intent.ACTION_PICK, People.CONTENT_URI);\n                startActivityForResult(intent, PICK_CONTACT);\n            }\n        });\n    }"}
{"magic_number_smell": "\t\t\t\tresult = true;\n\t\t\t\tbreak;\n\t\t\tcase R.id.menu_action_choose_view:\n\t\t\t\tshowDialog(0);\n\t\t\t\tresult = true;\n\t\t\t\tbreak;\n\t\t\tcase R.id.menu_action_zoom_out:", "refactored_code": "\tprivate static final int DIALOG_CHOOSE_VIEW_ID = 0;\n\t\t\t\tresult = true;\n\t\t\t\tbreak;\n\t\t\tcase R.id.menu_action_choose_view:\n\t\t\t\tshowDialog(DIALOG_CHOOSE_VIEW_ID);\n\t\t\t\tresult = true;\n\t\t\t\tbreak;\n\t\t\tcase R.id.menu_action_zoom_out:"}
{"magic_number_smell": "\t}\n\n\tpublic int detectZoom(MotionEvent event) {\n\t\tint result = 0;\n\t\tswitch (event.getAction() & MotionEvent.ACTION_MASK) {\n\t\t\tcase MotionEvent.ACTION_MOVE:\n\t\t\t\tresult = moving(event);", "refactored_code": "\tpublic static final int OTHER = 0;\n\t}\n\n\tpublic int detectZoom(MotionEvent event) {\n\t\tint result = OTHER;\n\t\tswitch (event.getAction() & MotionEvent.ACTION_MASK) {\n\t\t\tcase MotionEvent.ACTION_MOVE:\n\t\t\t\tresult = moving(event);"}
{"magic_number_smell": "    @Override\n    public void setDisplayOptions(int options) {\n        int changes = mLeftNav.setDisplayOptions(options);\n        if (has(changes, 0x20) || has(changes, DISPLAY_AUTO_EXPAND)\n                || has(changes, DISPLAY_SHOW_TITLE)\n                || has(changes, DISPLAY_SHOW_INDETERMINATE_PROGRESS)) {\n            updateWindowLayout(false);", "refactored_code": "    public static final int DISPLAY_ALWAYS_EXPANDED = 0x20;\n    @Override\n    public void setDisplayOptions(int options) {\n        int changes = mLeftNav.setDisplayOptions(options);\n        if (has(changes, DISPLAY_ALWAYS_EXPANDED) || has(changes, DISPLAY_AUTO_EXPAND)\n                || has(changes, DISPLAY_SHOW_TITLE)\n                || has(changes, DISPLAY_SHOW_INDETERMINATE_PROGRESS)) {\n            updateWindowLayout(false);"}
{"magic_number_smell": "    }\n\n    /**\n     * @see #-2\n     */\n    void add(TabImpl tab, int position, boolean setSelected) {\n        if (position == -2) {", "refactored_code": "    public static final int LAST_POSITION = -2;\n    }\n\n    /**\n     * @see #LAST_POSITION\n     */\n    void add(TabImpl tab, int position, boolean setSelected) {\n        if (position == LAST_POSITION) {"}
{"magic_number_smell": "    }\n\n    private CameraUpdate zoomToLastKnownLatLng() {\n        return CameraUpdateFactory.newLatLngZoom(getLastKnownLatLng(), 16);\n    }\n\n    private LatLng getLastKnownLatLng() {", "refactored_code": "    private static final int ZOOM_LEVEL = 16;\n    }\n\n    private CameraUpdate zoomToLastKnownLatLng() {\n        return CameraUpdateFactory.newLatLngZoom(getLastKnownLatLng(), ZOOM_LEVEL);\n    }\n\n    private LatLng getLastKnownLatLng() {"}
{"magic_number_smell": "\n    @Override\n    public int getItemViewType(final int position) {\n        return moviesSate.size() == position ? NEXT_PAGE_ITEM : 0;\n    }\n\n    @Override", "refactored_code": "    private static final int MOVIE_ITEM = 0;\n\n    @Override\n    public int getItemViewType(final int position) {\n        return moviesSate.size() == position ? NEXT_PAGE_ITEM : MOVIE_ITEM;\n    }\n\n    @Override"}
{"magic_number_smell": "\t}\n\n\tpublic int detectZoom(MotionEvent event) {\n\t\tint result = 0;\n\t\tswitch (event.getAction() & MotionEvent.ACTION_MASK) {\n\t\t\tcase MotionEvent.ACTION_MOVE:\n\t\t\t\tresult = moving(event);", "refactored_code": "\tpublic static final int OTHER = 0;\n\t}\n\n\tpublic int detectZoom(MotionEvent event) {\n\t\tint result = OTHER;\n\t\tswitch (event.getAction() & MotionEvent.ACTION_MASK) {\n\t\t\tcase MotionEvent.ACTION_MOVE:\n\t\t\t\tresult = moving(event);"}
{"magic_number_smell": "    }\n\n    private boolean credentialsAreInvalid() {\n        return userNameEditText.getText().toString().length() < 4\n                || passwordEditText.getText().toString().length() < 4;\n    }\n", "refactored_code": "    private static final int MINIMUM_INPUT_LENGTH = 4;\n    }\n\n    private boolean credentialsAreInvalid() {\n        return userNameEditText.getText().toString().length() < MINIMUM_INPUT_LENGTH\n                || passwordEditText.getText().toString().length() < MINIMUM_INPUT_LENGTH;\n    }\n"}
{"magic_number_smell": "    private List<Quad> landscapeLayers = new ArrayList<>(LANDSCAPE_LAYERS_FILES_NAMES.length);\n    private List<Quad> snowFlakesQuads = new ArrayList<>(SnowFlakeTypes.count());\n    private List<Quad> currentLayers = new ArrayList<>();\n    private List<SnowFlake> snowFlakes = new ArrayList<>(40);\n\n    private Quad santaToLeftLayer;\n    private Quad santaToRightLayer;", "refactored_code": "    private static final int MAX_SNOW_FLAKES_COUNT = 40;\n    private List<Quad> landscapeLayers = new ArrayList<>(LANDSCAPE_LAYERS_FILES_NAMES.length);\n    private List<Quad> snowFlakesQuads = new ArrayList<>(SnowFlakeTypes.count());\n    private List<Quad> currentLayers = new ArrayList<>();\n    private List<SnowFlake> snowFlakes = new ArrayList<>(MAX_SNOW_FLAKES_COUNT);\n\n    private Quad santaToLeftLayer;\n    private Quad santaToRightLayer;"}
{"magic_number_smell": "\n    private float resetYToCentralHeight() {\n        Random random = new Random();\n        return random.nextFloat() * (skyHeight - santaHeight) * 0.6f + (skyHeight - santaHeight) * TOP_SKY_FRACTION;\n    }\n\n    public void updatePosition() {", "refactored_code": "    private static final float SKY_HEIGHT_FRACTION = 0.6f;\n\n    private float resetYToCentralHeight() {\n        Random random = new Random();\n        return random.nextFloat() * (skyHeight - santaHeight) * SKY_HEIGHT_FRACTION + (skyHeight - santaHeight) * TOP_SKY_FRACTION;\n    }\n\n    public void updatePosition() {"}
{"magic_number_smell": "        }\n\n        public EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig config) {\n                int[] attrib_list = {0x3098, eglContextClientVersion,\n                EGL10.EGL_NONE };\n                return egl.eglCreateContext(display, config, EGL10.EGL_NO_CONTEXT,\n                                eglContextClientVersion != 0 ? attrib_list : null);", "refactored_code": "        private static final int EGL_CONTEXT_CLIENT_VERSION = 0x3098;\n        }\n\n        public EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig config) {\n                int[] attrib_list = {EGL_CONTEXT_CLIENT_VERSION, eglContextClientVersion,\n                EGL10.EGL_NONE };\n                return egl.eglCreateContext(display, config, EGL10.EGL_NO_CONTEXT,\n                                eglContextClientVersion != 0 ? attrib_list : null);"}
{"magic_number_smell": "\t\t      1f,  0f,  // 3, Top Right\n\t\t      1f, 1f,  // 2, Bottom Right\n\t\t};\n\t\tByteBuffer byteBuffer = ByteBuffer.allocateDirect(vertices.length * 4);\n\t\tbyteBuffer.order(ByteOrder.nativeOrder());\n\t\tvertexBuffer = byteBuffer.asFloatBuffer();\n\t\tvertexBuffer.put(vertices);", "refactored_code": "\tprivate static final int SIZEOF_FLOAT = 4;\n\t\t      1f,  0f,  // 3, Top Right\n\t\t      1f, 1f,  // 2, Bottom Right\n\t\t};\n\t\tByteBuffer byteBuffer = ByteBuffer.allocateDirect(vertices.length * SIZEOF_FLOAT);\n\t\tbyteBuffer.order(ByteOrder.nativeOrder());\n\t\tvertexBuffer = byteBuffer.asFloatBuffer();\n\t\tvertexBuffer.put(vertices);"}
{"magic_number_smell": "        this.assetManager = assetManager;\n    }\n\n    private int[] textures = new int[16];\n    private int nextSlot = 0;\n\n    public boolean slotsAvailable() {", "refactored_code": "    public static final int MAX_TEXTURES = 16;\n        this.assetManager = assetManager;\n    }\n\n    private int[] textures = new int[MAX_TEXTURES];\n    private int nextSlot = 0;\n\n    public boolean slotsAvailable() {"}
{"magic_number_smell": "            \"DROP TABLE IF EXISTS \" + TaskEntry.TABLE_NAME;\n\n    public TaskReaderDbHelper(Context context) {\n        super(context, DATABASE_NAME, null, 1);\n    }\n\n    public void onCreate(SQLiteDatabase db) {", "refactored_code": "    public static final int DATABASE_VERSION = 1;\n            \"DROP TABLE IF EXISTS \" + TaskEntry.TABLE_NAME;\n\n    public TaskReaderDbHelper(Context context) {\n        super(context, DATABASE_NAME, null, DATABASE_VERSION);\n    }\n\n    public void onCreate(SQLiteDatabase db) {"}
{"magic_number_smell": "        this.step2result = (TextView)findViewById(R.id.step2result);\n        this.step3result = (TextView)findViewById(R.id.step3result);  \n        \n        startActivityForResult(new Intent(Wizard.INTENT_STEP1), 1);        \n    }\n    \n    ", "refactored_code": "    private static final int STEP1 = 1;\n        this.step2result = (TextView)findViewById(R.id.step2result);\n        this.step3result = (TextView)findViewById(R.id.step3result);  \n        \n        startActivityForResult(new Intent(Wizard.INTENT_STEP1), STEP1);        \n    }\n    \n    "}
{"magic_number_smell": "    private final int 256 = 256;\n    private final int UPPER_LIMIT = 2048;\n\n    private StringBuilder buf = new StringBuilder(256);\n    private boolean locationInfo = false;\n    private boolean properties = false;\n", "refactored_code": "    private final int DEFAULT_SIZE = 256;\n    private final int DEFAULT_SIZE = 256;\n    private final int UPPER_LIMIT = 2048;\n\n    private StringBuilder buf = new StringBuilder(DEFAULT_SIZE);\n    private boolean locationInfo = false;\n    private boolean properties = false;\n"}
{"magic_number_smell": "    private InetAddress address;\n    private int port;\n    private int reconnectionDelay;\n    private int acceptConnectionTimeout = 5000;\n\n    private String receiverId;\n    private volatile Socket socket;", "refactored_code": "    private static final int DEFAULT_ACCEPT_CONNECTION_DELAY = 5000;\n    private InetAddress address;\n    private int port;\n    private int reconnectionDelay;\n    private int acceptConnectionTimeout = DEFAULT_ACCEPT_CONNECTION_DELAY;\n\n    private String receiverId;\n    private volatile Socket socket;"}
{"magic_number_smell": "    public static final int 50 = 50;\n\n    private int port = AbstractSocketAppender.DEFAULT_PORT;\n    private int backlog = 50;\n\n    private String address;\n", "refactored_code": "    public static final int DEFAULT_BACKLOG = 50;\n    public static final int DEFAULT_BACKLOG = 50;\n\n    private int port = AbstractSocketAppender.DEFAULT_PORT;\n    private int backlog = DEFAULT_BACKLOG;\n\n    private String address;\n"}
{"magic_number_smell": "    private static final double NEGATIVE = -1;\n    private volatile boolean cacheEnabled = true;\n\n    private final NameCache cache = new NameCache(512);\n\n    private Abbreviator abbreviator = null;\n", "refactored_code": "    private static final int INITIAL_CACHE_SIZE = 512;\n    private static final double NEGATIVE = -1;\n    private volatile boolean cacheEnabled = true;\n\n    private final NameCache cache = new NameCache(INITIAL_CACHE_SIZE);\n\n    private Abbreviator abbreviator = null;\n"}
{"magic_number_smell": "    }\n\n    protected String throwableProxyToString(IThrowableProxy tp) {\n        StringBuilder sb = new StringBuilder(2048);\n\n        recursiveAppend(sb, null, ThrowableProxyUtil.REGULAR_EXCEPTION_INDENT, tp);\n", "refactored_code": "    protected static final int BUILDER_CAPACITY = 2048;\n    }\n\n    protected String throwableProxyToString(IThrowableProxy tp) {\n        StringBuilder sb = new StringBuilder(BUILDER_CAPACITY);\n\n        recursiveAppend(sb, null, ThrowableProxyUtil.REGULAR_EXCEPTION_INDENT, tp);\n"}
{"magic_number_smell": "        StackTraceElement[] steArray = t.getStackTrace();\n        StackTraceElement[] callerDataArray;\n\n        int found = -1;\n        for (int i = 0; i < steArray.length; i++) {\n            if (isInFrameworkSpace(steArray[i].getClassName(), fqnOfInvokingClass, frameworkPackageList)) {\n                // the caller is assumed to be the next stack frame, hence the +1.", "refactored_code": "    public static final int LINE_NA = -1;\n        StackTraceElement[] steArray = t.getStackTrace();\n        StackTraceElement[] callerDataArray;\n\n        int found = LINE_NA;\n        for (int i = 0; i < steArray.length; i++) {\n            if (isInFrameworkSpace(steArray[i].getClassName(), fqnOfInvokingClass, frameworkPackageList)) {\n                // the caller is assumed to be the next stack frame, hence the +1."}
{"magic_number_smell": "\n    private static final int -1 = -1;\n\n    private static int hasJMXObjectName = -1;\n\n    public static boolean hasJMXObjectName() {\n        if (hasJMXObjectName == -1) {", "refactored_code": "    private static final int UNINITIALIZED = -1;\n\n    private static final int UNINITIALIZED = -1;\n\n    private static int hasJMXObjectName = UNINITIALIZED;\n\n    public static boolean hasJMXObjectName() {\n        if (hasJMXObjectName == UNINITIALIZED) {"}
{"magic_number_smell": "    public static String asString(IThrowableProxy tp) {\n        StringBuilder sb = new StringBuilder(BUILDER_CAPACITY);\n\n        recursiveAppend(sb, null, 1, tp);\n\n        return sb.toString();\n    }", "refactored_code": "    public static final int REGULAR_EXCEPTION_INDENT = 1;\n    public static String asString(IThrowableProxy tp) {\n        StringBuilder sb = new StringBuilder(BUILDER_CAPACITY);\n\n        recursiveAppend(sb, null, REGULAR_EXCEPTION_INDENT, tp);\n\n        return sb.toString();\n    }"}
{"magic_number_smell": "    public static final int DEFAULT_ALLOWED_REPETITIONS = 5;\n\n    public int allowedRepetitions = DEFAULT_ALLOWED_REPETITIONS;\n    public int cacheSize = 100;\n\n    private LRUMessageCache msgCache;\n", "refactored_code": "    public static final int DEFAULT_CACHE_SIZE = 100;\n    public static final int DEFAULT_ALLOWED_REPETITIONS = 5;\n\n    public int allowedRepetitions = DEFAULT_ALLOWED_REPETITIONS;\n    public int cacheSize = DEFAULT_CACHE_SIZE;\n\n    private LRUMessageCache msgCache;\n"}
{"magic_number_smell": "    private void updateMaskIfNecessary(long now) {\n        final long timeElapsedSinceLastMaskUpdateCheck = now - lastMaskCheck;\n        lastMaskCheck = now;\n        if (timeElapsedSinceLastMaskUpdateCheck < MASK_INCREASE_THRESHOLD && (mask < 0xFFFF)) {\n            mask = (mask << 1) | 1;\n        } else if (timeElapsedSinceLastMaskUpdateCheck > MASK_DECREASE_THRESHOLD) {\n            mask = mask >>> 2;", "refactored_code": "    private static final int MAX_MASK = 0xFFFF;\n    private void updateMaskIfNecessary(long now) {\n        final long timeElapsedSinceLastMaskUpdateCheck = now - lastMaskCheck;\n        lastMaskCheck = now;\n        if (timeElapsedSinceLastMaskUpdateCheck < MASK_INCREASE_THRESHOLD && (mask < MAX_MASK)) {\n            mask = (mask << 1) | 1;\n        } else if (timeElapsedSinceLastMaskUpdateCheck > MASK_DECREASE_THRESHOLD) {\n            mask = mask >>> 2;"}
{"magic_number_smell": "    }\n\n    /**\n     * Make a standard corpus. The standard corpus has {@link #50 * 1000}\n     * elements.\n     * \n     * @return event array representing the standard corpus", "refactored_code": "    static public final int STANDARD_CORPUS_SIZE = 50 * 1000;\n    }\n\n    /**\n     * Make a standard corpus. The standard corpus has {@link #STANDARD_CORPUS_SIZE}\n     * elements.\n     * \n     * @return event array representing the standard corpus"}
{"magic_number_smell": "\n    private void runTest() {\n\n        CountDownLatch latch = new CountDownLatch(3);\n        List<Thread> threads = new ArrayList<>(3);\n        for (int i = 0; i < 3; i++) {\n            LoggerThread thread = new LoggerThread(latch, \"message from thread \" + i);", "refactored_code": "    private static final int THREADS = 3;\n\n    private void runTest() {\n\n        CountDownLatch latch = new CountDownLatch(THREADS);\n        List<Thread> threads = new ArrayList<>(THREADS);\n        for (int i = 0; i < THREADS; i++) {\n            LoggerThread thread = new LoggerThread(latch, \"message from thread \" + i);"}
{"magic_number_smell": "        receiver.stop();\n        ExecutorService executor = lc.getExecutorService();\n        executor.shutdownNow();\n        assertTrue(executor.awaitTermination(1000, TimeUnit.MILLISECONDS));\n        socket.close();\n        serverSocket.close();\n        lc.stop();", "refactored_code": "    private static final int DELAY = 1000;\n        receiver.stop();\n        ExecutorService executor = lc.getExecutorService();\n        executor.shutdownNow();\n        assertTrue(executor.awaitTermination(DELAY, TimeUnit.MILLISECONDS));\n        socket.close();\n        serverSocket.close();\n        lc.stop();"}
{"magic_number_smell": "            LoggingEventVO eventVO = LoggingEventVO.build(event);\n\n            ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());\n            for (int i = 0; i < 10; i++) {\n                oos.writeObject(eventVO);\n            }\n", "refactored_code": "    private static final int EVENT_COUNT = 10;\n            LoggingEventVO eventVO = LoggingEventVO.build(event);\n\n            ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());\n            for (int i = 0; i < EVENT_COUNT; i++) {\n                oos.writeObject(eventVO);\n            }\n"}
{"magic_number_smell": "\n    void someMethodWithNullException() throws Exception {\n        throw new Exception(\"someMethodWithNullException\") {\n            private static final long 1L = -2419053636101615373L;\n\n            @Override\n            public StackTraceElement[] getStackTrace() {", "refactored_code": "            private static final long serialVersionUID = 1L;\n\n    void someMethodWithNullException() throws Exception {\n        throw new Exception(\"someMethodWithNullException\") {\n            private static final long serialVersionUID = -2419053636101615373L;\n\n            @Override\n            public StackTraceElement[] getStackTrace() {"}
{"magic_number_smell": "     * The default buffer size.\n     */\n    public static final int 256 = 256;\n    int queueSize = 256;\n\n    int appenderCount = 0;\n", "refactored_code": "    public static final int DEFAULT_QUEUE_SIZE = 256;\n     * The default buffer size.\n     */\n    public static final int DEFAULT_QUEUE_SIZE = 256;\n    int queueSize = DEFAULT_QUEUE_SIZE;\n\n    int appenderCount = 0;\n"}
{"magic_number_smell": "        }\n\n        synchronized (statusListLock) {\n            if (statusList.size() < 150) {\n                statusList.add(newStatus);\n            } else {\n                tailBuffer.add(newStatus);", "refactored_code": "    public static final int MAX_HEADER_COUNT = 150;\n        }\n\n        synchronized (statusListLock) {\n            if (statusList.size() < MAX_HEADER_COUNT) {\n                statusList.add(newStatus);\n            } else {\n                tailBuffer.add(newStatus);"}
{"magic_number_smell": "\n    private boolean prudent = false;\n\n    private FileSize bufferSize = new FileSize(8192);\n\n    /**\n     * The <b>File</b> property takes a string value which should be the name of the", "refactored_code": "    public static final long DEFAULT_BUFFER_SIZE = 8192;\n\n    private boolean prudent = false;\n\n    private FileSize bufferSize = new FileSize(DEFAULT_BUFFER_SIZE);\n\n    /**\n     * The <b>File</b> property takes a string value which should be the name of the"}
{"magic_number_smell": "            return result;\n        } catch (Exception ex) {\n            errorCount++;\n            if (errorCount >= 4) {\n                stop();\n            }\n            throw new EvaluationException(\"Evaluator [\" + name + \"] caused an exception\", ex);", "refactored_code": "    static public final int ERROR_THRESHOLD = 4;\n            return result;\n        } catch (Exception ex) {\n            errorCount++;\n            if (errorCount >= ERROR_THRESHOLD) {\n                stop();\n            }\n            throw new EvaluationException(\"Evaluator [\" + name + \"] caused an exception\", ex);"}
{"magic_number_smell": "        while (end > -1) {\n            output.append(str.substring(start, end));\n            output.append(CDATA_EMBEDED_END);\n            start = end + CDATA_END.length();\n\n            if (start < str.length()) {\n                end = str.indexOf(CDATA_END, start);", "refactored_code": "    private static final int CDATA_END_LEN = CDATA_END.length();\n        while (end > -1) {\n            output.append(str.substring(start, end));\n            output.append(CDATA_EMBEDED_END);\n            start = end + CDATA_END_LEN;\n\n            if (start < str.length()) {\n                end = str.indexOf(CDATA_END, start);"}
{"magic_number_smell": "    private final QueueFactory queueFactory;\n\n    private String remoteHost;\n    private int port = 4560;\n    private InetAddress address;\n    private Duration reconnectionDelay = new Duration(DEFAULT_RECONNECTION_DELAY);\n    private int queueSize = DEFAULT_QUEUE_SIZE;", "refactored_code": "    public static final int DEFAULT_PORT = 4560;\n    private final QueueFactory queueFactory;\n\n    private String remoteHost;\n    private int port = DEFAULT_PORT;\n    private InetAddress address;\n    private Duration reconnectionDelay = new Duration(DEFAULT_RECONNECTION_DELAY);\n    private int queueSize = DEFAULT_QUEUE_SIZE;"}
{"magic_number_smell": "        DatagramPacket packet = new DatagramPacket(bytes, bytes.length, address, port);\n\n        // clean up for next round\n        if (baos.size() > 1024) {\n            baos = new ByteArrayOutputStream();\n        } else {\n            baos.reset();", "refactored_code": "    private static final int MAX_LEN = 1024;\n        DatagramPacket packet = new DatagramPacket(bytes, bytes.length, address, port);\n\n        // clean up for next round\n        if (baos.size() > MAX_LEN) {\n            baos = new ByteArrayOutputStream();\n        } else {\n            baos.reset();"}
{"magic_number_smell": "    public static final int DEFAULT_CLIENT_QUEUE_SIZE = 100;\n\n    private int port = AbstractSocketAppender.DEFAULT_PORT;\n    private int backlog = 50;\n    private int clientQueueSize = DEFAULT_CLIENT_QUEUE_SIZE;\n\n    private String address;", "refactored_code": "    public static final int DEFAULT_BACKLOG = 50;\n    public static final int DEFAULT_CLIENT_QUEUE_SIZE = 100;\n\n    private int port = AbstractSocketAppender.DEFAULT_PORT;\n    private int backlog = DEFAULT_BACKLOG;\n    private int clientQueueSize = DEFAULT_CLIENT_QUEUE_SIZE;\n\n    private String address;"}
{"magic_number_smell": "     */\n    public static final long 10 * 1024 * 1024 = 10 * 1024 * 1024; // 10 MB\n\n    FileSize maxFileSize = new FileSize(10 * 1024 * 1024);\n    InvocationGate invocationGate = new SimpleInvocationGate();\n    Duration checkIncrement = null;\n", "refactored_code": "    public static final long DEFAULT_MAX_FILE_SIZE = 10 * 1024 * 1024; // 10 MB\n     */\n    public static final long DEFAULT_MAX_FILE_SIZE = 10 * 1024 * 1024; // 10 MB\n\n    FileSize maxFileSize = new FileSize(DEFAULT_MAX_FILE_SIZE);\n    InvocationGate invocationGate = new SimpleInvocationGate();\n    Duration checkIncrement = null;\n"}
{"magic_number_smell": "                    String indexAsStr = matcher.group(1);\n\n                    if (indexAsStr == null || indexAsStr.isEmpty())\n                        return -1; // unreachable code?\n                    else\n                        return Integer.parseInt(indexAsStr);\n                } else", "refactored_code": "    protected static final int NO_INDEX = -1;\n                    String indexAsStr = matcher.group(1);\n\n                    if (indexAsStr == null || indexAsStr.isEmpty())\n                        return NO_INDEX; // unreachable code?\n                    else\n                        return Integer.parseInt(indexAsStr);\n                } else"}
{"magic_number_smell": "    private int maxHistory = CoreConstants.UNBOUNDED_HISTORY;\n    private long totalSizeCap = CoreConstants.UNBOUNDED_TOTAL_SIZE_CAP;\n    final boolean parentClean;\n    long lastHeartBeat = -1;\n\n    public TimeBasedArchiveRemover(FileNamePattern fileNamePattern, RollingCalendar rc) {\n        this.fileNamePattern = fileNamePattern;", "refactored_code": "    static protected final long UNINITIALIZED = -1;\n    private int maxHistory = CoreConstants.UNBOUNDED_HISTORY;\n    private long totalSizeCap = CoreConstants.UNBOUNDED_TOTAL_SIZE_CAP;\n    final boolean parentClean;\n    long lastHeartBeat = UNINITIALIZED;\n\n    public TimeBasedArchiveRemover(FileNamePattern fileNamePattern, RollingCalendar rc) {\n        this.fileNamePattern = fileNamePattern;"}
{"magic_number_smell": "    }\n\n    private void increaseMask() {\n        if (mask >= 0xFFFF)\n            return;\n        mask = (mask << 1) | 1;\n    }", "refactored_code": "    private static final int MAX_MASK = 0xFFFF;\n    }\n\n    private void increaseMask() {\n        if (mask >= MAX_MASK)\n            return;\n        mask = (mask << 1) | 1;\n    }"}
{"magic_number_smell": "    private ByteBuffer buffer;\n\n    public DirectJson() {\n        buffer = ByteBuffer.allocateDirect(1024);\n    }\n\n    public void openObject() { buffer.put(OPEN_OBJ); }", "refactored_code": "    private static final int INITIAL_BUFFER_SIZE = 1024;\n    private ByteBuffer buffer;\n\n    public DirectJson() {\n        buffer = ByteBuffer.allocateDirect(INITIAL_BUFFER_SIZE);\n    }\n\n    public void openObject() { buffer.put(OPEN_OBJ); }"}
{"magic_number_smell": "            Pattern.CASE_INSENSITIVE);\n\n    static public final long 1024 = 1024;\n    static public final long MB_COEFFICIENT = 1024 * 1024;\n    static public final long GB_COEFFICIENT = 1024 * MB_COEFFICIENT;\n\n    final long size;", "refactored_code": "    static public final long KB_COEFFICIENT = 1024;\n            Pattern.CASE_INSENSITIVE);\n\n    static public final long KB_COEFFICIENT = 1024;\n    static public final long MB_COEFFICIENT = 1024 * KB_COEFFICIENT;\n    static public final long GB_COEFFICIENT = 1024 * MB_COEFFICIENT;\n\n    final long size;"}
{"magic_number_smell": "        instrumentedAppender.stop();\n        Assertions.assertFalse(instrumentedAppender.isStarted());\n        threadPoolExecutor.shutdownNow();\n        Assertions.assertTrue(threadPoolExecutor.awaitTermination(2000, TimeUnit.MILLISECONDS));\n    }\n\n    @Disabled // JDK 16", "refactored_code": "    private static final int TIMEOUT = 2000;\n        instrumentedAppender.stop();\n        Assertions.assertFalse(instrumentedAppender.isStarted());\n        threadPoolExecutor.shutdownNow();\n        Assertions.assertTrue(threadPoolExecutor.awaitTermination(TIMEOUT, TimeUnit.MILLISECONDS));\n    }\n\n    @Disabled // JDK 16"}
{"magic_number_smell": "        \n        Future<Socket> connectorTask = executor.submit(connector);\n\n        Socket socket = connectorTask.get(2000, TimeUnit.MILLISECONDS);\n        Assertions.assertNotNull(socket);\n        connectorTask.cancel(true);\n", "refactored_code": "    private static final int DELAY = 2000;\n        \n        Future<Socket> connectorTask = executor.submit(connector);\n\n        Socket socket = connectorTask.get(DELAY, TimeUnit.MILLISECONDS);\n        Assertions.assertNotNull(socket);\n        connectorTask.cancel(true);\n"}
{"magic_number_smell": "    @AfterEach\n    public void tearDown() throws Exception {\n        executor.shutdownNow();\n        Assertions.assertTrue(executor.awaitTermination(10000, TimeUnit.MILLISECONDS));\n    }\n\n    @Test", "refactored_code": "    private static final int DELAY = 10000;\n    @AfterEach\n    public void tearDown() throws Exception {\n        executor.shutdownNow();\n        Assertions.assertTrue(executor.awaitTermination(DELAY, TimeUnit.MILLISECONDS));\n    }\n\n    @Test"}
{"magic_number_smell": "        socket.setSoTimeout(1000);\n        ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());\n\n        for (int i = 0; i < 10; i++) {\n            appender.append(TEST_EVENT + i);\n            Assertions.assertEquals(TEST_EVENT + i, ois.readObject());\n        }", "refactored_code": "    private static final int EVENT_COUNT = 10;\n        socket.setSoTimeout(1000);\n        ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());\n\n        for (int i = 0; i < EVENT_COUNT; i++) {\n            appender.append(TEST_EVENT + i);\n            Assertions.assertEquals(TEST_EVENT + i, ois.readObject());\n        }"}
{"magic_number_smell": "        public void run() {\n            sleep(10);\n            while(!isDone()) {\n                if (0 == random.nextInt(100)) {\n                    long ct = currentTime.incrementAndGet();\n                    if((ct & MASK) == MASK) {\n                        System.out.println(\"Time increment ct=\"+ct);", "refactored_code": "    private static final int ONCE_EVERY = 100;\n        public void run() {\n            sleep(10);\n            while(!isDone()) {\n                if (0 == random.nextInt(ONCE_EVERY)) {\n                    long ct = currentTime.incrementAndGet();\n                    if((ct & MASK) == MASK) {\n                        System.out.println(\"Time increment ct=\"+ct);"}
{"magic_number_smell": "    String logfileStr = outputDirStr + \"output.log\";\n\n    private static final int 8 = 8;\n    private static final int LOOP_COUNT = 100/ 8;\n\n    @BeforeEach\n    public void beforeEach() {", "refactored_code": "    private static final int THREAD_COUNT = 8;\n    String logfileStr = outputDirStr + \"output.log\";\n\n    private static final int THREAD_COUNT = 8;\n    private static final int LOOP_COUNT = 100/ THREAD_COUNT;\n\n    @BeforeEach\n    public void beforeEach() {"}
{"magic_number_smell": "    String result=i.getStringExtra(PAYLOAD);\n    int resultCode=i.getIntExtra(RESULT_CODE, -1);\n    \n    if (resultCode==1337) {\n      success(result);\n    }\n    else {", "refactored_code": "  private static final int SUCCESS=1337;\n    String result=i.getStringExtra(PAYLOAD);\n    int resultCode=i.getIntExtra(RESULT_CODE, -1);\n    \n    if (resultCode==SUCCESS) {\n      success(result);\n    }\n    else {"}
{"magic_number_smell": "  }\n  \n  private void success(Intent intent, String result) {\n    send(intent, result, 1337);\n  }\n  \n  private void failure(Intent intent, String error) {", "refactored_code": "  private static final int SUCCESS=1337;\n  }\n  \n  private void success(Intent intent, String result) {\n    send(intent, result, SUCCESS);\n  }\n  \n  private void failure(Intent intent, String error) {"}
{"magic_number_smell": "                            \"...but not enough to keep the activity running\",\n                            i);\n    \n    mgr.notify(1337, note);\n  }\n}", "refactored_code": "  private static final int NOTIFY_ME_ID=1337;\n                            \"...but not enough to keep the activity running\",\n                            i);\n    \n    mgr.notify(NOTIFY_ME_ID, note);\n  }\n}"}
{"magic_number_smell": "      public void onClick(View view) {\n        Intent i=new Intent(Intent.ACTION_PICK, CONTENT_URI);\n\n        startActivityForResult(i, 1337);\n      }\n    });\n  }", "refactored_code": "  private static final int PICK_REQUEST=1337;\n      public void onClick(View view) {\n        Intent i=new Intent(Intent.ACTION_PICK, CONTENT_URI);\n\n        startActivityForResult(i, PICK_REQUEST);\n      }\n    });\n  }"}
{"magic_number_smell": "  \n  @Override\n  public boolean onCreateOptionsMenu(Menu menu) {\n    menu.add(Menu.NONE, Menu.FIRST+1, Menu.NONE, \"Add\")\n        .setIcon(R.drawable.add)\n        .setAlphabeticShortcut('a');\n", "refactored_code": "  private static final int ADD_ID = Menu.FIRST+1;\n  \n  @Override\n  public boolean onCreateOptionsMenu(Menu menu) {\n    menu.add(Menu.NONE, ADD_ID, Menu.NONE, \"Add\")\n        .setIcon(R.drawable.add)\n        .setAlphabeticShortcut('a');\n"}
{"magic_number_smell": "  static {\n    MATCHER=new UriMatcher(UriMatcher.NO_MATCH);\n    MATCHER.addURI(\"com.commonsware.android.constants.Provider\",\n                   \"constants\", 1);\n    MATCHER.addURI(\"com.commonsware.android.constants.Provider\",\n                   \"constants/#\", CONSTANT_ID);\n  }", "refactored_code": "  private static final int CONSTANTS=1;\n  static {\n    MATCHER=new UriMatcher(UriMatcher.NO_MATCH);\n    MATCHER.addURI(\"com.commonsware.android.constants.Provider\",\n                   \"constants\", CONSTANTS);\n    MATCHER.addURI(\"com.commonsware.android.constants.Provider\",\n                   \"constants/#\", CONSTANT_ID);\n  }"}
{"magic_number_smell": "  \n  @Override\n  public boolean onCreateOptionsMenu(Menu menu) {\n    menu.add(Menu.NONE, Menu.FIRST+1, Menu.NONE, \"Add\")\n        .setIcon(R.drawable.add)\n        .setAlphabeticShortcut('a');\n", "refactored_code": "  private static final int ADD_ID = Menu.FIRST+1;\n  \n  @Override\n  public boolean onCreateOptionsMenu(Menu menu) {\n    menu.add(Menu.NONE, ADD_ID, Menu.NONE, \"Add\")\n        .setIcon(R.drawable.add)\n        .setAlphabeticShortcut('a');\n"}
{"magic_number_smell": "  static {\n    MATCHER=new UriMatcher(UriMatcher.NO_MATCH);\n    MATCHER.addURI(\"com.commonsware.android.constants.Provider\",\n                   \"constants\", 1);\n    MATCHER.addURI(\"com.commonsware.android.constants.Provider\",\n                   \"constants/#\", CONSTANT_ID);\n  }", "refactored_code": "  private static final int CONSTANTS=1;\n  static {\n    MATCHER=new UriMatcher(UriMatcher.NO_MATCH);\n    MATCHER.addURI(\"com.commonsware.android.constants.Provider\",\n                   \"constants\", CONSTANTS);\n    MATCHER.addURI(\"com.commonsware.android.constants.Provider\",\n                   \"constants/#\", CONSTANT_ID);\n  }"}
{"magic_number_smell": "\n  @Override\n  public boolean onCreateOptionsMenu(Menu menu) {\n    menu.add(Menu.NONE, Menu.FIRST + 1, Menu.NONE, \"Add\")\n        .setIcon(R.drawable.add).setAlphabeticShortcut('a');\n\n    return(super.onCreateOptionsMenu(menu));", "refactored_code": "  private static final int ADD_ID=Menu.FIRST + 1;\n\n  @Override\n  public boolean onCreateOptionsMenu(Menu menu) {\n    menu.add(Menu.NONE, ADD_ID, Menu.NONE, \"Add\")\n        .setIcon(R.drawable.add).setAlphabeticShortcut('a');\n\n    return(super.onCreateOptionsMenu(menu));"}
{"magic_number_smell": "  static {\n    MATCHER=new UriMatcher(UriMatcher.NO_MATCH);\n    MATCHER.addURI(\"com.commonsware.android.constants.Provider\",\n                   \"constants\", 1);\n    MATCHER.addURI(\"com.commonsware.android.constants.Provider\",\n                   \"constants/#\", CONSTANT_ID);\n  }", "refactored_code": "  private static final int CONSTANTS=1;\n  static {\n    MATCHER=new UriMatcher(UriMatcher.NO_MATCH);\n    MATCHER.addURI(\"com.commonsware.android.constants.Provider\",\n                   \"constants\", CONSTANTS);\n    MATCHER.addURI(\"com.commonsware.android.constants.Provider\",\n                   \"constants/#\", CONSTANT_ID);\n  }"}
{"magic_number_smell": "    Intent data=new Intent();\n\n    data.putExtras(result);\n    data.putExtra(RESULT_CODE, 1337);\n\n    send(intent, data);\n  }", "refactored_code": "  public static final int SUCCESS=1337;\n    Intent data=new Intent();\n\n    data.putExtras(result);\n    data.putExtra(RESULT_CODE, SUCCESS);\n\n    send(intent, data);\n  }"}
{"magic_number_smell": "  \n  @Override\n  public boolean onCreateOptionsMenu(Menu menu) {\n    menu.add(Menu.NONE, Menu.FIRST+1, Menu.NONE, \"Add\")\n        .setIcon(R.drawable.add)\n        .setAlphabeticShortcut('a');\n", "refactored_code": "  private static final int ADD_ID = Menu.FIRST+1;\n  \n  @Override\n  public boolean onCreateOptionsMenu(Menu menu) {\n    menu.add(Menu.NONE, ADD_ID, Menu.NONE, \"Add\")\n        .setIcon(R.drawable.add)\n        .setAlphabeticShortcut('a');\n"}
{"magic_number_smell": "  static {\n    MATCHER=new UriMatcher(UriMatcher.NO_MATCH);\n    MATCHER.addURI(\"com.commonsware.android.constants.Provider\",\n                   \"constants\", 1);\n    MATCHER.addURI(\"com.commonsware.android.constants.Provider\",\n                   \"constants/#\", CONSTANT_ID);\n  }", "refactored_code": "  private static final int CONSTANTS=1;\n  static {\n    MATCHER=new UriMatcher(UriMatcher.NO_MATCH);\n    MATCHER.addURI(\"com.commonsware.android.constants.Provider\",\n                   \"constants\", CONSTANTS);\n    MATCHER.addURI(\"com.commonsware.android.constants.Provider\",\n                   \"constants/#\", CONSTANT_ID);\n  }"}
{"magic_number_smell": "        final SharedPreferences prefs = context.getSharedPreferences(\n                PREFERENCE,\n                Context.MODE_PRIVATE);\n        return prefs.getLong(BACKOFF, 30000);\n    }\n    \n    static void setBackoff(Context context, long backoff) {", "refactored_code": "    private static final long DEFAULT_BACKOFF = 30000;\n        final SharedPreferences prefs = context.getSharedPreferences(\n                PREFERENCE,\n                Context.MODE_PRIVATE);\n        return prefs.getLong(BACKOFF, DEFAULT_BACKOFF);\n    }\n    \n    static void setBackoff(Context context, long backoff) {"}
{"magic_number_smell": "    \n  @Override\n  public boolean onCreateOptionsMenu(Menu menu) {\n    menu.add(Menu.NONE, Menu.FIRST+1, Menu.NONE, \"Local Search\")\n            .setIcon(android.R.drawable.ic_search_category_default);\n    menu.add(Menu.NONE, GLOBAL_SEARCH_ID, Menu.NONE, \"Global Search\")\n            .setIcon(R.drawable.search)", "refactored_code": "  private static final int LOCAL_SEARCH_ID = Menu.FIRST+1;\n    \n  @Override\n  public boolean onCreateOptionsMenu(Menu menu) {\n    menu.add(Menu.NONE, LOCAL_SEARCH_ID, Menu.NONE, \"Local Search\")\n            .setIcon(android.R.drawable.ic_search_category_default);\n    menu.add(Menu.NONE, GLOBAL_SEARCH_ID, Menu.NONE, \"Global Search\")\n            .setIcon(R.drawable.search)"}
{"magic_number_smell": "    \n    mgr.setRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP,\n                      SystemClock.elapsedRealtime()+60000,\n                      300000,\n                      pi);\n  }\n}", "refactored_code": "  private static final int PERIOD=300000;  // 5 minutes\n    \n    mgr.setRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP,\n                      SystemClock.elapsedRealtime()+60000,\n                      PERIOD,\n                      pi);\n  }\n}"}
{"magic_number_smell": "  @Override\n  protected void onActivityResult(int requestCode, int resultCode,\n                                    Intent data) {\n    if (requestCode==1337) {\n      if (resultCode==RESULT_OK) {\n        ClipData clip=ClipData.newUri(getContentResolver(),\n                                       \"Some music\", data.getData());", "refactored_code": "  private static final int PICK_REQUEST=1337;\n  @Override\n  protected void onActivityResult(int requestCode, int resultCode,\n                                    Intent data) {\n    if (requestCode==PICK_REQUEST) {\n      if (resultCode==RESULT_OK) {\n        ClipData clip=ClipData.newUri(getContentResolver(),\n                                       \"Some music\", data.getData());"}
{"magic_number_smell": "    long now=System.currentTimeMillis();\n    long lastSyncTime=prefs.getLong(KEY_SYNC_TIME, 0);\n\n    return(lastSyncTime == 0 || (now - lastSyncTime) >= 900000L || !iCanHasData(ctxt));\n  }\n\n  public SyncService() {", "refactored_code": "  private static final long SYNC_PERIOD=900000L; // 15 min\n    long now=System.currentTimeMillis();\n    long lastSyncTime=prefs.getLong(KEY_SYNC_TIME, 0);\n\n    return(lastSyncTime == 0 || (now - lastSyncTime) >= SYNC_PERIOD || !iCanHasData(ctxt));\n  }\n\n  public SyncService() {"}
{"magic_number_smell": "        int julLevelValue = record.getLevel().intValue();\n        int slf4jLevel;\n\n        if (julLevelValue <= Level.FINEST.intValue()) {\n            slf4jLevel = LocationAwareLogger.TRACE_INT;\n        } else if (julLevelValue <= DEBUG_LEVEL_THRESHOLD) {\n            slf4jLevel = LocationAwareLogger.DEBUG_INT;", "refactored_code": "    private static final int TRACE_LEVEL_THRESHOLD = Level.FINEST.intValue();\n        int julLevelValue = record.getLevel().intValue();\n        int slf4jLevel;\n\n        if (julLevelValue <= TRACE_LEVEL_THRESHOLD) {\n            slf4jLevel = LocationAwareLogger.TRACE_INT;\n        } else if (julLevelValue <= DEBUG_LEVEL_THRESHOLD) {\n            slf4jLevel = LocationAwareLogger.DEBUG_INT;"}
{"magic_number_smell": "     * \n     * @since 1.2.12\n     */\n    public static final Level TRACE = new Level(5000, \"TRACE\", 7);\n\n    /**\n     * The <code>ALL</code> has the lowest possible rank and is intended to turn on", "refactored_code": "    public static final int TRACE_INT = 5000;\n     * \n     * @since 1.2.12\n     */\n    public static final Level TRACE = new Level(TRACE_INT, \"TRACE\", 7);\n\n    /**\n     * The <code>ALL</code> has the lowest possible rank and is intended to turn on"}
{"magic_number_smell": "        }\n\n        String loggerNamePrefix = this.getClass().getName();\n        for (int i = 0; i < 32; i++) {\n            Logger logger = LoggerFactory.getLogger(loggerNamePrefix + \"-\" + count + \"-\" + i);\n            loggerList.add(logger);\n            Thread.yield();", "refactored_code": "    private static final int LOOP_LEN = 32;\n        }\n\n        String loggerNamePrefix = this.getClass().getName();\n        for (int i = 0; i < LOOP_LEN; i++) {\n            Logger logger = LoggerFactory.getLogger(loggerNamePrefix + \"-\" + count + \"-\" + i);\n            loggerList.add(logger);\n            Thread.yield();"}
{"magic_number_smell": "public class MultithereadedExecutionTest {\n\n    private static final int 2 = 2;\n    private final Thread[] threads = new Thread[2];\n\n    private static final long TEST_DURATION_IN_MILLIS = 100;\n    ", "refactored_code": "    private static final int THREAD_COUNT = 2;\npublic class MultithereadedExecutionTest {\n\n    private static final int THREAD_COUNT = 2;\n    private final Thread[] threads = new Thread[THREAD_COUNT];\n\n    private static final long TEST_DURATION_IN_MILLIS = 100;\n    "}
{"magic_number_smell": "    private static final String STORE_CASE_SENSITIVE = EXTENSION_POINT_ID + \"CASE_SENSITIVE\";\n    private static final String STORE_SEARCH_DERIVED = EXTENSION_POINT_ID + \"SEARCH_DERIVED\";\n    private static final String STORE_HISTORY = EXTENSION_POINT_ID + \"HISTORY\";\n    private static final String STORE_HISTORY_SIZE = EXTENSION_POINT_ID + \"12\";\n\n    private List<SearchPatternData> fPreviousSearchPatterns = new ArrayList<SearchPatternData>(20);\n", "refactored_code": "    private static final int HISTORY_SIZE = 12;\n    private static final String STORE_CASE_SENSITIVE = EXTENSION_POINT_ID + \"CASE_SENSITIVE\";\n    private static final String STORE_SEARCH_DERIVED = EXTENSION_POINT_ID + \"SEARCH_DERIVED\";\n    private static final String STORE_HISTORY = EXTENSION_POINT_ID + \"HISTORY\";\n    private static final String STORE_HISTORY_SIZE = EXTENSION_POINT_ID + \"HISTORY_SIZE\";\n\n    private List<SearchPatternData> fPreviousSearchPatterns = new ArrayList<SearchPatternData>(20);\n"}
{"magic_number_smell": "        composite.setLayout(layout);\n        composite.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));\n\n        fReplaceButton = createActionButton(composite, IDialogConstants.CLIENT_ID + 1, SearchMessages.ReplaceDialog_replace, true);\n        fReplaceAllInFileButton = createActionButton(composite, REPLACE_ALL_IN_FILE,\n                SearchMessages.ReplaceDialog_replaceAllInFile, false);\n", "refactored_code": "    private static final int REPLACE = IDialogConstants.CLIENT_ID + 1;\n        composite.setLayout(layout);\n        composite.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));\n\n        fReplaceButton = createActionButton(composite, REPLACE, SearchMessages.ReplaceDialog_replace, true);\n        fReplaceAllInFileButton = createActionButton(composite, REPLACE_ALL_IN_FILE,\n                SearchMessages.ReplaceDialog_replaceAllInFile, false);\n"}
{"magic_number_smell": "        node.put(NAMES_TO_IGNORE_UNUSED_VARIABLE, DEFAULT_NAMES_TO_IGNORE_UNUSED_VARIABLE);\n        node.put(NAMES_TO_IGNORE_UNUSED_IMPORT, DEFAULT_NAMES_TO_IGNORE_UNUSED_IMPORT);\n        node.put(NAMES_TO_CONSIDER_GLOBALS, DEFAULT_NAMES_TO_CONSIDER_GLOBALS);\n        node.putInt(WHEN_ANALYZE, IAnalysisPreferences.ANALYZE_ON_SUCCESFUL_PARSE);\n        node.putBoolean(DO_CODE_ANALYSIS, DEFAULT_DO_CODE_ANALYSIS);\n        node.putBoolean(DO_AUTO_IMPORT, DEFAULT_DO_AUT_IMPORT);\n        node.putBoolean(DO_AUTO_IMPORT_ON_ORGANIZE_IMPORTS, DEFAULT_DO_AUTO_IMPORT_ON_ORGANIZE_IMPORTS);", "refactored_code": "    public static final int DEFAULT_WHEN_ANALYZE = IAnalysisPreferences.ANALYZE_ON_SUCCESFUL_PARSE;\n        node.put(NAMES_TO_IGNORE_UNUSED_VARIABLE, DEFAULT_NAMES_TO_IGNORE_UNUSED_VARIABLE);\n        node.put(NAMES_TO_IGNORE_UNUSED_IMPORT, DEFAULT_NAMES_TO_IGNORE_UNUSED_IMPORT);\n        node.put(NAMES_TO_CONSIDER_GLOBALS, DEFAULT_NAMES_TO_CONSIDER_GLOBALS);\n        node.putInt(WHEN_ANALYZE, DEFAULT_WHEN_ANALYZE);\n        node.putBoolean(DO_CODE_ANALYSIS, DEFAULT_DO_CODE_ANALYSIS);\n        node.putBoolean(DO_AUTO_IMPORT, DEFAULT_DO_AUT_IMPORT);\n        node.putBoolean(DO_AUTO_IMPORT_ON_ORGANIZE_IMPORTS, DEFAULT_DO_AUTO_IMPORT_ON_ORGANIZE_IMPORTS);"}
{"magic_number_smell": "     */\n    private void checkDeltaSize() {\n        synchronized (lock) {\n            if (deltaSaver.availableDeltas() > 50) {\n                this.save();\n            }\n        }", "refactored_code": "    public static final int MAXIMUN_NUMBER_OF_DELTAS = 50;\n     */\n    private void checkDeltaSize() {\n        synchronized (lock) {\n            if (deltaSaver.availableDeltas() > MAXIMUN_NUMBER_OF_DELTAS) {\n                this.save();\n            }\n        }"}
{"magic_number_smell": "     * @return the initials for the name\n     */\n    protected String getInitials(String name) {\n        if (name.length() < 3) {\n            return name;\n        }\n        return name.substring(0, 3).toLowerCase();", "refactored_code": "    public static final int NUMBER_OF_INITIALS_TO_INDEX = 3;\n     * @return the initials for the name\n     */\n    protected String getInitials(String name) {\n        if (name.length() < NUMBER_OF_INITIALS_TO_INDEX) {\n            return name;\n        }\n        return name.substring(0, NUMBER_OF_INITIALS_TO_INDEX).toLowerCase();"}
{"magic_number_smell": "\n    private static boolean checkTimesOk(IAnalysisBuilderRunnable oldAnalysisBuilderThread, long oldDocTime,\n            long documentTime, long oldResourceStamp, long resourceStamp) {\n        if (oldAnalysisBuilderThread != null && oldDocTime > documentTime - 500) {\n            //If the document version of the new one is lower than the one already active, don't do the analysis\n            if (oldResourceStamp != resourceStamp) {\n                if (oldResourceStamp == IResource.NULL_STAMP || resourceStamp == IResource.NULL_STAMP) {", "refactored_code": "    private static final int DELTA_TO_CONSIDER_SAME = 500;\n\n    private static boolean checkTimesOk(IAnalysisBuilderRunnable oldAnalysisBuilderThread, long oldDocTime,\n            long documentTime, long oldResourceStamp, long resourceStamp) {\n        if (oldAnalysisBuilderThread != null && oldDocTime > documentTime - DELTA_TO_CONSIDER_SAME) {\n            //If the document version of the new one is lower than the one already active, don't do the analysis\n            if (oldResourceStamp != resourceStamp) {\n                if (oldResourceStamp == IResource.NULL_STAMP || resourceStamp == IResource.NULL_STAMP) {"}
{"magic_number_smell": "    public static final int DEFINITIONS_MODULE = 2;\n\n    /**\n     * 1\n     * ANALYSIS_CAUSE_PARSER\n     */\n    int getAnalysisCause();", "refactored_code": "    public static final int ANALYSIS_CAUSE_BUILDER = 1;\n    public static final int DEFINITIONS_MODULE = 2;\n\n    /**\n     * ANALYSIS_CAUSE_BUILDER\n     * ANALYSIS_CAUSE_PARSER\n     */\n    int getAnalysisCause();"}
{"magic_number_smell": "            }\n\n        }\n        return 0;\n    }\n\n    @SuppressWarnings(\"unchecked\")", "refactored_code": "    private static final int NO_STATIC_NOR_CLASSMETHOD = 0;\n            }\n\n        }\n        return NO_STATIC_NOR_CLASSMETHOD;\n    }\n\n    @SuppressWarnings(\"unchecked\")"}
{"magic_number_smell": "    /**\n     * Constant defining the scopes that should be considered when we're in a method\n     */\n    public static final int ACCEPTED_METHOD_SCOPES = 1 | SCOPE_TYPE_METHOD | SCOPE_TYPE_LAMBDA\n            | SCOPE_TYPE_LIST_COMP;\n\n    /**", "refactored_code": "    public static final int SCOPE_TYPE_GLOBAL = 1;\n    /**\n     * Constant defining the scopes that should be considered when we're in a method\n     */\n    public static final int ACCEPTED_METHOD_SCOPES = SCOPE_TYPE_GLOBAL | SCOPE_TYPE_METHOD | SCOPE_TYPE_LAMBDA\n            | SCOPE_TYPE_LIST_COMP;\n\n    /**"}
{"magic_number_smell": "        node.putBoolean(ADD_SPACE_AND_COLON_WHEN_NEEDED, DEFAULT_ADD_SPACES_AND_COLON_WHEN_NEEDED);\n        node.putBoolean(FORCE_PY3K_PRINT_ON_PY2, DEFAULT_FORCE_PY3K_PRINT_ON_PY2);\n        node.put(KEYWORDS_CODE_COMPLETION, DEFAULT_KEYWORDS_CODE_COMPLETION);\n        node.putInt(CHARS_FOR_CTX_INSENSITIVE_MODULES_COMPLETION, 2);\n        node.putInt(CHARS_FOR_CTX_INSENSITIVE_TOKENS_COMPLETION, DEFAULT_CHARS_FOR_CTX_INSENSITIVE_TOKENS_COMPLETION);\n    }\n", "refactored_code": "    public static final int DEFAULT_CHARS_FOR_CTX_INSENSITIVE_MODULES_COMPLETION = 2;\n        node.putBoolean(ADD_SPACE_AND_COLON_WHEN_NEEDED, DEFAULT_ADD_SPACES_AND_COLON_WHEN_NEEDED);\n        node.putBoolean(FORCE_PY3K_PRINT_ON_PY2, DEFAULT_FORCE_PY3K_PRINT_ON_PY2);\n        node.put(KEYWORDS_CODE_COMPLETION, DEFAULT_KEYWORDS_CODE_COMPLETION);\n        node.putInt(CHARS_FOR_CTX_INSENSITIVE_MODULES_COMPLETION, DEFAULT_CHARS_FOR_CTX_INSENSITIVE_MODULES_COMPLETION);\n        node.putInt(CHARS_FOR_CTX_INSENSITIVE_TOKENS_COMPLETION, DEFAULT_CHARS_FOR_CTX_INSENSITIVE_TOKENS_COMPLETION);\n    }\n"}
{"magic_number_smell": "    @Override\n    public void initializeDefaultPreferences() {\n        Preferences node = new DefaultScope().getNode(PydevPlugin.DEFAULT_PYDEV_SCOPE);\n        node.putInt(PYDEV_REMOTE_DEBUGGER_PORT, 5678);\n    }\n\n    public static int getRemoteDebuggerPort() {", "refactored_code": "    public static final int DEFAULT_REMOTE_DEBUGGER_PORT = 5678;\n    @Override\n    public void initializeDefaultPreferences() {\n        Preferences node = new DefaultScope().getNode(PydevPlugin.DEFAULT_PYDEV_SCOPE);\n        node.putInt(PYDEV_REMOTE_DEBUGGER_PORT, DEFAULT_REMOTE_DEBUGGER_PORT);\n    }\n\n    public static int getRemoteDebuggerPort() {"}
{"magic_number_smell": "                    fKind = DOCUMENT;\n                    fModificationStamp = ((IDocumentExtension4) document).getModificationStamp();\n                } else {\n                    fKind = 1;\n                    fModificationStamp = file.getModificationStamp();\n                }\n            }", "refactored_code": "        public static final int RESOURCE = 1;\n                    fKind = DOCUMENT;\n                    fModificationStamp = ((IDocumentExtension4) document).getModificationStamp();\n                } else {\n                    fKind = RESOURCE;\n                    fModificationStamp = file.getModificationStamp();\n                }\n            }"}
{"magic_number_smell": "            new String(SearchMessages.FileLabelProvider_removed_resource_label);\n\n        String name = BasicElementLabels.getResourceName(resource);\n        if (fOrder == 1) {\n            return getColoredLabelWithCounts(resource, new String(name));\n        }\n", "refactored_code": "    public static final int SHOW_LABEL = 1;\n            new String(SearchMessages.FileLabelProvider_removed_resource_label);\n\n        String name = BasicElementLabels.getResourceName(resource);\n        if (fOrder == SHOW_LABEL) {\n            return getColoredLabelWithCounts(resource, new String(name));\n        }\n"}
{"magic_number_smell": "        fSortByPathAction = new SortAction(SearchMessages.FileSearchPage_sort_path_label, this,\n                FileLabelProvider.SHOW_PATH_LABEL);\n\n        setElementLimit(new Integer(1000));\n    }\n\n    public void setElementLimit(Integer elementLimit) {", "refactored_code": "    private static final int DEFAULT_ELEMENT_LIMIT = 1000;\n        fSortByPathAction = new SortAction(SearchMessages.FileSearchPage_sort_path_label, this,\n                FileLabelProvider.SHOW_PATH_LABEL);\n\n        setElementLimit(new Integer(DEFAULT_ELEMENT_LIMIT));\n    }\n\n    public void setElementLimit(Integer elementLimit) {"}
{"magic_number_smell": "            StringBuffer buf = new StringBuffer(length);\n\n            /* every string we did not check looks mixed at first\n             * so initialize retain case mode with 0\n             */\n            fRetainCaseMode = 0;\n", "refactored_code": "        private static final int RC_MIXED = 0;\n            StringBuffer buf = new StringBuffer(length);\n\n            /* every string we did not check looks mixed at first\n             * so initialize retain case mode with RC_MIXED\n             */\n            fRetainCaseMode = RC_MIXED;\n"}
{"magic_number_smell": "\n        try {\n            RefactoringInfo refactoringInfo = new RefactoringInfo(targetEditor);\n            execute(refactoringInfo, 0);\n        } catch (Throwable e) {\n            Log.log(e);\n            Throwable initial = e;", "refactored_code": "    public static final int LOCATION_STRATEGY_BEFORE_CURRENT = 0; //before the current method (in the same level)\n\n        try {\n            RefactoringInfo refactoringInfo = new RefactoringInfo(targetEditor);\n            execute(refactoringInfo, LOCATION_STRATEGY_BEFORE_CURRENT);\n        } catch (Throwable e) {\n            Log.log(e);\n            Throwable initial = e;"}
{"magic_number_smell": "\n            if (targetClass != null) {\n                switch (createAs) {\n                    case 0:\n                        parametersAfterCall = checkFirst(parametersAfterCall, \"self\");\n                        break;\n", "refactored_code": "    public static final int BOUND_METHOD = 0;\n\n            if (targetClass != null) {\n                switch (createAs) {\n                    case BOUND_METHOD:\n                        parametersAfterCall = checkFirst(parametersAfterCall, \"self\");\n                        break;\n"}
{"magic_number_smell": "    public PyRenameImportProcess(Definition definition) {\n        super(definition);\n        if (definition.ast == null) {\n            this.type = 1;\n        } else {\n            this.type = TYPE_RENAME_UNRESOLVED_IMPORT;\n        }", "refactored_code": "    public static final int TYPE_RENAME_MODULE = 1;\n    public PyRenameImportProcess(Definition definition) {\n        super(definition);\n        if (definition.ast == null) {\n            this.type = TYPE_RENAME_MODULE;\n        } else {\n            this.type = TYPE_RENAME_UNRESOLVED_IMPORT;\n        }"}
{"magic_number_smell": "     * number is higher than the number of resources changed, this visitor is not called).\n     */\n    public int maxResourcesToVisit() {\n        return -1;\n    }\n\n    /**", "refactored_code": "    public static final int MAX_TO_VISIT_INFINITE = -1;\n     * number is higher than the number of resources changed, this visitor is not called).\n     */\n    public int maxResourcesToVisit() {\n        return MAX_TO_VISIT_INFINITE;\n    }\n\n    /**"}
{"magic_number_smell": "                        PyDevBuilder.communicateProgress(monitor, totalResources, currentResourcesVisited, resource,\n                                visitor, bufferToCommunicateProgress);\n                        switch (visitType) {\n                            case 1:\n                                visitor.visitAddedResource(resource, document, monitor);\n                                break;\n", "refactored_code": "    private final int VISIT_ADD = 1;\n                        PyDevBuilder.communicateProgress(monitor, totalResources, currentResourcesVisited, resource,\n                                visitor, bufferToCommunicateProgress);\n                        switch (visitType) {\n                            case VISIT_ADD:\n                                visitor.visitAddedResource(resource, document, monitor);\n                                break;\n"}
{"magic_number_smell": "    public static final String[][] LABEL_AND_VALUE = new String[][] {\n            { \"Error\", String.valueOf(IMarker.SEVERITY_ERROR) },\n            { \"Warning\", String.valueOf(IMarker.SEVERITY_WARNING) }, { \"Info\", String.valueOf(IMarker.SEVERITY_INFO) },\n            { \"Ignore\", String.valueOf(-1) }, };\n\n    // errors\n    public static final String SEVERITY_ERRORS = \"SEVERITY_ERRORS\";", "refactored_code": "    public static final int SEVERITY_IGNORE = -1;\n    public static final String[][] LABEL_AND_VALUE = new String[][] {\n            { \"Error\", String.valueOf(IMarker.SEVERITY_ERROR) },\n            { \"Warning\", String.valueOf(IMarker.SEVERITY_WARNING) }, { \"Info\", String.valueOf(IMarker.SEVERITY_INFO) },\n            { \"Ignore\", String.valueOf(SEVERITY_IGNORE) }, };\n\n    // errors\n    public static final String SEVERITY_ERRORS = \"SEVERITY_ERRORS\";"}
{"magic_number_smell": "        layout.numColumns = 1;\n\n        String msg = \"Help keeping PyDev alive\";\n        createLabel(composite, WrapAndCaseUtils.wrap(msg, 120), 1);\n\n        try {\n            final String html = \"<html><head>\"", "refactored_code": "    private static final int BOLD_COLS = 120;\n        layout.numColumns = 1;\n\n        String msg = \"Help keeping PyDev alive\";\n        createLabel(composite, WrapAndCaseUtils.wrap(msg, BOLD_COLS), 1);\n\n        try {\n            final String html = \"<html><head>\""}
{"magic_number_smell": "    /** The default token to be returned on success and if nothing else has been specified. */\n    protected IToken fDefaultToken;\n    /** The column constraint */\n    protected int fColumn = -1;\n    /** The table of predefined words and token for this rule */\n    protected Map<String, IToken> fWords = new HashMap<String, IToken>();\n    /** Buffer used for pattern detection */", "refactored_code": "    protected static final int UNDEFINED = -1;\n    /** The default token to be returned on success and if nothing else has been specified. */\n    protected IToken fDefaultToken;\n    /** The column constraint */\n    protected int fColumn = UNDEFINED;\n    /** The table of predefined words and token for this rule */\n    protected Map<String, IToken> fWords = new HashMap<String, IToken>();\n    /** Buffer used for pattern detection */"}
{"magic_number_smell": "         * 2 = 2 spaces\n         * ... \n         */\n        public int spacesBeforeComment = -1;\n\n        /**\n         * Spaces after the '#' in a comment. -1 = don't handle.", "refactored_code": "        public static final int DONT_HANDLE_SPACES = -1;\n         * 2 = 2 spaces\n         * ... \n         */\n        public int spacesBeforeComment = DONT_HANDLE_SPACES;\n\n        /**\n         * Spaces after the '#' in a comment. -1 = don't handle."}
{"magic_number_smell": "                return QUALIFIER_PRIVATE;\n\n            } else {\n                return 0;\n            }\n        } else if (name.startsWith(\"_\")) {\n            return QUALIFIER_PROTECTED;", "refactored_code": "    private static final int QUALIFIER_PUBLIC = 0;\n                return QUALIFIER_PRIVATE;\n\n            } else {\n                return QUALIFIER_PUBLIC;\n            }\n        } else if (name.startsWith(\"_\")) {\n            return QUALIFIER_PROTECTED;"}
{"magic_number_smell": "     * Function which can take care of getting the paths just for the project (i.e.: without external\n     * source folders).\n     * \n     * @param replace used only if returnType == 1.\n     * \n     * @param substitution the object which will do the string substitutions (only internally used as an optimization as\n     * creating the instance may be expensive, so, if some other place already creates it, it can be passed along).", "refactored_code": "    private static final int RETURN_STRING_WITH_SEPARATOR = 1;\n     * Function which can take care of getting the paths just for the project (i.e.: without external\n     * source folders).\n     * \n     * @param replace used only if returnType == RETURN_STRING_WITH_SEPARATOR.\n     * \n     * @param substitution the object which will do the string substitutions (only internally used as an optimization as\n     * creating the instance may be expensive, so, if some other place already creates it, it can be passed along)."}
{"magic_number_smell": "    public static final String[][] LABEL_AND_VALUE = new String[][] {\n            { \"underscore_separated\", String.valueOf(METHODS_FORMAT_UNDERSCORE_SEPARATED) },\n            { \"CamelCase() with first upper\", String.valueOf(METHODS_FORMAT_CAMELCASE_FIRST_UPPER) },\n            { \"camelCase() with first lower\", String.valueOf(0) }, };\n\n    public static final String[][] LOCALS_LABEL_AND_VALUE = new String[][] {\n            { \"underscore_separated\", String.valueOf(false) }, { \"camelCase with first lower\", String.valueOf(true) }, };", "refactored_code": "    public static final int METHODS_FORMAT_CAMELCASE_FIRST_LOWER = 0;\n    public static final String[][] LABEL_AND_VALUE = new String[][] {\n            { \"underscore_separated\", String.valueOf(METHODS_FORMAT_UNDERSCORE_SEPARATED) },\n            { \"CamelCase() with first upper\", String.valueOf(METHODS_FORMAT_CAMELCASE_FIRST_UPPER) },\n            { \"camelCase() with first lower\", String.valueOf(METHODS_FORMAT_CAMELCASE_FIRST_LOWER) }, };\n\n    public static final String[][] LOCALS_LABEL_AND_VALUE = new String[][] {\n            { \"underscore_separated\", String.valueOf(false) }, { \"camelCase with first lower\", String.valueOf(true) }, };"}
{"magic_number_smell": "    public static final int TEST_RUNNER_PY_TEST = 2;\n\n    public static final String[][] ENTRY_NAMES_AND_VALUES = new String[][] {\n            { \"PyDev test runner\", Integer.toString(0) },\n            { \"Nose test runner\", Integer.toString(TEST_RUNNER_NOSE) },\n            { \"Py.test runner\", Integer.toString(TEST_RUNNER_PY_TEST) }, };\n", "refactored_code": "    public static final int TEST_RUNNER_PYDEV = 0;\n    public static final int TEST_RUNNER_PY_TEST = 2;\n\n    public static final String[][] ENTRY_NAMES_AND_VALUES = new String[][] {\n            { \"PyDev test runner\", Integer.toString(TEST_RUNNER_PYDEV) },\n            { \"Nose test runner\", Integer.toString(TEST_RUNNER_NOSE) },\n            { \"Py.test runner\", Integer.toString(TEST_RUNNER_PY_TEST) }, };\n"}
{"magic_number_smell": "    protected void updateOrientation() {\n        switch (orientationPreference) {\n            case PREFERENCES_VIEW_ORIENTATION_HORIZONTAL:\n                setNewOrientation(1);\n                break;\n\n            case PREFERENCES_VIEW_ORIENTATION_VERTICAL:", "refactored_code": "    public static final int VIEW_ORIENTATION_HORIZONTAL = 1;\n    protected void updateOrientation() {\n        switch (orientationPreference) {\n            case PREFERENCES_VIEW_ORIENTATION_HORIZONTAL:\n                setNewOrientation(VIEW_ORIENTATION_HORIZONTAL);\n                break;\n\n            case PREFERENCES_VIEW_ORIENTATION_VERTICAL:"}
{"magic_number_smell": "        DrillDownComposite drillDown = new DrillDownComposite(this, SWT.BORDER);\n        GridData spec = new GridData(GridData.VERTICAL_ALIGN_FILL | GridData.HORIZONTAL_ALIGN_FILL\n                | GridData.GRAB_HORIZONTAL | GridData.GRAB_VERTICAL);\n        spec.widthHint = 320;\n        spec.heightHint = heightHint;\n        drillDown.setLayoutData(spec);\n", "refactored_code": "    private static final int SIZING_SELECTION_PANE_WIDTH = 320;\n        DrillDownComposite drillDown = new DrillDownComposite(this, SWT.BORDER);\n        GridData spec = new GridData(GridData.VERTICAL_ALIGN_FILL | GridData.HORIZONTAL_ALIGN_FILL\n                | GridData.GRAB_HORIZONTAL | GridData.GRAB_VERTICAL);\n        spec.widthHint = SIZING_SELECTION_PANE_WIDTH;\n        spec.heightHint = heightHint;\n        drillDown.setLayoutData(spec);\n"}
{"magic_number_smell": "        // new project name entry field\n        projectNameField = new Text(projectGroup, SWT.BORDER);\n        GridData data = new GridData(GridData.FILL_HORIZONTAL);\n        data.widthHint = 250;\n        projectNameField.setLayoutData(data);\n        projectNameField.setFont(font);\n", "refactored_code": "    private static final int SIZING_TEXT_FIELD_WIDTH = 250;\n        // new project name entry field\n        projectNameField = new Text(projectGroup, SWT.BORDER);\n        GridData data = new GridData(GridData.FILL_HORIZONTAL);\n        data.widthHint = SIZING_TEXT_FIELD_WIDTH;\n        projectNameField.setLayoutData(data);\n        projectNameField.setFont(font);\n"}
{"magic_number_smell": "    private boolean emptyStringAllowed = true;\n\n    /**\n     * The validation strategy; <code>0</code> by default.\n     */\n    private int validateStrategy = 0;\n", "refactored_code": "    public static final int VALIDATE_ON_KEY_STROKE = 0;\n    private boolean emptyStringAllowed = true;\n\n    /**\n     * The validation strategy; <code>VALIDATE_ON_KEY_STROKE</code> by default.\n     */\n    private int validateStrategy = VALIDATE_ON_KEY_STROKE;\n"}
{"magic_number_smell": "    private final Object lock = new Object();\n\n    ModulesManagerCache() {\n        internalCache = new LRUCache<Tuple<ModulesKey, ModulesManager>, AbstractModule>(400);\n    }\n\n    /**", "refactored_code": "    private static final int MAX_NUMBER_OF_MODULES = 400;\n    private final Object lock = new Object();\n\n    ModulesManagerCache() {\n        internalCache = new LRUCache<Tuple<ModulesKey, ModulesManager>, AbstractModule>(MAX_NUMBER_OF_MODULES);\n    }\n\n    /**"}
{"magic_number_smell": "\n    @Override\n    protected int getPriority() {\n        return PRIORITY_DEFAULT;\n    }\n\n    /**", "refactored_code": "    public static final int PRIORITY_CODE_COMPLETION = PRIORITY_DEFAULT;\n\n    @Override\n    protected int getPriority() {\n        return PRIORITY_CODE_COMPLETION;\n    }\n\n    /**"}
{"magic_number_smell": "        setColor(x, BLACK);\n    }\n\n    private static final long -6520786458950516097L = 919286545866124006L;\n\n    /**\n     * Save the state of the <tt>ModulesKeyTreeMap</tt> instance to a stream (i.e.,", "refactored_code": "        private static final long serialVersionUID = -6520786458950516097L;\n        setColor(x, BLACK);\n    }\n\n    private static final long serialVersionUID = 919286545866124006L;\n\n    /**\n     * Save the state of the <tt>ModulesKeyTreeMap</tt> instance to a stream (i.e.,"}
{"magic_number_smell": "                    String next = it.next();\n                    IPath existingInPath = Path.fromPortableString(next);\n                    if (resource.getFullPath().isPrefixOf(existingInPath)) {\n                        if (operation == PythonPathHelper.1\n                                || operation == PythonPathHelper.OPERATION_DELETE) {\n                            it.remove(); //Remove from that project (but not on copy)\n                            changed.add(resource.getProject());", "refactored_code": "    public static final int OPERATION_MOVE = 1;\n                    String next = it.next();\n                    IPath existingInPath = Path.fromPortableString(next);\n                    if (resource.getFullPath().isPrefixOf(existingInPath)) {\n                        if (operation == PythonPathHelper.OPERATION_MOVE\n                                || operation == PythonPathHelper.OPERATION_DELETE) {\n                            it.remove(); //Remove from that project (but not on copy)\n                            changed.add(resource.getProject());"}
{"magic_number_smell": "\n    private IJavaProject javaProject;\n\n    private int moduleType = -1;\n\n    /**\n     * @param name that's the name of the module for jython", "refactored_code": "    private static final int UNKNOWN = -1;\n\n    private IJavaProject javaProject;\n\n    private int moduleType = UNKNOWN;\n\n    /**\n     * @param name that's the name of the module for jython"}
{"magic_number_smell": "        long maxTime = System.currentTimeMillis() + (1000 * 50); //50 secs timeout\n\n        while (System.currentTimeMillis() < maxTime) { //clear until we get no message and timeout is not elapsed\n            byte[] b = new byte[AbstractShell.1024];\n            if (this.socketToRead != null) {\n                this.socketToRead.getInputStream().read(b);\n", "refactored_code": "    public static final int BUFFER_SIZE = 1024;\n        long maxTime = System.currentTimeMillis() + (1000 * 50); //50 secs timeout\n\n        while (System.currentTimeMillis() < maxTime) { //clear until we get no message and timeout is not elapsed\n            byte[] b = new byte[AbstractShell.BUFFER_SIZE];\n            if (this.socketToRead != null) {\n                this.socketToRead.getInputStream().read(b);\n"}
{"magic_number_smell": "    //-------- cycling through simple completions and default processor\n    private static final int 1 = 1;\n    private static final int SHOW_DEFAULT = 2;\n    private int whatToShow = 1;\n\n    public void startCycle() {\n        whatToShow = 1;", "refactored_code": "    private static final int SHOW_SIMPLE = 1;\n    //-------- cycling through simple completions and default processor\n    private static final int SHOW_SIMPLE = 1;\n    private static final int SHOW_DEFAULT = 2;\n    private int whatToShow = SHOW_SIMPLE;\n\n    public void startCycle() {\n        whatToShow = SHOW_SIMPLE;"}
{"magic_number_smell": "        if (extensionStateModel != null) {\n            if (extensionStateModel.getBooleanProperty(SHOW_TOP_LEVEL_WORKING_SETS)) {\n                //show working set\n                this.rootMode = 0;\n                if (DEBUG) {\n                    System.out.println(\"Show working set as top level\");\n                }", "refactored_code": "    public static final int WORKING_SETS = 0;\n        if (extensionStateModel != null) {\n            if (extensionStateModel.getBooleanProperty(SHOW_TOP_LEVEL_WORKING_SETS)) {\n                //show working set\n                this.rootMode = WORKING_SETS;\n                if (DEBUG) {\n                    System.out.println(\"Show working set as top level\");\n                }"}
{"magic_number_smell": "\n    public static List<Integer> createList() {\n        List<Integer> grammarVersions = new ArrayList<Integer>();\n        grammarVersions.add(IGrammarVersionProvider.10);\n        grammarVersions.add(IGrammarVersionProvider.GRAMMAR_PYTHON_VERSION_2_5);\n        grammarVersions.add(IGrammarVersionProvider.GRAMMAR_PYTHON_VERSION_2_6);\n        grammarVersions.add(IGrammarVersionProvider.GRAMMAR_PYTHON_VERSION_2_7);", "refactored_code": "    public static final int GRAMMAR_PYTHON_VERSION_2_4 = 10;\n\n    public static List<Integer> createList() {\n        List<Integer> grammarVersions = new ArrayList<Integer>();\n        grammarVersions.add(IGrammarVersionProvider.GRAMMAR_PYTHON_VERSION_2_4);\n        grammarVersions.add(IGrammarVersionProvider.GRAMMAR_PYTHON_VERSION_2_5);\n        grammarVersions.add(IGrammarVersionProvider.GRAMMAR_PYTHON_VERSION_2_6);\n        grammarVersions.add(IGrammarVersionProvider.GRAMMAR_PYTHON_VERSION_2_7);"}
{"magic_number_smell": "     * @return whether the passed token is part of the global tokens of this module (including imported tokens) and the \n     * actual reason why it was considered there (as indicated by the constants).\n     * \n     * @see #0               \n     * @see #FOUND_TOKEN             \n     * @see #FOUND_BECAUSE_OF_GETATTR\n     * ", "refactored_code": "    public static final int NOT_FOUND = 0;\n     * @return whether the passed token is part of the global tokens of this module (including imported tokens) and the \n     * actual reason why it was considered there (as indicated by the constants).\n     * \n     * @see #NOT_FOUND               \n     * @see #FOUND_TOKEN             \n     * @see #FOUND_BECAUSE_OF_GETATTR\n     * "}
{"magic_number_smell": "    /**\n     * @return the id that is related to this nature given its type\n     * \n     * @see #0\n     * @see #INTERPRETER_TYPE_JYTHON\n     * @see #INTERPRETER_TYPE_IRONPYTHON\n     */", "refactored_code": "    public static final int INTERPRETER_TYPE_PYTHON = 0;\n    /**\n     * @return the id that is related to this nature given its type\n     * \n     * @see #INTERPRETER_TYPE_PYTHON\n     * @see #INTERPRETER_TYPE_JYTHON\n     * @see #INTERPRETER_TYPE_IRONPYTHON\n     */"}
{"magic_number_smell": "            if (secondPart.length() == 0 && !hasCall) {\n                continue; //local var or number\n            }\n            ret.add(new TddPossibleMatches(matcher.group(0), matcher.group(TDD_PART_PART1), secondPart));\n        }\n        return ret;\n    }", "refactored_code": "    private static final int TDD_PART_FULL = 0;\n            if (secondPart.length() == 0 && !hasCall) {\n                continue; //local var or number\n            }\n            ret.add(new TddPossibleMatches(matcher.group(TDD_PART_FULL), matcher.group(TDD_PART_PART1), secondPart));\n        }\n        return ret;\n    }"}
{"magic_number_smell": "        try {\n            return fForward ? readForwards() : readBackwards();\n        } catch (BadLocationException x) {\n            return -1; //Document may have changed...\n        }\n    }\n", "refactored_code": "    public static final int EOF = -1;\n        try {\n            return fForward ? readForwards() : readBackwards();\n        } catch (BadLocationException x) {\n            return EOF; //Document may have changed...\n        }\n    }\n"}
{"magic_number_smell": "            HashSet<String> resolvedVariables = new HashSet<String>();\n\n            int pos = 0;\n            int state = 0;\n            while (pos < expression.length()) {\n                switch (state) {\n                    case 0:", "refactored_code": "        private static final int SCAN_FOR_START = 0;\n            HashSet<String> resolvedVariables = new HashSet<String>();\n\n            int pos = 0;\n            int state = SCAN_FOR_START;\n            while (pos < expression.length()) {\n                switch (state) {\n                    case SCAN_FOR_START:"}
{"magic_number_smell": "                lastState = STATE_NUMBER;\n            } else {\n                buf.append(c);\n                lastState = 0;\n            }\n        }\n        return buf.toString();", "refactored_code": "    private static final int STATE_LOWER = 0;\n                lastState = STATE_NUMBER;\n            } else {\n                buf.append(c);\n                lastState = STATE_LOWER;\n            }\n        }\n        return buf.toString();"}
{"magic_number_smell": "    }\n\n    void start() {\n        start(10000);\n    }\n\n    private synchronized void poll() {", "refactored_code": "    private static final long DEFAULT_POLL_FREQUENCY = 10000;\n    }\n\n    void start() {\n        start(DEFAULT_POLL_FREQUENCY);\n    }\n\n    private synchronized void poll() {"}
{"magic_number_smell": "        // app engine location entry field\n        locationPathField = new Text(appEngineGroup, SWT.BORDER);\n        GridData data = new GridData(GridData.FILL_HORIZONTAL);\n        data.widthHint = 250;\n        locationPathField.setLayoutData(data);\n        locationPathField.setFont(font);\n", "refactored_code": "    private static final int SIZING_TEXT_FIELD_WIDTH = 250;\n        // app engine location entry field\n        locationPathField = new Text(appEngineGroup, SWT.BORDER);\n        GridData data = new GridData(GridData.FILL_HORIZONTAL);\n        data.widthHint = SIZING_TEXT_FIELD_WIDTH;\n        locationPathField.setLayoutData(data);\n        locationPathField.setFont(font);\n"}
{"magic_number_smell": "\n    private static final int 0 = 0;\n    private static final int STATE_RUNNING = 1;\n    private volatile int state = 0;\n\n    //only while running\n    private ThreadStreamReader err;", "refactored_code": "    private static final int STATE_NOT_RUNNING = 0;\n\n    private static final int STATE_NOT_RUNNING = 0;\n    private static final int STATE_RUNNING = 1;\n    private volatile int state = STATE_NOT_RUNNING;\n\n    //only while running\n    private ThreadStreamReader err;"}
{"magic_number_smell": "\n    public Point computeSize(int wHint, int hHint, boolean changed) {\n        checkWidget();\n        Point size = new Point(50, DEFAULT_HEIGHT);\n        if (wHint != SWT.DEFAULT)\n            size.x = wHint;\n        if (hHint != SWT.DEFAULT)", "refactored_code": "    private static final int DEFAULT_WIDTH = 50;\n\n    public Point computeSize(int wHint, int hHint, boolean changed) {\n        checkWidget();\n        Point size = new Point(DEFAULT_WIDTH, DEFAULT_HEIGHT);\n        if (wHint != SWT.DEFAULT)\n            size.x = wHint;\n        if (hHint != SWT.DEFAULT)"}
{"magic_number_smell": "                    ansiState.prevAttribute = colorManager.getAnsiTextAttribute(str, ansiState.prevAttribute, attr);\n\n                    ansiState.escBuf.clear();\n                    ansiState.state = AnsiState.0;\n                }\n            } else {\n                if (c == '\\u001B') {", "refactored_code": "        private static final int STATE_DEFAULT = 0;\n                    ansiState.prevAttribute = colorManager.getAnsiTextAttribute(str, ansiState.prevAttribute, attr);\n\n                    ansiState.escBuf.clear();\n                    ansiState.state = AnsiState.STATE_DEFAULT;\n                }\n            } else {\n                if (c == '\\u001B') {"}
{"magic_number_smell": "    private Text newText(Composite parent) {\n        Text t = new Text(parent, SWT.BORDER);\n        GridData gd = new GridData(GridData.FILL_HORIZONTAL);\n        gd.widthHint = 250;\n        t.setLayoutData(gd);\n        return t;\n    }", "refactored_code": "    private static final int SIZING_TEXT_FIELD_WIDTH = 250;\n    private Text newText(Composite parent) {\n        Text t = new Text(parent, SWT.BORDER);\n        GridData gd = new GridData(GridData.FILL_HORIZONTAL);\n        gd.widthHint = SIZING_TEXT_FIELD_WIDTH;\n        t.setLayoutData(gd);\n        return t;\n    }"}
{"magic_number_smell": "\n    public static Hashtable fillTypes() {\n        Hashtable types = new Hashtable();\n        types.put(Boolean.TYPE, new Integer(0));\n        types.put(Byte.TYPE, new Integer(tByte));\n        types.put(Short.TYPE, new Integer(tShort));\n        types.put(Integer.TYPE, new Integer(tInteger));", "refactored_code": "    public static final int tBoolean = 0;\n\n    public static Hashtable fillTypes() {\n        Hashtable types = new Hashtable();\n        types.put(Boolean.TYPE, new Integer(tBoolean));\n        types.put(Byte.TYPE, new Integer(tByte));\n        types.put(Short.TYPE, new Integer(tShort));\n        types.put(Integer.TYPE, new Integer(tInteger));"}
{"magic_number_smell": "        int n = data.length;\n\n        int api = (data[n - 4] << 24) + (data[n - 3] << 16) + (data[n - 2] << 8) + data[n - 1];\n        if (api != 12) {\n            if (testing) {\n                return null;\n            } else {", "refactored_code": "    public static final int APIVersion = 12;\n        int n = data.length;\n\n        int api = (data[n - 4] << 24) + (data[n - 3] << 16) + (data[n - 2] << 8) + data[n - 1];\n        if (api != APIVersion) {\n            if (testing) {\n                return null;\n            } else {"}
{"magic_number_smell": "    }\n\n    public static void writeError(String type, String msg) {\n        maybeWrite(type, msg, -1);\n    }\n\n    public static void writeWarning(String type, String msg) {", "refactored_code": "    public static final int ERROR = -1;\n    }\n\n    public static void writeError(String type, String msg) {\n        maybeWrite(type, msg, ERROR);\n    }\n\n    public static void writeWarning(String type, String msg) {"}
{"magic_number_smell": "                return dict.__finditem__(key);\n            case ITEMS:\n                return new PyTuple(new PyObject[] { key, dict.__finditem__(key) });\n            default: // 0\n                return key;\n        }\n    }", "refactored_code": "    public static final int KEYS = 0;\n                return dict.__finditem__(key);\n            case ITEMS:\n                return new PyTuple(new PyObject[] { key, dict.__finditem__(key) });\n            default: // KEYS\n                return key;\n        }\n    }"}
{"magic_number_smell": "            int i = 0;\n            while (i < n) {\n                int sz = n - i;\n                sz = sz > 30000 ? 30000 : sz;\n                ostream.write(bytes, i, sz);\n                i += sz;\n            }", "refactored_code": "        private static final int MAX_WRITE = 30000;\n            int i = 0;\n            while (i < n) {\n                int sz = n - i;\n                sz = sz > MAX_WRITE ? MAX_WRITE : sz;\n                ostream.write(bytes, i, sz);\n                i += sz;\n            }"}
{"magic_number_smell": "    public static final int ITEMS = 2;\n\n    public PyStringMapIter(String[] keys, PyObject[] values) {\n        this(keys, values, 0);\n    }\n\n    public PyStringMapIter(String[] keys, PyObject[] values, int type) {", "refactored_code": "    public static final int KEYS = 0;\n    public static final int ITEMS = 2;\n\n    public PyStringMapIter(String[] keys, PyObject[] values) {\n        this(keys, values, KEYS);\n    }\n\n    public PyStringMapIter(String[] keys, PyObject[] values, int type) {"}
{"magic_number_smell": "        } else if (args.length == 2 && args[0] == PyObject[].class && args[1] == String[].class) {\n            this.flags = PyArgsKeywordsCall;\n        } else {\n            this.flags = 0;\n        }\n    }\n", "refactored_code": "    public static final int StandardCall = 0;\n        } else if (args.length == 2 && args[0] == PyObject[].class && args[1] == String[].class) {\n            this.flags = PyArgsKeywordsCall;\n        } else {\n            this.flags = StandardCall;\n        }\n    }\n"}
{"magic_number_smell": "            // increase the counter each time a thread reference is added\n            // to the table\n            additionCounter++;\n            if (additionCounter > 25) {\n                cleanupThreadTable();\n                additionCounter = 0;\n            }", "refactored_code": "    private static final int MAX_ADDITIONS = 25;\n            // increase the counter each time a thread reference is added\n            // to the table\n            additionCounter++;\n            if (additionCounter > MAX_ADDITIONS) {\n                cleanupThreadTable();\n                additionCounter = 0;\n            }"}
{"magic_number_smell": "    private static final PyObject strerror = new PyDictionary();\n\n    public static void classDictInit(PyObject dict) throws PyIgnoreMethodTag {\n        addcode(dict, 1, \"1\", \"Operation not permitted\");\n        addcode(dict, ENOENT, \"ENOENT\", \"No such file or directory\");\n        addcode(dict, ESRCH, \"ESRCH\", \"No such process\");\n        addcode(dict, EINTR, \"EINTR\", \"Interrupted system call\");", "refactored_code": "    public static final int EPERM = 1;\n    private static final PyObject strerror = new PyDictionary();\n\n    public static void classDictInit(PyObject dict) throws PyIgnoreMethodTag {\n        addcode(dict, EPERM, \"EPERM\", \"Operation not permitted\");\n        addcode(dict, ENOENT, \"ENOENT\", \"No such file or directory\");\n        addcode(dict, ESRCH, \"ESRCH\", \"No such process\");\n        addcode(dict, EINTR, \"EINTR\", \"Interrupted system call\");"}
{"magic_number_smell": "                    return new ModuleInfo(newFile(compiledFile), compiledFile.getPath(), \".class\", \"rb\", PY_COMPILED);\n                }\n            }\n            return new ModuleInfo(newFile(sourceFile), sourceFile.getPath(), \".py\", \"r\", 1);\n        }\n\n        // If no source, try loading precompiled", "refactored_code": "    public static final int PY_SOURCE = 1;\n                    return new ModuleInfo(newFile(compiledFile), compiledFile.getPath(), \".class\", \"rb\", PY_COMPILED);\n                }\n            }\n            return new ModuleInfo(newFile(sourceFile), sourceFile.getPath(), \".py\", \"r\", PY_SOURCE);\n        }\n\n        // If no source, try loading precompiled"}
{"magic_number_smell": "    }\n\n    private void java_init() {\n        digest = new int[20 / 4];\n        data = new int[DATA_LENGTH / 4];\n        tmp = new byte[DATA_LENGTH];\n        w = new int[80];", "refactored_code": "    private static final int HASH_LENGTH = 20;\n    }\n\n    private void java_init() {\n        digest = new int[HASH_LENGTH / 4];\n        data = new int[DATA_LENGTH / 4];\n        tmp = new byte[DATA_LENGTH];\n        w = new int[80];"}
{"magic_number_smell": "            if (expected == null)\n                return false;\n\n            int[] ahead = new int[3 - 1];\n\n            int i = 0;\n            for (;;) {", "refactored_code": "    private static final int MAX_LOOKAHEAD = 3;\n            if (expected == null)\n                return false;\n\n            int[] ahead = new int[MAX_LOOKAHEAD - 1];\n\n            int i = 0;\n            for (;;) {"}
{"magic_number_smell": "    public static final int 1 = 1;\n    public static final int Or = 2;\n\n    public static final String[] boolopTypeNames = new String[] { \"<undef>\", \"1\", \"Or\", };\n}\n", "refactored_code": "    public static final int And = 1;\n    public static final int And = 1;\n    public static final int Or = 2;\n\n    public static final String[] boolopTypeNames = new String[] { \"<undef>\", \"And\", \"Or\", };\n}\n"}
{"magic_number_smell": "    public static final int In = 9;\n    public static final int NotIn = 10;\n\n    public static final String[] cmpopTypeNames = new String[] { \"<undef>\", \"1\", \"NotEq\", \"Lt\", \"LtE\", \"Gt\", \"GtE\",\n            \"Is\", \"IsNot\", \"In\", \"NotIn\", };\n}\n", "refactored_code": "    public static final int Eq = 1;\n    public static final int In = 9;\n    public static final int NotIn = 10;\n\n    public static final String[] cmpopTypeNames = new String[] { \"<undef>\", \"Eq\", \"NotEq\", \"Lt\", \"LtE\", \"Gt\", \"GtE\",\n            \"Is\", \"IsNot\", \"In\", \"NotIn\", };\n}\n"}
{"magic_number_smell": "    public static final int AugStore = 5;\n    public static final int Param = 6;\n\n    public static final String[] expr_contextTypeNames = new String[] { \"<undef>\", \"1\", \"Store\", \"Del\", \"AugLoad\",\n            \"AugStore\", \"Param\", };\n}\n", "refactored_code": "    public static final int Load = 1;\n    public static final int AugStore = 5;\n    public static final int Param = 6;\n\n    public static final String[] expr_contextTypeNames = new String[] { \"<undef>\", \"Load\", \"Store\", \"Del\", \"AugLoad\",\n            \"AugStore\", \"Param\", };\n}\n"}
{"magic_number_smell": "    public static final int BitAnd = 11;\n    public static final int FloorDiv = 12;\n\n    public static final String[] operatorTypeNames = new String[] { \"<undef>\", \"1\", \"Sub\", \"Mult\", \"Div\", \"Mod\",\n            \"Pow\", \"LShift\", \"RShift\", \"BitOr\", \"BitXor\", \"BitAnd\", \"FloorDiv\", };\n}\n", "refactored_code": "    public static final int Add = 1;\n    public static final int BitAnd = 11;\n    public static final int FloorDiv = 12;\n\n    public static final String[] operatorTypeNames = new String[] { \"<undef>\", \"Add\", \"Sub\", \"Mult\", \"Div\", \"Mod\",\n            \"Pow\", \"LShift\", \"RShift\", \"BitOr\", \"BitXor\", \"BitAnd\", \"FloorDiv\", };\n}\n"}
{"magic_number_smell": "    public static final int UAdd = 3;\n    public static final int USub = 4;\n\n    public static final String[] unaryopTypeNames = new String[] { \"<undef>\", \"1\", \"Not\", \"UAdd\", \"USub\", };\n}\n", "refactored_code": "    public static final int Invert = 1;\n    public static final int UAdd = 3;\n    public static final int USub = 4;\n\n    public static final String[] unaryopTypeNames = new String[] { \"<undef>\", \"Invert\", \"Not\", \"UAdd\", \"USub\", };\n}\n"}
{"magic_number_smell": "\n    // added: 12-Mar-1999 baw\n    public TokenMgrError(String message, int errorLine, int errorColumn) {\n        this(message + \" at line \" + errorLine + \", column \" + errorColumn, 0);\n        this.EOFSeen = false;\n        this.errorLine = errorLine;\n        this.errorColumn = errorColumn;", "refactored_code": "    static public final int LEXICAL_ERROR = 0;\n\n    // added: 12-Mar-1999 baw\n    public TokenMgrError(String message, int errorLine, int errorColumn) {\n        this(message + \" at line \" + errorLine + \", column \" + errorColumn, LEXICAL_ERROR);\n        this.EOFSeen = false;\n        this.errorLine = errorLine;\n        this.errorColumn = errorColumn;"}
{"magic_number_smell": "    public static final int 1 = 1;\n    public static final int Or = 2;\n\n    public static final String[] boolopTypeNames = new String[] { \"<undef>\", \"1\", \"Or\", };\n}\n", "refactored_code": "    public static final int And = 1;\n    public static final int And = 1;\n    public static final int Or = 2;\n\n    public static final String[] boolopTypeNames = new String[] { \"<undef>\", \"And\", \"Or\", };\n}\n"}
{"magic_number_smell": "    public static final int In = 9;\n    public static final int NotIn = 10;\n\n    public static final String[] cmpopTypeNames = new String[] { \"<undef>\", \"1\", \"NotEq\", \"Lt\", \"LtE\", \"Gt\", \"GtE\",\n            \"Is\", \"IsNot\", \"In\", \"NotIn\", };\n}\n", "refactored_code": "    public static final int Eq = 1;\n    public static final int In = 9;\n    public static final int NotIn = 10;\n\n    public static final String[] cmpopTypeNames = new String[] { \"<undef>\", \"Eq\", \"NotEq\", \"Lt\", \"LtE\", \"Gt\", \"GtE\",\n            \"Is\", \"IsNot\", \"In\", \"NotIn\", };\n}\n"}
{"magic_number_smell": "    public static final int TupleCtx = 2;\n    public static final int EmptyCtx = 3;\n\n    public static final String[] comp_contextTypeNames = new String[] { \"<undef>\", \"1\", \"TupleCtx\", \"EmptyCtx\", };\n}\n", "refactored_code": "    public static final int ListCtx = 1;\n    public static final int TupleCtx = 2;\n    public static final int EmptyCtx = 3;\n\n    public static final String[] comp_contextTypeNames = new String[] { \"<undef>\", \"ListCtx\", \"TupleCtx\", \"EmptyCtx\", };\n}\n"}
{"magic_number_smell": "    public static final int Artificial = 7;\n    public static final int KwOnlyParam = 8;\n\n    public static final String[] expr_contextTypeNames = new String[] { \"<undef>\", \"1\", \"Store\", \"Del\", \"AugLoad\",\n            \"AugStore\", \"Param\", \"Artificial\", \"KwOnlyParam\", };\n}\n", "refactored_code": "    public static final int Load = 1;\n    public static final int Artificial = 7;\n    public static final int KwOnlyParam = 8;\n\n    public static final String[] expr_contextTypeNames = new String[] { \"<undef>\", \"Load\", \"Store\", \"Del\", \"AugLoad\",\n            \"AugStore\", \"Param\", \"Artificial\", \"KwOnlyParam\", };\n}\n"}
{"magic_number_smell": "    public static final int GlobalName = 9;\n    public static final int NonLocalName = 10;\n\n    public static final String[] name_contextTypeNames = new String[] { \"<undef>\", \"1\", \"FunctionName\",\n            \"KeywordName\", \"ImportName\", \"VarArg\", \"KwArg\", \"ImportModule\", \"Attrib\", \"GlobalName\", \"NonLocalName\", };\n}\n", "refactored_code": "    public static final int ClassName = 1;\n    public static final int GlobalName = 9;\n    public static final int NonLocalName = 10;\n\n    public static final String[] name_contextTypeNames = new String[] { \"<undef>\", \"ClassName\", \"FunctionName\",\n            \"KeywordName\", \"ImportName\", \"VarArg\", \"KwArg\", \"ImportModule\", \"Attrib\", \"GlobalName\", \"NonLocalName\", };\n}\n"}
{"magic_number_smell": "    public static final int Oct = 5;\n    public static final int Comp = 6;\n\n    public static final String[] num_typeTypeNames = new String[] { \"<undef>\", \"1\", \"Long\", \"Float\", \"Hex\", \"Oct\",\n            \"Comp\", };\n}\n", "refactored_code": "    public static final int Int = 1;\n    public static final int Oct = 5;\n    public static final int Comp = 6;\n\n    public static final String[] num_typeTypeNames = new String[] { \"<undef>\", \"Int\", \"Long\", \"Float\", \"Hex\", \"Oct\",\n            \"Comp\", };\n}\n"}
{"magic_number_smell": "    public static final int BitAnd = 11;\n    public static final int FloorDiv = 12;\n\n    public static final String[] operatorTypeNames = new String[] { \"<undef>\", \"1\", \"Sub\", \"Mult\", \"Div\", \"Mod\",\n            \"Pow\", \"LShift\", \"RShift\", \"BitOr\", \"BitXor\", \"BitAnd\", \"FloorDiv\", };\n}\n", "refactored_code": "    public static final int Add = 1;\n    public static final int BitAnd = 11;\n    public static final int FloorDiv = 12;\n\n    public static final String[] operatorTypeNames = new String[] { \"<undef>\", \"Add\", \"Sub\", \"Mult\", \"Div\", \"Mod\",\n            \"Pow\", \"LShift\", \"RShift\", \"BitOr\", \"BitXor\", \"BitAnd\", \"FloorDiv\", };\n}\n"}
{"magic_number_smell": "    public static final int Unicode = 2;\n    public static final int Raw = 3;\n\n    public static final String[] str_repTypeNames = new String[] { \"<undef>\", \"1\", \"Unicode\", \"Raw\", };\n}\n", "refactored_code": "    public static final int Normal = 1;\n    public static final int Unicode = 2;\n    public static final int Raw = 3;\n\n    public static final String[] str_repTypeNames = new String[] { \"<undef>\", \"Normal\", \"Unicode\", \"Raw\", };\n}\n"}
{"magic_number_smell": "    public static final int SingleSingle = 3;\n    public static final int SingleDouble = 4;\n\n    public static final String[] str_typeTypeNames = new String[] { \"<undef>\", \"1\", \"TripleDouble\",\n            \"SingleSingle\", \"SingleDouble\", };\n}\n", "refactored_code": "    public static final int TripleSingle = 1;\n    public static final int SingleSingle = 3;\n    public static final int SingleDouble = 4;\n\n    public static final String[] str_typeTypeNames = new String[] { \"<undef>\", \"TripleSingle\", \"TripleDouble\",\n            \"SingleSingle\", \"SingleDouble\", };\n}\n"}
{"magic_number_smell": "    public static final int UAdd = 3;\n    public static final int USub = 4;\n\n    public static final String[] unaryopTypeNames = new String[] { \"<undef>\", \"1\", \"Not\", \"UAdd\", \"USub\", };\n}\n", "refactored_code": "    public static final int Invert = 1;\n    public static final int UAdd = 3;\n    public static final int USub = 4;\n\n    public static final String[] unaryopTypeNames = new String[] { \"<undef>\", \"Invert\", \"Not\", \"UAdd\", \"USub\", };\n}\n"}
{"magic_number_smell": "        switch (tok.charAt(0)) {\n            case '(':\n            case ')':\n                use = this.0;\n                break;\n\n            case '[':", "refactored_code": "    private final int LEVEL_PARENS = 0; //()\n        switch (tok.charAt(0)) {\n            case '(':\n            case ')':\n                use = this.LEVEL_PARENS;\n                break;\n\n            case '[':"}
{"magic_number_smell": "    private void incrementPosition(DefaultGraphCell cell) {\n        stack.push(cell);\n        indent += INDENT_STEP;\n        depth += 30;\n    }\n\n    private void parentAddPort() {", "refactored_code": "    private static final int DEPTH_STEP = 30;\n    private void incrementPosition(DefaultGraphCell cell) {\n        stack.push(cell);\n        indent += INDENT_STEP;\n        depth += DEPTH_STEP;\n    }\n\n    private void parentAddPort() {"}
{"magic_number_smell": "    private int indent;\n\n    public IndentVisitor() {\n        this.indent = 4;\n    }\n\n    public int getIndent() {", "refactored_code": "    private static final int DEFAULT_INDENT = 4;\n    private int indent;\n\n    public IndentVisitor() {\n        this.indent = DEFAULT_INDENT;\n    }\n\n    public int getIndent() {"}
{"magic_number_smell": "    }\n\n    public boolean isGetter() {\n        return (flags & 1) == 1;\n    }\n\n    public boolean isSetter() {", "refactored_code": "    public static final int GETTER = 1;\n    }\n\n    public boolean isGetter() {\n        return (flags & GETTER) == GETTER;\n    }\n\n    public boolean isSetter() {"}
{"magic_number_smell": "        try {\n            reader = new BufferedReader(new FileReader(file));\n            StringBuilder builder = new StringBuilder();\n            char[] buffer = new char[1024];\n            int len;\n            while ((len = reader.read(buffer, 0, 1024)) != -1) {\n                builder.append(buffer, 0, len);", "refactored_code": "    private static final int BUFFER_SIZE = 1024;\n        try {\n            reader = new BufferedReader(new FileReader(file));\n            StringBuilder builder = new StringBuilder();\n            char[] buffer = new char[BUFFER_SIZE];\n            int len;\n            while ((len = reader.read(buffer, 0, BUFFER_SIZE)) != -1) {\n                builder.append(buffer, 0, len);"}
{"magic_number_smell": "     * Creates a listener list in which listeners are compared using equality.\n     */\n    public ListenerList(Class<X> genericType) {\n        this(genericType, 0);\n    }\n\n    /**", "refactored_code": "    public static final int EQUALITY = 0;\n     * Creates a listener list in which listeners are compared using equality.\n     */\n    public ListenerList(Class<X> genericType) {\n        this(genericType, EQUALITY);\n    }\n\n    /**"}
{"magic_number_smell": "        }\n        try {\n            if (SharedCorePlugin.inTestMode()) {\n                if (IStatus.WARNING <= errorLevel) {\n                    System.err.println(message);\n                    if (e != null) {\n                        e.printStackTrace();", "refactored_code": "    private static final int DEBUG_LEVEL = IStatus.WARNING;\n        }\n        try {\n            if (SharedCorePlugin.inTestMode()) {\n                if (DEBUG_LEVEL <= errorLevel) {\n                    System.err.println(message);\n                    if (e != null) {\n                        e.printStackTrace();"}
{"magic_number_smell": "    /**\n     * initially we're waiting\n     */\n    volatile int state = 0;\n\n    /**\n     * this is the exact time a parse later was requested", "refactored_code": "    public static final int STATE_WAITING = 0;\n    /**\n     * initially we're waiting\n     */\n    volatile int state = STATE_WAITING;\n\n    /**\n     * this is the exact time a parse later was requested"}
{"magic_number_smell": "        try {\n            return fForward ? readForwards() : readBackwards();\n        } catch (BadLocationException x) {\n            return -1; //Document may have changed...\n        }\n    }\n", "refactored_code": "    public static final int EOF = -1;\n        try {\n            return fForward ? readForwards() : readBackwards();\n        } catch (BadLocationException x) {\n            return EOF; //Document may have changed...\n        }\n    }\n"}
{"magic_number_smell": "            @Override\n            protected void createButtonsForButtonBar(Composite parent) {\n                super.createButtonsForButtonBar(parent);\n                createButton(parent, IDialogConstants.CLIENT_ID + 1, \"Clear History\", false); //$NON-NLS-1$\n            }\n\n            @Override", "refactored_code": "            private static final int CLEAR_HISTORY_ID = IDialogConstants.CLIENT_ID + 1;\n            @Override\n            protected void createButtonsForButtonBar(Composite parent) {\n                super.createButtonsForButtonBar(parent);\n                createButton(parent, CLEAR_HISTORY_ID, \"Clear History\", false); //$NON-NLS-1$\n            }\n\n            @Override"}
{"magic_number_smell": "    //-------- cycling through regular completions and templates\n    public static final int 1 = 1;\n    public static final int SHOW_ONLY_TEMPLATES = 2;\n    protected int whatToShow = 1;\n\n    public void startCycle() {\n        whatToShow = 1;", "refactored_code": "    public static final int SHOW_ALL = 1;\n    //-------- cycling through regular completions and templates\n    public static final int SHOW_ALL = 1;\n    public static final int SHOW_ONLY_TEMPLATES = 2;\n    protected int whatToShow = SHOW_ALL;\n\n    public void startCycle() {\n        whatToShow = SHOW_ALL;"}
{"magic_number_smell": "     * @return the behavior when faced with a given proposal (that has the same internal representation)\n     */\n    public int getOverrideBehavior(ICompletionProposal curr) {\n        return 0;\n    }\n}\n", "refactored_code": "    public static final int BEHAVIOR_OVERRIDES = 0;\n     * @return the behavior when faced with a given proposal (that has the same internal representation)\n     */\n    public int getOverrideBehavior(ICompletionProposal curr) {\n        return BEHAVIOR_OVERRIDES;\n    }\n}\n"}
{"magic_number_smell": "    protected void showInformationControl(Rectangle subjectArea) {\n        if (fControl instanceof IWidgetTokenOwnerExtension && fControl instanceof IWidgetTokenOwner) {\n            IWidgetTokenOwnerExtension extension = (IWidgetTokenOwnerExtension) fControl;\n            if (extension.requestWidgetToken(this, 5)) {\n                super.showInformationControl(subjectArea);\n            }\n        } else if (fControl instanceof IWidgetTokenOwner) {", "refactored_code": "    public static final int WIDGET_PRIORITY = 5;\n    protected void showInformationControl(Rectangle subjectArea) {\n        if (fControl instanceof IWidgetTokenOwnerExtension && fControl instanceof IWidgetTokenOwner) {\n            IWidgetTokenOwnerExtension extension = (IWidgetTokenOwnerExtension) fControl;\n            if (extension.requestWidgetToken(this, WIDGET_PRIORITY)) {\n                super.showInformationControl(subjectArea);\n            }\n        } else if (fControl instanceof IWidgetTokenOwner) {"}
{"magic_number_smell": "                    display = Display.getDefault();\n                }\n                if (display != null) {\n                    display.timerExec(300, updateStatus);\n                } else {\n                    Log.log(\"AsynchronousProgressMonitorDialog: No display available!\");\n                }", "refactored_code": "    public static final int UPDATE_INTERVAL_MS = 300;\n                    display = Display.getDefault();\n                }\n                if (display != null) {\n                    display.timerExec(UPDATE_INTERVAL_MS, updateStatus);\n                } else {\n                    Log.log(\"AsynchronousProgressMonitorDialog: No display available!\");\n                }"}
{"magic_number_smell": "\n                        if (fill != null) {\n                            gc.setBackground(fill);\n                            gc.fillRectangle(2, yy, size.x - (2 * 2), hh);\n                        }\n\n                        if (stroke != null) {", "refactored_code": "    private static final int INSET = 2;\n\n                        if (fill != null) {\n                            gc.setBackground(fill);\n                            gc.fillRectangle(INSET, yy, size.x - (2 * INSET), hh);\n                        }\n\n                        if (stroke != null) {"}
{"magic_number_smell": "    public void testRefreshAnalyzesFiles() throws Exception {\n        editor.close(false);\n        goToIdleLoopUntilCondition(getInitialParsesCondition(), getParsesDone(), false); //just to have any parse events consumed\n        goToManual(2000); //give it a bit more time...\n\n        PythonNature nature = PythonNature.getPythonNature(mod1);\n        AbstractAdditionalTokensInfo info = AdditionalProjectInterpreterInfo.getAdditionalInfoForProject(nature);", "refactored_code": "    public static final int TIME_FOR_ANALYSIS = 2000;\n    public void testRefreshAnalyzesFiles() throws Exception {\n        editor.close(false);\n        goToIdleLoopUntilCondition(getInitialParsesCondition(), getParsesDone(), false); //just to have any parse events consumed\n        goToManual(TIME_FOR_ANALYSIS); //give it a bit more time...\n\n        PythonNature nature = PythonNature.getPythonNature(mod1);\n        AbstractAdditionalTokensInfo info = AdditionalProjectInterpreterInfo.getAdditionalInfoForProject(nature);"}
{"magic_number_smell": "    //            \n    //            \n    //            fastString.clear();\n    //            for(int i=0;i<10000;i++){\n    //                fastString.append(\"test\").append(\"bar\").append(\"foo\").append(\"foo\").append(\"foo\").append(\"foo\");\n    //            }\n    //            ", "refactored_code": "    private static final int ITERATIONS = 10000;\n    //            \n    //            \n    //            fastString.clear();\n    //            for(int i=0;i<ITERATIONS;i++){\n    //                fastString.append(\"test\").append(\"bar\").append(\"foo\").append(\"foo\").append(\"foo\").append(\"foo\");\n    //            }\n    //            "}
{"magic_number_smell": "    /**\n     * Total time in millis that the test has for finishing \n     */\n    private final int TOTAL_TIME_FOR_TESTS = 300 * STEP_TIMEOUT * (TOTAL_STEPS + 1);\n\n    /**\n     * Used for having wait()", "refactored_code": "    private final int MAX_LOOPS = 300;\n    /**\n     * Total time in millis that the test has for finishing \n     */\n    private final int TOTAL_TIME_FOR_TESTS = MAX_LOOPS * STEP_TIMEOUT * (TOTAL_STEPS + 1);\n\n    /**\n     * Used for having wait()"}
{"magic_number_smell": "            // timer.printDiff();\n            //\n            // timer = new Timer();\n            // parseGeneration = 0;\n            // System.out.println(\"Fast parse\");\n            // test.parseFilesInDir(new File(\"D:/bin/python265/Lib\"), true);\n            // timer.printDiff();", "refactored_code": "    private static final int PARSE_GENERATION_DEFAULT = 0;\n            // timer.printDiff();\n            //\n            // timer = new Timer();\n            // parseGeneration = PARSE_GENERATION_DEFAULT;\n            // System.out.println(\"Fast parse\");\n            // test.parseFilesInDir(new File(\"D:/bin/python265/Lib\"), true);\n            // timer.printDiff();"}
{"magic_number_smell": "        IDocument doc = new Document(data.source);\n        Module astModule = VisitorFactory.getRootNode(doc, createVersionProvider());\n        String name = data.file.getName();\n        name = name.substring(0, name.length() - 4);\n        ModuleAdapter module = new ModuleAdapter(null, data.file, doc, astModule, new PythonNatureStub());\n\n        if (data.sourceSelection == null) {", "refactored_code": "    private static final int EXTENSION = 4;\n        IDocument doc = new Document(data.source);\n        Module astModule = VisitorFactory.getRootNode(doc, createVersionProvider());\n        String name = data.file.getName();\n        name = name.substring(0, name.length() - EXTENSION);\n        ModuleAdapter module = new ModuleAdapter(null, data.file, doc, astModule, new PythonNatureStub());\n\n        if (data.sourceSelection == null) {"}
{"magic_number_smell": "\n    private IInputOutputTestCase createTest(File file) {\n        String filename = file.getName();\n        String testCaseName = filename.substring(0, filename.length() - 3);\n\n        TestData data = new TestData(file);\n        IInputOutputTestCase testCase = createTestCase(testCaseName);", "refactored_code": "    private static final int EXTENSION = 3;\n\n    private IInputOutputTestCase createTest(File file) {\n        String filename = file.getName();\n        String testCaseName = filename.substring(0, filename.length() - EXTENSION);\n\n        TestData data = new TestData(file);\n        IInputOutputTestCase testCase = createTestCase(testCaseName);"}
{"magic_number_smell": "            doCallOffice(true);\n        // otherwise, prompt for permission\n        else\n            ActivityCompat.requestPermissions(this, new String[] {Manifest.permission.CALL_PHONE}, 0);\n\n    }\n", "refactored_code": "\tpublic static final int PERMISSION_TO_DIAL_DIRECTLY = 0;\n            doCallOffice(true);\n        // otherwise, prompt for permission\n        else\n            ActivityCompat.requestPermissions(this, new String[] {Manifest.permission.CALL_PHONE}, PERMISSION_TO_DIAL_DIRECTLY);\n\n    }\n"}
{"magic_number_smell": "\t\t\n\t\tif (firstTime()) {\n\t\t\ttripFirstTimeFlag();\n\t\t\tshowDialog(1);\n\t\t}\n\t\t\n\t\tsetupControls();", "refactored_code": "\tprivate static final int EXPLANATION = 1;\n\t\t\n\t\tif (firstTime()) {\n\t\t\ttripFirstTimeFlag();\n\t\t\tshowDialog(EXPLANATION);\n\t\t}\n\t\t\n\t\tsetupControls();"}
{"magic_number_smell": "\t\tif (!loadPhotoTasks.containsKey(bioguide_id)) {\n\t\t\t\n\t\t\t// if we have free space, fetch the photo\n\t\t\tif (loadPhotoTasks.size() <= 10) {\n\t\t\t\ttry {\n\t\t\t\t\tloadPhotoTasks.put(bioguide_id, (LoadPhotoTask) new LoadPhotoTask(this, LegislatorImage.PIC_SMALL, bioguide_id).execute(bioguide_id));\n\t\t\t\t} catch(RejectedExecutionException e) {", "refactored_code": "\tprivate static final int MAX_PHOTO_TASKS = 10;\n\t\tif (!loadPhotoTasks.containsKey(bioguide_id)) {\n\t\t\t\n\t\t\t// if we have free space, fetch the photo\n\t\t\tif (loadPhotoTasks.size() <= MAX_PHOTO_TASKS) {\n\t\t\t\ttry {\n\t\t\t\t\tloadPhotoTasks.put(bioguide_id, (LoadPhotoTask) new LoadPhotoTask(this, LegislatorImage.PIC_SMALL, bioguide_id).execute(bioguide_id));\n\t\t\t\t} catch(RejectedExecutionException e) {"}
{"magic_number_smell": "\t\tLayoutInflater inflater = getActivity().getLayoutInflater();\n\t\tint type = getArguments().getInt(\"type\");\n\t\t\n\t\tif (type == 1)\n\t\t\treturn about(inflater);\n\t\telse if (type == CHANGELOG)\n\t\t\treturn changelog(inflater);", "refactored_code": "\tpublic static final int ABOUT = 1;\n\t\tLayoutInflater inflater = getActivity().getLayoutInflater();\n\t\tint type = getArguments().getInt(\"type\");\n\t\t\n\t\tif (type == ABOUT)\n\t\t\treturn about(inflater);\n\t\telse if (type == CHANGELOG)\n\t\t\treturn changelog(inflater);"}
{"magic_number_smell": "\tpublic static BillListFragment forActive() {\n\t\tBillListFragment frag = new BillListFragment();\n\t\tBundle args = new Bundle();\n\t\targs.putInt(\"type\", 0);\n\t\tfrag.setArguments(args);\n\t\tfrag.setRetainInstance(true);\n\t\treturn frag;", "refactored_code": "\tpublic static final int BILLS_ACTIVE = 0;\n\tpublic static BillListFragment forActive() {\n\t\tBillListFragment frag = new BillListFragment();\n\t\tBundle args = new Bundle();\n\t\targs.putInt(\"type\", BILLS_ACTIVE);\n\t\tfrag.setArguments(args);\n\t\tfrag.setRetainInstance(true);\n\t\treturn frag;"}
{"magic_number_smell": "\tpublic static CommitteeListFragment forChamber(String chamber) {\n\t\tCommitteeListFragment frag = new CommitteeListFragment();\n\t\tBundle args = new Bundle();\n\t\targs.putInt(\"type\", 1);\n\t\targs.putString(\"chamber\", chamber);\n\t\tfrag.setArguments(args);\n\t\tfrag.setRetainInstance(true);", "refactored_code": "\tpublic static final int CHAMBER = 1;\n\tpublic static CommitteeListFragment forChamber(String chamber) {\n\t\tCommitteeListFragment frag = new CommitteeListFragment();\n\t\tBundle args = new Bundle();\n\t\targs.putInt(\"type\", CHAMBER);\n\t\targs.putString(\"chamber\", chamber);\n\t\tfrag.setArguments(args);\n\t\tfrag.setRetainInstance(true);"}
{"magic_number_smell": "\t\t}\n\t\t\n\t\t// only re-enable the pagination if we got a full page back\n\t\tif (updates.size() >= 20)\n\t\t\tadapterHelper.setOnScrollListener(pager);\n\t}\n\t", "refactored_code": "\tpublic static final int PER_PAGE = 20;\n\t\t}\n\t\t\n\t\t// only re-enable the pagination if we got a full page back\n\t\tif (updates.size() >= PER_PAGE)\n\t\t\tadapterHelper.setOnScrollListener(pager);\n\t}\n\t"}
{"magic_number_smell": "\tpublic static LegislatorListFragment forState(String state) {\n\t\tLegislatorListFragment frag = new LegislatorListFragment();\n\t\tBundle args = new Bundle();\n\t\targs.putInt(\"type\", 2);\n\t\targs.putString(\"state\", state);\n\t\tfrag.setArguments(args);\n\t\tfrag.setRetainInstance(true);", "refactored_code": "\tpublic static final int SEARCH_STATE = 2;\n\tpublic static LegislatorListFragment forState(String state) {\n\t\tLegislatorListFragment frag = new LegislatorListFragment();\n\t\tBundle args = new Bundle();\n\t\targs.putInt(\"type\", SEARCH_STATE);\n\t\targs.putString(\"state\", state);\n\t\tfrag.setArguments(args);\n\t\tfrag.setRetainInstance(true);"}
{"magic_number_smell": "\t\t}\n\t\t\n\t\t// only re-enable the pagination if we got a full page back\n\t\tif (rolls.size() >= 20)\n\t\t\tgetListView().setOnScrollListener(pager);\n\t}\n\t", "refactored_code": "\tpublic static final int PER_PAGE = 20;\n\t\t}\n\t\t\n\t\t// only re-enable the pagination if we got a full page back\n\t\tif (rolls.size() >= PER_PAGE)\n\t\t\tgetListView().setOnScrollListener(pager);\n\t}\n\t"}
{"magic_number_smell": "        public int getItemViewType(int position) {\n        \tItem item = getItem(position);\n        \tif (item instanceof UpcomingAdapter.Date)\n        \t\treturn UpcomingAdapter.0;\n        \telse\n        \t\treturn UpcomingAdapter.TYPE_BILL;\n        }", "refactored_code": "\t\tprivate static final int TYPE_DATE = 0;\n        public int getItemViewType(int position) {\n        \tItem item = getItem(position);\n        \tif (item instanceof UpcomingAdapter.Date)\n        \t\treturn UpcomingAdapter.TYPE_DATE;\n        \telse\n        \t\treturn UpcomingAdapter.TYPE_BILL;\n        }"}
{"magic_number_smell": "\t\n\t// used when there's a database error on initialization and there's not much else to do\n\tprivate void setError() {\n\t\tstate = -2;\n\t\t\n\t\ttext.setText(R.string.footer_error);\n\t\ttext.setTextColor(resources.getColor(R.color.text_grey));", "refactored_code": "\tpublic static final int ERROR = -2;\n\t\n\t// used when there's a database error on initialization and there's not much else to do\n\tprivate void setError() {\n\t\tstate = ERROR;\n\t\t\n\t\ttext.setText(R.string.footer_error);\n\t\ttext.setTextColor(resources.getColor(R.color.text_grey));"}
{"magic_number_smell": "\t\tResources res = activity.getResources();\n\n\t\tboolean notificationsOn = Utils.getBooleanPreference(activity, NotificationSettings.KEY_NOTIFY_ENABLED, false);\n        event = event.setCustomDimension(3, notificationsOn ? \"on\" : \"off\");\n\n\t\tString entrySource = entrySource(activity);\n\t\tif (entrySource != null)", "refactored_code": "\tpublic static final int DIMENSION_NOTIFICATIONS_ON = 3; // whether notifications are enabled (session)\n\t\tResources res = activity.getResources();\n\n\t\tboolean notificationsOn = Utils.getBooleanPreference(activity, NotificationSettings.KEY_NOTIFY_ENABLED, false);\n        event = event.setCustomDimension(DIMENSION_NOTIFICATIONS_ON, notificationsOn ? \"on\" : \"off\");\n\n\t\tString entrySource = entrySource(activity);\n\t\tif (entrySource != null)"}
{"magic_number_smell": "\n\tprivate static class DatabaseHelper extends SQLiteOpenHelper {\n\t\tpublic DatabaseHelper(Context context) {\n\t\t\tsuper(context, DATABASE_NAME, null, 9);\n\t\t}\n\n\t\tprivate void createTable(SQLiteDatabase db, String table, String[] columns) {", "refactored_code": "\tprivate static final int DATABASE_VERSION = 9;\n\n\tprivate static class DatabaseHelper extends SQLiteOpenHelper {\n\t\tpublic DatabaseHelper(Context context) {\n\t\t\tsuper(context, DATABASE_NAME, null, DATABASE_VERSION);\n\t\t}\n\n\t\tprivate void createTable(SQLiteDatabase db, String table, String[] columns) {"}
{"magic_number_smell": "        public int getItemViewType(int position) {\n        \tDateAdapterHelper<Content>.ItemWrapper item = getItem(position);\n        \tif (item instanceof DateAdapterHelper.DateWrapper)\n        \t\treturn 0;\n        \telse\n        \t\treturn TYPE_CONTENT;\n        }", "refactored_code": "    \tprivate static final int TYPE_DATE = 0;\n        public int getItemViewType(int position) {\n        \tDateAdapterHelper<Content>.ItemWrapper item = getItem(position);\n        \tif (item instanceof DateAdapterHelper.DateWrapper)\n        \t\treturn TYPE_DATE;\n        \telse\n        \t\treturn TYPE_CONTENT;\n        }"}
{"magic_number_smell": "\n\n\tpublic static class Action implements Serializable {\n\t\tprivate static final long 1L = 1L;\n\n\t\tpublic int id;\n\t\tpublic String full_id; // bill_id + \"-\" + id", "refactored_code": "\tprivate static final long serialVersionUID = 1L;\n\n\n\tpublic static class Action implements Serializable {\n\t\tprivate static final long serialVersionUID = 1L;\n\n\t\tpublic int id;\n\t\tpublic String full_id; // bill_id + \"-\" + id"}
{"magic_number_smell": "\t}\n\t\n\tpublic static class Membership implements Serializable {\n\t\tprivate static final long 1L = 1L;\n\n\t\tpublic String side, title;\n\t\tpublic int rank;", "refactored_code": "\tprivate static final long serialVersionUID = 1L;\n\t}\n\t\n\tpublic static class Membership implements Serializable {\n\t\tprivate static final long serialVersionUID = 1L;\n\n\t\tpublic String side, title;\n\t\tpublic int rank;"}
{"magic_number_smell": "    \tpublic NotFound(String msg) {\n    \t\tsuper(msg);\n    \t}\n    \tprivate static final long -2623309261327198187L = -2623309261327198188L;\n    }\n    \n    public static class BehindFirewall extends CongressException {", "refactored_code": "\tprivate static final long serialVersionUID = -2623309261327198187L;\n    \tpublic NotFound(String msg) {\n    \t\tsuper(msg);\n    \t}\n    \tprivate static final long serialVersionUID = -2623309261327198188L;\n    }\n    \n    public static class BehindFirewall extends CongressException {"}
{"magic_number_smell": "\t * to look up more information about the legislator.\n\t */\n\tpublic static class Vote implements Comparable<Vote>, Serializable {\n\t\tprivate static final long 1L = 1L;\n\t\t\n\t\tpublic String voter_id; // bioguide ID\n\t\tpublic String vote;", "refactored_code": "\tprivate static final long serialVersionUID = 1L;\n\t * to look up more information about the legislator.\n\t */\n\tpublic static class Vote implements Comparable<Vote>, Serializable {\n\t\tprivate static final long serialVersionUID = 1L;\n\t\t\n\t\tpublic String voter_id; // bioguide ID\n\t\tpublic String vote;"}
{"magic_number_smell": "    protected boolean useXmlFormat;\n    protected String resourcePath = DEFAULT_RESOURCE_PATH;\n    protected long fileLastModified;\n    protected int reloadIntervalSeconds = 10;\n\n    public PropertiesRealm() {\n        super();", "refactored_code": "    private static final int DEFAULT_RELOAD_INTERVAL_SECONDS = 10;\n    protected boolean useXmlFormat;\n    protected String resourcePath = DEFAULT_RESOURCE_PATH;\n    protected long fileLastModified;\n    protected int reloadIntervalSeconds = DEFAULT_RELOAD_INTERVAL_SECONDS;\n\n    public PropertiesRealm() {\n        super();"}
{"magic_number_smell": "public abstract class AbstractSessionManager implements SessionManager {\n\n    protected static final long 1000 = 1000;\n    protected static final long MILLIS_PER_MINUTE = 60 * 1000;\n    protected static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;\n\n    /**", "refactored_code": "    protected static final long MILLIS_PER_SECOND = 1000;\npublic abstract class AbstractSessionManager implements SessionManager {\n\n    protected static final long MILLIS_PER_SECOND = 1000;\n    protected static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND;\n    protected static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;\n\n    /**"}
{"magic_number_smell": "\n    public AbstractValidatingSessionManager() {\n        this.sessionValidationSchedulerEnabled = true;\n        this.sessionValidationInterval = MILLIS_PER_HOUR;\n    }\n\n    public boolean isSessionValidationSchedulerEnabled() {", "refactored_code": "    public static final long DEFAULT_SESSION_VALIDATION_INTERVAL = MILLIS_PER_HOUR;\n\n    public AbstractValidatingSessionManager() {\n        this.sessionValidationSchedulerEnabled = true;\n        this.sessionValidationInterval = DEFAULT_SESSION_VALIDATION_INTERVAL;\n    }\n\n    public boolean isSessionValidationSchedulerEnabled() {"}
{"magic_number_smell": "public class SimpleSession implements ValidatingSession, Serializable {\n\n    protected static final long 1000 = 1000;\n    protected static final long MILLIS_PER_MINUTE = 60 * 1000;\n    protected static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;\n\n    //serialization bitmask fields. DO NOT CHANGE THE ORDER THEY ARE DECLARED!", "refactored_code": "    protected static final long MILLIS_PER_SECOND = 1000;\npublic class SimpleSession implements ValidatingSession, Serializable {\n\n    protected static final long MILLIS_PER_SECOND = 1000;\n    protected static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND;\n    protected static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;\n\n    //serialization bitmask fields. DO NOT CHANGE THE ORDER THEY ARE DECLARED!"}
{"magic_number_smell": "    /**\n     * Serialization write support.\n     * <p/>\n     * NOTE: Don't forget to change the -6305224034025797558L constant at the top of this class\n     * if you make any backwards-incompatible serialization changes!!!\n     * (use the JDK 'serialver' program for this)\n     *", "refactored_code": "    private static final long serialVersionUID = -6305224034025797558L;\n    /**\n     * Serialization write support.\n     * <p/>\n     * NOTE: Don't forget to change the serialVersionUID constant at the top of this class\n     * if you make any backwards-incompatible serialization changes!!!\n     * (use the JDK 'serialver' program for this)\n     *"}
{"magic_number_smell": "            MAJOR_VERSION = JAVA_14;\n        } else {\n            // else leave 1.3 as default (it's either 1.3 or unknown)\n            MAJOR_VERSION = 0;\n        }\n    }\n", "refactored_code": "    public static final int JAVA_13 = 0;\n            MAJOR_VERSION = JAVA_14;\n        } else {\n            // else leave 1.3 as default (it's either 1.3 or unknown)\n            MAJOR_VERSION = JAVA_13;\n        }\n    }\n"}
{"magic_number_smell": "\n    private static final int Pattern.DOTALL = Pattern.DOTALL;\n\n    private static final int CASE_INSENSITIVE = Pattern.DOTALL | Pattern.CASE_INSENSITIVE;\n\n    private boolean caseInsensitive;\n", "refactored_code": "    private static final int DEFAULT = Pattern.DOTALL;\n\n    private static final int DEFAULT = Pattern.DOTALL;\n\n    private static final int CASE_INSENSITIVE = DEFAULT | Pattern.CASE_INSENSITIVE;\n\n    private boolean caseInsensitive;\n"}
{"magic_number_smell": "        final String password = \"password\";\n        final Object hashedPassword = new Sha512Hash(password, username).getBytes();\n        AuthenticationInfo account = new AuthenticationInfo() {\n            private static final long -3613684957517438801L = -6942549615727484358L;\n\n            @Override\n            public PrincipalCollection getPrincipals() {", "refactored_code": "            private static final long serialVersionUID = -3613684957517438801L;\n        final String password = \"password\";\n        final Object hashedPassword = new Sha512Hash(password, username).getBytes();\n        AuthenticationInfo account = new AuthenticationInfo() {\n            private static final long serialVersionUID = -6942549615727484358L;\n\n            @Override\n            public PrincipalCollection getPrincipals() {"}
{"magic_number_smell": "        assertEquals(USERNAME, usernamePrincipal.getUsername());\n\n        UserIdPrincipal userIdPrincipal = info.getPrincipals().oneByType(UserIdPrincipal.class);\n        assertEquals(12345, userIdPrincipal.getUserId());\n\n        String stringPrincipal = info.getPrincipals().oneByType(String.class);\n        assertEquals(12345 + USERNAME, stringPrincipal);", "refactored_code": "    private static final int USER_ID = 12345;\n        assertEquals(USERNAME, usernamePrincipal.getUsername());\n\n        UserIdPrincipal userIdPrincipal = info.getPrincipals().oneByType(UserIdPrincipal.class);\n        assertEquals(USER_ID, userIdPrincipal.getUserId());\n\n        String stringPrincipal = info.getPrincipals().oneByType(String.class);\n        assertEquals(USER_ID + USERNAME, stringPrincipal);"}
{"magic_number_smell": "        assertEquals(USERNAME, usernamePrincipal.getUsername());\n\n        UserIdPrincipal userIdPrincipal = subject.getPrincipals().oneByType(UserIdPrincipal.class);\n        assertEquals(12345, userIdPrincipal.getUserId());\n\n        assertTrue(realm.hasRole(subject.getPrincipals(), ROLE));\n", "refactored_code": "    private static final int USER_ID = 12345;\n        assertEquals(USERNAME, usernamePrincipal.getUsername());\n\n        UserIdPrincipal userIdPrincipal = subject.getPrincipals().oneByType(UserIdPrincipal.class);\n        assertEquals(USER_ID, userIdPrincipal.getUserId());\n\n        assertTrue(realm.hasRole(subject.getPrincipals(), ROLE));\n"}
{"magic_number_smell": "    public BlowfishCipherService() {\n        super(ALGORITHM_NAME);\n        //like most block ciphers, the IV size is the same as the block size\n        setInitializationVectorSize(64);\n    }\n}\n", "refactored_code": "    private static final int BLOCK_SIZE = 64;\n    public BlowfishCipherService() {\n        super(ALGORITHM_NAME);\n        //like most block ciphers, the IV size is the same as the block size\n        setInitializationVectorSize(BLOCK_SIZE);\n    }\n}\n"}
{"magic_number_smell": "        this.modeName = OperationMode.CBC.name();\n        this.paddingSchemeName = PaddingScheme.PKCS5.getTransformationName();\n        //0 = use the JCA provider's default\n        this.blockSize = 0;\n\n        this.streamingModeName = OperationMode.CBC.name();\n        this.streamingPaddingSchemeName = PaddingScheme.PKCS5.getTransformationName();", "refactored_code": "    private static final int DEFAULT_BLOCK_SIZE = 0;\n        this.modeName = OperationMode.CBC.name();\n        this.paddingSchemeName = PaddingScheme.PKCS5.getTransformationName();\n        //0 = use the JCA provider's default\n        this.blockSize = DEFAULT_BLOCK_SIZE;\n\n        this.streamingModeName = OperationMode.CBC.name();\n        this.streamingPaddingSchemeName = PaddingScheme.PKCS5.getTransformationName();"}
{"magic_number_smell": "            throw new IllegalArgumentException(\"algorithmName argument cannot be null or empty.\");\n        }\n        this.algorithmName = algorithmName;\n        this.keySize = 128;\n        //default to same size as the key size (a common algorithm practice)\n        this.initializationVectorSize = 128;\n        this.streamingBufferSize = DEFAULT_STREAMING_BUFFER_SIZE;", "refactored_code": "    private static final int DEFAULT_KEY_SIZE = 128;\n            throw new IllegalArgumentException(\"algorithmName argument cannot be null or empty.\");\n        }\n        this.algorithmName = algorithmName;\n        this.keySize = DEFAULT_KEY_SIZE;\n        //default to same size as the key size (a common algorithm practice)\n        this.initializationVectorSize = DEFAULT_KEY_SIZE;\n        this.streamingBufferSize = DEFAULT_STREAMING_BUFFER_SIZE;"}
{"magic_number_smell": "     * used in cryptographic algorithms.\n     */\n    public SecureRandomNumberGenerator() {\n        this.defaultNextBytesSize = 16;\n        this.secureRandom = new SecureRandom();\n    }\n", "refactored_code": "    protected static final int DEFAULT_NEXT_BYTES_SIZE = 16;\n     * used in cryptographic algorithms.\n     */\n    public SecureRandomNumberGenerator() {\n        this.defaultNextBytesSize = DEFAULT_NEXT_BYTES_SIZE;\n        this.secureRandom = new SecureRandom();\n    }\n"}
{"magic_number_smell": "     */\n    public SimpleHash(String algorithmName) {\n        this.algorithmName = algorithmName;\n        this.iterations = 1;\n    }\n\n    /**", "refactored_code": "    private static final int DEFAULT_ITERATIONS = 1;\n     */\n    public SimpleHash(String algorithmName) {\n        this.algorithmName = algorithmName;\n        this.iterations = DEFAULT_ITERATIONS;\n    }\n\n    /**"}
{"magic_number_smell": "\n    public static Argon2Hash generate(String algorithmName, ByteSource source, ByteSource salt, int iterations) {\n        return generate(algorithmName, DEFAULT_ALGORITHM_VERSION, source, salt, iterations,\n                DEFAULT_MEMORY_KIB, 4, DEFAULT_OUTPUT_LENGTH_BITS);\n    }\n\n    public static Argon2Hash generate(", "refactored_code": "    public static final int DEFAULT_PARALLELISM = 4;\n\n    public static Argon2Hash generate(String algorithmName, ByteSource source, ByteSource salt, int iterations) {\n        return generate(algorithmName, DEFAULT_ALGORITHM_VERSION, source, salt, iterations,\n                DEFAULT_MEMORY_KIB, DEFAULT_PARALLELISM, DEFAULT_OUTPUT_LENGTH_BITS);\n    }\n\n    public static Argon2Hash generate("}
{"magic_number_smell": "    }\n\n    public static BCryptHash generate(final ByteSource source) {\n        return generate(source, createSalt(), 10);\n    }\n\n", "refactored_code": "    public static final int DEFAULT_COST = 10;\n    }\n\n    public static BCryptHash generate(final ByteSource source) {\n        return generate(source, createSalt(), DEFAULT_COST);\n    }\n\n"}
{"magic_number_smell": "\n    /**\n     * Creates a new SoftHashMap with a default retention size size of\n     * {@link #100 100} (100 entries).\n     *\n     * @see #SoftHashMap(int)\n     */", "refactored_code": "    private static final int DEFAULT_RETENTION_SIZE = 100;\n\n    /**\n     * Creates a new SoftHashMap with a default retention size size of\n     * {@link #DEFAULT_RETENTION_SIZE DEFAULT_RETENTION_SIZE} (100 entries).\n     *\n     * @see #SoftHashMap(int)\n     */"}
{"magic_number_smell": "    /**\n     * The session validation interval in milliseconds.\n     */\n    private long sessionValidationInterval = DefaultSessionManager.DEFAULT_SESSION_VALIDATION_INTERVAL;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |", "refactored_code": "    public static final long DEFAULT_SESSION_VALIDATION_INTERVAL = DefaultSessionManager.DEFAULT_SESSION_VALIDATION_INTERVAL;\n    /**\n     * The session validation interval in milliseconds.\n     */\n    private long sessionValidationInterval = DEFAULT_SESSION_VALIDATION_INTERVAL;\n\n    /*--------------------------------------------\n    |         C O N S T R U C T O R S           |"}
{"magic_number_smell": "        String saltString = null;\n        String saltBytesString = null;\n        boolean generateSalt = false;\n        int generatedSaltSize = 128;\n        String privateSaltString = null;\n        String privateSaltBytesString = null;\n", "refactored_code": "    private static final int DEFAULT_GENERATED_SALT_SIZE = 128;\n        String saltString = null;\n        String saltBytesString = null;\n        boolean generateSalt = false;\n        int generatedSaltSize = DEFAULT_GENERATED_SALT_SIZE;\n        String privateSaltString = null;\n        String privateSaltBytesString = null;\n"}
{"magic_number_smell": "    public static final int 80 = 80;\n    public static final String HTTP_SCHEME = \"http\";\n\n    private int port = 80;\n\n    public int getPort() {\n        return port;", "refactored_code": "    public static final int DEFAULT_HTTP_PORT = 80;\n    public static final int DEFAULT_HTTP_PORT = 80;\n    public static final String HTTP_SCHEME = \"http\";\n\n    private int port = DEFAULT_HTTP_PORT;\n\n    public int getPort() {\n        return port;"}
{"magic_number_smell": "    private HSTS hsts;\n\n    public SslFilter() {\n        setPort(443);\n        this.hsts = new HSTS();\n    }\n", "refactored_code": "    public static final int DEFAULT_HTTPS_PORT = 443;\n    private HSTS hsts;\n\n    public SslFilter() {\n        setPort(DEFAULT_HTTPS_PORT);\n        this.hsts = new HSTS();\n    }\n"}
{"magic_number_smell": "    private SameSiteOptions sameSite;\n\n    public SimpleCookie() {\n        this.maxAge = -1;\n        this.version = DEFAULT_VERSION;\n        //most of the cookies ever used by Shiro should be as secure as possible.\n        this.httpOnly = true;", "refactored_code": "    public static final int DEFAULT_MAX_AGE = -1;\n    private SameSiteOptions sameSite;\n\n    public SimpleCookie() {\n        this.maxAge = DEFAULT_MAX_AGE;\n        this.version = DEFAULT_VERSION;\n        //most of the cookies ever used by Shiro should be as secure as possible.\n        this.httpOnly = true;"}
{"magic_number_smell": "\n    /**\n     * @param xform             The {@link AffineTransform} to use for the operation.\n     * @param interpolationType One of the integer interpolation type constants defined by this class: {@link #java.awt.image.AffineTransformOp.TYPE_NEAREST_NEIGHBOR}, {@link #TYPE_BILINEAR}, {@link #TYPE_BICUBIC}.\n     */\n    public AffineTransformOp(final AffineTransform xform, final int interpolationType) {\n        delegate = new java.awt.image.AffineTransformOp(xform, interpolationType);", "refactored_code": "    public static final int TYPE_NEAREST_NEIGHBOR = java.awt.image.AffineTransformOp.TYPE_NEAREST_NEIGHBOR;\n\n    /**\n     * @param xform             The {@link AffineTransform} to use for the operation.\n     * @param interpolationType One of the integer interpolation type constants defined by this class: {@link #TYPE_NEAREST_NEIGHBOR}, {@link #TYPE_BILINEAR}, {@link #TYPE_BICUBIC}.\n     */\n    public AffineTransformOp(final AffineTransform xform, final int interpolationType) {\n        delegate = new java.awt.image.AffineTransformOp(xform, interpolationType);"}
{"magic_number_smell": "     * Adds a border to the image while convolving. The border will reflect the\n     * edges of the original image. This is usually a good default.\n     * Note that while this mode typically provides better quality than the\n     * standard modes {@code ConvolveOp.EDGE_ZERO_FILL} and {@code EDGE_NO_OP}, it does so\n     * at the expense of higher memory consumption and considerable more computation.\n     */\n    public static final int EDGE_REFLECT = 2; // as JAI BORDER_REFLECT", "refactored_code": "    public static final int EDGE_ZERO_FILL = ConvolveOp.EDGE_ZERO_FILL;\n     * Adds a border to the image while convolving. The border will reflect the\n     * edges of the original image. This is usually a good default.\n     * Note that while this mode typically provides better quality than the\n     * standard modes {@code EDGE_ZERO_FILL} and {@code EDGE_NO_OP}, it does so\n     * at the expense of higher memory consumption and considerable more computation.\n     */\n    public static final int EDGE_REFLECT = 2; // as JAI BORDER_REFLECT"}
{"magic_number_smell": "        // Random errors in [-1 .. 1] - for first row\n        for (int i = 0; i < width + 2; i++) {\n            // Note: This is broken for the strange cases where nextInt returns Integer.MIN_VALUE\n            currErr[i][0] = RANDOM.nextInt(1 << 8 * 2) - 1 << 8;\n            currErr[i][1] = RANDOM.nextInt(1 << 8 * 2) - 1 << 8;\n            currErr[i][2] = RANDOM.nextInt(1 << 8 * 2) - 1 << 8;\n        }", "refactored_code": "    private static final int FS_SCALE = 1 << 8;\n        // Random errors in [-1 .. 1] - for first row\n        for (int i = 0; i < width + 2; i++) {\n            // Note: This is broken for the strange cases where nextInt returns Integer.MIN_VALUE\n            currErr[i][0] = RANDOM.nextInt(FS_SCALE * 2) - FS_SCALE;\n            currErr[i][1] = RANDOM.nextInt(FS_SCALE * 2) - FS_SCALE;\n            currErr[i][2] = RANDOM.nextInt(FS_SCALE * 2) - FS_SCALE;\n        }"}
{"magic_number_smell": "     * Adds a border to the image while convolving. The border will reflect the\n     * edges of the original image. This is usually a good default.\n     * Note that while this mode typically provides better quality than the\n     * standard modes {@code ConvolveOp.EDGE_ZERO_FILL} and {@code EDGE_NO_OP}, it does so\n     * at the expense of higher memory consumption and considerable more computation.\n     * @see #convolve(java.awt.image.BufferedImage, java.awt.image.Kernel, int)\n     */", "refactored_code": "    public static final int EDGE_ZERO_FILL = ConvolveOp.EDGE_ZERO_FILL;\n     * Adds a border to the image while convolving. The border will reflect the\n     * edges of the original image. This is usually a good default.\n     * Note that while this mode typically provides better quality than the\n     * standard modes {@code EDGE_ZERO_FILL} and {@code EDGE_NO_OP}, it does so\n     * at the expense of higher memory consumption and considerable more computation.\n     * @see #convolve(java.awt.image.BufferedImage, java.awt.image.Kernel, int)\n     */"}
{"magic_number_smell": "\n    static {\n        try {\n            nativeOp[0] = Class.forName(\"com.twelvemonkeys.image.ResampleOp\");\n        }\n        catch (ClassNotFoundException e) {\n            System.err.println(\"Could not find class: \" + e);", "refactored_code": "    private static final int RESAMPLE_OP = 0;\n\n    static {\n        try {\n            nativeOp[RESAMPLE_OP] = Class.forName(\"com.twelvemonkeys.image.ResampleOp\");\n        }\n        catch (ClassNotFoundException e) {\n            System.err.println(\"Could not find class: \" + e);"}
{"magic_number_smell": "\n    private final int 30 = 30;\n    private final int height = 20;\n    private final double anchor = min(30, height) / 2.0;\n\n    @Test\n    public void testGetPoint2D() {", "refactored_code": "    private final int width = 30;\n\n    private final int width = 30;\n    private final int height = 20;\n    private final double anchor = min(width, height) / 2.0;\n\n    @Test\n    public void testGetPoint2D() {"}
{"magic_number_smell": "            // int, int - unknown: 0,0\n\n            // If the shell settings are present, skip them\n            if ((flags & 0x01) != 0) {\n                // Shell Item Id List present\n                //System.out.println(\"Shell Item Id List present\");\n                int shellLen = in.readShort(); // Short", "refactored_code": "    private static final int FLAG_ITEM_ID_LIST = 0x01;\n            // int, int - unknown: 0,0\n\n            // If the shell settings are present, skip them\n            if ((flags & FLAG_ITEM_ID_LIST) != 0) {\n                // Shell Item Id List present\n                //System.out.println(\"Shell Item Id List present\");\n                int shellLen = in.readShort(); // Short"}
{"magic_number_smell": "    // easy reading of the Thumbs.db file\n    // It's probably safer to create one version for InputStream and one for File\n    private static boolean canRead(final DataInput pInput, final boolean pReset) {\n        long pos = -1;\n        if (pReset) {\n            try {\n                if (pInput instanceof InputStream && ((InputStream) pInput).markSupported()) {", "refactored_code": "    private static final int FREE_SID = -1;\n    // easy reading of the Thumbs.db file\n    // It's probably safer to create one version for InputStream and one for File\n    private static boolean canRead(final DataInput pInput, final boolean pReset) {\n        long pos = FREE_SID;\n        if (pReset) {\n            try {\n                if (pInput instanceof InputStream && ((InputStream) pInput).markSupported()) {"}
{"magic_number_smell": "    public static final long 1000l = 1000l;\n\n    /** One minute: 60 seconds (60 000 milliseconds). */\n    public static final long MINUTE = 60l * 1000l;\n\n    /**\n     * One hour: 60 minutes (3 600 000 milliseconds).", "refactored_code": "    public static final long SECOND = 1000l;\n    public static final long SECOND = 1000l;\n\n    /** One minute: 60 seconds (60 000 milliseconds). */\n    public static final long MINUTE = 60l * SECOND;\n\n    /**\n     * One hour: 60 minutes (3 600 000 milliseconds)."}
{"magic_number_smell": "     *     private static final int 100 = 100;\n     *\n     *     protected boolean removeEldestEntry(Map.Entry eldest) {\n     *        return size() &gt; 100;\n     *     }\n     * </pre>\n     *", "refactored_code": "     *     private static final int MAX_ENTRIES = 100;\n     *     private static final int MAX_ENTRIES = 100;\n     *\n     *     protected boolean removeEldestEntry(Map.Entry eldest) {\n     *        return size() &gt; MAX_ENTRIES;\n     *     }\n     * </pre>\n     *"}
{"magic_number_smell": "    }\n\n    public int getXPixelsPerMeter() {\n        return xPixelsPerMeter != 0 ? xPixelsPerMeter : 2835;\n    }\n\n    public int getYPixelsPerMeter() {", "refactored_code": "    private final int DEFAULT_PIXELS_PER_METER = 2835;\n    }\n\n    public int getXPixelsPerMeter() {\n        return xPixelsPerMeter != 0 ? xPixelsPerMeter : DEFAULT_PIXELS_PER_METER;\n    }\n\n    public int getYPixelsPerMeter() {"}
{"magic_number_smell": "        // and which must be written *before* the image data?\n        // - Allocate a block of N * 16 bytes\n        //   - If image count % N > N, we need to move the first image backwards in the file and allocate another N items...\n        imageOutput.write(new byte[INITIAL_ENTRY_COUNT * 16]); // Allocate room for 8 entries for now\n    }\n\n    @Override", "refactored_code": "    private static final int ENTRY_SIZE = 16;\n        // and which must be written *before* the image data?\n        // - Allocate a block of N * 16 bytes\n        //   - If image count % N > N, we need to move the first image backwards in the file and allocate another N items...\n        imageOutput.write(new byte[INITIAL_ENTRY_COUNT * ENTRY_SIZE]); // Allocate room for 8 entries for now\n    }\n\n    @Override"}
{"magic_number_smell": "        // Photoshop seems to write as linked if all points are the same....\n        return (x1 == x2 && x2 == x3 && y1 == y2 && y2 == y3) ||\n                (x1 != x2 || y1 != y2) && (x2 != x3 || y2 != y3) &&\n                 Math.abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) <= 0.00000001; // With some slack...\n\n    }\n", "refactored_code": "    private static final double COLLINEARITY_THRESHOLD = 0.00000001;\n        // Photoshop seems to write as linked if all points are the same....\n        return (x1 == x2 && x2 == x3 && y1 == y2 && y2 == y3) ||\n                (x1 != x2 || y1 != y2) && (x2 != x3 || y2 != y3) &&\n                 Math.abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) <= COLLINEARITY_THRESHOLD; // With some slack...\n\n    }\n"}
{"magic_number_smell": "     * @return the {@link ColorSpace} specified by the color space constant.\n     * @throws IllegalArgumentException if {@code colorSpace} is not one of the defined color spaces ({@code CS_*}).\n     * @see ColorSpace\n     * @see ColorSpaces#5000\n     * @see ColorSpaces#CS_GENERIC_CMYK\n     */\n    public static ColorSpace getColorSpace(int colorSpace) {", "refactored_code": "    public static final int CS_ADOBE_RGB_1998 = 5000;\n     * @return the {@link ColorSpace} specified by the color space constant.\n     * @throws IllegalArgumentException if {@code colorSpace} is not one of the defined color spaces ({@code CS_*}).\n     * @see ColorSpace\n     * @see ColorSpaces#CS_ADOBE_RGB_1998\n     * @see ColorSpaces#CS_GENERIC_CMYK\n     */\n    public static ColorSpace getColorSpace(int colorSpace) {"}
{"magic_number_smell": "        byte[] data = profile.getData(tagSignature);\n\n        // The CMM expects 0x64 65 73 63 ('XYZ ') but is 0x17 A5 05 B8..?\n        if (data != null && intFromBigEndian(data, 0) == 0x17 << 24 | 0xA5 << 16 | 0x05 << 8 | 0xB8) {\n            intToBigEndian(ICC_Profile.icSigXYZData, data, 0);\n            profile.setData(tagSignature, data);\n", "refactored_code": "    private static final int CORBIS_RGB_ALTERNATE_XYZ = 0x17 << 24 | 0xA5 << 16 | 0x05 << 8 | 0xB8;\n        byte[] data = profile.getData(tagSignature);\n\n        // The CMM expects 0x64 65 73 63 ('XYZ ') but is 0x17 A5 05 B8..?\n        if (data != null && intFromBigEndian(data, 0) == CORBIS_RGB_ALTERNATE_XYZ) {\n            intToBigEndian(ICC_Profile.icSigXYZData, data, 0);\n            profile.setData(tagSignature, data);\n"}
{"magic_number_smell": "            switch (type) {\n                // Special handling for INT_RGB and BGR, due to bug in ImageTypeSpecifier for these types (DirectColorModel is 32 bits)\n                case BufferedImage.TYPE_INT_RGB:\n                    expected = createPacked(sRGB, 24, 0x00ff0000, DCM_GREEN_MASK, DCM_BLUE_MASK, 0, DataBuffer.TYPE_INT, false);\n                    break;\n                case BufferedImage.TYPE_INT_BGR:\n                    expected = createPacked(sRGB, 24, DCM_BGR_RED_MASK, DCM_BGR_GRN_MASK, DCM_BGR_BLU_MASK, 0, DataBuffer.TYPE_INT, false);", "refactored_code": "    private static final int DCM_RED_MASK = 0x00ff0000;\n            switch (type) {\n                // Special handling for INT_RGB and BGR, due to bug in ImageTypeSpecifier for these types (DirectColorModel is 32 bits)\n                case BufferedImage.TYPE_INT_RGB:\n                    expected = createPacked(sRGB, 24, DCM_RED_MASK, DCM_GREEN_MASK, DCM_BLUE_MASK, 0, DataBuffer.TYPE_INT, false);\n                    break;\n                case BufferedImage.TYPE_INT_BGR:\n                    expected = createPacked(sRGB, 24, DCM_BGR_RED_MASK, DCM_BGR_GRN_MASK, DCM_BGR_BLU_MASK, 0, DataBuffer.TYPE_INT, false);"}
{"magic_number_smell": "        }\n\n        public boolean isProgramTypeValid() {\n            return ((valid & 0x01) != 0);\n        }\n\n        public boolean isGammaValid() {", "refactored_code": "    private static final int VALID_PROGRAMTYPE = 0x01;\n        }\n\n        public boolean isProgramTypeValid() {\n            return ((valid & VALID_PROGRAMTYPE) != 0);\n        }\n\n        public boolean isGammaValid() {"}
{"magic_number_smell": "        Decoder decoder = createDecoder();\n        ByteArrayInputStream bytes = new ByteArrayInputStream(new byte[0]);\n\n        int count = decoder.decode(bytes, ByteBuffer.allocate(1024));\n        assertEquals(\"Should not be able to read any bytes\", 0, count);\n    }\n", "refactored_code": "    public static final int BUFFER_SIZE = 1024;\n        Decoder decoder = createDecoder();\n        ByteArrayInputStream bytes = new ByteArrayInputStream(new byte[0]);\n\n        int count = decoder.decode(bytes, ByteBuffer.allocate(BUFFER_SIZE));\n        assertEquals(\"Should not be able to read any bytes\", 0, count);\n    }\n"}
{"magic_number_smell": "        }\n\n        for (int i = 1; k < 256; i++, k++) {\n            tab[k] = i | 0x80000000;\n        }\n\n        int currentTable = 1;", "refactored_code": "    private static final int MSB = 0x80000000;\n        }\n\n        for (int i = 1; k < 256; i++, k++) {\n            tab[k] = i | MSB;\n        }\n\n        int currentTable = 1;"}
{"magic_number_smell": "    final byte[] thumbnail;\n\n    JFXX(final int extensionCode, final byte[] thumbnail) {\n        super(com.twelvemonkeys.imageio.metadata.jpeg.0x10.APP0, \"JFXX\", new byte[1 + (thumbnail != null ? thumbnail.length : 0)]);\n\n        this.extensionCode = extensionCode;\n        this.thumbnail = thumbnail;", "refactored_code": "    public static final int JPEG = 0x10;\n    final byte[] thumbnail;\n\n    JFXX(final int extensionCode, final byte[] thumbnail) {\n        super(com.twelvemonkeys.imageio.metadata.jpeg.JPEG.APP0, \"JFXX\", new byte[1 + (thumbnail != null ? thumbnail.length : 0)]);\n\n        this.extensionCode = extensionCode;\n        this.thumbnail = thumbnail;"}
{"magic_number_smell": "\n                @Override\n                public void imageProgress(ImageReader source, float percentageDone) {\n                    int steps = ((int) (percentageDone * 78) / 100);\n\n                    for (int i = lastProgress; i < steps; i++) {\n                        System.out.print(\".\");", "refactored_code": "                private static final int MAX_W = 78;\n\n                @Override\n                public void imageProgress(ImageReader source, float percentageDone) {\n                    int steps = ((int) (percentageDone * MAX_W) / 100);\n\n                    for (int i = lastProgress; i < steps; i++) {\n                        System.out.print(\".\");"}
{"magic_number_smell": "                    }\n                }\n\n                if ((current < 0xFFD0) || (current > RESTART_MARKER_END)) {\n                    break; //current=MARKER\n                }\n            }", "refactored_code": "    private static final int RESTART_MARKER_BEGIN = 0xFFD0;\n                    }\n                }\n\n                if ((current < RESTART_MARKER_BEGIN) || (current > RESTART_MARKER_END)) {\n                    break; //current=MARKER\n                }\n            }"}
{"magic_number_smell": "    private int parseEncoding(final ImageInputStream pInput, int tagByteCount) throws IOException {\n        return tagByteCount == 3\n                && (pInput.readUnsignedByte() << 16 | pInput.readUnsignedByte() << 8 | pInput.readUnsignedByte()) == ENCODING_UTF_8\n                ? ENCODING_UTF_8 : -1;\n    }\n\n    // TODO: Pass encoding as parameter? Use if specified", "refactored_code": "    private static final int ENCODING_UNKNOWN = -1;\n    private int parseEncoding(final ImageInputStream pInput, int tagByteCount) throws IOException {\n        return tagByteCount == 3\n                && (pInput.readUnsignedByte() << 16 | pInput.readUnsignedByte() << 8 | pInput.readUnsignedByte()) == ENCODING_UTF_8\n                ? ENCODING_UTF_8 : ENCODING_UNKNOWN;\n    }\n\n    // TODO: Pass encoding as parameter? Use if specified"}
{"magic_number_smell": "\n            int i;\n            for (i = 0; i < len; i++) {\n                if (i % 32 == 0) {\n                    if (i > 0) {\n                        builder.append(\"\\n\");\n                    }", "refactored_code": "        private static final int WIDTH = 32;\n\n            int i;\n            for (i = 0; i < len; i++) {\n                if (i % WIDTH == 0) {\n                    if (i > 0) {\n                        builder.append(\"\\n\");\n                    }"}
{"magic_number_smell": "        this.offsetSize = Validate.isTrue(offsetSize == 4 || offsetSize == 8, offsetSize, \"offsetSize must be 4 for TIFF or 8 for BigTIFF\");\n\n        longOffsets = offsetSize == 8;\n        directoryCountLength = longOffsets ? 8 : 2;\n        entryLength = 2 * 2 + 2 * offsetSize;\n    }\n", "refactored_code": "    private static final int WORD_LENGTH = 2;\n        this.offsetSize = Validate.isTrue(offsetSize == 4 || offsetSize == 8, offsetSize, \"offsetSize must be 4 for TIFF or 8 for BigTIFF\");\n\n        longOffsets = offsetSize == 8;\n        directoryCountLength = longOffsets ? 8 : WORD_LENGTH;\n        entryLength = 2 * WORD_LENGTH + 2 * offsetSize;\n    }\n"}
{"magic_number_smell": "        ImageInputStream stream = ImageIO.createImageInputStream(getClass().getResourceAsStream(\"/jpeg/9788245605525.jpg\"));\n\n        try {\n            assertEquals(.92f, JPEGQuality.getJPEGQuality(stream), .000001f);\n        }\n        finally {\n            stream.close();", "refactored_code": "    private static final float DELTA = .000001f;\n        ImageInputStream stream = ImageIO.createImageInputStream(getClass().getResourceAsStream(\"/jpeg/9788245605525.jpg\"));\n\n        try {\n            assertEquals(.92f, JPEGQuality.getJPEGQuality(stream), DELTA);\n        }\n        finally {\n            stream.close();"}
{"magic_number_smell": "        public Shape createStrokedShape(Shape shape) {\n            GeneralPath result = new GeneralPath();\n\n            PathIterator it = new FlatteningPathIterator(shape.getPathIterator(null), 1);\n            float points[] = new float[6];\n            float moveX = 0, moveY = 0;\n            float lastX = 0, lastY = 0;", "refactored_code": "        private static final float FLATNESS = 1;\n        public Shape createStrokedShape(Shape shape) {\n            GeneralPath result = new GeneralPath();\n\n            PathIterator it = new FlatteningPathIterator(shape.getPathIterator(null), FLATNESS);\n            float points[] = new float[6];\n            float moveX = 0, moveY = 0;\n            float lastX = 0, lastY = 0;"}
{"magic_number_smell": "            description.depth = pStream.readShort(); // Image bit depth\n            description.colorLUTId = pStream.readShort(); // Color Lookup Table Id, -1 means none\n\n            int extraDescSize = description.size - ImageDesc.86;\n            if (extraDescSize < 0) {\n                throw new IIOException(\"Negative array size in 'idsc' Atom: \" + extraDescSize);\n            }", "refactored_code": "        private static final int SIZE = 86;\n            description.depth = pStream.readShort(); // Image bit depth\n            description.colorLUTId = pStream.readShort(); // Color Lookup Table Id, -1 means none\n\n            int extraDescSize = description.size - ImageDesc.SIZE;\n            if (extraDescSize < 0) {\n                throw new IIOException(\"Negative array size in 'idsc' Atom: \" + extraDescSize);\n            }"}
{"magic_number_smell": "        // TODO: It might be possible to speed this up, with less wrapping...\n        // Use in-memory input stream for max speed, images are small\n        ImageInputStream input = new MemoryCacheImageInputStream(entry.getInputStream());\n        input.skipBytes(12);\n        reader.setInput(input);\n    }\n", "refactored_code": "    private static final int THUMBNAIL_OFFSET = 12;\n        // TODO: It might be possible to speed this up, with less wrapping...\n        // Use in-memory input stream for max speed, images are small\n        ImageInputStream input = new MemoryCacheImageInputStream(entry.getInputStream());\n        input.skipBytes(THUMBNAIL_OFFSET);\n        reader.setInput(input);\n    }\n"}
{"magic_number_smell": "                    }\n\n                    // Read lengths as short array\n                    short[] lengths = new short[16];\n                    for (int i = 0; i < 16; i++) {\n                        lengths[i] = (short) data.readUnsignedByte();\n                    }", "refactored_code": "    private static final int DHT_LENGTH = 16;\n                    }\n\n                    // Read lengths as short array\n                    short[] lengths = new short[DHT_LENGTH];\n                    for (int i = 0; i < DHT_LENGTH; i++) {\n                        lengths[i] = (short) data.readUnsignedByte();\n                    }"}
{"magic_number_smell": "\n    private void init() {\n        tableLength = 258;\n        bitsPerCode = 9;\n        bitMask = bitmaskFor(bitsPerCode);\n        maxCode = maxCode();\n        maxString = 1;", "refactored_code": "    private static final int MIN_BITS = 9;\n\n    private void init() {\n        tableLength = 258;\n        bitsPerCode = MIN_BITS;\n        bitMask = bitmaskFor(bitsPerCode);\n        maxCode = maxCode();\n        maxString = 1;"}
{"magic_number_smell": "\n    // Initial setup\n    private int parent = -1;\n    private int bitsPerCode = 9;\n    private int nextValidCode = EOI_CODE + 1;\n    private int maxCode = maxValue(bitsPerCode);\n", "refactored_code": "    private static final int MIN_BITS = 9;\n\n    // Initial setup\n    private int parent = -1;\n    private int bitsPerCode = MIN_BITS;\n    private int nextValidCode = EOI_CODE + 1;\n    private int maxCode = maxValue(bitsPerCode);\n"}
{"magic_number_smell": "        byte[] bytes = FileUtil.read(getClass().getResourceAsStream(\"/lzw/lzw-long.bin\"));\n\n\n        for (int i = 0; i < 1024; i++) {\n            ByteBuffer buffer = ByteBuffer.allocate(1024);\n            ByteArrayInputStream input = new ByteArrayInputStream(bytes);\n            LZWDecoder decoder = new LZWDecoder.LZWSpecDecoder();", "refactored_code": "    public static final int SPEED_TEST_ITERATIONS = 1024;\n        byte[] bytes = FileUtil.read(getClass().getResourceAsStream(\"/lzw/lzw-long.bin\"));\n\n\n        for (int i = 0; i < SPEED_TEST_ITERATIONS; i++) {\n            ByteBuffer buffer = ByteBuffer.allocate(1024);\n            ByteArrayInputStream input = new ByteArrayInputStream(bytes);\n            LZWDecoder decoder = new LZWDecoder.LZWSpecDecoder();"}
{"magic_number_smell": "    private static final long 0x1e35a7bdL = 0x1e35a7bdL;\n\n    private static int hashPix(final int argb, final int shift) {\n        return (int) (((argb * 0x1e35a7bdL) & 0xffffffffL) >> shift);\n    }\n\n    ColorCache(final int hashBits) {", "refactored_code": "    private static final long K_HASH_MUL = 0x1e35a7bdL;\n    private static final long K_HASH_MUL = 0x1e35a7bdL;\n\n    private static int hashPix(final int argb, final int shift) {\n        return (int) (((argb * K_HASH_MUL) & 0xffffffffL) >> shift);\n    }\n\n    ColorCache(final int hashBits) {"}
{"magic_number_smell": "     * Symbols of the L-code in the order they need to be read\n     */\n    private static final int[] L_CODE_ORDER = {17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n    private final int[] level1 = new int[1 << 8];\n    private final List<int[]> level2 = new ArrayList<>();\n\n    /**", "refactored_code": "    private static final int LEVEL1_BITS = 8;\n     * Symbols of the L-code in the order they need to be read\n     */\n    private static final int[] L_CODE_ORDER = {17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n    private final int[] level1 = new int[1 << LEVEL1_BITS];\n    private final List<int[]> level2 = new ArrayList<>();\n\n    /**"}
{"magic_number_smell": "\n\t\t\ttemp1 = (input[offset + 4] * sinpi8sqrt2) >> 16;\n\t\t\ttemp2 = input[offset + 12]\n\t\t\t\t\t+ ((input[offset + 12] * 20091) >> 16);\n\n\t\t\tc1 = temp1 - temp2;\n", "refactored_code": "\tprivate static final int cospi8sqrt2minus1 = 20091;\n\n\t\t\ttemp1 = (input[offset + 4] * sinpi8sqrt2) >> 16;\n\t\t\ttemp2 = input[offset + 12]\n\t\t\t\t\t+ ((input[offset + 12] * cospi8sqrt2minus1) >> 16);\n\n\t\t\tc1 = temp1 - temp2;\n"}
{"magic_number_smell": "\n//        logger.log(\"refresh_last_frame: \" + refreshLastFrame);\n\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < COEF_BANDS; j++) {\n                for (int k = 0; k < PREV_COEF_CONTEXTS; k++) {\n                    for (int l = 0; l < MAX_ENTROPY_TOKENS - 1; l++) {", "refactored_code": "    private static final int BLOCK_TYPES = 4;\n\n//        logger.log(\"refresh_last_frame: \" + refreshLastFrame);\n\n        for (int i = 0; i < BLOCK_TYPES; i++) {\n            for (int j = 0; j < COEF_BANDS; j++) {\n                for (int k = 0; k < PREV_COEF_CONTEXTS; k++) {\n                    for (int l = 0; l < MAX_ENTROPY_TOKENS - 1; l++) {"}
{"magic_number_smell": "                target.append(input);\n                return target;\n            }\n            j += 2;\n\n            // Check for invalid string with END_TOKEN before BEGIN_TOKEN\n            if (k < j) {", "refactored_code": "    private static final int BEGIN_TOKEN_LEN = 2;\n                target.append(input);\n                return target;\n            }\n            j += BEGIN_TOKEN_LEN;\n\n            // Check for invalid string with END_TOKEN before BEGIN_TOKEN\n            if (k < j) {"}
{"magic_number_smell": "    private int pos = 0;\n    private int startOfValue;\n    private final ArrayList<Object> options = new ArrayList<>();\n    private int state = 0;\n    private final Charset cs;\n\n    private final WidthSupplier width;", "refactored_code": "    private static final int LOOKING_FOR_FIRST_ESC_CHAR = 0;\n    private int pos = 0;\n    private int startOfValue;\n    private final ArrayList<Object> options = new ArrayList<>();\n    private int state = LOOKING_FOR_FIRST_ESC_CHAR;\n    private final Charset cs;\n\n    private final WidthSupplier width;"}
{"magic_number_smell": "    private static final double kappa = 24389.0 / 27.0;\n\n    private static double pivotXyz(double n) {\n        return n > 216.0 / 24389.0 ? Math.cbrt(n) : (kappa * n + 16) / 116;\n    }\n\n    private static double sqr(double n) {", "refactored_code": "    private static final double epsilon = 216.0 / 24389.0;\n    private static final double kappa = 24389.0 / 27.0;\n\n    private static double pivotXyz(double n) {\n        return n > epsilon ? Math.cbrt(n) : (kappa * n + 16) / 116;\n    }\n\n    private static double sqr(double n) {"}
{"magic_number_smell": "    private static final short BACKGROUND_WHITE = (short) (BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE);\n\n    private static final short[] ANSI_FOREGROUND_COLOR_MAP = {\n        0,\n        FOREGROUND_RED,\n        FOREGROUND_GREEN,\n        FOREGROUND_YELLOW,", "refactored_code": "    private static final short FOREGROUND_BLACK = 0;\n    private static final short BACKGROUND_WHITE = (short) (BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE);\n\n    private static final short[] ANSI_FOREGROUND_COLOR_MAP = {\n        FOREGROUND_BLACK,\n        FOREGROUND_RED,\n        FOREGROUND_GREEN,\n        FOREGROUND_YELLOW,"}
{"magic_number_smell": "    private int blockSize;\n\n    public ByteBufferBuilder() {\n        this(8192);\n    }\n\n    public ByteBufferBuilder(int aSize) {", "refactored_code": "    private static final int DEFAULT_BLOCK_SIZE = 8192;\n    private int blockSize;\n\n    public ByteBufferBuilder() {\n        this(DEFAULT_BLOCK_SIZE);\n    }\n\n    public ByteBufferBuilder(int aSize) {"}
{"magic_number_smell": "\n\t@Override\n\tpublic void updateDrawState(TextPaint tp) {\n\t\ttp.setTextSize(tp.getTextSize() * 0.3f);\n\t}\n\n\t@Override", "refactored_code": "\tprivate static final float PROPORTION = 0.3f;\n\n\t@Override\n\tpublic void updateDrawState(TextPaint tp) {\n\t\ttp.setTextSize(tp.getTextSize() * PROPORTION);\n\t}\n\n\t@Override"}
{"magic_number_smell": "\n\tpublic QuoteSpan(int color, DisplayMetrics metrics) {\n\t\tthis.color = color;\n\t\tthis.width = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, 2f, metrics);\n\t\tthis.paddingLeft = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, PADDING_LEFT_SP, metrics);\n\t\tthis.paddingRight = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, PADDING_RIGHT_SP, metrics);\n\t}", "refactored_code": "\tprivate static final float WIDTH_SP = 2f;\n\n\tpublic QuoteSpan(int color, DisplayMetrics metrics) {\n\t\tthis.color = color;\n\t\tthis.width = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, WIDTH_SP, metrics);\n\t\tthis.paddingLeft = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, PADDING_LEFT_SP, metrics);\n\t\tthis.paddingRight = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, PADDING_RIGHT_SP, metrics);\n\t}"}
{"magic_number_smell": "\n\t\t\tbyte[] bytes = null;\n            try {\n                if ((flags & 1) != 0) {\n                    publishProgress(R.string.upload_compress);\n                    bytes = FileHelper.shrinkPicture(ctx, path, fileUploadSizeLimit);\n                }", "refactored_code": "    public static final int F_RESIZE = 1;\n\n\t\t\tbyte[] bytes = null;\n            try {\n                if ((flags & F_RESIZE) != 0) {\n                    publishProgress(R.string.upload_compress);\n                    bytes = FileHelper.shrinkPicture(ctx, path, fileUploadSizeLimit);\n                }"}
{"magic_number_smell": "\t\tswitch (menu_id) {\n\t\tcase R.id.roster_contextmenu_take_image: return REQUEST_CAMERA;\n\t\tcase R.id.roster_contextmenu_send_image: return REQUEST_IMAGE;\n\t\tcase R.id.roster_contextmenu_send_file: return 1;\n\t\tdefault: throw new IllegalStateException(\"Unknown menu ID!\");\n\t\t}\n\t}", "refactored_code": "\tprivate static final int REQUEST_FILE = 1;\n\t\tswitch (menu_id) {\n\t\tcase R.id.roster_contextmenu_take_image: return REQUEST_CAMERA;\n\t\tcase R.id.roster_contextmenu_send_image: return REQUEST_IMAGE;\n\t\tcase R.id.roster_contextmenu_send_file: return REQUEST_FILE;\n\t\tdefault: throw new IllegalStateException(\"Unknown menu ID!\");\n\t\t}\n\t}"}
{"magic_number_smell": "\tprivate static final int ARCHIVE = 3;\n\n\tstatic {\n\t\tURI_MATCHER.addURI(AUTHORITY, \"chats\", 1);\n\t\tURI_MATCHER.addURI(AUTHORITY, \"chats/#\", MESSAGE_ID);\n\t\tURI_MATCHER.addURI(AUTHORITY, \"archive\", ARCHIVE);\n\t}", "refactored_code": "\tprivate static final int MESSAGES = 1;\n\tprivate static final int ARCHIVE = 3;\n\n\tstatic {\n\t\tURI_MATCHER.addURI(AUTHORITY, \"chats\", MESSAGES);\n\t\tURI_MATCHER.addURI(AUTHORITY, \"chats/#\", MESSAGE_ID);\n\t\tURI_MATCHER.addURI(AUTHORITY, \"archive\", ARCHIVE);\n\t}"}
{"magic_number_smell": "\t\n\n\tstatic {\n\t\tURI_MATCHER.addURI(AUTHORITY, \"roster\", 1);\n\t\tURI_MATCHER.addURI(AUTHORITY, \"roster/#\", CONTACT_ID);\n\t\tURI_MATCHER.addURI(AUTHORITY, \"groups\", GROUPS);\n\t\tURI_MATCHER.addURI(AUTHORITY, \"groups/*\", GROUP_MEMBERS);", "refactored_code": "\tprivate static final int CONTACTS = 1;\n\t\n\n\tstatic {\n\t\tURI_MATCHER.addURI(AUTHORITY, \"roster\", CONTACTS);\n\t\tURI_MATCHER.addURI(AUTHORITY, \"roster/#\", CONTACT_ID);\n\t\tURI_MATCHER.addURI(AUTHORITY, \"groups\", GROUPS);\n\t\tURI_MATCHER.addURI(AUTHORITY, \"groups/*\", GROUP_MEMBERS);"}
{"magic_number_smell": "\t\treturn code;\n\t}\n\tpublic String createInvitationCode() {\n\t\treturn createInvitationCode(14*24*3600);\n\t}\n\t\n\tpublic void whitelistInvitationJID(String jid) {", "refactored_code": "\tprivate static final long DEFAULT_INVITATION_TIME = 14*24*3600; // two weeks in seconds\n\t\treturn code;\n\t}\n\tpublic String createInvitationCode() {\n\t\treturn createInvitationCode(DEFAULT_INVITATION_TIME);\n\t}\n\t\n\tpublic void whitelistInvitationJID(String jid) {"}
{"magic_number_smell": "\t\tXMPPConnection c = YaximApplication.getInstance().getSmackable().getConnection();\n\t\ttry {\n\t\t\tswitch (mode) {\n\t\t\t\tcase 0:\n\t\t\t\t\tloadBookmarksOrThrow(c);\n\t\t\t\t\tbreak;\n\t\t\t\tcase MODE_DOMAIN:", "refactored_code": "\tpublic static final int MODE_BOOKMARKS = 0;\n\t\tXMPPConnection c = YaximApplication.getInstance().getSmackable().getConnection();\n\t\ttry {\n\t\t\tswitch (mode) {\n\t\t\t\tcase MODE_BOOKMARKS:\n\t\t\t\t\tloadBookmarksOrThrow(c);\n\t\t\t\t\tbreak;\n\t\t\t\tcase MODE_DOMAIN:"}
{"magic_number_smell": "\t\t\tString messageSummary = msg_string;\n\t\t\tif (newline >= 0)\n\t\t\t\tlimit = newline;\n\t\t\tif (limit > 45 || nd.lastMessage.length() > 45)\n\t\t\t\tlimit = 45;\n\t\t\tif (limit > 0)\n\t\t\t\tmessageSummary = msg_string.substring(0, limit) + \"\u00e2\u20ac\u00a6\";", "refactored_code": "\tprivate static final int MAX_TICKER_MSG_LEN = 45;\n\t\t\tString messageSummary = msg_string;\n\t\t\tif (newline >= 0)\n\t\t\t\tlimit = newline;\n\t\t\tif (limit > MAX_TICKER_MSG_LEN || nd.lastMessage.length() > MAX_TICKER_MSG_LEN)\n\t\t\t\tlimit = MAX_TICKER_MSG_LEN;\n\t\t\tif (limit > 0)\n\t\t\t\tmessageSummary = msg_string.substring(0, limit) + \"\u00e2\u20ac\u00a6\";"}
{"magic_number_smell": "\n\n\tpublic static final int 250 = 250;\n\tprivate CircularArray lastIDs = new CircularArray<Long>(250);\n\tlong lastPong = -1;\n\n\tMUCController(XMPPConnection c, String jid) {", "refactored_code": "\tpublic static final int LOOKUP_SIZE = 250;\n\n\n\tpublic static final int LOOKUP_SIZE = 250;\n\tprivate CircularArray lastIDs = new CircularArray<Long>(LOOKUP_SIZE);\n\tlong lastPong = -1;\n\n\tMUCController(XMPPConnection c, String jid) {"}
{"magic_number_smell": "\tprivate static final int 5 = 5;\n\tprivate static final int RECONNECT_MAXIMUM = 10*60;\n\tprivate static final String RECONNECT_ALARM = \"org.yaxim.androidclient.RECONNECT_ALARM\";\n\tprivate int mReconnectTimeout = 5;\n\tprivate String mReconnectInfo = \"\";\n\tprivate Intent mAlarmIntent = new Intent(RECONNECT_ALARM);\n\tprivate PendingIntent mPAlarmIntent;", "refactored_code": "\tprivate static final int RECONNECT_AFTER = 5;\n\tprivate static final int RECONNECT_AFTER = 5;\n\tprivate static final int RECONNECT_MAXIMUM = 10*60;\n\tprivate static final String RECONNECT_ALARM = \"org.yaxim.androidclient.RECONNECT_ALARM\";\n\tprivate int mReconnectTimeout = RECONNECT_AFTER;\n\tprivate String mReconnectInfo = \"\";\n\tprivate Intent mAlarmIntent = new Intent(RECONNECT_ALARM);\n\tprivate PendingIntent mPAlarmIntent;"}
{"magic_number_smell": "\t\t\tif (!opts.outMimeType.contains(\"jpeg\") || opts.outHeight < 0 || opts.outWidth < 0)\n\t\t\t\treturn null;\n\t\t\tint current_size = (opts.outWidth > opts.outHeight)? opts.outWidth : opts.outHeight;\n\t\t\tint factor = (int)Math.ceil((double)current_size/ 1920);\n\t\t\tis.close();\n\t\t\tint rotation = getExifRotation(ctx, path);\n\t\t\tByteArrayOutputStream baos;", "refactored_code": "\tprivate static final int IMAGE_SIZE = 1920;\n\t\t\tif (!opts.outMimeType.contains(\"jpeg\") || opts.outHeight < 0 || opts.outWidth < 0)\n\t\t\t\treturn null;\n\t\t\tint current_size = (opts.outWidth > opts.outHeight)? opts.outWidth : opts.outHeight;\n\t\t\tint factor = (int)Math.ceil((double)current_size/ IMAGE_SIZE);\n\t\t\tis.close();\n\t\t\tint rotation = getExifRotation(ctx, path);\n\t\t\tByteArrayOutputStream baos;"}
{"magic_number_smell": "\tpublic static String securePassword() {\n\t\tSecureRandom r = new SecureRandom();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0 ; i < 12; i++)\n\t\t\tsb.append(PASSWORD_CHARS.charAt(r.nextInt(PASSWORD_CHARS.length() - 1)));\n\t\treturn sb.toString();\n\t}", "refactored_code": "\tprivate static final int PASSWORD_LENGTH = 12;\n\tpublic static String securePassword() {\n\t\tSecureRandom r = new SecureRandom();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0 ; i < PASSWORD_LENGTH; i++)\n\t\t\tsb.append(PASSWORD_CHARS.charAt(r.nextInt(PASSWORD_CHARS.length() - 1)));\n\t\treturn sb.toString();\n\t}"}
{"magic_number_smell": "\n        String expected = \"\" +\n                \"{\\n\" +\n                \"  \\\"1\\\":1,\\n\" +\n                \"  \\\"a_long\\\":2,\\n\" +\n                \"  \\\"a_string\\\":\\\"3\\\",\\n\" +\n                \"  \\\"a_mappable\\\":{\\n\" +", "refactored_code": "        public final int an_int = 1;\n\n        String expected = \"\" +\n                \"{\\n\" +\n                \"  \\\"an_int\\\":1,\\n\" +\n                \"  \\\"a_long\\\":2,\\n\" +\n                \"  \\\"a_string\\\":\\\"3\\\",\\n\" +\n                \"  \\\"a_mappable\\\":{\\n\" +"}
{"magic_number_smell": "        @Override\n        public int getItemViewType(int position) {\n        \tif (position == 0)\n        \t\treturn 0;\n        \tif (position == mFrequentSeparatorPos) {\n                // We don't want the separator view to be recycled.\n                return IGNORE_ITEM_VIEW_TYPE;", "refactored_code": "    \tpublic static final int OP_ITEM_VIEW_TYPE = 0;\n        @Override\n        public int getItemViewType(int position) {\n        \tif (position == 0)\n        \t\treturn OP_ITEM_VIEW_TYPE;\n        \tif (position == mFrequentSeparatorPos) {\n                // We don't want the separator view to be recycled.\n                return IGNORE_ITEM_VIEW_TYPE;"}
{"magic_number_smell": "\t\t        registry.register(\n\t\t        \t\tnew Scheme(\"https\", getHttpsSocketFactory(), 443));\n\t\t        HttpParams params = getParams();\n\t\t\t\tHttpConnectionParams.setConnectionTimeout(params, 60 * 1000);\n\t\t\t\tHttpConnectionParams.setSoTimeout(params, 60 * 1000);\n\t\t\t\tHttpConnectionParams.setSocketBufferSize(params, 8192);\n\t\t        return new ThreadSafeClientConnManager(params, registry);", "refactored_code": "\tprivate static final int SOCKET_OPERATION_TIMEOUT = 60 * 1000;\n\t\t        registry.register(\n\t\t        \t\tnew Scheme(\"https\", getHttpsSocketFactory(), 443));\n\t\t        HttpParams params = getParams();\n\t\t\t\tHttpConnectionParams.setConnectionTimeout(params, SOCKET_OPERATION_TIMEOUT);\n\t\t\t\tHttpConnectionParams.setSoTimeout(params, SOCKET_OPERATION_TIMEOUT);\n\t\t\t\tHttpConnectionParams.setSocketBufferSize(params, 8192);\n\t\t        return new ThreadSafeClientConnManager(params, registry);"}
{"magic_number_smell": "        \n        @Override\n        public int getViewTypeCount() {\n        \treturn 2;\n        }\n        \n    \tpublic boolean isEmpty() {", "refactored_code": "    \tprivate static final int VIEW_TYPE_COUNT = 2;\n        \n        @Override\n        public int getViewTypeCount() {\n        \treturn VIEW_TYPE_COUNT;\n        }\n        \n    \tpublic boolean isEmpty() {"}
{"magic_number_smell": "    public static final int SOCKET_TIMEOUT = 30500;\n    public static final RequestConfig DEFAULT_REQUEST_CONFIG = RequestConfig\n        .custom()\n        .setConnectTimeout(10000)\n        .setSocketTimeout(SOCKET_TIMEOUT)\n        .build();\n    public static final SocketConfig DEFAULT_SOCKET_CONFIG = SocketConfig", "refactored_code": "    public static final int CONNECTION_TIMEOUT = 10000;\n    public static final int SOCKET_TIMEOUT = 30500;\n    public static final RequestConfig DEFAULT_REQUEST_CONFIG = RequestConfig\n        .custom()\n        .setConnectTimeout(CONNECTION_TIMEOUT)\n        .setSocketTimeout(SOCKET_TIMEOUT)\n        .build();\n    public static final SocketConfig DEFAULT_SOCKET_CONFIG = SocketConfig"}
{"magic_number_smell": "\n    @Test\n    public void fullConstructorShouldPreserveAllValues() {\n        ApiException error = new ApiException(anyMessage, 123, anyMoreInfo, anyHttpStatus, anyCause);\n        assertEquals(\"Message\", anyMessage, error.getMessage());\n        assertSame(\"Cause\", anyCause, error.getCause());\n        assertEquals(\"More info\", anyMoreInfo, error.getMoreInfo());", "refactored_code": "    private final int anyErrorCode = 123;\n\n    @Test\n    public void fullConstructorShouldPreserveAllValues() {\n        ApiException error = new ApiException(anyMessage, anyErrorCode, anyMoreInfo, anyHttpStatus, anyCause);\n        assertEquals(\"Message\", anyMessage, error.getMessage());\n        assertSame(\"Cause\", anyCause, error.getCause());\n        assertEquals(\"More info\", anyMoreInfo, error.getMoreInfo());"}
{"magic_number_smell": "\n        String canonicalRequest = canonicalizeWithPath(path);\n\n        Assert.assertEquals(\"/v1/test\", getLine(1, canonicalRequest));\n    }\n\n    @Test", "refactored_code": "    private static final int PATH_LINE = 1;\n\n        String canonicalRequest = canonicalizeWithPath(path);\n\n        Assert.assertEquals(\"/v1/test\", getLine(PATH_LINE, canonicalRequest));\n    }\n\n    @Test"}
{"magic_number_smell": "    private static final int 2 = 2;\n\n    private Server jettyServer;\n    private int headerBufferMultiplier = 2;\n    private BrowserMobHttpClient httpClient;\n    protected final Set<SslRelay> sslRelays = new HashSet<SslRelay>();\n", "refactored_code": "    private static final int HEADER_BUFFER_DEFAULT = 2;\n    private static final int HEADER_BUFFER_DEFAULT = 2;\n\n    private Server jettyServer;\n    private int headerBufferMultiplier = HEADER_BUFFER_DEFAULT;\n    private BrowserMobHttpClient httpClient;\n    protected final Set<SslRelay> sslRelays = new HashSet<SslRelay>();\n"}
{"magic_number_smell": "\n    public static long copyWithStats(InputStream is, OutputStream os) throws IOException {\n        long bytesCopied = 0;\n        byte[] buffer = new byte[4096];\n        int length;\n\n        try {", "refactored_code": "    private static final int BUFFER = 4096;\n\n    public static long copyWithStats(InputStream is, OutputStream os) throws IOException {\n        long bytesCopied = 0;\n        byte[] buffer = new byte[BUFFER];\n        int length;\n\n        try {"}
{"magic_number_smell": "    \n    /* -------------------------------------------------------------- */\n    private ArrayList _fields=new ArrayList(15);\n    private int[] _index=new int[128];\n    private int _version;\n    private SimpleDateFormat _dateReceive[]; \n    private StringBuffer _dateBuffer;", "refactored_code": "    private static final int __maxCacheSize=128;\n    \n    /* -------------------------------------------------------------- */\n    private ArrayList _fields=new ArrayList(15);\n    private int[] _index=new int[__maxCacheSize];\n    private int _version;\n    private SimpleDateFormat _dateReceive[]; \n    private StringBuffer _dateBuffer;"}
{"magic_number_smell": "    public static final int 8192=8192;\n    public static final int __HDR_SIZE=4;\n    public static final int __DATA_HDR=7;\n    public static final int __MAX_DATA=8192-__DATA_HDR;\n\n    public static final byte __FORWARD_REQUEST=2, __SHUTDOWN=7, __SEND_BODY_CHUNK=3, __SEND_HEADERS=4, __END_RESPONSE=5, __GET_BODY_CHUNK=6;\n", "refactored_code": "    public static final int __MAX_BUF=8192;\n    public static final int __MAX_BUF=8192;\n    public static final int __HDR_SIZE=4;\n    public static final int __DATA_HDR=7;\n    public static final int __MAX_DATA=__MAX_BUF-__DATA_HDR;\n\n    public static final byte __FORWARD_REQUEST=2, __SHUTDOWN=7, __SEND_BODY_CHUNK=3, __SEND_HEADERS=4, __END_RESPONSE=5, __GET_BODY_CHUNK=6;\n"}
{"magic_number_smell": "    {\n        switch(eventID)\n        {\n          case 1:\n          case SERVICE_CONTROL_PAUSE:\n              stopAll();\n              break;", "refactored_code": "    public static final int SERVICE_CONTROL_STOP = 1;\n    {\n        switch(eventID)\n        {\n          case SERVICE_CONTROL_STOP:\n          case SERVICE_CONTROL_PAUSE:\n              stopAll();\n              break;"}
{"magic_number_smell": "    private static final int 9=9;\n    \n    /* ------------------------------------------------------------ */\n    protected int _width=9;\n    protected Node _root=new Node();\n    protected boolean _ignoreCase=false;\n    protected NullEntry _nullEntry=null;", "refactored_code": "    private static final int __HASH_WIDTH=9;\n    private static final int __HASH_WIDTH=9;\n    \n    /* ------------------------------------------------------------ */\n    protected int _width=__HASH_WIDTH;\n    protected Node _root=new Node();\n    protected boolean _ignoreCase=false;\n    protected NullEntry _nullEntry=null;"}
{"magic_number_smell": "                sleepTime = 0;\n            }\n\n            damping = 0.5f;\n        }\n\n        try {", "refactored_code": "    private static final float DAMPING_FACTOR = 0.5f;\n                sleepTime = 0;\n            }\n\n            damping = DAMPING_FACTOR;\n        }\n\n        try {"}
{"magic_number_smell": "    private static final int 4096 = 4096;\n\n    public static void copy(InputStream in, OutputStream out) throws IOException {\n        byte[] buffer = new byte[4096];\n        int length;\n        while ((length = in.read(buffer)) != -1) {\n            out.write(buffer, 0, length);", "refactored_code": "    private static final int BUFFER = 4096;\n    private static final int BUFFER = 4096;\n\n    public static void copy(InputStream in, OutputStream out) throws IOException {\n        byte[] buffer = new byte[BUFFER];\n        int length;\n        while ((length = in.read(buffer)) != -1) {\n            out.write(buffer, 0, length);"}
{"magic_number_smell": "    private static void copyStream(InputStream in, OutputStream out) throws IOException {\n        try {\n\n            byte[] buffer = new byte[8192];\n            int count = 0;\n            do {\n                out.write(buffer, 0, count);", "refactored_code": "    private static final int BUF_SIZE = 8192;\n    private static void copyStream(InputStream in, OutputStream out) throws IOException {\n        try {\n\n            byte[] buffer = new byte[BUF_SIZE];\n            int count = 0;\n            do {\n                out.write(buffer, 0, count);"}
{"magic_number_smell": "            String className = record.getLoggerName();\n            int classNameLength = className.length();\n            int before = sb.length();\n            if (classNameLength > 20) {\n                int index = -1;\n                while (true) {\n                    sb.append(className.charAt(index + 1));", "refactored_code": "    private static final int CLASS_LENGTH = 20;\n            String className = record.getLoggerName();\n            int classNameLength = className.length();\n            int before = sb.length();\n            if (classNameLength > CLASS_LENGTH) {\n                int index = -1;\n                while (true) {\n                    sb.append(className.charAt(index + 1));"}
{"magic_number_smell": "            }\n\n            if (tokens[i].indexOf('.') >= 0) {\n                // An 1 address must be the last component\n                if (i < last)\n                    return null;\n                // There can't have been more than 6 components.", "refactored_code": "    public static final int IPv4 = 1;\n            }\n\n            if (tokens[i].indexOf('.') >= 0) {\n                // An IPv4 address must be the last component\n                if (i < last)\n                    return null;\n                // There can't have been more than 6 components."}
{"magic_number_smell": "\t\ttypes.setMaximum(0xFFFF);\n\t\ttypes.setNumericAllowed(true);\n\n\t\ttypes.add(1, \"1\");\n\t\ttypes.add(SPKI, \"SPKI\");\n\t\ttypes.add(PGP, \"PGP\");\n\t\ttypes.add(1, \"IPKIX\");", "refactored_code": "\tpublic static final int PKIX = 1;\n\t\ttypes.setMaximum(0xFFFF);\n\t\ttypes.setNumericAllowed(true);\n\n\t\ttypes.add(PKIX, \"PKIX\");\n\t\ttypes.add(SPKI, \"SPKI\");\n\t\ttypes.add(PGP, \"PGP\");\n\t\ttypes.add(PKIX, \"IPKIX\");"}
{"magic_number_smell": " */\npublic\nCompression() {\n\ttable = new Entry[17];\n}\n\n/**", "refactored_code": "private static final int TABLE_SIZE = 17;\n */\npublic\nCompression() {\n\ttable = new Entry[TABLE_SIZE];\n}\n\n/**"}
{"magic_number_smell": "private static Mnemonic classes = new DClassMnemonic();\n\nstatic {\n\tclasses.add(1, \"1\");\n\tclasses.add(CH, \"CH\");\n\tclasses.addAlias(CH, \"CHAOS\");\n\tclasses.add(HS, \"HS\");", "refactored_code": "public static final int IN\t\t= 1;\nprivate static Mnemonic classes = new DClassMnemonic();\n\nstatic {\n\tclasses.add(IN, \"IN\");\n\tclasses.add(CH, \"CH\");\n\tclasses.addAlias(CH, \"CHAOS\");\n\tclasses.add(HS, \"HS\");"}
{"magic_number_smell": "\tflags = st.getUInt16();\n\tproto = st.getUInt8();\n\tString algString = st.getString();\n\talg = 3.Algorithm.value(algString);\n\tif (alg < 0)\n\t\tthrow st.exception(\"Invalid algorithm: \" + algString);\n\tkey = st.getBase64();", "refactored_code": "\tpublic static final int DNSSEC = 3;\n\tflags = st.getUInt16();\n\tproto = st.getUInt8();\n\tString algString = st.getString();\n\talg = DNSSEC.Algorithm.value(algString);\n\tif (alg < 0)\n\t\tthrow st.exception(\"Invalid algorithm: \" + algString);\n\tkey = st.getBase64();"}
{"magic_number_smell": "\t\talgs.setMaximum(0xFF);\n\t\talgs.setNumericAllowed(true);\n\n\t\talgs.add(1, \"1\");\n\t\talgs.add(DH, \"DH\");\n\t\talgs.add(DSA, \"DSA\");\n\t\talgs.add(ECC, \"ECC\");", "refactored_code": "\tpublic static final int RSAMD5 = 1;\n\t\talgs.setMaximum(0xFF);\n\t\talgs.setNumericAllowed(true);\n\n\t\talgs.add(RSAMD5, \"RSAMD5\");\n\t\talgs.add(DH, \"DH\");\n\t\talgs.add(DSA, \"DSA\");\n\t\talgs.add(ECC, \"ECC\");"}
{"magic_number_smell": "\textflags.setPrefix(\"FLAG\");\n\textflags.setNumericAllowed(true);\n\n\textflags.add(0x8000, \"do\");\n}\n\nprivate", "refactored_code": "public static final int DO\t\t= 0x8000;\n\textflags.setPrefix(\"FLAG\");\n\textflags.setNumericAllowed(true);\n\n\textflags.add(DO, \"do\");\n}\n\nprivate"}
{"magic_number_smell": "\tif (servers != null) {\n\t\tfor (int i = 0; i < servers.length; i++) {\n\t\t\tResolver r = new SimpleResolver(servers[i]);\n\t\t\tr.setTimeout(5);\n\t\t\tresolvers.add(r);\n\t\t}\n\t}", "refactored_code": "private static final int quantum = 5;\n\tif (servers != null) {\n\t\tfor (int i = 0; i < servers.length; i++) {\n\t\t\tResolver r = new SimpleResolver(servers[i]);\n\t\t\tr.setTimeout(quantum);\n\t\t\tresolvers.add(r);\n\t\t}\n\t}"}
{"magic_number_smell": "\tflags.setPrefix(\"FLAG\");\n\tflags.setNumericAllowed(true);\n\n\tflags.add(0, \"qr\");\n\tflags.add(AA, \"aa\");\n\tflags.add(TC, \"tc\");\n\tflags.add(RD, \"rd\");", "refactored_code": "public static final byte QR\t\t= 0;\n\tflags.setPrefix(\"FLAG\");\n\tflags.setNumericAllowed(true);\n\n\tflags.add(QR, \"qr\");\n\tflags.add(AA, \"aa\");\n\tflags.add(TC, \"tc\");\n\tflags.add(RD, \"rd\");"}
{"magic_number_smell": "                    l.add(it.next());\n            }\n\n            result = 0;\n            answers = (Record[]) l.toArray(new Record[l.size()]);\n            done = true;\n        } else if (response.isNXDOMAIN()) {", "refactored_code": "    public static final int SUCCESSFUL = 0;\n                    l.add(it.next());\n            }\n\n            result = SUCCESSFUL;\n            answers = (Record[]) l.toArray(new Record[l.size()]);\n            done = true;\n        } else if (response.isNXDOMAIN()) {"}
{"magic_number_smell": "\topcodes.setPrefix(\"RESERVED\");\n\topcodes.setNumericAllowed(true);\n\n\topcodes.add(0, \"0\");\n\topcodes.add(IQUERY, \"IQUERY\");\n\topcodes.add(STATUS, \"STATUS\");\n\topcodes.add(NOTIFY, \"NOTIFY\");", "refactored_code": "public static final int QUERY\t\t= 0;\n\topcodes.setPrefix(\"RESERVED\");\n\topcodes.setNumericAllowed(true);\n\n\topcodes.add(QUERY, \"QUERY\");\n\topcodes.add(IQUERY, \"IQUERY\");\n\topcodes.add(STATUS, \"STATUS\");\n\topcodes.add(NOTIFY, \"NOTIFY\");"}
{"magic_number_smell": "\trcodes.setPrefix(\"RESERVED\");\n\trcodes.setNumericAllowed(true);\n\n\trcodes.add(0, \"0\");\n\trcodes.add(FORMERR, \"FORMERR\");\n\trcodes.add(SERVFAIL, \"SERVFAIL\");\n\trcodes.add(NXDOMAIN, \"NXDOMAIN\");", "refactored_code": "public static final int NOERROR\t\t= 0;\n\trcodes.setPrefix(\"RESERVED\");\n\trcodes.setNumericAllowed(true);\n\n\trcodes.add(NOERROR, \"NOERROR\");\n\trcodes.add(FORMERR, \"FORMERR\");\n\trcodes.add(SERVFAIL, \"SERVFAIL\");\n\trcodes.add(NXDOMAIN, \"NXDOMAIN\");"}
{"magic_number_smell": "\tsections.setMaximum(3);\n\tsections.setNumericAllowed(true);\n\n\tsections.add(0, \"qd\");\n\tsections.add(ANSWER, \"an\");\n\tsections.add(AUTHORITY, \"au\");\n\tsections.add(ADDITIONAL, \"ad\");", "refactored_code": "public static final int QUESTION\t= 0;\n\tsections.setMaximum(3);\n\tsections.setNumericAllowed(true);\n\n\tsections.add(QUESTION, \"qd\");\n\tsections.add(ANSWER, \"an\");\n\tsections.add(AUTHORITY, \"au\");\n\tsections.add(ADDITIONAL, \"ad\");"}
{"magic_number_smell": " */\npublic static int\ncompare(long serial1, long serial2) {\n\tif (serial1 < 0 || serial1 > 0xFFFFFFFFL)\n\t\tthrow new IllegalArgumentException(serial1 + \" out of range\");\n\tif (serial2 < 0 || serial2 > 0xFFFFFFFFL)\n\t\tthrow new IllegalArgumentException(serial2 + \" out of range\");", "refactored_code": "private static final long MAX32 = 0xFFFFFFFFL;\n */\npublic static int\ncompare(long serial1, long serial2) {\n\tif (serial1 < 0 || serial1 > MAX32)\n\t\tthrow new IllegalArgumentException(serial1 + \" out of range\");\n\tif (serial2 < 0 || serial2 > MAX32)\n\t\tthrow new IllegalArgumentException(serial2 + \" out of range\");"}
{"magic_number_smell": "\t\taddr = InetAddress.getLocalHost();\n\telse\n\t\taddr = InetAddress.getByName(hostname);\n\taddress = new InetSocketAddress(addr, 53);\n}\n\n/**", "refactored_code": "public static final int DEFAULT_PORT = 53;\n\t\taddr = InetAddress.getLocalHost();\n\telse\n\t\taddr = InetAddress.getByName(hostname);\n\taddress = new InetSocketAddress(addr, DEFAULT_PORT);\n}\n\n/**"}
{"magic_number_smell": "\tpublic String\n\ttoString() {\n\t\tswitch (type) {\n\t\tcase 0:\n\t\t\treturn \"<eof>\";\n\t\tcase EOL:\n\t\t\treturn \"<eol>\";", "refactored_code": "public static final int EOF\t\t= 0;\n\tpublic String\n\ttoString() {\n\t\tswitch (type) {\n\t\tcase EOF:\n\t\t\treturn \"<eof>\";\n\t\tcase EOL:\n\t\t\treturn \"<eol>\";"}
{"magic_number_smell": "\n\tfudge = Options.intValue(\"tsigfudge\");\n\tif (fudge < 0 || fudge > 0x7FFF)\n\t\tfudge = 300;\n\n\tif (old != null) {\n\t\tDNSOutput out = new DNSOutput();", "refactored_code": "public static final short FUDGE\t\t= 300;\n\n\tfudge = Options.intValue(\"tsigfudge\");\n\tif (fudge < 0 || fudge > 0x7FFF)\n\t\tfudge = FUDGE;\n\n\tif (old != null) {\n\t\tDNSOutput out = new DNSOutput();"}
{"magic_number_smell": "\nstatic void\ncheck(long i) {\n\tif (i < 0 || i > 0x7FFFFFFFL)\n\t\tthrow new InvalidTTLException(i);\n}\n", "refactored_code": "public static final long MAX_VALUE = 0x7FFFFFFFL;\n\nstatic void\ncheck(long i) {\n\tif (i < 0 || i > MAX_VALUE)\n\t\tthrow new InvalidTTLException(i);\n}\n"}
{"magic_number_smell": "private static TypeMnemonic types = new TypeMnemonic();\n\nstatic {\n\ttypes.add(1, \"1\", new ARecord());\n\ttypes.add(NS, \"NS\", new NSRecord());\n\ttypes.add(MD, \"MD\", new MDRecord());\n\ttypes.add(MF, \"MF\", new MFRecord());", "refactored_code": "public static final int A\t\t= 1;\nprivate static TypeMnemonic types = new TypeMnemonic();\n\nstatic {\n\ttypes.add(A, \"A\", new ARecord());\n\ttypes.add(NS, \"NS\", new NSRecord());\n\ttypes.add(MD, \"MD\", new MDRecord());\n\ttypes.add(MF, \"MF\", new MFRecord());"}
{"magic_number_smell": "\nprivate static final int 1024 = 1024;\nprivate static final int EPHEMERAL_STOP  = 65535;\nprivate static final int EPHEMERAL_RANGE  = EPHEMERAL_STOP - 1024;\n\nprivate static SecureRandom prng = new SecureRandom();\n", "refactored_code": "private static final int EPHEMERAL_START = 1024;\n\nprivate static final int EPHEMERAL_START = 1024;\nprivate static final int EPHEMERAL_STOP  = 65535;\nprivate static final int EPHEMERAL_RANGE  = EPHEMERAL_STOP - EPHEMERAL_START;\n\nprivate static SecureRandom prng = new SecureRandom();\n"}
{"magic_number_smell": "\tdclass = DClass.IN;\n\tixfr_serial = serial;\n\twant_fallback = fallback;\n\tstate = 0;\n}\n\n/**", "refactored_code": "private static final int INITIALSOA\t= 0;\n\tdclass = DClass.IN;\n\tixfr_serial = serial;\n\twant_fallback = fallback;\n\tstate = INITIALSOA;\n}\n\n/**"}
{"magic_number_smell": "\t\n\tint validity = Options.intValue(\"sig0validity\");\n\tif (validity < 0)\n\t\tvalidity = 300;\n\n\tlong now = System.currentTimeMillis();\n\tDate timeSigned = new Date(now);", "refactored_code": "private static final short VALIDITY = 300;\n\t\n\tint validity = Options.intValue(\"sig0validity\");\n\tif (validity < 0)\n\t\tvalidity = VALIDITY;\n\n\tlong now = System.currentTimeMillis();\n\tDate timeSigned = new Date(now);"}
{"magic_number_smell": "\tipad = new byte[PADLEN];\n\topad = new byte[PADLEN];\n\tfor (i = 0; i < key.length; i++) {\n\t\tipad[i] = (byte) (key[i] ^ 0x36);\n\t\topad[i] = (byte) (key[i] ^ OPAD);\n\t}\n\tfor (; i < PADLEN; i++) {", "refactored_code": "private static final byte IPAD = 0x36;\n\tipad = new byte[PADLEN];\n\topad = new byte[PADLEN];\n\tfor (i = 0; i < key.length; i++) {\n\t\tipad[i] = (byte) (key[i] ^ IPAD);\n\t\topad[i] = (byte) (key[i] ^ OPAD);\n\t}\n\tfor (; i < PADLEN; i++) {"}
{"magic_number_smell": "\tprivate Object _lock = new Object();\n\t\n\t// Timeout to wait for ready in ms\n\tprivate int waitForReadyTimeout = 60000;\n\t\n\tprotected String serviceClassName = \"\";\n\tprotected String serviceName = \"\";", "refactored_code": "\tprivate static final int DEFAULT_WAIT_FOR_READY = 60000;\n\tprivate Object _lock = new Object();\n\t\n\t// Timeout to wait for ready in ms\n\tprivate int waitForReadyTimeout = DEFAULT_WAIT_FOR_READY;\n\t\n\tprotected String serviceClassName = \"\";\n\tprotected String serviceName = \"\";"}
{"magic_number_smell": "        notification.setLatestEventInfo(this, getText(R.string.app_name), text, contentIntent);\n\n        // Send the notification.\n        mNM.notify(2008, notification);\n    }\n\tprotected abstract void onStartService(Intent i);\n\tprotected abstract void runService();", "refactored_code": "\tprotected static final int NOTIFICATION = 2008;\n        notification.setLatestEventInfo(this, getText(R.string.app_name), text, contentIntent);\n\n        // Send the notification.\n        mNM.notify(NOTIFICATION, notification);\n    }\n\tprotected abstract void onStartService(Intent i);\n\tprotected abstract void runService();"}
{"magic_number_smell": "\t * @return\n\t */\n\tpublic static String tagToString(long tagVal) {\n\t\tif ((tagVal >= 5678001) && tagVal < (TAG_MAP_LENGTH + 5678001)) {\n\t\t\treturn _tagToStringMap[(int)tagVal - 5678001];\n\t\t} \n\t\treturn null;", "refactored_code": "\tpublic static final int EXAMPLE_OFFSET = 5678001;\t// This needs to not conflict with any TAG used elsewhere.\n\t * @return\n\t */\n\tpublic static String tagToString(long tagVal) {\n\t\tif ((tagVal >= EXAMPLE_OFFSET) && tagVal < (TAG_MAP_LENGTH + EXAMPLE_OFFSET)) {\n\t\t\treturn _tagToStringMap[(int)tagVal - EXAMPLE_OFFSET];\n\t\t} \n\t\treturn null;"}
{"magic_number_smell": "\n\t/**\n\t * GetLatestVersion attempt timeout.\n\t * TODO  This timeout is set to 1000 to work around the problem\n\t * in ccnd where some interests take >300ms (and sometimes longer, have seen periodic delays >800ms)\n\t * when that bug is found and fixed, this can be reduced back to the SHORT_TIMEOUT.\n\t * long attemptTimeout = SystemConfiguration.SHORT_TIMEOUT;", "refactored_code": "\tpublic static final long MEDIUM_TIMEOUT = 1000;\n\n\t/**\n\t * GetLatestVersion attempt timeout.\n\t * TODO  This timeout is set to MEDIUM_TIMEOUT to work around the problem\n\t * in ccnd where some interests take >300ms (and sometimes longer, have seen periodic delays >800ms)\n\t * when that bug is found and fixed, this can be reduced back to the SHORT_TIMEOUT.\n\t * long attemptTimeout = SystemConfiguration.SHORT_TIMEOUT;"}
{"magic_number_smell": "\t\n\tpublic static String defaultSymmetricKeystoreType() { return DEFAULT_SYMMETRIC_KEYSTORE_TYPE; }\n\t\n\tpublic static int defaultKeyLength() { return 1024; }\n\n\tpublic static Component defaultKeyNamespaceMarker() { return DEFAULT_KEY_NAMESPACE_MARKER; }\n}", "refactored_code": "\tprotected static final int DEFAULT_KEY_LENGTH = 1024;\n\t\n\tpublic static String defaultSymmetricKeystoreType() { return DEFAULT_SYMMETRIC_KEYSTORE_TYPE; }\n\t\n\tpublic static int defaultKeyLength() { return DEFAULT_KEY_LENGTH; }\n\n\tpublic static Component defaultKeyNamespaceMarker() { return DEFAULT_KEY_NAMESPACE_MARKER; }\n}"}
{"magic_number_smell": "\tprotected long _timeout = SystemConfiguration.FC_TIMEOUT;\n\tprotected long _timeoutToUse = SystemConfiguration.FC_TIMEOUT;\n\n\tprotected int _capacity = CCNSegmenter.HOLD_COUNT + 1;\n\n\t// Value used to determine whether the buffer is draining in waitForPutDrain\n\tprotected long _nOut = 0;", "refactored_code": "\tprotected static final int DEFAULT_CAPACITY = CCNSegmenter.HOLD_COUNT + 1;\n\tprotected long _timeout = SystemConfiguration.FC_TIMEOUT;\n\tprotected long _timeoutToUse = SystemConfiguration.FC_TIMEOUT;\n\n\tprotected int _capacity = DEFAULT_CAPACITY;\n\n\t// Value used to determine whether the buffer is draining in waitForPutDrain\n\tprotected long _nOut = 0;"}
{"magic_number_smell": "\t\t\t\tsynchronized (_opencloseLock) {\n\t\t\t\t\t_opencloseLock.wait(_downDelay);\n\t\t\t\t\tif (! _ncConnected) {\n\t\t\t\t\t\tif (_downDelay < 3500)\n\t\t\t\t\t\t\t_downDelay = _downDelay * 2 + 1;\n\t\t\t\t\t\topen();\n\t\t\t\t\t}", "refactored_code": "\tpublic static final int HEARTBEAT_PERIOD = 3500;\n\t\t\t\tsynchronized (_opencloseLock) {\n\t\t\t\t\t_opencloseLock.wait(_downDelay);\n\t\t\t\t\tif (! _ncConnected) {\n\t\t\t\t\t\tif (_downDelay < HEARTBEAT_PERIOD)\n\t\t\t\t\t\t\t_downDelay = _downDelay * 2 + 1;\n\t\t\t\t\t\topen();\n\t\t\t\t\t}"}
{"magic_number_smell": "\tprotected FileOutputStream _tapStreamOut = null;\n\tprotected FileOutputStream _tapStreamIn = null;\n\tprotected long _lastHeartbeat = 0;\n\tprotected int _port = 9695;\n\tprotected String _host = DEFAULT_AGENT_HOST;\n\tprotected NetworkProtocol _protocol = SystemConfiguration.AGENT_PROTOCOL;\n", "refactored_code": "\tpublic static final int DEFAULT_AGENT_PORT = 9695; // ccnx registered port\n\tprotected FileOutputStream _tapStreamOut = null;\n\tprotected FileOutputStream _tapStreamIn = null;\n\tprotected long _lastHeartbeat = 0;\n\tprotected int _port = DEFAULT_AGENT_PORT;\n\tprotected String _host = DEFAULT_AGENT_HOST;\n\tprotected NetworkProtocol _protocol = SystemConfiguration.AGENT_PROTOCOL;\n"}
{"magic_number_smell": "\tprotected int _byteScale = SegmentationProfile.DEFAULT_SCALE;\n\tprotected SegmentNumberType _sequenceType = SegmentNumberType.SEGMENT_FIXED_INCREMENT;\n\n\tprotected ArrayList<ContentObject> _blocks = new ArrayList<ContentObject>(128 + 1);\n\n\tprotected CCNHandle _handle;\n", "refactored_code": "\tpublic static final int HOLD_COUNT = 128;\n\tprotected int _byteScale = SegmentationProfile.DEFAULT_SCALE;\n\tprotected SegmentNumberType _sequenceType = SegmentNumberType.SEGMENT_FIXED_INCREMENT;\n\n\tprotected ArrayList<ContentObject> _blocks = new ArrayList<ContentObject>(HOLD_COUNT + 1);\n\n\tprotected CCNHandle _handle;\n"}
{"magic_number_smell": "public final class BinaryXMLDecoder extends GenericXMLDecoder implements XMLDecoder {\n\n\tpublic final int 512 = 512;\t// Default max we can go back for a resync\n\tprotected int _resyncLimit = 512;\n\tprotected boolean _resyncable = false;\n\n\tpublic BinaryXMLDecoder() {", "refactored_code": "\tpublic final int RESYNC_LIMIT = 512;\t// Default max we can go back for a resync\npublic final class BinaryXMLDecoder extends GenericXMLDecoder implements XMLDecoder {\n\n\tpublic final int RESYNC_LIMIT = 512;\t// Default max we can go back for a resync\n\tprotected int _resyncLimit = RESYNC_LIMIT;\n\tprotected boolean _resyncable = false;\n\n\tpublic BinaryXMLDecoder() {"}
{"magic_number_smell": "\tprotected static final String [] _tagToStringMap = new String[]{\n\t\tnull, null, null, null, null, null, null, null, null, null, null,\n\t\tnull, null,\n\t\t\"13\", \"Name\", \"Component\", \"Certificate\", \"Collection\", \"CompleteName\",\n\t\t\"Content\", \"SignedInfo\", \"ContentDigest\", \"ContentHash\", null, \"Count\", \"Header\",\n\t\t\"Interest\", \"Key\", \"KeyLocator\", \"KeyName\", \"Length\", \"Link\", \"LinkAuthenticator\",\n\t\t\"NameComponentCount\", \"ExtOpt\", null, \"RootDigest\", \"Signature\", \"Start\", \"Timestamp\", \"Type\",", "refactored_code": "\tpublic static final int Any = 13;\n\tprotected static final String [] _tagToStringMap = new String[]{\n\t\tnull, null, null, null, null, null, null, null, null, null, null,\n\t\tnull, null,\n\t\t\"Any\", \"Name\", \"Component\", \"Certificate\", \"Collection\", \"CompleteName\",\n\t\t\"Content\", \"SignedInfo\", \"ContentDigest\", \"ContentHash\", null, \"Count\", \"Header\",\n\t\t\"Interest\", \"Key\", \"KeyLocator\", \"KeyName\", \"Length\", \"Link\", \"LinkAuthenticator\",\n\t\t\"NameComponentCount\", \"ExtOpt\", null, \"RootDigest\", \"Signature\", \"Start\", \"Timestamp\", \"Type\","}
{"magic_number_smell": "\t\t\ttry {\n\t\t\t\tString nanostr = dateParts[1].substring(0, dateParts[1].length()-1); // remove trailing Z\n\t\t\t\tnanostr = \n\t\t\t\t\t(nanostr.length() < 9) ? (nanostr + PAD_STRING.substring(0, (9 - nanostr.length()))) :\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(nanostr);\n\t\t\t\tnanos = Integer.valueOf(nanostr.toString());\n\t\t\t\tts.setNanos(nanos);", "refactored_code": "\tprotected static final int NANO_LENGTH = 9;\n\t\t\ttry {\n\t\t\t\tString nanostr = dateParts[1].substring(0, dateParts[1].length()-1); // remove trailing Z\n\t\t\t\tnanostr = \n\t\t\t\t\t(nanostr.length() < NANO_LENGTH) ? (nanostr + PAD_STRING.substring(0, (NANO_LENGTH - nanostr.length()))) :\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(nanostr);\n\t\t\t\tnanos = Integer.valueOf(nanostr.toString());\n\t\t\t\tts.setNanos(nanos);"}
{"magic_number_smell": "\n\tpublic void add(ContentObject co) {\n\t\t_currentQueueSize++;\n\t\tif (!_throttled && _currentQueueSize > 2000) {\n\t\t\t_throttled = true;\n\t\t\t_server.setThrottle(true);\n\t\t}", "refactored_code": "\tpublic static final int THROTTLE_TOP = 2000;\n\n\tpublic void add(ContentObject co) {\n\t\t_currentQueueSize++;\n\t\tif (!_throttled && _currentQueueSize > THROTTLE_TOP) {\n\t\t\t_throttled = true;\n\t\t\t_server.setThrottle(true);\n\t\t}"}
{"magic_number_smell": "\tpublic byte [] root() { \n\t\tif ((null == _tree) || (_tree.length == 0))\n\t\t\treturn new byte[0];\n\t\treturn get(1);\n\t} \n\t\n\t/**", "refactored_code": "\tprotected static final int ROOT_NODE = 1;\n\tpublic byte [] root() { \n\t\tif ((null == _tree) || (_tree.length == 0))\n\t\t\treturn new byte[0];\n\t\treturn get(ROOT_NODE);\n\t} \n\t\n\t/**"}
{"magic_number_smell": "\t */\n\tpublic static synchronized ContentKeys generateRandomKeys() throws NoSuchAlgorithmException, NoSuchPaddingException {\n\t\tbyte [] key = new byte[DEFAULT_KEY_LENGTH];\n\t\tbyte [] iv = new byte[8];\n\t\t// do we want additional whitening?\n\t\tSecureRandom random = ContentKeys.getRandom();\n\t\trandom.nextBytes(key);", "refactored_code": "\tpublic static final int IV_MASTER_LENGTH = 8; // bytes\n\t */\n\tpublic static synchronized ContentKeys generateRandomKeys() throws NoSuchAlgorithmException, NoSuchPaddingException {\n\t\tbyte [] key = new byte[DEFAULT_KEY_LENGTH];\n\t\tbyte [] iv = new byte[IV_MASTER_LENGTH];\n\t\t// do we want additional whitening?\n\t\tSecureRandom random = ContentKeys.getRandom();\n\t\trandom.nextBytes(key);"}
{"magic_number_smell": "\t\t\to = (DERTaggedObject)e.nextElement();\n\t\t\t\n\t\t\tswitch (o.getTagNo()) {\n\t\t\t\tcase 0:\n\t\t\t\t\tthis._keyIdentifier = ASN1OctetString.getInstance(o);\n\t\t\t\t\tbreak;\n\t\t\t\tcase tag_IssuerName:", "refactored_code": "\tpublic static final int tag_KeyIdentifier \t\t\t= 0;\n\t\t\to = (DERTaggedObject)e.nextElement();\n\t\t\t\n\t\t\tswitch (o.getTagNo()) {\n\t\t\t\tcase tag_KeyIdentifier:\n\t\t\t\t\tthis._keyIdentifier = ASN1OctetString.getInstance(o);\n\t\t\t\t\tbreak;\n\t\t\t\tcase tag_IssuerName:"}
{"magic_number_smell": "\t public static void writePEMCertificate(PrintWriter writer, X509Certificate certificate) throws CertificateEncodingException {\n\t\t writer.println(BEGIN_CERTIFICATE);\n\t\t // TODO print or println?\n\t\t writer.println(DataUtils.base64Encode(certificate.getEncoded(), 40));\n\t\t writer.println(END_CERTIFICATE);\n\t\t writer.println();\n\t }", "refactored_code": "\t public static final int CERTIFICATE_WRAP_LENGTH = 40; // TODO what should this be?\n\t public static void writePEMCertificate(PrintWriter writer, X509Certificate certificate) throws CertificateEncodingException {\n\t\t writer.println(BEGIN_CERTIFICATE);\n\t\t // TODO print or println?\n\t\t writer.println(DataUtils.base64Encode(certificate.getEncoded(), CERTIFICATE_WRAP_LENGTH));\n\t\t writer.println(END_CERTIFICATE);\n\t\t writer.println();\n\t }"}
{"magic_number_smell": "\t\t\t\t\t\t\"ca_compromise\", \"extra_space\", \"affiliation_changed\",\n\t\t\t\t\t\t\"superseded\", \"cessation_of_operation\", \"certificate_hold\",\n\t\t\t\t\t\t\"remove_from_crl\"};\n\tpublic static final int REASON_CODES[] = {0, REASON_KEY_COMPROMISE,\n\t\t\tREASON_CA_COMPROMISE, REASON_AFFILIATION_CHANGED, REASON_SUPERSEDED,\n\t\t\tREASON_CESSATION_OF_OPERATION, REASON_CERTIFICATE_HOLD, REASON_REMOVE_FROM_CRL\n\t\t\t};", "refactored_code": "\tpublic static final int REASON_UNSPECIFIED \t\t= 0;\n\t\t\t\t\t\t\"ca_compromise\", \"extra_space\", \"affiliation_changed\",\n\t\t\t\t\t\t\"superseded\", \"cessation_of_operation\", \"certificate_hold\",\n\t\t\t\t\t\t\"remove_from_crl\"};\n\tpublic static final int REASON_CODES[] = {REASON_UNSPECIFIED, REASON_KEY_COMPROMISE,\n\t\t\tREASON_CA_COMPROMISE, REASON_AFFILIATION_CHANGED, REASON_SUPERSEDED,\n\t\t\tREASON_CESSATION_OF_OPERATION, REASON_CERTIFICATE_HOLD, REASON_REMOVE_FROM_CRL\n\t\t\t};"}
{"magic_number_smell": "\tpublic static Mac _AESKeyMac;\n\tpublic static String _AESKeyAlgorithm = MAC_ALGORITHM;\n\t\n\tprotected static DERInteger _version = new DERInteger(1);\n\t\n\tprotected byte[] _id = null;\n\tprotected KeyStore.Entry _ourEntry = null;", "refactored_code": "\tpublic static final int VERSION = 1;\n\tpublic static Mac _AESKeyMac;\n\tpublic static String _AESKeyAlgorithm = MAC_ALGORITHM;\n\t\n\tprotected static DERInteger _version = new DERInteger(VERSION);\n\t\n\tprotected byte[] _id = null;\n\tprotected KeyStore.Entry _ourEntry = null;"}
{"magic_number_smell": "\n\tprotected static class DaemonListenerClass extends UnicastRemoteObject implements DaemonListener {\n\n\t\tprivate static final long -4969812722104756329L = -9217344397211709762L;\n\t\tprotected WorkerThread _daemonThread;\n\n\t\tpublic DaemonListenerClass(WorkerThread daemonThread) throws RemoteException {", "refactored_code": "\t\tprivate static final long serialVersionUID = -4969812722104756329L;\n\n\tprotected static class DaemonListenerClass extends UnicastRemoteObject implements DaemonListener {\n\n\t\tprivate static final long serialVersionUID = -9217344397211709762L;\n\t\tprotected WorkerThread _daemonThread;\n\n\t\tpublic DaemonListenerClass(WorkerThread daemonThread) throws RemoteException {"}
{"magic_number_smell": "\tprotected static final int 1 = 1;\n\t\n\tpublic DetailedFormatter() {\n\t\t_args[1] = new Date();\n\t}\n\t\n\tprotected Date getDate() { return (Date)_args[1]; }", "refactored_code": "\tprotected static final int DATE_INDEX = 1;\n\tprotected static final int DATE_INDEX = 1;\n\t\n\tpublic DetailedFormatter() {\n\t\t_args[DATE_INDEX] = new Date();\n\t}\n\t\n\tprotected Date getDate() { return (Date)_args[DATE_INDEX]; }"}
{"magic_number_smell": "\t * @return true means would write log\n\t */\n\tpublic static boolean isLoggable(Level level) {\n\t\tif (level.intValue() <\t_fac_value[FAC_DEFAULT]\t || _fac_value[FAC_DEFAULT] == Level.OFF.intValue()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;", "refactored_code": "\tprotected static final int offValue = Level.OFF.intValue();\n\t * @return true means would write log\n\t */\n\tpublic static boolean isLoggable(Level level) {\n\t\tif (level.intValue() <\t_fac_value[FAC_DEFAULT]\t || _fac_value[FAC_DEFAULT] == offValue) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;"}
{"magic_number_smell": "\t\tif (null != startName)\n\t\t\t_doCallbacks = false;\n\t\t_decoder = new BinaryXMLDecoder();\n\t\t_decoder.setInitialBufferSize(756);\n\t}\n\t\n\t/**", "refactored_code": "\tpublic static final int DECODER_SIZE = 756;\n\t\tif (null != startName)\n\t\t\t_doCallbacks = false;\n\t\t_decoder = new BinaryXMLDecoder();\n\t\t_decoder.setInitialBufferSize(DECODER_SIZE);\n\t}\n\t\n\t/**"}
{"magic_number_smell": "\n\t\t\tInterest i = null;\n\n\t\t\twhile (_sentInterests.size() + inOrderSegments.size() + outOfOrderSegments.size() + 0 < SystemConfiguration.PIPELINE_SIZE && !doneAdvancing) {\n\t\t\t\tif (Log.isLoggable(Log.FAC_PIPELINE, Level.INFO))\n\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: _sentInterests.size() = {0} inOrderSegments.size() = {1} outOfOrderSegments.size()  = {2} 0 = {3} total = {4}\", _sentInterests.size(), inOrderSegments.size(), outOfOrderSegments.size(), 0, (_sentInterests.size() + inOrderSegments.size() + outOfOrderSegments.size() + 0) );\n", "refactored_code": "\tprivate final int processingDefer = 0;\n\n\t\t\tInterest i = null;\n\n\t\t\twhile (_sentInterests.size() + inOrderSegments.size() + outOfOrderSegments.size() + processingDefer < SystemConfiguration.PIPELINE_SIZE && !doneAdvancing) {\n\t\t\t\tif (Log.isLoggable(Log.FAC_PIPELINE, Level.INFO))\n\t\t\t\t\tLog.info(Log.FAC_PIPELINE, \"PIPELINE: _sentInterests.size() = {0} inOrderSegments.size() = {1} outOfOrderSegments.size()  = {2} processingDefer = {3} total = {4}\", _sentInterests.size(), inOrderSegments.size(), outOfOrderSegments.size(), processingDefer, (_sentInterests.size() + inOrderSegments.size() + outOfOrderSegments.size() + processingDefer) );\n"}
{"magic_number_smell": "\t\tsuper((SegmentationProfile.isSegment(baseName) ? SegmentationProfile.segmentRoot(baseName) : baseName),\n\t\t\t  locator, publisher, type, keys, segmenter);\n\n\t\t_buffers = new byte[128][];\n\t\t// Always make the first one; it simplifies error handling later and only is superfluous if we\n\t\t// attempt to write an empty stream, which is rare.\n\t\t_buffers[0] = new byte[_segmenter.getBlockSize()];", "refactored_code": "\tpublic static final int BLOCK_BUF_COUNT = 128;\t// Must be at least 2\n\t\tsuper((SegmentationProfile.isSegment(baseName) ? SegmentationProfile.segmentRoot(baseName) : baseName),\n\t\t\t  locator, publisher, type, keys, segmenter);\n\n\t\t_buffers = new byte[BLOCK_BUF_COUNT][];\n\t\t// Always make the first one; it simplifies error handling later and only is superfluous if we\n\t\t// attempt to write an empty stream, which is rare.\n\t\t_buffers[0] = new byte[_segmenter.getBlockSize()];"}
{"magic_number_smell": "\t\tKeyGenerator kg;\n\t\ttry {\n\t\t\tkg = KeyGenerator.getInstance(NONCE_KEY_ALGORITHM);\n\t\t\tkg.init(128);\n\n\t\t\tKey nk = kg.generateKey();\n\t\t\treturn nk;", "refactored_code": "\tprotected static final int NONCE_KEY_LENGTH = 128;\n\t\tKeyGenerator kg;\n\t\ttry {\n\t\t\tkg = KeyGenerator.getInstance(NONCE_KEY_ALGORITHM);\n\t\t\tkg.init(NONCE_KEY_LENGTH);\n\n\t\t\tKey nk = kg.generateKey();\n\t\t\treturn nk;"}
{"magic_number_smell": "\t * Control whether fragments start at 0 or 1.\n\t * @return\n\t */\n\tpublic static final long baseSegment() { return 0; }\n\n\tpublic static boolean isUnsegmented(ContentName name) {\n\t\treturn isNotSegmentMarker(name.lastComponent());", "refactored_code": "\tpublic static final long BASE_SEGMENT = 0;\n\t * Control whether fragments start at 0 or 1.\n\t * @return\n\t */\n\tpublic static final long baseSegment() { return BASE_SEGMENT; }\n\n\tpublic static boolean isUnsegmented(ContentName name) {\n\t\treturn isNotSegmentMarker(name.lastComponent());"}
{"magic_number_smell": "\tpublic static final int CCN_FORW_TAP = 64;\t\t\t// Causes the entry to be used right away - intended\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// for debugging and monitoring purposes.\n\tpublic static final int CCN_FORW_CAPTURE_OK = 128;\t// Use this with CCN_FORW_CHILD_INHERIT to make it eligible for capture.\n\tpublic static final int CCN_FORW_PUBMASK = \t1 |\n            \t\t\t\t\t\t\t\t\tCCN_FORW_CHILD_INHERIT |\n            \t\t\t\t\t\t\t\t\tCCN_FORW_ADVERTISE     |\n            \t\t\t\t\t\t\t\t\tCCN_FORW_LAST          |", "refactored_code": "\tpublic static final int CCN_FORW_ACTIVE = 1;\n\tpublic static final int CCN_FORW_TAP = 64;\t\t\t// Causes the entry to be used right away - intended\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// for debugging and monitoring purposes.\n\tpublic static final int CCN_FORW_CAPTURE_OK = 128;\t// Use this with CCN_FORW_CHILD_INHERIT to make it eligible for capture.\n\tpublic static final int CCN_FORW_PUBMASK = \tCCN_FORW_ACTIVE |\n            \t\t\t\t\t\t\t\t\tCCN_FORW_CHILD_INHERIT |\n            \t\t\t\t\t\t\t\t\tCCN_FORW_ADVERTISE     |\n            \t\t\t\t\t\t\t\t\tCCN_FORW_LAST          |"}
{"magic_number_smell": "\t\t\t}\n\t\t}\n\n\t\tif (!ServiceDiscoveryProfile.LOCALHOST_SCOPE.isMarker(nameWithServicePrefix.component(0))) {\n\t\t\tif (Log.isLoggable(Log.FAC_KEYS, Level.FINER)) {\n\t\t\t\tLog.finer(Log.FAC_KEYS, \"Cannot get local service name, {0} does not begin with local service prefix {1}.\",\n\t\t\t\t\t\tnameWithServicePrefix, ServiceDiscoveryProfile.LOCALHOST_SCOPE);", "refactored_code": "\tpublic static final int SCOPE_COMPONENT = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (!ServiceDiscoveryProfile.LOCALHOST_SCOPE.isMarker(nameWithServicePrefix.component(SCOPE_COMPONENT))) {\n\t\t\tif (Log.isLoggable(Log.FAC_KEYS, Level.FINER)) {\n\t\t\t\tLog.finer(Log.FAC_KEYS, \"Cannot get local service name, {0} does not begin with local service prefix {1}.\",\n\t\t\t\t\t\tnameWithServicePrefix, ServiceDiscoveryProfile.LOCALHOST_SCOPE);"}
{"magic_number_smell": "\n\tpublic static class SuffixName extends ContentName {\n\t\t\n\t\tprivate static final long 5093471560639087706L = 3252505381608872546L;\n\n\t\tpublic SuffixName(ContentName other) {\n\t\t\tsuper(other);", "refactored_code": "\t\tprivate static final long serialVersionUID = 5093471560639087706L;\n\n\tpublic static class SuffixName extends ContentName {\n\t\t\n\t\tprivate static final long serialVersionUID = 3252505381608872546L;\n\n\t\tpublic SuffixName(ContentName other) {\n\t\t\tsuper(other);"}
{"magic_number_smell": "\t **/\n\tpublic Key generateDataKey(ContentName dataNodeName) {\n\t\t// Generate new random data key of appropriate length\n\t\tbyte [] dataKeyBytes = new byte[16];\n\t\t_random.nextBytes(dataKeyBytes);\n\t\tKey dataKey = new SecretKeySpec(dataKeyBytes, DEFAULT_DATA_KEY_ALGORITHM);\n\t\treturn dataKey;", "refactored_code": "\tpublic static final int DEFAULT_DATA_KEY_LENGTH = 16;\n\t **/\n\tpublic Key generateDataKey(ContentName dataNodeName) {\n\t\t// Generate new random data key of appropriate length\n\t\tbyte [] dataKeyBytes = new byte[DEFAULT_DATA_KEY_LENGTH];\n\t\t_random.nextBytes(dataKeyBytes);\n\t\tKey dataKey = new SecretKeySpec(dataKeyBytes, DEFAULT_DATA_KEY_ALGORITHM);\n\t\treturn dataKey;"}
{"magic_number_smell": "\t\t\n\t\tContentName cn = GroupAccessControlProfile.groupPointerToParentGroupName(groupName());\n\t\tEnumeratedNameList parentList = new EnumeratedNameList(cn, _handle);\n\t\tparentList.waitForChildren(3000);\n\t\tif (parentList.hasChildren()) {\n\t\t\tSortedSet<ContentName> parents = parentList.getChildren();\n\t\t\tfor (ContentName parentLinkName : parents) {", "refactored_code": "\tprivate static final long PARENT_GROUP_ENUMERATION_TIMEOUT = 3000;\n\t\t\n\t\tContentName cn = GroupAccessControlProfile.groupPointerToParentGroupName(groupName());\n\t\tEnumeratedNameList parentList = new EnumeratedNameList(cn, _handle);\n\t\tparentList.waitForChildren(PARENT_GROUP_ENUMERATION_TIMEOUT);\n\t\tif (parentList.hasChildren()) {\n\t\t\tSortedSet<ContentName> parents = parentList.getChildren();\n\t\t\tfor (ContentName parentLinkName : parents) {"}
{"magic_number_smell": "\t */\n\tpublic static Interest next(ContentName name,Exclude exclude, Integer prefixCount, Integer maxSuffixComponents, Integer minSuffixComponents,\n\t\t\t\t\tPublisherPublicKeyDigest publisher) {\n\t\treturn nextOrLast(name, exclude, new Integer(0), prefixCount, maxSuffixComponents, minSuffixComponents, publisher);\n\t}\n\t\n\t/**", "refactored_code": "\tpublic static final int CHILD_SELECTOR_LEFT = 0;\n\t */\n\tpublic static Interest next(ContentName name,Exclude exclude, Integer prefixCount, Integer maxSuffixComponents, Integer minSuffixComponents,\n\t\t\t\t\tPublisherPublicKeyDigest publisher) {\n\t\treturn nextOrLast(name, exclude, new Integer(CHILD_SELECTOR_LEFT), prefixCount, maxSuffixComponents, minSuffixComponents, publisher);\n\t}\n\t\n\t/**"}
{"magic_number_smell": "\t\t\t\n\t\t\t// Dump the file in small packets\n\t        InputStream is = new FileInputStream(theFile);\n\t        byte[] bytes = new byte[432];\n\t        int i = 0;\n\t        CCNWriter writer = new CCNWriter(name, handle);\n\t        writer.disableFlowControl();", "refactored_code": "\tpublic static final int CHUNK_SIZE = 432;\n\t\t\t\n\t\t\t// Dump the file in small packets\n\t        InputStream is = new FileInputStream(theFile);\n\t        byte[] bytes = new byte[CHUNK_SIZE];\n\t        int i = 0;\n\t        CCNWriter writer = new CCNWriter(name, handle);\n\t        writer.disableFlowControl();"}
{"magic_number_smell": "\t\ttree_popup = new JPopupMenu();\n\t\ttree_popupaction = new AbstractAction() {\n\n\t\t\tprivate static final long 1L = 9114007083621952181L;\n\n\t\t\tpublic void actionPerformed(ActionEvent e){\n\t\t\t\tTreePath p = (TreePath)(tree_popupaction.getValue(\"PATH\"));", "refactored_code": "\tprivate static final long serialVersionUID = 1L;\n\t\ttree_popup = new JPopupMenu();\n\t\ttree_popupaction = new AbstractAction() {\n\n\t\t\tprivate static final long serialVersionUID = 9114007083621952181L;\n\n\t\t\tpublic void actionPerformed(ActionEvent e){\n\t\t\t\tTreePath p = (TreePath)(tree_popupaction.getValue(\"PATH\"));"}
{"magic_number_smell": "\t\t}\n\n\t\tpublic void runBenchmark(String desc, T input, U parameter) throws Exception {\n\t\t\trunBenchmark(1000, desc, input, parameter);\n\t\t}\n\n\t\tpublic void runBenchmark(int count, String desc, T input, U parameter) throws Exception {", "refactored_code": "\tpublic static final int NUM_ITER = 1000;\n\t\t}\n\n\t\tpublic void runBenchmark(String desc, T input, U parameter) throws Exception {\n\t\t\trunBenchmark(NUM_ITER, desc, input, parameter);\n\t\t}\n\n\t\tpublic void runBenchmark(int count, String desc, T input, U parameter) throws Exception {"}
{"magic_number_smell": "\t\t\tThread.sleep(20);\n\t\t\tDate start = new Date();\n\t\t\tgetter.start();\n\t\t\tputter.join(200000);\n\t\t\tgetter.join(200000);\n\t\t\tboolean good = true;\n\t\t\texit = true;", "refactored_code": "\tpublic static final int WAIT_DELAY = 200000;\n\t\t\tThread.sleep(20);\n\t\t\tDate start = new Date();\n\t\t\tgetter.start();\n\t\t\tputter.join(WAIT_DELAY);\n\t\t\tgetter.join(WAIT_DELAY);\n\t\t\tboolean good = true;\n\t\t\texit = true;"}
{"magic_number_smell": "public final class SecurityBaseNoCcnd {\n\tpublic static final int 5 = 5;\n\tpublic static final int DATA_COUNT_PER_KEY = 3;\n\tpublic static final KeyPair [] pairs = new KeyPair[5];\n\tstatic ContentName testprefix = new ContentName(\"test\",\"pubidtest\");\n\tstatic ContentName keyprefix = new ContentName(testprefix,\"keys\");\n", "refactored_code": "\tpublic static final int KEY_COUNT = 5;\npublic final class SecurityBaseNoCcnd {\n\tpublic static final int KEY_COUNT = 5;\n\tpublic static final int DATA_COUNT_PER_KEY = 3;\n\tpublic static final KeyPair [] pairs = new KeyPair[KEY_COUNT];\n\tstatic ContentName testprefix = new ContentName(\"test\",\"pubidtest\");\n\tstatic ContentName keyprefix = new ContentName(testprefix,\"keys\");\n"}
{"magic_number_smell": "\t\t\tif (ok)\n\t\t\t\tbreak;\n\t\t\ttry {\n\t\t\t\tThread.sleep(100);\n\t\t\t} catch (InterruptedException e) {}\n\t\t} while((System.currentTimeMillis() - startTime) < SystemConfiguration.EXTRA_LONG_TIMEOUT);\n\t\tif (!ok)", "refactored_code": "\tpublic static final int WAIT_TIME = 100;\n\t\t\tif (ok)\n\t\t\t\tbreak;\n\t\t\ttry {\n\t\t\t\tThread.sleep(WAIT_TIME);\n\t\t\t} catch (InterruptedException e) {}\n\t\t} while((System.currentTimeMillis() - startTime) < SystemConfiguration.EXTRA_LONG_TIMEOUT);\n\t\tif (!ok)"}
{"magic_number_smell": "\t\tBogusFilterListener bfl = new BogusFilterListener();\n\t\tTestListener tl = new TestListener();\n\t\tputHandle.registerFilter(testPrefix, bfl);\n\t\tputHandle.checkError(SystemConfiguration.MEDIUM_TIMEOUT);\n\t\tInterest interest = new Interest(testPrefix);\n\t\tsynchronized (bfl) {\n\t\t\tgetHandle.expressInterest(interest, tl);", "refactored_code": "\tprotected static final long TEST_TIMEOUT = SystemConfiguration.MEDIUM_TIMEOUT;\n\t\tBogusFilterListener bfl = new BogusFilterListener();\n\t\tTestListener tl = new TestListener();\n\t\tputHandle.registerFilter(testPrefix, bfl);\n\t\tputHandle.checkError(TEST_TIMEOUT);\n\t\tInterest interest = new Interest(testPrefix);\n\t\tsynchronized (bfl) {\n\t\t\tgetHandle.expressInterest(interest, tl);"}
{"magic_number_smell": "\t\tAssert.assertFalse(gotInterest);\n\t\tgetHandle.cancelInterest(interest1, tl);\n\t\tgetHandle.expressInterest(interest2, tl);\n\t\tAssert.assertTrue(\"Couldn't get semaphore\", filterSema.tryAcquire(8000, TimeUnit.MILLISECONDS));\n\t\tgetHandle.checkError(TEST_TIMEOUT);\n\t\tAssert.assertTrue(gotInterest);\n\t\tgetHandle.cancelInterest(interest2, tl);", "refactored_code": "\tprotected static final int WAIT_MILLIS = 8000;\n\t\tAssert.assertFalse(gotInterest);\n\t\tgetHandle.cancelInterest(interest1, tl);\n\t\tgetHandle.expressInterest(interest2, tl);\n\t\tAssert.assertTrue(\"Couldn't get semaphore\", filterSema.tryAcquire(WAIT_MILLIS, TimeUnit.MILLISECONDS));\n\t\tgetHandle.checkError(TEST_TIMEOUT);\n\t\tAssert.assertTrue(gotInterest);\n\t\tgetHandle.cancelInterest(interest2, tl);"}
{"magic_number_smell": "\tpublic static void setUpBeforeClass() throws Exception {\n\t\tmyHandle = CCNHandle.open();\n\t\t// Generate users to a repository\n\t\ttestUsers = new CreateUserData(testHelper.getClassChildName(USER_NAMESPACE), 3, true, PASSWORD);\n\t\tuserNames = testUsers.friendlyNames().toArray(new String[3]);\n\t\tuserHandles = new CCNHandle[3];\n\t\tfor (int i=0; i < 3; ++i) {", "refactored_code": "\tpublic static final int NUM_USERS = 3; // plus the user running the test. should coordinate with other\n\tpublic static void setUpBeforeClass() throws Exception {\n\t\tmyHandle = CCNHandle.open();\n\t\t// Generate users to a repository\n\t\ttestUsers = new CreateUserData(testHelper.getClassChildName(USER_NAMESPACE), NUM_USERS, true, PASSWORD);\n\t\tuserNames = testUsers.friendlyNames().toArray(new String[NUM_USERS]);\n\t\tuserHandles = new CCNHandle[NUM_USERS];\n\t\tfor (int i=0; i < NUM_USERS; ++i) {"}
{"magic_number_smell": "\t\tLog.info(Log.FAC_TEST, \"Streaming data to file \" + outputStream.getBaseName() + \n\t\t\t\t\t\" using stream class: \" + outputStream.getClass().getName());\n\t\tlong elapsed = 0;\n\t\tbyte [] buf = new byte[1024];\n\t\tMessageDigest digest = MessageDigest.getInstance(\"SHA-1\");\n\t\twhile (elapsed < FILE_SIZE) {\n\t\t\trandom.nextBytes(buf);", "refactored_code": "\tpublic static final int BUF_SIZE = 1024;\n\t\tLog.info(Log.FAC_TEST, \"Streaming data to file \" + outputStream.getBaseName() + \n\t\t\t\t\t\" using stream class: \" + outputStream.getClass().getName());\n\t\tlong elapsed = 0;\n\t\tbyte [] buf = new byte[BUF_SIZE];\n\t\tMessageDigest digest = MessageDigest.getInstance(\"SHA-1\");\n\t\twhile (elapsed < FILE_SIZE) {\n\t\t\trandom.nextBytes(buf);"}
{"magic_number_smell": "\t\tServiceDiscoveryProfile.publishLocalServiceKey(PUBLISHED_SERVICE, null, server1Handle.keyManager());\n\t\t\n\t\tArrayList<ContentObject> results = ServiceDiscoveryProfile.getLocalServiceKeys(PUBLISHED_SERVICE, \n\t\t\t\tSystemConfiguration.MEDIUM_TIMEOUT, readerHandle);\n\t\t\n\t\tprintResults(results);\n\t\tAssert.assertEquals(1, results.size());", "refactored_code": "\tpublic static final long TEST_TIMEOUT = SystemConfiguration.MEDIUM_TIMEOUT;\n\t\tServiceDiscoveryProfile.publishLocalServiceKey(PUBLISHED_SERVICE, null, server1Handle.keyManager());\n\t\t\n\t\tArrayList<ContentObject> results = ServiceDiscoveryProfile.getLocalServiceKeys(PUBLISHED_SERVICE, \n\t\t\t\tTEST_TIMEOUT, readerHandle);\n\t\t\n\t\tprintResults(results);\n\t\tAssert.assertEquals(1, results.size());"}
{"magic_number_smell": "\t\t\n\t\tputHandle.registerFilter(baseName, new DummyFilterListener());\n\n\t\tfor (int i = 0; i < 1000; i++) {\n\t\t\tRepositoryOutputStream ros = new RepositoryOutputStream(\n\t\t\t\t\tnew ContentName(baseName, fileNameBase + i), putHandle);\n\t\t\tros.write(\"NE test\".getBytes(), 0, \"NE test\".getBytes().length);", "refactored_code": "\tpublic static final int NFILES = 1000;\n\t\t\n\t\tputHandle.registerFilter(baseName, new DummyFilterListener());\n\n\t\tfor (int i = 0; i < NFILES; i++) {\n\t\t\tRepositoryOutputStream ros = new RepositoryOutputStream(\n\t\t\t\t\tnew ContentName(baseName, fileNameBase + i), putHandle);\n\t\t\tros.write(\"NE test\".getBytes(), 0, \"NE test\".getBytes().length);"}
{"magic_number_smell": "\npublic class SyncTestCommon {\n\tpublic static final int 1024 = 1024;\n\tpublic static int maxBytes = 10 * 1024;\n\n\tpublic static int writeFile(ContentName name, boolean random, int size, CCNHandle handle) throws Exception {\n\t\tint segmentsToWrite = 0;", "refactored_code": "\tpublic static final int BUF_SIZE = 1024;\n\npublic class SyncTestCommon {\n\tpublic static final int BUF_SIZE = 1024;\n\tpublic static int maxBytes = 10 * BUF_SIZE;\n\n\tpublic static int writeFile(ContentName name, boolean random, int size, CCNHandle handle) throws Exception {\n\t\tint segmentsToWrite = 0;"}
{"magic_number_smell": "public class RepoInitializationTest extends RepoTestBase {\n\tpublic static final int 15000 = 15000; // ms - 30 seconds\n\tpublic static final int TEST_INTERVAL = 3000;\n\tpublic int countDown = 15000;\n\t\n\t@Test\n\tpublic void testRepoIsUp() throws Throwable {", "refactored_code": "\tpublic static final int TEST_TIME = 15000; // ms - 30 seconds\npublic class RepoInitializationTest extends RepoTestBase {\n\tpublic static final int TEST_TIME = 15000; // ms - 30 seconds\n\tpublic static final int TEST_INTERVAL = 3000;\n\tpublic int countDown = TEST_TIME;\n\t\n\t@Test\n\tpublic void testRepoIsUp() throws Throwable {"}
{"magic_number_smell": "\t\tfor(;;) {\n\t\t\tInterest i = Interest.constructInterest(name, e, Interest.CHILD_SELECTOR_LEFT, null, null, null);\n\t\t\tLog.info(\"searching for {0} content {1}, exclude {2}\", name, str, e);\n\t\t\tContentObject co = getHandle.get(i, 5000);\n\t\t\tAssert.assertTrue(null != co);\n\t\t\tLog.info(\"got result {0} digest={1}\", co, DataUtils.printHexBytes(co.digest()));\n\t\t\tif (DataUtils.arrayEquals(co.content(), content))", "refactored_code": "\tpublic static final long TIMEOUT = 5000;\n\t\tfor(;;) {\n\t\t\tInterest i = Interest.constructInterest(name, e, Interest.CHILD_SELECTOR_LEFT, null, null, null);\n\t\t\tLog.info(\"searching for {0} content {1}, exclude {2}\", name, str, e);\n\t\t\tContentObject co = getHandle.get(i, TIMEOUT);\n\t\t\tAssert.assertTrue(null != co);\n\t\t\tLog.info(\"got result {0} digest={1}\", co, DataUtils.printHexBytes(co.digest()));\n\t\t\tif (DataUtils.arrayEquals(co.content(), content))"}
{"magic_number_smell": "\t\tLog.info(Log.FAC_TEST, \"Starting testReadFromRepo\");\n\n\t\tContentName name = new ContentName(_testPrefix, _testStream);\n\t\t_cacheManager.clearCache(name, getHandle, 10000);\n\t\tThread.sleep(5000);\n\t\tCCNInputStream input = new CCNInputStream(name, getHandle);\n\t\tbyte[] testBytes = new byte[data.length];", "refactored_code": "\tprotected static final int CACHE_CLEAR_TIMEOUT = 10000;\n\t\tLog.info(Log.FAC_TEST, \"Starting testReadFromRepo\");\n\n\t\tContentName name = new ContentName(_testPrefix, _testStream);\n\t\t_cacheManager.clearCache(name, getHandle, CACHE_CLEAR_TIMEOUT);\n\t\tThread.sleep(5000);\n\t\tCCNInputStream input = new CCNInputStream(name, getHandle);\n\t\tbyte[] testBytes = new byte[data.length];"}
{"magic_number_smell": "            return null;\n        long str = NativeHelper.toNativeString(var, true);\n        long buf = Native.malloc(4096);\n        long res = NativeHelper.call(Native.loadLibrary(\"kernel32.dll\"), \"ExpandEnvironmentStringsW\", str, buf, 4096);\n        String rs = null;\n        if (res > 0 && res <= 4096) {\n            rs = NativeHelper.getString(buf, 4096, true);", "refactored_code": "    private static final long library = Native.loadLibrary(\"kernel32.dll\");\n            return null;\n        long str = NativeHelper.toNativeString(var, true);\n        long buf = Native.malloc(4096);\n        long res = NativeHelper.call(library, \"ExpandEnvironmentStringsW\", str, buf, 4096);\n        String rs = null;\n        if (res > 0 && res <= 4096) {\n            rs = NativeHelper.getString(buf, 4096, true);"}
{"magic_number_smell": "    }\n\n    public static long getPointer(long ptr) {\n        ByteBuffer bb = Native.fromPointer(ptr, Native.IS_64 ? 8 : 4).order(ByteOrder.LITTLE_ENDIAN);\n        return Native.IS_64 ? bb.getLong() : bb.getInt();\n    }\n", "refactored_code": "    public static final int PTR_SIZE = Native.IS_64 ? 8 : 4;\n    }\n\n    public static long getPointer(long ptr) {\n        ByteBuffer bb = Native.fromPointer(ptr, PTR_SIZE).order(ByteOrder.LITTLE_ENDIAN);\n        return Native.IS_64 ? bb.getLong() : bb.getInt();\n    }\n"}
{"magic_number_smell": "        long hszService = createStringHandle(idInst, service, CP_WINUNICODE);\n        long hszTopic = createStringHandle(idInst, topic, CP_WINUNICODE);\n        long ptr = context == null ? 0 : context.toNative();\n        long res = NativeHelper.call(User32.library, \"DdeConnect\", idInst, hszService, hszTopic, ptr);\n        freeStringHandle(idInst, hszService);\n        freeStringHandle(idInst, hszTopic);\n        if (ptr != 0)", "refactored_code": "    public static final long library = User32.library;\n        long hszService = createStringHandle(idInst, service, CP_WINUNICODE);\n        long hszTopic = createStringHandle(idInst, topic, CP_WINUNICODE);\n        long ptr = context == null ? 0 : context.toNative();\n        long res = NativeHelper.call(library, \"DdeConnect\", idInst, hszService, hszTopic, ptr);\n        freeStringHandle(idInst, hszService);\n        freeStringHandle(idInst, hszTopic);\n        if (ptr != 0)"}
{"magic_number_smell": "            return null;\n        long str = NativeHelper.toNativeString(var, true);\n        long buf = Native.malloc(4096);\n        long res = NativeHelper.call(Native.loadLibrary(\"kernel32.dll\"), \"ExpandEnvironmentStringsW\", str, buf, 4096);\n        String rs = null;\n        if (res > 0 && res <= 4096) {\n            rs = NativeHelper.getString(buf, 4096, true);", "refactored_code": "    private static final long library = Native.loadLibrary(\"kernel32.dll\");\n            return null;\n        long str = NativeHelper.toNativeString(var, true);\n        long buf = Native.malloc(4096);\n        long res = NativeHelper.call(library, \"ExpandEnvironmentStringsW\", str, buf, 4096);\n        String rs = null;\n        if (res > 0 && res <= 4096) {\n            rs = NativeHelper.getString(buf, 4096, true);"}
{"magic_number_smell": "    public static final long Native.loadLibrary(\"gdi32\") = Native.loadLibrary(\"gdi32\");\n\n    public static long getStockObject(int fnObject) {\n        return NativeHelper.call(Native.loadLibrary(\"gdi32\"), \"GetStockObject\", fnObject);\n    }\n}\n", "refactored_code": "    public static final long library = Native.loadLibrary(\"gdi32\");\n    public static final long library = Native.loadLibrary(\"gdi32\");\n\n    public static long getStockObject(int fnObject) {\n        return NativeHelper.call(library, \"GetStockObject\", fnObject);\n    }\n}\n"}
{"magic_number_smell": "            return null;\n        long pdwSize = Native.malloc(4);\n        NativeHelper.setInt(pdwSize, 0);\n        long res = NativeHelper.call(Native.loadLibrary(\"iphlpapi\"), \"GetExtendedTcpTable\", 0, pdwSize, order ? 1 : 0, ulAf, tableClass, 0);\n        if (res == WinError.ERROR_INSUFFICIENT_BUFFER) {\n            int size = NativeHelper.getInt(pdwSize);\n            long pTcpTable = Native.malloc(size);", "refactored_code": "    public static final long library = Native.loadLibrary(\"iphlpapi\");\n            return null;\n        long pdwSize = Native.malloc(4);\n        NativeHelper.setInt(pdwSize, 0);\n        long res = NativeHelper.call(library, \"GetExtendedTcpTable\", 0, pdwSize, order ? 1 : 0, ulAf, tableClass, 0);\n        if (res == WinError.ERROR_INSUFFICIENT_BUFFER) {\n            int size = NativeHelper.getInt(pdwSize);\n            long pTcpTable = Native.malloc(size);"}
{"magic_number_smell": "\n    public static String getModuleFilenameEx(long hProcess, int hModule) {\n        long ptr = Native.malloc(Shell32.MAX_PATHW);\n        NativeHelper.call(Native.loadLibrary(\"psapi\"), \"GetModuleFileNameExW\", hProcess, hModule,\n                ptr, Shell32.MAX_PATHW);\n        String res = NativeHelper.getString(ptr, Shell32.MAX_PATHW, true);\n        Native.free(ptr);", "refactored_code": "    public static final long library = Native.loadLibrary(\"psapi\");\n\n    public static String getModuleFilenameEx(long hProcess, int hModule) {\n        long ptr = Native.malloc(Shell32.MAX_PATHW);\n        NativeHelper.call(library, \"GetModuleFileNameExW\", hProcess, hModule,\n                ptr, Shell32.MAX_PATHW);\n        String res = NativeHelper.getString(ptr, Shell32.MAX_PATHW, true);\n        Native.free(ptr);"}
{"magic_number_smell": "\n    public static File getFolderPath(int type) {\n        long buf = Native.malloc(MAX_PATHW);\n        NativeHelper.call(Native.loadLibrary(\"shell32\"), \"SHGetFolderPathW\", 0, type, 0, 0, buf);\n        String res = NativeHelper.getString(buf, MAX_PATHW, true);\n        Native.free(buf);\n        if (res == null || res.length() == 0)", "refactored_code": "    public static final long library = Native.loadLibrary(\"shell32\");\n\n    public static File getFolderPath(int type) {\n        long buf = Native.malloc(MAX_PATHW);\n        NativeHelper.call(library, \"SHGetFolderPathW\", 0, type, 0, 0, buf);\n        String res = NativeHelper.getString(buf, MAX_PATHW, true);\n        Native.free(buf);\n        if (res == null || res.length() == 0)"}
{"magic_number_smell": "\tpublic static final int TYPE_VAR=4;\n\tpublic static final int TYPE_MODULE=8;\n\t\n\tpublic static final int TYPE_ALL=1 | TYPE_CONSTRUCTOR | TYPE_VAR | TYPE_MODULE;\n\t\n\tpublic static final int SCOPE_DEFINITIONS=1;\n\tpublic static final int SCOPE_REFERENCES=2;", "refactored_code": "\tpublic static final int TYPE_TYPE=1;\n\tpublic static final int TYPE_VAR=4;\n\tpublic static final int TYPE_MODULE=8;\n\t\n\tpublic static final int TYPE_ALL=TYPE_TYPE | TYPE_CONSTRUCTOR | TYPE_VAR | TYPE_MODULE;\n\t\n\tpublic static final int SCOPE_DEFINITIONS=1;\n\tpublic static final int SCOPE_REFERENCES=2;"}
{"magic_number_smell": "          }\n\n        try {\n          Thread.sleep( 1000 );\n        } catch (InterruptedException ie){\n          //noop\n        }", "refactored_code": "  private static final long DELAY=1000;\n          }\n\n        try {\n          Thread.sleep( DELAY );\n        } catch (InterruptedException ie){\n          //noop\n        }"}
{"magic_number_smell": "\t/**\n\t * number of columns to adapt formatting to\n\t */\n\tprivate int columns=80;\n\t\n\t/**\n\t * the extensions needed to parse the file correctly", "refactored_code": "\tpublic static final int DEFAULT_COLUMNS=80;\n\t/**\n\t * number of columns to adapt formatting to\n\t */\n\tprivate int columns=DEFAULT_COLUMNS;\n\t\n\t/**\n\t * the extensions needed to parse the file correctly"}
{"magic_number_smell": "    }\n    // Set the default text width hint and let clients modify accordingly\n    // after the fact\n    setWidthHint( 100 );\n  }\n\n  private void snapToGridLayout( final GridLayout layout ) {", "refactored_code": "  public static final int F_DEFAULT_TEXT_WIDTH_HINT = 100;\n    }\n    // Set the default text width hint and let clients modify accordingly\n    // after the fact\n    setWidthHint( F_DEFAULT_TEXT_WIDTH_HINT );\n  }\n\n  private void snapToGridLayout( final GridLayout layout ) {"}
{"magic_number_smell": "        // so I just keep setting the hover to the best size\n        // if somebody write all documentation in one big line, they'll get a big hover\n        // but so what? Long lines are hard to read in code anyway\n        // contentWidth may exceed 600 if there are wide lines that cannot\n        // be broken.\n\n //      if (contentWidth <= 600) {", "refactored_code": "  //private static final int HOVER_WRAPWIDTH = 600; // bounds for the tooltip with type info and errors/warnings\n        // so I just keep setting the hover to the best size\n        // if somebody write all documentation in one big line, they'll get a big hover\n        // but so what? Long lines are hard to read in code anyway\n        // contentWidth may exceed HOVER_WRAPWIDTH if there are wide lines that cannot\n        // be broken.\n\n //      if (contentWidth <= HOVER_WRAPWIDTH) {"}
{"magic_number_smell": "\n              if (tap.getType()!=null){\n                String t=tap.getType();\n                // if name + type has less than 150 characters, we keep it on one line\n                boolean tshort=tap.getName().length()+t.length()<150;\n                sb.append(html && tshort ? \"<nobr>\" : \"\");\n", "refactored_code": "  private static final int SHORT_LENGTH=150;\n\n              if (tap.getType()!=null){\n                String t=tap.getType();\n                // if name + type has less than SHORT_LENGTH characters, we keep it on one line\n                boolean tshort=tap.getName().length()+t.length()<SHORT_LENGTH;\n                sb.append(html && tshort ? \"<nobr>\" : \"\");\n"}
{"magic_number_smell": "        direction = BACKWARDS;\n      } else if (isOpeningCharacter(start)) {\n        anchor = LEFT;\n        direction = +1;\n      } else {\n        return null;\n      }", "refactored_code": "  private static final int FORWARD = +1;\n        direction = BACKWARDS;\n      } else if (isOpeningCharacter(start)) {\n        anchor = LEFT;\n        direction = FORWARD;\n      } else {\n        return null;\n      }"}
{"magic_number_smell": "\n  @Override\n  public void doOperation( final int operation ) {\n    if (ISourceViewer.INFORMATION+10==operation){\n      ITextSelection selection= (ITextSelection) getSelection();\n      IDocument document= getDocument();\n      try {", "refactored_code": "  public static final int TOGGLE_COMMENT=ISourceViewer.INFORMATION+10;\n\n  @Override\n  public void doOperation( final int operation ) {\n    if (TOGGLE_COMMENT==operation){\n      ITextSelection selection= (ITextSelection) getSelection();\n      IDocument document= getDocument();\n      try {"}
{"magic_number_smell": "\n      if( width <= 0 ) {\n        //table.getColumn( i ).pack();\n        table.getColumn( i ).setWidth( 100 );\n      } else {\n        table.getColumn( i ).setWidth( width );\n      }", "refactored_code": "  private static final int DEFAULT_WIDTH = 100;\n\n      if( width <= 0 ) {\n        //table.getColumn( i ).pack();\n        table.getColumn( i ).setWidth( DEFAULT_WIDTH );\n      } else {\n        table.getColumn( i ).setWidth( width );\n      }"}
{"magic_number_smell": "  public static InputStream readPartially( final InputStream is )\n                                                            throws IOException {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    byte[] data = new byte[ 2048 ];\n    int currentByte = is.read( data, 0, 2048 );\n    while( currentByte != -1 ) {\n      baos.write( data, 0, currentByte );", "refactored_code": "  private static final int BUFFER = 2048;\n  public static InputStream readPartially( final InputStream is )\n                                                            throws IOException {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    byte[] data = new byte[ BUFFER ];\n    int currentByte = is.read( data, 0, BUFFER );\n    while( currentByte != -1 ) {\n      baos.write( data, 0, currentByte );"}
{"magic_number_smell": "    public JSONWriter(Writer w) {\n        this.comma = false;\n        this.mode = 'i';\n        this.stack = new JSONObject[20];\n        this.top = 0;\n        this.writer = w;\n    }", "refactored_code": "    private static final int maxdepth = 20;\n    public JSONWriter(Writer w) {\n        this.comma = false;\n        this.mode = 'i';\n        this.stack = new JSONObject[maxdepth];\n        this.top = 0;\n        this.writer = w;\n    }"}
{"magic_number_smell": "\n\t  @Override\n\t  public void run() {\n\t    byte[] cbuf = new byte[ 2048 ];\n\t    int count;\n\t    try {\n\t      while( ( count = fInput.read( cbuf, 0, 2048 ) ) >= 0 ) {", "refactored_code": "\t  private static final int BUFFER_SIZE = 2048;\n\n\t  @Override\n\t  public void run() {\n\t    byte[] cbuf = new byte[ BUFFER_SIZE ];\n\t    int count;\n\t    try {\n\t      while( ( count = fInput.read( cbuf, 0, BUFFER_SIZE ) ) >= 0 ) {"}
{"magic_number_smell": "\n  @Override\n  public void run() {\n    char[] cbuf = new char[ 2048 ];\n    int count;\n    try {\n      while( ( count = fInput.read( cbuf, 0, 2048 ) ) >= 0 ) {", "refactored_code": "  private static final int BUFFER_SIZE = 2048;\n\n  @Override\n  public void run() {\n    char[] cbuf = new char[ BUFFER_SIZE ];\n    int count;\n    try {\n      while( ( count = fInput.read( cbuf, 0, BUFFER_SIZE ) ) >= 0 ) {"}
{"magic_number_smell": "\t\t\t\t\tparent.setBounds(r.x+newx, r.y+newy, Bubble.this);\n\t\t\t\t} else {\n\t\t\t\t\t//if (getBounds().contains(x, y)){\n\t\t\t\t\t\tif (x>(r.width)-15 && y>(+r.height)-15){\n\t\t\t\t\t\t\tsetCursor(sizeCursor);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsetCursor(moveCursor);", "refactored_code": "\tprivate static final int SIZE_PIXELS=15;\n\t\t\t\t\tparent.setBounds(r.x+newx, r.y+newy, Bubble.this);\n\t\t\t\t} else {\n\t\t\t\t\t//if (getBounds().contains(x, y)){\n\t\t\t\t\t\tif (x>(r.width)-SIZE_PIXELS && y>(+r.height)-SIZE_PIXELS){\n\t\t\t\t\t\t\tsetCursor(sizeCursor);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsetCursor(moveCursor);"}
{"magic_number_smell": "      boolean _frameSet = false;\n\n      int _state = STATE_TEXT;\n      int _tokenType = -0;\n      int _pushBack = 0;\n      int _comment = 0;\n      int _quote = 0;", "refactored_code": "   private static final int TOKEN_NONE = -0;\n      boolean _frameSet = false;\n\n      int _state = STATE_TEXT;\n      int _tokenType = TOKEN_NONE;\n      int _pushBack = 0;\n      int _comment = 0;\n      int _quote = 0;"}
{"magic_number_smell": "            final String classMatch = searchForClosestClass(classMappings);\n\n            if (classMatch == null) {\n                result = 0;\n            }\n            else {\n                result = ((Integer) classMappings.get(classMatch)).intValue();", "refactored_code": "    public static final int UNKNOWN   = 0;\n            final String classMatch = searchForClosestClass(classMappings);\n\n            if (classMatch == null) {\n                result = UNKNOWN;\n            }\n            else {\n                result = ((Integer) classMappings.get(classMatch)).intValue();"}
{"magic_number_smell": "    private int blockSize;\n\n    public FastByteArrayOutputStream() {\n        this(8192);\n    }\n\n    public FastByteArrayOutputStream(int aSize) {", "refactored_code": "    private static final int DEFAULT_BLOCK_SIZE = 8192;\n    private int blockSize;\n\n    public FastByteArrayOutputStream() {\n        this(DEFAULT_BLOCK_SIZE);\n    }\n\n    public FastByteArrayOutputStream(int aSize) {"}
{"magic_number_smell": "\n    public boolean shouldAutoCreateSession() {\n        return false;\n//        return Container.get() == Container.TOMCAT;  - this is removed due to SIM-151.  \n    }\n\n    public boolean shouldLogUnhandledExceptions() {", "refactored_code": "    private final int container = Container.get();\n\n    public boolean shouldAutoCreateSession() {\n        return false;\n//        return container == Container.TOMCAT;  - this is removed due to SIM-151.  \n    }\n\n    public boolean shouldLogUnhandledExceptions() {"}
{"magic_number_smell": "\n        System.out.println(\"Amount of data: \" + page.length);\n        System.gc();\n        runPerformanceTest(\"Normal #1\", page, normal, 1000);\n        System.gc();\n        runPerformanceTest(\"Fast #1\", page, fast, 1000);\n        System.gc();", "refactored_code": "    private static final int PARSE_COUNT = 1000;\n\n        System.out.println(\"Amount of data: \" + page.length);\n        System.gc();\n        runPerformanceTest(\"Normal #1\", page, normal, PARSE_COUNT);\n        System.gc();\n        runPerformanceTest(\"Fast #1\", page, fast, PARSE_COUNT);\n        System.gc();"}
{"magic_number_smell": "\t/**\n\t * Type of deployment.\n\t *\n\t * @see 0\n\t * @see TYPE_EAR\n\t * @see TYPE_UNPACK\n\t */", "refactored_code": "\tpublic static final int TYPE_WAR    = 0;\n\t/**\n\t * Type of deployment.\n\t *\n\t * @see TYPE_WAR\n\t * @see TYPE_EAR\n\t * @see TYPE_UNPACK\n\t */"}
{"magic_number_smell": "    public static long toJavaDate(double value) {\n        Calendar c = new GregorianCalendar();\n        long days = Math.round(Math.floor(value));\n        long millis = Math.round(86400000 * (value - days));\n        c.setLenient(true);\n        c.set(1900, 0, 0, 0, 0, 0);\n        c.set(Calendar.DAY_OF_YEAR, (int) days - 1);", "refactored_code": "    public static final double MS_IN_DAY = 86400000; // 24*60*60*1000\n    public static long toJavaDate(double value) {\n        Calendar c = new GregorianCalendar();\n        long days = Math.round(Math.floor(value));\n        long millis = Math.round(MS_IN_DAY * (value - days));\n        c.setLenient(true);\n        c.set(1900, 0, 0, 0, 0, 0);\n        c.set(Calendar.DAY_OF_YEAR, (int) days - 1);"}
{"magic_number_smell": "    public static final int xlPrompt = 0x1000;\n\n    /* Excel command numbers */\n    public static final int xlcBeep = (0 | 0x8000);\n    public static final int xlcOpen = (1 | 0x8000);\n    public static final int xlcOpenLinks = (2 | 0x8000);\n    public static final int xlcCloseAll = (3 | 0x8000);", "refactored_code": "    public static final int xlCommand = 0x8000;\n    public static final int xlPrompt = 0x1000;\n\n    /* Excel command numbers */\n    public static final int xlcBeep = (0 | xlCommand);\n    public static final int xlcOpen = (1 | xlCommand);\n    public static final int xlcOpenLinks = (2 | xlCommand);\n    public static final int xlcCloseAll = (3 | xlCommand);"}
{"magic_number_smell": "    public static long toJavaDate(double value) {\n        Calendar c = new GregorianCalendar();\n        long days = Math.round(Math.floor(value));\n        long millis = Math.round(86400000 * (value - days));\n        c.setLenient(true);\n        c.set(1900, 0, 0, 0, 0, 0);\n        c.set(Calendar.DAY_OF_YEAR, (int) days - 1);", "refactored_code": "    public static final double MS_IN_DAY = 86400000; // 24*60*60*1000\n    public static long toJavaDate(double value) {\n        Calendar c = new GregorianCalendar();\n        long days = Math.round(Math.floor(value));\n        long millis = Math.round(MS_IN_DAY * (value - days));\n        c.setLenient(true);\n        c.set(1900, 0, 0, 0, 0, 0);\n        c.set(Calendar.DAY_OF_YEAR, (int) days - 1);"}
{"magic_number_smell": "    public static final String PROP_CONDITION = LineBreakpoint.PROP_CONDITION;\n    private boolean enabled = true;\n    private boolean hidden = false;\n    private int suspend = JPDABreakpoint.SUSPEND_ALL;\n    private String printText;\n    private String url = \"\";       // NOI18N\n", "refactored_code": "    public static final int SUSPEND_ALL = JPDABreakpoint.SUSPEND_ALL;\n    public static final String PROP_CONDITION = LineBreakpoint.PROP_CONDITION;\n    private boolean enabled = true;\n    private boolean hidden = false;\n    private int suspend = SUSPEND_ALL;\n    private String printText;\n    private String url = \"\";       // NOI18N\n"}
{"magic_number_smell": "                    foldList.add(getFoldInfo(start,\n                                             end,\n                                             getFoldType(foldTypeDesc),\n                                             getFoldString(foldText, foldDesc, 50)));\n\n                    start = 0;\n                    end = 0;", "refactored_code": "    private static final int MAX_FOLD_DESC_LEN = 50;\n                    foldList.add(getFoldInfo(start,\n                                             end,\n                                             getFoldType(foldTypeDesc),\n                                             getFoldString(foldText, foldDesc, MAX_FOLD_DESC_LEN)));\n\n                    start = 0;\n                    end = 0;"}
{"magic_number_smell": "                        switch(_layout)\n                        {\n\n                        case 0:\n                            doc.remove(_dotOffset, _carretOffset - _dotOffset );\n                            break;\n                        case UppercaseAfterParen:", "refactored_code": "    private static final int LowercaseAfterParen = 0;\n                        switch(_layout)\n                        {\n\n                        case LowercaseAfterParen:\n                            doc.remove(_dotOffset, _carretOffset - _dotOffset );\n                            break;\n                        case UppercaseAfterParen:"}
{"magic_number_smell": "\n                private int getLayout(String filter, boolean isDotPressed)\n                {\n                //private static final int 0 = 0;\n                //private static final int UppercaseAfterParen = 1;\n                //private static final int LowercaseAfterParenWithDot = 2;\n                //private static final int UppercaseAfterParenWithDot = 3;", "refactored_code": "private static final int LowercaseAfterParen = 0;\n\n                private int getLayout(String filter, boolean isDotPressed)\n                {\n                //private static final int LowercaseAfterParen = 0;\n                //private static final int UppercaseAfterParen = 1;\n                //private static final int LowercaseAfterParenWithDot = 2;\n                //private static final int UppercaseAfterParenWithDot = 3;"}
{"magic_number_smell": "     * @param classVisitor the visitor that must visit this class.\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #SKIP_DEBUG}, {@link #EXPAND_FRAMES},\n     *        {@link #SKIP_FRAMES}, {@link #1}.\n     */\n    public void accept(final ClassVisitor classVisitor, final int flags) {\n        accept(classVisitor, new Attribute[0], flags);", "refactored_code": "    public static final int SKIP_CODE = 1;\n     * @param classVisitor the visitor that must visit this class.\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #SKIP_DEBUG}, {@link #EXPAND_FRAMES},\n     *        {@link #SKIP_FRAMES}, {@link #SKIP_CODE}.\n     */\n    public void accept(final ClassVisitor classVisitor, final int flags) {\n        accept(classVisitor, new Attribute[0], flags);"}
{"magic_number_smell": "     * Constructs a new {@link ClassWriter} object.\n     *\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #1}, {@link #COMPUTE_FRAMES}.\n     */\n    public ClassWriter(final int flags) {\n        index = 1;", "refactored_code": "    public static final int COMPUTE_MAXS = 1;\n     * Constructs a new {@link ClassWriter} object.\n     *\n     * @param flags option flags that can be used to modify the default behavior\n     *        of this class. See {@link #COMPUTE_MAXS}, {@link #COMPUTE_FRAMES}.\n     */\n    public ClassWriter(final int flags) {\n        index = 1;"}
{"magic_number_smell": "        if (outputLocals == null || local >= outputLocals.length) {\n            // this local has never been assigned in this basic block,\n            // so it is still equal to its value in the input frame\n            return 0x2000000 | local;\n        } else {\n            int type = outputLocals[local];\n            if (type == 0) {", "refactored_code": "    private static final int LOCAL = 0x2000000;\n        if (outputLocals == null || local >= outputLocals.length) {\n            // this local has never been assigned in this basic block,\n            // so it is still equal to its value in the input frame\n            return LOCAL | local;\n        } else {\n            int type = outputLocals[local];\n            if (type == 0) {"}
{"magic_number_smell": "    /**\n     * Indicates what must be automatically computed.\n     * \n     * @see #0\n     * @see #MAXS\n     * @see #NOTHING\n     */", "refactored_code": "    private static final int FRAMES = 0;\n    /**\n     * Indicates what must be automatically computed.\n     * \n     * @see #FRAMES\n     * @see #MAXS\n     * @see #NOTHING\n     */"}
{"magic_number_smell": "    /**\n     * The <tt>void</tt> type.\n     */\n    public static final Type VOID_TYPE = new Type(0);\n\n    /**\n     * The <tt>boolean</tt> type.", "refactored_code": "    public static final int VOID = 0;\n    /**\n     * The <tt>void</tt> type.\n     */\n    public static final Type VOID_TYPE = new Type(VOID);\n\n    /**\n     * The <tt>boolean</tt> type."}
{"magic_number_smell": "     * Generates the instruction to do the specified mathematical or logical\n     * operation.\n     * \n     * @param op a mathematical or logical operation. Must be one of Opcodes.IADD, SUB,\n     *        MUL, DIV, REM, NEG, SHL, SHR, USHR, AND, OR, XOR.\n     * @param type the type of the operand(s) for this operation.\n     */", "refactored_code": "    public static final int ADD = Opcodes.IADD;\n     * Generates the instruction to do the specified mathematical or logical\n     * operation.\n     * \n     * @param op a mathematical or logical operation. Must be one of ADD, SUB,\n     *        MUL, DIV, REM, NEG, SHL, SHR, USHR, AND, OR, XOR.\n     * @param type the type of the operand(s) for this operation.\n     */"}
{"magic_number_smell": "                break;\n        }\n        buf.append(\", \");\n        appendAccess(access | 262144);\n        buf.append(\", \");\n        appendConstant(name);\n        buf.append(\", \");", "refactored_code": "    private static final int ACCESS_CLASS = 262144;\n                break;\n        }\n        buf.append(\", \");\n        appendAccess(access | ACCESS_CLASS);\n        buf.append(\", \");\n        appendConstant(name);\n        buf.append(\", \");"}
{"magic_number_smell": "     * Creates a new {@link CheckSignatureAdapter} object.\n     * \n     * @param type the type of signature to be checked. See\n     *        {@link #0}, {@link #METHOD_SIGNATURE} and\n     *        {@link #TYPE_SIGNATURE}.\n     * @param sv the visitor to which this adapter must delegate calls. May be\n     *        <tt>null</tt>.", "refactored_code": "    public static final int CLASS_SIGNATURE = 0;\n     * Creates a new {@link CheckSignatureAdapter} object.\n     * \n     * @param type the type of signature to be checked. See\n     *        {@link #CLASS_SIGNATURE}, {@link #METHOD_SIGNATURE} and\n     *        {@link #TYPE_SIGNATURE}.\n     * @param sv the visitor to which this adapter must delegate calls. May be\n     *        <tt>null</tt>."}
{"magic_number_smell": "     */\n    static final Map OPCODES = new HashMap();\n    static {\n        addOpcode(\"NOP\", NOP, OpcodeGroup.0);\n        addOpcode(\"ACONST_NULL\", ACONST_NULL, OpcodeGroup.0);\n        addOpcode(\"ICONST_M1\", ICONST_M1, OpcodeGroup.0);\n        addOpcode(\"ICONST_0\", ICONST_0, OpcodeGroup.0);", "refactored_code": "        public static final int INSN = 0;\n     */\n    static final Map OPCODES = new HashMap();\n    static {\n        addOpcode(\"NOP\", NOP, OpcodeGroup.INSN);\n        addOpcode(\"ACONST_NULL\", ACONST_NULL, OpcodeGroup.INSN);\n        addOpcode(\"ICONST_M1\", ICONST_M1, OpcodeGroup.INSN);\n        addOpcode(\"ICONST_0\", ICONST_0, OpcodeGroup.INSN);"}
{"magic_number_smell": "\n        ContentHandler outDocHandler = null;\n        switch (outRepresentation) {\n            case 1:\n                outDocHandler = new OutputSlicingHandler(new ASMContentHandlerFactory(zos,\n                        computeMax),\n                        entryElement,", "refactored_code": "    public static final int BYTECODE = 1;\n\n        ContentHandler outDocHandler = null;\n        switch (outRepresentation) {\n            case BYTECODE:\n                outDocHandler = new OutputSlicingHandler(new ASMContentHandlerFactory(zos,\n                        computeMax),\n                        entryElement,"}
{"magic_number_smell": "        final String[] interfaces)\n    {\n        StringBuffer sb = new StringBuffer();\n        appendAccess(access | 262144, sb);\n\n        AttributesImpl att = new AttributesImpl();\n        att.addAttribute(\"\", \"access\", \"access\", \"\", sb.toString());", "refactored_code": "    private static final int ACCESS_CLASS = 262144;\n        final String[] interfaces)\n    {\n        StringBuffer sb = new StringBuffer();\n        appendAccess(access | ACCESS_CLASS, sb);\n\n        AttributesImpl att = new AttributesImpl();\n        att.addAttribute(\"\", \"access\", \"access\", \"\", sb.toString());"}
{"magic_number_smell": "\t\t\tbreak;\n\t\tcase PASTE:\n\t\t\tString body = message.body.trim();\n\t\t\tholder.body.setText(Utils.truncate(body, 200));\n\t\t\tbreak;\n\t\tcase TEXT:\n\t\tcase TRANSIT:", "refactored_code": "\tprivate static final int PASTE_TRUNCATE = 200;\n\t\t\tbreak;\n\t\tcase PASTE:\n\t\t\tString body = message.body.trim();\n\t\t\tholder.body.setText(Utils.truncate(body, PASTE_TRUNCATE));\n\t\t\tbreak;\n\t\tcase TEXT:\n\t\tcase TRANSIT:"}
{"magic_number_smell": "    public boolean onCreateOptionsMenu(Menu menu) { \n\t    boolean result = super.onCreateOptionsMenu(menu);\n\t    \n\t    menu.add(0, 0, 0, R.string.menu_settings).setIcon(android.R.drawable.ic_menu_preferences);\n        menu.add(1, MENU_CLEAR, 1, R.string.menu_logout).setIcon(android.R.drawable.ic_menu_close_clear_cancel);\n        menu.add(2, MENU_FEEDBACK, 3, R.string.menu_feedback).setIcon(R.drawable.ic_menu_send);\n        menu.add(3, MENU_ABOUT, 4, R.string.menu_about).setIcon(android.R.drawable.ic_menu_help);", "refactored_code": "\tprivate static final int MENU_SETTINGS = 0;\n    public boolean onCreateOptionsMenu(Menu menu) { \n\t    boolean result = super.onCreateOptionsMenu(menu);\n\t    \n\t    menu.add(0, MENU_SETTINGS, 0, R.string.menu_settings).setIcon(android.R.drawable.ic_menu_preferences);\n        menu.add(1, MENU_CLEAR, 1, R.string.menu_logout).setIcon(android.R.drawable.ic_menu_close_clear_cancel);\n        menu.add(2, MENU_FEEDBACK, 3, R.string.menu_feedback).setIcon(R.drawable.ic_menu_send);\n        menu.add(3, MENU_ABOUT, 4, R.string.menu_about).setIcon(android.R.drawable.ic_menu_help);"}
{"magic_number_smell": "    public boolean onCreateOptionsMenu(Menu menu) {\n\t    boolean result = super.onCreateOptionsMenu(menu);\n\n\t    menu.add(0, 0, 0, R.string.menu_settings)\n\t    \t.setIcon(android.R.drawable.ic_menu_preferences);\n\t    menu.add(1, MENU_SHORTCUT, 1, R.string.menu_shortcut)\n\t    \t.setIcon(android.R.drawable.ic_menu_add);", "refactored_code": "\tprivate static final int MENU_SETTINGS = 0;\n    public boolean onCreateOptionsMenu(Menu menu) {\n\t    boolean result = super.onCreateOptionsMenu(menu);\n\n\t    menu.add(0, MENU_SETTINGS, 0, R.string.menu_settings)\n\t    \t.setIcon(android.R.drawable.ic_menu_preferences);\n\t    menu.add(1, MENU_SHORTCUT, 1, R.string.menu_shortcut)\n\t    \t.setIcon(android.R.drawable.ic_menu_add);"}
{"magic_number_smell": "\t\n\tpublic void setupControls() {\n\t\tUtils.setTitle(this, R.string.menu_settings);\n\t\tupdateNumberMessagesSummary(Utils.getStringPreference(this, NUMBER_MESSAGES_KEY, 80 + \"\"));\n\t\t\n\t\tfindPreference(NUMBER_MESSAGES_KEY).setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {\n\t\t\t@Override public boolean onPreferenceChange(Preference preference, Object newValue) {", "refactored_code": "\tpublic static final int NUMBER_MESSAGES_DEFAULT = 80;\n\t\n\tpublic void setupControls() {\n\t\tUtils.setTitle(this, R.string.menu_settings);\n\t\tupdateNumberMessagesSummary(Utils.getStringPreference(this, NUMBER_MESSAGES_KEY, NUMBER_MESSAGES_DEFAULT + \"\"));\n\t\t\n\t\tfindPreference(NUMBER_MESSAGES_KEY).setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {\n\t\t\t@Override public boolean onPreferenceChange(Preference preference, Object newValue) {"}
{"magic_number_smell": "\t\n\tpublic void onLogin() {\n\t\tif (room == null)\n\t\t\tstartActivityForResult(new Intent(this, RoomList.class).putExtra(\"for_result\", true), 0);\n\t}\n\t\n\tpublic void onLoadRoom() {", "refactored_code": "\tprivate static final int RESULT_ROOM_ID = 0;\n\t\n\tpublic void onLogin() {\n\t\tif (room == null)\n\t\t\tstartActivityForResult(new Intent(this, RoomList.class).putExtra(\"for_result\", true), RESULT_ROOM_ID);\n\t}\n\t\n\tpublic void onLoadRoom() {"}
